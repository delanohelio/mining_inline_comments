{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI2MDA5ODkx", "number": 11251, "title": "Rewrite opt for combining consecutive byte loads", "bodyText": "Changes were made inside the sequentialStoreSimplification. Despite the name\nof the optimization, the changes are targeted at sequential loads.\nRewrote the optimization that identifies byte loads from conseuctive memory\naddresses and replaces them with a wider load such as an iload or lload. The\nnew version greatly expands the number of tree patterns indentified by the\noptimization. The new wide load optimization works with 2-8 consecutive byte\nloads and in both big and little endian order.\nThe original version of the opt is still available under the env var\nTR_UseOldSeqLoadOpt.\nMoved sequentialStoreSimplificationGroup later in the optimization order so\nthat the trees are more likely to be in the right shape for the optimization.\nMoved sequentialStoreSimplification out of Optimizations.enum to OMR where it\nis used for the tracing option.\nCloses: #11250\nSigned-off-by: jimmyk jimmyk@ca.ibm.com", "createdAt": "2020-11-23T21:33:42Z", "url": "https://github.com/eclipse-openj9/openj9/pull/11251", "merged": true, "mergeCommit": {"oid": "1f9ff7b914477bd52e2c1bcd4e63c4e146b0dc19"}, "closed": true, "closedAt": "2021-05-31T12:28:08Z", "author": {"login": "IBMJimmyk"}, "timelineItems": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdfcI8gABqjQwMjk3NDU4Njg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABeWayOngBqjQ3NDI5MzE5MzM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e1d03fa00f68b39709d7f623a0ffce4906dce4b8", "author": {"user": {"login": "IBMJimmyk", "name": "Jimmy K"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/e1d03fa00f68b39709d7f623a0ffce4906dce4b8", "committedDate": "2020-11-23T21:30:33Z", "message": "Rewrite opt for combining consecutive byte loads\n\nChanges were made inside the sequentialStoreSimplification. Despite the name\nof the optimization, the changes are targeted at sequential loads.\n\nRewrote the optimization that identifies byte loads from conseuctive memory\naddresses and replaces them with a wider load such as an iload or lload. The\nnew version greatly expands the number of tree patterns indentified by the\noptimization. The new wide load optimization works with 2-8 consecutive byte\nloads and in both big and little endian order.\n\nThe original version of the opt is still available under the env var\nTR_UseOldSeqLoadOpt.\n\nMoved sequentialStoreSimplificationGroup later in the optimization order so\nthat the trees are more likely to be in the right shape for the optimization.\n\nMoved sequentialStoreSimplification out of Optimizations.enum to OMR where it\nis used for the tracing option.\n\nCloses: #11250\nSigned-off-by: jimmyk <jimmyk@ca.ibm.com>"}, "afterCommit": {"oid": "9f671e8df35fda1f9bbe965b4342651d8d26adcd", "author": {"user": {"login": "IBMJimmyk", "name": "Jimmy K"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/9f671e8df35fda1f9bbe965b4342651d8d26adcd", "committedDate": "2020-11-23T21:35:42Z", "message": "Rewrite opt for combining consecutive byte loads\n\nChanges were made inside the sequentialStoreSimplification. Despite the name\nof the optimization, the changes are targeted at sequential loads.\n\nRewrote the optimization that identifies byte loads from conseuctive memory\naddresses and replaces them with a wider load such as an iload or lload. The\nnew version greatly expands the number of tree patterns indentified by the\noptimization. The new wide load optimization works with 2-8 consecutive byte\nloads and in both big and little endian order.\n\nThe original version of the opt is still available under the env var\nTR_UseOldSeqLoadOpt.\n\nMoved sequentialStoreSimplificationGroup later in the optimization order so\nthat the trees are more likely to be in the right shape for the optimization.\n\nMoved sequentialStoreSimplification out of Optimizations.enum to OMR where it\nis used for the tracing option.\n\nCloses: #11250\nSigned-off-by: jimmyk <jimmyk@ca.ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9f671e8df35fda1f9bbe965b4342651d8d26adcd", "author": {"user": {"login": "IBMJimmyk", "name": "Jimmy K"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/9f671e8df35fda1f9bbe965b4342651d8d26adcd", "committedDate": "2020-11-23T21:35:42Z", "message": "Rewrite opt for combining consecutive byte loads\n\nChanges were made inside the sequentialStoreSimplification. Despite the name\nof the optimization, the changes are targeted at sequential loads.\n\nRewrote the optimization that identifies byte loads from conseuctive memory\naddresses and replaces them with a wider load such as an iload or lload. The\nnew version greatly expands the number of tree patterns indentified by the\noptimization. The new wide load optimization works with 2-8 consecutive byte\nloads and in both big and little endian order.\n\nThe original version of the opt is still available under the env var\nTR_UseOldSeqLoadOpt.\n\nMoved sequentialStoreSimplificationGroup later in the optimization order so\nthat the trees are more likely to be in the right shape for the optimization.\n\nMoved sequentialStoreSimplification out of Optimizations.enum to OMR where it\nis used for the tracing option.\n\nCloses: #11250\nSigned-off-by: jimmyk <jimmyk@ca.ibm.com>"}, "afterCommit": {"oid": "33ba8dd8987396ac4824237c0e44a340db9f7ec0", "author": {"user": {"login": "IBMJimmyk", "name": "Jimmy K"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/33ba8dd8987396ac4824237c0e44a340db9f7ec0", "committedDate": "2020-11-23T21:38:49Z", "message": "Rewrite opt for combining consecutive byte loads\n\nChanges were made inside the sequentialStoreSimplification. Despite the name\nof the optimization, the changes are targeted at sequential loads.\n\nRewrote the optimization that identifies byte loads from conseuctive memory\naddresses and replaces them with a wider load such as an iload or lload. The\nnew version greatly expands the number of tree patterns indentified by the\noptimization. The new wide load optimization works with 2-8 consecutive byte\nloads and in both big and little endian order.\n\nThe original version of the opt is still available under the env var\nTR_UseOldSeqLoadOpt.\n\nMoved sequentialStoreSimplificationGroup later in the optimization order so\nthat the trees are more likely to be in the right shape for the optimization.\n\nMoved sequentialStoreSimplification out of Optimizations.enum to OMR where it\nis used for the tracing option.\n\nCloses: #11250\nSigned-off-by: jimmyk <jimmyk@ca.ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0NTgxMjI0", "url": "https://github.com/eclipse-openj9/openj9/pull/11251#pullrequestreview-544581224", "createdAt": "2020-12-04T00:56:47Z", "commit": {"oid": "9c17f5745e482b16315475e38333b0117cb5e11a"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQwMDo1Njo0N1rOH-8AAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQwMToxODoxN1rOH-8fHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTc1NjgwMA==", "bodyText": "Analysis and transformation phases are not clearly separated. Would be good at least to describe more clearly what each function does. For example, isValidSeqLoadCombine() walks the tree recursively and proves that the node can be represented as\n(processed byte load)(combine)(processed byte load)(combine)...\nafter associative and commutative rules applied (eg order of ORs and ADDs is not important).\n(processed byte load) is loaded and shifted(multiplied) byte\n(combine) is OR or ADD\nThere is a limit on the number of processed bytes but it can be less than needed to form int or long. In that case, we will expect then to fill in the lower part of resulting int or long.\ngenerateArraycopyFromSequentialLoads() checks\n\nbyte loads are consequitive\nmultiplier matches the load offset\n...", "url": "https://github.com/eclipse-openj9/openj9/pull/11251#discussion_r535756800", "createdAt": "2020-12-04T00:56:47Z", "author": {"login": "gita-omr"}, "path": "runtime/compiler/optimizer/SequentialStoreSimplifier.cpp", "diffHunk": "@@ -677,621 +684,2200 @@ TR::Node* getALoadReferenceForSeqLoad(TR::Node* rootNode, int32_t totalBytes, in\n       }\n    }\n \n-bool TR_ShiftedValueTree::process(TR::Node* loadNode)\n+TR::TreeTop* seqLoadSearchAndCombine(TR::Compilation* comp, bool trace, TR_BitVector* visitedNodes, TR::TreeTop* currentTree, TR::Node* currentNode, NodeForwardList* combineNodeList)\n    {\n-\n-   bool shift = true;\n-   TR::ILOpCodes convCode = loadNode->getOpCodeValue();\n-   TR::ILOpCodes shiftCode, altShiftCode, constCode;\n-   int32_t size;\n-\n-   _isConst = false;\n-   switch(convCode)\n-      {\n-      case TR::s2b: shift = true;  _valueSize = 2; shiftCode = TR::sushr; altShiftCode = TR::sshr; constCode = TR::iconst; break;\n-      case TR::i2b: shift = true;  _valueSize = 4; shiftCode = TR::iushr; altShiftCode = TR::ishr; constCode = TR::iconst; break;\n-      case TR::l2b: shift = true;  _valueSize = 8; shiftCode = TR::lushr; altShiftCode = TR::lshr; constCode = TR::iconst; break;\n-      case TR::bload:\n-      case TR::bconst:\n-      case TR::sconst:\n-      case TR::iconst:\n-      case TR::lconst: shift = false; _valueSize = 1; _shiftValue = 0; break;\n-      default: return false;\n-      }\n-\n-//   dumpOptDetails(comp(), \"arraycopy sequential store - check load node %p\\n\", loadNode);\n-\n-   if (shift)\n+   if (visitedNodes->isSet(currentNode->getGlobalIndex()))\n+      return currentTree;\n+\n+   visitedNodes->set(currentNode->getGlobalIndex());\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c17f5745e482b16315475e38333b0117cb5e11a"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTc1NzI5NQ==", "bodyText": "\"seems good\" sounds concerning. Eg what exactly was checked at this point? If it only \"seems\" good do we need to recheck something?", "url": "https://github.com/eclipse-openj9/openj9/pull/11251#discussion_r535757295", "createdAt": "2020-12-04T00:58:07Z", "author": {"login": "gita-omr"}, "path": "runtime/compiler/optimizer/SequentialStoreSimplifier.cpp", "diffHunk": "@@ -677,621 +684,2200 @@ TR::Node* getALoadReferenceForSeqLoad(TR::Node* rootNode, int32_t totalBytes, in\n       }\n    }\n \n-bool TR_ShiftedValueTree::process(TR::Node* loadNode)\n+TR::TreeTop* seqLoadSearchAndCombine(TR::Compilation* comp, bool trace, TR_BitVector* visitedNodes, TR::TreeTop* currentTree, TR::Node* currentNode, NodeForwardList* combineNodeList)\n    {\n-\n-   bool shift = true;\n-   TR::ILOpCodes convCode = loadNode->getOpCodeValue();\n-   TR::ILOpCodes shiftCode, altShiftCode, constCode;\n-   int32_t size;\n-\n-   _isConst = false;\n-   switch(convCode)\n-      {\n-      case TR::s2b: shift = true;  _valueSize = 2; shiftCode = TR::sushr; altShiftCode = TR::sshr; constCode = TR::iconst; break;\n-      case TR::i2b: shift = true;  _valueSize = 4; shiftCode = TR::iushr; altShiftCode = TR::ishr; constCode = TR::iconst; break;\n-      case TR::l2b: shift = true;  _valueSize = 8; shiftCode = TR::lushr; altShiftCode = TR::lshr; constCode = TR::iconst; break;\n-      case TR::bload:\n-      case TR::bconst:\n-      case TR::sconst:\n-      case TR::iconst:\n-      case TR::lconst: shift = false; _valueSize = 1; _shiftValue = 0; break;\n-      default: return false;\n-      }\n-\n-//   dumpOptDetails(comp(), \"arraycopy sequential store - check load node %p\\n\", loadNode);\n-\n-   if (shift)\n+   if (visitedNodes->isSet(currentNode->getGlobalIndex()))\n+      return currentTree;\n+\n+   visitedNodes->set(currentNode->getGlobalIndex());\n+\n+   /*\n+    * Combine nodes are the \"add\" and \"or\" nodes that construct the longer value out of several loaded bytes.\n+    * combineNodeList keeps tracks of the nodes used to construct one particular value. It is populated by isValidSeqLoadCombine.\n+    * combineNodeList needs to be cleared each time before it is repopulated.\n+    * isValidSeqLoadCombine also performs a series of initial checks to see if the tree structure contains the pattern\n+    * of byte loads that can be combined into wider loads.\n+    * combineNodeCount tracks the number of combine nodes.\n+    */\n+   combineNodeList->clear();\n+   int32_t combineNodeCount = 0;\n+   if (isValidSeqLoadCombine(comp, trace, currentNode, combineNodeList, combineNodeCount))\n       {\n-      if (loadNode->getFirstChild()->getOpCodeValue() != shiftCode && loadNode->getFirstChild()->getOpCodeValue() != altShiftCode)\n-         {\n-         _valNode = loadNode->getFirstChild();\n-         _shiftValue = 0;\n-         }\n-      else\n-         {\n-         TR::Node* shiftVal = loadNode->getFirstChild()->getSecondChild();\n-         if (shiftVal->getOpCodeValue() != constCode)\n-            {\n-            dumpOptDetails(comp(), \" Shifted Value: did not encounter correct const code\\n\");\n-            return false;\n-            }\n-         _valNode = loadNode->getFirstChild()->getFirstChild();\n-         switch(constCode)\n-            {\n-            case TR::sconst: _shiftValue = shiftVal->getShortInt(); break;\n-            case TR::iconst: _shiftValue = shiftVal->getInt(); break;\n-            case TR::lconst: _shiftValue = shiftVal->getLongInt(); break;\n-            default: break;\n-            }\n-         }\n+      /*\n+       * The initial tree structure seems good at this point. generateArraycopyFromSequentialLoads will do some additional", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c17f5745e482b16315475e38333b0117cb5e11a"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTc1NzU3NA==", "bodyText": "Why is AND needed. Could you give an example?", "url": "https://github.com/eclipse-openj9/openj9/pull/11251#discussion_r535757574", "createdAt": "2020-12-04T00:58:56Z", "author": {"login": "gita-omr"}, "path": "runtime/compiler/optimizer/SequentialStoreSimplifier.cpp", "diffHunk": "@@ -677,621 +684,2200 @@ TR::Node* getALoadReferenceForSeqLoad(TR::Node* rootNode, int32_t totalBytes, in\n       }\n    }\n \n-bool TR_ShiftedValueTree::process(TR::Node* loadNode)\n+TR::TreeTop* seqLoadSearchAndCombine(TR::Compilation* comp, bool trace, TR_BitVector* visitedNodes, TR::TreeTop* currentTree, TR::Node* currentNode, NodeForwardList* combineNodeList)\n    {\n-\n-   bool shift = true;\n-   TR::ILOpCodes convCode = loadNode->getOpCodeValue();\n-   TR::ILOpCodes shiftCode, altShiftCode, constCode;\n-   int32_t size;\n-\n-   _isConst = false;\n-   switch(convCode)\n-      {\n-      case TR::s2b: shift = true;  _valueSize = 2; shiftCode = TR::sushr; altShiftCode = TR::sshr; constCode = TR::iconst; break;\n-      case TR::i2b: shift = true;  _valueSize = 4; shiftCode = TR::iushr; altShiftCode = TR::ishr; constCode = TR::iconst; break;\n-      case TR::l2b: shift = true;  _valueSize = 8; shiftCode = TR::lushr; altShiftCode = TR::lshr; constCode = TR::iconst; break;\n-      case TR::bload:\n-      case TR::bconst:\n-      case TR::sconst:\n-      case TR::iconst:\n-      case TR::lconst: shift = false; _valueSize = 1; _shiftValue = 0; break;\n-      default: return false;\n-      }\n-\n-//   dumpOptDetails(comp(), \"arraycopy sequential store - check load node %p\\n\", loadNode);\n-\n-   if (shift)\n+   if (visitedNodes->isSet(currentNode->getGlobalIndex()))\n+      return currentTree;\n+\n+   visitedNodes->set(currentNode->getGlobalIndex());\n+\n+   /*\n+    * Combine nodes are the \"add\" and \"or\" nodes that construct the longer value out of several loaded bytes.\n+    * combineNodeList keeps tracks of the nodes used to construct one particular value. It is populated by isValidSeqLoadCombine.\n+    * combineNodeList needs to be cleared each time before it is repopulated.\n+    * isValidSeqLoadCombine also performs a series of initial checks to see if the tree structure contains the pattern\n+    * of byte loads that can be combined into wider loads.\n+    * combineNodeCount tracks the number of combine nodes.\n+    */\n+   combineNodeList->clear();\n+   int32_t combineNodeCount = 0;\n+   if (isValidSeqLoadCombine(comp, trace, currentNode, combineNodeList, combineNodeCount))\n       {\n-      if (loadNode->getFirstChild()->getOpCodeValue() != shiftCode && loadNode->getFirstChild()->getOpCodeValue() != altShiftCode)\n-         {\n-         _valNode = loadNode->getFirstChild();\n-         _shiftValue = 0;\n-         }\n-      else\n-         {\n-         TR::Node* shiftVal = loadNode->getFirstChild()->getSecondChild();\n-         if (shiftVal->getOpCodeValue() != constCode)\n-            {\n-            dumpOptDetails(comp(), \" Shifted Value: did not encounter correct const code\\n\");\n-            return false;\n-            }\n-         _valNode = loadNode->getFirstChild()->getFirstChild();\n-         switch(constCode)\n-            {\n-            case TR::sconst: _shiftValue = shiftVal->getShortInt(); break;\n-            case TR::iconst: _shiftValue = shiftVal->getInt(); break;\n-            case TR::lconst: _shiftValue = shiftVal->getLongInt(); break;\n-            default: break;\n-            }\n-         }\n+      /*\n+       * The initial tree structure seems good at this point. generateArraycopyFromSequentialLoads will do some additional\n+       * checks. If they also pass, it will combine the byte loads into wider loads.\n+       */\n+      currentTree = generateArraycopyFromSequentialLoads(comp, trace, currentTree, currentNode, combineNodeList);\n       }\n    else\n       {\n-      _valNode = loadNode;\n-      if (convCode != TR::bload)\n+      /* If the checks in isValidSeqLoadCombine fail, try again on the children. */\n+      for (int i = 0; i < currentNode->getNumChildren(); i++)\n          {\n-         _isConst = true;\n+         currentTree = seqLoadSearchAndCombine(comp, trace, visitedNodes, currentTree, currentNode->getChild(i), combineNodeList);\n          }\n       }\n \n-   if ((_shiftValue % 8) != 0 || (_shiftValue < 0) || (_shiftValue >= _valueSize*8))\n-      {\n-      dumpOptDetails(comp(), \"Shifted Value: did not encounter valid shift value %d for var size %d\\n\", _shiftValue, _valueSize);\n-      return false;\n-      }\n-\n-   _rootNode = loadNode;\n-\n-   return true;\n+   return currentTree;\n    }\n \n-bool TR_arraycopySequentialStores::checkAiadd(TR::TreeTop * currentTree, TR::Node* aiaddNode)\n+bool isValidSeqLoadCombine(TR::Compilation* comp, bool trace, TR::Node* combineNode, NodeForwardList* combineNodeList, int32_t &combineNodeCount)\n    {\n-//   dumpOptDetails(comp(), \"arraycopy sequential store - check aiadd node %p\\n\", aiaddNode);\n-   _activeAddrTree = new (trStackMemory()) TR_AddressTree(stackAlloc, comp());\n-   _activeTreeTop = currentTree;\n-   if (_activeAddrTree->process(aiaddNode, _comp->cg()->getSupportsAlignedAccessOnly()))\n+   /* Combine nodes are the \"add\" and \"or\" nodes that construct the longer value out of several loaded bytes. */\n+\n+   /* Check if the candidate combine node is: iadd, ior, ladd, lor */\n+   if ((combineNode->getOpCodeValue() != TR::iadd) && (combineNode->getOpCodeValue() != TR::ior) &&\n+       (combineNode->getOpCodeValue() != TR::ladd) && (combineNode->getOpCodeValue() != TR::lor)\n+      )\n       {\n-      return insertConsistentTree();\n+      return false;\n       }\n-   return false;\n-   }\n \n-void TR_arraycopySequentialStores::insertTree(int entry)\n-   {\n-//   dumpOptDetails(comp(), \" insert nodes %p,%p into entry %d\\n\",\n-//      _activeAddrTree->getRootNode(), _activeValueTree->getRootNode(), entry);\n-   if ((_addrTree[entry] != NULL) && (entry < _maxAddressTrees))\n+   /*\n+    * Only the topmost combine node (the first one to be looked at) can have a reference count greater than 1.\n+    * If not, it means the intermediate values when constructing the larger value are used in other places and still\n+    * needs to be generated.\n+    */\n+   if ((combineNodeCount > 0) && (combineNode->getReferenceCount() != 1))\n       {\n-      memmove(&_addrTree[entry+1], &_addrTree[entry], (_maxAddressTrees-entry-1)*sizeof(TR_AddressTree*));\n-      memmove(&_val[entry+1], &_val[entry],  (_maxAddressTrees-entry-1)*sizeof(TR_ShiftedValueTree*));\n-      memmove(&_treeTops[entry+1], &_treeTops[entry], (_maxAddressTrees-entry-1)*sizeof(TR::TreeTop*));\n+      return false;\n       }\n-   _addrTree[entry] = _activeAddrTree;\n-   _val[entry] = _activeValueTree;\n-   _treeTops[entry] = _activeTreeTop;\n-   }\n \n-bool TR_arraycopySequentialStores::insertConsistentTree()\n-   {\n+   /* The node being looked at is a potential combine node so it gets added to the list. */\n+   combineNodeList->push_front(combineNode);\n+   combineNodeCount++;\n \n-   // these are byte arrays we are working with - the multiplier must be 1\n-   if (_activeAddrTree->getMultiplier() != 1)\n+   /*\n+    * If int width combine nodes are being used, no more than 4 bytes can be combined which means no more than 3 combine nodes.\n+    * If long width combine nodes are being used, no more than 8 bytes can be combined which means no more than 7 combine nodes.\n+    */\n+   if ((combineNodeCount > 3) && ((combineNode->getOpCodeValue() == TR::iadd) || (combineNode->getOpCodeValue() == TR::ior)))\n       {\n-      dumpOptDetails(comp(), \" insertTree: multiplier must be 1 in aiadd tree\\n\");\n       return false;\n       }\n-   TR::SymbolReference* activeBaseRef = _activeAddrTree->getBaseVarNode()->isNull() ? NULL : _activeAddrTree->getBaseVarNode()->getChild()->skipConversions()->getSymbolReference();\n-   if (activeBaseRef == NULL)\n+   else if ((combineNodeCount > 7) && ((combineNode->getOpCodeValue() == TR::ladd) || (combineNode->getOpCodeValue() == TR::lor)))\n       {\n-      dumpOptDetails(comp(), \" insertTree: no base variable in aiadd tree\\n\");\n       return false;\n       }\n \n-   if (_addrTree[0] == NULL)\n-      {\n-//      dumpOptDetails(comp(), \" insertTree: first tree inserted successfully with offset: %d\\n\", _activeAddrTree->getOffset());\n-      insertTree(0);\n-      return true;\n-      }\n+   TR::Node* childrenArray[2];\n+   childrenArray[0] = combineNode->getFirstChild();\n+   childrenArray[1] = combineNode->getSecondChild();\n \n-   // make sure the index variable and base variable is consistent with the first tree\n-   TR::SymbolReference* baseRef = _addrTree[0]->getBaseVarNode()->isNull() ? NULL : _addrTree[0]->getBaseVarNode()->getChild()->skipConversions()->getSymbolReference();\n-   if (baseRef != activeBaseRef)\n+   /*\n+    * Check if the children match the pattern for combining byte loads.\n+    * There is an optional mul/shl layer.\n+    * There is an optional and layer.\n+    * The byte conversion nodes are the ones on the path to the byte loads.\n+    * The child can also be another combine node (add/or).\n+    */\n+   for (int i = 0; i < 2; i++)\n       {\n-      dumpOptDetails(comp(), \" insertTree: base variable is different than previous tree\\n\");\n-      return false;\n-      }\n+      TR::ILOpCodes childOpCode = childrenArray[i]->getOpCodeValue();\n \n-   TR::SymbolReference* indRef = _addrTree[0]->getIndVarNode()->isNull() ? NULL : _addrTree[0]->getIndVarNode()->getChild()->skipConversions()->getSymbolReference();\n-   TR::SymbolReference* activeIndRef = _activeAddrTree->getIndVarNode()->isNull() ? NULL : _activeAddrTree->getIndVarNode()->getChild()->skipConversions()->getSymbolReference();\n+      switch (childOpCode)\n+         {\n+         case TR::imul:\n+         case TR::ishl:\n+         case TR::lmul:\n+         case TR::lshl:\n+            if (!isValidSeqLoadMulOrShl(comp, trace, childrenArray[i]))\n+               return false;\n+            break;\n+         case TR::iand:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c17f5745e482b16315475e38333b0117cb5e11a"}, "originalPosition": 258}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTc2MTcyNA==", "bodyText": "Do we allow byte loads without the basePointerNode? How would we match then nodes that have it and the ones that don't?", "url": "https://github.com/eclipse-openj9/openj9/pull/11251#discussion_r535761724", "createdAt": "2020-12-04T01:10:13Z", "author": {"login": "gita-omr"}, "path": "runtime/compiler/optimizer/SequentialStoreSimplifier.cpp", "diffHunk": "@@ -677,621 +684,2200 @@ TR::Node* getALoadReferenceForSeqLoad(TR::Node* rootNode, int32_t totalBytes, in\n       }\n    }\n \n-bool TR_ShiftedValueTree::process(TR::Node* loadNode)\n+TR::TreeTop* seqLoadSearchAndCombine(TR::Compilation* comp, bool trace, TR_BitVector* visitedNodes, TR::TreeTop* currentTree, TR::Node* currentNode, NodeForwardList* combineNodeList)\n    {\n-\n-   bool shift = true;\n-   TR::ILOpCodes convCode = loadNode->getOpCodeValue();\n-   TR::ILOpCodes shiftCode, altShiftCode, constCode;\n-   int32_t size;\n-\n-   _isConst = false;\n-   switch(convCode)\n-      {\n-      case TR::s2b: shift = true;  _valueSize = 2; shiftCode = TR::sushr; altShiftCode = TR::sshr; constCode = TR::iconst; break;\n-      case TR::i2b: shift = true;  _valueSize = 4; shiftCode = TR::iushr; altShiftCode = TR::ishr; constCode = TR::iconst; break;\n-      case TR::l2b: shift = true;  _valueSize = 8; shiftCode = TR::lushr; altShiftCode = TR::lshr; constCode = TR::iconst; break;\n-      case TR::bload:\n-      case TR::bconst:\n-      case TR::sconst:\n-      case TR::iconst:\n-      case TR::lconst: shift = false; _valueSize = 1; _shiftValue = 0; break;\n-      default: return false;\n-      }\n-\n-//   dumpOptDetails(comp(), \"arraycopy sequential store - check load node %p\\n\", loadNode);\n-\n-   if (shift)\n+   if (visitedNodes->isSet(currentNode->getGlobalIndex()))\n+      return currentTree;\n+\n+   visitedNodes->set(currentNode->getGlobalIndex());\n+\n+   /*\n+    * Combine nodes are the \"add\" and \"or\" nodes that construct the longer value out of several loaded bytes.\n+    * combineNodeList keeps tracks of the nodes used to construct one particular value. It is populated by isValidSeqLoadCombine.\n+    * combineNodeList needs to be cleared each time before it is repopulated.\n+    * isValidSeqLoadCombine also performs a series of initial checks to see if the tree structure contains the pattern\n+    * of byte loads that can be combined into wider loads.\n+    * combineNodeCount tracks the number of combine nodes.\n+    */\n+   combineNodeList->clear();\n+   int32_t combineNodeCount = 0;\n+   if (isValidSeqLoadCombine(comp, trace, currentNode, combineNodeList, combineNodeCount))\n       {\n-      if (loadNode->getFirstChild()->getOpCodeValue() != shiftCode && loadNode->getFirstChild()->getOpCodeValue() != altShiftCode)\n-         {\n-         _valNode = loadNode->getFirstChild();\n-         _shiftValue = 0;\n-         }\n-      else\n-         {\n-         TR::Node* shiftVal = loadNode->getFirstChild()->getSecondChild();\n-         if (shiftVal->getOpCodeValue() != constCode)\n-            {\n-            dumpOptDetails(comp(), \" Shifted Value: did not encounter correct const code\\n\");\n-            return false;\n-            }\n-         _valNode = loadNode->getFirstChild()->getFirstChild();\n-         switch(constCode)\n-            {\n-            case TR::sconst: _shiftValue = shiftVal->getShortInt(); break;\n-            case TR::iconst: _shiftValue = shiftVal->getInt(); break;\n-            case TR::lconst: _shiftValue = shiftVal->getLongInt(); break;\n-            default: break;\n-            }\n-         }\n+      /*\n+       * The initial tree structure seems good at this point. generateArraycopyFromSequentialLoads will do some additional\n+       * checks. If they also pass, it will combine the byte loads into wider loads.\n+       */\n+      currentTree = generateArraycopyFromSequentialLoads(comp, trace, currentTree, currentNode, combineNodeList);\n       }\n    else\n       {\n-      _valNode = loadNode;\n-      if (convCode != TR::bload)\n+      /* If the checks in isValidSeqLoadCombine fail, try again on the children. */\n+      for (int i = 0; i < currentNode->getNumChildren(); i++)\n          {\n-         _isConst = true;\n+         currentTree = seqLoadSearchAndCombine(comp, trace, visitedNodes, currentTree, currentNode->getChild(i), combineNodeList);\n          }\n       }\n \n-   if ((_shiftValue % 8) != 0 || (_shiftValue < 0) || (_shiftValue >= _valueSize*8))\n-      {\n-      dumpOptDetails(comp(), \"Shifted Value: did not encounter valid shift value %d for var size %d\\n\", _shiftValue, _valueSize);\n-      return false;\n-      }\n-\n-   _rootNode = loadNode;\n-\n-   return true;\n+   return currentTree;\n    }\n \n-bool TR_arraycopySequentialStores::checkAiadd(TR::TreeTop * currentTree, TR::Node* aiaddNode)\n+bool isValidSeqLoadCombine(TR::Compilation* comp, bool trace, TR::Node* combineNode, NodeForwardList* combineNodeList, int32_t &combineNodeCount)\n    {\n-//   dumpOptDetails(comp(), \"arraycopy sequential store - check aiadd node %p\\n\", aiaddNode);\n-   _activeAddrTree = new (trStackMemory()) TR_AddressTree(stackAlloc, comp());\n-   _activeTreeTop = currentTree;\n-   if (_activeAddrTree->process(aiaddNode, _comp->cg()->getSupportsAlignedAccessOnly()))\n+   /* Combine nodes are the \"add\" and \"or\" nodes that construct the longer value out of several loaded bytes. */\n+\n+   /* Check if the candidate combine node is: iadd, ior, ladd, lor */\n+   if ((combineNode->getOpCodeValue() != TR::iadd) && (combineNode->getOpCodeValue() != TR::ior) &&\n+       (combineNode->getOpCodeValue() != TR::ladd) && (combineNode->getOpCodeValue() != TR::lor)\n+      )\n       {\n-      return insertConsistentTree();\n+      return false;\n       }\n-   return false;\n-   }\n \n-void TR_arraycopySequentialStores::insertTree(int entry)\n-   {\n-//   dumpOptDetails(comp(), \" insert nodes %p,%p into entry %d\\n\",\n-//      _activeAddrTree->getRootNode(), _activeValueTree->getRootNode(), entry);\n-   if ((_addrTree[entry] != NULL) && (entry < _maxAddressTrees))\n+   /*\n+    * Only the topmost combine node (the first one to be looked at) can have a reference count greater than 1.\n+    * If not, it means the intermediate values when constructing the larger value are used in other places and still\n+    * needs to be generated.\n+    */\n+   if ((combineNodeCount > 0) && (combineNode->getReferenceCount() != 1))\n       {\n-      memmove(&_addrTree[entry+1], &_addrTree[entry], (_maxAddressTrees-entry-1)*sizeof(TR_AddressTree*));\n-      memmove(&_val[entry+1], &_val[entry],  (_maxAddressTrees-entry-1)*sizeof(TR_ShiftedValueTree*));\n-      memmove(&_treeTops[entry+1], &_treeTops[entry], (_maxAddressTrees-entry-1)*sizeof(TR::TreeTop*));\n+      return false;\n       }\n-   _addrTree[entry] = _activeAddrTree;\n-   _val[entry] = _activeValueTree;\n-   _treeTops[entry] = _activeTreeTop;\n-   }\n \n-bool TR_arraycopySequentialStores::insertConsistentTree()\n-   {\n+   /* The node being looked at is a potential combine node so it gets added to the list. */\n+   combineNodeList->push_front(combineNode);\n+   combineNodeCount++;\n \n-   // these are byte arrays we are working with - the multiplier must be 1\n-   if (_activeAddrTree->getMultiplier() != 1)\n+   /*\n+    * If int width combine nodes are being used, no more than 4 bytes can be combined which means no more than 3 combine nodes.\n+    * If long width combine nodes are being used, no more than 8 bytes can be combined which means no more than 7 combine nodes.\n+    */\n+   if ((combineNodeCount > 3) && ((combineNode->getOpCodeValue() == TR::iadd) || (combineNode->getOpCodeValue() == TR::ior)))\n       {\n-      dumpOptDetails(comp(), \" insertTree: multiplier must be 1 in aiadd tree\\n\");\n       return false;\n       }\n-   TR::SymbolReference* activeBaseRef = _activeAddrTree->getBaseVarNode()->isNull() ? NULL : _activeAddrTree->getBaseVarNode()->getChild()->skipConversions()->getSymbolReference();\n-   if (activeBaseRef == NULL)\n+   else if ((combineNodeCount > 7) && ((combineNode->getOpCodeValue() == TR::ladd) || (combineNode->getOpCodeValue() == TR::lor)))\n       {\n-      dumpOptDetails(comp(), \" insertTree: no base variable in aiadd tree\\n\");\n       return false;\n       }\n \n-   if (_addrTree[0] == NULL)\n-      {\n-//      dumpOptDetails(comp(), \" insertTree: first tree inserted successfully with offset: %d\\n\", _activeAddrTree->getOffset());\n-      insertTree(0);\n-      return true;\n-      }\n+   TR::Node* childrenArray[2];\n+   childrenArray[0] = combineNode->getFirstChild();\n+   childrenArray[1] = combineNode->getSecondChild();\n \n-   // make sure the index variable and base variable is consistent with the first tree\n-   TR::SymbolReference* baseRef = _addrTree[0]->getBaseVarNode()->isNull() ? NULL : _addrTree[0]->getBaseVarNode()->getChild()->skipConversions()->getSymbolReference();\n-   if (baseRef != activeBaseRef)\n+   /*\n+    * Check if the children match the pattern for combining byte loads.\n+    * There is an optional mul/shl layer.\n+    * There is an optional and layer.\n+    * The byte conversion nodes are the ones on the path to the byte loads.\n+    * The child can also be another combine node (add/or).\n+    */\n+   for (int i = 0; i < 2; i++)\n       {\n-      dumpOptDetails(comp(), \" insertTree: base variable is different than previous tree\\n\");\n-      return false;\n-      }\n+      TR::ILOpCodes childOpCode = childrenArray[i]->getOpCodeValue();\n \n-   TR::SymbolReference* indRef = _addrTree[0]->getIndVarNode()->isNull() ? NULL : _addrTree[0]->getIndVarNode()->getChild()->skipConversions()->getSymbolReference();\n-   TR::SymbolReference* activeIndRef = _activeAddrTree->getIndVarNode()->isNull() ? NULL : _activeAddrTree->getIndVarNode()->getChild()->skipConversions()->getSymbolReference();\n+      switch (childOpCode)\n+         {\n+         case TR::imul:\n+         case TR::ishl:\n+         case TR::lmul:\n+         case TR::lshl:\n+            if (!isValidSeqLoadMulOrShl(comp, trace, childrenArray[i]))\n+               return false;\n+            break;\n+         case TR::iand:\n+         case TR::land:\n+            if (!isValidSeqLoadAnd(comp, trace, childrenArray[i]))\n+               return false;\n+            break;\n+         case TR::b2i:\n+         case TR::b2l:\n+         case TR::bu2i:\n+         case TR::bu2l:\n+            if (!isValidSeqLoadByteConversion(comp, trace, childrenArray[i]))\n+               return false;\n+            break;\n+         case TR::iadd:\n+         case TR::ior:\n+         case TR::ladd:\n+         case TR::lor:\n+            if (!isValidSeqLoadCombine(comp, trace, childrenArray[i], combineNodeList, combineNodeCount))\n+               return false;\n+            break;\n+         default:\n+            return false;\n+         }\n+      }\n \n-   TR::Node* indBase = NULL;\n-   TR::Node* activeIndBase = NULL;\n-   if (!_addrTree[0]->getIndexBase()->isNull())\n-      indBase = _addrTree[0]->getIndexBase()->getParent();\n-   if (!_activeAddrTree->getIndexBase()->isNull())\n-      activeIndBase = _activeAddrTree->getIndexBase()->getParent();\n+   return true;\n+   }\n \n-   if (indRef != activeIndRef || indBase != activeIndBase)\n+bool isValidSeqLoadMulOrShl(TR::Compilation* comp, bool trace, TR::Node* mulOrShlNode)\n+   {\n+   /* Confirm that the input mulOrShlNode is one of: imul, ishl, lmul, lshl */\n+   if ((mulOrShlNode->getOpCodeValue() != TR::imul) && (mulOrShlNode->getOpCodeValue() != TR::ishl) &&\n+       (mulOrShlNode->getOpCodeValue() != TR::lmul) && (mulOrShlNode->getOpCodeValue() != TR::lshl)\n+      )\n       {\n-      dumpOptDetails(comp(), \" insertTree: index variable is different than previous tree\\n\");\n       return false;\n       }\n \n-   // make sure the value being loaded is consistent with the first tree\n-   if (_val[0]->isConst() !=  _activeValueTree->isConst())\n+   /*\n+    * mulOrShlNode must have a refCount of 1. After the transformation the intermediate value generated by this node\n+    * won't be calculated. If the value is needed for something else, the transformation needs to bail out here.\n+    */\n+   if (mulOrShlNode->getReferenceCount() != 1)\n       {\n-      dumpOptDetails(comp(), \" insertTree: const value attributes inconsistent\\n\");\n       return false;\n       }\n \n-   if (!_val[0]->isConst() && (_val[0]->getValNode() != _activeValueTree->getValNode()))\n+   TR::Node* firstChild = mulOrShlNode->getFirstChild();\n+   TR::Node* secondChild = mulOrShlNode->getSecondChild();\n+\n+   /*\n+    * Check if the first child matches the pattern.\n+    * There is an optional and layer.\n+    * The byte conversion nodes are the ones on the path to the byte loads.\n+    */\n+   switch (firstChild->getOpCodeValue())\n       {\n-      dumpOptDetails(comp(), \" insertTree: value variable is different than previous tree\\n\");\n-      return false;\n+      case TR::iand:\n+      case TR::land:\n+         if (!isValidSeqLoadAnd(comp, trace, firstChild))\n+            return false;\n+         break;\n+      case TR::b2i:\n+      case TR::b2l:\n+      case TR::bu2i:\n+      case TR::bu2l:\n+         if (!isValidSeqLoadByteConversion(comp, trace, firstChild))\n+            return false;\n+         break;\n+      default:\n+         return false;\n       }\n \n-   // make sure the value tree doesn't reference the address tree base var\n-   if (_activeValueTree->getRootNode()->referencesSymbolInSubTree(baseRef, _comp->incOrResetVisitCount()))\n+   /*\n+    * The second child must a const node and only certain values are valid.\n+    * These values correspond with the constants needed to shift a loaded byte left by multiples of 8 bits.\n+    */\n+   if ((secondChild->getOpCodeValue() != TR::iconst) && (secondChild->getOpCodeValue() != TR::lconst))\n       {\n-      dumpOptDetails(comp(), \" insertTree: value tree %p references address tree base var\\n\", _activeValueTree->getRootNode());\n       return false;\n       }\n \n-//   dumpOptDetails(comp(), \" insertTree: tree inserted successfully. offset:%d\\n\", _activeAddrTree->getOffset());\n-   int entry;\n-   for (entry=0; entry < _maxAddressTrees && _addrTree[entry] != NULL; ++entry)\n+   if (mulOrShlNode->getOpCodeValue() == TR::imul)\n       {\n-      if (_activeAddrTree->getOffset() < _addrTree[entry]->getOffset())\n+      switch (secondChild->getInt())\n          {\n-         insertTree(entry);\n-         return true;\n+         case 0x100:     /* 256   */\n+         case 0x10000:   /* 256^2 */\n+         case 0x1000000: /* 256^3 */\n+            break;\n+         default:\n+            return false;\n+         }\n+      }\n+   else if (mulOrShlNode->getOpCodeValue() == TR::ishl)\n+      {\n+      switch (secondChild->getInt())\n+         {\n+         case 8:\n+         case 16:\n+         case 24:\n+            break;\n+         default:\n+            return false;\n+         }\n+      }\n+   else if (mulOrShlNode->getOpCodeValue() == TR::lmul)\n+      {\n+      switch (secondChild->getLongInt())\n+         {\n+         case 0x100L:             /* 256   */\n+         case 0x10000L:           /* 256^2 */\n+         case 0x1000000L:         /* 256^3 */\n+         case 0x100000000L:       /* 256^4 */\n+         case 0x10000000000L:     /* 256^5 */\n+         case 0x1000000000000L:   /* 256^6 */\n+         case 0x100000000000000L: /* 256^7 */\n+            break;\n+         default:\n+            return false;\n+         }\n+      }\n+   else /* mulOrShlNode->getOpCodeValue() == TR::lshl */\n+      {\n+      switch (secondChild->getInt())\n+         {\n+         case 8:\n+         case 16:\n+         case 24:\n+         case 32:\n+         case 40:\n+         case 48:\n+         case 56:\n+            break;\n+         default:\n+            return false;\n          }\n       }\n \n-   insertTree(entry);\n    return true;\n    }\n \n-\n-int TR_arraycopySequentialStores::numTrees()\n+bool isValidSeqLoadAnd(TR::Compilation* comp, bool trace, TR::Node* andNode)\n    {\n-   int i;\n-   for (i=0; i<_maxAddressTrees; ++i)\n+   /* Confirm that the input andNode is one of: iand, land */\n+   if ((andNode->getOpCodeValue() != TR::iand) && (andNode->getOpCodeValue() != TR::land))\n       {\n-      if (_addrTree[i] == NULL)\n-         return i;\n+      return false;\n       }\n-   return _maxAddressTrees;\n-   }\n \n-int TR_arraycopySequentialStores::numValidTrees(int maxEntries)\n-   {\n-   int dir = (_bigEndian) ? -1 : 1;\n-   int entry;\n+   /*\n+    * andNode must have a refCount of 1. After the transformation the intermediate value generated by this node\n+    * won't be calculated. If the value is needed for something else, the transformation needs to bail out here.\n+    */\n+   if (andNode->getReferenceCount() != 1)\n+      {\n+      return false;\n+      }\n \n-//   dumpOptDetails(comp(), \"...check if valid entries\\n\");\n-   for (entry=1; (_addrTree[entry] != NULL) && (entry < maxEntries); ++entry)\n+   TR::Node* firstChild = andNode->getFirstChild();\n+   TR::Node* secondChild = andNode->getSecondChild();\n+\n+   /*\n+    * Check if the first child matches the pattern.\n+    * The byte conversion nodes are the ones on the path to the byte loads.\n+    */\n+   switch (firstChild->getOpCodeValue())\n       {\n-      if (_addrTree[entry]->getOffset() != _addrTree[0]->getOffset() + entry)\n-         {\n+      case TR::b2i:\n+      case TR::b2l:\n+      case TR::bu2i:\n+      case TR::bu2l:\n+         if (!isValidSeqLoadByteConversion(comp, trace, firstChild))\n+            return false;\n          break;\n-         }\n-      if (!hasConstValue() && (_val[entry]->getShiftValue() != _val[0]->getShiftValue() + dir*8*entry))\n+      default:\n+         return false;\n+      }\n+\n+   /*\n+    * The second child must a const node and only 0xFF is valid.\n+    * This node is supposed to act as a mask so that only 8 bits are affected when this is combined via add/or with the other\n+    * loaded bytes.\n+    */\n+   if (secondChild->getOpCodeValue() == TR::iconst)\n+      {\n+      if (secondChild->getInt() != 0xFF)\n          {\n-         break;\n+         return false;\n          }\n       }\n-   if ((entry == 1) && !hasConstValue() && _comp->cg()->supportsByteswap())\n+   else if (secondChild->getOpCodeValue() == TR::lconst)\n       {\n-//      dumpOptDetails(comp(), \"...no valid entries forward\\n...see if reverse store finds any entries\\n\");\n-      _alternateDir = true;\n-      // repeat process for reversed store\n-      dir = (_bigEndian) ? 1 : -1;\n-      for (entry=1; (_addrTree[entry] != NULL) && (entry < maxEntries); ++entry)\n+      if (secondChild->getLongInt() != 0xFF)\n          {\n-         if (_addrTree[entry]->getOffset() != _addrTree[0]->getOffset() + entry)\n-            {\n-            break;\n-            }\n-         if (_val[entry]->getShiftValue() != _val[0]->getShiftValue() + dir*8*entry)\n-            {\n-            break;\n-            }\n+         return false;\n          }\n       }\n-   if (entry > 1)\n+   else\n       {\n-      dumpOptDetails(comp(), \"Found %d sequential valid trees\\n\", entry);\n+      return false;\n       }\n-   return entry;\n+\n+   return true;\n    }\n \n-bool TR_arraycopySequentialStores::checkTrees()\n+bool isValidSeqLoadByteConversion(TR::Compilation* comp, bool trace, TR::Node* conversionNode)\n    {\n-   if (_val[0] == NULL)\n+   /*\n+    * Example tree:\n+    * b2i        <--- conversionNode\n+    *   bloadi\n+    *     aladd\n+    *       aload/aloadi\n+    *       lsub/ladd\n+    *         **basePointerNode**\n+    *         lconst\n+    */\n+\n+   /* Confirm that the input conversionNode is one of: b2i, b2l, bu2i, bu2l */\n+   if ((conversionNode->getOpCodeValue() != TR::b2i) && (conversionNode->getOpCodeValue() != TR::bu2i) &&\n+       (conversionNode->getOpCodeValue() != TR::b2l) && (conversionNode->getOpCodeValue() != TR::bu2l)\n+      )\n       {\n       return false;\n       }\n \n-   if (hasConstValue())\n+   /*\n+    * conversionNode must have a refCount of 1. After the transformation the intermediate value generated by this node\n+    * won't be calculated. If the value is needed for something else, the transformation needs to bail out here.\n+    */\n+   if (conversionNode->getReferenceCount() != 1)\n       {\n-      _numBytes = numValidTrees();\n+      return false;\n       }\n-   else\n+\n+   TR::Node* firstChild = conversionNode->getFirstChild();\n+   TR::Node* secondChild = NULL;\n+\n+   /*\n+    * conversionNode's child must be a bloadi with a refcount of 1. After the transformation the intermediate value generated by this node\n+    * won't be calculated. If the value is needed for something else, the transformation needs to bail out here.\n+    */\n+   if ((firstChild->getOpCodeValue() != TR::bloadi) || (firstChild->getReferenceCount() != 1))\n       {\n-      _numBytes = numValidTrees(_val[0]->getValueSize());\n+      return false;\n       }\n \n-   return (_numBytes == 2 || _numBytes == 4 || _numBytes == 8);\n-   }\n+   firstChild = firstChild->getFirstChild();\n \n-void TR_arraycopySequentialStores::removeTrees(TR::SymbolReference * symRef)\n-   {\n-   TR::SparseBitVector fromAliases(_comp->allocator(\"SCSS bitvector\"));\n+   if (comp->target().is64Bit())\n+      {\n+      /*\n+       * Under 64bit, bloadi's child must be an aladd node. Some of the aladd nodes go away after the transformation.\n+       * So, if the refCount is not 1, bail out here.\n+       */\n+      if ((firstChild->getOpCodeValue() != TR::aladd) || (firstChild->getReferenceCount() != 1))\n+         {\n+         return false;\n+         }\n \n-   for (int32_t i = 0; i < _numBytes; ++i)\n+      secondChild = firstChild->getSecondChild();\n+      firstChild = firstChild->getFirstChild();\n+\n+      /* aladd's first child can be aload or aloadi. This load is kept so there is no refcount restriction. */\n+      if ((firstChild->getOpCodeValue() != TR::aload) && (firstChild->getOpCodeValue() != TR::aloadi))\n+         {\n+         return false;\n+         }\n+\n+      /*\n+       * aladd's second child can be an lconst, ladd or lsub. The ladd or lsub might go away after transformation\n+       * so they must have a refCount of 1.\n+       */\n+      if (secondChild->getReferenceCount() != 1)\n+         {\n+         if (secondChild->getOpCodeValue() != TR::lconst)\n+            {\n+            return false;\n+            }\n+         }\n+      else\n+         {\n+         if ((secondChild->getOpCodeValue() != TR::lconst) &&\n+             (secondChild->getOpCodeValue() != TR::ladd)   &&\n+             (secondChild->getOpCodeValue() != TR::lsub))\n+            {\n+            return false;\n+            }\n+         }\n+\n+      /* If the second child is lsub or ladd, make sure that node's second child is an lconst. */\n+      if (secondChild->getOpCodeValue() != TR::lconst)\n+         {\n+         secondChild = secondChild->getSecondChild();\n+\n+         if (secondChild->getOpCodeValue() != TR::lconst)\n+            {\n+            return false;\n+            }\n+         }\n+      }\n+   else\n       {\n-      dumpOptDetails(_comp, \" Remove trees %p to %p\\n\", _treeTops[i]->getNode(), _treeTops[i]->getNextTreeTop()->getNode());\n-      TR::TreeTop::removeDeadTrees(_comp, _treeTops[i], _treeTops[i]->getNextTreeTop());\n+      /*\n+       * Under 32bit, bloadi's child must be an aiadd node. Some of the aiadd nodes go away after the transformation.\n+       * So, if the refCount is not 1, bail out here.\n+       */\n+      if ((firstChild->getOpCodeValue() != TR::aiadd) || (firstChild->getReferenceCount() != 1))\n+         {\n+         return false;\n+         }\n+\n+      secondChild = firstChild->getSecondChild();\n+      firstChild = firstChild->getFirstChild();\n+\n+      /* aiadd's first child can be aload or aloadi. This load is kept so there is no refcount restriction. */\n+      if ((firstChild->getOpCodeValue() != TR::aload) && (firstChild->getOpCodeValue() != TR::aloadi))\n+         {\n+         return false;\n+         }\n+\n+      /*\n+       * aiadd's second child can be an iconst, iadd or isub. The iadd or isub might go away after transformation\n+       * so they must have a refCount of 1.\n+       */\n+      if (secondChild->getReferenceCount() != 1)\n+         {\n+         if (secondChild->getOpCodeValue() != TR::iconst)\n+            {\n+            return false;\n+            }\n+         }\n+      else\n+         {\n+         if ((secondChild->getOpCodeValue() != TR::iconst) &&\n+             (secondChild->getOpCodeValue() != TR::iadd)   &&\n+             (secondChild->getOpCodeValue() != TR::isub))\n+            {\n+            return false;\n+            }\n+         }\n+\n+      /* If the second child is isub or iadd, make sure that node's second child is an iconst. */\n+      if (secondChild->getOpCodeValue() != TR::iconst)\n+         {\n+         secondChild = secondChild->getSecondChild();\n+\n+         if (secondChild->getOpCodeValue() != TR::iconst)\n+            {\n+            return false;\n+            }\n+         }\n       }\n \n+   return true;\n    }\n \n-int64_t TR_arraycopySequentialStores::constVal()\n+int64_t getOffsetForSeqLoad(TR::Compilation* comp, TR::Node* byteConversionNode)\n    {\n-   int dir;\n-   int baseShift;\n-   uint64_t val = 0;\n+   /*\n+    * Returns the constant offset from basePointerNode. Offset from aload/aloadi if there is no basePointerNode.\n+    * byteConversionNode must be: b2i, b2l, bu2i, bu2l\n+    *\n+    * Example tree: (sub/add version)\n+    * b2i        <--- byteConversionNode\n+    *   bloadi\n+    *     aladd\n+    *       aload/aloadi\n+    *       lsub/ladd     <<--- displacementNode\n+    *         **basePointerNode**\n+    *         lconst      <<--- return value\n+    *\n+    *\n+    * Example tree: (const version)\n+    * b2i        <--- byteConversionNode\n+    *   bloadi\n+    *     aladd\n+    *       aload/aloadi\n+    *       lconst        <<--- displacementNode, return value", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c17f5745e482b16315475e38333b0117cb5e11a"}, "originalPosition": 714}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTc2NDc2NA==", "bodyText": "Is it possible to replace this loop with mapping from multValue to j and check that j is within the right range and that there no duplicates? Then the following loop would not be needed either.", "url": "https://github.com/eclipse-openj9/openj9/pull/11251#discussion_r535764764", "createdAt": "2020-12-04T01:18:17Z", "author": {"login": "gita-omr"}, "path": "runtime/compiler/optimizer/SequentialStoreSimplifier.cpp", "diffHunk": "@@ -677,621 +684,2200 @@ TR::Node* getALoadReferenceForSeqLoad(TR::Node* rootNode, int32_t totalBytes, in\n       }\n    }\n \n-bool TR_ShiftedValueTree::process(TR::Node* loadNode)\n+TR::TreeTop* seqLoadSearchAndCombine(TR::Compilation* comp, bool trace, TR_BitVector* visitedNodes, TR::TreeTop* currentTree, TR::Node* currentNode, NodeForwardList* combineNodeList)\n    {\n-\n-   bool shift = true;\n-   TR::ILOpCodes convCode = loadNode->getOpCodeValue();\n-   TR::ILOpCodes shiftCode, altShiftCode, constCode;\n-   int32_t size;\n-\n-   _isConst = false;\n-   switch(convCode)\n-      {\n-      case TR::s2b: shift = true;  _valueSize = 2; shiftCode = TR::sushr; altShiftCode = TR::sshr; constCode = TR::iconst; break;\n-      case TR::i2b: shift = true;  _valueSize = 4; shiftCode = TR::iushr; altShiftCode = TR::ishr; constCode = TR::iconst; break;\n-      case TR::l2b: shift = true;  _valueSize = 8; shiftCode = TR::lushr; altShiftCode = TR::lshr; constCode = TR::iconst; break;\n-      case TR::bload:\n-      case TR::bconst:\n-      case TR::sconst:\n-      case TR::iconst:\n-      case TR::lconst: shift = false; _valueSize = 1; _shiftValue = 0; break;\n-      default: return false;\n-      }\n-\n-//   dumpOptDetails(comp(), \"arraycopy sequential store - check load node %p\\n\", loadNode);\n-\n-   if (shift)\n+   if (visitedNodes->isSet(currentNode->getGlobalIndex()))\n+      return currentTree;\n+\n+   visitedNodes->set(currentNode->getGlobalIndex());\n+\n+   /*\n+    * Combine nodes are the \"add\" and \"or\" nodes that construct the longer value out of several loaded bytes.\n+    * combineNodeList keeps tracks of the nodes used to construct one particular value. It is populated by isValidSeqLoadCombine.\n+    * combineNodeList needs to be cleared each time before it is repopulated.\n+    * isValidSeqLoadCombine also performs a series of initial checks to see if the tree structure contains the pattern\n+    * of byte loads that can be combined into wider loads.\n+    * combineNodeCount tracks the number of combine nodes.\n+    */\n+   combineNodeList->clear();\n+   int32_t combineNodeCount = 0;\n+   if (isValidSeqLoadCombine(comp, trace, currentNode, combineNodeList, combineNodeCount))\n       {\n-      if (loadNode->getFirstChild()->getOpCodeValue() != shiftCode && loadNode->getFirstChild()->getOpCodeValue() != altShiftCode)\n-         {\n-         _valNode = loadNode->getFirstChild();\n-         _shiftValue = 0;\n-         }\n-      else\n-         {\n-         TR::Node* shiftVal = loadNode->getFirstChild()->getSecondChild();\n-         if (shiftVal->getOpCodeValue() != constCode)\n-            {\n-            dumpOptDetails(comp(), \" Shifted Value: did not encounter correct const code\\n\");\n-            return false;\n-            }\n-         _valNode = loadNode->getFirstChild()->getFirstChild();\n-         switch(constCode)\n-            {\n-            case TR::sconst: _shiftValue = shiftVal->getShortInt(); break;\n-            case TR::iconst: _shiftValue = shiftVal->getInt(); break;\n-            case TR::lconst: _shiftValue = shiftVal->getLongInt(); break;\n-            default: break;\n-            }\n-         }\n+      /*\n+       * The initial tree structure seems good at this point. generateArraycopyFromSequentialLoads will do some additional\n+       * checks. If they also pass, it will combine the byte loads into wider loads.\n+       */\n+      currentTree = generateArraycopyFromSequentialLoads(comp, trace, currentTree, currentNode, combineNodeList);\n       }\n    else\n       {\n-      _valNode = loadNode;\n-      if (convCode != TR::bload)\n+      /* If the checks in isValidSeqLoadCombine fail, try again on the children. */\n+      for (int i = 0; i < currentNode->getNumChildren(); i++)\n          {\n-         _isConst = true;\n+         currentTree = seqLoadSearchAndCombine(comp, trace, visitedNodes, currentTree, currentNode->getChild(i), combineNodeList);\n          }\n       }\n \n-   if ((_shiftValue % 8) != 0 || (_shiftValue < 0) || (_shiftValue >= _valueSize*8))\n-      {\n-      dumpOptDetails(comp(), \"Shifted Value: did not encounter valid shift value %d for var size %d\\n\", _shiftValue, _valueSize);\n-      return false;\n-      }\n-\n-   _rootNode = loadNode;\n-\n-   return true;\n+   return currentTree;\n    }\n \n-bool TR_arraycopySequentialStores::checkAiadd(TR::TreeTop * currentTree, TR::Node* aiaddNode)\n+bool isValidSeqLoadCombine(TR::Compilation* comp, bool trace, TR::Node* combineNode, NodeForwardList* combineNodeList, int32_t &combineNodeCount)\n    {\n-//   dumpOptDetails(comp(), \"arraycopy sequential store - check aiadd node %p\\n\", aiaddNode);\n-   _activeAddrTree = new (trStackMemory()) TR_AddressTree(stackAlloc, comp());\n-   _activeTreeTop = currentTree;\n-   if (_activeAddrTree->process(aiaddNode, _comp->cg()->getSupportsAlignedAccessOnly()))\n+   /* Combine nodes are the \"add\" and \"or\" nodes that construct the longer value out of several loaded bytes. */\n+\n+   /* Check if the candidate combine node is: iadd, ior, ladd, lor */\n+   if ((combineNode->getOpCodeValue() != TR::iadd) && (combineNode->getOpCodeValue() != TR::ior) &&\n+       (combineNode->getOpCodeValue() != TR::ladd) && (combineNode->getOpCodeValue() != TR::lor)\n+      )\n       {\n-      return insertConsistentTree();\n+      return false;\n       }\n-   return false;\n-   }\n \n-void TR_arraycopySequentialStores::insertTree(int entry)\n-   {\n-//   dumpOptDetails(comp(), \" insert nodes %p,%p into entry %d\\n\",\n-//      _activeAddrTree->getRootNode(), _activeValueTree->getRootNode(), entry);\n-   if ((_addrTree[entry] != NULL) && (entry < _maxAddressTrees))\n+   /*\n+    * Only the topmost combine node (the first one to be looked at) can have a reference count greater than 1.\n+    * If not, it means the intermediate values when constructing the larger value are used in other places and still\n+    * needs to be generated.\n+    */\n+   if ((combineNodeCount > 0) && (combineNode->getReferenceCount() != 1))\n       {\n-      memmove(&_addrTree[entry+1], &_addrTree[entry], (_maxAddressTrees-entry-1)*sizeof(TR_AddressTree*));\n-      memmove(&_val[entry+1], &_val[entry],  (_maxAddressTrees-entry-1)*sizeof(TR_ShiftedValueTree*));\n-      memmove(&_treeTops[entry+1], &_treeTops[entry], (_maxAddressTrees-entry-1)*sizeof(TR::TreeTop*));\n+      return false;\n       }\n-   _addrTree[entry] = _activeAddrTree;\n-   _val[entry] = _activeValueTree;\n-   _treeTops[entry] = _activeTreeTop;\n-   }\n \n-bool TR_arraycopySequentialStores::insertConsistentTree()\n-   {\n+   /* The node being looked at is a potential combine node so it gets added to the list. */\n+   combineNodeList->push_front(combineNode);\n+   combineNodeCount++;\n \n-   // these are byte arrays we are working with - the multiplier must be 1\n-   if (_activeAddrTree->getMultiplier() != 1)\n+   /*\n+    * If int width combine nodes are being used, no more than 4 bytes can be combined which means no more than 3 combine nodes.\n+    * If long width combine nodes are being used, no more than 8 bytes can be combined which means no more than 7 combine nodes.\n+    */\n+   if ((combineNodeCount > 3) && ((combineNode->getOpCodeValue() == TR::iadd) || (combineNode->getOpCodeValue() == TR::ior)))\n       {\n-      dumpOptDetails(comp(), \" insertTree: multiplier must be 1 in aiadd tree\\n\");\n       return false;\n       }\n-   TR::SymbolReference* activeBaseRef = _activeAddrTree->getBaseVarNode()->isNull() ? NULL : _activeAddrTree->getBaseVarNode()->getChild()->skipConversions()->getSymbolReference();\n-   if (activeBaseRef == NULL)\n+   else if ((combineNodeCount > 7) && ((combineNode->getOpCodeValue() == TR::ladd) || (combineNode->getOpCodeValue() == TR::lor)))\n       {\n-      dumpOptDetails(comp(), \" insertTree: no base variable in aiadd tree\\n\");\n       return false;\n       }\n \n-   if (_addrTree[0] == NULL)\n-      {\n-//      dumpOptDetails(comp(), \" insertTree: first tree inserted successfully with offset: %d\\n\", _activeAddrTree->getOffset());\n-      insertTree(0);\n-      return true;\n-      }\n+   TR::Node* childrenArray[2];\n+   childrenArray[0] = combineNode->getFirstChild();\n+   childrenArray[1] = combineNode->getSecondChild();\n \n-   // make sure the index variable and base variable is consistent with the first tree\n-   TR::SymbolReference* baseRef = _addrTree[0]->getBaseVarNode()->isNull() ? NULL : _addrTree[0]->getBaseVarNode()->getChild()->skipConversions()->getSymbolReference();\n-   if (baseRef != activeBaseRef)\n+   /*\n+    * Check if the children match the pattern for combining byte loads.\n+    * There is an optional mul/shl layer.\n+    * There is an optional and layer.\n+    * The byte conversion nodes are the ones on the path to the byte loads.\n+    * The child can also be another combine node (add/or).\n+    */\n+   for (int i = 0; i < 2; i++)\n       {\n-      dumpOptDetails(comp(), \" insertTree: base variable is different than previous tree\\n\");\n-      return false;\n-      }\n+      TR::ILOpCodes childOpCode = childrenArray[i]->getOpCodeValue();\n \n-   TR::SymbolReference* indRef = _addrTree[0]->getIndVarNode()->isNull() ? NULL : _addrTree[0]->getIndVarNode()->getChild()->skipConversions()->getSymbolReference();\n-   TR::SymbolReference* activeIndRef = _activeAddrTree->getIndVarNode()->isNull() ? NULL : _activeAddrTree->getIndVarNode()->getChild()->skipConversions()->getSymbolReference();\n+      switch (childOpCode)\n+         {\n+         case TR::imul:\n+         case TR::ishl:\n+         case TR::lmul:\n+         case TR::lshl:\n+            if (!isValidSeqLoadMulOrShl(comp, trace, childrenArray[i]))\n+               return false;\n+            break;\n+         case TR::iand:\n+         case TR::land:\n+            if (!isValidSeqLoadAnd(comp, trace, childrenArray[i]))\n+               return false;\n+            break;\n+         case TR::b2i:\n+         case TR::b2l:\n+         case TR::bu2i:\n+         case TR::bu2l:\n+            if (!isValidSeqLoadByteConversion(comp, trace, childrenArray[i]))\n+               return false;\n+            break;\n+         case TR::iadd:\n+         case TR::ior:\n+         case TR::ladd:\n+         case TR::lor:\n+            if (!isValidSeqLoadCombine(comp, trace, childrenArray[i], combineNodeList, combineNodeCount))\n+               return false;\n+            break;\n+         default:\n+            return false;\n+         }\n+      }\n \n-   TR::Node* indBase = NULL;\n-   TR::Node* activeIndBase = NULL;\n-   if (!_addrTree[0]->getIndexBase()->isNull())\n-      indBase = _addrTree[0]->getIndexBase()->getParent();\n-   if (!_activeAddrTree->getIndexBase()->isNull())\n-      activeIndBase = _activeAddrTree->getIndexBase()->getParent();\n+   return true;\n+   }\n \n-   if (indRef != activeIndRef || indBase != activeIndBase)\n+bool isValidSeqLoadMulOrShl(TR::Compilation* comp, bool trace, TR::Node* mulOrShlNode)\n+   {\n+   /* Confirm that the input mulOrShlNode is one of: imul, ishl, lmul, lshl */\n+   if ((mulOrShlNode->getOpCodeValue() != TR::imul) && (mulOrShlNode->getOpCodeValue() != TR::ishl) &&\n+       (mulOrShlNode->getOpCodeValue() != TR::lmul) && (mulOrShlNode->getOpCodeValue() != TR::lshl)\n+      )\n       {\n-      dumpOptDetails(comp(), \" insertTree: index variable is different than previous tree\\n\");\n       return false;\n       }\n \n-   // make sure the value being loaded is consistent with the first tree\n-   if (_val[0]->isConst() !=  _activeValueTree->isConst())\n+   /*\n+    * mulOrShlNode must have a refCount of 1. After the transformation the intermediate value generated by this node\n+    * won't be calculated. If the value is needed for something else, the transformation needs to bail out here.\n+    */\n+   if (mulOrShlNode->getReferenceCount() != 1)\n       {\n-      dumpOptDetails(comp(), \" insertTree: const value attributes inconsistent\\n\");\n       return false;\n       }\n \n-   if (!_val[0]->isConst() && (_val[0]->getValNode() != _activeValueTree->getValNode()))\n+   TR::Node* firstChild = mulOrShlNode->getFirstChild();\n+   TR::Node* secondChild = mulOrShlNode->getSecondChild();\n+\n+   /*\n+    * Check if the first child matches the pattern.\n+    * There is an optional and layer.\n+    * The byte conversion nodes are the ones on the path to the byte loads.\n+    */\n+   switch (firstChild->getOpCodeValue())\n       {\n-      dumpOptDetails(comp(), \" insertTree: value variable is different than previous tree\\n\");\n-      return false;\n+      case TR::iand:\n+      case TR::land:\n+         if (!isValidSeqLoadAnd(comp, trace, firstChild))\n+            return false;\n+         break;\n+      case TR::b2i:\n+      case TR::b2l:\n+      case TR::bu2i:\n+      case TR::bu2l:\n+         if (!isValidSeqLoadByteConversion(comp, trace, firstChild))\n+            return false;\n+         break;\n+      default:\n+         return false;\n       }\n \n-   // make sure the value tree doesn't reference the address tree base var\n-   if (_activeValueTree->getRootNode()->referencesSymbolInSubTree(baseRef, _comp->incOrResetVisitCount()))\n+   /*\n+    * The second child must a const node and only certain values are valid.\n+    * These values correspond with the constants needed to shift a loaded byte left by multiples of 8 bits.\n+    */\n+   if ((secondChild->getOpCodeValue() != TR::iconst) && (secondChild->getOpCodeValue() != TR::lconst))\n       {\n-      dumpOptDetails(comp(), \" insertTree: value tree %p references address tree base var\\n\", _activeValueTree->getRootNode());\n       return false;\n       }\n \n-//   dumpOptDetails(comp(), \" insertTree: tree inserted successfully. offset:%d\\n\", _activeAddrTree->getOffset());\n-   int entry;\n-   for (entry=0; entry < _maxAddressTrees && _addrTree[entry] != NULL; ++entry)\n+   if (mulOrShlNode->getOpCodeValue() == TR::imul)\n       {\n-      if (_activeAddrTree->getOffset() < _addrTree[entry]->getOffset())\n+      switch (secondChild->getInt())\n          {\n-         insertTree(entry);\n-         return true;\n+         case 0x100:     /* 256   */\n+         case 0x10000:   /* 256^2 */\n+         case 0x1000000: /* 256^3 */\n+            break;\n+         default:\n+            return false;\n+         }\n+      }\n+   else if (mulOrShlNode->getOpCodeValue() == TR::ishl)\n+      {\n+      switch (secondChild->getInt())\n+         {\n+         case 8:\n+         case 16:\n+         case 24:\n+            break;\n+         default:\n+            return false;\n+         }\n+      }\n+   else if (mulOrShlNode->getOpCodeValue() == TR::lmul)\n+      {\n+      switch (secondChild->getLongInt())\n+         {\n+         case 0x100L:             /* 256   */\n+         case 0x10000L:           /* 256^2 */\n+         case 0x1000000L:         /* 256^3 */\n+         case 0x100000000L:       /* 256^4 */\n+         case 0x10000000000L:     /* 256^5 */\n+         case 0x1000000000000L:   /* 256^6 */\n+         case 0x100000000000000L: /* 256^7 */\n+            break;\n+         default:\n+            return false;\n+         }\n+      }\n+   else /* mulOrShlNode->getOpCodeValue() == TR::lshl */\n+      {\n+      switch (secondChild->getInt())\n+         {\n+         case 8:\n+         case 16:\n+         case 24:\n+         case 32:\n+         case 40:\n+         case 48:\n+         case 56:\n+            break;\n+         default:\n+            return false;\n          }\n       }\n \n-   insertTree(entry);\n    return true;\n    }\n \n-\n-int TR_arraycopySequentialStores::numTrees()\n+bool isValidSeqLoadAnd(TR::Compilation* comp, bool trace, TR::Node* andNode)\n    {\n-   int i;\n-   for (i=0; i<_maxAddressTrees; ++i)\n+   /* Confirm that the input andNode is one of: iand, land */\n+   if ((andNode->getOpCodeValue() != TR::iand) && (andNode->getOpCodeValue() != TR::land))\n       {\n-      if (_addrTree[i] == NULL)\n-         return i;\n+      return false;\n       }\n-   return _maxAddressTrees;\n-   }\n \n-int TR_arraycopySequentialStores::numValidTrees(int maxEntries)\n-   {\n-   int dir = (_bigEndian) ? -1 : 1;\n-   int entry;\n+   /*\n+    * andNode must have a refCount of 1. After the transformation the intermediate value generated by this node\n+    * won't be calculated. If the value is needed for something else, the transformation needs to bail out here.\n+    */\n+   if (andNode->getReferenceCount() != 1)\n+      {\n+      return false;\n+      }\n \n-//   dumpOptDetails(comp(), \"...check if valid entries\\n\");\n-   for (entry=1; (_addrTree[entry] != NULL) && (entry < maxEntries); ++entry)\n+   TR::Node* firstChild = andNode->getFirstChild();\n+   TR::Node* secondChild = andNode->getSecondChild();\n+\n+   /*\n+    * Check if the first child matches the pattern.\n+    * The byte conversion nodes are the ones on the path to the byte loads.\n+    */\n+   switch (firstChild->getOpCodeValue())\n       {\n-      if (_addrTree[entry]->getOffset() != _addrTree[0]->getOffset() + entry)\n-         {\n+      case TR::b2i:\n+      case TR::b2l:\n+      case TR::bu2i:\n+      case TR::bu2l:\n+         if (!isValidSeqLoadByteConversion(comp, trace, firstChild))\n+            return false;\n          break;\n-         }\n-      if (!hasConstValue() && (_val[entry]->getShiftValue() != _val[0]->getShiftValue() + dir*8*entry))\n+      default:\n+         return false;\n+      }\n+\n+   /*\n+    * The second child must a const node and only 0xFF is valid.\n+    * This node is supposed to act as a mask so that only 8 bits are affected when this is combined via add/or with the other\n+    * loaded bytes.\n+    */\n+   if (secondChild->getOpCodeValue() == TR::iconst)\n+      {\n+      if (secondChild->getInt() != 0xFF)\n          {\n-         break;\n+         return false;\n          }\n       }\n-   if ((entry == 1) && !hasConstValue() && _comp->cg()->supportsByteswap())\n+   else if (secondChild->getOpCodeValue() == TR::lconst)\n       {\n-//      dumpOptDetails(comp(), \"...no valid entries forward\\n...see if reverse store finds any entries\\n\");\n-      _alternateDir = true;\n-      // repeat process for reversed store\n-      dir = (_bigEndian) ? 1 : -1;\n-      for (entry=1; (_addrTree[entry] != NULL) && (entry < maxEntries); ++entry)\n+      if (secondChild->getLongInt() != 0xFF)\n          {\n-         if (_addrTree[entry]->getOffset() != _addrTree[0]->getOffset() + entry)\n-            {\n-            break;\n-            }\n-         if (_val[entry]->getShiftValue() != _val[0]->getShiftValue() + dir*8*entry)\n-            {\n-            break;\n-            }\n+         return false;\n          }\n       }\n-   if (entry > 1)\n+   else\n       {\n-      dumpOptDetails(comp(), \"Found %d sequential valid trees\\n\", entry);\n+      return false;\n       }\n-   return entry;\n+\n+   return true;\n    }\n \n-bool TR_arraycopySequentialStores::checkTrees()\n+bool isValidSeqLoadByteConversion(TR::Compilation* comp, bool trace, TR::Node* conversionNode)\n    {\n-   if (_val[0] == NULL)\n+   /*\n+    * Example tree:\n+    * b2i        <--- conversionNode\n+    *   bloadi\n+    *     aladd\n+    *       aload/aloadi\n+    *       lsub/ladd\n+    *         **basePointerNode**\n+    *         lconst\n+    */\n+\n+   /* Confirm that the input conversionNode is one of: b2i, b2l, bu2i, bu2l */\n+   if ((conversionNode->getOpCodeValue() != TR::b2i) && (conversionNode->getOpCodeValue() != TR::bu2i) &&\n+       (conversionNode->getOpCodeValue() != TR::b2l) && (conversionNode->getOpCodeValue() != TR::bu2l)\n+      )\n       {\n       return false;\n       }\n \n-   if (hasConstValue())\n+   /*\n+    * conversionNode must have a refCount of 1. After the transformation the intermediate value generated by this node\n+    * won't be calculated. If the value is needed for something else, the transformation needs to bail out here.\n+    */\n+   if (conversionNode->getReferenceCount() != 1)\n       {\n-      _numBytes = numValidTrees();\n+      return false;\n       }\n-   else\n+\n+   TR::Node* firstChild = conversionNode->getFirstChild();\n+   TR::Node* secondChild = NULL;\n+\n+   /*\n+    * conversionNode's child must be a bloadi with a refcount of 1. After the transformation the intermediate value generated by this node\n+    * won't be calculated. If the value is needed for something else, the transformation needs to bail out here.\n+    */\n+   if ((firstChild->getOpCodeValue() != TR::bloadi) || (firstChild->getReferenceCount() != 1))\n       {\n-      _numBytes = numValidTrees(_val[0]->getValueSize());\n+      return false;\n       }\n \n-   return (_numBytes == 2 || _numBytes == 4 || _numBytes == 8);\n-   }\n+   firstChild = firstChild->getFirstChild();\n \n-void TR_arraycopySequentialStores::removeTrees(TR::SymbolReference * symRef)\n-   {\n-   TR::SparseBitVector fromAliases(_comp->allocator(\"SCSS bitvector\"));\n+   if (comp->target().is64Bit())\n+      {\n+      /*\n+       * Under 64bit, bloadi's child must be an aladd node. Some of the aladd nodes go away after the transformation.\n+       * So, if the refCount is not 1, bail out here.\n+       */\n+      if ((firstChild->getOpCodeValue() != TR::aladd) || (firstChild->getReferenceCount() != 1))\n+         {\n+         return false;\n+         }\n \n-   for (int32_t i = 0; i < _numBytes; ++i)\n+      secondChild = firstChild->getSecondChild();\n+      firstChild = firstChild->getFirstChild();\n+\n+      /* aladd's first child can be aload or aloadi. This load is kept so there is no refcount restriction. */\n+      if ((firstChild->getOpCodeValue() != TR::aload) && (firstChild->getOpCodeValue() != TR::aloadi))\n+         {\n+         return false;\n+         }\n+\n+      /*\n+       * aladd's second child can be an lconst, ladd or lsub. The ladd or lsub might go away after transformation\n+       * so they must have a refCount of 1.\n+       */\n+      if (secondChild->getReferenceCount() != 1)\n+         {\n+         if (secondChild->getOpCodeValue() != TR::lconst)\n+            {\n+            return false;\n+            }\n+         }\n+      else\n+         {\n+         if ((secondChild->getOpCodeValue() != TR::lconst) &&\n+             (secondChild->getOpCodeValue() != TR::ladd)   &&\n+             (secondChild->getOpCodeValue() != TR::lsub))\n+            {\n+            return false;\n+            }\n+         }\n+\n+      /* If the second child is lsub or ladd, make sure that node's second child is an lconst. */\n+      if (secondChild->getOpCodeValue() != TR::lconst)\n+         {\n+         secondChild = secondChild->getSecondChild();\n+\n+         if (secondChild->getOpCodeValue() != TR::lconst)\n+            {\n+            return false;\n+            }\n+         }\n+      }\n+   else\n       {\n-      dumpOptDetails(_comp, \" Remove trees %p to %p\\n\", _treeTops[i]->getNode(), _treeTops[i]->getNextTreeTop()->getNode());\n-      TR::TreeTop::removeDeadTrees(_comp, _treeTops[i], _treeTops[i]->getNextTreeTop());\n+      /*\n+       * Under 32bit, bloadi's child must be an aiadd node. Some of the aiadd nodes go away after the transformation.\n+       * So, if the refCount is not 1, bail out here.\n+       */\n+      if ((firstChild->getOpCodeValue() != TR::aiadd) || (firstChild->getReferenceCount() != 1))\n+         {\n+         return false;\n+         }\n+\n+      secondChild = firstChild->getSecondChild();\n+      firstChild = firstChild->getFirstChild();\n+\n+      /* aiadd's first child can be aload or aloadi. This load is kept so there is no refcount restriction. */\n+      if ((firstChild->getOpCodeValue() != TR::aload) && (firstChild->getOpCodeValue() != TR::aloadi))\n+         {\n+         return false;\n+         }\n+\n+      /*\n+       * aiadd's second child can be an iconst, iadd or isub. The iadd or isub might go away after transformation\n+       * so they must have a refCount of 1.\n+       */\n+      if (secondChild->getReferenceCount() != 1)\n+         {\n+         if (secondChild->getOpCodeValue() != TR::iconst)\n+            {\n+            return false;\n+            }\n+         }\n+      else\n+         {\n+         if ((secondChild->getOpCodeValue() != TR::iconst) &&\n+             (secondChild->getOpCodeValue() != TR::iadd)   &&\n+             (secondChild->getOpCodeValue() != TR::isub))\n+            {\n+            return false;\n+            }\n+         }\n+\n+      /* If the second child is isub or iadd, make sure that node's second child is an iconst. */\n+      if (secondChild->getOpCodeValue() != TR::iconst)\n+         {\n+         secondChild = secondChild->getSecondChild();\n+\n+         if (secondChild->getOpCodeValue() != TR::iconst)\n+            {\n+            return false;\n+            }\n+         }\n       }\n \n+   return true;\n    }\n \n-int64_t TR_arraycopySequentialStores::constVal()\n+int64_t getOffsetForSeqLoad(TR::Compilation* comp, TR::Node* byteConversionNode)\n    {\n-   int dir;\n-   int baseShift;\n-   uint64_t val = 0;\n+   /*\n+    * Returns the constant offset from basePointerNode. Offset from aload/aloadi if there is no basePointerNode.\n+    * byteConversionNode must be: b2i, b2l, bu2i, bu2l\n+    *\n+    * Example tree: (sub/add version)\n+    * b2i        <--- byteConversionNode\n+    *   bloadi\n+    *     aladd\n+    *       aload/aloadi\n+    *       lsub/ladd     <<--- displacementNode\n+    *         **basePointerNode**\n+    *         lconst      <<--- return value\n+    *\n+    *\n+    * Example tree: (const version)\n+    * b2i        <--- byteConversionNode\n+    *   bloadi\n+    *     aladd\n+    *       aload/aloadi\n+    *       lconst        <<--- displacementNode, return value\n+    */\n \n-   if (_bigEndian)\n+\n+   if ((byteConversionNode->getOpCodeValue() != TR::b2i) && (byteConversionNode->getOpCodeValue() != TR::bu2i) &&\n+       (byteConversionNode->getOpCodeValue() != TR::b2l) && (byteConversionNode->getOpCodeValue() != TR::bu2l)\n+      )\n       {\n-      dir = -1;\n-      baseShift = (_numBytes-1)*8;\n+      TR_ASSERT_FATAL_WITH_NODE(byteConversionNode, 0, \"Unsupported opCode. This should have been caught earlier. byteConversionNode: %p.\", byteConversionNode);\n       }\n-   else\n+\n+   TR::Node* displacementNode = byteConversionNode->getFirstChild()->getFirstChild()->getSecondChild();\n+\n+   if (comp->target().is64Bit())\n       {\n-      dir = 1;\n-      baseShift = 0;\n+      if (displacementNode->getOpCodeValue() == TR::lconst)\n+         {\n+         return displacementNode->getLongInt();\n+         }\n+      else if (displacementNode->getOpCodeValue() == TR::lsub)\n+         {\n+         return displacementNode->getSecondChild()->getLongInt() * -1;\n+         }\n+      else //displacementNode->getOpCodeValue() == TR::ladd\n+         {\n+         return displacementNode->getSecondChild()->getLongInt();\n+         }\n       }\n-\n-   for (int entry=0; entry < _numBytes; ++entry)\n+   else\n       {\n-      uint64_t curVal = 0;\n-      switch (_val[entry]->getValNode()->getOpCodeValue())\n+      if (displacementNode->getOpCodeValue() == TR::iconst)\n          {\n-         case TR::bconst: curVal = (uint64_t) (_val[entry]->getValNode()->getByte() & 0xFF); break;\n-         case TR::sconst: curVal = (uint64_t) (_val[entry]->getValNode()->getShortInt() & 0xFF); break;\n-         case TR::iconst: curVal = (uint64_t) (_val[entry]->getValNode()->getInt() & 0xFF); break;\n-         case TR::lconst: curVal = (uint64_t) (_val[entry]->getValNode()->getLongInt() & 0xFF); break;\n-         default: break;\n+         return displacementNode->getInt();\n+         }\n+      else if (displacementNode->getOpCodeValue() == TR::isub)\n+         {\n+         return displacementNode->getSecondChild()->getInt() * -1;\n+         }\n+      else //displacementNode->getOpCodeValue() == TR::iadd\n+         {\n+         return displacementNode->getSecondChild()->getInt();\n          }\n-      curVal = curVal << (baseShift + dir*8*entry);\n-      val |= curVal;\n       }\n-   return (int64_t)val;\n    }\n \n-TR::Node* TR_arraycopySequentialStores::constValNode()\n+TR::Node* getBasePointerReferenceForSeqLoad(TR::Node* inputNode)\n    {\n-   TR::Node* rootNode = getAddrTree()->getRootNode();\n-   TR::Node* node = NULL;\n+   /*\n+    * Returns the basePointerNode. Returns NULL if there is no basePointerNode.\n+    * inputNode is a child of a combine node that is not also a combine node.\n+    * Combine nodes are the add/or nodes that construct the longer value out of seperate loaded bytes.\n+    *\n+    * Example tree: (sub/add version)\n+    * b2i        <--- inputNode\n+    *   bloadi\n+    *     aladd\n+    *       aload/aloadi\n+    *       lsub/ladd     <<--- displacementNode\n+    *         **basePointerNode**  <<--- return basePointerNode (search down past any conversion nodes, if any)\n+    *         lconst\n+    *\n+    *\n+    * Example tree: (const version)\n+    * b2i        <--- inputNode\n+    *   bloadi\n+    *     aladd\n+    *       aload/aloadi\n+    *       lconst        <<--- displacementNode, return NULL\n+    */\n \n-   switch (_numBytes)\n+\n+   TR::Node* basePointerNode = NULL;\n+   TR::Node* displacementNode = NULL;\n+\n+   switch (inputNode->getOpCodeValue())\n       {\n-      case 1: node = TR::Node::bconst(rootNode,(int8_t) constVal()); break;\n-      case 2: node = TR::Node::sconst(rootNode,(int16_t) constVal()); break;\n-      case 4: node = TR::Node::create(rootNode, TR::iconst); node->setInt((int32_t) constVal()); break;\n-      case 8: node = TR::Node::create(rootNode, TR::lconst); node->setLongInt(constVal()); break;\n-      default: TR_ASSERT(false, \"const val node has invalid number of bytes\"); break;\n+      case TR::iand:\n+      case TR::imul:\n+      case TR::ishl:\n+      case TR::land:\n+      case TR::lmul:\n+      case TR::lshl:\n+         /* Keep searching down for the b2i node. */\n+         basePointerNode = getBasePointerReferenceForSeqLoad(inputNode->getFirstChild());\n+         break;\n+      case TR::b2i:\n+      case TR::b2l:\n+      case TR::bu2i:\n+      case TR::bu2l:\n+         displacementNode = inputNode->getFirstChild()->getFirstChild()->getSecondChild();\n+         if ((displacementNode->getOpCodeValue() == TR::iconst) || (displacementNode->getOpCodeValue() == TR::lconst))\n+            {\n+            basePointerNode = NULL;\n+            break;\n+            }\n+         basePointerNode = displacementNode->getFirstChild()->skipConversions();\n+         break;\n+      default:\n+         TR_ASSERT_FATAL_WITH_NODE(inputNode, 0, \"Unsupported opCode. This should have been caught earlier. inputNode: %p.\", inputNode);\n+         break;\n       }\n-   return node;\n-   }\n \n-// Transform a set of sequential stores into increasing storage from an integral type into\n-// an arraycopy call\n-// Order varies depending if on Big Endian or Little Endian target hardware\n-// ibstore <array element>\n-//   aiadd\n-//     aload <arr>\n-//     isub\n-//       iload <var>\n-//       iconst -<base> - <offset> - <element>\n-//   i2b [node cannot overflow]\n-//       iushr [node >= 0] [node cannot overflow] <iushr disappears when <element> == sizeof(value) - 1>\n-//         iload <value>\n-//         iconst (sizeof(<value>) - <element> + 1)*8 (sizeof(<value>) == 1,2,4,8) [Big Endian]\n-//          -or-\n-//         iconst (<element> + 1)*8 (sizeof(<value>) == 1,2,4,8)                   [Little Endian]\n-//\n+   return basePointerNode;\n+   }\n \n-static TR::TreeTop* generateArraycopyFromSequentialStores(TR::Compilation* comp, TR::TreeTop* prevTreeTop, TR::TreeTop* istoreTreeTop, TR::Node* istoreNode)\n+int64_t getMultValueForSeqLoad(TR::Node* inputNode)\n    {\n-   TR::CodeGenerator* codeGen = comp->cg();\n+   /*\n+    * Returns the value a byte is multiplied by before being combined with the other bytes.\n+    * The purpose of this multiplication is to shift the byte into the right place.\n+    * If inputNode is a mul node, return the const on the second child.\n+    * If it is a shl node instead, the shift value is converted to a mul value before being returned.\n+    * If it is not mul or shift, the multValue is 1.\n+    *\n+    * inputNode is a child of a combine node that is not also a combine node.\n+    * Combine nodes are the add/or nodes that construct the longer value out of seperate loaded bytes.\n+    */\n \n-   TR_arraycopySequentialStores arraycopy = TR_arraycopySequentialStores(comp);\n-   TR::Node* curNode = istoreNode;\n-   TR::TreeTop* curTreeTop = istoreTreeTop;\n-   while (\n-          arraycopy.numTrees() < arraycopy.maxNumTrees() &&\n-          arraycopy.checkIStore(curNode) &&\n-          arraycopy.checkALoadValue(curNode->getSecondChild()) &&\n-          arraycopy.checkAiadd(curTreeTop, curNode->getFirstChild())\n-         )\n-      {\n-      curTreeTop = curTreeTop->getNextTreeTop();\n-      curNode    = curTreeTop->getNode();\n-      }\n+   int64_t multValue = 0;\n \n-   if (!arraycopy.checkTrees())\n+   switch (inputNode->getOpCodeValue())\n       {\n-      return istoreTreeTop;\n+      case TR::imul:\n+         multValue = inputNode->getSecondChild()->getInt();\n+         break;\n+      case TR::lmul:\n+         multValue = inputNode->getSecondChild()->getLongInt();\n+         break;\n+      case TR::ishl:\n+      case TR::lshl:\n+         multValue = 1L << (inputNode->getSecondChild()->getInt());\n+         break;\n+      case TR::b2i:\n+      case TR::b2l:\n+      case TR::bu2i:\n+      case TR::bu2l:\n+      case TR::iand:\n+      case TR::land:\n+         multValue = 1;\n+         break;\n+      default:\n+         TR_ASSERT_FATAL_WITH_NODE(inputNode, 0, \"Unsupported opCode. This should have been caught earlier. inputNode: %p.\", inputNode);\n+         break;\n       }\n \n-   int32_t numBytes = arraycopy.getNumBytes();\n-   if (numBytes == 1)\n-      {\n-      dumpOptDetails(comp, \" Sequential Store of 1 byte not worth reducing\\n\");\n-      return istoreTreeTop;\n-      }\n-   else if (numBytes != 2 && numBytes != 4 && numBytes != 8)\n-      {\n-      dumpOptDetails(comp, \" Sequential Store of size other than 2/4/8 not reducible\\n\");\n-      return istoreTreeTop;\n-      }\n+   return multValue;\n+   }\n \n-   int32_t loadSize = arraycopy.getVal()->getValueSize();\n-   if (!arraycopy.hasConstValue() && (loadSize != numBytes))\n-      {\n-      dumpOptDetails(comp, \" Sequential Store of size different than trees (%d,%d) not supported yet\\n\", loadSize, numBytes);\n-      return istoreTreeTop;\n-      }\n+TR::Node* getALoadReferenceForSeqLoad(TR::Node* inputNode)\n+   {\n+   /*\n+    * Returns the node that loads the address of the byte array.\n+    * inputNode is a child of a combine node that is not also a combine node.\n+    * Combine nodes are the add/or nodes that construct the longer value out of seperate loaded bytes.\n+    *\n+    * Example tree:\n+    * b2i        <--- inputNode\n+    *   bloadi\n+    *     aladd\n+    *       aload/aloadi  <<--- aloadNode\n+    *       lsub/ladd\n+    *         **basePointerNode**\n+    *         lconst\n+    */\n \n-   if(codeGen->getSupportsAlignedAccessOnly() &&\n-      ((arraycopy.getAddrTree()->getOffset() % numBytes) != 0))\n+\n+   TR::Node* aloadNode = NULL;\n+\n+   switch (inputNode->getOpCodeValue())\n       {\n-      dumpOptDetails(comp, \" Sequential Store of %d bytes at offset %d would have caused unaligned memory access\\n\", numBytes, arraycopy.getAddrTree()->getOffset());\n-      return istoreTreeTop;\n+      case TR::iand:\n+      case TR::imul:\n+      case TR::ishl:\n+      case TR::land:\n+      case TR::lmul:\n+      case TR::lshl:\n+         /* Keep searching down for the b2i node. */\n+         aloadNode = getALoadReferenceForSeqLoad(inputNode->getFirstChild());\n+         break;\n+      case TR::b2i:\n+      case TR::b2l:\n+      case TR::bu2i:\n+      case TR::bu2l:\n+         aloadNode = inputNode->getFirstChild()->getFirstChild()->getFirstChild();\n+         break;\n+      default:\n+         TR_ASSERT_FATAL_WITH_NODE(inputNode, 0, \"Unsupported opCode. This should have been caught earlier. inputNode: %p.\", inputNode);\n+         break;\n       }\n \n-   if (!performTransformation(comp, \"%sReducing arraycopy sequential stores\\n\", OPT_DETAILS))\n-      return istoreTreeTop;\n-\n-   dumpOptDetails(comp, \" Load Node:%p Number of bytes: %d\\n\", istoreNode, numBytes);\n+   return aloadNode;\n+   }\n \n-   TR::SymbolReference *symRef = comp->getSymRefTab()->findOrCreateGenericIntShadowSymbolReference(0);\n-   // propagate the offset of the symbol reference\n-   symRef->setOffset(arraycopy.getTreeTop()->getNode()->getSymbolReference()->getOffset());\n+TR::Node* getByteConversionNodeForSeqLoad(TR::Node* inputNode)\n+   {\n+   /*\n+    * Returns the byte conversion node.\n+    * inputNode is a child of a combine node that is not also a combine node.\n+    * Combine nodes are the add/or nodes that construct the longer value out of seperate loaded bytes.\n+    *\n+    * Example tree:\n+    * b2i        <--- inputNode, byteConversionNode\n+    *   bloadi\n+    *     aladd\n+    *       aload/aloadi\n+    *       lsub/ladd\n+    *         **basePointerNode**\n+    *         lconst\n+    */\n \n-   //\n-   // delete the ibstore trees and replace them with a new, improved iXstore tree\n-   //\n-   arraycopy.removeTrees(symRef);\n \n-   TR::Node* aiaddNode = arraycopy.getAddrTree()->getRootNode(); //->duplicateTree();\n-   TR::Node* loadNode;\n+   TR::Node* byteConversionNode = NULL;\n \n-   if (arraycopy.hasConstValue())\n-      {\n-      loadNode = arraycopy.constValNode();\n-      }\n-   else\n+   switch (inputNode->getOpCodeValue())\n       {\n-      loadNode = arraycopy.getVal()->getValNode(); // ->duplicateTree();\n+      case TR::iand:\n+      case TR::imul:\n+      case TR::ishl:\n+      case TR::land:\n+      case TR::lmul:\n+      case TR::lshl:\n+         /* Keep searching down for the b2i node. */\n+         byteConversionNode = getByteConversionNodeForSeqLoad(inputNode->getFirstChild());\n+         break;\n+      case TR::b2i:\n+      case TR::b2l:\n+      case TR::bu2i:\n+      case TR::bu2l:\n+         byteConversionNode = inputNode;\n+         break;\n+      default:\n+         TR_ASSERT_FATAL_WITH_NODE(inputNode, 0, \"Unsupported opCode. This should have been caught earlier. inputNode: %p.\", inputNode);\n+         break;\n       }\n \n-   TR::ILOpCodes opcode;\n-   TR::ILOpCodes byteswapOpcode;\n+   return byteConversionNode;\n+   }\n \n-   // create a load/store of the right size\n-   switch(numBytes)\n-      {\n-      case 2: opcode = TR::sstorei; byteswapOpcode = TR::sbyteswap; break;\n-      case 4: opcode = TR::istorei; byteswapOpcode = TR::ibyteswap; break;\n-      case 8: opcode = TR::lstorei; byteswapOpcode = TR::lbyteswap; break;\n-      default: TR_ASSERT(0, \" number of bytes unexpected\\n\"); break;\n-      }\n+bool checkForSeqLoadSignExtendedByte(TR::Node* inputNode)\n+   {\n+   /*\n+    * Checks if the loaded byte needs to be sign extended or not.\n+    * If bu2i/bu2l nodes are used, the loaded byte is unsigned.\n+    * If iand/land nodes are used, the loaded byte was masked with 0xFF and is treated as unsigned.\n+    * If b2i/b2l nodes are used, the loaded byte is signed. If it is the most significant byte, it will need to\n+    * be sign extended later. If it isn't the most significant byte, the transformation will bail out since the\n+    * sign bits may interfere with the other loaded bytes.\n+    *\n+    * inputNode is a child of a combine node that is not also a combine node.\n+    * Combine nodes are the add/or nodes that construct the longer value out of seperate loaded bytes.\n+    *\n+    * Example tree:\n+    * iand     <--- inputNode\n+    *   b2i\n+    *     bloadi\n+    *       aladd\n+    *         aload/aloadi\n+    *         lsub/ladd\n+    *           **basePointerNode**\n+    *           lconst\n+    *   iconst 0xFF\n+    */\n \n-   if (arraycopy.alternateDir())\n-      {\n-      loadNode = TR::Node::create(byteswapOpcode, 1, loadNode);\n-      }\n \n-   TR::Node* iXstoreNode = TR::Node::createWithSymRef(opcode, 2, 2, aiaddNode, loadNode, symRef);\n-   TR::TreeTop* treeTop = TR::TreeTop::create(comp, iXstoreNode);\n-   TR::TreeTop* nextTreeTop = prevTreeTop->getNextTreeTop();\n+   bool signExtendedByte = false;\n \n-   prevTreeTop->join(treeTop);\n-   treeTop->join(nextTreeTop);\n+   switch (inputNode->getOpCodeValue())\n+      {\n+      case TR::imul:\n+      case TR::ishl:\n+      case TR::lmul:\n+      case TR::lshl:\n+         /* Keep searching down for the b2i/and node. */\n+         signExtendedByte = checkForSeqLoadSignExtendedByte(inputNode->getFirstChild());\n+         break;\n+      case TR::bu2i:\n+      case TR::bu2l:\n+      case TR::iand:\n+      case TR::land:\n+         signExtendedByte = false;\n+         break;\n+      case TR::b2i:\n+      case TR::b2l:\n+         signExtendedByte = true;\n+         break;\n+      default:\n+         TR_ASSERT_FATAL_WITH_NODE(inputNode, 0, \"Unsupported opCode. This should have been caught earlier. inputNode: %p.\", inputNode);\n+         break;\n+      }\n \n-   return treeTop;\n+   return signExtendedByte;\n    }\n \n-static TR::TreeTop* generateArraycopyFromSequentialLoads(TR::Compilation* comp, TR::TreeTop* currentTreeTop, TR::Node* ibloadNode)\n+bool matchLittleEndianSeqLoadPattern(int64_t byteOffsets[], int32_t byteCount)\n    {\n+   /*\n+    * byteOffsets array contains relative locations that each byte is loaded from.\n+    * byteCount is the total number of bytes.\n+    * byteOffsets[0] is the offset of the least significant byte.\n+    * byteOffsets[byteCount-1] is the offset of the most significant byte.\n+    * To be an LE load, the offset needs to go UP by exactly 1 when going from 0 to (byteCount-1).\n+    */\n+   int64_t currentByteOffset = byteOffsets[0];\n \n-   static const char * disableSeqLoadOpt = feGetEnv(\"TR_DisableSeqLoadOpt\");\n+   for (int i = 1; i < byteCount; i++)\n+      {\n+      if (byteOffsets[i] != (currentByteOffset + 1))\n+         {\n+         return false;\n+         }\n+      currentByteOffset = byteOffsets[i];\n+      }\n+\n+   return true;\n+   }\n+\n+bool matchBigEndianSeqLoadPattern(int64_t byteOffsets[], int32_t byteCount)\n+   {\n+   /*\n+    * byteOffsets array contains relative locations that each byte is loaded from.\n+    * byteCount is the total number of bytes.\n+    * byteOffsets[0] is the offset of the least significant byte.\n+    * byteOffsets[byteCount-1] is the offset of the most significant byte.\n+    * To be an BE load, the offset needs to go DOWN by exactly 1 when going from 0 to (byteCount-1).\n+    */\n+   int64_t currentByteOffset = byteOffsets[0];\n+\n+   for (int i = 1; i < byteCount; i++)\n+      {\n+      if (byteOffsets[i] != (currentByteOffset - 1))\n+         {\n+         return false;\n+         }\n+      currentByteOffset = byteOffsets[i];\n+      }\n+\n+   return true;\n+   }\n+\n+bool TR_ShiftedValueTree::process(TR::Node* loadNode)\n+   {\n+\n+   bool shift = true;\n+   TR::ILOpCodes convCode = loadNode->getOpCodeValue();\n+   TR::ILOpCodes shiftCode, altShiftCode, constCode;\n+   int32_t size;\n+\n+   _isConst = false;\n+   switch(convCode)\n+      {\n+      case TR::s2b: shift = true;  _valueSize = 2; shiftCode = TR::sushr; altShiftCode = TR::sshr; constCode = TR::iconst; break;\n+      case TR::i2b: shift = true;  _valueSize = 4; shiftCode = TR::iushr; altShiftCode = TR::ishr; constCode = TR::iconst; break;\n+      case TR::l2b: shift = true;  _valueSize = 8; shiftCode = TR::lushr; altShiftCode = TR::lshr; constCode = TR::iconst; break;\n+      case TR::bload:\n+      case TR::bconst:\n+      case TR::sconst:\n+      case TR::iconst:\n+      case TR::lconst: shift = false; _valueSize = 1; _shiftValue = 0; break;\n+      default: return false;\n+      }\n+\n+//   dumpOptDetails(comp(), \"arraycopy sequential store - check load node %p\\n\", loadNode);\n+\n+   if (shift)\n+      {\n+      if (loadNode->getFirstChild()->getOpCodeValue() != shiftCode && loadNode->getFirstChild()->getOpCodeValue() != altShiftCode)\n+         {\n+         _valNode = loadNode->getFirstChild();\n+         _shiftValue = 0;\n+         }\n+      else\n+         {\n+         TR::Node* shiftVal = loadNode->getFirstChild()->getSecondChild();\n+         if (shiftVal->getOpCodeValue() != constCode)\n+            {\n+            dumpOptDetails(comp(), \" Shifted Value: did not encounter correct const code\\n\");\n+            return false;\n+            }\n+         _valNode = loadNode->getFirstChild()->getFirstChild();\n+         switch(constCode)\n+            {\n+            case TR::sconst: _shiftValue = shiftVal->getShortInt(); break;\n+            case TR::iconst: _shiftValue = shiftVal->getInt(); break;\n+            case TR::lconst: _shiftValue = shiftVal->getLongInt(); break;\n+            default: break;\n+            }\n+         }\n+      }\n+   else\n+      {\n+      _valNode = loadNode;\n+      if (convCode != TR::bload)\n+         {\n+         _isConst = true;\n+         }\n+      }\n+\n+   if ((_shiftValue % 8) != 0 || (_shiftValue < 0) || (_shiftValue >= _valueSize*8))\n+      {\n+      dumpOptDetails(comp(), \"Shifted Value: did not encounter valid shift value %d for var size %d\\n\", _shiftValue, _valueSize);\n+      return false;\n+      }\n+\n+   _rootNode = loadNode;\n+\n+   return true;\n+   }\n+\n+bool TR_arraycopySequentialStores::checkAiadd(TR::TreeTop * currentTree, TR::Node* aiaddNode)\n+   {\n+//   dumpOptDetails(comp(), \"arraycopy sequential store - check aiadd node %p\\n\", aiaddNode);\n+   _activeAddrTree = new (trStackMemory()) TR_AddressTree(stackAlloc, comp());\n+   _activeTreeTop = currentTree;\n+   if (_activeAddrTree->process(aiaddNode, _comp->cg()->getSupportsAlignedAccessOnly()))\n+      {\n+      return insertConsistentTree();\n+      }\n+   return false;\n+   }\n+\n+void TR_arraycopySequentialStores::insertTree(int entry)\n+   {\n+//   dumpOptDetails(comp(), \" insert nodes %p,%p into entry %d\\n\",\n+//      _activeAddrTree->getRootNode(), _activeValueTree->getRootNode(), entry);\n+   if ((_addrTree[entry] != NULL) && (entry < _maxAddressTrees))\n+      {\n+      memmove(&_addrTree[entry+1], &_addrTree[entry], (_maxAddressTrees-entry-1)*sizeof(TR_AddressTree*));\n+      memmove(&_val[entry+1], &_val[entry],  (_maxAddressTrees-entry-1)*sizeof(TR_ShiftedValueTree*));\n+      memmove(&_treeTops[entry+1], &_treeTops[entry], (_maxAddressTrees-entry-1)*sizeof(TR::TreeTop*));\n+      }\n+   _addrTree[entry] = _activeAddrTree;\n+   _val[entry] = _activeValueTree;\n+   _treeTops[entry] = _activeTreeTop;\n+   }\n+\n+bool TR_arraycopySequentialStores::insertConsistentTree()\n+   {\n+\n+   // these are byte arrays we are working with - the multiplier must be 1\n+   if (_activeAddrTree->getMultiplier() != 1)\n+      {\n+      dumpOptDetails(comp(), \" insertTree: multiplier must be 1 in aiadd tree\\n\");\n+      return false;\n+      }\n+   TR::SymbolReference* activeBaseRef = _activeAddrTree->getBaseVarNode()->isNull() ? NULL : _activeAddrTree->getBaseVarNode()->getChild()->skipConversions()->getSymbolReference();\n+   if (activeBaseRef == NULL)\n+      {\n+      dumpOptDetails(comp(), \" insertTree: no base variable in aiadd tree\\n\");\n+      return false;\n+      }\n+\n+   if (_addrTree[0] == NULL)\n+      {\n+//      dumpOptDetails(comp(), \" insertTree: first tree inserted successfully with offset: %d\\n\", _activeAddrTree->getOffset());\n+      insertTree(0);\n+      return true;\n+      }\n+\n+   // make sure the index variable and base variable is consistent with the first tree\n+   TR::SymbolReference* baseRef = _addrTree[0]->getBaseVarNode()->isNull() ? NULL : _addrTree[0]->getBaseVarNode()->getChild()->skipConversions()->getSymbolReference();\n+   if (baseRef != activeBaseRef)\n+      {\n+      dumpOptDetails(comp(), \" insertTree: base variable is different than previous tree\\n\");\n+      return false;\n+      }\n+\n+   TR::SymbolReference* indRef = _addrTree[0]->getIndVarNode()->isNull() ? NULL : _addrTree[0]->getIndVarNode()->getChild()->skipConversions()->getSymbolReference();\n+   TR::SymbolReference* activeIndRef = _activeAddrTree->getIndVarNode()->isNull() ? NULL : _activeAddrTree->getIndVarNode()->getChild()->skipConversions()->getSymbolReference();\n+\n+   TR::Node* indBase = NULL;\n+   TR::Node* activeIndBase = NULL;\n+   if (!_addrTree[0]->getIndexBase()->isNull())\n+      indBase = _addrTree[0]->getIndexBase()->getParent();\n+   if (!_activeAddrTree->getIndexBase()->isNull())\n+      activeIndBase = _activeAddrTree->getIndexBase()->getParent();\n+\n+   if (indRef != activeIndRef || indBase != activeIndBase)\n+      {\n+      dumpOptDetails(comp(), \" insertTree: index variable is different than previous tree\\n\");\n+      return false;\n+      }\n+\n+   // make sure the value being loaded is consistent with the first tree\n+   if (_val[0]->isConst() !=  _activeValueTree->isConst())\n+      {\n+      dumpOptDetails(comp(), \" insertTree: const value attributes inconsistent\\n\");\n+      return false;\n+      }\n+\n+   if (!_val[0]->isConst() && (_val[0]->getValNode() != _activeValueTree->getValNode()))\n+      {\n+      dumpOptDetails(comp(), \" insertTree: value variable is different than previous tree\\n\");\n+      return false;\n+      }\n+\n+   // make sure the value tree doesn't reference the address tree base var\n+   if (_activeValueTree->getRootNode()->referencesSymbolInSubTree(baseRef, _comp->incOrResetVisitCount()))\n+      {\n+      dumpOptDetails(comp(), \" insertTree: value tree %p references address tree base var\\n\", _activeValueTree->getRootNode());\n+      return false;\n+      }\n+\n+//   dumpOptDetails(comp(), \" insertTree: tree inserted successfully. offset:%d\\n\", _activeAddrTree->getOffset());\n+   int entry;\n+   for (entry=0; entry < _maxAddressTrees && _addrTree[entry] != NULL; ++entry)\n+      {\n+      if (_activeAddrTree->getOffset() < _addrTree[entry]->getOffset())\n+         {\n+         insertTree(entry);\n+         return true;\n+         }\n+      }\n+\n+   insertTree(entry);\n+   return true;\n+   }\n+\n+\n+int TR_arraycopySequentialStores::numTrees()\n+   {\n+   int i;\n+   for (i=0; i<_maxAddressTrees; ++i)\n+      {\n+      if (_addrTree[i] == NULL)\n+         return i;\n+      }\n+   return _maxAddressTrees;\n+   }\n+\n+int TR_arraycopySequentialStores::numValidTrees(int maxEntries)\n+   {\n+   int dir = (_bigEndian) ? -1 : 1;\n+   int entry;\n+\n+//   dumpOptDetails(comp(), \"...check if valid entries\\n\");\n+   for (entry=1; (_addrTree[entry] != NULL) && (entry < maxEntries); ++entry)\n+      {\n+      if (_addrTree[entry]->getOffset() != _addrTree[0]->getOffset() + entry)\n+         {\n+         break;\n+         }\n+      if (!hasConstValue() && (_val[entry]->getShiftValue() != _val[0]->getShiftValue() + dir*8*entry))\n+         {\n+         break;\n+         }\n+      }\n+   if ((entry == 1) && !hasConstValue() && _comp->cg()->supportsByteswap())\n+      {\n+//      dumpOptDetails(comp(), \"...no valid entries forward\\n...see if reverse store finds any entries\\n\");\n+      _alternateDir = true;\n+      // repeat process for reversed store\n+      dir = (_bigEndian) ? 1 : -1;\n+      for (entry=1; (_addrTree[entry] != NULL) && (entry < maxEntries); ++entry)\n+         {\n+         if (_addrTree[entry]->getOffset() != _addrTree[0]->getOffset() + entry)\n+            {\n+            break;\n+            }\n+         if (_val[entry]->getShiftValue() != _val[0]->getShiftValue() + dir*8*entry)\n+            {\n+            break;\n+            }\n+         }\n+      }\n+   if (entry > 1)\n+      {\n+      dumpOptDetails(comp(), \"Found %d sequential valid trees\\n\", entry);\n+      }\n+   return entry;\n+   }\n+\n+bool TR_arraycopySequentialStores::checkTrees()\n+   {\n+   if (_val[0] == NULL)\n+      {\n+      return false;\n+      }\n+\n+   if (hasConstValue())\n+      {\n+      _numBytes = numValidTrees();\n+      }\n+   else\n+      {\n+      _numBytes = numValidTrees(_val[0]->getValueSize());\n+      }\n+\n+   return (_numBytes == 2 || _numBytes == 4 || _numBytes == 8);\n+   }\n+\n+void TR_arraycopySequentialStores::removeTrees(TR::SymbolReference * symRef)\n+   {\n+   TR::SparseBitVector fromAliases(_comp->allocator(\"SCSS bitvector\"));\n+\n+   for (int32_t i = 0; i < _numBytes; ++i)\n+      {\n+      dumpOptDetails(_comp, \" Remove trees %p to %p\\n\", _treeTops[i]->getNode(), _treeTops[i]->getNextTreeTop()->getNode());\n+      TR::TreeTop::removeDeadTrees(_comp, _treeTops[i], _treeTops[i]->getNextTreeTop());\n+      }\n+\n+   }\n+\n+int64_t TR_arraycopySequentialStores::constVal()\n+   {\n+   int dir;\n+   int baseShift;\n+   uint64_t val = 0;\n+\n+   if (_bigEndian)\n+      {\n+      dir = -1;\n+      baseShift = (_numBytes-1)*8;\n+      }\n+   else\n+      {\n+      dir = 1;\n+      baseShift = 0;\n+      }\n+\n+   for (int entry=0; entry < _numBytes; ++entry)\n+      {\n+      uint64_t curVal = 0;\n+      switch (_val[entry]->getValNode()->getOpCodeValue())\n+         {\n+         case TR::bconst: curVal = (uint64_t) (_val[entry]->getValNode()->getByte() & 0xFF); break;\n+         case TR::sconst: curVal = (uint64_t) (_val[entry]->getValNode()->getShortInt() & 0xFF); break;\n+         case TR::iconst: curVal = (uint64_t) (_val[entry]->getValNode()->getInt() & 0xFF); break;\n+         case TR::lconst: curVal = (uint64_t) (_val[entry]->getValNode()->getLongInt() & 0xFF); break;\n+         default: break;\n+         }\n+      curVal = curVal << (baseShift + dir*8*entry);\n+      val |= curVal;\n+      }\n+   return (int64_t)val;\n+   }\n+\n+TR::Node* TR_arraycopySequentialStores::constValNode()\n+   {\n+   TR::Node* rootNode = getAddrTree()->getRootNode();\n+   TR::Node* node = NULL;\n+\n+   switch (_numBytes)\n+      {\n+      case 1: node = TR::Node::bconst(rootNode,(int8_t) constVal()); break;\n+      case 2: node = TR::Node::sconst(rootNode,(int16_t) constVal()); break;\n+      case 4: node = TR::Node::create(rootNode, TR::iconst); node->setInt((int32_t) constVal()); break;\n+      case 8: node = TR::Node::create(rootNode, TR::lconst); node->setLongInt(constVal()); break;\n+      default: TR_ASSERT(false, \"const val node has invalid number of bytes\"); break;\n+      }\n+   return node;\n+   }\n+\n+// Transform a set of sequential stores into increasing storage from an integral type into\n+// an arraycopy call\n+// Order varies depending if on Big Endian or Little Endian target hardware\n+// ibstore <array element>\n+//   aiadd\n+//     aload <arr>\n+//     isub\n+//       iload <var>\n+//       iconst -<base> - <offset> - <element>\n+//   i2b [node cannot overflow]\n+//       iushr [node >= 0] [node cannot overflow] <iushr disappears when <element> == sizeof(value) - 1>\n+//         iload <value>\n+//         iconst (sizeof(<value>) - <element> + 1)*8 (sizeof(<value>) == 1,2,4,8) [Big Endian]\n+//          -or-\n+//         iconst (<element> + 1)*8 (sizeof(<value>) == 1,2,4,8)                   [Little Endian]\n+//\n+\n+static TR::TreeTop* generateArraycopyFromSequentialStores(TR::Compilation* comp, TR::TreeTop* prevTreeTop, TR::TreeTop* istoreTreeTop, TR::Node* istoreNode)\n+   {\n+   TR::CodeGenerator* codeGen = comp->cg();\n+\n+   TR_arraycopySequentialStores arraycopy = TR_arraycopySequentialStores(comp);\n+   TR::Node* curNode = istoreNode;\n+   TR::TreeTop* curTreeTop = istoreTreeTop;\n+   while (\n+          arraycopy.numTrees() < arraycopy.maxNumTrees() &&\n+          arraycopy.checkIStore(curNode) &&\n+          arraycopy.checkALoadValue(curNode->getSecondChild()) &&\n+          arraycopy.checkAiadd(curTreeTop, curNode->getFirstChild())\n+         )\n+      {\n+      curTreeTop = curTreeTop->getNextTreeTop();\n+      curNode    = curTreeTop->getNode();\n+      }\n+\n+   if (!arraycopy.checkTrees())\n+      {\n+      return istoreTreeTop;\n+      }\n+\n+   int32_t numBytes = arraycopy.getNumBytes();\n+   if (numBytes == 1)\n+      {\n+      dumpOptDetails(comp, \" Sequential Store of 1 byte not worth reducing\\n\");\n+      return istoreTreeTop;\n+      }\n+   else if (numBytes != 2 && numBytes != 4 && numBytes != 8)\n+      {\n+      dumpOptDetails(comp, \" Sequential Store of size other than 2/4/8 not reducible\\n\");\n+      return istoreTreeTop;\n+      }\n+\n+   int32_t loadSize = arraycopy.getVal()->getValueSize();\n+   if (!arraycopy.hasConstValue() && (loadSize != numBytes))\n+      {\n+      dumpOptDetails(comp, \" Sequential Store of size different than trees (%d,%d) not supported yet\\n\", loadSize, numBytes);\n+      return istoreTreeTop;\n+      }\n+\n+   if(codeGen->getSupportsAlignedAccessOnly() &&\n+      ((arraycopy.getAddrTree()->getOffset() % numBytes) != 0))\n+      {\n+      dumpOptDetails(comp, \" Sequential Store of %d bytes at offset %d would have caused unaligned memory access\\n\", numBytes, arraycopy.getAddrTree()->getOffset());\n+      return istoreTreeTop;\n+      }\n+\n+   if (!performTransformation(comp, \"%sReducing arraycopy sequential stores\\n\", OPT_DETAILS))\n+      return istoreTreeTop;\n+\n+   dumpOptDetails(comp, \" Load Node:%p Number of bytes: %d\\n\", istoreNode, numBytes);\n+\n+   TR::SymbolReference *symRef = comp->getSymRefTab()->findOrCreateGenericIntShadowSymbolReference(0);\n+   // propagate the offset of the symbol reference\n+   symRef->setOffset(arraycopy.getTreeTop()->getNode()->getSymbolReference()->getOffset());\n+\n+   //\n+   // delete the ibstore trees and replace them with a new, improved iXstore tree\n+   //\n+   arraycopy.removeTrees(symRef);\n+\n+   TR::Node* aiaddNode = arraycopy.getAddrTree()->getRootNode(); //->duplicateTree();\n+   TR::Node* loadNode;\n+\n+   if (arraycopy.hasConstValue())\n+      {\n+      loadNode = arraycopy.constValNode();\n+      }\n+   else\n+      {\n+      loadNode = arraycopy.getVal()->getValNode(); // ->duplicateTree();\n+      }\n+\n+   TR::ILOpCodes opcode;\n+   TR::ILOpCodes byteswapOpcode;\n+\n+   // create a load/store of the right size\n+   switch(numBytes)\n+      {\n+      case 2: opcode = TR::sstorei; byteswapOpcode = TR::sbyteswap; break;\n+      case 4: opcode = TR::istorei; byteswapOpcode = TR::ibyteswap; break;\n+      case 8: opcode = TR::lstorei; byteswapOpcode = TR::lbyteswap; break;\n+      default: TR_ASSERT(0, \" number of bytes unexpected\\n\"); break;\n+      }\n+\n+   if (arraycopy.alternateDir())\n+      {\n+      loadNode = TR::Node::create(byteswapOpcode, 1, loadNode);\n+      }\n+\n+   TR::Node* iXstoreNode = TR::Node::createWithSymRef(opcode, 2, 2, aiaddNode, loadNode, symRef);\n+   TR::TreeTop* treeTop = TR::TreeTop::create(comp, iXstoreNode);\n+   TR::TreeTop* nextTreeTop = prevTreeTop->getNextTreeTop();\n+\n+   prevTreeTop->join(treeTop);\n+   treeTop->join(nextTreeTop);\n+\n+   return treeTop;\n+   }\n+\n+static TR::TreeTop* generateArraycopyFromSequentialLoadsDEPRECATED(TR::Compilation* comp, TR::TreeTop* currentTreeTop, TR::Node* ibloadNode)\n+   {\n+\n+   static const char * disableSeqLoadOpt = feGetEnv(\"TR_DisableSeqLoadOpt\");\n+   if (disableSeqLoadOpt)\n+      return currentTreeTop;\n+\n+   TR::CodeGenerator* codeGen = comp->cg();\n+\n+   if (comp->target().cpu.isLittleEndian())\n+      return currentTreeTop;\n+\n+   int32_t numBytes = 0;\n+   TR::Node* currentNode = currentTreeTop->getNode();\n+   TR::Node* prevNode = NULL;\n+   TR::Node* rootNode;\n+\n+   //checking the number of bytes\n+   while ( !((currentNode->getFirstChild() == ibloadNode) && (currentNode->getOpCodeValue() == TR::bu2i)) )\n+      {\n+      if ( (currentNode->getOpCodeValue() == TR::iadd) || (currentNode->getOpCodeValue() == TR::ior))\n+         {\n+         numBytes++;\n+         if (numBytes==1)\n+            rootNode=prevNode;\n+         }\n+      else if (isValidSeqLoadIMul(comp, currentNode))\n+         numBytes++;\n+      else\n+         numBytes = 0;\n+      prevNode = currentNode;\n+      currentNode = currentNode->getFirstChild();\n+      }\n+\n+   if (numBytes == 1)\n+      {\n+      dumpOptDetails(comp, \" Sequential Load of 1 byte not worth reducing\\n\");\n+      return currentTreeTop;\n+      }\n+   else if ( numBytes != 2 && numBytes != 3 && numBytes != 4 )\n+      {\n+      dumpOptDetails(comp, \" Sequential Load of size other than 2/3/4 not reducible\\n\");\n+      return currentTreeTop;\n+      }\n+\n+   /*\n+    * This version of generateArraycopyFromSequentialLoads does not work when numBytes is equal to 2.\n+    * This version is deprecated so the opt bails out here rather than fix this particular version.\n+    * Even if it did not bail out here, a check would likely fail later on anyways.\n+    */\n+   if (2 == numBytes)\n+      {\n+      return currentTreeTop;\n+      }\n+\n+   // Need to make sure these loads are not under spine checks.\n+   //\n+   if (comp->requiresSpineChecks() && ibloadNode->getReferenceCount() > 1)\n+      {\n+      TR::TreeTop *tt = currentTreeTop;\n+      TR::TreeTop *lastTreeTop = currentTreeTop->getEnclosingBlock()->startOfExtendedBlock()->getFirstRealTreeTop()->getPrevTreeTop();\n+\n+      // Search backwards to the top of the EBB and look at all spine checks.\n+      while (tt != lastTreeTop)\n+         {\n+         TR::Node *node = tt->getNode();\n+         if (node->getOpCodeValue() == TR::BNDCHKwithSpineCHK ||\n+             node->getOpCodeValue() == TR::SpineCHK)\n+            {\n+            node = node->getFirstChild();\n+            while (node->getOpCode().isConversion())\n+               node = node->getFirstChild();\n+            if (node == ibloadNode)\n+               {\n+               dumpOptDetails(comp, \" Sequential Load to spine checked array not reducible\\n\");\n+               return currentTreeTop;\n+               }\n+            }\n+         tt = tt->getPrevTreeTop();\n+         }\n+      }\n+\n+   currentNode = rootNode;\n+   int32_t baseOffset;\n+   int32_t shiftVar;\n+   int32_t multiplier = 0;\n+   TR::Node* aloadNode;\n+   TR::Node* newLoadChildNode;\n+   TR::Node* newConvertChildNode;\n+   TR::Node* newMultChildNode;\n+   TR::Node* oldChildNode;\n+   TR::Node* basePointerNode;\n+\n+   // see if all the trees are valid\n+   for (int32_t i = 0; i < numBytes; i++)\n+      {\n+      currentNode = currentNode->getFirstChild();\n+      if (currentNode->getReferenceCount() > 1)\n+         {\n+         dumpOptDetails(comp, \" Sequential load not possible due to ref count > 1 %p\\n\", currentNode);\n+         return currentTreeTop;\n+         }\n+      if (i == 0)\n+         {\n+         if ( !(isValidSeqLoadB2i(comp, currentNode->getSecondChild())) )\n+            return currentTreeTop;\n+         baseOffset = getOffsetForSeqLoadDEPRECATED(comp, rootNode, numBytes, numBytes - i);\n+         aloadNode = getALoadReferenceForSeqLoadDEPRECATED(rootNode, numBytes, numBytes - i);\n+         basePointerNode = getBasePointerReferenceForSeqLoadDEPRECATED(comp, rootNode, numBytes, numBytes - i);\n+         shiftVar = getMultValueForSeqLoadDEPRECATED(comp, rootNode, numBytes, numBytes - i);\n+         if (shiftVar != 1)\n+            return currentTreeTop;\n+         }\n+      else if (i == numBytes-1)\n+         {\n+         if ( !(isValidSeqLoadIMul(comp, currentNode)) )\n+            return currentTreeTop;\n+         if ( !(shiftVar*multiplier==getMultValueForSeqLoadDEPRECATED(comp, rootNode, numBytes, numBytes - i)) )  //This check is broken for numBytes == 2 since multiplier is 0 instead of 256.\n+            return currentTreeTop;\n+         if ( !(baseOffset == getOffsetForSeqLoadDEPRECATED(comp, rootNode, numBytes, numBytes - i) + i)\n+            || !(aloadNode == getALoadReferenceForSeqLoadDEPRECATED(rootNode, numBytes, numBytes - i))\n+            || !(basePointerNode == getBasePointerReferenceForSeqLoadDEPRECATED(comp, rootNode, numBytes, numBytes - i)))\n+            return currentTreeTop;\n+         baseOffset = getOffsetForSeqLoadDEPRECATED(comp, rootNode, numBytes, numBytes - i);\n+         newLoadChildNode = currentNode->getFirstChild()->getFirstChild();\n+         newConvertChildNode = currentNode->getFirstChild();\n+         newMultChildNode = currentNode;\n+         }\n+      else\n+         {\n+         if ( !(isValidSeqLoadIMul(comp, currentNode->getSecondChild())) )\n+            return currentTreeTop;\n+         if ( !(baseOffset == getOffsetForSeqLoadDEPRECATED(comp, rootNode, numBytes, numBytes - i) + i)\n+            || !(aloadNode == getALoadReferenceForSeqLoadDEPRECATED(rootNode, numBytes, numBytes - i))\n+            || !(basePointerNode == getBasePointerReferenceForSeqLoadDEPRECATED(comp, rootNode, numBytes, numBytes - i)))\n+            return currentTreeTop;\n+         if (multiplier == 0)\n+            {\n+            multiplier = getMultValueForSeqLoadDEPRECATED(comp, rootNode, numBytes, numBytes - i);\n+            shiftVar = multiplier;\n+            if (!(multiplier == 256))\n+               return currentTreeTop;\n+            }\n+         else\n+            {\n+            shiftVar = multiplier * shiftVar;\n+            if ( !(shiftVar == getMultValueForSeqLoadDEPRECATED(comp, rootNode, numBytes, numBytes - i)) )\n+               return currentTreeTop;\n+            }\n+         }\n+\n+      }\n+\n+   if(numBytes == 4 || numBytes == 3 || numBytes == 2)\n+      {\n+      if (!performTransformation(comp, \"%sReducing sequential loads\\n\", OPT_DETAILS))\n+         {\n+         return currentTreeTop;\n+         }\n+      dumpOptDetails(comp, \" Sequential Load reduced at node: %p Number of bytes: %d\\n\", rootNode, numBytes);\n+      }\n+\n+   if (numBytes == 4)\n+      {\n+      oldChildNode = rootNode->getFirstChild();\n+      rootNode->setAndIncChild(0, newLoadChildNode);\n+      oldChildNode->recursivelyDecReferenceCount();\n+      TR::Node::recreate(newLoadChildNode, TR::iloadi);\n+      }\n+\n+   if (numBytes == 3)\n+      {\n+      oldChildNode = rootNode->getFirstChild()->getFirstChild();\n+      rootNode->getFirstChild()->setAndIncChild(0, newMultChildNode);\n+      oldChildNode->recursivelyDecReferenceCount();\n+      TR::Node::recreate(newLoadChildNode, TR::sloadi);\n+      TR::Node::recreate(newConvertChildNode, TR::su2i);\n+      newMultChildNode->getSecondChild()->setInt(256);\n+      }\n+\n+   if (numBytes == 2)\n+      {\n+      oldChildNode = rootNode->getFirstChild();\n+      rootNode->setAndIncChild(0, newConvertChildNode);\n+      oldChildNode->recursivelyDecReferenceCount();\n+      TR::Node::recreate(newLoadChildNode, TR::sloadi);\n+      TR::Node::recreate(newConvertChildNode, TR::su2i);\n+      }\n+\n+   return currentTreeTop;\n+   }\n+\n+TR::TreeTop* generateArraycopyFromSequentialLoads(TR::Compilation* comp, bool trace, TR::TreeTop* currentTreeTop, TR::Node* rootNode, NodeForwardList* combineNodeList)\n+   {\n+   static const char * disableSeqLoadOpt = feGetEnv(\"TR_DisableSeqLoadOpt\");\n    if (disableSeqLoadOpt)\n+      {\n       return currentTreeTop;\n+      }\n \n-   TR::CodeGenerator* codeGen = comp->cg();\n+   /*\n+    * This is an example transformation. 4 consective byte loads from a byte array are used to construct an int.\n+    * After the transformation a Little Endian int load is used to directly create the int.\n+    * Big Endian has support as well but the bytes in the original array need to be in the opposite order or a byteswap is inserted.\n+    *\n+    * Original trees:\n+    * n01n  iadd         <<-- rootNode, combineNode (2)\n+    * n02n    iadd       <<-- combineNode (1)\n+    * n03n      iadd     <<-- combineNode (0)\n+    * n04n        imul                     <<-- processedByteNodes (0)\n+    * n05n          bu2i                   <<-- byteConversionNode (0)\n+    * n06n            bloadi\n+    * n07n              aladd\n+    * n08n                ==>aloadi        <<-- aloadNode, loads byte array address, used in all 4 byte loads\n+    * n09n                lsub\n+    * n10n                  i2l\n+    * n11n                    iload        <<-- basePointerNode, used in all 4 byte loads\n+    * n12n                  lconst -9      <<-- byteOffsets (0)\n+    * n13n          iconst 256             <<-- multValue (0)\n+    * n14n        bu2i                   <<-- processedByteNodes (1), byteConversionNode (1)\n+    * n15n          bloadi\n+    * n16n            aladd\n+    * n08n              ==>aloadi\n+    * n17n              lsub\n+    * n10n                ==>i2l\n+    * n18n                lconst -8      <<-- byteOffsets (1)\n+    * n19n      imul                  <<-- processedByteNodes (2)\n+    * n20n        bu2i                <<-- byteConversionNode (2)\n+    * n21n          bloadi\n+    * n22n            aladd\n+    * n08n              ==>aloadi\n+    * n23n              lsub\n+    * n10n                ==>i2l\n+    * n24n                lconst -10  <<-- byteOffsets (2)\n+    * n25n        iconst 0x10000      <<-- multValue (2)\n+    * n26n    imul                  <<-- processedByteNodes (3)\n+    * n27n      b2i                 <<-- byteConversionNode (3)\n+    * n28n        bloadi\n+    * n29n          aladd\n+    * n08n            ==>aloadi\n+    * n30n            lsub\n+    * n10n              ==>i2l\n+    * n31n              lconst -11  <<-- byteOffsets (3)\n+    * n32n      iconst 0x1000000    <<-- multValue (3)\n+    *\n+    *\n+    * After transformation:\n+    * n01n  iloadi         <<-- rootNode\n+    * n16n    aladd\n+    * n08n      ==>aloadi\n+    * n17n      lsub\n+    * n10n        i2l\n+    * n11n          iload\n+    * n18n        lconst -8\n+    */\n \n-   if (comp->target().cpu.isLittleEndian())\n+\n+   /* processedByteNodes are children of a combine node that are not also a combine node. */\n+   TR::Node* processedByteNodes[8];\n+   /* byteConversionNodes are the conversion node parent for each loaded byte. Sorted such that the least significant byte is in position 0. */\n+   TR::Node* byteConversionNodes[8];\n+   /* byteOffsets are the constants that act as relative offsets for each loaded byte. Sorted such that the least significant byte is in position 0. */\n+   int64_t byteOffsets[8];\n+\n+   /* byteCount is the number of loaded bytes. */\n+   int32_t byteCount = 0;\n+\n+   /* These are used to make sure the same aload/aloadi node and basePointerNode are used for all of the byte loads. */\n+   TR::Node* aloadNode = NULL;\n+   TR::Node* basePointerNode = NULL;\n+\n+   /* Tracks if the final loaded result needs to be sign extended. */\n+   bool signExtendResult = false;\n+   /* Tracks if the bytes can be loaded with an Little Endian or Big Endian load. If neither works, the opt bails. */\n+   bool littleEndianLoad = false;\n+   /* Tracks if the final loaded result is an int or a long. */\n+   bool is64bitResult = rootNode->getDataType().isInt64();\n+   /* Tracks if byteswap are needed due to endianness differences. */\n+   bool swapBytes = false;\n+\n+   /* These are used to track nodes while performing the transformation. */\n+   TR::Node* newLoadChildNode = NULL;\n+   TR::Node* newConvertChildNode = NULL;\n+   TR::Node* disconnectedNode1 = NULL;\n+   TR::Node* disconnectedNode2 = NULL;\n+\n+   if (trace) traceMsg(comp, \"Sequential Load Simplification Candidate - rootNode: %p\\n\", rootNode);\n+\n+   for (int i = 0; i < 8; i++)\n+      {\n+      processedByteNodes[i] = NULL;\n+      byteConversionNodes[i] = NULL;\n+      }\n+\n+   /* Iterate over combineNodeList and populate the processedByteNodes array. */\n+   for (auto it = combineNodeList->begin(); it != combineNodeList->end(); ++it)\n+      {\n+      TR::Node* firstChild = (*it)->getFirstChild();\n+      TR::Node* secondChild = (*it)->getSecondChild();\n+\n+      if ((firstChild->getOpCodeValue() != TR::iadd) && (firstChild->getOpCodeValue() != TR::ior) &&\n+          (firstChild->getOpCodeValue() != TR::ladd) && (firstChild->getOpCodeValue() != TR::lor)\n+         )\n+         {\n+         processedByteNodes[byteCount] = firstChild;\n+         byteCount++;\n+         }\n+\n+      if ((secondChild->getOpCodeValue() != TR::iadd) && (secondChild->getOpCodeValue() != TR::ior) &&\n+          (secondChild->getOpCodeValue() != TR::ladd) && (secondChild->getOpCodeValue() != TR::lor)\n+         )\n+         {\n+         processedByteNodes[byteCount] = secondChild;\n+         byteCount++;\n+         }\n+      }\n+\n+   if (trace) traceMsg(comp, \"Sequential Load Simplification Candidate - rootNode: %p, byteCount: %d\\n\", rootNode, byteCount);\n+\n+   if (!is64bitResult && (byteCount > 4))\n+      {\n+      if (trace) traceMsg(comp, \"byteCount is too high for constructing an int value. rootNode: %p, byteCount: %d\\n\", rootNode, byteCount);\n       return currentTreeTop;\n+      }\n \n-   int32_t numBytes = 0;\n-   TR::Node* currentNode = currentTreeTop->getNode();\n-   TR::Node* prevNode = NULL;\n-   TR::Node* rootNode;\n+   if ((byteCount < 2) || (byteCount > 8))\n+      {\n+      if (trace) traceMsg(comp, \"Sequential Load of size other than 2 to 8 is not supported. rootNode: %p, byteCount: %d\\n\", rootNode, byteCount);\n+      return currentTreeTop;\n+      }\n \n-   //checking the number of bytes\n-   while ( !((currentNode->getFirstChild() == ibloadNode) && (currentNode->getOpCodeValue() == TR::bu2i)) )\n+   /* This loop performs more checks and collects info on each loaded byte. */\n+   for (int i = 0; i < byteCount; i++)\n+      {\n+      TR::Node* byteConversionNode = NULL;\n+      int64_t multValue = 0;\n+\n+      if (trace) traceMsg(comp, \"Sequential Load Simplification Candidate - rootNode: %p, processedByteNodes[%d]: %p\\n\", rootNode, i, processedByteNodes[i]);\n+\n+      if (0 == i)\n+         {\n+         aloadNode = getALoadReferenceForSeqLoad(processedByteNodes[i]);\n+         if (trace) traceMsg(comp, \"Sequential Load Simplification Candidate - rootNode: %p, aloadNode: %p\\n\", rootNode, aloadNode);\n+         basePointerNode = getBasePointerReferenceForSeqLoad(processedByteNodes[i]);\n+         if (trace) traceMsg(comp, \"Sequential Load Simplification Candidate - rootNode: %p, basePointerNode: %p\\n\", rootNode, basePointerNode);\n+         }\n+      else\n+         {\n+         /* aloadNode for all loaded bytes must be the exact same node. */\n+         if (aloadNode != getALoadReferenceForSeqLoad(processedByteNodes[i]))\n+            {\n+            if (trace) traceMsg(comp, \"Sequential Load Simplification aload mismatch. rootNode: %p, aloadNode(0): %p, aloadNode(%d): %p\\n\",\n+                                rootNode, aloadNode, i, getALoadReferenceForSeqLoad(processedByteNodes[i]));\n+            return currentTreeTop;\n+            }\n+\n+         /* basePointerNode for all loaded bytes must be the exact same node (or all NULL). */\n+         if (basePointerNode != getBasePointerReferenceForSeqLoad(processedByteNodes[i]))\n+            {\n+            if (trace) traceMsg(comp, \"Sequential Load Simplification basePointerNode mismatch. rootNode: %p, basePointerNode(0): %p, basePointerNode(%d): %p\\n\",\n+                                rootNode, basePointerNode, i, getBasePointerReferenceForSeqLoad(processedByteNodes[i]));\n+            return currentTreeTop;\n+            }\n+         }\n+\n+      byteConversionNode = getByteConversionNodeForSeqLoad(processedByteNodes[i]);\n+      if (trace) traceMsg(comp, \"Sequential Load Simplification Candidate - rootNode: %p, byteConversionNode: %p\\n\", rootNode, byteConversionNode);\n+      multValue = getMultValueForSeqLoad(processedByteNodes[i]);\n+      if (trace) traceMsg(comp, \"Sequential Load Simplification Candidate - rootNode: %p, multValue: %ld\\n\", rootNode, multValue);\n+\n+      if (multValue > (1L << ((byteCount - 1) * 8)))\n+         {\n+         if (trace) traceMsg(comp, \"multValue is too high for the given byteCount. rootNode: %p, byteCount: %d, multValue: %ld\\n\", rootNode, byteCount, multValue);\n+         return currentTreeTop;\n+         }\n+\n+      if ((1L << ((byteCount - 1) * 8)) == multValue)\n+         {\n+         /* Check if most significant byte is signed extended or not. */\n+         signExtendResult = checkForSeqLoadSignExtendedByte(processedByteNodes[i]);\n+         if (trace) traceMsg(comp, \"Sequential Load Simplification Candidate - rootNode: %p, signExtendResult: %d\\n\", rootNode, signExtendResult);\n+         }\n+      else\n+         {\n+         /* Other bytes can not be sign extended. */\n+         if (checkForSeqLoadSignExtendedByte(processedByteNodes[i]))\n+            {\n+            if (trace) traceMsg(comp, \"Bytes other than the most significant byte should not be sign extended. rootNode: %p, processedByteNodes[%d]: %p\\n\", rootNode, i, processedByteNodes[i]);\n+            return currentTreeTop;\n+            }\n+         }\n+\n+      /*\n+       * byteConversionNodes and byteOffsets are sorted such that the least significant byte load is in position 0.\n+       * Position 1 has the next most significant load and so on.\n+       * multValue is used to determine the significance of the byte load.\n+       * If two byte loads have the same multValue, the opt bails out.\n+       */\n+      for (int j = 0; j < byteCount; j++)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c17f5745e482b16315475e38333b0117cb5e11a"}, "originalPosition": 2015}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9c17f5745e482b16315475e38333b0117cb5e11a", "author": {"user": {"login": "IBMJimmyk", "name": "Jimmy K"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/9c17f5745e482b16315475e38333b0117cb5e11a", "committedDate": "2020-11-24T19:47:51Z", "message": "Undo Optimizations.enum changes\n\nsequentialStoreSimplification is no longer being moved out of\nOptimizations.enum. This breaks the dependency of the OpenJ9 and OMR changes\non each other."}, "afterCommit": {"oid": "f9fdc3f62f8d471f3b9d6d479cbfdb6c25f8694b", "author": {"user": {"login": "IBMJimmyk", "name": "Jimmy K"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/f9fdc3f62f8d471f3b9d6d479cbfdb6c25f8694b", "committedDate": "2020-12-16T21:24:28Z", "message": "Changed handling of multValue\n\nChanged getMultValueForSeqLoad to getShiftValueForSeqLoad.\n\nLoop that looks for duplicate multValues and orders the loaded bytes is no\nlonger a loop and is now based on shiftValue.\n\nAdded more comments.\nCleaned up the code."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU1MDI4OTgy", "url": "https://github.com/eclipse-openj9/openj9/pull/11251#pullrequestreview-555028982", "createdAt": "2020-12-17T22:11:57Z", "commit": {"oid": "a618a71d2d0500f0c10d984a3a8d5cbb906937a9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QyMjoxMTo1N1rOIIK0lw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QyMjoxMTo1N1rOIIK0lw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQzNjgyMw==", "bodyText": "Does this need to be in its own directory? Do we envision adding more files here? If not we should move it out.\nGreat set of tests by the way! Readers take note.", "url": "https://github.com/eclipse-openj9/openj9/pull/11251#discussion_r545436823", "createdAt": "2020-12-17T22:11:57Z", "author": {"login": "fjeremic"}, "path": "test/functional/JIT_Test/src/jit/test/tr/SeqLoadSimplification/SeqLoadSimplificationTest.java", "diffHunk": "@@ -0,0 +1,935 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+package jit.test.tr.SeqLoadSimplification;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a618a71d2d0500f0c10d984a3a8d5cbb906937a9"}, "originalPosition": 22}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYyMjc1Mjkz", "url": "https://github.com/eclipse-openj9/openj9/pull/11251#pullrequestreview-562275293", "createdAt": "2021-01-06T01:57:45Z", "commit": {"oid": "193b06309248f14f3bc9c4c5c50b32509018bedf"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQwMTo1Nzo0NVrOIOvAWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQwMzo0Mjo0OVrOIOw43A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjMyMTExMw==", "bodyText": "Sorry, but I still find the comment confusing. I think it's better to list the assumptions about the set of nodes that have been collected so far. For example: \"at this point, the trees have a correct structure in terms of all the opcodes. Next step is to check that the actual node values properly match, e.g. all byte loads use the same base pointer, load offsets and shift amounts are consecutive and properly match, etc.\"", "url": "https://github.com/eclipse-openj9/openj9/pull/11251#discussion_r552321113", "createdAt": "2021-01-06T01:57:45Z", "author": {"login": "gita-omr"}, "path": "runtime/compiler/optimizer/SequentialStoreSimplifier.cpp", "diffHunk": "@@ -677,621 +684,2233 @@ TR::Node* getALoadReferenceForSeqLoad(TR::Node* rootNode, int32_t totalBytes, in\n       }\n    }\n \n-bool TR_ShiftedValueTree::process(TR::Node* loadNode)\n+TR::TreeTop* seqLoadSearchAndCombine(TR::Compilation* comp, bool trace, TR_BitVector* visitedNodes, TR::TreeTop* currentTree, TR::Node* currentNode, NodeForwardList* combineNodeList)\n    {\n-\n-   bool shift = true;\n-   TR::ILOpCodes convCode = loadNode->getOpCodeValue();\n-   TR::ILOpCodes shiftCode, altShiftCode, constCode;\n-   int32_t size;\n-\n-   _isConst = false;\n-   switch(convCode)\n-      {\n-      case TR::s2b: shift = true;  _valueSize = 2; shiftCode = TR::sushr; altShiftCode = TR::sshr; constCode = TR::iconst; break;\n-      case TR::i2b: shift = true;  _valueSize = 4; shiftCode = TR::iushr; altShiftCode = TR::ishr; constCode = TR::iconst; break;\n-      case TR::l2b: shift = true;  _valueSize = 8; shiftCode = TR::lushr; altShiftCode = TR::lshr; constCode = TR::iconst; break;\n-      case TR::bload:\n-      case TR::bconst:\n-      case TR::sconst:\n-      case TR::iconst:\n-      case TR::lconst: shift = false; _valueSize = 1; _shiftValue = 0; break;\n-      default: return false;\n-      }\n-\n-//   dumpOptDetails(comp(), \"arraycopy sequential store - check load node %p\\n\", loadNode);\n-\n-   if (shift)\n+   /*\n+    * seqLoadSearchAndCombine recursively searches down the tree looking for a set of nodes that potentially matches\n+    * the pattern of byte loads to sequential memory locations that are used to construct a larger value.\n+    * This search looks at opcodes, const values and node reference counts to check for a match.\n+    * If these checks pass, generateArraycopyFromSequentialLoads is called which does a few more detailed check and\n+    * potentially performs the transformation to combine the byte loads together.\n+    */\n+   if (visitedNodes->isSet(currentNode->getGlobalIndex()))\n+      return currentTree;\n+\n+   visitedNodes->set(currentNode->getGlobalIndex());\n+\n+   /*\n+    * Combine nodes are the \"add\" and \"or\" nodes that construct the longer value out of several loaded bytes.\n+    * combineNodeList keeps tracks of the nodes used to construct one particular value. It is populated by isValidSeqLoadCombine.\n+    * combineNodeList needs to be cleared each time before it is repopulated.\n+    * isValidSeqLoadCombine also performs a series of initial checks to see if the tree structure contains the pattern\n+    * of byte loads that can be combined into wider loads.\n+    * combineNodeCount tracks the number of combine nodes.\n+    */\n+   combineNodeList->clear();\n+   int32_t combineNodeCount = 0;\n+   if (isValidSeqLoadCombine(comp, trace, currentNode, combineNodeList, combineNodeCount))\n       {\n-      if (loadNode->getFirstChild()->getOpCodeValue() != shiftCode && loadNode->getFirstChild()->getOpCodeValue() != altShiftCode)\n-         {\n-         _valNode = loadNode->getFirstChild();\n-         _shiftValue = 0;\n-         }\n-      else\n-         {\n-         TR::Node* shiftVal = loadNode->getFirstChild()->getSecondChild();\n-         if (shiftVal->getOpCodeValue() != constCode)\n-            {\n-            dumpOptDetails(comp(), \" Shifted Value: did not encounter correct const code\\n\");\n-            return false;\n-            }\n-         _valNode = loadNode->getFirstChild()->getFirstChild();\n-         switch(constCode)\n-            {\n-            case TR::sconst: _shiftValue = shiftVal->getShortInt(); break;\n-            case TR::iconst: _shiftValue = shiftVal->getInt(); break;\n-            case TR::lconst: _shiftValue = shiftVal->getLongInt(); break;\n-            default: break;\n-            }\n-         }\n+      /*\n+       * The initial tree structure seems good at this point. generateArraycopyFromSequentialLoads will do some additional", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "193b06309248f14f3bc9c4c5c50b32509018bedf"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjMyMTgxMA==", "bodyText": "Why do we call it a base pointer? Maybe it's better to call it a \"base offset\" since it should not be a pointer? I think aload/aloadi is a base pointer. It's a minor thing but makes understanding the code and the comments a bit easier.", "url": "https://github.com/eclipse-openj9/openj9/pull/11251#discussion_r552321810", "createdAt": "2021-01-06T02:00:17Z", "author": {"login": "gita-omr"}, "path": "runtime/compiler/optimizer/SequentialStoreSimplifier.cpp", "diffHunk": "@@ -677,621 +684,2233 @@ TR::Node* getALoadReferenceForSeqLoad(TR::Node* rootNode, int32_t totalBytes, in\n       }\n    }\n \n-bool TR_ShiftedValueTree::process(TR::Node* loadNode)\n+TR::TreeTop* seqLoadSearchAndCombine(TR::Compilation* comp, bool trace, TR_BitVector* visitedNodes, TR::TreeTop* currentTree, TR::Node* currentNode, NodeForwardList* combineNodeList)\n    {\n-\n-   bool shift = true;\n-   TR::ILOpCodes convCode = loadNode->getOpCodeValue();\n-   TR::ILOpCodes shiftCode, altShiftCode, constCode;\n-   int32_t size;\n-\n-   _isConst = false;\n-   switch(convCode)\n-      {\n-      case TR::s2b: shift = true;  _valueSize = 2; shiftCode = TR::sushr; altShiftCode = TR::sshr; constCode = TR::iconst; break;\n-      case TR::i2b: shift = true;  _valueSize = 4; shiftCode = TR::iushr; altShiftCode = TR::ishr; constCode = TR::iconst; break;\n-      case TR::l2b: shift = true;  _valueSize = 8; shiftCode = TR::lushr; altShiftCode = TR::lshr; constCode = TR::iconst; break;\n-      case TR::bload:\n-      case TR::bconst:\n-      case TR::sconst:\n-      case TR::iconst:\n-      case TR::lconst: shift = false; _valueSize = 1; _shiftValue = 0; break;\n-      default: return false;\n-      }\n-\n-//   dumpOptDetails(comp(), \"arraycopy sequential store - check load node %p\\n\", loadNode);\n-\n-   if (shift)\n+   /*\n+    * seqLoadSearchAndCombine recursively searches down the tree looking for a set of nodes that potentially matches\n+    * the pattern of byte loads to sequential memory locations that are used to construct a larger value.\n+    * This search looks at opcodes, const values and node reference counts to check for a match.\n+    * If these checks pass, generateArraycopyFromSequentialLoads is called which does a few more detailed check and\n+    * potentially performs the transformation to combine the byte loads together.\n+    */\n+   if (visitedNodes->isSet(currentNode->getGlobalIndex()))\n+      return currentTree;\n+\n+   visitedNodes->set(currentNode->getGlobalIndex());\n+\n+   /*\n+    * Combine nodes are the \"add\" and \"or\" nodes that construct the longer value out of several loaded bytes.\n+    * combineNodeList keeps tracks of the nodes used to construct one particular value. It is populated by isValidSeqLoadCombine.\n+    * combineNodeList needs to be cleared each time before it is repopulated.\n+    * isValidSeqLoadCombine also performs a series of initial checks to see if the tree structure contains the pattern\n+    * of byte loads that can be combined into wider loads.\n+    * combineNodeCount tracks the number of combine nodes.\n+    */\n+   combineNodeList->clear();\n+   int32_t combineNodeCount = 0;\n+   if (isValidSeqLoadCombine(comp, trace, currentNode, combineNodeList, combineNodeCount))\n       {\n-      if (loadNode->getFirstChild()->getOpCodeValue() != shiftCode && loadNode->getFirstChild()->getOpCodeValue() != altShiftCode)\n-         {\n-         _valNode = loadNode->getFirstChild();\n-         _shiftValue = 0;\n-         }\n-      else\n-         {\n-         TR::Node* shiftVal = loadNode->getFirstChild()->getSecondChild();\n-         if (shiftVal->getOpCodeValue() != constCode)\n-            {\n-            dumpOptDetails(comp(), \" Shifted Value: did not encounter correct const code\\n\");\n-            return false;\n-            }\n-         _valNode = loadNode->getFirstChild()->getFirstChild();\n-         switch(constCode)\n-            {\n-            case TR::sconst: _shiftValue = shiftVal->getShortInt(); break;\n-            case TR::iconst: _shiftValue = shiftVal->getInt(); break;\n-            case TR::lconst: _shiftValue = shiftVal->getLongInt(); break;\n-            default: break;\n-            }\n-         }\n+      /*\n+       * The initial tree structure seems good at this point. generateArraycopyFromSequentialLoads will do some additional\n+       * checks. If they also pass, it will combine the byte loads into wider loads.\n+       */\n+      currentTree = generateArraycopyFromSequentialLoads(comp, trace, currentTree, currentNode, combineNodeList);\n       }\n    else\n       {\n-      _valNode = loadNode;\n-      if (convCode != TR::bload)\n+      /* If the checks in isValidSeqLoadCombine fail, try again on the children. */\n+      for (int i = 0; i < currentNode->getNumChildren(); i++)\n          {\n-         _isConst = true;\n+         currentTree = seqLoadSearchAndCombine(comp, trace, visitedNodes, currentTree, currentNode->getChild(i), combineNodeList);\n          }\n       }\n \n-   if ((_shiftValue % 8) != 0 || (_shiftValue < 0) || (_shiftValue >= _valueSize*8))\n-      {\n-      dumpOptDetails(comp(), \"Shifted Value: did not encounter valid shift value %d for var size %d\\n\", _shiftValue, _valueSize);\n-      return false;\n-      }\n-\n-   _rootNode = loadNode;\n-\n-   return true;\n+   return currentTree;\n    }\n \n-bool TR_arraycopySequentialStores::checkAiadd(TR::TreeTop * currentTree, TR::Node* aiaddNode)\n+bool isValidSeqLoadCombine(TR::Compilation* comp, bool trace, TR::Node* combineNode, NodeForwardList* combineNodeList, int32_t &combineNodeCount)\n    {\n-//   dumpOptDetails(comp(), \"arraycopy sequential store - check aiadd node %p\\n\", aiaddNode);\n-   _activeAddrTree = new (trStackMemory()) TR_AddressTree(stackAlloc, comp());\n-   _activeTreeTop = currentTree;\n-   if (_activeAddrTree->process(aiaddNode, _comp->cg()->getSupportsAlignedAccessOnly()))\n+   /*\n+    * Combine nodes are the \"add\" and \"or\" nodes that construct the longer value out of several loaded bytes.\n+    * This layer of checks is focused on the \"add\" and \"or\" nodes that construct the final value out of the\n+    * loaded value. It calls other functions the confirm that those loaded values are properly processed byte values.\n+    */\n+\n+   /* Check if the candidate combine node is: iadd, ior, ladd, lor */\n+   if ((combineNode->getOpCodeValue() != TR::iadd) && (combineNode->getOpCodeValue() != TR::ior) &&\n+       (combineNode->getOpCodeValue() != TR::ladd) && (combineNode->getOpCodeValue() != TR::lor))\n       {\n-      return insertConsistentTree();\n+      return false;\n       }\n-   return false;\n-   }\n \n-void TR_arraycopySequentialStores::insertTree(int entry)\n-   {\n-//   dumpOptDetails(comp(), \" insert nodes %p,%p into entry %d\\n\",\n-//      _activeAddrTree->getRootNode(), _activeValueTree->getRootNode(), entry);\n-   if ((_addrTree[entry] != NULL) && (entry < _maxAddressTrees))\n+   /*\n+    * Only the topmost combine node (the first one to be looked at) can have a reference count greater than 1.\n+    * If not, it means the intermediate values when constructing the larger value are used in other places and still\n+    * needs to be generated.\n+    */\n+   if ((combineNodeCount > 0) && (combineNode->getReferenceCount() != 1))\n       {\n-      memmove(&_addrTree[entry+1], &_addrTree[entry], (_maxAddressTrees-entry-1)*sizeof(TR_AddressTree*));\n-      memmove(&_val[entry+1], &_val[entry],  (_maxAddressTrees-entry-1)*sizeof(TR_ShiftedValueTree*));\n-      memmove(&_treeTops[entry+1], &_treeTops[entry], (_maxAddressTrees-entry-1)*sizeof(TR::TreeTop*));\n+      return false;\n       }\n-   _addrTree[entry] = _activeAddrTree;\n-   _val[entry] = _activeValueTree;\n-   _treeTops[entry] = _activeTreeTop;\n-   }\n \n-bool TR_arraycopySequentialStores::insertConsistentTree()\n-   {\n+   /* The node being looked at is a potential combine node so it gets added to the list. */\n+   combineNodeList->push_front(combineNode);\n+   combineNodeCount++;\n \n-   // these are byte arrays we are working with - the multiplier must be 1\n-   if (_activeAddrTree->getMultiplier() != 1)\n+   /*\n+    * If int width combine nodes are being used, no more than 4 bytes can be combined which means no more than 3 combine nodes.\n+    * If long width combine nodes are being used, no more than 8 bytes can be combined which means no more than 7 combine nodes.\n+    */\n+   if ((combineNodeCount > 3) && ((combineNode->getOpCodeValue() == TR::iadd) || (combineNode->getOpCodeValue() == TR::ior)))\n       {\n-      dumpOptDetails(comp(), \" insertTree: multiplier must be 1 in aiadd tree\\n\");\n       return false;\n       }\n-   TR::SymbolReference* activeBaseRef = _activeAddrTree->getBaseVarNode()->isNull() ? NULL : _activeAddrTree->getBaseVarNode()->getChild()->skipConversions()->getSymbolReference();\n-   if (activeBaseRef == NULL)\n+   else if ((combineNodeCount > 7) && ((combineNode->getOpCodeValue() == TR::ladd) || (combineNode->getOpCodeValue() == TR::lor)))\n       {\n-      dumpOptDetails(comp(), \" insertTree: no base variable in aiadd tree\\n\");\n       return false;\n       }\n \n-   if (_addrTree[0] == NULL)\n-      {\n-//      dumpOptDetails(comp(), \" insertTree: first tree inserted successfully with offset: %d\\n\", _activeAddrTree->getOffset());\n-      insertTree(0);\n-      return true;\n-      }\n+   TR::Node* childrenArray[2];\n+   childrenArray[0] = combineNode->getFirstChild();\n+   childrenArray[1] = combineNode->getSecondChild();\n \n-   // make sure the index variable and base variable is consistent with the first tree\n-   TR::SymbolReference* baseRef = _addrTree[0]->getBaseVarNode()->isNull() ? NULL : _addrTree[0]->getBaseVarNode()->getChild()->skipConversions()->getSymbolReference();\n-   if (baseRef != activeBaseRef)\n+   /*\n+    * Check if the children match the pattern for combining byte loads.\n+    * There is an optional mul/shl layer.\n+    * There is an optional and layer.\n+    * The byte conversion nodes are the ones on the path to the byte loads.\n+    * The child can also be another combine node (add/or).\n+    */\n+   for (int i = 0; i < 2; i++)\n       {\n-      dumpOptDetails(comp(), \" insertTree: base variable is different than previous tree\\n\");\n-      return false;\n+      TR::ILOpCodes childOpCode = childrenArray[i]->getOpCodeValue();\n+\n+      switch (childOpCode)\n+         {\n+         case TR::imul:\n+         case TR::ishl:\n+         case TR::lmul:\n+         case TR::lshl:\n+            if (!isValidSeqLoadMulOrShl(comp, trace, childrenArray[i]))\n+               return false;\n+            break;\n+         case TR::iand:\n+         case TR::land:\n+            if (!isValidSeqLoadAnd(comp, trace, childrenArray[i]))\n+               return false;\n+            break;\n+         case TR::b2i:\n+         case TR::b2l:\n+         case TR::bu2i:\n+         case TR::bu2l:\n+            if (!isValidSeqLoadByteConversion(comp, trace, childrenArray[i]))\n+               return false;\n+            break;\n+         case TR::iadd:\n+         case TR::ior:\n+         case TR::ladd:\n+         case TR::lor:\n+            if (!isValidSeqLoadCombine(comp, trace, childrenArray[i], combineNodeList, combineNodeCount))\n+               return false;\n+            break;\n+         default:\n+            return false;\n+         }\n       }\n \n-   TR::SymbolReference* indRef = _addrTree[0]->getIndVarNode()->isNull() ? NULL : _addrTree[0]->getIndVarNode()->getChild()->skipConversions()->getSymbolReference();\n-   TR::SymbolReference* activeIndRef = _activeAddrTree->getIndVarNode()->isNull() ? NULL : _activeAddrTree->getIndVarNode()->getChild()->skipConversions()->getSymbolReference();\n+   return true;\n+   }\n \n-   TR::Node* indBase = NULL;\n-   TR::Node* activeIndBase = NULL;\n-   if (!_addrTree[0]->getIndexBase()->isNull())\n-      indBase = _addrTree[0]->getIndexBase()->getParent();\n-   if (!_activeAddrTree->getIndexBase()->isNull())\n-      activeIndBase = _activeAddrTree->getIndexBase()->getParent();\n+bool isValidSeqLoadMulOrShl(TR::Compilation* comp, bool trace, TR::Node* mulOrShlNode)\n+   {\n+   /*\n+    * A mul or shl node is used to move the loaded byte into the proper position such that they can be combined\n+    * together with \"add\" or \"or\" nodes later on to construct the final value.\n+    * isValidSeqLoadMulOrShl checks the ref counts on the mul/shl node and that the const child have one of the\n+    * possible expected values.\n+    * The validity of the non-const child is handled by calling out to another function.\n+    */\n \n-   if (indRef != activeIndRef || indBase != activeIndBase)\n+   /* Confirm that the input mulOrShlNode is one of: imul, ishl, lmul, lshl */\n+   if ((mulOrShlNode->getOpCodeValue() != TR::imul) && (mulOrShlNode->getOpCodeValue() != TR::ishl) &&\n+       (mulOrShlNode->getOpCodeValue() != TR::lmul) && (mulOrShlNode->getOpCodeValue() != TR::lshl))\n       {\n-      dumpOptDetails(comp(), \" insertTree: index variable is different than previous tree\\n\");\n       return false;\n       }\n \n-   // make sure the value being loaded is consistent with the first tree\n-   if (_val[0]->isConst() !=  _activeValueTree->isConst())\n+   /*\n+    * mulOrShlNode must have a refCount of 1. After the transformation the intermediate value generated by this node\n+    * won't be calculated. If the value is needed for something else, the transformation needs to bail out here.\n+    */\n+   if (mulOrShlNode->getReferenceCount() != 1)\n       {\n-      dumpOptDetails(comp(), \" insertTree: const value attributes inconsistent\\n\");\n       return false;\n       }\n \n-   if (!_val[0]->isConst() && (_val[0]->getValNode() != _activeValueTree->getValNode()))\n+   TR::Node* firstChild = mulOrShlNode->getFirstChild();\n+   TR::Node* secondChild = mulOrShlNode->getSecondChild();\n+\n+   /*\n+    * Check if the first child matches the pattern.\n+    * There is an optional and layer.\n+    * The byte conversion nodes are the ones on the path to the byte loads.\n+    */\n+   switch (firstChild->getOpCodeValue())\n       {\n-      dumpOptDetails(comp(), \" insertTree: value variable is different than previous tree\\n\");\n-      return false;\n+      case TR::iand:\n+      case TR::land:\n+         if (!isValidSeqLoadAnd(comp, trace, firstChild))\n+            return false;\n+         break;\n+      case TR::b2i:\n+      case TR::b2l:\n+      case TR::bu2i:\n+      case TR::bu2l:\n+         if (!isValidSeqLoadByteConversion(comp, trace, firstChild))\n+            return false;\n+         break;\n+      default:\n+         return false;\n       }\n \n-   // make sure the value tree doesn't reference the address tree base var\n-   if (_activeValueTree->getRootNode()->referencesSymbolInSubTree(baseRef, _comp->incOrResetVisitCount()))\n+   /*\n+    * The second child must a const node and only certain values are valid.\n+    * These values correspond with the constants needed to shift a loaded byte left by multiples of 8 bits.\n+    */\n+   if ((secondChild->getOpCodeValue() != TR::iconst) && (secondChild->getOpCodeValue() != TR::lconst))\n       {\n-      dumpOptDetails(comp(), \" insertTree: value tree %p references address tree base var\\n\", _activeValueTree->getRootNode());\n       return false;\n       }\n \n-//   dumpOptDetails(comp(), \" insertTree: tree inserted successfully. offset:%d\\n\", _activeAddrTree->getOffset());\n-   int entry;\n-   for (entry=0; entry < _maxAddressTrees && _addrTree[entry] != NULL; ++entry)\n+   if (mulOrShlNode->getOpCodeValue() == TR::imul)\n       {\n-      if (_activeAddrTree->getOffset() < _addrTree[entry]->getOffset())\n+      switch (secondChild->getInt())\n          {\n-         insertTree(entry);\n-         return true;\n+         case 0x100:     /* 256   */\n+         case 0x10000:   /* 256^2 */\n+         case 0x1000000: /* 256^3 */\n+            break;\n+         default:\n+            return false;\n+         }\n+      }\n+   else if (mulOrShlNode->getOpCodeValue() == TR::ishl)\n+      {\n+      switch (secondChild->getInt())\n+         {\n+         case 8:\n+         case 16:\n+         case 24:\n+            break;\n+         default:\n+            return false;\n+         }\n+      }\n+   else if (mulOrShlNode->getOpCodeValue() == TR::lmul)\n+      {\n+      switch (secondChild->getLongInt())\n+         {\n+         case 0x100L:             /* 256   */\n+         case 0x10000L:           /* 256^2 */\n+         case 0x1000000L:         /* 256^3 */\n+         case 0x100000000L:       /* 256^4 */\n+         case 0x10000000000L:     /* 256^5 */\n+         case 0x1000000000000L:   /* 256^6 */\n+         case 0x100000000000000L: /* 256^7 */\n+            break;\n+         default:\n+            return false;\n+         }\n+      }\n+   else /* mulOrShlNode->getOpCodeValue() == TR::lshl */\n+      {\n+      switch (secondChild->getInt())\n+         {\n+         case 8:\n+         case 16:\n+         case 24:\n+         case 32:\n+         case 40:\n+         case 48:\n+         case 56:\n+            break;\n+         default:\n+            return false;\n          }\n       }\n \n-   insertTree(entry);\n    return true;\n    }\n \n-\n-int TR_arraycopySequentialStores::numTrees()\n+bool isValidSeqLoadAnd(TR::Compilation* comp, bool trace, TR::Node* andNode)\n    {\n-   int i;\n-   for (i=0; i<_maxAddressTrees; ++i)\n+   /*\n+    * Sometimes the loaded byte is and'd with 0xFF so that bits set due to sign extension are cleared.\n+    * This is done so those bits do not interfere when the bytes are combined via add/or nodes.\n+    * The non const child must be a byte to int conversion node which is passed to another function to be\n+    * verified.\n+    */\n+\n+   /* Confirm that the input andNode is one of: iand, land */\n+   if ((andNode->getOpCodeValue() != TR::iand) && (andNode->getOpCodeValue() != TR::land))\n       {\n-      if (_addrTree[i] == NULL)\n-         return i;\n+      return false;\n       }\n-   return _maxAddressTrees;\n-   }\n \n-int TR_arraycopySequentialStores::numValidTrees(int maxEntries)\n-   {\n-   int dir = (_bigEndian) ? -1 : 1;\n-   int entry;\n+   /*\n+    * andNode must have a refCount of 1. After the transformation the intermediate value generated by this node\n+    * won't be calculated. If the value is needed for something else, the transformation needs to bail out here.\n+    */\n+   if (andNode->getReferenceCount() != 1)\n+      {\n+      return false;\n+      }\n \n-//   dumpOptDetails(comp(), \"...check if valid entries\\n\");\n-   for (entry=1; (_addrTree[entry] != NULL) && (entry < maxEntries); ++entry)\n+   TR::Node* firstChild = andNode->getFirstChild();\n+   TR::Node* secondChild = andNode->getSecondChild();\n+\n+   /*\n+    * Check if the first child matches the pattern.\n+    * The byte conversion nodes are the ones on the path to the byte loads.\n+    */\n+   switch (firstChild->getOpCodeValue())\n       {\n-      if (_addrTree[entry]->getOffset() != _addrTree[0]->getOffset() + entry)\n-         {\n+      case TR::b2i:\n+      case TR::b2l:\n+      case TR::bu2i:\n+      case TR::bu2l:\n+         if (!isValidSeqLoadByteConversion(comp, trace, firstChild))\n+            return false;\n          break;\n-         }\n-      if (!hasConstValue() && (_val[entry]->getShiftValue() != _val[0]->getShiftValue() + dir*8*entry))\n+      default:\n+         return false;\n+      }\n+\n+   /*\n+    * The second child must a const node and only 0xFF is valid.\n+    * This node is supposed to act as a mask so that only 8 bits are affected when this is combined via add/or with the other\n+    * loaded bytes.\n+    */\n+   if (secondChild->getOpCodeValue() == TR::iconst)\n+      {\n+      if (secondChild->getInt() != 0xFF)\n          {\n-         break;\n+         return false;\n          }\n       }\n-   if ((entry == 1) && !hasConstValue() && _comp->cg()->supportsByteswap())\n+   else if (secondChild->getOpCodeValue() == TR::lconst)\n       {\n-//      dumpOptDetails(comp(), \"...no valid entries forward\\n...see if reverse store finds any entries\\n\");\n-      _alternateDir = true;\n-      // repeat process for reversed store\n-      dir = (_bigEndian) ? 1 : -1;\n-      for (entry=1; (_addrTree[entry] != NULL) && (entry < maxEntries); ++entry)\n+      if (secondChild->getLongInt() != 0xFF)\n          {\n-         if (_addrTree[entry]->getOffset() != _addrTree[0]->getOffset() + entry)\n-            {\n-            break;\n-            }\n-         if (_val[entry]->getShiftValue() != _val[0]->getShiftValue() + dir*8*entry)\n-            {\n-            break;\n-            }\n+         return false;\n          }\n       }\n-   if (entry > 1)\n+   else\n       {\n-      dumpOptDetails(comp(), \"Found %d sequential valid trees\\n\", entry);\n+      return false;\n       }\n-   return entry;\n+\n+   return true;\n    }\n \n-bool TR_arraycopySequentialStores::checkTrees()\n+bool isValidSeqLoadByteConversion(TR::Compilation* comp, bool trace, TR::Node* conversionNode)\n    {\n-   if (_val[0] == NULL)\n+   /*\n+    * This function checks the opcode and reference counts related to nodes that perform the byte load and\n+    * convert to an int or a long.\n+    *\n+    * Example tree:\n+    * b2i        <--- conversionNode\n+    *   bloadi\n+    *     aladd\n+    *       aload/aloadi\n+    *       lsub/ladd\n+    *         **basePointerNode**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "193b06309248f14f3bc9c4c5c50b32509018bedf"}, "originalPosition": 567}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM1MTk2NA==", "bodyText": "Will we have an iloadi node with a symbol reference of type byte(Int8) ? I think this can lead to some complications in the optimizer and the codegens.", "url": "https://github.com/eclipse-openj9/openj9/pull/11251#discussion_r552351964", "createdAt": "2021-01-06T03:42:49Z", "author": {"login": "gita-omr"}, "path": "runtime/compiler/optimizer/SequentialStoreSimplifier.cpp", "diffHunk": "@@ -677,621 +684,2233 @@ TR::Node* getALoadReferenceForSeqLoad(TR::Node* rootNode, int32_t totalBytes, in\n       }\n    }\n \n-bool TR_ShiftedValueTree::process(TR::Node* loadNode)\n+TR::TreeTop* seqLoadSearchAndCombine(TR::Compilation* comp, bool trace, TR_BitVector* visitedNodes, TR::TreeTop* currentTree, TR::Node* currentNode, NodeForwardList* combineNodeList)\n    {\n-\n-   bool shift = true;\n-   TR::ILOpCodes convCode = loadNode->getOpCodeValue();\n-   TR::ILOpCodes shiftCode, altShiftCode, constCode;\n-   int32_t size;\n-\n-   _isConst = false;\n-   switch(convCode)\n-      {\n-      case TR::s2b: shift = true;  _valueSize = 2; shiftCode = TR::sushr; altShiftCode = TR::sshr; constCode = TR::iconst; break;\n-      case TR::i2b: shift = true;  _valueSize = 4; shiftCode = TR::iushr; altShiftCode = TR::ishr; constCode = TR::iconst; break;\n-      case TR::l2b: shift = true;  _valueSize = 8; shiftCode = TR::lushr; altShiftCode = TR::lshr; constCode = TR::iconst; break;\n-      case TR::bload:\n-      case TR::bconst:\n-      case TR::sconst:\n-      case TR::iconst:\n-      case TR::lconst: shift = false; _valueSize = 1; _shiftValue = 0; break;\n-      default: return false;\n-      }\n-\n-//   dumpOptDetails(comp(), \"arraycopy sequential store - check load node %p\\n\", loadNode);\n-\n-   if (shift)\n+   /*\n+    * seqLoadSearchAndCombine recursively searches down the tree looking for a set of nodes that potentially matches\n+    * the pattern of byte loads to sequential memory locations that are used to construct a larger value.\n+    * This search looks at opcodes, const values and node reference counts to check for a match.\n+    * If these checks pass, generateArraycopyFromSequentialLoads is called which does a few more detailed check and\n+    * potentially performs the transformation to combine the byte loads together.\n+    */\n+   if (visitedNodes->isSet(currentNode->getGlobalIndex()))\n+      return currentTree;\n+\n+   visitedNodes->set(currentNode->getGlobalIndex());\n+\n+   /*\n+    * Combine nodes are the \"add\" and \"or\" nodes that construct the longer value out of several loaded bytes.\n+    * combineNodeList keeps tracks of the nodes used to construct one particular value. It is populated by isValidSeqLoadCombine.\n+    * combineNodeList needs to be cleared each time before it is repopulated.\n+    * isValidSeqLoadCombine also performs a series of initial checks to see if the tree structure contains the pattern\n+    * of byte loads that can be combined into wider loads.\n+    * combineNodeCount tracks the number of combine nodes.\n+    */\n+   combineNodeList->clear();\n+   int32_t combineNodeCount = 0;\n+   if (isValidSeqLoadCombine(comp, trace, currentNode, combineNodeList, combineNodeCount))\n       {\n-      if (loadNode->getFirstChild()->getOpCodeValue() != shiftCode && loadNode->getFirstChild()->getOpCodeValue() != altShiftCode)\n-         {\n-         _valNode = loadNode->getFirstChild();\n-         _shiftValue = 0;\n-         }\n-      else\n-         {\n-         TR::Node* shiftVal = loadNode->getFirstChild()->getSecondChild();\n-         if (shiftVal->getOpCodeValue() != constCode)\n-            {\n-            dumpOptDetails(comp(), \" Shifted Value: did not encounter correct const code\\n\");\n-            return false;\n-            }\n-         _valNode = loadNode->getFirstChild()->getFirstChild();\n-         switch(constCode)\n-            {\n-            case TR::sconst: _shiftValue = shiftVal->getShortInt(); break;\n-            case TR::iconst: _shiftValue = shiftVal->getInt(); break;\n-            case TR::lconst: _shiftValue = shiftVal->getLongInt(); break;\n-            default: break;\n-            }\n-         }\n+      /*\n+       * The initial tree structure seems good at this point. generateArraycopyFromSequentialLoads will do some additional\n+       * checks. If they also pass, it will combine the byte loads into wider loads.\n+       */\n+      currentTree = generateArraycopyFromSequentialLoads(comp, trace, currentTree, currentNode, combineNodeList);\n       }\n    else\n       {\n-      _valNode = loadNode;\n-      if (convCode != TR::bload)\n+      /* If the checks in isValidSeqLoadCombine fail, try again on the children. */\n+      for (int i = 0; i < currentNode->getNumChildren(); i++)\n          {\n-         _isConst = true;\n+         currentTree = seqLoadSearchAndCombine(comp, trace, visitedNodes, currentTree, currentNode->getChild(i), combineNodeList);\n          }\n       }\n \n-   if ((_shiftValue % 8) != 0 || (_shiftValue < 0) || (_shiftValue >= _valueSize*8))\n-      {\n-      dumpOptDetails(comp(), \"Shifted Value: did not encounter valid shift value %d for var size %d\\n\", _shiftValue, _valueSize);\n-      return false;\n-      }\n-\n-   _rootNode = loadNode;\n-\n-   return true;\n+   return currentTree;\n    }\n \n-bool TR_arraycopySequentialStores::checkAiadd(TR::TreeTop * currentTree, TR::Node* aiaddNode)\n+bool isValidSeqLoadCombine(TR::Compilation* comp, bool trace, TR::Node* combineNode, NodeForwardList* combineNodeList, int32_t &combineNodeCount)\n    {\n-//   dumpOptDetails(comp(), \"arraycopy sequential store - check aiadd node %p\\n\", aiaddNode);\n-   _activeAddrTree = new (trStackMemory()) TR_AddressTree(stackAlloc, comp());\n-   _activeTreeTop = currentTree;\n-   if (_activeAddrTree->process(aiaddNode, _comp->cg()->getSupportsAlignedAccessOnly()))\n+   /*\n+    * Combine nodes are the \"add\" and \"or\" nodes that construct the longer value out of several loaded bytes.\n+    * This layer of checks is focused on the \"add\" and \"or\" nodes that construct the final value out of the\n+    * loaded value. It calls other functions the confirm that those loaded values are properly processed byte values.\n+    */\n+\n+   /* Check if the candidate combine node is: iadd, ior, ladd, lor */\n+   if ((combineNode->getOpCodeValue() != TR::iadd) && (combineNode->getOpCodeValue() != TR::ior) &&\n+       (combineNode->getOpCodeValue() != TR::ladd) && (combineNode->getOpCodeValue() != TR::lor))\n       {\n-      return insertConsistentTree();\n+      return false;\n       }\n-   return false;\n-   }\n \n-void TR_arraycopySequentialStores::insertTree(int entry)\n-   {\n-//   dumpOptDetails(comp(), \" insert nodes %p,%p into entry %d\\n\",\n-//      _activeAddrTree->getRootNode(), _activeValueTree->getRootNode(), entry);\n-   if ((_addrTree[entry] != NULL) && (entry < _maxAddressTrees))\n+   /*\n+    * Only the topmost combine node (the first one to be looked at) can have a reference count greater than 1.\n+    * If not, it means the intermediate values when constructing the larger value are used in other places and still\n+    * needs to be generated.\n+    */\n+   if ((combineNodeCount > 0) && (combineNode->getReferenceCount() != 1))\n       {\n-      memmove(&_addrTree[entry+1], &_addrTree[entry], (_maxAddressTrees-entry-1)*sizeof(TR_AddressTree*));\n-      memmove(&_val[entry+1], &_val[entry],  (_maxAddressTrees-entry-1)*sizeof(TR_ShiftedValueTree*));\n-      memmove(&_treeTops[entry+1], &_treeTops[entry], (_maxAddressTrees-entry-1)*sizeof(TR::TreeTop*));\n+      return false;\n       }\n-   _addrTree[entry] = _activeAddrTree;\n-   _val[entry] = _activeValueTree;\n-   _treeTops[entry] = _activeTreeTop;\n-   }\n \n-bool TR_arraycopySequentialStores::insertConsistentTree()\n-   {\n+   /* The node being looked at is a potential combine node so it gets added to the list. */\n+   combineNodeList->push_front(combineNode);\n+   combineNodeCount++;\n \n-   // these are byte arrays we are working with - the multiplier must be 1\n-   if (_activeAddrTree->getMultiplier() != 1)\n+   /*\n+    * If int width combine nodes are being used, no more than 4 bytes can be combined which means no more than 3 combine nodes.\n+    * If long width combine nodes are being used, no more than 8 bytes can be combined which means no more than 7 combine nodes.\n+    */\n+   if ((combineNodeCount > 3) && ((combineNode->getOpCodeValue() == TR::iadd) || (combineNode->getOpCodeValue() == TR::ior)))\n       {\n-      dumpOptDetails(comp(), \" insertTree: multiplier must be 1 in aiadd tree\\n\");\n       return false;\n       }\n-   TR::SymbolReference* activeBaseRef = _activeAddrTree->getBaseVarNode()->isNull() ? NULL : _activeAddrTree->getBaseVarNode()->getChild()->skipConversions()->getSymbolReference();\n-   if (activeBaseRef == NULL)\n+   else if ((combineNodeCount > 7) && ((combineNode->getOpCodeValue() == TR::ladd) || (combineNode->getOpCodeValue() == TR::lor)))\n       {\n-      dumpOptDetails(comp(), \" insertTree: no base variable in aiadd tree\\n\");\n       return false;\n       }\n \n-   if (_addrTree[0] == NULL)\n-      {\n-//      dumpOptDetails(comp(), \" insertTree: first tree inserted successfully with offset: %d\\n\", _activeAddrTree->getOffset());\n-      insertTree(0);\n-      return true;\n-      }\n+   TR::Node* childrenArray[2];\n+   childrenArray[0] = combineNode->getFirstChild();\n+   childrenArray[1] = combineNode->getSecondChild();\n \n-   // make sure the index variable and base variable is consistent with the first tree\n-   TR::SymbolReference* baseRef = _addrTree[0]->getBaseVarNode()->isNull() ? NULL : _addrTree[0]->getBaseVarNode()->getChild()->skipConversions()->getSymbolReference();\n-   if (baseRef != activeBaseRef)\n+   /*\n+    * Check if the children match the pattern for combining byte loads.\n+    * There is an optional mul/shl layer.\n+    * There is an optional and layer.\n+    * The byte conversion nodes are the ones on the path to the byte loads.\n+    * The child can also be another combine node (add/or).\n+    */\n+   for (int i = 0; i < 2; i++)\n       {\n-      dumpOptDetails(comp(), \" insertTree: base variable is different than previous tree\\n\");\n-      return false;\n+      TR::ILOpCodes childOpCode = childrenArray[i]->getOpCodeValue();\n+\n+      switch (childOpCode)\n+         {\n+         case TR::imul:\n+         case TR::ishl:\n+         case TR::lmul:\n+         case TR::lshl:\n+            if (!isValidSeqLoadMulOrShl(comp, trace, childrenArray[i]))\n+               return false;\n+            break;\n+         case TR::iand:\n+         case TR::land:\n+            if (!isValidSeqLoadAnd(comp, trace, childrenArray[i]))\n+               return false;\n+            break;\n+         case TR::b2i:\n+         case TR::b2l:\n+         case TR::bu2i:\n+         case TR::bu2l:\n+            if (!isValidSeqLoadByteConversion(comp, trace, childrenArray[i]))\n+               return false;\n+            break;\n+         case TR::iadd:\n+         case TR::ior:\n+         case TR::ladd:\n+         case TR::lor:\n+            if (!isValidSeqLoadCombine(comp, trace, childrenArray[i], combineNodeList, combineNodeCount))\n+               return false;\n+            break;\n+         default:\n+            return false;\n+         }\n       }\n \n-   TR::SymbolReference* indRef = _addrTree[0]->getIndVarNode()->isNull() ? NULL : _addrTree[0]->getIndVarNode()->getChild()->skipConversions()->getSymbolReference();\n-   TR::SymbolReference* activeIndRef = _activeAddrTree->getIndVarNode()->isNull() ? NULL : _activeAddrTree->getIndVarNode()->getChild()->skipConversions()->getSymbolReference();\n+   return true;\n+   }\n \n-   TR::Node* indBase = NULL;\n-   TR::Node* activeIndBase = NULL;\n-   if (!_addrTree[0]->getIndexBase()->isNull())\n-      indBase = _addrTree[0]->getIndexBase()->getParent();\n-   if (!_activeAddrTree->getIndexBase()->isNull())\n-      activeIndBase = _activeAddrTree->getIndexBase()->getParent();\n+bool isValidSeqLoadMulOrShl(TR::Compilation* comp, bool trace, TR::Node* mulOrShlNode)\n+   {\n+   /*\n+    * A mul or shl node is used to move the loaded byte into the proper position such that they can be combined\n+    * together with \"add\" or \"or\" nodes later on to construct the final value.\n+    * isValidSeqLoadMulOrShl checks the ref counts on the mul/shl node and that the const child have one of the\n+    * possible expected values.\n+    * The validity of the non-const child is handled by calling out to another function.\n+    */\n \n-   if (indRef != activeIndRef || indBase != activeIndBase)\n+   /* Confirm that the input mulOrShlNode is one of: imul, ishl, lmul, lshl */\n+   if ((mulOrShlNode->getOpCodeValue() != TR::imul) && (mulOrShlNode->getOpCodeValue() != TR::ishl) &&\n+       (mulOrShlNode->getOpCodeValue() != TR::lmul) && (mulOrShlNode->getOpCodeValue() != TR::lshl))\n       {\n-      dumpOptDetails(comp(), \" insertTree: index variable is different than previous tree\\n\");\n       return false;\n       }\n \n-   // make sure the value being loaded is consistent with the first tree\n-   if (_val[0]->isConst() !=  _activeValueTree->isConst())\n+   /*\n+    * mulOrShlNode must have a refCount of 1. After the transformation the intermediate value generated by this node\n+    * won't be calculated. If the value is needed for something else, the transformation needs to bail out here.\n+    */\n+   if (mulOrShlNode->getReferenceCount() != 1)\n       {\n-      dumpOptDetails(comp(), \" insertTree: const value attributes inconsistent\\n\");\n       return false;\n       }\n \n-   if (!_val[0]->isConst() && (_val[0]->getValNode() != _activeValueTree->getValNode()))\n+   TR::Node* firstChild = mulOrShlNode->getFirstChild();\n+   TR::Node* secondChild = mulOrShlNode->getSecondChild();\n+\n+   /*\n+    * Check if the first child matches the pattern.\n+    * There is an optional and layer.\n+    * The byte conversion nodes are the ones on the path to the byte loads.\n+    */\n+   switch (firstChild->getOpCodeValue())\n       {\n-      dumpOptDetails(comp(), \" insertTree: value variable is different than previous tree\\n\");\n-      return false;\n+      case TR::iand:\n+      case TR::land:\n+         if (!isValidSeqLoadAnd(comp, trace, firstChild))\n+            return false;\n+         break;\n+      case TR::b2i:\n+      case TR::b2l:\n+      case TR::bu2i:\n+      case TR::bu2l:\n+         if (!isValidSeqLoadByteConversion(comp, trace, firstChild))\n+            return false;\n+         break;\n+      default:\n+         return false;\n       }\n \n-   // make sure the value tree doesn't reference the address tree base var\n-   if (_activeValueTree->getRootNode()->referencesSymbolInSubTree(baseRef, _comp->incOrResetVisitCount()))\n+   /*\n+    * The second child must a const node and only certain values are valid.\n+    * These values correspond with the constants needed to shift a loaded byte left by multiples of 8 bits.\n+    */\n+   if ((secondChild->getOpCodeValue() != TR::iconst) && (secondChild->getOpCodeValue() != TR::lconst))\n       {\n-      dumpOptDetails(comp(), \" insertTree: value tree %p references address tree base var\\n\", _activeValueTree->getRootNode());\n       return false;\n       }\n \n-//   dumpOptDetails(comp(), \" insertTree: tree inserted successfully. offset:%d\\n\", _activeAddrTree->getOffset());\n-   int entry;\n-   for (entry=0; entry < _maxAddressTrees && _addrTree[entry] != NULL; ++entry)\n+   if (mulOrShlNode->getOpCodeValue() == TR::imul)\n       {\n-      if (_activeAddrTree->getOffset() < _addrTree[entry]->getOffset())\n+      switch (secondChild->getInt())\n          {\n-         insertTree(entry);\n-         return true;\n+         case 0x100:     /* 256   */\n+         case 0x10000:   /* 256^2 */\n+         case 0x1000000: /* 256^3 */\n+            break;\n+         default:\n+            return false;\n+         }\n+      }\n+   else if (mulOrShlNode->getOpCodeValue() == TR::ishl)\n+      {\n+      switch (secondChild->getInt())\n+         {\n+         case 8:\n+         case 16:\n+         case 24:\n+            break;\n+         default:\n+            return false;\n+         }\n+      }\n+   else if (mulOrShlNode->getOpCodeValue() == TR::lmul)\n+      {\n+      switch (secondChild->getLongInt())\n+         {\n+         case 0x100L:             /* 256   */\n+         case 0x10000L:           /* 256^2 */\n+         case 0x1000000L:         /* 256^3 */\n+         case 0x100000000L:       /* 256^4 */\n+         case 0x10000000000L:     /* 256^5 */\n+         case 0x1000000000000L:   /* 256^6 */\n+         case 0x100000000000000L: /* 256^7 */\n+            break;\n+         default:\n+            return false;\n+         }\n+      }\n+   else /* mulOrShlNode->getOpCodeValue() == TR::lshl */\n+      {\n+      switch (secondChild->getInt())\n+         {\n+         case 8:\n+         case 16:\n+         case 24:\n+         case 32:\n+         case 40:\n+         case 48:\n+         case 56:\n+            break;\n+         default:\n+            return false;\n          }\n       }\n \n-   insertTree(entry);\n    return true;\n    }\n \n-\n-int TR_arraycopySequentialStores::numTrees()\n+bool isValidSeqLoadAnd(TR::Compilation* comp, bool trace, TR::Node* andNode)\n    {\n-   int i;\n-   for (i=0; i<_maxAddressTrees; ++i)\n+   /*\n+    * Sometimes the loaded byte is and'd with 0xFF so that bits set due to sign extension are cleared.\n+    * This is done so those bits do not interfere when the bytes are combined via add/or nodes.\n+    * The non const child must be a byte to int conversion node which is passed to another function to be\n+    * verified.\n+    */\n+\n+   /* Confirm that the input andNode is one of: iand, land */\n+   if ((andNode->getOpCodeValue() != TR::iand) && (andNode->getOpCodeValue() != TR::land))\n       {\n-      if (_addrTree[i] == NULL)\n-         return i;\n+      return false;\n       }\n-   return _maxAddressTrees;\n-   }\n \n-int TR_arraycopySequentialStores::numValidTrees(int maxEntries)\n-   {\n-   int dir = (_bigEndian) ? -1 : 1;\n-   int entry;\n+   /*\n+    * andNode must have a refCount of 1. After the transformation the intermediate value generated by this node\n+    * won't be calculated. If the value is needed for something else, the transformation needs to bail out here.\n+    */\n+   if (andNode->getReferenceCount() != 1)\n+      {\n+      return false;\n+      }\n \n-//   dumpOptDetails(comp(), \"...check if valid entries\\n\");\n-   for (entry=1; (_addrTree[entry] != NULL) && (entry < maxEntries); ++entry)\n+   TR::Node* firstChild = andNode->getFirstChild();\n+   TR::Node* secondChild = andNode->getSecondChild();\n+\n+   /*\n+    * Check if the first child matches the pattern.\n+    * The byte conversion nodes are the ones on the path to the byte loads.\n+    */\n+   switch (firstChild->getOpCodeValue())\n       {\n-      if (_addrTree[entry]->getOffset() != _addrTree[0]->getOffset() + entry)\n-         {\n+      case TR::b2i:\n+      case TR::b2l:\n+      case TR::bu2i:\n+      case TR::bu2l:\n+         if (!isValidSeqLoadByteConversion(comp, trace, firstChild))\n+            return false;\n          break;\n-         }\n-      if (!hasConstValue() && (_val[entry]->getShiftValue() != _val[0]->getShiftValue() + dir*8*entry))\n+      default:\n+         return false;\n+      }\n+\n+   /*\n+    * The second child must a const node and only 0xFF is valid.\n+    * This node is supposed to act as a mask so that only 8 bits are affected when this is combined via add/or with the other\n+    * loaded bytes.\n+    */\n+   if (secondChild->getOpCodeValue() == TR::iconst)\n+      {\n+      if (secondChild->getInt() != 0xFF)\n          {\n-         break;\n+         return false;\n          }\n       }\n-   if ((entry == 1) && !hasConstValue() && _comp->cg()->supportsByteswap())\n+   else if (secondChild->getOpCodeValue() == TR::lconst)\n       {\n-//      dumpOptDetails(comp(), \"...no valid entries forward\\n...see if reverse store finds any entries\\n\");\n-      _alternateDir = true;\n-      // repeat process for reversed store\n-      dir = (_bigEndian) ? 1 : -1;\n-      for (entry=1; (_addrTree[entry] != NULL) && (entry < maxEntries); ++entry)\n+      if (secondChild->getLongInt() != 0xFF)\n          {\n-         if (_addrTree[entry]->getOffset() != _addrTree[0]->getOffset() + entry)\n-            {\n-            break;\n-            }\n-         if (_val[entry]->getShiftValue() != _val[0]->getShiftValue() + dir*8*entry)\n-            {\n-            break;\n-            }\n+         return false;\n          }\n       }\n-   if (entry > 1)\n+   else\n       {\n-      dumpOptDetails(comp(), \"Found %d sequential valid trees\\n\", entry);\n+      return false;\n       }\n-   return entry;\n+\n+   return true;\n    }\n \n-bool TR_arraycopySequentialStores::checkTrees()\n+bool isValidSeqLoadByteConversion(TR::Compilation* comp, bool trace, TR::Node* conversionNode)\n    {\n-   if (_val[0] == NULL)\n+   /*\n+    * This function checks the opcode and reference counts related to nodes that perform the byte load and\n+    * convert to an int or a long.\n+    *\n+    * Example tree:\n+    * b2i        <--- conversionNode\n+    *   bloadi\n+    *     aladd\n+    *       aload/aloadi\n+    *       lsub/ladd\n+    *         **basePointerNode**\n+    *         lconst\n+    */\n+\n+   /* Confirm that the input conversionNode is one of: b2i, b2l, bu2i, bu2l */\n+   if ((conversionNode->getOpCodeValue() != TR::b2i) && (conversionNode->getOpCodeValue() != TR::bu2i) &&\n+       (conversionNode->getOpCodeValue() != TR::b2l) && (conversionNode->getOpCodeValue() != TR::bu2l))\n       {\n       return false;\n       }\n \n-   if (hasConstValue())\n+   /*\n+    * conversionNode must have a refCount of 1. After the transformation the intermediate value generated by this node\n+    * won't be calculated. If the value is needed for something else, the transformation needs to bail out here.\n+    */\n+   if (conversionNode->getReferenceCount() != 1)\n       {\n-      _numBytes = numValidTrees();\n+      return false;\n       }\n-   else\n+\n+   TR::Node* firstChild = conversionNode->getFirstChild();\n+   TR::Node* secondChild = NULL;\n+\n+   /*\n+    * conversionNode's child must be a bloadi with a refcount of 1. After the transformation the intermediate value generated by this node\n+    * won't be calculated. If the value is needed for something else, the transformation needs to bail out here.\n+    */\n+   if ((firstChild->getOpCodeValue() != TR::bloadi) || (firstChild->getReferenceCount() != 1))\n       {\n-      _numBytes = numValidTrees(_val[0]->getValueSize());\n+      return false;\n       }\n \n-   return (_numBytes == 2 || _numBytes == 4 || _numBytes == 8);\n+   firstChild = firstChild->getFirstChild();\n+\n+   if (comp->target().is64Bit())\n+      {\n+      /*\n+       * Under 64bit, bloadi's child must be an aladd node. Some of the aladd nodes go away after the transformation.\n+       * So, if the refCount is not 1, bail out here.\n+       */\n+      if ((firstChild->getOpCodeValue() != TR::aladd) || (firstChild->getReferenceCount() != 1))\n+         {\n+         return false;\n+         }\n+\n+      secondChild = firstChild->getSecondChild();\n+      firstChild = firstChild->getFirstChild();\n+\n+      /* aladd's first child can be aload or aloadi. This load is kept so there is no refcount restriction. */\n+      if ((firstChild->getOpCodeValue() != TR::aload) && (firstChild->getOpCodeValue() != TR::aloadi))\n+         {\n+         return false;\n+         }\n+\n+      /*\n+       * aladd's second child can be an lconst, ladd or lsub. The ladd or lsub might go away after transformation\n+       * so they must have a refCount of 1.\n+       */\n+      if (secondChild->getReferenceCount() != 1)\n+         {\n+         if (secondChild->getOpCodeValue() != TR::lconst)\n+            {\n+            return false;\n+            }\n+         }\n+      else\n+         {\n+         if ((secondChild->getOpCodeValue() != TR::lconst) &&\n+             (secondChild->getOpCodeValue() != TR::ladd)   &&\n+             (secondChild->getOpCodeValue() != TR::lsub))\n+            {\n+            return false;\n+            }\n+         }\n+\n+      /* If the second child is lsub or ladd, make sure that node's second child is an lconst. */\n+      if (secondChild->getOpCodeValue() != TR::lconst)\n+         {\n+         secondChild = secondChild->getSecondChild();\n+\n+         if (secondChild->getOpCodeValue() != TR::lconst)\n+            {\n+            return false;\n+            }\n+         }\n+      }\n+   else\n+      {\n+      /*\n+       * Under 32bit, bloadi's child must be an aiadd node. Some of the aiadd nodes go away after the transformation.\n+       * So, if the refCount is not 1, bail out here.\n+       */\n+      if ((firstChild->getOpCodeValue() != TR::aiadd) || (firstChild->getReferenceCount() != 1))\n+         {\n+         return false;\n+         }\n+\n+      secondChild = firstChild->getSecondChild();\n+      firstChild = firstChild->getFirstChild();\n+\n+      /* aiadd's first child can be aload or aloadi. This load is kept so there is no refcount restriction. */\n+      if ((firstChild->getOpCodeValue() != TR::aload) && (firstChild->getOpCodeValue() != TR::aloadi))\n+         {\n+         return false;\n+         }\n+\n+      /*\n+       * aiadd's second child can be an iconst, iadd or isub. The iadd or isub might go away after transformation\n+       * so they must have a refCount of 1.\n+       */\n+      if (secondChild->getReferenceCount() != 1)\n+         {\n+         if (secondChild->getOpCodeValue() != TR::iconst)\n+            {\n+            return false;\n+            }\n+         }\n+      else\n+         {\n+         if ((secondChild->getOpCodeValue() != TR::iconst) &&\n+             (secondChild->getOpCodeValue() != TR::iadd)   &&\n+             (secondChild->getOpCodeValue() != TR::isub))\n+            {\n+            return false;\n+            }\n+         }\n+\n+      /* If the second child is isub or iadd, make sure that node's second child is an iconst. */\n+      if (secondChild->getOpCodeValue() != TR::iconst)\n+         {\n+         secondChild = secondChild->getSecondChild();\n+\n+         if (secondChild->getOpCodeValue() != TR::iconst)\n+            {\n+            return false;\n+            }\n+         }\n+      }\n+\n+   return true;\n+   }\n+\n+int64_t getOffsetForSeqLoad(TR::Compilation* comp, TR::Node* byteConversionNode)\n+   {\n+   /*\n+    * Returns the constant offset from basePointerNode. Offset from aload/aloadi if there is no basePointerNode.\n+    * byteConversionNode must be: b2i, b2l, bu2i, bu2l\n+    *\n+    * Example tree: (sub/add version)\n+    * b2i        <--- byteConversionNode\n+    *   bloadi\n+    *     aladd\n+    *       aload/aloadi\n+    *       lsub/ladd     <<--- displacementNode\n+    *         **basePointerNode**\n+    *         lconst      <<--- return value\n+    *\n+    *\n+    * Example tree: (const version)\n+    * b2i        <--- byteConversionNode\n+    *   bloadi\n+    *     aladd\n+    *       aload/aloadi\n+    *       lconst        <<--- displacementNode, return value\n+    */\n+\n+\n+   if ((byteConversionNode->getOpCodeValue() != TR::b2i) && (byteConversionNode->getOpCodeValue() != TR::bu2i) &&\n+       (byteConversionNode->getOpCodeValue() != TR::b2l) && (byteConversionNode->getOpCodeValue() != TR::bu2l))\n+      {\n+      TR_ASSERT_FATAL_WITH_NODE(byteConversionNode, 0, \"Unsupported opCode. This should have been caught earlier. byteConversionNode: %p.\", byteConversionNode);\n+      }\n+\n+   TR::Node* displacementNode = byteConversionNode->getFirstChild()->getFirstChild()->getSecondChild();\n+\n+   if (comp->target().is64Bit())\n+      {\n+      if (displacementNode->getOpCodeValue() == TR::lconst)\n+         {\n+         return displacementNode->getLongInt();\n+         }\n+      else if (displacementNode->getOpCodeValue() == TR::lsub)\n+         {\n+         return displacementNode->getSecondChild()->getLongInt() * -1;\n+         }\n+      else //displacementNode->getOpCodeValue() == TR::ladd\n+         {\n+         return displacementNode->getSecondChild()->getLongInt();\n+         }\n+      }\n+   else\n+      {\n+      if (displacementNode->getOpCodeValue() == TR::iconst)\n+         {\n+         return displacementNode->getInt();\n+         }\n+      else if (displacementNode->getOpCodeValue() == TR::isub)\n+         {\n+         return displacementNode->getSecondChild()->getInt() * -1;\n+         }\n+      else //displacementNode->getOpCodeValue() == TR::iadd\n+         {\n+         return displacementNode->getSecondChild()->getInt();\n+         }\n+      }\n+   }\n+\n+TR::Node* getBasePointerReferenceForSeqLoad(TR::Node* inputNode)\n+   {\n+   /*\n+    * Returns the basePointerNode. Returns NULL if there is no basePointerNode.\n+    * inputNode is a child of a combine node that is not also a combine node.\n+    * Combine nodes are the add/or nodes that construct the longer value out of seperate loaded bytes.\n+    *\n+    * Example tree: (sub/add version)\n+    * b2i        <--- inputNode\n+    *   bloadi\n+    *     aladd\n+    *       aload/aloadi\n+    *       lsub/ladd     <<--- displacementNode\n+    *         **basePointerNode**  <<--- return basePointerNode (search down past any conversion nodes, if any)\n+    *         lconst\n+    *\n+    *\n+    * Example tree: (const version)\n+    * b2i        <--- inputNode\n+    *   bloadi\n+    *     aladd\n+    *       aload/aloadi\n+    *       lconst        <<--- displacementNode, return NULL\n+    */\n+\n+\n+   TR::Node* basePointerNode = NULL;\n+   TR::Node* displacementNode = NULL;\n+\n+   switch (inputNode->getOpCodeValue())\n+      {\n+      case TR::iand:\n+      case TR::imul:\n+      case TR::ishl:\n+      case TR::land:\n+      case TR::lmul:\n+      case TR::lshl:\n+         /* Keep searching down for the b2i node. */\n+         basePointerNode = getBasePointerReferenceForSeqLoad(inputNode->getFirstChild());\n+         break;\n+      case TR::b2i:\n+      case TR::b2l:\n+      case TR::bu2i:\n+      case TR::bu2l:\n+         displacementNode = inputNode->getFirstChild()->getFirstChild()->getSecondChild();\n+         if ((displacementNode->getOpCodeValue() == TR::iconst) || (displacementNode->getOpCodeValue() == TR::lconst))\n+            {\n+            basePointerNode = NULL;\n+            break;\n+            }\n+         basePointerNode = displacementNode->getFirstChild()->skipConversions();\n+         break;\n+      default:\n+         TR_ASSERT_FATAL_WITH_NODE(inputNode, 0, \"Unsupported opCode. This should have been caught earlier. inputNode: %p.\", inputNode);\n+         break;\n+      }\n+\n+   return basePointerNode;\n+   }\n+\n+int32_t convertMultValueToShiftValue(int64_t multValue)\n+   {\n+   /*\n+    * Converts the constant used for multiplication into the equivalent number of shifted bits.\n+    * Prior checks should have already been done to ensure that the multiplication value is one of the listed cases.\n+    */\n+   switch (multValue)\n+      {\n+      case 0x100L:             /* 256   */\n+         return 8;\n+      case 0x10000L:           /* 256^2 */\n+         return 16;\n+      case 0x1000000L:         /* 256^3 */\n+         return 24;\n+      case 0x100000000L:       /* 256^4 */\n+         return 32;\n+      case 0x10000000000L:     /* 256^5 */\n+         return 40;\n+      case 0x1000000000000L:   /* 256^6 */\n+         return 48;\n+      case 0x100000000000000L: /* 256^7 */\n+         return 56;\n+      default:\n+         TR_ASSERT_FATAL(0, \"Unknown multValue. This should have been caught earlier. multValue: %ld.\", multValue);\n+         return -1;\n+      }\n+   }\n+\n+int32_t getShiftValueForSeqLoad(TR::Node* inputNode)\n+   {\n+   /*\n+    * Returns the number of bits a byte is shifted by before being combined with the other bytes.\n+    * The purpose of this is to shift the byte into the right place.\n+    * If inputNode is a mul node, the mult value is converted to a shift value before being returned.\n+    * If it is a shl node instead, return the const on the second child.\n+    * If it is not mul or shift, the shiftValue is 0.\n+    *\n+    * inputNode is a child of a combine node that is not also a combine node.\n+    * Combine nodes are the add/or nodes that construct the longer value out of seperate loaded bytes.\n+    */\n+\n+   int32_t shiftValue = 0;\n+\n+   switch (inputNode->getOpCodeValue())\n+      {\n+      case TR::imul:\n+         shiftValue = convertMultValueToShiftValue(inputNode->getSecondChild()->getInt());\n+         break;\n+      case TR::lmul:\n+         shiftValue = convertMultValueToShiftValue(inputNode->getSecondChild()->getLongInt());\n+         break;\n+      case TR::ishl:\n+      case TR::lshl:\n+         shiftValue = inputNode->getSecondChild()->getInt();\n+         break;\n+      case TR::b2i:\n+      case TR::b2l:\n+      case TR::bu2i:\n+      case TR::bu2l:\n+      case TR::iand:\n+      case TR::land:\n+         shiftValue = 0;\n+         break;\n+      default:\n+         TR_ASSERT_FATAL_WITH_NODE(inputNode, 0, \"Unsupported opCode. This should have been caught earlier. inputNode: %p.\", inputNode);\n+         break;\n+      }\n+\n+   return shiftValue;\n+   }\n+\n+TR::Node* getALoadReferenceForSeqLoad(TR::Node* inputNode)\n+   {\n+   /*\n+    * Returns the node that loads the address of the byte array.\n+    * inputNode is a child of a combine node that is not also a combine node.\n+    * Combine nodes are the add/or nodes that construct the longer value out of seperate loaded bytes.\n+    *\n+    * Example tree:\n+    * b2i        <--- inputNode\n+    *   bloadi\n+    *     aladd\n+    *       aload/aloadi  <<--- aloadNode\n+    *       lsub/ladd\n+    *         **basePointerNode**\n+    *         lconst\n+    */\n+\n+\n+   TR::Node* aloadNode = NULL;\n+\n+   switch (inputNode->getOpCodeValue())\n+      {\n+      case TR::iand:\n+      case TR::imul:\n+      case TR::ishl:\n+      case TR::land:\n+      case TR::lmul:\n+      case TR::lshl:\n+         /* Keep searching down for the b2i node. */\n+         aloadNode = getALoadReferenceForSeqLoad(inputNode->getFirstChild());\n+         break;\n+      case TR::b2i:\n+      case TR::b2l:\n+      case TR::bu2i:\n+      case TR::bu2l:\n+         aloadNode = inputNode->getFirstChild()->getFirstChild()->getFirstChild();\n+         break;\n+      default:\n+         TR_ASSERT_FATAL_WITH_NODE(inputNode, 0, \"Unsupported opCode. This should have been caught earlier. inputNode: %p.\", inputNode);\n+         break;\n+      }\n+\n+   return aloadNode;\n+   }\n+\n+TR::Node* getByteConversionNodeForSeqLoad(TR::Node* inputNode)\n+   {\n+   /*\n+    * Returns the byte conversion node.\n+    * inputNode is a child of a combine node that is not also a combine node.\n+    * Combine nodes are the add/or nodes that construct the longer value out of seperate loaded bytes.\n+    *\n+    * Example tree:\n+    * b2i        <--- inputNode, byteConversionNode\n+    *   bloadi\n+    *     aladd\n+    *       aload/aloadi\n+    *       lsub/ladd\n+    *         **basePointerNode**\n+    *         lconst\n+    */\n+\n+\n+   TR::Node* byteConversionNode = NULL;\n+\n+   switch (inputNode->getOpCodeValue())\n+      {\n+      case TR::iand:\n+      case TR::imul:\n+      case TR::ishl:\n+      case TR::land:\n+      case TR::lmul:\n+      case TR::lshl:\n+         /* Keep searching down for the b2i node. */\n+         byteConversionNode = getByteConversionNodeForSeqLoad(inputNode->getFirstChild());\n+         break;\n+      case TR::b2i:\n+      case TR::b2l:\n+      case TR::bu2i:\n+      case TR::bu2l:\n+         byteConversionNode = inputNode;\n+         break;\n+      default:\n+         TR_ASSERT_FATAL_WITH_NODE(inputNode, 0, \"Unsupported opCode. This should have been caught earlier. inputNode: %p.\", inputNode);\n+         break;\n+      }\n+\n+   return byteConversionNode;\n+   }\n+\n+bool checkForSeqLoadSignExtendedByte(TR::Node* inputNode)\n+   {\n+   /*\n+    * Checks if the loaded byte needs to be sign extended or not.\n+    * If bu2i/bu2l nodes are used, the loaded byte is unsigned.\n+    * If iand/land nodes are used, the loaded byte was masked with 0xFF and is treated as unsigned.\n+    * If b2i/b2l nodes are used, the loaded byte is signed. If it is the most significant byte, it will need to\n+    * be sign extended later. If it isn't the most significant byte, the transformation will bail out since the\n+    * sign bits may interfere with the other loaded bytes.\n+    *\n+    * inputNode is a child of a combine node that is not also a combine node.\n+    * Combine nodes are the add/or nodes that construct the longer value out of seperate loaded bytes.\n+    *\n+    * Example tree:\n+    * iand     <--- inputNode\n+    *   b2i\n+    *     bloadi\n+    *       aladd\n+    *         aload/aloadi\n+    *         lsub/ladd\n+    *           **basePointerNode**\n+    *           lconst\n+    *   iconst 0xFF\n+    */\n+\n+\n+   bool signExtendedByte = false;\n+\n+   switch (inputNode->getOpCodeValue())\n+      {\n+      case TR::imul:\n+      case TR::ishl:\n+      case TR::lmul:\n+      case TR::lshl:\n+         /* Keep searching down for the b2i/and node. */\n+         signExtendedByte = checkForSeqLoadSignExtendedByte(inputNode->getFirstChild());\n+         break;\n+      case TR::bu2i:\n+      case TR::bu2l:\n+      case TR::iand:\n+      case TR::land:\n+         signExtendedByte = false;\n+         break;\n+      case TR::b2i:\n+      case TR::b2l:\n+         signExtendedByte = true;\n+         break;\n+      default:\n+         TR_ASSERT_FATAL_WITH_NODE(inputNode, 0, \"Unsupported opCode. This should have been caught earlier. inputNode: %p.\", inputNode);\n+         break;\n+      }\n+\n+   return signExtendedByte;\n+   }\n+\n+bool matchLittleEndianSeqLoadPattern(int64_t byteOffsets[], int32_t byteCount)\n+   {\n+   /*\n+    * byteOffsets array contains relative locations that each byte is loaded from.\n+    * byteCount is the total number of bytes.\n+    * byteOffsets[0] is the offset of the least significant byte.\n+    * byteOffsets[byteCount-1] is the offset of the most significant byte.\n+    * To be an LE load, the offset needs to go *UP* by exactly 1 when going from 0 to (byteCount-1).\n+    */\n+   int64_t currentByteOffset = byteOffsets[0];\n+\n+   for (int i = 1; i < byteCount; i++)\n+      {\n+      if (byteOffsets[i] != (currentByteOffset + 1))\n+         {\n+         return false;\n+         }\n+      currentByteOffset = byteOffsets[i];\n+      }\n+\n+   return true;\n+   }\n+\n+bool matchBigEndianSeqLoadPattern(int64_t byteOffsets[], int32_t byteCount)\n+   {\n+   /*\n+    * byteOffsets array contains relative locations that each byte is loaded from.\n+    * byteCount is the total number of bytes.\n+    * byteOffsets[0] is the offset of the least significant byte.\n+    * byteOffsets[byteCount-1] is the offset of the most significant byte.\n+    * To be an BE load, the offset needs to go *DOWN* by exactly 1 when going from 0 to (byteCount-1).\n+    */\n+   int64_t currentByteOffset = byteOffsets[0];\n+\n+   for (int i = 1; i < byteCount; i++)\n+      {\n+      if (byteOffsets[i] != (currentByteOffset - 1))\n+         {\n+         return false;\n+         }\n+      currentByteOffset = byteOffsets[i];\n+      }\n+\n+   return true;\n+   }\n+\n+bool TR_ShiftedValueTree::process(TR::Node* loadNode)\n+   {\n+\n+   bool shift = true;\n+   TR::ILOpCodes convCode = loadNode->getOpCodeValue();\n+   TR::ILOpCodes shiftCode, altShiftCode, constCode;\n+   int32_t size;\n+\n+   _isConst = false;\n+   switch(convCode)\n+      {\n+      case TR::s2b: shift = true;  _valueSize = 2; shiftCode = TR::sushr; altShiftCode = TR::sshr; constCode = TR::iconst; break;\n+      case TR::i2b: shift = true;  _valueSize = 4; shiftCode = TR::iushr; altShiftCode = TR::ishr; constCode = TR::iconst; break;\n+      case TR::l2b: shift = true;  _valueSize = 8; shiftCode = TR::lushr; altShiftCode = TR::lshr; constCode = TR::iconst; break;\n+      case TR::bload:\n+      case TR::bconst:\n+      case TR::sconst:\n+      case TR::iconst:\n+      case TR::lconst: shift = false; _valueSize = 1; _shiftValue = 0; break;\n+      default: return false;\n+      }\n+\n+//   dumpOptDetails(comp(), \"arraycopy sequential store - check load node %p\\n\", loadNode);\n+\n+   if (shift)\n+      {\n+      if (loadNode->getFirstChild()->getOpCodeValue() != shiftCode && loadNode->getFirstChild()->getOpCodeValue() != altShiftCode)\n+         {\n+         _valNode = loadNode->getFirstChild();\n+         _shiftValue = 0;\n+         }\n+      else\n+         {\n+         TR::Node* shiftVal = loadNode->getFirstChild()->getSecondChild();\n+         if (shiftVal->getOpCodeValue() != constCode)\n+            {\n+            dumpOptDetails(comp(), \" Shifted Value: did not encounter correct const code\\n\");\n+            return false;\n+            }\n+         _valNode = loadNode->getFirstChild()->getFirstChild();\n+         switch(constCode)\n+            {\n+            case TR::sconst: _shiftValue = shiftVal->getShortInt(); break;\n+            case TR::iconst: _shiftValue = shiftVal->getInt(); break;\n+            case TR::lconst: _shiftValue = shiftVal->getLongInt(); break;\n+            default: break;\n+            }\n+         }\n+      }\n+   else\n+      {\n+      _valNode = loadNode;\n+      if (convCode != TR::bload)\n+         {\n+         _isConst = true;\n+         }\n+      }\n+\n+   if ((_shiftValue % 8) != 0 || (_shiftValue < 0) || (_shiftValue >= _valueSize*8))\n+      {\n+      dumpOptDetails(comp(), \"Shifted Value: did not encounter valid shift value %d for var size %d\\n\", _shiftValue, _valueSize);\n+      return false;\n+      }\n+\n+   _rootNode = loadNode;\n+\n+   return true;\n+   }\n+\n+bool TR_arraycopySequentialStores::checkAiadd(TR::TreeTop * currentTree, TR::Node* aiaddNode)\n+   {\n+//   dumpOptDetails(comp(), \"arraycopy sequential store - check aiadd node %p\\n\", aiaddNode);\n+   _activeAddrTree = new (trStackMemory()) TR_AddressTree(stackAlloc, comp());\n+   _activeTreeTop = currentTree;\n+   if (_activeAddrTree->process(aiaddNode, _comp->cg()->getSupportsAlignedAccessOnly()))\n+      {\n+      return insertConsistentTree();\n+      }\n+   return false;\n+   }\n+\n+void TR_arraycopySequentialStores::insertTree(int entry)\n+   {\n+//   dumpOptDetails(comp(), \" insert nodes %p,%p into entry %d\\n\",\n+//      _activeAddrTree->getRootNode(), _activeValueTree->getRootNode(), entry);\n+   if ((_addrTree[entry] != NULL) && (entry < _maxAddressTrees))\n+      {\n+      memmove(&_addrTree[entry+1], &_addrTree[entry], (_maxAddressTrees-entry-1)*sizeof(TR_AddressTree*));\n+      memmove(&_val[entry+1], &_val[entry],  (_maxAddressTrees-entry-1)*sizeof(TR_ShiftedValueTree*));\n+      memmove(&_treeTops[entry+1], &_treeTops[entry], (_maxAddressTrees-entry-1)*sizeof(TR::TreeTop*));\n+      }\n+   _addrTree[entry] = _activeAddrTree;\n+   _val[entry] = _activeValueTree;\n+   _treeTops[entry] = _activeTreeTop;\n+   }\n+\n+bool TR_arraycopySequentialStores::insertConsistentTree()\n+   {\n+\n+   // these are byte arrays we are working with - the multiplier must be 1\n+   if (_activeAddrTree->getMultiplier() != 1)\n+      {\n+      dumpOptDetails(comp(), \" insertTree: multiplier must be 1 in aiadd tree\\n\");\n+      return false;\n+      }\n+   TR::SymbolReference* activeBaseRef = _activeAddrTree->getBaseVarNode()->isNull() ? NULL : _activeAddrTree->getBaseVarNode()->getChild()->skipConversions()->getSymbolReference();\n+   if (activeBaseRef == NULL)\n+      {\n+      dumpOptDetails(comp(), \" insertTree: no base variable in aiadd tree\\n\");\n+      return false;\n+      }\n+\n+   if (_addrTree[0] == NULL)\n+      {\n+//      dumpOptDetails(comp(), \" insertTree: first tree inserted successfully with offset: %d\\n\", _activeAddrTree->getOffset());\n+      insertTree(0);\n+      return true;\n+      }\n+\n+   // make sure the index variable and base variable is consistent with the first tree\n+   TR::SymbolReference* baseRef = _addrTree[0]->getBaseVarNode()->isNull() ? NULL : _addrTree[0]->getBaseVarNode()->getChild()->skipConversions()->getSymbolReference();\n+   if (baseRef != activeBaseRef)\n+      {\n+      dumpOptDetails(comp(), \" insertTree: base variable is different than previous tree\\n\");\n+      return false;\n+      }\n+\n+   TR::SymbolReference* indRef = _addrTree[0]->getIndVarNode()->isNull() ? NULL : _addrTree[0]->getIndVarNode()->getChild()->skipConversions()->getSymbolReference();\n+   TR::SymbolReference* activeIndRef = _activeAddrTree->getIndVarNode()->isNull() ? NULL : _activeAddrTree->getIndVarNode()->getChild()->skipConversions()->getSymbolReference();\n+\n+   TR::Node* indBase = NULL;\n+   TR::Node* activeIndBase = NULL;\n+   if (!_addrTree[0]->getIndexBase()->isNull())\n+      indBase = _addrTree[0]->getIndexBase()->getParent();\n+   if (!_activeAddrTree->getIndexBase()->isNull())\n+      activeIndBase = _activeAddrTree->getIndexBase()->getParent();\n+\n+   if (indRef != activeIndRef || indBase != activeIndBase)\n+      {\n+      dumpOptDetails(comp(), \" insertTree: index variable is different than previous tree\\n\");\n+      return false;\n+      }\n+\n+   // make sure the value being loaded is consistent with the first tree\n+   if (_val[0]->isConst() !=  _activeValueTree->isConst())\n+      {\n+      dumpOptDetails(comp(), \" insertTree: const value attributes inconsistent\\n\");\n+      return false;\n+      }\n+\n+   if (!_val[0]->isConst() && (_val[0]->getValNode() != _activeValueTree->getValNode()))\n+      {\n+      dumpOptDetails(comp(), \" insertTree: value variable is different than previous tree\\n\");\n+      return false;\n+      }\n+\n+   // make sure the value tree doesn't reference the address tree base var\n+   if (_activeValueTree->getRootNode()->referencesSymbolInSubTree(baseRef, _comp->incOrResetVisitCount()))\n+      {\n+      dumpOptDetails(comp(), \" insertTree: value tree %p references address tree base var\\n\", _activeValueTree->getRootNode());\n+      return false;\n+      }\n+\n+//   dumpOptDetails(comp(), \" insertTree: tree inserted successfully. offset:%d\\n\", _activeAddrTree->getOffset());\n+   int entry;\n+   for (entry=0; entry < _maxAddressTrees && _addrTree[entry] != NULL; ++entry)\n+      {\n+      if (_activeAddrTree->getOffset() < _addrTree[entry]->getOffset())\n+         {\n+         insertTree(entry);\n+         return true;\n+         }\n+      }\n+\n+   insertTree(entry);\n+   return true;\n+   }\n+\n+\n+int TR_arraycopySequentialStores::numTrees()\n+   {\n+   int i;\n+   for (i=0; i<_maxAddressTrees; ++i)\n+      {\n+      if (_addrTree[i] == NULL)\n+         return i;\n+      }\n+   return _maxAddressTrees;\n+   }\n+\n+int TR_arraycopySequentialStores::numValidTrees(int maxEntries)\n+   {\n+   int dir = (_bigEndian) ? -1 : 1;\n+   int entry;\n+\n+//   dumpOptDetails(comp(), \"...check if valid entries\\n\");\n+   for (entry=1; (_addrTree[entry] != NULL) && (entry < maxEntries); ++entry)\n+      {\n+      if (_addrTree[entry]->getOffset() != _addrTree[0]->getOffset() + entry)\n+         {\n+         break;\n+         }\n+      if (!hasConstValue() && (_val[entry]->getShiftValue() != _val[0]->getShiftValue() + dir*8*entry))\n+         {\n+         break;\n+         }\n+      }\n+   if ((entry == 1) && !hasConstValue() && _comp->cg()->supportsByteswap())\n+      {\n+//      dumpOptDetails(comp(), \"...no valid entries forward\\n...see if reverse store finds any entries\\n\");\n+      _alternateDir = true;\n+      // repeat process for reversed store\n+      dir = (_bigEndian) ? 1 : -1;\n+      for (entry=1; (_addrTree[entry] != NULL) && (entry < maxEntries); ++entry)\n+         {\n+         if (_addrTree[entry]->getOffset() != _addrTree[0]->getOffset() + entry)\n+            {\n+            break;\n+            }\n+         if (_val[entry]->getShiftValue() != _val[0]->getShiftValue() + dir*8*entry)\n+            {\n+            break;\n+            }\n+         }\n+      }\n+   if (entry > 1)\n+      {\n+      dumpOptDetails(comp(), \"Found %d sequential valid trees\\n\", entry);\n+      }\n+   return entry;\n+   }\n+\n+bool TR_arraycopySequentialStores::checkTrees()\n+   {\n+   if (_val[0] == NULL)\n+      {\n+      return false;\n+      }\n+\n+   if (hasConstValue())\n+      {\n+      _numBytes = numValidTrees();\n+      }\n+   else\n+      {\n+      _numBytes = numValidTrees(_val[0]->getValueSize());\n+      }\n+\n+   return (_numBytes == 2 || _numBytes == 4 || _numBytes == 8);\n+   }\n+\n+void TR_arraycopySequentialStores::removeTrees(TR::SymbolReference * symRef)\n+   {\n+   TR::SparseBitVector fromAliases(_comp->allocator(\"SCSS bitvector\"));\n+\n+   for (int32_t i = 0; i < _numBytes; ++i)\n+      {\n+      dumpOptDetails(_comp, \" Remove trees %p to %p\\n\", _treeTops[i]->getNode(), _treeTops[i]->getNextTreeTop()->getNode());\n+      TR::TreeTop::removeDeadTrees(_comp, _treeTops[i], _treeTops[i]->getNextTreeTop());\n+      }\n+\n+   }\n+\n+int64_t TR_arraycopySequentialStores::constVal()\n+   {\n+   int dir;\n+   int baseShift;\n+   uint64_t val = 0;\n+\n+   if (_bigEndian)\n+      {\n+      dir = -1;\n+      baseShift = (_numBytes-1)*8;\n+      }\n+   else\n+      {\n+      dir = 1;\n+      baseShift = 0;\n+      }\n+\n+   for (int entry=0; entry < _numBytes; ++entry)\n+      {\n+      uint64_t curVal = 0;\n+      switch (_val[entry]->getValNode()->getOpCodeValue())\n+         {\n+         case TR::bconst: curVal = (uint64_t) (_val[entry]->getValNode()->getByte() & 0xFF); break;\n+         case TR::sconst: curVal = (uint64_t) (_val[entry]->getValNode()->getShortInt() & 0xFF); break;\n+         case TR::iconst: curVal = (uint64_t) (_val[entry]->getValNode()->getInt() & 0xFF); break;\n+         case TR::lconst: curVal = (uint64_t) (_val[entry]->getValNode()->getLongInt() & 0xFF); break;\n+         default: break;\n+         }\n+      curVal = curVal << (baseShift + dir*8*entry);\n+      val |= curVal;\n+      }\n+   return (int64_t)val;\n+   }\n+\n+TR::Node* TR_arraycopySequentialStores::constValNode()\n+   {\n+   TR::Node* rootNode = getAddrTree()->getRootNode();\n+   TR::Node* node = NULL;\n+\n+   switch (_numBytes)\n+      {\n+      case 1: node = TR::Node::bconst(rootNode,(int8_t) constVal()); break;\n+      case 2: node = TR::Node::sconst(rootNode,(int16_t) constVal()); break;\n+      case 4: node = TR::Node::create(rootNode, TR::iconst); node->setInt((int32_t) constVal()); break;\n+      case 8: node = TR::Node::create(rootNode, TR::lconst); node->setLongInt(constVal()); break;\n+      default: TR_ASSERT(false, \"const val node has invalid number of bytes\"); break;\n+      }\n+   return node;\n+   }\n+\n+// Transform a set of sequential stores into increasing storage from an integral type into\n+// an arraycopy call\n+// Order varies depending if on Big Endian or Little Endian target hardware\n+// ibstore <array element>\n+//   aiadd\n+//     aload <arr>\n+//     isub\n+//       iload <var>\n+//       iconst -<base> - <offset> - <element>\n+//   i2b [node cannot overflow]\n+//       iushr [node >= 0] [node cannot overflow] <iushr disappears when <element> == sizeof(value) - 1>\n+//         iload <value>\n+//         iconst (sizeof(<value>) - <element> + 1)*8 (sizeof(<value>) == 1,2,4,8) [Big Endian]\n+//          -or-\n+//         iconst (<element> + 1)*8 (sizeof(<value>) == 1,2,4,8)                   [Little Endian]\n+//\n+\n+static TR::TreeTop* generateArraycopyFromSequentialStores(TR::Compilation* comp, TR::TreeTop* prevTreeTop, TR::TreeTop* istoreTreeTop, TR::Node* istoreNode)\n+   {\n+   TR::CodeGenerator* codeGen = comp->cg();\n+\n+   TR_arraycopySequentialStores arraycopy = TR_arraycopySequentialStores(comp);\n+   TR::Node* curNode = istoreNode;\n+   TR::TreeTop* curTreeTop = istoreTreeTop;\n+   while (\n+          arraycopy.numTrees() < arraycopy.maxNumTrees() &&\n+          arraycopy.checkIStore(curNode) &&\n+          arraycopy.checkALoadValue(curNode->getSecondChild()) &&\n+          arraycopy.checkAiadd(curTreeTop, curNode->getFirstChild())\n+         )\n+      {\n+      curTreeTop = curTreeTop->getNextTreeTop();\n+      curNode    = curTreeTop->getNode();\n+      }\n+\n+   if (!arraycopy.checkTrees())\n+      {\n+      return istoreTreeTop;\n+      }\n+\n+   int32_t numBytes = arraycopy.getNumBytes();\n+   if (numBytes == 1)\n+      {\n+      dumpOptDetails(comp, \" Sequential Store of 1 byte not worth reducing\\n\");\n+      return istoreTreeTop;\n+      }\n+   else if (numBytes != 2 && numBytes != 4 && numBytes != 8)\n+      {\n+      dumpOptDetails(comp, \" Sequential Store of size other than 2/4/8 not reducible\\n\");\n+      return istoreTreeTop;\n+      }\n+\n+   int32_t loadSize = arraycopy.getVal()->getValueSize();\n+   if (!arraycopy.hasConstValue() && (loadSize != numBytes))\n+      {\n+      dumpOptDetails(comp, \" Sequential Store of size different than trees (%d,%d) not supported yet\\n\", loadSize, numBytes);\n+      return istoreTreeTop;\n+      }\n+\n+   if(codeGen->getSupportsAlignedAccessOnly() &&\n+      ((arraycopy.getAddrTree()->getOffset() % numBytes) != 0))\n+      {\n+      dumpOptDetails(comp, \" Sequential Store of %d bytes at offset %d would have caused unaligned memory access\\n\", numBytes, arraycopy.getAddrTree()->getOffset());\n+      return istoreTreeTop;\n+      }\n+\n+   if (!performTransformation(comp, \"%sReducing arraycopy sequential stores\\n\", OPT_DETAILS))\n+      return istoreTreeTop;\n+\n+   dumpOptDetails(comp, \" Load Node:%p Number of bytes: %d\\n\", istoreNode, numBytes);\n+\n+   TR::SymbolReference *symRef = comp->getSymRefTab()->findOrCreateGenericIntShadowSymbolReference(0);\n+   // propagate the offset of the symbol reference\n+   symRef->setOffset(arraycopy.getTreeTop()->getNode()->getSymbolReference()->getOffset());\n+\n+   //\n+   // delete the ibstore trees and replace them with a new, improved iXstore tree\n+   //\n+   arraycopy.removeTrees(symRef);\n+\n+   TR::Node* aiaddNode = arraycopy.getAddrTree()->getRootNode(); //->duplicateTree();\n+   TR::Node* loadNode;\n+\n+   if (arraycopy.hasConstValue())\n+      {\n+      loadNode = arraycopy.constValNode();\n+      }\n+   else\n+      {\n+      loadNode = arraycopy.getVal()->getValNode(); // ->duplicateTree();\n+      }\n+\n+   TR::ILOpCodes opcode;\n+   TR::ILOpCodes byteswapOpcode;\n+\n+   // create a load/store of the right size\n+   switch(numBytes)\n+      {\n+      case 2: opcode = TR::sstorei; byteswapOpcode = TR::sbyteswap; break;\n+      case 4: opcode = TR::istorei; byteswapOpcode = TR::ibyteswap; break;\n+      case 8: opcode = TR::lstorei; byteswapOpcode = TR::lbyteswap; break;\n+      default: TR_ASSERT(0, \" number of bytes unexpected\\n\"); break;\n+      }\n+\n+   if (arraycopy.alternateDir())\n+      {\n+      loadNode = TR::Node::create(byteswapOpcode, 1, loadNode);\n+      }\n+\n+   TR::Node* iXstoreNode = TR::Node::createWithSymRef(opcode, 2, 2, aiaddNode, loadNode, symRef);\n+   TR::TreeTop* treeTop = TR::TreeTop::create(comp, iXstoreNode);\n+   TR::TreeTop* nextTreeTop = prevTreeTop->getNextTreeTop();\n+\n+   prevTreeTop->join(treeTop);\n+   treeTop->join(nextTreeTop);\n+\n+   return treeTop;\n    }\n \n-void TR_arraycopySequentialStores::removeTrees(TR::SymbolReference * symRef)\n-   {\n-   TR::SparseBitVector fromAliases(_comp->allocator(\"SCSS bitvector\"));\n+static TR::TreeTop* generateArraycopyFromSequentialLoadsDEPRECATED(TR::Compilation* comp, TR::TreeTop* currentTreeTop, TR::Node* ibloadNode)\n+   {\n+\n+   static const char * disableSeqLoadOpt = feGetEnv(\"TR_DisableSeqLoadOpt\");\n+   if (disableSeqLoadOpt)\n+      return currentTreeTop;\n+\n+   TR::CodeGenerator* codeGen = comp->cg();\n+\n+   if (comp->target().cpu.isLittleEndian())\n+      return currentTreeTop;\n+\n+   int32_t numBytes = 0;\n+   TR::Node* currentNode = currentTreeTop->getNode();\n+   TR::Node* prevNode = NULL;\n+   TR::Node* rootNode;\n+\n+   //checking the number of bytes\n+   while ( !((currentNode->getFirstChild() == ibloadNode) && (currentNode->getOpCodeValue() == TR::bu2i)) )\n+      {\n+      if ( (currentNode->getOpCodeValue() == TR::iadd) || (currentNode->getOpCodeValue() == TR::ior))\n+         {\n+         numBytes++;\n+         if (numBytes==1)\n+            rootNode=prevNode;\n+         }\n+      else if (isValidSeqLoadIMul(comp, currentNode))\n+         numBytes++;\n+      else\n+         numBytes = 0;\n+      prevNode = currentNode;\n+      currentNode = currentNode->getFirstChild();\n+      }\n+\n+   if (numBytes == 1)\n+      {\n+      dumpOptDetails(comp, \" Sequential Load of 1 byte not worth reducing\\n\");\n+      return currentTreeTop;\n+      }\n+   else if ( numBytes != 2 && numBytes != 3 && numBytes != 4 )\n+      {\n+      dumpOptDetails(comp, \" Sequential Load of size other than 2/3/4 not reducible\\n\");\n+      return currentTreeTop;\n+      }\n+\n+   /*\n+    * This version of generateArraycopyFromSequentialLoads does not work when numBytes is equal to 2.\n+    * This version is deprecated so the opt bails out here rather than fix this particular version.\n+    * Even if it did not bail out here, a check would likely fail later on anyways.\n+    */\n+   if (2 == numBytes)\n+      {\n+      return currentTreeTop;\n+      }\n+\n+   // Need to make sure these loads are not under spine checks.\n+   //\n+   if (comp->requiresSpineChecks() && ibloadNode->getReferenceCount() > 1)\n+      {\n+      TR::TreeTop *tt = currentTreeTop;\n+      TR::TreeTop *lastTreeTop = currentTreeTop->getEnclosingBlock()->startOfExtendedBlock()->getFirstRealTreeTop()->getPrevTreeTop();\n+\n+      // Search backwards to the top of the EBB and look at all spine checks.\n+      while (tt != lastTreeTop)\n+         {\n+         TR::Node *node = tt->getNode();\n+         if (node->getOpCodeValue() == TR::BNDCHKwithSpineCHK ||\n+             node->getOpCodeValue() == TR::SpineCHK)\n+            {\n+            node = node->getFirstChild();\n+            while (node->getOpCode().isConversion())\n+               node = node->getFirstChild();\n+            if (node == ibloadNode)\n+               {\n+               dumpOptDetails(comp, \" Sequential Load to spine checked array not reducible\\n\");\n+               return currentTreeTop;\n+               }\n+            }\n+         tt = tt->getPrevTreeTop();\n+         }\n+      }\n+\n+   currentNode = rootNode;\n+   int32_t baseOffset;\n+   int32_t shiftVar;\n+   int32_t multiplier = 0;\n+   TR::Node* aloadNode;\n+   TR::Node* newLoadChildNode;\n+   TR::Node* newConvertChildNode;\n+   TR::Node* newMultChildNode;\n+   TR::Node* oldChildNode;\n+   TR::Node* basePointerNode;\n+\n+   // see if all the trees are valid\n+   for (int32_t i = 0; i < numBytes; i++)\n+      {\n+      currentNode = currentNode->getFirstChild();\n+      if (currentNode->getReferenceCount() > 1)\n+         {\n+         dumpOptDetails(comp, \" Sequential load not possible due to ref count > 1 %p\\n\", currentNode);\n+         return currentTreeTop;\n+         }\n+      if (i == 0)\n+         {\n+         if ( !(isValidSeqLoadB2i(comp, currentNode->getSecondChild())) )\n+            return currentTreeTop;\n+         baseOffset = getOffsetForSeqLoadDEPRECATED(comp, rootNode, numBytes, numBytes - i);\n+         aloadNode = getALoadReferenceForSeqLoadDEPRECATED(rootNode, numBytes, numBytes - i);\n+         basePointerNode = getBasePointerReferenceForSeqLoadDEPRECATED(comp, rootNode, numBytes, numBytes - i);\n+         shiftVar = getMultValueForSeqLoadDEPRECATED(comp, rootNode, numBytes, numBytes - i);\n+         if (shiftVar != 1)\n+            return currentTreeTop;\n+         }\n+      else if (i == numBytes-1)\n+         {\n+         if ( !(isValidSeqLoadIMul(comp, currentNode)) )\n+            return currentTreeTop;\n+         if ( !(shiftVar*multiplier==getMultValueForSeqLoadDEPRECATED(comp, rootNode, numBytes, numBytes - i)) )  //This check is broken for numBytes == 2 since multiplier is 0 instead of 256.\n+            return currentTreeTop;\n+         if ( !(baseOffset == getOffsetForSeqLoadDEPRECATED(comp, rootNode, numBytes, numBytes - i) + i)\n+            || !(aloadNode == getALoadReferenceForSeqLoadDEPRECATED(rootNode, numBytes, numBytes - i))\n+            || !(basePointerNode == getBasePointerReferenceForSeqLoadDEPRECATED(comp, rootNode, numBytes, numBytes - i)))\n+            return currentTreeTop;\n+         baseOffset = getOffsetForSeqLoadDEPRECATED(comp, rootNode, numBytes, numBytes - i);\n+         newLoadChildNode = currentNode->getFirstChild()->getFirstChild();\n+         newConvertChildNode = currentNode->getFirstChild();\n+         newMultChildNode = currentNode;\n+         }\n+      else\n+         {\n+         if ( !(isValidSeqLoadIMul(comp, currentNode->getSecondChild())) )\n+            return currentTreeTop;\n+         if ( !(baseOffset == getOffsetForSeqLoadDEPRECATED(comp, rootNode, numBytes, numBytes - i) + i)\n+            || !(aloadNode == getALoadReferenceForSeqLoadDEPRECATED(rootNode, numBytes, numBytes - i))\n+            || !(basePointerNode == getBasePointerReferenceForSeqLoadDEPRECATED(comp, rootNode, numBytes, numBytes - i)))\n+            return currentTreeTop;\n+         if (multiplier == 0)\n+            {\n+            multiplier = getMultValueForSeqLoadDEPRECATED(comp, rootNode, numBytes, numBytes - i);\n+            shiftVar = multiplier;\n+            if (!(multiplier == 256))\n+               return currentTreeTop;\n+            }\n+         else\n+            {\n+            shiftVar = multiplier * shiftVar;\n+            if ( !(shiftVar == getMultValueForSeqLoadDEPRECATED(comp, rootNode, numBytes, numBytes - i)) )\n+               return currentTreeTop;\n+            }\n+         }\n+\n+      }\n \n-   for (int32_t i = 0; i < _numBytes; ++i)\n+   if(numBytes == 4 || numBytes == 3 || numBytes == 2)\n       {\n-      dumpOptDetails(_comp, \" Remove trees %p to %p\\n\", _treeTops[i]->getNode(), _treeTops[i]->getNextTreeTop()->getNode());\n-      TR::TreeTop::removeDeadTrees(_comp, _treeTops[i], _treeTops[i]->getNextTreeTop());\n+      if (!performTransformation(comp, \"%sReducing sequential loads\\n\", OPT_DETAILS))\n+         {\n+         return currentTreeTop;\n+         }\n+      dumpOptDetails(comp, \" Sequential Load reduced at node: %p Number of bytes: %d\\n\", rootNode, numBytes);\n       }\n \n-   }\n-\n-int64_t TR_arraycopySequentialStores::constVal()\n-   {\n-   int dir;\n-   int baseShift;\n-   uint64_t val = 0;\n-\n-   if (_bigEndian)\n+   if (numBytes == 4)\n       {\n-      dir = -1;\n-      baseShift = (_numBytes-1)*8;\n+      oldChildNode = rootNode->getFirstChild();\n+      rootNode->setAndIncChild(0, newLoadChildNode);\n+      oldChildNode->recursivelyDecReferenceCount();\n+      TR::Node::recreate(newLoadChildNode, TR::iloadi);\n       }\n-   else\n+\n+   if (numBytes == 3)\n       {\n-      dir = 1;\n-      baseShift = 0;\n+      oldChildNode = rootNode->getFirstChild()->getFirstChild();\n+      rootNode->getFirstChild()->setAndIncChild(0, newMultChildNode);\n+      oldChildNode->recursivelyDecReferenceCount();\n+      TR::Node::recreate(newLoadChildNode, TR::sloadi);\n+      TR::Node::recreate(newConvertChildNode, TR::su2i);\n+      newMultChildNode->getSecondChild()->setInt(256);\n       }\n \n-   for (int entry=0; entry < _numBytes; ++entry)\n+   if (numBytes == 2)\n       {\n-      uint64_t curVal = 0;\n-      switch (_val[entry]->getValNode()->getOpCodeValue())\n-         {\n-         case TR::bconst: curVal = (uint64_t) (_val[entry]->getValNode()->getByte() & 0xFF); break;\n-         case TR::sconst: curVal = (uint64_t) (_val[entry]->getValNode()->getShortInt() & 0xFF); break;\n-         case TR::iconst: curVal = (uint64_t) (_val[entry]->getValNode()->getInt() & 0xFF); break;\n-         case TR::lconst: curVal = (uint64_t) (_val[entry]->getValNode()->getLongInt() & 0xFF); break;\n-         default: break;\n-         }\n-      curVal = curVal << (baseShift + dir*8*entry);\n-      val |= curVal;\n+      oldChildNode = rootNode->getFirstChild();\n+      rootNode->setAndIncChild(0, newConvertChildNode);\n+      oldChildNode->recursivelyDecReferenceCount();\n+      TR::Node::recreate(newLoadChildNode, TR::sloadi);\n+      TR::Node::recreate(newConvertChildNode, TR::su2i);\n       }\n-   return (int64_t)val;\n+\n+   return currentTreeTop;\n    }\n \n-TR::Node* TR_arraycopySequentialStores::constValNode()\n+TR::TreeTop* generateArraycopyFromSequentialLoads(TR::Compilation* comp, bool trace, TR::TreeTop* currentTreeTop, TR::Node* rootNode, NodeForwardList* combineNodeList)\n    {\n-   TR::Node* rootNode = getAddrTree()->getRootNode();\n-   TR::Node* node = NULL;\n-\n-   switch (_numBytes)\n+   static const char * disableSeqLoadOpt = feGetEnv(\"TR_DisableSeqLoadOpt\");\n+   if (disableSeqLoadOpt)\n       {\n-      case 1: node = TR::Node::bconst(rootNode,(int8_t) constVal()); break;\n-      case 2: node = TR::Node::sconst(rootNode,(int16_t) constVal()); break;\n-      case 4: node = TR::Node::create(rootNode, TR::iconst); node->setInt((int32_t) constVal()); break;\n-      case 8: node = TR::Node::create(rootNode, TR::lconst); node->setLongInt(constVal()); break;\n-      default: TR_ASSERT(false, \"const val node has invalid number of bytes\"); break;\n+      return currentTreeTop;\n       }\n-   return node;\n-   }\n \n-// Transform a set of sequential stores into increasing storage from an integral type into\n-// an arraycopy call\n-// Order varies depending if on Big Endian or Little Endian target hardware\n-// ibstore <array element>\n-//   aiadd\n-//     aload <arr>\n-//     isub\n-//       iload <var>\n-//       iconst -<base> - <offset> - <element>\n-//   i2b [node cannot overflow]\n-//       iushr [node >= 0] [node cannot overflow] <iushr disappears when <element> == sizeof(value) - 1>\n-//         iload <value>\n-//         iconst (sizeof(<value>) - <element> + 1)*8 (sizeof(<value>) == 1,2,4,8) [Big Endian]\n-//          -or-\n-//         iconst (<element> + 1)*8 (sizeof(<value>) == 1,2,4,8)                   [Little Endian]\n-//\n+   /*\n+    * This is an example transformation. 4 consective byte loads from a byte array are used to construct an int.\n+    * After the transformation a Little Endian int load is used to directly create the int.\n+    * Big Endian has support as well but the bytes in the original array need to be in the opposite order or a byteswap is inserted.\n+    *\n+    * Original trees:\n+    * n01n  iadd         <<-- rootNode, combineNode (2)\n+    * n02n    iadd       <<-- combineNode (1)\n+    * n03n      iadd     <<-- combineNode (0)\n+    * n04n        imul                     <<-- processedByteNodes (0)\n+    * n05n          bu2i                   <<-- byteConversionNode (0)\n+    * n06n            bloadi\n+    * n07n              aladd\n+    * n08n                ==>aloadi        <<-- aloadNode, loads byte array address, used in all 4 byte loads\n+    * n09n                lsub\n+    * n10n                  i2l\n+    * n11n                    iload        <<-- basePointerNode, used in all 4 byte loads\n+    * n12n                  lconst -9      <<-- byteOffsets (0)\n+    * n13n          iconst 256             <<-- converted to shiftValue (0)\n+    * n14n        bu2i                   <<-- processedByteNodes (1), byteConversionNode (1)\n+    * n15n          bloadi\n+    * n16n            aladd\n+    * n08n              ==>aloadi\n+    * n17n              lsub\n+    * n10n                ==>i2l\n+    * n18n                lconst -8      <<-- byteOffsets (1)\n+    * n19n      imul                  <<-- processedByteNodes (2)\n+    * n20n        bu2i                <<-- byteConversionNode (2)\n+    * n21n          bloadi\n+    * n22n            aladd\n+    * n08n              ==>aloadi\n+    * n23n              lsub\n+    * n10n                ==>i2l\n+    * n24n                lconst -10  <<-- byteOffsets (2)\n+    * n25n        iconst 0x10000      <<-- convreted to shiftValue (2)\n+    * n26n    imul                  <<-- processedByteNodes (3)\n+    * n27n      b2i                 <<-- byteConversionNode (3)\n+    * n28n        bloadi\n+    * n29n          aladd\n+    * n08n            ==>aloadi\n+    * n30n            lsub\n+    * n10n              ==>i2l\n+    * n31n              lconst -11  <<-- byteOffsets (3)\n+    * n32n      iconst 0x1000000    <<-- converted to shiftValue (3)\n+    *\n+    *\n+    * After transformation:\n+    * n01n  iloadi         <<-- rootNode\n+    * n16n    aladd\n+    * n08n      ==>aloadi\n+    * n17n      lsub\n+    * n10n        i2l\n+    * n11n          iload\n+    * n18n        lconst -8\n+    */\n \n-static TR::TreeTop* generateArraycopyFromSequentialStores(TR::Compilation* comp, TR::TreeTop* prevTreeTop, TR::TreeTop* istoreTreeTop, TR::Node* istoreNode)\n-   {\n-   TR::CodeGenerator* codeGen = comp->cg();\n \n-   TR_arraycopySequentialStores arraycopy = TR_arraycopySequentialStores(comp);\n-   TR::Node* curNode = istoreNode;\n-   TR::TreeTop* curTreeTop = istoreTreeTop;\n-   while (\n-          arraycopy.numTrees() < arraycopy.maxNumTrees() &&\n-          arraycopy.checkIStore(curNode) &&\n-          arraycopy.checkALoadValue(curNode->getSecondChild()) &&\n-          arraycopy.checkAiadd(curTreeTop, curNode->getFirstChild())\n-         )\n-      {\n-      curTreeTop = curTreeTop->getNextTreeTop();\n-      curNode    = curTreeTop->getNode();\n-      }\n+   /* processedByteNodes are children of a combine node that are not also a combine node. */\n+   TR::Node* processedByteNodes[8];\n+   /* byteConversionNodes are the conversion node parent for each loaded byte. Sorted such that the least significant byte is in position 0. */\n+   TR::Node* byteConversionNodes[8];\n+   /* byteOffsets are the constants that act as relative offsets for each loaded byte. Sorted such that the least significant byte is in position 0. */\n+   int64_t byteOffsets[8];\n \n-   if (!arraycopy.checkTrees())\n+   /* byteCount is the number of loaded bytes. */\n+   int32_t byteCount = 0;\n+\n+   /* These are used to make sure the same aload/aloadi node and basePointerNode are used for all of the byte loads. */\n+   TR::Node* aloadNode = NULL;\n+   TR::Node* basePointerNode = NULL;\n+\n+   /* Tracks if the final loaded result needs to be sign extended. */\n+   bool signExtendResult = false;\n+   /* Tracks if the bytes can be loaded with an Little Endian or Big Endian load. If neither works, the opt bails. */\n+   bool littleEndianLoad = false;\n+   /* Tracks if the final loaded result is an int or a long. */\n+   bool is64bitResult = rootNode->getDataType().isInt64();\n+   /* Tracks if byteswap are needed due to endianness differences. */\n+   bool swapBytes = false;\n+\n+   /* These are used to track nodes while performing the transformation. */\n+   TR::Node* newLoadChildNode = NULL;\n+   TR::Node* newConvertChildNode = NULL;\n+   TR::Node* disconnectedNode1 = NULL;\n+   TR::Node* disconnectedNode2 = NULL;\n+\n+   if (trace) traceMsg(comp, \"Sequential Load Simplification Candidate - rootNode: %p\\n\", rootNode);\n+\n+   for (int i = 0; i < 8; i++)\n       {\n-      return istoreTreeTop;\n+      processedByteNodes[i] = NULL;\n+      byteConversionNodes[i] = NULL;\n       }\n \n-   int32_t numBytes = arraycopy.getNumBytes();\n-   if (numBytes == 1)\n+   /* Iterate over combineNodeList and populate the processedByteNodes array. */\n+   for (auto it = combineNodeList->begin(); it != combineNodeList->end(); ++it)\n       {\n-      dumpOptDetails(comp, \" Sequential Store of 1 byte not worth reducing\\n\");\n-      return istoreTreeTop;\n+      TR::Node* firstChild = (*it)->getFirstChild();\n+      TR::Node* secondChild = (*it)->getSecondChild();\n+\n+      if ((firstChild->getOpCodeValue() != TR::iadd) && (firstChild->getOpCodeValue() != TR::ior) &&\n+          (firstChild->getOpCodeValue() != TR::ladd) && (firstChild->getOpCodeValue() != TR::lor))\n+         {\n+         processedByteNodes[byteCount] = firstChild;\n+         byteCount++;\n+         }\n+\n+      if ((secondChild->getOpCodeValue() != TR::iadd) && (secondChild->getOpCodeValue() != TR::ior) &&\n+          (secondChild->getOpCodeValue() != TR::ladd) && (secondChild->getOpCodeValue() != TR::lor))\n+         {\n+         processedByteNodes[byteCount] = secondChild;\n+         byteCount++;\n+         }\n       }\n-   else if (numBytes != 2 && numBytes != 4 && numBytes != 8)\n+\n+   if (trace) traceMsg(comp, \"Sequential Load Simplification Candidate - rootNode: %p, byteCount: %d\\n\", rootNode, byteCount);\n+\n+   if (!is64bitResult && (byteCount > 4))\n       {\n-      dumpOptDetails(comp, \" Sequential Store of size other than 2/4/8 not reducible\\n\");\n-      return istoreTreeTop;\n+      if (trace) traceMsg(comp, \"byteCount is too high for constructing an int value. rootNode: %p, byteCount: %d\\n\", rootNode, byteCount);\n+      return currentTreeTop;\n       }\n \n-   int32_t loadSize = arraycopy.getVal()->getValueSize();\n-   if (!arraycopy.hasConstValue() && (loadSize != numBytes))\n+   if ((byteCount < 2) || (byteCount > 8))\n       {\n-      dumpOptDetails(comp, \" Sequential Store of size different than trees (%d,%d) not supported yet\\n\", loadSize, numBytes);\n-      return istoreTreeTop;\n+      if (trace) traceMsg(comp, \"Sequential Load of size other than 2 to 8 is not supported. rootNode: %p, byteCount: %d\\n\", rootNode, byteCount);\n+      return currentTreeTop;\n       }\n \n-   if(codeGen->getSupportsAlignedAccessOnly() &&\n-      ((arraycopy.getAddrTree()->getOffset() % numBytes) != 0))\n+   /* This loop performs more checks and collects info on each loaded byte. */\n+   for (int i = 0; i < byteCount; i++)\n       {\n-      dumpOptDetails(comp, \" Sequential Store of %d bytes at offset %d would have caused unaligned memory access\\n\", numBytes, arraycopy.getAddrTree()->getOffset());\n-      return istoreTreeTop;\n-      }\n+      TR::Node* byteConversionNode = NULL;\n+      int32_t shiftValue = 0;\n \n-   if (!performTransformation(comp, \"%sReducing arraycopy sequential stores\\n\", OPT_DETAILS))\n-      return istoreTreeTop;\n+      if (trace) traceMsg(comp, \"Sequential Load Simplification Candidate - rootNode: %p, processedByteNodes[%d]: %p\\n\", rootNode, i, processedByteNodes[i]);\n \n-   dumpOptDetails(comp, \" Load Node:%p Number of bytes: %d\\n\", istoreNode, numBytes);\n+      if (0 == i)\n+         {\n+         aloadNode = getALoadReferenceForSeqLoad(processedByteNodes[i]);\n+         if (trace) traceMsg(comp, \"Sequential Load Simplification Candidate - rootNode: %p, aloadNode: %p\\n\", rootNode, aloadNode);\n+         basePointerNode = getBasePointerReferenceForSeqLoad(processedByteNodes[i]);\n+         if (trace) traceMsg(comp, \"Sequential Load Simplification Candidate - rootNode: %p, basePointerNode: %p\\n\", rootNode, basePointerNode);\n+         }\n+      else\n+         {\n+         /* aloadNode for all loaded bytes must be the exact same node. */\n+         if (aloadNode != getALoadReferenceForSeqLoad(processedByteNodes[i]))\n+            {\n+            if (trace) traceMsg(comp, \"Sequential Load Simplification aload mismatch. rootNode: %p, aloadNode(0): %p, aloadNode(%d): %p\\n\",\n+                                rootNode, aloadNode, i, getALoadReferenceForSeqLoad(processedByteNodes[i]));\n+            return currentTreeTop;\n+            }\n \n-   TR::SymbolReference *symRef = comp->getSymRefTab()->findOrCreateGenericIntShadowSymbolReference(0);\n-   // propagate the offset of the symbol reference\n-   symRef->setOffset(arraycopy.getTreeTop()->getNode()->getSymbolReference()->getOffset());\n+         /* basePointerNode for all loaded bytes must be the exact same node (or all NULL). */\n+         if (basePointerNode != getBasePointerReferenceForSeqLoad(processedByteNodes[i]))\n+            {\n+            if (trace) traceMsg(comp, \"Sequential Load Simplification basePointerNode mismatch. rootNode: %p, basePointerNode(0): %p, basePointerNode(%d): %p\\n\",\n+                                rootNode, basePointerNode, i, getBasePointerReferenceForSeqLoad(processedByteNodes[i]));\n+            return currentTreeTop;\n+            }\n+         }\n \n-   //\n-   // delete the ibstore trees and replace them with a new, improved iXstore tree\n-   //\n-   arraycopy.removeTrees(symRef);\n+      byteConversionNode = getByteConversionNodeForSeqLoad(processedByteNodes[i]);\n+      if (trace) traceMsg(comp, \"Sequential Load Simplification Candidate - rootNode: %p, byteConversionNode: %p\\n\", rootNode, byteConversionNode);\n+      shiftValue = getShiftValueForSeqLoad(processedByteNodes[i]);\n+      if (trace) traceMsg(comp, \"Sequential Load Simplification Candidate - rootNode: %p, shiftValue: %d\\n\", rootNode, shiftValue);\n \n-   TR::Node* aiaddNode = arraycopy.getAddrTree()->getRootNode(); //->duplicateTree();\n-   TR::Node* loadNode;\n+      if ((shiftValue > ((byteCount - 1) * 8)) || (shiftValue < 0))\n+         {\n+         if (trace) traceMsg(comp, \"shiftValue is out of range for the given byteCount. rootNode: %p, byteCount: %d, shiftValue: %d\\n\", rootNode, byteCount, shiftValue);\n+         return currentTreeTop;\n+         }\n \n-   if (arraycopy.hasConstValue())\n-      {\n-      loadNode = arraycopy.constValNode();\n-      }\n-   else\n-      {\n-      loadNode = arraycopy.getVal()->getValNode(); // ->duplicateTree();\n-      }\n+      if (((byteCount - 1) * 8) == shiftValue)\n+         {\n+         /* Check if most significant byte is signed extended or not. */\n+         signExtendResult = checkForSeqLoadSignExtendedByte(processedByteNodes[i]);\n+         if (trace) traceMsg(comp, \"Sequential Load Simplification Candidate - rootNode: %p, signExtendResult: %d\\n\", rootNode, signExtendResult);\n+         }\n+      else\n+         {\n+         /* Other bytes can not be sign extended. */\n+         if (checkForSeqLoadSignExtendedByte(processedByteNodes[i]))\n+            {\n+            if (trace) traceMsg(comp, \"Bytes other than the most significant byte should not be sign extended. rootNode: %p, processedByteNodes[%d]: %p\\n\", rootNode, i, processedByteNodes[i]);\n+            return currentTreeTop;\n+            }\n+         }\n \n-   TR::ILOpCodes opcode;\n-   TR::ILOpCodes byteswapOpcode;\n+      /*\n+       * byteConversionNodes and byteOffsets are sorted such that the least significant byte load is in position 0.\n+       * Position 1 has the next most significant load and so on.\n+       * shiftValue is used to determine the significance of the byte load.\n+       * If two byte loads have the same shiftValue, the opt bails out.\n+       */\n+      int32_t byteNumber = shiftValue / 8;\n \n-   // create a load/store of the right size\n-   switch(numBytes)\n-      {\n-      case 2: opcode = TR::sstorei; byteswapOpcode = TR::sbyteswap; break;\n-      case 4: opcode = TR::istorei; byteswapOpcode = TR::ibyteswap; break;\n-      case 8: opcode = TR::lstorei; byteswapOpcode = TR::lbyteswap; break;\n-      default: TR_ASSERT(0, \" number of bytes unexpected\\n\"); break;\n+      if (byteConversionNodes[byteNumber] != NULL)\n+         {\n+         if (trace) traceMsg(comp, \"Duplicate shiftValue. rootNode: %p, shiftValue: %d, byteConversionNodes[%d]: %p, byteConversionNode(%d): %p\\n\",\n+                             rootNode, shiftValue, byteNumber, byteConversionNodes[byteNumber], i, byteConversionNode);\n+         return currentTreeTop;\n+         }\n+\n+      byteConversionNodes[byteNumber] = byteConversionNode;\n+      byteOffsets[byteNumber] = getOffsetForSeqLoad(comp, byteConversionNode);\n       }\n \n-   if (arraycopy.alternateDir())\n+   if (trace)\n       {\n-      loadNode = TR::Node::create(byteswapOpcode, 1, loadNode);\n+      traceMsg(comp, \"Sequential Load Simplification Candidate - rootNode: %p, byteOffsets: %ld\", rootNode, byteOffsets[0]);\n+      for (int i = 1; i < byteCount; i++)\n+         {\n+         traceMsg(comp, \", %ld\", byteOffsets[i]);\n+         }\n+      traceMsg(comp, \"\\n\");\n       }\n \n-   TR::Node* iXstoreNode = TR::Node::createWithSymRef(opcode, 2, 2, aiaddNode, loadNode, symRef);\n-   TR::TreeTop* treeTop = TR::TreeTop::create(comp, iXstoreNode);\n-   TR::TreeTop* nextTreeTop = prevTreeTop->getNextTreeTop();\n-\n-   prevTreeTop->join(treeTop);\n-   treeTop->join(nextTreeTop);\n-\n-   return treeTop;\n-   }\n-\n-static TR::TreeTop* generateArraycopyFromSequentialLoads(TR::Compilation* comp, TR::TreeTop* currentTreeTop, TR::Node* ibloadNode)\n-   {\n-\n-   static const char * disableSeqLoadOpt = feGetEnv(\"TR_DisableSeqLoadOpt\");\n-   if (disableSeqLoadOpt)\n-      return currentTreeTop;\n-\n-   TR::CodeGenerator* codeGen = comp->cg();\n+   /*\n+    * Check if the bytes are loaded from consecutive locations in memory.\n+    * At this point it is known what the significance of each loaded byte is so check if they can be loaded with an LE or BE load.\n+    * If both are incompatible, the opt bails out.\n+    */\n+   if (matchLittleEndianSeqLoadPattern(byteOffsets, byteCount))\n+      {\n+      littleEndianLoad = true;\n \n-   if (comp->target().cpu.isLittleEndian())\n+      if ((3 == byteCount) || (5 == byteCount))\n+         {\n+         newConvertChildNode = byteConversionNodes[1];\n+         newLoadChildNode = byteConversionNodes[1]->getFirstChild();\n+         }\n+      else if (6 == byteCount)\n+         {\n+         newConvertChildNode = byteConversionNodes[2];\n+         newLoadChildNode = byteConversionNodes[2]->getFirstChild();\n+         }\n+      else if (7 == byteCount)\n+         {\n+         newConvertChildNode = byteConversionNodes[3];\n+         newLoadChildNode = byteConversionNodes[3]->getFirstChild();\n+         }\n+      else /* byteCount is 2, 4 or 8. */\n+         {\n+         newConvertChildNode = byteConversionNodes[0];\n+         newLoadChildNode = byteConversionNodes[0]->getFirstChild();\n+         }\n+      }\n+   else if (matchBigEndianSeqLoadPattern(byteOffsets, byteCount))\n+      {\n+      littleEndianLoad = false;\n+      newConvertChildNode = byteConversionNodes[byteCount-1];\n+      newLoadChildNode = byteConversionNodes[byteCount-1]->getFirstChild();\n+      }\n+   else\n+      {\n+      if (trace) traceMsg(comp, \"byteOffsets array does not match a big or little endian pattern. rootNode: %p\\n\", rootNode);\n       return currentTreeTop;\n+      }\n \n-   int32_t numBytes = 0;\n-   TR::Node* currentNode = currentTreeTop->getNode();\n-   TR::Node* prevNode = NULL;\n-   TR::Node* rootNode;\n+   if (trace) traceMsg(comp, \"Sequential Load Simplification Candidate - rootNode: %p, %s\\n\", rootNode, littleEndianLoad ? \"Little Endian Load\" : \"Big Endian Load\");\n+   if (trace) traceMsg(comp, \"Sequential Load Simplification Candidate - rootNode: %p, newConvertChildNode: %p, newLoadChildNode: %p\\n\", rootNode, newConvertChildNode, newLoadChildNode);\n \n-   //checking the number of bytes\n-   while ( !((currentNode->getFirstChild() == ibloadNode) && (currentNode->getOpCodeValue() == TR::bu2i)) )\n+   /*\n+    * Check the endianess of the platform and the endianess of the byte array.\n+    * If they don't match, byteswaps will be needed.\n+    */\n+   if (littleEndianLoad && !comp->target().cpu.isLittleEndian())\n+      {\n+      if (!comp->cg()->supportsByteswap())\n+         {\n+         if (trace) traceMsg(comp, \"Little endian load on big endian target without byteswap is not supported. rootNode: %p\\n\", rootNode);\n+         return currentTreeTop;\n+         }\n+      swapBytes = true;\n+      }\n+   else if (!littleEndianLoad && comp->target().cpu.isLittleEndian())\n       {\n-      if ( (currentNode->getOpCodeValue() == TR::iadd) || (currentNode->getOpCodeValue() == TR::ior))\n+      if (!comp->cg()->supportsByteswap())\n          {\n-         numBytes++;\n-         if (numBytes==1)\n-            rootNode=prevNode;\n+         if (trace) traceMsg(comp, \"Big endian load on little endian target without byteswap is not supported. rootNode: %p\\n\", rootNode);\n+         return currentTreeTop;\n          }\n-      else if (isValidSeqLoadIMul(comp, currentNode))\n-         numBytes++;\n-      else\n-         numBytes = 0;\n-      prevNode = currentNode;\n-      currentNode = currentNode->getFirstChild();\n+      swapBytes = true;\n       }\n \n-   if (numBytes == 1)\n+   if (!performTransformation(comp, \"%sReducing sequential loads\\n\", OPT_DETAILS))\n       {\n-      dumpOptDetails(comp, \" Sequential Load of 1 byte not worth reducing\\n\");\n       return currentTreeTop;\n       }\n-   else if ( numBytes != 2 && numBytes != 3 && numBytes != 4 )\n+\n+   /* All checks have passed so perform the transformation. */\n+   traceMsg(comp, \"Sequential Load reduced at rootNode: %p\\n\", rootNode);\n+\n+   disconnectedNode1 = rootNode->getFirstChild();\n+   disconnectedNode2 = rootNode->getSecondChild();\n+\n+   if (((4 == byteCount) && !swapBytes && !is64bitResult) ||\n+       ((8 == byteCount) && !swapBytes))\n       {\n-      dumpOptDetails(comp, \" Sequential Load of size other than 2/3/4 not reducible\\n\");\n-      return currentTreeTop;\n-      }\n+      if (4 == byteCount)\n+         {\n+         /* byteCount is 4, final result is an int, no byteswaps */\n+         if (trace) traceMsg(comp, \"Recreating rootNode (%p) as iloadi.\\n\", rootNode);\n+         TR::Node::recreateWithSymRef(rootNode, TR::iloadi, newLoadChildNode->getSymbolReference());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "193b06309248f14f3bc9c4c5c50b32509018bedf"}, "originalPosition": 2205}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkyNjI2MDg3", "url": "https://github.com/eclipse-openj9/openj9/pull/11251#pullrequestreview-592626087", "createdAt": "2021-02-17T21:05:01Z", "commit": {"oid": "e425ca1524e7f250b2b2ba6de0cad680e6eafed0"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk0MzMzOTQ5", "url": "https://github.com/eclipse-openj9/openj9/pull/11251#pullrequestreview-594333949", "createdAt": "2021-02-19T16:06:14Z", "commit": {"oid": "e425ca1524e7f250b2b2ba6de0cad680e6eafed0"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e425ca1524e7f250b2b2ba6de0cad680e6eafed0", "author": {"user": {"login": "IBMJimmyk", "name": "Jimmy K"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/e425ca1524e7f250b2b2ba6de0cad680e6eafed0", "committedDate": "2021-02-08T21:12:44Z", "message": "Changes symrefs to generic int array shadow\n\nAfter multiple bloadi nodes are combined into a wider load such as a iloadi\nnode, the new load node need the correct symref. I fixed it so that they are\nnow given a generic int array shadow symref.\n\nUpdated several comments to fix grammar or add clarity.\n\nRenamed basePointerNode to baseOffsetNode to more accurately represent what\nit is."}, "afterCommit": {"oid": "0de68e1a4d0bd713784dd10190c623674f5a443b", "author": {"user": {"login": "IBMJimmyk", "name": "Jimmy K"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/0de68e1a4d0bd713784dd10190c623674f5a443b", "committedDate": "2021-02-23T20:02:23Z", "message": "Rewrite opt for combining consecutive byte loads\n\nChanges were made inside the sequentialStoreSimplification. Despite the name\nof the optimization, the changes are targeted at sequential loads.\n\nRewrote the optimization that identifies byte loads from conseuctive memory\naddresses and replaces them with a wider load such as an iload or lload. The\nnew version greatly expands the number of tree patterns indentified by the\noptimization. The new wide load optimization works with 2-8 consecutive byte\nloads and in both big and little endian order.\n\nThe original version of the opt is still available under the env var\nTR_UseOldSeqLoadOpt.\n\nMoved sequentialStoreSimplificationGroup later in the optimization order so\nthat the trees are more likely to be in the right shape for the optimization.\n\nAdded tests to exercise the combining of sequential byte loads in the\nsequentialStoreSimplification optimization.\n\nCloses: #11250\nSigned-off-by: jimmyk <jimmyk@ca.ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0de68e1a4d0bd713784dd10190c623674f5a443b", "author": {"user": {"login": "IBMJimmyk", "name": "Jimmy K"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/0de68e1a4d0bd713784dd10190c623674f5a443b", "committedDate": "2021-02-23T20:02:23Z", "message": "Rewrite opt for combining consecutive byte loads\n\nChanges were made inside the sequentialStoreSimplification. Despite the name\nof the optimization, the changes are targeted at sequential loads.\n\nRewrote the optimization that identifies byte loads from conseuctive memory\naddresses and replaces them with a wider load such as an iload or lload. The\nnew version greatly expands the number of tree patterns indentified by the\noptimization. The new wide load optimization works with 2-8 consecutive byte\nloads and in both big and little endian order.\n\nThe original version of the opt is still available under the env var\nTR_UseOldSeqLoadOpt.\n\nMoved sequentialStoreSimplificationGroup later in the optimization order so\nthat the trees are more likely to be in the right shape for the optimization.\n\nAdded tests to exercise the combining of sequential byte loads in the\nsequentialStoreSimplification optimization.\n\nCloses: #11250\nSigned-off-by: jimmyk <jimmyk@ca.ibm.com>"}, "afterCommit": {"oid": "dcf375449c199e2e464d22eb032b5a004affe284", "author": {"user": {"login": "IBMJimmyk", "name": "Jimmy K"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/dcf375449c199e2e464d22eb032b5a004affe284", "committedDate": "2021-04-12T14:21:00Z", "message": "Rewrite opt for combining consecutive byte loads\n\nChanges were made inside the sequentialStoreSimplification. Despite the name\nof the optimization, the changes are targeted at sequential loads.\n\nRewrote the optimization that identifies byte loads from conseuctive memory\naddresses and replaces them with a wider load such as an iload or lload. The\nnew version greatly expands the number of tree patterns indentified by the\noptimization. The new wide load optimization works with 2-8 consecutive byte\nloads and in both big and little endian order.\n\nThe original version of the opt is still available under the env var\nTR_UseOldSeqLoadOpt.\n\nMoved sequentialStoreSimplificationGroup later in the optimization order so\nthat the trees are more likely to be in the right shape for the optimization.\n\nAdded tests to exercise the combining of sequential byte loads in the\nsequentialStoreSimplification optimization.\n\nCloses: #11250\nSigned-off-by: jimmyk <jimmyk@ca.ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "dcf375449c199e2e464d22eb032b5a004affe284", "author": {"user": {"login": "IBMJimmyk", "name": "Jimmy K"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/dcf375449c199e2e464d22eb032b5a004affe284", "committedDate": "2021-04-12T14:21:00Z", "message": "Rewrite opt for combining consecutive byte loads\n\nChanges were made inside the sequentialStoreSimplification. Despite the name\nof the optimization, the changes are targeted at sequential loads.\n\nRewrote the optimization that identifies byte loads from conseuctive memory\naddresses and replaces them with a wider load such as an iload or lload. The\nnew version greatly expands the number of tree patterns indentified by the\noptimization. The new wide load optimization works with 2-8 consecutive byte\nloads and in both big and little endian order.\n\nThe original version of the opt is still available under the env var\nTR_UseOldSeqLoadOpt.\n\nMoved sequentialStoreSimplificationGroup later in the optimization order so\nthat the trees are more likely to be in the right shape for the optimization.\n\nAdded tests to exercise the combining of sequential byte loads in the\nsequentialStoreSimplification optimization.\n\nCloses: #11250\nSigned-off-by: jimmyk <jimmyk@ca.ibm.com>"}, "afterCommit": {"oid": "82c9e09932a5fd11b5d9fd327545ddbdf31f8b90", "author": {"user": {"login": "IBMJimmyk", "name": "Jimmy K"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/82c9e09932a5fd11b5d9fd327545ddbdf31f8b90", "committedDate": "2021-04-22T03:42:43Z", "message": "Rewrite opt for combining consecutive byte loads\n\nChanges were made inside the sequentialStoreSimplification. Despite the name\nof the optimization, the changes are targeted at sequential loads.\n\nRewrote the optimization that identifies byte loads from conseuctive memory\naddresses and replaces them with a wider load such as an iload or lload. The\nnew version greatly expands the number of tree patterns indentified by the\noptimization. The new wide load optimization works with 2-8 consecutive byte\nloads and in both big and little endian order.\n\nThe original version of the opt is still available under the env var\nTR_UseOldSeqLoadOpt.\n\nMoved sequentialStoreSimplificationGroup later in the optimization order so\nthat the trees are more likely to be in the right shape for the optimization.\n\nAdded tests to exercise the combining of sequential byte loads in the\nsequentialStoreSimplification optimization.\n\nCloses: #11250\nSigned-off-by: jimmyk <jimmyk@ca.ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a88a744eaea97913c5361585bf24f7bd4c9d0217", "author": {"user": {"login": "IBMJimmyk", "name": "Jimmy K"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/a88a744eaea97913c5361585bf24f7bd4c9d0217", "committedDate": "2021-05-13T16:56:43Z", "message": "Rewrite opt for combining consecutive byte loads\n\nChanges were made inside the sequentialStoreSimplification. Despite the name\nof the optimization, the changes are targeted at sequential loads.\n\nRewrote the optimization that identifies byte loads from conseuctive memory\naddresses and replaces them with a wider load such as an iload or lload. The\nnew version greatly expands the number of tree patterns indentified by the\noptimization. The new wide load optimization works with 2-8 consecutive byte\nloads and in both big and little endian order.\n\nThe original version of the opt is still available under the env var\nTR_UseOldSeqLoadOpt.\n\nMoved sequentialStoreSimplificationGroup later in the optimization order so\nthat the trees are more likely to be in the right shape for the optimization.\n\nAdded tests to exercise the combining of sequential byte loads in the\nsequentialStoreSimplification optimization.\n\nCloses: #11250\nSigned-off-by: jimmyk <jimmyk@ca.ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "82c9e09932a5fd11b5d9fd327545ddbdf31f8b90", "author": {"user": {"login": "IBMJimmyk", "name": "Jimmy K"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/82c9e09932a5fd11b5d9fd327545ddbdf31f8b90", "committedDate": "2021-04-22T03:42:43Z", "message": "Rewrite opt for combining consecutive byte loads\n\nChanges were made inside the sequentialStoreSimplification. Despite the name\nof the optimization, the changes are targeted at sequential loads.\n\nRewrote the optimization that identifies byte loads from conseuctive memory\naddresses and replaces them with a wider load such as an iload or lload. The\nnew version greatly expands the number of tree patterns indentified by the\noptimization. The new wide load optimization works with 2-8 consecutive byte\nloads and in both big and little endian order.\n\nThe original version of the opt is still available under the env var\nTR_UseOldSeqLoadOpt.\n\nMoved sequentialStoreSimplificationGroup later in the optimization order so\nthat the trees are more likely to be in the right shape for the optimization.\n\nAdded tests to exercise the combining of sequential byte loads in the\nsequentialStoreSimplification optimization.\n\nCloses: #11250\nSigned-off-by: jimmyk <jimmyk@ca.ibm.com>"}, "afterCommit": {"oid": "a88a744eaea97913c5361585bf24f7bd4c9d0217", "author": {"user": {"login": "IBMJimmyk", "name": "Jimmy K"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/a88a744eaea97913c5361585bf24f7bd4c9d0217", "committedDate": "2021-05-13T16:56:43Z", "message": "Rewrite opt for combining consecutive byte loads\n\nChanges were made inside the sequentialStoreSimplification. Despite the name\nof the optimization, the changes are targeted at sequential loads.\n\nRewrote the optimization that identifies byte loads from conseuctive memory\naddresses and replaces them with a wider load such as an iload or lload. The\nnew version greatly expands the number of tree patterns indentified by the\noptimization. The new wide load optimization works with 2-8 consecutive byte\nloads and in both big and little endian order.\n\nThe original version of the opt is still available under the env var\nTR_UseOldSeqLoadOpt.\n\nMoved sequentialStoreSimplificationGroup later in the optimization order so\nthat the trees are more likely to be in the right shape for the optimization.\n\nAdded tests to exercise the combining of sequential byte loads in the\nsequentialStoreSimplification optimization.\n\nCloses: #11250\nSigned-off-by: jimmyk <jimmyk@ca.ibm.com>"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1630, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}