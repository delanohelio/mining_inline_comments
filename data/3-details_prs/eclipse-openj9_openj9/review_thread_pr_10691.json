{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkyNTk1NzYz", "number": 10691, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QyMTo0OToxOVrOErXqfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxMzoyNTozOVrOErnOdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzOTExOTM1OnYy", "diffSide": "RIGHT", "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodType.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QyMTo0OToxOVrOHeGvKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QyMTo0OToxOVrOHeGvKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMyOTcwNQ==", "bodyText": "One extra empty line.", "url": "https://github.com/eclipse-openj9/openj9/pull/10691#discussion_r501329705", "createdAt": "2020-10-07T21:49:19Z", "author": {"login": "babsingh"}, "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodType.java", "diffHunk": "@@ -75,32 +75,11 @@\n /*[ENDIF]*/\n {\n \tstatic final Class<?>[] EMTPY_PARAMS = new Class<?>[0];\n-\tstatic final Set<Class<?>> WRAPPER_SET;\n-\tstatic {\n-\t\tClass<?>[] wrappers = {Byte.class, Character.class, Double.class, Float.class, Integer.class, Long.class, Short.class, Boolean.class };\n-\t\tWRAPPER_SET = Collections.unmodifiableSet(new HashSet<Class<?>>(Arrays.asList(wrappers)));\n-\t}\n \n /*[IF Sidecar19-SE-OpenJ9]*/\t\n \tprivate MethodTypeForm form;\n /*[ENDIF]*/\t\n-\t\n-\t/*[IF ]*/\n-\t/* Do not include 'primitives.put(\"V\", void.class)' as void.class is not yet loaded when\n-\t * MethodType gets loaded and this will cause the VM not to start.  See the code\n-\t * in Class#getPrimitiveClass() for the issue. */\n-\t/*[ENDIF]*/\n-\tstatic final Class<?>[] primitivesArray = new Class<?>[26];\n-\tstatic {\n-\t\tprimitivesArray['B' - 'A'] = byte.class;\n-\t\tprimitivesArray['C' - 'A'] = char.class;\n-\t\tprimitivesArray['D' - 'A'] = double.class;\n-\t\tprimitivesArray['F' - 'A'] = float.class;\n-\t\tprimitivesArray['I' - 'A'] = int.class;\n-\t\tprimitivesArray['J' - 'A'] = long.class;\n-\t\tprimitivesArray['S' - 'A'] = short.class;\n-\t\tprimitivesArray['Z' - 'A'] = boolean.class;\n-\t}\n+\n \t", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c9ea728638f31bdb3e11d7e90068addd3233991a"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzOTEyMDc3OnYy", "diffSide": "RIGHT", "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodType.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QyMTo0OTo1MlrOHeGwHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QyMTo0OTo1MlrOHeGwHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMyOTk0OQ==", "bodyText": "Two extra empty lines.", "url": "https://github.com/eclipse-openj9/openj9/pull/10691#discussion_r501329949", "createdAt": "2020-10-07T21:49:52Z", "author": {"login": "babsingh"}, "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodType.java", "diffHunk": "@@ -411,31 +390,7 @@ private static final MethodType fromMethodDescriptorStringAppendArg(String metho\n \t\treturn methodType(returnType, types);\n \t}\n \t\n-\t/**\n-\t * This helper calls MethodType.fromMethodDescriptorString(...) or \n-\t * MethodType.fromMethodDescriptorStringAppendArg(...) but throws \n-\t * NoClassDefFoundError instead of TypeNotPresentException during \n-\t * the VM resolve stage.\n-\t *\n-\t * @param methodDescriptor - the method descriptor string\n-\t * @param loader - the ClassLoader to be used\n-\t * @param appendArgumentType - an extra argument type\n-\t *\n-\t * @return a MethodType object representing the method descriptor string\n-\t *\n-\t * @throws IllegalArgumentException - if the string is not well-formed\n-\t * @throws NoClassDefFoundError - if a named type cannot be found\n-\t */\n-\tstatic final MethodType vmResolveFromMethodDescriptorString(String methodDescriptor, ClassLoader loader, Class<?> appendArgumentType) throws Throwable {\n-\t\ttry {\n-\t\t\tif (null == appendArgumentType) {\n-\t\t\t\treturn MethodType.fromMethodDescriptorString(methodDescriptor, loader);\n-\t\t\t}\n-\t\t\treturn MethodType.fromMethodDescriptorStringAppendArg(methodDescriptor, loader, appendArgumentType);\n-\t\t} catch (TypeNotPresentException e) {\n-\t\t\tthrow throwNoClassDefFoundError(e);\n-\t\t}\n-\t}\n+\n ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c9ea728638f31bdb3e11d7e90068addd3233991a"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzOTEyNDM3OnYy", "diffSide": "RIGHT", "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodType.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QyMTo1MTowMVrOHeGyLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QyMDoyNzo0OFrOHg4R_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMzMDQ3Ng==", "bodyText": "Is git a typo?", "url": "https://github.com/eclipse-openj9/openj9/pull/10691#discussion_r501330476", "createdAt": "2020-10-07T21:51:01Z", "author": {"login": "babsingh"}, "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodType.java", "diffHunk": "@@ -1070,133 +959,11 @@ public MethodType appendParameterTypes(List<Class<?>> classes) throws IllegalArg\n \t\tcombinedParameters.addAll(classes);\n \t\treturn methodType(returnType, combinedParameters);\n \t}\n-\t\n-\t/**\n-\t * Returns the appropriate wrapper class or the original class\n-\t * @param primitiveClass The class to convert to a wrapper class\n-\t * @return The wrapper class or the original class if no wrapper is available\n-\t */\n-\tstatic Class<?> wrapPrimitive(Class<?> primitveClass) {\n-\t\tif (primitveClass.isPrimitive()) {\n-\t\t\tif (int.class == primitveClass){ //I\n-\t\t\t\treturn Integer.class;\n-\t\t\t}\n-\t\t\tif (long.class == primitveClass){ //J\n-\t\t\t\treturn Long.class;\n-\t\t\t}\n-\t\t\tif (byte.class == primitveClass){\t//B\n-\t\t\t\treturn Byte.class;\n-\t\t\t}\n-\t\t\tif (char.class == primitveClass){ //C\n-\t\t\t\treturn Character.class;\n-\t\t\t}\n-\t\t\tif (double.class == primitveClass){ //D\n-\t\t\t\treturn Double.class;\n-\t\t\t}\n-\t\t\tif (float.class == primitveClass){ //F\n-\t\t\t\treturn Float.class;\n-\t\t\t}\n-\t\t\tif (boolean.class == primitveClass){ //Z\n-\t\t\t\treturn Boolean.class;\n-\t\t\t}\n-\t\t\tif (void.class == primitveClass) {\n-\t\t\t\treturn Void.class;\n-\t\t\t}\n-\t\t\tif (short.class == primitveClass){ //S\n-\t\t\t\treturn Short.class;\n-\t\t\t}\n-\t\t}\n-\t\treturn primitveClass;\n-\t}\n-\t\n-\t\n-\t/**\n-\t * Takes a class and returns the corresponding primitive if one exists.\n-\t * @param wrapperClass The class to check for primitive classes.\n-\t * @return The corresponding primitive class or the input class.\n-\t */\n-\t/*[IF ]*/\n-\t/* Note that Void.class is not handled by this method as it is only viewed as a\n-\t * wrapper when it is the return class.\n-\t */\n-\t/*[ENDIF]*/\n-\tstatic Class<?> unwrapPrimitive(Class<?> wrapperClass){\n-\t\tif (Integer.class == wrapperClass) { //I\n-\t\t\treturn int.class;\n-\t\t}\n-\t\tif (Long.class == wrapperClass) { //J\n-\t\t\treturn long.class;\n-\t\t}\n-\t\tif (Byte.class == wrapperClass) {\t//B\n-\t\t\treturn byte.class;\n-\t\t}\n-\t\tif (Character.class == wrapperClass) { //C\n-\t\t\treturn char.class;\n-\t\t}\n-\t\tif (Double.class == wrapperClass) { //D\n-\t\t\treturn double.class;\n-\t\t}\n-\t\tif (Float.class == wrapperClass) { //F\n-\t\t\treturn float.class;\n-\t\t}\n-\t\tif (Short.class == wrapperClass) { //S\n-\t\t\treturn short.class;\n-\t\t}\n-\t\tif (Boolean.class == wrapperClass) { //Z\n-\t\t\treturn boolean.class;\n-\t\t}\n-\t\treturn wrapperClass;\n-\t}\n-\t\n-\t/* The string returned by this method should be in sync with Class.descriptorString() */\n-\tstatic String getBytecodeStringName(Class<?> c){\n-\t\tif (c.isPrimitive()) {\n-\t\t\tif (c == int.class) {\n-\t\t\t\treturn \"I\"; //$NON-NLS-1$\n-\t\t\t} else if (c == long.class) {\n-\t\t\t\treturn \"J\"; //$NON-NLS-1$\n-\t\t\t} else if (c == byte.class) {\n-\t\t\t\treturn \"B\"; //$NON-NLS-1$\n-\t\t\t} else if (c == boolean.class) {\n-\t\t\t\treturn \"Z\"; //$NON-NLS-1$\n-\t\t\t} else if (c == void.class) {\n-\t\t\t\treturn \"V\"; //$NON-NLS-1$\n-\t\t\t} else if (c == char.class) {\n-\t\t\t\treturn \"C\"; //$NON-NLS-1$\n-\t\t\t} else if (c == double.class) {\n-\t\t\t\treturn \"D\"; //$NON-NLS-1$\n-\t\t\t} else if (c == float.class) {\n-\t\t\t\treturn \"F\"; //$NON-NLS-1$\n-\t\t\t} else if (c == short.class) {\n-\t\t\t\treturn \"S\"; //$NON-NLS-1$\n-\t\t\t}\n-\t\t}\n-\t\tClass<?> clazz = c;\n-\t\tif (c.isArray()) {\n-\t\t\tclazz = c.getComponentType();\n-\t\t\twhile (clazz.isArray()) {\n-\t\t\t\tclazz = clazz.getComponentType();\n-\t\t\t}\n-\t\t}\n-\t\tString name = c.getName().replace('.', '/');\n-\t\t/*[IF Java15]*/\n-\t\tif (clazz.isHidden()) {\n-\t\t\t/* keep the last \".\" before romaddress for hidden classes */\n-\t\t\tint index = name.lastIndexOf('/');\n-\t\t\tname = name.substring(0, index) + '.' + name.substring(index + 1,name.length());\n-\t\t}\n-\t\t/*[ENDIF] Java15 */\n-\t\t\n-\t\tif (c.isArray()) {\n-\t\t\treturn name;\n-\t\t}\n-\t\treturn \"L\"+ name + \";\"; //$NON-NLS-1$ //$NON-NLS-2$\n-\t}\n-\t\n+\n \t/*\n \t * Implements JSR 292 serialization spec.\n \t * Write the MethodType without writing the field names.\n-\t * Format:\n+\t * Format:git", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c9ea728638f31bdb3e11d7e90068addd3233991a"}, "originalPosition": 334}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQxNzM2NQ==", "bodyText": "yes!", "url": "https://github.com/eclipse-openj9/openj9/pull/10691#discussion_r501417365", "createdAt": "2020-10-08T02:48:40Z", "author": {"login": "fengxue-IS"}, "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodType.java", "diffHunk": "@@ -1070,133 +959,11 @@ public MethodType appendParameterTypes(List<Class<?>> classes) throws IllegalArg\n \t\tcombinedParameters.addAll(classes);\n \t\treturn methodType(returnType, combinedParameters);\n \t}\n-\t\n-\t/**\n-\t * Returns the appropriate wrapper class or the original class\n-\t * @param primitiveClass The class to convert to a wrapper class\n-\t * @return The wrapper class or the original class if no wrapper is available\n-\t */\n-\tstatic Class<?> wrapPrimitive(Class<?> primitveClass) {\n-\t\tif (primitveClass.isPrimitive()) {\n-\t\t\tif (int.class == primitveClass){ //I\n-\t\t\t\treturn Integer.class;\n-\t\t\t}\n-\t\t\tif (long.class == primitveClass){ //J\n-\t\t\t\treturn Long.class;\n-\t\t\t}\n-\t\t\tif (byte.class == primitveClass){\t//B\n-\t\t\t\treturn Byte.class;\n-\t\t\t}\n-\t\t\tif (char.class == primitveClass){ //C\n-\t\t\t\treturn Character.class;\n-\t\t\t}\n-\t\t\tif (double.class == primitveClass){ //D\n-\t\t\t\treturn Double.class;\n-\t\t\t}\n-\t\t\tif (float.class == primitveClass){ //F\n-\t\t\t\treturn Float.class;\n-\t\t\t}\n-\t\t\tif (boolean.class == primitveClass){ //Z\n-\t\t\t\treturn Boolean.class;\n-\t\t\t}\n-\t\t\tif (void.class == primitveClass) {\n-\t\t\t\treturn Void.class;\n-\t\t\t}\n-\t\t\tif (short.class == primitveClass){ //S\n-\t\t\t\treturn Short.class;\n-\t\t\t}\n-\t\t}\n-\t\treturn primitveClass;\n-\t}\n-\t\n-\t\n-\t/**\n-\t * Takes a class and returns the corresponding primitive if one exists.\n-\t * @param wrapperClass The class to check for primitive classes.\n-\t * @return The corresponding primitive class or the input class.\n-\t */\n-\t/*[IF ]*/\n-\t/* Note that Void.class is not handled by this method as it is only viewed as a\n-\t * wrapper when it is the return class.\n-\t */\n-\t/*[ENDIF]*/\n-\tstatic Class<?> unwrapPrimitive(Class<?> wrapperClass){\n-\t\tif (Integer.class == wrapperClass) { //I\n-\t\t\treturn int.class;\n-\t\t}\n-\t\tif (Long.class == wrapperClass) { //J\n-\t\t\treturn long.class;\n-\t\t}\n-\t\tif (Byte.class == wrapperClass) {\t//B\n-\t\t\treturn byte.class;\n-\t\t}\n-\t\tif (Character.class == wrapperClass) { //C\n-\t\t\treturn char.class;\n-\t\t}\n-\t\tif (Double.class == wrapperClass) { //D\n-\t\t\treturn double.class;\n-\t\t}\n-\t\tif (Float.class == wrapperClass) { //F\n-\t\t\treturn float.class;\n-\t\t}\n-\t\tif (Short.class == wrapperClass) { //S\n-\t\t\treturn short.class;\n-\t\t}\n-\t\tif (Boolean.class == wrapperClass) { //Z\n-\t\t\treturn boolean.class;\n-\t\t}\n-\t\treturn wrapperClass;\n-\t}\n-\t\n-\t/* The string returned by this method should be in sync with Class.descriptorString() */\n-\tstatic String getBytecodeStringName(Class<?> c){\n-\t\tif (c.isPrimitive()) {\n-\t\t\tif (c == int.class) {\n-\t\t\t\treturn \"I\"; //$NON-NLS-1$\n-\t\t\t} else if (c == long.class) {\n-\t\t\t\treturn \"J\"; //$NON-NLS-1$\n-\t\t\t} else if (c == byte.class) {\n-\t\t\t\treturn \"B\"; //$NON-NLS-1$\n-\t\t\t} else if (c == boolean.class) {\n-\t\t\t\treturn \"Z\"; //$NON-NLS-1$\n-\t\t\t} else if (c == void.class) {\n-\t\t\t\treturn \"V\"; //$NON-NLS-1$\n-\t\t\t} else if (c == char.class) {\n-\t\t\t\treturn \"C\"; //$NON-NLS-1$\n-\t\t\t} else if (c == double.class) {\n-\t\t\t\treturn \"D\"; //$NON-NLS-1$\n-\t\t\t} else if (c == float.class) {\n-\t\t\t\treturn \"F\"; //$NON-NLS-1$\n-\t\t\t} else if (c == short.class) {\n-\t\t\t\treturn \"S\"; //$NON-NLS-1$\n-\t\t\t}\n-\t\t}\n-\t\tClass<?> clazz = c;\n-\t\tif (c.isArray()) {\n-\t\t\tclazz = c.getComponentType();\n-\t\t\twhile (clazz.isArray()) {\n-\t\t\t\tclazz = clazz.getComponentType();\n-\t\t\t}\n-\t\t}\n-\t\tString name = c.getName().replace('.', '/');\n-\t\t/*[IF Java15]*/\n-\t\tif (clazz.isHidden()) {\n-\t\t\t/* keep the last \".\" before romaddress for hidden classes */\n-\t\t\tint index = name.lastIndexOf('/');\n-\t\t\tname = name.substring(0, index) + '.' + name.substring(index + 1,name.length());\n-\t\t}\n-\t\t/*[ENDIF] Java15 */\n-\t\t\n-\t\tif (c.isArray()) {\n-\t\t\treturn name;\n-\t\t}\n-\t\treturn \"L\"+ name + \";\"; //$NON-NLS-1$ //$NON-NLS-2$\n-\t}\n-\t\n+\n \t/*\n \t * Implements JSR 292 serialization spec.\n \t * Write the MethodType without writing the field names.\n-\t * Format:\n+\t * Format:git", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMzMDQ3Ng=="}, "originalCommit": {"oid": "c9ea728638f31bdb3e11d7e90068addd3233991a"}, "originalPosition": 334}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDIzODU5MQ==", "bodyText": "typo is still present", "url": "https://github.com/eclipse-openj9/openj9/pull/10691#discussion_r504238591", "createdAt": "2020-10-13T20:27:48Z", "author": {"login": "DanHeidinga"}, "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodType.java", "diffHunk": "@@ -1070,133 +959,11 @@ public MethodType appendParameterTypes(List<Class<?>> classes) throws IllegalArg\n \t\tcombinedParameters.addAll(classes);\n \t\treturn methodType(returnType, combinedParameters);\n \t}\n-\t\n-\t/**\n-\t * Returns the appropriate wrapper class or the original class\n-\t * @param primitiveClass The class to convert to a wrapper class\n-\t * @return The wrapper class or the original class if no wrapper is available\n-\t */\n-\tstatic Class<?> wrapPrimitive(Class<?> primitveClass) {\n-\t\tif (primitveClass.isPrimitive()) {\n-\t\t\tif (int.class == primitveClass){ //I\n-\t\t\t\treturn Integer.class;\n-\t\t\t}\n-\t\t\tif (long.class == primitveClass){ //J\n-\t\t\t\treturn Long.class;\n-\t\t\t}\n-\t\t\tif (byte.class == primitveClass){\t//B\n-\t\t\t\treturn Byte.class;\n-\t\t\t}\n-\t\t\tif (char.class == primitveClass){ //C\n-\t\t\t\treturn Character.class;\n-\t\t\t}\n-\t\t\tif (double.class == primitveClass){ //D\n-\t\t\t\treturn Double.class;\n-\t\t\t}\n-\t\t\tif (float.class == primitveClass){ //F\n-\t\t\t\treturn Float.class;\n-\t\t\t}\n-\t\t\tif (boolean.class == primitveClass){ //Z\n-\t\t\t\treturn Boolean.class;\n-\t\t\t}\n-\t\t\tif (void.class == primitveClass) {\n-\t\t\t\treturn Void.class;\n-\t\t\t}\n-\t\t\tif (short.class == primitveClass){ //S\n-\t\t\t\treturn Short.class;\n-\t\t\t}\n-\t\t}\n-\t\treturn primitveClass;\n-\t}\n-\t\n-\t\n-\t/**\n-\t * Takes a class and returns the corresponding primitive if one exists.\n-\t * @param wrapperClass The class to check for primitive classes.\n-\t * @return The corresponding primitive class or the input class.\n-\t */\n-\t/*[IF ]*/\n-\t/* Note that Void.class is not handled by this method as it is only viewed as a\n-\t * wrapper when it is the return class.\n-\t */\n-\t/*[ENDIF]*/\n-\tstatic Class<?> unwrapPrimitive(Class<?> wrapperClass){\n-\t\tif (Integer.class == wrapperClass) { //I\n-\t\t\treturn int.class;\n-\t\t}\n-\t\tif (Long.class == wrapperClass) { //J\n-\t\t\treturn long.class;\n-\t\t}\n-\t\tif (Byte.class == wrapperClass) {\t//B\n-\t\t\treturn byte.class;\n-\t\t}\n-\t\tif (Character.class == wrapperClass) { //C\n-\t\t\treturn char.class;\n-\t\t}\n-\t\tif (Double.class == wrapperClass) { //D\n-\t\t\treturn double.class;\n-\t\t}\n-\t\tif (Float.class == wrapperClass) { //F\n-\t\t\treturn float.class;\n-\t\t}\n-\t\tif (Short.class == wrapperClass) { //S\n-\t\t\treturn short.class;\n-\t\t}\n-\t\tif (Boolean.class == wrapperClass) { //Z\n-\t\t\treturn boolean.class;\n-\t\t}\n-\t\treturn wrapperClass;\n-\t}\n-\t\n-\t/* The string returned by this method should be in sync with Class.descriptorString() */\n-\tstatic String getBytecodeStringName(Class<?> c){\n-\t\tif (c.isPrimitive()) {\n-\t\t\tif (c == int.class) {\n-\t\t\t\treturn \"I\"; //$NON-NLS-1$\n-\t\t\t} else if (c == long.class) {\n-\t\t\t\treturn \"J\"; //$NON-NLS-1$\n-\t\t\t} else if (c == byte.class) {\n-\t\t\t\treturn \"B\"; //$NON-NLS-1$\n-\t\t\t} else if (c == boolean.class) {\n-\t\t\t\treturn \"Z\"; //$NON-NLS-1$\n-\t\t\t} else if (c == void.class) {\n-\t\t\t\treturn \"V\"; //$NON-NLS-1$\n-\t\t\t} else if (c == char.class) {\n-\t\t\t\treturn \"C\"; //$NON-NLS-1$\n-\t\t\t} else if (c == double.class) {\n-\t\t\t\treturn \"D\"; //$NON-NLS-1$\n-\t\t\t} else if (c == float.class) {\n-\t\t\t\treturn \"F\"; //$NON-NLS-1$\n-\t\t\t} else if (c == short.class) {\n-\t\t\t\treturn \"S\"; //$NON-NLS-1$\n-\t\t\t}\n-\t\t}\n-\t\tClass<?> clazz = c;\n-\t\tif (c.isArray()) {\n-\t\t\tclazz = c.getComponentType();\n-\t\t\twhile (clazz.isArray()) {\n-\t\t\t\tclazz = clazz.getComponentType();\n-\t\t\t}\n-\t\t}\n-\t\tString name = c.getName().replace('.', '/');\n-\t\t/*[IF Java15]*/\n-\t\tif (clazz.isHidden()) {\n-\t\t\t/* keep the last \".\" before romaddress for hidden classes */\n-\t\t\tint index = name.lastIndexOf('/');\n-\t\t\tname = name.substring(0, index) + '.' + name.substring(index + 1,name.length());\n-\t\t}\n-\t\t/*[ENDIF] Java15 */\n-\t\t\n-\t\tif (c.isArray()) {\n-\t\t\treturn name;\n-\t\t}\n-\t\treturn \"L\"+ name + \";\"; //$NON-NLS-1$ //$NON-NLS-2$\n-\t}\n-\t\n+\n \t/*\n \t * Implements JSR 292 serialization spec.\n \t * Write the MethodType without writing the field names.\n-\t * Format:\n+\t * Format:git", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMzMDQ3Ng=="}, "originalCommit": {"oid": "c9ea728638f31bdb3e11d7e90068addd3233991a"}, "originalPosition": 334}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzOTEyNzkyOnYy", "diffSide": "RIGHT", "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodTypeHelper.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QyMTo1MjoxMFrOHeG0VA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QyMTo1MjoxMFrOHeG0VA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMzMTAyOA==", "bodyText": "Inconsistent spacing\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tif (Byte.class == wrapperClass) {\t//B\n          \n          \n            \n            \t\tif (Byte.class == wrapperClass) { //B", "url": "https://github.com/eclipse-openj9/openj9/pull/10691#discussion_r501331028", "createdAt": "2020-10-07T21:52:10Z", "author": {"login": "babsingh"}, "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodTypeHelper.java", "diffHunk": "@@ -0,0 +1,281 @@\n+/*[INCLUDE-IF Sidecar18-SE]*/\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+package java.lang.invoke;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import com.ibm.oti.util.Msg;\n+\n+/**\n+ * MethodTypeHelper - static methods\n+ * \n+ * @since Java 11\n+ */\n+public final class MethodTypeHelper {\n+\tstatic final Set<Class<?>> WRAPPER_SET;\n+\tstatic {\n+\t\tClass<?>[] wrappers = {Byte.class, Character.class, Double.class, Float.class, Integer.class, Long.class, Short.class, Boolean.class };\n+\t\tWRAPPER_SET = Collections.unmodifiableSet(new HashSet<Class<?>>(Arrays.asList(wrappers)));\n+\t}\n+\n+\t/*[IF ]*/\n+\t/* Do not include 'primitives.put(\"V\", void.class)' as void.class is not yet loaded when\n+\t * MethodType gets loaded and this will cause the VM not to start.  See the code\n+\t * in Class#getPrimitiveClass() for the issue. */\n+\t/*[ENDIF]*/\n+\tstatic final Class<?>[] primitivesArray = new Class<?>[26];\n+\tstatic {\n+\t\tprimitivesArray['B' - 'A'] = byte.class;\n+\t\tprimitivesArray['C' - 'A'] = char.class;\n+\t\tprimitivesArray['D' - 'A'] = double.class;\n+\t\tprimitivesArray['F' - 'A'] = float.class;\n+\t\tprimitivesArray['I' - 'A'] = int.class;\n+\t\tprimitivesArray['J' - 'A'] = long.class;\n+\t\tprimitivesArray['S' - 'A'] = short.class;\n+\t\tprimitivesArray['Z' - 'A'] = boolean.class;\n+\t}\n+\n+\t/**\n+\t * Returns the appropriate wrapper class or the original class\n+\t * @param primitiveClass The class to convert to a wrapper class\n+\t * @return The wrapper class or the original class if no wrapper is available\n+\t */\n+\tstatic Class<?> wrapPrimitive(Class<?> primitveClass) {\n+\t\tif (primitveClass.isPrimitive()) {\n+\t\t\tif (int.class == primitveClass){ //I\n+\t\t\t\treturn Integer.class;\n+\t\t\t}\n+\t\t\tif (long.class == primitveClass){ //J\n+\t\t\t\treturn Long.class;\n+\t\t\t}\n+\t\t\tif (byte.class == primitveClass){\t//B\n+\t\t\t\treturn Byte.class;\n+\t\t\t}\n+\t\t\tif (char.class == primitveClass){ //C\n+\t\t\t\treturn Character.class;\n+\t\t\t}\n+\t\t\tif (double.class == primitveClass){ //D\n+\t\t\t\treturn Double.class;\n+\t\t\t}\n+\t\t\tif (float.class == primitveClass){ //F\n+\t\t\t\treturn Float.class;\n+\t\t\t}\n+\t\t\tif (boolean.class == primitveClass){ //Z\n+\t\t\t\treturn Boolean.class;\n+\t\t\t}\n+\t\t\tif (void.class == primitveClass) {\n+\t\t\t\treturn Void.class;\n+\t\t\t}\n+\t\t\tif (short.class == primitveClass){ //S\n+\t\t\t\treturn Short.class;\n+\t\t\t}\n+\t\t}\n+\t\treturn primitveClass;\n+\t}\n+\t\n+\t/**\n+\t * Takes a class and returns the corresponding primitive if one exists.\n+\t * @param wrapperClass The class to check for primitive classes.\n+\t * @return The corresponding primitive class or the input class.\n+\t */\n+\t/*[IF ]*/\n+\t/* Note that Void.class is not handled by this method as it is only viewed as a\n+\t * wrapper when it is the return class.\n+\t */\n+\t/*[ENDIF]*/\n+\tstatic Class<?> unwrapPrimitive(Class<?> wrapperClass){\n+\t\tif (Integer.class == wrapperClass) { //I\n+\t\t\treturn int.class;\n+\t\t}\n+\t\tif (Long.class == wrapperClass) { //J\n+\t\t\treturn long.class;\n+\t\t}\n+\t\tif (Byte.class == wrapperClass) {\t//B", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c9ea728638f31bdb3e11d7e90068addd3233991a"}, "originalPosition": 117}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzOTEyOTI4OnYy", "diffSide": "RIGHT", "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodTypeHelper.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QyMTo1MjozN1rOHeG1Kw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QyMDoyODoxN1rOHg4TAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMzMTI0Mw==", "bodyText": "Inconsistent spacing\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\tif (byte.class == primitveClass){\t//B\n          \n          \n            \n            \t\t\tif (byte.class == primitveClass){ //B", "url": "https://github.com/eclipse-openj9/openj9/pull/10691#discussion_r501331243", "createdAt": "2020-10-07T21:52:37Z", "author": {"login": "babsingh"}, "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodTypeHelper.java", "diffHunk": "@@ -0,0 +1,281 @@\n+/*[INCLUDE-IF Sidecar18-SE]*/\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+package java.lang.invoke;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import com.ibm.oti.util.Msg;\n+\n+/**\n+ * MethodTypeHelper - static methods\n+ * \n+ * @since Java 11\n+ */\n+public final class MethodTypeHelper {\n+\tstatic final Set<Class<?>> WRAPPER_SET;\n+\tstatic {\n+\t\tClass<?>[] wrappers = {Byte.class, Character.class, Double.class, Float.class, Integer.class, Long.class, Short.class, Boolean.class };\n+\t\tWRAPPER_SET = Collections.unmodifiableSet(new HashSet<Class<?>>(Arrays.asList(wrappers)));\n+\t}\n+\n+\t/*[IF ]*/\n+\t/* Do not include 'primitives.put(\"V\", void.class)' as void.class is not yet loaded when\n+\t * MethodType gets loaded and this will cause the VM not to start.  See the code\n+\t * in Class#getPrimitiveClass() for the issue. */\n+\t/*[ENDIF]*/\n+\tstatic final Class<?>[] primitivesArray = new Class<?>[26];\n+\tstatic {\n+\t\tprimitivesArray['B' - 'A'] = byte.class;\n+\t\tprimitivesArray['C' - 'A'] = char.class;\n+\t\tprimitivesArray['D' - 'A'] = double.class;\n+\t\tprimitivesArray['F' - 'A'] = float.class;\n+\t\tprimitivesArray['I' - 'A'] = int.class;\n+\t\tprimitivesArray['J' - 'A'] = long.class;\n+\t\tprimitivesArray['S' - 'A'] = short.class;\n+\t\tprimitivesArray['Z' - 'A'] = boolean.class;\n+\t}\n+\n+\t/**\n+\t * Returns the appropriate wrapper class or the original class\n+\t * @param primitiveClass The class to convert to a wrapper class\n+\t * @return The wrapper class or the original class if no wrapper is available\n+\t */\n+\tstatic Class<?> wrapPrimitive(Class<?> primitveClass) {\n+\t\tif (primitveClass.isPrimitive()) {\n+\t\t\tif (int.class == primitveClass){ //I\n+\t\t\t\treturn Integer.class;\n+\t\t\t}\n+\t\t\tif (long.class == primitveClass){ //J\n+\t\t\t\treturn Long.class;\n+\t\t\t}\n+\t\t\tif (byte.class == primitveClass){\t//B", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c9ea728638f31bdb3e11d7e90068addd3233991a"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDIzODg0OA==", "bodyText": "still present", "url": "https://github.com/eclipse-openj9/openj9/pull/10691#discussion_r504238848", "createdAt": "2020-10-13T20:28:17Z", "author": {"login": "DanHeidinga"}, "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodTypeHelper.java", "diffHunk": "@@ -0,0 +1,281 @@\n+/*[INCLUDE-IF Sidecar18-SE]*/\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+package java.lang.invoke;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import com.ibm.oti.util.Msg;\n+\n+/**\n+ * MethodTypeHelper - static methods\n+ * \n+ * @since Java 11\n+ */\n+public final class MethodTypeHelper {\n+\tstatic final Set<Class<?>> WRAPPER_SET;\n+\tstatic {\n+\t\tClass<?>[] wrappers = {Byte.class, Character.class, Double.class, Float.class, Integer.class, Long.class, Short.class, Boolean.class };\n+\t\tWRAPPER_SET = Collections.unmodifiableSet(new HashSet<Class<?>>(Arrays.asList(wrappers)));\n+\t}\n+\n+\t/*[IF ]*/\n+\t/* Do not include 'primitives.put(\"V\", void.class)' as void.class is not yet loaded when\n+\t * MethodType gets loaded and this will cause the VM not to start.  See the code\n+\t * in Class#getPrimitiveClass() for the issue. */\n+\t/*[ENDIF]*/\n+\tstatic final Class<?>[] primitivesArray = new Class<?>[26];\n+\tstatic {\n+\t\tprimitivesArray['B' - 'A'] = byte.class;\n+\t\tprimitivesArray['C' - 'A'] = char.class;\n+\t\tprimitivesArray['D' - 'A'] = double.class;\n+\t\tprimitivesArray['F' - 'A'] = float.class;\n+\t\tprimitivesArray['I' - 'A'] = int.class;\n+\t\tprimitivesArray['J' - 'A'] = long.class;\n+\t\tprimitivesArray['S' - 'A'] = short.class;\n+\t\tprimitivesArray['Z' - 'A'] = boolean.class;\n+\t}\n+\n+\t/**\n+\t * Returns the appropriate wrapper class or the original class\n+\t * @param primitiveClass The class to convert to a wrapper class\n+\t * @return The wrapper class or the original class if no wrapper is available\n+\t */\n+\tstatic Class<?> wrapPrimitive(Class<?> primitveClass) {\n+\t\tif (primitveClass.isPrimitive()) {\n+\t\t\tif (int.class == primitveClass){ //I\n+\t\t\t\treturn Integer.class;\n+\t\t\t}\n+\t\t\tif (long.class == primitveClass){ //J\n+\t\t\t\treturn Long.class;\n+\t\t\t}\n+\t\t\tif (byte.class == primitveClass){\t//B", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMzMTI0Mw=="}, "originalCommit": {"oid": "c9ea728638f31bdb3e11d7e90068addd3233991a"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzOTEzMDYzOnYy", "diffSide": "RIGHT", "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodTypeHelper.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QyMTo1MzowNlrOHeG1-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QyMTo1MzowNlrOHeG1-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMzMTQ0OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tstatic String getBytecodeStringName(Class<?> c){\n          \n          \n            \n            \tstatic String getBytecodeStringName(Class<?> c) {", "url": "https://github.com/eclipse-openj9/openj9/pull/10691#discussion_r501331449", "createdAt": "2020-10-07T21:53:06Z", "author": {"login": "babsingh"}, "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodTypeHelper.java", "diffHunk": "@@ -0,0 +1,281 @@\n+/*[INCLUDE-IF Sidecar18-SE]*/\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+package java.lang.invoke;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import com.ibm.oti.util.Msg;\n+\n+/**\n+ * MethodTypeHelper - static methods\n+ * \n+ * @since Java 11\n+ */\n+public final class MethodTypeHelper {\n+\tstatic final Set<Class<?>> WRAPPER_SET;\n+\tstatic {\n+\t\tClass<?>[] wrappers = {Byte.class, Character.class, Double.class, Float.class, Integer.class, Long.class, Short.class, Boolean.class };\n+\t\tWRAPPER_SET = Collections.unmodifiableSet(new HashSet<Class<?>>(Arrays.asList(wrappers)));\n+\t}\n+\n+\t/*[IF ]*/\n+\t/* Do not include 'primitives.put(\"V\", void.class)' as void.class is not yet loaded when\n+\t * MethodType gets loaded and this will cause the VM not to start.  See the code\n+\t * in Class#getPrimitiveClass() for the issue. */\n+\t/*[ENDIF]*/\n+\tstatic final Class<?>[] primitivesArray = new Class<?>[26];\n+\tstatic {\n+\t\tprimitivesArray['B' - 'A'] = byte.class;\n+\t\tprimitivesArray['C' - 'A'] = char.class;\n+\t\tprimitivesArray['D' - 'A'] = double.class;\n+\t\tprimitivesArray['F' - 'A'] = float.class;\n+\t\tprimitivesArray['I' - 'A'] = int.class;\n+\t\tprimitivesArray['J' - 'A'] = long.class;\n+\t\tprimitivesArray['S' - 'A'] = short.class;\n+\t\tprimitivesArray['Z' - 'A'] = boolean.class;\n+\t}\n+\n+\t/**\n+\t * Returns the appropriate wrapper class or the original class\n+\t * @param primitiveClass The class to convert to a wrapper class\n+\t * @return The wrapper class or the original class if no wrapper is available\n+\t */\n+\tstatic Class<?> wrapPrimitive(Class<?> primitveClass) {\n+\t\tif (primitveClass.isPrimitive()) {\n+\t\t\tif (int.class == primitveClass){ //I\n+\t\t\t\treturn Integer.class;\n+\t\t\t}\n+\t\t\tif (long.class == primitveClass){ //J\n+\t\t\t\treturn Long.class;\n+\t\t\t}\n+\t\t\tif (byte.class == primitveClass){\t//B\n+\t\t\t\treturn Byte.class;\n+\t\t\t}\n+\t\t\tif (char.class == primitveClass){ //C\n+\t\t\t\treturn Character.class;\n+\t\t\t}\n+\t\t\tif (double.class == primitveClass){ //D\n+\t\t\t\treturn Double.class;\n+\t\t\t}\n+\t\t\tif (float.class == primitveClass){ //F\n+\t\t\t\treturn Float.class;\n+\t\t\t}\n+\t\t\tif (boolean.class == primitveClass){ //Z\n+\t\t\t\treturn Boolean.class;\n+\t\t\t}\n+\t\t\tif (void.class == primitveClass) {\n+\t\t\t\treturn Void.class;\n+\t\t\t}\n+\t\t\tif (short.class == primitveClass){ //S\n+\t\t\t\treturn Short.class;\n+\t\t\t}\n+\t\t}\n+\t\treturn primitveClass;\n+\t}\n+\t\n+\t/**\n+\t * Takes a class and returns the corresponding primitive if one exists.\n+\t * @param wrapperClass The class to check for primitive classes.\n+\t * @return The corresponding primitive class or the input class.\n+\t */\n+\t/*[IF ]*/\n+\t/* Note that Void.class is not handled by this method as it is only viewed as a\n+\t * wrapper when it is the return class.\n+\t */\n+\t/*[ENDIF]*/\n+\tstatic Class<?> unwrapPrimitive(Class<?> wrapperClass){\n+\t\tif (Integer.class == wrapperClass) { //I\n+\t\t\treturn int.class;\n+\t\t}\n+\t\tif (Long.class == wrapperClass) { //J\n+\t\t\treturn long.class;\n+\t\t}\n+\t\tif (Byte.class == wrapperClass) {\t//B\n+\t\t\treturn byte.class;\n+\t\t}\n+\t\tif (Character.class == wrapperClass) { //C\n+\t\t\treturn char.class;\n+\t\t}\n+\t\tif (Double.class == wrapperClass) { //D\n+\t\t\treturn double.class;\n+\t\t}\n+\t\tif (Float.class == wrapperClass) { //F\n+\t\t\treturn float.class;\n+\t\t}\n+\t\tif (Short.class == wrapperClass) { //S\n+\t\t\treturn short.class;\n+\t\t}\n+\t\tif (Boolean.class == wrapperClass) { //Z\n+\t\t\treturn boolean.class;\n+\t\t}\n+\t\treturn wrapperClass;\n+\t}\n+\n+\t/* The string returned by this method should be in sync with Class.descriptorString() */\n+\tstatic String getBytecodeStringName(Class<?> c){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c9ea728638f31bdb3e11d7e90068addd3233991a"}, "originalPosition": 139}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzOTEzMTQyOnYy", "diffSide": "RIGHT", "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodTypeHelper.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QyMTo1MzoyNFrOHeG2dg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QyMTo1MzoyNFrOHeG2dg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMzMTU3NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tstatic Class<?> unwrapPrimitive(Class<?> wrapperClass){\n          \n          \n            \n            \tstatic Class<?> unwrapPrimitive(Class<?> wrapperClass) {", "url": "https://github.com/eclipse-openj9/openj9/pull/10691#discussion_r501331574", "createdAt": "2020-10-07T21:53:24Z", "author": {"login": "babsingh"}, "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodTypeHelper.java", "diffHunk": "@@ -0,0 +1,281 @@\n+/*[INCLUDE-IF Sidecar18-SE]*/\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+package java.lang.invoke;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import com.ibm.oti.util.Msg;\n+\n+/**\n+ * MethodTypeHelper - static methods\n+ * \n+ * @since Java 11\n+ */\n+public final class MethodTypeHelper {\n+\tstatic final Set<Class<?>> WRAPPER_SET;\n+\tstatic {\n+\t\tClass<?>[] wrappers = {Byte.class, Character.class, Double.class, Float.class, Integer.class, Long.class, Short.class, Boolean.class };\n+\t\tWRAPPER_SET = Collections.unmodifiableSet(new HashSet<Class<?>>(Arrays.asList(wrappers)));\n+\t}\n+\n+\t/*[IF ]*/\n+\t/* Do not include 'primitives.put(\"V\", void.class)' as void.class is not yet loaded when\n+\t * MethodType gets loaded and this will cause the VM not to start.  See the code\n+\t * in Class#getPrimitiveClass() for the issue. */\n+\t/*[ENDIF]*/\n+\tstatic final Class<?>[] primitivesArray = new Class<?>[26];\n+\tstatic {\n+\t\tprimitivesArray['B' - 'A'] = byte.class;\n+\t\tprimitivesArray['C' - 'A'] = char.class;\n+\t\tprimitivesArray['D' - 'A'] = double.class;\n+\t\tprimitivesArray['F' - 'A'] = float.class;\n+\t\tprimitivesArray['I' - 'A'] = int.class;\n+\t\tprimitivesArray['J' - 'A'] = long.class;\n+\t\tprimitivesArray['S' - 'A'] = short.class;\n+\t\tprimitivesArray['Z' - 'A'] = boolean.class;\n+\t}\n+\n+\t/**\n+\t * Returns the appropriate wrapper class or the original class\n+\t * @param primitiveClass The class to convert to a wrapper class\n+\t * @return The wrapper class or the original class if no wrapper is available\n+\t */\n+\tstatic Class<?> wrapPrimitive(Class<?> primitveClass) {\n+\t\tif (primitveClass.isPrimitive()) {\n+\t\t\tif (int.class == primitveClass){ //I\n+\t\t\t\treturn Integer.class;\n+\t\t\t}\n+\t\t\tif (long.class == primitveClass){ //J\n+\t\t\t\treturn Long.class;\n+\t\t\t}\n+\t\t\tif (byte.class == primitveClass){\t//B\n+\t\t\t\treturn Byte.class;\n+\t\t\t}\n+\t\t\tif (char.class == primitveClass){ //C\n+\t\t\t\treturn Character.class;\n+\t\t\t}\n+\t\t\tif (double.class == primitveClass){ //D\n+\t\t\t\treturn Double.class;\n+\t\t\t}\n+\t\t\tif (float.class == primitveClass){ //F\n+\t\t\t\treturn Float.class;\n+\t\t\t}\n+\t\t\tif (boolean.class == primitveClass){ //Z\n+\t\t\t\treturn Boolean.class;\n+\t\t\t}\n+\t\t\tif (void.class == primitveClass) {\n+\t\t\t\treturn Void.class;\n+\t\t\t}\n+\t\t\tif (short.class == primitveClass){ //S\n+\t\t\t\treturn Short.class;\n+\t\t\t}\n+\t\t}\n+\t\treturn primitveClass;\n+\t}\n+\t\n+\t/**\n+\t * Takes a class and returns the corresponding primitive if one exists.\n+\t * @param wrapperClass The class to check for primitive classes.\n+\t * @return The corresponding primitive class or the input class.\n+\t */\n+\t/*[IF ]*/\n+\t/* Note that Void.class is not handled by this method as it is only viewed as a\n+\t * wrapper when it is the return class.\n+\t */\n+\t/*[ENDIF]*/\n+\tstatic Class<?> unwrapPrimitive(Class<?> wrapperClass){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c9ea728638f31bdb3e11d7e90068addd3233991a"}, "originalPosition": 110}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0MTY1NDYxOnYy", "diffSide": "RIGHT", "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodTypeHelper.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxMzoyMjozOVrOHeeUWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QyMDoxOTo1OFrOHg36VA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTcxNjA1OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            public final class MethodTypeHelper {\n          \n          \n            \n            final class MethodTypeHelper {\n          \n      \n    \n    \n  \n\nThis can't be a public class in the java.* package.", "url": "https://github.com/eclipse-openj9/openj9/pull/10691#discussion_r501716059", "createdAt": "2020-10-08T13:22:39Z", "author": {"login": "DanHeidinga"}, "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodTypeHelper.java", "diffHunk": "@@ -0,0 +1,281 @@\n+/*[INCLUDE-IF Sidecar18-SE]*/\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+package java.lang.invoke;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import com.ibm.oti.util.Msg;\n+\n+/**\n+ * MethodTypeHelper - static methods\n+ * \n+ * @since Java 11\n+ */\n+public final class MethodTypeHelper {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56326b1ea40bd9d3f9aaa46a8a60daeccfdbabfc"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDIzMjUzMg==", "bodyText": "fixed", "url": "https://github.com/eclipse-openj9/openj9/pull/10691#discussion_r504232532", "createdAt": "2020-10-13T20:19:58Z", "author": {"login": "fengxue-IS"}, "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodTypeHelper.java", "diffHunk": "@@ -0,0 +1,281 @@\n+/*[INCLUDE-IF Sidecar18-SE]*/\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+package java.lang.invoke;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import com.ibm.oti.util.Msg;\n+\n+/**\n+ * MethodTypeHelper - static methods\n+ * \n+ * @since Java 11\n+ */\n+public final class MethodTypeHelper {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTcxNjA1OQ=="}, "originalCommit": {"oid": "56326b1ea40bd9d3f9aaa46a8a60daeccfdbabfc"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0MTY2OTAxOnYy", "diffSide": "RIGHT", "path": "runtime/oti/vmconstantpool.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxMzoyNTozOVrOHeedJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QyMDoxOTo1MlrOHg359g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTcxODMwOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t<staticmethodref class=\"java/lang/invoke/MethodTypeHelper\" name=\"vmResolveFromMethodDescriptorString\" signature=\"(Ljava/lang/String;Ljava/lang/ClassLoader;Ljava/lang/Class;)Ljava/lang/invoke/MethodType;\" flags=\"opt_methodHandleCommon\"/>\n          \n          \n            \n            \t<!-- Common method references shared between OpenJ9 and OpenJDK MethodHandles. -->\n          \n          \n            \n            \t<staticmethodref class=\"java/lang/invoke/MethodTypeHelper\" name=\"vmResolveFromMethodDescriptorString\" signature=\"(Ljava/lang/String;Ljava/lang/ClassLoader;Ljava/lang/Class;)Ljava/lang/invoke/MethodType;\" flags=\"opt_methodHandleCommon\"/>\n          \n          \n            \n            \t\n          \n          \n            \n            \t<!-- Static method references needed to support OpenJDK MethodHandles. -->\n          \n      \n    \n    \n  \n\nThe comment needs to be shifted after the opt_methodHandleCommon method and a new comment added above", "url": "https://github.com/eclipse-openj9/openj9/pull/10691#discussion_r501718308", "createdAt": "2020-10-08T13:25:39Z", "author": {"login": "DanHeidinga"}, "path": "runtime/oti/vmconstantpool.xml", "diffHunk": "@@ -412,7 +411,7 @@ SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-excepti\n \t<staticmethodref class=\"java/lang/J9VMInternals\" name=\"recordInitializationFailure\" signature=\"(Ljava/lang/Class;Ljava/lang/Throwable;)V\"/>\n \n \t<!-- Static method references needed to support OpenJDK MethodHandles. -->\n-\t<staticmethodref class=\"java/lang/invoke/MethodTypeHelper\" name=\"vmResolveFromMethodDescriptorString\" signature=\"(Ljava/lang/String;Ljava/lang/ClassLoader;Ljava/lang/Class;)Ljava/lang/invoke/MethodType;\" flags=\"opt_openjdkMethodhandle\"/>\n+\t<staticmethodref class=\"java/lang/invoke/MethodTypeHelper\" name=\"vmResolveFromMethodDescriptorString\" signature=\"(Ljava/lang/String;Ljava/lang/ClassLoader;Ljava/lang/Class;)Ljava/lang/invoke/MethodType;\" flags=\"opt_methodHandleCommon\"/>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56326b1ea40bd9d3f9aaa46a8a60daeccfdbabfc"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDIzMjQzOA==", "bodyText": "fixed", "url": "https://github.com/eclipse-openj9/openj9/pull/10691#discussion_r504232438", "createdAt": "2020-10-13T20:19:52Z", "author": {"login": "fengxue-IS"}, "path": "runtime/oti/vmconstantpool.xml", "diffHunk": "@@ -412,7 +411,7 @@ SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-excepti\n \t<staticmethodref class=\"java/lang/J9VMInternals\" name=\"recordInitializationFailure\" signature=\"(Ljava/lang/Class;Ljava/lang/Throwable;)V\"/>\n \n \t<!-- Static method references needed to support OpenJDK MethodHandles. -->\n-\t<staticmethodref class=\"java/lang/invoke/MethodTypeHelper\" name=\"vmResolveFromMethodDescriptorString\" signature=\"(Ljava/lang/String;Ljava/lang/ClassLoader;Ljava/lang/Class;)Ljava/lang/invoke/MethodType;\" flags=\"opt_openjdkMethodhandle\"/>\n+\t<staticmethodref class=\"java/lang/invoke/MethodTypeHelper\" name=\"vmResolveFromMethodDescriptorString\" signature=\"(Ljava/lang/String;Ljava/lang/ClassLoader;Ljava/lang/Class;)Ljava/lang/invoke/MethodType;\" flags=\"opt_methodHandleCommon\"/>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTcxODMwOA=="}, "originalCommit": {"oid": "56326b1ea40bd9d3f9aaa46a8a60daeccfdbabfc"}, "originalPosition": 26}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1236, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}