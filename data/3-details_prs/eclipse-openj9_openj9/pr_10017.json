{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQwMTUzOTY0", "number": 10017, "title": "Group cache field and static info in JITServer", "bodyText": "TR_J9ServerVM::jitFieldsAreSame/jitStaticsAreSame are mostly called\nduring ILGen for checking if the symbol reference for a field\nhas already been created. We iterate through all existing symbol\nreferences of the corresponding type and determine if any existing\nsymref describes the current field.\nThis commit optimizes the process by prefetching info for all\nfields and statics in a method in one message.\n\n\nImplement caching for jitStaticsAreSame\nand merges message hanlding code for fields and statics into one,\nsince they are funcionally identical.\n\n\nSimplify client-side code for finding field data.\nnon-JITServer code doesn't look for field data if both fields are\nresolved and their value offsets are different. This is an optimization\nthat shouldn't affect functional correctness, so this commit always\nlooks for field data, because it improves caching and simplifies the\ncode.", "createdAt": "2020-06-25T17:15:00Z", "url": "https://github.com/eclipse-openj9/openj9/pull/10017", "merged": true, "mergeCommit": {"oid": "3343c3ddb27d2b8a6bcaea878d239c9c46445717"}, "closed": true, "closedAt": "2020-07-06T23:15:29Z", "author": {"login": "dmitry-ten"}, "timelineItems": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcux-A8gBqjM0ODMzODM2MDQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcyWVVzgBqjM1MTczMzM0NTg=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "941365fb32a04cdf1304e4c29cf141df0eee4f19", "author": {"user": {"login": "dmitry-ten", "name": "Dmitry Ten"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/941365fb32a04cdf1304e4c29cf141df0eee4f19", "committedDate": "2020-06-25T16:59:54Z", "message": "Group cache field and static info in JITServer\n\n`TR_J9ServerVM::jitFieldsAreSame`/`jitStaticsAreSame` are mostly called\nduring ILGen for checking if the symbol reference for a field\nhas already been created. We iterate through all existing symbol\nreferences of the corresponding type and determine if any existing\nsymref describes the current field.\nThis commit optimizes the process by prefetching info for all\nfields and statics in a method in one message.\nThis commit also implements caching for `jitStaticsAreSame`.\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>"}, "afterCommit": {"oid": "7a9dde65cfe0a18e4b4b8a6387dc7007d501e67e", "author": {"user": {"login": "dmitry-ten", "name": "Dmitry Ten"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/7a9dde65cfe0a18e4b4b8a6387dc7007d501e67e", "committedDate": "2020-06-25T17:17:31Z", "message": "Group cache field and static info in JITServer\n\n- `TR_J9ServerVM::jitFieldsAreSame`/`jitStaticsAreSame` are mostly called\nduring ILGen for checking if the symbol reference for a field\nhas already been created. We iterate through all existing symbol\nreferences of the corresponding type and determine if any existing\nsymref describes the current field.\nThis commit optimizes the process by prefetching info for all\nfields and statics in a method in one message.\n\n- This commit also implements caching for `jitStaticsAreSame`\nand merges message hanlding code for fields and statics into one,\nsince they are funcionally identical.\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7a9dde65cfe0a18e4b4b8a6387dc7007d501e67e", "author": {"user": {"login": "dmitry-ten", "name": "Dmitry Ten"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/7a9dde65cfe0a18e4b4b8a6387dc7007d501e67e", "committedDate": "2020-06-25T17:17:31Z", "message": "Group cache field and static info in JITServer\n\n- `TR_J9ServerVM::jitFieldsAreSame`/`jitStaticsAreSame` are mostly called\nduring ILGen for checking if the symbol reference for a field\nhas already been created. We iterate through all existing symbol\nreferences of the corresponding type and determine if any existing\nsymref describes the current field.\nThis commit optimizes the process by prefetching info for all\nfields and statics in a method in one message.\n\n- This commit also implements caching for `jitStaticsAreSame`\nand merges message hanlding code for fields and statics into one,\nsince they are funcionally identical.\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>"}, "afterCommit": {"oid": "ab218f19ae775db9f48500332deeacef8e8c4873", "author": {"user": {"login": "dmitry-ten", "name": "Dmitry Ten"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/ab218f19ae775db9f48500332deeacef8e8c4873", "committedDate": "2020-06-25T17:31:34Z", "message": "Group cache field and static info in JITServer\n\n- `TR_J9ServerVM::jitFieldsAreSame`/`jitStaticsAreSame` are mostly called\nduring ILGen for checking if the symbol reference for a field\nhas already been created. We iterate through all existing symbol\nreferences of the corresponding type and determine if any existing\nsymref describes the current field.\nThis commit optimizes the process by prefetching info for all\nfields and statics in a method in one message.\n\n- This commit also implements caching for `jitStaticsAreSame`\nand merges message hanlding code for fields and statics into one,\nsince they are funcionally identical.\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ab218f19ae775db9f48500332deeacef8e8c4873", "author": {"user": {"login": "dmitry-ten", "name": "Dmitry Ten"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/ab218f19ae775db9f48500332deeacef8e8c4873", "committedDate": "2020-06-25T17:31:34Z", "message": "Group cache field and static info in JITServer\n\n- `TR_J9ServerVM::jitFieldsAreSame`/`jitStaticsAreSame` are mostly called\nduring ILGen for checking if the symbol reference for a field\nhas already been created. We iterate through all existing symbol\nreferences of the corresponding type and determine if any existing\nsymref describes the current field.\nThis commit optimizes the process by prefetching info for all\nfields and statics in a method in one message.\n\n- This commit also implements caching for `jitStaticsAreSame`\nand merges message hanlding code for fields and statics into one,\nsince they are funcionally identical.\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>"}, "afterCommit": {"oid": "aa8eb2b0cc78fabe95402fe9dfa85dc66d46c552", "author": {"user": {"login": "dmitry-ten", "name": "Dmitry Ten"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/aa8eb2b0cc78fabe95402fe9dfa85dc66d46c552", "committedDate": "2020-06-25T18:51:53Z", "message": "Group cache field and static info in JITServer\n\n- `TR_J9ServerVM::jitFieldsAreSame`/`jitStaticsAreSame` are mostly called\nduring ILGen for checking if the symbol reference for a field\nhas already been created. We iterate through all existing symbol\nreferences of the corresponding type and determine if any existing\nsymref describes the current field.\nThis commit optimizes the process by prefetching info for all\nfields and statics in a method in one message.\n\n- Implement caching for `jitStaticsAreSame`\nand merges message hanlding code for fields and statics into one,\nsince they are funcionally identical.\n\n- Simplify client-side code for finding field data.\nnon-JITServer code doesn't look for field data if both fields are\nresolved and their value offsets are different. This is an optimization\nthat shouldn't affect functional correctness, so this commit always\nlooks for field data, because it improves caching and simplifies the\ncode.\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM5MTg2MzM4", "url": "https://github.com/eclipse-openj9/openj9/pull/10017#pullrequestreview-439186338", "createdAt": "2020-06-29T14:14:10Z", "commit": {"oid": "aa8eb2b0cc78fabe95402fe9dfa85dc66d46c552"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxNDoxNDoxMFrOGqS8PQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQyMDozNDo1NFrOGqhNMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAwMzcwOQ==", "bodyText": "comp()->getMethodBeingCompiled() has changed to _methodSymbol->getResolvedMethod() which I believe is more correct. Does the test on comp()->getMethodBeingCompiled() make sense anymore?", "url": "https://github.com/eclipse-openj9/openj9/pull/10017#discussion_r447003709", "createdAt": "2020-06-29T14:14:10Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -229,7 +229,11 @@ TR::Block * TR_J9ByteCodeIlGenerator::walker(TR::Block * prevBlock)\n       //\n       // NOTE: first request occurs in the switch statement over bytecodes,\n       // second request occurs in stashArgumentsForOSR\n-      static_cast<TR_ResolvedJ9JITServerMethod *>(comp()->getMethodBeingCompiled())->cacheResolvedMethodsCallees(2);\n+      static_cast<TR_ResolvedJ9JITServerMethod *>(_methodSymbol->getResolvedMethod())->cacheResolvedMethodsCallees(2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aa8eb2b0cc78fabe95402fe9dfa85dc66d46c552"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAwNTE4OA==", "bodyText": "Also, is walker called for inlined methods as well? I wonder if we do double duty with the code that prefeteches all resolved methods during estimateCallSize", "url": "https://github.com/eclipse-openj9/openj9/pull/10017#discussion_r447005188", "createdAt": "2020-06-29T14:16:00Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -229,7 +229,11 @@ TR::Block * TR_J9ByteCodeIlGenerator::walker(TR::Block * prevBlock)\n       //\n       // NOTE: first request occurs in the switch statement over bytecodes,\n       // second request occurs in stashArgumentsForOSR\n-      static_cast<TR_ResolvedJ9JITServerMethod *>(comp()->getMethodBeingCompiled())->cacheResolvedMethodsCallees(2);\n+      static_cast<TR_ResolvedJ9JITServerMethod *>(_methodSymbol->getResolvedMethod())->cacheResolvedMethodsCallees(2);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAwMzcwOQ=="}, "originalCommit": {"oid": "aa8eb2b0cc78fabe95402fe9dfa85dc66d46c552"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzEzNzM3Mw==", "bodyText": "Let's move  cpIndex, field and declaringClass down under if (isField) test", "url": "https://github.com/eclipse-openj9/openj9/pull/10017#discussion_r447137373", "createdAt": "2020-06-29T17:32:19Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/env/VMJ9Server.cpp", "diffHunk": "@@ -438,34 +467,63 @@ TR_J9ServerVM::cacheField(J9Class *ramClass, int32_t cpIndex, J9Class *declaring\n       }\n    }\n \n-bool\n-TR_J9ServerVM::jitStaticsAreSame(TR_ResolvedMethod *method1, I_32 cpIndex1, TR_ResolvedMethod *method2, I_32 cpIndex2)\n-   {\n-   JITServer::ServerStream *stream = _compInfoPT->getMethodBeingCompiled()->_stream;\n+void\n+TR_J9ServerVM::cacheFields(TR_ResolvedJ9Method *owningMethod)\n+   {\n+   // 1. Iterate through bytecodes and look for loads/stores\n+   // If the corresponding field or static is not cached, add it\n+   // to the list of fields that will be sent to the client in one batch.\n+   TR_J9ByteCodeIterator bci(0, owningMethod, this, _compInfoPT->getCompilation());\n+   std::vector<int32_t> cpIndices;\n+   std::vector<uint8_t> isStaticField;\n+   J9Class *ramClass = owningMethod->constantPoolHdr();\n+   for(TR_J9ByteCode bc = bci.first(); bc != J9BCunknown; bc = bci.next())\n+      {\n+      J9Class *declaringClass;\n+      UDATA field;\n+      int32_t cpIndex = bci.next2Bytes();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aa8eb2b0cc78fabe95402fe9dfa85dc66d46c552"}, "originalPosition": 176}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzE0OTgwOA==", "bodyText": "What is the sign that the field is unresolved? I am guessing field == 0 and declaringClass == NULL.\nWe could check these at the server and avoid caching them if needed.", "url": "https://github.com/eclipse-openj9/openj9/pull/10017#discussion_r447149808", "createdAt": "2020-06-29T17:54:14Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/control/JITClientCompilationThread.cpp", "diffHunk": "@@ -1152,6 +1093,31 @@ handleServerMessage(JITServer::ClientStream *client, TR_J9VM *fe, JITServer::Mes\n          client->write(response, fe->getObjectSizeClass(std::get<0>(recv)));\n          }\n          break;\n+      case MessageType::VM_getFields:\n+         {\n+         auto recv = client->getRecvData<TR_ResolvedJ9Method *, std::vector<int32_t>, std::vector<uint8_t>>();\n+         TR_ResolvedJ9Method *owningMethod = std::get<0>(recv);\n+         auto &cpIndices = std::get<1>(recv);\n+         auto &isStatic = std::get<2>(recv);\n+\n+         int32_t numFields = cpIndices.size();\n+         std::vector<J9Class *> declaringClasses;\n+         std::vector<UDATA> fields;\n+         declaringClasses.reserve(numFields);\n+         fields.reserve(numFields);\n+\n+         J9ConstantPool *cp = reinterpret_cast<J9ConstantPool *>(owningMethod->ramConstantPool());\n+         for (int32_t i = 0; i < numFields; ++i)\n+            {\n+            J9Class *declaringClass;\n+            // do we need to check if the field is resolved?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aa8eb2b0cc78fabe95402fe9dfa85dc66d46c552"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzIzMzAxNw==", "bodyText": "Maybe we should enter a critical section for this entire for loop ( OMR::CriticalSection getRemoteROMClass(_compInfoPT->getClientData()->getROMMapMonitor());)\nThe reason is, acquiring a monitor recursively (while have it) is faster than acquiring it from scratch.", "url": "https://github.com/eclipse-openj9/openj9/pull/10017#discussion_r447233017", "createdAt": "2020-06-29T20:26:42Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/env/VMJ9Server.cpp", "diffHunk": "@@ -438,34 +467,63 @@ TR_J9ServerVM::cacheField(J9Class *ramClass, int32_t cpIndex, J9Class *declaring\n       }\n    }\n \n-bool\n-TR_J9ServerVM::jitStaticsAreSame(TR_ResolvedMethod *method1, I_32 cpIndex1, TR_ResolvedMethod *method2, I_32 cpIndex2)\n-   {\n-   JITServer::ServerStream *stream = _compInfoPT->getMethodBeingCompiled()->_stream;\n+void\n+TR_J9ServerVM::cacheFields(TR_ResolvedJ9Method *owningMethod)\n+   {\n+   // 1. Iterate through bytecodes and look for loads/stores\n+   // If the corresponding field or static is not cached, add it\n+   // to the list of fields that will be sent to the client in one batch.\n+   TR_J9ByteCodeIterator bci(0, owningMethod, this, _compInfoPT->getCompilation());\n+   std::vector<int32_t> cpIndices;\n+   std::vector<uint8_t> isStaticField;\n+   J9Class *ramClass = owningMethod->constantPoolHdr();\n+   for(TR_J9ByteCode bc = bci.first(); bc != J9BCunknown; bc = bci.next())\n+      {\n+      J9Class *declaringClass;\n+      UDATA field;\n+      int32_t cpIndex = bci.next2Bytes();\n+      bool isField = false;\n+      bool isStatic;\n+      if (bc == J9BCgetfield || bc == J9BCputfield)\n+         {\n+         isField = true;\n+         isStatic = false;\n+         }\n+      else if (bc == J9BCgetstatic || bc == J9BCputstatic)\n+         {\n+         isField = true;\n+         isStatic = true;\n+         }\n+      if (isField && !getCachedField(ramClass, cpIndex, &declaringClass, &field))\n+         {\n+         cpIndices.push_back(cpIndex);\n+         isStaticField.push_back(isStatic);\n+         }\n+      }\n \n-   // Pass pointers to client mirrors of the ResolvedMethod objects instead of local objects\n-   TR_ResolvedJ9JITServerMethod *serverMethod1 = static_cast<TR_ResolvedJ9JITServerMethod*>(method1);\n-   TR_ResolvedJ9JITServerMethod *serverMethod2 = static_cast<TR_ResolvedJ9JITServerMethod*>(method2);\n-   TR_ResolvedMethod *clientMethod1 = serverMethod1->getRemoteMirror();\n-   TR_ResolvedMethod *clientMethod2 = serverMethod2->getRemoteMirror();\n+   // If there's just one field, it's faster to get it through regular means,\n+   // to avoid overhead of vectors\n+   int32_t numFields = cpIndices.size();\n+   if (numFields < 2)\n+      return;\n \n-   bool result = false;\n+   // 2. Send a message to get info for all fields\n+   JITServer::ServerStream *stream = _compInfoPT->getMethodBeingCompiled()->_stream;\n+   stream->write(\n+      JITServer::MessageType::VM_getFields,\n+      static_cast<TR_ResolvedJ9JITServerMethod *>(owningMethod)->getRemoteMirror(),\n+      cpIndices,\n+      isStaticField);\n+   auto recv = stream->read<std::vector<J9Class *>, std::vector<UDATA>>();\n \n-   bool sigSame = true;\n-   if (serverMethod1->staticsAreSame(cpIndex1, serverMethod2, cpIndex2, sigSame))\n+   // 3. Cache all received fields\n+   auto &declaringClasses = std::get<0>(recv);\n+   auto &fields = std::get<1>(recv);\n+   TR_ASSERT(numFields == declaringClasses.size(), \"Number of received fields does not match the requested number\");\n+   for (int32_t i = 0; i < numFields; ++i)\n       {\n-      result = true;\n+      cacheField(ramClass, cpIndices[i], declaringClasses[i], fields[i]);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aa8eb2b0cc78fabe95402fe9dfa85dc66d46c552"}, "originalPosition": 226}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzIzNzQyNA==", "bodyText": "I would prefer a logical and rather than a bit-wise and operator here:\nbool cached = getCachedField(ramClass1, cpIndex1, &declaringClass1, &field1) &&\n              getCachedField(ramClass2, cpIndex2, &declaringClass2, &field2);", "url": "https://github.com/eclipse-openj9/openj9/pull/10017#discussion_r447237424", "createdAt": "2020-06-29T20:34:54Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/env/VMJ9Server.cpp", "diffHunk": "@@ -343,20 +344,61 @@ TR_J9ServerVM::getSystemClassLoader()\n    }\n \n bool\n-TR_J9ServerVM::jitFieldsAreSame(TR_ResolvedMethod * method1, I_32 cpIndex1, TR_ResolvedMethod * method2, I_32 cpIndex2, int32_t isStatic)\n+TR_J9ServerVM::jitFieldsOrStaticsAreIdentical(TR_ResolvedMethod * method1, I_32 cpIndex1, TR_ResolvedMethod * method2, I_32 cpIndex2, int32_t isStatic)\n    {\n-   JITServer::ServerStream *stream = _compInfoPT->getMethodBeingCompiled()->_stream;\n-\n-   // Pass pointers to client mirrors of the ResolvedMethod objects instead of local objects\n-   TR_ResolvedJ9JITServerMethod *serverMethod1 = static_cast<TR_ResolvedJ9JITServerMethod*>(method1);\n-   TR_ResolvedJ9JITServerMethod *serverMethod2 = static_cast<TR_ResolvedJ9JITServerMethod*>(method2);\n-   TR_ResolvedMethod *clientMethod1 = serverMethod1->getRemoteMirror();\n-   TR_ResolvedMethod *clientMethod2 = serverMethod2->getRemoteMirror();\n+   auto serverMethod1 = static_cast<TR_ResolvedJ9JITServerMethod*>(method1);\n+   auto serverMethod2 = static_cast<TR_ResolvedJ9JITServerMethod*>(method2);\n+   J9Class *ramClass1 = serverMethod1->constantPoolHdr();\n+   J9Class *ramClass2 = serverMethod2->constantPoolHdr();\n+   UDATA field1 = 0, field2 = 0;\n+   J9Class *declaringClass1 = NULL, *declaringClass2 = NULL;\n \n    bool result = false;\n+   bool needRemoteCall = true;\n+   bool cached = getCachedField(ramClass1, cpIndex1, &declaringClass1, &field1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aa8eb2b0cc78fabe95402fe9dfa85dc66d46c552"}, "originalPosition": 31}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "aa8eb2b0cc78fabe95402fe9dfa85dc66d46c552", "author": {"user": {"login": "dmitry-ten", "name": "Dmitry Ten"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/aa8eb2b0cc78fabe95402fe9dfa85dc66d46c552", "committedDate": "2020-06-25T18:51:53Z", "message": "Group cache field and static info in JITServer\n\n- `TR_J9ServerVM::jitFieldsAreSame`/`jitStaticsAreSame` are mostly called\nduring ILGen for checking if the symbol reference for a field\nhas already been created. We iterate through all existing symbol\nreferences of the corresponding type and determine if any existing\nsymref describes the current field.\nThis commit optimizes the process by prefetching info for all\nfields and statics in a method in one message.\n\n- Implement caching for `jitStaticsAreSame`\nand merges message hanlding code for fields and statics into one,\nsince they are funcionally identical.\n\n- Simplify client-side code for finding field data.\nnon-JITServer code doesn't look for field data if both fields are\nresolved and their value offsets are different. This is an optimization\nthat shouldn't affect functional correctness, so this commit always\nlooks for field data, because it improves caching and simplifies the\ncode.\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>"}, "afterCommit": {"oid": "089954ef0033e6a31c8fff3dc752770f4a56d313", "author": {"user": {"login": "dmitry-ten", "name": "Dmitry Ten"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/089954ef0033e6a31c8fff3dc752770f4a56d313", "committedDate": "2020-06-30T16:43:03Z", "message": "Group cache field and static info in JITServer\n\n- `TR_J9ServerVM::jitFieldsAreSame`/`jitStaticsAreSame` are mostly called\nduring ILGen for checking if the symbol reference for a field\nhas already been created. We iterate through all existing symbol\nreferences of the corresponding type and determine if any existing\nsymref describes the current field.\nThis commit optimizes the process by prefetching info for all\nfields and statics in a method in one message.\n\n- Implement caching for `jitStaticsAreSame`\nand merges message hanlding code for fields and statics into one,\nsince they are funcionally identical.\n\n- Simplify client-side code for finding field data.\nnon-JITServer code doesn't look for field data if both fields are\nresolved and their value offsets are different. This is an optimization\nthat shouldn't affect functional correctness, so this commit always\nlooks for field data, because it improves caching and simplifies the\ncode.\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwMjAyMDAx", "url": "https://github.com/eclipse-openj9/openj9/pull/10017#pullrequestreview-440202001", "createdAt": "2020-06-30T16:44:42Z", "commit": {"oid": "089954ef0033e6a31c8fff3dc752770f4a56d313"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNjo0NDo0MlrOGrFWlg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNjo0NDo0MlrOGrFWlg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgyOTY1NA==", "bodyText": "I moved caching code out of the if statement, since if one field is resolved, while the other one isn't it still makes sense to cache the resolved one.", "url": "https://github.com/eclipse-openj9/openj9/pull/10017#discussion_r447829654", "createdAt": "2020-06-30T16:44:42Z", "author": {"login": "dmitry-ten"}, "path": "runtime/compiler/env/VMJ9Server.cpp", "diffHunk": "@@ -343,20 +344,62 @@ TR_J9ServerVM::getSystemClassLoader()\n    }\n \n bool\n-TR_J9ServerVM::jitFieldsAreSame(TR_ResolvedMethod * method1, I_32 cpIndex1, TR_ResolvedMethod * method2, I_32 cpIndex2, int32_t isStatic)\n+TR_J9ServerVM::jitFieldsOrStaticsAreIdentical(TR_ResolvedMethod * method1, I_32 cpIndex1, TR_ResolvedMethod * method2, I_32 cpIndex2, int32_t isStatic)\n    {\n-   JITServer::ServerStream *stream = _compInfoPT->getMethodBeingCompiled()->_stream;\n-\n-   // Pass pointers to client mirrors of the ResolvedMethod objects instead of local objects\n-   TR_ResolvedJ9JITServerMethod *serverMethod1 = static_cast<TR_ResolvedJ9JITServerMethod*>(method1);\n-   TR_ResolvedJ9JITServerMethod *serverMethod2 = static_cast<TR_ResolvedJ9JITServerMethod*>(method2);\n-   TR_ResolvedMethod *clientMethod1 = serverMethod1->getRemoteMirror();\n-   TR_ResolvedMethod *clientMethod2 = serverMethod2->getRemoteMirror();\n+   auto serverMethod1 = static_cast<TR_ResolvedJ9JITServerMethod*>(method1);\n+   auto serverMethod2 = static_cast<TR_ResolvedJ9JITServerMethod*>(method2);\n+   J9Class *ramClass1 = serverMethod1->constantPoolHdr();\n+   J9Class *ramClass2 = serverMethod2->constantPoolHdr();\n+   UDATA field1 = 0, field2 = 0;\n+   J9Class *declaringClass1 = NULL, *declaringClass2 = NULL;\n \n    bool result = false;\n+   bool needRemoteCall = true;\n+   bool cached =\n+      getCachedField(ramClass1, cpIndex1, &declaringClass1, &field1) &&\n+      getCachedField(ramClass2, cpIndex2, &declaringClass2, &field2);\n+   if (cached)\n+      {\n+      needRemoteCall = false;\n+      result = declaringClass1 == declaringClass2 && field1 == field2;\n+#if defined(DEBUG) || defined(PROD_WITH_ASSUMES)\n+      // validate cached result\n+      needRemoteCall = true;\n+#endif\n+      }\n+   if (needRemoteCall)\n+      {\n+      JITServer::ServerStream *stream = _compInfoPT->getMethodBeingCompiled()->_stream;\n+      // Pass pointers to client mirrors of the ResolvedMethod objects instead of local objects\n+      TR_ResolvedMethod *clientMethod1 = serverMethod1->getRemoteMirror();\n+      TR_ResolvedMethod *clientMethod2 = serverMethod2->getRemoteMirror();\n+\n+      stream->write(JITServer::MessageType::VM_jitFieldsOrStaticsAreSame, clientMethod1, cpIndex1, clientMethod2, cpIndex2, isStatic);\n+      auto recv = stream->read<J9Class *, J9Class *, UDATA, UDATA>();\n+      declaringClass1 = std::get<0>(recv);\n+      declaringClass2 = std::get<1>(recv);\n+      field1 = std::get<2>(recv);\n+      field2 = std::get<3>(recv);\n+      cacheField(ramClass1, cpIndex1, declaringClass1, field1);\n+      cacheField(ramClass2, cpIndex2, declaringClass2, field2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "089954ef0033e6a31c8fff3dc752770f4a56d313"}, "originalPosition": 57}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxNzk2MDQ4", "url": "https://github.com/eclipse-openj9/openj9/pull/10017#pullrequestreview-441796048", "createdAt": "2020-07-02T15:23:58Z", "commit": {"oid": "089954ef0033e6a31c8fff3dc752770f4a56d313"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNToyMzo1OFrOGsRtrg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxOTo0NzozMlrOGsbCAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA4MDc1MA==", "bodyText": "I just realized that the comments with the message number are going to be off after this change. To ease further changes like this I suggest we put comments only every 10 entries.", "url": "https://github.com/eclipse-openj9/openj9/pull/10017#discussion_r449080750", "createdAt": "2020-07-02T15:23:58Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/net/MessageTypes.hpp", "diffHunk": "@@ -387,8 +387,7 @@ static const char *messageNames[MessageType_ARRAYSIZE] =\n    \"VM_getLeafComponentClassFromArrayClass\", // 82\n    \"VM_isClassLoadedBySystemClassLoader\", // 83\n    \"VM_getClassFromSignature\", // 84\n-   \"VM_jitFieldsAreSame\", // 85\n-   \"VM_jitStaticsAreSame\", // 86\n+   \"VM_jitFieldsOrStaticsAreSame\", // 85", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "089954ef0033e6a31c8fff3dc752770f4a56d313"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA5ODM5NQ==", "bodyText": "I looked at the possibility to calling walker several times for the same method which would result in several calls to cacheFields(). I see it called once as walker(0) during genILFromBytecodes() and another time as walker(lastBlock) from getExceptionHandlers(). At the very least I think we need to block the second attempt by checking that the parameter to walker is 0.", "url": "https://github.com/eclipse-openj9/openj9/pull/10017#discussion_r449098395", "createdAt": "2020-07-02T15:39:32Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -220,7 +220,7 @@ TR::Block * TR_J9ByteCodeIlGenerator::walker(TR::Block * prevBlock)\n \n \n #if defined(J9VM_OPT_JITSERVER)\n-   if (comp()->isOutOfProcessCompilation() && comp()->getMethodBeingCompiled())\n+   if (comp()->isOutOfProcessCompilation() && _methodSymbol->getResolvedMethod())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "089954ef0033e6a31c8fff3dc752770f4a56d313"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIyNDA4Nw==", "bodyText": "I see that we only send remote requests for fields that are not cached, so there is no additional burden at the client unless the field is unresolved and we ask again.\nThere is also the code that walks the bytecodes at the server and checks whether the fields are cached. Ideally we would not repeat these calls if possible.", "url": "https://github.com/eclipse-openj9/openj9/pull/10017#discussion_r449224087", "createdAt": "2020-07-02T19:25:38Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -220,7 +220,7 @@ TR::Block * TR_J9ByteCodeIlGenerator::walker(TR::Block * prevBlock)\n \n \n #if defined(J9VM_OPT_JITSERVER)\n-   if (comp()->isOutOfProcessCompilation() && comp()->getMethodBeingCompiled())\n+   if (comp()->isOutOfProcessCompilation() && _methodSymbol->getResolvedMethod())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA5ODM5NQ=="}, "originalCommit": {"oid": "089954ef0033e6a31c8fff3dc752770f4a56d313"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIzMzQxMA==", "bodyText": "This delegates to the frontend implementation. Can we move the implementation from TR_J9ServerVM into this method so that we eliminate one level of indirection?", "url": "https://github.com/eclipse-openj9/openj9/pull/10017#discussion_r449233410", "createdAt": "2020-07-02T19:47:32Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/env/j9methodServer.cpp", "diffHunk": "@@ -1891,6 +1891,12 @@ TR_ResolvedJ9JITServerMethod::cacheResolvedMethodsCallees(int32_t ttlForUnresolv\n       }\n    }\n \n+void\n+TR_ResolvedJ9JITServerMethod::cacheFields()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "089954ef0033e6a31c8fff3dc752770f4a56d313"}, "originalPosition": 5}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9c474c3e170f164ce71283bdfc884412d99ddf9b", "author": {"user": {"login": "dmitry-ten", "name": "Dmitry Ten"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/9c474c3e170f164ce71283bdfc884412d99ddf9b", "committedDate": "2020-07-03T15:57:39Z", "message": "Group cache field and static info in JITServer\n\n- `TR_J9ServerVM::jitFieldsAreSame`/`jitStaticsAreSame` are mostly called\nduring ILGen for checking if the symbol reference for a field\nhas already been created. We iterate through all existing symbol\nreferences of the corresponding type and determine if any existing\nsymref describes the current field.\nThis commit optimizes the process by prefetching info for all\nfields and statics in a method in one message.\n\n- Implement caching for `jitStaticsAreSame`\nand merges message hanlding code for fields and statics into one,\nsince they are funcionally identical.\n\n- Simplify client-side code for finding field data.\nnon-JITServer code doesn't look for field data if both fields are\nresolved and their value offsets are different. This is an optimization\nthat shouldn't affect functional correctness, so this commit always\nlooks for field data, because it improves caching and simplifies the\ncode.\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "089954ef0033e6a31c8fff3dc752770f4a56d313", "author": {"user": {"login": "dmitry-ten", "name": "Dmitry Ten"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/089954ef0033e6a31c8fff3dc752770f4a56d313", "committedDate": "2020-06-30T16:43:03Z", "message": "Group cache field and static info in JITServer\n\n- `TR_J9ServerVM::jitFieldsAreSame`/`jitStaticsAreSame` are mostly called\nduring ILGen for checking if the symbol reference for a field\nhas already been created. We iterate through all existing symbol\nreferences of the corresponding type and determine if any existing\nsymref describes the current field.\nThis commit optimizes the process by prefetching info for all\nfields and statics in a method in one message.\n\n- Implement caching for `jitStaticsAreSame`\nand merges message hanlding code for fields and statics into one,\nsince they are funcionally identical.\n\n- Simplify client-side code for finding field data.\nnon-JITServer code doesn't look for field data if both fields are\nresolved and their value offsets are different. This is an optimization\nthat shouldn't affect functional correctness, so this commit always\nlooks for field data, because it improves caching and simplifies the\ncode.\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>"}, "afterCommit": {"oid": "9c474c3e170f164ce71283bdfc884412d99ddf9b", "author": {"user": {"login": "dmitry-ten", "name": "Dmitry Ten"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/9c474c3e170f164ce71283bdfc884412d99ddf9b", "committedDate": "2020-07-03T15:57:39Z", "message": "Group cache field and static info in JITServer\n\n- `TR_J9ServerVM::jitFieldsAreSame`/`jitStaticsAreSame` are mostly called\nduring ILGen for checking if the symbol reference for a field\nhas already been created. We iterate through all existing symbol\nreferences of the corresponding type and determine if any existing\nsymref describes the current field.\nThis commit optimizes the process by prefetching info for all\nfields and statics in a method in one message.\n\n- Implement caching for `jitStaticsAreSame`\nand merges message hanlding code for fields and statics into one,\nsince they are funcionally identical.\n\n- Simplify client-side code for finding field data.\nnon-JITServer code doesn't look for field data if both fields are\nresolved and their value offsets are different. This is an optimization\nthat shouldn't affect functional correctness, so this commit always\nlooks for field data, because it improves caching and simplifies the\ncode.\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQzMzM1MjI2", "url": "https://github.com/eclipse-openj9/openj9/pull/10017#pullrequestreview-443335226", "createdAt": "2020-07-06T19:02:23Z", "commit": {"oid": "9c474c3e170f164ce71283bdfc884412d99ddf9b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2ff58c6e34530b7968ab660674f2aecc1ae1df69", "author": {"user": {"login": "dmitry-ten", "name": "Dmitry Ten"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/2ff58c6e34530b7968ab660674f2aecc1ae1df69", "committedDate": "2020-07-06T19:21:35Z", "message": "Coalesce messages in interprocedural analyzer\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>"}, "afterCommit": {"oid": "9c474c3e170f164ce71283bdfc884412d99ddf9b", "author": {"user": {"login": "dmitry-ten", "name": "Dmitry Ten"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/9c474c3e170f164ce71283bdfc884412d99ddf9b", "committedDate": "2020-07-03T15:57:39Z", "message": "Group cache field and static info in JITServer\n\n- `TR_J9ServerVM::jitFieldsAreSame`/`jitStaticsAreSame` are mostly called\nduring ILGen for checking if the symbol reference for a field\nhas already been created. We iterate through all existing symbol\nreferences of the corresponding type and determine if any existing\nsymref describes the current field.\nThis commit optimizes the process by prefetching info for all\nfields and statics in a method in one message.\n\n- Implement caching for `jitStaticsAreSame`\nand merges message hanlding code for fields and statics into one,\nsince they are funcionally identical.\n\n- Simplify client-side code for finding field data.\nnon-JITServer code doesn't look for field data if both fields are\nresolved and their value offsets are different. This is an optimization\nthat shouldn't affect functional correctness, so this commit always\nlooks for field data, because it improves caching and simplifies the\ncode.\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 450, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}