{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk4MDY0MzY4", "number": 10788, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQyMDo1MDo0OVrOEqej0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxNDoxMjowNFrOErokuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyOTc2MzM2OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/compile/J9SymbolReferenceTable.cpp", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQyMDo1MDo0OVrOHctU7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QyMzo1NDoxNlrOHeJeLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg2NDgxMg==", "bodyText": "This is going to need a different name - in the compiler a temp slot is a stack allocated variable - this usage will be very confusing. I would suggest findOrCreateVMThreadTempSlotSymbolRef or something explicit like that.", "url": "https://github.com/eclipse-openj9/openj9/pull/10788#discussion_r499864812", "createdAt": "2020-10-05T20:50:49Z", "author": {"login": "andrewcraik"}, "path": "runtime/compiler/compile/J9SymbolReferenceTable.cpp", "diffHunk": "@@ -2322,6 +2322,20 @@ J9::SymbolReferenceTable::findOrCreateProfilingBufferEndSymbolRef()\n    return element(profilingBufferEndSymbol);\n    }\n \n+TR::SymbolReference *\n+J9::SymbolReferenceTable::findOrCreateTempSlotSymbolRef()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b666e299d6199c9045a209b374435c7908e48cde"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg2NDk3Mw==", "bodyText": "Please add doxygen for what this is", "url": "https://github.com/eclipse-openj9/openj9/pull/10788#discussion_r499864973", "createdAt": "2020-10-05T20:51:09Z", "author": {"login": "andrewcraik"}, "path": "runtime/compiler/compile/J9SymbolReferenceTable.cpp", "diffHunk": "@@ -2322,6 +2322,20 @@ J9::SymbolReferenceTable::findOrCreateProfilingBufferEndSymbolRef()\n    return element(profilingBufferEndSymbol);\n    }\n \n+TR::SymbolReference *\n+J9::SymbolReferenceTable::findOrCreateTempSlotSymbolRef()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg2NDgxMg=="}, "originalCommit": {"oid": "b666e299d6199c9045a209b374435c7908e48cde"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTM3NDUxMA==", "bodyText": "Addressed your suggestions.", "url": "https://github.com/eclipse-openj9/openj9/pull/10788#discussion_r501374510", "createdAt": "2020-10-07T23:54:16Z", "author": {"login": "nbhuiyan"}, "path": "runtime/compiler/compile/J9SymbolReferenceTable.cpp", "diffHunk": "@@ -2322,6 +2322,20 @@ J9::SymbolReferenceTable::findOrCreateProfilingBufferEndSymbolRef()\n    return element(profilingBufferEndSymbol);\n    }\n \n+TR::SymbolReference *\n+J9::SymbolReferenceTable::findOrCreateTempSlotSymbolRef()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg2NDgxMg=="}, "originalCommit": {"oid": "b666e299d6199c9045a209b374435c7908e48cde"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyOTc2NjM3OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/compile/J9SymbolReferenceTable.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQyMDo1MTo0OVrOHctWxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QyMzo1NTowM1rOHeJfIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg2NTI4NQ==", "bodyText": "This label is also potentially confusing in the lop with the other occurrences of temp slot - I think some thought needs to go into changing this to make it less confusing.", "url": "https://github.com/eclipse-openj9/openj9/pull/10788#discussion_r499865285", "createdAt": "2020-10-05T20:51:49Z", "author": {"login": "andrewcraik"}, "path": "runtime/compiler/compile/J9SymbolReferenceTable.cpp", "diffHunk": "@@ -2322,6 +2322,20 @@ J9::SymbolReferenceTable::findOrCreateProfilingBufferEndSymbolRef()\n    return element(profilingBufferEndSymbol);\n    }\n \n+TR::SymbolReference *\n+J9::SymbolReferenceTable::findOrCreateTempSlotSymbolRef()\n+   {\n+   if (!element(tempSlotSymbol))\n+      {\n+      TR_J9VMBase *fej9 = (TR_J9VMBase *)(fe());\n+      TR::Symbol * sym = TR::RegisterMappedSymbol::createMethodMetaDataSymbol(trHeapMemory(), \"tempSlot\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b666e299d6199c9045a209b374435c7908e48cde"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTM3NDc1NQ==", "bodyText": "Changed the label to something more explicit.", "url": "https://github.com/eclipse-openj9/openj9/pull/10788#discussion_r501374755", "createdAt": "2020-10-07T23:55:03Z", "author": {"login": "nbhuiyan"}, "path": "runtime/compiler/compile/J9SymbolReferenceTable.cpp", "diffHunk": "@@ -2322,6 +2322,20 @@ J9::SymbolReferenceTable::findOrCreateProfilingBufferEndSymbolRef()\n    return element(profilingBufferEndSymbol);\n    }\n \n+TR::SymbolReference *\n+J9::SymbolReferenceTable::findOrCreateTempSlotSymbolRef()\n+   {\n+   if (!element(tempSlotSymbol))\n+      {\n+      TR_J9VMBase *fej9 = (TR_J9VMBase *)(fe());\n+      TR::Symbol * sym = TR::RegisterMappedSymbol::createMethodMetaDataSymbol(trHeapMemory(), \"tempSlot\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg2NTI4NQ=="}, "originalCommit": {"oid": "b666e299d6199c9045a209b374435c7908e48cde"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyOTc4MzYwOnYy", "diffSide": "RIGHT", "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQyMDo1NzoxNFrOHcthqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxNDowMzoyNFrOHegMgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg2ODA3Mg==", "bodyText": "I assume code later will clean up the call?", "url": "https://github.com/eclipse-openj9/openj9/pull/10788#discussion_r499868072", "createdAt": "2020-10-05T20:57:14Z", "author": {"login": "andrewcraik"}, "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -1013,6 +1013,16 @@ J9::CodeGenerator::lowerTreeIfNeeded(\n       self()->lowerNonhelperCallIfNeeded(node, tt);\n       }\n \n+   if (node->getOpCode().isCall() &&\n+       !node->getSymbol()->castToMethodSymbol()->isHelper() &&\n+       (node->getSymbol()->castToMethodSymbol()->getRecognizedMethod() == TR::java_lang_invoke_MethodHandle_invokeBasic))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b666e299d6199c9045a209b374435c7908e48cde"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTM3NDI1OA==", "bodyText": "I am not sure what you mean by this comment. Please explain what you were expecting the later code to do.", "url": "https://github.com/eclipse-openj9/openj9/pull/10788#discussion_r501374258", "createdAt": "2020-10-07T23:53:15Z", "author": {"login": "nbhuiyan"}, "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -1013,6 +1013,16 @@ J9::CodeGenerator::lowerTreeIfNeeded(\n       self()->lowerNonhelperCallIfNeeded(node, tt);\n       }\n \n+   if (node->getOpCode().isCall() &&\n+       !node->getSymbol()->castToMethodSymbol()->isHelper() &&\n+       (node->getSymbol()->castToMethodSymbol()->getRecognizedMethod() == TR::java_lang_invoke_MethodHandle_invokeBasic))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg2ODA3Mg=="}, "originalCommit": {"oid": "b666e299d6199c9045a209b374435c7908e48cde"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc0NjgxNg==", "bodyText": "@andrewcraik The call will remain in the tree, codegen will generate instructions for it. It's just that we need to store additional information to J9VMThread, hence this PR", "url": "https://github.com/eclipse-openj9/openj9/pull/10788#discussion_r501746816", "createdAt": "2020-10-08T14:03:24Z", "author": {"login": "liqunl"}, "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -1013,6 +1013,16 @@ J9::CodeGenerator::lowerTreeIfNeeded(\n       self()->lowerNonhelperCallIfNeeded(node, tt);\n       }\n \n+   if (node->getOpCode().isCall() &&\n+       !node->getSymbol()->castToMethodSymbol()->isHelper() &&\n+       (node->getSymbol()->castToMethodSymbol()->getRecognizedMethod() == TR::java_lang_invoke_MethodHandle_invokeBasic))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg2ODA3Mg=="}, "originalCommit": {"oid": "b666e299d6199c9045a209b374435c7908e48cde"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0MTg3NjU1OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxNDowOToyNFrOHegeZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxNjoyMjoyOFrOHemfTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc1MTM5OQ==", "bodyText": "We should call createStore(TR::Node *originatingByteCodeNode, TR::SymbolReference * symRef, TR::Node * value) and pass in the call node as the originatingByteCodeNode such that the store node gets the right bytecode index.", "url": "https://github.com/eclipse-openj9/openj9/pull/10788#discussion_r501751399", "createdAt": "2020-10-08T14:09:24Z", "author": {"login": "liqunl"}, "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -1013,6 +1013,16 @@ J9::CodeGenerator::lowerTreeIfNeeded(\n       self()->lowerNonhelperCallIfNeeded(node, tt);\n       }\n \n+   if (node->getOpCode().isCall() &&\n+       !node->getSymbol()->castToMethodSymbol()->isHelper() &&\n+       (node->getSymbol()->castToMethodSymbol()->getRecognizedMethod() == TR::java_lang_invoke_MethodHandle_invokeBasic))\n+      {\n+      TR::SymbolReference *vmThreadTempSlotSymRef = self()->comp()->getSymRefTab()->findOrCreateVMThreadTempSlotSymbolRef();\n+      TR::Node *numArgsNode = TR::Node::iconst(node, node->getNumArguments() - 1);\n+      TR::Node *storeNode = TR::Node::createStore(vmThreadTempSlotSymRef, numArgsNode, TR::istore);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e782c5fd9f78c62a730f4afb59f46959fd4cfbe7"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTg0OTkzMw==", "bodyText": "There is no API for creating store that allows me to specify the opcode as well as the originating bytecode. Without explicitly specifying TR::istore, we end up with TR::astore. As a workaround for setting the bytecode index, I've added the following line:\nstoreNode->setByteCodeIndex(node->getByteCodeIndex());", "url": "https://github.com/eclipse-openj9/openj9/pull/10788#discussion_r501849933", "createdAt": "2020-10-08T16:22:28Z", "author": {"login": "nbhuiyan"}, "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -1013,6 +1013,16 @@ J9::CodeGenerator::lowerTreeIfNeeded(\n       self()->lowerNonhelperCallIfNeeded(node, tt);\n       }\n \n+   if (node->getOpCode().isCall() &&\n+       !node->getSymbol()->castToMethodSymbol()->isHelper() &&\n+       (node->getSymbol()->castToMethodSymbol()->getRecognizedMethod() == TR::java_lang_invoke_MethodHandle_invokeBasic))\n+      {\n+      TR::SymbolReference *vmThreadTempSlotSymRef = self()->comp()->getSymRefTab()->findOrCreateVMThreadTempSlotSymbolRef();\n+      TR::Node *numArgsNode = TR::Node::iconst(node, node->getNumArguments() - 1);\n+      TR::Node *storeNode = TR::Node::createStore(vmThreadTempSlotSymRef, numArgsNode, TR::istore);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc1MTM5OQ=="}, "originalCommit": {"oid": "e782c5fd9f78c62a730f4afb59f46959fd4cfbe7"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0MTg4OTg1OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/compile/J9SymbolReferenceTable.hpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxNDoxMjowNFrOHegmfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxNjoyMjozN1rOHemfoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc1MzQ2OA==", "bodyText": "Can the name be updated to findOrCreateVMThreadTempSlotFieldSymbolRef?", "url": "https://github.com/eclipse-openj9/openj9/pull/10788#discussion_r501753468", "createdAt": "2020-10-08T14:12:04Z", "author": {"login": "liqunl"}, "path": "runtime/compiler/compile/J9SymbolReferenceTable.hpp", "diffHunk": "@@ -76,6 +76,15 @@ class SymbolReferenceTable : public OMR::SymbolReferenceTableConnector\n    TR::SymbolReference * findOrCreateOSRScratchBufferSymbolRef();\n    TR::SymbolReference * findOrCreateOSRFrameIndexSymbolRef();\n \n+   /** \\brief\n+    * Find or create VMThread tempSlot symbol reference. J9VMThread.tempSlot provides a mechanism for the\n+    * compiler to provide information that the VM can use for various reasons - such as locating items on\n+    * the stack during a call to internal native methods that are signature-polymorphic.\n+    *\n+    * \\return TR::SymbolReference* the VMThreadTempSlotField symbol reference\n+    */\n+   TR::SymbolReference * findOrCreateVMThreadTempSlotSymbolRef();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e782c5fd9f78c62a730f4afb59f46959fd4cfbe7"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTg1MDAxNg==", "bodyText": "Done.", "url": "https://github.com/eclipse-openj9/openj9/pull/10788#discussion_r501850016", "createdAt": "2020-10-08T16:22:37Z", "author": {"login": "nbhuiyan"}, "path": "runtime/compiler/compile/J9SymbolReferenceTable.hpp", "diffHunk": "@@ -76,6 +76,15 @@ class SymbolReferenceTable : public OMR::SymbolReferenceTableConnector\n    TR::SymbolReference * findOrCreateOSRScratchBufferSymbolRef();\n    TR::SymbolReference * findOrCreateOSRFrameIndexSymbolRef();\n \n+   /** \\brief\n+    * Find or create VMThread tempSlot symbol reference. J9VMThread.tempSlot provides a mechanism for the\n+    * compiler to provide information that the VM can use for various reasons - such as locating items on\n+    * the stack during a call to internal native methods that are signature-polymorphic.\n+    *\n+    * \\return TR::SymbolReference* the VMThreadTempSlotField symbol reference\n+    */\n+   TR::SymbolReference * findOrCreateVMThreadTempSlotSymbolRef();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc1MzQ2OA=="}, "originalCommit": {"oid": "e782c5fd9f78c62a730f4afb59f46959fd4cfbe7"}, "originalPosition": 11}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1286, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}