{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA3OTk0MzIy", "number": 9341, "title": "Java 14: track interrupt state when thread is dead", "bodyText": "Fixes: #8916\n\nA new private boolean is added to java.lang.Thread to track the interrupt state since a J9VMThread only exists when the thread is actually running. When a thread is started the interrupt state will be transferred from the deadInterrupt boolean to the J9VMThread and tracked in the vm. When the thread is cleaned up, the interrupt state will be transferred back to be tracked by the deadInterrupt boolean.\nUpdate formatting for Java14AndUp test playlist\n\nSigned-off-by: Theresa Mammarella Theresa.T.Mammarella@ibm.com", "createdAt": "2020-04-23T15:20:35Z", "url": "https://github.com/eclipse-openj9/openj9/pull/9341", "merged": true, "mergeCommit": {"oid": "29f42b10045aece4f55bcdc74015ffb81a5a669f"}, "closed": true, "closedAt": "2020-05-08T15:12:59Z", "author": {"login": "theresa-m"}, "timelineItems": {"totalCount": 22, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcaelkZABqjMyNjU1MzM4Njc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcfTKSXAFqTQwODI5OTMzNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "82bd4c06239cfd75df0ea6bc5e316e39d2118a7c", "author": {"user": {"login": "theresa-m", "name": "Theresa Mammarella"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/82bd4c06239cfd75df0ea6bc5e316e39d2118a7c", "committedDate": "2020-04-22T22:35:14Z", "message": "Java 14: track interrupt state when thread is dead\n\nA new private boolean is added to java.lang.Thread to track the interrupt state since a J9VMThread only exists when the thread is actually running. When a thread is started the interrupt state will be transferred from the deadInterrupt boolean to the J9VMThread and tracked in the vm. When the thread is cleaned up, the interrupt state will be transferred back to be tracked by the deadInterrupt boolean.\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>"}, "afterCommit": {"oid": "d0f53a8c489079fd059b1e92d3d5ada006aa4753", "author": {"user": {"login": "theresa-m", "name": "Theresa Mammarella"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/d0f53a8c489079fd059b1e92d3d5ada006aa4753", "committedDate": "2020-04-23T15:26:05Z", "message": "Java 14: track interrupt state when thread is dead\n\nA new private boolean is added to java.lang.Thread to track the interrupt state since a J9VMThread only exists when the thread is actually running. When a thread is started the interrupt state will be transferred from the deadInterrupt boolean to the J9VMThread and tracked in the vm. When the thread is cleaned up, the interrupt state will be transferred back to be tracked by the deadInterrupt boolean.\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk5Mjg1OTMx", "url": "https://github.com/eclipse-openj9/openj9/pull/9341#pullrequestreview-399285931", "createdAt": "2020-04-23T16:45:08Z", "commit": {"oid": "d0f53a8c489079fd059b1e92d3d5ada006aa4753"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxNjo0NTowOFrOGKx5DA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxNjo0NTowOFrOGKx5DA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk1NjM2NA==", "bodyText": "Why bother introducing this variable at all in versions < 14? In the vmconstantpool.xml the versions can be specified via versions=\"14-\". Similarly the VM code can use #if JAVA_SPEC_VERSION >= 14", "url": "https://github.com/eclipse-openj9/openj9/pull/9341#discussion_r413956364", "createdAt": "2020-04-23T16:45:08Z", "author": {"login": "pshipton"}, "path": "jcl/src/java.base/share/classes/java/lang/Thread.java", "diffHunk": "@@ -80,6 +80,13 @@\n \t// Instance variables\n \tprivate long threadRef;\t\t\t\t\t\t\t\t\t// Used by the VM\n \tlong stackSize = 0;\n+    /* For Java 14+:\n+     * deadInterrupt tracks the thread interrupt state when threadRef has no reference (ie thread is not alive). \n+     * Note that this value need not be updated while the thread is running since the interrupt state will be \n+     * tracked by the vm during that time. Because of this the value should not be used over calling\n+     *  isInterrupted() or interrupted().\n+     */\n+\tprivate volatile boolean deadInterrupt;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0f53a8c489079fd059b1e92d3d5ada006aa4753"}, "originalPosition": 19}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk5Mjg2NDc0", "url": "https://github.com/eclipse-openj9/openj9/pull/9341#pullrequestreview-399286474", "createdAt": "2020-04-23T16:45:46Z", "commit": {"oid": "d0f53a8c489079fd059b1e92d3d5ada006aa4753"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxNjo0NTo0NlrOGKx62A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxNjo0NTo0NlrOGKx62A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk1NjgyNA==", "bodyText": "Pls use the preprocessor to only include this in Java 14+. Similarly for isInterrupted().", "url": "https://github.com/eclipse-openj9/openj9/pull/9341#discussion_r413956824", "createdAt": "2020-04-23T16:45:46Z", "author": {"login": "pshipton"}, "path": "jcl/src/java.base/share/classes/java/lang/Thread.java", "diffHunk": "@@ -677,6 +684,8 @@ public final ThreadGroup getThreadGroup() {\n \n /**\n  * Posts an interrupt request to the receiver\n+ * \n+ * From Java 14, the interrupt state for threads that are not alive is tracked.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0f53a8c489079fd059b1e92d3d5ada006aa4753"}, "originalPosition": 28}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "02bf93478b955a9d116a6352a33dea3b8338bcb5", "author": {"user": {"login": "theresa-m", "name": "Theresa Mammarella"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/02bf93478b955a9d116a6352a33dea3b8338bcb5", "committedDate": "2020-04-24T18:31:49Z", "message": "formatting"}, "afterCommit": {"oid": "c1d3d5fbe89f6aa609a2a12975941f0d9a0781e8", "author": {"user": {"login": "theresa-m", "name": "Theresa Mammarella"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/c1d3d5fbe89f6aa609a2a12975941f0d9a0781e8", "committedDate": "2020-04-24T18:47:52Z", "message": "Java 14: track interrupt state when thread is dead\n\nA new private boolean is added to java.lang.Thread to track the interrupt state since a J9VMThread only exists when the thread is actually running. When a thread is started the interrupt state will be transferred from the deadInterrupt boolean to the J9VMThread and tracked in the vm. When the thread is cleaned up, the interrupt state will be transferred back to be tracked by the deadInterrupt boolean.\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwMjM2Mjkx", "url": "https://github.com/eclipse-openj9/openj9/pull/9341#pullrequestreview-400236291", "createdAt": "2020-04-24T20:04:35Z", "commit": {"oid": "c1d3d5fbe89f6aa609a2a12975941f0d9a0781e8"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQyMDowNDozNVrOGLnTIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQyMDoyOTo0MlrOGLoGJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgzMTM5NA==", "bodyText": "The indenting is off in the new section. Using spaces instead of tabs like the surrounding code.", "url": "https://github.com/eclipse-openj9/openj9/pull/9341#discussion_r414831394", "createdAt": "2020-04-24T20:04:35Z", "author": {"login": "pshipton"}, "path": "jcl/src/java.base/share/classes/java/lang/Thread.java", "diffHunk": "@@ -79,7 +79,15 @@\n \n \t// Instance variables\n \tprivate long threadRef;\t\t\t\t\t\t\t\t\t// Used by the VM\n-\tlong stackSize = 0;\n+    long stackSize = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1d3d5fbe89f6aa609a2a12975941f0d9a0781e8"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgzNDI1Ng==", "bodyText": "Is the whitespace change for Jep359Tests intentional?", "url": "https://github.com/eclipse-openj9/openj9/pull/9341#discussion_r414834256", "createdAt": "2020-04-24T20:10:09Z", "author": {"login": "pshipton"}, "path": "test/functional/Java14andUp/playlist.xml", "diffHunk": "@@ -23,28 +23,51 @@\n -->\n \n <playlist xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation=\"../../TestConfig/playlist.xsd\">\n-      <test>\n-          <testCaseName>Jep359Tests</testCaseName>\n-          <variations>\n-                  <variation>NoOptions</variation>\n-          </variations>\n-          <command>$(JAVA_COMMAND) $(JVM_OPTIONS) \\\n-                  --enable-preview \\\n-                  -cp $(Q)$(LIB_DIR)$(D)asm-7.3.jar$(P)$(RESOURCES_DIR)$(P)$(TESTNG)$(P)$(TEST_RESROOT)$(D)GeneralTest.jar$(Q) \\\n-                  org.testng.TestNG -d $(REPORTDIR) $(Q)$(TEST_RESROOT)$(D)testng.xml$(Q) -testnames Jep359Tests \\\n-                  -groups $(TEST_GROUP) \\\n-                  -excludegroups $(DEFAULT_EXCLUDE); \\\n-                  $(TEST_STATUS)\n-          </command>\n-          <levels>\n-                  <level>sanity</level>\n-          </levels>\n-          <groups>\n-                  <group>functional</group>\n-          </groups>\n-          <!-- Run for Java 14 only since this is a preview feature. -->\n-          <subsets>\n-                  <subset>14</subset>\n-          </subsets>\n-        </test>\n+    <test>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1d3d5fbe89f6aa609a2a12975941f0d9a0781e8"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgzNDkwNQ==", "bodyText": "This test should be just rolled into test_interruptAtStartSetAfterRun()", "url": "https://github.com/eclipse-openj9/openj9/pull/9341#discussion_r414834905", "createdAt": "2020-04-24T20:11:26Z", "author": {"login": "pshipton"}, "path": "test/functional/Java14andUp/src/org/openj9/test/java/lang/Test_Thread.java", "diffHunk": "@@ -0,0 +1,203 @@\n+package org.openj9.test.java.lang;\n+\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+import org.testng.annotations.Test;\n+import org.testng.AssertJUnit;\n+\n+/**\n+ * This test is to verify matching behavior to the RI from the following implementation change\n+ * discussed in the Java 14 release notes:\n+ * \n+ * \"The specification for java.lang.Thread::interrupt allows for an implementation to only track the \n+ * interrupt state for live threads, and previously this is what occurred. As of this release, the \n+ * interrupt state of a Thread is always available, and if you interrupt a thread t before it is started, \n+ * or after it has terminated, the query t.isInterrupted() will return true.\"\n+ */\n+\n+@Test(groups = { \"level.sanity\" })\n+public class Test_Thread {\n+\n+    /* interrupt thread before it has started */\n+    @Test\n+    public void test_interruptBeforeRun() {\n+        String name = \"interruptBeforeRun: \";\n+        Thread t = new Thread();\n+\n+        /* Verify thread is dead and has not been interrupted */\n+        AssertJUnit.assertFalse(name + \"thread should not be alive\", t.isAlive());\n+        AssertJUnit.assertFalse(name + \"interrupt flag should not be set\", t.isInterrupted());\n+\n+        t.interrupt();\n+\n+        /* Verify that the thread was successfully interrupted. */\n+        AssertJUnit.assertTrue(name + \"thread that has not started should have interrupt flag set\", t.isInterrupted());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1d3d5fbe89f6aa609a2a12975941f0d9a0781e8"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgzNzUwMQ==", "bodyText": "Pls set a volatile boolean field here, and test it after join(). Similarly in the next test.", "url": "https://github.com/eclipse-openj9/openj9/pull/9341#discussion_r414837501", "createdAt": "2020-04-24T20:16:27Z", "author": {"login": "pshipton"}, "path": "test/functional/Java14andUp/src/org/openj9/test/java/lang/Test_Thread.java", "diffHunk": "@@ -0,0 +1,203 @@\n+package org.openj9.test.java.lang;\n+\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+import org.testng.annotations.Test;\n+import org.testng.AssertJUnit;\n+\n+/**\n+ * This test is to verify matching behavior to the RI from the following implementation change\n+ * discussed in the Java 14 release notes:\n+ * \n+ * \"The specification for java.lang.Thread::interrupt allows for an implementation to only track the \n+ * interrupt state for live threads, and previously this is what occurred. As of this release, the \n+ * interrupt state of a Thread is always available, and if you interrupt a thread t before it is started, \n+ * or after it has terminated, the query t.isInterrupted() will return true.\"\n+ */\n+\n+@Test(groups = { \"level.sanity\" })\n+public class Test_Thread {\n+\n+    /* interrupt thread before it has started */\n+    @Test\n+    public void test_interruptBeforeRun() {\n+        String name = \"interruptBeforeRun: \";\n+        Thread t = new Thread();\n+\n+        /* Verify thread is dead and has not been interrupted */\n+        AssertJUnit.assertFalse(name + \"thread should not be alive\", t.isAlive());\n+        AssertJUnit.assertFalse(name + \"interrupt flag should not be set\", t.isInterrupted());\n+\n+        t.interrupt();\n+\n+        /* Verify that the thread was successfully interrupted. */\n+        AssertJUnit.assertTrue(name + \"thread that has not started should have interrupt flag set\", t.isInterrupted());\n+    }\n+\n+    /* interrupt thread after it has ended */\n+    @Test\n+    public void test_interruptAfterRun() throws Throwable {\n+        String name = \"interruptAfterRun: \";\n+        Thread t = new Thread();\n+\n+        /* run thread */\n+        t.start();\n+        t.join();\n+\n+        /* Verify thread is dead and has not been interrupted */\n+        AssertJUnit.assertFalse(name + \"thread should not be alive\", t.isAlive());\n+        AssertJUnit.assertFalse(name + \"interrupt flag should not be set\", t.isInterrupted());\n+\n+       t.interrupt();\n+\n+        /* Verify that the thread was successfully interrupted. */\n+        AssertJUnit.assertTrue(name + \"thread that has ended was was interrupted\", t.isInterrupted());    \n+    }\n+\n+    /* if thread is interrupted before start, verify that flag is still set after run. */\n+    @Test\n+    public void test_interruptAtStartSetAfterRun() throws Throwable {\n+        String name = \"interruptAtStartSetAfterRun: \";\n+        Thread t = new Thread();\n+\n+        /* Verify thread is dead and has not been interrupted */\n+        AssertJUnit.assertFalse(name + \"thread should not be alive\", t.isAlive());\n+        AssertJUnit.assertFalse(name + \"interrupt flag should not be set\", t.isInterrupted());\n+\n+        t.interrupt();\n+\n+        /* run thread */\n+        t.run();\n+        t.join();\n+\n+        /* Verify thread is dead and has not been interrupted */\n+        AssertJUnit.assertFalse(name + \"thread should be dead\", t.isAlive());\n+        AssertJUnit.assertTrue(name + \"interrupt flag should be set\", t.isInterrupted()); \n+    }\n+\n+    /* Interrupt thread during run, verify that interrupt flag is not set when thread stops running. \n+     * isInterrupted becomes false after InterruptedException is thrown. */\n+    @Test\n+    public void test_interruptDuringRun() throws Throwable {\n+        String name = \"interruptDuringRun: \";\n+        Thread t = new Thread() {\n+            public void run() {\n+                synchronized(this) {\n+                    try {\n+                        wait();\n+                        AssertJUnit.fail(); /* not interrupted */\n+                    } catch (InterruptedException e) {\n+                        /* expected */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1d3d5fbe89f6aa609a2a12975941f0d9a0781e8"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg0MTcwNg==", "bodyText": "This and the join() don't do anything, so this is really the same test as test_interruptBeforeRun().", "url": "https://github.com/eclipse-openj9/openj9/pull/9341#discussion_r414841706", "createdAt": "2020-04-24T20:24:47Z", "author": {"login": "pshipton"}, "path": "test/functional/Java14andUp/src/org/openj9/test/java/lang/Test_Thread.java", "diffHunk": "@@ -0,0 +1,203 @@\n+package org.openj9.test.java.lang;\n+\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+import org.testng.annotations.Test;\n+import org.testng.AssertJUnit;\n+\n+/**\n+ * This test is to verify matching behavior to the RI from the following implementation change\n+ * discussed in the Java 14 release notes:\n+ * \n+ * \"The specification for java.lang.Thread::interrupt allows for an implementation to only track the \n+ * interrupt state for live threads, and previously this is what occurred. As of this release, the \n+ * interrupt state of a Thread is always available, and if you interrupt a thread t before it is started, \n+ * or after it has terminated, the query t.isInterrupted() will return true.\"\n+ */\n+\n+@Test(groups = { \"level.sanity\" })\n+public class Test_Thread {\n+\n+    /* interrupt thread before it has started */\n+    @Test\n+    public void test_interruptBeforeRun() {\n+        String name = \"interruptBeforeRun: \";\n+        Thread t = new Thread();\n+\n+        /* Verify thread is dead and has not been interrupted */\n+        AssertJUnit.assertFalse(name + \"thread should not be alive\", t.isAlive());\n+        AssertJUnit.assertFalse(name + \"interrupt flag should not be set\", t.isInterrupted());\n+\n+        t.interrupt();\n+\n+        /* Verify that the thread was successfully interrupted. */\n+        AssertJUnit.assertTrue(name + \"thread that has not started should have interrupt flag set\", t.isInterrupted());\n+    }\n+\n+    /* interrupt thread after it has ended */\n+    @Test\n+    public void test_interruptAfterRun() throws Throwable {\n+        String name = \"interruptAfterRun: \";\n+        Thread t = new Thread();\n+\n+        /* run thread */\n+        t.start();\n+        t.join();\n+\n+        /* Verify thread is dead and has not been interrupted */\n+        AssertJUnit.assertFalse(name + \"thread should not be alive\", t.isAlive());\n+        AssertJUnit.assertFalse(name + \"interrupt flag should not be set\", t.isInterrupted());\n+\n+       t.interrupt();\n+\n+        /* Verify that the thread was successfully interrupted. */\n+        AssertJUnit.assertTrue(name + \"thread that has ended was was interrupted\", t.isInterrupted());    \n+    }\n+\n+    /* if thread is interrupted before start, verify that flag is still set after run. */\n+    @Test\n+    public void test_interruptAtStartSetAfterRun() throws Throwable {\n+        String name = \"interruptAtStartSetAfterRun: \";\n+        Thread t = new Thread();\n+\n+        /* Verify thread is dead and has not been interrupted */\n+        AssertJUnit.assertFalse(name + \"thread should not be alive\", t.isAlive());\n+        AssertJUnit.assertFalse(name + \"interrupt flag should not be set\", t.isInterrupted());\n+\n+        t.interrupt();\n+\n+        /* run thread */\n+        t.run();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1d3d5fbe89f6aa609a2a12975941f0d9a0781e8"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg0NDQ1NA==", "bodyText": "This and join() don't do anything, this test is the same as test_interruptAtStartSetAfterRun()", "url": "https://github.com/eclipse-openj9/openj9/pull/9341#discussion_r414844454", "createdAt": "2020-04-24T20:29:42Z", "author": {"login": "pshipton"}, "path": "test/functional/Java14andUp/src/org/openj9/test/java/lang/Test_Thread.java", "diffHunk": "@@ -0,0 +1,203 @@\n+package org.openj9.test.java.lang;\n+\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+import org.testng.annotations.Test;\n+import org.testng.AssertJUnit;\n+\n+/**\n+ * This test is to verify matching behavior to the RI from the following implementation change\n+ * discussed in the Java 14 release notes:\n+ * \n+ * \"The specification for java.lang.Thread::interrupt allows for an implementation to only track the \n+ * interrupt state for live threads, and previously this is what occurred. As of this release, the \n+ * interrupt state of a Thread is always available, and if you interrupt a thread t before it is started, \n+ * or after it has terminated, the query t.isInterrupted() will return true.\"\n+ */\n+\n+@Test(groups = { \"level.sanity\" })\n+public class Test_Thread {\n+\n+    /* interrupt thread before it has started */\n+    @Test\n+    public void test_interruptBeforeRun() {\n+        String name = \"interruptBeforeRun: \";\n+        Thread t = new Thread();\n+\n+        /* Verify thread is dead and has not been interrupted */\n+        AssertJUnit.assertFalse(name + \"thread should not be alive\", t.isAlive());\n+        AssertJUnit.assertFalse(name + \"interrupt flag should not be set\", t.isInterrupted());\n+\n+        t.interrupt();\n+\n+        /* Verify that the thread was successfully interrupted. */\n+        AssertJUnit.assertTrue(name + \"thread that has not started should have interrupt flag set\", t.isInterrupted());\n+    }\n+\n+    /* interrupt thread after it has ended */\n+    @Test\n+    public void test_interruptAfterRun() throws Throwable {\n+        String name = \"interruptAfterRun: \";\n+        Thread t = new Thread();\n+\n+        /* run thread */\n+        t.start();\n+        t.join();\n+\n+        /* Verify thread is dead and has not been interrupted */\n+        AssertJUnit.assertFalse(name + \"thread should not be alive\", t.isAlive());\n+        AssertJUnit.assertFalse(name + \"interrupt flag should not be set\", t.isInterrupted());\n+\n+       t.interrupt();\n+\n+        /* Verify that the thread was successfully interrupted. */\n+        AssertJUnit.assertTrue(name + \"thread that has ended was was interrupted\", t.isInterrupted());    \n+    }\n+\n+    /* if thread is interrupted before start, verify that flag is still set after run. */\n+    @Test\n+    public void test_interruptAtStartSetAfterRun() throws Throwable {\n+        String name = \"interruptAtStartSetAfterRun: \";\n+        Thread t = new Thread();\n+\n+        /* Verify thread is dead and has not been interrupted */\n+        AssertJUnit.assertFalse(name + \"thread should not be alive\", t.isAlive());\n+        AssertJUnit.assertFalse(name + \"interrupt flag should not be set\", t.isInterrupted());\n+\n+        t.interrupt();\n+\n+        /* run thread */\n+        t.run();\n+        t.join();\n+\n+        /* Verify thread is dead and has not been interrupted */\n+        AssertJUnit.assertFalse(name + \"thread should be dead\", t.isAlive());\n+        AssertJUnit.assertTrue(name + \"interrupt flag should be set\", t.isInterrupted()); \n+    }\n+\n+    /* Interrupt thread during run, verify that interrupt flag is not set when thread stops running. \n+     * isInterrupted becomes false after InterruptedException is thrown. */\n+    @Test\n+    public void test_interruptDuringRun() throws Throwable {\n+        String name = \"interruptDuringRun: \";\n+        Thread t = new Thread() {\n+            public void run() {\n+                synchronized(this) {\n+                    try {\n+                        wait();\n+                        AssertJUnit.fail(); /* not interrupted */\n+                    } catch (InterruptedException e) {\n+                        /* expected */\n+                    }\n+                }\n+            }\n+        };\n+\n+        /* run thread */\n+        t.start();\n+        AssertJUnit.assertFalse(name + \"thread not yet interrupted during run\", t.isInterrupted());\n+        t.interrupt();\n+        t.join();\n+\n+        /* Verify thread is dead and has not been interrupted */\n+        AssertJUnit.assertFalse(name + \"thread should be dead\", t.isAlive());\n+        AssertJUnit.assertFalse(name + \"interrupt flag should not be set\", t.isInterrupted()); \n+    }\n+\n+    /* Interrupt thread at start and during run, verify that interrupt flag is not set when thread stops running.\n+     * isInterrupted becomes false after InterruptedException is thrown. */\n+    @Test\n+    public void test_interruptBeforeAndDuringRun() throws Throwable {\n+        String name = \"interruptBeforeAndDuringRun: \";\n+        Thread t = new Thread() {\n+            public void run() {\n+                synchronized(this) {\n+                    try {\n+                        wait();\n+                        AssertJUnit.fail(); /* not interrupted */\n+                    } catch (InterruptedException e) {\n+                        /* expected */\n+                    }\n+                }\n+            }\n+        };\n+\n+        /* Verify thread is dead and has not been interrupted */\n+        AssertJUnit.assertFalse(name + \"thread should not be alive\", t.isAlive());\n+        AssertJUnit.assertFalse(name + \"interrupt flag should not be set\", t.isInterrupted());\n+\n+        /* interrupt before run */\n+        t.interrupt();\n+\n+        AssertJUnit.assertTrue(name + \"thread that has not started should have interrupt flag set\", t.isInterrupted());\n+\n+        /* run thread */\n+        t.start();\n+        t.interrupt();\n+        t.join();\n+\n+        /* Verify thread is dead and has not been interrupted */\n+        AssertJUnit.assertFalse(name + \"thread should be dead\", t.isAlive());\n+        AssertJUnit.assertFalse(name + \"interrupt flag should be cleared\", t.isInterrupted()); \n+    }\n+\n+    /* If thread is interrupted before start, Thread.interrupted is set */\n+    @Test\n+    public void test_interruptedStart() throws Throwable {\n+        String name = \"interruptedStart: \";\n+        Thread t = new Thread(){\n+            public void run() throws AssertionError {\n+                AssertJUnit.assertTrue(Thread.interrupted());\n+            }\n+          };\n+\n+        /* interrupt before start */\n+        t.interrupt();\n+\n+        t.start();\n+        t.join();\n+\n+        AssertJUnit.assertFalse(name + \"interrupt flag should be cleared\", t.isInterrupted()); \n+    }\n+\n+    /* If thread is interrupted before run, Thread.interrupted is not set */\n+    @Test\n+    public void test_interruptedRun() throws Throwable {\n+        String name = \"interrupted\";\n+        Thread t = new Thread(){\n+            public void run() throws AssertionError {\n+                AssertJUnit.assertFalse(Thread.interrupted());\n+            }\n+            };\n+\n+        /* interrupt before start */\n+        t.interrupt();\n+\n+        t.run();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1d3d5fbe89f6aa609a2a12975941f0d9a0781e8"}, "originalPosition": 196}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5d805fb26543e5b0022450d713a464e66f4861b1", "author": {"user": {"login": "theresa-m", "name": "Theresa Mammarella"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/5d805fb26543e5b0022450d713a464e66f4861b1", "committedDate": "2020-04-24T20:51:22Z", "message": "Fix formatting"}, "afterCommit": {"oid": "c2c9a1cb6fa359b15723150e1d0f7a1644557667", "author": {"user": {"login": "theresa-m", "name": "Theresa Mammarella"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/c2c9a1cb6fa359b15723150e1d0f7a1644557667", "committedDate": "2020-04-24T20:53:21Z", "message": "Fix formatting"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c2c9a1cb6fa359b15723150e1d0f7a1644557667", "author": {"user": {"login": "theresa-m", "name": "Theresa Mammarella"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/c2c9a1cb6fa359b15723150e1d0f7a1644557667", "committedDate": "2020-04-24T20:53:21Z", "message": "Fix formatting"}, "afterCommit": {"oid": "c4b895791d3ef2f9e254d6317fbbadc02edfa95d", "author": {"user": {"login": "theresa-m", "name": "Theresa Mammarella"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/c4b895791d3ef2f9e254d6317fbbadc02edfa95d", "committedDate": "2020-04-24T20:54:19Z", "message": "Fix formatting"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c4b895791d3ef2f9e254d6317fbbadc02edfa95d", "author": {"user": {"login": "theresa-m", "name": "Theresa Mammarella"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/c4b895791d3ef2f9e254d6317fbbadc02edfa95d", "committedDate": "2020-04-24T20:54:19Z", "message": "Fix formatting"}, "afterCommit": {"oid": "99c75c37e3309c53314dbfa310ae3efe4202a60a", "author": {"user": {"login": "theresa-m", "name": "Theresa Mammarella"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/99c75c37e3309c53314dbfa310ae3efe4202a60a", "committedDate": "2020-04-24T20:55:03Z", "message": "Fix formatting"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "99c75c37e3309c53314dbfa310ae3efe4202a60a", "author": {"user": {"login": "theresa-m", "name": "Theresa Mammarella"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/99c75c37e3309c53314dbfa310ae3efe4202a60a", "committedDate": "2020-04-24T20:55:03Z", "message": "Fix formatting"}, "afterCommit": {"oid": "88c5e35d29688065ac52933a616c805702e4de8b", "author": {"user": {"login": "theresa-m", "name": "Theresa Mammarella"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/88c5e35d29688065ac52933a616c805702e4de8b", "committedDate": "2020-04-24T20:56:51Z", "message": "Formatting"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "88c5e35d29688065ac52933a616c805702e4de8b", "author": {"user": {"login": "theresa-m", "name": "Theresa Mammarella"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/88c5e35d29688065ac52933a616c805702e4de8b", "committedDate": "2020-04-24T20:56:51Z", "message": "Formatting"}, "afterCommit": {"oid": "7db4f6e386800ab9451a3a646d1656d9d035e71a", "author": {"user": {"login": "theresa-m", "name": "Theresa Mammarella"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/7db4f6e386800ab9451a3a646d1656d9d035e71a", "committedDate": "2020-04-29T18:10:49Z", "message": "Java 14: track interrupt state when thread is dead\n\n- A new private boolean is added to java.lang.Thread to track the interrupt state since a J9VMThread only exists when the thread is actually running. When a thread is started the interrupt state will be transferred from the deadInterrupt boolean to the J9VMThread and tracked in the vm. When the thread is cleaned up, the interrupt state will be transferred back to be tracked by the deadInterrupt boolean.\n- Update formatting for Java14AndUp test playlist\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7db4f6e386800ab9451a3a646d1656d9d035e71a", "author": {"user": {"login": "theresa-m", "name": "Theresa Mammarella"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/7db4f6e386800ab9451a3a646d1656d9d035e71a", "committedDate": "2020-04-29T18:10:49Z", "message": "Java 14: track interrupt state when thread is dead\n\n- A new private boolean is added to java.lang.Thread to track the interrupt state since a J9VMThread only exists when the thread is actually running. When a thread is started the interrupt state will be transferred from the deadInterrupt boolean to the J9VMThread and tracked in the vm. When the thread is cleaned up, the interrupt state will be transferred back to be tracked by the deadInterrupt boolean.\n- Update formatting for Java14AndUp test playlist\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>"}, "afterCommit": {"oid": "ba295f22a72c6877721b6b71d3ffaaedcfff215b", "author": {"user": {"login": "theresa-m", "name": "Theresa Mammarella"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/ba295f22a72c6877721b6b71d3ffaaedcfff215b", "committedDate": "2020-04-29T20:55:44Z", "message": "Java 14: track interrupt state when thread is dead\n\n- A new private boolean is added to java.lang.Thread to track the interrupt state since a J9VMThread only exists when the thread is actually running. When a thread is started the interrupt state will be transferred from the deadInterrupt boolean to the J9VMThread and tracked in the vm. When the thread is cleaned up, the interrupt state will be transferred back to be tracked by the deadInterrupt boolean.\n- Update formatting for Java14AndUp test playlist\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2MDEwNjkx", "url": "https://github.com/eclipse-openj9/openj9/pull/9341#pullrequestreview-406010691", "createdAt": "2020-05-05T17:37:07Z", "commit": {"oid": "ba295f22a72c6877721b6b71d3ffaaedcfff215b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxNzozNzowN1rOGQ0Wgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxNzozNzowN1rOGQ0Wgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI4ODEzMQ==", "bodyText": "Is --enable-preview needed for this test?", "url": "https://github.com/eclipse-openj9/openj9/pull/9341#discussion_r420288131", "createdAt": "2020-05-05T17:37:07Z", "author": {"login": "pshipton"}, "path": "test/functional/Java14andUp/playlist.xml", "diffHunk": "@@ -23,28 +23,51 @@\n -->\n \n <playlist xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation=\"../../TestConfig/playlist.xsd\">\n-      <test>\n-          <testCaseName>Jep359Tests</testCaseName>\n-          <variations>\n-                  <variation>NoOptions</variation>\n-          </variations>\n-          <command>$(JAVA_COMMAND) $(JVM_OPTIONS) \\\n-                  --enable-preview \\\n-                  -cp $(Q)$(LIB_DIR)$(D)asm-7.3.jar$(P)$(RESOURCES_DIR)$(P)$(TESTNG)$(P)$(TEST_RESROOT)$(D)GeneralTest.jar$(Q) \\\n-                  org.testng.TestNG -d $(REPORTDIR) $(Q)$(TEST_RESROOT)$(D)testng.xml$(Q) -testnames Jep359Tests \\\n-                  -groups $(TEST_GROUP) \\\n-                  -excludegroups $(DEFAULT_EXCLUDE); \\\n-                  $(TEST_STATUS)\n-          </command>\n-          <levels>\n-                  <level>sanity</level>\n-          </levels>\n-          <groups>\n-                  <group>functional</group>\n-          </groups>\n-          <!-- Run for Java 14 only since this is a preview feature. -->\n-          <subsets>\n-                  <subset>14</subset>\n-          </subsets>\n-        </test>\n+    <test>\n+        <testCaseName>Jep359Tests</testCaseName>\n+        <variations>\n+            <variation>NoOptions</variation>\n+        </variations>\n+        <command>$(JAVA_COMMAND) $(JVM_OPTIONS) \\\n+            --enable-preview \\\n+            -cp $(Q)$(LIB_DIR)$(D)asm-7.3.jar$(P)$(RESOURCES_DIR)$(P)$(TESTNG)$(P)$(TEST_RESROOT)$(D)GeneralTest.jar$(Q) \\\n+            org.testng.TestNG -d $(REPORTDIR) $(Q)$(TEST_RESROOT)$(D)testng.xml$(Q) -testnames Jep359Tests \\\n+            -groups $(TEST_GROUP) \\\n+            -excludegroups $(DEFAULT_EXCLUDE); \\\n+            $(TEST_STATUS)\n+        </command>\n+        <levels>\n+            <level>sanity</level>\n+        </levels>\n+        <groups>\n+            <group>functional</group>\n+        </groups>\n+        <!-- Run for Java 14 only since this is a preview feature. -->\n+        <subsets>\n+            <subset>14</subset>\n+        </subsets>\n+    </test>\n+    <test>\n+        <testCaseName>ThreadInterruptImplTest</testCaseName>\n+        <variations>\n+            <variation>NoOptions</variation>\n+        </variations>\n+        <command>$(JAVA_COMMAND) $(JVM_OPTIONS) \\\n+            --enable-preview \\", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba295f22a72c6877721b6b71d3ffaaedcfff215b"}, "originalPosition": 58}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2MTI3OTMz", "url": "https://github.com/eclipse-openj9/openj9/pull/9341#pullrequestreview-406127933", "createdAt": "2020-05-05T20:24:14Z", "commit": {"oid": "ba295f22a72c6877721b6b71d3ffaaedcfff215b"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMDoyNDoxNVrOGQ6LRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMDoyOTowNlrOGQ6VdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDM4MzU1Ng==", "bodyText": "Formating nitpick\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t/*  deadInterrupt tracks the thread interrupt state when threadRef has no reference (ie thread is not alive). \n          \n          \n            \n            \t* Note that this value need not be updated while the thread is running since the interrupt state will be \n          \n          \n            \n            \t* tracked by the vm during that time. Because of this the value should not be used over calling\n          \n          \n            \n            \t*  isInterrupted() or interrupted().\n          \n          \n            \n            \t*/\n          \n          \n            \n            \t/* deadInterrupt tracks the thread interrupt state when threadRef has no reference (ie thread is not alive). \n          \n          \n            \n            \t * Note that this value need not be updated while the thread is running since the interrupt state will be \n          \n          \n            \n            \t * tracked by the vm during that time. Because of this the value should not be used over calling\n          \n          \n            \n            \t * isInterrupted() or interrupted().\n          \n          \n            \n            \t */", "url": "https://github.com/eclipse-openj9/openj9/pull/9341#discussion_r420383556", "createdAt": "2020-05-05T20:24:15Z", "author": {"login": "DanHeidinga"}, "path": "jcl/src/java.base/share/classes/java/lang/Thread.java", "diffHunk": "@@ -80,6 +80,14 @@\n \t// Instance variables\n \tprivate long threadRef;\t\t\t\t\t\t\t\t\t// Used by the VM\n \tlong stackSize = 0;\n+\t/*[IF Java14]*/\n+\t/*  deadInterrupt tracks the thread interrupt state when threadRef has no reference (ie thread is not alive). \n+\t* Note that this value need not be updated while the thread is running since the interrupt state will be \n+\t* tracked by the vm during that time. Because of this the value should not be used over calling\n+\t*  isInterrupted() or interrupted().\n+\t*/", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba295f22a72c6877721b6b71d3ffaaedcfff215b"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDM4NDI0OQ==", "bodyText": "Formatting seems odd here too\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\tdeadInterrupt = true;\n          \n          \n            \n            \t\tdeadInterrupt = true;", "url": "https://github.com/eclipse-openj9/openj9/pull/9341#discussion_r420384249", "createdAt": "2020-05-05T20:25:32Z", "author": {"login": "DanHeidinga"}, "path": "jcl/src/java.base/share/classes/java/lang/Thread.java", "diffHunk": "@@ -700,7 +712,12 @@ public void interrupt() {\n \t\tsun.nio.ch.Interruptible localBlockOn = blockOn;\n \t\tif (localBlockOn != null) {\n \t\t\tlocalBlockOn.interrupt(this);\n-\t\t}\n+        }\n+        /*[IF Java14]*/\n+        if (!isAlive()) {\n+\t\t\tdeadInterrupt = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba295f22a72c6877721b6b71d3ffaaedcfff215b"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDM4NTE1OA==", "bodyText": "We can't modify an object without vm access.  This will need to be done before the call to releaseVMAccess", "url": "https://github.com/eclipse-openj9/openj9/pull/9341#discussion_r420385158", "createdAt": "2020-05-05T20:27:16Z", "author": {"login": "DanHeidinga"}, "path": "runtime/vm/vmthread.c", "diffHunk": "@@ -399,6 +399,11 @@ void threadCleanup(J9VMThread * vmThread, UDATA forkedByVM)\n \t/* We are dead at this point. Clear the suspend bit prior to triggering the thread end hook */\n \tclearHaltFlag(vmThread, J9_PUBLIC_FLAGS_HALT_THREAD_JAVA_SUSPEND);\n \n+#if (JAVA_SPEC_VERSION >= 14)\n+    /* Refresh java.lang.Thread interrupt value so it is acessible when vm thread is cleaned up. */\n+    J9VMJAVALANGTHREAD_SET_DEADINTERRUPT(vmThread, vmThread->threadObject, omrthread_interrupted(vmThread->osThread));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba295f22a72c6877721b6b71d3ffaaedcfff215b"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDM4NjE2NQ==", "bodyText": "Should this clear DEADINTERRUPT as well since it's being transferred to the native thread's interrupted state?  Otherwise, when the thread dies, it will appear to be interrupted as this will still be set", "url": "https://github.com/eclipse-openj9/openj9/pull/9341#discussion_r420386165", "createdAt": "2020-05-05T20:29:06Z", "author": {"login": "DanHeidinga"}, "path": "runtime/vm/vmthread.c", "diffHunk": "@@ -1959,6 +1964,13 @@ startJavaThreadInternal(J9VMThread * currentThread, UDATA privateFlags, UDATA os\n \t}\n \tJ9VMJAVALANGTHREAD_SET_THREADREF(currentThread, threadObject, newThread);\n \n+#if (JAVA_SPEC_VERSION >= 14)\n+    /* If thread was interrupted before start, make sure interrupt flag is set for running thread. */\n+    if (J9VMJAVALANGTHREAD_DEADINTERRUPT(currentThread, threadObject)) {\n+        omrthread_interrupt(osThread);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba295f22a72c6877721b6b71d3ffaaedcfff215b"}, "originalPosition": 26}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "cf868ecb30ffe057744f24eb4cc75702987a6cea", "author": {"user": {"login": "theresa-m", "name": "Theresa Mammarella"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/cf868ecb30ffe057744f24eb4cc75702987a6cea", "committedDate": "2020-05-05T21:39:46Z", "message": "Update jcl/src/java.base/share/classes/java/lang/Thread.java\n\nCo-authored-by: Dan Heidinga <daniel_heidinga@ca.ibm.com>"}, "afterCommit": {"oid": "9e2f0d88f51b6e5e8743019d8fe1c1e9d88481f8", "author": {"user": {"login": "theresa-m", "name": "Theresa Mammarella"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/9e2f0d88f51b6e5e8743019d8fe1c1e9d88481f8", "committedDate": "2020-05-05T22:33:22Z", "message": "Java 14: track interrupt state when thread is dead\n\n- A new private boolean is added to java.lang.Thread to track the interrupt state since a J9VMThread only exists when the thread is actually running. When a thread is started the interrupt state will be transferred from the deadInterrupt boolean to the J9VMThread and tracked in the vm. When the thread is cleaned up, the interrupt state will be transferred back to be tracked by the deadInterrupt boolean.\n- Update formatting for Java14AndUp test playlist\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2MjkyNTI5", "url": "https://github.com/eclipse-openj9/openj9/pull/9341#pullrequestreview-406292529", "createdAt": "2020-05-06T04:08:14Z", "commit": {"oid": "9e2f0d88f51b6e5e8743019d8fe1c1e9d88481f8"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwNDowODoxNFrOGRDY7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwNDoxNTowN1rOGRDehw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUzNDUwOQ==", "bodyText": "Can this be moved into the existing java \"cleanUpAttachedThread\" call?\nThe call path, starting below in cleanUpAttachedThread is:\nhttps://github.com/eclipse/openj9/blob/ed6c69f07441718bb9ab8cbf65c4d755f9ca56c3/runtime/vm/callin.cpp#L459\nhttps://github.com/eclipse/openj9/blob/906d4009533c1c313e9e31a9e5db895e9ff0dcdf/jcl/src/java.base/share/classes/java/lang/J9VMInternals.java#L318\nhttps://github.com/eclipse/openj9/blob/5a2386c150d3277d326c05224b206ef041ffbc73/jcl/src/java.base/share/classes/java/lang/Thread.java#L1527\nCould this cleanup method call isInterrupted() and handle this final set in java?  Using the java native to do the set would also clear the native thread's interrupted state which would be a plus, given we recycle the native threads at the vm level", "url": "https://github.com/eclipse-openj9/openj9/pull/9341#discussion_r420534509", "createdAt": "2020-05-06T04:08:14Z", "author": {"login": "DanHeidinga"}, "path": "runtime/vm/vmthread.c", "diffHunk": "@@ -391,6 +391,12 @@ void threadCleanup(J9VMThread * vmThread, UDATA forkedByVM)\n \t\t/* Safe to call this whether handleUncaughtException clears the exception or not */\n \t\tinternalExceptionDescribe(vmThread);\n \t}\n+\n+\t#if (JAVA_SPEC_VERSION >= 14)\n+\t\t/* Refresh java.lang.Thread interrupt value so it is acessible when vm thread is cleaned up. */\n+\t\tJ9VMJAVALANGTHREAD_SET_DEADINTERRUPT(vmThread, vmThread->threadObject, omrthread_interrupted(vmThread->osThread));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e2f0d88f51b6e5e8743019d8fe1c1e9d88481f8"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUzNTk0Mw==", "bodyText": "If we can't do it in java, then I'd like to see this moved as late as possible - so it's done in the same acquire / release block as the cleanUpAttachedThread call", "url": "https://github.com/eclipse-openj9/openj9/pull/9341#discussion_r420535943", "createdAt": "2020-05-06T04:15:07Z", "author": {"login": "DanHeidinga"}, "path": "runtime/vm/vmthread.c", "diffHunk": "@@ -391,6 +391,12 @@ void threadCleanup(J9VMThread * vmThread, UDATA forkedByVM)\n \t\t/* Safe to call this whether handleUncaughtException clears the exception or not */\n \t\tinternalExceptionDescribe(vmThread);\n \t}\n+\n+\t#if (JAVA_SPEC_VERSION >= 14)\n+\t\t/* Refresh java.lang.Thread interrupt value so it is acessible when vm thread is cleaned up. */\n+\t\tJ9VMJAVALANGTHREAD_SET_DEADINTERRUPT(vmThread, vmThread->threadObject, omrthread_interrupted(vmThread->osThread));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUzNDUwOQ=="}, "originalCommit": {"oid": "9e2f0d88f51b6e5e8743019d8fe1c1e9d88481f8"}, "originalPosition": 14}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2OTIzNTU0", "url": "https://github.com/eclipse-openj9/openj9/pull/9341#pullrequestreview-406923554", "createdAt": "2020-05-06T19:30:58Z", "commit": {"oid": "f926cc1b1c5176688b72ec10dcba320e7e18d2e9"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxOTozMDo1OFrOGRiPiA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxOTozNDozN1rOGRiXig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA0MDAwOA==", "bodyText": "Why the second interrupt in this test?  The interrupt state should still be set from the previous interrupt call", "url": "https://github.com/eclipse-openj9/openj9/pull/9341#discussion_r421040008", "createdAt": "2020-05-06T19:30:58Z", "author": {"login": "DanHeidinga"}, "path": "test/functional/Java14andUp/src/org/openj9/test/java/lang/Test_Thread.java", "diffHunk": "@@ -0,0 +1,177 @@\n+package org.openj9.test.java.lang;\n+\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+import org.testng.annotations.Test;\n+import org.testng.AssertJUnit;\n+\n+/**\n+ * This test is to verify matching behavior to the RI from the following implementation change\n+ * discussed in the Java 14 release notes:\n+ * \n+ * \"The specification for java.lang.Thread::interrupt allows for an implementation to only track the \n+ * interrupt state for live threads, and previously this is what occurred. As of this release, the \n+ * interrupt state of a Thread is always available, and if you interrupt a thread t before it is started, \n+ * or after it has terminated, the query t.isInterrupted() will return true.\"\n+ */\n+\n+@Test(groups = { \"level.sanity\" })\n+public class Test_Thread {\n+\n+    /* interrupt thread after it has ended */\n+    @Test\n+    public void test_interruptAfterRun() throws Throwable {\n+        String name = \"interruptAfterRun: \";\n+        Thread t = new Thread();\n+\n+        /* run thread */\n+        t.start();\n+        t.join();\n+\n+        /* Verify thread is dead and has not been interrupted */\n+        AssertJUnit.assertFalse(name + \"thread should not be alive\", t.isAlive());\n+        AssertJUnit.assertFalse(name + \"interrupt flag should not be set\", t.isInterrupted());\n+        \n+        t.interrupt();\n+\n+        /* Verify that the thread was successfully interrupted. */\n+        AssertJUnit.assertTrue(name + \"thread that has ended was was interrupted\", t.isInterrupted());    \n+    }\n+\n+    /* Verify that thread was sucessfully interrupted before it is started, and that the interrupt flag is \n+     * still set after it is run. */\n+    @Test\n+    public void test_interruptAtStartSetAfterRun() throws Throwable {\n+        String name = \"interruptAtStartSetAfterRun: \";\n+        Thread t = new Thread();\n+\n+        /* Verify thread is dead and has not been interrupted */\n+        AssertJUnit.assertFalse(name + \"thread should not be alive\", t.isAlive());\n+        AssertJUnit.assertFalse(name + \"interrupt flag should not be set\", t.isInterrupted());\n+\n+        t.interrupt();\n+\n+        /* Verify that the thread was successfully interrupted. */\n+        AssertJUnit.assertTrue(name + \"thread that has not started should have interrupt flag set\", t.isInterrupted());\n+\n+        /* run thread */\n+        t.start();\n+        t.join();\n+\n+        /* Verify thread is dead and has not been interrupted */\n+        AssertJUnit.assertFalse(name + \"thread should be dead\", t.isAlive());\n+        AssertJUnit.assertTrue(name + \"interrupt flag should be set\", t.isInterrupted()); \n+    }\n+\n+    /* Interrupt thread during run, verify that interrupt flag is not set when thread stops running. \n+     * isInterrupted becomes false after InterruptedException is thrown. */\n+    private volatile boolean bool_interruptDuringRun = false;\n+    @Test\n+    public void test_interruptDuringRun() throws Throwable {\n+        String name = \"interruptDuringRun: \";\n+        Thread t = new Thread() {\n+            public void run() {\n+                synchronized(this) {\n+                    try {\n+                        wait();\n+                    } catch (InterruptedException e) {\n+                        /* expected */\n+                        bool_interruptDuringRun = true;\n+                    }\n+                }\n+            }\n+        };\n+\n+        /* run thread */\n+        t.start();\n+        AssertJUnit.assertFalse(name + \"thread not yet interrupted during run\", t.isInterrupted());\n+        t.interrupt();\n+        t.join();\n+\n+        AssertJUnit.assertTrue(name + \"InterruptedException was thrown during run\", bool_interruptDuringRun);\n+\n+        /* Verify thread is dead and has not been interrupted */\n+        AssertJUnit.assertFalse(name + \"thread should be dead\", t.isAlive());\n+        AssertJUnit.assertFalse(name + \"interrupt flag should not be set\", t.isInterrupted()); \n+    }\n+\n+    /* Interrupt thread at start and during run, verify that interrupt flag is not set when thread stops running.\n+     * isInterrupted becomes false after InterruptedException is thrown. */\n+    private volatile boolean bool_interruptBeforeAndDuringRun = false;\n+    @Test\n+    public void test_interruptBeforeAndDuringRun() throws Throwable {\n+        String name = \"interruptBeforeAndDuringRun: \";\n+        Thread t = new Thread() {\n+            public void run() {\n+                synchronized(this) {\n+                    try {\n+                        wait();\n+                    } catch (InterruptedException e) {\n+                        bool_interruptBeforeAndDuringRun = true;\n+                    }\n+                }\n+            }\n+        };\n+\n+        /* Verify thread is dead and has not been interrupted */\n+        AssertJUnit.assertFalse(name + \"thread should not be alive\", t.isAlive());\n+        AssertJUnit.assertFalse(name + \"interrupt flag should not be set\", t.isInterrupted());\n+\n+        /* interrupt before run */\n+        t.interrupt();\n+\n+        AssertJUnit.assertTrue(name + \"thread that has not started should have interrupt flag set\", t.isInterrupted());\n+\n+        /* run thread */\n+        t.start();\n+        t.interrupt();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f926cc1b1c5176688b72ec10dcba320e7e18d2e9"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA0MTE0OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    /* Verify thread is dead and has not been interrupted */\n          \n          \n            \n                    /* Verify thread is dead and has been interrupted */", "url": "https://github.com/eclipse-openj9/openj9/pull/9341#discussion_r421041149", "createdAt": "2020-05-06T19:33:05Z", "author": {"login": "DanHeidinga"}, "path": "test/functional/Java14andUp/src/org/openj9/test/java/lang/Test_Thread.java", "diffHunk": "@@ -0,0 +1,177 @@\n+package org.openj9.test.java.lang;\n+\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+import org.testng.annotations.Test;\n+import org.testng.AssertJUnit;\n+\n+/**\n+ * This test is to verify matching behavior to the RI from the following implementation change\n+ * discussed in the Java 14 release notes:\n+ * \n+ * \"The specification for java.lang.Thread::interrupt allows for an implementation to only track the \n+ * interrupt state for live threads, and previously this is what occurred. As of this release, the \n+ * interrupt state of a Thread is always available, and if you interrupt a thread t before it is started, \n+ * or after it has terminated, the query t.isInterrupted() will return true.\"\n+ */\n+\n+@Test(groups = { \"level.sanity\" })\n+public class Test_Thread {\n+\n+    /* interrupt thread after it has ended */\n+    @Test\n+    public void test_interruptAfterRun() throws Throwable {\n+        String name = \"interruptAfterRun: \";\n+        Thread t = new Thread();\n+\n+        /* run thread */\n+        t.start();\n+        t.join();\n+\n+        /* Verify thread is dead and has not been interrupted */\n+        AssertJUnit.assertFalse(name + \"thread should not be alive\", t.isAlive());\n+        AssertJUnit.assertFalse(name + \"interrupt flag should not be set\", t.isInterrupted());\n+        \n+        t.interrupt();\n+\n+        /* Verify that the thread was successfully interrupted. */\n+        AssertJUnit.assertTrue(name + \"thread that has ended was was interrupted\", t.isInterrupted());    \n+    }\n+\n+    /* Verify that thread was sucessfully interrupted before it is started, and that the interrupt flag is \n+     * still set after it is run. */\n+    @Test\n+    public void test_interruptAtStartSetAfterRun() throws Throwable {\n+        String name = \"interruptAtStartSetAfterRun: \";\n+        Thread t = new Thread();\n+\n+        /* Verify thread is dead and has not been interrupted */\n+        AssertJUnit.assertFalse(name + \"thread should not be alive\", t.isAlive());\n+        AssertJUnit.assertFalse(name + \"interrupt flag should not be set\", t.isInterrupted());\n+\n+        t.interrupt();\n+\n+        /* Verify that the thread was successfully interrupted. */\n+        AssertJUnit.assertTrue(name + \"thread that has not started should have interrupt flag set\", t.isInterrupted());\n+\n+        /* run thread */\n+        t.start();\n+        t.join();\n+\n+        /* Verify thread is dead and has not been interrupted */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f926cc1b1c5176688b72ec10dcba320e7e18d2e9"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA0MjA1OA==", "bodyText": "I like this approach.  Can you confirm that the thread is \"isAlive\" at this point?  Otherwise the interrupted() call will return the previous setting of deadInterrupt.", "url": "https://github.com/eclipse-openj9/openj9/pull/9341#discussion_r421042058", "createdAt": "2020-05-06T19:34:37Z", "author": {"login": "DanHeidinga"}, "path": "jcl/src/java.base/share/classes/java/lang/Thread.java", "diffHunk": "@@ -1525,6 +1551,11 @@ void uncaughtException(Throwable e) {\n  * @see J9VMInternals#threadCleanup()\n  */\n void cleanup() {\n+/*[IF Java14]*/\n+\t/* Refresh deadInterrupt value so it is accurate when vm thread is cleaned up. */\t\n+\tdeadInterrupt = interrupted();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f926cc1b1c5176688b72ec10dcba320e7e18d2e9"}, "originalPosition": 78}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f926cc1b1c5176688b72ec10dcba320e7e18d2e9", "author": {"user": {"login": "theresa-m", "name": "Theresa Mammarella"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/f926cc1b1c5176688b72ec10dcba320e7e18d2e9", "committedDate": "2020-05-06T18:06:24Z", "message": "review"}, "afterCommit": {"oid": "d43bd50fd28e68ab5f1836291fc6083ebdac28c9", "author": {"user": {"login": "theresa-m", "name": "Theresa Mammarella"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/d43bd50fd28e68ab5f1836291fc6083ebdac28c9", "committedDate": "2020-05-06T19:36:03Z", "message": "Java 14: track interrupt state when thread is dead\n\n- A new private boolean is added to java.lang.Thread to track the interrupt state since a J9VMThread only exists when the thread is actually running. When a thread is started the interrupt state will be transferred from the deadInterrupt boolean to the J9VMThread and tracked in the vm. When the thread is cleaned up, the interrupt state will be transferred back to be tracked by the deadInterrupt boolean.\n- Update formatting for Java14AndUp test playlist\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "64f97efabbcf97a5f3fe54a7866319a4e7f0788c", "author": {"user": {"login": "theresa-m", "name": "Theresa Mammarella"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/64f97efabbcf97a5f3fe54a7866319a4e7f0788c", "committedDate": "2020-05-06T20:04:35Z", "message": "Java 14: track interrupt state when thread is dead\n\n- A new private boolean is added to java.lang.Thread to track the interrupt state since a J9VMThread only exists when the thread is actually running. When a thread is started the interrupt state will be transferred from the deadInterrupt boolean to the J9VMThread and tracked in the vm. When the thread is cleaned up, the interrupt state will be transferred back to be tracked by the deadInterrupt boolean.\n- Update formatting for Java14AndUp test playlist\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "bc0ff875546adafb2aa6ed1d58c1fae88d818a6e", "author": {"user": {"login": "theresa-m", "name": "Theresa Mammarella"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/bc0ff875546adafb2aa6ed1d58c1fae88d818a6e", "committedDate": "2020-05-06T20:03:05Z", "message": "Update test/functional/Java14andUp/src/org/openj9/test/java/lang/Test_Thread.java\n\nCo-authored-by: Dan Heidinga <daniel_heidinga@ca.ibm.com>"}, "afterCommit": {"oid": "64f97efabbcf97a5f3fe54a7866319a4e7f0788c", "author": {"user": {"login": "theresa-m", "name": "Theresa Mammarella"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/64f97efabbcf97a5f3fe54a7866319a4e7f0788c", "committedDate": "2020-05-06T20:04:35Z", "message": "Java 14: track interrupt state when thread is dead\n\n- A new private boolean is added to java.lang.Thread to track the interrupt state since a J9VMThread only exists when the thread is actually running. When a thread is started the interrupt state will be transferred from the deadInterrupt boolean to the J9VMThread and tracked in the vm. When the thread is cleaned up, the interrupt state will be transferred back to be tracked by the deadInterrupt boolean.\n- Update formatting for Java14AndUp test playlist\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA3ODA4NDkx", "url": "https://github.com/eclipse-openj9/openj9/pull/9341#pullrequestreview-407808491", "createdAt": "2020-05-07T20:23:33Z", "commit": {"oid": "64f97efabbcf97a5f3fe54a7866319a4e7f0788c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA3ODEyNzM4", "url": "https://github.com/eclipse-openj9/openj9/pull/9341#pullrequestreview-407812738", "createdAt": "2020-05-07T20:29:58Z", "commit": {"oid": "64f97efabbcf97a5f3fe54a7866319a4e7f0788c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA4Mjk5MzM0", "url": "https://github.com/eclipse-openj9/openj9/pull/9341#pullrequestreview-408299334", "createdAt": "2020-05-08T14:57:10Z", "commit": {"oid": "64f97efabbcf97a5f3fe54a7866319a4e7f0788c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1057, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}