{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc3MzAwNDYx", "number": 8615, "title": "Improve performance of iterateStackTrace", "bodyText": "The changes contained in this PR are a consequence of the discussions and investigations from #8053. In particular the changes within this PR have been measured [1] to improve a real workload while keeping the implementation simple. There are two changes within the PR, spearated out into two separate commits:\nCache J9Class in iterateStackTrace callback\nAvoid having to lookup the J9Class* within getStackTraceIterator\nby optionally passing the J9Class* as an argument. If the caller\nhas the J9Class* available we will avoid an extra call to\npeekClassHashTable which will improve the performance of the\ncallback.\nIterate over J9Method* rather than J9ROMMethod* for performance\nROMMethods are variable sized making walking them more expensive. For\nJITTed methods, we have the RAMClass in hand already which would\nallow walking the J9Methods which are fixed sized. This improves the\nspeed of that operation.\nIssue: #7776\n[1] #8053 (comment)", "createdAt": "2020-02-19T17:45:49Z", "url": "https://github.com/eclipse-openj9/openj9/pull/8615", "merged": true, "mergeCommit": {"oid": "284a67dc8e8a639348fdb541589828ee0df280a9"}, "closed": true, "closedAt": "2020-05-04T19:37:52Z", "author": {"login": "fjeremic"}, "timelineItems": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcF8EY0AFqTM2MTM5MTc5NQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABceExPigFqTQwNTI4ODA0Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYxMzkxNzk1", "url": "https://github.com/eclipse-openj9/openj9/pull/8615#pullrequestreview-361391795", "createdAt": "2020-02-19T19:54:17Z", "commit": {"oid": "da33dfbfeb87922355e5259b5883af88dd8de8cd"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQxOTo1NDoxN1rOFr1dnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQxOTo1NDo0NlrOFr1epQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUwOTAyMQ==", "bodyText": "I'm not sure if the PR testing will catch it but there seems to almost certainly be a problem with the this code from da33dfb. It seems when this code is enabled we hit the assert in [1] for some reason. Another (internal) test seems to fail where I can see a bunch of:\nat <unknown class>.<unknown method>(Unknown Source)\n\nIn the backtrace which looks incorrect. Previously the code on line 359 was:\nif ((methodPC >= (UDATA)J9_BYTECODE_START_FROM_ROM_METHOD(possibleMethod)) && (methodPC < (UDATA)J9_BYTECODE_END_FROM_ROM_METHOD(possibleMethod))) {\n\t...\n}\n\nWhich did not work because it broke the test case in [2]. It was returning the following:\n\"main\" Id=1 RUNNABLE\n        at <unknown class>.<unknown method>(Unknown Source)\n        at com.ibm.java.lang.management.internal.ThreadMXBeanImpl.getThreadInfo(ThreadMXBeanImpl.java:266)\n\ninstead of:\n\"main\" prio=5 Id=1 RUNNABLE\n        at com.ibm.java.lang.management.internal.ThreadMXBeanImpl.getMultiThreadInfoImpl(Native Method)\n        at com.ibm.java.lang.management.internal.ThreadMXBeanImpl.getThreadInfo(ThreadMXBeanImpl.java:266)\n\nThe reason seems to be that native methods have a different methodPC. This is also confirmed by looking at the implementation of findROMMethodInROMClass [3] which also does not use J9_BYTECODE_START_FROM_ROM_METHOD and compares the methodPC directly against the J9ROMMethod*.\nThere seems to be another bug here now which is causing the assert [1] to be triggered and other backtrace strings not to be generated.\n[1] https://github.com/eclipse/openj9/blob/60ed51cffd39410084955081e3f37667ace61717/runtime/jcl/common/jclexception.c#L263\n[2] https://github.com/eclipse/openj9/blob/60ed51cffd39410084955081e3f37667ace61717/test/functional/JLM_Tests/src/org/openj9/test/java/lang/management/TestManagementFactory.java#L1306-L1307\n[3] https://github.com/eclipse/openj9/blob/60ed51cffd39410084955081e3f37667ace61717/runtime/vm/findmethod.c#L60-L63", "url": "https://github.com/eclipse-openj9/openj9/pull/8615#discussion_r381509021", "createdAt": "2020-02-19T19:54:17Z", "author": {"login": "fjeremic"}, "path": "runtime/vm/exceptiondescribe.c", "diffHunk": "@@ -343,10 +343,25 @@ iterateStackTrace(J9VMThread * vmThread, j9object_t* exception, callback_func_t\n \t\t\t\t\tpruneConstructors = FALSE;\n #endif\n \t\t\t\t\tromClass = findROMClassFromPC(vmThread, methodPC, &classLoader);\n-\t\t\t\t\tif(romClass) {\n-\t\t\t\t\t\tromMethod = findROMMethodInROMClass(vmThread, romClass, methodPC);\n-\t\t\t\t\t\tif (romMethod != NULL) {\n-\t\t\t\t\t\t\tmethodPC -= (UDATA) J9_BYTECODE_START_FROM_ROM_METHOD(romMethod);\n+\t\t\t\t\tif (NULL != romClass) {\n+\t\t\t\t\t\tJ9UTF8 const *utfClassName = J9ROMCLASS_CLASSNAME(romClass);\n+\n+\t\t\t\t\t\tramClass = peekClassHashTable(vmThread, classLoader, J9UTF8_DATA(utfClassName), J9UTF8_LENGTH(utfClassName));\n+\t\t\t\t\t\tif (NULL != ramClass) {\n+\t\t\t\t\t\t\tU_32 i = 0;\n+\t\t\t\t\t\t\tJ9Method *methods = ramClass->ramMethods;\n+\t\t\t\t\t\t\tfor (i = 0; i < romClass->romMethodCount; ++i) {\n+\t\t\t\t\t\t\t\tJ9ROMMethod *possibleMethod = J9_ROM_METHOD_FROM_RAM_METHOD(&methods[i]);\n+\n+\t\t\t\t\t\t\t\t/* Note that we cannot use `J9_BYTECODE_START_FROM_ROM_METHOD` here because native method PCs\n+\t\t\t\t\t\t\t\t * point to the start of the J9ROMMethod data structure\n+\t\t\t\t\t\t\t\t */\n+\t\t\t\t\t\t\t\tif ((methodPC >= (UDATA)possibleMethod) && (methodPC < (UDATA)J9_BYTECODE_END_FROM_ROM_METHOD(possibleMethod))) {\n+\t\t\t\t\t\t\t\t\tromMethod = possibleMethod;\n+\t\t\t\t\t\t\t\t\tmethodPC -= (UDATA)J9_BYTECODE_START_FROM_ROM_METHOD(romMethod);\n+\t\t\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da33dfbfeb87922355e5259b5883af88dd8de8cd"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUwOTI4NQ==", "bodyText": "@DanHeidinga was wondering if you could have a glance and maybe your expertise may be able to eyeball what the issue might be.", "url": "https://github.com/eclipse-openj9/openj9/pull/8615#discussion_r381509285", "createdAt": "2020-02-19T19:54:46Z", "author": {"login": "fjeremic"}, "path": "runtime/vm/exceptiondescribe.c", "diffHunk": "@@ -343,10 +343,25 @@ iterateStackTrace(J9VMThread * vmThread, j9object_t* exception, callback_func_t\n \t\t\t\t\tpruneConstructors = FALSE;\n #endif\n \t\t\t\t\tromClass = findROMClassFromPC(vmThread, methodPC, &classLoader);\n-\t\t\t\t\tif(romClass) {\n-\t\t\t\t\t\tromMethod = findROMMethodInROMClass(vmThread, romClass, methodPC);\n-\t\t\t\t\t\tif (romMethod != NULL) {\n-\t\t\t\t\t\t\tmethodPC -= (UDATA) J9_BYTECODE_START_FROM_ROM_METHOD(romMethod);\n+\t\t\t\t\tif (NULL != romClass) {\n+\t\t\t\t\t\tJ9UTF8 const *utfClassName = J9ROMCLASS_CLASSNAME(romClass);\n+\n+\t\t\t\t\t\tramClass = peekClassHashTable(vmThread, classLoader, J9UTF8_DATA(utfClassName), J9UTF8_LENGTH(utfClassName));\n+\t\t\t\t\t\tif (NULL != ramClass) {\n+\t\t\t\t\t\t\tU_32 i = 0;\n+\t\t\t\t\t\t\tJ9Method *methods = ramClass->ramMethods;\n+\t\t\t\t\t\t\tfor (i = 0; i < romClass->romMethodCount; ++i) {\n+\t\t\t\t\t\t\t\tJ9ROMMethod *possibleMethod = J9_ROM_METHOD_FROM_RAM_METHOD(&methods[i]);\n+\n+\t\t\t\t\t\t\t\t/* Note that we cannot use `J9_BYTECODE_START_FROM_ROM_METHOD` here because native method PCs\n+\t\t\t\t\t\t\t\t * point to the start of the J9ROMMethod data structure\n+\t\t\t\t\t\t\t\t */\n+\t\t\t\t\t\t\t\tif ((methodPC >= (UDATA)possibleMethod) && (methodPC < (UDATA)J9_BYTECODE_END_FROM_ROM_METHOD(possibleMethod))) {\n+\t\t\t\t\t\t\t\t\tromMethod = possibleMethod;\n+\t\t\t\t\t\t\t\t\tmethodPC -= (UDATA)J9_BYTECODE_START_FROM_ROM_METHOD(romMethod);\n+\t\t\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUwOTAyMQ=="}, "originalCommit": {"oid": "da33dfbfeb87922355e5259b5883af88dd8de8cd"}, "originalPosition": 67}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2NjIwMzcw", "url": "https://github.com/eclipse-openj9/openj9/pull/8615#pullrequestreview-366620370", "createdAt": "2020-02-28T19:06:40Z", "commit": {"oid": "da33dfbfeb87922355e5259b5883af88dd8de8cd"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxOTowNjo0MFrOFv_rZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxOTowNjo0MFrOFv_rZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg3MDY5NA==", "bodyText": "peekClassHashTable will fail for non-bootclasspath classes defined in the SCC as the classLoader from findROMClassFromPC will always be the bootloader.  There is a large chance that SCC classes will be from the apploader as well so we should attempt to probe that loader as well before we fail back to the segment search.\nSomething like:\nif (ramClass == NULL) {\n  if (j9shr_Query_IsAddressInCache(vm, romClass, romClass->size)) {\n    /* Probe the application loader to determine if it has the J9Class for the current class.\n     * This secondary probe is required as all ROMClasses from the SCC appear to be owned\n     * by the bootstrap classloader.\n     */\n      ramClass = peekClassHashTable(vmThread, vm->applicationClassLoader, J9UTF8_DATA(utfClassName), J9UTF8_LENGTH(utfClassName));\n  }\n}\nWe'll still need a fallback path as this won't catch all cases but should catch substantially more.", "url": "https://github.com/eclipse-openj9/openj9/pull/8615#discussion_r385870694", "createdAt": "2020-02-28T19:06:40Z", "author": {"login": "DanHeidinga"}, "path": "runtime/vm/exceptiondescribe.c", "diffHunk": "@@ -343,10 +343,25 @@ iterateStackTrace(J9VMThread * vmThread, j9object_t* exception, callback_func_t\n \t\t\t\t\tpruneConstructors = FALSE;\n #endif\n \t\t\t\t\tromClass = findROMClassFromPC(vmThread, methodPC, &classLoader);\n-\t\t\t\t\tif(romClass) {\n-\t\t\t\t\t\tromMethod = findROMMethodInROMClass(vmThread, romClass, methodPC);\n-\t\t\t\t\t\tif (romMethod != NULL) {\n-\t\t\t\t\t\t\tmethodPC -= (UDATA) J9_BYTECODE_START_FROM_ROM_METHOD(romMethod);\n+\t\t\t\t\tif (NULL != romClass) {\n+\t\t\t\t\t\tJ9UTF8 const *utfClassName = J9ROMCLASS_CLASSNAME(romClass);\n+\n+\t\t\t\t\t\tramClass = peekClassHashTable(vmThread, classLoader, J9UTF8_DATA(utfClassName), J9UTF8_LENGTH(utfClassName));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da33dfbfeb87922355e5259b5883af88dd8de8cd"}, "originalPosition": 52}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0a9989dca0837bd49f1d405665928f090458d70e", "author": {"user": {"login": "fjeremic", "name": "Filip Jeremic"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/0a9989dca0837bd49f1d405665928f090458d70e", "committedDate": "2020-03-02T18:19:22Z", "message": "Cache J9Class in iterateStackTrace callback\n\nAvoid having to lookup the `J9Class*` within `getStackTraceIterator`\nby optionally passing the `J9Class*` as an argument. If the caller\nhas the `J9Class*` available we will avoid an extra call to\n`peekClassHashTable` which will improve the performance of the\ncallback.\n\nSigned-off-by: Filip Jeremic <fjeremic@ca.ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "da33dfbfeb87922355e5259b5883af88dd8de8cd", "author": {"user": {"login": "fjeremic", "name": "Filip Jeremic"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/da33dfbfeb87922355e5259b5883af88dd8de8cd", "committedDate": "2020-02-19T17:44:30Z", "message": "Iterate over J9Method* rather than J9ROMMethod* for performance\n\nROMMethods are variable sized making walking them more expensive. For\nJITTed methods, we have the RAMClass in hand already which would\nallow walking the J9Methods which are fixed sized. This improves the\nspeed of that operation.\n\nSigned-off-by: Filip Jeremic <fjeremic@ca.ibm.com>"}, "afterCommit": {"oid": "4d7bb309bfca95d5d08e0d055e3074b7557ccdf5", "author": {"user": {"login": "fjeremic", "name": "Filip Jeremic"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/4d7bb309bfca95d5d08e0d055e3074b7557ccdf5", "committedDate": "2020-03-02T18:19:22Z", "message": "Iterate over J9Method* rather than J9ROMMethod* for performance\n\nROMMethods are variable sized making walking them more expensive. For\nJITTed methods, we have the RAMClass in hand already which would\nallow walking the J9Methods which are fixed sized. This improves the\nspeed of that operation.\n\nSigned-off-by: Filip Jeremic <fjeremic@ca.ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e706c526de871fb7cfbaa7b41a3282d0b08d9fe3", "author": {"user": {"login": "fjeremic", "name": "Filip Jeremic"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/e706c526de871fb7cfbaa7b41a3282d0b08d9fe3", "committedDate": "2020-03-02T22:23:30Z", "message": "Make SCQueryFunctions helpers inline\n\nDefining static utility functions in header files is typically not\nwanted because each compilation unit which includes the header will get\nit's own copy of the defined functions. Moreover when building with\nwarnings as errors (which is the default today) we cannot compile such\ncompilation units without using all defined APIs as the compiler will\nemit a(n) (warning) error.\n\nWe define the functions within SCQueryFunctions.h as inline functions\nto avoid such problems.\n\nSigned-off-by: Filip Jeremic <fjeremic@ca.ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4d7bb309bfca95d5d08e0d055e3074b7557ccdf5", "author": {"user": {"login": "fjeremic", "name": "Filip Jeremic"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/4d7bb309bfca95d5d08e0d055e3074b7557ccdf5", "committedDate": "2020-03-02T18:19:22Z", "message": "Iterate over J9Method* rather than J9ROMMethod* for performance\n\nROMMethods are variable sized making walking them more expensive. For\nJITTed methods, we have the RAMClass in hand already which would\nallow walking the J9Methods which are fixed sized. This improves the\nspeed of that operation.\n\nSigned-off-by: Filip Jeremic <fjeremic@ca.ibm.com>"}, "afterCommit": {"oid": "a7aa8a4b37aed9c08825841319d2639bec3917f4", "author": {"user": {"login": "fjeremic", "name": "Filip Jeremic"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/a7aa8a4b37aed9c08825841319d2639bec3917f4", "committedDate": "2020-03-02T22:23:30Z", "message": "Iterate over J9Method* rather than J9ROMMethod* for performance\n\nROMMethods are variable sized making walking them more expensive. For\nJITTed methods, we have the RAMClass in hand already which would\nallow walking the J9Methods which are fixed sized. This improves the\nspeed of that operation.\n\nSigned-off-by: Filip Jeremic <fjeremic@ca.ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0MTkwMjM1", "url": "https://github.com/eclipse-openj9/openj9/pull/8615#pullrequestreview-404190235", "createdAt": "2020-05-01T14:30:59Z", "commit": {"oid": "a7aa8a4b37aed9c08825841319d2639bec3917f4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQxNDozMTowMFrOGPLRcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQxNDozMTowMFrOGPLRcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODU2NjUxNA==", "bodyText": "Two braces here are overindented.", "url": "https://github.com/eclipse-openj9/openj9/pull/8615#discussion_r418566514", "createdAt": "2020-05-01T14:31:00Z", "author": {"login": "gacholio"}, "path": "runtime/vm/exceptiondescribe.c", "diffHunk": "@@ -343,11 +344,46 @@ iterateStackTrace(J9VMThread * vmThread, j9object_t* exception, callback_func_t\n \t\t\t\t\tpruneConstructors = FALSE;\n #endif\n \t\t\t\t\tromClass = findROMClassFromPC(vmThread, methodPC, &classLoader);\n-\t\t\t\t\tif(romClass) {\n-\t\t\t\t\t\tromMethod = findROMMethodInROMClass(vmThread, romClass, methodPC);\n-\t\t\t\t\t\tif (romMethod != NULL) {\n-\t\t\t\t\t\t\tmethodPC -= (UDATA) J9_BYTECODE_START_FROM_ROM_METHOD(romMethod);\n+\t\t\t\t\tif (NULL != romClass) {\n+\t\t\t\t\t\tJ9UTF8 const *utfClassName = J9ROMCLASS_CLASSNAME(romClass);\n+\n+\t\t\t\t\t\tramClass = peekClassHashTable(vmThread, classLoader, J9UTF8_DATA(utfClassName), J9UTF8_LENGTH(utfClassName));\n+\t\t\t\t\t\tif (ramClass == NULL) {\n+\t\t\t\t\t\t\tif (j9shr_Query_IsAddressInCache(vm, romClass, romClass->romSize)) {\n+\t\t\t\t\t\t\t\t/* Probe the application loader to determine if it has the J9Class for the current class.\n+\t\t\t\t\t\t\t\t * This secondary probe is required as all ROMClasses from the SCC appear to be owned\n+\t\t\t\t\t\t\t\t * by the bootstrap classloader.\n+\t\t\t\t\t\t\t\t */\n+\t\t\t\t\t\t\t\tramClass = peekClassHashTable(vmThread, vm->applicationClassLoader, J9UTF8_DATA(utfClassName), J9UTF8_LENGTH(utfClassName));\n+\t\t\t\t\t\t\t\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7aa8a4b37aed9c08825841319d2639bec3917f4"}, "originalPosition": 62}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0921605921fb6482be5eb990637e36a8bf741cbc", "author": {"user": {"login": "fjeremic", "name": "Filip Jeremic"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/0921605921fb6482be5eb990637e36a8bf741cbc", "committedDate": "2020-05-01T18:34:54Z", "message": "Iterate over J9Method* rather than J9ROMMethod* for performance\n\nROMMethods are variable sized making walking them more expensive. For\nJITTed methods, we have the RAMClass in hand already which would\nallow walking the J9Methods which are fixed sized. This improves the\nspeed of that operation.\n\nSigned-off-by: Filip Jeremic <fjeremic@ca.ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a7aa8a4b37aed9c08825841319d2639bec3917f4", "author": {"user": {"login": "fjeremic", "name": "Filip Jeremic"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/a7aa8a4b37aed9c08825841319d2639bec3917f4", "committedDate": "2020-03-02T22:23:30Z", "message": "Iterate over J9Method* rather than J9ROMMethod* for performance\n\nROMMethods are variable sized making walking them more expensive. For\nJITTed methods, we have the RAMClass in hand already which would\nallow walking the J9Methods which are fixed sized. This improves the\nspeed of that operation.\n\nSigned-off-by: Filip Jeremic <fjeremic@ca.ibm.com>"}, "afterCommit": {"oid": "0921605921fb6482be5eb990637e36a8bf741cbc", "author": {"user": {"login": "fjeremic", "name": "Filip Jeremic"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/0921605921fb6482be5eb990637e36a8bf741cbc", "committedDate": "2020-05-01T18:34:54Z", "message": "Iterate over J9Method* rather than J9ROMMethod* for performance\n\nROMMethods are variable sized making walking them more expensive. For\nJITTed methods, we have the RAMClass in hand already which would\nallow walking the J9Methods which are fixed sized. This improves the\nspeed of that operation.\n\nSigned-off-by: Filip Jeremic <fjeremic@ca.ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0MzQ4MTgy", "url": "https://github.com/eclipse-openj9/openj9/pull/8615#pullrequestreview-404348182", "createdAt": "2020-05-01T19:17:01Z", "commit": {"oid": "0921605921fb6482be5eb990637e36a8bf741cbc"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA1Mjg4MDQ3", "url": "https://github.com/eclipse-openj9/openj9/pull/8615#pullrequestreview-405288047", "createdAt": "2020-05-04T19:37:13Z", "commit": {"oid": "0921605921fb6482be5eb990637e36a8bf741cbc"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 573, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}