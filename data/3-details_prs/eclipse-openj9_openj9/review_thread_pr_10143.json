{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ3NTQwMTcx", "number": 10143, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxNjo0ODozM1rOENV_PQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxOTozNjo0NVrOENZNhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyNDI3MTk3OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/control/CompilationThread.cpp", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxNjo0ODozM1rOGv-V9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxNzowMTozOFrOGv-vvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjk1NzY4NA==", "bodyText": "Curious why are we not calling postCompilationTasks here instead?", "url": "https://github.com/eclipse-openj9/openj9/pull/10143#discussion_r452957684", "createdAt": "2020-07-10T16:48:33Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/control/CompilationThread.cpp", "diffHunk": "@@ -8654,6 +8659,8 @@ TR::CompilationInfoPerThreadBase::wrappedCompile(J9PortLibrary *portLib, void *\n \n       if (compiler)\n          {\n+         // The KOT needs to survive at least until we're done committing virtual guards and we must not be holding the\n+         // comp monitor prior to freeing the KOT because it requires VM access.\n          if (compiler->getKnownObjectTable())\n             compiler->freeKnownObjectTable();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1582c84de0b6d7b84671801eb327dc1bd5b0b82"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjk2NDI4NQ==", "bodyText": "postCompilationTasks is relatively new; it was code that was refactored to cover a gap in the exception handling (see #1118). As such, I refactored the code to not change the order in which things happen. It might be possible to make the call here but I would have to read the code in detail.", "url": "https://github.com/eclipse-openj9/openj9/pull/10143#discussion_r452964285", "createdAt": "2020-07-10T17:01:38Z", "author": {"login": "dsouzai"}, "path": "runtime/compiler/control/CompilationThread.cpp", "diffHunk": "@@ -8654,6 +8659,8 @@ TR::CompilationInfoPerThreadBase::wrappedCompile(J9PortLibrary *portLib, void *\n \n       if (compiler)\n          {\n+         // The KOT needs to survive at least until we're done committing virtual guards and we must not be holding the\n+         // comp monitor prior to freeing the KOT because it requires VM access.\n          if (compiler->getKnownObjectTable())\n             compiler->freeKnownObjectTable();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjk1NzY4NA=="}, "originalCommit": {"oid": "e1582c84de0b6d7b84671801eb327dc1bd5b0b82"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyNDI3OTUwOnYy", "diffSide": "RIGHT", "path": "runtime/compiler/control/JitDump.cpp", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxNjo1MDo0OVrOGv-aew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxNzowOTozNlrOGv--3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjk1ODg0Mw==", "bodyText": "The releaseVMAccess macro that we call in compileOnSeparateThread should have asserted I would have thought, because prior to this change we would not have held VM access while trying to release it. Any ideas why we don't assert in today's world?", "url": "https://github.com/eclipse-openj9/openj9/pull/10143#discussion_r452958843", "createdAt": "2020-07-10T16:50:49Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/control/JitDump.cpp", "diffHunk": "@@ -526,174 +517,198 @@ runJitdump(char *label, J9RASdumpContext *context, J9RASdumpAgent *agent)\n       compInfo->releaseCompMonitor(crashedThread);\n       }\n \n-   // if our compinfo is null, we are an application thread\n-   if (threadCompInfo == 0)\n+   try\n       {\n-      if (options->getVerboseOption(TR_VerboseDump))\n-         TR_VerboseLog::writeLineLocked(TR_Vlog_JITDUMP, \"Crashed in application thread\");\n-      trfprintf(logFile, \"#INFO: Crashed in application thread %p.\\n\", crashedThread);\n-\n-      // only bother doing anything if we have a healthy compilation thread available\n-      if (recompilationThread)\n+      // if our compinfo is null, we are an application thread\n+      if (threadCompInfo == 0)\n          {\n-         // make space for methods to be recompiled\n-         // FIXME: this is on the stack... is the stack big enough?\n-         int currentMethodIndex = 0;\n-         TR_MethodToBeCompiledForDump jittedMethodsOnStack[STACK_WALK_DEPTH] = { 0 };\n-\n-         // set up the stack walk object\n-         J9StackWalkState walkState;\n-\n-         walkState.userData1 = (void *)jittedMethodsOnStack;\n-         walkState.userData2 = (void *)&currentMethodIndex;\n-         walkState.walkThread = crashedThread;\n-         walkState.skipCount = 0;\n-         walkState.maxFrames = STACK_WALK_DEPTH;\n-         walkState.flags = (\n-            // J9_STACKWALK_LINEAR |\n-            // J9_STACKWALK_START_AT_JIT_FRAME |\n-            // J9_STACKWALK_INCLUDE_NATIVES |\n-            // J9_STACKWALK_HIDE_EXCEPTION_FRAMES |\n-            // J9_STACKWALK_ITERATE_HIDDEN_JIT_FRAMES |\n-            J9_STACKWALK_VISIBLE_ONLY |\n-            J9_STACKWALK_SKIP_INLINES |\n-            J9_STACKWALK_COUNT_SPECIFIED |\n-            J9_STACKWALK_ITERATE_FRAMES\n-            );\n-         walkState.frameWalkFunction = logStackIterator;\n-\n-         /*\n-          * NOTE [March 6th, 2013]:\n-          *\n-          *    Graham Chapman said:\n-          *\n-          *    This will make the stack walker jump back to the last\n-          *    interpreter transition point if a bad return address is found,\n-          *    rather than asserting.  You'll miss a bunch of frames, but\n-          *    there's really nothing better to be done in that case.\n-          */\n-         walkState.errorMode = J9_STACKWALK_ERROR_MODE_IGNORE;\n-\n-         // actually walk the stack, adding all JITed methods to the queue\n-         compInfo->acquireCompMonitor(crashedThread);\n-         crashedThread->javaVM->walkStackFrames(crashedThread, &walkState);\n-         compInfo->releaseCompMonitor(crashedThread);\n-\n          if (options->getVerboseOption(TR_VerboseDump))\n-            TR_VerboseLog::writeLineLocked(TR_Vlog_JITDUMP, \"found %d JITed methods on Java stack\", currentMethodIndex);\n-         trfprintf(logFile, \"#INFO: Found %d JITed methods on Java stack.\\n\", currentMethodIndex);\n-\n-         // resume the compilation thread\n-         recompilationThreadInfo->resumeCompilationThread();\n+            TR_VerboseLog::writeLineLocked(TR_Vlog_JITDUMP, \"Crashed in application thread\");\n+         trfprintf(logFile, \"#INFO: Crashed in application thread %p.\\n\", crashedThread);\n \n-         // compile our methods\n-         for (int i = 0; i < currentMethodIndex; i++)\n+         // only bother doing anything if we have a healthy compilation thread available\n+         if (recompilationThread)\n             {\n-            // skip if method is somehow null\n-            if (!(jittedMethodsOnStack[i]._method))\n-               continue;\n-\n-            TR_CompilationErrorCode compErrCode;\n-            compErrCode = recompileMethodForLog(\n-               crashedThread,\n-               jittedMethodsOnStack[i]._method,\n-               compInfo,\n-               frontendOfThread,\n-               jittedMethodsOnStack[i]._optLevel,\n-               false,\n-               jittedMethodsOnStack[i]._oldStartPC,\n-               logFile\n+            // make space for methods to be recompiled\n+            // FIXME: this is on the stack... is the stack big enough?\n+            int currentMethodIndex = 0;\n+            TR_MethodToBeCompiledForDump jittedMethodsOnStack[STACK_WALK_DEPTH] = { 0 };\n+\n+            // set up the stack walk object\n+            J9StackWalkState walkState;\n+\n+            walkState.userData1 = (void *)jittedMethodsOnStack;\n+            walkState.userData2 = (void *)&currentMethodIndex;\n+            walkState.walkThread = crashedThread;\n+            walkState.skipCount = 0;\n+            walkState.maxFrames = STACK_WALK_DEPTH;\n+            walkState.flags = (\n+               // J9_STACKWALK_LINEAR |\n+               // J9_STACKWALK_START_AT_JIT_FRAME |\n+               // J9_STACKWALK_INCLUDE_NATIVES |\n+               // J9_STACKWALK_HIDE_EXCEPTION_FRAMES |\n+               // J9_STACKWALK_ITERATE_HIDDEN_JIT_FRAMES |\n+               J9_STACKWALK_VISIBLE_ONLY |\n+               J9_STACKWALK_SKIP_INLINES |\n+               J9_STACKWALK_COUNT_SPECIFIED |\n+               J9_STACKWALK_ITERATE_FRAMES\n                );\n-            } // for\n-\n-         if (currentMethodIndex == 0)\n-            trfprintf(logFile, \"#INFO: DUMP FAILED: no methods to recompile\\n\");\n+            walkState.frameWalkFunction = logStackIterator;\n+\n+            /*\n+             * NOTE [March 6th, 2013]:\n+             *\n+             *    Graham Chapman said:\n+             *\n+             *    This will make the stack walker jump back to the last\n+             *    interpreter transition point if a bad return address is found,\n+             *    rather than asserting.  You'll miss a bunch of frames, but\n+             *    there's really nothing better to be done in that case.\n+             */\n+            walkState.errorMode = J9_STACKWALK_ERROR_MODE_IGNORE;\n+\n+            // actually walk the stack, adding all JITed methods to the queue\n+            compInfo->acquireCompMonitor(crashedThread);\n+            crashedThread->javaVM->walkStackFrames(crashedThread, &walkState);\n+            compInfo->releaseCompMonitor(crashedThread);\n+\n+            if (options->getVerboseOption(TR_VerboseDump))\n+               TR_VerboseLog::writeLineLocked(TR_Vlog_JITDUMP, \"found %d JITed methods on Java stack\", currentMethodIndex);\n+            trfprintf(logFile, \"#INFO: Found %d JITed methods on Java stack.\\n\", currentMethodIndex);\n+\n+            // resume the compilation thread\n+            recompilationThreadInfo->resumeCompilationThread();\n+\n+            // compile our methods\n+            for (int i = 0; i < currentMethodIndex; i++)\n+               {\n+               // skip if method is somehow null\n+               if (!(jittedMethodsOnStack[i]._method))\n+                  continue;\n \n-         if (options->getVerboseOption(TR_VerboseDump))\n-            TR_VerboseLog::writeLineLocked(TR_Vlog_JITDUMP, \"recompilations complete\");\n+               TR_CompilationErrorCode compErrCode;\n+               compErrCode = recompileMethodForLog(\n+                  crashedThread,\n+                  jittedMethodsOnStack[i]._method,\n+                  compInfo,\n+                  frontendOfThread,\n+                  jittedMethodsOnStack[i]._optLevel,\n+                  false,\n+                  jittedMethodsOnStack[i]._oldStartPC,\n+                  logFile\n+               );\n+               } // for\n \n-         } // if recompilationThread\n-      else\n-         {\n-         trfprintf(logFile, \"#INFO: DUMP FAILED: no diagnostic thread\\n\");\n-         jitDumpFailedBecause(crashedThread, \"no thread available to compile for dump\");\n-         }\n+            if (currentMethodIndex == 0)\n+               trfprintf(logFile, \"#INFO: DUMP FAILED: no methods to recompile\\n\");\n \n-      } // if threadcompinfo\n+            if (options->getVerboseOption(TR_VerboseDump))\n+               TR_VerboseLog::writeLineLocked(TR_Vlog_JITDUMP, \"recompilations complete\");\n \n-   // if our compinfo is not null, we are a compilation thread\n-   else\n-      {\n-      if (options->getVerboseOption(TR_VerboseDump))\n-         TR_VerboseLog::writeLineLocked(TR_Vlog_JITDUMP, \"crashed in compilation thread\");\n-      trfprintf(logFile, \"#INFO: Crashed in compilation thread %p.\\n\", crashedThread);\n+            } // if recompilationThread\n+         else\n+            {\n+            trfprintf(logFile, \"#INFO: DUMP FAILED: no diagnostic thread\\n\");\n+            jitDumpFailedBecause(crashedThread, \"no thread available to compile for dump\");\n+            }\n \n-      // get current compilation\n-      TR::Compilation *comp = threadCompInfo->getCompilation();\n+         } // if threadcompinfo\n \n-      // if the compilation is in progress, dump interesting things from it and then recompile\n-      if (comp)\n+      // if our compinfo is not null, we are a compilation thread\n+      else\n          {\n          if (options->getVerboseOption(TR_VerboseDump))\n-            TR_VerboseLog::writeLineLocked(TR_Vlog_JITDUMP, \"Found compilation object\");\n+            TR_VerboseLog::writeLineLocked(TR_Vlog_JITDUMP, \"crashed in compilation thread\");\n+         trfprintf(logFile, \"#INFO: Crashed in compilation thread %p.\\n\", crashedThread);\n \n-         // dump IL of current compilation\n-         dumpCurrentIL(comp, crashedThread, jitConfig, logFile);\n+         // get current compilation\n+         TR::Compilation *comp = threadCompInfo->getCompilation();\n \n-         // if there was an available compilation thread, recompile the current method\n-         if (recompilationThread)\n+         // if the compilation is in progress, dump interesting things from it and then recompile\n+         if (comp)\n             {\n-            // only proceed to recompile if the method is a regular Java method\n-            if (currentMethodBeingCompiled &&\n-               currentMethodBeingCompiled->getMethodDetails().isOrdinaryMethod())\n-               {\n-               // resume the healthy compilation thread\n-               recompilationThreadInfo->resumeCompilationThread();  // TODO: Postpone this so that the thread does not get to sleep again\n-               if (options->getVerboseOption(TR_VerboseDump))\n-                  TR_VerboseLog::writeLineLocked(TR_Vlog_JITDUMP, \"Resuming DiagCompThread\");\n+            if (options->getVerboseOption(TR_VerboseDump))\n+               TR_VerboseLog::writeLineLocked(TR_Vlog_JITDUMP, \"Found compilation object\");\n \n-               // get old start PC if method was available\n-               void *oldStartPC = 0;\n-               if (currentMethodBeingCompiled)\n-                  oldStartPC = currentMethodBeingCompiled->_oldStartPC;\n+            // dump IL of current compilation\n+            dumpCurrentIL(comp, crashedThread, jitConfig, logFile);\n \n-               // request the compilation\n-               TR_CompilationErrorCode compErrCode;\n-               compErrCode = recompileMethodForLog(\n-                  crashedThread,\n-                  (J9Method *)(comp->getCurrentMethod()->getPersistentIdentifier()),\n-                  compInfo,\n-                  frontendOfThread,\n-                  (TR_Hotness)comp->getOptLevel(),\n-                  comp->isProfilingCompilation(),\n-                  oldStartPC,\n-                  logFile\n+            // if there was an available compilation thread, recompile the current method\n+            if (recompilationThread)\n+               {\n+               // only proceed to recompile if the method is a regular Java method\n+               if (currentMethodBeingCompiled &&\n+                  currentMethodBeingCompiled->getMethodDetails().isOrdinaryMethod())\n+                  {\n+                  // resume the healthy compilation thread\n+                  recompilationThreadInfo->resumeCompilationThread();  // TODO: Postpone this so that the thread does not get to sleep again\n+                  if (options->getVerboseOption(TR_VerboseDump))\n+                     TR_VerboseLog::writeLineLocked(TR_Vlog_JITDUMP, \"Resuming DiagCompThread\");\n+\n+                  // get old start PC if method was available\n+                  void *oldStartPC = 0;\n+                  if (currentMethodBeingCompiled)\n+                     oldStartPC = currentMethodBeingCompiled->_oldStartPC;\n+\n+                  // The current thread is a compilation thread which may or may not currently hold VM access. The request\n+                  // for recompilation to generate the jitdump will be performed synchronously for which the code path we\n+                  // will take will be the same as if we were an application thread. We will take the synchronous request\n+                  // path in `compileOnSeparateThread` which ends up releasing VM access prior to waiting on the diagnostic\n+                  // thread to finish the queued compile. To avoid deadlocks we must acquire VM access here.\n+                  TR::VMAccessCriticalSection requestSynchronousCompilation(TR_J9VMBase::get(jitConfig, crashedThread));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1582c84de0b6d7b84671801eb327dc1bd5b0b82"}, "originalPosition": 292}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjk2ODE1Ng==", "bodyText": "It looks like in [1] we go to call [2]:\nVM_VMAccess::inlineReleaseVMAccess (vmThread=0x8c200) at /openjdk/openj9/runtime/oti/VMAccess.hpp:179\n\nThere is no assert there. This looks like the \"fast\" version of release VM access. Looks dangerous IMO. Should we be calling the API which does assert throughout the JIT?\n[1] https://github.com/eclipse/openj9/blob/3fe51ff39281bf1c5e316b021164eea41256febe/runtime/compiler/control/CompilationThread.cpp#L6223\n[2] https://github.com/eclipse/openj9/blob/3fe51ff39281bf1c5e316b021164eea41256febe/runtime/oti/VMAccess.hpp#L165-L193", "url": "https://github.com/eclipse-openj9/openj9/pull/10143#discussion_r452968156", "createdAt": "2020-07-10T17:09:36Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/control/JitDump.cpp", "diffHunk": "@@ -526,174 +517,198 @@ runJitdump(char *label, J9RASdumpContext *context, J9RASdumpAgent *agent)\n       compInfo->releaseCompMonitor(crashedThread);\n       }\n \n-   // if our compinfo is null, we are an application thread\n-   if (threadCompInfo == 0)\n+   try\n       {\n-      if (options->getVerboseOption(TR_VerboseDump))\n-         TR_VerboseLog::writeLineLocked(TR_Vlog_JITDUMP, \"Crashed in application thread\");\n-      trfprintf(logFile, \"#INFO: Crashed in application thread %p.\\n\", crashedThread);\n-\n-      // only bother doing anything if we have a healthy compilation thread available\n-      if (recompilationThread)\n+      // if our compinfo is null, we are an application thread\n+      if (threadCompInfo == 0)\n          {\n-         // make space for methods to be recompiled\n-         // FIXME: this is on the stack... is the stack big enough?\n-         int currentMethodIndex = 0;\n-         TR_MethodToBeCompiledForDump jittedMethodsOnStack[STACK_WALK_DEPTH] = { 0 };\n-\n-         // set up the stack walk object\n-         J9StackWalkState walkState;\n-\n-         walkState.userData1 = (void *)jittedMethodsOnStack;\n-         walkState.userData2 = (void *)&currentMethodIndex;\n-         walkState.walkThread = crashedThread;\n-         walkState.skipCount = 0;\n-         walkState.maxFrames = STACK_WALK_DEPTH;\n-         walkState.flags = (\n-            // J9_STACKWALK_LINEAR |\n-            // J9_STACKWALK_START_AT_JIT_FRAME |\n-            // J9_STACKWALK_INCLUDE_NATIVES |\n-            // J9_STACKWALK_HIDE_EXCEPTION_FRAMES |\n-            // J9_STACKWALK_ITERATE_HIDDEN_JIT_FRAMES |\n-            J9_STACKWALK_VISIBLE_ONLY |\n-            J9_STACKWALK_SKIP_INLINES |\n-            J9_STACKWALK_COUNT_SPECIFIED |\n-            J9_STACKWALK_ITERATE_FRAMES\n-            );\n-         walkState.frameWalkFunction = logStackIterator;\n-\n-         /*\n-          * NOTE [March 6th, 2013]:\n-          *\n-          *    Graham Chapman said:\n-          *\n-          *    This will make the stack walker jump back to the last\n-          *    interpreter transition point if a bad return address is found,\n-          *    rather than asserting.  You'll miss a bunch of frames, but\n-          *    there's really nothing better to be done in that case.\n-          */\n-         walkState.errorMode = J9_STACKWALK_ERROR_MODE_IGNORE;\n-\n-         // actually walk the stack, adding all JITed methods to the queue\n-         compInfo->acquireCompMonitor(crashedThread);\n-         crashedThread->javaVM->walkStackFrames(crashedThread, &walkState);\n-         compInfo->releaseCompMonitor(crashedThread);\n-\n          if (options->getVerboseOption(TR_VerboseDump))\n-            TR_VerboseLog::writeLineLocked(TR_Vlog_JITDUMP, \"found %d JITed methods on Java stack\", currentMethodIndex);\n-         trfprintf(logFile, \"#INFO: Found %d JITed methods on Java stack.\\n\", currentMethodIndex);\n-\n-         // resume the compilation thread\n-         recompilationThreadInfo->resumeCompilationThread();\n+            TR_VerboseLog::writeLineLocked(TR_Vlog_JITDUMP, \"Crashed in application thread\");\n+         trfprintf(logFile, \"#INFO: Crashed in application thread %p.\\n\", crashedThread);\n \n-         // compile our methods\n-         for (int i = 0; i < currentMethodIndex; i++)\n+         // only bother doing anything if we have a healthy compilation thread available\n+         if (recompilationThread)\n             {\n-            // skip if method is somehow null\n-            if (!(jittedMethodsOnStack[i]._method))\n-               continue;\n-\n-            TR_CompilationErrorCode compErrCode;\n-            compErrCode = recompileMethodForLog(\n-               crashedThread,\n-               jittedMethodsOnStack[i]._method,\n-               compInfo,\n-               frontendOfThread,\n-               jittedMethodsOnStack[i]._optLevel,\n-               false,\n-               jittedMethodsOnStack[i]._oldStartPC,\n-               logFile\n+            // make space for methods to be recompiled\n+            // FIXME: this is on the stack... is the stack big enough?\n+            int currentMethodIndex = 0;\n+            TR_MethodToBeCompiledForDump jittedMethodsOnStack[STACK_WALK_DEPTH] = { 0 };\n+\n+            // set up the stack walk object\n+            J9StackWalkState walkState;\n+\n+            walkState.userData1 = (void *)jittedMethodsOnStack;\n+            walkState.userData2 = (void *)&currentMethodIndex;\n+            walkState.walkThread = crashedThread;\n+            walkState.skipCount = 0;\n+            walkState.maxFrames = STACK_WALK_DEPTH;\n+            walkState.flags = (\n+               // J9_STACKWALK_LINEAR |\n+               // J9_STACKWALK_START_AT_JIT_FRAME |\n+               // J9_STACKWALK_INCLUDE_NATIVES |\n+               // J9_STACKWALK_HIDE_EXCEPTION_FRAMES |\n+               // J9_STACKWALK_ITERATE_HIDDEN_JIT_FRAMES |\n+               J9_STACKWALK_VISIBLE_ONLY |\n+               J9_STACKWALK_SKIP_INLINES |\n+               J9_STACKWALK_COUNT_SPECIFIED |\n+               J9_STACKWALK_ITERATE_FRAMES\n                );\n-            } // for\n-\n-         if (currentMethodIndex == 0)\n-            trfprintf(logFile, \"#INFO: DUMP FAILED: no methods to recompile\\n\");\n+            walkState.frameWalkFunction = logStackIterator;\n+\n+            /*\n+             * NOTE [March 6th, 2013]:\n+             *\n+             *    Graham Chapman said:\n+             *\n+             *    This will make the stack walker jump back to the last\n+             *    interpreter transition point if a bad return address is found,\n+             *    rather than asserting.  You'll miss a bunch of frames, but\n+             *    there's really nothing better to be done in that case.\n+             */\n+            walkState.errorMode = J9_STACKWALK_ERROR_MODE_IGNORE;\n+\n+            // actually walk the stack, adding all JITed methods to the queue\n+            compInfo->acquireCompMonitor(crashedThread);\n+            crashedThread->javaVM->walkStackFrames(crashedThread, &walkState);\n+            compInfo->releaseCompMonitor(crashedThread);\n+\n+            if (options->getVerboseOption(TR_VerboseDump))\n+               TR_VerboseLog::writeLineLocked(TR_Vlog_JITDUMP, \"found %d JITed methods on Java stack\", currentMethodIndex);\n+            trfprintf(logFile, \"#INFO: Found %d JITed methods on Java stack.\\n\", currentMethodIndex);\n+\n+            // resume the compilation thread\n+            recompilationThreadInfo->resumeCompilationThread();\n+\n+            // compile our methods\n+            for (int i = 0; i < currentMethodIndex; i++)\n+               {\n+               // skip if method is somehow null\n+               if (!(jittedMethodsOnStack[i]._method))\n+                  continue;\n \n-         if (options->getVerboseOption(TR_VerboseDump))\n-            TR_VerboseLog::writeLineLocked(TR_Vlog_JITDUMP, \"recompilations complete\");\n+               TR_CompilationErrorCode compErrCode;\n+               compErrCode = recompileMethodForLog(\n+                  crashedThread,\n+                  jittedMethodsOnStack[i]._method,\n+                  compInfo,\n+                  frontendOfThread,\n+                  jittedMethodsOnStack[i]._optLevel,\n+                  false,\n+                  jittedMethodsOnStack[i]._oldStartPC,\n+                  logFile\n+               );\n+               } // for\n \n-         } // if recompilationThread\n-      else\n-         {\n-         trfprintf(logFile, \"#INFO: DUMP FAILED: no diagnostic thread\\n\");\n-         jitDumpFailedBecause(crashedThread, \"no thread available to compile for dump\");\n-         }\n+            if (currentMethodIndex == 0)\n+               trfprintf(logFile, \"#INFO: DUMP FAILED: no methods to recompile\\n\");\n \n-      } // if threadcompinfo\n+            if (options->getVerboseOption(TR_VerboseDump))\n+               TR_VerboseLog::writeLineLocked(TR_Vlog_JITDUMP, \"recompilations complete\");\n \n-   // if our compinfo is not null, we are a compilation thread\n-   else\n-      {\n-      if (options->getVerboseOption(TR_VerboseDump))\n-         TR_VerboseLog::writeLineLocked(TR_Vlog_JITDUMP, \"crashed in compilation thread\");\n-      trfprintf(logFile, \"#INFO: Crashed in compilation thread %p.\\n\", crashedThread);\n+            } // if recompilationThread\n+         else\n+            {\n+            trfprintf(logFile, \"#INFO: DUMP FAILED: no diagnostic thread\\n\");\n+            jitDumpFailedBecause(crashedThread, \"no thread available to compile for dump\");\n+            }\n \n-      // get current compilation\n-      TR::Compilation *comp = threadCompInfo->getCompilation();\n+         } // if threadcompinfo\n \n-      // if the compilation is in progress, dump interesting things from it and then recompile\n-      if (comp)\n+      // if our compinfo is not null, we are a compilation thread\n+      else\n          {\n          if (options->getVerboseOption(TR_VerboseDump))\n-            TR_VerboseLog::writeLineLocked(TR_Vlog_JITDUMP, \"Found compilation object\");\n+            TR_VerboseLog::writeLineLocked(TR_Vlog_JITDUMP, \"crashed in compilation thread\");\n+         trfprintf(logFile, \"#INFO: Crashed in compilation thread %p.\\n\", crashedThread);\n \n-         // dump IL of current compilation\n-         dumpCurrentIL(comp, crashedThread, jitConfig, logFile);\n+         // get current compilation\n+         TR::Compilation *comp = threadCompInfo->getCompilation();\n \n-         // if there was an available compilation thread, recompile the current method\n-         if (recompilationThread)\n+         // if the compilation is in progress, dump interesting things from it and then recompile\n+         if (comp)\n             {\n-            // only proceed to recompile if the method is a regular Java method\n-            if (currentMethodBeingCompiled &&\n-               currentMethodBeingCompiled->getMethodDetails().isOrdinaryMethod())\n-               {\n-               // resume the healthy compilation thread\n-               recompilationThreadInfo->resumeCompilationThread();  // TODO: Postpone this so that the thread does not get to sleep again\n-               if (options->getVerboseOption(TR_VerboseDump))\n-                  TR_VerboseLog::writeLineLocked(TR_Vlog_JITDUMP, \"Resuming DiagCompThread\");\n+            if (options->getVerboseOption(TR_VerboseDump))\n+               TR_VerboseLog::writeLineLocked(TR_Vlog_JITDUMP, \"Found compilation object\");\n \n-               // get old start PC if method was available\n-               void *oldStartPC = 0;\n-               if (currentMethodBeingCompiled)\n-                  oldStartPC = currentMethodBeingCompiled->_oldStartPC;\n+            // dump IL of current compilation\n+            dumpCurrentIL(comp, crashedThread, jitConfig, logFile);\n \n-               // request the compilation\n-               TR_CompilationErrorCode compErrCode;\n-               compErrCode = recompileMethodForLog(\n-                  crashedThread,\n-                  (J9Method *)(comp->getCurrentMethod()->getPersistentIdentifier()),\n-                  compInfo,\n-                  frontendOfThread,\n-                  (TR_Hotness)comp->getOptLevel(),\n-                  comp->isProfilingCompilation(),\n-                  oldStartPC,\n-                  logFile\n+            // if there was an available compilation thread, recompile the current method\n+            if (recompilationThread)\n+               {\n+               // only proceed to recompile if the method is a regular Java method\n+               if (currentMethodBeingCompiled &&\n+                  currentMethodBeingCompiled->getMethodDetails().isOrdinaryMethod())\n+                  {\n+                  // resume the healthy compilation thread\n+                  recompilationThreadInfo->resumeCompilationThread();  // TODO: Postpone this so that the thread does not get to sleep again\n+                  if (options->getVerboseOption(TR_VerboseDump))\n+                     TR_VerboseLog::writeLineLocked(TR_Vlog_JITDUMP, \"Resuming DiagCompThread\");\n+\n+                  // get old start PC if method was available\n+                  void *oldStartPC = 0;\n+                  if (currentMethodBeingCompiled)\n+                     oldStartPC = currentMethodBeingCompiled->_oldStartPC;\n+\n+                  // The current thread is a compilation thread which may or may not currently hold VM access. The request\n+                  // for recompilation to generate the jitdump will be performed synchronously for which the code path we\n+                  // will take will be the same as if we were an application thread. We will take the synchronous request\n+                  // path in `compileOnSeparateThread` which ends up releasing VM access prior to waiting on the diagnostic\n+                  // thread to finish the queued compile. To avoid deadlocks we must acquire VM access here.\n+                  TR::VMAccessCriticalSection requestSynchronousCompilation(TR_J9VMBase::get(jitConfig, crashedThread));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjk1ODg0Mw=="}, "originalCommit": {"oid": "e1582c84de0b6d7b84671801eb327dc1bd5b0b82"}, "originalPosition": 292}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyNDgwMDA1OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/control/JitDump.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxOTozNjo0NVrOGwDfKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QyMDoxMzozNlrOGw4Ijg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA0MTk2Mw==", "bodyText": "It's better that you add the brace brackets to explicitly scope the critical section.", "url": "https://github.com/eclipse-openj9/openj9/pull/10143#discussion_r453041963", "createdAt": "2020-07-10T19:36:45Z", "author": {"login": "dsouzai"}, "path": "runtime/compiler/control/JitDump.cpp", "diffHunk": "@@ -657,6 +658,13 @@ runJitdump(char *label, J9RASdumpContext *context, J9RASdumpAgent *agent)\n                if (currentMethodBeingCompiled)\n                   oldStartPC = currentMethodBeingCompiled->_oldStartPC;\n \n+               // The current thread is a compilation thread which may or may not currently hold VM access. The request\n+               // for recompilation to generate the jitdump will be performed synchronously for which the code path we\n+               // will take will be the same as if we were an application thread. We will take the synchronous request\n+               // path in `compileOnSeparateThread` which ends up releasing VM access prior to waiting on the diagnostic\n+               // thread to finish the queued compile. To avoid deadlocks we must acquire VM access here.\n+               TR::VMAccessCriticalSection requestSynchronousCompilation(TR_J9VMBase::get(jitConfig, crashedThread));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6da9b376d25f86cfb70e7fb9f06b9b6a7572e01e"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzkwNDUyNg==", "bodyText": "Fixed in 9cc7a45", "url": "https://github.com/eclipse-openj9/openj9/pull/10143#discussion_r453904526", "createdAt": "2020-07-13T20:13:36Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/control/JitDump.cpp", "diffHunk": "@@ -657,6 +658,13 @@ runJitdump(char *label, J9RASdumpContext *context, J9RASdumpAgent *agent)\n                if (currentMethodBeingCompiled)\n                   oldStartPC = currentMethodBeingCompiled->_oldStartPC;\n \n+               // The current thread is a compilation thread which may or may not currently hold VM access. The request\n+               // for recompilation to generate the jitdump will be performed synchronously for which the code path we\n+               // will take will be the same as if we were an application thread. We will take the synchronous request\n+               // path in `compileOnSeparateThread` which ends up releasing VM access prior to waiting on the diagnostic\n+               // thread to finish the queued compile. To avoid deadlocks we must acquire VM access here.\n+               TR::VMAccessCriticalSection requestSynchronousCompilation(TR_J9VMBase::get(jitConfig, crashedThread));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA0MTk2Mw=="}, "originalCommit": {"oid": "6da9b376d25f86cfb70e7fb9f06b9b6a7572e01e"}, "originalPosition": 17}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4939, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}