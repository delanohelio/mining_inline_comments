{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE0NzkzMDMz", "number": 11088, "reviewThreads": {"totalCount": 43, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxNjo0NjoxN1rOE1vs8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQyMjoyMTozNlrOE-3XPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0NzkxNTM5OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxNjo0NjoxN1rOHuMVzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQyMTowOTozMVrOH2xvJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODE5ODczMw==", "bodyText": "This trace message needs to be updated to remove the \"DCDC\" (Dhruv Chopra? \ud83d\ude04 ). Also if we're adding it here we should also add it for x86 as well.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r518198733", "createdAt": "2020-11-05T16:46:17Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,339 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n+TR::Node *\n+createOutlinedCallNode(TR::CodeGenerator *cg, TR::Node *callNode, TR::ILOpCodes callOp)\n+   {\n+   int32_t   i;\n+   TR::Node  *child;\n+\n+   TR::Node *newCallNode = TR::Node::createWithSymRef(callNode, callOp, callNode->getNumChildren(), callNode->getSymbolReference());\n+\n+   newCallNode->setReferenceCount(1);\n+\n+   for (i=0; i<callNode->getNumChildren(); i++)\n+      {\n+      child = callNode->getChild(i);\n+\n+      if (child->getRegister() != NULL)\n+         {\n+         // Child has already been evaluated outside this tree.\n+         //\n+         newCallNode->setAndIncChild(i, child);\n+         }\n+      else if (child->getOpCode().isLoadConst())\n+         {\n+         // Copy unevaluated constant nodes.\n+         //\n+         child = TR::Node::copy(child);\n+         child->setReferenceCount(1);\n+         newCallNode->setChild(i, child);\n+         }\n+      else\n+         {\n+         if ((child->getOpCodeValue() == TR::loadaddr) &&\n+             (child->getSymbolReference()->getSymbol()) &&\n+             (child->getSymbolReference()->getSymbol()->getStaticSymbol()))\n+            {\n+            child = TR::Node::copy(child);\n+            child->setReferenceCount(1);\n+            newCallNode->setChild(i, child);\n+            }\n+         else\n+            {\n+            // Be very conservative at this point, even though it is possible to make it less so.  For example, this will catch\n+            // the case of an unevaluated argument not persisting outside of the outlined region even though one of its subtrees will.\n+            (void)cg->evaluate(child);\n+\n+            // Do not decrement the reference count here.  It will be decremented when the call node is evaluated\n+            // again in the helper instruction stream.\n+            newCallNode->setAndIncChild(i, child);\n+            }\n+         }\n+      }\n+   if(callNode->isPreparedForDirectJNI())\n+      {\n+         newCallNode->setPreparedForDirectJNI();\n+      }\n+\n+   return newCallNode;\n+   }\n+\n ///////////////////////////////////////////////////////////////////////////////////////\n // multianewArrayEvaluator:  multi-dimensional new array of objects\n ///////////////////////////////////////////////////////////////////////////////////////\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::acall);\n-   TR::Register * targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n-   }\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = (TR_J9VMBase *)(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt()!=2)\n+      {\n+      traceMsg(cg->comp(), \"DCDCDCDC - multianewArrayEvaluator. More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fd870a28386d90aa97661f88b14126e8af243c6"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIwMDAzNw==", "bodyText": "The eyecatcher is now removed. I'll add a similar message to the x86 evaluator in a different PR.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r527200037", "createdAt": "2020-11-19T21:09:31Z", "author": {"login": "dchopra001"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,339 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n+TR::Node *\n+createOutlinedCallNode(TR::CodeGenerator *cg, TR::Node *callNode, TR::ILOpCodes callOp)\n+   {\n+   int32_t   i;\n+   TR::Node  *child;\n+\n+   TR::Node *newCallNode = TR::Node::createWithSymRef(callNode, callOp, callNode->getNumChildren(), callNode->getSymbolReference());\n+\n+   newCallNode->setReferenceCount(1);\n+\n+   for (i=0; i<callNode->getNumChildren(); i++)\n+      {\n+      child = callNode->getChild(i);\n+\n+      if (child->getRegister() != NULL)\n+         {\n+         // Child has already been evaluated outside this tree.\n+         //\n+         newCallNode->setAndIncChild(i, child);\n+         }\n+      else if (child->getOpCode().isLoadConst())\n+         {\n+         // Copy unevaluated constant nodes.\n+         //\n+         child = TR::Node::copy(child);\n+         child->setReferenceCount(1);\n+         newCallNode->setChild(i, child);\n+         }\n+      else\n+         {\n+         if ((child->getOpCodeValue() == TR::loadaddr) &&\n+             (child->getSymbolReference()->getSymbol()) &&\n+             (child->getSymbolReference()->getSymbol()->getStaticSymbol()))\n+            {\n+            child = TR::Node::copy(child);\n+            child->setReferenceCount(1);\n+            newCallNode->setChild(i, child);\n+            }\n+         else\n+            {\n+            // Be very conservative at this point, even though it is possible to make it less so.  For example, this will catch\n+            // the case of an unevaluated argument not persisting outside of the outlined region even though one of its subtrees will.\n+            (void)cg->evaluate(child);\n+\n+            // Do not decrement the reference count here.  It will be decremented when the call node is evaluated\n+            // again in the helper instruction stream.\n+            newCallNode->setAndIncChild(i, child);\n+            }\n+         }\n+      }\n+   if(callNode->isPreparedForDirectJNI())\n+      {\n+         newCallNode->setPreparedForDirectJNI();\n+      }\n+\n+   return newCallNode;\n+   }\n+\n ///////////////////////////////////////////////////////////////////////////////////////\n // multianewArrayEvaluator:  multi-dimensional new array of objects\n ///////////////////////////////////////////////////////////////////////////////////////\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::acall);\n-   TR::Register * targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n-   }\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = (TR_J9VMBase *)(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt()!=2)\n+      {\n+      traceMsg(cg->comp(), \"DCDCDCDC - multianewArrayEvaluator. More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODE5ODczMw=="}, "originalCommit": {"oid": "7fd870a28386d90aa97661f88b14126e8af243c6"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0ODAwMzMyOnYy", "diffSide": "RIGHT", "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxNzowNTo1N1rOHuNMZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QwNDo1NToyN1rOH3_W_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODIxMjcxMA==", "bodyText": "I don't see a need for this function to exist. I see that x86 has the exact same copy as well. We shouldn't be duplicating code like this which seems it could be shared across codegens. However I don't think we should do that as this function serves no purpose to me. We should be able to just evaluate the call as we do before this change, without \"recreating\" the call node.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r518212710", "createdAt": "2020-11-05T17:05:57Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,339 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n+TR::Node *\n+createOutlinedCallNode(TR::CodeGenerator *cg, TR::Node *callNode, TR::ILOpCodes callOp)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fd870a28386d90aa97661f88b14126e8af243c6"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzAwODEyOQ==", "bodyText": "So this routine is used to create a copy of a node that can be passed to the directCallEvaluator. One reason we don't just pass the same node in is because we don't want the reference counts of the children to get decremented. This would be incorrect since we don't actually see the node appear another time in the trees. I think we can manually increase the counts before passing in the same node. This could solve that problem. I don't know if that's a better solution. Let me know what you prefer, and if there's a better solution here. I copied the entire routine from x86 here because I thought there's perhaps an opportunity to refactor here if we decide to use this routine.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r523008129", "createdAt": "2020-11-13T15:05:13Z", "author": {"login": "dchopra001"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,339 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n+TR::Node *\n+createOutlinedCallNode(TR::CodeGenerator *cg, TR::Node *callNode, TR::ILOpCodes callOp)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODIxMjcxMA=="}, "originalCommit": {"oid": "7fd870a28386d90aa97661f88b14126e8af243c6"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQ3MTgwNQ==", "bodyText": "This routine no longer exists and we instead don't decrement the reference count in the multianewarrayEvaluator (it's done in the call we make to directCallEvaluator as per your recommendation. So the problem I mentioned above is no longer an issue.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r528471805", "createdAt": "2020-11-23T04:55:27Z", "author": {"login": "dchopra001"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,339 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n+TR::Node *\n+createOutlinedCallNode(TR::CodeGenerator *cg, TR::Node *callNode, TR::ILOpCodes callOp)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODIxMjcxMA=="}, "originalCommit": {"oid": "7fd870a28386d90aa97661f88b14126e8af243c6"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0ODAwNjY1OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxNzowNjozN1rOHuNOVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QwNDo1Mzo1NVrOH3_V4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODIxMzIwNw==", "bodyText": "I don't think this should exist either unless we envision further uses of this function.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r518213207", "createdAt": "2020-11-05T17:06:37Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,339 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fd870a28386d90aa97661f88b14126e8af243c6"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzAwOTUxOA==", "bodyText": "If we do decide to go with this routine, there's an opportunity to refactor here because x86 also has a similar routine inside OMRTreeEvaluator.cpp:\nTR::Register *\nOMR::X86::TreeEvaluator::performHelperCall(\n      TR::Node *node,\n      TR::SymbolReference *helperSymRef,\n      TR::ILOpCodes helperCallOpCode,\n      bool spillFPRegs,\n      TR::CodeGenerator *cg)\n   {\n   TR::ILOpCodes opCode = node->getOpCodeValue();\n   TR::Node::recreate(node, helperCallOpCode);\n   if(helperSymRef)\n      node->setSymbolReference(helperSymRef);\n   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false, spillFPRegs, cg);\n   TR::Node::recreate(node, opCode);\n   return targetReg;\n   }", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r523009518", "createdAt": "2020-11-13T15:07:25Z", "author": {"login": "dchopra001"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,339 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODIxMzIwNw=="}, "originalCommit": {"oid": "7fd870a28386d90aa97661f88b14126e8af243c6"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQ3MTUyMQ==", "bodyText": "I've removed the use of this routine in 0c0a523.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r528471521", "createdAt": "2020-11-23T04:53:55Z", "author": {"login": "dchopra001"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,339 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODIxMzIwNw=="}, "originalCommit": {"oid": "7fd870a28386d90aa97661f88b14126e8af243c6"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0ODAyNzM1OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxNzoxMToxN1rOHuNbcw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQyMToxMToyMVrOH2xzKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODIxNjU2Mw==", "bodyText": "We've already evaluated the children in the mainline. Why can't we just do:\n   TR_S390OutOfLineCodeSection *outlinedSlowPath = new (cg->trHeapMemory()) TR_S390OutOfLineCodeSection(oolFailLabel, cFlowRegionEnd, cg);\n   cg->getS390OutOfLineCodeSectionList().push_front(outlinedSlowPath);\n   outlinedSlowPath->swapInstructionListsWithCompilation();\n\n   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, oolFailLabel);\n\n   TR::ILOpCodes opCode = node->getOpCodeValue();\n   TR::Node::recreate(node, TR::acall);\n   TR::Register* helperCallReturnReg = directCallEvaluator(node, cg);\n   TR::Node::recreate(node, opCode);\n\n   generateRRInstruction(cg, TR::InstOpCode::getLoadRegOpCode(), node, targetReg, helperCallReturnReg);\n   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);\n   \n   outlinedSlowPath->swapInstructionListsWithCompilation();\n\nAnd remove those two functions created above in this PR.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r518216563", "createdAt": "2020-11-05T17:11:17Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,339 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n+TR::Node *\n+createOutlinedCallNode(TR::CodeGenerator *cg, TR::Node *callNode, TR::ILOpCodes callOp)\n+   {\n+   int32_t   i;\n+   TR::Node  *child;\n+\n+   TR::Node *newCallNode = TR::Node::createWithSymRef(callNode, callOp, callNode->getNumChildren(), callNode->getSymbolReference());\n+\n+   newCallNode->setReferenceCount(1);\n+\n+   for (i=0; i<callNode->getNumChildren(); i++)\n+      {\n+      child = callNode->getChild(i);\n+\n+      if (child->getRegister() != NULL)\n+         {\n+         // Child has already been evaluated outside this tree.\n+         //\n+         newCallNode->setAndIncChild(i, child);\n+         }\n+      else if (child->getOpCode().isLoadConst())\n+         {\n+         // Copy unevaluated constant nodes.\n+         //\n+         child = TR::Node::copy(child);\n+         child->setReferenceCount(1);\n+         newCallNode->setChild(i, child);\n+         }\n+      else\n+         {\n+         if ((child->getOpCodeValue() == TR::loadaddr) &&\n+             (child->getSymbolReference()->getSymbol()) &&\n+             (child->getSymbolReference()->getSymbol()->getStaticSymbol()))\n+            {\n+            child = TR::Node::copy(child);\n+            child->setReferenceCount(1);\n+            newCallNode->setChild(i, child);\n+            }\n+         else\n+            {\n+            // Be very conservative at this point, even though it is possible to make it less so.  For example, this will catch\n+            // the case of an unevaluated argument not persisting outside of the outlined region even though one of its subtrees will.\n+            (void)cg->evaluate(child);\n+\n+            // Do not decrement the reference count here.  It will be decremented when the call node is evaluated\n+            // again in the helper instruction stream.\n+            newCallNode->setAndIncChild(i, child);\n+            }\n+         }\n+      }\n+   if(callNode->isPreparedForDirectJNI())\n+      {\n+         newCallNode->setPreparedForDirectJNI();\n+      }\n+\n+   return newCallNode;\n+   }\n+\n ///////////////////////////////////////////////////////////////////////////////////////\n // multianewArrayEvaluator:  multi-dimensional new array of objects\n ///////////////////////////////////////////////////////////////////////////////////////\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::acall);\n-   TR::Register * targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n-   }\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = (TR_J9VMBase *)(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt()!=2)\n+      {\n+      traceMsg(cg->comp(), \"DCDCDCDC - multianewArrayEvaluator. More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      return performHelperCall(node, NULL, TR::acall, false, cg);\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // First generate the OOL code. This path will be used to handle the scenarios that we don't want to handle in JITT'ed code.\n+   TR_S390OutOfLineCodeSection *outlinedSlowPath = new (cg->trHeapMemory()) TR_S390OutOfLineCodeSection(oolFailLabel, cFlowRegionEnd, cg);\n+   cg->getS390OutOfLineCodeSectionList().push_front(outlinedSlowPath);\n+   outlinedSlowPath->swapInstructionListsWithCompilation();\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, oolFailLabel);\n+\n+   TR::Node *_callNode = createOutlinedCallNode(cg, node, TR::acall);\n+   TR::Register *targetReg2 = NULL;\n+   targetReg2 = TR::TreeEvaluator::performCall(_callNode, false, cg);\n+   cg->decReferenceCount(_callNode);\n+   generateRRInstruction(cg, TR::InstOpCode::LR, node, targetReg, targetReg2);\n+\n+   // After returning from the helper, branch back to mainline code.\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);\n+   // End of OOL\n+   outlinedSlowPath->swapInstructionListsWithCompilation();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fd870a28386d90aa97661f88b14126e8af243c6"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzA3NDA3NA==", "bodyText": "TR::ILOpCodes opCode = node->getOpCodeValue();\n   TR::Node::recreate(node, TR::acall);\n   TR::Register* helperCallReturnReg = directCallEvaluator(node, cg);\n   TR::Node::recreate(node, opCode);\n\nThis workload above is a candidate for refactoring across the two codgens. So that's why I have an extra routine for it. I've made note of this in your comment above about the routine as well (#11088 (comment)). If you don't think we should refactor it then let me know and I'll inline it back in here.\nAlso if we call an evaluator then the reference count of the children will be decremented and we don't want that as we would technically evaluate the same node twice in the evaluator. I can manually increment them before calling the evaluator. Let me know if that is a better solution then creating a new node here (which is what I'm doing currently using the createOutlinedCallNode routine).", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r523074074", "createdAt": "2020-11-13T16:47:35Z", "author": {"login": "dchopra001"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,339 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n+TR::Node *\n+createOutlinedCallNode(TR::CodeGenerator *cg, TR::Node *callNode, TR::ILOpCodes callOp)\n+   {\n+   int32_t   i;\n+   TR::Node  *child;\n+\n+   TR::Node *newCallNode = TR::Node::createWithSymRef(callNode, callOp, callNode->getNumChildren(), callNode->getSymbolReference());\n+\n+   newCallNode->setReferenceCount(1);\n+\n+   for (i=0; i<callNode->getNumChildren(); i++)\n+      {\n+      child = callNode->getChild(i);\n+\n+      if (child->getRegister() != NULL)\n+         {\n+         // Child has already been evaluated outside this tree.\n+         //\n+         newCallNode->setAndIncChild(i, child);\n+         }\n+      else if (child->getOpCode().isLoadConst())\n+         {\n+         // Copy unevaluated constant nodes.\n+         //\n+         child = TR::Node::copy(child);\n+         child->setReferenceCount(1);\n+         newCallNode->setChild(i, child);\n+         }\n+      else\n+         {\n+         if ((child->getOpCodeValue() == TR::loadaddr) &&\n+             (child->getSymbolReference()->getSymbol()) &&\n+             (child->getSymbolReference()->getSymbol()->getStaticSymbol()))\n+            {\n+            child = TR::Node::copy(child);\n+            child->setReferenceCount(1);\n+            newCallNode->setChild(i, child);\n+            }\n+         else\n+            {\n+            // Be very conservative at this point, even though it is possible to make it less so.  For example, this will catch\n+            // the case of an unevaluated argument not persisting outside of the outlined region even though one of its subtrees will.\n+            (void)cg->evaluate(child);\n+\n+            // Do not decrement the reference count here.  It will be decremented when the call node is evaluated\n+            // again in the helper instruction stream.\n+            newCallNode->setAndIncChild(i, child);\n+            }\n+         }\n+      }\n+   if(callNode->isPreparedForDirectJNI())\n+      {\n+         newCallNode->setPreparedForDirectJNI();\n+      }\n+\n+   return newCallNode;\n+   }\n+\n ///////////////////////////////////////////////////////////////////////////////////////\n // multianewArrayEvaluator:  multi-dimensional new array of objects\n ///////////////////////////////////////////////////////////////////////////////////////\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::acall);\n-   TR::Register * targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n-   }\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = (TR_J9VMBase *)(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt()!=2)\n+      {\n+      traceMsg(cg->comp(), \"DCDCDCDC - multianewArrayEvaluator. More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      return performHelperCall(node, NULL, TR::acall, false, cg);\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // First generate the OOL code. This path will be used to handle the scenarios that we don't want to handle in JITT'ed code.\n+   TR_S390OutOfLineCodeSection *outlinedSlowPath = new (cg->trHeapMemory()) TR_S390OutOfLineCodeSection(oolFailLabel, cFlowRegionEnd, cg);\n+   cg->getS390OutOfLineCodeSectionList().push_front(outlinedSlowPath);\n+   outlinedSlowPath->swapInstructionListsWithCompilation();\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, oolFailLabel);\n+\n+   TR::Node *_callNode = createOutlinedCallNode(cg, node, TR::acall);\n+   TR::Register *targetReg2 = NULL;\n+   targetReg2 = TR::TreeEvaluator::performCall(_callNode, false, cg);\n+   cg->decReferenceCount(_callNode);\n+   generateRRInstruction(cg, TR::InstOpCode::LR, node, targetReg, targetReg2);\n+\n+   // After returning from the helper, branch back to mainline code.\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);\n+   // End of OOL\n+   outlinedSlowPath->swapInstructionListsWithCompilation();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODIxNjU2Mw=="}, "originalCommit": {"oid": "7fd870a28386d90aa97661f88b14126e8af243c6"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQwNTYzOQ==", "bodyText": "I understand that calling directCallEvaluator will decrement the node counts and kill registers potentially (if node reference count reaches 0). We can just move the above snippet of code I pasted to the end of the multianewArrayEvaluator and remove the following three lines:\n   cg->decReferenceCount(node->getFirstChild());\n   cg->decReferenceCount(node->getSecondChild());\n   cg->decReferenceCount(node->getThirdChild());\n\nInstead just put a comment down noting that the call to directCallEvaluator in the OOL will have taken care of the reference counts.\nNote that this isn't the most ideal situation as ideally we would just call an API which accepts a method symbol and a bunch of argument TR::Register* values and generates a call. This is effectively what directCallEvaluator does via the linkage classes but in a convoluted way. IIRC we don't have a clear API like this today, which is why we recreate the node here to an acall and go through the evaluator.\nThis eliminates the need for createOutlinedCallNode.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r524405639", "createdAt": "2020-11-16T16:37:11Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,339 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n+TR::Node *\n+createOutlinedCallNode(TR::CodeGenerator *cg, TR::Node *callNode, TR::ILOpCodes callOp)\n+   {\n+   int32_t   i;\n+   TR::Node  *child;\n+\n+   TR::Node *newCallNode = TR::Node::createWithSymRef(callNode, callOp, callNode->getNumChildren(), callNode->getSymbolReference());\n+\n+   newCallNode->setReferenceCount(1);\n+\n+   for (i=0; i<callNode->getNumChildren(); i++)\n+      {\n+      child = callNode->getChild(i);\n+\n+      if (child->getRegister() != NULL)\n+         {\n+         // Child has already been evaluated outside this tree.\n+         //\n+         newCallNode->setAndIncChild(i, child);\n+         }\n+      else if (child->getOpCode().isLoadConst())\n+         {\n+         // Copy unevaluated constant nodes.\n+         //\n+         child = TR::Node::copy(child);\n+         child->setReferenceCount(1);\n+         newCallNode->setChild(i, child);\n+         }\n+      else\n+         {\n+         if ((child->getOpCodeValue() == TR::loadaddr) &&\n+             (child->getSymbolReference()->getSymbol()) &&\n+             (child->getSymbolReference()->getSymbol()->getStaticSymbol()))\n+            {\n+            child = TR::Node::copy(child);\n+            child->setReferenceCount(1);\n+            newCallNode->setChild(i, child);\n+            }\n+         else\n+            {\n+            // Be very conservative at this point, even though it is possible to make it less so.  For example, this will catch\n+            // the case of an unevaluated argument not persisting outside of the outlined region even though one of its subtrees will.\n+            (void)cg->evaluate(child);\n+\n+            // Do not decrement the reference count here.  It will be decremented when the call node is evaluated\n+            // again in the helper instruction stream.\n+            newCallNode->setAndIncChild(i, child);\n+            }\n+         }\n+      }\n+   if(callNode->isPreparedForDirectJNI())\n+      {\n+         newCallNode->setPreparedForDirectJNI();\n+      }\n+\n+   return newCallNode;\n+   }\n+\n ///////////////////////////////////////////////////////////////////////////////////////\n // multianewArrayEvaluator:  multi-dimensional new array of objects\n ///////////////////////////////////////////////////////////////////////////////////////\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::acall);\n-   TR::Register * targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n-   }\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = (TR_J9VMBase *)(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt()!=2)\n+      {\n+      traceMsg(cg->comp(), \"DCDCDCDC - multianewArrayEvaluator. More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      return performHelperCall(node, NULL, TR::acall, false, cg);\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // First generate the OOL code. This path will be used to handle the scenarios that we don't want to handle in JITT'ed code.\n+   TR_S390OutOfLineCodeSection *outlinedSlowPath = new (cg->trHeapMemory()) TR_S390OutOfLineCodeSection(oolFailLabel, cFlowRegionEnd, cg);\n+   cg->getS390OutOfLineCodeSectionList().push_front(outlinedSlowPath);\n+   outlinedSlowPath->swapInstructionListsWithCompilation();\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, oolFailLabel);\n+\n+   TR::Node *_callNode = createOutlinedCallNode(cg, node, TR::acall);\n+   TR::Register *targetReg2 = NULL;\n+   targetReg2 = TR::TreeEvaluator::performCall(_callNode, false, cg);\n+   cg->decReferenceCount(_callNode);\n+   generateRRInstruction(cg, TR::InstOpCode::LR, node, targetReg, targetReg2);\n+\n+   // After returning from the helper, branch back to mainline code.\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);\n+   // End of OOL\n+   outlinedSlowPath->swapInstructionListsWithCompilation();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODIxNjU2Mw=="}, "originalCommit": {"oid": "7fd870a28386d90aa97661f88b14126e8af243c6"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIwMTA2NQ==", "bodyText": "The code has been moved to the end of the evaluator, as per your suggestion (see 10d5904).\nperformHelperCall is used to do the bulk of the work, as it's a similar workload.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r527201065", "createdAt": "2020-11-19T21:11:21Z", "author": {"login": "dchopra001"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,339 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n+TR::Node *\n+createOutlinedCallNode(TR::CodeGenerator *cg, TR::Node *callNode, TR::ILOpCodes callOp)\n+   {\n+   int32_t   i;\n+   TR::Node  *child;\n+\n+   TR::Node *newCallNode = TR::Node::createWithSymRef(callNode, callOp, callNode->getNumChildren(), callNode->getSymbolReference());\n+\n+   newCallNode->setReferenceCount(1);\n+\n+   for (i=0; i<callNode->getNumChildren(); i++)\n+      {\n+      child = callNode->getChild(i);\n+\n+      if (child->getRegister() != NULL)\n+         {\n+         // Child has already been evaluated outside this tree.\n+         //\n+         newCallNode->setAndIncChild(i, child);\n+         }\n+      else if (child->getOpCode().isLoadConst())\n+         {\n+         // Copy unevaluated constant nodes.\n+         //\n+         child = TR::Node::copy(child);\n+         child->setReferenceCount(1);\n+         newCallNode->setChild(i, child);\n+         }\n+      else\n+         {\n+         if ((child->getOpCodeValue() == TR::loadaddr) &&\n+             (child->getSymbolReference()->getSymbol()) &&\n+             (child->getSymbolReference()->getSymbol()->getStaticSymbol()))\n+            {\n+            child = TR::Node::copy(child);\n+            child->setReferenceCount(1);\n+            newCallNode->setChild(i, child);\n+            }\n+         else\n+            {\n+            // Be very conservative at this point, even though it is possible to make it less so.  For example, this will catch\n+            // the case of an unevaluated argument not persisting outside of the outlined region even though one of its subtrees will.\n+            (void)cg->evaluate(child);\n+\n+            // Do not decrement the reference count here.  It will be decremented when the call node is evaluated\n+            // again in the helper instruction stream.\n+            newCallNode->setAndIncChild(i, child);\n+            }\n+         }\n+      }\n+   if(callNode->isPreparedForDirectJNI())\n+      {\n+         newCallNode->setPreparedForDirectJNI();\n+      }\n+\n+   return newCallNode;\n+   }\n+\n ///////////////////////////////////////////////////////////////////////////////////////\n // multianewArrayEvaluator:  multi-dimensional new array of objects\n ///////////////////////////////////////////////////////////////////////////////////////\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::acall);\n-   TR::Register * targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n-   }\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = (TR_J9VMBase *)(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt()!=2)\n+      {\n+      traceMsg(cg->comp(), \"DCDCDCDC - multianewArrayEvaluator. More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      return performHelperCall(node, NULL, TR::acall, false, cg);\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // First generate the OOL code. This path will be used to handle the scenarios that we don't want to handle in JITT'ed code.\n+   TR_S390OutOfLineCodeSection *outlinedSlowPath = new (cg->trHeapMemory()) TR_S390OutOfLineCodeSection(oolFailLabel, cFlowRegionEnd, cg);\n+   cg->getS390OutOfLineCodeSectionList().push_front(outlinedSlowPath);\n+   outlinedSlowPath->swapInstructionListsWithCompilation();\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, oolFailLabel);\n+\n+   TR::Node *_callNode = createOutlinedCallNode(cg, node, TR::acall);\n+   TR::Register *targetReg2 = NULL;\n+   targetReg2 = TR::TreeEvaluator::performCall(_callNode, false, cg);\n+   cg->decReferenceCount(_callNode);\n+   generateRRInstruction(cg, TR::InstOpCode::LR, node, targetReg, targetReg2);\n+\n+   // After returning from the helper, branch back to mainline code.\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);\n+   // End of OOL\n+   outlinedSlowPath->swapInstructionListsWithCompilation();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODIxNjU2Mw=="}, "originalCommit": {"oid": "7fd870a28386d90aa97661f88b14126e8af243c6"}, "originalPosition": 132}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0ODAzMTA0OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxNzoxMjoxMlrOHuNd2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQyMToxMTo0OFrOH2x0LQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODIxNzE3Ng==", "bodyText": "This looks incorrect. What about 64-bit non-compressedrefs? Surely this will fail every time right? Does any of the testing catch this? If it doesn't I'm a bit worried we don't have adequate testing in this area.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r518217176", "createdAt": "2020-11-05T17:12:12Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,339 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n+TR::Node *\n+createOutlinedCallNode(TR::CodeGenerator *cg, TR::Node *callNode, TR::ILOpCodes callOp)\n+   {\n+   int32_t   i;\n+   TR::Node  *child;\n+\n+   TR::Node *newCallNode = TR::Node::createWithSymRef(callNode, callOp, callNode->getNumChildren(), callNode->getSymbolReference());\n+\n+   newCallNode->setReferenceCount(1);\n+\n+   for (i=0; i<callNode->getNumChildren(); i++)\n+      {\n+      child = callNode->getChild(i);\n+\n+      if (child->getRegister() != NULL)\n+         {\n+         // Child has already been evaluated outside this tree.\n+         //\n+         newCallNode->setAndIncChild(i, child);\n+         }\n+      else if (child->getOpCode().isLoadConst())\n+         {\n+         // Copy unevaluated constant nodes.\n+         //\n+         child = TR::Node::copy(child);\n+         child->setReferenceCount(1);\n+         newCallNode->setChild(i, child);\n+         }\n+      else\n+         {\n+         if ((child->getOpCodeValue() == TR::loadaddr) &&\n+             (child->getSymbolReference()->getSymbol()) &&\n+             (child->getSymbolReference()->getSymbol()->getStaticSymbol()))\n+            {\n+            child = TR::Node::copy(child);\n+            child->setReferenceCount(1);\n+            newCallNode->setChild(i, child);\n+            }\n+         else\n+            {\n+            // Be very conservative at this point, even though it is possible to make it less so.  For example, this will catch\n+            // the case of an unevaluated argument not persisting outside of the outlined region even though one of its subtrees will.\n+            (void)cg->evaluate(child);\n+\n+            // Do not decrement the reference count here.  It will be decremented when the call node is evaluated\n+            // again in the helper instruction stream.\n+            newCallNode->setAndIncChild(i, child);\n+            }\n+         }\n+      }\n+   if(callNode->isPreparedForDirectJNI())\n+      {\n+         newCallNode->setPreparedForDirectJNI();\n+      }\n+\n+   return newCallNode;\n+   }\n+\n ///////////////////////////////////////////////////////////////////////////////////////\n // multianewArrayEvaluator:  multi-dimensional new array of objects\n ///////////////////////////////////////////////////////////////////////////////////////\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::acall);\n-   TR::Register * targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n-   }\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = (TR_J9VMBase *)(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt()!=2)\n+      {\n+      traceMsg(cg->comp(), \"DCDCDCDC - multianewArrayEvaluator. More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      return performHelperCall(node, NULL, TR::acall, false, cg);\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // First generate the OOL code. This path will be used to handle the scenarios that we don't want to handle in JITT'ed code.\n+   TR_S390OutOfLineCodeSection *outlinedSlowPath = new (cg->trHeapMemory()) TR_S390OutOfLineCodeSection(oolFailLabel, cFlowRegionEnd, cg);\n+   cg->getS390OutOfLineCodeSectionList().push_front(outlinedSlowPath);\n+   outlinedSlowPath->swapInstructionListsWithCompilation();\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, oolFailLabel);\n+\n+   TR::Node *_callNode = createOutlinedCallNode(cg, node, TR::acall);\n+   TR::Register *targetReg2 = NULL;\n+   targetReg2 = TR::TreeEvaluator::performCall(_callNode, false, cg);\n+   cg->decReferenceCount(_callNode);\n+   generateRRInstruction(cg, TR::InstOpCode::LR, node, targetReg, targetReg2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fd870a28386d90aa97661f88b14126e8af243c6"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIwMTMyNQ==", "bodyText": "This should no longer be an issue: ff6da2b", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r527201325", "createdAt": "2020-11-19T21:11:48Z", "author": {"login": "dchopra001"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,339 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n+TR::Node *\n+createOutlinedCallNode(TR::CodeGenerator *cg, TR::Node *callNode, TR::ILOpCodes callOp)\n+   {\n+   int32_t   i;\n+   TR::Node  *child;\n+\n+   TR::Node *newCallNode = TR::Node::createWithSymRef(callNode, callOp, callNode->getNumChildren(), callNode->getSymbolReference());\n+\n+   newCallNode->setReferenceCount(1);\n+\n+   for (i=0; i<callNode->getNumChildren(); i++)\n+      {\n+      child = callNode->getChild(i);\n+\n+      if (child->getRegister() != NULL)\n+         {\n+         // Child has already been evaluated outside this tree.\n+         //\n+         newCallNode->setAndIncChild(i, child);\n+         }\n+      else if (child->getOpCode().isLoadConst())\n+         {\n+         // Copy unevaluated constant nodes.\n+         //\n+         child = TR::Node::copy(child);\n+         child->setReferenceCount(1);\n+         newCallNode->setChild(i, child);\n+         }\n+      else\n+         {\n+         if ((child->getOpCodeValue() == TR::loadaddr) &&\n+             (child->getSymbolReference()->getSymbol()) &&\n+             (child->getSymbolReference()->getSymbol()->getStaticSymbol()))\n+            {\n+            child = TR::Node::copy(child);\n+            child->setReferenceCount(1);\n+            newCallNode->setChild(i, child);\n+            }\n+         else\n+            {\n+            // Be very conservative at this point, even though it is possible to make it less so.  For example, this will catch\n+            // the case of an unevaluated argument not persisting outside of the outlined region even though one of its subtrees will.\n+            (void)cg->evaluate(child);\n+\n+            // Do not decrement the reference count here.  It will be decremented when the call node is evaluated\n+            // again in the helper instruction stream.\n+            newCallNode->setAndIncChild(i, child);\n+            }\n+         }\n+      }\n+   if(callNode->isPreparedForDirectJNI())\n+      {\n+         newCallNode->setPreparedForDirectJNI();\n+      }\n+\n+   return newCallNode;\n+   }\n+\n ///////////////////////////////////////////////////////////////////////////////////////\n // multianewArrayEvaluator:  multi-dimensional new array of objects\n ///////////////////////////////////////////////////////////////////////////////////////\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::acall);\n-   TR::Register * targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n-   }\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = (TR_J9VMBase *)(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt()!=2)\n+      {\n+      traceMsg(cg->comp(), \"DCDCDCDC - multianewArrayEvaluator. More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      return performHelperCall(node, NULL, TR::acall, false, cg);\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // First generate the OOL code. This path will be used to handle the scenarios that we don't want to handle in JITT'ed code.\n+   TR_S390OutOfLineCodeSection *outlinedSlowPath = new (cg->trHeapMemory()) TR_S390OutOfLineCodeSection(oolFailLabel, cFlowRegionEnd, cg);\n+   cg->getS390OutOfLineCodeSectionList().push_front(outlinedSlowPath);\n+   outlinedSlowPath->swapInstructionListsWithCompilation();\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, oolFailLabel);\n+\n+   TR::Node *_callNode = createOutlinedCallNode(cg, node, TR::acall);\n+   TR::Register *targetReg2 = NULL;\n+   targetReg2 = TR::TreeEvaluator::performCall(_callNode, false, cg);\n+   cg->decReferenceCount(_callNode);\n+   generateRRInstruction(cg, TR::InstOpCode::LR, node, targetReg, targetReg2);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODIxNzE3Ng=="}, "originalCommit": {"oid": "7fd870a28386d90aa97661f88b14126e8af243c6"}, "originalPosition": 127}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0ODAzNDY5OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxNzoxMzowMFrOHuNgJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQyMToxMjoxNFrOH2x1GA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODIxNzc2Ng==", "bodyText": "Extra new lines.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r518217766", "createdAt": "2020-11-05T17:13:00Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,339 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n+TR::Node *\n+createOutlinedCallNode(TR::CodeGenerator *cg, TR::Node *callNode, TR::ILOpCodes callOp)\n+   {\n+   int32_t   i;\n+   TR::Node  *child;\n+\n+   TR::Node *newCallNode = TR::Node::createWithSymRef(callNode, callOp, callNode->getNumChildren(), callNode->getSymbolReference());\n+\n+   newCallNode->setReferenceCount(1);\n+\n+   for (i=0; i<callNode->getNumChildren(); i++)\n+      {\n+      child = callNode->getChild(i);\n+\n+      if (child->getRegister() != NULL)\n+         {\n+         // Child has already been evaluated outside this tree.\n+         //\n+         newCallNode->setAndIncChild(i, child);\n+         }\n+      else if (child->getOpCode().isLoadConst())\n+         {\n+         // Copy unevaluated constant nodes.\n+         //\n+         child = TR::Node::copy(child);\n+         child->setReferenceCount(1);\n+         newCallNode->setChild(i, child);\n+         }\n+      else\n+         {\n+         if ((child->getOpCodeValue() == TR::loadaddr) &&\n+             (child->getSymbolReference()->getSymbol()) &&\n+             (child->getSymbolReference()->getSymbol()->getStaticSymbol()))\n+            {\n+            child = TR::Node::copy(child);\n+            child->setReferenceCount(1);\n+            newCallNode->setChild(i, child);\n+            }\n+         else\n+            {\n+            // Be very conservative at this point, even though it is possible to make it less so.  For example, this will catch\n+            // the case of an unevaluated argument not persisting outside of the outlined region even though one of its subtrees will.\n+            (void)cg->evaluate(child);\n+\n+            // Do not decrement the reference count here.  It will be decremented when the call node is evaluated\n+            // again in the helper instruction stream.\n+            newCallNode->setAndIncChild(i, child);\n+            }\n+         }\n+      }\n+   if(callNode->isPreparedForDirectJNI())\n+      {\n+         newCallNode->setPreparedForDirectJNI();\n+      }\n+\n+   return newCallNode;\n+   }\n+\n ///////////////////////////////////////////////////////////////////////////////////////\n // multianewArrayEvaluator:  multi-dimensional new array of objects\n ///////////////////////////////////////////////////////////////////////////////////////\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::acall);\n-   TR::Register * targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n-   }\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = (TR_J9VMBase *)(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt()!=2)\n+      {\n+      traceMsg(cg->comp(), \"DCDCDCDC - multianewArrayEvaluator. More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      return performHelperCall(node, NULL, TR::acall, false, cg);\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // First generate the OOL code. This path will be used to handle the scenarios that we don't want to handle in JITT'ed code.\n+   TR_S390OutOfLineCodeSection *outlinedSlowPath = new (cg->trHeapMemory()) TR_S390OutOfLineCodeSection(oolFailLabel, cFlowRegionEnd, cg);\n+   cg->getS390OutOfLineCodeSectionList().push_front(outlinedSlowPath);\n+   outlinedSlowPath->swapInstructionListsWithCompilation();\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, oolFailLabel);\n+\n+   TR::Node *_callNode = createOutlinedCallNode(cg, node, TR::acall);\n+   TR::Register *targetReg2 = NULL;\n+   targetReg2 = TR::TreeEvaluator::performCall(_callNode, false, cg);\n+   cg->decReferenceCount(_callNode);\n+   generateRRInstruction(cg, TR::InstOpCode::LR, node, targetReg, targetReg2);\n+\n+   // After returning from the helper, branch back to mainline code.\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);\n+   // End of OOL\n+   outlinedSlowPath->swapInstructionListsWithCompilation();\n \n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::LG, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));\n+\n+   TR::Register *secondDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::LG, node, secondDimLenReg, generateS390MemoryReference(dimsPtrReg, 0, cg));\n+\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fd870a28386d90aa97661f88b14126e8af243c6"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIwMTU2MA==", "bodyText": "I don't have a commit to point to for this one, but these new lines shouldn't be an issue anymore.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r527201560", "createdAt": "2020-11-19T21:12:14Z", "author": {"login": "dchopra001"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,339 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n+TR::Node *\n+createOutlinedCallNode(TR::CodeGenerator *cg, TR::Node *callNode, TR::ILOpCodes callOp)\n+   {\n+   int32_t   i;\n+   TR::Node  *child;\n+\n+   TR::Node *newCallNode = TR::Node::createWithSymRef(callNode, callOp, callNode->getNumChildren(), callNode->getSymbolReference());\n+\n+   newCallNode->setReferenceCount(1);\n+\n+   for (i=0; i<callNode->getNumChildren(); i++)\n+      {\n+      child = callNode->getChild(i);\n+\n+      if (child->getRegister() != NULL)\n+         {\n+         // Child has already been evaluated outside this tree.\n+         //\n+         newCallNode->setAndIncChild(i, child);\n+         }\n+      else if (child->getOpCode().isLoadConst())\n+         {\n+         // Copy unevaluated constant nodes.\n+         //\n+         child = TR::Node::copy(child);\n+         child->setReferenceCount(1);\n+         newCallNode->setChild(i, child);\n+         }\n+      else\n+         {\n+         if ((child->getOpCodeValue() == TR::loadaddr) &&\n+             (child->getSymbolReference()->getSymbol()) &&\n+             (child->getSymbolReference()->getSymbol()->getStaticSymbol()))\n+            {\n+            child = TR::Node::copy(child);\n+            child->setReferenceCount(1);\n+            newCallNode->setChild(i, child);\n+            }\n+         else\n+            {\n+            // Be very conservative at this point, even though it is possible to make it less so.  For example, this will catch\n+            // the case of an unevaluated argument not persisting outside of the outlined region even though one of its subtrees will.\n+            (void)cg->evaluate(child);\n+\n+            // Do not decrement the reference count here.  It will be decremented when the call node is evaluated\n+            // again in the helper instruction stream.\n+            newCallNode->setAndIncChild(i, child);\n+            }\n+         }\n+      }\n+   if(callNode->isPreparedForDirectJNI())\n+      {\n+         newCallNode->setPreparedForDirectJNI();\n+      }\n+\n+   return newCallNode;\n+   }\n+\n ///////////////////////////////////////////////////////////////////////////////////////\n // multianewArrayEvaluator:  multi-dimensional new array of objects\n ///////////////////////////////////////////////////////////////////////////////////////\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::acall);\n-   TR::Register * targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n-   }\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = (TR_J9VMBase *)(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt()!=2)\n+      {\n+      traceMsg(cg->comp(), \"DCDCDCDC - multianewArrayEvaluator. More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      return performHelperCall(node, NULL, TR::acall, false, cg);\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // First generate the OOL code. This path will be used to handle the scenarios that we don't want to handle in JITT'ed code.\n+   TR_S390OutOfLineCodeSection *outlinedSlowPath = new (cg->trHeapMemory()) TR_S390OutOfLineCodeSection(oolFailLabel, cFlowRegionEnd, cg);\n+   cg->getS390OutOfLineCodeSectionList().push_front(outlinedSlowPath);\n+   outlinedSlowPath->swapInstructionListsWithCompilation();\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, oolFailLabel);\n+\n+   TR::Node *_callNode = createOutlinedCallNode(cg, node, TR::acall);\n+   TR::Register *targetReg2 = NULL;\n+   targetReg2 = TR::TreeEvaluator::performCall(_callNode, false, cg);\n+   cg->decReferenceCount(_callNode);\n+   generateRRInstruction(cg, TR::InstOpCode::LR, node, targetReg, targetReg2);\n+\n+   // After returning from the helper, branch back to mainline code.\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);\n+   // End of OOL\n+   outlinedSlowPath->swapInstructionListsWithCompilation();\n \n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::LG, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));\n+\n+   TR::Register *secondDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::LG, node, secondDimLenReg, generateS390MemoryReference(dimsPtrReg, 0, cg));\n+\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODIxNzc2Ng=="}, "originalCommit": {"oid": "7fd870a28386d90aa97661f88b14126e8af243c6"}, "originalPosition": 141}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0ODA0NTg3OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxNzoxNTo0N1rOHuNnTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQyMToxMjo1NFrOH2x2eQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODIxOTU5Nw==", "bodyText": "I don't know enough about this opcode (multiANewArray), so I guess this is an opportunity for me to learn. What is the dimsPtrReg pointing to? It looks like a struct of two 64-bit values? Is this true even on 32-bit/compressedrefs? Could you describe what children of this evaluator represent?", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r518219597", "createdAt": "2020-11-05T17:15:47Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,339 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n+TR::Node *\n+createOutlinedCallNode(TR::CodeGenerator *cg, TR::Node *callNode, TR::ILOpCodes callOp)\n+   {\n+   int32_t   i;\n+   TR::Node  *child;\n+\n+   TR::Node *newCallNode = TR::Node::createWithSymRef(callNode, callOp, callNode->getNumChildren(), callNode->getSymbolReference());\n+\n+   newCallNode->setReferenceCount(1);\n+\n+   for (i=0; i<callNode->getNumChildren(); i++)\n+      {\n+      child = callNode->getChild(i);\n+\n+      if (child->getRegister() != NULL)\n+         {\n+         // Child has already been evaluated outside this tree.\n+         //\n+         newCallNode->setAndIncChild(i, child);\n+         }\n+      else if (child->getOpCode().isLoadConst())\n+         {\n+         // Copy unevaluated constant nodes.\n+         //\n+         child = TR::Node::copy(child);\n+         child->setReferenceCount(1);\n+         newCallNode->setChild(i, child);\n+         }\n+      else\n+         {\n+         if ((child->getOpCodeValue() == TR::loadaddr) &&\n+             (child->getSymbolReference()->getSymbol()) &&\n+             (child->getSymbolReference()->getSymbol()->getStaticSymbol()))\n+            {\n+            child = TR::Node::copy(child);\n+            child->setReferenceCount(1);\n+            newCallNode->setChild(i, child);\n+            }\n+         else\n+            {\n+            // Be very conservative at this point, even though it is possible to make it less so.  For example, this will catch\n+            // the case of an unevaluated argument not persisting outside of the outlined region even though one of its subtrees will.\n+            (void)cg->evaluate(child);\n+\n+            // Do not decrement the reference count here.  It will be decremented when the call node is evaluated\n+            // again in the helper instruction stream.\n+            newCallNode->setAndIncChild(i, child);\n+            }\n+         }\n+      }\n+   if(callNode->isPreparedForDirectJNI())\n+      {\n+         newCallNode->setPreparedForDirectJNI();\n+      }\n+\n+   return newCallNode;\n+   }\n+\n ///////////////////////////////////////////////////////////////////////////////////////\n // multianewArrayEvaluator:  multi-dimensional new array of objects\n ///////////////////////////////////////////////////////////////////////////////////////\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::acall);\n-   TR::Register * targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n-   }\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = (TR_J9VMBase *)(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt()!=2)\n+      {\n+      traceMsg(cg->comp(), \"DCDCDCDC - multianewArrayEvaluator. More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      return performHelperCall(node, NULL, TR::acall, false, cg);\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // First generate the OOL code. This path will be used to handle the scenarios that we don't want to handle in JITT'ed code.\n+   TR_S390OutOfLineCodeSection *outlinedSlowPath = new (cg->trHeapMemory()) TR_S390OutOfLineCodeSection(oolFailLabel, cFlowRegionEnd, cg);\n+   cg->getS390OutOfLineCodeSectionList().push_front(outlinedSlowPath);\n+   outlinedSlowPath->swapInstructionListsWithCompilation();\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, oolFailLabel);\n+\n+   TR::Node *_callNode = createOutlinedCallNode(cg, node, TR::acall);\n+   TR::Register *targetReg2 = NULL;\n+   targetReg2 = TR::TreeEvaluator::performCall(_callNode, false, cg);\n+   cg->decReferenceCount(_callNode);\n+   generateRRInstruction(cg, TR::InstOpCode::LR, node, targetReg, targetReg2);\n+\n+   // After returning from the helper, branch back to mainline code.\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);\n+   // End of OOL\n+   outlinedSlowPath->swapInstructionListsWithCompilation();\n \n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::LG, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fd870a28386d90aa97661f88b14126e8af243c6"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzI1NjgzOQ==", "bodyText": "Here's an example tree:\n n18n     (  0)  treetop                                                                              [     0x3ff7de09e40] bci=[-1,2,13] rc=0 vc=144 vn=- li=2 udi=- nc=1\n n16n     (  2)    multianewarray  jitAMultiANewArray[#36  helper Method] [flags 0x400 0x0 ] (X!=0 sharedMemory )  [     0x3ff7de09da0] bci=[-1,2,13] rc=2 vc=144 vn=- li=2 udi=- nc=3 flg=0x24\n n116n    (  1)      loadaddr  <auto slot -1>[#387  Auto] [flags 0x3 0x0 ]                            [     0x3ff7de86400] bci=[-1,2,13] rc=1 vc=144 vn=- li=- udi=- nc=0\n n17n     (  1)      iconst 2 (X!=0 X>=0 )                                                            [     0x3ff7de09df0] bci=[-1,2,13] rc=1 vc=144 vn=- li=2 udi=- nc=0 flg=0x104\n n15n     (  1)      loadaddr  [[I[#377  Static] [flags 0x18307 0x0 ]                                 [     0x3ff7de09d50] bci=[-1,2,13] rc=1 vc=144 vn=- li=2 udi=- nc=0\n\nThe first child points to a structure that holds the size of each dimension.\nThe second child represents the number of dimensions in the multidimensional array.\nThe third child holds the class of the array.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r523256839", "createdAt": "2020-11-13T22:00:55Z", "author": {"login": "dchopra001"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,339 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n+TR::Node *\n+createOutlinedCallNode(TR::CodeGenerator *cg, TR::Node *callNode, TR::ILOpCodes callOp)\n+   {\n+   int32_t   i;\n+   TR::Node  *child;\n+\n+   TR::Node *newCallNode = TR::Node::createWithSymRef(callNode, callOp, callNode->getNumChildren(), callNode->getSymbolReference());\n+\n+   newCallNode->setReferenceCount(1);\n+\n+   for (i=0; i<callNode->getNumChildren(); i++)\n+      {\n+      child = callNode->getChild(i);\n+\n+      if (child->getRegister() != NULL)\n+         {\n+         // Child has already been evaluated outside this tree.\n+         //\n+         newCallNode->setAndIncChild(i, child);\n+         }\n+      else if (child->getOpCode().isLoadConst())\n+         {\n+         // Copy unevaluated constant nodes.\n+         //\n+         child = TR::Node::copy(child);\n+         child->setReferenceCount(1);\n+         newCallNode->setChild(i, child);\n+         }\n+      else\n+         {\n+         if ((child->getOpCodeValue() == TR::loadaddr) &&\n+             (child->getSymbolReference()->getSymbol()) &&\n+             (child->getSymbolReference()->getSymbol()->getStaticSymbol()))\n+            {\n+            child = TR::Node::copy(child);\n+            child->setReferenceCount(1);\n+            newCallNode->setChild(i, child);\n+            }\n+         else\n+            {\n+            // Be very conservative at this point, even though it is possible to make it less so.  For example, this will catch\n+            // the case of an unevaluated argument not persisting outside of the outlined region even though one of its subtrees will.\n+            (void)cg->evaluate(child);\n+\n+            // Do not decrement the reference count here.  It will be decremented when the call node is evaluated\n+            // again in the helper instruction stream.\n+            newCallNode->setAndIncChild(i, child);\n+            }\n+         }\n+      }\n+   if(callNode->isPreparedForDirectJNI())\n+      {\n+         newCallNode->setPreparedForDirectJNI();\n+      }\n+\n+   return newCallNode;\n+   }\n+\n ///////////////////////////////////////////////////////////////////////////////////////\n // multianewArrayEvaluator:  multi-dimensional new array of objects\n ///////////////////////////////////////////////////////////////////////////////////////\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::acall);\n-   TR::Register * targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n-   }\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = (TR_J9VMBase *)(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt()!=2)\n+      {\n+      traceMsg(cg->comp(), \"DCDCDCDC - multianewArrayEvaluator. More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      return performHelperCall(node, NULL, TR::acall, false, cg);\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // First generate the OOL code. This path will be used to handle the scenarios that we don't want to handle in JITT'ed code.\n+   TR_S390OutOfLineCodeSection *outlinedSlowPath = new (cg->trHeapMemory()) TR_S390OutOfLineCodeSection(oolFailLabel, cFlowRegionEnd, cg);\n+   cg->getS390OutOfLineCodeSectionList().push_front(outlinedSlowPath);\n+   outlinedSlowPath->swapInstructionListsWithCompilation();\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, oolFailLabel);\n+\n+   TR::Node *_callNode = createOutlinedCallNode(cg, node, TR::acall);\n+   TR::Register *targetReg2 = NULL;\n+   targetReg2 = TR::TreeEvaluator::performCall(_callNode, false, cg);\n+   cg->decReferenceCount(_callNode);\n+   generateRRInstruction(cg, TR::InstOpCode::LR, node, targetReg, targetReg2);\n+\n+   // After returning from the helper, branch back to mainline code.\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);\n+   // End of OOL\n+   outlinedSlowPath->swapInstructionListsWithCompilation();\n \n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::LG, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODIxOTU5Nw=="}, "originalCommit": {"oid": "7fd870a28386d90aa97661f88b14126e8af243c6"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDM4MDQ3OQ==", "bodyText": "The first child points to a structure that holds the size of each dimension.\n\nSo it is an array of sizes. What is the type of array? i.e. how wide is each field? Is is 4 bytes? I see we restrict this evaluator to only a two dimensional multianewarray, so just making sure each size field is 4-bytes because we do a 8-byte load here.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r524380479", "createdAt": "2020-11-16T16:03:16Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,339 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n+TR::Node *\n+createOutlinedCallNode(TR::CodeGenerator *cg, TR::Node *callNode, TR::ILOpCodes callOp)\n+   {\n+   int32_t   i;\n+   TR::Node  *child;\n+\n+   TR::Node *newCallNode = TR::Node::createWithSymRef(callNode, callOp, callNode->getNumChildren(), callNode->getSymbolReference());\n+\n+   newCallNode->setReferenceCount(1);\n+\n+   for (i=0; i<callNode->getNumChildren(); i++)\n+      {\n+      child = callNode->getChild(i);\n+\n+      if (child->getRegister() != NULL)\n+         {\n+         // Child has already been evaluated outside this tree.\n+         //\n+         newCallNode->setAndIncChild(i, child);\n+         }\n+      else if (child->getOpCode().isLoadConst())\n+         {\n+         // Copy unevaluated constant nodes.\n+         //\n+         child = TR::Node::copy(child);\n+         child->setReferenceCount(1);\n+         newCallNode->setChild(i, child);\n+         }\n+      else\n+         {\n+         if ((child->getOpCodeValue() == TR::loadaddr) &&\n+             (child->getSymbolReference()->getSymbol()) &&\n+             (child->getSymbolReference()->getSymbol()->getStaticSymbol()))\n+            {\n+            child = TR::Node::copy(child);\n+            child->setReferenceCount(1);\n+            newCallNode->setChild(i, child);\n+            }\n+         else\n+            {\n+            // Be very conservative at this point, even though it is possible to make it less so.  For example, this will catch\n+            // the case of an unevaluated argument not persisting outside of the outlined region even though one of its subtrees will.\n+            (void)cg->evaluate(child);\n+\n+            // Do not decrement the reference count here.  It will be decremented when the call node is evaluated\n+            // again in the helper instruction stream.\n+            newCallNode->setAndIncChild(i, child);\n+            }\n+         }\n+      }\n+   if(callNode->isPreparedForDirectJNI())\n+      {\n+         newCallNode->setPreparedForDirectJNI();\n+      }\n+\n+   return newCallNode;\n+   }\n+\n ///////////////////////////////////////////////////////////////////////////////////////\n // multianewArrayEvaluator:  multi-dimensional new array of objects\n ///////////////////////////////////////////////////////////////////////////////////////\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::acall);\n-   TR::Register * targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n-   }\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = (TR_J9VMBase *)(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt()!=2)\n+      {\n+      traceMsg(cg->comp(), \"DCDCDCDC - multianewArrayEvaluator. More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      return performHelperCall(node, NULL, TR::acall, false, cg);\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // First generate the OOL code. This path will be used to handle the scenarios that we don't want to handle in JITT'ed code.\n+   TR_S390OutOfLineCodeSection *outlinedSlowPath = new (cg->trHeapMemory()) TR_S390OutOfLineCodeSection(oolFailLabel, cFlowRegionEnd, cg);\n+   cg->getS390OutOfLineCodeSectionList().push_front(outlinedSlowPath);\n+   outlinedSlowPath->swapInstructionListsWithCompilation();\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, oolFailLabel);\n+\n+   TR::Node *_callNode = createOutlinedCallNode(cg, node, TR::acall);\n+   TR::Register *targetReg2 = NULL;\n+   targetReg2 = TR::TreeEvaluator::performCall(_callNode, false, cg);\n+   cg->decReferenceCount(_callNode);\n+   generateRRInstruction(cg, TR::InstOpCode::LR, node, targetReg, targetReg2);\n+\n+   // After returning from the helper, branch back to mainline code.\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);\n+   // End of OOL\n+   outlinedSlowPath->swapInstructionListsWithCompilation();\n \n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::LG, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODIxOTU5Nw=="}, "originalCommit": {"oid": "7fd870a28386d90aa97661f88b14126e8af243c6"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDM5MTQ3Mw==", "bodyText": "I can confirm type is an int as per the Java lang. spec: https://docs.oracle.com/javase/specs/jls/se8/html/jls-10.html.\nThe LG is incorrect here and will be changed in my next commit.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r524391473", "createdAt": "2020-11-16T16:18:11Z", "author": {"login": "dchopra001"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,339 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n+TR::Node *\n+createOutlinedCallNode(TR::CodeGenerator *cg, TR::Node *callNode, TR::ILOpCodes callOp)\n+   {\n+   int32_t   i;\n+   TR::Node  *child;\n+\n+   TR::Node *newCallNode = TR::Node::createWithSymRef(callNode, callOp, callNode->getNumChildren(), callNode->getSymbolReference());\n+\n+   newCallNode->setReferenceCount(1);\n+\n+   for (i=0; i<callNode->getNumChildren(); i++)\n+      {\n+      child = callNode->getChild(i);\n+\n+      if (child->getRegister() != NULL)\n+         {\n+         // Child has already been evaluated outside this tree.\n+         //\n+         newCallNode->setAndIncChild(i, child);\n+         }\n+      else if (child->getOpCode().isLoadConst())\n+         {\n+         // Copy unevaluated constant nodes.\n+         //\n+         child = TR::Node::copy(child);\n+         child->setReferenceCount(1);\n+         newCallNode->setChild(i, child);\n+         }\n+      else\n+         {\n+         if ((child->getOpCodeValue() == TR::loadaddr) &&\n+             (child->getSymbolReference()->getSymbol()) &&\n+             (child->getSymbolReference()->getSymbol()->getStaticSymbol()))\n+            {\n+            child = TR::Node::copy(child);\n+            child->setReferenceCount(1);\n+            newCallNode->setChild(i, child);\n+            }\n+         else\n+            {\n+            // Be very conservative at this point, even though it is possible to make it less so.  For example, this will catch\n+            // the case of an unevaluated argument not persisting outside of the outlined region even though one of its subtrees will.\n+            (void)cg->evaluate(child);\n+\n+            // Do not decrement the reference count here.  It will be decremented when the call node is evaluated\n+            // again in the helper instruction stream.\n+            newCallNode->setAndIncChild(i, child);\n+            }\n+         }\n+      }\n+   if(callNode->isPreparedForDirectJNI())\n+      {\n+         newCallNode->setPreparedForDirectJNI();\n+      }\n+\n+   return newCallNode;\n+   }\n+\n ///////////////////////////////////////////////////////////////////////////////////////\n // multianewArrayEvaluator:  multi-dimensional new array of objects\n ///////////////////////////////////////////////////////////////////////////////////////\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::acall);\n-   TR::Register * targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n-   }\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = (TR_J9VMBase *)(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt()!=2)\n+      {\n+      traceMsg(cg->comp(), \"DCDCDCDC - multianewArrayEvaluator. More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      return performHelperCall(node, NULL, TR::acall, false, cg);\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // First generate the OOL code. This path will be used to handle the scenarios that we don't want to handle in JITT'ed code.\n+   TR_S390OutOfLineCodeSection *outlinedSlowPath = new (cg->trHeapMemory()) TR_S390OutOfLineCodeSection(oolFailLabel, cFlowRegionEnd, cg);\n+   cg->getS390OutOfLineCodeSectionList().push_front(outlinedSlowPath);\n+   outlinedSlowPath->swapInstructionListsWithCompilation();\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, oolFailLabel);\n+\n+   TR::Node *_callNode = createOutlinedCallNode(cg, node, TR::acall);\n+   TR::Register *targetReg2 = NULL;\n+   targetReg2 = TR::TreeEvaluator::performCall(_callNode, false, cg);\n+   cg->decReferenceCount(_callNode);\n+   generateRRInstruction(cg, TR::InstOpCode::LR, node, targetReg, targetReg2);\n+\n+   // After returning from the helper, branch back to mainline code.\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);\n+   // End of OOL\n+   outlinedSlowPath->swapInstructionListsWithCompilation();\n \n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::LG, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODIxOTU5Nw=="}, "originalCommit": {"oid": "7fd870a28386d90aa97661f88b14126e8af243c6"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIwMTkxMw==", "bodyText": "This should no longer be an issue: ff6da2b", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r527201913", "createdAt": "2020-11-19T21:12:54Z", "author": {"login": "dchopra001"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,339 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n+TR::Node *\n+createOutlinedCallNode(TR::CodeGenerator *cg, TR::Node *callNode, TR::ILOpCodes callOp)\n+   {\n+   int32_t   i;\n+   TR::Node  *child;\n+\n+   TR::Node *newCallNode = TR::Node::createWithSymRef(callNode, callOp, callNode->getNumChildren(), callNode->getSymbolReference());\n+\n+   newCallNode->setReferenceCount(1);\n+\n+   for (i=0; i<callNode->getNumChildren(); i++)\n+      {\n+      child = callNode->getChild(i);\n+\n+      if (child->getRegister() != NULL)\n+         {\n+         // Child has already been evaluated outside this tree.\n+         //\n+         newCallNode->setAndIncChild(i, child);\n+         }\n+      else if (child->getOpCode().isLoadConst())\n+         {\n+         // Copy unevaluated constant nodes.\n+         //\n+         child = TR::Node::copy(child);\n+         child->setReferenceCount(1);\n+         newCallNode->setChild(i, child);\n+         }\n+      else\n+         {\n+         if ((child->getOpCodeValue() == TR::loadaddr) &&\n+             (child->getSymbolReference()->getSymbol()) &&\n+             (child->getSymbolReference()->getSymbol()->getStaticSymbol()))\n+            {\n+            child = TR::Node::copy(child);\n+            child->setReferenceCount(1);\n+            newCallNode->setChild(i, child);\n+            }\n+         else\n+            {\n+            // Be very conservative at this point, even though it is possible to make it less so.  For example, this will catch\n+            // the case of an unevaluated argument not persisting outside of the outlined region even though one of its subtrees will.\n+            (void)cg->evaluate(child);\n+\n+            // Do not decrement the reference count here.  It will be decremented when the call node is evaluated\n+            // again in the helper instruction stream.\n+            newCallNode->setAndIncChild(i, child);\n+            }\n+         }\n+      }\n+   if(callNode->isPreparedForDirectJNI())\n+      {\n+         newCallNode->setPreparedForDirectJNI();\n+      }\n+\n+   return newCallNode;\n+   }\n+\n ///////////////////////////////////////////////////////////////////////////////////////\n // multianewArrayEvaluator:  multi-dimensional new array of objects\n ///////////////////////////////////////////////////////////////////////////////////////\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::acall);\n-   TR::Register * targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n-   }\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = (TR_J9VMBase *)(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt()!=2)\n+      {\n+      traceMsg(cg->comp(), \"DCDCDCDC - multianewArrayEvaluator. More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      return performHelperCall(node, NULL, TR::acall, false, cg);\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // First generate the OOL code. This path will be used to handle the scenarios that we don't want to handle in JITT'ed code.\n+   TR_S390OutOfLineCodeSection *outlinedSlowPath = new (cg->trHeapMemory()) TR_S390OutOfLineCodeSection(oolFailLabel, cFlowRegionEnd, cg);\n+   cg->getS390OutOfLineCodeSectionList().push_front(outlinedSlowPath);\n+   outlinedSlowPath->swapInstructionListsWithCompilation();\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, oolFailLabel);\n+\n+   TR::Node *_callNode = createOutlinedCallNode(cg, node, TR::acall);\n+   TR::Register *targetReg2 = NULL;\n+   targetReg2 = TR::TreeEvaluator::performCall(_callNode, false, cg);\n+   cg->decReferenceCount(_callNode);\n+   generateRRInstruction(cg, TR::InstOpCode::LR, node, targetReg, targetReg2);\n+\n+   // After returning from the helper, branch back to mainline code.\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);\n+   // End of OOL\n+   outlinedSlowPath->swapInstructionListsWithCompilation();\n \n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::LG, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODIxOTU5Nw=="}, "originalCommit": {"oid": "7fd870a28386d90aa97661f88b14126e8af243c6"}, "originalPosition": 136}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0ODA1NjUyOnYy", "diffSide": "RIGHT", "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxNzoxODoyMVrOHuNuFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQxNjoyMTowN1rOH0Gcdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODIyMTMzMw==", "bodyText": "We don't typically generate this instructions by themselves. We should use generateS390CompareAndBranchInstruction to mimic all the other uses. Also let's remove the unnecessary casts and extra parenthesis while here.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r518221333", "createdAt": "2020-11-05T17:18:21Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,339 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n+TR::Node *\n+createOutlinedCallNode(TR::CodeGenerator *cg, TR::Node *callNode, TR::ILOpCodes callOp)\n+   {\n+   int32_t   i;\n+   TR::Node  *child;\n+\n+   TR::Node *newCallNode = TR::Node::createWithSymRef(callNode, callOp, callNode->getNumChildren(), callNode->getSymbolReference());\n+\n+   newCallNode->setReferenceCount(1);\n+\n+   for (i=0; i<callNode->getNumChildren(); i++)\n+      {\n+      child = callNode->getChild(i);\n+\n+      if (child->getRegister() != NULL)\n+         {\n+         // Child has already been evaluated outside this tree.\n+         //\n+         newCallNode->setAndIncChild(i, child);\n+         }\n+      else if (child->getOpCode().isLoadConst())\n+         {\n+         // Copy unevaluated constant nodes.\n+         //\n+         child = TR::Node::copy(child);\n+         child->setReferenceCount(1);\n+         newCallNode->setChild(i, child);\n+         }\n+      else\n+         {\n+         if ((child->getOpCodeValue() == TR::loadaddr) &&\n+             (child->getSymbolReference()->getSymbol()) &&\n+             (child->getSymbolReference()->getSymbol()->getStaticSymbol()))\n+            {\n+            child = TR::Node::copy(child);\n+            child->setReferenceCount(1);\n+            newCallNode->setChild(i, child);\n+            }\n+         else\n+            {\n+            // Be very conservative at this point, even though it is possible to make it less so.  For example, this will catch\n+            // the case of an unevaluated argument not persisting outside of the outlined region even though one of its subtrees will.\n+            (void)cg->evaluate(child);\n+\n+            // Do not decrement the reference count here.  It will be decremented when the call node is evaluated\n+            // again in the helper instruction stream.\n+            newCallNode->setAndIncChild(i, child);\n+            }\n+         }\n+      }\n+   if(callNode->isPreparedForDirectJNI())\n+      {\n+         newCallNode->setPreparedForDirectJNI();\n+      }\n+\n+   return newCallNode;\n+   }\n+\n ///////////////////////////////////////////////////////////////////////////////////////\n // multianewArrayEvaluator:  multi-dimensional new array of objects\n ///////////////////////////////////////////////////////////////////////////////////////\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::acall);\n-   TR::Register * targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n-   }\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = (TR_J9VMBase *)(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt()!=2)\n+      {\n+      traceMsg(cg->comp(), \"DCDCDCDC - multianewArrayEvaluator. More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      return performHelperCall(node, NULL, TR::acall, false, cg);\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // First generate the OOL code. This path will be used to handle the scenarios that we don't want to handle in JITT'ed code.\n+   TR_S390OutOfLineCodeSection *outlinedSlowPath = new (cg->trHeapMemory()) TR_S390OutOfLineCodeSection(oolFailLabel, cFlowRegionEnd, cg);\n+   cg->getS390OutOfLineCodeSectionList().push_front(outlinedSlowPath);\n+   outlinedSlowPath->swapInstructionListsWithCompilation();\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, oolFailLabel);\n+\n+   TR::Node *_callNode = createOutlinedCallNode(cg, node, TR::acall);\n+   TR::Register *targetReg2 = NULL;\n+   targetReg2 = TR::TreeEvaluator::performCall(_callNode, false, cg);\n+   cg->decReferenceCount(_callNode);\n+   generateRRInstruction(cg, TR::InstOpCode::LR, node, targetReg, targetReg2);\n+\n+   // After returning from the helper, branch back to mainline code.\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);\n+   // End of OOL\n+   outlinedSlowPath->swapInstructionListsWithCompilation();\n \n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::LG, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));\n+\n+   TR::Register *secondDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::LG, node, secondDimLenReg, generateS390MemoryReference(dimsPtrReg, 0, cg));\n+\n+\n+   // Check to see if second dimension is indeed 0. If yes, then proceed to handle the case here. Otherwise jump to OOL code to perform the call.\n+   generateRIEInstruction(cg, TR::InstOpCode::CLGIJ, node, secondDimLenReg, (int8_t)0, oolFailLabel, (TR::InstOpCode::COND_BNE));\n+\n+   // Now check to see if first dimension is also 0. If no, then jump to nonZeroFirstDimLabel to handle it. Otherwise continue below to handle the case when length for both dimensions is 0.\n+   generateRIEInstruction(cg, TR::InstOpCode::CLGIJ, node, firstDimLenReg, (int8_t)0, nonZeroFirstDimLabel, (TR::InstOpCode::COND_BNE));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fd870a28386d90aa97661f88b14126e8af243c6"}, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzAzMDk0Mw==", "bodyText": "Removing the casts causes an ambiguous call to overloaded function error. Here are the error details:\nerror: call of overloaded \u2018generateRIEInstruction(TR::CodeGenerator*&, OMR::InstOpCode::Mnemonic, TR::Node*&, TR::Register*&, int, TR::LabelSymbol*&, OMR::Z::InstOpCode::S390BranchCondition)\u2019 is ambiguous\n    generateRIEInstruction(cg, TR::InstOpCode::CLGIJ, node, firstDimLenReg, 0, nonZeroFirstDimLabel, (TR::InstOpCode::COND_BNE));\n\nCandidates:\nS390GenerateInstructions.hpp:913:19: note: candidate: TR::Instruction* generateRIEInstruction(TR::CodeGenerator*, OMR::InstOpCode::Mnemonic, TR::Node*, TR::Register*, TR::Register*, TR::LabelSymbol*, OMR::Z::InstOpCode::S390BranchCondition, TR::Instruction*)\n\nS390GenerateInstructions.hpp:934:19: note: candidate: TR::Instruction* generateRIEInstruction(TR::CodeGenerator*, OMR::InstOpCode::Mnemonic, TR::Node*, TR::Register*, int8_t, TR::LabelSymbol*, OMR::Z::InstOpCode::S390BranchCondition, TR::Instruction*)", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r523030943", "createdAt": "2020-11-13T15:39:57Z", "author": {"login": "dchopra001"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,339 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n+TR::Node *\n+createOutlinedCallNode(TR::CodeGenerator *cg, TR::Node *callNode, TR::ILOpCodes callOp)\n+   {\n+   int32_t   i;\n+   TR::Node  *child;\n+\n+   TR::Node *newCallNode = TR::Node::createWithSymRef(callNode, callOp, callNode->getNumChildren(), callNode->getSymbolReference());\n+\n+   newCallNode->setReferenceCount(1);\n+\n+   for (i=0; i<callNode->getNumChildren(); i++)\n+      {\n+      child = callNode->getChild(i);\n+\n+      if (child->getRegister() != NULL)\n+         {\n+         // Child has already been evaluated outside this tree.\n+         //\n+         newCallNode->setAndIncChild(i, child);\n+         }\n+      else if (child->getOpCode().isLoadConst())\n+         {\n+         // Copy unevaluated constant nodes.\n+         //\n+         child = TR::Node::copy(child);\n+         child->setReferenceCount(1);\n+         newCallNode->setChild(i, child);\n+         }\n+      else\n+         {\n+         if ((child->getOpCodeValue() == TR::loadaddr) &&\n+             (child->getSymbolReference()->getSymbol()) &&\n+             (child->getSymbolReference()->getSymbol()->getStaticSymbol()))\n+            {\n+            child = TR::Node::copy(child);\n+            child->setReferenceCount(1);\n+            newCallNode->setChild(i, child);\n+            }\n+         else\n+            {\n+            // Be very conservative at this point, even though it is possible to make it less so.  For example, this will catch\n+            // the case of an unevaluated argument not persisting outside of the outlined region even though one of its subtrees will.\n+            (void)cg->evaluate(child);\n+\n+            // Do not decrement the reference count here.  It will be decremented when the call node is evaluated\n+            // again in the helper instruction stream.\n+            newCallNode->setAndIncChild(i, child);\n+            }\n+         }\n+      }\n+   if(callNode->isPreparedForDirectJNI())\n+      {\n+         newCallNode->setPreparedForDirectJNI();\n+      }\n+\n+   return newCallNode;\n+   }\n+\n ///////////////////////////////////////////////////////////////////////////////////////\n // multianewArrayEvaluator:  multi-dimensional new array of objects\n ///////////////////////////////////////////////////////////////////////////////////////\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::acall);\n-   TR::Register * targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n-   }\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = (TR_J9VMBase *)(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt()!=2)\n+      {\n+      traceMsg(cg->comp(), \"DCDCDCDC - multianewArrayEvaluator. More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      return performHelperCall(node, NULL, TR::acall, false, cg);\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // First generate the OOL code. This path will be used to handle the scenarios that we don't want to handle in JITT'ed code.\n+   TR_S390OutOfLineCodeSection *outlinedSlowPath = new (cg->trHeapMemory()) TR_S390OutOfLineCodeSection(oolFailLabel, cFlowRegionEnd, cg);\n+   cg->getS390OutOfLineCodeSectionList().push_front(outlinedSlowPath);\n+   outlinedSlowPath->swapInstructionListsWithCompilation();\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, oolFailLabel);\n+\n+   TR::Node *_callNode = createOutlinedCallNode(cg, node, TR::acall);\n+   TR::Register *targetReg2 = NULL;\n+   targetReg2 = TR::TreeEvaluator::performCall(_callNode, false, cg);\n+   cg->decReferenceCount(_callNode);\n+   generateRRInstruction(cg, TR::InstOpCode::LR, node, targetReg, targetReg2);\n+\n+   // After returning from the helper, branch back to mainline code.\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);\n+   // End of OOL\n+   outlinedSlowPath->swapInstructionListsWithCompilation();\n \n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::LG, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));\n+\n+   TR::Register *secondDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::LG, node, secondDimLenReg, generateS390MemoryReference(dimsPtrReg, 0, cg));\n+\n+\n+   // Check to see if second dimension is indeed 0. If yes, then proceed to handle the case here. Otherwise jump to OOL code to perform the call.\n+   generateRIEInstruction(cg, TR::InstOpCode::CLGIJ, node, secondDimLenReg, (int8_t)0, oolFailLabel, (TR::InstOpCode::COND_BNE));\n+\n+   // Now check to see if first dimension is also 0. If no, then jump to nonZeroFirstDimLabel to handle it. Otherwise continue below to handle the case when length for both dimensions is 0.\n+   generateRIEInstruction(cg, TR::InstOpCode::CLGIJ, node, firstDimLenReg, (int8_t)0, nonZeroFirstDimLabel, (TR::InstOpCode::COND_BNE));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODIyMTMzMw=="}, "originalCommit": {"oid": "7fd870a28386d90aa97661f88b14126e8af243c6"}, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDM4NTQ0OA==", "bodyText": "Right. Special case because of NULL and 0 alias. Let's follow an existing example using generateS390CompareAndBranchInstruction:\nhttps://github.com/eclipse/openj9/blob/547bb8e04985d8043443b977ef979eb183139da6/runtime/compiler/z/codegen/J9TreeEvaluator.cpp#L602", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r524385448", "createdAt": "2020-11-16T16:10:05Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,339 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n+TR::Node *\n+createOutlinedCallNode(TR::CodeGenerator *cg, TR::Node *callNode, TR::ILOpCodes callOp)\n+   {\n+   int32_t   i;\n+   TR::Node  *child;\n+\n+   TR::Node *newCallNode = TR::Node::createWithSymRef(callNode, callOp, callNode->getNumChildren(), callNode->getSymbolReference());\n+\n+   newCallNode->setReferenceCount(1);\n+\n+   for (i=0; i<callNode->getNumChildren(); i++)\n+      {\n+      child = callNode->getChild(i);\n+\n+      if (child->getRegister() != NULL)\n+         {\n+         // Child has already been evaluated outside this tree.\n+         //\n+         newCallNode->setAndIncChild(i, child);\n+         }\n+      else if (child->getOpCode().isLoadConst())\n+         {\n+         // Copy unevaluated constant nodes.\n+         //\n+         child = TR::Node::copy(child);\n+         child->setReferenceCount(1);\n+         newCallNode->setChild(i, child);\n+         }\n+      else\n+         {\n+         if ((child->getOpCodeValue() == TR::loadaddr) &&\n+             (child->getSymbolReference()->getSymbol()) &&\n+             (child->getSymbolReference()->getSymbol()->getStaticSymbol()))\n+            {\n+            child = TR::Node::copy(child);\n+            child->setReferenceCount(1);\n+            newCallNode->setChild(i, child);\n+            }\n+         else\n+            {\n+            // Be very conservative at this point, even though it is possible to make it less so.  For example, this will catch\n+            // the case of an unevaluated argument not persisting outside of the outlined region even though one of its subtrees will.\n+            (void)cg->evaluate(child);\n+\n+            // Do not decrement the reference count here.  It will be decremented when the call node is evaluated\n+            // again in the helper instruction stream.\n+            newCallNode->setAndIncChild(i, child);\n+            }\n+         }\n+      }\n+   if(callNode->isPreparedForDirectJNI())\n+      {\n+         newCallNode->setPreparedForDirectJNI();\n+      }\n+\n+   return newCallNode;\n+   }\n+\n ///////////////////////////////////////////////////////////////////////////////////////\n // multianewArrayEvaluator:  multi-dimensional new array of objects\n ///////////////////////////////////////////////////////////////////////////////////////\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::acall);\n-   TR::Register * targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n-   }\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = (TR_J9VMBase *)(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt()!=2)\n+      {\n+      traceMsg(cg->comp(), \"DCDCDCDC - multianewArrayEvaluator. More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      return performHelperCall(node, NULL, TR::acall, false, cg);\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // First generate the OOL code. This path will be used to handle the scenarios that we don't want to handle in JITT'ed code.\n+   TR_S390OutOfLineCodeSection *outlinedSlowPath = new (cg->trHeapMemory()) TR_S390OutOfLineCodeSection(oolFailLabel, cFlowRegionEnd, cg);\n+   cg->getS390OutOfLineCodeSectionList().push_front(outlinedSlowPath);\n+   outlinedSlowPath->swapInstructionListsWithCompilation();\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, oolFailLabel);\n+\n+   TR::Node *_callNode = createOutlinedCallNode(cg, node, TR::acall);\n+   TR::Register *targetReg2 = NULL;\n+   targetReg2 = TR::TreeEvaluator::performCall(_callNode, false, cg);\n+   cg->decReferenceCount(_callNode);\n+   generateRRInstruction(cg, TR::InstOpCode::LR, node, targetReg, targetReg2);\n+\n+   // After returning from the helper, branch back to mainline code.\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);\n+   // End of OOL\n+   outlinedSlowPath->swapInstructionListsWithCompilation();\n \n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::LG, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));\n+\n+   TR::Register *secondDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::LG, node, secondDimLenReg, generateS390MemoryReference(dimsPtrReg, 0, cg));\n+\n+\n+   // Check to see if second dimension is indeed 0. If yes, then proceed to handle the case here. Otherwise jump to OOL code to perform the call.\n+   generateRIEInstruction(cg, TR::InstOpCode::CLGIJ, node, secondDimLenReg, (int8_t)0, oolFailLabel, (TR::InstOpCode::COND_BNE));\n+\n+   // Now check to see if first dimension is also 0. If no, then jump to nonZeroFirstDimLabel to handle it. Otherwise continue below to handle the case when length for both dimensions is 0.\n+   generateRIEInstruction(cg, TR::InstOpCode::CLGIJ, node, firstDimLenReg, (int8_t)0, nonZeroFirstDimLabel, (TR::InstOpCode::COND_BNE));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODIyMTMzMw=="}, "originalCommit": {"oid": "7fd870a28386d90aa97661f88b14126e8af243c6"}, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDM5MzU5MA==", "bodyText": "This will be fixed in my next commit. We won't need to worry about the casts as I'll be using generateS390CompareAndBranchInstruction", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r524393590", "createdAt": "2020-11-16T16:21:07Z", "author": {"login": "dchopra001"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,339 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n+TR::Node *\n+createOutlinedCallNode(TR::CodeGenerator *cg, TR::Node *callNode, TR::ILOpCodes callOp)\n+   {\n+   int32_t   i;\n+   TR::Node  *child;\n+\n+   TR::Node *newCallNode = TR::Node::createWithSymRef(callNode, callOp, callNode->getNumChildren(), callNode->getSymbolReference());\n+\n+   newCallNode->setReferenceCount(1);\n+\n+   for (i=0; i<callNode->getNumChildren(); i++)\n+      {\n+      child = callNode->getChild(i);\n+\n+      if (child->getRegister() != NULL)\n+         {\n+         // Child has already been evaluated outside this tree.\n+         //\n+         newCallNode->setAndIncChild(i, child);\n+         }\n+      else if (child->getOpCode().isLoadConst())\n+         {\n+         // Copy unevaluated constant nodes.\n+         //\n+         child = TR::Node::copy(child);\n+         child->setReferenceCount(1);\n+         newCallNode->setChild(i, child);\n+         }\n+      else\n+         {\n+         if ((child->getOpCodeValue() == TR::loadaddr) &&\n+             (child->getSymbolReference()->getSymbol()) &&\n+             (child->getSymbolReference()->getSymbol()->getStaticSymbol()))\n+            {\n+            child = TR::Node::copy(child);\n+            child->setReferenceCount(1);\n+            newCallNode->setChild(i, child);\n+            }\n+         else\n+            {\n+            // Be very conservative at this point, even though it is possible to make it less so.  For example, this will catch\n+            // the case of an unevaluated argument not persisting outside of the outlined region even though one of its subtrees will.\n+            (void)cg->evaluate(child);\n+\n+            // Do not decrement the reference count here.  It will be decremented when the call node is evaluated\n+            // again in the helper instruction stream.\n+            newCallNode->setAndIncChild(i, child);\n+            }\n+         }\n+      }\n+   if(callNode->isPreparedForDirectJNI())\n+      {\n+         newCallNode->setPreparedForDirectJNI();\n+      }\n+\n+   return newCallNode;\n+   }\n+\n ///////////////////////////////////////////////////////////////////////////////////////\n // multianewArrayEvaluator:  multi-dimensional new array of objects\n ///////////////////////////////////////////////////////////////////////////////////////\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::acall);\n-   TR::Register * targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n-   }\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = (TR_J9VMBase *)(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt()!=2)\n+      {\n+      traceMsg(cg->comp(), \"DCDCDCDC - multianewArrayEvaluator. More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      return performHelperCall(node, NULL, TR::acall, false, cg);\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // First generate the OOL code. This path will be used to handle the scenarios that we don't want to handle in JITT'ed code.\n+   TR_S390OutOfLineCodeSection *outlinedSlowPath = new (cg->trHeapMemory()) TR_S390OutOfLineCodeSection(oolFailLabel, cFlowRegionEnd, cg);\n+   cg->getS390OutOfLineCodeSectionList().push_front(outlinedSlowPath);\n+   outlinedSlowPath->swapInstructionListsWithCompilation();\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, oolFailLabel);\n+\n+   TR::Node *_callNode = createOutlinedCallNode(cg, node, TR::acall);\n+   TR::Register *targetReg2 = NULL;\n+   targetReg2 = TR::TreeEvaluator::performCall(_callNode, false, cg);\n+   cg->decReferenceCount(_callNode);\n+   generateRRInstruction(cg, TR::InstOpCode::LR, node, targetReg, targetReg2);\n+\n+   // After returning from the helper, branch back to mainline code.\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);\n+   // End of OOL\n+   outlinedSlowPath->swapInstructionListsWithCompilation();\n \n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::LG, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));\n+\n+   TR::Register *secondDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::LG, node, secondDimLenReg, generateS390MemoryReference(dimsPtrReg, 0, cg));\n+\n+\n+   // Check to see if second dimension is indeed 0. If yes, then proceed to handle the case here. Otherwise jump to OOL code to perform the call.\n+   generateRIEInstruction(cg, TR::InstOpCode::CLGIJ, node, secondDimLenReg, (int8_t)0, oolFailLabel, (TR::InstOpCode::COND_BNE));\n+\n+   // Now check to see if first dimension is also 0. If no, then jump to nonZeroFirstDimLabel to handle it. Otherwise continue below to handle the case when length for both dimensions is 0.\n+   generateRIEInstruction(cg, TR::InstOpCode::CLGIJ, node, firstDimLenReg, (int8_t)0, nonZeroFirstDimLabel, (TR::InstOpCode::COND_BNE));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODIyMTMzMw=="}, "originalCommit": {"oid": "7fd870a28386d90aa97661f88b14126e8af243c6"}, "originalPosition": 146}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0ODA2MDkzOnYy", "diffSide": "RIGHT", "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxNzoxOToyNVrOHuNwyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxNzoxOToyNVrOHuNwyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODIyMjAyNw==", "bodyText": "I think this clouds the evaluator. When generating a trace log if I see a label I'd expect there is an incoming branch somewhere. So this will definitely confuse readers. If you want to separate code and organize it, just use a comment.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r518222027", "createdAt": "2020-11-05T17:19:25Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,339 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n+TR::Node *\n+createOutlinedCallNode(TR::CodeGenerator *cg, TR::Node *callNode, TR::ILOpCodes callOp)\n+   {\n+   int32_t   i;\n+   TR::Node  *child;\n+\n+   TR::Node *newCallNode = TR::Node::createWithSymRef(callNode, callOp, callNode->getNumChildren(), callNode->getSymbolReference());\n+\n+   newCallNode->setReferenceCount(1);\n+\n+   for (i=0; i<callNode->getNumChildren(); i++)\n+      {\n+      child = callNode->getChild(i);\n+\n+      if (child->getRegister() != NULL)\n+         {\n+         // Child has already been evaluated outside this tree.\n+         //\n+         newCallNode->setAndIncChild(i, child);\n+         }\n+      else if (child->getOpCode().isLoadConst())\n+         {\n+         // Copy unevaluated constant nodes.\n+         //\n+         child = TR::Node::copy(child);\n+         child->setReferenceCount(1);\n+         newCallNode->setChild(i, child);\n+         }\n+      else\n+         {\n+         if ((child->getOpCodeValue() == TR::loadaddr) &&\n+             (child->getSymbolReference()->getSymbol()) &&\n+             (child->getSymbolReference()->getSymbol()->getStaticSymbol()))\n+            {\n+            child = TR::Node::copy(child);\n+            child->setReferenceCount(1);\n+            newCallNode->setChild(i, child);\n+            }\n+         else\n+            {\n+            // Be very conservative at this point, even though it is possible to make it less so.  For example, this will catch\n+            // the case of an unevaluated argument not persisting outside of the outlined region even though one of its subtrees will.\n+            (void)cg->evaluate(child);\n+\n+            // Do not decrement the reference count here.  It will be decremented when the call node is evaluated\n+            // again in the helper instruction stream.\n+            newCallNode->setAndIncChild(i, child);\n+            }\n+         }\n+      }\n+   if(callNode->isPreparedForDirectJNI())\n+      {\n+         newCallNode->setPreparedForDirectJNI();\n+      }\n+\n+   return newCallNode;\n+   }\n+\n ///////////////////////////////////////////////////////////////////////////////////////\n // multianewArrayEvaluator:  multi-dimensional new array of objects\n ///////////////////////////////////////////////////////////////////////////////////////\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::acall);\n-   TR::Register * targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n-   }\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = (TR_J9VMBase *)(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt()!=2)\n+      {\n+      traceMsg(cg->comp(), \"DCDCDCDC - multianewArrayEvaluator. More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      return performHelperCall(node, NULL, TR::acall, false, cg);\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // First generate the OOL code. This path will be used to handle the scenarios that we don't want to handle in JITT'ed code.\n+   TR_S390OutOfLineCodeSection *outlinedSlowPath = new (cg->trHeapMemory()) TR_S390OutOfLineCodeSection(oolFailLabel, cFlowRegionEnd, cg);\n+   cg->getS390OutOfLineCodeSectionList().push_front(outlinedSlowPath);\n+   outlinedSlowPath->swapInstructionListsWithCompilation();\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, oolFailLabel);\n+\n+   TR::Node *_callNode = createOutlinedCallNode(cg, node, TR::acall);\n+   TR::Register *targetReg2 = NULL;\n+   targetReg2 = TR::TreeEvaluator::performCall(_callNode, false, cg);\n+   cg->decReferenceCount(_callNode);\n+   generateRRInstruction(cg, TR::InstOpCode::LR, node, targetReg, targetReg2);\n+\n+   // After returning from the helper, branch back to mainline code.\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);\n+   // End of OOL\n+   outlinedSlowPath->swapInstructionListsWithCompilation();\n \n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::LG, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));\n+\n+   TR::Register *secondDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::LG, node, secondDimLenReg, generateS390MemoryReference(dimsPtrReg, 0, cg));\n+\n+\n+   // Check to see if second dimension is indeed 0. If yes, then proceed to handle the case here. Otherwise jump to OOL code to perform the call.\n+   generateRIEInstruction(cg, TR::InstOpCode::CLGIJ, node, secondDimLenReg, (int8_t)0, oolFailLabel, (TR::InstOpCode::COND_BNE));\n+\n+   // Now check to see if first dimension is also 0. If no, then jump to nonZeroFirstDimLabel to handle it. Otherwise continue below to handle the case when length for both dimensions is 0.\n+   generateRIEInstruction(cg, TR::InstOpCode::CLGIJ, node, firstDimLenReg, (int8_t)0, nonZeroFirstDimLabel, (TR::InstOpCode::COND_BNE));\n+\n+   // TODO: We don't need this label. But it's good for organizing the different paths for now.\n+   TR::LabelSymbol *firstDimZeroLabel = generateLabelSymbol(cg);\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, firstDimZeroLabel);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fd870a28386d90aa97661f88b14126e8af243c6"}, "originalPosition": 150}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0ODA4MDcxOnYy", "diffSide": "RIGHT", "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxNzoyNDoxNlrOHuN9Tw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQyMzoyMjozMlrOH22BEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODIyNTIzMQ==", "bodyText": "We don't need a register for this. We can use MVHI / MVGHI. Also does this even work under gencon? What would those two fej9->get* APIs return in gencon?", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r518225231", "createdAt": "2020-11-05T17:24:16Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,339 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n+TR::Node *\n+createOutlinedCallNode(TR::CodeGenerator *cg, TR::Node *callNode, TR::ILOpCodes callOp)\n+   {\n+   int32_t   i;\n+   TR::Node  *child;\n+\n+   TR::Node *newCallNode = TR::Node::createWithSymRef(callNode, callOp, callNode->getNumChildren(), callNode->getSymbolReference());\n+\n+   newCallNode->setReferenceCount(1);\n+\n+   for (i=0; i<callNode->getNumChildren(); i++)\n+      {\n+      child = callNode->getChild(i);\n+\n+      if (child->getRegister() != NULL)\n+         {\n+         // Child has already been evaluated outside this tree.\n+         //\n+         newCallNode->setAndIncChild(i, child);\n+         }\n+      else if (child->getOpCode().isLoadConst())\n+         {\n+         // Copy unevaluated constant nodes.\n+         //\n+         child = TR::Node::copy(child);\n+         child->setReferenceCount(1);\n+         newCallNode->setChild(i, child);\n+         }\n+      else\n+         {\n+         if ((child->getOpCodeValue() == TR::loadaddr) &&\n+             (child->getSymbolReference()->getSymbol()) &&\n+             (child->getSymbolReference()->getSymbol()->getStaticSymbol()))\n+            {\n+            child = TR::Node::copy(child);\n+            child->setReferenceCount(1);\n+            newCallNode->setChild(i, child);\n+            }\n+         else\n+            {\n+            // Be very conservative at this point, even though it is possible to make it less so.  For example, this will catch\n+            // the case of an unevaluated argument not persisting outside of the outlined region even though one of its subtrees will.\n+            (void)cg->evaluate(child);\n+\n+            // Do not decrement the reference count here.  It will be decremented when the call node is evaluated\n+            // again in the helper instruction stream.\n+            newCallNode->setAndIncChild(i, child);\n+            }\n+         }\n+      }\n+   if(callNode->isPreparedForDirectJNI())\n+      {\n+         newCallNode->setPreparedForDirectJNI();\n+      }\n+\n+   return newCallNode;\n+   }\n+\n ///////////////////////////////////////////////////////////////////////////////////////\n // multianewArrayEvaluator:  multi-dimensional new array of objects\n ///////////////////////////////////////////////////////////////////////////////////////\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::acall);\n-   TR::Register * targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n-   }\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = (TR_J9VMBase *)(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt()!=2)\n+      {\n+      traceMsg(cg->comp(), \"DCDCDCDC - multianewArrayEvaluator. More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      return performHelperCall(node, NULL, TR::acall, false, cg);\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // First generate the OOL code. This path will be used to handle the scenarios that we don't want to handle in JITT'ed code.\n+   TR_S390OutOfLineCodeSection *outlinedSlowPath = new (cg->trHeapMemory()) TR_S390OutOfLineCodeSection(oolFailLabel, cFlowRegionEnd, cg);\n+   cg->getS390OutOfLineCodeSectionList().push_front(outlinedSlowPath);\n+   outlinedSlowPath->swapInstructionListsWithCompilation();\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, oolFailLabel);\n+\n+   TR::Node *_callNode = createOutlinedCallNode(cg, node, TR::acall);\n+   TR::Register *targetReg2 = NULL;\n+   targetReg2 = TR::TreeEvaluator::performCall(_callNode, false, cg);\n+   cg->decReferenceCount(_callNode);\n+   generateRRInstruction(cg, TR::InstOpCode::LR, node, targetReg, targetReg2);\n+\n+   // After returning from the helper, branch back to mainline code.\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);\n+   // End of OOL\n+   outlinedSlowPath->swapInstructionListsWithCompilation();\n \n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::LG, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));\n+\n+   TR::Register *secondDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::LG, node, secondDimLenReg, generateS390MemoryReference(dimsPtrReg, 0, cg));\n+\n+\n+   // Check to see if second dimension is indeed 0. If yes, then proceed to handle the case here. Otherwise jump to OOL code to perform the call.\n+   generateRIEInstruction(cg, TR::InstOpCode::CLGIJ, node, secondDimLenReg, (int8_t)0, oolFailLabel, (TR::InstOpCode::COND_BNE));\n+\n+   // Now check to see if first dimension is also 0. If no, then jump to nonZeroFirstDimLabel to handle it. Otherwise continue below to handle the case when length for both dimensions is 0.\n+   generateRIEInstruction(cg, TR::InstOpCode::CLGIJ, node, firstDimLenReg, (int8_t)0, nonZeroFirstDimLabel, (TR::InstOpCode::COND_BNE));\n+\n+   // TODO: We don't need this label. But it's good for organizing the different paths for now.\n+   TR::LabelSymbol *firstDimZeroLabel = generateLabelSymbol(cg);\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, firstDimZeroLabel);\n+\n+   // First Dim zero, only allocate 1 zero-length object array\n+   int32_t zeroArraySize = TR::Compiler->om.discontiguousArrayHeaderSizeInBytes();\n+   TR::Register *vmThreadReg = cg->getMethodMetaDataRealRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, targetReg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+\n+   // Branch to OOL if there's not enough space for an array of size 0.\n+   TR::Register *temp1Reg = cg->allocateRegister();\n+   generateRIEInstruction(cg, TR::InstOpCode::getAddHalfWordImmDistinctOperandOpCode(), node, temp1Reg, targetReg, zeroArraySize);\n+   generateRXInstruction(cg, TR::InstOpCode::getCmpLogicalOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapTop), cg));\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BH, node, oolFailLabel);\n+\n+   // If there's enough space, then we can continue to allocate.\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+   \n+   // Init class\n+   bool use64BitClasses = comp->target().is64Bit() && !TR::Compiler->om.generateCompressedObjectHeaders();\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, classReg, generateS390MemoryReference(targetReg, TR::Compiler->om.offsetOfObjectVftField(), cg));\n+   \n+   // Init size and '0' fields to 0\n+   TR::Register *temp0Reg = cg->allocateRegister();\n+   generateRRInstruction(cg, TR::InstOpCode::getXORRegOpCode(), node, temp0Reg, temp0Reg);\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp0Reg, generateS390MemoryReference(targetReg, fej9->getOffsetOfContiguousArraySizeField(), cg));\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp0Reg, generateS390MemoryReference(targetReg, fej9->getOffsetOfDiscontiguousArraySizeField(), cg));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fd870a28386d90aa97661f88b14126e8af243c6"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzI3MDE2MA==", "bodyText": "Using move instructions now in 294933a and ff6da2b.\nI've never had any problems in any particular GC policy.\nOn a compressedrefs jvm on zlinux, I get the following output for those queries:\nfej9->getOffsetOfContiguousArraySizeField(): 4, fej9->getOffsetOfDiscontiguousArraySizeField(): 8", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r527270160", "createdAt": "2020-11-19T23:22:32Z", "author": {"login": "dchopra001"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,339 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n+TR::Node *\n+createOutlinedCallNode(TR::CodeGenerator *cg, TR::Node *callNode, TR::ILOpCodes callOp)\n+   {\n+   int32_t   i;\n+   TR::Node  *child;\n+\n+   TR::Node *newCallNode = TR::Node::createWithSymRef(callNode, callOp, callNode->getNumChildren(), callNode->getSymbolReference());\n+\n+   newCallNode->setReferenceCount(1);\n+\n+   for (i=0; i<callNode->getNumChildren(); i++)\n+      {\n+      child = callNode->getChild(i);\n+\n+      if (child->getRegister() != NULL)\n+         {\n+         // Child has already been evaluated outside this tree.\n+         //\n+         newCallNode->setAndIncChild(i, child);\n+         }\n+      else if (child->getOpCode().isLoadConst())\n+         {\n+         // Copy unevaluated constant nodes.\n+         //\n+         child = TR::Node::copy(child);\n+         child->setReferenceCount(1);\n+         newCallNode->setChild(i, child);\n+         }\n+      else\n+         {\n+         if ((child->getOpCodeValue() == TR::loadaddr) &&\n+             (child->getSymbolReference()->getSymbol()) &&\n+             (child->getSymbolReference()->getSymbol()->getStaticSymbol()))\n+            {\n+            child = TR::Node::copy(child);\n+            child->setReferenceCount(1);\n+            newCallNode->setChild(i, child);\n+            }\n+         else\n+            {\n+            // Be very conservative at this point, even though it is possible to make it less so.  For example, this will catch\n+            // the case of an unevaluated argument not persisting outside of the outlined region even though one of its subtrees will.\n+            (void)cg->evaluate(child);\n+\n+            // Do not decrement the reference count here.  It will be decremented when the call node is evaluated\n+            // again in the helper instruction stream.\n+            newCallNode->setAndIncChild(i, child);\n+            }\n+         }\n+      }\n+   if(callNode->isPreparedForDirectJNI())\n+      {\n+         newCallNode->setPreparedForDirectJNI();\n+      }\n+\n+   return newCallNode;\n+   }\n+\n ///////////////////////////////////////////////////////////////////////////////////////\n // multianewArrayEvaluator:  multi-dimensional new array of objects\n ///////////////////////////////////////////////////////////////////////////////////////\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::acall);\n-   TR::Register * targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n-   }\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = (TR_J9VMBase *)(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt()!=2)\n+      {\n+      traceMsg(cg->comp(), \"DCDCDCDC - multianewArrayEvaluator. More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      return performHelperCall(node, NULL, TR::acall, false, cg);\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // First generate the OOL code. This path will be used to handle the scenarios that we don't want to handle in JITT'ed code.\n+   TR_S390OutOfLineCodeSection *outlinedSlowPath = new (cg->trHeapMemory()) TR_S390OutOfLineCodeSection(oolFailLabel, cFlowRegionEnd, cg);\n+   cg->getS390OutOfLineCodeSectionList().push_front(outlinedSlowPath);\n+   outlinedSlowPath->swapInstructionListsWithCompilation();\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, oolFailLabel);\n+\n+   TR::Node *_callNode = createOutlinedCallNode(cg, node, TR::acall);\n+   TR::Register *targetReg2 = NULL;\n+   targetReg2 = TR::TreeEvaluator::performCall(_callNode, false, cg);\n+   cg->decReferenceCount(_callNode);\n+   generateRRInstruction(cg, TR::InstOpCode::LR, node, targetReg, targetReg2);\n+\n+   // After returning from the helper, branch back to mainline code.\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);\n+   // End of OOL\n+   outlinedSlowPath->swapInstructionListsWithCompilation();\n \n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::LG, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));\n+\n+   TR::Register *secondDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::LG, node, secondDimLenReg, generateS390MemoryReference(dimsPtrReg, 0, cg));\n+\n+\n+   // Check to see if second dimension is indeed 0. If yes, then proceed to handle the case here. Otherwise jump to OOL code to perform the call.\n+   generateRIEInstruction(cg, TR::InstOpCode::CLGIJ, node, secondDimLenReg, (int8_t)0, oolFailLabel, (TR::InstOpCode::COND_BNE));\n+\n+   // Now check to see if first dimension is also 0. If no, then jump to nonZeroFirstDimLabel to handle it. Otherwise continue below to handle the case when length for both dimensions is 0.\n+   generateRIEInstruction(cg, TR::InstOpCode::CLGIJ, node, firstDimLenReg, (int8_t)0, nonZeroFirstDimLabel, (TR::InstOpCode::COND_BNE));\n+\n+   // TODO: We don't need this label. But it's good for organizing the different paths for now.\n+   TR::LabelSymbol *firstDimZeroLabel = generateLabelSymbol(cg);\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, firstDimZeroLabel);\n+\n+   // First Dim zero, only allocate 1 zero-length object array\n+   int32_t zeroArraySize = TR::Compiler->om.discontiguousArrayHeaderSizeInBytes();\n+   TR::Register *vmThreadReg = cg->getMethodMetaDataRealRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, targetReg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+\n+   // Branch to OOL if there's not enough space for an array of size 0.\n+   TR::Register *temp1Reg = cg->allocateRegister();\n+   generateRIEInstruction(cg, TR::InstOpCode::getAddHalfWordImmDistinctOperandOpCode(), node, temp1Reg, targetReg, zeroArraySize);\n+   generateRXInstruction(cg, TR::InstOpCode::getCmpLogicalOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapTop), cg));\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BH, node, oolFailLabel);\n+\n+   // If there's enough space, then we can continue to allocate.\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+   \n+   // Init class\n+   bool use64BitClasses = comp->target().is64Bit() && !TR::Compiler->om.generateCompressedObjectHeaders();\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, classReg, generateS390MemoryReference(targetReg, TR::Compiler->om.offsetOfObjectVftField(), cg));\n+   \n+   // Init size and '0' fields to 0\n+   TR::Register *temp0Reg = cg->allocateRegister();\n+   generateRRInstruction(cg, TR::InstOpCode::getXORRegOpCode(), node, temp0Reg, temp0Reg);\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp0Reg, generateS390MemoryReference(targetReg, fej9->getOffsetOfContiguousArraySizeField(), cg));\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp0Reg, generateS390MemoryReference(targetReg, fej9->getOffsetOfDiscontiguousArraySizeField(), cg));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODIyNTIzMQ=="}, "originalCommit": {"oid": "7fd870a28386d90aa97661f88b14126e8af243c6"}, "originalPosition": 174}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0ODA4MjQ3OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxNzoyNDozOVrOHuN-Vw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxNzoyNDozOVrOHuN-Vw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODIyNTQ5NQ==", "bodyText": "I don't think these comments are too useful. They don't say anything more than the actual line of code.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r518225495", "createdAt": "2020-11-05T17:24:39Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,339 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n+TR::Node *\n+createOutlinedCallNode(TR::CodeGenerator *cg, TR::Node *callNode, TR::ILOpCodes callOp)\n+   {\n+   int32_t   i;\n+   TR::Node  *child;\n+\n+   TR::Node *newCallNode = TR::Node::createWithSymRef(callNode, callOp, callNode->getNumChildren(), callNode->getSymbolReference());\n+\n+   newCallNode->setReferenceCount(1);\n+\n+   for (i=0; i<callNode->getNumChildren(); i++)\n+      {\n+      child = callNode->getChild(i);\n+\n+      if (child->getRegister() != NULL)\n+         {\n+         // Child has already been evaluated outside this tree.\n+         //\n+         newCallNode->setAndIncChild(i, child);\n+         }\n+      else if (child->getOpCode().isLoadConst())\n+         {\n+         // Copy unevaluated constant nodes.\n+         //\n+         child = TR::Node::copy(child);\n+         child->setReferenceCount(1);\n+         newCallNode->setChild(i, child);\n+         }\n+      else\n+         {\n+         if ((child->getOpCodeValue() == TR::loadaddr) &&\n+             (child->getSymbolReference()->getSymbol()) &&\n+             (child->getSymbolReference()->getSymbol()->getStaticSymbol()))\n+            {\n+            child = TR::Node::copy(child);\n+            child->setReferenceCount(1);\n+            newCallNode->setChild(i, child);\n+            }\n+         else\n+            {\n+            // Be very conservative at this point, even though it is possible to make it less so.  For example, this will catch\n+            // the case of an unevaluated argument not persisting outside of the outlined region even though one of its subtrees will.\n+            (void)cg->evaluate(child);\n+\n+            // Do not decrement the reference count here.  It will be decremented when the call node is evaluated\n+            // again in the helper instruction stream.\n+            newCallNode->setAndIncChild(i, child);\n+            }\n+         }\n+      }\n+   if(callNode->isPreparedForDirectJNI())\n+      {\n+         newCallNode->setPreparedForDirectJNI();\n+      }\n+\n+   return newCallNode;\n+   }\n+\n ///////////////////////////////////////////////////////////////////////////////////////\n // multianewArrayEvaluator:  multi-dimensional new array of objects\n ///////////////////////////////////////////////////////////////////////////////////////\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::acall);\n-   TR::Register * targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n-   }\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = (TR_J9VMBase *)(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt()!=2)\n+      {\n+      traceMsg(cg->comp(), \"DCDCDCDC - multianewArrayEvaluator. More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      return performHelperCall(node, NULL, TR::acall, false, cg);\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // First generate the OOL code. This path will be used to handle the scenarios that we don't want to handle in JITT'ed code.\n+   TR_S390OutOfLineCodeSection *outlinedSlowPath = new (cg->trHeapMemory()) TR_S390OutOfLineCodeSection(oolFailLabel, cFlowRegionEnd, cg);\n+   cg->getS390OutOfLineCodeSectionList().push_front(outlinedSlowPath);\n+   outlinedSlowPath->swapInstructionListsWithCompilation();\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, oolFailLabel);\n+\n+   TR::Node *_callNode = createOutlinedCallNode(cg, node, TR::acall);\n+   TR::Register *targetReg2 = NULL;\n+   targetReg2 = TR::TreeEvaluator::performCall(_callNode, false, cg);\n+   cg->decReferenceCount(_callNode);\n+   generateRRInstruction(cg, TR::InstOpCode::LR, node, targetReg, targetReg2);\n+\n+   // After returning from the helper, branch back to mainline code.\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);\n+   // End of OOL\n+   outlinedSlowPath->swapInstructionListsWithCompilation();\n \n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::LG, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));\n+\n+   TR::Register *secondDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::LG, node, secondDimLenReg, generateS390MemoryReference(dimsPtrReg, 0, cg));\n+\n+\n+   // Check to see if second dimension is indeed 0. If yes, then proceed to handle the case here. Otherwise jump to OOL code to perform the call.\n+   generateRIEInstruction(cg, TR::InstOpCode::CLGIJ, node, secondDimLenReg, (int8_t)0, oolFailLabel, (TR::InstOpCode::COND_BNE));\n+\n+   // Now check to see if first dimension is also 0. If no, then jump to nonZeroFirstDimLabel to handle it. Otherwise continue below to handle the case when length for both dimensions is 0.\n+   generateRIEInstruction(cg, TR::InstOpCode::CLGIJ, node, firstDimLenReg, (int8_t)0, nonZeroFirstDimLabel, (TR::InstOpCode::COND_BNE));\n+\n+   // TODO: We don't need this label. But it's good for organizing the different paths for now.\n+   TR::LabelSymbol *firstDimZeroLabel = generateLabelSymbol(cg);\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, firstDimZeroLabel);\n+\n+   // First Dim zero, only allocate 1 zero-length object array\n+   int32_t zeroArraySize = TR::Compiler->om.discontiguousArrayHeaderSizeInBytes();\n+   TR::Register *vmThreadReg = cg->getMethodMetaDataRealRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, targetReg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+\n+   // Branch to OOL if there's not enough space for an array of size 0.\n+   TR::Register *temp1Reg = cg->allocateRegister();\n+   generateRIEInstruction(cg, TR::InstOpCode::getAddHalfWordImmDistinctOperandOpCode(), node, temp1Reg, targetReg, zeroArraySize);\n+   generateRXInstruction(cg, TR::InstOpCode::getCmpLogicalOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapTop), cg));\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BH, node, oolFailLabel);\n+\n+   // If there's enough space, then we can continue to allocate.\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+   \n+   // Init class\n+   bool use64BitClasses = comp->target().is64Bit() && !TR::Compiler->om.generateCompressedObjectHeaders();\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, classReg, generateS390MemoryReference(targetReg, TR::Compiler->om.offsetOfObjectVftField(), cg));\n+   \n+   // Init size and '0' fields to 0\n+   TR::Register *temp0Reg = cg->allocateRegister();\n+   generateRRInstruction(cg, TR::InstOpCode::getXORRegOpCode(), node, temp0Reg, temp0Reg);\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp0Reg, generateS390MemoryReference(targetReg, fej9->getOffsetOfContiguousArraySizeField(), cg));\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp0Reg, generateS390MemoryReference(targetReg, fej9->getOffsetOfDiscontiguousArraySizeField(), cg));\n+\n+   // Done with this scenario, so jump to end of ICF.\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fd870a28386d90aa97661f88b14126e8af243c6"}, "originalPosition": 177}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0ODA4NTg2OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxNzoyNToyOFrOHuOAhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxNzoyNToyOFrOHuOAhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODIyNjA1NQ==", "bodyText": "\"DCDC\" needs to be removed. If there is something to be done, we should leave a TODO and open an issue for it.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r518226055", "createdAt": "2020-11-05T17:25:28Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,339 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n+TR::Node *\n+createOutlinedCallNode(TR::CodeGenerator *cg, TR::Node *callNode, TR::ILOpCodes callOp)\n+   {\n+   int32_t   i;\n+   TR::Node  *child;\n+\n+   TR::Node *newCallNode = TR::Node::createWithSymRef(callNode, callOp, callNode->getNumChildren(), callNode->getSymbolReference());\n+\n+   newCallNode->setReferenceCount(1);\n+\n+   for (i=0; i<callNode->getNumChildren(); i++)\n+      {\n+      child = callNode->getChild(i);\n+\n+      if (child->getRegister() != NULL)\n+         {\n+         // Child has already been evaluated outside this tree.\n+         //\n+         newCallNode->setAndIncChild(i, child);\n+         }\n+      else if (child->getOpCode().isLoadConst())\n+         {\n+         // Copy unevaluated constant nodes.\n+         //\n+         child = TR::Node::copy(child);\n+         child->setReferenceCount(1);\n+         newCallNode->setChild(i, child);\n+         }\n+      else\n+         {\n+         if ((child->getOpCodeValue() == TR::loadaddr) &&\n+             (child->getSymbolReference()->getSymbol()) &&\n+             (child->getSymbolReference()->getSymbol()->getStaticSymbol()))\n+            {\n+            child = TR::Node::copy(child);\n+            child->setReferenceCount(1);\n+            newCallNode->setChild(i, child);\n+            }\n+         else\n+            {\n+            // Be very conservative at this point, even though it is possible to make it less so.  For example, this will catch\n+            // the case of an unevaluated argument not persisting outside of the outlined region even though one of its subtrees will.\n+            (void)cg->evaluate(child);\n+\n+            // Do not decrement the reference count here.  It will be decremented when the call node is evaluated\n+            // again in the helper instruction stream.\n+            newCallNode->setAndIncChild(i, child);\n+            }\n+         }\n+      }\n+   if(callNode->isPreparedForDirectJNI())\n+      {\n+         newCallNode->setPreparedForDirectJNI();\n+      }\n+\n+   return newCallNode;\n+   }\n+\n ///////////////////////////////////////////////////////////////////////////////////////\n // multianewArrayEvaluator:  multi-dimensional new array of objects\n ///////////////////////////////////////////////////////////////////////////////////////\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::acall);\n-   TR::Register * targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n-   }\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = (TR_J9VMBase *)(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt()!=2)\n+      {\n+      traceMsg(cg->comp(), \"DCDCDCDC - multianewArrayEvaluator. More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      return performHelperCall(node, NULL, TR::acall, false, cg);\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // First generate the OOL code. This path will be used to handle the scenarios that we don't want to handle in JITT'ed code.\n+   TR_S390OutOfLineCodeSection *outlinedSlowPath = new (cg->trHeapMemory()) TR_S390OutOfLineCodeSection(oolFailLabel, cFlowRegionEnd, cg);\n+   cg->getS390OutOfLineCodeSectionList().push_front(outlinedSlowPath);\n+   outlinedSlowPath->swapInstructionListsWithCompilation();\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, oolFailLabel);\n+\n+   TR::Node *_callNode = createOutlinedCallNode(cg, node, TR::acall);\n+   TR::Register *targetReg2 = NULL;\n+   targetReg2 = TR::TreeEvaluator::performCall(_callNode, false, cg);\n+   cg->decReferenceCount(_callNode);\n+   generateRRInstruction(cg, TR::InstOpCode::LR, node, targetReg, targetReg2);\n+\n+   // After returning from the helper, branch back to mainline code.\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);\n+   // End of OOL\n+   outlinedSlowPath->swapInstructionListsWithCompilation();\n \n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::LG, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));\n+\n+   TR::Register *secondDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::LG, node, secondDimLenReg, generateS390MemoryReference(dimsPtrReg, 0, cg));\n+\n+\n+   // Check to see if second dimension is indeed 0. If yes, then proceed to handle the case here. Otherwise jump to OOL code to perform the call.\n+   generateRIEInstruction(cg, TR::InstOpCode::CLGIJ, node, secondDimLenReg, (int8_t)0, oolFailLabel, (TR::InstOpCode::COND_BNE));\n+\n+   // Now check to see if first dimension is also 0. If no, then jump to nonZeroFirstDimLabel to handle it. Otherwise continue below to handle the case when length for both dimensions is 0.\n+   generateRIEInstruction(cg, TR::InstOpCode::CLGIJ, node, firstDimLenReg, (int8_t)0, nonZeroFirstDimLabel, (TR::InstOpCode::COND_BNE));\n+\n+   // TODO: We don't need this label. But it's good for organizing the different paths for now.\n+   TR::LabelSymbol *firstDimZeroLabel = generateLabelSymbol(cg);\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, firstDimZeroLabel);\n+\n+   // First Dim zero, only allocate 1 zero-length object array\n+   int32_t zeroArraySize = TR::Compiler->om.discontiguousArrayHeaderSizeInBytes();\n+   TR::Register *vmThreadReg = cg->getMethodMetaDataRealRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, targetReg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+\n+   // Branch to OOL if there's not enough space for an array of size 0.\n+   TR::Register *temp1Reg = cg->allocateRegister();\n+   generateRIEInstruction(cg, TR::InstOpCode::getAddHalfWordImmDistinctOperandOpCode(), node, temp1Reg, targetReg, zeroArraySize);\n+   generateRXInstruction(cg, TR::InstOpCode::getCmpLogicalOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapTop), cg));\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BH, node, oolFailLabel);\n+\n+   // If there's enough space, then we can continue to allocate.\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+   \n+   // Init class\n+   bool use64BitClasses = comp->target().is64Bit() && !TR::Compiler->om.generateCompressedObjectHeaders();\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, classReg, generateS390MemoryReference(targetReg, TR::Compiler->om.offsetOfObjectVftField(), cg));\n+   \n+   // Init size and '0' fields to 0\n+   TR::Register *temp0Reg = cg->allocateRegister();\n+   generateRRInstruction(cg, TR::InstOpCode::getXORRegOpCode(), node, temp0Reg, temp0Reg);\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp0Reg, generateS390MemoryReference(targetReg, fej9->getOffsetOfContiguousArraySizeField(), cg));\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp0Reg, generateS390MemoryReference(targetReg, fej9->getOffsetOfDiscontiguousArraySizeField(), cg));\n+\n+   // Done with this scenario, so jump to end of ICF.\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);\n+\n+   // We end up in this block of the ICF if the first dimension is non-zero and the second dimension is zero.\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, nonZeroFirstDimLabel); // DCDCDCDC - > This is temporary. In the long run we want to have actual code and not just fall through into oolFailLabel.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fd870a28386d90aa97661f88b14126e8af243c6"}, "originalPosition": 180}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwNTU0OTc3OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQyMTowNTozMFrOH2xmlw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQyMjozMDozNlrOH3i4Ug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE5Nzg0Nw==", "bodyText": "We should use static_cast here.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r527197847", "createdAt": "2020-11-19T21:05:30Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,264 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n ///////////////////////////////////////////////////////////////////////////////////////\n // multianewArrayEvaluator:  multi-dimensional new array of objects\n ///////////////////////////////////////////////////////////////////////////////////////\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::acall);\n-   TR::Register * targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n-   }\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = (TR_J9VMBase *)(comp->fe());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10d5904fe4cd34f70dcf0c92e294ba54ba930b38"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAwNTIwMg==", "bodyText": "Should be fixed in: 0d2a7a6", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r528005202", "createdAt": "2020-11-20T22:30:36Z", "author": {"login": "dchopra001"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,264 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n ///////////////////////////////////////////////////////////////////////////////////////\n // multianewArrayEvaluator:  multi-dimensional new array of objects\n ///////////////////////////////////////////////////////////////////////////////////////\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::acall);\n-   TR::Register * targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n-   }\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = (TR_J9VMBase *)(comp->fe());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE5Nzg0Nw=="}, "originalCommit": {"oid": "10d5904fe4cd34f70dcf0c92e294ba54ba930b38"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwNTU3OTI4OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQyMToxMzo0OFrOH2x4Mw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNToyNTo0N1rOH3USMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIwMjM1NQ==", "bodyText": "Does this mean we only allow inline allocations if the signature is [x][0]? That doesn't really make sense to me.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r527202355", "createdAt": "2020-11-19T21:13:48Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,264 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n ///////////////////////////////////////////////////////////////////////////////////////\n // multianewArrayEvaluator:  multi-dimensional new array of objects\n ///////////////////////////////////////////////////////////////////////////////////////\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::acall);\n-   TR::Register * targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n-   }\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = (TR_J9VMBase *)(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt() != 2)\n+      {\n+      traceMsg(cg->comp(), \"multianewArrayEvaluator - More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      return performHelperCall(node, NULL, TR::acall, false, cg);\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   // oolJumpLabel is a common point that all branches will jump to. From this label, we branch to OOL code.\n+   // We do this instead of jumping directly to OOL code from mainline because the RA can only handle the case where there's\n+   // a single jump point to OOL code.\n+   TR::LabelSymbol *oolJumpLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));\n+\n+   TR::Register *secondDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, secondDimLenReg, generateS390MemoryReference(dimsPtrReg, 0, cg));\n+\n+   // Check to see if second dimension is indeed 0. If yes, then proceed to handle the case here. Otherwise jump to OOL code.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, secondDimLenReg, 0, TR::InstOpCode::COND_BNE, oolJumpLabel, false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10d5904fe4cd34f70dcf0c92e294ba54ba930b38"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIyMDg4MA==", "bodyText": "Would you be able to elaborate on why it doesn't make sense?\nThe purpose of doing this work on x86 originally was to only accelerate cases where the second dimension is 0: #2408 (comment). The goal was always to only accelerate these cases as performance investigations showed that some benchmarks were generating 2 dimensional arrays with the second dimension being 0.\nSo I'm doing a similar thing on Z.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r527220880", "createdAt": "2020-11-19T21:41:59Z", "author": {"login": "dchopra001"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,264 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n ///////////////////////////////////////////////////////////////////////////////////////\n // multianewArrayEvaluator:  multi-dimensional new array of objects\n ///////////////////////////////////////////////////////////////////////////////////////\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::acall);\n-   TR::Register * targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n-   }\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = (TR_J9VMBase *)(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt() != 2)\n+      {\n+      traceMsg(cg->comp(), \"multianewArrayEvaluator - More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      return performHelperCall(node, NULL, TR::acall, false, cg);\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   // oolJumpLabel is a common point that all branches will jump to. From this label, we branch to OOL code.\n+   // We do this instead of jumping directly to OOL code from mainline because the RA can only handle the case where there's\n+   // a single jump point to OOL code.\n+   TR::LabelSymbol *oolJumpLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));\n+\n+   TR::Register *secondDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, secondDimLenReg, generateS390MemoryReference(dimsPtrReg, 0, cg));\n+\n+   // Check to see if second dimension is indeed 0. If yes, then proceed to handle the case here. Otherwise jump to OOL code.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, secondDimLenReg, 0, TR::InstOpCode::COND_BNE, oolJumpLabel, false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIwMjM1NQ=="}, "originalCommit": {"oid": "10d5904fe4cd34f70dcf0c92e294ba54ba930b38"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzc2NjA2Nw==", "bodyText": "Just read over the x86 comments you referenced. It seems odd that we restricted to only zero length second dimensions. I don't think it would have been much extra work to support the general case. But alas it seems this change was driven by what we saw in the profiles of a benchmark. I suppose there was no need to accelerate non-zero second dimensions, at least at the time.\nI was under the assumption that we are doing the general case, which is why it didn't make sense that we restricted only to [x][0] here. My assumption was wrong as you point out. Thanks for linking that comment. This part looks fine.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r527766067", "createdAt": "2020-11-20T15:25:47Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,264 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n ///////////////////////////////////////////////////////////////////////////////////////\n // multianewArrayEvaluator:  multi-dimensional new array of objects\n ///////////////////////////////////////////////////////////////////////////////////////\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::acall);\n-   TR::Register * targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n-   }\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = (TR_J9VMBase *)(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt() != 2)\n+      {\n+      traceMsg(cg->comp(), \"multianewArrayEvaluator - More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      return performHelperCall(node, NULL, TR::acall, false, cg);\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   // oolJumpLabel is a common point that all branches will jump to. From this label, we branch to OOL code.\n+   // We do this instead of jumping directly to OOL code from mainline because the RA can only handle the case where there's\n+   // a single jump point to OOL code.\n+   TR::LabelSymbol *oolJumpLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));\n+\n+   TR::Register *secondDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, secondDimLenReg, generateS390MemoryReference(dimsPtrReg, 0, cg));\n+\n+   // Check to see if second dimension is indeed 0. If yes, then proceed to handle the case here. Otherwise jump to OOL code.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, secondDimLenReg, 0, TR::InstOpCode::COND_BNE, oolJumpLabel, false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIwMjM1NQ=="}, "originalCommit": {"oid": "10d5904fe4cd34f70dcf0c92e294ba54ba930b38"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwNTU5NTQyOnYy", "diffSide": "RIGHT", "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQyMToxODowOVrOH2yB6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQyMjozMjo1M1rOH3i7Ug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIwNDg0Mw==", "bodyText": "Typo: ump", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r527204843", "createdAt": "2020-11-19T21:18:09Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,264 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n ///////////////////////////////////////////////////////////////////////////////////////\n // multianewArrayEvaluator:  multi-dimensional new array of objects\n ///////////////////////////////////////////////////////////////////////////////////////\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::acall);\n-   TR::Register * targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n-   }\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = (TR_J9VMBase *)(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt() != 2)\n+      {\n+      traceMsg(cg->comp(), \"multianewArrayEvaluator - More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      return performHelperCall(node, NULL, TR::acall, false, cg);\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   // oolJumpLabel is a common point that all branches will jump to. From this label, we branch to OOL code.\n+   // We do this instead of jumping directly to OOL code from mainline because the RA can only handle the case where there's\n+   // a single jump point to OOL code.\n+   TR::LabelSymbol *oolJumpLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));\n+\n+   TR::Register *secondDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, secondDimLenReg, generateS390MemoryReference(dimsPtrReg, 0, cg));\n+\n+   // Check to see if second dimension is indeed 0. If yes, then proceed to handle the case here. Otherwise jump to OOL code.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, secondDimLenReg, 0, TR::InstOpCode::COND_BNE, oolJumpLabel, false);\n+\n+   // Now check to see if first dimension is also 0. If yes, continue below to handle the case when length for both dimensions is 0. Otherwise jump to nonZeroFirstDimLabel.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, 0, TR::InstOpCode::COND_BNE, nonZeroFirstDimLabel, false);\n+\n+   // First dimension zero, so only allocate 1 zero-length object array\n+   int32_t zeroArraySize = TR::Compiler->om.discontiguousArrayHeaderSizeInBytes();\n+   TR::Register *vmThreadReg = cg->getMethodMetaDataRealRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, targetReg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+\n+   // Branch to OOL if there's not enough space for an array of size 0.\n+   TR::Register *temp1Reg = cg->allocateRegister();\n+   generateRIEInstruction(cg, TR::InstOpCode::getAddHalfWordImmDistinctOperandOpCode(), node, temp1Reg, targetReg, zeroArraySize);\n+   generateRXInstruction(cg, TR::InstOpCode::getCmpLogicalOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapTop), cg));\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BH, node, oolJumpLabel);\n+\n+   // If there's enough space, then we can continue to allocate.\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+   \n+   bool use64BitClasses = comp->target().is64Bit() && !TR::Compiler->om.generateCompressedObjectHeaders();\n+\n+   // Init class and fields, then jump to end of ICF\n+   generateRXInstruction(cg, use64BitClasses ? TR::InstOpCode::STG : TR::InstOpCode::ST, node, classReg, generateS390MemoryReference(targetReg, TR::Compiler->om.offsetOfObjectVftField(), cg));\n+   generateSILInstruction(cg, use64BitClasses ? TR::InstOpCode::MVGHI : TR::InstOpCode::MVHI, node, generateS390MemoryReference(targetReg, fej9->getOffsetOfContiguousArraySizeField(), cg), 0);\n+   generateSILInstruction(cg, use64BitClasses ? TR::InstOpCode::MVGHI : TR::InstOpCode::MVHI, node, generateS390MemoryReference(targetReg, fej9->getOffsetOfDiscontiguousArraySizeField(), cg), 0);\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);\n+\n+   // We end up in this region of the ICF if the first dimension is non-zero and the second dimension is zero.\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, nonZeroFirstDimLabel);\n+\n+   TR::Register *componentClassReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, componentClassReg, generateS390MemoryReference(classReg, offsetof(J9ArrayClass, componentType), cg));\n+\n+   // Calculate maximum allowable object size in elements and ump to OOL if it's higher than firstDimLenReg.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10d5904fe4cd34f70dcf0c92e294ba54ba930b38"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAwNTk3MA==", "bodyText": "Fixed in 0d2a7a6", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r528005970", "createdAt": "2020-11-20T22:32:53Z", "author": {"login": "dchopra001"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,264 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n ///////////////////////////////////////////////////////////////////////////////////////\n // multianewArrayEvaluator:  multi-dimensional new array of objects\n ///////////////////////////////////////////////////////////////////////////////////////\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::acall);\n-   TR::Register * targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n-   }\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = (TR_J9VMBase *)(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt() != 2)\n+      {\n+      traceMsg(cg->comp(), \"multianewArrayEvaluator - More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      return performHelperCall(node, NULL, TR::acall, false, cg);\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   // oolJumpLabel is a common point that all branches will jump to. From this label, we branch to OOL code.\n+   // We do this instead of jumping directly to OOL code from mainline because the RA can only handle the case where there's\n+   // a single jump point to OOL code.\n+   TR::LabelSymbol *oolJumpLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));\n+\n+   TR::Register *secondDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, secondDimLenReg, generateS390MemoryReference(dimsPtrReg, 0, cg));\n+\n+   // Check to see if second dimension is indeed 0. If yes, then proceed to handle the case here. Otherwise jump to OOL code.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, secondDimLenReg, 0, TR::InstOpCode::COND_BNE, oolJumpLabel, false);\n+\n+   // Now check to see if first dimension is also 0. If yes, continue below to handle the case when length for both dimensions is 0. Otherwise jump to nonZeroFirstDimLabel.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, 0, TR::InstOpCode::COND_BNE, nonZeroFirstDimLabel, false);\n+\n+   // First dimension zero, so only allocate 1 zero-length object array\n+   int32_t zeroArraySize = TR::Compiler->om.discontiguousArrayHeaderSizeInBytes();\n+   TR::Register *vmThreadReg = cg->getMethodMetaDataRealRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, targetReg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+\n+   // Branch to OOL if there's not enough space for an array of size 0.\n+   TR::Register *temp1Reg = cg->allocateRegister();\n+   generateRIEInstruction(cg, TR::InstOpCode::getAddHalfWordImmDistinctOperandOpCode(), node, temp1Reg, targetReg, zeroArraySize);\n+   generateRXInstruction(cg, TR::InstOpCode::getCmpLogicalOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapTop), cg));\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BH, node, oolJumpLabel);\n+\n+   // If there's enough space, then we can continue to allocate.\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+   \n+   bool use64BitClasses = comp->target().is64Bit() && !TR::Compiler->om.generateCompressedObjectHeaders();\n+\n+   // Init class and fields, then jump to end of ICF\n+   generateRXInstruction(cg, use64BitClasses ? TR::InstOpCode::STG : TR::InstOpCode::ST, node, classReg, generateS390MemoryReference(targetReg, TR::Compiler->om.offsetOfObjectVftField(), cg));\n+   generateSILInstruction(cg, use64BitClasses ? TR::InstOpCode::MVGHI : TR::InstOpCode::MVHI, node, generateS390MemoryReference(targetReg, fej9->getOffsetOfContiguousArraySizeField(), cg), 0);\n+   generateSILInstruction(cg, use64BitClasses ? TR::InstOpCode::MVGHI : TR::InstOpCode::MVHI, node, generateS390MemoryReference(targetReg, fej9->getOffsetOfDiscontiguousArraySizeField(), cg), 0);\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);\n+\n+   // We end up in this region of the ICF if the first dimension is non-zero and the second dimension is zero.\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, nonZeroFirstDimLabel);\n+\n+   TR::Register *componentClassReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, componentClassReg, generateS390MemoryReference(classReg, offsetof(J9ArrayClass, componentType), cg));\n+\n+   // Calculate maximum allowable object size in elements and ump to OOL if it's higher than firstDimLenReg.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIwNDg0Mw=="}, "originalCommit": {"oid": "10d5904fe4cd34f70dcf0c92e294ba54ba930b38"}, "originalPosition": 105}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwNTU5ODc5OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQyMToxOTowOFrOH2yD5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQyMjozNDozNlrOH3i9kA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIwNTM1MA==", "bodyText": "Shouldn't this be a generateS390CompareAndBranchInstruction?", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r527205350", "createdAt": "2020-11-19T21:19:08Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,264 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n ///////////////////////////////////////////////////////////////////////////////////////\n // multianewArrayEvaluator:  multi-dimensional new array of objects\n ///////////////////////////////////////////////////////////////////////////////////////\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::acall);\n-   TR::Register * targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n-   }\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = (TR_J9VMBase *)(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt() != 2)\n+      {\n+      traceMsg(cg->comp(), \"multianewArrayEvaluator - More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      return performHelperCall(node, NULL, TR::acall, false, cg);\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   // oolJumpLabel is a common point that all branches will jump to. From this label, we branch to OOL code.\n+   // We do this instead of jumping directly to OOL code from mainline because the RA can only handle the case where there's\n+   // a single jump point to OOL code.\n+   TR::LabelSymbol *oolJumpLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));\n+\n+   TR::Register *secondDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, secondDimLenReg, generateS390MemoryReference(dimsPtrReg, 0, cg));\n+\n+   // Check to see if second dimension is indeed 0. If yes, then proceed to handle the case here. Otherwise jump to OOL code.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, secondDimLenReg, 0, TR::InstOpCode::COND_BNE, oolJumpLabel, false);\n+\n+   // Now check to see if first dimension is also 0. If yes, continue below to handle the case when length for both dimensions is 0. Otherwise jump to nonZeroFirstDimLabel.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, 0, TR::InstOpCode::COND_BNE, nonZeroFirstDimLabel, false);\n+\n+   // First dimension zero, so only allocate 1 zero-length object array\n+   int32_t zeroArraySize = TR::Compiler->om.discontiguousArrayHeaderSizeInBytes();\n+   TR::Register *vmThreadReg = cg->getMethodMetaDataRealRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, targetReg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+\n+   // Branch to OOL if there's not enough space for an array of size 0.\n+   TR::Register *temp1Reg = cg->allocateRegister();\n+   generateRIEInstruction(cg, TR::InstOpCode::getAddHalfWordImmDistinctOperandOpCode(), node, temp1Reg, targetReg, zeroArraySize);\n+   generateRXInstruction(cg, TR::InstOpCode::getCmpLogicalOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapTop), cg));\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BH, node, oolJumpLabel);\n+\n+   // If there's enough space, then we can continue to allocate.\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+   \n+   bool use64BitClasses = comp->target().is64Bit() && !TR::Compiler->om.generateCompressedObjectHeaders();\n+\n+   // Init class and fields, then jump to end of ICF\n+   generateRXInstruction(cg, use64BitClasses ? TR::InstOpCode::STG : TR::InstOpCode::ST, node, classReg, generateS390MemoryReference(targetReg, TR::Compiler->om.offsetOfObjectVftField(), cg));\n+   generateSILInstruction(cg, use64BitClasses ? TR::InstOpCode::MVGHI : TR::InstOpCode::MVHI, node, generateS390MemoryReference(targetReg, fej9->getOffsetOfContiguousArraySizeField(), cg), 0);\n+   generateSILInstruction(cg, use64BitClasses ? TR::InstOpCode::MVGHI : TR::InstOpCode::MVHI, node, generateS390MemoryReference(targetReg, fej9->getOffsetOfDiscontiguousArraySizeField(), cg), 0);\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);\n+\n+   // We end up in this region of the ICF if the first dimension is non-zero and the second dimension is zero.\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, nonZeroFirstDimLabel);\n+\n+   TR::Register *componentClassReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, componentClassReg, generateS390MemoryReference(classReg, offsetof(J9ArrayClass, componentType), cg));\n+\n+   // Calculate maximum allowable object size in elements and ump to OOL if it's higher than firstDimLenReg.\n+   int32_t elementSize = comp->useCompressedPointers() ? TR::Compiler->om.sizeofReferenceField() : static_cast<int32_t>(TR::Compiler->om.sizeofReferenceAddress());\n+   uintptr_t maxObjectSize = cg->getMaxObjectSizeGuaranteedNotToOverflow();\n+   uintptr_t maxObjectSizeInElements = maxObjectSize / elementSize;\n+\n+   if (comp->target().is64Bit() && !(maxObjectSizeInElements >= 0 && maxObjectSizeInElements <= (uintptr_t)INT_MAX))\n+      {\n+      uint32_t high32 = maxObjectSizeInElements >> 32;\n+      generateRILInstruction(cg, TR::InstOpCode::LLIHF, node, temp1Reg, high32);\n+      generateRILInstruction(cg, TR::InstOpCode::IILF, node, temp1Reg, static_cast<uint32_t>(maxObjectSizeInElements));\n+      generateRIEInstruction(cg, TR::InstOpCode::CLGRJ, node, firstDimLenReg, temp1Reg, oolJumpLabel, TR::InstOpCode::COND_BRH);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10d5904fe4cd34f70dcf0c92e294ba54ba930b38"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAwNjU0NA==", "bodyText": "Fixed in 0d2a7a6", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r528006544", "createdAt": "2020-11-20T22:34:36Z", "author": {"login": "dchopra001"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,264 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n ///////////////////////////////////////////////////////////////////////////////////////\n // multianewArrayEvaluator:  multi-dimensional new array of objects\n ///////////////////////////////////////////////////////////////////////////////////////\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::acall);\n-   TR::Register * targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n-   }\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = (TR_J9VMBase *)(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt() != 2)\n+      {\n+      traceMsg(cg->comp(), \"multianewArrayEvaluator - More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      return performHelperCall(node, NULL, TR::acall, false, cg);\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   // oolJumpLabel is a common point that all branches will jump to. From this label, we branch to OOL code.\n+   // We do this instead of jumping directly to OOL code from mainline because the RA can only handle the case where there's\n+   // a single jump point to OOL code.\n+   TR::LabelSymbol *oolJumpLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));\n+\n+   TR::Register *secondDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, secondDimLenReg, generateS390MemoryReference(dimsPtrReg, 0, cg));\n+\n+   // Check to see if second dimension is indeed 0. If yes, then proceed to handle the case here. Otherwise jump to OOL code.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, secondDimLenReg, 0, TR::InstOpCode::COND_BNE, oolJumpLabel, false);\n+\n+   // Now check to see if first dimension is also 0. If yes, continue below to handle the case when length for both dimensions is 0. Otherwise jump to nonZeroFirstDimLabel.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, 0, TR::InstOpCode::COND_BNE, nonZeroFirstDimLabel, false);\n+\n+   // First dimension zero, so only allocate 1 zero-length object array\n+   int32_t zeroArraySize = TR::Compiler->om.discontiguousArrayHeaderSizeInBytes();\n+   TR::Register *vmThreadReg = cg->getMethodMetaDataRealRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, targetReg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+\n+   // Branch to OOL if there's not enough space for an array of size 0.\n+   TR::Register *temp1Reg = cg->allocateRegister();\n+   generateRIEInstruction(cg, TR::InstOpCode::getAddHalfWordImmDistinctOperandOpCode(), node, temp1Reg, targetReg, zeroArraySize);\n+   generateRXInstruction(cg, TR::InstOpCode::getCmpLogicalOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapTop), cg));\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BH, node, oolJumpLabel);\n+\n+   // If there's enough space, then we can continue to allocate.\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+   \n+   bool use64BitClasses = comp->target().is64Bit() && !TR::Compiler->om.generateCompressedObjectHeaders();\n+\n+   // Init class and fields, then jump to end of ICF\n+   generateRXInstruction(cg, use64BitClasses ? TR::InstOpCode::STG : TR::InstOpCode::ST, node, classReg, generateS390MemoryReference(targetReg, TR::Compiler->om.offsetOfObjectVftField(), cg));\n+   generateSILInstruction(cg, use64BitClasses ? TR::InstOpCode::MVGHI : TR::InstOpCode::MVHI, node, generateS390MemoryReference(targetReg, fej9->getOffsetOfContiguousArraySizeField(), cg), 0);\n+   generateSILInstruction(cg, use64BitClasses ? TR::InstOpCode::MVGHI : TR::InstOpCode::MVHI, node, generateS390MemoryReference(targetReg, fej9->getOffsetOfDiscontiguousArraySizeField(), cg), 0);\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);\n+\n+   // We end up in this region of the ICF if the first dimension is non-zero and the second dimension is zero.\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, nonZeroFirstDimLabel);\n+\n+   TR::Register *componentClassReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, componentClassReg, generateS390MemoryReference(classReg, offsetof(J9ArrayClass, componentType), cg));\n+\n+   // Calculate maximum allowable object size in elements and ump to OOL if it's higher than firstDimLenReg.\n+   int32_t elementSize = comp->useCompressedPointers() ? TR::Compiler->om.sizeofReferenceField() : static_cast<int32_t>(TR::Compiler->om.sizeofReferenceAddress());\n+   uintptr_t maxObjectSize = cg->getMaxObjectSizeGuaranteedNotToOverflow();\n+   uintptr_t maxObjectSizeInElements = maxObjectSize / elementSize;\n+\n+   if (comp->target().is64Bit() && !(maxObjectSizeInElements >= 0 && maxObjectSizeInElements <= (uintptr_t)INT_MAX))\n+      {\n+      uint32_t high32 = maxObjectSizeInElements >> 32;\n+      generateRILInstruction(cg, TR::InstOpCode::LLIHF, node, temp1Reg, high32);\n+      generateRILInstruction(cg, TR::InstOpCode::IILF, node, temp1Reg, static_cast<uint32_t>(maxObjectSizeInElements));\n+      generateRIEInstruction(cg, TR::InstOpCode::CLGRJ, node, firstDimLenReg, temp1Reg, oolJumpLabel, TR::InstOpCode::COND_BRH);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIwNTM1MA=="}, "originalCommit": {"oid": "10d5904fe4cd34f70dcf0c92e294ba54ba930b38"}, "originalPosition": 115}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwNTYwNTQ0OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQyMToyMDo1MlrOH2yHtg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQyMjozNDozMVrOH3i9bA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIwNjMyNg==", "bodyText": "This too can be a generateS390CompareAndBranchInstruction.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r527206326", "createdAt": "2020-11-19T21:20:52Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,264 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n ///////////////////////////////////////////////////////////////////////////////////////\n // multianewArrayEvaluator:  multi-dimensional new array of objects\n ///////////////////////////////////////////////////////////////////////////////////////\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::acall);\n-   TR::Register * targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n-   }\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = (TR_J9VMBase *)(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt() != 2)\n+      {\n+      traceMsg(cg->comp(), \"multianewArrayEvaluator - More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      return performHelperCall(node, NULL, TR::acall, false, cg);\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   // oolJumpLabel is a common point that all branches will jump to. From this label, we branch to OOL code.\n+   // We do this instead of jumping directly to OOL code from mainline because the RA can only handle the case where there's\n+   // a single jump point to OOL code.\n+   TR::LabelSymbol *oolJumpLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));\n+\n+   TR::Register *secondDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, secondDimLenReg, generateS390MemoryReference(dimsPtrReg, 0, cg));\n+\n+   // Check to see if second dimension is indeed 0. If yes, then proceed to handle the case here. Otherwise jump to OOL code.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, secondDimLenReg, 0, TR::InstOpCode::COND_BNE, oolJumpLabel, false);\n+\n+   // Now check to see if first dimension is also 0. If yes, continue below to handle the case when length for both dimensions is 0. Otherwise jump to nonZeroFirstDimLabel.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, 0, TR::InstOpCode::COND_BNE, nonZeroFirstDimLabel, false);\n+\n+   // First dimension zero, so only allocate 1 zero-length object array\n+   int32_t zeroArraySize = TR::Compiler->om.discontiguousArrayHeaderSizeInBytes();\n+   TR::Register *vmThreadReg = cg->getMethodMetaDataRealRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, targetReg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+\n+   // Branch to OOL if there's not enough space for an array of size 0.\n+   TR::Register *temp1Reg = cg->allocateRegister();\n+   generateRIEInstruction(cg, TR::InstOpCode::getAddHalfWordImmDistinctOperandOpCode(), node, temp1Reg, targetReg, zeroArraySize);\n+   generateRXInstruction(cg, TR::InstOpCode::getCmpLogicalOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapTop), cg));\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BH, node, oolJumpLabel);\n+\n+   // If there's enough space, then we can continue to allocate.\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+   \n+   bool use64BitClasses = comp->target().is64Bit() && !TR::Compiler->om.generateCompressedObjectHeaders();\n+\n+   // Init class and fields, then jump to end of ICF\n+   generateRXInstruction(cg, use64BitClasses ? TR::InstOpCode::STG : TR::InstOpCode::ST, node, classReg, generateS390MemoryReference(targetReg, TR::Compiler->om.offsetOfObjectVftField(), cg));\n+   generateSILInstruction(cg, use64BitClasses ? TR::InstOpCode::MVGHI : TR::InstOpCode::MVHI, node, generateS390MemoryReference(targetReg, fej9->getOffsetOfContiguousArraySizeField(), cg), 0);\n+   generateSILInstruction(cg, use64BitClasses ? TR::InstOpCode::MVGHI : TR::InstOpCode::MVHI, node, generateS390MemoryReference(targetReg, fej9->getOffsetOfDiscontiguousArraySizeField(), cg), 0);\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);\n+\n+   // We end up in this region of the ICF if the first dimension is non-zero and the second dimension is zero.\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, nonZeroFirstDimLabel);\n+\n+   TR::Register *componentClassReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, componentClassReg, generateS390MemoryReference(classReg, offsetof(J9ArrayClass, componentType), cg));\n+\n+   // Calculate maximum allowable object size in elements and ump to OOL if it's higher than firstDimLenReg.\n+   int32_t elementSize = comp->useCompressedPointers() ? TR::Compiler->om.sizeofReferenceField() : static_cast<int32_t>(TR::Compiler->om.sizeofReferenceAddress());\n+   uintptr_t maxObjectSize = cg->getMaxObjectSizeGuaranteedNotToOverflow();\n+   uintptr_t maxObjectSizeInElements = maxObjectSize / elementSize;\n+\n+   if (comp->target().is64Bit() && !(maxObjectSizeInElements >= 0 && maxObjectSizeInElements <= (uintptr_t)INT_MAX))\n+      {\n+      uint32_t high32 = maxObjectSizeInElements >> 32;\n+      generateRILInstruction(cg, TR::InstOpCode::LLIHF, node, temp1Reg, high32);\n+      generateRILInstruction(cg, TR::InstOpCode::IILF, node, temp1Reg, static_cast<uint32_t>(maxObjectSizeInElements));\n+      generateRIEInstruction(cg, TR::InstOpCode::CLGRJ, node, firstDimLenReg, temp1Reg, oolJumpLabel, TR::InstOpCode::COND_BRH);\n+      }\n+   else\n+      {\n+      generateRILInstruction(cg, TR::InstOpCode::CFI, node, firstDimLenReg, static_cast<uint32_t>(maxObjectSizeInElements));\n+      generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BHR, node, oolJumpLabel);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10d5904fe4cd34f70dcf0c92e294ba54ba930b38"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAwNjUwOA==", "bodyText": "Fixed in 0d2a7a6", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r528006508", "createdAt": "2020-11-20T22:34:31Z", "author": {"login": "dchopra001"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,264 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n ///////////////////////////////////////////////////////////////////////////////////////\n // multianewArrayEvaluator:  multi-dimensional new array of objects\n ///////////////////////////////////////////////////////////////////////////////////////\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::acall);\n-   TR::Register * targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n-   }\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = (TR_J9VMBase *)(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt() != 2)\n+      {\n+      traceMsg(cg->comp(), \"multianewArrayEvaluator - More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      return performHelperCall(node, NULL, TR::acall, false, cg);\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   // oolJumpLabel is a common point that all branches will jump to. From this label, we branch to OOL code.\n+   // We do this instead of jumping directly to OOL code from mainline because the RA can only handle the case where there's\n+   // a single jump point to OOL code.\n+   TR::LabelSymbol *oolJumpLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));\n+\n+   TR::Register *secondDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, secondDimLenReg, generateS390MemoryReference(dimsPtrReg, 0, cg));\n+\n+   // Check to see if second dimension is indeed 0. If yes, then proceed to handle the case here. Otherwise jump to OOL code.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, secondDimLenReg, 0, TR::InstOpCode::COND_BNE, oolJumpLabel, false);\n+\n+   // Now check to see if first dimension is also 0. If yes, continue below to handle the case when length for both dimensions is 0. Otherwise jump to nonZeroFirstDimLabel.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, 0, TR::InstOpCode::COND_BNE, nonZeroFirstDimLabel, false);\n+\n+   // First dimension zero, so only allocate 1 zero-length object array\n+   int32_t zeroArraySize = TR::Compiler->om.discontiguousArrayHeaderSizeInBytes();\n+   TR::Register *vmThreadReg = cg->getMethodMetaDataRealRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, targetReg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+\n+   // Branch to OOL if there's not enough space for an array of size 0.\n+   TR::Register *temp1Reg = cg->allocateRegister();\n+   generateRIEInstruction(cg, TR::InstOpCode::getAddHalfWordImmDistinctOperandOpCode(), node, temp1Reg, targetReg, zeroArraySize);\n+   generateRXInstruction(cg, TR::InstOpCode::getCmpLogicalOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapTop), cg));\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BH, node, oolJumpLabel);\n+\n+   // If there's enough space, then we can continue to allocate.\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+   \n+   bool use64BitClasses = comp->target().is64Bit() && !TR::Compiler->om.generateCompressedObjectHeaders();\n+\n+   // Init class and fields, then jump to end of ICF\n+   generateRXInstruction(cg, use64BitClasses ? TR::InstOpCode::STG : TR::InstOpCode::ST, node, classReg, generateS390MemoryReference(targetReg, TR::Compiler->om.offsetOfObjectVftField(), cg));\n+   generateSILInstruction(cg, use64BitClasses ? TR::InstOpCode::MVGHI : TR::InstOpCode::MVHI, node, generateS390MemoryReference(targetReg, fej9->getOffsetOfContiguousArraySizeField(), cg), 0);\n+   generateSILInstruction(cg, use64BitClasses ? TR::InstOpCode::MVGHI : TR::InstOpCode::MVHI, node, generateS390MemoryReference(targetReg, fej9->getOffsetOfDiscontiguousArraySizeField(), cg), 0);\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);\n+\n+   // We end up in this region of the ICF if the first dimension is non-zero and the second dimension is zero.\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, nonZeroFirstDimLabel);\n+\n+   TR::Register *componentClassReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, componentClassReg, generateS390MemoryReference(classReg, offsetof(J9ArrayClass, componentType), cg));\n+\n+   // Calculate maximum allowable object size in elements and ump to OOL if it's higher than firstDimLenReg.\n+   int32_t elementSize = comp->useCompressedPointers() ? TR::Compiler->om.sizeofReferenceField() : static_cast<int32_t>(TR::Compiler->om.sizeofReferenceAddress());\n+   uintptr_t maxObjectSize = cg->getMaxObjectSizeGuaranteedNotToOverflow();\n+   uintptr_t maxObjectSizeInElements = maxObjectSize / elementSize;\n+\n+   if (comp->target().is64Bit() && !(maxObjectSizeInElements >= 0 && maxObjectSizeInElements <= (uintptr_t)INT_MAX))\n+      {\n+      uint32_t high32 = maxObjectSizeInElements >> 32;\n+      generateRILInstruction(cg, TR::InstOpCode::LLIHF, node, temp1Reg, high32);\n+      generateRILInstruction(cg, TR::InstOpCode::IILF, node, temp1Reg, static_cast<uint32_t>(maxObjectSizeInElements));\n+      generateRIEInstruction(cg, TR::InstOpCode::CLGRJ, node, firstDimLenReg, temp1Reg, oolJumpLabel, TR::InstOpCode::COND_BRH);\n+      }\n+   else\n+      {\n+      generateRILInstruction(cg, TR::InstOpCode::CFI, node, firstDimLenReg, static_cast<uint32_t>(maxObjectSizeInElements));\n+      generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BHR, node, oolJumpLabel);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIwNjMyNg=="}, "originalCommit": {"oid": "10d5904fe4cd34f70dcf0c92e294ba54ba930b38"}, "originalPosition": 120}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwNTYxMTg3OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQyMToyMjo0NFrOH2yLlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QwNDo1MjozNFrOH3_U_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIwNzMxNw==", "bodyText": "Is this ever even true? I don't think field width is ever smaller than object alignment.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r527207317", "createdAt": "2020-11-19T21:22:44Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,264 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n ///////////////////////////////////////////////////////////////////////////////////////\n // multianewArrayEvaluator:  multi-dimensional new array of objects\n ///////////////////////////////////////////////////////////////////////////////////////\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::acall);\n-   TR::Register * targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n-   }\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = (TR_J9VMBase *)(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt() != 2)\n+      {\n+      traceMsg(cg->comp(), \"multianewArrayEvaluator - More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      return performHelperCall(node, NULL, TR::acall, false, cg);\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   // oolJumpLabel is a common point that all branches will jump to. From this label, we branch to OOL code.\n+   // We do this instead of jumping directly to OOL code from mainline because the RA can only handle the case where there's\n+   // a single jump point to OOL code.\n+   TR::LabelSymbol *oolJumpLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));\n+\n+   TR::Register *secondDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, secondDimLenReg, generateS390MemoryReference(dimsPtrReg, 0, cg));\n+\n+   // Check to see if second dimension is indeed 0. If yes, then proceed to handle the case here. Otherwise jump to OOL code.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, secondDimLenReg, 0, TR::InstOpCode::COND_BNE, oolJumpLabel, false);\n+\n+   // Now check to see if first dimension is also 0. If yes, continue below to handle the case when length for both dimensions is 0. Otherwise jump to nonZeroFirstDimLabel.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, 0, TR::InstOpCode::COND_BNE, nonZeroFirstDimLabel, false);\n+\n+   // First dimension zero, so only allocate 1 zero-length object array\n+   int32_t zeroArraySize = TR::Compiler->om.discontiguousArrayHeaderSizeInBytes();\n+   TR::Register *vmThreadReg = cg->getMethodMetaDataRealRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, targetReg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+\n+   // Branch to OOL if there's not enough space for an array of size 0.\n+   TR::Register *temp1Reg = cg->allocateRegister();\n+   generateRIEInstruction(cg, TR::InstOpCode::getAddHalfWordImmDistinctOperandOpCode(), node, temp1Reg, targetReg, zeroArraySize);\n+   generateRXInstruction(cg, TR::InstOpCode::getCmpLogicalOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapTop), cg));\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BH, node, oolJumpLabel);\n+\n+   // If there's enough space, then we can continue to allocate.\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+   \n+   bool use64BitClasses = comp->target().is64Bit() && !TR::Compiler->om.generateCompressedObjectHeaders();\n+\n+   // Init class and fields, then jump to end of ICF\n+   generateRXInstruction(cg, use64BitClasses ? TR::InstOpCode::STG : TR::InstOpCode::ST, node, classReg, generateS390MemoryReference(targetReg, TR::Compiler->om.offsetOfObjectVftField(), cg));\n+   generateSILInstruction(cg, use64BitClasses ? TR::InstOpCode::MVGHI : TR::InstOpCode::MVHI, node, generateS390MemoryReference(targetReg, fej9->getOffsetOfContiguousArraySizeField(), cg), 0);\n+   generateSILInstruction(cg, use64BitClasses ? TR::InstOpCode::MVGHI : TR::InstOpCode::MVHI, node, generateS390MemoryReference(targetReg, fej9->getOffsetOfDiscontiguousArraySizeField(), cg), 0);\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);\n+\n+   // We end up in this region of the ICF if the first dimension is non-zero and the second dimension is zero.\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, nonZeroFirstDimLabel);\n+\n+   TR::Register *componentClassReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, componentClassReg, generateS390MemoryReference(classReg, offsetof(J9ArrayClass, componentType), cg));\n+\n+   // Calculate maximum allowable object size in elements and ump to OOL if it's higher than firstDimLenReg.\n+   int32_t elementSize = comp->useCompressedPointers() ? TR::Compiler->om.sizeofReferenceField() : static_cast<int32_t>(TR::Compiler->om.sizeofReferenceAddress());\n+   uintptr_t maxObjectSize = cg->getMaxObjectSizeGuaranteedNotToOverflow();\n+   uintptr_t maxObjectSizeInElements = maxObjectSize / elementSize;\n+\n+   if (comp->target().is64Bit() && !(maxObjectSizeInElements >= 0 && maxObjectSizeInElements <= (uintptr_t)INT_MAX))\n+      {\n+      uint32_t high32 = maxObjectSizeInElements >> 32;\n+      generateRILInstruction(cg, TR::InstOpCode::LLIHF, node, temp1Reg, high32);\n+      generateRILInstruction(cg, TR::InstOpCode::IILF, node, temp1Reg, static_cast<uint32_t>(maxObjectSizeInElements));\n+      generateRIEInstruction(cg, TR::InstOpCode::CLGRJ, node, firstDimLenReg, temp1Reg, oolJumpLabel, TR::InstOpCode::COND_BRH);\n+      }\n+   else\n+      {\n+      generateRILInstruction(cg, TR::InstOpCode::CFI, node, firstDimLenReg, static_cast<uint32_t>(maxObjectSizeInElements));\n+      generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BHR, node, oolJumpLabel);\n+      }\n+\n+   // Now check to see if we have enough space to do the allocation. If not then jump to OOL code.\n+   generateRRInstruction(cg, TR::InstOpCode::LR, node, temp1Reg, firstDimLenReg);\n+\n+   int32_t round = (elementSize >= TR::Compiler->om.objectAlignmentInBytes()) ? 0 : TR::Compiler->om.objectAlignmentInBytes();\n+   int32_t disp32 = round ? (round - 1) : 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10d5904fe4cd34f70dcf0c92e294ba54ba930b38"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzc3MDcyOA==", "bodyText": "I don't think it's possible. Object alignment is computed in [1] and it returns the maximum of OMR_MINIMUM_OBJECT_ALIGNMENT which is 8 [2], and the other value. So it is always at least 8. There are no array elements that are greater than 8 bytes in size, so this entire computation can be simplified.\n[1] https://github.com/eclipse/omr/blob/94b8b73a050f72c6afcfdfeafe94c897b3892794/gc/base/ObjectModelBase.hpp#L336\n[2] https://github.com/eclipse/omr/blob/94b8b73a050f72c6afcfdfeafe94c897b3892794/gc/base/ObjectModelBase.hpp#L50", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r527770728", "createdAt": "2020-11-20T15:32:32Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,264 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n ///////////////////////////////////////////////////////////////////////////////////////\n // multianewArrayEvaluator:  multi-dimensional new array of objects\n ///////////////////////////////////////////////////////////////////////////////////////\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::acall);\n-   TR::Register * targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n-   }\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = (TR_J9VMBase *)(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt() != 2)\n+      {\n+      traceMsg(cg->comp(), \"multianewArrayEvaluator - More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      return performHelperCall(node, NULL, TR::acall, false, cg);\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   // oolJumpLabel is a common point that all branches will jump to. From this label, we branch to OOL code.\n+   // We do this instead of jumping directly to OOL code from mainline because the RA can only handle the case where there's\n+   // a single jump point to OOL code.\n+   TR::LabelSymbol *oolJumpLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));\n+\n+   TR::Register *secondDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, secondDimLenReg, generateS390MemoryReference(dimsPtrReg, 0, cg));\n+\n+   // Check to see if second dimension is indeed 0. If yes, then proceed to handle the case here. Otherwise jump to OOL code.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, secondDimLenReg, 0, TR::InstOpCode::COND_BNE, oolJumpLabel, false);\n+\n+   // Now check to see if first dimension is also 0. If yes, continue below to handle the case when length for both dimensions is 0. Otherwise jump to nonZeroFirstDimLabel.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, 0, TR::InstOpCode::COND_BNE, nonZeroFirstDimLabel, false);\n+\n+   // First dimension zero, so only allocate 1 zero-length object array\n+   int32_t zeroArraySize = TR::Compiler->om.discontiguousArrayHeaderSizeInBytes();\n+   TR::Register *vmThreadReg = cg->getMethodMetaDataRealRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, targetReg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+\n+   // Branch to OOL if there's not enough space for an array of size 0.\n+   TR::Register *temp1Reg = cg->allocateRegister();\n+   generateRIEInstruction(cg, TR::InstOpCode::getAddHalfWordImmDistinctOperandOpCode(), node, temp1Reg, targetReg, zeroArraySize);\n+   generateRXInstruction(cg, TR::InstOpCode::getCmpLogicalOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapTop), cg));\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BH, node, oolJumpLabel);\n+\n+   // If there's enough space, then we can continue to allocate.\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+   \n+   bool use64BitClasses = comp->target().is64Bit() && !TR::Compiler->om.generateCompressedObjectHeaders();\n+\n+   // Init class and fields, then jump to end of ICF\n+   generateRXInstruction(cg, use64BitClasses ? TR::InstOpCode::STG : TR::InstOpCode::ST, node, classReg, generateS390MemoryReference(targetReg, TR::Compiler->om.offsetOfObjectVftField(), cg));\n+   generateSILInstruction(cg, use64BitClasses ? TR::InstOpCode::MVGHI : TR::InstOpCode::MVHI, node, generateS390MemoryReference(targetReg, fej9->getOffsetOfContiguousArraySizeField(), cg), 0);\n+   generateSILInstruction(cg, use64BitClasses ? TR::InstOpCode::MVGHI : TR::InstOpCode::MVHI, node, generateS390MemoryReference(targetReg, fej9->getOffsetOfDiscontiguousArraySizeField(), cg), 0);\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);\n+\n+   // We end up in this region of the ICF if the first dimension is non-zero and the second dimension is zero.\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, nonZeroFirstDimLabel);\n+\n+   TR::Register *componentClassReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, componentClassReg, generateS390MemoryReference(classReg, offsetof(J9ArrayClass, componentType), cg));\n+\n+   // Calculate maximum allowable object size in elements and ump to OOL if it's higher than firstDimLenReg.\n+   int32_t elementSize = comp->useCompressedPointers() ? TR::Compiler->om.sizeofReferenceField() : static_cast<int32_t>(TR::Compiler->om.sizeofReferenceAddress());\n+   uintptr_t maxObjectSize = cg->getMaxObjectSizeGuaranteedNotToOverflow();\n+   uintptr_t maxObjectSizeInElements = maxObjectSize / elementSize;\n+\n+   if (comp->target().is64Bit() && !(maxObjectSizeInElements >= 0 && maxObjectSizeInElements <= (uintptr_t)INT_MAX))\n+      {\n+      uint32_t high32 = maxObjectSizeInElements >> 32;\n+      generateRILInstruction(cg, TR::InstOpCode::LLIHF, node, temp1Reg, high32);\n+      generateRILInstruction(cg, TR::InstOpCode::IILF, node, temp1Reg, static_cast<uint32_t>(maxObjectSizeInElements));\n+      generateRIEInstruction(cg, TR::InstOpCode::CLGRJ, node, firstDimLenReg, temp1Reg, oolJumpLabel, TR::InstOpCode::COND_BRH);\n+      }\n+   else\n+      {\n+      generateRILInstruction(cg, TR::InstOpCode::CFI, node, firstDimLenReg, static_cast<uint32_t>(maxObjectSizeInElements));\n+      generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BHR, node, oolJumpLabel);\n+      }\n+\n+   // Now check to see if we have enough space to do the allocation. If not then jump to OOL code.\n+   generateRRInstruction(cg, TR::InstOpCode::LR, node, temp1Reg, firstDimLenReg);\n+\n+   int32_t round = (elementSize >= TR::Compiler->om.objectAlignmentInBytes()) ? 0 : TR::Compiler->om.objectAlignmentInBytes();\n+   int32_t disp32 = round ? (round - 1) : 0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIwNzMxNw=="}, "originalCommit": {"oid": "10d5904fe4cd34f70dcf0c92e294ba54ba930b38"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzc3NDkzNA==", "bodyText": "I was currently looking into this. But I'll try your suggestion first.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r527774934", "createdAt": "2020-11-20T15:39:00Z", "author": {"login": "dchopra001"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,264 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n ///////////////////////////////////////////////////////////////////////////////////////\n // multianewArrayEvaluator:  multi-dimensional new array of objects\n ///////////////////////////////////////////////////////////////////////////////////////\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::acall);\n-   TR::Register * targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n-   }\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = (TR_J9VMBase *)(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt() != 2)\n+      {\n+      traceMsg(cg->comp(), \"multianewArrayEvaluator - More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      return performHelperCall(node, NULL, TR::acall, false, cg);\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   // oolJumpLabel is a common point that all branches will jump to. From this label, we branch to OOL code.\n+   // We do this instead of jumping directly to OOL code from mainline because the RA can only handle the case where there's\n+   // a single jump point to OOL code.\n+   TR::LabelSymbol *oolJumpLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));\n+\n+   TR::Register *secondDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, secondDimLenReg, generateS390MemoryReference(dimsPtrReg, 0, cg));\n+\n+   // Check to see if second dimension is indeed 0. If yes, then proceed to handle the case here. Otherwise jump to OOL code.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, secondDimLenReg, 0, TR::InstOpCode::COND_BNE, oolJumpLabel, false);\n+\n+   // Now check to see if first dimension is also 0. If yes, continue below to handle the case when length for both dimensions is 0. Otherwise jump to nonZeroFirstDimLabel.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, 0, TR::InstOpCode::COND_BNE, nonZeroFirstDimLabel, false);\n+\n+   // First dimension zero, so only allocate 1 zero-length object array\n+   int32_t zeroArraySize = TR::Compiler->om.discontiguousArrayHeaderSizeInBytes();\n+   TR::Register *vmThreadReg = cg->getMethodMetaDataRealRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, targetReg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+\n+   // Branch to OOL if there's not enough space for an array of size 0.\n+   TR::Register *temp1Reg = cg->allocateRegister();\n+   generateRIEInstruction(cg, TR::InstOpCode::getAddHalfWordImmDistinctOperandOpCode(), node, temp1Reg, targetReg, zeroArraySize);\n+   generateRXInstruction(cg, TR::InstOpCode::getCmpLogicalOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapTop), cg));\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BH, node, oolJumpLabel);\n+\n+   // If there's enough space, then we can continue to allocate.\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+   \n+   bool use64BitClasses = comp->target().is64Bit() && !TR::Compiler->om.generateCompressedObjectHeaders();\n+\n+   // Init class and fields, then jump to end of ICF\n+   generateRXInstruction(cg, use64BitClasses ? TR::InstOpCode::STG : TR::InstOpCode::ST, node, classReg, generateS390MemoryReference(targetReg, TR::Compiler->om.offsetOfObjectVftField(), cg));\n+   generateSILInstruction(cg, use64BitClasses ? TR::InstOpCode::MVGHI : TR::InstOpCode::MVHI, node, generateS390MemoryReference(targetReg, fej9->getOffsetOfContiguousArraySizeField(), cg), 0);\n+   generateSILInstruction(cg, use64BitClasses ? TR::InstOpCode::MVGHI : TR::InstOpCode::MVHI, node, generateS390MemoryReference(targetReg, fej9->getOffsetOfDiscontiguousArraySizeField(), cg), 0);\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);\n+\n+   // We end up in this region of the ICF if the first dimension is non-zero and the second dimension is zero.\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, nonZeroFirstDimLabel);\n+\n+   TR::Register *componentClassReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, componentClassReg, generateS390MemoryReference(classReg, offsetof(J9ArrayClass, componentType), cg));\n+\n+   // Calculate maximum allowable object size in elements and ump to OOL if it's higher than firstDimLenReg.\n+   int32_t elementSize = comp->useCompressedPointers() ? TR::Compiler->om.sizeofReferenceField() : static_cast<int32_t>(TR::Compiler->om.sizeofReferenceAddress());\n+   uintptr_t maxObjectSize = cg->getMaxObjectSizeGuaranteedNotToOverflow();\n+   uintptr_t maxObjectSizeInElements = maxObjectSize / elementSize;\n+\n+   if (comp->target().is64Bit() && !(maxObjectSizeInElements >= 0 && maxObjectSizeInElements <= (uintptr_t)INT_MAX))\n+      {\n+      uint32_t high32 = maxObjectSizeInElements >> 32;\n+      generateRILInstruction(cg, TR::InstOpCode::LLIHF, node, temp1Reg, high32);\n+      generateRILInstruction(cg, TR::InstOpCode::IILF, node, temp1Reg, static_cast<uint32_t>(maxObjectSizeInElements));\n+      generateRIEInstruction(cg, TR::InstOpCode::CLGRJ, node, firstDimLenReg, temp1Reg, oolJumpLabel, TR::InstOpCode::COND_BRH);\n+      }\n+   else\n+      {\n+      generateRILInstruction(cg, TR::InstOpCode::CFI, node, firstDimLenReg, static_cast<uint32_t>(maxObjectSizeInElements));\n+      generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BHR, node, oolJumpLabel);\n+      }\n+\n+   // Now check to see if we have enough space to do the allocation. If not then jump to OOL code.\n+   generateRRInstruction(cg, TR::InstOpCode::LR, node, temp1Reg, firstDimLenReg);\n+\n+   int32_t round = (elementSize >= TR::Compiler->om.objectAlignmentInBytes()) ? 0 : TR::Compiler->om.objectAlignmentInBytes();\n+   int32_t disp32 = round ? (round - 1) : 0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIwNzMxNw=="}, "originalCommit": {"oid": "10d5904fe4cd34f70dcf0c92e294ba54ba930b38"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzkyMjExNg==", "bodyText": "Thought about this again. So elementSize is only 4 or 8 bytes realistically, so under 64-bit compressedrefs we can have the false case of the ternary here. We should use the OMR::align API here though.\nint32_t elementSizeAligned = OMR::align(elementSize, TR::Compiler->om.objectAlignmentInBytes());\nint32_t alignmentCompensation = (elementSize == elementSizeAligned) ? 0 : elementSizeAligned - 1;\n\n...\n\nif (alignmentCompensation != 0)\n   {\n   generateRILInstruction(cg, TR::InstOpCode::NILF, node, temp1Reg, -alignmentCompensation);\n   }", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r527922116", "createdAt": "2020-11-20T19:21:28Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,264 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n ///////////////////////////////////////////////////////////////////////////////////////\n // multianewArrayEvaluator:  multi-dimensional new array of objects\n ///////////////////////////////////////////////////////////////////////////////////////\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::acall);\n-   TR::Register * targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n-   }\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = (TR_J9VMBase *)(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt() != 2)\n+      {\n+      traceMsg(cg->comp(), \"multianewArrayEvaluator - More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      return performHelperCall(node, NULL, TR::acall, false, cg);\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   // oolJumpLabel is a common point that all branches will jump to. From this label, we branch to OOL code.\n+   // We do this instead of jumping directly to OOL code from mainline because the RA can only handle the case where there's\n+   // a single jump point to OOL code.\n+   TR::LabelSymbol *oolJumpLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));\n+\n+   TR::Register *secondDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, secondDimLenReg, generateS390MemoryReference(dimsPtrReg, 0, cg));\n+\n+   // Check to see if second dimension is indeed 0. If yes, then proceed to handle the case here. Otherwise jump to OOL code.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, secondDimLenReg, 0, TR::InstOpCode::COND_BNE, oolJumpLabel, false);\n+\n+   // Now check to see if first dimension is also 0. If yes, continue below to handle the case when length for both dimensions is 0. Otherwise jump to nonZeroFirstDimLabel.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, 0, TR::InstOpCode::COND_BNE, nonZeroFirstDimLabel, false);\n+\n+   // First dimension zero, so only allocate 1 zero-length object array\n+   int32_t zeroArraySize = TR::Compiler->om.discontiguousArrayHeaderSizeInBytes();\n+   TR::Register *vmThreadReg = cg->getMethodMetaDataRealRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, targetReg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+\n+   // Branch to OOL if there's not enough space for an array of size 0.\n+   TR::Register *temp1Reg = cg->allocateRegister();\n+   generateRIEInstruction(cg, TR::InstOpCode::getAddHalfWordImmDistinctOperandOpCode(), node, temp1Reg, targetReg, zeroArraySize);\n+   generateRXInstruction(cg, TR::InstOpCode::getCmpLogicalOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapTop), cg));\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BH, node, oolJumpLabel);\n+\n+   // If there's enough space, then we can continue to allocate.\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+   \n+   bool use64BitClasses = comp->target().is64Bit() && !TR::Compiler->om.generateCompressedObjectHeaders();\n+\n+   // Init class and fields, then jump to end of ICF\n+   generateRXInstruction(cg, use64BitClasses ? TR::InstOpCode::STG : TR::InstOpCode::ST, node, classReg, generateS390MemoryReference(targetReg, TR::Compiler->om.offsetOfObjectVftField(), cg));\n+   generateSILInstruction(cg, use64BitClasses ? TR::InstOpCode::MVGHI : TR::InstOpCode::MVHI, node, generateS390MemoryReference(targetReg, fej9->getOffsetOfContiguousArraySizeField(), cg), 0);\n+   generateSILInstruction(cg, use64BitClasses ? TR::InstOpCode::MVGHI : TR::InstOpCode::MVHI, node, generateS390MemoryReference(targetReg, fej9->getOffsetOfDiscontiguousArraySizeField(), cg), 0);\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);\n+\n+   // We end up in this region of the ICF if the first dimension is non-zero and the second dimension is zero.\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, nonZeroFirstDimLabel);\n+\n+   TR::Register *componentClassReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, componentClassReg, generateS390MemoryReference(classReg, offsetof(J9ArrayClass, componentType), cg));\n+\n+   // Calculate maximum allowable object size in elements and ump to OOL if it's higher than firstDimLenReg.\n+   int32_t elementSize = comp->useCompressedPointers() ? TR::Compiler->om.sizeofReferenceField() : static_cast<int32_t>(TR::Compiler->om.sizeofReferenceAddress());\n+   uintptr_t maxObjectSize = cg->getMaxObjectSizeGuaranteedNotToOverflow();\n+   uintptr_t maxObjectSizeInElements = maxObjectSize / elementSize;\n+\n+   if (comp->target().is64Bit() && !(maxObjectSizeInElements >= 0 && maxObjectSizeInElements <= (uintptr_t)INT_MAX))\n+      {\n+      uint32_t high32 = maxObjectSizeInElements >> 32;\n+      generateRILInstruction(cg, TR::InstOpCode::LLIHF, node, temp1Reg, high32);\n+      generateRILInstruction(cg, TR::InstOpCode::IILF, node, temp1Reg, static_cast<uint32_t>(maxObjectSizeInElements));\n+      generateRIEInstruction(cg, TR::InstOpCode::CLGRJ, node, firstDimLenReg, temp1Reg, oolJumpLabel, TR::InstOpCode::COND_BRH);\n+      }\n+   else\n+      {\n+      generateRILInstruction(cg, TR::InstOpCode::CFI, node, firstDimLenReg, static_cast<uint32_t>(maxObjectSizeInElements));\n+      generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BHR, node, oolJumpLabel);\n+      }\n+\n+   // Now check to see if we have enough space to do the allocation. If not then jump to OOL code.\n+   generateRRInstruction(cg, TR::InstOpCode::LR, node, temp1Reg, firstDimLenReg);\n+\n+   int32_t round = (elementSize >= TR::Compiler->om.objectAlignmentInBytes()) ? 0 : TR::Compiler->om.objectAlignmentInBytes();\n+   int32_t disp32 = round ? (round - 1) : 0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIwNzMxNw=="}, "originalCommit": {"oid": "10d5904fe4cd34f70dcf0c92e294ba54ba930b38"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQ3MTI5NA==", "bodyText": "Using the correct API in 0c0a523.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r528471294", "createdAt": "2020-11-23T04:52:34Z", "author": {"login": "dchopra001"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,264 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n ///////////////////////////////////////////////////////////////////////////////////////\n // multianewArrayEvaluator:  multi-dimensional new array of objects\n ///////////////////////////////////////////////////////////////////////////////////////\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::acall);\n-   TR::Register * targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n-   }\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = (TR_J9VMBase *)(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt() != 2)\n+      {\n+      traceMsg(cg->comp(), \"multianewArrayEvaluator - More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      return performHelperCall(node, NULL, TR::acall, false, cg);\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   // oolJumpLabel is a common point that all branches will jump to. From this label, we branch to OOL code.\n+   // We do this instead of jumping directly to OOL code from mainline because the RA can only handle the case where there's\n+   // a single jump point to OOL code.\n+   TR::LabelSymbol *oolJumpLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));\n+\n+   TR::Register *secondDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, secondDimLenReg, generateS390MemoryReference(dimsPtrReg, 0, cg));\n+\n+   // Check to see if second dimension is indeed 0. If yes, then proceed to handle the case here. Otherwise jump to OOL code.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, secondDimLenReg, 0, TR::InstOpCode::COND_BNE, oolJumpLabel, false);\n+\n+   // Now check to see if first dimension is also 0. If yes, continue below to handle the case when length for both dimensions is 0. Otherwise jump to nonZeroFirstDimLabel.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, 0, TR::InstOpCode::COND_BNE, nonZeroFirstDimLabel, false);\n+\n+   // First dimension zero, so only allocate 1 zero-length object array\n+   int32_t zeroArraySize = TR::Compiler->om.discontiguousArrayHeaderSizeInBytes();\n+   TR::Register *vmThreadReg = cg->getMethodMetaDataRealRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, targetReg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+\n+   // Branch to OOL if there's not enough space for an array of size 0.\n+   TR::Register *temp1Reg = cg->allocateRegister();\n+   generateRIEInstruction(cg, TR::InstOpCode::getAddHalfWordImmDistinctOperandOpCode(), node, temp1Reg, targetReg, zeroArraySize);\n+   generateRXInstruction(cg, TR::InstOpCode::getCmpLogicalOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapTop), cg));\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BH, node, oolJumpLabel);\n+\n+   // If there's enough space, then we can continue to allocate.\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+   \n+   bool use64BitClasses = comp->target().is64Bit() && !TR::Compiler->om.generateCompressedObjectHeaders();\n+\n+   // Init class and fields, then jump to end of ICF\n+   generateRXInstruction(cg, use64BitClasses ? TR::InstOpCode::STG : TR::InstOpCode::ST, node, classReg, generateS390MemoryReference(targetReg, TR::Compiler->om.offsetOfObjectVftField(), cg));\n+   generateSILInstruction(cg, use64BitClasses ? TR::InstOpCode::MVGHI : TR::InstOpCode::MVHI, node, generateS390MemoryReference(targetReg, fej9->getOffsetOfContiguousArraySizeField(), cg), 0);\n+   generateSILInstruction(cg, use64BitClasses ? TR::InstOpCode::MVGHI : TR::InstOpCode::MVHI, node, generateS390MemoryReference(targetReg, fej9->getOffsetOfDiscontiguousArraySizeField(), cg), 0);\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);\n+\n+   // We end up in this region of the ICF if the first dimension is non-zero and the second dimension is zero.\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, nonZeroFirstDimLabel);\n+\n+   TR::Register *componentClassReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, componentClassReg, generateS390MemoryReference(classReg, offsetof(J9ArrayClass, componentType), cg));\n+\n+   // Calculate maximum allowable object size in elements and ump to OOL if it's higher than firstDimLenReg.\n+   int32_t elementSize = comp->useCompressedPointers() ? TR::Compiler->om.sizeofReferenceField() : static_cast<int32_t>(TR::Compiler->om.sizeofReferenceAddress());\n+   uintptr_t maxObjectSize = cg->getMaxObjectSizeGuaranteedNotToOverflow();\n+   uintptr_t maxObjectSizeInElements = maxObjectSize / elementSize;\n+\n+   if (comp->target().is64Bit() && !(maxObjectSizeInElements >= 0 && maxObjectSizeInElements <= (uintptr_t)INT_MAX))\n+      {\n+      uint32_t high32 = maxObjectSizeInElements >> 32;\n+      generateRILInstruction(cg, TR::InstOpCode::LLIHF, node, temp1Reg, high32);\n+      generateRILInstruction(cg, TR::InstOpCode::IILF, node, temp1Reg, static_cast<uint32_t>(maxObjectSizeInElements));\n+      generateRIEInstruction(cg, TR::InstOpCode::CLGRJ, node, firstDimLenReg, temp1Reg, oolJumpLabel, TR::InstOpCode::COND_BRH);\n+      }\n+   else\n+      {\n+      generateRILInstruction(cg, TR::InstOpCode::CFI, node, firstDimLenReg, static_cast<uint32_t>(maxObjectSizeInElements));\n+      generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BHR, node, oolJumpLabel);\n+      }\n+\n+   // Now check to see if we have enough space to do the allocation. If not then jump to OOL code.\n+   generateRRInstruction(cg, TR::InstOpCode::LR, node, temp1Reg, firstDimLenReg);\n+\n+   int32_t round = (elementSize >= TR::Compiler->om.objectAlignmentInBytes()) ? 0 : TR::Compiler->om.objectAlignmentInBytes();\n+   int32_t disp32 = round ? (round - 1) : 0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIwNzMxNw=="}, "originalCommit": {"oid": "10d5904fe4cd34f70dcf0c92e294ba54ba930b38"}, "originalPosition": 127}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwNTYxODM4OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQyMToyNDozN1rOH2yPkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQyMjozNjo1N1rOH3jAzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIwODMzOA==", "bodyText": "This should be static const. Also why the _ underscore?", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r527208338", "createdAt": "2020-11-19T21:24:37Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,264 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n ///////////////////////////////////////////////////////////////////////////////////////\n // multianewArrayEvaluator:  multi-dimensional new array of objects\n ///////////////////////////////////////////////////////////////////////////////////////\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::acall);\n-   TR::Register * targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n-   }\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = (TR_J9VMBase *)(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt() != 2)\n+      {\n+      traceMsg(cg->comp(), \"multianewArrayEvaluator - More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      return performHelperCall(node, NULL, TR::acall, false, cg);\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   // oolJumpLabel is a common point that all branches will jump to. From this label, we branch to OOL code.\n+   // We do this instead of jumping directly to OOL code from mainline because the RA can only handle the case where there's\n+   // a single jump point to OOL code.\n+   TR::LabelSymbol *oolJumpLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));\n+\n+   TR::Register *secondDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, secondDimLenReg, generateS390MemoryReference(dimsPtrReg, 0, cg));\n+\n+   // Check to see if second dimension is indeed 0. If yes, then proceed to handle the case here. Otherwise jump to OOL code.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, secondDimLenReg, 0, TR::InstOpCode::COND_BNE, oolJumpLabel, false);\n+\n+   // Now check to see if first dimension is also 0. If yes, continue below to handle the case when length for both dimensions is 0. Otherwise jump to nonZeroFirstDimLabel.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, 0, TR::InstOpCode::COND_BNE, nonZeroFirstDimLabel, false);\n+\n+   // First dimension zero, so only allocate 1 zero-length object array\n+   int32_t zeroArraySize = TR::Compiler->om.discontiguousArrayHeaderSizeInBytes();\n+   TR::Register *vmThreadReg = cg->getMethodMetaDataRealRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, targetReg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+\n+   // Branch to OOL if there's not enough space for an array of size 0.\n+   TR::Register *temp1Reg = cg->allocateRegister();\n+   generateRIEInstruction(cg, TR::InstOpCode::getAddHalfWordImmDistinctOperandOpCode(), node, temp1Reg, targetReg, zeroArraySize);\n+   generateRXInstruction(cg, TR::InstOpCode::getCmpLogicalOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapTop), cg));\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BH, node, oolJumpLabel);\n+\n+   // If there's enough space, then we can continue to allocate.\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+   \n+   bool use64BitClasses = comp->target().is64Bit() && !TR::Compiler->om.generateCompressedObjectHeaders();\n+\n+   // Init class and fields, then jump to end of ICF\n+   generateRXInstruction(cg, use64BitClasses ? TR::InstOpCode::STG : TR::InstOpCode::ST, node, classReg, generateS390MemoryReference(targetReg, TR::Compiler->om.offsetOfObjectVftField(), cg));\n+   generateSILInstruction(cg, use64BitClasses ? TR::InstOpCode::MVGHI : TR::InstOpCode::MVHI, node, generateS390MemoryReference(targetReg, fej9->getOffsetOfContiguousArraySizeField(), cg), 0);\n+   generateSILInstruction(cg, use64BitClasses ? TR::InstOpCode::MVGHI : TR::InstOpCode::MVHI, node, generateS390MemoryReference(targetReg, fej9->getOffsetOfDiscontiguousArraySizeField(), cg), 0);\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);\n+\n+   // We end up in this region of the ICF if the first dimension is non-zero and the second dimension is zero.\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, nonZeroFirstDimLabel);\n+\n+   TR::Register *componentClassReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, componentClassReg, generateS390MemoryReference(classReg, offsetof(J9ArrayClass, componentType), cg));\n+\n+   // Calculate maximum allowable object size in elements and ump to OOL if it's higher than firstDimLenReg.\n+   int32_t elementSize = comp->useCompressedPointers() ? TR::Compiler->om.sizeofReferenceField() : static_cast<int32_t>(TR::Compiler->om.sizeofReferenceAddress());\n+   uintptr_t maxObjectSize = cg->getMaxObjectSizeGuaranteedNotToOverflow();\n+   uintptr_t maxObjectSizeInElements = maxObjectSize / elementSize;\n+\n+   if (comp->target().is64Bit() && !(maxObjectSizeInElements >= 0 && maxObjectSizeInElements <= (uintptr_t)INT_MAX))\n+      {\n+      uint32_t high32 = maxObjectSizeInElements >> 32;\n+      generateRILInstruction(cg, TR::InstOpCode::LLIHF, node, temp1Reg, high32);\n+      generateRILInstruction(cg, TR::InstOpCode::IILF, node, temp1Reg, static_cast<uint32_t>(maxObjectSizeInElements));\n+      generateRIEInstruction(cg, TR::InstOpCode::CLGRJ, node, firstDimLenReg, temp1Reg, oolJumpLabel, TR::InstOpCode::COND_BRH);\n+      }\n+   else\n+      {\n+      generateRILInstruction(cg, TR::InstOpCode::CFI, node, firstDimLenReg, static_cast<uint32_t>(maxObjectSizeInElements));\n+      generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BHR, node, oolJumpLabel);\n+      }\n+\n+   // Now check to see if we have enough space to do the allocation. If not then jump to OOL code.\n+   generateRRInstruction(cg, TR::InstOpCode::LR, node, temp1Reg, firstDimLenReg);\n+\n+   int32_t round = (elementSize >= TR::Compiler->om.objectAlignmentInBytes()) ? 0 : TR::Compiler->om.objectAlignmentInBytes();\n+   int32_t disp32 = round ? (round - 1) : 0;\n+\n+   uint8_t _multiplierToStrideMap[] = {0, 0, 1, 0, 2, 0, 0, 0, 3};", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10d5904fe4cd34f70dcf0c92e294ba54ba930b38"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAwNzM3NA==", "bodyText": "Both issues addressed in: 0d2a7a6", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r528007374", "createdAt": "2020-11-20T22:36:57Z", "author": {"login": "dchopra001"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,264 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n ///////////////////////////////////////////////////////////////////////////////////////\n // multianewArrayEvaluator:  multi-dimensional new array of objects\n ///////////////////////////////////////////////////////////////////////////////////////\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::acall);\n-   TR::Register * targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n-   }\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = (TR_J9VMBase *)(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt() != 2)\n+      {\n+      traceMsg(cg->comp(), \"multianewArrayEvaluator - More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      return performHelperCall(node, NULL, TR::acall, false, cg);\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   // oolJumpLabel is a common point that all branches will jump to. From this label, we branch to OOL code.\n+   // We do this instead of jumping directly to OOL code from mainline because the RA can only handle the case where there's\n+   // a single jump point to OOL code.\n+   TR::LabelSymbol *oolJumpLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));\n+\n+   TR::Register *secondDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, secondDimLenReg, generateS390MemoryReference(dimsPtrReg, 0, cg));\n+\n+   // Check to see if second dimension is indeed 0. If yes, then proceed to handle the case here. Otherwise jump to OOL code.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, secondDimLenReg, 0, TR::InstOpCode::COND_BNE, oolJumpLabel, false);\n+\n+   // Now check to see if first dimension is also 0. If yes, continue below to handle the case when length for both dimensions is 0. Otherwise jump to nonZeroFirstDimLabel.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, 0, TR::InstOpCode::COND_BNE, nonZeroFirstDimLabel, false);\n+\n+   // First dimension zero, so only allocate 1 zero-length object array\n+   int32_t zeroArraySize = TR::Compiler->om.discontiguousArrayHeaderSizeInBytes();\n+   TR::Register *vmThreadReg = cg->getMethodMetaDataRealRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, targetReg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+\n+   // Branch to OOL if there's not enough space for an array of size 0.\n+   TR::Register *temp1Reg = cg->allocateRegister();\n+   generateRIEInstruction(cg, TR::InstOpCode::getAddHalfWordImmDistinctOperandOpCode(), node, temp1Reg, targetReg, zeroArraySize);\n+   generateRXInstruction(cg, TR::InstOpCode::getCmpLogicalOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapTop), cg));\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BH, node, oolJumpLabel);\n+\n+   // If there's enough space, then we can continue to allocate.\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+   \n+   bool use64BitClasses = comp->target().is64Bit() && !TR::Compiler->om.generateCompressedObjectHeaders();\n+\n+   // Init class and fields, then jump to end of ICF\n+   generateRXInstruction(cg, use64BitClasses ? TR::InstOpCode::STG : TR::InstOpCode::ST, node, classReg, generateS390MemoryReference(targetReg, TR::Compiler->om.offsetOfObjectVftField(), cg));\n+   generateSILInstruction(cg, use64BitClasses ? TR::InstOpCode::MVGHI : TR::InstOpCode::MVHI, node, generateS390MemoryReference(targetReg, fej9->getOffsetOfContiguousArraySizeField(), cg), 0);\n+   generateSILInstruction(cg, use64BitClasses ? TR::InstOpCode::MVGHI : TR::InstOpCode::MVHI, node, generateS390MemoryReference(targetReg, fej9->getOffsetOfDiscontiguousArraySizeField(), cg), 0);\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);\n+\n+   // We end up in this region of the ICF if the first dimension is non-zero and the second dimension is zero.\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, nonZeroFirstDimLabel);\n+\n+   TR::Register *componentClassReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, componentClassReg, generateS390MemoryReference(classReg, offsetof(J9ArrayClass, componentType), cg));\n+\n+   // Calculate maximum allowable object size in elements and ump to OOL if it's higher than firstDimLenReg.\n+   int32_t elementSize = comp->useCompressedPointers() ? TR::Compiler->om.sizeofReferenceField() : static_cast<int32_t>(TR::Compiler->om.sizeofReferenceAddress());\n+   uintptr_t maxObjectSize = cg->getMaxObjectSizeGuaranteedNotToOverflow();\n+   uintptr_t maxObjectSizeInElements = maxObjectSize / elementSize;\n+\n+   if (comp->target().is64Bit() && !(maxObjectSizeInElements >= 0 && maxObjectSizeInElements <= (uintptr_t)INT_MAX))\n+      {\n+      uint32_t high32 = maxObjectSizeInElements >> 32;\n+      generateRILInstruction(cg, TR::InstOpCode::LLIHF, node, temp1Reg, high32);\n+      generateRILInstruction(cg, TR::InstOpCode::IILF, node, temp1Reg, static_cast<uint32_t>(maxObjectSizeInElements));\n+      generateRIEInstruction(cg, TR::InstOpCode::CLGRJ, node, firstDimLenReg, temp1Reg, oolJumpLabel, TR::InstOpCode::COND_BRH);\n+      }\n+   else\n+      {\n+      generateRILInstruction(cg, TR::InstOpCode::CFI, node, firstDimLenReg, static_cast<uint32_t>(maxObjectSizeInElements));\n+      generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BHR, node, oolJumpLabel);\n+      }\n+\n+   // Now check to see if we have enough space to do the allocation. If not then jump to OOL code.\n+   generateRRInstruction(cg, TR::InstOpCode::LR, node, temp1Reg, firstDimLenReg);\n+\n+   int32_t round = (elementSize >= TR::Compiler->om.objectAlignmentInBytes()) ? 0 : TR::Compiler->om.objectAlignmentInBytes();\n+   int32_t disp32 = round ? (round - 1) : 0;\n+\n+   uint8_t _multiplierToStrideMap[] = {0, 0, 1, 0, 2, 0, 0, 0, 3};", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIwODMzOA=="}, "originalCommit": {"oid": "10d5904fe4cd34f70dcf0c92e294ba54ba930b38"}, "originalPosition": 129}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwNTYyMjE4OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQyMToyNTo0NFrOH2yR6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQyMjozNzoyMlrOH3jBOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIwODkzNg==", "bodyText": "We should inline this variable as it is only used once.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r527208936", "createdAt": "2020-11-19T21:25:44Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,264 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n ///////////////////////////////////////////////////////////////////////////////////////\n // multianewArrayEvaluator:  multi-dimensional new array of objects\n ///////////////////////////////////////////////////////////////////////////////////////\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::acall);\n-   TR::Register * targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n-   }\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = (TR_J9VMBase *)(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt() != 2)\n+      {\n+      traceMsg(cg->comp(), \"multianewArrayEvaluator - More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      return performHelperCall(node, NULL, TR::acall, false, cg);\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   // oolJumpLabel is a common point that all branches will jump to. From this label, we branch to OOL code.\n+   // We do this instead of jumping directly to OOL code from mainline because the RA can only handle the case where there's\n+   // a single jump point to OOL code.\n+   TR::LabelSymbol *oolJumpLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));\n+\n+   TR::Register *secondDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, secondDimLenReg, generateS390MemoryReference(dimsPtrReg, 0, cg));\n+\n+   // Check to see if second dimension is indeed 0. If yes, then proceed to handle the case here. Otherwise jump to OOL code.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, secondDimLenReg, 0, TR::InstOpCode::COND_BNE, oolJumpLabel, false);\n+\n+   // Now check to see if first dimension is also 0. If yes, continue below to handle the case when length for both dimensions is 0. Otherwise jump to nonZeroFirstDimLabel.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, 0, TR::InstOpCode::COND_BNE, nonZeroFirstDimLabel, false);\n+\n+   // First dimension zero, so only allocate 1 zero-length object array\n+   int32_t zeroArraySize = TR::Compiler->om.discontiguousArrayHeaderSizeInBytes();\n+   TR::Register *vmThreadReg = cg->getMethodMetaDataRealRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, targetReg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+\n+   // Branch to OOL if there's not enough space for an array of size 0.\n+   TR::Register *temp1Reg = cg->allocateRegister();\n+   generateRIEInstruction(cg, TR::InstOpCode::getAddHalfWordImmDistinctOperandOpCode(), node, temp1Reg, targetReg, zeroArraySize);\n+   generateRXInstruction(cg, TR::InstOpCode::getCmpLogicalOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapTop), cg));\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BH, node, oolJumpLabel);\n+\n+   // If there's enough space, then we can continue to allocate.\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+   \n+   bool use64BitClasses = comp->target().is64Bit() && !TR::Compiler->om.generateCompressedObjectHeaders();\n+\n+   // Init class and fields, then jump to end of ICF\n+   generateRXInstruction(cg, use64BitClasses ? TR::InstOpCode::STG : TR::InstOpCode::ST, node, classReg, generateS390MemoryReference(targetReg, TR::Compiler->om.offsetOfObjectVftField(), cg));\n+   generateSILInstruction(cg, use64BitClasses ? TR::InstOpCode::MVGHI : TR::InstOpCode::MVHI, node, generateS390MemoryReference(targetReg, fej9->getOffsetOfContiguousArraySizeField(), cg), 0);\n+   generateSILInstruction(cg, use64BitClasses ? TR::InstOpCode::MVGHI : TR::InstOpCode::MVHI, node, generateS390MemoryReference(targetReg, fej9->getOffsetOfDiscontiguousArraySizeField(), cg), 0);\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);\n+\n+   // We end up in this region of the ICF if the first dimension is non-zero and the second dimension is zero.\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, nonZeroFirstDimLabel);\n+\n+   TR::Register *componentClassReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, componentClassReg, generateS390MemoryReference(classReg, offsetof(J9ArrayClass, componentType), cg));\n+\n+   // Calculate maximum allowable object size in elements and ump to OOL if it's higher than firstDimLenReg.\n+   int32_t elementSize = comp->useCompressedPointers() ? TR::Compiler->om.sizeofReferenceField() : static_cast<int32_t>(TR::Compiler->om.sizeofReferenceAddress());\n+   uintptr_t maxObjectSize = cg->getMaxObjectSizeGuaranteedNotToOverflow();\n+   uintptr_t maxObjectSizeInElements = maxObjectSize / elementSize;\n+\n+   if (comp->target().is64Bit() && !(maxObjectSizeInElements >= 0 && maxObjectSizeInElements <= (uintptr_t)INT_MAX))\n+      {\n+      uint32_t high32 = maxObjectSizeInElements >> 32;\n+      generateRILInstruction(cg, TR::InstOpCode::LLIHF, node, temp1Reg, high32);\n+      generateRILInstruction(cg, TR::InstOpCode::IILF, node, temp1Reg, static_cast<uint32_t>(maxObjectSizeInElements));\n+      generateRIEInstruction(cg, TR::InstOpCode::CLGRJ, node, firstDimLenReg, temp1Reg, oolJumpLabel, TR::InstOpCode::COND_BRH);\n+      }\n+   else\n+      {\n+      generateRILInstruction(cg, TR::InstOpCode::CFI, node, firstDimLenReg, static_cast<uint32_t>(maxObjectSizeInElements));\n+      generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BHR, node, oolJumpLabel);\n+      }\n+\n+   // Now check to see if we have enough space to do the allocation. If not then jump to OOL code.\n+   generateRRInstruction(cg, TR::InstOpCode::LR, node, temp1Reg, firstDimLenReg);\n+\n+   int32_t round = (elementSize >= TR::Compiler->om.objectAlignmentInBytes()) ? 0 : TR::Compiler->om.objectAlignmentInBytes();\n+   int32_t disp32 = round ? (round - 1) : 0;\n+\n+   uint8_t _multiplierToStrideMap[] = {0, 0, 1, 0, 2, 0, 0, 0, 3};\n+   uint8_t shiftVal = _multiplierToStrideMap[elementSize];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10d5904fe4cd34f70dcf0c92e294ba54ba930b38"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAwNzQ4MQ==", "bodyText": "Done in: 0d2a7a6", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r528007481", "createdAt": "2020-11-20T22:37:22Z", "author": {"login": "dchopra001"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,264 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n ///////////////////////////////////////////////////////////////////////////////////////\n // multianewArrayEvaluator:  multi-dimensional new array of objects\n ///////////////////////////////////////////////////////////////////////////////////////\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::acall);\n-   TR::Register * targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n-   }\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = (TR_J9VMBase *)(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt() != 2)\n+      {\n+      traceMsg(cg->comp(), \"multianewArrayEvaluator - More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      return performHelperCall(node, NULL, TR::acall, false, cg);\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   // oolJumpLabel is a common point that all branches will jump to. From this label, we branch to OOL code.\n+   // We do this instead of jumping directly to OOL code from mainline because the RA can only handle the case where there's\n+   // a single jump point to OOL code.\n+   TR::LabelSymbol *oolJumpLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));\n+\n+   TR::Register *secondDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, secondDimLenReg, generateS390MemoryReference(dimsPtrReg, 0, cg));\n+\n+   // Check to see if second dimension is indeed 0. If yes, then proceed to handle the case here. Otherwise jump to OOL code.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, secondDimLenReg, 0, TR::InstOpCode::COND_BNE, oolJumpLabel, false);\n+\n+   // Now check to see if first dimension is also 0. If yes, continue below to handle the case when length for both dimensions is 0. Otherwise jump to nonZeroFirstDimLabel.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, 0, TR::InstOpCode::COND_BNE, nonZeroFirstDimLabel, false);\n+\n+   // First dimension zero, so only allocate 1 zero-length object array\n+   int32_t zeroArraySize = TR::Compiler->om.discontiguousArrayHeaderSizeInBytes();\n+   TR::Register *vmThreadReg = cg->getMethodMetaDataRealRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, targetReg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+\n+   // Branch to OOL if there's not enough space for an array of size 0.\n+   TR::Register *temp1Reg = cg->allocateRegister();\n+   generateRIEInstruction(cg, TR::InstOpCode::getAddHalfWordImmDistinctOperandOpCode(), node, temp1Reg, targetReg, zeroArraySize);\n+   generateRXInstruction(cg, TR::InstOpCode::getCmpLogicalOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapTop), cg));\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BH, node, oolJumpLabel);\n+\n+   // If there's enough space, then we can continue to allocate.\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+   \n+   bool use64BitClasses = comp->target().is64Bit() && !TR::Compiler->om.generateCompressedObjectHeaders();\n+\n+   // Init class and fields, then jump to end of ICF\n+   generateRXInstruction(cg, use64BitClasses ? TR::InstOpCode::STG : TR::InstOpCode::ST, node, classReg, generateS390MemoryReference(targetReg, TR::Compiler->om.offsetOfObjectVftField(), cg));\n+   generateSILInstruction(cg, use64BitClasses ? TR::InstOpCode::MVGHI : TR::InstOpCode::MVHI, node, generateS390MemoryReference(targetReg, fej9->getOffsetOfContiguousArraySizeField(), cg), 0);\n+   generateSILInstruction(cg, use64BitClasses ? TR::InstOpCode::MVGHI : TR::InstOpCode::MVHI, node, generateS390MemoryReference(targetReg, fej9->getOffsetOfDiscontiguousArraySizeField(), cg), 0);\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);\n+\n+   // We end up in this region of the ICF if the first dimension is non-zero and the second dimension is zero.\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, nonZeroFirstDimLabel);\n+\n+   TR::Register *componentClassReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, componentClassReg, generateS390MemoryReference(classReg, offsetof(J9ArrayClass, componentType), cg));\n+\n+   // Calculate maximum allowable object size in elements and ump to OOL if it's higher than firstDimLenReg.\n+   int32_t elementSize = comp->useCompressedPointers() ? TR::Compiler->om.sizeofReferenceField() : static_cast<int32_t>(TR::Compiler->om.sizeofReferenceAddress());\n+   uintptr_t maxObjectSize = cg->getMaxObjectSizeGuaranteedNotToOverflow();\n+   uintptr_t maxObjectSizeInElements = maxObjectSize / elementSize;\n+\n+   if (comp->target().is64Bit() && !(maxObjectSizeInElements >= 0 && maxObjectSizeInElements <= (uintptr_t)INT_MAX))\n+      {\n+      uint32_t high32 = maxObjectSizeInElements >> 32;\n+      generateRILInstruction(cg, TR::InstOpCode::LLIHF, node, temp1Reg, high32);\n+      generateRILInstruction(cg, TR::InstOpCode::IILF, node, temp1Reg, static_cast<uint32_t>(maxObjectSizeInElements));\n+      generateRIEInstruction(cg, TR::InstOpCode::CLGRJ, node, firstDimLenReg, temp1Reg, oolJumpLabel, TR::InstOpCode::COND_BRH);\n+      }\n+   else\n+      {\n+      generateRILInstruction(cg, TR::InstOpCode::CFI, node, firstDimLenReg, static_cast<uint32_t>(maxObjectSizeInElements));\n+      generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BHR, node, oolJumpLabel);\n+      }\n+\n+   // Now check to see if we have enough space to do the allocation. If not then jump to OOL code.\n+   generateRRInstruction(cg, TR::InstOpCode::LR, node, temp1Reg, firstDimLenReg);\n+\n+   int32_t round = (elementSize >= TR::Compiler->om.objectAlignmentInBytes()) ? 0 : TR::Compiler->om.objectAlignmentInBytes();\n+   int32_t disp32 = round ? (round - 1) : 0;\n+\n+   uint8_t _multiplierToStrideMap[] = {0, 0, 1, 0, 2, 0, 0, 0, 3};\n+   uint8_t shiftVal = _multiplierToStrideMap[elementSize];", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIwODkzNg=="}, "originalCommit": {"oid": "10d5904fe4cd34f70dcf0c92e294ba54ba930b38"}, "originalPosition": 130}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwNTYyOTU0OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQyMToyODowMlrOH2yWjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQyMjozNzo0M1rOH3jBkw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIxMDEyNg==", "bodyText": "You don't need the ternary here. sizeofReferenceField already checks for compressedrefs and returns the right thing.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r527210126", "createdAt": "2020-11-19T21:28:02Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,264 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n ///////////////////////////////////////////////////////////////////////////////////////\n // multianewArrayEvaluator:  multi-dimensional new array of objects\n ///////////////////////////////////////////////////////////////////////////////////////\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::acall);\n-   TR::Register * targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n-   }\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = (TR_J9VMBase *)(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt() != 2)\n+      {\n+      traceMsg(cg->comp(), \"multianewArrayEvaluator - More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      return performHelperCall(node, NULL, TR::acall, false, cg);\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   // oolJumpLabel is a common point that all branches will jump to. From this label, we branch to OOL code.\n+   // We do this instead of jumping directly to OOL code from mainline because the RA can only handle the case where there's\n+   // a single jump point to OOL code.\n+   TR::LabelSymbol *oolJumpLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));\n+\n+   TR::Register *secondDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, secondDimLenReg, generateS390MemoryReference(dimsPtrReg, 0, cg));\n+\n+   // Check to see if second dimension is indeed 0. If yes, then proceed to handle the case here. Otherwise jump to OOL code.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, secondDimLenReg, 0, TR::InstOpCode::COND_BNE, oolJumpLabel, false);\n+\n+   // Now check to see if first dimension is also 0. If yes, continue below to handle the case when length for both dimensions is 0. Otherwise jump to nonZeroFirstDimLabel.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, 0, TR::InstOpCode::COND_BNE, nonZeroFirstDimLabel, false);\n+\n+   // First dimension zero, so only allocate 1 zero-length object array\n+   int32_t zeroArraySize = TR::Compiler->om.discontiguousArrayHeaderSizeInBytes();\n+   TR::Register *vmThreadReg = cg->getMethodMetaDataRealRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, targetReg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+\n+   // Branch to OOL if there's not enough space for an array of size 0.\n+   TR::Register *temp1Reg = cg->allocateRegister();\n+   generateRIEInstruction(cg, TR::InstOpCode::getAddHalfWordImmDistinctOperandOpCode(), node, temp1Reg, targetReg, zeroArraySize);\n+   generateRXInstruction(cg, TR::InstOpCode::getCmpLogicalOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapTop), cg));\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BH, node, oolJumpLabel);\n+\n+   // If there's enough space, then we can continue to allocate.\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+   \n+   bool use64BitClasses = comp->target().is64Bit() && !TR::Compiler->om.generateCompressedObjectHeaders();\n+\n+   // Init class and fields, then jump to end of ICF\n+   generateRXInstruction(cg, use64BitClasses ? TR::InstOpCode::STG : TR::InstOpCode::ST, node, classReg, generateS390MemoryReference(targetReg, TR::Compiler->om.offsetOfObjectVftField(), cg));\n+   generateSILInstruction(cg, use64BitClasses ? TR::InstOpCode::MVGHI : TR::InstOpCode::MVHI, node, generateS390MemoryReference(targetReg, fej9->getOffsetOfContiguousArraySizeField(), cg), 0);\n+   generateSILInstruction(cg, use64BitClasses ? TR::InstOpCode::MVGHI : TR::InstOpCode::MVHI, node, generateS390MemoryReference(targetReg, fej9->getOffsetOfDiscontiguousArraySizeField(), cg), 0);\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);\n+\n+   // We end up in this region of the ICF if the first dimension is non-zero and the second dimension is zero.\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, nonZeroFirstDimLabel);\n+\n+   TR::Register *componentClassReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, componentClassReg, generateS390MemoryReference(classReg, offsetof(J9ArrayClass, componentType), cg));\n+\n+   // Calculate maximum allowable object size in elements and ump to OOL if it's higher than firstDimLenReg.\n+   int32_t elementSize = comp->useCompressedPointers() ? TR::Compiler->om.sizeofReferenceField() : static_cast<int32_t>(TR::Compiler->om.sizeofReferenceAddress());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10d5904fe4cd34f70dcf0c92e294ba54ba930b38"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAwNzU3MQ==", "bodyText": "Simplified in 0d2a7a6", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r528007571", "createdAt": "2020-11-20T22:37:43Z", "author": {"login": "dchopra001"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,264 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n ///////////////////////////////////////////////////////////////////////////////////////\n // multianewArrayEvaluator:  multi-dimensional new array of objects\n ///////////////////////////////////////////////////////////////////////////////////////\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::acall);\n-   TR::Register * targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n-   }\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = (TR_J9VMBase *)(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt() != 2)\n+      {\n+      traceMsg(cg->comp(), \"multianewArrayEvaluator - More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      return performHelperCall(node, NULL, TR::acall, false, cg);\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   // oolJumpLabel is a common point that all branches will jump to. From this label, we branch to OOL code.\n+   // We do this instead of jumping directly to OOL code from mainline because the RA can only handle the case where there's\n+   // a single jump point to OOL code.\n+   TR::LabelSymbol *oolJumpLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));\n+\n+   TR::Register *secondDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, secondDimLenReg, generateS390MemoryReference(dimsPtrReg, 0, cg));\n+\n+   // Check to see if second dimension is indeed 0. If yes, then proceed to handle the case here. Otherwise jump to OOL code.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, secondDimLenReg, 0, TR::InstOpCode::COND_BNE, oolJumpLabel, false);\n+\n+   // Now check to see if first dimension is also 0. If yes, continue below to handle the case when length for both dimensions is 0. Otherwise jump to nonZeroFirstDimLabel.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, 0, TR::InstOpCode::COND_BNE, nonZeroFirstDimLabel, false);\n+\n+   // First dimension zero, so only allocate 1 zero-length object array\n+   int32_t zeroArraySize = TR::Compiler->om.discontiguousArrayHeaderSizeInBytes();\n+   TR::Register *vmThreadReg = cg->getMethodMetaDataRealRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, targetReg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+\n+   // Branch to OOL if there's not enough space for an array of size 0.\n+   TR::Register *temp1Reg = cg->allocateRegister();\n+   generateRIEInstruction(cg, TR::InstOpCode::getAddHalfWordImmDistinctOperandOpCode(), node, temp1Reg, targetReg, zeroArraySize);\n+   generateRXInstruction(cg, TR::InstOpCode::getCmpLogicalOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapTop), cg));\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BH, node, oolJumpLabel);\n+\n+   // If there's enough space, then we can continue to allocate.\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+   \n+   bool use64BitClasses = comp->target().is64Bit() && !TR::Compiler->om.generateCompressedObjectHeaders();\n+\n+   // Init class and fields, then jump to end of ICF\n+   generateRXInstruction(cg, use64BitClasses ? TR::InstOpCode::STG : TR::InstOpCode::ST, node, classReg, generateS390MemoryReference(targetReg, TR::Compiler->om.offsetOfObjectVftField(), cg));\n+   generateSILInstruction(cg, use64BitClasses ? TR::InstOpCode::MVGHI : TR::InstOpCode::MVHI, node, generateS390MemoryReference(targetReg, fej9->getOffsetOfContiguousArraySizeField(), cg), 0);\n+   generateSILInstruction(cg, use64BitClasses ? TR::InstOpCode::MVGHI : TR::InstOpCode::MVHI, node, generateS390MemoryReference(targetReg, fej9->getOffsetOfDiscontiguousArraySizeField(), cg), 0);\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);\n+\n+   // We end up in this region of the ICF if the first dimension is non-zero and the second dimension is zero.\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, nonZeroFirstDimLabel);\n+\n+   TR::Register *componentClassReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, componentClassReg, generateS390MemoryReference(classReg, offsetof(J9ArrayClass, componentType), cg));\n+\n+   // Calculate maximum allowable object size in elements and ump to OOL if it's higher than firstDimLenReg.\n+   int32_t elementSize = comp->useCompressedPointers() ? TR::Compiler->om.sizeofReferenceField() : static_cast<int32_t>(TR::Compiler->om.sizeofReferenceAddress());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIxMDEyNg=="}, "originalCommit": {"oid": "10d5904fe4cd34f70dcf0c92e294ba54ba930b38"}, "originalPosition": 106}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwOTg4OTE2OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxODowMDozNFrOH3bGTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMlQxOTozNjozNFrOH36lmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzg3NzcxMQ==", "bodyText": "We don't need to zero out memory on Z since it is already bulk cleared. We should remove these two stores.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r527877711", "createdAt": "2020-11-20T18:00:34Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,259 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n ///////////////////////////////////////////////////////////////////////////////////////\n // multianewArrayEvaluator:  multi-dimensional new array of objects\n ///////////////////////////////////////////////////////////////////////////////////////\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::acall);\n-   TR::Register * targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n-   }\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = static_cast<TR_J9VMBase *>(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt() != 2)\n+      {\n+      traceMsg(cg->comp(), \"multianewArrayEvaluator - More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      return performHelperCall(node, NULL, TR::acall, false, cg);\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   // oolJumpLabel is a common point that all branches will jump to. From this label, we branch to OOL code.\n+   // We do this instead of jumping directly to OOL code from mainline because the RA can only handle the case where there's\n+   // a single jump point to OOL code.\n+   TR::LabelSymbol *oolJumpLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));\n+\n+   TR::Register *secondDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, secondDimLenReg, generateS390MemoryReference(dimsPtrReg, 0, cg));\n+\n+   // Check to see if second dimension is indeed 0. If yes, then proceed to handle the case here. Otherwise jump to OOL code.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, secondDimLenReg, 0, TR::InstOpCode::COND_BNE, oolJumpLabel, false);\n+\n+   // Now check to see if first dimension is also 0. If yes, continue below to handle the case when length for both dimensions is 0. Otherwise jump to nonZeroFirstDimLabel.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, 0, TR::InstOpCode::COND_BNE, nonZeroFirstDimLabel, false);\n+\n+   // First dimension zero, so only allocate 1 zero-length object array\n+   int32_t zeroArraySize = TR::Compiler->om.discontiguousArrayHeaderSizeInBytes();\n+   TR::Register *vmThreadReg = cg->getMethodMetaDataRealRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, targetReg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+\n+   // Branch to OOL if there's not enough space for an array of size 0.\n+   TR::Register *temp1Reg = cg->allocateRegister();\n+   generateRIEInstruction(cg, TR::InstOpCode::getAddHalfWordImmDistinctOperandOpCode(), node, temp1Reg, targetReg, zeroArraySize);\n+   generateRXInstruction(cg, TR::InstOpCode::getCmpLogicalOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapTop), cg));\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BH, node, oolJumpLabel);\n+\n+   // If there's enough space, then we can continue to allocate.\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+   \n+   bool use64BitClasses = comp->target().is64Bit() && !TR::Compiler->om.generateCompressedObjectHeaders();\n+\n+   // Init class and fields, then jump to end of ICF\n+   generateRXInstruction(cg, use64BitClasses ? TR::InstOpCode::STG : TR::InstOpCode::ST, node, classReg, generateS390MemoryReference(targetReg, TR::Compiler->om.offsetOfObjectVftField(), cg));\n+   generateSILInstruction(cg, use64BitClasses ? TR::InstOpCode::MVGHI : TR::InstOpCode::MVHI, node, generateS390MemoryReference(targetReg, fej9->getOffsetOfContiguousArraySizeField(), cg), 0);\n+   generateSILInstruction(cg, use64BitClasses ? TR::InstOpCode::MVGHI : TR::InstOpCode::MVHI, node, generateS390MemoryReference(targetReg, fej9->getOffsetOfDiscontiguousArraySizeField(), cg), 0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d2a7a622a97110d921a531735d149005cfec0f1"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODM5MzYyNQ==", "bodyText": "I've removed the moves here: 9d7f197", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r528393625", "createdAt": "2020-11-22T19:36:34Z", "author": {"login": "dchopra001"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,259 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n ///////////////////////////////////////////////////////////////////////////////////////\n // multianewArrayEvaluator:  multi-dimensional new array of objects\n ///////////////////////////////////////////////////////////////////////////////////////\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::acall);\n-   TR::Register * targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n-   }\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = static_cast<TR_J9VMBase *>(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt() != 2)\n+      {\n+      traceMsg(cg->comp(), \"multianewArrayEvaluator - More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      return performHelperCall(node, NULL, TR::acall, false, cg);\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   // oolJumpLabel is a common point that all branches will jump to. From this label, we branch to OOL code.\n+   // We do this instead of jumping directly to OOL code from mainline because the RA can only handle the case where there's\n+   // a single jump point to OOL code.\n+   TR::LabelSymbol *oolJumpLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));\n+\n+   TR::Register *secondDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, secondDimLenReg, generateS390MemoryReference(dimsPtrReg, 0, cg));\n+\n+   // Check to see if second dimension is indeed 0. If yes, then proceed to handle the case here. Otherwise jump to OOL code.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, secondDimLenReg, 0, TR::InstOpCode::COND_BNE, oolJumpLabel, false);\n+\n+   // Now check to see if first dimension is also 0. If yes, continue below to handle the case when length for both dimensions is 0. Otherwise jump to nonZeroFirstDimLabel.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, 0, TR::InstOpCode::COND_BNE, nonZeroFirstDimLabel, false);\n+\n+   // First dimension zero, so only allocate 1 zero-length object array\n+   int32_t zeroArraySize = TR::Compiler->om.discontiguousArrayHeaderSizeInBytes();\n+   TR::Register *vmThreadReg = cg->getMethodMetaDataRealRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, targetReg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+\n+   // Branch to OOL if there's not enough space for an array of size 0.\n+   TR::Register *temp1Reg = cg->allocateRegister();\n+   generateRIEInstruction(cg, TR::InstOpCode::getAddHalfWordImmDistinctOperandOpCode(), node, temp1Reg, targetReg, zeroArraySize);\n+   generateRXInstruction(cg, TR::InstOpCode::getCmpLogicalOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapTop), cg));\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BH, node, oolJumpLabel);\n+\n+   // If there's enough space, then we can continue to allocate.\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+   \n+   bool use64BitClasses = comp->target().is64Bit() && !TR::Compiler->om.generateCompressedObjectHeaders();\n+\n+   // Init class and fields, then jump to end of ICF\n+   generateRXInstruction(cg, use64BitClasses ? TR::InstOpCode::STG : TR::InstOpCode::ST, node, classReg, generateS390MemoryReference(targetReg, TR::Compiler->om.offsetOfObjectVftField(), cg));\n+   generateSILInstruction(cg, use64BitClasses ? TR::InstOpCode::MVGHI : TR::InstOpCode::MVHI, node, generateS390MemoryReference(targetReg, fej9->getOffsetOfContiguousArraySizeField(), cg), 0);\n+   generateSILInstruction(cg, use64BitClasses ? TR::InstOpCode::MVGHI : TR::InstOpCode::MVHI, node, generateS390MemoryReference(targetReg, fej9->getOffsetOfDiscontiguousArraySizeField(), cg), 0);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzg3NzcxMQ=="}, "originalCommit": {"oid": "0d2a7a622a97110d921a531735d149005cfec0f1"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxMDEwNDA1OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxOTowMTo1MlrOH3dMQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxNTowMDoxMFrOH4RQLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzkxMjAwMw==", "bodyText": "This is incorrect. firstDimLenReg is a 32-bit value, so it would be functionally incorrect to test this value against a 64-bit constant. The upper 32-bits are dirty. IMO we should just have a check up front where we check !secondChild->getOpCode().isLoadConst() and just ensure the array is not greater than cg->getMaxObjectSizeGuaranteedNotToOverflow(), and if it is just bail out of the inline sequence.\nWe're only trying to accelerate the most common cases here. If someone is allocating a 2D array of size > 0x10000000 we should just let the helper handle it.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r527912003", "createdAt": "2020-11-20T19:01:52Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,259 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n ///////////////////////////////////////////////////////////////////////////////////////\n // multianewArrayEvaluator:  multi-dimensional new array of objects\n ///////////////////////////////////////////////////////////////////////////////////////\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::acall);\n-   TR::Register * targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n-   }\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = static_cast<TR_J9VMBase *>(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt() != 2)\n+      {\n+      traceMsg(cg->comp(), \"multianewArrayEvaluator - More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      return performHelperCall(node, NULL, TR::acall, false, cg);\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   // oolJumpLabel is a common point that all branches will jump to. From this label, we branch to OOL code.\n+   // We do this instead of jumping directly to OOL code from mainline because the RA can only handle the case where there's\n+   // a single jump point to OOL code.\n+   TR::LabelSymbol *oolJumpLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));\n+\n+   TR::Register *secondDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, secondDimLenReg, generateS390MemoryReference(dimsPtrReg, 0, cg));\n+\n+   // Check to see if second dimension is indeed 0. If yes, then proceed to handle the case here. Otherwise jump to OOL code.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, secondDimLenReg, 0, TR::InstOpCode::COND_BNE, oolJumpLabel, false);\n+\n+   // Now check to see if first dimension is also 0. If yes, continue below to handle the case when length for both dimensions is 0. Otherwise jump to nonZeroFirstDimLabel.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, 0, TR::InstOpCode::COND_BNE, nonZeroFirstDimLabel, false);\n+\n+   // First dimension zero, so only allocate 1 zero-length object array\n+   int32_t zeroArraySize = TR::Compiler->om.discontiguousArrayHeaderSizeInBytes();\n+   TR::Register *vmThreadReg = cg->getMethodMetaDataRealRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, targetReg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+\n+   // Branch to OOL if there's not enough space for an array of size 0.\n+   TR::Register *temp1Reg = cg->allocateRegister();\n+   generateRIEInstruction(cg, TR::InstOpCode::getAddHalfWordImmDistinctOperandOpCode(), node, temp1Reg, targetReg, zeroArraySize);\n+   generateRXInstruction(cg, TR::InstOpCode::getCmpLogicalOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapTop), cg));\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BH, node, oolJumpLabel);\n+\n+   // If there's enough space, then we can continue to allocate.\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+   \n+   bool use64BitClasses = comp->target().is64Bit() && !TR::Compiler->om.generateCompressedObjectHeaders();\n+\n+   // Init class and fields, then jump to end of ICF\n+   generateRXInstruction(cg, use64BitClasses ? TR::InstOpCode::STG : TR::InstOpCode::ST, node, classReg, generateS390MemoryReference(targetReg, TR::Compiler->om.offsetOfObjectVftField(), cg));\n+   generateSILInstruction(cg, use64BitClasses ? TR::InstOpCode::MVGHI : TR::InstOpCode::MVHI, node, generateS390MemoryReference(targetReg, fej9->getOffsetOfContiguousArraySizeField(), cg), 0);\n+   generateSILInstruction(cg, use64BitClasses ? TR::InstOpCode::MVGHI : TR::InstOpCode::MVHI, node, generateS390MemoryReference(targetReg, fej9->getOffsetOfDiscontiguousArraySizeField(), cg), 0);\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);\n+\n+   // We end up in this region of the ICF if the first dimension is non-zero and the second dimension is zero.\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, nonZeroFirstDimLabel);\n+\n+   TR::Register *componentClassReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, componentClassReg, generateS390MemoryReference(classReg, offsetof(J9ArrayClass, componentType), cg));\n+\n+   // Calculate maximum allowable object size in elements and jump to OOL if it's higher than firstDimLenReg.\n+   int32_t elementSize = TR::Compiler->om.sizeofReferenceField();\n+   uintptr_t maxObjectSize = cg->getMaxObjectSizeGuaranteedNotToOverflow();\n+   uintptr_t maxObjectSizeInElements = maxObjectSize / elementSize;\n+\n+   if (comp->target().is64Bit() && !(maxObjectSizeInElements >= 0 && maxObjectSizeInElements <= (uintptr_t)INT_MAX))\n+      {\n+      generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CLG, node, firstDimLenReg, static_cast<int64_t>(maxObjectSizeInElements), TR::InstOpCode::COND_BRH, oolJumpLabel, false);\n+      }\n+   else\n+      {\n+      generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, static_cast<int32_t>(maxObjectSizeInElements), TR::InstOpCode::COND_BHR, oolJumpLabel, false);\n+      }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d2a7a622a97110d921a531735d149005cfec0f1"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk1ODU3MA==", "bodyText": "Do you mean to check the size of the array at compile time and bail if it's too large? The second child is not the size of the array. It represents the numbers of dimensions in the multi-dimensional array. So I don't think we can do the check you proposed above as that information is not available to us at compile time.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r527958570", "createdAt": "2020-11-20T20:40:23Z", "author": {"login": "dchopra001"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,259 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n ///////////////////////////////////////////////////////////////////////////////////////\n // multianewArrayEvaluator:  multi-dimensional new array of objects\n ///////////////////////////////////////////////////////////////////////////////////////\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::acall);\n-   TR::Register * targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n-   }\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = static_cast<TR_J9VMBase *>(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt() != 2)\n+      {\n+      traceMsg(cg->comp(), \"multianewArrayEvaluator - More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      return performHelperCall(node, NULL, TR::acall, false, cg);\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   // oolJumpLabel is a common point that all branches will jump to. From this label, we branch to OOL code.\n+   // We do this instead of jumping directly to OOL code from mainline because the RA can only handle the case where there's\n+   // a single jump point to OOL code.\n+   TR::LabelSymbol *oolJumpLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));\n+\n+   TR::Register *secondDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, secondDimLenReg, generateS390MemoryReference(dimsPtrReg, 0, cg));\n+\n+   // Check to see if second dimension is indeed 0. If yes, then proceed to handle the case here. Otherwise jump to OOL code.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, secondDimLenReg, 0, TR::InstOpCode::COND_BNE, oolJumpLabel, false);\n+\n+   // Now check to see if first dimension is also 0. If yes, continue below to handle the case when length for both dimensions is 0. Otherwise jump to nonZeroFirstDimLabel.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, 0, TR::InstOpCode::COND_BNE, nonZeroFirstDimLabel, false);\n+\n+   // First dimension zero, so only allocate 1 zero-length object array\n+   int32_t zeroArraySize = TR::Compiler->om.discontiguousArrayHeaderSizeInBytes();\n+   TR::Register *vmThreadReg = cg->getMethodMetaDataRealRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, targetReg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+\n+   // Branch to OOL if there's not enough space for an array of size 0.\n+   TR::Register *temp1Reg = cg->allocateRegister();\n+   generateRIEInstruction(cg, TR::InstOpCode::getAddHalfWordImmDistinctOperandOpCode(), node, temp1Reg, targetReg, zeroArraySize);\n+   generateRXInstruction(cg, TR::InstOpCode::getCmpLogicalOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapTop), cg));\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BH, node, oolJumpLabel);\n+\n+   // If there's enough space, then we can continue to allocate.\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+   \n+   bool use64BitClasses = comp->target().is64Bit() && !TR::Compiler->om.generateCompressedObjectHeaders();\n+\n+   // Init class and fields, then jump to end of ICF\n+   generateRXInstruction(cg, use64BitClasses ? TR::InstOpCode::STG : TR::InstOpCode::ST, node, classReg, generateS390MemoryReference(targetReg, TR::Compiler->om.offsetOfObjectVftField(), cg));\n+   generateSILInstruction(cg, use64BitClasses ? TR::InstOpCode::MVGHI : TR::InstOpCode::MVHI, node, generateS390MemoryReference(targetReg, fej9->getOffsetOfContiguousArraySizeField(), cg), 0);\n+   generateSILInstruction(cg, use64BitClasses ? TR::InstOpCode::MVGHI : TR::InstOpCode::MVHI, node, generateS390MemoryReference(targetReg, fej9->getOffsetOfDiscontiguousArraySizeField(), cg), 0);\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);\n+\n+   // We end up in this region of the ICF if the first dimension is non-zero and the second dimension is zero.\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, nonZeroFirstDimLabel);\n+\n+   TR::Register *componentClassReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, componentClassReg, generateS390MemoryReference(classReg, offsetof(J9ArrayClass, componentType), cg));\n+\n+   // Calculate maximum allowable object size in elements and jump to OOL if it's higher than firstDimLenReg.\n+   int32_t elementSize = TR::Compiler->om.sizeofReferenceField();\n+   uintptr_t maxObjectSize = cg->getMaxObjectSizeGuaranteedNotToOverflow();\n+   uintptr_t maxObjectSizeInElements = maxObjectSize / elementSize;\n+\n+   if (comp->target().is64Bit() && !(maxObjectSizeInElements >= 0 && maxObjectSizeInElements <= (uintptr_t)INT_MAX))\n+      {\n+      generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CLG, node, firstDimLenReg, static_cast<int64_t>(maxObjectSizeInElements), TR::InstOpCode::COND_BRH, oolJumpLabel, false);\n+      }\n+   else\n+      {\n+      generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, static_cast<int32_t>(maxObjectSizeInElements), TR::InstOpCode::COND_BHR, oolJumpLabel, false);\n+      }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzkxMjAwMw=="}, "originalCommit": {"oid": "0d2a7a622a97110d921a531735d149005cfec0f1"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODc2NDk3NA==", "bodyText": "As per our offline discussion, we can't do the check proposed during compile time. However we should only ever do a 32-bit comparison here. I've simplified this check in 6678b56.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r528764974", "createdAt": "2020-11-23T15:00:10Z", "author": {"login": "dchopra001"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,259 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n ///////////////////////////////////////////////////////////////////////////////////////\n // multianewArrayEvaluator:  multi-dimensional new array of objects\n ///////////////////////////////////////////////////////////////////////////////////////\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::acall);\n-   TR::Register * targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n-   }\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = static_cast<TR_J9VMBase *>(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt() != 2)\n+      {\n+      traceMsg(cg->comp(), \"multianewArrayEvaluator - More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      return performHelperCall(node, NULL, TR::acall, false, cg);\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   // oolJumpLabel is a common point that all branches will jump to. From this label, we branch to OOL code.\n+   // We do this instead of jumping directly to OOL code from mainline because the RA can only handle the case where there's\n+   // a single jump point to OOL code.\n+   TR::LabelSymbol *oolJumpLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));\n+\n+   TR::Register *secondDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, secondDimLenReg, generateS390MemoryReference(dimsPtrReg, 0, cg));\n+\n+   // Check to see if second dimension is indeed 0. If yes, then proceed to handle the case here. Otherwise jump to OOL code.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, secondDimLenReg, 0, TR::InstOpCode::COND_BNE, oolJumpLabel, false);\n+\n+   // Now check to see if first dimension is also 0. If yes, continue below to handle the case when length for both dimensions is 0. Otherwise jump to nonZeroFirstDimLabel.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, 0, TR::InstOpCode::COND_BNE, nonZeroFirstDimLabel, false);\n+\n+   // First dimension zero, so only allocate 1 zero-length object array\n+   int32_t zeroArraySize = TR::Compiler->om.discontiguousArrayHeaderSizeInBytes();\n+   TR::Register *vmThreadReg = cg->getMethodMetaDataRealRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, targetReg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+\n+   // Branch to OOL if there's not enough space for an array of size 0.\n+   TR::Register *temp1Reg = cg->allocateRegister();\n+   generateRIEInstruction(cg, TR::InstOpCode::getAddHalfWordImmDistinctOperandOpCode(), node, temp1Reg, targetReg, zeroArraySize);\n+   generateRXInstruction(cg, TR::InstOpCode::getCmpLogicalOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapTop), cg));\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BH, node, oolJumpLabel);\n+\n+   // If there's enough space, then we can continue to allocate.\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+   \n+   bool use64BitClasses = comp->target().is64Bit() && !TR::Compiler->om.generateCompressedObjectHeaders();\n+\n+   // Init class and fields, then jump to end of ICF\n+   generateRXInstruction(cg, use64BitClasses ? TR::InstOpCode::STG : TR::InstOpCode::ST, node, classReg, generateS390MemoryReference(targetReg, TR::Compiler->om.offsetOfObjectVftField(), cg));\n+   generateSILInstruction(cg, use64BitClasses ? TR::InstOpCode::MVGHI : TR::InstOpCode::MVHI, node, generateS390MemoryReference(targetReg, fej9->getOffsetOfContiguousArraySizeField(), cg), 0);\n+   generateSILInstruction(cg, use64BitClasses ? TR::InstOpCode::MVGHI : TR::InstOpCode::MVHI, node, generateS390MemoryReference(targetReg, fej9->getOffsetOfDiscontiguousArraySizeField(), cg), 0);\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);\n+\n+   // We end up in this region of the ICF if the first dimension is non-zero and the second dimension is zero.\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, nonZeroFirstDimLabel);\n+\n+   TR::Register *componentClassReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, componentClassReg, generateS390MemoryReference(classReg, offsetof(J9ArrayClass, componentType), cg));\n+\n+   // Calculate maximum allowable object size in elements and jump to OOL if it's higher than firstDimLenReg.\n+   int32_t elementSize = TR::Compiler->om.sizeofReferenceField();\n+   uintptr_t maxObjectSize = cg->getMaxObjectSizeGuaranteedNotToOverflow();\n+   uintptr_t maxObjectSizeInElements = maxObjectSize / elementSize;\n+\n+   if (comp->target().is64Bit() && !(maxObjectSizeInElements >= 0 && maxObjectSizeInElements <= (uintptr_t)INT_MAX))\n+      {\n+      generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CLG, node, firstDimLenReg, static_cast<int64_t>(maxObjectSizeInElements), TR::InstOpCode::COND_BRH, oolJumpLabel, false);\n+      }\n+   else\n+      {\n+      generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, static_cast<int32_t>(maxObjectSizeInElements), TR::InstOpCode::COND_BHR, oolJumpLabel, false);\n+      }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzkxMjAwMw=="}, "originalCommit": {"oid": "0d2a7a622a97110d921a531735d149005cfec0f1"}, "originalPosition": 117}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxMDE3Mjg1OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxOToyMjoyN1rOH3d1vA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMlQxOTo0Njo1OFrOH36qdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzkyMjYyMA==", "bodyText": "We can get rid of this load by just using firstDimLenReg in the shift below.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r527922620", "createdAt": "2020-11-20T19:22:27Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,259 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n ///////////////////////////////////////////////////////////////////////////////////////\n // multianewArrayEvaluator:  multi-dimensional new array of objects\n ///////////////////////////////////////////////////////////////////////////////////////\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::acall);\n-   TR::Register * targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n-   }\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = static_cast<TR_J9VMBase *>(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt() != 2)\n+      {\n+      traceMsg(cg->comp(), \"multianewArrayEvaluator - More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      return performHelperCall(node, NULL, TR::acall, false, cg);\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   // oolJumpLabel is a common point that all branches will jump to. From this label, we branch to OOL code.\n+   // We do this instead of jumping directly to OOL code from mainline because the RA can only handle the case where there's\n+   // a single jump point to OOL code.\n+   TR::LabelSymbol *oolJumpLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));\n+\n+   TR::Register *secondDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, secondDimLenReg, generateS390MemoryReference(dimsPtrReg, 0, cg));\n+\n+   // Check to see if second dimension is indeed 0. If yes, then proceed to handle the case here. Otherwise jump to OOL code.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, secondDimLenReg, 0, TR::InstOpCode::COND_BNE, oolJumpLabel, false);\n+\n+   // Now check to see if first dimension is also 0. If yes, continue below to handle the case when length for both dimensions is 0. Otherwise jump to nonZeroFirstDimLabel.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, 0, TR::InstOpCode::COND_BNE, nonZeroFirstDimLabel, false);\n+\n+   // First dimension zero, so only allocate 1 zero-length object array\n+   int32_t zeroArraySize = TR::Compiler->om.discontiguousArrayHeaderSizeInBytes();\n+   TR::Register *vmThreadReg = cg->getMethodMetaDataRealRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, targetReg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+\n+   // Branch to OOL if there's not enough space for an array of size 0.\n+   TR::Register *temp1Reg = cg->allocateRegister();\n+   generateRIEInstruction(cg, TR::InstOpCode::getAddHalfWordImmDistinctOperandOpCode(), node, temp1Reg, targetReg, zeroArraySize);\n+   generateRXInstruction(cg, TR::InstOpCode::getCmpLogicalOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapTop), cg));\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BH, node, oolJumpLabel);\n+\n+   // If there's enough space, then we can continue to allocate.\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+   \n+   bool use64BitClasses = comp->target().is64Bit() && !TR::Compiler->om.generateCompressedObjectHeaders();\n+\n+   // Init class and fields, then jump to end of ICF\n+   generateRXInstruction(cg, use64BitClasses ? TR::InstOpCode::STG : TR::InstOpCode::ST, node, classReg, generateS390MemoryReference(targetReg, TR::Compiler->om.offsetOfObjectVftField(), cg));\n+   generateSILInstruction(cg, use64BitClasses ? TR::InstOpCode::MVGHI : TR::InstOpCode::MVHI, node, generateS390MemoryReference(targetReg, fej9->getOffsetOfContiguousArraySizeField(), cg), 0);\n+   generateSILInstruction(cg, use64BitClasses ? TR::InstOpCode::MVGHI : TR::InstOpCode::MVHI, node, generateS390MemoryReference(targetReg, fej9->getOffsetOfDiscontiguousArraySizeField(), cg), 0);\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);\n+\n+   // We end up in this region of the ICF if the first dimension is non-zero and the second dimension is zero.\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, nonZeroFirstDimLabel);\n+\n+   TR::Register *componentClassReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, componentClassReg, generateS390MemoryReference(classReg, offsetof(J9ArrayClass, componentType), cg));\n+\n+   // Calculate maximum allowable object size in elements and jump to OOL if it's higher than firstDimLenReg.\n+   int32_t elementSize = TR::Compiler->om.sizeofReferenceField();\n+   uintptr_t maxObjectSize = cg->getMaxObjectSizeGuaranteedNotToOverflow();\n+   uintptr_t maxObjectSizeInElements = maxObjectSize / elementSize;\n+\n+   if (comp->target().is64Bit() && !(maxObjectSizeInElements >= 0 && maxObjectSizeInElements <= (uintptr_t)INT_MAX))\n+      {\n+      generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CLG, node, firstDimLenReg, static_cast<int64_t>(maxObjectSizeInElements), TR::InstOpCode::COND_BRH, oolJumpLabel, false);\n+      }\n+   else\n+      {\n+      generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, static_cast<int32_t>(maxObjectSizeInElements), TR::InstOpCode::COND_BHR, oolJumpLabel, false);\n+      }\n+\n+   // Now check to see if we have enough space to do the allocation. If not then jump to OOL code.\n+   generateRRInstruction(cg, TR::InstOpCode::LR, node, temp1Reg, firstDimLenReg);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d2a7a622a97110d921a531735d149005cfec0f1"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODM5NDg3MA==", "bodyText": "Fixed in 0c0a523", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r528394870", "createdAt": "2020-11-22T19:46:58Z", "author": {"login": "dchopra001"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,259 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n ///////////////////////////////////////////////////////////////////////////////////////\n // multianewArrayEvaluator:  multi-dimensional new array of objects\n ///////////////////////////////////////////////////////////////////////////////////////\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::acall);\n-   TR::Register * targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n-   }\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = static_cast<TR_J9VMBase *>(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt() != 2)\n+      {\n+      traceMsg(cg->comp(), \"multianewArrayEvaluator - More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      return performHelperCall(node, NULL, TR::acall, false, cg);\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   // oolJumpLabel is a common point that all branches will jump to. From this label, we branch to OOL code.\n+   // We do this instead of jumping directly to OOL code from mainline because the RA can only handle the case where there's\n+   // a single jump point to OOL code.\n+   TR::LabelSymbol *oolJumpLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));\n+\n+   TR::Register *secondDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, secondDimLenReg, generateS390MemoryReference(dimsPtrReg, 0, cg));\n+\n+   // Check to see if second dimension is indeed 0. If yes, then proceed to handle the case here. Otherwise jump to OOL code.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, secondDimLenReg, 0, TR::InstOpCode::COND_BNE, oolJumpLabel, false);\n+\n+   // Now check to see if first dimension is also 0. If yes, continue below to handle the case when length for both dimensions is 0. Otherwise jump to nonZeroFirstDimLabel.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, 0, TR::InstOpCode::COND_BNE, nonZeroFirstDimLabel, false);\n+\n+   // First dimension zero, so only allocate 1 zero-length object array\n+   int32_t zeroArraySize = TR::Compiler->om.discontiguousArrayHeaderSizeInBytes();\n+   TR::Register *vmThreadReg = cg->getMethodMetaDataRealRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, targetReg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+\n+   // Branch to OOL if there's not enough space for an array of size 0.\n+   TR::Register *temp1Reg = cg->allocateRegister();\n+   generateRIEInstruction(cg, TR::InstOpCode::getAddHalfWordImmDistinctOperandOpCode(), node, temp1Reg, targetReg, zeroArraySize);\n+   generateRXInstruction(cg, TR::InstOpCode::getCmpLogicalOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapTop), cg));\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BH, node, oolJumpLabel);\n+\n+   // If there's enough space, then we can continue to allocate.\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+   \n+   bool use64BitClasses = comp->target().is64Bit() && !TR::Compiler->om.generateCompressedObjectHeaders();\n+\n+   // Init class and fields, then jump to end of ICF\n+   generateRXInstruction(cg, use64BitClasses ? TR::InstOpCode::STG : TR::InstOpCode::ST, node, classReg, generateS390MemoryReference(targetReg, TR::Compiler->om.offsetOfObjectVftField(), cg));\n+   generateSILInstruction(cg, use64BitClasses ? TR::InstOpCode::MVGHI : TR::InstOpCode::MVHI, node, generateS390MemoryReference(targetReg, fej9->getOffsetOfContiguousArraySizeField(), cg), 0);\n+   generateSILInstruction(cg, use64BitClasses ? TR::InstOpCode::MVGHI : TR::InstOpCode::MVHI, node, generateS390MemoryReference(targetReg, fej9->getOffsetOfDiscontiguousArraySizeField(), cg), 0);\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);\n+\n+   // We end up in this region of the ICF if the first dimension is non-zero and the second dimension is zero.\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, nonZeroFirstDimLabel);\n+\n+   TR::Register *componentClassReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, componentClassReg, generateS390MemoryReference(classReg, offsetof(J9ArrayClass, componentType), cg));\n+\n+   // Calculate maximum allowable object size in elements and jump to OOL if it's higher than firstDimLenReg.\n+   int32_t elementSize = TR::Compiler->om.sizeofReferenceField();\n+   uintptr_t maxObjectSize = cg->getMaxObjectSizeGuaranteedNotToOverflow();\n+   uintptr_t maxObjectSizeInElements = maxObjectSize / elementSize;\n+\n+   if (comp->target().is64Bit() && !(maxObjectSizeInElements >= 0 && maxObjectSizeInElements <= (uintptr_t)INT_MAX))\n+      {\n+      generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CLG, node, firstDimLenReg, static_cast<int64_t>(maxObjectSizeInElements), TR::InstOpCode::COND_BRH, oolJumpLabel, false);\n+      }\n+   else\n+      {\n+      generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, static_cast<int32_t>(maxObjectSizeInElements), TR::InstOpCode::COND_BHR, oolJumpLabel, false);\n+      }\n+\n+   // Now check to see if we have enough space to do the allocation. If not then jump to OOL code.\n+   generateRRInstruction(cg, TR::InstOpCode::LR, node, temp1Reg, firstDimLenReg);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzkyMjYyMA=="}, "originalCommit": {"oid": "0d2a7a622a97110d921a531735d149005cfec0f1"}, "originalPosition": 120}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxMDE3Mzk5OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxOToyMjo1MVrOH3d2cA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QwNDo0Nzo0MVrOH3_RZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzkyMjgwMA==", "bodyText": "I'd like to see a fatal assert here if elementSize > 8 otherwise this will access garbage data.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r527922800", "createdAt": "2020-11-20T19:22:51Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,259 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n ///////////////////////////////////////////////////////////////////////////////////////\n // multianewArrayEvaluator:  multi-dimensional new array of objects\n ///////////////////////////////////////////////////////////////////////////////////////\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::acall);\n-   TR::Register * targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n-   }\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = static_cast<TR_J9VMBase *>(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt() != 2)\n+      {\n+      traceMsg(cg->comp(), \"multianewArrayEvaluator - More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      return performHelperCall(node, NULL, TR::acall, false, cg);\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   // oolJumpLabel is a common point that all branches will jump to. From this label, we branch to OOL code.\n+   // We do this instead of jumping directly to OOL code from mainline because the RA can only handle the case where there's\n+   // a single jump point to OOL code.\n+   TR::LabelSymbol *oolJumpLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));\n+\n+   TR::Register *secondDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, secondDimLenReg, generateS390MemoryReference(dimsPtrReg, 0, cg));\n+\n+   // Check to see if second dimension is indeed 0. If yes, then proceed to handle the case here. Otherwise jump to OOL code.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, secondDimLenReg, 0, TR::InstOpCode::COND_BNE, oolJumpLabel, false);\n+\n+   // Now check to see if first dimension is also 0. If yes, continue below to handle the case when length for both dimensions is 0. Otherwise jump to nonZeroFirstDimLabel.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, 0, TR::InstOpCode::COND_BNE, nonZeroFirstDimLabel, false);\n+\n+   // First dimension zero, so only allocate 1 zero-length object array\n+   int32_t zeroArraySize = TR::Compiler->om.discontiguousArrayHeaderSizeInBytes();\n+   TR::Register *vmThreadReg = cg->getMethodMetaDataRealRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, targetReg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+\n+   // Branch to OOL if there's not enough space for an array of size 0.\n+   TR::Register *temp1Reg = cg->allocateRegister();\n+   generateRIEInstruction(cg, TR::InstOpCode::getAddHalfWordImmDistinctOperandOpCode(), node, temp1Reg, targetReg, zeroArraySize);\n+   generateRXInstruction(cg, TR::InstOpCode::getCmpLogicalOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapTop), cg));\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BH, node, oolJumpLabel);\n+\n+   // If there's enough space, then we can continue to allocate.\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+   \n+   bool use64BitClasses = comp->target().is64Bit() && !TR::Compiler->om.generateCompressedObjectHeaders();\n+\n+   // Init class and fields, then jump to end of ICF\n+   generateRXInstruction(cg, use64BitClasses ? TR::InstOpCode::STG : TR::InstOpCode::ST, node, classReg, generateS390MemoryReference(targetReg, TR::Compiler->om.offsetOfObjectVftField(), cg));\n+   generateSILInstruction(cg, use64BitClasses ? TR::InstOpCode::MVGHI : TR::InstOpCode::MVHI, node, generateS390MemoryReference(targetReg, fej9->getOffsetOfContiguousArraySizeField(), cg), 0);\n+   generateSILInstruction(cg, use64BitClasses ? TR::InstOpCode::MVGHI : TR::InstOpCode::MVHI, node, generateS390MemoryReference(targetReg, fej9->getOffsetOfDiscontiguousArraySizeField(), cg), 0);\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);\n+\n+   // We end up in this region of the ICF if the first dimension is non-zero and the second dimension is zero.\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, nonZeroFirstDimLabel);\n+\n+   TR::Register *componentClassReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, componentClassReg, generateS390MemoryReference(classReg, offsetof(J9ArrayClass, componentType), cg));\n+\n+   // Calculate maximum allowable object size in elements and jump to OOL if it's higher than firstDimLenReg.\n+   int32_t elementSize = TR::Compiler->om.sizeofReferenceField();\n+   uintptr_t maxObjectSize = cg->getMaxObjectSizeGuaranteedNotToOverflow();\n+   uintptr_t maxObjectSizeInElements = maxObjectSize / elementSize;\n+\n+   if (comp->target().is64Bit() && !(maxObjectSizeInElements >= 0 && maxObjectSizeInElements <= (uintptr_t)INT_MAX))\n+      {\n+      generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CLG, node, firstDimLenReg, static_cast<int64_t>(maxObjectSizeInElements), TR::InstOpCode::COND_BRH, oolJumpLabel, false);\n+      }\n+   else\n+      {\n+      generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, static_cast<int32_t>(maxObjectSizeInElements), TR::InstOpCode::COND_BHR, oolJumpLabel, false);\n+      }\n+\n+   // Now check to see if we have enough space to do the allocation. If not then jump to OOL code.\n+   generateRRInstruction(cg, TR::InstOpCode::LR, node, temp1Reg, firstDimLenReg);\n+\n+   int32_t round = (elementSize >= TR::Compiler->om.objectAlignmentInBytes()) ? 0 : TR::Compiler->om.objectAlignmentInBytes();\n+   int32_t disp32 = round ? (round - 1) : 0;\n+\n+   static const uint8_t multiplierToStrideMap[] = {0, 0, 1, 0, 2, 0, 0, 0, 3};\n+   generateRSInstruction(cg, TR::InstOpCode::getShiftLeftLogicalSingleOpCode(), node, temp1Reg, temp1Reg, multiplierToStrideMap[elementSize]);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d2a7a622a97110d921a531735d149005cfec0f1"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQ3MDM3NQ==", "bodyText": "Added in 0c0a523", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r528470375", "createdAt": "2020-11-23T04:47:41Z", "author": {"login": "dchopra001"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,259 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n ///////////////////////////////////////////////////////////////////////////////////////\n // multianewArrayEvaluator:  multi-dimensional new array of objects\n ///////////////////////////////////////////////////////////////////////////////////////\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::acall);\n-   TR::Register * targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n-   }\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = static_cast<TR_J9VMBase *>(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt() != 2)\n+      {\n+      traceMsg(cg->comp(), \"multianewArrayEvaluator - More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      return performHelperCall(node, NULL, TR::acall, false, cg);\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   // oolJumpLabel is a common point that all branches will jump to. From this label, we branch to OOL code.\n+   // We do this instead of jumping directly to OOL code from mainline because the RA can only handle the case where there's\n+   // a single jump point to OOL code.\n+   TR::LabelSymbol *oolJumpLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));\n+\n+   TR::Register *secondDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, secondDimLenReg, generateS390MemoryReference(dimsPtrReg, 0, cg));\n+\n+   // Check to see if second dimension is indeed 0. If yes, then proceed to handle the case here. Otherwise jump to OOL code.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, secondDimLenReg, 0, TR::InstOpCode::COND_BNE, oolJumpLabel, false);\n+\n+   // Now check to see if first dimension is also 0. If yes, continue below to handle the case when length for both dimensions is 0. Otherwise jump to nonZeroFirstDimLabel.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, 0, TR::InstOpCode::COND_BNE, nonZeroFirstDimLabel, false);\n+\n+   // First dimension zero, so only allocate 1 zero-length object array\n+   int32_t zeroArraySize = TR::Compiler->om.discontiguousArrayHeaderSizeInBytes();\n+   TR::Register *vmThreadReg = cg->getMethodMetaDataRealRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, targetReg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+\n+   // Branch to OOL if there's not enough space for an array of size 0.\n+   TR::Register *temp1Reg = cg->allocateRegister();\n+   generateRIEInstruction(cg, TR::InstOpCode::getAddHalfWordImmDistinctOperandOpCode(), node, temp1Reg, targetReg, zeroArraySize);\n+   generateRXInstruction(cg, TR::InstOpCode::getCmpLogicalOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapTop), cg));\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BH, node, oolJumpLabel);\n+\n+   // If there's enough space, then we can continue to allocate.\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+   \n+   bool use64BitClasses = comp->target().is64Bit() && !TR::Compiler->om.generateCompressedObjectHeaders();\n+\n+   // Init class and fields, then jump to end of ICF\n+   generateRXInstruction(cg, use64BitClasses ? TR::InstOpCode::STG : TR::InstOpCode::ST, node, classReg, generateS390MemoryReference(targetReg, TR::Compiler->om.offsetOfObjectVftField(), cg));\n+   generateSILInstruction(cg, use64BitClasses ? TR::InstOpCode::MVGHI : TR::InstOpCode::MVHI, node, generateS390MemoryReference(targetReg, fej9->getOffsetOfContiguousArraySizeField(), cg), 0);\n+   generateSILInstruction(cg, use64BitClasses ? TR::InstOpCode::MVGHI : TR::InstOpCode::MVHI, node, generateS390MemoryReference(targetReg, fej9->getOffsetOfDiscontiguousArraySizeField(), cg), 0);\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);\n+\n+   // We end up in this region of the ICF if the first dimension is non-zero and the second dimension is zero.\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, nonZeroFirstDimLabel);\n+\n+   TR::Register *componentClassReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, componentClassReg, generateS390MemoryReference(classReg, offsetof(J9ArrayClass, componentType), cg));\n+\n+   // Calculate maximum allowable object size in elements and jump to OOL if it's higher than firstDimLenReg.\n+   int32_t elementSize = TR::Compiler->om.sizeofReferenceField();\n+   uintptr_t maxObjectSize = cg->getMaxObjectSizeGuaranteedNotToOverflow();\n+   uintptr_t maxObjectSizeInElements = maxObjectSize / elementSize;\n+\n+   if (comp->target().is64Bit() && !(maxObjectSizeInElements >= 0 && maxObjectSizeInElements <= (uintptr_t)INT_MAX))\n+      {\n+      generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CLG, node, firstDimLenReg, static_cast<int64_t>(maxObjectSizeInElements), TR::InstOpCode::COND_BRH, oolJumpLabel, false);\n+      }\n+   else\n+      {\n+      generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, static_cast<int32_t>(maxObjectSizeInElements), TR::InstOpCode::COND_BHR, oolJumpLabel, false);\n+      }\n+\n+   // Now check to see if we have enough space to do the allocation. If not then jump to OOL code.\n+   generateRRInstruction(cg, TR::InstOpCode::LR, node, temp1Reg, firstDimLenReg);\n+\n+   int32_t round = (elementSize >= TR::Compiler->om.objectAlignmentInBytes()) ? 0 : TR::Compiler->om.objectAlignmentInBytes();\n+   int32_t disp32 = round ? (round - 1) : 0;\n+\n+   static const uint8_t multiplierToStrideMap[] = {0, 0, 1, 0, 2, 0, 0, 0, 3};\n+   generateRSInstruction(cg, TR::InstOpCode::getShiftLeftLogicalSingleOpCode(), node, temp1Reg, temp1Reg, multiplierToStrideMap[elementSize]);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzkyMjgwMA=="}, "originalCommit": {"oid": "0d2a7a622a97110d921a531735d149005cfec0f1"}, "originalPosition": 126}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxMDE3NTA5OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxOToyMzowOVrOH3d3Dg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QwNDo1MTo1NFrOH3_UgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzkyMjk1OA==", "bodyText": "We can fold firstDimLenReg into the shift. Also let's not use a magic constant here. As Igor's recent work has shown the value of discontiguousArrayHeaderSizeInBytes can change in the future, so we don't want to hunt this bug down. Use the API.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r527922958", "createdAt": "2020-11-20T19:23:09Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,259 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n ///////////////////////////////////////////////////////////////////////////////////////\n // multianewArrayEvaluator:  multi-dimensional new array of objects\n ///////////////////////////////////////////////////////////////////////////////////////\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::acall);\n-   TR::Register * targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n-   }\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = static_cast<TR_J9VMBase *>(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt() != 2)\n+      {\n+      traceMsg(cg->comp(), \"multianewArrayEvaluator - More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      return performHelperCall(node, NULL, TR::acall, false, cg);\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   // oolJumpLabel is a common point that all branches will jump to. From this label, we branch to OOL code.\n+   // We do this instead of jumping directly to OOL code from mainline because the RA can only handle the case where there's\n+   // a single jump point to OOL code.\n+   TR::LabelSymbol *oolJumpLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));\n+\n+   TR::Register *secondDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, secondDimLenReg, generateS390MemoryReference(dimsPtrReg, 0, cg));\n+\n+   // Check to see if second dimension is indeed 0. If yes, then proceed to handle the case here. Otherwise jump to OOL code.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, secondDimLenReg, 0, TR::InstOpCode::COND_BNE, oolJumpLabel, false);\n+\n+   // Now check to see if first dimension is also 0. If yes, continue below to handle the case when length for both dimensions is 0. Otherwise jump to nonZeroFirstDimLabel.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, 0, TR::InstOpCode::COND_BNE, nonZeroFirstDimLabel, false);\n+\n+   // First dimension zero, so only allocate 1 zero-length object array\n+   int32_t zeroArraySize = TR::Compiler->om.discontiguousArrayHeaderSizeInBytes();\n+   TR::Register *vmThreadReg = cg->getMethodMetaDataRealRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, targetReg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+\n+   // Branch to OOL if there's not enough space for an array of size 0.\n+   TR::Register *temp1Reg = cg->allocateRegister();\n+   generateRIEInstruction(cg, TR::InstOpCode::getAddHalfWordImmDistinctOperandOpCode(), node, temp1Reg, targetReg, zeroArraySize);\n+   generateRXInstruction(cg, TR::InstOpCode::getCmpLogicalOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapTop), cg));\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BH, node, oolJumpLabel);\n+\n+   // If there's enough space, then we can continue to allocate.\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+   \n+   bool use64BitClasses = comp->target().is64Bit() && !TR::Compiler->om.generateCompressedObjectHeaders();\n+\n+   // Init class and fields, then jump to end of ICF\n+   generateRXInstruction(cg, use64BitClasses ? TR::InstOpCode::STG : TR::InstOpCode::ST, node, classReg, generateS390MemoryReference(targetReg, TR::Compiler->om.offsetOfObjectVftField(), cg));\n+   generateSILInstruction(cg, use64BitClasses ? TR::InstOpCode::MVGHI : TR::InstOpCode::MVHI, node, generateS390MemoryReference(targetReg, fej9->getOffsetOfContiguousArraySizeField(), cg), 0);\n+   generateSILInstruction(cg, use64BitClasses ? TR::InstOpCode::MVGHI : TR::InstOpCode::MVHI, node, generateS390MemoryReference(targetReg, fej9->getOffsetOfDiscontiguousArraySizeField(), cg), 0);\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);\n+\n+   // We end up in this region of the ICF if the first dimension is non-zero and the second dimension is zero.\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, nonZeroFirstDimLabel);\n+\n+   TR::Register *componentClassReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, componentClassReg, generateS390MemoryReference(classReg, offsetof(J9ArrayClass, componentType), cg));\n+\n+   // Calculate maximum allowable object size in elements and jump to OOL if it's higher than firstDimLenReg.\n+   int32_t elementSize = TR::Compiler->om.sizeofReferenceField();\n+   uintptr_t maxObjectSize = cg->getMaxObjectSizeGuaranteedNotToOverflow();\n+   uintptr_t maxObjectSizeInElements = maxObjectSize / elementSize;\n+\n+   if (comp->target().is64Bit() && !(maxObjectSizeInElements >= 0 && maxObjectSizeInElements <= (uintptr_t)INT_MAX))\n+      {\n+      generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CLG, node, firstDimLenReg, static_cast<int64_t>(maxObjectSizeInElements), TR::InstOpCode::COND_BRH, oolJumpLabel, false);\n+      }\n+   else\n+      {\n+      generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, static_cast<int32_t>(maxObjectSizeInElements), TR::InstOpCode::COND_BHR, oolJumpLabel, false);\n+      }\n+\n+   // Now check to see if we have enough space to do the allocation. If not then jump to OOL code.\n+   generateRRInstruction(cg, TR::InstOpCode::LR, node, temp1Reg, firstDimLenReg);\n+\n+   int32_t round = (elementSize >= TR::Compiler->om.objectAlignmentInBytes()) ? 0 : TR::Compiler->om.objectAlignmentInBytes();\n+   int32_t disp32 = round ? (round - 1) : 0;\n+\n+   static const uint8_t multiplierToStrideMap[] = {0, 0, 1, 0, 2, 0, 0, 0, 3};\n+   generateRSInstruction(cg, TR::InstOpCode::getShiftLeftLogicalSingleOpCode(), node, temp1Reg, temp1Reg, multiplierToStrideMap[elementSize]);\n+   generateRILInstruction(cg, TR::InstOpCode::AGFI, node, temp1Reg, static_cast<int32_t>(TR::Compiler->om.contiguousArrayHeaderSizeInBytes()) + disp32);\n+\n+   if (round)\n+      {\n+      generateRILInstruction(cg, TR::InstOpCode::NILF, node, temp1Reg, -round);\n+      }\n \n+   // temp2Reg = firstDimLenReg * 16 (discontiguousArrayHeaderSizeInBytes)\n+   TR::Register *temp2Reg = cg->allocateRegister();\n+   generateRRInstruction(cg, TR::InstOpCode::LR, node, temp2Reg, firstDimLenReg);\n+   generateRSInstruction(cg, TR::InstOpCode::getShiftLeftLogicalSingleOpCode(), node, temp2Reg, temp2Reg, 4);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d2a7a622a97110d921a531735d149005cfec0f1"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQ3MTE2OQ==", "bodyText": "I've folded the register into the shift in instruction in 0c0a523.\nWe also use the API now as you suggested. I've added in an assert to make sure that the size returned is 16 (see 0c0a523). If it changes in the future then we will catch this immediately. Alternatively we can do the calculation here to figure out the correct shift amount no matter what size is returned if you think doing that extra work is worthwhile.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r528471169", "createdAt": "2020-11-23T04:51:54Z", "author": {"login": "dchopra001"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,259 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n ///////////////////////////////////////////////////////////////////////////////////////\n // multianewArrayEvaluator:  multi-dimensional new array of objects\n ///////////////////////////////////////////////////////////////////////////////////////\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::acall);\n-   TR::Register * targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n-   }\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = static_cast<TR_J9VMBase *>(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt() != 2)\n+      {\n+      traceMsg(cg->comp(), \"multianewArrayEvaluator - More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      return performHelperCall(node, NULL, TR::acall, false, cg);\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   // oolJumpLabel is a common point that all branches will jump to. From this label, we branch to OOL code.\n+   // We do this instead of jumping directly to OOL code from mainline because the RA can only handle the case where there's\n+   // a single jump point to OOL code.\n+   TR::LabelSymbol *oolJumpLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));\n+\n+   TR::Register *secondDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, secondDimLenReg, generateS390MemoryReference(dimsPtrReg, 0, cg));\n+\n+   // Check to see if second dimension is indeed 0. If yes, then proceed to handle the case here. Otherwise jump to OOL code.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, secondDimLenReg, 0, TR::InstOpCode::COND_BNE, oolJumpLabel, false);\n+\n+   // Now check to see if first dimension is also 0. If yes, continue below to handle the case when length for both dimensions is 0. Otherwise jump to nonZeroFirstDimLabel.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, 0, TR::InstOpCode::COND_BNE, nonZeroFirstDimLabel, false);\n+\n+   // First dimension zero, so only allocate 1 zero-length object array\n+   int32_t zeroArraySize = TR::Compiler->om.discontiguousArrayHeaderSizeInBytes();\n+   TR::Register *vmThreadReg = cg->getMethodMetaDataRealRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, targetReg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+\n+   // Branch to OOL if there's not enough space for an array of size 0.\n+   TR::Register *temp1Reg = cg->allocateRegister();\n+   generateRIEInstruction(cg, TR::InstOpCode::getAddHalfWordImmDistinctOperandOpCode(), node, temp1Reg, targetReg, zeroArraySize);\n+   generateRXInstruction(cg, TR::InstOpCode::getCmpLogicalOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapTop), cg));\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BH, node, oolJumpLabel);\n+\n+   // If there's enough space, then we can continue to allocate.\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+   \n+   bool use64BitClasses = comp->target().is64Bit() && !TR::Compiler->om.generateCompressedObjectHeaders();\n+\n+   // Init class and fields, then jump to end of ICF\n+   generateRXInstruction(cg, use64BitClasses ? TR::InstOpCode::STG : TR::InstOpCode::ST, node, classReg, generateS390MemoryReference(targetReg, TR::Compiler->om.offsetOfObjectVftField(), cg));\n+   generateSILInstruction(cg, use64BitClasses ? TR::InstOpCode::MVGHI : TR::InstOpCode::MVHI, node, generateS390MemoryReference(targetReg, fej9->getOffsetOfContiguousArraySizeField(), cg), 0);\n+   generateSILInstruction(cg, use64BitClasses ? TR::InstOpCode::MVGHI : TR::InstOpCode::MVHI, node, generateS390MemoryReference(targetReg, fej9->getOffsetOfDiscontiguousArraySizeField(), cg), 0);\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);\n+\n+   // We end up in this region of the ICF if the first dimension is non-zero and the second dimension is zero.\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, nonZeroFirstDimLabel);\n+\n+   TR::Register *componentClassReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, componentClassReg, generateS390MemoryReference(classReg, offsetof(J9ArrayClass, componentType), cg));\n+\n+   // Calculate maximum allowable object size in elements and jump to OOL if it's higher than firstDimLenReg.\n+   int32_t elementSize = TR::Compiler->om.sizeofReferenceField();\n+   uintptr_t maxObjectSize = cg->getMaxObjectSizeGuaranteedNotToOverflow();\n+   uintptr_t maxObjectSizeInElements = maxObjectSize / elementSize;\n+\n+   if (comp->target().is64Bit() && !(maxObjectSizeInElements >= 0 && maxObjectSizeInElements <= (uintptr_t)INT_MAX))\n+      {\n+      generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CLG, node, firstDimLenReg, static_cast<int64_t>(maxObjectSizeInElements), TR::InstOpCode::COND_BRH, oolJumpLabel, false);\n+      }\n+   else\n+      {\n+      generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, static_cast<int32_t>(maxObjectSizeInElements), TR::InstOpCode::COND_BHR, oolJumpLabel, false);\n+      }\n+\n+   // Now check to see if we have enough space to do the allocation. If not then jump to OOL code.\n+   generateRRInstruction(cg, TR::InstOpCode::LR, node, temp1Reg, firstDimLenReg);\n+\n+   int32_t round = (elementSize >= TR::Compiler->om.objectAlignmentInBytes()) ? 0 : TR::Compiler->om.objectAlignmentInBytes();\n+   int32_t disp32 = round ? (round - 1) : 0;\n+\n+   static const uint8_t multiplierToStrideMap[] = {0, 0, 1, 0, 2, 0, 0, 0, 3};\n+   generateRSInstruction(cg, TR::InstOpCode::getShiftLeftLogicalSingleOpCode(), node, temp1Reg, temp1Reg, multiplierToStrideMap[elementSize]);\n+   generateRILInstruction(cg, TR::InstOpCode::AGFI, node, temp1Reg, static_cast<int32_t>(TR::Compiler->om.contiguousArrayHeaderSizeInBytes()) + disp32);\n+\n+   if (round)\n+      {\n+      generateRILInstruction(cg, TR::InstOpCode::NILF, node, temp1Reg, -round);\n+      }\n \n+   // temp2Reg = firstDimLenReg * 16 (discontiguousArrayHeaderSizeInBytes)\n+   TR::Register *temp2Reg = cg->allocateRegister();\n+   generateRRInstruction(cg, TR::InstOpCode::LR, node, temp2Reg, firstDimLenReg);\n+   generateRSInstruction(cg, TR::InstOpCode::getShiftLeftLogicalSingleOpCode(), node, temp2Reg, temp2Reg, 4);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzkyMjk1OA=="}, "originalCommit": {"oid": "0d2a7a622a97110d921a531735d149005cfec0f1"}, "originalPosition": 137}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxODA1MjMwOnYy", "diffSide": "RIGHT", "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QyMzoxMzoxOVrOH4jEIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwMDoyMTowMlrOH4kjeg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA1NjgwMQ==", "bodyText": "@bragaigor can you confirm in all of our GC policies that 0-length arrays will have the same layout, i.e. their size will be equal to sizeof(J9IndexableObjectDiscontiguousCompressed) or sizeof(J9IndexableObjectDiscontiguousFull) depending on compressedrefs mode. This is what the above om. API returns.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r529056801", "createdAt": "2020-11-23T23:13:19Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2943,13 +2944,230 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = static_cast<TR_J9VMBase *>(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt() != 2)\n+      {\n+      traceMsg(cg->comp(), \"multianewArrayEvaluator - More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      TR::ILOpCodes opCode = node->getOpCodeValue();\n+      TR::Node::recreate(node, TR::acall);\n+      TR::Register *helperTargetReg = TR::TreeEvaluator::performCall(node, false, cg);\n+      TR::Node::recreate(node, opCode);\n+      return helperTargetReg;\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   // oolJumpLabel is a common point that all branches will jump to. From this label, we branch to OOL code.\n+   // We do this instead of jumping directly to OOL code from mainline because the RA can only handle the case where there's\n+   // a single jump point to OOL code.\n+   TR::LabelSymbol *oolJumpLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));\n+\n+   TR::Register *secondDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, secondDimLenReg, generateS390MemoryReference(dimsPtrReg, 0, cg));\n+\n+   // Check to see if second dimension is indeed 0. If yes, then proceed to handle the case here. Otherwise jump to OOL code.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, secondDimLenReg, 0, TR::InstOpCode::COND_BNE, oolJumpLabel, false);\n+\n+   // Now check to see if first dimension is also 0. If yes, continue below to handle the case when length for both dimensions is 0. Otherwise jump to nonZeroFirstDimLabel.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, 0, TR::InstOpCode::COND_BNE, nonZeroFirstDimLabel, false);\n+\n+   // First dimension zero, so only allocate 1 zero-length object array\n+   int32_t zeroArraySize = TR::Compiler->om.discontiguousArrayHeaderSizeInBytes();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6678b5654755f3f8180759445dd464353128894f"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA4MTIxMA==", "bodyText": "That's correct, zero sized arrays will always have discontiguous array header layout independent of the policy.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r529081210", "createdAt": "2020-11-24T00:21:02Z", "author": {"login": "bragaigor"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2943,13 +2944,230 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = static_cast<TR_J9VMBase *>(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt() != 2)\n+      {\n+      traceMsg(cg->comp(), \"multianewArrayEvaluator - More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      TR::ILOpCodes opCode = node->getOpCodeValue();\n+      TR::Node::recreate(node, TR::acall);\n+      TR::Register *helperTargetReg = TR::TreeEvaluator::performCall(node, false, cg);\n+      TR::Node::recreate(node, opCode);\n+      return helperTargetReg;\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   // oolJumpLabel is a common point that all branches will jump to. From this label, we branch to OOL code.\n+   // We do this instead of jumping directly to OOL code from mainline because the RA can only handle the case where there's\n+   // a single jump point to OOL code.\n+   TR::LabelSymbol *oolJumpLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));\n+\n+   TR::Register *secondDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, secondDimLenReg, generateS390MemoryReference(dimsPtrReg, 0, cg));\n+\n+   // Check to see if second dimension is indeed 0. If yes, then proceed to handle the case here. Otherwise jump to OOL code.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, secondDimLenReg, 0, TR::InstOpCode::COND_BNE, oolJumpLabel, false);\n+\n+   // Now check to see if first dimension is also 0. If yes, continue below to handle the case when length for both dimensions is 0. Otherwise jump to nonZeroFirstDimLabel.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, 0, TR::InstOpCode::COND_BNE, nonZeroFirstDimLabel, false);\n+\n+   // First dimension zero, so only allocate 1 zero-length object array\n+   int32_t zeroArraySize = TR::Compiler->om.discontiguousArrayHeaderSizeInBytes();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA1NjgwMQ=="}, "originalCommit": {"oid": "6678b5654755f3f8180759445dd464353128894f"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxODA1MzQxOnYy", "diffSide": "RIGHT", "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QyMzoxMzo1M1rOH4jE1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNzo0NjoxMVrOH5OPJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA1Njk4Mw==", "bodyText": "This should be a compare and branch.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r529056983", "createdAt": "2020-11-23T23:13:53Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2943,13 +2944,230 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = static_cast<TR_J9VMBase *>(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt() != 2)\n+      {\n+      traceMsg(cg->comp(), \"multianewArrayEvaluator - More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      TR::ILOpCodes opCode = node->getOpCodeValue();\n+      TR::Node::recreate(node, TR::acall);\n+      TR::Register *helperTargetReg = TR::TreeEvaluator::performCall(node, false, cg);\n+      TR::Node::recreate(node, opCode);\n+      return helperTargetReg;\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   // oolJumpLabel is a common point that all branches will jump to. From this label, we branch to OOL code.\n+   // We do this instead of jumping directly to OOL code from mainline because the RA can only handle the case where there's\n+   // a single jump point to OOL code.\n+   TR::LabelSymbol *oolJumpLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));\n+\n+   TR::Register *secondDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, secondDimLenReg, generateS390MemoryReference(dimsPtrReg, 0, cg));\n+\n+   // Check to see if second dimension is indeed 0. If yes, then proceed to handle the case here. Otherwise jump to OOL code.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, secondDimLenReg, 0, TR::InstOpCode::COND_BNE, oolJumpLabel, false);\n+\n+   // Now check to see if first dimension is also 0. If yes, continue below to handle the case when length for both dimensions is 0. Otherwise jump to nonZeroFirstDimLabel.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, 0, TR::InstOpCode::COND_BNE, nonZeroFirstDimLabel, false);\n+\n+   // First dimension zero, so only allocate 1 zero-length object array\n+   int32_t zeroArraySize = TR::Compiler->om.discontiguousArrayHeaderSizeInBytes();\n+   TR::Register *vmThreadReg = cg->getMethodMetaDataRealRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, targetReg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+\n+   // Branch to OOL if there's not enough space for an array of size 0.\n+   TR::Register *temp1Reg = cg->allocateRegister();\n+   generateRIEInstruction(cg, TR::InstOpCode::getAddHalfWordImmDistinctOperandOpCode(), node, temp1Reg, targetReg, zeroArraySize);\n+   generateRXInstruction(cg, TR::InstOpCode::getCmpLogicalOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapTop), cg));\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BH, node, oolJumpLabel);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6678b5654755f3f8180759445dd464353128894f"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU5OTI1Mg==", "bodyText": "I didn't use the API for this and your other suggestion because I didn't find a version of the API that allows for a comparison with a memory reference. If there's another way of doing this then please let me know.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r529599252", "createdAt": "2020-11-24T14:45:40Z", "author": {"login": "dchopra001"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2943,13 +2944,230 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = static_cast<TR_J9VMBase *>(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt() != 2)\n+      {\n+      traceMsg(cg->comp(), \"multianewArrayEvaluator - More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      TR::ILOpCodes opCode = node->getOpCodeValue();\n+      TR::Node::recreate(node, TR::acall);\n+      TR::Register *helperTargetReg = TR::TreeEvaluator::performCall(node, false, cg);\n+      TR::Node::recreate(node, opCode);\n+      return helperTargetReg;\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   // oolJumpLabel is a common point that all branches will jump to. From this label, we branch to OOL code.\n+   // We do this instead of jumping directly to OOL code from mainline because the RA can only handle the case where there's\n+   // a single jump point to OOL code.\n+   TR::LabelSymbol *oolJumpLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));\n+\n+   TR::Register *secondDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, secondDimLenReg, generateS390MemoryReference(dimsPtrReg, 0, cg));\n+\n+   // Check to see if second dimension is indeed 0. If yes, then proceed to handle the case here. Otherwise jump to OOL code.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, secondDimLenReg, 0, TR::InstOpCode::COND_BNE, oolJumpLabel, false);\n+\n+   // Now check to see if first dimension is also 0. If yes, continue below to handle the case when length for both dimensions is 0. Otherwise jump to nonZeroFirstDimLabel.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, 0, TR::InstOpCode::COND_BNE, nonZeroFirstDimLabel, false);\n+\n+   // First dimension zero, so only allocate 1 zero-length object array\n+   int32_t zeroArraySize = TR::Compiler->om.discontiguousArrayHeaderSizeInBytes();\n+   TR::Register *vmThreadReg = cg->getMethodMetaDataRealRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, targetReg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+\n+   // Branch to OOL if there's not enough space for an array of size 0.\n+   TR::Register *temp1Reg = cg->allocateRegister();\n+   generateRIEInstruction(cg, TR::InstOpCode::getAddHalfWordImmDistinctOperandOpCode(), node, temp1Reg, targetReg, zeroArraySize);\n+   generateRXInstruction(cg, TR::InstOpCode::getCmpLogicalOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapTop), cg));\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BH, node, oolJumpLabel);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA1Njk4Mw=="}, "originalCommit": {"oid": "6678b5654755f3f8180759445dd464353128894f"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTc2NDEzNQ==", "bodyText": "You're totally correct. There doesn't seem to be a compare and branch variant for SI format comparisons. This will need to stay as is. Thanks for pointing this out.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r529764135", "createdAt": "2020-11-24T17:46:11Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2943,13 +2944,230 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = static_cast<TR_J9VMBase *>(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt() != 2)\n+      {\n+      traceMsg(cg->comp(), \"multianewArrayEvaluator - More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      TR::ILOpCodes opCode = node->getOpCodeValue();\n+      TR::Node::recreate(node, TR::acall);\n+      TR::Register *helperTargetReg = TR::TreeEvaluator::performCall(node, false, cg);\n+      TR::Node::recreate(node, opCode);\n+      return helperTargetReg;\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   // oolJumpLabel is a common point that all branches will jump to. From this label, we branch to OOL code.\n+   // We do this instead of jumping directly to OOL code from mainline because the RA can only handle the case where there's\n+   // a single jump point to OOL code.\n+   TR::LabelSymbol *oolJumpLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));\n+\n+   TR::Register *secondDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, secondDimLenReg, generateS390MemoryReference(dimsPtrReg, 0, cg));\n+\n+   // Check to see if second dimension is indeed 0. If yes, then proceed to handle the case here. Otherwise jump to OOL code.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, secondDimLenReg, 0, TR::InstOpCode::COND_BNE, oolJumpLabel, false);\n+\n+   // Now check to see if first dimension is also 0. If yes, continue below to handle the case when length for both dimensions is 0. Otherwise jump to nonZeroFirstDimLabel.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, 0, TR::InstOpCode::COND_BNE, nonZeroFirstDimLabel, false);\n+\n+   // First dimension zero, so only allocate 1 zero-length object array\n+   int32_t zeroArraySize = TR::Compiler->om.discontiguousArrayHeaderSizeInBytes();\n+   TR::Register *vmThreadReg = cg->getMethodMetaDataRealRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, targetReg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+\n+   // Branch to OOL if there's not enough space for an array of size 0.\n+   TR::Register *temp1Reg = cg->allocateRegister();\n+   generateRIEInstruction(cg, TR::InstOpCode::getAddHalfWordImmDistinctOperandOpCode(), node, temp1Reg, targetReg, zeroArraySize);\n+   generateRXInstruction(cg, TR::InstOpCode::getCmpLogicalOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapTop), cg));\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BH, node, oolJumpLabel);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA1Njk4Mw=="}, "originalCommit": {"oid": "6678b5654755f3f8180759445dd464353128894f"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxODA4ODAyOnYy", "diffSide": "RIGHT", "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QyMzoyNzoxNVrOH4jZuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNzo0NjoyMlrOH5OPiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA2MjMyOQ==", "bodyText": "This should be a compare and branch.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r529062329", "createdAt": "2020-11-23T23:27:15Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2943,13 +2944,230 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = static_cast<TR_J9VMBase *>(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt() != 2)\n+      {\n+      traceMsg(cg->comp(), \"multianewArrayEvaluator - More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      TR::ILOpCodes opCode = node->getOpCodeValue();\n+      TR::Node::recreate(node, TR::acall);\n+      TR::Register *helperTargetReg = TR::TreeEvaluator::performCall(node, false, cg);\n+      TR::Node::recreate(node, opCode);\n+      return helperTargetReg;\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   // oolJumpLabel is a common point that all branches will jump to. From this label, we branch to OOL code.\n+   // We do this instead of jumping directly to OOL code from mainline because the RA can only handle the case where there's\n+   // a single jump point to OOL code.\n+   TR::LabelSymbol *oolJumpLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));\n+\n+   TR::Register *secondDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, secondDimLenReg, generateS390MemoryReference(dimsPtrReg, 0, cg));\n+\n+   // Check to see if second dimension is indeed 0. If yes, then proceed to handle the case here. Otherwise jump to OOL code.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, secondDimLenReg, 0, TR::InstOpCode::COND_BNE, oolJumpLabel, false);\n+\n+   // Now check to see if first dimension is also 0. If yes, continue below to handle the case when length for both dimensions is 0. Otherwise jump to nonZeroFirstDimLabel.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, 0, TR::InstOpCode::COND_BNE, nonZeroFirstDimLabel, false);\n+\n+   // First dimension zero, so only allocate 1 zero-length object array\n+   int32_t zeroArraySize = TR::Compiler->om.discontiguousArrayHeaderSizeInBytes();\n+   TR::Register *vmThreadReg = cg->getMethodMetaDataRealRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, targetReg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+\n+   // Branch to OOL if there's not enough space for an array of size 0.\n+   TR::Register *temp1Reg = cg->allocateRegister();\n+   generateRIEInstruction(cg, TR::InstOpCode::getAddHalfWordImmDistinctOperandOpCode(), node, temp1Reg, targetReg, zeroArraySize);\n+   generateRXInstruction(cg, TR::InstOpCode::getCmpLogicalOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapTop), cg));\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BH, node, oolJumpLabel);\n+\n+   // If there's enough space, then we can continue to allocate.\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+   \n+   bool use64BitClasses = comp->target().is64Bit() && !TR::Compiler->om.generateCompressedObjectHeaders();\n+\n+   // Init class and fields, then jump to end of ICF\n+   generateRXInstruction(cg, use64BitClasses ? TR::InstOpCode::STG : TR::InstOpCode::ST, node, classReg, generateS390MemoryReference(targetReg, TR::Compiler->om.offsetOfObjectVftField(), cg));\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);\n+\n+   // We end up in this region of the ICF if the first dimension is non-zero and the second dimension is zero.\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, nonZeroFirstDimLabel);\n+\n+   TR::Register *componentClassReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, componentClassReg, generateS390MemoryReference(classReg, offsetof(J9ArrayClass, componentType), cg));\n+\n+   // Calculate maximum allowable object size in elements and jump to OOL if it's higher than firstDimLenReg.\n+   int32_t elementSize = TR::Compiler->om.sizeofReferenceField();\n+   uintptr_t maxObjectSize = cg->getMaxObjectSizeGuaranteedNotToOverflow();\n+   uintptr_t maxObjectSizeInElements = maxObjectSize / elementSize;\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, static_cast<int32_t>(maxObjectSizeInElements), TR::InstOpCode::COND_BHR, oolJumpLabel, false);\n+\n+   // Now check to see if we have enough space to do the allocation. If not then jump to OOL code.\n+   int32_t elementSizeAligned = OMR::align(elementSize, TR::Compiler->om.objectAlignmentInBytes());\n+   int32_t alignmentCompensation = (elementSize == elementSizeAligned) ? 0 : elementSizeAligned - 1;\n+   static const uint8_t multiplierToStrideMap[] = {0, 0, 1, 0, 2, 0, 0, 0, 3};\n+   TR_ASSERT_FATAL(elementSize <= 8, \"multianewArrayEvaluator - elementSize cannot be greater than 8!\");\n+   generateRSInstruction(cg, TR::InstOpCode::getShiftLeftLogicalSingleOpCode(), node, temp1Reg, firstDimLenReg, multiplierToStrideMap[elementSize]);\n+   generateRILInstruction(cg, TR::InstOpCode::AGFI, node, temp1Reg, static_cast<int32_t>(TR::Compiler->om.contiguousArrayHeaderSizeInBytes()) + alignmentCompensation);\n+\n+   if (alignmentCompensation != 0)\n+      {\n+      generateRILInstruction(cg, TR::InstOpCode::NILF, node, temp1Reg, -elementSizeAligned);\n+      }\n+\n+   TR::Register *temp2Reg = cg->allocateRegister();\n+   TR_ASSERT_FATAL(TR::Compiler->om.discontiguousArrayHeaderSizeInBytes() == 16, \"multianewArrayEvaluator - Expecting discontiguousArrayHeaderSizeInBytes to be 16.\");\n+   // temp2Reg = firstDimLenReg * 16 (discontiguousArrayHeaderSizeInBytes)\n+   generateRSInstruction(cg, TR::InstOpCode::getShiftLeftLogicalSingleOpCode(), node, temp2Reg, firstDimLenReg, 4);\n+\n+   generateRRInstruction(cg, TR::InstOpCode::getAddRegOpCode(), node, temp2Reg, temp1Reg);\n+\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, targetReg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+   generateRRInstruction(cg, TR::InstOpCode::getAddRegOpCode(), node, temp2Reg, targetReg);\n+   generateRXInstruction(cg, TR::InstOpCode::getCmpLogicalOpCode(), node, temp2Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapTop), cg));\n+\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BH, node, oolJumpLabel);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6678b5654755f3f8180759445dd464353128894f"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTc2NDIzNQ==", "bodyText": "See previous comment for why this is resolved.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r529764235", "createdAt": "2020-11-24T17:46:22Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2943,13 +2944,230 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = static_cast<TR_J9VMBase *>(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt() != 2)\n+      {\n+      traceMsg(cg->comp(), \"multianewArrayEvaluator - More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      TR::ILOpCodes opCode = node->getOpCodeValue();\n+      TR::Node::recreate(node, TR::acall);\n+      TR::Register *helperTargetReg = TR::TreeEvaluator::performCall(node, false, cg);\n+      TR::Node::recreate(node, opCode);\n+      return helperTargetReg;\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   // oolJumpLabel is a common point that all branches will jump to. From this label, we branch to OOL code.\n+   // We do this instead of jumping directly to OOL code from mainline because the RA can only handle the case where there's\n+   // a single jump point to OOL code.\n+   TR::LabelSymbol *oolJumpLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));\n+\n+   TR::Register *secondDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, secondDimLenReg, generateS390MemoryReference(dimsPtrReg, 0, cg));\n+\n+   // Check to see if second dimension is indeed 0. If yes, then proceed to handle the case here. Otherwise jump to OOL code.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, secondDimLenReg, 0, TR::InstOpCode::COND_BNE, oolJumpLabel, false);\n+\n+   // Now check to see if first dimension is also 0. If yes, continue below to handle the case when length for both dimensions is 0. Otherwise jump to nonZeroFirstDimLabel.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, 0, TR::InstOpCode::COND_BNE, nonZeroFirstDimLabel, false);\n+\n+   // First dimension zero, so only allocate 1 zero-length object array\n+   int32_t zeroArraySize = TR::Compiler->om.discontiguousArrayHeaderSizeInBytes();\n+   TR::Register *vmThreadReg = cg->getMethodMetaDataRealRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, targetReg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+\n+   // Branch to OOL if there's not enough space for an array of size 0.\n+   TR::Register *temp1Reg = cg->allocateRegister();\n+   generateRIEInstruction(cg, TR::InstOpCode::getAddHalfWordImmDistinctOperandOpCode(), node, temp1Reg, targetReg, zeroArraySize);\n+   generateRXInstruction(cg, TR::InstOpCode::getCmpLogicalOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapTop), cg));\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BH, node, oolJumpLabel);\n+\n+   // If there's enough space, then we can continue to allocate.\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+   \n+   bool use64BitClasses = comp->target().is64Bit() && !TR::Compiler->om.generateCompressedObjectHeaders();\n+\n+   // Init class and fields, then jump to end of ICF\n+   generateRXInstruction(cg, use64BitClasses ? TR::InstOpCode::STG : TR::InstOpCode::ST, node, classReg, generateS390MemoryReference(targetReg, TR::Compiler->om.offsetOfObjectVftField(), cg));\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);\n+\n+   // We end up in this region of the ICF if the first dimension is non-zero and the second dimension is zero.\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, nonZeroFirstDimLabel);\n+\n+   TR::Register *componentClassReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, componentClassReg, generateS390MemoryReference(classReg, offsetof(J9ArrayClass, componentType), cg));\n+\n+   // Calculate maximum allowable object size in elements and jump to OOL if it's higher than firstDimLenReg.\n+   int32_t elementSize = TR::Compiler->om.sizeofReferenceField();\n+   uintptr_t maxObjectSize = cg->getMaxObjectSizeGuaranteedNotToOverflow();\n+   uintptr_t maxObjectSizeInElements = maxObjectSize / elementSize;\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, static_cast<int32_t>(maxObjectSizeInElements), TR::InstOpCode::COND_BHR, oolJumpLabel, false);\n+\n+   // Now check to see if we have enough space to do the allocation. If not then jump to OOL code.\n+   int32_t elementSizeAligned = OMR::align(elementSize, TR::Compiler->om.objectAlignmentInBytes());\n+   int32_t alignmentCompensation = (elementSize == elementSizeAligned) ? 0 : elementSizeAligned - 1;\n+   static const uint8_t multiplierToStrideMap[] = {0, 0, 1, 0, 2, 0, 0, 0, 3};\n+   TR_ASSERT_FATAL(elementSize <= 8, \"multianewArrayEvaluator - elementSize cannot be greater than 8!\");\n+   generateRSInstruction(cg, TR::InstOpCode::getShiftLeftLogicalSingleOpCode(), node, temp1Reg, firstDimLenReg, multiplierToStrideMap[elementSize]);\n+   generateRILInstruction(cg, TR::InstOpCode::AGFI, node, temp1Reg, static_cast<int32_t>(TR::Compiler->om.contiguousArrayHeaderSizeInBytes()) + alignmentCompensation);\n+\n+   if (alignmentCompensation != 0)\n+      {\n+      generateRILInstruction(cg, TR::InstOpCode::NILF, node, temp1Reg, -elementSizeAligned);\n+      }\n+\n+   TR::Register *temp2Reg = cg->allocateRegister();\n+   TR_ASSERT_FATAL(TR::Compiler->om.discontiguousArrayHeaderSizeInBytes() == 16, \"multianewArrayEvaluator - Expecting discontiguousArrayHeaderSizeInBytes to be 16.\");\n+   // temp2Reg = firstDimLenReg * 16 (discontiguousArrayHeaderSizeInBytes)\n+   generateRSInstruction(cg, TR::InstOpCode::getShiftLeftLogicalSingleOpCode(), node, temp2Reg, firstDimLenReg, 4);\n+\n+   generateRRInstruction(cg, TR::InstOpCode::getAddRegOpCode(), node, temp2Reg, temp1Reg);\n+\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, targetReg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+   generateRRInstruction(cg, TR::InstOpCode::getAddRegOpCode(), node, temp2Reg, targetReg);\n+   generateRXInstruction(cg, TR::InstOpCode::getCmpLogicalOpCode(), node, temp2Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapTop), cg));\n+\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BH, node, oolJumpLabel);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA2MjMyOQ=="}, "originalCommit": {"oid": "6678b5654755f3f8180759445dd464353128894f"}, "originalPosition": 119}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxODEwNzcyOnYy", "diffSide": "RIGHT", "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QyMzozNToyNlrOH4jlyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxODoyNjoyMlrOH5Pzlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA2NTQxOA==", "bodyText": "@bragaigor can you also confirm that no matter what the GC policy, if an array of a certain length will fit into the TLH it will always have a contiguous layout?", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r529065418", "createdAt": "2020-11-23T23:35:26Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2943,13 +2944,230 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = static_cast<TR_J9VMBase *>(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt() != 2)\n+      {\n+      traceMsg(cg->comp(), \"multianewArrayEvaluator - More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      TR::ILOpCodes opCode = node->getOpCodeValue();\n+      TR::Node::recreate(node, TR::acall);\n+      TR::Register *helperTargetReg = TR::TreeEvaluator::performCall(node, false, cg);\n+      TR::Node::recreate(node, opCode);\n+      return helperTargetReg;\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   // oolJumpLabel is a common point that all branches will jump to. From this label, we branch to OOL code.\n+   // We do this instead of jumping directly to OOL code from mainline because the RA can only handle the case where there's\n+   // a single jump point to OOL code.\n+   TR::LabelSymbol *oolJumpLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));\n+\n+   TR::Register *secondDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, secondDimLenReg, generateS390MemoryReference(dimsPtrReg, 0, cg));\n+\n+   // Check to see if second dimension is indeed 0. If yes, then proceed to handle the case here. Otherwise jump to OOL code.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, secondDimLenReg, 0, TR::InstOpCode::COND_BNE, oolJumpLabel, false);\n+\n+   // Now check to see if first dimension is also 0. If yes, continue below to handle the case when length for both dimensions is 0. Otherwise jump to nonZeroFirstDimLabel.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, 0, TR::InstOpCode::COND_BNE, nonZeroFirstDimLabel, false);\n+\n+   // First dimension zero, so only allocate 1 zero-length object array\n+   int32_t zeroArraySize = TR::Compiler->om.discontiguousArrayHeaderSizeInBytes();\n+   TR::Register *vmThreadReg = cg->getMethodMetaDataRealRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, targetReg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+\n+   // Branch to OOL if there's not enough space for an array of size 0.\n+   TR::Register *temp1Reg = cg->allocateRegister();\n+   generateRIEInstruction(cg, TR::InstOpCode::getAddHalfWordImmDistinctOperandOpCode(), node, temp1Reg, targetReg, zeroArraySize);\n+   generateRXInstruction(cg, TR::InstOpCode::getCmpLogicalOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapTop), cg));\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BH, node, oolJumpLabel);\n+\n+   // If there's enough space, then we can continue to allocate.\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+   \n+   bool use64BitClasses = comp->target().is64Bit() && !TR::Compiler->om.generateCompressedObjectHeaders();\n+\n+   // Init class and fields, then jump to end of ICF\n+   generateRXInstruction(cg, use64BitClasses ? TR::InstOpCode::STG : TR::InstOpCode::ST, node, classReg, generateS390MemoryReference(targetReg, TR::Compiler->om.offsetOfObjectVftField(), cg));\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);\n+\n+   // We end up in this region of the ICF if the first dimension is non-zero and the second dimension is zero.\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, nonZeroFirstDimLabel);\n+\n+   TR::Register *componentClassReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, componentClassReg, generateS390MemoryReference(classReg, offsetof(J9ArrayClass, componentType), cg));\n+\n+   // Calculate maximum allowable object size in elements and jump to OOL if it's higher than firstDimLenReg.\n+   int32_t elementSize = TR::Compiler->om.sizeofReferenceField();\n+   uintptr_t maxObjectSize = cg->getMaxObjectSizeGuaranteedNotToOverflow();\n+   uintptr_t maxObjectSizeInElements = maxObjectSize / elementSize;\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, static_cast<int32_t>(maxObjectSizeInElements), TR::InstOpCode::COND_BHR, oolJumpLabel, false);\n+\n+   // Now check to see if we have enough space to do the allocation. If not then jump to OOL code.\n+   int32_t elementSizeAligned = OMR::align(elementSize, TR::Compiler->om.objectAlignmentInBytes());\n+   int32_t alignmentCompensation = (elementSize == elementSizeAligned) ? 0 : elementSizeAligned - 1;\n+   static const uint8_t multiplierToStrideMap[] = {0, 0, 1, 0, 2, 0, 0, 0, 3};\n+   TR_ASSERT_FATAL(elementSize <= 8, \"multianewArrayEvaluator - elementSize cannot be greater than 8!\");\n+   generateRSInstruction(cg, TR::InstOpCode::getShiftLeftLogicalSingleOpCode(), node, temp1Reg, firstDimLenReg, multiplierToStrideMap[elementSize]);\n+   generateRILInstruction(cg, TR::InstOpCode::AGFI, node, temp1Reg, static_cast<int32_t>(TR::Compiler->om.contiguousArrayHeaderSizeInBytes()) + alignmentCompensation);\n+\n+   if (alignmentCompensation != 0)\n+      {\n+      generateRILInstruction(cg, TR::InstOpCode::NILF, node, temp1Reg, -elementSizeAligned);\n+      }\n+\n+   TR::Register *temp2Reg = cg->allocateRegister();\n+   TR_ASSERT_FATAL(TR::Compiler->om.discontiguousArrayHeaderSizeInBytes() == 16, \"multianewArrayEvaluator - Expecting discontiguousArrayHeaderSizeInBytes to be 16.\");\n+   // temp2Reg = firstDimLenReg * 16 (discontiguousArrayHeaderSizeInBytes)\n+   generateRSInstruction(cg, TR::InstOpCode::getShiftLeftLogicalSingleOpCode(), node, temp2Reg, firstDimLenReg, 4);\n+\n+   generateRRInstruction(cg, TR::InstOpCode::getAddRegOpCode(), node, temp2Reg, temp1Reg);\n+\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, targetReg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+   generateRRInstruction(cg, TR::InstOpCode::getAddRegOpCode(), node, temp2Reg, targetReg);\n+   generateRXInstruction(cg, TR::InstOpCode::getCmpLogicalOpCode(), node, temp2Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapTop), cg));\n+\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BH, node, oolJumpLabel);\n+\n+   // We have enough space, so proceed with the allocation.\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp2Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+\n+   // Init 1st dim array class and size fields.\n+   generateRXInstruction(cg, use64BitClasses ? TR::InstOpCode::STG : TR::InstOpCode::ST, node, classReg, generateS390MemoryReference(targetReg, TR::Compiler->om.offsetOfObjectVftField(), cg));\n+   generateRXInstruction(cg, TR::InstOpCode::ST, node, firstDimLenReg, generateS390MemoryReference(targetReg, fej9->getOffsetOfContiguousArraySizeField(), cg));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6678b5654755f3f8180759445dd464353128894f"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA4MjUzMg==", "bodyText": "Not quite, arrays will always be contiguous with the exception of metronome and balanced policies. Both of these GC policies are region based, and the decision to either allocate an array contiguously or discontiguously is based on the array size in comparison to the region size. So I can imagine a situation where, in either of these policies, an array is large enough to not fit in TLH but small enough to fit inside a region. We will only have discontiguous array layout if the array is larger than a region. Does that help?", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r529082532", "createdAt": "2020-11-24T00:25:04Z", "author": {"login": "bragaigor"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2943,13 +2944,230 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = static_cast<TR_J9VMBase *>(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt() != 2)\n+      {\n+      traceMsg(cg->comp(), \"multianewArrayEvaluator - More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      TR::ILOpCodes opCode = node->getOpCodeValue();\n+      TR::Node::recreate(node, TR::acall);\n+      TR::Register *helperTargetReg = TR::TreeEvaluator::performCall(node, false, cg);\n+      TR::Node::recreate(node, opCode);\n+      return helperTargetReg;\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   // oolJumpLabel is a common point that all branches will jump to. From this label, we branch to OOL code.\n+   // We do this instead of jumping directly to OOL code from mainline because the RA can only handle the case where there's\n+   // a single jump point to OOL code.\n+   TR::LabelSymbol *oolJumpLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));\n+\n+   TR::Register *secondDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, secondDimLenReg, generateS390MemoryReference(dimsPtrReg, 0, cg));\n+\n+   // Check to see if second dimension is indeed 0. If yes, then proceed to handle the case here. Otherwise jump to OOL code.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, secondDimLenReg, 0, TR::InstOpCode::COND_BNE, oolJumpLabel, false);\n+\n+   // Now check to see if first dimension is also 0. If yes, continue below to handle the case when length for both dimensions is 0. Otherwise jump to nonZeroFirstDimLabel.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, 0, TR::InstOpCode::COND_BNE, nonZeroFirstDimLabel, false);\n+\n+   // First dimension zero, so only allocate 1 zero-length object array\n+   int32_t zeroArraySize = TR::Compiler->om.discontiguousArrayHeaderSizeInBytes();\n+   TR::Register *vmThreadReg = cg->getMethodMetaDataRealRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, targetReg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+\n+   // Branch to OOL if there's not enough space for an array of size 0.\n+   TR::Register *temp1Reg = cg->allocateRegister();\n+   generateRIEInstruction(cg, TR::InstOpCode::getAddHalfWordImmDistinctOperandOpCode(), node, temp1Reg, targetReg, zeroArraySize);\n+   generateRXInstruction(cg, TR::InstOpCode::getCmpLogicalOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapTop), cg));\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BH, node, oolJumpLabel);\n+\n+   // If there's enough space, then we can continue to allocate.\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+   \n+   bool use64BitClasses = comp->target().is64Bit() && !TR::Compiler->om.generateCompressedObjectHeaders();\n+\n+   // Init class and fields, then jump to end of ICF\n+   generateRXInstruction(cg, use64BitClasses ? TR::InstOpCode::STG : TR::InstOpCode::ST, node, classReg, generateS390MemoryReference(targetReg, TR::Compiler->om.offsetOfObjectVftField(), cg));\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);\n+\n+   // We end up in this region of the ICF if the first dimension is non-zero and the second dimension is zero.\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, nonZeroFirstDimLabel);\n+\n+   TR::Register *componentClassReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, componentClassReg, generateS390MemoryReference(classReg, offsetof(J9ArrayClass, componentType), cg));\n+\n+   // Calculate maximum allowable object size in elements and jump to OOL if it's higher than firstDimLenReg.\n+   int32_t elementSize = TR::Compiler->om.sizeofReferenceField();\n+   uintptr_t maxObjectSize = cg->getMaxObjectSizeGuaranteedNotToOverflow();\n+   uintptr_t maxObjectSizeInElements = maxObjectSize / elementSize;\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, static_cast<int32_t>(maxObjectSizeInElements), TR::InstOpCode::COND_BHR, oolJumpLabel, false);\n+\n+   // Now check to see if we have enough space to do the allocation. If not then jump to OOL code.\n+   int32_t elementSizeAligned = OMR::align(elementSize, TR::Compiler->om.objectAlignmentInBytes());\n+   int32_t alignmentCompensation = (elementSize == elementSizeAligned) ? 0 : elementSizeAligned - 1;\n+   static const uint8_t multiplierToStrideMap[] = {0, 0, 1, 0, 2, 0, 0, 0, 3};\n+   TR_ASSERT_FATAL(elementSize <= 8, \"multianewArrayEvaluator - elementSize cannot be greater than 8!\");\n+   generateRSInstruction(cg, TR::InstOpCode::getShiftLeftLogicalSingleOpCode(), node, temp1Reg, firstDimLenReg, multiplierToStrideMap[elementSize]);\n+   generateRILInstruction(cg, TR::InstOpCode::AGFI, node, temp1Reg, static_cast<int32_t>(TR::Compiler->om.contiguousArrayHeaderSizeInBytes()) + alignmentCompensation);\n+\n+   if (alignmentCompensation != 0)\n+      {\n+      generateRILInstruction(cg, TR::InstOpCode::NILF, node, temp1Reg, -elementSizeAligned);\n+      }\n+\n+   TR::Register *temp2Reg = cg->allocateRegister();\n+   TR_ASSERT_FATAL(TR::Compiler->om.discontiguousArrayHeaderSizeInBytes() == 16, \"multianewArrayEvaluator - Expecting discontiguousArrayHeaderSizeInBytes to be 16.\");\n+   // temp2Reg = firstDimLenReg * 16 (discontiguousArrayHeaderSizeInBytes)\n+   generateRSInstruction(cg, TR::InstOpCode::getShiftLeftLogicalSingleOpCode(), node, temp2Reg, firstDimLenReg, 4);\n+\n+   generateRRInstruction(cg, TR::InstOpCode::getAddRegOpCode(), node, temp2Reg, temp1Reg);\n+\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, targetReg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+   generateRRInstruction(cg, TR::InstOpCode::getAddRegOpCode(), node, temp2Reg, targetReg);\n+   generateRXInstruction(cg, TR::InstOpCode::getCmpLogicalOpCode(), node, temp2Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapTop), cg));\n+\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BH, node, oolJumpLabel);\n+\n+   // We have enough space, so proceed with the allocation.\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp2Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+\n+   // Init 1st dim array class and size fields.\n+   generateRXInstruction(cg, use64BitClasses ? TR::InstOpCode::STG : TR::InstOpCode::ST, node, classReg, generateS390MemoryReference(targetReg, TR::Compiler->om.offsetOfObjectVftField(), cg));\n+   generateRXInstruction(cg, TR::InstOpCode::ST, node, firstDimLenReg, generateS390MemoryReference(targetReg, fej9->getOffsetOfContiguousArraySizeField(), cg));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA2NTQxOA=="}, "originalCommit": {"oid": "6678b5654755f3f8180759445dd464353128894f"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTc2NjE4Ng==", "bodyText": "So I can imagine a situation where, in either of these policies, an array is large enough to not fit in TLH but small enough to fit inside a region.\n\n@bragaigor the above query tests for whether the array can fit within the TLH. I understand what you describe above, but is the converse true as well? i.e.\nIf an array is small enough to fit within the current TLH, it will always have a contiguous array layout.\nIs the above statement true?", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r529766186", "createdAt": "2020-11-24T17:49:24Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2943,13 +2944,230 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = static_cast<TR_J9VMBase *>(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt() != 2)\n+      {\n+      traceMsg(cg->comp(), \"multianewArrayEvaluator - More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      TR::ILOpCodes opCode = node->getOpCodeValue();\n+      TR::Node::recreate(node, TR::acall);\n+      TR::Register *helperTargetReg = TR::TreeEvaluator::performCall(node, false, cg);\n+      TR::Node::recreate(node, opCode);\n+      return helperTargetReg;\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   // oolJumpLabel is a common point that all branches will jump to. From this label, we branch to OOL code.\n+   // We do this instead of jumping directly to OOL code from mainline because the RA can only handle the case where there's\n+   // a single jump point to OOL code.\n+   TR::LabelSymbol *oolJumpLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));\n+\n+   TR::Register *secondDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, secondDimLenReg, generateS390MemoryReference(dimsPtrReg, 0, cg));\n+\n+   // Check to see if second dimension is indeed 0. If yes, then proceed to handle the case here. Otherwise jump to OOL code.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, secondDimLenReg, 0, TR::InstOpCode::COND_BNE, oolJumpLabel, false);\n+\n+   // Now check to see if first dimension is also 0. If yes, continue below to handle the case when length for both dimensions is 0. Otherwise jump to nonZeroFirstDimLabel.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, 0, TR::InstOpCode::COND_BNE, nonZeroFirstDimLabel, false);\n+\n+   // First dimension zero, so only allocate 1 zero-length object array\n+   int32_t zeroArraySize = TR::Compiler->om.discontiguousArrayHeaderSizeInBytes();\n+   TR::Register *vmThreadReg = cg->getMethodMetaDataRealRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, targetReg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+\n+   // Branch to OOL if there's not enough space for an array of size 0.\n+   TR::Register *temp1Reg = cg->allocateRegister();\n+   generateRIEInstruction(cg, TR::InstOpCode::getAddHalfWordImmDistinctOperandOpCode(), node, temp1Reg, targetReg, zeroArraySize);\n+   generateRXInstruction(cg, TR::InstOpCode::getCmpLogicalOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapTop), cg));\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BH, node, oolJumpLabel);\n+\n+   // If there's enough space, then we can continue to allocate.\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+   \n+   bool use64BitClasses = comp->target().is64Bit() && !TR::Compiler->om.generateCompressedObjectHeaders();\n+\n+   // Init class and fields, then jump to end of ICF\n+   generateRXInstruction(cg, use64BitClasses ? TR::InstOpCode::STG : TR::InstOpCode::ST, node, classReg, generateS390MemoryReference(targetReg, TR::Compiler->om.offsetOfObjectVftField(), cg));\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);\n+\n+   // We end up in this region of the ICF if the first dimension is non-zero and the second dimension is zero.\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, nonZeroFirstDimLabel);\n+\n+   TR::Register *componentClassReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, componentClassReg, generateS390MemoryReference(classReg, offsetof(J9ArrayClass, componentType), cg));\n+\n+   // Calculate maximum allowable object size in elements and jump to OOL if it's higher than firstDimLenReg.\n+   int32_t elementSize = TR::Compiler->om.sizeofReferenceField();\n+   uintptr_t maxObjectSize = cg->getMaxObjectSizeGuaranteedNotToOverflow();\n+   uintptr_t maxObjectSizeInElements = maxObjectSize / elementSize;\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, static_cast<int32_t>(maxObjectSizeInElements), TR::InstOpCode::COND_BHR, oolJumpLabel, false);\n+\n+   // Now check to see if we have enough space to do the allocation. If not then jump to OOL code.\n+   int32_t elementSizeAligned = OMR::align(elementSize, TR::Compiler->om.objectAlignmentInBytes());\n+   int32_t alignmentCompensation = (elementSize == elementSizeAligned) ? 0 : elementSizeAligned - 1;\n+   static const uint8_t multiplierToStrideMap[] = {0, 0, 1, 0, 2, 0, 0, 0, 3};\n+   TR_ASSERT_FATAL(elementSize <= 8, \"multianewArrayEvaluator - elementSize cannot be greater than 8!\");\n+   generateRSInstruction(cg, TR::InstOpCode::getShiftLeftLogicalSingleOpCode(), node, temp1Reg, firstDimLenReg, multiplierToStrideMap[elementSize]);\n+   generateRILInstruction(cg, TR::InstOpCode::AGFI, node, temp1Reg, static_cast<int32_t>(TR::Compiler->om.contiguousArrayHeaderSizeInBytes()) + alignmentCompensation);\n+\n+   if (alignmentCompensation != 0)\n+      {\n+      generateRILInstruction(cg, TR::InstOpCode::NILF, node, temp1Reg, -elementSizeAligned);\n+      }\n+\n+   TR::Register *temp2Reg = cg->allocateRegister();\n+   TR_ASSERT_FATAL(TR::Compiler->om.discontiguousArrayHeaderSizeInBytes() == 16, \"multianewArrayEvaluator - Expecting discontiguousArrayHeaderSizeInBytes to be 16.\");\n+   // temp2Reg = firstDimLenReg * 16 (discontiguousArrayHeaderSizeInBytes)\n+   generateRSInstruction(cg, TR::InstOpCode::getShiftLeftLogicalSingleOpCode(), node, temp2Reg, firstDimLenReg, 4);\n+\n+   generateRRInstruction(cg, TR::InstOpCode::getAddRegOpCode(), node, temp2Reg, temp1Reg);\n+\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, targetReg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+   generateRRInstruction(cg, TR::InstOpCode::getAddRegOpCode(), node, temp2Reg, targetReg);\n+   generateRXInstruction(cg, TR::InstOpCode::getCmpLogicalOpCode(), node, temp2Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapTop), cg));\n+\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BH, node, oolJumpLabel);\n+\n+   // We have enough space, so proceed with the allocation.\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp2Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+\n+   // Init 1st dim array class and size fields.\n+   generateRXInstruction(cg, use64BitClasses ? TR::InstOpCode::STG : TR::InstOpCode::ST, node, classReg, generateS390MemoryReference(targetReg, TR::Compiler->om.offsetOfObjectVftField(), cg));\n+   generateRXInstruction(cg, TR::InstOpCode::ST, node, firstDimLenReg, generateS390MemoryReference(targetReg, fej9->getOffsetOfContiguousArraySizeField(), cg));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA2NTQxOA=="}, "originalCommit": {"oid": "6678b5654755f3f8180759445dd464353128894f"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTc4OTg0Nw==", "bodyText": "If an array is small enough to fit within the current TLH, it will always have a contiguous array layout.\n\nGiven that TLH sizes cannot be greater than a region size then yes. TLHs are taken from Memory Pool, and Memory Pool is a property of a region; hence, always smaller; defaults are min region size is 512k and max TLH size is 128k (thanks @dmitripivkine). That way array size will always be strictly smaller than a region; hence, denoted as contiguous.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r529789847", "createdAt": "2020-11-24T18:26:22Z", "author": {"login": "bragaigor"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2943,13 +2944,230 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = static_cast<TR_J9VMBase *>(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt() != 2)\n+      {\n+      traceMsg(cg->comp(), \"multianewArrayEvaluator - More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      TR::ILOpCodes opCode = node->getOpCodeValue();\n+      TR::Node::recreate(node, TR::acall);\n+      TR::Register *helperTargetReg = TR::TreeEvaluator::performCall(node, false, cg);\n+      TR::Node::recreate(node, opCode);\n+      return helperTargetReg;\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   // oolJumpLabel is a common point that all branches will jump to. From this label, we branch to OOL code.\n+   // We do this instead of jumping directly to OOL code from mainline because the RA can only handle the case where there's\n+   // a single jump point to OOL code.\n+   TR::LabelSymbol *oolJumpLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));\n+\n+   TR::Register *secondDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, secondDimLenReg, generateS390MemoryReference(dimsPtrReg, 0, cg));\n+\n+   // Check to see if second dimension is indeed 0. If yes, then proceed to handle the case here. Otherwise jump to OOL code.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, secondDimLenReg, 0, TR::InstOpCode::COND_BNE, oolJumpLabel, false);\n+\n+   // Now check to see if first dimension is also 0. If yes, continue below to handle the case when length for both dimensions is 0. Otherwise jump to nonZeroFirstDimLabel.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, 0, TR::InstOpCode::COND_BNE, nonZeroFirstDimLabel, false);\n+\n+   // First dimension zero, so only allocate 1 zero-length object array\n+   int32_t zeroArraySize = TR::Compiler->om.discontiguousArrayHeaderSizeInBytes();\n+   TR::Register *vmThreadReg = cg->getMethodMetaDataRealRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, targetReg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+\n+   // Branch to OOL if there's not enough space for an array of size 0.\n+   TR::Register *temp1Reg = cg->allocateRegister();\n+   generateRIEInstruction(cg, TR::InstOpCode::getAddHalfWordImmDistinctOperandOpCode(), node, temp1Reg, targetReg, zeroArraySize);\n+   generateRXInstruction(cg, TR::InstOpCode::getCmpLogicalOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapTop), cg));\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BH, node, oolJumpLabel);\n+\n+   // If there's enough space, then we can continue to allocate.\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+   \n+   bool use64BitClasses = comp->target().is64Bit() && !TR::Compiler->om.generateCompressedObjectHeaders();\n+\n+   // Init class and fields, then jump to end of ICF\n+   generateRXInstruction(cg, use64BitClasses ? TR::InstOpCode::STG : TR::InstOpCode::ST, node, classReg, generateS390MemoryReference(targetReg, TR::Compiler->om.offsetOfObjectVftField(), cg));\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);\n+\n+   // We end up in this region of the ICF if the first dimension is non-zero and the second dimension is zero.\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, nonZeroFirstDimLabel);\n+\n+   TR::Register *componentClassReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, componentClassReg, generateS390MemoryReference(classReg, offsetof(J9ArrayClass, componentType), cg));\n+\n+   // Calculate maximum allowable object size in elements and jump to OOL if it's higher than firstDimLenReg.\n+   int32_t elementSize = TR::Compiler->om.sizeofReferenceField();\n+   uintptr_t maxObjectSize = cg->getMaxObjectSizeGuaranteedNotToOverflow();\n+   uintptr_t maxObjectSizeInElements = maxObjectSize / elementSize;\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, static_cast<int32_t>(maxObjectSizeInElements), TR::InstOpCode::COND_BHR, oolJumpLabel, false);\n+\n+   // Now check to see if we have enough space to do the allocation. If not then jump to OOL code.\n+   int32_t elementSizeAligned = OMR::align(elementSize, TR::Compiler->om.objectAlignmentInBytes());\n+   int32_t alignmentCompensation = (elementSize == elementSizeAligned) ? 0 : elementSizeAligned - 1;\n+   static const uint8_t multiplierToStrideMap[] = {0, 0, 1, 0, 2, 0, 0, 0, 3};\n+   TR_ASSERT_FATAL(elementSize <= 8, \"multianewArrayEvaluator - elementSize cannot be greater than 8!\");\n+   generateRSInstruction(cg, TR::InstOpCode::getShiftLeftLogicalSingleOpCode(), node, temp1Reg, firstDimLenReg, multiplierToStrideMap[elementSize]);\n+   generateRILInstruction(cg, TR::InstOpCode::AGFI, node, temp1Reg, static_cast<int32_t>(TR::Compiler->om.contiguousArrayHeaderSizeInBytes()) + alignmentCompensation);\n+\n+   if (alignmentCompensation != 0)\n+      {\n+      generateRILInstruction(cg, TR::InstOpCode::NILF, node, temp1Reg, -elementSizeAligned);\n+      }\n+\n+   TR::Register *temp2Reg = cg->allocateRegister();\n+   TR_ASSERT_FATAL(TR::Compiler->om.discontiguousArrayHeaderSizeInBytes() == 16, \"multianewArrayEvaluator - Expecting discontiguousArrayHeaderSizeInBytes to be 16.\");\n+   // temp2Reg = firstDimLenReg * 16 (discontiguousArrayHeaderSizeInBytes)\n+   generateRSInstruction(cg, TR::InstOpCode::getShiftLeftLogicalSingleOpCode(), node, temp2Reg, firstDimLenReg, 4);\n+\n+   generateRRInstruction(cg, TR::InstOpCode::getAddRegOpCode(), node, temp2Reg, temp1Reg);\n+\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, targetReg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+   generateRRInstruction(cg, TR::InstOpCode::getAddRegOpCode(), node, temp2Reg, targetReg);\n+   generateRXInstruction(cg, TR::InstOpCode::getCmpLogicalOpCode(), node, temp2Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapTop), cg));\n+\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BH, node, oolJumpLabel);\n+\n+   // We have enough space, so proceed with the allocation.\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp2Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+\n+   // Init 1st dim array class and size fields.\n+   generateRXInstruction(cg, use64BitClasses ? TR::InstOpCode::STG : TR::InstOpCode::ST, node, classReg, generateS390MemoryReference(targetReg, TR::Compiler->om.offsetOfObjectVftField(), cg));\n+   generateRXInstruction(cg, TR::InstOpCode::ST, node, firstDimLenReg, generateS390MemoryReference(targetReg, fej9->getOffsetOfContiguousArraySizeField(), cg));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA2NTQxOA=="}, "originalCommit": {"oid": "6678b5654755f3f8180759445dd464353128894f"}, "originalPosition": 126}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxODExOTQ0OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QyMzo0MDoyOVrOH4jtGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNDo1ODo0NlrOH5E0Eg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA2NzI5MA==", "bodyText": "We don't need distinct operands here. An RI format instruction will suffice. Use getAddHalfWordImmOpCode() instead with generateRIInstruction.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r529067290", "createdAt": "2020-11-23T23:40:29Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2943,13 +2944,230 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = static_cast<TR_J9VMBase *>(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt() != 2)\n+      {\n+      traceMsg(cg->comp(), \"multianewArrayEvaluator - More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      TR::ILOpCodes opCode = node->getOpCodeValue();\n+      TR::Node::recreate(node, TR::acall);\n+      TR::Register *helperTargetReg = TR::TreeEvaluator::performCall(node, false, cg);\n+      TR::Node::recreate(node, opCode);\n+      return helperTargetReg;\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   // oolJumpLabel is a common point that all branches will jump to. From this label, we branch to OOL code.\n+   // We do this instead of jumping directly to OOL code from mainline because the RA can only handle the case where there's\n+   // a single jump point to OOL code.\n+   TR::LabelSymbol *oolJumpLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));\n+\n+   TR::Register *secondDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, secondDimLenReg, generateS390MemoryReference(dimsPtrReg, 0, cg));\n+\n+   // Check to see if second dimension is indeed 0. If yes, then proceed to handle the case here. Otherwise jump to OOL code.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, secondDimLenReg, 0, TR::InstOpCode::COND_BNE, oolJumpLabel, false);\n+\n+   // Now check to see if first dimension is also 0. If yes, continue below to handle the case when length for both dimensions is 0. Otherwise jump to nonZeroFirstDimLabel.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, 0, TR::InstOpCode::COND_BNE, nonZeroFirstDimLabel, false);\n+\n+   // First dimension zero, so only allocate 1 zero-length object array\n+   int32_t zeroArraySize = TR::Compiler->om.discontiguousArrayHeaderSizeInBytes();\n+   TR::Register *vmThreadReg = cg->getMethodMetaDataRealRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, targetReg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+\n+   // Branch to OOL if there's not enough space for an array of size 0.\n+   TR::Register *temp1Reg = cg->allocateRegister();\n+   generateRIEInstruction(cg, TR::InstOpCode::getAddHalfWordImmDistinctOperandOpCode(), node, temp1Reg, targetReg, zeroArraySize);\n+   generateRXInstruction(cg, TR::InstOpCode::getCmpLogicalOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapTop), cg));\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BH, node, oolJumpLabel);\n+\n+   // If there's enough space, then we can continue to allocate.\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+   \n+   bool use64BitClasses = comp->target().is64Bit() && !TR::Compiler->om.generateCompressedObjectHeaders();\n+\n+   // Init class and fields, then jump to end of ICF\n+   generateRXInstruction(cg, use64BitClasses ? TR::InstOpCode::STG : TR::InstOpCode::ST, node, classReg, generateS390MemoryReference(targetReg, TR::Compiler->om.offsetOfObjectVftField(), cg));\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);\n+\n+   // We end up in this region of the ICF if the first dimension is non-zero and the second dimension is zero.\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, nonZeroFirstDimLabel);\n+\n+   TR::Register *componentClassReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, componentClassReg, generateS390MemoryReference(classReg, offsetof(J9ArrayClass, componentType), cg));\n+\n+   // Calculate maximum allowable object size in elements and jump to OOL if it's higher than firstDimLenReg.\n+   int32_t elementSize = TR::Compiler->om.sizeofReferenceField();\n+   uintptr_t maxObjectSize = cg->getMaxObjectSizeGuaranteedNotToOverflow();\n+   uintptr_t maxObjectSizeInElements = maxObjectSize / elementSize;\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, static_cast<int32_t>(maxObjectSizeInElements), TR::InstOpCode::COND_BHR, oolJumpLabel, false);\n+\n+   // Now check to see if we have enough space to do the allocation. If not then jump to OOL code.\n+   int32_t elementSizeAligned = OMR::align(elementSize, TR::Compiler->om.objectAlignmentInBytes());\n+   int32_t alignmentCompensation = (elementSize == elementSizeAligned) ? 0 : elementSizeAligned - 1;\n+   static const uint8_t multiplierToStrideMap[] = {0, 0, 1, 0, 2, 0, 0, 0, 3};\n+   TR_ASSERT_FATAL(elementSize <= 8, \"multianewArrayEvaluator - elementSize cannot be greater than 8!\");\n+   generateRSInstruction(cg, TR::InstOpCode::getShiftLeftLogicalSingleOpCode(), node, temp1Reg, firstDimLenReg, multiplierToStrideMap[elementSize]);\n+   generateRILInstruction(cg, TR::InstOpCode::AGFI, node, temp1Reg, static_cast<int32_t>(TR::Compiler->om.contiguousArrayHeaderSizeInBytes()) + alignmentCompensation);\n+\n+   if (alignmentCompensation != 0)\n+      {\n+      generateRILInstruction(cg, TR::InstOpCode::NILF, node, temp1Reg, -elementSizeAligned);\n+      }\n+\n+   TR::Register *temp2Reg = cg->allocateRegister();\n+   TR_ASSERT_FATAL(TR::Compiler->om.discontiguousArrayHeaderSizeInBytes() == 16, \"multianewArrayEvaluator - Expecting discontiguousArrayHeaderSizeInBytes to be 16.\");\n+   // temp2Reg = firstDimLenReg * 16 (discontiguousArrayHeaderSizeInBytes)\n+   generateRSInstruction(cg, TR::InstOpCode::getShiftLeftLogicalSingleOpCode(), node, temp2Reg, firstDimLenReg, 4);\n+\n+   generateRRInstruction(cg, TR::InstOpCode::getAddRegOpCode(), node, temp2Reg, temp1Reg);\n+\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, targetReg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+   generateRRInstruction(cg, TR::InstOpCode::getAddRegOpCode(), node, temp2Reg, targetReg);\n+   generateRXInstruction(cg, TR::InstOpCode::getCmpLogicalOpCode(), node, temp2Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapTop), cg));\n+\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BH, node, oolJumpLabel);\n+\n+   // We have enough space, so proceed with the allocation.\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp2Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+\n+   // Init 1st dim array class and size fields.\n+   generateRXInstruction(cg, use64BitClasses ? TR::InstOpCode::STG : TR::InstOpCode::ST, node, classReg, generateS390MemoryReference(targetReg, TR::Compiler->om.offsetOfObjectVftField(), cg));\n+   generateRXInstruction(cg, TR::InstOpCode::ST, node, firstDimLenReg, generateS390MemoryReference(targetReg, fej9->getOffsetOfContiguousArraySizeField(), cg));\n+\n+   // temp2 point to end of 1st dim array i.e. start of 2nd dim\n+   generateRRInstruction(cg, TR::InstOpCode::getLoadRegOpCode(), node, temp2Reg, targetReg);\n+   generateRRInstruction(cg, TR::InstOpCode::getAddRegOpCode(), node, temp2Reg, temp1Reg);\n+   generateRIEInstruction(cg, TR::InstOpCode::getAddHalfWordImmDistinctOperandOpCode(), node, temp1Reg, targetReg, TR::Compiler->om.contiguousArrayHeaderSizeInBytes());\n+\n+   uintptr_t heapBase = TR::Compiler->vm.heapBaseAddress();\n+   bool useRegForHeapBase = comp->target().is64Bit() && comp->useCompressedPointers() &&\n+                           (heapBase != 0) && (!IS_32BIT_SIGNED(heapBase) || TR::Compiler->om.nativeAddressesCanChangeSize());\n+   if (useRegForHeapBase)\n+      {\n+      uint32_t high32 = heapBase >> 32;\n+      generateRILInstruction(cg, TR::InstOpCode::LLIHF, node, secondDimLenReg, high32);\n+      generateRILInstruction(cg, TR::InstOpCode::IILF, node, secondDimLenReg, static_cast<uint32_t>(heapBase));\n+      }\n+\n+   // Loop start\n+   TR::LabelSymbol *loopLabel = generateLabelSymbol(cg);\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, loopLabel);\n+\n+   // Init 2nd dim element's class\n+   generateRXInstruction(cg, use64BitClasses ? TR::InstOpCode::STG : TR::InstOpCode::ST, node, componentClassReg, generateS390MemoryReference(temp2Reg, TR::Compiler->om.offsetOfObjectVftField(), cg));\n+\n+   // Store 2nd dim element into 1st dim array slot, compress temp2 if needed\n+   TR::Register *temp3Reg = cg->allocateRegister();\n+   if (comp->target().is64Bit() && comp->useCompressedPointers())\n+      {\n+      int32_t shiftAmount = TR::Compiler->om.compressedReferenceShift();\n+      generateRRInstruction(cg, TR::InstOpCode::getLoadRegOpCode(), node, temp3Reg, temp2Reg);\n+\n+      if (heapBase != 0)\n+         {\n+         if (useRegForHeapBase)\n+            {\n+            generateRRInstruction(cg, TR::InstOpCode::getSubstractRegOpCode(), node, temp3Reg, secondDimLenReg);\n+            }\n+         else\n+            {\n+            generateRILInstruction(cg, TR::InstOpCode::getSubtractLogicalImmOpCode(), node, temp3Reg, static_cast<int32_t>(heapBase));\n+            }\n+         }\n+      if (shiftAmount != 0)\n+         {\n+         generateRSInstruction(cg, comp->target().is64Bit() ? TR::InstOpCode::SRAG : TR::InstOpCode::SRAK, node, temp3Reg, temp3Reg, shiftAmount);\n+         }\n+      generateRXInstruction(cg, TR::InstOpCode::ST, node, temp3Reg, generateS390MemoryReference(temp1Reg, 0, cg));\n+      }\n+   else\n+      {\n+      generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp2Reg, generateS390MemoryReference(temp1Reg, 0, cg));\n+      }\n+\n+   // Advance cursors temp1 and temp2. Then branch back or fall through if done.\n+   generateRIEInstruction(cg, TR::InstOpCode::getAddHalfWordImmDistinctOperandOpCode(), node, temp2Reg, temp2Reg, TR::Compiler->om.discontiguousArrayHeaderSizeInBytes());\n+   generateRIEInstruction(cg, TR::InstOpCode::getAddHalfWordImmDistinctOperandOpCode(), node, temp1Reg, temp1Reg, elementSize);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6678b5654755f3f8180759445dd464353128894f"}, "originalPosition": 181}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTYwOTc0Ng==", "bodyText": "Changed in 5a8e256", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r529609746", "createdAt": "2020-11-24T14:58:46Z", "author": {"login": "dchopra001"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2943,13 +2944,230 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = static_cast<TR_J9VMBase *>(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt() != 2)\n+      {\n+      traceMsg(cg->comp(), \"multianewArrayEvaluator - More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      TR::ILOpCodes opCode = node->getOpCodeValue();\n+      TR::Node::recreate(node, TR::acall);\n+      TR::Register *helperTargetReg = TR::TreeEvaluator::performCall(node, false, cg);\n+      TR::Node::recreate(node, opCode);\n+      return helperTargetReg;\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   // oolJumpLabel is a common point that all branches will jump to. From this label, we branch to OOL code.\n+   // We do this instead of jumping directly to OOL code from mainline because the RA can only handle the case where there's\n+   // a single jump point to OOL code.\n+   TR::LabelSymbol *oolJumpLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));\n+\n+   TR::Register *secondDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, secondDimLenReg, generateS390MemoryReference(dimsPtrReg, 0, cg));\n+\n+   // Check to see if second dimension is indeed 0. If yes, then proceed to handle the case here. Otherwise jump to OOL code.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, secondDimLenReg, 0, TR::InstOpCode::COND_BNE, oolJumpLabel, false);\n+\n+   // Now check to see if first dimension is also 0. If yes, continue below to handle the case when length for both dimensions is 0. Otherwise jump to nonZeroFirstDimLabel.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, 0, TR::InstOpCode::COND_BNE, nonZeroFirstDimLabel, false);\n+\n+   // First dimension zero, so only allocate 1 zero-length object array\n+   int32_t zeroArraySize = TR::Compiler->om.discontiguousArrayHeaderSizeInBytes();\n+   TR::Register *vmThreadReg = cg->getMethodMetaDataRealRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, targetReg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+\n+   // Branch to OOL if there's not enough space for an array of size 0.\n+   TR::Register *temp1Reg = cg->allocateRegister();\n+   generateRIEInstruction(cg, TR::InstOpCode::getAddHalfWordImmDistinctOperandOpCode(), node, temp1Reg, targetReg, zeroArraySize);\n+   generateRXInstruction(cg, TR::InstOpCode::getCmpLogicalOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapTop), cg));\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BH, node, oolJumpLabel);\n+\n+   // If there's enough space, then we can continue to allocate.\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+   \n+   bool use64BitClasses = comp->target().is64Bit() && !TR::Compiler->om.generateCompressedObjectHeaders();\n+\n+   // Init class and fields, then jump to end of ICF\n+   generateRXInstruction(cg, use64BitClasses ? TR::InstOpCode::STG : TR::InstOpCode::ST, node, classReg, generateS390MemoryReference(targetReg, TR::Compiler->om.offsetOfObjectVftField(), cg));\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);\n+\n+   // We end up in this region of the ICF if the first dimension is non-zero and the second dimension is zero.\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, nonZeroFirstDimLabel);\n+\n+   TR::Register *componentClassReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, componentClassReg, generateS390MemoryReference(classReg, offsetof(J9ArrayClass, componentType), cg));\n+\n+   // Calculate maximum allowable object size in elements and jump to OOL if it's higher than firstDimLenReg.\n+   int32_t elementSize = TR::Compiler->om.sizeofReferenceField();\n+   uintptr_t maxObjectSize = cg->getMaxObjectSizeGuaranteedNotToOverflow();\n+   uintptr_t maxObjectSizeInElements = maxObjectSize / elementSize;\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, static_cast<int32_t>(maxObjectSizeInElements), TR::InstOpCode::COND_BHR, oolJumpLabel, false);\n+\n+   // Now check to see if we have enough space to do the allocation. If not then jump to OOL code.\n+   int32_t elementSizeAligned = OMR::align(elementSize, TR::Compiler->om.objectAlignmentInBytes());\n+   int32_t alignmentCompensation = (elementSize == elementSizeAligned) ? 0 : elementSizeAligned - 1;\n+   static const uint8_t multiplierToStrideMap[] = {0, 0, 1, 0, 2, 0, 0, 0, 3};\n+   TR_ASSERT_FATAL(elementSize <= 8, \"multianewArrayEvaluator - elementSize cannot be greater than 8!\");\n+   generateRSInstruction(cg, TR::InstOpCode::getShiftLeftLogicalSingleOpCode(), node, temp1Reg, firstDimLenReg, multiplierToStrideMap[elementSize]);\n+   generateRILInstruction(cg, TR::InstOpCode::AGFI, node, temp1Reg, static_cast<int32_t>(TR::Compiler->om.contiguousArrayHeaderSizeInBytes()) + alignmentCompensation);\n+\n+   if (alignmentCompensation != 0)\n+      {\n+      generateRILInstruction(cg, TR::InstOpCode::NILF, node, temp1Reg, -elementSizeAligned);\n+      }\n+\n+   TR::Register *temp2Reg = cg->allocateRegister();\n+   TR_ASSERT_FATAL(TR::Compiler->om.discontiguousArrayHeaderSizeInBytes() == 16, \"multianewArrayEvaluator - Expecting discontiguousArrayHeaderSizeInBytes to be 16.\");\n+   // temp2Reg = firstDimLenReg * 16 (discontiguousArrayHeaderSizeInBytes)\n+   generateRSInstruction(cg, TR::InstOpCode::getShiftLeftLogicalSingleOpCode(), node, temp2Reg, firstDimLenReg, 4);\n+\n+   generateRRInstruction(cg, TR::InstOpCode::getAddRegOpCode(), node, temp2Reg, temp1Reg);\n+\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, targetReg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+   generateRRInstruction(cg, TR::InstOpCode::getAddRegOpCode(), node, temp2Reg, targetReg);\n+   generateRXInstruction(cg, TR::InstOpCode::getCmpLogicalOpCode(), node, temp2Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapTop), cg));\n+\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BH, node, oolJumpLabel);\n+\n+   // We have enough space, so proceed with the allocation.\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp2Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+\n+   // Init 1st dim array class and size fields.\n+   generateRXInstruction(cg, use64BitClasses ? TR::InstOpCode::STG : TR::InstOpCode::ST, node, classReg, generateS390MemoryReference(targetReg, TR::Compiler->om.offsetOfObjectVftField(), cg));\n+   generateRXInstruction(cg, TR::InstOpCode::ST, node, firstDimLenReg, generateS390MemoryReference(targetReg, fej9->getOffsetOfContiguousArraySizeField(), cg));\n+\n+   // temp2 point to end of 1st dim array i.e. start of 2nd dim\n+   generateRRInstruction(cg, TR::InstOpCode::getLoadRegOpCode(), node, temp2Reg, targetReg);\n+   generateRRInstruction(cg, TR::InstOpCode::getAddRegOpCode(), node, temp2Reg, temp1Reg);\n+   generateRIEInstruction(cg, TR::InstOpCode::getAddHalfWordImmDistinctOperandOpCode(), node, temp1Reg, targetReg, TR::Compiler->om.contiguousArrayHeaderSizeInBytes());\n+\n+   uintptr_t heapBase = TR::Compiler->vm.heapBaseAddress();\n+   bool useRegForHeapBase = comp->target().is64Bit() && comp->useCompressedPointers() &&\n+                           (heapBase != 0) && (!IS_32BIT_SIGNED(heapBase) || TR::Compiler->om.nativeAddressesCanChangeSize());\n+   if (useRegForHeapBase)\n+      {\n+      uint32_t high32 = heapBase >> 32;\n+      generateRILInstruction(cg, TR::InstOpCode::LLIHF, node, secondDimLenReg, high32);\n+      generateRILInstruction(cg, TR::InstOpCode::IILF, node, secondDimLenReg, static_cast<uint32_t>(heapBase));\n+      }\n+\n+   // Loop start\n+   TR::LabelSymbol *loopLabel = generateLabelSymbol(cg);\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, loopLabel);\n+\n+   // Init 2nd dim element's class\n+   generateRXInstruction(cg, use64BitClasses ? TR::InstOpCode::STG : TR::InstOpCode::ST, node, componentClassReg, generateS390MemoryReference(temp2Reg, TR::Compiler->om.offsetOfObjectVftField(), cg));\n+\n+   // Store 2nd dim element into 1st dim array slot, compress temp2 if needed\n+   TR::Register *temp3Reg = cg->allocateRegister();\n+   if (comp->target().is64Bit() && comp->useCompressedPointers())\n+      {\n+      int32_t shiftAmount = TR::Compiler->om.compressedReferenceShift();\n+      generateRRInstruction(cg, TR::InstOpCode::getLoadRegOpCode(), node, temp3Reg, temp2Reg);\n+\n+      if (heapBase != 0)\n+         {\n+         if (useRegForHeapBase)\n+            {\n+            generateRRInstruction(cg, TR::InstOpCode::getSubstractRegOpCode(), node, temp3Reg, secondDimLenReg);\n+            }\n+         else\n+            {\n+            generateRILInstruction(cg, TR::InstOpCode::getSubtractLogicalImmOpCode(), node, temp3Reg, static_cast<int32_t>(heapBase));\n+            }\n+         }\n+      if (shiftAmount != 0)\n+         {\n+         generateRSInstruction(cg, comp->target().is64Bit() ? TR::InstOpCode::SRAG : TR::InstOpCode::SRAK, node, temp3Reg, temp3Reg, shiftAmount);\n+         }\n+      generateRXInstruction(cg, TR::InstOpCode::ST, node, temp3Reg, generateS390MemoryReference(temp1Reg, 0, cg));\n+      }\n+   else\n+      {\n+      generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp2Reg, generateS390MemoryReference(temp1Reg, 0, cg));\n+      }\n+\n+   // Advance cursors temp1 and temp2. Then branch back or fall through if done.\n+   generateRIEInstruction(cg, TR::InstOpCode::getAddHalfWordImmDistinctOperandOpCode(), node, temp2Reg, temp2Reg, TR::Compiler->om.discontiguousArrayHeaderSizeInBytes());\n+   generateRIEInstruction(cg, TR::InstOpCode::getAddHalfWordImmDistinctOperandOpCode(), node, temp1Reg, temp1Reg, elementSize);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA2NzI5MA=="}, "originalCommit": {"oid": "6678b5654755f3f8180759445dd464353128894f"}, "originalPosition": 181}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxODEzNDE1OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QyMzo0NjozNlrOH4j2HA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxODoxNjoyNFrOH5Pa5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA2OTU5Ng==", "bodyText": "I believe this is always 0. I don't think we support non-zero heap base today, nor do we envision it in the future. @0xdaryl should we just fold code that references it? It needlessly complicates these evaluators and we have no way of testing these code paths anyway.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r529069596", "createdAt": "2020-11-23T23:46:36Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2943,13 +2944,230 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = static_cast<TR_J9VMBase *>(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt() != 2)\n+      {\n+      traceMsg(cg->comp(), \"multianewArrayEvaluator - More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      TR::ILOpCodes opCode = node->getOpCodeValue();\n+      TR::Node::recreate(node, TR::acall);\n+      TR::Register *helperTargetReg = TR::TreeEvaluator::performCall(node, false, cg);\n+      TR::Node::recreate(node, opCode);\n+      return helperTargetReg;\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   // oolJumpLabel is a common point that all branches will jump to. From this label, we branch to OOL code.\n+   // We do this instead of jumping directly to OOL code from mainline because the RA can only handle the case where there's\n+   // a single jump point to OOL code.\n+   TR::LabelSymbol *oolJumpLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));\n+\n+   TR::Register *secondDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, secondDimLenReg, generateS390MemoryReference(dimsPtrReg, 0, cg));\n+\n+   // Check to see if second dimension is indeed 0. If yes, then proceed to handle the case here. Otherwise jump to OOL code.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, secondDimLenReg, 0, TR::InstOpCode::COND_BNE, oolJumpLabel, false);\n+\n+   // Now check to see if first dimension is also 0. If yes, continue below to handle the case when length for both dimensions is 0. Otherwise jump to nonZeroFirstDimLabel.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, 0, TR::InstOpCode::COND_BNE, nonZeroFirstDimLabel, false);\n+\n+   // First dimension zero, so only allocate 1 zero-length object array\n+   int32_t zeroArraySize = TR::Compiler->om.discontiguousArrayHeaderSizeInBytes();\n+   TR::Register *vmThreadReg = cg->getMethodMetaDataRealRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, targetReg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+\n+   // Branch to OOL if there's not enough space for an array of size 0.\n+   TR::Register *temp1Reg = cg->allocateRegister();\n+   generateRIEInstruction(cg, TR::InstOpCode::getAddHalfWordImmDistinctOperandOpCode(), node, temp1Reg, targetReg, zeroArraySize);\n+   generateRXInstruction(cg, TR::InstOpCode::getCmpLogicalOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapTop), cg));\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BH, node, oolJumpLabel);\n+\n+   // If there's enough space, then we can continue to allocate.\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+   \n+   bool use64BitClasses = comp->target().is64Bit() && !TR::Compiler->om.generateCompressedObjectHeaders();\n+\n+   // Init class and fields, then jump to end of ICF\n+   generateRXInstruction(cg, use64BitClasses ? TR::InstOpCode::STG : TR::InstOpCode::ST, node, classReg, generateS390MemoryReference(targetReg, TR::Compiler->om.offsetOfObjectVftField(), cg));\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);\n+\n+   // We end up in this region of the ICF if the first dimension is non-zero and the second dimension is zero.\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, nonZeroFirstDimLabel);\n+\n+   TR::Register *componentClassReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, componentClassReg, generateS390MemoryReference(classReg, offsetof(J9ArrayClass, componentType), cg));\n+\n+   // Calculate maximum allowable object size in elements and jump to OOL if it's higher than firstDimLenReg.\n+   int32_t elementSize = TR::Compiler->om.sizeofReferenceField();\n+   uintptr_t maxObjectSize = cg->getMaxObjectSizeGuaranteedNotToOverflow();\n+   uintptr_t maxObjectSizeInElements = maxObjectSize / elementSize;\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, static_cast<int32_t>(maxObjectSizeInElements), TR::InstOpCode::COND_BHR, oolJumpLabel, false);\n+\n+   // Now check to see if we have enough space to do the allocation. If not then jump to OOL code.\n+   int32_t elementSizeAligned = OMR::align(elementSize, TR::Compiler->om.objectAlignmentInBytes());\n+   int32_t alignmentCompensation = (elementSize == elementSizeAligned) ? 0 : elementSizeAligned - 1;\n+   static const uint8_t multiplierToStrideMap[] = {0, 0, 1, 0, 2, 0, 0, 0, 3};\n+   TR_ASSERT_FATAL(elementSize <= 8, \"multianewArrayEvaluator - elementSize cannot be greater than 8!\");\n+   generateRSInstruction(cg, TR::InstOpCode::getShiftLeftLogicalSingleOpCode(), node, temp1Reg, firstDimLenReg, multiplierToStrideMap[elementSize]);\n+   generateRILInstruction(cg, TR::InstOpCode::AGFI, node, temp1Reg, static_cast<int32_t>(TR::Compiler->om.contiguousArrayHeaderSizeInBytes()) + alignmentCompensation);\n+\n+   if (alignmentCompensation != 0)\n+      {\n+      generateRILInstruction(cg, TR::InstOpCode::NILF, node, temp1Reg, -elementSizeAligned);\n+      }\n+\n+   TR::Register *temp2Reg = cg->allocateRegister();\n+   TR_ASSERT_FATAL(TR::Compiler->om.discontiguousArrayHeaderSizeInBytes() == 16, \"multianewArrayEvaluator - Expecting discontiguousArrayHeaderSizeInBytes to be 16.\");\n+   // temp2Reg = firstDimLenReg * 16 (discontiguousArrayHeaderSizeInBytes)\n+   generateRSInstruction(cg, TR::InstOpCode::getShiftLeftLogicalSingleOpCode(), node, temp2Reg, firstDimLenReg, 4);\n+\n+   generateRRInstruction(cg, TR::InstOpCode::getAddRegOpCode(), node, temp2Reg, temp1Reg);\n+\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, targetReg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+   generateRRInstruction(cg, TR::InstOpCode::getAddRegOpCode(), node, temp2Reg, targetReg);\n+   generateRXInstruction(cg, TR::InstOpCode::getCmpLogicalOpCode(), node, temp2Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapTop), cg));\n+\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BH, node, oolJumpLabel);\n+\n+   // We have enough space, so proceed with the allocation.\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp2Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+\n+   // Init 1st dim array class and size fields.\n+   generateRXInstruction(cg, use64BitClasses ? TR::InstOpCode::STG : TR::InstOpCode::ST, node, classReg, generateS390MemoryReference(targetReg, TR::Compiler->om.offsetOfObjectVftField(), cg));\n+   generateRXInstruction(cg, TR::InstOpCode::ST, node, firstDimLenReg, generateS390MemoryReference(targetReg, fej9->getOffsetOfContiguousArraySizeField(), cg));\n+\n+   // temp2 point to end of 1st dim array i.e. start of 2nd dim\n+   generateRRInstruction(cg, TR::InstOpCode::getLoadRegOpCode(), node, temp2Reg, targetReg);\n+   generateRRInstruction(cg, TR::InstOpCode::getAddRegOpCode(), node, temp2Reg, temp1Reg);\n+   generateRIEInstruction(cg, TR::InstOpCode::getAddHalfWordImmDistinctOperandOpCode(), node, temp1Reg, targetReg, TR::Compiler->om.contiguousArrayHeaderSizeInBytes());\n+\n+   uintptr_t heapBase = TR::Compiler->vm.heapBaseAddress();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6678b5654755f3f8180759445dd464353128894f"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTc4MzUyNw==", "bodyText": "I've opened the following issue to track this potential work: #11263.\nIf we decide to remove it, then the code here can be removed as part of the cleanup in the new item.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r529783527", "createdAt": "2020-11-24T18:16:24Z", "author": {"login": "dchopra001"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2943,13 +2944,230 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = static_cast<TR_J9VMBase *>(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt() != 2)\n+      {\n+      traceMsg(cg->comp(), \"multianewArrayEvaluator - More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      TR::ILOpCodes opCode = node->getOpCodeValue();\n+      TR::Node::recreate(node, TR::acall);\n+      TR::Register *helperTargetReg = TR::TreeEvaluator::performCall(node, false, cg);\n+      TR::Node::recreate(node, opCode);\n+      return helperTargetReg;\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   // oolJumpLabel is a common point that all branches will jump to. From this label, we branch to OOL code.\n+   // We do this instead of jumping directly to OOL code from mainline because the RA can only handle the case where there's\n+   // a single jump point to OOL code.\n+   TR::LabelSymbol *oolJumpLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));\n+\n+   TR::Register *secondDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, secondDimLenReg, generateS390MemoryReference(dimsPtrReg, 0, cg));\n+\n+   // Check to see if second dimension is indeed 0. If yes, then proceed to handle the case here. Otherwise jump to OOL code.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, secondDimLenReg, 0, TR::InstOpCode::COND_BNE, oolJumpLabel, false);\n+\n+   // Now check to see if first dimension is also 0. If yes, continue below to handle the case when length for both dimensions is 0. Otherwise jump to nonZeroFirstDimLabel.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, 0, TR::InstOpCode::COND_BNE, nonZeroFirstDimLabel, false);\n+\n+   // First dimension zero, so only allocate 1 zero-length object array\n+   int32_t zeroArraySize = TR::Compiler->om.discontiguousArrayHeaderSizeInBytes();\n+   TR::Register *vmThreadReg = cg->getMethodMetaDataRealRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, targetReg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+\n+   // Branch to OOL if there's not enough space for an array of size 0.\n+   TR::Register *temp1Reg = cg->allocateRegister();\n+   generateRIEInstruction(cg, TR::InstOpCode::getAddHalfWordImmDistinctOperandOpCode(), node, temp1Reg, targetReg, zeroArraySize);\n+   generateRXInstruction(cg, TR::InstOpCode::getCmpLogicalOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapTop), cg));\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BH, node, oolJumpLabel);\n+\n+   // If there's enough space, then we can continue to allocate.\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+   \n+   bool use64BitClasses = comp->target().is64Bit() && !TR::Compiler->om.generateCompressedObjectHeaders();\n+\n+   // Init class and fields, then jump to end of ICF\n+   generateRXInstruction(cg, use64BitClasses ? TR::InstOpCode::STG : TR::InstOpCode::ST, node, classReg, generateS390MemoryReference(targetReg, TR::Compiler->om.offsetOfObjectVftField(), cg));\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);\n+\n+   // We end up in this region of the ICF if the first dimension is non-zero and the second dimension is zero.\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, nonZeroFirstDimLabel);\n+\n+   TR::Register *componentClassReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, componentClassReg, generateS390MemoryReference(classReg, offsetof(J9ArrayClass, componentType), cg));\n+\n+   // Calculate maximum allowable object size in elements and jump to OOL if it's higher than firstDimLenReg.\n+   int32_t elementSize = TR::Compiler->om.sizeofReferenceField();\n+   uintptr_t maxObjectSize = cg->getMaxObjectSizeGuaranteedNotToOverflow();\n+   uintptr_t maxObjectSizeInElements = maxObjectSize / elementSize;\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, static_cast<int32_t>(maxObjectSizeInElements), TR::InstOpCode::COND_BHR, oolJumpLabel, false);\n+\n+   // Now check to see if we have enough space to do the allocation. If not then jump to OOL code.\n+   int32_t elementSizeAligned = OMR::align(elementSize, TR::Compiler->om.objectAlignmentInBytes());\n+   int32_t alignmentCompensation = (elementSize == elementSizeAligned) ? 0 : elementSizeAligned - 1;\n+   static const uint8_t multiplierToStrideMap[] = {0, 0, 1, 0, 2, 0, 0, 0, 3};\n+   TR_ASSERT_FATAL(elementSize <= 8, \"multianewArrayEvaluator - elementSize cannot be greater than 8!\");\n+   generateRSInstruction(cg, TR::InstOpCode::getShiftLeftLogicalSingleOpCode(), node, temp1Reg, firstDimLenReg, multiplierToStrideMap[elementSize]);\n+   generateRILInstruction(cg, TR::InstOpCode::AGFI, node, temp1Reg, static_cast<int32_t>(TR::Compiler->om.contiguousArrayHeaderSizeInBytes()) + alignmentCompensation);\n+\n+   if (alignmentCompensation != 0)\n+      {\n+      generateRILInstruction(cg, TR::InstOpCode::NILF, node, temp1Reg, -elementSizeAligned);\n+      }\n+\n+   TR::Register *temp2Reg = cg->allocateRegister();\n+   TR_ASSERT_FATAL(TR::Compiler->om.discontiguousArrayHeaderSizeInBytes() == 16, \"multianewArrayEvaluator - Expecting discontiguousArrayHeaderSizeInBytes to be 16.\");\n+   // temp2Reg = firstDimLenReg * 16 (discontiguousArrayHeaderSizeInBytes)\n+   generateRSInstruction(cg, TR::InstOpCode::getShiftLeftLogicalSingleOpCode(), node, temp2Reg, firstDimLenReg, 4);\n+\n+   generateRRInstruction(cg, TR::InstOpCode::getAddRegOpCode(), node, temp2Reg, temp1Reg);\n+\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, targetReg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+   generateRRInstruction(cg, TR::InstOpCode::getAddRegOpCode(), node, temp2Reg, targetReg);\n+   generateRXInstruction(cg, TR::InstOpCode::getCmpLogicalOpCode(), node, temp2Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapTop), cg));\n+\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BH, node, oolJumpLabel);\n+\n+   // We have enough space, so proceed with the allocation.\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp2Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+\n+   // Init 1st dim array class and size fields.\n+   generateRXInstruction(cg, use64BitClasses ? TR::InstOpCode::STG : TR::InstOpCode::ST, node, classReg, generateS390MemoryReference(targetReg, TR::Compiler->om.offsetOfObjectVftField(), cg));\n+   generateRXInstruction(cg, TR::InstOpCode::ST, node, firstDimLenReg, generateS390MemoryReference(targetReg, fej9->getOffsetOfContiguousArraySizeField(), cg));\n+\n+   // temp2 point to end of 1st dim array i.e. start of 2nd dim\n+   generateRRInstruction(cg, TR::InstOpCode::getLoadRegOpCode(), node, temp2Reg, targetReg);\n+   generateRRInstruction(cg, TR::InstOpCode::getAddRegOpCode(), node, temp2Reg, temp1Reg);\n+   generateRIEInstruction(cg, TR::InstOpCode::getAddHalfWordImmDistinctOperandOpCode(), node, temp1Reg, targetReg, TR::Compiler->om.contiguousArrayHeaderSizeInBytes());\n+\n+   uintptr_t heapBase = TR::Compiler->vm.heapBaseAddress();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA2OTU5Ng=="}, "originalCommit": {"oid": "6678b5654755f3f8180759445dd464353128894f"}, "originalPosition": 133}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMjQ2MDY0OnYy", "diffSide": "RIGHT", "path": "test/functional/JIT_Test/src/jit/test/jitt/array/multianewarray.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNzo1MzowMFrOH5Of0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQyMToyOTo0NlrOH6nq5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTc2ODQwMA==", "bodyText": "Copyright should be 2020, 2020.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r529768400", "createdAt": "2020-11-24T17:53:00Z", "author": {"login": "fjeremic"}, "path": "test/functional/JIT_Test/src/jit/test/jitt/array/multianewarray.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*******************************************************************************\n+ * Copyright (c) 2001, 2020 IBM Corp. and others", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "54d6632c18ac873641e83f53e51c247f24db7052"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTIyOTQxMg==", "bodyText": "Fixed in d825ed9", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r531229412", "createdAt": "2020-11-26T21:29:46Z", "author": {"login": "dchopra001"}, "path": "test/functional/JIT_Test/src/jit/test/jitt/array/multianewarray.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*******************************************************************************\n+ * Copyright (c) 2001, 2020 IBM Corp. and others", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTc2ODQwMA=="}, "originalCommit": {"oid": "54d6632c18ac873641e83f53e51c247f24db7052"}, "originalPosition": 2}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMjQ3ODk2OnYy", "diffSide": "RIGHT", "path": "test/functional/JIT_Test/src/jit/test/jitt/array/multianewarray.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNzo1NzoyN1rOH5Oq8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQyMToyOTozOFrOH6nqyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTc3MTI1MQ==", "bodyText": "Do we need this? Can't we just use AssertJUnit.assertEquals which is much more standard and pretty prints everything for us already.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r529771251", "createdAt": "2020-11-24T17:57:27Z", "author": {"login": "fjeremic"}, "path": "test/functional/JIT_Test/src/jit/test/jitt/array/multianewarray.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*******************************************************************************\n+ * Copyright (c) 2001, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+package jit.test.jitt.array;\n+\n+import org.testng.annotations.Test;\n+import org.testng.log4testng.Logger;\n+import org.testng.Assert;\n+\n+@Test(groups = { \"level.sanity\",\"component.jit\" })\n+\n+public class multianewarray extends jit.test.jitt.Test\n+   {\n+\n+   private static Logger logger = Logger.getLogger(multianewarray.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "54d6632c18ac873641e83f53e51c247f24db7052"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTIyOTM4NA==", "bodyText": "Switch to AssertJUnit class in d825ed9", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r531229384", "createdAt": "2020-11-26T21:29:38Z", "author": {"login": "dchopra001"}, "path": "test/functional/JIT_Test/src/jit/test/jitt/array/multianewarray.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*******************************************************************************\n+ * Copyright (c) 2001, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+package jit.test.jitt.array;\n+\n+import org.testng.annotations.Test;\n+import org.testng.log4testng.Logger;\n+import org.testng.Assert;\n+\n+@Test(groups = { \"level.sanity\",\"component.jit\" })\n+\n+public class multianewarray extends jit.test.jitt.Test\n+   {\n+\n+   private static Logger logger = Logger.getLogger(multianewarray.class);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTc3MTI1MQ=="}, "originalCommit": {"oid": "54d6632c18ac873641e83f53e51c247f24db7052"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMjQ4NTY4OnYy", "diffSide": "RIGHT", "path": "test/functional/JIT_Test/src/jit/test/jitt/array/multianewarray.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNzo1OTowOVrOH5OvJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxNToxNDowOVrOH7Bqfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTc3MjMyNA==", "bodyText": "Do we need to extend this class? What functionality does it provide?", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r529772324", "createdAt": "2020-11-24T17:59:09Z", "author": {"login": "fjeremic"}, "path": "test/functional/JIT_Test/src/jit/test/jitt/array/multianewarray.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*******************************************************************************\n+ * Copyright (c) 2001, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+package jit.test.jitt.array;\n+\n+import org.testng.annotations.Test;\n+import org.testng.log4testng.Logger;\n+import org.testng.Assert;\n+\n+@Test(groups = { \"level.sanity\",\"component.jit\" })\n+\n+public class multianewarray extends jit.test.jitt.Test", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "54d6632c18ac873641e83f53e51c247f24db7052"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTE5MzM4NQ==", "bodyText": "I don't think this provides anything we need specifically, but this is the convention used throughout the other tests in this directory. We use this convention to add the test names inside testng.xml as well. So I think if we want to change it here, we should do it for all the other tests as well.\n@llxia Can you confirm or deny this? I might be missing something here.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r531193385", "createdAt": "2020-11-26T19:07:02Z", "author": {"login": "dchopra001"}, "path": "test/functional/JIT_Test/src/jit/test/jitt/array/multianewarray.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*******************************************************************************\n+ * Copyright (c) 2001, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+package jit.test.jitt.array;\n+\n+import org.testng.annotations.Test;\n+import org.testng.log4testng.Logger;\n+import org.testng.Assert;\n+\n+@Test(groups = { \"level.sanity\",\"component.jit\" })\n+\n+public class multianewarray extends jit.test.jitt.Test", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTc3MjMyNA=="}, "originalCommit": {"oid": "54d6632c18ac873641e83f53e51c247f24db7052"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTIzNjk5MQ==", "bodyText": "jit.test.jitt.Test is not needed for testng. The entry in testng.xml is the class name of the test <class name=\"jit.test.jitt.array.multianewarray\"/>. If we do not need anything from jit.test.jitt.Test, we do not need to extend the class.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r531236991", "createdAt": "2020-11-26T22:05:38Z", "author": {"login": "llxia"}, "path": "test/functional/JIT_Test/src/jit/test/jitt/array/multianewarray.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*******************************************************************************\n+ * Copyright (c) 2001, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+package jit.test.jitt.array;\n+\n+import org.testng.annotations.Test;\n+import org.testng.log4testng.Logger;\n+import org.testng.Assert;\n+\n+@Test(groups = { \"level.sanity\",\"component.jit\" })\n+\n+public class multianewarray extends jit.test.jitt.Test", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTc3MjMyNA=="}, "originalCommit": {"oid": "54d6632c18ac873641e83f53e51c247f24db7052"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTY1NTI5NA==", "bodyText": "Thank you for the explanation. I've removed the class extension here: 51ffa13", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r531655294", "createdAt": "2020-11-27T15:14:09Z", "author": {"login": "dchopra001"}, "path": "test/functional/JIT_Test/src/jit/test/jitt/array/multianewarray.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*******************************************************************************\n+ * Copyright (c) 2001, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+package jit.test.jitt.array;\n+\n+import org.testng.annotations.Test;\n+import org.testng.log4testng.Logger;\n+import org.testng.Assert;\n+\n+@Test(groups = { \"level.sanity\",\"component.jit\" })\n+\n+public class multianewarray extends jit.test.jitt.Test", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTc3MjMyNA=="}, "originalCommit": {"oid": "54d6632c18ac873641e83f53e51c247f24db7052"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMjUxNzE4OnYy", "diffSide": "RIGHT", "path": "test/functional/JIT_Test/src/jit/test/jitt/array/multianewarray.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxODowNjoxMlrOH5PCaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQyMToyOTowNFrOH6nqPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTc3NzI1Nw==", "bodyText": "Can we add an invocation count here to run the test twice:\n@Test(groups = {\"level.sanity\"}, invocationCount=2)\n\nAnd then modify playlist.xml for jit_jitt to add a variation which runs -Xjit:count=1,disalbeAsyncCompilation. This will ensure everything in here is properly resolved.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r529777257", "createdAt": "2020-11-24T18:06:12Z", "author": {"login": "fjeremic"}, "path": "test/functional/JIT_Test/src/jit/test/jitt/array/multianewarray.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*******************************************************************************\n+ * Copyright (c) 2001, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+package jit.test.jitt.array;\n+\n+import org.testng.annotations.Test;\n+import org.testng.log4testng.Logger;\n+import org.testng.Assert;\n+\n+@Test(groups = { \"level.sanity\",\"component.jit\" })", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "54d6632c18ac873641e83f53e51c247f24db7052"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTIyOTI0Ng==", "bodyText": "Added in 0a0f545", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r531229246", "createdAt": "2020-11-26T21:29:04Z", "author": {"login": "dchopra001"}, "path": "test/functional/JIT_Test/src/jit/test/jitt/array/multianewarray.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*******************************************************************************\n+ * Copyright (c) 2001, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+package jit.test.jitt.array;\n+\n+import org.testng.annotations.Test;\n+import org.testng.log4testng.Logger;\n+import org.testng.Assert;\n+\n+@Test(groups = { \"level.sanity\",\"component.jit\" })", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTc3NzI1Nw=="}, "originalCommit": {"oid": "54d6632c18ac873641e83f53e51c247f24db7052"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMjUyMDA3OnYy", "diffSide": "RIGHT", "path": "test/functional/JIT_Test/src/jit/test/jitt/array/multianewarray.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxODowNjo1MVrOH5PEDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQyMToyNzowMVrOH6nosQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTc3NzY3Ng==", "bodyText": "Brace styles should match that of VM Java code (tabs, braces in Java style, etc.). See:\nhttps://github.com/dchopra001/openj9/blob/arrayDim-Final/test/functional/JIT_Test/src/jit/test/recognizedMethod/TestRecognizedCallTransformer.java\nas an example.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r529777676", "createdAt": "2020-11-24T18:06:51Z", "author": {"login": "fjeremic"}, "path": "test/functional/JIT_Test/src/jit/test/jitt/array/multianewarray.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*******************************************************************************\n+ * Copyright (c) 2001, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+package jit.test.jitt.array;\n+\n+import org.testng.annotations.Test;\n+import org.testng.log4testng.Logger;\n+import org.testng.Assert;\n+\n+@Test(groups = { \"level.sanity\",\"component.jit\" })\n+\n+public class multianewarray extends jit.test.jitt.Test\n+   {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "54d6632c18ac873641e83f53e51c247f24db7052"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTIyODg0OQ==", "bodyText": "Formatting fixed in: d825ed9", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r531228849", "createdAt": "2020-11-26T21:27:01Z", "author": {"login": "dchopra001"}, "path": "test/functional/JIT_Test/src/jit/test/jitt/array/multianewarray.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*******************************************************************************\n+ * Copyright (c) 2001, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+package jit.test.jitt.array;\n+\n+import org.testng.annotations.Test;\n+import org.testng.log4testng.Logger;\n+import org.testng.Assert;\n+\n+@Test(groups = { \"level.sanity\",\"component.jit\" })\n+\n+public class multianewarray extends jit.test.jitt.Test\n+   {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTc3NzY3Ng=="}, "originalCommit": {"oid": "54d6632c18ac873641e83f53e51c247f24db7052"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMjk1NTE2OnYy", "diffSide": "RIGHT", "path": "test/functional/JIT_Test/src/jit/test/jitt/array/multianewarray.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMDowMzozMVrOH5TLsg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQyMToyNjo1MlrOH6nong==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg0NTE3MA==", "bodyText": "Can we instead use a non-built in type of non-trivial length. For example can use use:\n\tpublic static class Vector {\n\t\tlong x;\n\t\tlong y;\n\t}\n\ninstead. This will have more coverage and ensure we handle classes with at least two fields. An instance of the above class will be greater than the object alignment, so that is covered as well.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r529845170", "createdAt": "2020-11-24T20:03:31Z", "author": {"login": "fjeremic"}, "path": "test/functional/JIT_Test/src/jit/test/jitt/array/multianewarray.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*******************************************************************************\n+ * Copyright (c) 2001, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+package jit.test.jitt.array;\n+\n+import org.testng.annotations.Test;\n+import org.testng.log4testng.Logger;\n+import org.testng.Assert;\n+\n+@Test(groups = { \"level.sanity\",\"component.jit\" })\n+\n+public class multianewarray extends jit.test.jitt.Test\n+   {\n+\n+   private static Logger logger = Logger.getLogger(multianewarray.class);\n+\n+   private Integer[][] createMultiArray(int firstDimLength, int secondDimLength)\n+      {\n+      Integer[][] multiarray = new Integer[firstDimLength][secondDimLength];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5263da19db7f55f00d638cc6d8ca672dfe11c20"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTIyODgzMA==", "bodyText": "We now test for both Integer and a Vector class: d825ed9.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r531228830", "createdAt": "2020-11-26T21:26:52Z", "author": {"login": "dchopra001"}, "path": "test/functional/JIT_Test/src/jit/test/jitt/array/multianewarray.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*******************************************************************************\n+ * Copyright (c) 2001, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+package jit.test.jitt.array;\n+\n+import org.testng.annotations.Test;\n+import org.testng.log4testng.Logger;\n+import org.testng.Assert;\n+\n+@Test(groups = { \"level.sanity\",\"component.jit\" })\n+\n+public class multianewarray extends jit.test.jitt.Test\n+   {\n+\n+   private static Logger logger = Logger.getLogger(multianewarray.class);\n+\n+   private Integer[][] createMultiArray(int firstDimLength, int secondDimLength)\n+      {\n+      Integer[][] multiarray = new Integer[firstDimLength][secondDimLength];", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg0NTE3MA=="}, "originalCommit": {"oid": "e5263da19db7f55f00d638cc6d8ca672dfe11c20"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMjk2MzYzOnYy", "diffSide": "RIGHT", "path": "test/functional/JIT_Test/src/jit/test/jitt/array/multianewarray.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMDowNTo1OFrOH5TQtw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQyMToyNDo0M1rOH6nmjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg0NjQ1NQ==", "bodyText": "We should just use AssertJUnit.assertTrue.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r529846455", "createdAt": "2020-11-24T20:05:58Z", "author": {"login": "fjeremic"}, "path": "test/functional/JIT_Test/src/jit/test/jitt/array/multianewarray.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*******************************************************************************\n+ * Copyright (c) 2001, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+package jit.test.jitt.array;\n+\n+import org.testng.annotations.Test;\n+import org.testng.log4testng.Logger;\n+import org.testng.Assert;\n+\n+@Test(groups = { \"level.sanity\",\"component.jit\" })\n+\n+public class multianewarray extends jit.test.jitt.Test\n+   {\n+\n+   private static Logger logger = Logger.getLogger(multianewarray.class);\n+\n+   private Integer[][] createMultiArray(int firstDimLength, int secondDimLength)\n+      {\n+      Integer[][] multiarray = new Integer[firstDimLength][secondDimLength];\n+      for (int i = 0; i < firstDimLength; i++)\n+         {\n+         for (int j = 0; j < secondDimLength; j++)\n+            {\n+            multiarray[i][j] = i * j;\n+            }\n+         }\n+      return multiarray;\n+      }\n+\n+   private boolean testMultiArray(Integer[][] inputArray)\n+      {\n+      for (int i = 0; i < inputArray.length; i++)\n+         {\n+         for (int j = 0; j < inputArray[0].length; j++)\n+            {\n+            if (inputArray[i][j] != i*j)\n+               {\n+               logger.error(\"testmultianewarray failed! Value at array[\" + i + \"][\" + j + \"] is \" + inputArray[i][j] + \" but expected to be \" + i*j);\n+               return false;\n+               }\n+            }\n+         }\n+      return true;\n+      }\n+\n+   @Test\n+   public void testmultianewarray()\n+      {\n+      Integer[][] inputArray;\n+\n+      for (int i = 0; i < 10000; i++)\n+         {\n+         inputArray = createMultiArray(0, 0);\n+         if (!testMultiArray(inputArray))\n+                 Assert.fail(\"input array not constructed correctly for array of length 0,0 at iteration\" + i);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5263da19db7f55f00d638cc6d8ca672dfe11c20"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTIyODMwMw==", "bodyText": "I've rewritten the tests so we now only JUnit asserts inside the test functions only: d825ed9", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r531228303", "createdAt": "2020-11-26T21:24:43Z", "author": {"login": "dchopra001"}, "path": "test/functional/JIT_Test/src/jit/test/jitt/array/multianewarray.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*******************************************************************************\n+ * Copyright (c) 2001, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+package jit.test.jitt.array;\n+\n+import org.testng.annotations.Test;\n+import org.testng.log4testng.Logger;\n+import org.testng.Assert;\n+\n+@Test(groups = { \"level.sanity\",\"component.jit\" })\n+\n+public class multianewarray extends jit.test.jitt.Test\n+   {\n+\n+   private static Logger logger = Logger.getLogger(multianewarray.class);\n+\n+   private Integer[][] createMultiArray(int firstDimLength, int secondDimLength)\n+      {\n+      Integer[][] multiarray = new Integer[firstDimLength][secondDimLength];\n+      for (int i = 0; i < firstDimLength; i++)\n+         {\n+         for (int j = 0; j < secondDimLength; j++)\n+            {\n+            multiarray[i][j] = i * j;\n+            }\n+         }\n+      return multiarray;\n+      }\n+\n+   private boolean testMultiArray(Integer[][] inputArray)\n+      {\n+      for (int i = 0; i < inputArray.length; i++)\n+         {\n+         for (int j = 0; j < inputArray[0].length; j++)\n+            {\n+            if (inputArray[i][j] != i*j)\n+               {\n+               logger.error(\"testmultianewarray failed! Value at array[\" + i + \"][\" + j + \"] is \" + inputArray[i][j] + \" but expected to be \" + i*j);\n+               return false;\n+               }\n+            }\n+         }\n+      return true;\n+      }\n+\n+   @Test\n+   public void testmultianewarray()\n+      {\n+      Integer[][] inputArray;\n+\n+      for (int i = 0; i < 10000; i++)\n+         {\n+         inputArray = createMultiArray(0, 0);\n+         if (!testMultiArray(inputArray))\n+                 Assert.fail(\"input array not constructed correctly for array of length 0,0 at iteration\" + i);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg0NjQ1NQ=="}, "originalCommit": {"oid": "e5263da19db7f55f00d638cc6d8ca672dfe11c20"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMzE5NjExOnYy", "diffSide": "RIGHT", "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMToxNDo1N1rOH5VboA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNzowMDozMFrOH58flQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg4MjAxNg==", "bodyText": "I'm fairly confident we don't need this code. This is already covered in the lowering phase:\nhttps://github.com/eclipse/openj9/blob/8c76311cdcccaa6def680d362df418eca6ae9325/runtime/compiler/env/VMJ9.cpp#L3394-L3449\nI don't think we can ever enter this if block. In fact it makes sense for this check to be performed in the lowering phase as such code doesn't need to be replicated across different codegens.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r529882016", "createdAt": "2020-11-24T21:14:57Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2943,13 +2944,230 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = static_cast<TR_J9VMBase *>(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt() != 2)\n+      {\n+      traceMsg(cg->comp(), \"multianewArrayEvaluator - More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      TR::ILOpCodes opCode = node->getOpCodeValue();\n+      TR::Node::recreate(node, TR::acall);\n+      TR::Register *helperTargetReg = TR::TreeEvaluator::performCall(node, false, cg);\n+      TR::Node::recreate(node, opCode);\n+      return helperTargetReg;\n+      }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5263da19db7f55f00d638cc6d8ca672dfe11c20"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDUyMjAwNQ==", "bodyText": "I think you're right. It looks like we do a check here to see if there are more than 2 dimensions. And in such a case we transform this into a TR::acall node. Going to just do a couple more sanity checks and then will remove the code in the evaluator.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r530522005", "createdAt": "2020-11-25T17:00:30Z", "author": {"login": "dchopra001"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2943,13 +2944,230 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = static_cast<TR_J9VMBase *>(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt() != 2)\n+      {\n+      traceMsg(cg->comp(), \"multianewArrayEvaluator - More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      TR::ILOpCodes opCode = node->getOpCodeValue();\n+      TR::Node::recreate(node, TR::acall);\n+      TR::Register *helperTargetReg = TR::TreeEvaluator::performCall(node, false, cg);\n+      TR::Node::recreate(node, opCode);\n+      return helperTargetReg;\n+      }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg4MjAxNg=="}, "originalCommit": {"oid": "e5263da19db7f55f00d638cc6d8ca672dfe11c20"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMzIwNTAyOnYy", "diffSide": "RIGHT", "path": "test/functional/JIT_Test/src/jit/test/jitt/array/multianewarray.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMToxNzoxMVrOH5VgqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQyMTozMDowOVrOH6nrOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg4MzMwNA==", "bodyText": "We should also validate the lengths of the arrays are what we think they are, just in case the inline code doesn't allocate the arrays of correct sizes.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r529883304", "createdAt": "2020-11-24T21:17:11Z", "author": {"login": "fjeremic"}, "path": "test/functional/JIT_Test/src/jit/test/jitt/array/multianewarray.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*******************************************************************************\n+ * Copyright (c) 2001, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+package jit.test.jitt.array;\n+\n+import org.testng.annotations.Test;\n+import org.testng.log4testng.Logger;\n+import org.testng.Assert;\n+\n+@Test(groups = { \"level.sanity\",\"component.jit\" })\n+\n+public class multianewarray extends jit.test.jitt.Test\n+   {\n+\n+   private static Logger logger = Logger.getLogger(multianewarray.class);\n+\n+   private Integer[][] createMultiArray(int firstDimLength, int secondDimLength)\n+      {\n+      Integer[][] multiarray = new Integer[firstDimLength][secondDimLength];\n+      for (int i = 0; i < firstDimLength; i++)\n+         {\n+         for (int j = 0; j < secondDimLength; j++)\n+            {\n+            multiarray[i][j] = i * j;\n+            }\n+         }\n+      return multiarray;\n+      }\n+\n+   private boolean testMultiArray(Integer[][] inputArray)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5263da19db7f55f00d638cc6d8ca672dfe11c20"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTIyOTQ5Ng==", "bodyText": "The test methods now test for length as well: d825ed9", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r531229496", "createdAt": "2020-11-26T21:30:09Z", "author": {"login": "dchopra001"}, "path": "test/functional/JIT_Test/src/jit/test/jitt/array/multianewarray.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*******************************************************************************\n+ * Copyright (c) 2001, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+package jit.test.jitt.array;\n+\n+import org.testng.annotations.Test;\n+import org.testng.log4testng.Logger;\n+import org.testng.Assert;\n+\n+@Test(groups = { \"level.sanity\",\"component.jit\" })\n+\n+public class multianewarray extends jit.test.jitt.Test\n+   {\n+\n+   private static Logger logger = Logger.getLogger(multianewarray.class);\n+\n+   private Integer[][] createMultiArray(int firstDimLength, int secondDimLength)\n+      {\n+      Integer[][] multiarray = new Integer[firstDimLength][secondDimLength];\n+      for (int i = 0; i < firstDimLength; i++)\n+         {\n+         for (int j = 0; j < secondDimLength; j++)\n+            {\n+            multiarray[i][j] = i * j;\n+            }\n+         }\n+      return multiarray;\n+      }\n+\n+   private boolean testMultiArray(Integer[][] inputArray)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg4MzMwNA=="}, "originalCommit": {"oid": "e5263da19db7f55f00d638cc6d8ca672dfe11c20"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzMjA2MDMwOnYy", "diffSide": "RIGHT", "path": "test/functional/JIT_Test/testng.xml", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQyMjoxNDoyOVrOH6oPrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQyMjoxNDoyOVrOH6oPrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTIzODgyOQ==", "bodyText": "btw, adding the class name under arrayTest  means any test target in playlist.xml uses -testnames arrayTest  will run this test. That is,\njit_jitt\njit_jitt_openj9_none_SCC\njit_jitt_none_SCC\njit_jitt_XCEEHDLR\nPlease ignore this comment if the change is intended. I just want to point it out so we do not run this test in the wrong test target or miss any cases.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r531238829", "createdAt": "2020-11-26T22:14:29Z", "author": {"login": "llxia"}, "path": "test/functional/JIT_Test/testng.xml", "diffHunk": "@@ -46,6 +46,7 @@\n       <class name=\"jit.test.jitt.array.intArrayLoadStore\"/>\n       <class name=\"jit.test.jitt.array.intArrayLoadStoreConstIndices\"/>\n       <class name=\"jit.test.jitt.array.shortArrayLoadStore\"/>\n+      <class name=\"jit.test.jitt.array.multianewarray\"/>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "96a5c5234fa62e73ea3e4ceba64bd5c0d782421d"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0MzU0MjM5OnYy", "diffSide": "RIGHT", "path": "test/functional/JIT_Test/src/jit/test/jitt/array/multianewarray.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQyMjoyMTozNlrOH8QLdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQyMjoyODoyM1rOH8QXbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjk0MTY4NA==", "bodyText": "I think the 10000 here may be causing timeout issues on Power. For example see here:\nhttps://ci.eclipse.org/openj9/job/Test_openjdk8_j9_sanity.functional_ppc64_aix_Personal_testList_1/95/console\n16:28:11  variation: -Xrs -Xjit:noJitUntilMain,count=0,assumeStrictFP,optlevel=warm,gcOnResolve,rtResolve -verbose:stackwalk=0 -Xdump\n16:28:11  JVM_OPTIONS:  -Xrs -Xjit:noJitUntilMain,count=0,assumeStrictFP,optlevel=warm,gcOnResolve,rtResolve -verbose:stackwalk=0 -Xdump \n16:28:11  { itercnt=1; \\\n16:28:11  mkdir -p \"/home/jenkins/workspace/Test_openjdk8_j9_sanity.functional_ppc64_aix_Personal_testList_1/openjdk-tests/TKG/../TKG/test_output_16067716828123/jit_jitt_1\"; \\\n16:28:11  cd \"/home/jenkins/workspace/Test_openjdk8_j9_sanity.functional_ppc64_aix_Personal_testList_1/openjdk-tests/TKG/../TKG/test_output_16067716828123/jit_jitt_1\"; \\\n16:28:11  \"/home/jenkins/workspace/Test_openjdk8_j9_sanity.functional_ppc64_aix_Personal_testList_1/openjdkbinary/j2sdk-image/bin/java\"  -Xrs -Xjit:noJitUntilMain,count=0,assumeStrictFP,optlevel=warm,gcOnResolve,rtResolve -verbose:stackwalk=0 -Xdump  \\\n16:28:11  -cp \"/home/jenkins/workspace/Test_openjdk8_j9_sanity.functional_ppc64_aix_Personal_testList_1/openjdk-tests/TKG/../../jvmtest/TestConfig/resources:/home/jenkins/workspace/Test_openjdk8_j9_sanity.functional_ppc64_aix_Personal_testList_1/openjdk-tests/TKG/../TKG/lib/testng.jar:/home/jenkins/workspace/Test_openjdk8_j9_sanity.functional_ppc64_aix_Personal_testList_1/openjdk-tests/TKG/../TKG/lib/jcommander.jar:/home/jenkins/workspace/Test_openjdk8_j9_sanity.functional_ppc64_aix_Personal_testList_1/openjdk-tests/TKG/../../jvmtest/functional/JIT_Test/jitt.jar\" \\\n16:28:11  org.testng.TestNG -d \"/home/jenkins/workspace/Test_openjdk8_j9_sanity.functional_ppc64_aix_Personal_testList_1/openjdk-tests/TKG/../TKG/test_output_16067716828123/jit_jitt_1\" \"/home/jenkins/workspace/Test_openjdk8_j9_sanity.functional_ppc64_aix_Personal_testList_1/openjdk-tests/TKG/../../jvmtest/functional/JIT_Test/testng.xml\" \\\n16:28:11  -testnames \\\n16:28:11  arrayTest,\\\n16:28:11  assemblerTest,\\\n16:28:11  castingTest,\\\n16:28:11  cfgTest,\\\n16:28:11  crashesTest,\\\n16:28:11  ctresolvesTest,\\\n16:28:11  exceptionsTest,\\\n16:28:11  fieldsTest,\\\n16:28:11  floatsTest,\\\n16:28:11  gcTest,\\\n16:28:11  geCastingTest,\\\n16:28:11  immedOpTest,\\\n16:28:11  invokeTest,\\\n16:28:11  mathTest,\\\n16:28:11  math2Test,\\\n16:28:11  miscTest,\\\n16:28:11  os390LinkageTest,\\\n16:28:11  promotionTest,\\\n16:28:11  resolvesTest,\\\n16:28:11  sieveTest,\\\n16:28:11  transitionsTest \\\n16:28:11  -groups level.sanity \\\n16:28:11  -excludegroups d.*.aix_ppc-64_cmprssptrs,d.*.arch.ppc,d.*.os.aix,d.*.bits.64,d.*.generic-all; \\\n16:28:11  if [ $? -eq 0 ] ; then echo \"\"; echo \"jit_jitt_1\"\"_PASSED\"; echo \"\"; cd /home/jenkins/workspace/Test_openjdk8_j9_sanity.functional_ppc64_aix_Personal_testList_1/openjdk-tests/TKG/..;  else echo \"\"; echo \"jit_jitt_1\"\"_FAILED\"; echo \"\"; fi; } 2>&1 | tee -a \"/home/jenkins/workspace/Test_openjdk8_j9_sanity.functional_ppc64_aix_Personal_testList_1/openjdk-tests/TKG/../TKG/test_output_16067716828123/TestTargetResult\";\n16:28:17  [IncludeExcludeTestAnnotationTransformer] [INFO] exclude file is /home/jenkins/workspace/Test_openjdk8_j9_sanity.functional_ppc64_aix_Personal_testList_1/openjdk-tests/TKG/../TestConfig/resources/excludes/latest_exclude_8.txt\n16:28:17  ...\n16:28:17  ... TestNG 6.14.2 by C\u00e9dric Beust (cedric@beust.com)\n16:28:17  ...\n16:28:17  \nCalling Pipeline was cancelled\n16:34:50  Sending interrupt signal to process\n16:35:04  /bin/sh[4]: 20316372 Terminated\n16:35:04  \n16:35:04  jit_jitt_1_FAILED\n\nIt was spinning for 5 mins. then got cancelled. Can we tone this down to something more reasonable, perhaps 64 would be enough?", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r532941684", "createdAt": "2020-11-30T22:21:36Z", "author": {"login": "fjeremic"}, "path": "test/functional/JIT_Test/src/jit/test/jitt/array/multianewarray.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+package jit.test.jitt.array;\n+\n+import org.testng.annotations.Test;\n+import org.testng.Assert;\t\n+import org.testng.AssertJUnit;\n+\n+@Test(groups = { \"level.sanity\",\"component.jit\" }, invocationCount=2)\n+public class multianewarray {\n+\tclass Vector {\n+\t\tlong x;\n+\t\tlong y;\n+\t}\n+\n+\tprivate Integer[][] createMultiArray(int firstDimLength, int secondDimLength) {\n+\t\tInteger[][] multiarray = new Integer[firstDimLength][secondDimLength];\n+\t\tfor (int i = 0; i < firstDimLength; i++) {\n+\t\t\tfor (int j = 0; j < secondDimLength; j++) {\n+\t\t\t\tmultiarray[i][j] = i * j;\n+\t\t\t}\n+\t\t}\n+\t\treturn multiarray;\n+\t}\n+\n+\tprivate Vector[][] createMultiVector(int firstDimLength, int secondDimLength) {\n+\t\tVector[][] multiVector = new Vector[firstDimLength][secondDimLength];\n+\t\tfor (int i = 0; i < firstDimLength; i++) {\n+\t\t\tfor (int j = 0; j < secondDimLength; j++) {\n+\t\t\t\tmultiVector[i][j] = new Vector();\n+\t\t\t\tmultiVector[i][j].x = i * j;\n+\t\t\t\tmultiVector[i][j].y = i * i + j * j;\n+\t\t\t}\n+\t\t}\n+\t\treturn multiVector;\n+\t}\n+\n+\tprivate void testMultiVector(Vector[][] inputVector, int dim1Length, int dim2Length) {\n+\t\tAssertJUnit.assertEquals(dim1Length, inputVector.length);\n+\t\tif (inputVector.length > 0)\n+\t\t\tAssertJUnit.assertEquals(dim2Length, inputVector[0].length);\n+\n+\t\tfor (int i = 0; i < inputVector.length; i++) {\n+\t\t\tfor (int j = 0; j < inputVector[0].length; j++) {\n+\t\t\t\tAssertJUnit.assertEquals(i*j, (inputVector[i][j]).x);\n+\t\t\t\tAssertJUnit.assertEquals(i*i + j*j, (inputVector[i][j]).y);\n+\t\t\t}\n+\t\t}\n+\t}\n+\tprivate void testMultiArray(Integer[][] inputArray, int dim1Length, int dim2Length) {\n+\t\tAssertJUnit.assertEquals(dim1Length, inputArray.length);\n+\t\tif (inputArray.length > 0)\n+\t\t\tAssertJUnit.assertEquals(dim2Length, inputArray[0].length);\n+\t\tfor (int i = 0; i < inputArray.length; i++) {\n+\t\t\tfor (int j = 0; j < inputArray[0].length; j++) {\n+\t\t\t\tAssertJUnit.assertEquals(i*j, (inputArray[i][j]).intValue());\n+\t\t\t}\n+\t\t}\n+\t}\n+\t@Test\n+\tpublic void testmultianewarray() {\n+\t\tInteger[][] inputArray;\n+\t\tVector[][] inputVector;\n+\t\tfor (int i = 0; i < 10000; i++) {\n+\t\t\tinputVector = createMultiVector(0, 0);\n+\t\t\ttestMultiVector(inputVector, 0, 0);\n+\t\t\tinputArray = createMultiArray(0, 0);\n+\t\t\ttestMultiArray(inputArray, 0, 0);\n+\t\t}\n+\t\tfor (int i = 0; i < 10000; i++) {\n+\t\t\tinputVector = createMultiVector(i, 0);\n+\t\t\ttestMultiVector(inputVector, i, 0);\n+\t\t\tinputArray = createMultiArray(i, 0);\n+\t\t\ttestMultiArray(inputArray, i, 0);\n+\t\t}\n+\t\tfor (int i = 0; i < 10000; i++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f85779ba406f57f872f3765b1546487d3f16dc4e"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjk0NDc0OA==", "bodyText": "Changed in : cfd7aa6", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r532944748", "createdAt": "2020-11-30T22:28:23Z", "author": {"login": "dchopra001"}, "path": "test/functional/JIT_Test/src/jit/test/jitt/array/multianewarray.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+package jit.test.jitt.array;\n+\n+import org.testng.annotations.Test;\n+import org.testng.Assert;\t\n+import org.testng.AssertJUnit;\n+\n+@Test(groups = { \"level.sanity\",\"component.jit\" }, invocationCount=2)\n+public class multianewarray {\n+\tclass Vector {\n+\t\tlong x;\n+\t\tlong y;\n+\t}\n+\n+\tprivate Integer[][] createMultiArray(int firstDimLength, int secondDimLength) {\n+\t\tInteger[][] multiarray = new Integer[firstDimLength][secondDimLength];\n+\t\tfor (int i = 0; i < firstDimLength; i++) {\n+\t\t\tfor (int j = 0; j < secondDimLength; j++) {\n+\t\t\t\tmultiarray[i][j] = i * j;\n+\t\t\t}\n+\t\t}\n+\t\treturn multiarray;\n+\t}\n+\n+\tprivate Vector[][] createMultiVector(int firstDimLength, int secondDimLength) {\n+\t\tVector[][] multiVector = new Vector[firstDimLength][secondDimLength];\n+\t\tfor (int i = 0; i < firstDimLength; i++) {\n+\t\t\tfor (int j = 0; j < secondDimLength; j++) {\n+\t\t\t\tmultiVector[i][j] = new Vector();\n+\t\t\t\tmultiVector[i][j].x = i * j;\n+\t\t\t\tmultiVector[i][j].y = i * i + j * j;\n+\t\t\t}\n+\t\t}\n+\t\treturn multiVector;\n+\t}\n+\n+\tprivate void testMultiVector(Vector[][] inputVector, int dim1Length, int dim2Length) {\n+\t\tAssertJUnit.assertEquals(dim1Length, inputVector.length);\n+\t\tif (inputVector.length > 0)\n+\t\t\tAssertJUnit.assertEquals(dim2Length, inputVector[0].length);\n+\n+\t\tfor (int i = 0; i < inputVector.length; i++) {\n+\t\t\tfor (int j = 0; j < inputVector[0].length; j++) {\n+\t\t\t\tAssertJUnit.assertEquals(i*j, (inputVector[i][j]).x);\n+\t\t\t\tAssertJUnit.assertEquals(i*i + j*j, (inputVector[i][j]).y);\n+\t\t\t}\n+\t\t}\n+\t}\n+\tprivate void testMultiArray(Integer[][] inputArray, int dim1Length, int dim2Length) {\n+\t\tAssertJUnit.assertEquals(dim1Length, inputArray.length);\n+\t\tif (inputArray.length > 0)\n+\t\t\tAssertJUnit.assertEquals(dim2Length, inputArray[0].length);\n+\t\tfor (int i = 0; i < inputArray.length; i++) {\n+\t\t\tfor (int j = 0; j < inputArray[0].length; j++) {\n+\t\t\t\tAssertJUnit.assertEquals(i*j, (inputArray[i][j]).intValue());\n+\t\t\t}\n+\t\t}\n+\t}\n+\t@Test\n+\tpublic void testmultianewarray() {\n+\t\tInteger[][] inputArray;\n+\t\tVector[][] inputVector;\n+\t\tfor (int i = 0; i < 10000; i++) {\n+\t\t\tinputVector = createMultiVector(0, 0);\n+\t\t\ttestMultiVector(inputVector, 0, 0);\n+\t\t\tinputArray = createMultiArray(0, 0);\n+\t\t\ttestMultiArray(inputArray, 0, 0);\n+\t\t}\n+\t\tfor (int i = 0; i < 10000; i++) {\n+\t\t\tinputVector = createMultiVector(i, 0);\n+\t\t\ttestMultiVector(inputVector, i, 0);\n+\t\t\tinputArray = createMultiArray(i, 0);\n+\t\t\ttestMultiArray(inputArray, i, 0);\n+\t\t}\n+\t\tfor (int i = 0; i < 10000; i++) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjk0MTY4NA=="}, "originalCommit": {"oid": "f85779ba406f57f872f3765b1546487d3f16dc4e"}, "originalPosition": 95}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1077, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}