{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE2MzgyNTkx", "number": 11118, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxODozODo1NlrOE3W_ZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0yM1QxNDoyNjoxMFrOF1x2qw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2NDgzODEzOnYy", "diffSide": "RIGHT", "path": "runtime/compiler/env/j9method.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxODozODo1NlrOHwqJhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxODozODo1NlrOHwqJhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc4NDI2Mg==", "bodyText": "class25 should be added to recognizedClasses[] at the right entry, then you don't need to recognize the method here", "url": "https://github.com/eclipse-openj9/openj9/pull/11118#discussion_r520784262", "createdAt": "2020-11-10T18:38:56Z", "author": {"login": "liqunl"}, "path": "runtime/compiler/env/j9method.cpp", "diffHunk": "@@ -4613,6 +4621,13 @@ void TR_ResolvedJ9Method::construct()\n             setRecognizedMethodInfo(TR::java_util_concurrent_ConcurrentHashMap_all);\n          else if ((classNameLen == 16) && !strncmp(className, \"java/util/Vector\", 16))\n             setRecognizedMethodInfo(TR::java_util_Vector_all);\n+         else if ((classNameLen == 25) && !strncmp(className, \"java/lang/invoke/Invokers\", 25))\n+            {\n+            if (!strncmp(name, \"checkCustomized\", 15))\n+               setRecognizedMethodInfo(TR::java_lang_invoke_Invokers_checkCustomized);\n+            else if (!strncmp(name, \"checkExactType\", 14))\n+               setRecognizedMethodInfo(TR::java_lang_invoke_Invokers_checkExactType);\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69c3a733378f560d3d49ccca1133a6ed94c1b23a"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2NTAyNDg4OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/optimizer/J9RecognizedCallTransformer.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxOToxOToyNVrOHwsCEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxOToxOToyNVrOHwsCEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgxNTEyMQ==", "bodyText": "It's better to use getArgument. The child index may not match argument index for some methods", "url": "https://github.com/eclipse-openj9/openj9/pull/11118#discussion_r520815121", "createdAt": "2020-11-10T19:19:25Z", "author": {"login": "liqunl"}, "path": "runtime/compiler/optimizer/J9RecognizedCallTransformer.cpp", "diffHunk": "@@ -116,6 +116,80 @@ void J9::RecognizedCallTransformer::process_java_lang_StrictMath_and_Math_sqrt(T\n \n    TR::TransformUtil::removeTree(comp(), treetop);\n    }\n+\n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+/*\n+Transforms calls to java/lang/invoke/Invokers.checkExactType to the more performant ZEROCHK.\n+\n+Blocks before transformation: ==>\n+\n+start Block_A\n+...\n+treetop\n+        call  java/lang/invoke/Invokers.checkExactType(Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)\n+           ==>aload\n+           ==>aload\n+...\n+end Block_A\n+\n+Blocks after transformation: ==>\n+\n+start Block_A\n+...\n+treetop\n+        ZEROCHK\n+          acmpeq\n+             ==>aload <expected type>\n+             aloadi <MethodHandle.type>\n+               ==>aload <MethodHandle>\n+...\n+end Block_A\n+\n+*/\n+void J9::RecognizedCallTransformer::process_java_lang_invoke_Invokers_checkExactType(TR::TreeTop* treetop, TR::Node* node)\n+   {\n+   TR::Node * methodHandleNode = node->getChild(0);\n+   TR::Node * expectedTypeNode = node->getChild(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69c3a733378f560d3d49ccca1133a6ed94c1b23a"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2NTA5NDcxOnYy", "diffSide": "RIGHT", "path": "runtime/compiler/optimizer/J9RecognizedCallTransformer.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxOTozODowM1rOHwssTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxOTozODowM1rOHwssTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgyNTkzMg==", "bodyText": "Nodes created after ilgen should have originating bytecode node. Use the node create API that takes a node as the first argument to create the node.", "url": "https://github.com/eclipse-openj9/openj9/pull/11118#discussion_r520825932", "createdAt": "2020-11-10T19:38:03Z", "author": {"login": "liqunl"}, "path": "runtime/compiler/optimizer/J9RecognizedCallTransformer.cpp", "diffHunk": "@@ -116,6 +116,80 @@ void J9::RecognizedCallTransformer::process_java_lang_StrictMath_and_Math_sqrt(T\n \n    TR::TransformUtil::removeTree(comp(), treetop);\n    }\n+\n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+/*\n+Transforms calls to java/lang/invoke/Invokers.checkExactType to the more performant ZEROCHK.\n+\n+Blocks before transformation: ==>\n+\n+start Block_A\n+...\n+treetop\n+        call  java/lang/invoke/Invokers.checkExactType(Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)\n+           ==>aload\n+           ==>aload\n+...\n+end Block_A\n+\n+Blocks after transformation: ==>\n+\n+start Block_A\n+...\n+treetop\n+        ZEROCHK\n+          acmpeq\n+             ==>aload <expected type>\n+             aloadi <MethodHandle.type>\n+               ==>aload <MethodHandle>\n+...\n+end Block_A\n+\n+*/\n+void J9::RecognizedCallTransformer::process_java_lang_invoke_Invokers_checkExactType(TR::TreeTop* treetop, TR::Node* node)\n+   {\n+   TR::Node * methodHandleNode = node->getChild(0);\n+   TR::Node * expectedTypeNode = node->getChild(1);\n+   TR_J9VMBase* fej9 = static_cast<TR_J9VMBase*>(comp()->fe());\n+   uint32_t typeOffset = fej9->getInstanceFieldOffsetIncludingHeader(\"Ljava/lang/invoke/MethodHandle;\", \"type\", \"Ljava/lang/invoke/MethodType;\", comp()->getCurrentMethod());\n+   TR::SymbolReference *typeSymRef = comp()->getSymRefTab()->findOrFabricateShadowSymbol(comp()->getMethodSymbol(),\n+                                                                                         TR::Symbol::Java_lang_invoke_MethodHandle_type,\n+                                                                                         TR::Address,\n+                                                                                         typeOffset,\n+                                                                                         false,\n+                                                                                         false,\n+                                                                                         true,\n+                                                                                         \"java/lang/invoke/MethodHandle.type Ljava/lang/invoke/MethodType;\");\n+   TR::Node *handleTypeNode = TR::Node::createWithSymRef(comp()->il.opCodeForIndirectLoad(TR::Address), 1, 1, methodHandleNode, typeSymRef);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69c3a733378f560d3d49ccca1133a6ed94c1b23a"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2NTA5ODE4OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/optimizer/J9RecognizedCallTransformer.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxOTozOTowNFrOHwsuhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxOTozOTowNFrOHwsuhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgyNjUwMQ==", "bodyText": "The zerochk node should have MethodTypeCheck symref on it", "url": "https://github.com/eclipse-openj9/openj9/pull/11118#discussion_r520826501", "createdAt": "2020-11-10T19:39:04Z", "author": {"login": "liqunl"}, "path": "runtime/compiler/optimizer/J9RecognizedCallTransformer.cpp", "diffHunk": "@@ -116,6 +116,80 @@ void J9::RecognizedCallTransformer::process_java_lang_StrictMath_and_Math_sqrt(T\n \n    TR::TransformUtil::removeTree(comp(), treetop);\n    }\n+\n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+/*\n+Transforms calls to java/lang/invoke/Invokers.checkExactType to the more performant ZEROCHK.\n+\n+Blocks before transformation: ==>\n+\n+start Block_A\n+...\n+treetop\n+        call  java/lang/invoke/Invokers.checkExactType(Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)\n+           ==>aload\n+           ==>aload\n+...\n+end Block_A\n+\n+Blocks after transformation: ==>\n+\n+start Block_A\n+...\n+treetop\n+        ZEROCHK\n+          acmpeq\n+             ==>aload <expected type>\n+             aloadi <MethodHandle.type>\n+               ==>aload <MethodHandle>\n+...\n+end Block_A\n+\n+*/\n+void J9::RecognizedCallTransformer::process_java_lang_invoke_Invokers_checkExactType(TR::TreeTop* treetop, TR::Node* node)\n+   {\n+   TR::Node * methodHandleNode = node->getChild(0);\n+   TR::Node * expectedTypeNode = node->getChild(1);\n+   TR_J9VMBase* fej9 = static_cast<TR_J9VMBase*>(comp()->fe());\n+   uint32_t typeOffset = fej9->getInstanceFieldOffsetIncludingHeader(\"Ljava/lang/invoke/MethodHandle;\", \"type\", \"Ljava/lang/invoke/MethodType;\", comp()->getCurrentMethod());\n+   TR::SymbolReference *typeSymRef = comp()->getSymRefTab()->findOrFabricateShadowSymbol(comp()->getMethodSymbol(),\n+                                                                                         TR::Symbol::Java_lang_invoke_MethodHandle_type,\n+                                                                                         TR::Address,\n+                                                                                         typeOffset,\n+                                                                                         false,\n+                                                                                         false,\n+                                                                                         true,\n+                                                                                         \"java/lang/invoke/MethodHandle.type Ljava/lang/invoke/MethodType;\");\n+   TR::Node *handleTypeNode = TR::Node::createWithSymRef(comp()->il.opCodeForIndirectLoad(TR::Address), 1, 1, methodHandleNode, typeSymRef);\n+   TR::Node *cmpEqNode = TR::Node::create(TR::acmpeq, 2, expectedTypeNode, handleTypeNode);\n+   prepareToReplaceNode(node);\n+   TR::Node::recreate(node, TR::ZEROCHK);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69c3a733378f560d3d49ccca1133a6ed94c1b23a"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2NTEwNjk3OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/optimizer/J9RecognizedCallTransformer.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxOTo0MToyOVrOHwsz-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxOTo0MToyOVrOHwsz-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgyNzg5Ng==", "bodyText": "During inlining, the node may not have known object index. The known object info can come from inlined stack. Check if we're during inlining, and check the prex arg from the inline stack\nTR_PrexArgInfo *argInfo = comp->getCurrentInlinedCallArgInfo();\n   TR_PrexArgument *arg = argInfo->get(0);\n   if (arg && arg->getKnownObjectIndex() != TR::KnownObjectTable::UNKNOWN)\n      {", "url": "https://github.com/eclipse-openj9/openj9/pull/11118#discussion_r520827896", "createdAt": "2020-11-10T19:41:29Z", "author": {"login": "liqunl"}, "path": "runtime/compiler/optimizer/J9RecognizedCallTransformer.cpp", "diffHunk": "@@ -386,6 +460,12 @@ bool J9::RecognizedCallTransformer::isInlineable(TR::TreeTop* treetop)\n       case TR::java_lang_StrictMath_sqrt:\n       case TR::java_lang_Math_sqrt:\n          return comp()->target().cpu.getSupportsHardwareSQRT();\n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+      case TR::java_lang_invoke_Invokers_checkExactType:\n+         return true;\n+      case TR::java_lang_invoke_Invokers_checkCustomized:\n+         return node->getChild(0)->getSymbolReference()->hasKnownObjectIndex();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69c3a733378f560d3d49ccca1133a6ed94c1b23a"}, "originalPosition": 89}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzg2MzkwNzEwOnYy", "diffSide": "RIGHT", "path": "runtime/compiler/optimizer/MethodHandleTransformer.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0wOVQyMDo0NzoxOFrOJGmKuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0wOVQyMDo0NzoxOFrOJGmKuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMDg5NjU2OA==", "bodyText": "treetops are traversed in a loop, removing the tree now may cause problem later. You can transform the call node to a passthrough with OMR::TransformUtil::transformCallNodeToPassThrough", "url": "https://github.com/eclipse-openj9/openj9/pull/11118#discussion_r610896568", "createdAt": "2021-04-09T20:47:18Z", "author": {"login": "liqunl"}, "path": "runtime/compiler/optimizer/MethodHandleTransformer.cpp", "diffHunk": "@@ -602,3 +608,87 @@ TR_MethodHandleTransformer::process_java_lang_invoke_MethodHandle_linkTo(TR::Tre\n                                                                                tt);\n       }\n    }\n+\n+/*\n+Transforms calls to java/lang/invoke/Invokers.checkExactType to the more performant ZEROCHK.\n+\n+Blocks before transformation: ==>\n+\n+start Block_A\n+...\n+treetop\n+        call  java/lang/invoke/Invokers.checkExactType(Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)\n+           ==>aload\n+           ==>aload\n+...\n+end Block_A\n+\n+Blocks after transformation: ==>\n+\n+start Block_A\n+...\n+treetop\n+        ZEROCHK\n+          acmpeq\n+             ==>aload <expected type>\n+             aloadi <MethodHandle.type>\n+               ==>aload <MethodHandle>\n+...\n+end Block_A\n+\n+*/\n+void\n+TR_MethodHandleTransformer::process_java_lang_invoke_Invokers_checkExactType(TR::TreeTop* tt, TR::Node* node)\n+   {\n+   if (!performTransformation(comp(), \"%sChanging checkExactType call node n%dn to ZEROCHK\\n\", optDetailString(), node->getGlobalIndex()))\n+      return;\n+   TR::Node * methodHandleNode = node->getArgument(0);\n+   TR::Node * expectedTypeNode = node->getArgument(1);\n+   TR_J9VMBase* fej9 = static_cast<TR_J9VMBase*>(comp()->fe());\n+   uint32_t typeOffset = fej9->getInstanceFieldOffsetIncludingHeader(\"Ljava/lang/invoke/MethodHandle;\", \"type\", \"Ljava/lang/invoke/MethodType;\", comp()->getCurrentMethod());\n+   TR::SymbolReference *typeSymRef = comp()->getSymRefTab()->findOrFabricateShadowSymbol(comp()->getMethodSymbol(),\n+                                                                                         TR::Symbol::Java_lang_invoke_MethodHandle_type,\n+                                                                                         TR::Address,\n+                                                                                         typeOffset,\n+                                                                                         false,\n+                                                                                         false,\n+                                                                                         true,\n+                                                                                         \"java/lang/invoke/MethodHandle.type Ljava/lang/invoke/MethodType;\");\n+   TR::Node *handleTypeNode = TR::Node::createWithSymRef(node, comp()->il.opCodeForIndirectLoad(TR::Address), 1, methodHandleNode, typeSymRef);\n+   TR::Node *cmpEqNode = TR::Node::create(node, TR::acmpeq, 2, expectedTypeNode, handleTypeNode);\n+   prepareToReplaceNode(node);\n+   TR::Node::recreate(node, TR::ZEROCHK);\n+   node->setSymbolReference(comp()->getSymRefTab()->findOrCreateMethodTypeCheckSymbolRef(comp()->getMethodSymbol()));\n+   node->setNumChildren(1);\n+   node->setAndIncChild(0, cmpEqNode);\n+   }\n+\n+/*\n+java/lang/invoke/Invokers.checkCustomized is redundant if its argument is a known object. This transformation\n+eliminates calls to java/lang/invoke/Invokers.checkCustomized.\n+\n+Blocks before transformation: ==>\n+\n+start Block_A\n+...\n+treetop\n+        call  java/lang/invoke/Invokers.checkCustomized(Ljava/lang/invoke/MethodHandle;)V\n+          aload  <MethodHandle>\n+...\n+end Block_A\n+\n+Blocks after transformation: ==> treetop eliminated\n+\n+*/\n+void\n+TR_MethodHandleTransformer::process_java_lang_invoke_Invokers_checkCustomized(TR::TreeTop* tt, TR::Node* node)\n+   {\n+   TR::KnownObjectTable::Index objIndex = getObjectInfoOfNode(node->getFirstArgument());\n+   auto knot = comp()->getKnownObjectTable();\n+   if (isKnownObject(objIndex) && knot && !knot->isNull(objIndex))\n+      {\n+      if (!performTransformation(comp(), \"%sRemoving checkCustomized call node n%dn as it is now redundant as MethodHandle has known object index\\n\", optDetailString(), node->getGlobalIndex()))\n+         return;\n+      TR::TransformUtil::removeTree(comp(), tt);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2548f20ee3e647c0b387f626de61c06ee6ea842"}, "originalPosition": 98}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzg2NDA1NTE0OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/optimizer/MethodHandleTransformer.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0wOVQyMTo0Mjo0MFrOJGniAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0wOVQyMTo0Mjo0MFrOJGniAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMDkxODkxMw==", "bodyText": "If the two arguments are known object, we can do the check at compile time and remove the call if the types match", "url": "https://github.com/eclipse-openj9/openj9/pull/11118#discussion_r610918913", "createdAt": "2021-04-09T21:42:40Z", "author": {"login": "liqunl"}, "path": "runtime/compiler/optimizer/MethodHandleTransformer.cpp", "diffHunk": "@@ -602,3 +608,87 @@ TR_MethodHandleTransformer::process_java_lang_invoke_MethodHandle_linkTo(TR::Tre\n                                                                                tt);\n       }\n    }\n+\n+/*\n+Transforms calls to java/lang/invoke/Invokers.checkExactType to the more performant ZEROCHK.\n+\n+Blocks before transformation: ==>\n+\n+start Block_A\n+...\n+treetop\n+        call  java/lang/invoke/Invokers.checkExactType(Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)\n+           ==>aload\n+           ==>aload\n+...\n+end Block_A\n+\n+Blocks after transformation: ==>\n+\n+start Block_A\n+...\n+treetop\n+        ZEROCHK\n+          acmpeq\n+             ==>aload <expected type>\n+             aloadi <MethodHandle.type>\n+               ==>aload <MethodHandle>\n+...\n+end Block_A\n+\n+*/\n+void\n+TR_MethodHandleTransformer::process_java_lang_invoke_Invokers_checkExactType(TR::TreeTop* tt, TR::Node* node)\n+   {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2548f20ee3e647c0b387f626de61c06ee6ea842"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzkxOTM1NjU5OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/optimizer/MethodHandleTransformer.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0yM1QxNDoyNjoxMFrOJOk1lQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0yM1QxNDoyNjoxMFrOJOk1lQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxOTI2MzM4MQ==", "bodyText": "type is a private field", "url": "https://github.com/eclipse-openj9/openj9/pull/11118#discussion_r619263381", "createdAt": "2021-04-23T14:26:10Z", "author": {"login": "liqunl"}, "path": "runtime/compiler/optimizer/MethodHandleTransformer.cpp", "diffHunk": "@@ -602,3 +609,123 @@ TR_MethodHandleTransformer::process_java_lang_invoke_MethodHandle_linkTo(TR::Tre\n                                                                                tt);\n       }\n    }\n+\n+/*\n+Transforms calls to java/lang/invoke/Invokers.checkExactType to the more performant ZEROCHK.\n+\n+Blocks before transformation: ==>\n+\n+start Block_A\n+...\n+treetop\n+        call  java/lang/invoke/Invokers.checkExactType(Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)\n+           ==>aload\n+           ==>aload\n+...\n+end Block_A\n+\n+Blocks after transformation: ==>\n+\n+If MethodHandle and expected type are known objects at compile time and match: ==>\n+\n+start Block_A\n+...\n+treetop\n+        PassThrough\n+          aload <MethodHandle>\n+...\n+end Block_A\n+\n+else: ==>\n+\n+start Block_A\n+...\n+treetop\n+        ZEROCHK\n+          acmpeq\n+             ==>aload <expected type>\n+             aloadi <MethodHandle.type>\n+               ==>aload <MethodHandle>\n+...\n+end Block_A\n+\n+*/\n+void\n+TR_MethodHandleTransformer::process_java_lang_invoke_Invokers_checkExactType(TR::TreeTop* tt, TR::Node* node)\n+   {\n+   auto methodHandleNode = node->getArgument(0);\n+   auto expectedTypeNode = node->getArgument(1);\n+   TR_J9VMBase* fej9 = static_cast<TR_J9VMBase*>(comp()->fe());\n+\n+   TR::KnownObjectTable::Index mhIndex = getObjectInfoOfNode(methodHandleNode);\n+   TR::KnownObjectTable::Index expectedTypeIndex = getObjectInfoOfNode(expectedTypeNode);\n+   auto knot = comp()->getKnownObjectTable();\n+   if (knot && isKnownObject(mhIndex) && isKnownObject(expectedTypeIndex))\n+      {\n+      TR::VMAccessCriticalSection vmAccess(fej9);\n+      uintptr_t mhObject = knot->getPointer(mhIndex);\n+      uintptr_t mtObject = fej9->getReferenceField(mhObject, \"type\", \"Ljava/lang/invoke/MethodType;\");\n+      uintptr_t etObject = knot->getPointer(expectedTypeIndex);\n+\n+      if (etObject == mtObject && performTransformation(comp(), \"%sChanging checkExactType call node n%dn to PassThrough\\n\", optDetailString(), node->getGlobalIndex()))\n+         {\n+         TR::TransformUtil::transformCallNodeToPassThrough(this, node, tt, node->getFirstArgument());\n+         return;\n+         }\n+      }\n+   if (!performTransformation(comp(), \"%sChanging checkExactType call node n%dn to ZEROCHK\\n\", optDetailString(), node->getGlobalIndex()))\n+      return;\n+   uint32_t typeOffset = fej9->getInstanceFieldOffsetIncludingHeader(\"Ljava/lang/invoke/MethodHandle;\", \"type\", \"Ljava/lang/invoke/MethodType;\", comp()->getCurrentMethod());\n+   auto typeSymRef = comp()->getSymRefTab()->findOrFabricateShadowSymbol(comp()->getMethodSymbol(),\n+                                                                                         TR::Symbol::Java_lang_invoke_MethodHandle_type,\n+                                                                                         TR::Address,\n+                                                                                         typeOffset,\n+                                                                                         false,\n+                                                                                         false,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7aff3ec564219cbd32c36f19ad7e6230531500be"}, "originalPosition": 97}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1094, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}