{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgyNDUxODIw", "number": 8712, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxNTowMTo0MVrODsGoEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxNTowMjo1NlrODsGqiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3NTcyNDk3OnYy", "diffSide": "RIGHT", "path": "runtime/gc_vlhgc/VLHGCAccessBarrier.cpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxNTowMTo0MVrOF81GvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxNTowMTo0MVrOF81GvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTMyODk1Nw==", "bodyText": "pull in the declaration:\nfor (jni i = 0", "url": "https://github.com/eclipse-openj9/openj9/pull/8712#discussion_r399328957", "createdAt": "2020-03-27T15:01:41Z", "author": {"login": "amicic"}, "path": "runtime/gc_vlhgc/VLHGCAccessBarrier.cpp", "diffHunk": "@@ -435,61 +435,96 @@ MM_VLHGCAccessBarrier::jniReleasePrimitiveArrayCritical(J9VMThread* vmThread, ja\n \tVM_VMAccess::inlineExitVMToJNI(vmThread);\n }\n \n+void\n+MM_VLHGCAccessBarrier::copyStringCritical(J9VMThread *vmThread, GC_ArrayObjectModel *indexableObjectModel,\n+\tJ9InternalVMFunctions *functions, jchar **data, J9JavaVM *javaVM,\n+\tJ9IndexableObject *valueObject, J9Object *stringObject, jboolean *isCopy, bool isCompressed)\n+{\n+\tjint length = J9VMJAVALANGSTRING_LENGTH(vmThread, stringObject);\n+\tUDATA sizeInBytes = length * sizeof(jchar);\n+\t*data = (jchar*)functions->jniArrayAllocateMemoryFromThread(vmThread, sizeInBytes);\n+\tif (NULL == *data) {\n+\t\tfunctions->setNativeOutOfMemoryError(vmThread, 0, 0);\t// better error message here?\n+\t} else {\n+\t\tif (isCompressed) {\n+\t\t\tjint i;\n+\t\t\tfor (i = 0; i < length; i++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad8ad4d0a2d4fed1a4ca4f6f4d385efc2ec3bd5a"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3NTczMTMxOnYy", "diffSide": "RIGHT", "path": "runtime/gc_vlhgc/VLHGCAccessBarrier.cpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxNTowMjo1NlrOF81KjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxNTowMjo1NlrOF81KjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTMyOTkzMw==", "bodyText": "now that shouldCopy  is gone, you can make this one liner:\nbool isCompressed = IS_STRING_COMPRESSED(vmThread, stringObject);", "url": "https://github.com/eclipse-openj9/openj9/pull/8712#discussion_r399329933", "createdAt": "2020-03-27T15:02:56Z", "author": {"login": "amicic"}, "path": "runtime/gc_vlhgc/VLHGCAccessBarrier.cpp", "diffHunk": "@@ -435,61 +435,96 @@ MM_VLHGCAccessBarrier::jniReleasePrimitiveArrayCritical(J9VMThread* vmThread, ja\n \tVM_VMAccess::inlineExitVMToJNI(vmThread);\n }\n \n+void\n+MM_VLHGCAccessBarrier::copyStringCritical(J9VMThread *vmThread, GC_ArrayObjectModel *indexableObjectModel,\n+\tJ9InternalVMFunctions *functions, jchar **data, J9JavaVM *javaVM,\n+\tJ9IndexableObject *valueObject, J9Object *stringObject, jboolean *isCopy, bool isCompressed)\n+{\n+\tjint length = J9VMJAVALANGSTRING_LENGTH(vmThread, stringObject);\n+\tUDATA sizeInBytes = length * sizeof(jchar);\n+\t*data = (jchar*)functions->jniArrayAllocateMemoryFromThread(vmThread, sizeInBytes);\n+\tif (NULL == *data) {\n+\t\tfunctions->setNativeOutOfMemoryError(vmThread, 0, 0);\t// better error message here?\n+\t} else {\n+\t\tif (isCompressed) {\n+\t\t\tjint i;\n+\t\t\tfor (i = 0; i < length; i++) {\n+\t\t\t\t*data[i] = (jchar)J9JAVAARRAYOFBYTE_LOAD(vmThread, (j9object_t)valueObject, i) & (jchar)0xFF;\n+\t\t\t}\n+\t\t} else {\n+\t\t\tif (J9_ARE_ANY_BITS_SET(javaVM->runtimeFlags, J9_RUNTIME_STRING_BYTE_ARRAY)) {\n+\t\t\t\t// This API determines the stride based on the type of valueObject so in the [B case we must passin the length in bytes\n+\t\t\t\tindexableObjectModel->memcpyFromArray(*data, valueObject, 0, (I_32)sizeInBytes);\n+\t\t\t} else {\n+\t\t\t\tindexableObjectModel->memcpyFromArray(*data, valueObject, 0, length);\n+\t\t\t}\n+\t\t}\n+\t\tif (NULL != isCopy) {\n+\t\t\t*isCopy = JNI_TRUE;\n+\t\t}\n+\t\tvmThread->jniCriticalCopyCount += 1;\n+\t}\n+}\n+\n const jchar*\n MM_VLHGCAccessBarrier::jniGetStringCritical(J9VMThread* vmThread, jstring str, jboolean *isCopy)\n {\n \tjchar *data = NULL;\n \tJ9JavaVM *javaVM = vmThread->javaVM;\n \tJ9InternalVMFunctions *functions = javaVM->internalVMFunctions;\n \tVM_VMAccess::inlineEnterVMFromJNI(vmThread);\n+\tGC_ArrayObjectModel *indexableObjectModel = &_extensions->indexableObjectModel;\n \n \tJ9Object *stringObject = (J9Object*)J9_JNI_UNWRAP_REFERENCE(str);\n \tJ9IndexableObject *valueObject = (J9IndexableObject*)J9VMJAVALANGSTRING_VALUE(vmThread, stringObject);\n-\tbool shouldCopy = false;\n \tbool isCompressed = false;\n \n \t/* If the string bytes are in compressed UNICODE, then we need to copy to decompress */\t\n \tif (IS_STRING_COMPRESSED(vmThread, stringObject)) {\n \t\tisCompressed = true;\n-\t\tshouldCopy = true;\n \t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad8ad4d0a2d4fed1a4ca4f6f4d385efc2ec3bd5a"}, "originalPosition": 53}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 637, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}