{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQwOTk1NDUz", "number": 10034, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxNDoyMTo1NVrOEJrrYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQyMDowNzoxOFrOEMoyVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4NTg4MjU2OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxNDoyMTo1NVrOGqTSzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNjoxMjo0MlrOGrD63A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAwOTQ4Nw==", "bodyText": "is it only awrtbari or does it also handle astorei?", "url": "https://github.com/eclipse-openj9/openj9/pull/10034#discussion_r447009487", "createdAt": "2020-06-29T14:21:55Z", "author": {"login": "andrewcraik"}, "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -1493,6 +1500,201 @@ J9::CodeGenerator::lowerTreeIfNeeded(\n    }\n \n \n+/*\n+ * If value types are enabled, and the value that is being assigned to the array\n+ * element might be a null reference, lower the ArrayStoreCHK by splitting the\n+ * block before the ArrayStoreCHK, and inserting a NULLCHK guarded by a check\n+ * of whether the array's component type is a value type.\n+ */\n+void\n+J9::CodeGenerator::lowerArrayStoreCHK(TR::Node *node, TR::TreeTop *tt)\n+   {\n+   TR::Node *destChild;\n+   TR::Node *sourceChild;\n+\n+   // Pattern match the ArrayStoreCHK operands to get the source of the assignment\n+   // (sourceChild) and the array to which an element will have a value assigned (destChild)\n+   findArrayStoreCHKOperands(node, destChild, sourceChild);\n+\n+   // Only need to lower if it is possible that the value is a null reference\n+   if (!sourceChild->isNonNull())\n+      {\n+      TR::CFG * cfg = self()->comp()->getFlowGraph();\n+      cfg->invalidateStructure();\n+\n+      TR::Block *prevBlock = tt->getEnclosingBlock();\n+\n+      performTransformation(self()->comp(), \"%sTransforming ArrayStoreCHK n%dn [%p] by splitting block block_%d, and inserting a NULLCHK guarded with a check of whether the component type of the array is a value type\\n\", OPT_DETAILS, node->getGlobalIndex(), node, prevBlock->getNumber());\n+\n+      // Anchor the node that contains the destination array and the node\n+      // containing the source of the array element assignment to ensure\n+      // they are available in the ificmpeq and NULLCHK\n+      TR::TreeTop *anchoredArrayTT = TR::TreeTop::create(self()->comp(), tt->getPrevTreeTop(), TR::Node::create(TR::treetop, 1, destChild));\n+      TR::TreeTop *anchoredSourceTT = TR::TreeTop::create(self()->comp(), anchoredArrayTT, TR::Node::create(TR::treetop, 1, sourceChild));\n+\n+      // Transform\n+      //   +--------------------------------+\n+      //   | ttprev                         |\n+      //   | ArrayStoreCHK                  |\n+      //   |   awrtbari                     |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "296416a8399ba933c0bd630fb76e348a6a891549"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAyMzkzMw==", "bodyText": "Yes, it handles astorei as well.  I'll fix up the comments.", "url": "https://github.com/eclipse-openj9/openj9/pull/10034#discussion_r447023933", "createdAt": "2020-06-29T14:41:05Z", "author": {"login": "hzongaro"}, "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -1493,6 +1500,201 @@ J9::CodeGenerator::lowerTreeIfNeeded(\n    }\n \n \n+/*\n+ * If value types are enabled, and the value that is being assigned to the array\n+ * element might be a null reference, lower the ArrayStoreCHK by splitting the\n+ * block before the ArrayStoreCHK, and inserting a NULLCHK guarded by a check\n+ * of whether the array's component type is a value type.\n+ */\n+void\n+J9::CodeGenerator::lowerArrayStoreCHK(TR::Node *node, TR::TreeTop *tt)\n+   {\n+   TR::Node *destChild;\n+   TR::Node *sourceChild;\n+\n+   // Pattern match the ArrayStoreCHK operands to get the source of the assignment\n+   // (sourceChild) and the array to which an element will have a value assigned (destChild)\n+   findArrayStoreCHKOperands(node, destChild, sourceChild);\n+\n+   // Only need to lower if it is possible that the value is a null reference\n+   if (!sourceChild->isNonNull())\n+      {\n+      TR::CFG * cfg = self()->comp()->getFlowGraph();\n+      cfg->invalidateStructure();\n+\n+      TR::Block *prevBlock = tt->getEnclosingBlock();\n+\n+      performTransformation(self()->comp(), \"%sTransforming ArrayStoreCHK n%dn [%p] by splitting block block_%d, and inserting a NULLCHK guarded with a check of whether the component type of the array is a value type\\n\", OPT_DETAILS, node->getGlobalIndex(), node, prevBlock->getNumber());\n+\n+      // Anchor the node that contains the destination array and the node\n+      // containing the source of the array element assignment to ensure\n+      // they are available in the ificmpeq and NULLCHK\n+      TR::TreeTop *anchoredArrayTT = TR::TreeTop::create(self()->comp(), tt->getPrevTreeTop(), TR::Node::create(TR::treetop, 1, destChild));\n+      TR::TreeTop *anchoredSourceTT = TR::TreeTop::create(self()->comp(), anchoredArrayTT, TR::Node::create(TR::treetop, 1, sourceChild));\n+\n+      // Transform\n+      //   +--------------------------------+\n+      //   | ttprev                         |\n+      //   | ArrayStoreCHK                  |\n+      //   |   awrtbari                     |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAwOTQ4Nw=="}, "originalCommit": {"oid": "296416a8399ba933c0bd630fb76e348a6a891549"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgwNjE3Mg==", "bodyText": "Adjusted comments in commit 58ab83b", "url": "https://github.com/eclipse-openj9/openj9/pull/10034#discussion_r447806172", "createdAt": "2020-06-30T16:12:42Z", "author": {"login": "hzongaro"}, "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -1493,6 +1500,201 @@ J9::CodeGenerator::lowerTreeIfNeeded(\n    }\n \n \n+/*\n+ * If value types are enabled, and the value that is being assigned to the array\n+ * element might be a null reference, lower the ArrayStoreCHK by splitting the\n+ * block before the ArrayStoreCHK, and inserting a NULLCHK guarded by a check\n+ * of whether the array's component type is a value type.\n+ */\n+void\n+J9::CodeGenerator::lowerArrayStoreCHK(TR::Node *node, TR::TreeTop *tt)\n+   {\n+   TR::Node *destChild;\n+   TR::Node *sourceChild;\n+\n+   // Pattern match the ArrayStoreCHK operands to get the source of the assignment\n+   // (sourceChild) and the array to which an element will have a value assigned (destChild)\n+   findArrayStoreCHKOperands(node, destChild, sourceChild);\n+\n+   // Only need to lower if it is possible that the value is a null reference\n+   if (!sourceChild->isNonNull())\n+      {\n+      TR::CFG * cfg = self()->comp()->getFlowGraph();\n+      cfg->invalidateStructure();\n+\n+      TR::Block *prevBlock = tt->getEnclosingBlock();\n+\n+      performTransformation(self()->comp(), \"%sTransforming ArrayStoreCHK n%dn [%p] by splitting block block_%d, and inserting a NULLCHK guarded with a check of whether the component type of the array is a value type\\n\", OPT_DETAILS, node->getGlobalIndex(), node, prevBlock->getNumber());\n+\n+      // Anchor the node that contains the destination array and the node\n+      // containing the source of the array element assignment to ensure\n+      // they are available in the ificmpeq and NULLCHK\n+      TR::TreeTop *anchoredArrayTT = TR::TreeTop::create(self()->comp(), tt->getPrevTreeTop(), TR::Node::create(TR::treetop, 1, destChild));\n+      TR::TreeTop *anchoredSourceTT = TR::TreeTop::create(self()->comp(), anchoredArrayTT, TR::Node::create(TR::treetop, 1, sourceChild));\n+\n+      // Transform\n+      //   +--------------------------------+\n+      //   | ttprev                         |\n+      //   | ArrayStoreCHK                  |\n+      //   |   awrtbari                     |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAwOTQ4Nw=="}, "originalCommit": {"oid": "296416a8399ba933c0bd630fb76e348a6a891549"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4NTg4NTkzOnYy", "diffSide": "RIGHT", "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxNDoyMjozOVrOGqTU5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNjoxMjoyOFrOGrD6UA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAxMDAyMg==", "bodyText": "The array reference needs to be evaluated before the value reference since the array-reference is deeper.", "url": "https://github.com/eclipse-openj9/openj9/pull/10034#discussion_r447010022", "createdAt": "2020-06-29T14:22:39Z", "author": {"login": "andrewcraik"}, "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -1493,6 +1500,201 @@ J9::CodeGenerator::lowerTreeIfNeeded(\n    }\n \n \n+/*\n+ * If value types are enabled, and the value that is being assigned to the array\n+ * element might be a null reference, lower the ArrayStoreCHK by splitting the\n+ * block before the ArrayStoreCHK, and inserting a NULLCHK guarded by a check\n+ * of whether the array's component type is a value type.\n+ */\n+void\n+J9::CodeGenerator::lowerArrayStoreCHK(TR::Node *node, TR::TreeTop *tt)\n+   {\n+   TR::Node *destChild;\n+   TR::Node *sourceChild;\n+\n+   // Pattern match the ArrayStoreCHK operands to get the source of the assignment\n+   // (sourceChild) and the array to which an element will have a value assigned (destChild)\n+   findArrayStoreCHKOperands(node, destChild, sourceChild);\n+\n+   // Only need to lower if it is possible that the value is a null reference\n+   if (!sourceChild->isNonNull())\n+      {\n+      TR::CFG * cfg = self()->comp()->getFlowGraph();\n+      cfg->invalidateStructure();\n+\n+      TR::Block *prevBlock = tt->getEnclosingBlock();\n+\n+      performTransformation(self()->comp(), \"%sTransforming ArrayStoreCHK n%dn [%p] by splitting block block_%d, and inserting a NULLCHK guarded with a check of whether the component type of the array is a value type\\n\", OPT_DETAILS, node->getGlobalIndex(), node, prevBlock->getNumber());\n+\n+      // Anchor the node that contains the destination array and the node\n+      // containing the source of the array element assignment to ensure\n+      // they are available in the ificmpeq and NULLCHK\n+      TR::TreeTop *anchoredArrayTT = TR::TreeTop::create(self()->comp(), tt->getPrevTreeTop(), TR::Node::create(TR::treetop, 1, destChild));\n+      TR::TreeTop *anchoredSourceTT = TR::TreeTop::create(self()->comp(), anchoredArrayTT, TR::Node::create(TR::treetop, 1, sourceChild));\n+\n+      // Transform\n+      //   +--------------------------------+\n+      //   | ttprev                         |\n+      //   | ArrayStoreCHK                  |\n+      //   |   awrtbari                     |\n+      //   |     aladd                      |\n+      //   |       <array-reference>        |\n+      //   |       index-offset-calculation |\n+      //   |     <value-reference>          |\n+      //   +--------------------------------+\n+      //\n+      // into\n+      //   +--------------------------------+\n+      //   | treetop                        |\n+      //   |   <value-reference>            |\n+      //   | treetop                        |\n+      //   |   <array-reference>            |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "296416a8399ba933c0bd630fb76e348a6a891549"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAyNDEwNQ==", "bodyText": "Thanks for catching that!", "url": "https://github.com/eclipse-openj9/openj9/pull/10034#discussion_r447024105", "createdAt": "2020-06-29T14:41:20Z", "author": {"login": "hzongaro"}, "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -1493,6 +1500,201 @@ J9::CodeGenerator::lowerTreeIfNeeded(\n    }\n \n \n+/*\n+ * If value types are enabled, and the value that is being assigned to the array\n+ * element might be a null reference, lower the ArrayStoreCHK by splitting the\n+ * block before the ArrayStoreCHK, and inserting a NULLCHK guarded by a check\n+ * of whether the array's component type is a value type.\n+ */\n+void\n+J9::CodeGenerator::lowerArrayStoreCHK(TR::Node *node, TR::TreeTop *tt)\n+   {\n+   TR::Node *destChild;\n+   TR::Node *sourceChild;\n+\n+   // Pattern match the ArrayStoreCHK operands to get the source of the assignment\n+   // (sourceChild) and the array to which an element will have a value assigned (destChild)\n+   findArrayStoreCHKOperands(node, destChild, sourceChild);\n+\n+   // Only need to lower if it is possible that the value is a null reference\n+   if (!sourceChild->isNonNull())\n+      {\n+      TR::CFG * cfg = self()->comp()->getFlowGraph();\n+      cfg->invalidateStructure();\n+\n+      TR::Block *prevBlock = tt->getEnclosingBlock();\n+\n+      performTransformation(self()->comp(), \"%sTransforming ArrayStoreCHK n%dn [%p] by splitting block block_%d, and inserting a NULLCHK guarded with a check of whether the component type of the array is a value type\\n\", OPT_DETAILS, node->getGlobalIndex(), node, prevBlock->getNumber());\n+\n+      // Anchor the node that contains the destination array and the node\n+      // containing the source of the array element assignment to ensure\n+      // they are available in the ificmpeq and NULLCHK\n+      TR::TreeTop *anchoredArrayTT = TR::TreeTop::create(self()->comp(), tt->getPrevTreeTop(), TR::Node::create(TR::treetop, 1, destChild));\n+      TR::TreeTop *anchoredSourceTT = TR::TreeTop::create(self()->comp(), anchoredArrayTT, TR::Node::create(TR::treetop, 1, sourceChild));\n+\n+      // Transform\n+      //   +--------------------------------+\n+      //   | ttprev                         |\n+      //   | ArrayStoreCHK                  |\n+      //   |   awrtbari                     |\n+      //   |     aladd                      |\n+      //   |       <array-reference>        |\n+      //   |       index-offset-calculation |\n+      //   |     <value-reference>          |\n+      //   +--------------------------------+\n+      //\n+      // into\n+      //   +--------------------------------+\n+      //   | treetop                        |\n+      //   |   <value-reference>            |\n+      //   | treetop                        |\n+      //   |   <array-reference>            |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAxMDAyMg=="}, "originalCommit": {"oid": "296416a8399ba933c0bd630fb76e348a6a891549"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgwNjAzMg==", "bodyText": "Thanks, Andrew.  My comment didn't match the code - fixed in commit 58ab83b", "url": "https://github.com/eclipse-openj9/openj9/pull/10034#discussion_r447806032", "createdAt": "2020-06-30T16:12:28Z", "author": {"login": "hzongaro"}, "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -1493,6 +1500,201 @@ J9::CodeGenerator::lowerTreeIfNeeded(\n    }\n \n \n+/*\n+ * If value types are enabled, and the value that is being assigned to the array\n+ * element might be a null reference, lower the ArrayStoreCHK by splitting the\n+ * block before the ArrayStoreCHK, and inserting a NULLCHK guarded by a check\n+ * of whether the array's component type is a value type.\n+ */\n+void\n+J9::CodeGenerator::lowerArrayStoreCHK(TR::Node *node, TR::TreeTop *tt)\n+   {\n+   TR::Node *destChild;\n+   TR::Node *sourceChild;\n+\n+   // Pattern match the ArrayStoreCHK operands to get the source of the assignment\n+   // (sourceChild) and the array to which an element will have a value assigned (destChild)\n+   findArrayStoreCHKOperands(node, destChild, sourceChild);\n+\n+   // Only need to lower if it is possible that the value is a null reference\n+   if (!sourceChild->isNonNull())\n+      {\n+      TR::CFG * cfg = self()->comp()->getFlowGraph();\n+      cfg->invalidateStructure();\n+\n+      TR::Block *prevBlock = tt->getEnclosingBlock();\n+\n+      performTransformation(self()->comp(), \"%sTransforming ArrayStoreCHK n%dn [%p] by splitting block block_%d, and inserting a NULLCHK guarded with a check of whether the component type of the array is a value type\\n\", OPT_DETAILS, node->getGlobalIndex(), node, prevBlock->getNumber());\n+\n+      // Anchor the node that contains the destination array and the node\n+      // containing the source of the array element assignment to ensure\n+      // they are available in the ificmpeq and NULLCHK\n+      TR::TreeTop *anchoredArrayTT = TR::TreeTop::create(self()->comp(), tt->getPrevTreeTop(), TR::Node::create(TR::treetop, 1, destChild));\n+      TR::TreeTop *anchoredSourceTT = TR::TreeTop::create(self()->comp(), anchoredArrayTT, TR::Node::create(TR::treetop, 1, sourceChild));\n+\n+      // Transform\n+      //   +--------------------------------+\n+      //   | ttprev                         |\n+      //   | ArrayStoreCHK                  |\n+      //   |   awrtbari                     |\n+      //   |     aladd                      |\n+      //   |       <array-reference>        |\n+      //   |       index-offset-calculation |\n+      //   |     <value-reference>          |\n+      //   +--------------------------------+\n+      //\n+      // into\n+      //   +--------------------------------+\n+      //   | treetop                        |\n+      //   |   <value-reference>            |\n+      //   | treetop                        |\n+      //   |   <array-reference>            |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAxMDAyMg=="}, "originalCommit": {"oid": "296416a8399ba933c0bd630fb76e348a6a891549"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4NjE5NTM2OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxNToyODoxNFrOGqWR0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNjoxMzo1MVrOGrD-BA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA1ODM4NQ==", "bodyText": "@hzongaro  Looking at the control flow described in the comment, I think you are using wrong API here. Block that contains ArrayStoreCHK tree is the merge block, so when creating arrayStoreCheckBlock I would use splitPostGRA. This way we have done uncommoning of the nodes that are live in the merge block. While for creating block containing NULLCHK which seems like the extension of previous block, I would use regular split API with doCommoning boolean set to false.\nFor reference on copying GlRegDeps you can take a look at  https://github.com/eclipse/openj9/blob/a7bf6c09925da0a4e352114e63b3c2cb3f59b355/runtime/compiler/optimizer/JProfilingValue.cpp#L764-L781.", "url": "https://github.com/eclipse-openj9/openj9/pull/10034#discussion_r447058385", "createdAt": "2020-06-29T15:28:14Z", "author": {"login": "r30shah"}, "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -1493,6 +1500,201 @@ J9::CodeGenerator::lowerTreeIfNeeded(\n    }\n \n \n+/*\n+ * If value types are enabled, and the value that is being assigned to the array\n+ * element might be a null reference, lower the ArrayStoreCHK by splitting the\n+ * block before the ArrayStoreCHK, and inserting a NULLCHK guarded by a check\n+ * of whether the array's component type is a value type.\n+ */\n+void\n+J9::CodeGenerator::lowerArrayStoreCHK(TR::Node *node, TR::TreeTop *tt)\n+   {\n+   TR::Node *destChild;\n+   TR::Node *sourceChild;\n+\n+   // Pattern match the ArrayStoreCHK operands to get the source of the assignment\n+   // (sourceChild) and the array to which an element will have a value assigned (destChild)\n+   findArrayStoreCHKOperands(node, destChild, sourceChild);\n+\n+   // Only need to lower if it is possible that the value is a null reference\n+   if (!sourceChild->isNonNull())\n+      {\n+      TR::CFG * cfg = self()->comp()->getFlowGraph();\n+      cfg->invalidateStructure();\n+\n+      TR::Block *prevBlock = tt->getEnclosingBlock();\n+\n+      performTransformation(self()->comp(), \"%sTransforming ArrayStoreCHK n%dn [%p] by splitting block block_%d, and inserting a NULLCHK guarded with a check of whether the component type of the array is a value type\\n\", OPT_DETAILS, node->getGlobalIndex(), node, prevBlock->getNumber());\n+\n+      // Anchor the node that contains the destination array and the node\n+      // containing the source of the array element assignment to ensure\n+      // they are available in the ificmpeq and NULLCHK\n+      TR::TreeTop *anchoredArrayTT = TR::TreeTop::create(self()->comp(), tt->getPrevTreeTop(), TR::Node::create(TR::treetop, 1, destChild));\n+      TR::TreeTop *anchoredSourceTT = TR::TreeTop::create(self()->comp(), anchoredArrayTT, TR::Node::create(TR::treetop, 1, sourceChild));\n+\n+      // Transform\n+      //   +--------------------------------+\n+      //   | ttprev                         |\n+      //   | ArrayStoreCHK                  |\n+      //   |   awrtbari                     |\n+      //   |     aladd                      |\n+      //   |       <array-reference>        |\n+      //   |       index-offset-calculation |\n+      //   |     <value-reference>          |\n+      //   +--------------------------------+\n+      //\n+      // into\n+      //   +--------------------------------+\n+      //   | treetop                        |\n+      //   |   <value-reference>            |\n+      //   | treetop                        |\n+      //   |   <array-reference>            |\n+      //   | ificmpeq  -->------------------*---------+\n+      //   |   iand                         |         |\n+      //   |     iloadi <isClassFlags>      |         |\n+      //   |       aloadi <componentClass>  |         |\n+      //   |         aloadi <vft-symbol>    |         |\n+      //   |           <array-reference>    |         |\n+      //   |     iconst J9ClassIsValueType  |         |\n+      //   |   iconst 0                     |         |\n+      //   | BBEnd                          |         |\n+      //   +--------------------------------+         |\n+      //   | BBStart (Extension)            |         |\n+      //   | NULLCHK                        |         |\n+      //   |   Passthrough                  |         |\n+      //   |     <value-reference>          |         |\n+      //   | BBEnd                          |         |\n+      //   +--------------------------------+         |\n+      //                   |                          |\n+      //                   +--------------------------+\n+      //                   |\n+      //                   v\n+      //   +--------------------------------+\n+      //   | BBStart                        |\n+      //   | ArrayStoreCHK                  |\n+      //   |   awrtbari                     |\n+      //   |     aladd                      |\n+      //   |       aload <array>            |\n+      //   |       index-offset-calculation |\n+      //   |     aload <value>              |\n+      //   +--------------------------------+\n+      //\n+      TR::SymbolReference *vftSymRef = self()->comp()->getSymRefTab()->findOrCreateVftSymbolRef();\n+      TR::SymbolReference *arrayCompSymRef = self()->comp()->getSymRefTab()->findOrCreateArrayComponentTypeSymbolRef();\n+      TR::SymbolReference *classFlagsSymRef = self()->comp()->getSymRefTab()->findOrCreateClassFlagsSymbolRef();\n+\n+      TR::Node *vft = TR::Node::createWithSymRef(node, TR::aloadi, 1, anchoredArrayTT->getNode()->getFirstChild(), vftSymRef);\n+      TR::Node *arrayCompClass = TR::Node::createWithSymRef(node, TR::aloadi, 1, vft, arrayCompSymRef);\n+      TR::Node *loadClassFlags = TR::Node::createWithSymRef(node, TR::iloadi, 1, arrayCompClass, classFlagsSymRef);\n+      TR::Node *isValueTypeNode = TR::Node::create(node, TR::iand, 2, loadClassFlags, TR::Node::iconst(node, J9ClassIsValueType));\n+\n+      TR::Node *ifNode = TR::Node::createif(TR::ificmpeq, isValueTypeNode, TR::Node::iconst(node, 0));\n+      ifNode->copyByteCodeInfo(node);\n+\n+\n+      TR::Node *passThru  = TR::Node::create(node, TR::PassThrough, 1, sourceChild);\n+      TR::ResolvedMethodSymbol *currentMethod = self()->comp()->getMethodSymbol();\n+      TR::Node *nullCheck = TR::Node::createWithSymRef(node, TR::NULLCHK, 1, passThru,\n+                               symRefTab()->findOrCreateNullCheckSymbolRef(currentMethod));\n+\n+      TR::Block *nullCheckBlock = prevBlock->splitPostGRA(tt, cfg);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "296416a8399ba933c0bd630fb76e348a6a891549"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzczNzc1Mw==", "bodyText": "Thanks for your review and advice, Rahil @r30shah - revised in commit 33c4ed8", "url": "https://github.com/eclipse-openj9/openj9/pull/10034#discussion_r447737753", "createdAt": "2020-06-30T14:41:13Z", "author": {"login": "hzongaro"}, "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -1493,6 +1500,201 @@ J9::CodeGenerator::lowerTreeIfNeeded(\n    }\n \n \n+/*\n+ * If value types are enabled, and the value that is being assigned to the array\n+ * element might be a null reference, lower the ArrayStoreCHK by splitting the\n+ * block before the ArrayStoreCHK, and inserting a NULLCHK guarded by a check\n+ * of whether the array's component type is a value type.\n+ */\n+void\n+J9::CodeGenerator::lowerArrayStoreCHK(TR::Node *node, TR::TreeTop *tt)\n+   {\n+   TR::Node *destChild;\n+   TR::Node *sourceChild;\n+\n+   // Pattern match the ArrayStoreCHK operands to get the source of the assignment\n+   // (sourceChild) and the array to which an element will have a value assigned (destChild)\n+   findArrayStoreCHKOperands(node, destChild, sourceChild);\n+\n+   // Only need to lower if it is possible that the value is a null reference\n+   if (!sourceChild->isNonNull())\n+      {\n+      TR::CFG * cfg = self()->comp()->getFlowGraph();\n+      cfg->invalidateStructure();\n+\n+      TR::Block *prevBlock = tt->getEnclosingBlock();\n+\n+      performTransformation(self()->comp(), \"%sTransforming ArrayStoreCHK n%dn [%p] by splitting block block_%d, and inserting a NULLCHK guarded with a check of whether the component type of the array is a value type\\n\", OPT_DETAILS, node->getGlobalIndex(), node, prevBlock->getNumber());\n+\n+      // Anchor the node that contains the destination array and the node\n+      // containing the source of the array element assignment to ensure\n+      // they are available in the ificmpeq and NULLCHK\n+      TR::TreeTop *anchoredArrayTT = TR::TreeTop::create(self()->comp(), tt->getPrevTreeTop(), TR::Node::create(TR::treetop, 1, destChild));\n+      TR::TreeTop *anchoredSourceTT = TR::TreeTop::create(self()->comp(), anchoredArrayTT, TR::Node::create(TR::treetop, 1, sourceChild));\n+\n+      // Transform\n+      //   +--------------------------------+\n+      //   | ttprev                         |\n+      //   | ArrayStoreCHK                  |\n+      //   |   awrtbari                     |\n+      //   |     aladd                      |\n+      //   |       <array-reference>        |\n+      //   |       index-offset-calculation |\n+      //   |     <value-reference>          |\n+      //   +--------------------------------+\n+      //\n+      // into\n+      //   +--------------------------------+\n+      //   | treetop                        |\n+      //   |   <value-reference>            |\n+      //   | treetop                        |\n+      //   |   <array-reference>            |\n+      //   | ificmpeq  -->------------------*---------+\n+      //   |   iand                         |         |\n+      //   |     iloadi <isClassFlags>      |         |\n+      //   |       aloadi <componentClass>  |         |\n+      //   |         aloadi <vft-symbol>    |         |\n+      //   |           <array-reference>    |         |\n+      //   |     iconst J9ClassIsValueType  |         |\n+      //   |   iconst 0                     |         |\n+      //   | BBEnd                          |         |\n+      //   +--------------------------------+         |\n+      //   | BBStart (Extension)            |         |\n+      //   | NULLCHK                        |         |\n+      //   |   Passthrough                  |         |\n+      //   |     <value-reference>          |         |\n+      //   | BBEnd                          |         |\n+      //   +--------------------------------+         |\n+      //                   |                          |\n+      //                   +--------------------------+\n+      //                   |\n+      //                   v\n+      //   +--------------------------------+\n+      //   | BBStart                        |\n+      //   | ArrayStoreCHK                  |\n+      //   |   awrtbari                     |\n+      //   |     aladd                      |\n+      //   |       aload <array>            |\n+      //   |       index-offset-calculation |\n+      //   |     aload <value>              |\n+      //   +--------------------------------+\n+      //\n+      TR::SymbolReference *vftSymRef = self()->comp()->getSymRefTab()->findOrCreateVftSymbolRef();\n+      TR::SymbolReference *arrayCompSymRef = self()->comp()->getSymRefTab()->findOrCreateArrayComponentTypeSymbolRef();\n+      TR::SymbolReference *classFlagsSymRef = self()->comp()->getSymRefTab()->findOrCreateClassFlagsSymbolRef();\n+\n+      TR::Node *vft = TR::Node::createWithSymRef(node, TR::aloadi, 1, anchoredArrayTT->getNode()->getFirstChild(), vftSymRef);\n+      TR::Node *arrayCompClass = TR::Node::createWithSymRef(node, TR::aloadi, 1, vft, arrayCompSymRef);\n+      TR::Node *loadClassFlags = TR::Node::createWithSymRef(node, TR::iloadi, 1, arrayCompClass, classFlagsSymRef);\n+      TR::Node *isValueTypeNode = TR::Node::create(node, TR::iand, 2, loadClassFlags, TR::Node::iconst(node, J9ClassIsValueType));\n+\n+      TR::Node *ifNode = TR::Node::createif(TR::ificmpeq, isValueTypeNode, TR::Node::iconst(node, 0));\n+      ifNode->copyByteCodeInfo(node);\n+\n+\n+      TR::Node *passThru  = TR::Node::create(node, TR::PassThrough, 1, sourceChild);\n+      TR::ResolvedMethodSymbol *currentMethod = self()->comp()->getMethodSymbol();\n+      TR::Node *nullCheck = TR::Node::createWithSymRef(node, TR::NULLCHK, 1, passThru,\n+                               symRefTab()->findOrCreateNullCheckSymbolRef(currentMethod));\n+\n+      TR::Block *nullCheckBlock = prevBlock->splitPostGRA(tt, cfg);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA1ODM4NQ=="}, "originalCommit": {"oid": "296416a8399ba933c0bd630fb76e348a6a891549"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgwNjk4MA==", "bodyText": "Updated commit to 58ab83b - no further changes there with respect to this comment.", "url": "https://github.com/eclipse-openj9/openj9/pull/10034#discussion_r447806980", "createdAt": "2020-06-30T16:13:51Z", "author": {"login": "hzongaro"}, "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -1493,6 +1500,201 @@ J9::CodeGenerator::lowerTreeIfNeeded(\n    }\n \n \n+/*\n+ * If value types are enabled, and the value that is being assigned to the array\n+ * element might be a null reference, lower the ArrayStoreCHK by splitting the\n+ * block before the ArrayStoreCHK, and inserting a NULLCHK guarded by a check\n+ * of whether the array's component type is a value type.\n+ */\n+void\n+J9::CodeGenerator::lowerArrayStoreCHK(TR::Node *node, TR::TreeTop *tt)\n+   {\n+   TR::Node *destChild;\n+   TR::Node *sourceChild;\n+\n+   // Pattern match the ArrayStoreCHK operands to get the source of the assignment\n+   // (sourceChild) and the array to which an element will have a value assigned (destChild)\n+   findArrayStoreCHKOperands(node, destChild, sourceChild);\n+\n+   // Only need to lower if it is possible that the value is a null reference\n+   if (!sourceChild->isNonNull())\n+      {\n+      TR::CFG * cfg = self()->comp()->getFlowGraph();\n+      cfg->invalidateStructure();\n+\n+      TR::Block *prevBlock = tt->getEnclosingBlock();\n+\n+      performTransformation(self()->comp(), \"%sTransforming ArrayStoreCHK n%dn [%p] by splitting block block_%d, and inserting a NULLCHK guarded with a check of whether the component type of the array is a value type\\n\", OPT_DETAILS, node->getGlobalIndex(), node, prevBlock->getNumber());\n+\n+      // Anchor the node that contains the destination array and the node\n+      // containing the source of the array element assignment to ensure\n+      // they are available in the ificmpeq and NULLCHK\n+      TR::TreeTop *anchoredArrayTT = TR::TreeTop::create(self()->comp(), tt->getPrevTreeTop(), TR::Node::create(TR::treetop, 1, destChild));\n+      TR::TreeTop *anchoredSourceTT = TR::TreeTop::create(self()->comp(), anchoredArrayTT, TR::Node::create(TR::treetop, 1, sourceChild));\n+\n+      // Transform\n+      //   +--------------------------------+\n+      //   | ttprev                         |\n+      //   | ArrayStoreCHK                  |\n+      //   |   awrtbari                     |\n+      //   |     aladd                      |\n+      //   |       <array-reference>        |\n+      //   |       index-offset-calculation |\n+      //   |     <value-reference>          |\n+      //   +--------------------------------+\n+      //\n+      // into\n+      //   +--------------------------------+\n+      //   | treetop                        |\n+      //   |   <value-reference>            |\n+      //   | treetop                        |\n+      //   |   <array-reference>            |\n+      //   | ificmpeq  -->------------------*---------+\n+      //   |   iand                         |         |\n+      //   |     iloadi <isClassFlags>      |         |\n+      //   |       aloadi <componentClass>  |         |\n+      //   |         aloadi <vft-symbol>    |         |\n+      //   |           <array-reference>    |         |\n+      //   |     iconst J9ClassIsValueType  |         |\n+      //   |   iconst 0                     |         |\n+      //   | BBEnd                          |         |\n+      //   +--------------------------------+         |\n+      //   | BBStart (Extension)            |         |\n+      //   | NULLCHK                        |         |\n+      //   |   Passthrough                  |         |\n+      //   |     <value-reference>          |         |\n+      //   | BBEnd                          |         |\n+      //   +--------------------------------+         |\n+      //                   |                          |\n+      //                   +--------------------------+\n+      //                   |\n+      //                   v\n+      //   +--------------------------------+\n+      //   | BBStart                        |\n+      //   | ArrayStoreCHK                  |\n+      //   |   awrtbari                     |\n+      //   |     aladd                      |\n+      //   |       aload <array>            |\n+      //   |       index-offset-calculation |\n+      //   |     aload <value>              |\n+      //   +--------------------------------+\n+      //\n+      TR::SymbolReference *vftSymRef = self()->comp()->getSymRefTab()->findOrCreateVftSymbolRef();\n+      TR::SymbolReference *arrayCompSymRef = self()->comp()->getSymRefTab()->findOrCreateArrayComponentTypeSymbolRef();\n+      TR::SymbolReference *classFlagsSymRef = self()->comp()->getSymRefTab()->findOrCreateClassFlagsSymbolRef();\n+\n+      TR::Node *vft = TR::Node::createWithSymRef(node, TR::aloadi, 1, anchoredArrayTT->getNode()->getFirstChild(), vftSymRef);\n+      TR::Node *arrayCompClass = TR::Node::createWithSymRef(node, TR::aloadi, 1, vft, arrayCompSymRef);\n+      TR::Node *loadClassFlags = TR::Node::createWithSymRef(node, TR::iloadi, 1, arrayCompClass, classFlagsSymRef);\n+      TR::Node *isValueTypeNode = TR::Node::create(node, TR::iand, 2, loadClassFlags, TR::Node::iconst(node, J9ClassIsValueType));\n+\n+      TR::Node *ifNode = TR::Node::createif(TR::ificmpeq, isValueTypeNode, TR::Node::iconst(node, 0));\n+      ifNode->copyByteCodeInfo(node);\n+\n+\n+      TR::Node *passThru  = TR::Node::create(node, TR::PassThrough, 1, sourceChild);\n+      TR::ResolvedMethodSymbol *currentMethod = self()->comp()->getMethodSymbol();\n+      TR::Node *nullCheck = TR::Node::createWithSymRef(node, TR::NULLCHK, 1, passThru,\n+                               symRefTab()->findOrCreateNullCheckSymbolRef(currentMethod));\n+\n+      TR::Block *nullCheckBlock = prevBlock->splitPostGRA(tt, cfg);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA1ODM4NQ=="}, "originalCommit": {"oid": "296416a8399ba933c0bd630fb76e348a6a891549"}, "originalPosition": 115}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxNjg2NjE1OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQyMDowNzoxOFrOGu3dCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxNDo1NjoyMVrOGv6lpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc5NjIzNA==", "bodyText": "@hzongaro  Changes looks good to me, one small thing I noticed is that you are calling splitPostGRA before creating treetops for NULLCHK and isValueTypeNode test, but nodes for the trees are created. For the purpose of this change it is fine as those new trees would not introduce any node that needs un-commoning, but if there were, you will introduce a bug where a node is live outside of its extended basic block, as block splitter walks treetops to identify nodes which would need uncommoning.", "url": "https://github.com/eclipse-openj9/openj9/pull/10034#discussion_r451796234", "createdAt": "2020-07-08T20:07:18Z", "author": {"login": "r30shah"}, "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -1493,6 +1500,196 @@ J9::CodeGenerator::lowerTreeIfNeeded(\n    }\n \n \n+/*\n+ * If value types are enabled, and the value that is being assigned to the array\n+ * element might be a null reference, lower the ArrayStoreCHK by splitting the\n+ * block before the ArrayStoreCHK, and inserting a NULLCHK guarded by a check\n+ * of whether the array's component type is a value type.\n+ */\n+void\n+J9::CodeGenerator::lowerArrayStoreCHK(TR::Node *node, TR::TreeTop *tt)\n+   {\n+   TR::Node *destChild;\n+   TR::Node *sourceChild;\n+\n+   // Pattern match the ArrayStoreCHK operands to get the source of the assignment\n+   // (sourceChild) and the array to which an element will have a value assigned (destChild)\n+   findArrayStoreCHKOperands(node, destChild, sourceChild);\n+\n+   // Only need to lower if it is possible that the value is a null reference\n+   if (!sourceChild->isNonNull())\n+      {\n+      TR::CFG * cfg = self()->comp()->getFlowGraph();\n+      cfg->invalidateStructure();\n+\n+      TR::Block *prevBlock = tt->getEnclosingBlock();\n+\n+      performTransformation(self()->comp(), \"%sTransforming ArrayStoreCHK n%dn [%p] by splitting block block_%d, and inserting a NULLCHK guarded with a check of whether the component type of the array is a value type\\n\", OPT_DETAILS, node->getGlobalIndex(), node, prevBlock->getNumber());\n+\n+      // Anchor the node containing the source of the array element\n+      // assignment and the node that contains the destination array\n+      // to ensure they are available for the ificmpeq and NULLCHK\n+      TR::TreeTop *anchoredArrayTT = TR::TreeTop::create(self()->comp(), tt->getPrevTreeTop(), TR::Node::create(TR::treetop, 1, destChild));\n+      TR::TreeTop *anchoredSourceTT = TR::TreeTop::create(self()->comp(), anchoredArrayTT, TR::Node::create(TR::treetop, 1, sourceChild));\n+\n+      // Transform\n+      //   +--------------------------------+\n+      //   | ttprev                         |\n+      //   | ArrayStoreCHK                  |\n+      //   |   astorei/awrtbari             |\n+      //   |     aladd                      |\n+      //   |       <array-reference>        |\n+      //   |       index-offset-calculation |\n+      //   |     <value-reference>          |\n+      //   +--------------------------------+\n+      //\n+      // into\n+      //   +--------------------------------+\n+      //   | treetop                        |\n+      //   |   <array-reference>            |\n+      //   | treetop                        |\n+      //   |   <value-reference>            |\n+      //   | ificmpeq  -->------------------*---------+\n+      //   |   iand                         |         |\n+      //   |     iloadi <isClassFlags>      |         |\n+      //   |       aloadi <componentClass>  |         |\n+      //   |         aloadi <vft-symbol>    |         |\n+      //   |           <array-reference>    |         |\n+      //   |     iconst J9ClassIsValueType  |         |\n+      //   |   iconst 0                     |         |\n+      //   | BBEnd                          |         |\n+      //   +--------------------------------+         |\n+      //   | BBStart (Extension)            |         |\n+      //   | NULLCHK                        |         |\n+      //   |   Passthrough                  |         |\n+      //   |     <value-reference>          |         |\n+      //   | BBEnd                          |         |\n+      //   +--------------------------------+         |\n+      //                   |                          |\n+      //                   +--------------------------+\n+      //                   |\n+      //                   v\n+      //   +--------------------------------+\n+      //   | BBStart                        |\n+      //   | ArrayStoreCHK                  |\n+      //   |   astorei/awrtbari             |\n+      //   |     aladd                      |\n+      //   |       aload <array>            |\n+      //   |       index-offset-calculation |\n+      //   |     aload <value>              |\n+      //   +--------------------------------+\n+      //\n+      TR::SymbolReference *vftSymRef = self()->comp()->getSymRefTab()->findOrCreateVftSymbolRef();\n+      TR::SymbolReference *arrayCompSymRef = self()->comp()->getSymRefTab()->findOrCreateArrayComponentTypeSymbolRef();\n+      TR::SymbolReference *classFlagsSymRef = self()->comp()->getSymRefTab()->findOrCreateClassFlagsSymbolRef();\n+\n+      TR::Node *vft = TR::Node::createWithSymRef(node, TR::aloadi, 1, anchoredArrayTT->getNode()->getFirstChild(), vftSymRef);\n+      TR::Node *arrayCompClass = TR::Node::createWithSymRef(node, TR::aloadi, 1, vft, arrayCompSymRef);\n+      TR::Node *loadClassFlags = TR::Node::createWithSymRef(node, TR::iloadi, 1, arrayCompClass, classFlagsSymRef);\n+      TR::Node *isValueTypeNode = TR::Node::create(node, TR::iand, 2, loadClassFlags, TR::Node::iconst(node, J9ClassIsValueType));\n+\n+      TR::Node *ifNode = TR::Node::createif(TR::ificmpeq, isValueTypeNode, TR::Node::iconst(node, 0));\n+      ifNode->copyByteCodeInfo(node);\n+\n+      TR::Node *passThru  = TR::Node::create(node, TR::PassThrough, 1, sourceChild);\n+      TR::ResolvedMethodSymbol *currentMethod = self()->comp()->getMethodSymbol();\n+\n+      TR::Block *arrayStoreCheckBlock = prevBlock->splitPostGRA(tt, cfg);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58ab83bcf1cf130105931a3c27f9fa299cc3acd4"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTkxMjIzMQ==", "bodyText": "@r30shah If you feel that would make the code easier to understand, and avoid any potential future bugs - especially if someone needs to model a future change on this - I would be happy to adjust this accordingly, either under this pull request or in a follow up PR to clean it up. . . .", "url": "https://github.com/eclipse-openj9/openj9/pull/10034#discussion_r451912231", "createdAt": "2020-07-09T01:28:05Z", "author": {"login": "hzongaro"}, "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -1493,6 +1500,196 @@ J9::CodeGenerator::lowerTreeIfNeeded(\n    }\n \n \n+/*\n+ * If value types are enabled, and the value that is being assigned to the array\n+ * element might be a null reference, lower the ArrayStoreCHK by splitting the\n+ * block before the ArrayStoreCHK, and inserting a NULLCHK guarded by a check\n+ * of whether the array's component type is a value type.\n+ */\n+void\n+J9::CodeGenerator::lowerArrayStoreCHK(TR::Node *node, TR::TreeTop *tt)\n+   {\n+   TR::Node *destChild;\n+   TR::Node *sourceChild;\n+\n+   // Pattern match the ArrayStoreCHK operands to get the source of the assignment\n+   // (sourceChild) and the array to which an element will have a value assigned (destChild)\n+   findArrayStoreCHKOperands(node, destChild, sourceChild);\n+\n+   // Only need to lower if it is possible that the value is a null reference\n+   if (!sourceChild->isNonNull())\n+      {\n+      TR::CFG * cfg = self()->comp()->getFlowGraph();\n+      cfg->invalidateStructure();\n+\n+      TR::Block *prevBlock = tt->getEnclosingBlock();\n+\n+      performTransformation(self()->comp(), \"%sTransforming ArrayStoreCHK n%dn [%p] by splitting block block_%d, and inserting a NULLCHK guarded with a check of whether the component type of the array is a value type\\n\", OPT_DETAILS, node->getGlobalIndex(), node, prevBlock->getNumber());\n+\n+      // Anchor the node containing the source of the array element\n+      // assignment and the node that contains the destination array\n+      // to ensure they are available for the ificmpeq and NULLCHK\n+      TR::TreeTop *anchoredArrayTT = TR::TreeTop::create(self()->comp(), tt->getPrevTreeTop(), TR::Node::create(TR::treetop, 1, destChild));\n+      TR::TreeTop *anchoredSourceTT = TR::TreeTop::create(self()->comp(), anchoredArrayTT, TR::Node::create(TR::treetop, 1, sourceChild));\n+\n+      // Transform\n+      //   +--------------------------------+\n+      //   | ttprev                         |\n+      //   | ArrayStoreCHK                  |\n+      //   |   astorei/awrtbari             |\n+      //   |     aladd                      |\n+      //   |       <array-reference>        |\n+      //   |       index-offset-calculation |\n+      //   |     <value-reference>          |\n+      //   +--------------------------------+\n+      //\n+      // into\n+      //   +--------------------------------+\n+      //   | treetop                        |\n+      //   |   <array-reference>            |\n+      //   | treetop                        |\n+      //   |   <value-reference>            |\n+      //   | ificmpeq  -->------------------*---------+\n+      //   |   iand                         |         |\n+      //   |     iloadi <isClassFlags>      |         |\n+      //   |       aloadi <componentClass>  |         |\n+      //   |         aloadi <vft-symbol>    |         |\n+      //   |           <array-reference>    |         |\n+      //   |     iconst J9ClassIsValueType  |         |\n+      //   |   iconst 0                     |         |\n+      //   | BBEnd                          |         |\n+      //   +--------------------------------+         |\n+      //   | BBStart (Extension)            |         |\n+      //   | NULLCHK                        |         |\n+      //   |   Passthrough                  |         |\n+      //   |     <value-reference>          |         |\n+      //   | BBEnd                          |         |\n+      //   +--------------------------------+         |\n+      //                   |                          |\n+      //                   +--------------------------+\n+      //                   |\n+      //                   v\n+      //   +--------------------------------+\n+      //   | BBStart                        |\n+      //   | ArrayStoreCHK                  |\n+      //   |   astorei/awrtbari             |\n+      //   |     aladd                      |\n+      //   |       aload <array>            |\n+      //   |       index-offset-calculation |\n+      //   |     aload <value>              |\n+      //   +--------------------------------+\n+      //\n+      TR::SymbolReference *vftSymRef = self()->comp()->getSymRefTab()->findOrCreateVftSymbolRef();\n+      TR::SymbolReference *arrayCompSymRef = self()->comp()->getSymRefTab()->findOrCreateArrayComponentTypeSymbolRef();\n+      TR::SymbolReference *classFlagsSymRef = self()->comp()->getSymRefTab()->findOrCreateClassFlagsSymbolRef();\n+\n+      TR::Node *vft = TR::Node::createWithSymRef(node, TR::aloadi, 1, anchoredArrayTT->getNode()->getFirstChild(), vftSymRef);\n+      TR::Node *arrayCompClass = TR::Node::createWithSymRef(node, TR::aloadi, 1, vft, arrayCompSymRef);\n+      TR::Node *loadClassFlags = TR::Node::createWithSymRef(node, TR::iloadi, 1, arrayCompClass, classFlagsSymRef);\n+      TR::Node *isValueTypeNode = TR::Node::create(node, TR::iand, 2, loadClassFlags, TR::Node::iconst(node, J9ClassIsValueType));\n+\n+      TR::Node *ifNode = TR::Node::createif(TR::ificmpeq, isValueTypeNode, TR::Node::iconst(node, 0));\n+      ifNode->copyByteCodeInfo(node);\n+\n+      TR::Node *passThru  = TR::Node::create(node, TR::PassThrough, 1, sourceChild);\n+      TR::ResolvedMethodSymbol *currentMethod = self()->comp()->getMethodSymbol();\n+\n+      TR::Block *arrayStoreCheckBlock = prevBlock->splitPostGRA(tt, cfg);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc5NjIzNA=="}, "originalCommit": {"oid": "58ab83bcf1cf130105931a3c27f9fa299cc3acd4"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjI2MjAzOA==", "bodyText": "@hzongaro Sorry about this minor nitpick, I am fine with the way code is interacting with splitter currently but if you want to make changes, as you are creating nodes for ifNode and NULLCHK before splitting block, you can create and insert the treetop before tt and anchoredSourceTT and can split the block from tt.", "url": "https://github.com/eclipse-openj9/openj9/pull/10034#discussion_r452262038", "createdAt": "2020-07-09T14:31:34Z", "author": {"login": "r30shah"}, "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -1493,6 +1500,196 @@ J9::CodeGenerator::lowerTreeIfNeeded(\n    }\n \n \n+/*\n+ * If value types are enabled, and the value that is being assigned to the array\n+ * element might be a null reference, lower the ArrayStoreCHK by splitting the\n+ * block before the ArrayStoreCHK, and inserting a NULLCHK guarded by a check\n+ * of whether the array's component type is a value type.\n+ */\n+void\n+J9::CodeGenerator::lowerArrayStoreCHK(TR::Node *node, TR::TreeTop *tt)\n+   {\n+   TR::Node *destChild;\n+   TR::Node *sourceChild;\n+\n+   // Pattern match the ArrayStoreCHK operands to get the source of the assignment\n+   // (sourceChild) and the array to which an element will have a value assigned (destChild)\n+   findArrayStoreCHKOperands(node, destChild, sourceChild);\n+\n+   // Only need to lower if it is possible that the value is a null reference\n+   if (!sourceChild->isNonNull())\n+      {\n+      TR::CFG * cfg = self()->comp()->getFlowGraph();\n+      cfg->invalidateStructure();\n+\n+      TR::Block *prevBlock = tt->getEnclosingBlock();\n+\n+      performTransformation(self()->comp(), \"%sTransforming ArrayStoreCHK n%dn [%p] by splitting block block_%d, and inserting a NULLCHK guarded with a check of whether the component type of the array is a value type\\n\", OPT_DETAILS, node->getGlobalIndex(), node, prevBlock->getNumber());\n+\n+      // Anchor the node containing the source of the array element\n+      // assignment and the node that contains the destination array\n+      // to ensure they are available for the ificmpeq and NULLCHK\n+      TR::TreeTop *anchoredArrayTT = TR::TreeTop::create(self()->comp(), tt->getPrevTreeTop(), TR::Node::create(TR::treetop, 1, destChild));\n+      TR::TreeTop *anchoredSourceTT = TR::TreeTop::create(self()->comp(), anchoredArrayTT, TR::Node::create(TR::treetop, 1, sourceChild));\n+\n+      // Transform\n+      //   +--------------------------------+\n+      //   | ttprev                         |\n+      //   | ArrayStoreCHK                  |\n+      //   |   astorei/awrtbari             |\n+      //   |     aladd                      |\n+      //   |       <array-reference>        |\n+      //   |       index-offset-calculation |\n+      //   |     <value-reference>          |\n+      //   +--------------------------------+\n+      //\n+      // into\n+      //   +--------------------------------+\n+      //   | treetop                        |\n+      //   |   <array-reference>            |\n+      //   | treetop                        |\n+      //   |   <value-reference>            |\n+      //   | ificmpeq  -->------------------*---------+\n+      //   |   iand                         |         |\n+      //   |     iloadi <isClassFlags>      |         |\n+      //   |       aloadi <componentClass>  |         |\n+      //   |         aloadi <vft-symbol>    |         |\n+      //   |           <array-reference>    |         |\n+      //   |     iconst J9ClassIsValueType  |         |\n+      //   |   iconst 0                     |         |\n+      //   | BBEnd                          |         |\n+      //   +--------------------------------+         |\n+      //   | BBStart (Extension)            |         |\n+      //   | NULLCHK                        |         |\n+      //   |   Passthrough                  |         |\n+      //   |     <value-reference>          |         |\n+      //   | BBEnd                          |         |\n+      //   +--------------------------------+         |\n+      //                   |                          |\n+      //                   +--------------------------+\n+      //                   |\n+      //                   v\n+      //   +--------------------------------+\n+      //   | BBStart                        |\n+      //   | ArrayStoreCHK                  |\n+      //   |   astorei/awrtbari             |\n+      //   |     aladd                      |\n+      //   |       aload <array>            |\n+      //   |       index-offset-calculation |\n+      //   |     aload <value>              |\n+      //   +--------------------------------+\n+      //\n+      TR::SymbolReference *vftSymRef = self()->comp()->getSymRefTab()->findOrCreateVftSymbolRef();\n+      TR::SymbolReference *arrayCompSymRef = self()->comp()->getSymRefTab()->findOrCreateArrayComponentTypeSymbolRef();\n+      TR::SymbolReference *classFlagsSymRef = self()->comp()->getSymRefTab()->findOrCreateClassFlagsSymbolRef();\n+\n+      TR::Node *vft = TR::Node::createWithSymRef(node, TR::aloadi, 1, anchoredArrayTT->getNode()->getFirstChild(), vftSymRef);\n+      TR::Node *arrayCompClass = TR::Node::createWithSymRef(node, TR::aloadi, 1, vft, arrayCompSymRef);\n+      TR::Node *loadClassFlags = TR::Node::createWithSymRef(node, TR::iloadi, 1, arrayCompClass, classFlagsSymRef);\n+      TR::Node *isValueTypeNode = TR::Node::create(node, TR::iand, 2, loadClassFlags, TR::Node::iconst(node, J9ClassIsValueType));\n+\n+      TR::Node *ifNode = TR::Node::createif(TR::ificmpeq, isValueTypeNode, TR::Node::iconst(node, 0));\n+      ifNode->copyByteCodeInfo(node);\n+\n+      TR::Node *passThru  = TR::Node::create(node, TR::PassThrough, 1, sourceChild);\n+      TR::ResolvedMethodSymbol *currentMethod = self()->comp()->getMethodSymbol();\n+\n+      TR::Block *arrayStoreCheckBlock = prevBlock->splitPostGRA(tt, cfg);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc5NjIzNA=="}, "originalCommit": {"oid": "58ab83bcf1cf130105931a3c27f9fa299cc3acd4"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjg4NTk4NA==", "bodyText": "Thanks @hzongaro  for pointing out the issue with the change I suggested in previous comment,(Issue with the change I suggested is that it will introduce the regStore trees after the control flow trees before ending basic block. Which is not functionally correct). Taking my suggestion back, Changes looks completely fine to me.", "url": "https://github.com/eclipse-openj9/openj9/pull/10034#discussion_r452885984", "createdAt": "2020-07-10T14:39:54Z", "author": {"login": "r30shah"}, "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -1493,6 +1500,196 @@ J9::CodeGenerator::lowerTreeIfNeeded(\n    }\n \n \n+/*\n+ * If value types are enabled, and the value that is being assigned to the array\n+ * element might be a null reference, lower the ArrayStoreCHK by splitting the\n+ * block before the ArrayStoreCHK, and inserting a NULLCHK guarded by a check\n+ * of whether the array's component type is a value type.\n+ */\n+void\n+J9::CodeGenerator::lowerArrayStoreCHK(TR::Node *node, TR::TreeTop *tt)\n+   {\n+   TR::Node *destChild;\n+   TR::Node *sourceChild;\n+\n+   // Pattern match the ArrayStoreCHK operands to get the source of the assignment\n+   // (sourceChild) and the array to which an element will have a value assigned (destChild)\n+   findArrayStoreCHKOperands(node, destChild, sourceChild);\n+\n+   // Only need to lower if it is possible that the value is a null reference\n+   if (!sourceChild->isNonNull())\n+      {\n+      TR::CFG * cfg = self()->comp()->getFlowGraph();\n+      cfg->invalidateStructure();\n+\n+      TR::Block *prevBlock = tt->getEnclosingBlock();\n+\n+      performTransformation(self()->comp(), \"%sTransforming ArrayStoreCHK n%dn [%p] by splitting block block_%d, and inserting a NULLCHK guarded with a check of whether the component type of the array is a value type\\n\", OPT_DETAILS, node->getGlobalIndex(), node, prevBlock->getNumber());\n+\n+      // Anchor the node containing the source of the array element\n+      // assignment and the node that contains the destination array\n+      // to ensure they are available for the ificmpeq and NULLCHK\n+      TR::TreeTop *anchoredArrayTT = TR::TreeTop::create(self()->comp(), tt->getPrevTreeTop(), TR::Node::create(TR::treetop, 1, destChild));\n+      TR::TreeTop *anchoredSourceTT = TR::TreeTop::create(self()->comp(), anchoredArrayTT, TR::Node::create(TR::treetop, 1, sourceChild));\n+\n+      // Transform\n+      //   +--------------------------------+\n+      //   | ttprev                         |\n+      //   | ArrayStoreCHK                  |\n+      //   |   astorei/awrtbari             |\n+      //   |     aladd                      |\n+      //   |       <array-reference>        |\n+      //   |       index-offset-calculation |\n+      //   |     <value-reference>          |\n+      //   +--------------------------------+\n+      //\n+      // into\n+      //   +--------------------------------+\n+      //   | treetop                        |\n+      //   |   <array-reference>            |\n+      //   | treetop                        |\n+      //   |   <value-reference>            |\n+      //   | ificmpeq  -->------------------*---------+\n+      //   |   iand                         |         |\n+      //   |     iloadi <isClassFlags>      |         |\n+      //   |       aloadi <componentClass>  |         |\n+      //   |         aloadi <vft-symbol>    |         |\n+      //   |           <array-reference>    |         |\n+      //   |     iconst J9ClassIsValueType  |         |\n+      //   |   iconst 0                     |         |\n+      //   | BBEnd                          |         |\n+      //   +--------------------------------+         |\n+      //   | BBStart (Extension)            |         |\n+      //   | NULLCHK                        |         |\n+      //   |   Passthrough                  |         |\n+      //   |     <value-reference>          |         |\n+      //   | BBEnd                          |         |\n+      //   +--------------------------------+         |\n+      //                   |                          |\n+      //                   +--------------------------+\n+      //                   |\n+      //                   v\n+      //   +--------------------------------+\n+      //   | BBStart                        |\n+      //   | ArrayStoreCHK                  |\n+      //   |   astorei/awrtbari             |\n+      //   |     aladd                      |\n+      //   |       aload <array>            |\n+      //   |       index-offset-calculation |\n+      //   |     aload <value>              |\n+      //   +--------------------------------+\n+      //\n+      TR::SymbolReference *vftSymRef = self()->comp()->getSymRefTab()->findOrCreateVftSymbolRef();\n+      TR::SymbolReference *arrayCompSymRef = self()->comp()->getSymRefTab()->findOrCreateArrayComponentTypeSymbolRef();\n+      TR::SymbolReference *classFlagsSymRef = self()->comp()->getSymRefTab()->findOrCreateClassFlagsSymbolRef();\n+\n+      TR::Node *vft = TR::Node::createWithSymRef(node, TR::aloadi, 1, anchoredArrayTT->getNode()->getFirstChild(), vftSymRef);\n+      TR::Node *arrayCompClass = TR::Node::createWithSymRef(node, TR::aloadi, 1, vft, arrayCompSymRef);\n+      TR::Node *loadClassFlags = TR::Node::createWithSymRef(node, TR::iloadi, 1, arrayCompClass, classFlagsSymRef);\n+      TR::Node *isValueTypeNode = TR::Node::create(node, TR::iand, 2, loadClassFlags, TR::Node::iconst(node, J9ClassIsValueType));\n+\n+      TR::Node *ifNode = TR::Node::createif(TR::ificmpeq, isValueTypeNode, TR::Node::iconst(node, 0));\n+      ifNode->copyByteCodeInfo(node);\n+\n+      TR::Node *passThru  = TR::Node::create(node, TR::PassThrough, 1, sourceChild);\n+      TR::ResolvedMethodSymbol *currentMethod = self()->comp()->getMethodSymbol();\n+\n+      TR::Block *arrayStoreCheckBlock = prevBlock->splitPostGRA(tt, cfg);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc5NjIzNA=="}, "originalCommit": {"oid": "58ab83bcf1cf130105931a3c27f9fa299cc3acd4"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjg5NjE2Ng==", "bodyText": "Thanks for reviewing, Rahil @r30shah!", "url": "https://github.com/eclipse-openj9/openj9/pull/10034#discussion_r452896166", "createdAt": "2020-07-10T14:56:21Z", "author": {"login": "hzongaro"}, "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -1493,6 +1500,196 @@ J9::CodeGenerator::lowerTreeIfNeeded(\n    }\n \n \n+/*\n+ * If value types are enabled, and the value that is being assigned to the array\n+ * element might be a null reference, lower the ArrayStoreCHK by splitting the\n+ * block before the ArrayStoreCHK, and inserting a NULLCHK guarded by a check\n+ * of whether the array's component type is a value type.\n+ */\n+void\n+J9::CodeGenerator::lowerArrayStoreCHK(TR::Node *node, TR::TreeTop *tt)\n+   {\n+   TR::Node *destChild;\n+   TR::Node *sourceChild;\n+\n+   // Pattern match the ArrayStoreCHK operands to get the source of the assignment\n+   // (sourceChild) and the array to which an element will have a value assigned (destChild)\n+   findArrayStoreCHKOperands(node, destChild, sourceChild);\n+\n+   // Only need to lower if it is possible that the value is a null reference\n+   if (!sourceChild->isNonNull())\n+      {\n+      TR::CFG * cfg = self()->comp()->getFlowGraph();\n+      cfg->invalidateStructure();\n+\n+      TR::Block *prevBlock = tt->getEnclosingBlock();\n+\n+      performTransformation(self()->comp(), \"%sTransforming ArrayStoreCHK n%dn [%p] by splitting block block_%d, and inserting a NULLCHK guarded with a check of whether the component type of the array is a value type\\n\", OPT_DETAILS, node->getGlobalIndex(), node, prevBlock->getNumber());\n+\n+      // Anchor the node containing the source of the array element\n+      // assignment and the node that contains the destination array\n+      // to ensure they are available for the ificmpeq and NULLCHK\n+      TR::TreeTop *anchoredArrayTT = TR::TreeTop::create(self()->comp(), tt->getPrevTreeTop(), TR::Node::create(TR::treetop, 1, destChild));\n+      TR::TreeTop *anchoredSourceTT = TR::TreeTop::create(self()->comp(), anchoredArrayTT, TR::Node::create(TR::treetop, 1, sourceChild));\n+\n+      // Transform\n+      //   +--------------------------------+\n+      //   | ttprev                         |\n+      //   | ArrayStoreCHK                  |\n+      //   |   astorei/awrtbari             |\n+      //   |     aladd                      |\n+      //   |       <array-reference>        |\n+      //   |       index-offset-calculation |\n+      //   |     <value-reference>          |\n+      //   +--------------------------------+\n+      //\n+      // into\n+      //   +--------------------------------+\n+      //   | treetop                        |\n+      //   |   <array-reference>            |\n+      //   | treetop                        |\n+      //   |   <value-reference>            |\n+      //   | ificmpeq  -->------------------*---------+\n+      //   |   iand                         |         |\n+      //   |     iloadi <isClassFlags>      |         |\n+      //   |       aloadi <componentClass>  |         |\n+      //   |         aloadi <vft-symbol>    |         |\n+      //   |           <array-reference>    |         |\n+      //   |     iconst J9ClassIsValueType  |         |\n+      //   |   iconst 0                     |         |\n+      //   | BBEnd                          |         |\n+      //   +--------------------------------+         |\n+      //   | BBStart (Extension)            |         |\n+      //   | NULLCHK                        |         |\n+      //   |   Passthrough                  |         |\n+      //   |     <value-reference>          |         |\n+      //   | BBEnd                          |         |\n+      //   +--------------------------------+         |\n+      //                   |                          |\n+      //                   +--------------------------+\n+      //                   |\n+      //                   v\n+      //   +--------------------------------+\n+      //   | BBStart                        |\n+      //   | ArrayStoreCHK                  |\n+      //   |   astorei/awrtbari             |\n+      //   |     aladd                      |\n+      //   |       aload <array>            |\n+      //   |       index-offset-calculation |\n+      //   |     aload <value>              |\n+      //   +--------------------------------+\n+      //\n+      TR::SymbolReference *vftSymRef = self()->comp()->getSymRefTab()->findOrCreateVftSymbolRef();\n+      TR::SymbolReference *arrayCompSymRef = self()->comp()->getSymRefTab()->findOrCreateArrayComponentTypeSymbolRef();\n+      TR::SymbolReference *classFlagsSymRef = self()->comp()->getSymRefTab()->findOrCreateClassFlagsSymbolRef();\n+\n+      TR::Node *vft = TR::Node::createWithSymRef(node, TR::aloadi, 1, anchoredArrayTT->getNode()->getFirstChild(), vftSymRef);\n+      TR::Node *arrayCompClass = TR::Node::createWithSymRef(node, TR::aloadi, 1, vft, arrayCompSymRef);\n+      TR::Node *loadClassFlags = TR::Node::createWithSymRef(node, TR::iloadi, 1, arrayCompClass, classFlagsSymRef);\n+      TR::Node *isValueTypeNode = TR::Node::create(node, TR::iand, 2, loadClassFlags, TR::Node::iconst(node, J9ClassIsValueType));\n+\n+      TR::Node *ifNode = TR::Node::createif(TR::ificmpeq, isValueTypeNode, TR::Node::iconst(node, 0));\n+      ifNode->copyByteCodeInfo(node);\n+\n+      TR::Node *passThru  = TR::Node::create(node, TR::PassThrough, 1, sourceChild);\n+      TR::ResolvedMethodSymbol *currentMethod = self()->comp()->getMethodSymbol();\n+\n+      TR::Block *arrayStoreCheckBlock = prevBlock->splitPostGRA(tt, cfg);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc5NjIzNA=="}, "originalCommit": {"oid": "58ab83bcf1cf130105931a3c27f9fa299cc3acd4"}, "originalPosition": 112}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4876, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}