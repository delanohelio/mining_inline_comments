{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg3MzE4NTg0", "number": 8844, "reviewThreads": {"totalCount": 24, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxNjoxNjozMVrODniB1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQyMDoxMDowMlrODtRQyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyNzc4NTgwOnYy", "diffSide": "RIGHT", "path": "runtime/compiler/runtime/Listener.cpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxNjoxNjozMVrOF1lfVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxNjoxNjozMVrOF1lfVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTczMzA3OQ==", "bodyText": "formatting?  Maybe?  Hard to tell when if statements don't always have { & }", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r391733079", "createdAt": "2020-03-12T16:16:31Z", "author": {"login": "DanHeidinga"}, "path": "runtime/compiler/runtime/Listener.cpp", "diffHunk": "@@ -20,18 +20,284 @@\n  * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n  *******************************************************************************/\n \n-#include \"runtime/Listener.hpp\"\n-#include \"net/ServerStream.hpp\"\n+#include <arpa/inet.h>\n+#include <chrono>\n+#include <fcntl.h>\n+#include <netdb.h>\n+#include <netinet/in.h>\n+#include <netinet/tcp.h>\t/* for TCP_NODELAY option */\n+#include <openssl/err.h>\n+#include <poll.h>\n+#include <sys/types.h>\n+#include <sys/socket.h>\n+#include <sys/un.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <unistd.h> /// gethostname, read, write\n+#include \"control/CompilationRuntime.hpp\"\n+#include \"env/TRMemory.hpp\"\n #include \"env/VMJ9.h\"\n+#include \"net/CommunicationStream.hpp\"\n+#include \"net/LoadSSLLibs.hpp\"\n+#include \"net/ServerStream.hpp\"\n+#include \"net/SSLProtobufStream.hpp\"\n #include \"runtime/CompileService.hpp\"\n-#include \"control/CompilationRuntime.hpp\"\n+#include \"runtime/Listener.hpp\"\n+\n+static SSL_CTX *\n+createSSLContext(TR::PersistentInfo *info)\n+   {\n+   SSL_CTX *ctx = (*OSSL_CTX_new)((*OSSLv23_server_method)());\n+\n+   if (!ctx)\n+      {\n+      perror(\"can't create SSL context\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   const char *sessionIDContext = \"JITServer\";\n+   (*OSSL_CTX_set_session_id_context)(ctx, (const unsigned char*)sessionIDContext, strlen(sessionIDContext));\n+\n+   if ((*OSSL_CTX_set_ecdh_auto)(ctx, 1) != 1)\n+      {\n+      perror(\"failed to configure SSL ecdh\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   TR::CompilationInfo *compInfo = TR::CompilationInfo::get();\n+   auto &sslKeys = compInfo->getJITServerSslKeys();\n+   auto &sslCerts = compInfo->getJITServerSslCerts();\n+   auto &sslRootCerts = compInfo->getJITServerSslRootCerts();\n+\n+   TR_ASSERT_FATAL(sslKeys.size() == 1 && sslCerts.size() == 1, \"only one key and cert is supported for now\");\n+   TR_ASSERT_FATAL(sslRootCerts.size() == 0, \"server does not understand root certs yet\");\n+\n+   // Parse and set private key\n+   BIO *keyMem = (*OBIO_new_mem_buf)(&sslKeys[0][0], sslKeys[0].size());\n+   if (!keyMem)\n+      {\n+      perror(\"cannot create memory buffer for private key (OOM?)\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   EVP_PKEY *privKey = (*OPEM_read_bio_PrivateKey)(keyMem, NULL, NULL, NULL);\n+   if (!privKey)\n+      {\n+      perror(\"cannot parse private key\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   if ((*OSSL_CTX_use_PrivateKey)(ctx, privKey) != 1)\n+      {\n+      perror(\"cannot use private key\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // Parse and set certificate\n+   BIO *certMem = (*OBIO_new_mem_buf)(&sslCerts[0][0], sslCerts[0].size());\n+   if (!certMem)\n+      {\n+      perror(\"cannot create memory buffer for cert (OOM?)\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   X509 *certificate = (*OPEM_read_bio_X509)(certMem, NULL, NULL, NULL);\n+   if (!certificate)\n+      {\n+      perror(\"cannot parse cert\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   if ((*OSSL_CTX_use_certificate)(ctx, certificate) != 1)\n+      {\n+      perror(\"cannot use cert\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // Verify key and cert are valid\n+   if ((*OSSL_CTX_check_private_key)(ctx) != 1)\n+      {\n+      perror(\"private key check failed\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // verify server identity using standard method\n+   (*OSSL_CTX_set_verify)(ctx, SSL_VERIFY_PEER, NULL);\n+\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+      TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"Successfully initialized SSL context (%s)\\n\", (*OOpenSSL_version)(0));\n+\n+   return ctx;\n+   }\n+\n+static bool\n+handleOpenSSLConnectionError(int connfd, SSL *&ssl, BIO *&bio, const char *errMsg)\n+{\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+       TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"%s: errno=%d\", errMsg, errno);\n+   (*OERR_print_errors_fp)(stderr);\n+\n+   close(connfd);\n+   if (bio)\n+      {\n+      (*OBIO_free_all)(bio);\n+      bio = NULL;\n+      }\n+   if (ssl)\n+      {\n+      (*OSSL_free)(ssl);\n+      ssl = NULL;\n+      }\n+   return false;\n+}\n+\n+static bool\n+acceptOpenSSLConnection(SSL_CTX *sslCtx, int connfd, BIO *&bio)\n+   {\n+   SSL *ssl = (*OSSL_new)(sslCtx);\n+   if (!ssl)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error creating SSL connection\");\n+\n+   (*OSSL_set_accept_state)(ssl);\n+\n+   if ((*OSSL_set_fd)(ssl, connfd) != 1)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error setting SSL file descriptor\");\n+\n+   if ((*OSSL_accept)(ssl) <= 0)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error accepting SSL connection\");\n+\n+   bio = (*OBIO_new_ssl)(sslCtx, false);\n+   if (!bio)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error creating new BIO\");\n+\n+   if ((*OBIO_ctrl)(bio, BIO_C_SET_SSL, true, (char *)ssl) != 1) // BIO_set_ssl(bio, ssl, true)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error setting BIO SSL\");\n+\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+      TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"SSL connection on socket 0x%x, Version: %s, Cipher: %s\\n\",\n+                                                     connfd, (*OSSL_get_version)(ssl), (*OSSL_get_cipher)(ssl));\n+   return true;\n+   }\n \n TR_Listener::TR_Listener()\n    : _listenerThread(NULL), _listenerMonitor(NULL), _listenerOSThread(NULL), \n    _listenerThreadAttachAttempted(false), _listenerThreadExitFlag(false)\n    {\n    }\n \n+void\n+TR_Listener::serveRemoteCompilationRequests(BaseCompileDispatcher *compiler)\n+   {\n+   TR::PersistentInfo *info = getCompilationInfo(jitConfig)->getPersistentInfo();\n+   SSL_CTX *sslCtx = NULL;\n+   if (JITServer::CommunicationStream::useSSL())\n+      {\n+      JITServer::CommunicationStream::initSSL();\n+      sslCtx = createSSLContext(info);\n+      }\n+\n+   uint32_t port = info->getJITServerPort();\n+   uint32_t timeoutMs = info->getSocketTimeout();\n+   struct pollfd pfd = {0};\n+   int sockfd = socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, 0);\n+   if (sockfd < 0)\n+      {\n+      perror(\"can't open server socket\");\n+      exit(1);\n+      }\n+\n+   // see `man 7 socket` for option explanations\n+   int flag = true;\n+   if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, (void *)&flag, sizeof(flag)) < 0)\n+      {\n+      perror(\"Can't set SO_REUSEADDR\");\n+      exit(-1);\n+      }\n+   if (setsockopt(sockfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&flag, sizeof(flag)) < 0)\n+      {\n+      perror(\"Can't set SO_KEEPALIVE\");\n+      exit(-1);\n+      }\n+\n+   struct sockaddr_in serv_addr;\n+   memset((char *)&serv_addr, 0, sizeof(serv_addr));\n+   serv_addr.sin_family = AF_INET;\n+   serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);\n+   serv_addr.sin_port = htons(port);\n+\n+   if (bind(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0)\n+      {\n+      perror(\"can't bind server address\");\n+      exit(1);\n+      }\n+   if (listen(sockfd, SOMAXCONN) < 0)\n+      {\n+      perror(\"listen failed\");\n+      exit(1);\n+      }\n+\n+   pfd.fd = sockfd;\n+   pfd.events = POLLIN;\n+\n+   while (!getListenerThreadExitFlag())\n+      {\n+      int32_t rc = 0;\n+      struct sockaddr_in cli_addr;\n+      socklen_t clilen = sizeof(cli_addr);\n+\n+      rc = poll(&pfd, 1, OPENJ9_LISTENER_POLL_TIMEOUT);\n+      if ((rc == 0) && getListenerThreadExitFlag())\n+         {\n+         break;\n+         }\n+      else if (rc < 0)\n+         {\n+         if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+            TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"Error in polling socket: errno=%d\", errno);\n+\t exit(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25b5d856e087db5e896c501a3706fc370ed8f867"}, "originalPosition": 246}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyODE4ODE4OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/runtime/Listener.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxODowMjowM1rOF1pf8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQyMDo1MzozOFrOF1u8pA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc5ODc3MQ==", "bodyText": "For a hard exit like this I would prefer a message to stderr, rather than the vlog (or in addition to the vlog). We used perror below, so we could use here as well.", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r391798771", "createdAt": "2020-03-12T18:02:03Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/runtime/Listener.cpp", "diffHunk": "@@ -20,18 +20,284 @@\n  * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n  *******************************************************************************/\n \n-#include \"runtime/Listener.hpp\"\n-#include \"net/ServerStream.hpp\"\n+#include <arpa/inet.h>\n+#include <chrono>\n+#include <fcntl.h>\n+#include <netdb.h>\n+#include <netinet/in.h>\n+#include <netinet/tcp.h>\t/* for TCP_NODELAY option */\n+#include <openssl/err.h>\n+#include <poll.h>\n+#include <sys/types.h>\n+#include <sys/socket.h>\n+#include <sys/un.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <unistd.h> /// gethostname, read, write\n+#include \"control/CompilationRuntime.hpp\"\n+#include \"env/TRMemory.hpp\"\n #include \"env/VMJ9.h\"\n+#include \"net/CommunicationStream.hpp\"\n+#include \"net/LoadSSLLibs.hpp\"\n+#include \"net/ServerStream.hpp\"\n+#include \"net/SSLProtobufStream.hpp\"\n #include \"runtime/CompileService.hpp\"\n-#include \"control/CompilationRuntime.hpp\"\n+#include \"runtime/Listener.hpp\"\n+\n+static SSL_CTX *\n+createSSLContext(TR::PersistentInfo *info)\n+   {\n+   SSL_CTX *ctx = (*OSSL_CTX_new)((*OSSLv23_server_method)());\n+\n+   if (!ctx)\n+      {\n+      perror(\"can't create SSL context\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   const char *sessionIDContext = \"JITServer\";\n+   (*OSSL_CTX_set_session_id_context)(ctx, (const unsigned char*)sessionIDContext, strlen(sessionIDContext));\n+\n+   if ((*OSSL_CTX_set_ecdh_auto)(ctx, 1) != 1)\n+      {\n+      perror(\"failed to configure SSL ecdh\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   TR::CompilationInfo *compInfo = TR::CompilationInfo::get();\n+   auto &sslKeys = compInfo->getJITServerSslKeys();\n+   auto &sslCerts = compInfo->getJITServerSslCerts();\n+   auto &sslRootCerts = compInfo->getJITServerSslRootCerts();\n+\n+   TR_ASSERT_FATAL(sslKeys.size() == 1 && sslCerts.size() == 1, \"only one key and cert is supported for now\");\n+   TR_ASSERT_FATAL(sslRootCerts.size() == 0, \"server does not understand root certs yet\");\n+\n+   // Parse and set private key\n+   BIO *keyMem = (*OBIO_new_mem_buf)(&sslKeys[0][0], sslKeys[0].size());\n+   if (!keyMem)\n+      {\n+      perror(\"cannot create memory buffer for private key (OOM?)\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   EVP_PKEY *privKey = (*OPEM_read_bio_PrivateKey)(keyMem, NULL, NULL, NULL);\n+   if (!privKey)\n+      {\n+      perror(\"cannot parse private key\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   if ((*OSSL_CTX_use_PrivateKey)(ctx, privKey) != 1)\n+      {\n+      perror(\"cannot use private key\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // Parse and set certificate\n+   BIO *certMem = (*OBIO_new_mem_buf)(&sslCerts[0][0], sslCerts[0].size());\n+   if (!certMem)\n+      {\n+      perror(\"cannot create memory buffer for cert (OOM?)\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   X509 *certificate = (*OPEM_read_bio_X509)(certMem, NULL, NULL, NULL);\n+   if (!certificate)\n+      {\n+      perror(\"cannot parse cert\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   if ((*OSSL_CTX_use_certificate)(ctx, certificate) != 1)\n+      {\n+      perror(\"cannot use cert\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // Verify key and cert are valid\n+   if ((*OSSL_CTX_check_private_key)(ctx) != 1)\n+      {\n+      perror(\"private key check failed\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // verify server identity using standard method\n+   (*OSSL_CTX_set_verify)(ctx, SSL_VERIFY_PEER, NULL);\n+\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+      TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"Successfully initialized SSL context (%s)\\n\", (*OOpenSSL_version)(0));\n+\n+   return ctx;\n+   }\n+\n+static bool\n+handleOpenSSLConnectionError(int connfd, SSL *&ssl, BIO *&bio, const char *errMsg)\n+{\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+       TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"%s: errno=%d\", errMsg, errno);\n+   (*OERR_print_errors_fp)(stderr);\n+\n+   close(connfd);\n+   if (bio)\n+      {\n+      (*OBIO_free_all)(bio);\n+      bio = NULL;\n+      }\n+   if (ssl)\n+      {\n+      (*OSSL_free)(ssl);\n+      ssl = NULL;\n+      }\n+   return false;\n+}\n+\n+static bool\n+acceptOpenSSLConnection(SSL_CTX *sslCtx, int connfd, BIO *&bio)\n+   {\n+   SSL *ssl = (*OSSL_new)(sslCtx);\n+   if (!ssl)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error creating SSL connection\");\n+\n+   (*OSSL_set_accept_state)(ssl);\n+\n+   if ((*OSSL_set_fd)(ssl, connfd) != 1)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error setting SSL file descriptor\");\n+\n+   if ((*OSSL_accept)(ssl) <= 0)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error accepting SSL connection\");\n+\n+   bio = (*OBIO_new_ssl)(sslCtx, false);\n+   if (!bio)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error creating new BIO\");\n+\n+   if ((*OBIO_ctrl)(bio, BIO_C_SET_SSL, true, (char *)ssl) != 1) // BIO_set_ssl(bio, ssl, true)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error setting BIO SSL\");\n+\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+      TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"SSL connection on socket 0x%x, Version: %s, Cipher: %s\\n\",\n+                                                     connfd, (*OSSL_get_version)(ssl), (*OSSL_get_cipher)(ssl));\n+   return true;\n+   }\n \n TR_Listener::TR_Listener()\n    : _listenerThread(NULL), _listenerMonitor(NULL), _listenerOSThread(NULL), \n    _listenerThreadAttachAttempted(false), _listenerThreadExitFlag(false)\n    {\n    }\n \n+void\n+TR_Listener::serveRemoteCompilationRequests(BaseCompileDispatcher *compiler)\n+   {\n+   TR::PersistentInfo *info = getCompilationInfo(jitConfig)->getPersistentInfo();\n+   SSL_CTX *sslCtx = NULL;\n+   if (JITServer::CommunicationStream::useSSL())\n+      {\n+      JITServer::CommunicationStream::initSSL();\n+      sslCtx = createSSLContext(info);\n+      }\n+\n+   uint32_t port = info->getJITServerPort();\n+   uint32_t timeoutMs = info->getSocketTimeout();\n+   struct pollfd pfd = {0};\n+   int sockfd = socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, 0);\n+   if (sockfd < 0)\n+      {\n+      perror(\"can't open server socket\");\n+      exit(1);\n+      }\n+\n+   // see `man 7 socket` for option explanations\n+   int flag = true;\n+   if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, (void *)&flag, sizeof(flag)) < 0)\n+      {\n+      perror(\"Can't set SO_REUSEADDR\");\n+      exit(-1);\n+      }\n+   if (setsockopt(sockfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&flag, sizeof(flag)) < 0)\n+      {\n+      perror(\"Can't set SO_KEEPALIVE\");\n+      exit(-1);\n+      }\n+\n+   struct sockaddr_in serv_addr;\n+   memset((char *)&serv_addr, 0, sizeof(serv_addr));\n+   serv_addr.sin_family = AF_INET;\n+   serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);\n+   serv_addr.sin_port = htons(port);\n+\n+   if (bind(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0)\n+      {\n+      perror(\"can't bind server address\");\n+      exit(1);\n+      }\n+   if (listen(sockfd, SOMAXCONN) < 0)\n+      {\n+      perror(\"listen failed\");\n+      exit(1);\n+      }\n+\n+   pfd.fd = sockfd;\n+   pfd.events = POLLIN;\n+\n+   while (!getListenerThreadExitFlag())\n+      {\n+      int32_t rc = 0;\n+      struct sockaddr_in cli_addr;\n+      socklen_t clilen = sizeof(cli_addr);\n+\n+      rc = poll(&pfd, 1, OPENJ9_LISTENER_POLL_TIMEOUT);\n+      if ((rc == 0) && getListenerThreadExitFlag())\n+         {\n+         break;\n+         }\n+      else if (rc < 0)\n+         {\n+         if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+            TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"Error in polling socket: errno=%d\", errno);\n+\t exit(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25b5d856e087db5e896c501a3706fc370ed8f867"}, "originalPosition": 246}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg4ODAzNg==", "bodyText": "Done.", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r391888036", "createdAt": "2020-03-12T20:53:38Z", "author": {"login": "ashu-mehra"}, "path": "runtime/compiler/runtime/Listener.cpp", "diffHunk": "@@ -20,18 +20,284 @@\n  * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n  *******************************************************************************/\n \n-#include \"runtime/Listener.hpp\"\n-#include \"net/ServerStream.hpp\"\n+#include <arpa/inet.h>\n+#include <chrono>\n+#include <fcntl.h>\n+#include <netdb.h>\n+#include <netinet/in.h>\n+#include <netinet/tcp.h>\t/* for TCP_NODELAY option */\n+#include <openssl/err.h>\n+#include <poll.h>\n+#include <sys/types.h>\n+#include <sys/socket.h>\n+#include <sys/un.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <unistd.h> /// gethostname, read, write\n+#include \"control/CompilationRuntime.hpp\"\n+#include \"env/TRMemory.hpp\"\n #include \"env/VMJ9.h\"\n+#include \"net/CommunicationStream.hpp\"\n+#include \"net/LoadSSLLibs.hpp\"\n+#include \"net/ServerStream.hpp\"\n+#include \"net/SSLProtobufStream.hpp\"\n #include \"runtime/CompileService.hpp\"\n-#include \"control/CompilationRuntime.hpp\"\n+#include \"runtime/Listener.hpp\"\n+\n+static SSL_CTX *\n+createSSLContext(TR::PersistentInfo *info)\n+   {\n+   SSL_CTX *ctx = (*OSSL_CTX_new)((*OSSLv23_server_method)());\n+\n+   if (!ctx)\n+      {\n+      perror(\"can't create SSL context\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   const char *sessionIDContext = \"JITServer\";\n+   (*OSSL_CTX_set_session_id_context)(ctx, (const unsigned char*)sessionIDContext, strlen(sessionIDContext));\n+\n+   if ((*OSSL_CTX_set_ecdh_auto)(ctx, 1) != 1)\n+      {\n+      perror(\"failed to configure SSL ecdh\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   TR::CompilationInfo *compInfo = TR::CompilationInfo::get();\n+   auto &sslKeys = compInfo->getJITServerSslKeys();\n+   auto &sslCerts = compInfo->getJITServerSslCerts();\n+   auto &sslRootCerts = compInfo->getJITServerSslRootCerts();\n+\n+   TR_ASSERT_FATAL(sslKeys.size() == 1 && sslCerts.size() == 1, \"only one key and cert is supported for now\");\n+   TR_ASSERT_FATAL(sslRootCerts.size() == 0, \"server does not understand root certs yet\");\n+\n+   // Parse and set private key\n+   BIO *keyMem = (*OBIO_new_mem_buf)(&sslKeys[0][0], sslKeys[0].size());\n+   if (!keyMem)\n+      {\n+      perror(\"cannot create memory buffer for private key (OOM?)\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   EVP_PKEY *privKey = (*OPEM_read_bio_PrivateKey)(keyMem, NULL, NULL, NULL);\n+   if (!privKey)\n+      {\n+      perror(\"cannot parse private key\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   if ((*OSSL_CTX_use_PrivateKey)(ctx, privKey) != 1)\n+      {\n+      perror(\"cannot use private key\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // Parse and set certificate\n+   BIO *certMem = (*OBIO_new_mem_buf)(&sslCerts[0][0], sslCerts[0].size());\n+   if (!certMem)\n+      {\n+      perror(\"cannot create memory buffer for cert (OOM?)\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   X509 *certificate = (*OPEM_read_bio_X509)(certMem, NULL, NULL, NULL);\n+   if (!certificate)\n+      {\n+      perror(\"cannot parse cert\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   if ((*OSSL_CTX_use_certificate)(ctx, certificate) != 1)\n+      {\n+      perror(\"cannot use cert\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // Verify key and cert are valid\n+   if ((*OSSL_CTX_check_private_key)(ctx) != 1)\n+      {\n+      perror(\"private key check failed\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // verify server identity using standard method\n+   (*OSSL_CTX_set_verify)(ctx, SSL_VERIFY_PEER, NULL);\n+\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+      TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"Successfully initialized SSL context (%s)\\n\", (*OOpenSSL_version)(0));\n+\n+   return ctx;\n+   }\n+\n+static bool\n+handleOpenSSLConnectionError(int connfd, SSL *&ssl, BIO *&bio, const char *errMsg)\n+{\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+       TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"%s: errno=%d\", errMsg, errno);\n+   (*OERR_print_errors_fp)(stderr);\n+\n+   close(connfd);\n+   if (bio)\n+      {\n+      (*OBIO_free_all)(bio);\n+      bio = NULL;\n+      }\n+   if (ssl)\n+      {\n+      (*OSSL_free)(ssl);\n+      ssl = NULL;\n+      }\n+   return false;\n+}\n+\n+static bool\n+acceptOpenSSLConnection(SSL_CTX *sslCtx, int connfd, BIO *&bio)\n+   {\n+   SSL *ssl = (*OSSL_new)(sslCtx);\n+   if (!ssl)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error creating SSL connection\");\n+\n+   (*OSSL_set_accept_state)(ssl);\n+\n+   if ((*OSSL_set_fd)(ssl, connfd) != 1)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error setting SSL file descriptor\");\n+\n+   if ((*OSSL_accept)(ssl) <= 0)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error accepting SSL connection\");\n+\n+   bio = (*OBIO_new_ssl)(sslCtx, false);\n+   if (!bio)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error creating new BIO\");\n+\n+   if ((*OBIO_ctrl)(bio, BIO_C_SET_SSL, true, (char *)ssl) != 1) // BIO_set_ssl(bio, ssl, true)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error setting BIO SSL\");\n+\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+      TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"SSL connection on socket 0x%x, Version: %s, Cipher: %s\\n\",\n+                                                     connfd, (*OSSL_get_version)(ssl), (*OSSL_get_cipher)(ssl));\n+   return true;\n+   }\n \n TR_Listener::TR_Listener()\n    : _listenerThread(NULL), _listenerMonitor(NULL), _listenerOSThread(NULL), \n    _listenerThreadAttachAttempted(false), _listenerThreadExitFlag(false)\n    {\n    }\n \n+void\n+TR_Listener::serveRemoteCompilationRequests(BaseCompileDispatcher *compiler)\n+   {\n+   TR::PersistentInfo *info = getCompilationInfo(jitConfig)->getPersistentInfo();\n+   SSL_CTX *sslCtx = NULL;\n+   if (JITServer::CommunicationStream::useSSL())\n+      {\n+      JITServer::CommunicationStream::initSSL();\n+      sslCtx = createSSLContext(info);\n+      }\n+\n+   uint32_t port = info->getJITServerPort();\n+   uint32_t timeoutMs = info->getSocketTimeout();\n+   struct pollfd pfd = {0};\n+   int sockfd = socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, 0);\n+   if (sockfd < 0)\n+      {\n+      perror(\"can't open server socket\");\n+      exit(1);\n+      }\n+\n+   // see `man 7 socket` for option explanations\n+   int flag = true;\n+   if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, (void *)&flag, sizeof(flag)) < 0)\n+      {\n+      perror(\"Can't set SO_REUSEADDR\");\n+      exit(-1);\n+      }\n+   if (setsockopt(sockfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&flag, sizeof(flag)) < 0)\n+      {\n+      perror(\"Can't set SO_KEEPALIVE\");\n+      exit(-1);\n+      }\n+\n+   struct sockaddr_in serv_addr;\n+   memset((char *)&serv_addr, 0, sizeof(serv_addr));\n+   serv_addr.sin_family = AF_INET;\n+   serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);\n+   serv_addr.sin_port = htons(port);\n+\n+   if (bind(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0)\n+      {\n+      perror(\"can't bind server address\");\n+      exit(1);\n+      }\n+   if (listen(sockfd, SOMAXCONN) < 0)\n+      {\n+      perror(\"listen failed\");\n+      exit(1);\n+      }\n+\n+   pfd.fd = sockfd;\n+   pfd.events = POLLIN;\n+\n+   while (!getListenerThreadExitFlag())\n+      {\n+      int32_t rc = 0;\n+      struct sockaddr_in cli_addr;\n+      socklen_t clilen = sizeof(cli_addr);\n+\n+      rc = poll(&pfd, 1, OPENJ9_LISTENER_POLL_TIMEOUT);\n+      if ((rc == 0) && getListenerThreadExitFlag())\n+         {\n+         break;\n+         }\n+      else if (rc < 0)\n+         {\n+         if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+            TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"Error in polling socket: errno=%d\", errno);\n+\t exit(1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc5ODc3MQ=="}, "originalCommit": {"oid": "25b5d856e087db5e896c501a3706fc370ed8f867"}, "originalPosition": 246}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyODI2NDQ1OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/runtime/Listener.hpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxODoyNTozNVrOF1qRRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQyMDo1Mzo0M1rOF1u8xw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgxMTM5Ng==", "bodyText": "Comment needs to be changed to reflect the new implementation.", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r391811396", "createdAt": "2020-03-12T18:25:35Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/runtime/Listener.hpp", "diffHunk": "@@ -37,12 +38,33 @@\n  \n     The current implementation does not provide code for nicely terminating the listener thread.\n  */\n+\n+#define OPENJ9_LISTENER_POLL_TIMEOUT 10 // in milliseconds\n+\n+class BaseCompileDispatcher;\n+\n class TR_Listener\n    {\n public:\n    TR_Listener();\n    static TR_Listener* allocate();\n    void startListenerThread(J9JavaVM *javaVM);\n+   void stop();\n+   /**\n+      @brief Function called to deal with incoming connection requests\n+\n+      This function opens a socket, binds it and then waits for incoming connection", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25b5d856e087db5e896c501a3706fc370ed8f867"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg4ODA3MQ==", "bodyText": "Done.", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r391888071", "createdAt": "2020-03-12T20:53:43Z", "author": {"login": "ashu-mehra"}, "path": "runtime/compiler/runtime/Listener.hpp", "diffHunk": "@@ -37,12 +38,33 @@\n  \n     The current implementation does not provide code for nicely terminating the listener thread.\n  */\n+\n+#define OPENJ9_LISTENER_POLL_TIMEOUT 10 // in milliseconds\n+\n+class BaseCompileDispatcher;\n+\n class TR_Listener\n    {\n public:\n    TR_Listener();\n    static TR_Listener* allocate();\n    void startListenerThread(J9JavaVM *javaVM);\n+   void stop();\n+   /**\n+      @brief Function called to deal with incoming connection requests\n+\n+      This function opens a socket, binds it and then waits for incoming connection", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgxMTM5Ng=="}, "originalCommit": {"oid": "25b5d856e087db5e896c501a3706fc370ed8f867"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyODI2NjgwOnYy", "diffSide": "RIGHT", "path": "runtime/compiler/runtime/Listener.hpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxODoyNjoyMlrOF1qSyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQyMDozNjo1OFrOF1ufNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgxMTc4Ng==", "bodyText": "Should we increase this to 100 ms?", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r391811786", "createdAt": "2020-03-12T18:26:22Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/runtime/Listener.hpp", "diffHunk": "@@ -37,12 +38,33 @@\n  \n     The current implementation does not provide code for nicely terminating the listener thread.\n  */\n+\n+#define OPENJ9_LISTENER_POLL_TIMEOUT 10 // in milliseconds", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25b5d856e087db5e896c501a3706fc370ed8f867"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg4MDUwMA==", "bodyText": "10 ms was just a random value. We can set the timeout to 100 ms. The larger it is, the lesser it would wake up to check the flag.", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r391880500", "createdAt": "2020-03-12T20:36:58Z", "author": {"login": "ashu-mehra"}, "path": "runtime/compiler/runtime/Listener.hpp", "diffHunk": "@@ -37,12 +38,33 @@\n  \n     The current implementation does not provide code for nicely terminating the listener thread.\n  */\n+\n+#define OPENJ9_LISTENER_POLL_TIMEOUT 10 // in milliseconds", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgxMTc4Ng=="}, "originalCommit": {"oid": "25b5d856e087db5e896c501a3706fc370ed8f867"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyODM1ODEzOnYy", "diffSide": "RIGHT", "path": "runtime/compiler/runtime/Listener.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxODo1NDowOFrOF1rM-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQyMDo0MTo1OFrOF1uoTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgyNjY4MQ==", "bodyText": "Is it possible for poll to fail with EINTR error code and still be able to continue?", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r391826681", "createdAt": "2020-03-12T18:54:08Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/runtime/Listener.cpp", "diffHunk": "@@ -20,18 +20,284 @@\n  * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n  *******************************************************************************/\n \n-#include \"runtime/Listener.hpp\"\n-#include \"net/ServerStream.hpp\"\n+#include <arpa/inet.h>\n+#include <chrono>\n+#include <fcntl.h>\n+#include <netdb.h>\n+#include <netinet/in.h>\n+#include <netinet/tcp.h>\t/* for TCP_NODELAY option */\n+#include <openssl/err.h>\n+#include <poll.h>\n+#include <sys/types.h>\n+#include <sys/socket.h>\n+#include <sys/un.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <unistd.h> /// gethostname, read, write\n+#include \"control/CompilationRuntime.hpp\"\n+#include \"env/TRMemory.hpp\"\n #include \"env/VMJ9.h\"\n+#include \"net/CommunicationStream.hpp\"\n+#include \"net/LoadSSLLibs.hpp\"\n+#include \"net/ServerStream.hpp\"\n+#include \"net/SSLProtobufStream.hpp\"\n #include \"runtime/CompileService.hpp\"\n-#include \"control/CompilationRuntime.hpp\"\n+#include \"runtime/Listener.hpp\"\n+\n+static SSL_CTX *\n+createSSLContext(TR::PersistentInfo *info)\n+   {\n+   SSL_CTX *ctx = (*OSSL_CTX_new)((*OSSLv23_server_method)());\n+\n+   if (!ctx)\n+      {\n+      perror(\"can't create SSL context\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   const char *sessionIDContext = \"JITServer\";\n+   (*OSSL_CTX_set_session_id_context)(ctx, (const unsigned char*)sessionIDContext, strlen(sessionIDContext));\n+\n+   if ((*OSSL_CTX_set_ecdh_auto)(ctx, 1) != 1)\n+      {\n+      perror(\"failed to configure SSL ecdh\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   TR::CompilationInfo *compInfo = TR::CompilationInfo::get();\n+   auto &sslKeys = compInfo->getJITServerSslKeys();\n+   auto &sslCerts = compInfo->getJITServerSslCerts();\n+   auto &sslRootCerts = compInfo->getJITServerSslRootCerts();\n+\n+   TR_ASSERT_FATAL(sslKeys.size() == 1 && sslCerts.size() == 1, \"only one key and cert is supported for now\");\n+   TR_ASSERT_FATAL(sslRootCerts.size() == 0, \"server does not understand root certs yet\");\n+\n+   // Parse and set private key\n+   BIO *keyMem = (*OBIO_new_mem_buf)(&sslKeys[0][0], sslKeys[0].size());\n+   if (!keyMem)\n+      {\n+      perror(\"cannot create memory buffer for private key (OOM?)\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   EVP_PKEY *privKey = (*OPEM_read_bio_PrivateKey)(keyMem, NULL, NULL, NULL);\n+   if (!privKey)\n+      {\n+      perror(\"cannot parse private key\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   if ((*OSSL_CTX_use_PrivateKey)(ctx, privKey) != 1)\n+      {\n+      perror(\"cannot use private key\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // Parse and set certificate\n+   BIO *certMem = (*OBIO_new_mem_buf)(&sslCerts[0][0], sslCerts[0].size());\n+   if (!certMem)\n+      {\n+      perror(\"cannot create memory buffer for cert (OOM?)\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   X509 *certificate = (*OPEM_read_bio_X509)(certMem, NULL, NULL, NULL);\n+   if (!certificate)\n+      {\n+      perror(\"cannot parse cert\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   if ((*OSSL_CTX_use_certificate)(ctx, certificate) != 1)\n+      {\n+      perror(\"cannot use cert\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // Verify key and cert are valid\n+   if ((*OSSL_CTX_check_private_key)(ctx) != 1)\n+      {\n+      perror(\"private key check failed\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // verify server identity using standard method\n+   (*OSSL_CTX_set_verify)(ctx, SSL_VERIFY_PEER, NULL);\n+\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+      TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"Successfully initialized SSL context (%s)\\n\", (*OOpenSSL_version)(0));\n+\n+   return ctx;\n+   }\n+\n+static bool\n+handleOpenSSLConnectionError(int connfd, SSL *&ssl, BIO *&bio, const char *errMsg)\n+{\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+       TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"%s: errno=%d\", errMsg, errno);\n+   (*OERR_print_errors_fp)(stderr);\n+\n+   close(connfd);\n+   if (bio)\n+      {\n+      (*OBIO_free_all)(bio);\n+      bio = NULL;\n+      }\n+   if (ssl)\n+      {\n+      (*OSSL_free)(ssl);\n+      ssl = NULL;\n+      }\n+   return false;\n+}\n+\n+static bool\n+acceptOpenSSLConnection(SSL_CTX *sslCtx, int connfd, BIO *&bio)\n+   {\n+   SSL *ssl = (*OSSL_new)(sslCtx);\n+   if (!ssl)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error creating SSL connection\");\n+\n+   (*OSSL_set_accept_state)(ssl);\n+\n+   if ((*OSSL_set_fd)(ssl, connfd) != 1)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error setting SSL file descriptor\");\n+\n+   if ((*OSSL_accept)(ssl) <= 0)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error accepting SSL connection\");\n+\n+   bio = (*OBIO_new_ssl)(sslCtx, false);\n+   if (!bio)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error creating new BIO\");\n+\n+   if ((*OBIO_ctrl)(bio, BIO_C_SET_SSL, true, (char *)ssl) != 1) // BIO_set_ssl(bio, ssl, true)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error setting BIO SSL\");\n+\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+      TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"SSL connection on socket 0x%x, Version: %s, Cipher: %s\\n\",\n+                                                     connfd, (*OSSL_get_version)(ssl), (*OSSL_get_cipher)(ssl));\n+   return true;\n+   }\n \n TR_Listener::TR_Listener()\n    : _listenerThread(NULL), _listenerMonitor(NULL), _listenerOSThread(NULL), \n    _listenerThreadAttachAttempted(false), _listenerThreadExitFlag(false)\n    {\n    }\n \n+void\n+TR_Listener::serveRemoteCompilationRequests(BaseCompileDispatcher *compiler)\n+   {\n+   TR::PersistentInfo *info = getCompilationInfo(jitConfig)->getPersistentInfo();\n+   SSL_CTX *sslCtx = NULL;\n+   if (JITServer::CommunicationStream::useSSL())\n+      {\n+      JITServer::CommunicationStream::initSSL();\n+      sslCtx = createSSLContext(info);\n+      }\n+\n+   uint32_t port = info->getJITServerPort();\n+   uint32_t timeoutMs = info->getSocketTimeout();\n+   struct pollfd pfd = {0};\n+   int sockfd = socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, 0);\n+   if (sockfd < 0)\n+      {\n+      perror(\"can't open server socket\");\n+      exit(1);\n+      }\n+\n+   // see `man 7 socket` for option explanations\n+   int flag = true;\n+   if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, (void *)&flag, sizeof(flag)) < 0)\n+      {\n+      perror(\"Can't set SO_REUSEADDR\");\n+      exit(-1);\n+      }\n+   if (setsockopt(sockfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&flag, sizeof(flag)) < 0)\n+      {\n+      perror(\"Can't set SO_KEEPALIVE\");\n+      exit(-1);\n+      }\n+\n+   struct sockaddr_in serv_addr;\n+   memset((char *)&serv_addr, 0, sizeof(serv_addr));\n+   serv_addr.sin_family = AF_INET;\n+   serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);\n+   serv_addr.sin_port = htons(port);\n+\n+   if (bind(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0)\n+      {\n+      perror(\"can't bind server address\");\n+      exit(1);\n+      }\n+   if (listen(sockfd, SOMAXCONN) < 0)\n+      {\n+      perror(\"listen failed\");\n+      exit(1);\n+      }\n+\n+   pfd.fd = sockfd;\n+   pfd.events = POLLIN;\n+\n+   while (!getListenerThreadExitFlag())\n+      {\n+      int32_t rc = 0;\n+      struct sockaddr_in cli_addr;\n+      socklen_t clilen = sizeof(cli_addr);\n+\n+      rc = poll(&pfd, 1, OPENJ9_LISTENER_POLL_TIMEOUT);\n+      if ((rc == 0) && getListenerThreadExitFlag())\n+         {\n+         break;\n+         }\n+      else if (rc < 0)\n+         {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25b5d856e087db5e896c501a3706fc370ed8f867"}, "originalPosition": 243}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg4MjgzMQ==", "bodyText": "yup, added check for EINTR and continue.", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r391882831", "createdAt": "2020-03-12T20:41:58Z", "author": {"login": "ashu-mehra"}, "path": "runtime/compiler/runtime/Listener.cpp", "diffHunk": "@@ -20,18 +20,284 @@\n  * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n  *******************************************************************************/\n \n-#include \"runtime/Listener.hpp\"\n-#include \"net/ServerStream.hpp\"\n+#include <arpa/inet.h>\n+#include <chrono>\n+#include <fcntl.h>\n+#include <netdb.h>\n+#include <netinet/in.h>\n+#include <netinet/tcp.h>\t/* for TCP_NODELAY option */\n+#include <openssl/err.h>\n+#include <poll.h>\n+#include <sys/types.h>\n+#include <sys/socket.h>\n+#include <sys/un.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <unistd.h> /// gethostname, read, write\n+#include \"control/CompilationRuntime.hpp\"\n+#include \"env/TRMemory.hpp\"\n #include \"env/VMJ9.h\"\n+#include \"net/CommunicationStream.hpp\"\n+#include \"net/LoadSSLLibs.hpp\"\n+#include \"net/ServerStream.hpp\"\n+#include \"net/SSLProtobufStream.hpp\"\n #include \"runtime/CompileService.hpp\"\n-#include \"control/CompilationRuntime.hpp\"\n+#include \"runtime/Listener.hpp\"\n+\n+static SSL_CTX *\n+createSSLContext(TR::PersistentInfo *info)\n+   {\n+   SSL_CTX *ctx = (*OSSL_CTX_new)((*OSSLv23_server_method)());\n+\n+   if (!ctx)\n+      {\n+      perror(\"can't create SSL context\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   const char *sessionIDContext = \"JITServer\";\n+   (*OSSL_CTX_set_session_id_context)(ctx, (const unsigned char*)sessionIDContext, strlen(sessionIDContext));\n+\n+   if ((*OSSL_CTX_set_ecdh_auto)(ctx, 1) != 1)\n+      {\n+      perror(\"failed to configure SSL ecdh\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   TR::CompilationInfo *compInfo = TR::CompilationInfo::get();\n+   auto &sslKeys = compInfo->getJITServerSslKeys();\n+   auto &sslCerts = compInfo->getJITServerSslCerts();\n+   auto &sslRootCerts = compInfo->getJITServerSslRootCerts();\n+\n+   TR_ASSERT_FATAL(sslKeys.size() == 1 && sslCerts.size() == 1, \"only one key and cert is supported for now\");\n+   TR_ASSERT_FATAL(sslRootCerts.size() == 0, \"server does not understand root certs yet\");\n+\n+   // Parse and set private key\n+   BIO *keyMem = (*OBIO_new_mem_buf)(&sslKeys[0][0], sslKeys[0].size());\n+   if (!keyMem)\n+      {\n+      perror(\"cannot create memory buffer for private key (OOM?)\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   EVP_PKEY *privKey = (*OPEM_read_bio_PrivateKey)(keyMem, NULL, NULL, NULL);\n+   if (!privKey)\n+      {\n+      perror(\"cannot parse private key\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   if ((*OSSL_CTX_use_PrivateKey)(ctx, privKey) != 1)\n+      {\n+      perror(\"cannot use private key\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // Parse and set certificate\n+   BIO *certMem = (*OBIO_new_mem_buf)(&sslCerts[0][0], sslCerts[0].size());\n+   if (!certMem)\n+      {\n+      perror(\"cannot create memory buffer for cert (OOM?)\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   X509 *certificate = (*OPEM_read_bio_X509)(certMem, NULL, NULL, NULL);\n+   if (!certificate)\n+      {\n+      perror(\"cannot parse cert\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   if ((*OSSL_CTX_use_certificate)(ctx, certificate) != 1)\n+      {\n+      perror(\"cannot use cert\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // Verify key and cert are valid\n+   if ((*OSSL_CTX_check_private_key)(ctx) != 1)\n+      {\n+      perror(\"private key check failed\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // verify server identity using standard method\n+   (*OSSL_CTX_set_verify)(ctx, SSL_VERIFY_PEER, NULL);\n+\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+      TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"Successfully initialized SSL context (%s)\\n\", (*OOpenSSL_version)(0));\n+\n+   return ctx;\n+   }\n+\n+static bool\n+handleOpenSSLConnectionError(int connfd, SSL *&ssl, BIO *&bio, const char *errMsg)\n+{\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+       TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"%s: errno=%d\", errMsg, errno);\n+   (*OERR_print_errors_fp)(stderr);\n+\n+   close(connfd);\n+   if (bio)\n+      {\n+      (*OBIO_free_all)(bio);\n+      bio = NULL;\n+      }\n+   if (ssl)\n+      {\n+      (*OSSL_free)(ssl);\n+      ssl = NULL;\n+      }\n+   return false;\n+}\n+\n+static bool\n+acceptOpenSSLConnection(SSL_CTX *sslCtx, int connfd, BIO *&bio)\n+   {\n+   SSL *ssl = (*OSSL_new)(sslCtx);\n+   if (!ssl)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error creating SSL connection\");\n+\n+   (*OSSL_set_accept_state)(ssl);\n+\n+   if ((*OSSL_set_fd)(ssl, connfd) != 1)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error setting SSL file descriptor\");\n+\n+   if ((*OSSL_accept)(ssl) <= 0)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error accepting SSL connection\");\n+\n+   bio = (*OBIO_new_ssl)(sslCtx, false);\n+   if (!bio)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error creating new BIO\");\n+\n+   if ((*OBIO_ctrl)(bio, BIO_C_SET_SSL, true, (char *)ssl) != 1) // BIO_set_ssl(bio, ssl, true)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error setting BIO SSL\");\n+\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+      TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"SSL connection on socket 0x%x, Version: %s, Cipher: %s\\n\",\n+                                                     connfd, (*OSSL_get_version)(ssl), (*OSSL_get_cipher)(ssl));\n+   return true;\n+   }\n \n TR_Listener::TR_Listener()\n    : _listenerThread(NULL), _listenerMonitor(NULL), _listenerOSThread(NULL), \n    _listenerThreadAttachAttempted(false), _listenerThreadExitFlag(false)\n    {\n    }\n \n+void\n+TR_Listener::serveRemoteCompilationRequests(BaseCompileDispatcher *compiler)\n+   {\n+   TR::PersistentInfo *info = getCompilationInfo(jitConfig)->getPersistentInfo();\n+   SSL_CTX *sslCtx = NULL;\n+   if (JITServer::CommunicationStream::useSSL())\n+      {\n+      JITServer::CommunicationStream::initSSL();\n+      sslCtx = createSSLContext(info);\n+      }\n+\n+   uint32_t port = info->getJITServerPort();\n+   uint32_t timeoutMs = info->getSocketTimeout();\n+   struct pollfd pfd = {0};\n+   int sockfd = socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, 0);\n+   if (sockfd < 0)\n+      {\n+      perror(\"can't open server socket\");\n+      exit(1);\n+      }\n+\n+   // see `man 7 socket` for option explanations\n+   int flag = true;\n+   if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, (void *)&flag, sizeof(flag)) < 0)\n+      {\n+      perror(\"Can't set SO_REUSEADDR\");\n+      exit(-1);\n+      }\n+   if (setsockopt(sockfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&flag, sizeof(flag)) < 0)\n+      {\n+      perror(\"Can't set SO_KEEPALIVE\");\n+      exit(-1);\n+      }\n+\n+   struct sockaddr_in serv_addr;\n+   memset((char *)&serv_addr, 0, sizeof(serv_addr));\n+   serv_addr.sin_family = AF_INET;\n+   serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);\n+   serv_addr.sin_port = htons(port);\n+\n+   if (bind(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0)\n+      {\n+      perror(\"can't bind server address\");\n+      exit(1);\n+      }\n+   if (listen(sockfd, SOMAXCONN) < 0)\n+      {\n+      perror(\"listen failed\");\n+      exit(1);\n+      }\n+\n+   pfd.fd = sockfd;\n+   pfd.events = POLLIN;\n+\n+   while (!getListenerThreadExitFlag())\n+      {\n+      int32_t rc = 0;\n+      struct sockaddr_in cli_addr;\n+      socklen_t clilen = sizeof(cli_addr);\n+\n+      rc = poll(&pfd, 1, OPENJ9_LISTENER_POLL_TIMEOUT);\n+      if ((rc == 0) && getListenerThreadExitFlag())\n+         {\n+         break;\n+         }\n+      else if (rc < 0)\n+         {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgyNjY4MQ=="}, "originalCommit": {"oid": "25b5d856e087db5e896c501a3706fc370ed8f867"}, "originalPosition": 243}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyODM1OTQ0OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/runtime/Listener.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxODo1NDozMVrOF1rNwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQyMDo0MTo1NVrOF1uoOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgyNjg4Mg==", "bodyText": "If the exit flag is set and we have an incomming connection request we will proceed with the connection request. I believe we still want to exit without handling this request.", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r391826882", "createdAt": "2020-03-12T18:54:31Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/runtime/Listener.cpp", "diffHunk": "@@ -20,18 +20,284 @@\n  * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n  *******************************************************************************/\n \n-#include \"runtime/Listener.hpp\"\n-#include \"net/ServerStream.hpp\"\n+#include <arpa/inet.h>\n+#include <chrono>\n+#include <fcntl.h>\n+#include <netdb.h>\n+#include <netinet/in.h>\n+#include <netinet/tcp.h>\t/* for TCP_NODELAY option */\n+#include <openssl/err.h>\n+#include <poll.h>\n+#include <sys/types.h>\n+#include <sys/socket.h>\n+#include <sys/un.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <unistd.h> /// gethostname, read, write\n+#include \"control/CompilationRuntime.hpp\"\n+#include \"env/TRMemory.hpp\"\n #include \"env/VMJ9.h\"\n+#include \"net/CommunicationStream.hpp\"\n+#include \"net/LoadSSLLibs.hpp\"\n+#include \"net/ServerStream.hpp\"\n+#include \"net/SSLProtobufStream.hpp\"\n #include \"runtime/CompileService.hpp\"\n-#include \"control/CompilationRuntime.hpp\"\n+#include \"runtime/Listener.hpp\"\n+\n+static SSL_CTX *\n+createSSLContext(TR::PersistentInfo *info)\n+   {\n+   SSL_CTX *ctx = (*OSSL_CTX_new)((*OSSLv23_server_method)());\n+\n+   if (!ctx)\n+      {\n+      perror(\"can't create SSL context\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   const char *sessionIDContext = \"JITServer\";\n+   (*OSSL_CTX_set_session_id_context)(ctx, (const unsigned char*)sessionIDContext, strlen(sessionIDContext));\n+\n+   if ((*OSSL_CTX_set_ecdh_auto)(ctx, 1) != 1)\n+      {\n+      perror(\"failed to configure SSL ecdh\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   TR::CompilationInfo *compInfo = TR::CompilationInfo::get();\n+   auto &sslKeys = compInfo->getJITServerSslKeys();\n+   auto &sslCerts = compInfo->getJITServerSslCerts();\n+   auto &sslRootCerts = compInfo->getJITServerSslRootCerts();\n+\n+   TR_ASSERT_FATAL(sslKeys.size() == 1 && sslCerts.size() == 1, \"only one key and cert is supported for now\");\n+   TR_ASSERT_FATAL(sslRootCerts.size() == 0, \"server does not understand root certs yet\");\n+\n+   // Parse and set private key\n+   BIO *keyMem = (*OBIO_new_mem_buf)(&sslKeys[0][0], sslKeys[0].size());\n+   if (!keyMem)\n+      {\n+      perror(\"cannot create memory buffer for private key (OOM?)\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   EVP_PKEY *privKey = (*OPEM_read_bio_PrivateKey)(keyMem, NULL, NULL, NULL);\n+   if (!privKey)\n+      {\n+      perror(\"cannot parse private key\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   if ((*OSSL_CTX_use_PrivateKey)(ctx, privKey) != 1)\n+      {\n+      perror(\"cannot use private key\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // Parse and set certificate\n+   BIO *certMem = (*OBIO_new_mem_buf)(&sslCerts[0][0], sslCerts[0].size());\n+   if (!certMem)\n+      {\n+      perror(\"cannot create memory buffer for cert (OOM?)\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   X509 *certificate = (*OPEM_read_bio_X509)(certMem, NULL, NULL, NULL);\n+   if (!certificate)\n+      {\n+      perror(\"cannot parse cert\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   if ((*OSSL_CTX_use_certificate)(ctx, certificate) != 1)\n+      {\n+      perror(\"cannot use cert\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // Verify key and cert are valid\n+   if ((*OSSL_CTX_check_private_key)(ctx) != 1)\n+      {\n+      perror(\"private key check failed\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // verify server identity using standard method\n+   (*OSSL_CTX_set_verify)(ctx, SSL_VERIFY_PEER, NULL);\n+\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+      TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"Successfully initialized SSL context (%s)\\n\", (*OOpenSSL_version)(0));\n+\n+   return ctx;\n+   }\n+\n+static bool\n+handleOpenSSLConnectionError(int connfd, SSL *&ssl, BIO *&bio, const char *errMsg)\n+{\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+       TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"%s: errno=%d\", errMsg, errno);\n+   (*OERR_print_errors_fp)(stderr);\n+\n+   close(connfd);\n+   if (bio)\n+      {\n+      (*OBIO_free_all)(bio);\n+      bio = NULL;\n+      }\n+   if (ssl)\n+      {\n+      (*OSSL_free)(ssl);\n+      ssl = NULL;\n+      }\n+   return false;\n+}\n+\n+static bool\n+acceptOpenSSLConnection(SSL_CTX *sslCtx, int connfd, BIO *&bio)\n+   {\n+   SSL *ssl = (*OSSL_new)(sslCtx);\n+   if (!ssl)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error creating SSL connection\");\n+\n+   (*OSSL_set_accept_state)(ssl);\n+\n+   if ((*OSSL_set_fd)(ssl, connfd) != 1)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error setting SSL file descriptor\");\n+\n+   if ((*OSSL_accept)(ssl) <= 0)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error accepting SSL connection\");\n+\n+   bio = (*OBIO_new_ssl)(sslCtx, false);\n+   if (!bio)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error creating new BIO\");\n+\n+   if ((*OBIO_ctrl)(bio, BIO_C_SET_SSL, true, (char *)ssl) != 1) // BIO_set_ssl(bio, ssl, true)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error setting BIO SSL\");\n+\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+      TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"SSL connection on socket 0x%x, Version: %s, Cipher: %s\\n\",\n+                                                     connfd, (*OSSL_get_version)(ssl), (*OSSL_get_cipher)(ssl));\n+   return true;\n+   }\n \n TR_Listener::TR_Listener()\n    : _listenerThread(NULL), _listenerMonitor(NULL), _listenerOSThread(NULL), \n    _listenerThreadAttachAttempted(false), _listenerThreadExitFlag(false)\n    {\n    }\n \n+void\n+TR_Listener::serveRemoteCompilationRequests(BaseCompileDispatcher *compiler)\n+   {\n+   TR::PersistentInfo *info = getCompilationInfo(jitConfig)->getPersistentInfo();\n+   SSL_CTX *sslCtx = NULL;\n+   if (JITServer::CommunicationStream::useSSL())\n+      {\n+      JITServer::CommunicationStream::initSSL();\n+      sslCtx = createSSLContext(info);\n+      }\n+\n+   uint32_t port = info->getJITServerPort();\n+   uint32_t timeoutMs = info->getSocketTimeout();\n+   struct pollfd pfd = {0};\n+   int sockfd = socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, 0);\n+   if (sockfd < 0)\n+      {\n+      perror(\"can't open server socket\");\n+      exit(1);\n+      }\n+\n+   // see `man 7 socket` for option explanations\n+   int flag = true;\n+   if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, (void *)&flag, sizeof(flag)) < 0)\n+      {\n+      perror(\"Can't set SO_REUSEADDR\");\n+      exit(-1);\n+      }\n+   if (setsockopt(sockfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&flag, sizeof(flag)) < 0)\n+      {\n+      perror(\"Can't set SO_KEEPALIVE\");\n+      exit(-1);\n+      }\n+\n+   struct sockaddr_in serv_addr;\n+   memset((char *)&serv_addr, 0, sizeof(serv_addr));\n+   serv_addr.sin_family = AF_INET;\n+   serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);\n+   serv_addr.sin_port = htons(port);\n+\n+   if (bind(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0)\n+      {\n+      perror(\"can't bind server address\");\n+      exit(1);\n+      }\n+   if (listen(sockfd, SOMAXCONN) < 0)\n+      {\n+      perror(\"listen failed\");\n+      exit(1);\n+      }\n+\n+   pfd.fd = sockfd;\n+   pfd.events = POLLIN;\n+\n+   while (!getListenerThreadExitFlag())\n+      {\n+      int32_t rc = 0;\n+      struct sockaddr_in cli_addr;\n+      socklen_t clilen = sizeof(cli_addr);\n+\n+      rc = poll(&pfd, 1, OPENJ9_LISTENER_POLL_TIMEOUT);\n+      if ((rc == 0) && getListenerThreadExitFlag())\n+         {\n+         break;\n+         }\n+      else if (rc < 0)\n+         {\n+         if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+            TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"Error in polling socket: errno=%d\", errno);\n+\t exit(1);\n+         }\n+      int connfd = accept(sockfd, (struct sockaddr *)&cli_addr, &clilen);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25b5d856e087db5e896c501a3706fc370ed8f867"}, "originalPosition": 248}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg4MjgxMQ==", "bodyText": "right, fixed that.", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r391882811", "createdAt": "2020-03-12T20:41:55Z", "author": {"login": "ashu-mehra"}, "path": "runtime/compiler/runtime/Listener.cpp", "diffHunk": "@@ -20,18 +20,284 @@\n  * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n  *******************************************************************************/\n \n-#include \"runtime/Listener.hpp\"\n-#include \"net/ServerStream.hpp\"\n+#include <arpa/inet.h>\n+#include <chrono>\n+#include <fcntl.h>\n+#include <netdb.h>\n+#include <netinet/in.h>\n+#include <netinet/tcp.h>\t/* for TCP_NODELAY option */\n+#include <openssl/err.h>\n+#include <poll.h>\n+#include <sys/types.h>\n+#include <sys/socket.h>\n+#include <sys/un.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <unistd.h> /// gethostname, read, write\n+#include \"control/CompilationRuntime.hpp\"\n+#include \"env/TRMemory.hpp\"\n #include \"env/VMJ9.h\"\n+#include \"net/CommunicationStream.hpp\"\n+#include \"net/LoadSSLLibs.hpp\"\n+#include \"net/ServerStream.hpp\"\n+#include \"net/SSLProtobufStream.hpp\"\n #include \"runtime/CompileService.hpp\"\n-#include \"control/CompilationRuntime.hpp\"\n+#include \"runtime/Listener.hpp\"\n+\n+static SSL_CTX *\n+createSSLContext(TR::PersistentInfo *info)\n+   {\n+   SSL_CTX *ctx = (*OSSL_CTX_new)((*OSSLv23_server_method)());\n+\n+   if (!ctx)\n+      {\n+      perror(\"can't create SSL context\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   const char *sessionIDContext = \"JITServer\";\n+   (*OSSL_CTX_set_session_id_context)(ctx, (const unsigned char*)sessionIDContext, strlen(sessionIDContext));\n+\n+   if ((*OSSL_CTX_set_ecdh_auto)(ctx, 1) != 1)\n+      {\n+      perror(\"failed to configure SSL ecdh\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   TR::CompilationInfo *compInfo = TR::CompilationInfo::get();\n+   auto &sslKeys = compInfo->getJITServerSslKeys();\n+   auto &sslCerts = compInfo->getJITServerSslCerts();\n+   auto &sslRootCerts = compInfo->getJITServerSslRootCerts();\n+\n+   TR_ASSERT_FATAL(sslKeys.size() == 1 && sslCerts.size() == 1, \"only one key and cert is supported for now\");\n+   TR_ASSERT_FATAL(sslRootCerts.size() == 0, \"server does not understand root certs yet\");\n+\n+   // Parse and set private key\n+   BIO *keyMem = (*OBIO_new_mem_buf)(&sslKeys[0][0], sslKeys[0].size());\n+   if (!keyMem)\n+      {\n+      perror(\"cannot create memory buffer for private key (OOM?)\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   EVP_PKEY *privKey = (*OPEM_read_bio_PrivateKey)(keyMem, NULL, NULL, NULL);\n+   if (!privKey)\n+      {\n+      perror(\"cannot parse private key\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   if ((*OSSL_CTX_use_PrivateKey)(ctx, privKey) != 1)\n+      {\n+      perror(\"cannot use private key\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // Parse and set certificate\n+   BIO *certMem = (*OBIO_new_mem_buf)(&sslCerts[0][0], sslCerts[0].size());\n+   if (!certMem)\n+      {\n+      perror(\"cannot create memory buffer for cert (OOM?)\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   X509 *certificate = (*OPEM_read_bio_X509)(certMem, NULL, NULL, NULL);\n+   if (!certificate)\n+      {\n+      perror(\"cannot parse cert\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   if ((*OSSL_CTX_use_certificate)(ctx, certificate) != 1)\n+      {\n+      perror(\"cannot use cert\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // Verify key and cert are valid\n+   if ((*OSSL_CTX_check_private_key)(ctx) != 1)\n+      {\n+      perror(\"private key check failed\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // verify server identity using standard method\n+   (*OSSL_CTX_set_verify)(ctx, SSL_VERIFY_PEER, NULL);\n+\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+      TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"Successfully initialized SSL context (%s)\\n\", (*OOpenSSL_version)(0));\n+\n+   return ctx;\n+   }\n+\n+static bool\n+handleOpenSSLConnectionError(int connfd, SSL *&ssl, BIO *&bio, const char *errMsg)\n+{\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+       TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"%s: errno=%d\", errMsg, errno);\n+   (*OERR_print_errors_fp)(stderr);\n+\n+   close(connfd);\n+   if (bio)\n+      {\n+      (*OBIO_free_all)(bio);\n+      bio = NULL;\n+      }\n+   if (ssl)\n+      {\n+      (*OSSL_free)(ssl);\n+      ssl = NULL;\n+      }\n+   return false;\n+}\n+\n+static bool\n+acceptOpenSSLConnection(SSL_CTX *sslCtx, int connfd, BIO *&bio)\n+   {\n+   SSL *ssl = (*OSSL_new)(sslCtx);\n+   if (!ssl)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error creating SSL connection\");\n+\n+   (*OSSL_set_accept_state)(ssl);\n+\n+   if ((*OSSL_set_fd)(ssl, connfd) != 1)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error setting SSL file descriptor\");\n+\n+   if ((*OSSL_accept)(ssl) <= 0)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error accepting SSL connection\");\n+\n+   bio = (*OBIO_new_ssl)(sslCtx, false);\n+   if (!bio)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error creating new BIO\");\n+\n+   if ((*OBIO_ctrl)(bio, BIO_C_SET_SSL, true, (char *)ssl) != 1) // BIO_set_ssl(bio, ssl, true)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error setting BIO SSL\");\n+\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+      TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"SSL connection on socket 0x%x, Version: %s, Cipher: %s\\n\",\n+                                                     connfd, (*OSSL_get_version)(ssl), (*OSSL_get_cipher)(ssl));\n+   return true;\n+   }\n \n TR_Listener::TR_Listener()\n    : _listenerThread(NULL), _listenerMonitor(NULL), _listenerOSThread(NULL), \n    _listenerThreadAttachAttempted(false), _listenerThreadExitFlag(false)\n    {\n    }\n \n+void\n+TR_Listener::serveRemoteCompilationRequests(BaseCompileDispatcher *compiler)\n+   {\n+   TR::PersistentInfo *info = getCompilationInfo(jitConfig)->getPersistentInfo();\n+   SSL_CTX *sslCtx = NULL;\n+   if (JITServer::CommunicationStream::useSSL())\n+      {\n+      JITServer::CommunicationStream::initSSL();\n+      sslCtx = createSSLContext(info);\n+      }\n+\n+   uint32_t port = info->getJITServerPort();\n+   uint32_t timeoutMs = info->getSocketTimeout();\n+   struct pollfd pfd = {0};\n+   int sockfd = socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, 0);\n+   if (sockfd < 0)\n+      {\n+      perror(\"can't open server socket\");\n+      exit(1);\n+      }\n+\n+   // see `man 7 socket` for option explanations\n+   int flag = true;\n+   if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, (void *)&flag, sizeof(flag)) < 0)\n+      {\n+      perror(\"Can't set SO_REUSEADDR\");\n+      exit(-1);\n+      }\n+   if (setsockopt(sockfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&flag, sizeof(flag)) < 0)\n+      {\n+      perror(\"Can't set SO_KEEPALIVE\");\n+      exit(-1);\n+      }\n+\n+   struct sockaddr_in serv_addr;\n+   memset((char *)&serv_addr, 0, sizeof(serv_addr));\n+   serv_addr.sin_family = AF_INET;\n+   serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);\n+   serv_addr.sin_port = htons(port);\n+\n+   if (bind(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0)\n+      {\n+      perror(\"can't bind server address\");\n+      exit(1);\n+      }\n+   if (listen(sockfd, SOMAXCONN) < 0)\n+      {\n+      perror(\"listen failed\");\n+      exit(1);\n+      }\n+\n+   pfd.fd = sockfd;\n+   pfd.events = POLLIN;\n+\n+   while (!getListenerThreadExitFlag())\n+      {\n+      int32_t rc = 0;\n+      struct sockaddr_in cli_addr;\n+      socklen_t clilen = sizeof(cli_addr);\n+\n+      rc = poll(&pfd, 1, OPENJ9_LISTENER_POLL_TIMEOUT);\n+      if ((rc == 0) && getListenerThreadExitFlag())\n+         {\n+         break;\n+         }\n+      else if (rc < 0)\n+         {\n+         if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+            TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"Error in polling socket: errno=%d\", errno);\n+\t exit(1);\n+         }\n+      int connfd = accept(sockfd, (struct sockaddr *)&cli_addr, &clilen);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgyNjg4Mg=="}, "originalCommit": {"oid": "25b5d856e087db5e896c501a3706fc370ed8f867"}, "originalPosition": 248}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyODM2NjcxOnYy", "diffSide": "RIGHT", "path": "runtime/compiler/runtime/Listener.cpp", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxODo1NjozOFrOF1rSaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxMzo0NDo0MFrOF20xEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgyODA3Mw==", "bodyText": "Do we have to check the flags set in revent? We could have POLLIN/POLLERR/POLLHUP/POLLNVAL", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r391828073", "createdAt": "2020-03-12T18:56:38Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/runtime/Listener.cpp", "diffHunk": "@@ -20,18 +20,284 @@\n  * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n  *******************************************************************************/\n \n-#include \"runtime/Listener.hpp\"\n-#include \"net/ServerStream.hpp\"\n+#include <arpa/inet.h>\n+#include <chrono>\n+#include <fcntl.h>\n+#include <netdb.h>\n+#include <netinet/in.h>\n+#include <netinet/tcp.h>\t/* for TCP_NODELAY option */\n+#include <openssl/err.h>\n+#include <poll.h>\n+#include <sys/types.h>\n+#include <sys/socket.h>\n+#include <sys/un.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <unistd.h> /// gethostname, read, write\n+#include \"control/CompilationRuntime.hpp\"\n+#include \"env/TRMemory.hpp\"\n #include \"env/VMJ9.h\"\n+#include \"net/CommunicationStream.hpp\"\n+#include \"net/LoadSSLLibs.hpp\"\n+#include \"net/ServerStream.hpp\"\n+#include \"net/SSLProtobufStream.hpp\"\n #include \"runtime/CompileService.hpp\"\n-#include \"control/CompilationRuntime.hpp\"\n+#include \"runtime/Listener.hpp\"\n+\n+static SSL_CTX *\n+createSSLContext(TR::PersistentInfo *info)\n+   {\n+   SSL_CTX *ctx = (*OSSL_CTX_new)((*OSSLv23_server_method)());\n+\n+   if (!ctx)\n+      {\n+      perror(\"can't create SSL context\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   const char *sessionIDContext = \"JITServer\";\n+   (*OSSL_CTX_set_session_id_context)(ctx, (const unsigned char*)sessionIDContext, strlen(sessionIDContext));\n+\n+   if ((*OSSL_CTX_set_ecdh_auto)(ctx, 1) != 1)\n+      {\n+      perror(\"failed to configure SSL ecdh\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   TR::CompilationInfo *compInfo = TR::CompilationInfo::get();\n+   auto &sslKeys = compInfo->getJITServerSslKeys();\n+   auto &sslCerts = compInfo->getJITServerSslCerts();\n+   auto &sslRootCerts = compInfo->getJITServerSslRootCerts();\n+\n+   TR_ASSERT_FATAL(sslKeys.size() == 1 && sslCerts.size() == 1, \"only one key and cert is supported for now\");\n+   TR_ASSERT_FATAL(sslRootCerts.size() == 0, \"server does not understand root certs yet\");\n+\n+   // Parse and set private key\n+   BIO *keyMem = (*OBIO_new_mem_buf)(&sslKeys[0][0], sslKeys[0].size());\n+   if (!keyMem)\n+      {\n+      perror(\"cannot create memory buffer for private key (OOM?)\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   EVP_PKEY *privKey = (*OPEM_read_bio_PrivateKey)(keyMem, NULL, NULL, NULL);\n+   if (!privKey)\n+      {\n+      perror(\"cannot parse private key\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   if ((*OSSL_CTX_use_PrivateKey)(ctx, privKey) != 1)\n+      {\n+      perror(\"cannot use private key\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // Parse and set certificate\n+   BIO *certMem = (*OBIO_new_mem_buf)(&sslCerts[0][0], sslCerts[0].size());\n+   if (!certMem)\n+      {\n+      perror(\"cannot create memory buffer for cert (OOM?)\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   X509 *certificate = (*OPEM_read_bio_X509)(certMem, NULL, NULL, NULL);\n+   if (!certificate)\n+      {\n+      perror(\"cannot parse cert\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   if ((*OSSL_CTX_use_certificate)(ctx, certificate) != 1)\n+      {\n+      perror(\"cannot use cert\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // Verify key and cert are valid\n+   if ((*OSSL_CTX_check_private_key)(ctx) != 1)\n+      {\n+      perror(\"private key check failed\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // verify server identity using standard method\n+   (*OSSL_CTX_set_verify)(ctx, SSL_VERIFY_PEER, NULL);\n+\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+      TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"Successfully initialized SSL context (%s)\\n\", (*OOpenSSL_version)(0));\n+\n+   return ctx;\n+   }\n+\n+static bool\n+handleOpenSSLConnectionError(int connfd, SSL *&ssl, BIO *&bio, const char *errMsg)\n+{\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+       TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"%s: errno=%d\", errMsg, errno);\n+   (*OERR_print_errors_fp)(stderr);\n+\n+   close(connfd);\n+   if (bio)\n+      {\n+      (*OBIO_free_all)(bio);\n+      bio = NULL;\n+      }\n+   if (ssl)\n+      {\n+      (*OSSL_free)(ssl);\n+      ssl = NULL;\n+      }\n+   return false;\n+}\n+\n+static bool\n+acceptOpenSSLConnection(SSL_CTX *sslCtx, int connfd, BIO *&bio)\n+   {\n+   SSL *ssl = (*OSSL_new)(sslCtx);\n+   if (!ssl)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error creating SSL connection\");\n+\n+   (*OSSL_set_accept_state)(ssl);\n+\n+   if ((*OSSL_set_fd)(ssl, connfd) != 1)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error setting SSL file descriptor\");\n+\n+   if ((*OSSL_accept)(ssl) <= 0)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error accepting SSL connection\");\n+\n+   bio = (*OBIO_new_ssl)(sslCtx, false);\n+   if (!bio)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error creating new BIO\");\n+\n+   if ((*OBIO_ctrl)(bio, BIO_C_SET_SSL, true, (char *)ssl) != 1) // BIO_set_ssl(bio, ssl, true)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error setting BIO SSL\");\n+\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+      TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"SSL connection on socket 0x%x, Version: %s, Cipher: %s\\n\",\n+                                                     connfd, (*OSSL_get_version)(ssl), (*OSSL_get_cipher)(ssl));\n+   return true;\n+   }\n \n TR_Listener::TR_Listener()\n    : _listenerThread(NULL), _listenerMonitor(NULL), _listenerOSThread(NULL), \n    _listenerThreadAttachAttempted(false), _listenerThreadExitFlag(false)\n    {\n    }\n \n+void\n+TR_Listener::serveRemoteCompilationRequests(BaseCompileDispatcher *compiler)\n+   {\n+   TR::PersistentInfo *info = getCompilationInfo(jitConfig)->getPersistentInfo();\n+   SSL_CTX *sslCtx = NULL;\n+   if (JITServer::CommunicationStream::useSSL())\n+      {\n+      JITServer::CommunicationStream::initSSL();\n+      sslCtx = createSSLContext(info);\n+      }\n+\n+   uint32_t port = info->getJITServerPort();\n+   uint32_t timeoutMs = info->getSocketTimeout();\n+   struct pollfd pfd = {0};\n+   int sockfd = socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, 0);\n+   if (sockfd < 0)\n+      {\n+      perror(\"can't open server socket\");\n+      exit(1);\n+      }\n+\n+   // see `man 7 socket` for option explanations\n+   int flag = true;\n+   if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, (void *)&flag, sizeof(flag)) < 0)\n+      {\n+      perror(\"Can't set SO_REUSEADDR\");\n+      exit(-1);\n+      }\n+   if (setsockopt(sockfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&flag, sizeof(flag)) < 0)\n+      {\n+      perror(\"Can't set SO_KEEPALIVE\");\n+      exit(-1);\n+      }\n+\n+   struct sockaddr_in serv_addr;\n+   memset((char *)&serv_addr, 0, sizeof(serv_addr));\n+   serv_addr.sin_family = AF_INET;\n+   serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);\n+   serv_addr.sin_port = htons(port);\n+\n+   if (bind(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0)\n+      {\n+      perror(\"can't bind server address\");\n+      exit(1);\n+      }\n+   if (listen(sockfd, SOMAXCONN) < 0)\n+      {\n+      perror(\"listen failed\");\n+      exit(1);\n+      }\n+\n+   pfd.fd = sockfd;\n+   pfd.events = POLLIN;\n+\n+   while (!getListenerThreadExitFlag())\n+      {\n+      int32_t rc = 0;\n+      struct sockaddr_in cli_addr;\n+      socklen_t clilen = sizeof(cli_addr);\n+\n+      rc = poll(&pfd, 1, OPENJ9_LISTENER_POLL_TIMEOUT);\n+      if ((rc == 0) && getListenerThreadExitFlag())\n+         {\n+         break;\n+         }\n+      else if (rc < 0)\n+         {\n+         if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+            TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"Error in polling socket: errno=%d\", errno);\n+\t exit(1);\n+         }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25b5d856e087db5e896c501a3706fc370ed8f867"}, "originalPosition": 247}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg3OTY2OA==", "bodyText": "We should never get POLLNVAL as it indicates bad fd.\nPOLLHUP can happen for connected sockets/pipes where one ends gets closed and we try to read from the other end. Again this does not apply to our case.\nPOLLERR indicates \"an asynchronous error occurred\" (http://man7.org/linux/man-pages/man7/socket.7.html). Doesn't look like it applies to listening socket.\nOnly flag left is POLLIN which indicates request for new connection.", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r391879668", "createdAt": "2020-03-12T20:35:01Z", "author": {"login": "ashu-mehra"}, "path": "runtime/compiler/runtime/Listener.cpp", "diffHunk": "@@ -20,18 +20,284 @@\n  * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n  *******************************************************************************/\n \n-#include \"runtime/Listener.hpp\"\n-#include \"net/ServerStream.hpp\"\n+#include <arpa/inet.h>\n+#include <chrono>\n+#include <fcntl.h>\n+#include <netdb.h>\n+#include <netinet/in.h>\n+#include <netinet/tcp.h>\t/* for TCP_NODELAY option */\n+#include <openssl/err.h>\n+#include <poll.h>\n+#include <sys/types.h>\n+#include <sys/socket.h>\n+#include <sys/un.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <unistd.h> /// gethostname, read, write\n+#include \"control/CompilationRuntime.hpp\"\n+#include \"env/TRMemory.hpp\"\n #include \"env/VMJ9.h\"\n+#include \"net/CommunicationStream.hpp\"\n+#include \"net/LoadSSLLibs.hpp\"\n+#include \"net/ServerStream.hpp\"\n+#include \"net/SSLProtobufStream.hpp\"\n #include \"runtime/CompileService.hpp\"\n-#include \"control/CompilationRuntime.hpp\"\n+#include \"runtime/Listener.hpp\"\n+\n+static SSL_CTX *\n+createSSLContext(TR::PersistentInfo *info)\n+   {\n+   SSL_CTX *ctx = (*OSSL_CTX_new)((*OSSLv23_server_method)());\n+\n+   if (!ctx)\n+      {\n+      perror(\"can't create SSL context\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   const char *sessionIDContext = \"JITServer\";\n+   (*OSSL_CTX_set_session_id_context)(ctx, (const unsigned char*)sessionIDContext, strlen(sessionIDContext));\n+\n+   if ((*OSSL_CTX_set_ecdh_auto)(ctx, 1) != 1)\n+      {\n+      perror(\"failed to configure SSL ecdh\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   TR::CompilationInfo *compInfo = TR::CompilationInfo::get();\n+   auto &sslKeys = compInfo->getJITServerSslKeys();\n+   auto &sslCerts = compInfo->getJITServerSslCerts();\n+   auto &sslRootCerts = compInfo->getJITServerSslRootCerts();\n+\n+   TR_ASSERT_FATAL(sslKeys.size() == 1 && sslCerts.size() == 1, \"only one key and cert is supported for now\");\n+   TR_ASSERT_FATAL(sslRootCerts.size() == 0, \"server does not understand root certs yet\");\n+\n+   // Parse and set private key\n+   BIO *keyMem = (*OBIO_new_mem_buf)(&sslKeys[0][0], sslKeys[0].size());\n+   if (!keyMem)\n+      {\n+      perror(\"cannot create memory buffer for private key (OOM?)\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   EVP_PKEY *privKey = (*OPEM_read_bio_PrivateKey)(keyMem, NULL, NULL, NULL);\n+   if (!privKey)\n+      {\n+      perror(\"cannot parse private key\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   if ((*OSSL_CTX_use_PrivateKey)(ctx, privKey) != 1)\n+      {\n+      perror(\"cannot use private key\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // Parse and set certificate\n+   BIO *certMem = (*OBIO_new_mem_buf)(&sslCerts[0][0], sslCerts[0].size());\n+   if (!certMem)\n+      {\n+      perror(\"cannot create memory buffer for cert (OOM?)\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   X509 *certificate = (*OPEM_read_bio_X509)(certMem, NULL, NULL, NULL);\n+   if (!certificate)\n+      {\n+      perror(\"cannot parse cert\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   if ((*OSSL_CTX_use_certificate)(ctx, certificate) != 1)\n+      {\n+      perror(\"cannot use cert\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // Verify key and cert are valid\n+   if ((*OSSL_CTX_check_private_key)(ctx) != 1)\n+      {\n+      perror(\"private key check failed\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // verify server identity using standard method\n+   (*OSSL_CTX_set_verify)(ctx, SSL_VERIFY_PEER, NULL);\n+\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+      TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"Successfully initialized SSL context (%s)\\n\", (*OOpenSSL_version)(0));\n+\n+   return ctx;\n+   }\n+\n+static bool\n+handleOpenSSLConnectionError(int connfd, SSL *&ssl, BIO *&bio, const char *errMsg)\n+{\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+       TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"%s: errno=%d\", errMsg, errno);\n+   (*OERR_print_errors_fp)(stderr);\n+\n+   close(connfd);\n+   if (bio)\n+      {\n+      (*OBIO_free_all)(bio);\n+      bio = NULL;\n+      }\n+   if (ssl)\n+      {\n+      (*OSSL_free)(ssl);\n+      ssl = NULL;\n+      }\n+   return false;\n+}\n+\n+static bool\n+acceptOpenSSLConnection(SSL_CTX *sslCtx, int connfd, BIO *&bio)\n+   {\n+   SSL *ssl = (*OSSL_new)(sslCtx);\n+   if (!ssl)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error creating SSL connection\");\n+\n+   (*OSSL_set_accept_state)(ssl);\n+\n+   if ((*OSSL_set_fd)(ssl, connfd) != 1)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error setting SSL file descriptor\");\n+\n+   if ((*OSSL_accept)(ssl) <= 0)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error accepting SSL connection\");\n+\n+   bio = (*OBIO_new_ssl)(sslCtx, false);\n+   if (!bio)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error creating new BIO\");\n+\n+   if ((*OBIO_ctrl)(bio, BIO_C_SET_SSL, true, (char *)ssl) != 1) // BIO_set_ssl(bio, ssl, true)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error setting BIO SSL\");\n+\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+      TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"SSL connection on socket 0x%x, Version: %s, Cipher: %s\\n\",\n+                                                     connfd, (*OSSL_get_version)(ssl), (*OSSL_get_cipher)(ssl));\n+   return true;\n+   }\n \n TR_Listener::TR_Listener()\n    : _listenerThread(NULL), _listenerMonitor(NULL), _listenerOSThread(NULL), \n    _listenerThreadAttachAttempted(false), _listenerThreadExitFlag(false)\n    {\n    }\n \n+void\n+TR_Listener::serveRemoteCompilationRequests(BaseCompileDispatcher *compiler)\n+   {\n+   TR::PersistentInfo *info = getCompilationInfo(jitConfig)->getPersistentInfo();\n+   SSL_CTX *sslCtx = NULL;\n+   if (JITServer::CommunicationStream::useSSL())\n+      {\n+      JITServer::CommunicationStream::initSSL();\n+      sslCtx = createSSLContext(info);\n+      }\n+\n+   uint32_t port = info->getJITServerPort();\n+   uint32_t timeoutMs = info->getSocketTimeout();\n+   struct pollfd pfd = {0};\n+   int sockfd = socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, 0);\n+   if (sockfd < 0)\n+      {\n+      perror(\"can't open server socket\");\n+      exit(1);\n+      }\n+\n+   // see `man 7 socket` for option explanations\n+   int flag = true;\n+   if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, (void *)&flag, sizeof(flag)) < 0)\n+      {\n+      perror(\"Can't set SO_REUSEADDR\");\n+      exit(-1);\n+      }\n+   if (setsockopt(sockfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&flag, sizeof(flag)) < 0)\n+      {\n+      perror(\"Can't set SO_KEEPALIVE\");\n+      exit(-1);\n+      }\n+\n+   struct sockaddr_in serv_addr;\n+   memset((char *)&serv_addr, 0, sizeof(serv_addr));\n+   serv_addr.sin_family = AF_INET;\n+   serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);\n+   serv_addr.sin_port = htons(port);\n+\n+   if (bind(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0)\n+      {\n+      perror(\"can't bind server address\");\n+      exit(1);\n+      }\n+   if (listen(sockfd, SOMAXCONN) < 0)\n+      {\n+      perror(\"listen failed\");\n+      exit(1);\n+      }\n+\n+   pfd.fd = sockfd;\n+   pfd.events = POLLIN;\n+\n+   while (!getListenerThreadExitFlag())\n+      {\n+      int32_t rc = 0;\n+      struct sockaddr_in cli_addr;\n+      socklen_t clilen = sizeof(cli_addr);\n+\n+      rc = poll(&pfd, 1, OPENJ9_LISTENER_POLL_TIMEOUT);\n+      if ((rc == 0) && getListenerThreadExitFlag())\n+         {\n+         break;\n+         }\n+      else if (rc < 0)\n+         {\n+         if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+            TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"Error in polling socket: errno=%d\", errno);\n+\t exit(1);\n+         }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgyODA3Mw=="}, "originalCommit": {"oid": "25b5d856e087db5e896c501a3706fc370ed8f867"}, "originalPosition": 247}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjQ1OTg0Mg==", "bodyText": "I see in this example: https://www.ibm.com/support/knowledgecenter/ssw_ibm_i_71/rzab6/poll.htm that a check of\n      if(fds[i].revents != POLLIN)\n      {\n        printf(\"  Error! revents = %d\\n\", fds[i].revents);\n        end_server = TRUE;\n        break;\n      }\n\nis done. Maybe we should do the same to be sure.", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r392459842", "createdAt": "2020-03-13T20:38:00Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/runtime/Listener.cpp", "diffHunk": "@@ -20,18 +20,284 @@\n  * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n  *******************************************************************************/\n \n-#include \"runtime/Listener.hpp\"\n-#include \"net/ServerStream.hpp\"\n+#include <arpa/inet.h>\n+#include <chrono>\n+#include <fcntl.h>\n+#include <netdb.h>\n+#include <netinet/in.h>\n+#include <netinet/tcp.h>\t/* for TCP_NODELAY option */\n+#include <openssl/err.h>\n+#include <poll.h>\n+#include <sys/types.h>\n+#include <sys/socket.h>\n+#include <sys/un.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <unistd.h> /// gethostname, read, write\n+#include \"control/CompilationRuntime.hpp\"\n+#include \"env/TRMemory.hpp\"\n #include \"env/VMJ9.h\"\n+#include \"net/CommunicationStream.hpp\"\n+#include \"net/LoadSSLLibs.hpp\"\n+#include \"net/ServerStream.hpp\"\n+#include \"net/SSLProtobufStream.hpp\"\n #include \"runtime/CompileService.hpp\"\n-#include \"control/CompilationRuntime.hpp\"\n+#include \"runtime/Listener.hpp\"\n+\n+static SSL_CTX *\n+createSSLContext(TR::PersistentInfo *info)\n+   {\n+   SSL_CTX *ctx = (*OSSL_CTX_new)((*OSSLv23_server_method)());\n+\n+   if (!ctx)\n+      {\n+      perror(\"can't create SSL context\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   const char *sessionIDContext = \"JITServer\";\n+   (*OSSL_CTX_set_session_id_context)(ctx, (const unsigned char*)sessionIDContext, strlen(sessionIDContext));\n+\n+   if ((*OSSL_CTX_set_ecdh_auto)(ctx, 1) != 1)\n+      {\n+      perror(\"failed to configure SSL ecdh\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   TR::CompilationInfo *compInfo = TR::CompilationInfo::get();\n+   auto &sslKeys = compInfo->getJITServerSslKeys();\n+   auto &sslCerts = compInfo->getJITServerSslCerts();\n+   auto &sslRootCerts = compInfo->getJITServerSslRootCerts();\n+\n+   TR_ASSERT_FATAL(sslKeys.size() == 1 && sslCerts.size() == 1, \"only one key and cert is supported for now\");\n+   TR_ASSERT_FATAL(sslRootCerts.size() == 0, \"server does not understand root certs yet\");\n+\n+   // Parse and set private key\n+   BIO *keyMem = (*OBIO_new_mem_buf)(&sslKeys[0][0], sslKeys[0].size());\n+   if (!keyMem)\n+      {\n+      perror(\"cannot create memory buffer for private key (OOM?)\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   EVP_PKEY *privKey = (*OPEM_read_bio_PrivateKey)(keyMem, NULL, NULL, NULL);\n+   if (!privKey)\n+      {\n+      perror(\"cannot parse private key\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   if ((*OSSL_CTX_use_PrivateKey)(ctx, privKey) != 1)\n+      {\n+      perror(\"cannot use private key\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // Parse and set certificate\n+   BIO *certMem = (*OBIO_new_mem_buf)(&sslCerts[0][0], sslCerts[0].size());\n+   if (!certMem)\n+      {\n+      perror(\"cannot create memory buffer for cert (OOM?)\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   X509 *certificate = (*OPEM_read_bio_X509)(certMem, NULL, NULL, NULL);\n+   if (!certificate)\n+      {\n+      perror(\"cannot parse cert\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   if ((*OSSL_CTX_use_certificate)(ctx, certificate) != 1)\n+      {\n+      perror(\"cannot use cert\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // Verify key and cert are valid\n+   if ((*OSSL_CTX_check_private_key)(ctx) != 1)\n+      {\n+      perror(\"private key check failed\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // verify server identity using standard method\n+   (*OSSL_CTX_set_verify)(ctx, SSL_VERIFY_PEER, NULL);\n+\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+      TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"Successfully initialized SSL context (%s)\\n\", (*OOpenSSL_version)(0));\n+\n+   return ctx;\n+   }\n+\n+static bool\n+handleOpenSSLConnectionError(int connfd, SSL *&ssl, BIO *&bio, const char *errMsg)\n+{\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+       TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"%s: errno=%d\", errMsg, errno);\n+   (*OERR_print_errors_fp)(stderr);\n+\n+   close(connfd);\n+   if (bio)\n+      {\n+      (*OBIO_free_all)(bio);\n+      bio = NULL;\n+      }\n+   if (ssl)\n+      {\n+      (*OSSL_free)(ssl);\n+      ssl = NULL;\n+      }\n+   return false;\n+}\n+\n+static bool\n+acceptOpenSSLConnection(SSL_CTX *sslCtx, int connfd, BIO *&bio)\n+   {\n+   SSL *ssl = (*OSSL_new)(sslCtx);\n+   if (!ssl)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error creating SSL connection\");\n+\n+   (*OSSL_set_accept_state)(ssl);\n+\n+   if ((*OSSL_set_fd)(ssl, connfd) != 1)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error setting SSL file descriptor\");\n+\n+   if ((*OSSL_accept)(ssl) <= 0)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error accepting SSL connection\");\n+\n+   bio = (*OBIO_new_ssl)(sslCtx, false);\n+   if (!bio)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error creating new BIO\");\n+\n+   if ((*OBIO_ctrl)(bio, BIO_C_SET_SSL, true, (char *)ssl) != 1) // BIO_set_ssl(bio, ssl, true)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error setting BIO SSL\");\n+\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+      TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"SSL connection on socket 0x%x, Version: %s, Cipher: %s\\n\",\n+                                                     connfd, (*OSSL_get_version)(ssl), (*OSSL_get_cipher)(ssl));\n+   return true;\n+   }\n \n TR_Listener::TR_Listener()\n    : _listenerThread(NULL), _listenerMonitor(NULL), _listenerOSThread(NULL), \n    _listenerThreadAttachAttempted(false), _listenerThreadExitFlag(false)\n    {\n    }\n \n+void\n+TR_Listener::serveRemoteCompilationRequests(BaseCompileDispatcher *compiler)\n+   {\n+   TR::PersistentInfo *info = getCompilationInfo(jitConfig)->getPersistentInfo();\n+   SSL_CTX *sslCtx = NULL;\n+   if (JITServer::CommunicationStream::useSSL())\n+      {\n+      JITServer::CommunicationStream::initSSL();\n+      sslCtx = createSSLContext(info);\n+      }\n+\n+   uint32_t port = info->getJITServerPort();\n+   uint32_t timeoutMs = info->getSocketTimeout();\n+   struct pollfd pfd = {0};\n+   int sockfd = socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, 0);\n+   if (sockfd < 0)\n+      {\n+      perror(\"can't open server socket\");\n+      exit(1);\n+      }\n+\n+   // see `man 7 socket` for option explanations\n+   int flag = true;\n+   if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, (void *)&flag, sizeof(flag)) < 0)\n+      {\n+      perror(\"Can't set SO_REUSEADDR\");\n+      exit(-1);\n+      }\n+   if (setsockopt(sockfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&flag, sizeof(flag)) < 0)\n+      {\n+      perror(\"Can't set SO_KEEPALIVE\");\n+      exit(-1);\n+      }\n+\n+   struct sockaddr_in serv_addr;\n+   memset((char *)&serv_addr, 0, sizeof(serv_addr));\n+   serv_addr.sin_family = AF_INET;\n+   serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);\n+   serv_addr.sin_port = htons(port);\n+\n+   if (bind(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0)\n+      {\n+      perror(\"can't bind server address\");\n+      exit(1);\n+      }\n+   if (listen(sockfd, SOMAXCONN) < 0)\n+      {\n+      perror(\"listen failed\");\n+      exit(1);\n+      }\n+\n+   pfd.fd = sockfd;\n+   pfd.events = POLLIN;\n+\n+   while (!getListenerThreadExitFlag())\n+      {\n+      int32_t rc = 0;\n+      struct sockaddr_in cli_addr;\n+      socklen_t clilen = sizeof(cli_addr);\n+\n+      rc = poll(&pfd, 1, OPENJ9_LISTENER_POLL_TIMEOUT);\n+      if ((rc == 0) && getListenerThreadExitFlag())\n+         {\n+         break;\n+         }\n+      else if (rc < 0)\n+         {\n+         if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+            TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"Error in polling socket: errno=%d\", errno);\n+\t exit(1);\n+         }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgyODA3Mw=="}, "originalCommit": {"oid": "25b5d856e087db5e896c501a3706fc370ed8f867"}, "originalPosition": 247}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzAzMTk1Mw==", "bodyText": "I have added a new commit with this change. I also added a do-while loop for accepting new connections as per the example mentioned in the link in previous comment, so that we can avoid calling poll() if multiple clients are ready.", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r393031953", "createdAt": "2020-03-16T13:44:40Z", "author": {"login": "ashu-mehra"}, "path": "runtime/compiler/runtime/Listener.cpp", "diffHunk": "@@ -20,18 +20,284 @@\n  * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n  *******************************************************************************/\n \n-#include \"runtime/Listener.hpp\"\n-#include \"net/ServerStream.hpp\"\n+#include <arpa/inet.h>\n+#include <chrono>\n+#include <fcntl.h>\n+#include <netdb.h>\n+#include <netinet/in.h>\n+#include <netinet/tcp.h>\t/* for TCP_NODELAY option */\n+#include <openssl/err.h>\n+#include <poll.h>\n+#include <sys/types.h>\n+#include <sys/socket.h>\n+#include <sys/un.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <unistd.h> /// gethostname, read, write\n+#include \"control/CompilationRuntime.hpp\"\n+#include \"env/TRMemory.hpp\"\n #include \"env/VMJ9.h\"\n+#include \"net/CommunicationStream.hpp\"\n+#include \"net/LoadSSLLibs.hpp\"\n+#include \"net/ServerStream.hpp\"\n+#include \"net/SSLProtobufStream.hpp\"\n #include \"runtime/CompileService.hpp\"\n-#include \"control/CompilationRuntime.hpp\"\n+#include \"runtime/Listener.hpp\"\n+\n+static SSL_CTX *\n+createSSLContext(TR::PersistentInfo *info)\n+   {\n+   SSL_CTX *ctx = (*OSSL_CTX_new)((*OSSLv23_server_method)());\n+\n+   if (!ctx)\n+      {\n+      perror(\"can't create SSL context\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   const char *sessionIDContext = \"JITServer\";\n+   (*OSSL_CTX_set_session_id_context)(ctx, (const unsigned char*)sessionIDContext, strlen(sessionIDContext));\n+\n+   if ((*OSSL_CTX_set_ecdh_auto)(ctx, 1) != 1)\n+      {\n+      perror(\"failed to configure SSL ecdh\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   TR::CompilationInfo *compInfo = TR::CompilationInfo::get();\n+   auto &sslKeys = compInfo->getJITServerSslKeys();\n+   auto &sslCerts = compInfo->getJITServerSslCerts();\n+   auto &sslRootCerts = compInfo->getJITServerSslRootCerts();\n+\n+   TR_ASSERT_FATAL(sslKeys.size() == 1 && sslCerts.size() == 1, \"only one key and cert is supported for now\");\n+   TR_ASSERT_FATAL(sslRootCerts.size() == 0, \"server does not understand root certs yet\");\n+\n+   // Parse and set private key\n+   BIO *keyMem = (*OBIO_new_mem_buf)(&sslKeys[0][0], sslKeys[0].size());\n+   if (!keyMem)\n+      {\n+      perror(\"cannot create memory buffer for private key (OOM?)\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   EVP_PKEY *privKey = (*OPEM_read_bio_PrivateKey)(keyMem, NULL, NULL, NULL);\n+   if (!privKey)\n+      {\n+      perror(\"cannot parse private key\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   if ((*OSSL_CTX_use_PrivateKey)(ctx, privKey) != 1)\n+      {\n+      perror(\"cannot use private key\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // Parse and set certificate\n+   BIO *certMem = (*OBIO_new_mem_buf)(&sslCerts[0][0], sslCerts[0].size());\n+   if (!certMem)\n+      {\n+      perror(\"cannot create memory buffer for cert (OOM?)\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   X509 *certificate = (*OPEM_read_bio_X509)(certMem, NULL, NULL, NULL);\n+   if (!certificate)\n+      {\n+      perror(\"cannot parse cert\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   if ((*OSSL_CTX_use_certificate)(ctx, certificate) != 1)\n+      {\n+      perror(\"cannot use cert\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // Verify key and cert are valid\n+   if ((*OSSL_CTX_check_private_key)(ctx) != 1)\n+      {\n+      perror(\"private key check failed\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // verify server identity using standard method\n+   (*OSSL_CTX_set_verify)(ctx, SSL_VERIFY_PEER, NULL);\n+\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+      TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"Successfully initialized SSL context (%s)\\n\", (*OOpenSSL_version)(0));\n+\n+   return ctx;\n+   }\n+\n+static bool\n+handleOpenSSLConnectionError(int connfd, SSL *&ssl, BIO *&bio, const char *errMsg)\n+{\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+       TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"%s: errno=%d\", errMsg, errno);\n+   (*OERR_print_errors_fp)(stderr);\n+\n+   close(connfd);\n+   if (bio)\n+      {\n+      (*OBIO_free_all)(bio);\n+      bio = NULL;\n+      }\n+   if (ssl)\n+      {\n+      (*OSSL_free)(ssl);\n+      ssl = NULL;\n+      }\n+   return false;\n+}\n+\n+static bool\n+acceptOpenSSLConnection(SSL_CTX *sslCtx, int connfd, BIO *&bio)\n+   {\n+   SSL *ssl = (*OSSL_new)(sslCtx);\n+   if (!ssl)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error creating SSL connection\");\n+\n+   (*OSSL_set_accept_state)(ssl);\n+\n+   if ((*OSSL_set_fd)(ssl, connfd) != 1)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error setting SSL file descriptor\");\n+\n+   if ((*OSSL_accept)(ssl) <= 0)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error accepting SSL connection\");\n+\n+   bio = (*OBIO_new_ssl)(sslCtx, false);\n+   if (!bio)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error creating new BIO\");\n+\n+   if ((*OBIO_ctrl)(bio, BIO_C_SET_SSL, true, (char *)ssl) != 1) // BIO_set_ssl(bio, ssl, true)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error setting BIO SSL\");\n+\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+      TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"SSL connection on socket 0x%x, Version: %s, Cipher: %s\\n\",\n+                                                     connfd, (*OSSL_get_version)(ssl), (*OSSL_get_cipher)(ssl));\n+   return true;\n+   }\n \n TR_Listener::TR_Listener()\n    : _listenerThread(NULL), _listenerMonitor(NULL), _listenerOSThread(NULL), \n    _listenerThreadAttachAttempted(false), _listenerThreadExitFlag(false)\n    {\n    }\n \n+void\n+TR_Listener::serveRemoteCompilationRequests(BaseCompileDispatcher *compiler)\n+   {\n+   TR::PersistentInfo *info = getCompilationInfo(jitConfig)->getPersistentInfo();\n+   SSL_CTX *sslCtx = NULL;\n+   if (JITServer::CommunicationStream::useSSL())\n+      {\n+      JITServer::CommunicationStream::initSSL();\n+      sslCtx = createSSLContext(info);\n+      }\n+\n+   uint32_t port = info->getJITServerPort();\n+   uint32_t timeoutMs = info->getSocketTimeout();\n+   struct pollfd pfd = {0};\n+   int sockfd = socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, 0);\n+   if (sockfd < 0)\n+      {\n+      perror(\"can't open server socket\");\n+      exit(1);\n+      }\n+\n+   // see `man 7 socket` for option explanations\n+   int flag = true;\n+   if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, (void *)&flag, sizeof(flag)) < 0)\n+      {\n+      perror(\"Can't set SO_REUSEADDR\");\n+      exit(-1);\n+      }\n+   if (setsockopt(sockfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&flag, sizeof(flag)) < 0)\n+      {\n+      perror(\"Can't set SO_KEEPALIVE\");\n+      exit(-1);\n+      }\n+\n+   struct sockaddr_in serv_addr;\n+   memset((char *)&serv_addr, 0, sizeof(serv_addr));\n+   serv_addr.sin_family = AF_INET;\n+   serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);\n+   serv_addr.sin_port = htons(port);\n+\n+   if (bind(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0)\n+      {\n+      perror(\"can't bind server address\");\n+      exit(1);\n+      }\n+   if (listen(sockfd, SOMAXCONN) < 0)\n+      {\n+      perror(\"listen failed\");\n+      exit(1);\n+      }\n+\n+   pfd.fd = sockfd;\n+   pfd.events = POLLIN;\n+\n+   while (!getListenerThreadExitFlag())\n+      {\n+      int32_t rc = 0;\n+      struct sockaddr_in cli_addr;\n+      socklen_t clilen = sizeof(cli_addr);\n+\n+      rc = poll(&pfd, 1, OPENJ9_LISTENER_POLL_TIMEOUT);\n+      if ((rc == 0) && getListenerThreadExitFlag())\n+         {\n+         break;\n+         }\n+      else if (rc < 0)\n+         {\n+         if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+            TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"Error in polling socket: errno=%d\", errno);\n+\t exit(1);\n+         }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgyODA3Mw=="}, "originalCommit": {"oid": "25b5d856e087db5e896c501a3706fc370ed8f867"}, "originalPosition": 247}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzNjQ1NTExOnYy", "diffSide": "RIGHT", "path": "runtime/compiler/runtime/Listener.cpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxNDoyODoxMVrOF2247g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxNDoyODoxMVrOF2247g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA2NjczNA==", "bodyText": "Could we please fix the alignment of these two lines", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r393066734", "createdAt": "2020-03-16T14:28:11Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/runtime/Listener.cpp", "diffHunk": "@@ -20,18 +20,305 @@\n  * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n  *******************************************************************************/\n \n-#include \"runtime/Listener.hpp\"\n-#include \"net/ServerStream.hpp\"\n+#include <arpa/inet.h>\n+#include <chrono>\n+#include <fcntl.h>\n+#include <netdb.h>\n+#include <netinet/in.h>\n+#include <netinet/tcp.h>\t/* for TCP_NODELAY option */\n+#include <openssl/err.h>\n+#include <poll.h>\n+#include <sys/types.h>\n+#include <sys/socket.h>\n+#include <sys/un.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <unistd.h> /// gethostname, read, write\n+#include \"control/CompilationRuntime.hpp\"\n+#include \"env/TRMemory.hpp\"\n #include \"env/VMJ9.h\"\n+#include \"net/CommunicationStream.hpp\"\n+#include \"net/LoadSSLLibs.hpp\"\n+#include \"net/ServerStream.hpp\"\n+#include \"net/SSLProtobufStream.hpp\"\n #include \"runtime/CompileService.hpp\"\n-#include \"control/CompilationRuntime.hpp\"\n+#include \"runtime/Listener.hpp\"\n+\n+static SSL_CTX *\n+createSSLContext(TR::PersistentInfo *info)\n+   {\n+   SSL_CTX *ctx = (*OSSL_CTX_new)((*OSSLv23_server_method)());\n+\n+   if (!ctx)\n+      {\n+      perror(\"can't create SSL context\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   const char *sessionIDContext = \"JITServer\";\n+   (*OSSL_CTX_set_session_id_context)(ctx, (const unsigned char*)sessionIDContext, strlen(sessionIDContext));\n+\n+   if ((*OSSL_CTX_set_ecdh_auto)(ctx, 1) != 1)\n+      {\n+      perror(\"failed to configure SSL ecdh\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   TR::CompilationInfo *compInfo = TR::CompilationInfo::get();\n+   auto &sslKeys = compInfo->getJITServerSslKeys();\n+   auto &sslCerts = compInfo->getJITServerSslCerts();\n+   auto &sslRootCerts = compInfo->getJITServerSslRootCerts();\n+\n+   TR_ASSERT_FATAL(sslKeys.size() == 1 && sslCerts.size() == 1, \"only one key and cert is supported for now\");\n+   TR_ASSERT_FATAL(sslRootCerts.size() == 0, \"server does not understand root certs yet\");\n+\n+   // Parse and set private key\n+   BIO *keyMem = (*OBIO_new_mem_buf)(&sslKeys[0][0], sslKeys[0].size());\n+   if (!keyMem)\n+      {\n+      perror(\"cannot create memory buffer for private key (OOM?)\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   EVP_PKEY *privKey = (*OPEM_read_bio_PrivateKey)(keyMem, NULL, NULL, NULL);\n+   if (!privKey)\n+      {\n+      perror(\"cannot parse private key\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   if ((*OSSL_CTX_use_PrivateKey)(ctx, privKey) != 1)\n+      {\n+      perror(\"cannot use private key\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // Parse and set certificate\n+   BIO *certMem = (*OBIO_new_mem_buf)(&sslCerts[0][0], sslCerts[0].size());\n+   if (!certMem)\n+      {\n+      perror(\"cannot create memory buffer for cert (OOM?)\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   X509 *certificate = (*OPEM_read_bio_X509)(certMem, NULL, NULL, NULL);\n+   if (!certificate)\n+      {\n+      perror(\"cannot parse cert\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   if ((*OSSL_CTX_use_certificate)(ctx, certificate) != 1)\n+      {\n+      perror(\"cannot use cert\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // Verify key and cert are valid\n+   if ((*OSSL_CTX_check_private_key)(ctx) != 1)\n+      {\n+      perror(\"private key check failed\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // verify server identity using standard method\n+   (*OSSL_CTX_set_verify)(ctx, SSL_VERIFY_PEER, NULL);\n+\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+      TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"Successfully initialized SSL context (%s)\\n\", (*OOpenSSL_version)(0));\n+\n+   return ctx;\n+   }\n+\n+static bool\n+handleOpenSSLConnectionError(int connfd, SSL *&ssl, BIO *&bio, const char *errMsg)\n+{\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+       TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"%s: errno=%d\", errMsg, errno);\n+   (*OERR_print_errors_fp)(stderr);\n+\n+   close(connfd);\n+   if (bio)\n+      {\n+      (*OBIO_free_all)(bio);\n+      bio = NULL;\n+      }\n+   if (ssl)\n+      {\n+      (*OSSL_free)(ssl);\n+      ssl = NULL;\n+      }\n+   return false;\n+}\n+\n+static bool\n+acceptOpenSSLConnection(SSL_CTX *sslCtx, int connfd, BIO *&bio)\n+   {\n+   SSL *ssl = (*OSSL_new)(sslCtx);\n+   if (!ssl)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error creating SSL connection\");\n+\n+   (*OSSL_set_accept_state)(ssl);\n+\n+   if ((*OSSL_set_fd)(ssl, connfd) != 1)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error setting SSL file descriptor\");\n+\n+   if ((*OSSL_accept)(ssl) <= 0)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error accepting SSL connection\");\n+\n+   bio = (*OBIO_new_ssl)(sslCtx, false);\n+   if (!bio)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error creating new BIO\");\n+\n+   if ((*OBIO_ctrl)(bio, BIO_C_SET_SSL, true, (char *)ssl) != 1) // BIO_set_ssl(bio, ssl, true)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error setting BIO SSL\");\n+\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+      TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"SSL connection on socket 0x%x, Version: %s, Cipher: %s\\n\",\n+                                                     connfd, (*OSSL_get_version)(ssl), (*OSSL_get_cipher)(ssl));\n+   return true;\n+   }\n \n TR_Listener::TR_Listener()\n    : _listenerThread(NULL), _listenerMonitor(NULL), _listenerOSThread(NULL), \n    _listenerThreadAttachAttempted(false), _listenerThreadExitFlag(false)\n    {\n    }\n \n+void\n+TR_Listener::serveRemoteCompilationRequests(BaseCompileDispatcher *compiler)\n+   {\n+   TR::PersistentInfo *info = getCompilationInfo(jitConfig)->getPersistentInfo();\n+   SSL_CTX *sslCtx = NULL;\n+   if (JITServer::CommunicationStream::useSSL())\n+      {\n+      JITServer::CommunicationStream::initSSL();\n+      sslCtx = createSSLContext(info);\n+      }\n+\n+   uint32_t port = info->getJITServerPort();\n+   uint32_t timeoutMs = info->getSocketTimeout();\n+   struct pollfd pfd = {0};\n+   int sockfd = socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, 0);\n+   if (sockfd < 0)\n+      {\n+      perror(\"can't open server socket\");\n+      exit(1);\n+      }\n+\n+   // see `man 7 socket` for option explanations\n+   int flag = true;\n+   if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, (void *)&flag, sizeof(flag)) < 0)\n+      {\n+      perror(\"Can't set SO_REUSEADDR\");\n+      exit(-1);\n+      }\n+   if (setsockopt(sockfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&flag, sizeof(flag)) < 0)\n+      {\n+      perror(\"Can't set SO_KEEPALIVE\");\n+      exit(-1);\n+      }\n+\n+   struct sockaddr_in serv_addr;\n+   memset((char *)&serv_addr, 0, sizeof(serv_addr));\n+   serv_addr.sin_family = AF_INET;\n+   serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);\n+   serv_addr.sin_port = htons(port);\n+\n+   if (bind(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0)\n+      {\n+      perror(\"can't bind server address\");\n+      exit(1);\n+      }\n+   if (listen(sockfd, SOMAXCONN) < 0)\n+      {\n+      perror(\"listen failed\");\n+      exit(1);\n+      }\n+\n+   pfd.fd = sockfd;\n+   pfd.events = POLLIN;\n+\n+   while (!getListenerThreadExitFlag())\n+      {\n+      int32_t rc = 0;\n+      struct sockaddr_in cli_addr;\n+      socklen_t clilen = sizeof(cli_addr);\n+\n+      rc = poll(&pfd, 1, OPENJ9_LISTENER_POLL_TIMEOUT);\n+      /* check if we are exiting; if yes, there is no need to accept() new connection */\n+      if (getListenerThreadExitFlag())\n+         {\n+         break;\n+         }\n+      else if (rc < 0)\n+         {\n+         if (errno == EINTR)\n+            {\n+            continue;\n+\t    }\n+         else\n+            {\n+            perror(\"error in polling listening socket\");\n+\t    exit(1);\n+\t    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a32f9727ea13034a2b6d14b29fd818d1210c45c"}, "originalPosition": 253}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzNjQ1ODQ2OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/runtime/Listener.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxNDoyODo1NFrOF227Ew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxNDoyODo1NFrOF227Ew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA2NzI4Mw==", "bodyText": "This lines needs two extra spaces", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r393067283", "createdAt": "2020-03-16T14:28:54Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/runtime/Listener.cpp", "diffHunk": "@@ -20,18 +20,305 @@\n  * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n  *******************************************************************************/\n \n-#include \"runtime/Listener.hpp\"\n-#include \"net/ServerStream.hpp\"\n+#include <arpa/inet.h>\n+#include <chrono>\n+#include <fcntl.h>\n+#include <netdb.h>\n+#include <netinet/in.h>\n+#include <netinet/tcp.h>\t/* for TCP_NODELAY option */\n+#include <openssl/err.h>\n+#include <poll.h>\n+#include <sys/types.h>\n+#include <sys/socket.h>\n+#include <sys/un.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <unistd.h> /// gethostname, read, write\n+#include \"control/CompilationRuntime.hpp\"\n+#include \"env/TRMemory.hpp\"\n #include \"env/VMJ9.h\"\n+#include \"net/CommunicationStream.hpp\"\n+#include \"net/LoadSSLLibs.hpp\"\n+#include \"net/ServerStream.hpp\"\n+#include \"net/SSLProtobufStream.hpp\"\n #include \"runtime/CompileService.hpp\"\n-#include \"control/CompilationRuntime.hpp\"\n+#include \"runtime/Listener.hpp\"\n+\n+static SSL_CTX *\n+createSSLContext(TR::PersistentInfo *info)\n+   {\n+   SSL_CTX *ctx = (*OSSL_CTX_new)((*OSSLv23_server_method)());\n+\n+   if (!ctx)\n+      {\n+      perror(\"can't create SSL context\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   const char *sessionIDContext = \"JITServer\";\n+   (*OSSL_CTX_set_session_id_context)(ctx, (const unsigned char*)sessionIDContext, strlen(sessionIDContext));\n+\n+   if ((*OSSL_CTX_set_ecdh_auto)(ctx, 1) != 1)\n+      {\n+      perror(\"failed to configure SSL ecdh\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   TR::CompilationInfo *compInfo = TR::CompilationInfo::get();\n+   auto &sslKeys = compInfo->getJITServerSslKeys();\n+   auto &sslCerts = compInfo->getJITServerSslCerts();\n+   auto &sslRootCerts = compInfo->getJITServerSslRootCerts();\n+\n+   TR_ASSERT_FATAL(sslKeys.size() == 1 && sslCerts.size() == 1, \"only one key and cert is supported for now\");\n+   TR_ASSERT_FATAL(sslRootCerts.size() == 0, \"server does not understand root certs yet\");\n+\n+   // Parse and set private key\n+   BIO *keyMem = (*OBIO_new_mem_buf)(&sslKeys[0][0], sslKeys[0].size());\n+   if (!keyMem)\n+      {\n+      perror(\"cannot create memory buffer for private key (OOM?)\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   EVP_PKEY *privKey = (*OPEM_read_bio_PrivateKey)(keyMem, NULL, NULL, NULL);\n+   if (!privKey)\n+      {\n+      perror(\"cannot parse private key\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   if ((*OSSL_CTX_use_PrivateKey)(ctx, privKey) != 1)\n+      {\n+      perror(\"cannot use private key\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // Parse and set certificate\n+   BIO *certMem = (*OBIO_new_mem_buf)(&sslCerts[0][0], sslCerts[0].size());\n+   if (!certMem)\n+      {\n+      perror(\"cannot create memory buffer for cert (OOM?)\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   X509 *certificate = (*OPEM_read_bio_X509)(certMem, NULL, NULL, NULL);\n+   if (!certificate)\n+      {\n+      perror(\"cannot parse cert\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   if ((*OSSL_CTX_use_certificate)(ctx, certificate) != 1)\n+      {\n+      perror(\"cannot use cert\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // Verify key and cert are valid\n+   if ((*OSSL_CTX_check_private_key)(ctx) != 1)\n+      {\n+      perror(\"private key check failed\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // verify server identity using standard method\n+   (*OSSL_CTX_set_verify)(ctx, SSL_VERIFY_PEER, NULL);\n+\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+      TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"Successfully initialized SSL context (%s)\\n\", (*OOpenSSL_version)(0));\n+\n+   return ctx;\n+   }\n+\n+static bool\n+handleOpenSSLConnectionError(int connfd, SSL *&ssl, BIO *&bio, const char *errMsg)\n+{\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+       TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"%s: errno=%d\", errMsg, errno);\n+   (*OERR_print_errors_fp)(stderr);\n+\n+   close(connfd);\n+   if (bio)\n+      {\n+      (*OBIO_free_all)(bio);\n+      bio = NULL;\n+      }\n+   if (ssl)\n+      {\n+      (*OSSL_free)(ssl);\n+      ssl = NULL;\n+      }\n+   return false;\n+}\n+\n+static bool\n+acceptOpenSSLConnection(SSL_CTX *sslCtx, int connfd, BIO *&bio)\n+   {\n+   SSL *ssl = (*OSSL_new)(sslCtx);\n+   if (!ssl)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error creating SSL connection\");\n+\n+   (*OSSL_set_accept_state)(ssl);\n+\n+   if ((*OSSL_set_fd)(ssl, connfd) != 1)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error setting SSL file descriptor\");\n+\n+   if ((*OSSL_accept)(ssl) <= 0)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error accepting SSL connection\");\n+\n+   bio = (*OBIO_new_ssl)(sslCtx, false);\n+   if (!bio)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error creating new BIO\");\n+\n+   if ((*OBIO_ctrl)(bio, BIO_C_SET_SSL, true, (char *)ssl) != 1) // BIO_set_ssl(bio, ssl, true)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error setting BIO SSL\");\n+\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+      TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"SSL connection on socket 0x%x, Version: %s, Cipher: %s\\n\",\n+                                                     connfd, (*OSSL_get_version)(ssl), (*OSSL_get_cipher)(ssl));\n+   return true;\n+   }\n \n TR_Listener::TR_Listener()\n    : _listenerThread(NULL), _listenerMonitor(NULL), _listenerOSThread(NULL), \n    _listenerThreadAttachAttempted(false), _listenerThreadExitFlag(false)\n    {\n    }\n \n+void\n+TR_Listener::serveRemoteCompilationRequests(BaseCompileDispatcher *compiler)\n+   {\n+   TR::PersistentInfo *info = getCompilationInfo(jitConfig)->getPersistentInfo();\n+   SSL_CTX *sslCtx = NULL;\n+   if (JITServer::CommunicationStream::useSSL())\n+      {\n+      JITServer::CommunicationStream::initSSL();\n+      sslCtx = createSSLContext(info);\n+      }\n+\n+   uint32_t port = info->getJITServerPort();\n+   uint32_t timeoutMs = info->getSocketTimeout();\n+   struct pollfd pfd = {0};\n+   int sockfd = socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, 0);\n+   if (sockfd < 0)\n+      {\n+      perror(\"can't open server socket\");\n+      exit(1);\n+      }\n+\n+   // see `man 7 socket` for option explanations\n+   int flag = true;\n+   if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, (void *)&flag, sizeof(flag)) < 0)\n+      {\n+      perror(\"Can't set SO_REUSEADDR\");\n+      exit(-1);\n+      }\n+   if (setsockopt(sockfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&flag, sizeof(flag)) < 0)\n+      {\n+      perror(\"Can't set SO_KEEPALIVE\");\n+      exit(-1);\n+      }\n+\n+   struct sockaddr_in serv_addr;\n+   memset((char *)&serv_addr, 0, sizeof(serv_addr));\n+   serv_addr.sin_family = AF_INET;\n+   serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);\n+   serv_addr.sin_port = htons(port);\n+\n+   if (bind(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0)\n+      {\n+      perror(\"can't bind server address\");\n+      exit(1);\n+      }\n+   if (listen(sockfd, SOMAXCONN) < 0)\n+      {\n+      perror(\"listen failed\");\n+      exit(1);\n+      }\n+\n+   pfd.fd = sockfd;\n+   pfd.events = POLLIN;\n+\n+   while (!getListenerThreadExitFlag())\n+      {\n+      int32_t rc = 0;\n+      struct sockaddr_in cli_addr;\n+      socklen_t clilen = sizeof(cli_addr);\n+\n+      rc = poll(&pfd, 1, OPENJ9_LISTENER_POLL_TIMEOUT);\n+      /* check if we are exiting; if yes, there is no need to accept() new connection */\n+      if (getListenerThreadExitFlag())\n+         {\n+         break;\n+         }\n+      else if (rc < 0)\n+         {\n+         if (errno == EINTR)\n+            {\n+            continue;\n+\t    }\n+         else\n+            {\n+            perror(\"error in polling listening socket\");\n+\t    exit(1);\n+\t    }\n+         }\n+      else if (pfd.revents != POLLIN)\n+         {\n+         fprintf(stderr, \"Unexpected event occurred during poll for new connection: revents=%d\\n\", pfd.revents);\n+\t exit(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a32f9727ea13034a2b6d14b29fd818d1210c45c"}, "originalPosition": 258}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzNjQ2ODU5OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/runtime/Listener.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxNDozMTowOVrOF23Bag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxNDozMTowOVrOF23Bag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA2ODkwNg==", "bodyText": "On my screen these lines are not properly aligned", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r393068906", "createdAt": "2020-03-16T14:31:09Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/runtime/Listener.cpp", "diffHunk": "@@ -20,18 +20,305 @@\n  * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n  *******************************************************************************/\n \n-#include \"runtime/Listener.hpp\"\n-#include \"net/ServerStream.hpp\"\n+#include <arpa/inet.h>\n+#include <chrono>\n+#include <fcntl.h>\n+#include <netdb.h>\n+#include <netinet/in.h>\n+#include <netinet/tcp.h>\t/* for TCP_NODELAY option */\n+#include <openssl/err.h>\n+#include <poll.h>\n+#include <sys/types.h>\n+#include <sys/socket.h>\n+#include <sys/un.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <unistd.h> /// gethostname, read, write\n+#include \"control/CompilationRuntime.hpp\"\n+#include \"env/TRMemory.hpp\"\n #include \"env/VMJ9.h\"\n+#include \"net/CommunicationStream.hpp\"\n+#include \"net/LoadSSLLibs.hpp\"\n+#include \"net/ServerStream.hpp\"\n+#include \"net/SSLProtobufStream.hpp\"\n #include \"runtime/CompileService.hpp\"\n-#include \"control/CompilationRuntime.hpp\"\n+#include \"runtime/Listener.hpp\"\n+\n+static SSL_CTX *\n+createSSLContext(TR::PersistentInfo *info)\n+   {\n+   SSL_CTX *ctx = (*OSSL_CTX_new)((*OSSLv23_server_method)());\n+\n+   if (!ctx)\n+      {\n+      perror(\"can't create SSL context\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   const char *sessionIDContext = \"JITServer\";\n+   (*OSSL_CTX_set_session_id_context)(ctx, (const unsigned char*)sessionIDContext, strlen(sessionIDContext));\n+\n+   if ((*OSSL_CTX_set_ecdh_auto)(ctx, 1) != 1)\n+      {\n+      perror(\"failed to configure SSL ecdh\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   TR::CompilationInfo *compInfo = TR::CompilationInfo::get();\n+   auto &sslKeys = compInfo->getJITServerSslKeys();\n+   auto &sslCerts = compInfo->getJITServerSslCerts();\n+   auto &sslRootCerts = compInfo->getJITServerSslRootCerts();\n+\n+   TR_ASSERT_FATAL(sslKeys.size() == 1 && sslCerts.size() == 1, \"only one key and cert is supported for now\");\n+   TR_ASSERT_FATAL(sslRootCerts.size() == 0, \"server does not understand root certs yet\");\n+\n+   // Parse and set private key\n+   BIO *keyMem = (*OBIO_new_mem_buf)(&sslKeys[0][0], sslKeys[0].size());\n+   if (!keyMem)\n+      {\n+      perror(\"cannot create memory buffer for private key (OOM?)\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   EVP_PKEY *privKey = (*OPEM_read_bio_PrivateKey)(keyMem, NULL, NULL, NULL);\n+   if (!privKey)\n+      {\n+      perror(\"cannot parse private key\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   if ((*OSSL_CTX_use_PrivateKey)(ctx, privKey) != 1)\n+      {\n+      perror(\"cannot use private key\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // Parse and set certificate\n+   BIO *certMem = (*OBIO_new_mem_buf)(&sslCerts[0][0], sslCerts[0].size());\n+   if (!certMem)\n+      {\n+      perror(\"cannot create memory buffer for cert (OOM?)\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   X509 *certificate = (*OPEM_read_bio_X509)(certMem, NULL, NULL, NULL);\n+   if (!certificate)\n+      {\n+      perror(\"cannot parse cert\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   if ((*OSSL_CTX_use_certificate)(ctx, certificate) != 1)\n+      {\n+      perror(\"cannot use cert\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // Verify key and cert are valid\n+   if ((*OSSL_CTX_check_private_key)(ctx) != 1)\n+      {\n+      perror(\"private key check failed\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // verify server identity using standard method\n+   (*OSSL_CTX_set_verify)(ctx, SSL_VERIFY_PEER, NULL);\n+\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+      TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"Successfully initialized SSL context (%s)\\n\", (*OOpenSSL_version)(0));\n+\n+   return ctx;\n+   }\n+\n+static bool\n+handleOpenSSLConnectionError(int connfd, SSL *&ssl, BIO *&bio, const char *errMsg)\n+{\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+       TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"%s: errno=%d\", errMsg, errno);\n+   (*OERR_print_errors_fp)(stderr);\n+\n+   close(connfd);\n+   if (bio)\n+      {\n+      (*OBIO_free_all)(bio);\n+      bio = NULL;\n+      }\n+   if (ssl)\n+      {\n+      (*OSSL_free)(ssl);\n+      ssl = NULL;\n+      }\n+   return false;\n+}\n+\n+static bool\n+acceptOpenSSLConnection(SSL_CTX *sslCtx, int connfd, BIO *&bio)\n+   {\n+   SSL *ssl = (*OSSL_new)(sslCtx);\n+   if (!ssl)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error creating SSL connection\");\n+\n+   (*OSSL_set_accept_state)(ssl);\n+\n+   if ((*OSSL_set_fd)(ssl, connfd) != 1)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error setting SSL file descriptor\");\n+\n+   if ((*OSSL_accept)(ssl) <= 0)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error accepting SSL connection\");\n+\n+   bio = (*OBIO_new_ssl)(sslCtx, false);\n+   if (!bio)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error creating new BIO\");\n+\n+   if ((*OBIO_ctrl)(bio, BIO_C_SET_SSL, true, (char *)ssl) != 1) // BIO_set_ssl(bio, ssl, true)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error setting BIO SSL\");\n+\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+      TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"SSL connection on socket 0x%x, Version: %s, Cipher: %s\\n\",\n+                                                     connfd, (*OSSL_get_version)(ssl), (*OSSL_get_cipher)(ssl));\n+   return true;\n+   }\n \n TR_Listener::TR_Listener()\n    : _listenerThread(NULL), _listenerMonitor(NULL), _listenerOSThread(NULL), \n    _listenerThreadAttachAttempted(false), _listenerThreadExitFlag(false)\n    {\n    }\n \n+void\n+TR_Listener::serveRemoteCompilationRequests(BaseCompileDispatcher *compiler)\n+   {\n+   TR::PersistentInfo *info = getCompilationInfo(jitConfig)->getPersistentInfo();\n+   SSL_CTX *sslCtx = NULL;\n+   if (JITServer::CommunicationStream::useSSL())\n+      {\n+      JITServer::CommunicationStream::initSSL();\n+      sslCtx = createSSLContext(info);\n+      }\n+\n+   uint32_t port = info->getJITServerPort();\n+   uint32_t timeoutMs = info->getSocketTimeout();\n+   struct pollfd pfd = {0};\n+   int sockfd = socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, 0);\n+   if (sockfd < 0)\n+      {\n+      perror(\"can't open server socket\");\n+      exit(1);\n+      }\n+\n+   // see `man 7 socket` for option explanations\n+   int flag = true;\n+   if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, (void *)&flag, sizeof(flag)) < 0)\n+      {\n+      perror(\"Can't set SO_REUSEADDR\");\n+      exit(-1);\n+      }\n+   if (setsockopt(sockfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&flag, sizeof(flag)) < 0)\n+      {\n+      perror(\"Can't set SO_KEEPALIVE\");\n+      exit(-1);\n+      }\n+\n+   struct sockaddr_in serv_addr;\n+   memset((char *)&serv_addr, 0, sizeof(serv_addr));\n+   serv_addr.sin_family = AF_INET;\n+   serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);\n+   serv_addr.sin_port = htons(port);\n+\n+   if (bind(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0)\n+      {\n+      perror(\"can't bind server address\");\n+      exit(1);\n+      }\n+   if (listen(sockfd, SOMAXCONN) < 0)\n+      {\n+      perror(\"listen failed\");\n+      exit(1);\n+      }\n+\n+   pfd.fd = sockfd;\n+   pfd.events = POLLIN;\n+\n+   while (!getListenerThreadExitFlag())\n+      {\n+      int32_t rc = 0;\n+      struct sockaddr_in cli_addr;\n+      socklen_t clilen = sizeof(cli_addr);\n+\n+      rc = poll(&pfd, 1, OPENJ9_LISTENER_POLL_TIMEOUT);\n+      /* check if we are exiting; if yes, there is no need to accept() new connection */\n+      if (getListenerThreadExitFlag())\n+         {\n+         break;\n+         }\n+      else if (rc < 0)\n+         {\n+         if (errno == EINTR)\n+            {\n+            continue;\n+\t    }\n+         else\n+            {\n+            perror(\"error in polling listening socket\");\n+\t    exit(1);\n+\t    }\n+         }\n+      else if (pfd.revents != POLLIN)\n+         {\n+         fprintf(stderr, \"Unexpected event occurred during poll for new connection: revents=%d\\n\", pfd.revents);\n+\t exit(1);\n+         }\n+      do\n+         {\n+         /* at this stage we should have a valid request for new connection */\n+         int connfd = accept(sockfd, (struct sockaddr *)&cli_addr, &clilen);\n+         if (connfd < 0)\n+            {\n+            if ((EAGAIN != errno) && (EWOULDBLOCK != errno))\n+               {\n+\t       if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+                  {\n+                  TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"Error accepting connection: errno=%d\", errno);\n+\t\t  }\n+\t       }\n+            }\n+         else\n+            {\n+            struct timeval timeoutMsForConnection = {(timeoutMs / 1000), ((timeoutMs % 1000) * 1000)};\n+            if (setsockopt(connfd, SOL_SOCKET, SO_RCVTIMEO, (void *)&timeoutMsForConnection, sizeof(timeoutMsForConnection)) < 0)\n+               {\n+               perror(\"Can't set option SO_RCVTIMEO on connfd socket\");\n+               exit(-1);\n+               }\n+            if (setsockopt(connfd, SOL_SOCKET, SO_SNDTIMEO, (void *)&timeoutMsForConnection, sizeof(timeoutMsForConnection)) < 0)\n+               {\n+               perror(\"Can't set option SO_SNDTIMEO on connfd socket\");\n+               exit(-1);\n+               }\n+\n+            BIO *bio = NULL;\n+            if (sslCtx && !acceptOpenSSLConnection(sslCtx, connfd, bio))\n+               continue;\n+\n+            JITServer::ServerStream *stream = new (PERSISTENT_NEW) JITServer::ServerStream(connfd, bio);\n+            compiler->compile(stream);\n+\t    }\n+         } while ((-1 != connfd) && !getListenerThreadExitFlag());\n+      }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a32f9727ea13034a2b6d14b29fd818d1210c45c"}, "originalPosition": 297}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1NzYyNTM1OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/runtime/Listener.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxMzozMDoxMVrOF6Fa7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxMzozMDoxMVrOF6Fa7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ1MDU0Mw==", "bodyText": "These brackets are not aligned properly", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r396450543", "createdAt": "2020-03-23T13:30:11Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/runtime/Listener.cpp", "diffHunk": "@@ -20,18 +20,309 @@\n  * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n  *******************************************************************************/\n \n-#include \"runtime/Listener.hpp\"\n-#include \"net/ServerStream.hpp\"\n+#include <arpa/inet.h>\n+#include <chrono>\n+#include <fcntl.h>\n+#include <netdb.h>\n+#include <netinet/in.h>\n+#include <netinet/tcp.h>\t/* for TCP_NODELAY option */\n+#include <openssl/err.h>\n+#include <poll.h>\n+#include <sys/types.h>\n+#include <sys/socket.h>\n+#include <sys/un.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <unistd.h> /// gethostname, read, write\n+#include \"control/CompilationRuntime.hpp\"\n+#include \"env/TRMemory.hpp\"\n #include \"env/VMJ9.h\"\n+#include \"net/CommunicationStream.hpp\"\n+#include \"net/LoadSSLLibs.hpp\"\n+#include \"net/ServerStream.hpp\"\n+#include \"net/SSLProtobufStream.hpp\"\n #include \"runtime/CompileService.hpp\"\n-#include \"control/CompilationRuntime.hpp\"\n+#include \"runtime/Listener.hpp\"\n+\n+static SSL_CTX *\n+createSSLContext(TR::PersistentInfo *info)\n+   {\n+   SSL_CTX *ctx = (*OSSL_CTX_new)((*OSSLv23_server_method)());\n+\n+   if (!ctx)\n+      {\n+      perror(\"can't create SSL context\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   const char *sessionIDContext = \"JITServer\";\n+   (*OSSL_CTX_set_session_id_context)(ctx, (const unsigned char*)sessionIDContext, strlen(sessionIDContext));\n+\n+   if ((*OSSL_CTX_set_ecdh_auto)(ctx, 1) != 1)\n+      {\n+      perror(\"failed to configure SSL ecdh\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   TR::CompilationInfo *compInfo = TR::CompilationInfo::get();\n+   auto &sslKeys = compInfo->getJITServerSslKeys();\n+   auto &sslCerts = compInfo->getJITServerSslCerts();\n+   auto &sslRootCerts = compInfo->getJITServerSslRootCerts();\n+\n+   TR_ASSERT_FATAL(sslKeys.size() == 1 && sslCerts.size() == 1, \"only one key and cert is supported for now\");\n+   TR_ASSERT_FATAL(sslRootCerts.size() == 0, \"server does not understand root certs yet\");\n+\n+   // Parse and set private key\n+   BIO *keyMem = (*OBIO_new_mem_buf)(&sslKeys[0][0], sslKeys[0].size());\n+   if (!keyMem)\n+      {\n+      perror(\"cannot create memory buffer for private key (OOM?)\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   EVP_PKEY *privKey = (*OPEM_read_bio_PrivateKey)(keyMem, NULL, NULL, NULL);\n+   if (!privKey)\n+      {\n+      perror(\"cannot parse private key\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   if ((*OSSL_CTX_use_PrivateKey)(ctx, privKey) != 1)\n+      {\n+      perror(\"cannot use private key\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // Parse and set certificate\n+   BIO *certMem = (*OBIO_new_mem_buf)(&sslCerts[0][0], sslCerts[0].size());\n+   if (!certMem)\n+      {\n+      perror(\"cannot create memory buffer for cert (OOM?)\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   X509 *certificate = (*OPEM_read_bio_X509)(certMem, NULL, NULL, NULL);\n+   if (!certificate)\n+      {\n+      perror(\"cannot parse cert\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   if ((*OSSL_CTX_use_certificate)(ctx, certificate) != 1)\n+      {\n+      perror(\"cannot use cert\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // Verify key and cert are valid\n+   if ((*OSSL_CTX_check_private_key)(ctx) != 1)\n+      {\n+      perror(\"private key check failed\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // verify server identity using standard method\n+   (*OSSL_CTX_set_verify)(ctx, SSL_VERIFY_PEER, NULL);\n+\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+      TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"Successfully initialized SSL context (%s)\\n\", (*OOpenSSL_version)(0));\n+\n+   return ctx;\n+   }\n+\n+static bool\n+handleOpenSSLConnectionError(int connfd, SSL *&ssl, BIO *&bio, const char *errMsg)\n+{", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68c9014ea8432c2531457a5eef3754e2bc26be96"}, "originalPosition": 124}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1NzYzODk0OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/runtime/Listener.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxMzozMzoyOFrOF6Fjpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxMzozMzoyOFrOF6Fjpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ1Mjc3NQ==", "bodyText": "I would leave if (getListenerThreadExitFlag()) as the first test. Error or not, timeout or not, if it's time to exit, we should exit.", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r396452775", "createdAt": "2020-03-23T13:33:28Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/runtime/Listener.cpp", "diffHunk": "@@ -20,18 +20,309 @@\n  * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n  *******************************************************************************/\n \n-#include \"runtime/Listener.hpp\"\n-#include \"net/ServerStream.hpp\"\n+#include <arpa/inet.h>\n+#include <chrono>\n+#include <fcntl.h>\n+#include <netdb.h>\n+#include <netinet/in.h>\n+#include <netinet/tcp.h>\t/* for TCP_NODELAY option */\n+#include <openssl/err.h>\n+#include <poll.h>\n+#include <sys/types.h>\n+#include <sys/socket.h>\n+#include <sys/un.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <unistd.h> /// gethostname, read, write\n+#include \"control/CompilationRuntime.hpp\"\n+#include \"env/TRMemory.hpp\"\n #include \"env/VMJ9.h\"\n+#include \"net/CommunicationStream.hpp\"\n+#include \"net/LoadSSLLibs.hpp\"\n+#include \"net/ServerStream.hpp\"\n+#include \"net/SSLProtobufStream.hpp\"\n #include \"runtime/CompileService.hpp\"\n-#include \"control/CompilationRuntime.hpp\"\n+#include \"runtime/Listener.hpp\"\n+\n+static SSL_CTX *\n+createSSLContext(TR::PersistentInfo *info)\n+   {\n+   SSL_CTX *ctx = (*OSSL_CTX_new)((*OSSLv23_server_method)());\n+\n+   if (!ctx)\n+      {\n+      perror(\"can't create SSL context\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   const char *sessionIDContext = \"JITServer\";\n+   (*OSSL_CTX_set_session_id_context)(ctx, (const unsigned char*)sessionIDContext, strlen(sessionIDContext));\n+\n+   if ((*OSSL_CTX_set_ecdh_auto)(ctx, 1) != 1)\n+      {\n+      perror(\"failed to configure SSL ecdh\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   TR::CompilationInfo *compInfo = TR::CompilationInfo::get();\n+   auto &sslKeys = compInfo->getJITServerSslKeys();\n+   auto &sslCerts = compInfo->getJITServerSslCerts();\n+   auto &sslRootCerts = compInfo->getJITServerSslRootCerts();\n+\n+   TR_ASSERT_FATAL(sslKeys.size() == 1 && sslCerts.size() == 1, \"only one key and cert is supported for now\");\n+   TR_ASSERT_FATAL(sslRootCerts.size() == 0, \"server does not understand root certs yet\");\n+\n+   // Parse and set private key\n+   BIO *keyMem = (*OBIO_new_mem_buf)(&sslKeys[0][0], sslKeys[0].size());\n+   if (!keyMem)\n+      {\n+      perror(\"cannot create memory buffer for private key (OOM?)\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   EVP_PKEY *privKey = (*OPEM_read_bio_PrivateKey)(keyMem, NULL, NULL, NULL);\n+   if (!privKey)\n+      {\n+      perror(\"cannot parse private key\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   if ((*OSSL_CTX_use_PrivateKey)(ctx, privKey) != 1)\n+      {\n+      perror(\"cannot use private key\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // Parse and set certificate\n+   BIO *certMem = (*OBIO_new_mem_buf)(&sslCerts[0][0], sslCerts[0].size());\n+   if (!certMem)\n+      {\n+      perror(\"cannot create memory buffer for cert (OOM?)\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   X509 *certificate = (*OPEM_read_bio_X509)(certMem, NULL, NULL, NULL);\n+   if (!certificate)\n+      {\n+      perror(\"cannot parse cert\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   if ((*OSSL_CTX_use_certificate)(ctx, certificate) != 1)\n+      {\n+      perror(\"cannot use cert\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // Verify key and cert are valid\n+   if ((*OSSL_CTX_check_private_key)(ctx) != 1)\n+      {\n+      perror(\"private key check failed\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // verify server identity using standard method\n+   (*OSSL_CTX_set_verify)(ctx, SSL_VERIFY_PEER, NULL);\n+\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+      TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"Successfully initialized SSL context (%s)\\n\", (*OOpenSSL_version)(0));\n+\n+   return ctx;\n+   }\n+\n+static bool\n+handleOpenSSLConnectionError(int connfd, SSL *&ssl, BIO *&bio, const char *errMsg)\n+{\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+       TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"%s: errno=%d\", errMsg, errno);\n+   (*OERR_print_errors_fp)(stderr);\n+\n+   close(connfd);\n+   if (bio)\n+      {\n+      (*OBIO_free_all)(bio);\n+      bio = NULL;\n+      }\n+   if (ssl)\n+      {\n+      (*OSSL_free)(ssl);\n+      ssl = NULL;\n+      }\n+   return false;\n+}\n+\n+static bool\n+acceptOpenSSLConnection(SSL_CTX *sslCtx, int connfd, BIO *&bio)\n+   {\n+   SSL *ssl = (*OSSL_new)(sslCtx);\n+   if (!ssl)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error creating SSL connection\");\n+\n+   (*OSSL_set_accept_state)(ssl);\n+\n+   if ((*OSSL_set_fd)(ssl, connfd) != 1)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error setting SSL file descriptor\");\n+\n+   if ((*OSSL_accept)(ssl) <= 0)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error accepting SSL connection\");\n+\n+   bio = (*OBIO_new_ssl)(sslCtx, false);\n+   if (!bio)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error creating new BIO\");\n+\n+   if ((*OBIO_ctrl)(bio, BIO_C_SET_SSL, true, (char *)ssl) != 1) // BIO_set_ssl(bio, ssl, true)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error setting BIO SSL\");\n+\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+      TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"SSL connection on socket 0x%x, Version: %s, Cipher: %s\\n\",\n+                                                     connfd, (*OSSL_get_version)(ssl), (*OSSL_get_cipher)(ssl));\n+   return true;\n+   }\n \n TR_Listener::TR_Listener()\n    : _listenerThread(NULL), _listenerMonitor(NULL), _listenerOSThread(NULL), \n    _listenerThreadAttachAttempted(false), _listenerThreadExitFlag(false)\n    {\n    }\n \n+void\n+TR_Listener::serveRemoteCompilationRequests(BaseCompileDispatcher *compiler)\n+   {\n+   TR::PersistentInfo *info = getCompilationInfo(jitConfig)->getPersistentInfo();\n+   SSL_CTX *sslCtx = NULL;\n+   if (JITServer::CommunicationStream::useSSL())\n+      {\n+      JITServer::CommunicationStream::initSSL();\n+      sslCtx = createSSLContext(info);\n+      }\n+\n+   uint32_t port = info->getJITServerPort();\n+   uint32_t timeoutMs = info->getSocketTimeout();\n+   struct pollfd pfd = {0};\n+   int sockfd = socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, 0);\n+   if (sockfd < 0)\n+      {\n+      perror(\"can't open server socket\");\n+      exit(1);\n+      }\n+\n+   // see `man 7 socket` for option explanations\n+   int flag = true;\n+   if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, (void *)&flag, sizeof(flag)) < 0)\n+      {\n+      perror(\"Can't set SO_REUSEADDR\");\n+      exit(-1);\n+      }\n+   if (setsockopt(sockfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&flag, sizeof(flag)) < 0)\n+      {\n+      perror(\"Can't set SO_KEEPALIVE\");\n+      exit(-1);\n+      }\n+\n+   struct sockaddr_in serv_addr;\n+   memset((char *)&serv_addr, 0, sizeof(serv_addr));\n+   serv_addr.sin_family = AF_INET;\n+   serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);\n+   serv_addr.sin_port = htons(port);\n+\n+   if (bind(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0)\n+      {\n+      perror(\"can't bind server address\");\n+      exit(1);\n+      }\n+   if (listen(sockfd, SOMAXCONN) < 0)\n+      {\n+      perror(\"listen failed\");\n+      exit(1);\n+      }\n+\n+   pfd.fd = sockfd;\n+   pfd.events = POLLIN;\n+\n+   while (!getListenerThreadExitFlag())\n+      {\n+      int32_t rc = 0;\n+      struct sockaddr_in cli_addr;\n+      socklen_t clilen = sizeof(cli_addr);\n+      int connfd = -1;\n+\n+      rc = poll(&pfd, 1, OPENJ9_LISTENER_POLL_TIMEOUT);\n+      if (0 == rc) // poll() timed out and no fd is ready\n+         {\n+         continue;\n+         }\n+      else if (getListenerThreadExitFlag()) // if we are exiting, there is no need to accept() new connection", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68c9014ea8432c2531457a5eef3754e2bc26be96"}, "originalPosition": 243}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1ODc2NDQ1OnYy", "diffSide": "RIGHT", "path": "runtime/j9vm/jvm.c", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxNzo0NDo1OVrOF6Q4UA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxOTo0MDoyNFrOF6VO4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjYzODI4OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Stopts the JITServer.\n          \n          \n            \n             * Stops the JITServer.", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r396638288", "createdAt": "2020-03-23T17:44:59Z", "author": {"login": "DanHeidinga"}, "path": "runtime/j9vm/jvm.c", "diffHunk": "@@ -1567,6 +1571,22 @@ waitForJITServerTermination(JITServer *jitServer)\n \t}\n \treturn rc;\n }\n+\n+/**\n+ * Stopts the JITServer.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0493378ca973e22e4243db6c1588ac7fe2378f89"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjcwOTYwMw==", "bodyText": "Done", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r396709603", "createdAt": "2020-03-23T19:40:24Z", "author": {"login": "ashu-mehra"}, "path": "runtime/j9vm/jvm.c", "diffHunk": "@@ -1567,6 +1571,22 @@ waitForJITServerTermination(JITServer *jitServer)\n \t}\n \treturn rc;\n }\n+\n+/**\n+ * Stopts the JITServer.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjYzODI4OA=="}, "originalCommit": {"oid": "0493378ca973e22e4243db6c1588ac7fe2378f89"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MjYxOTQ3OnYy", "diffSide": "RIGHT", "path": "runtime/j9vm/jvm.c", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxNTo0ODo1OFrOF62xaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxNDo0ODo0MFrOF8Kjqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI1OTExNQ==", "bodyText": "If this is freeing the jitServer, it should take a pointer to the pointer and update it to null.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            stopJITServer(JITServer *jitServer)\n          \n          \n            \n            stopJITServer(JITServer **jitServer)", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r397259115", "createdAt": "2020-03-24T15:48:58Z", "author": {"login": "DanHeidinga"}, "path": "runtime/j9vm/jvm.c", "diffHunk": "@@ -1567,6 +1571,22 @@ waitForJITServerTermination(JITServer *jitServer)\n \t}\n \treturn rc;\n }\n+\n+/**\n+ * Stops the JITServer.\n+ *\n+ * @param jitServer pointer to the JITServer interface\n+ *\n+ * @returns void\n+ */\n+static void\n+stopJITServer(JITServer *jitServer)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85f9af8d79769368bec576c717038cbdc2018ba8"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODYzMTg1MA==", "bodyText": "Done", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r398631850", "createdAt": "2020-03-26T14:48:40Z", "author": {"login": "ashu-mehra"}, "path": "runtime/j9vm/jvm.c", "diffHunk": "@@ -1567,6 +1571,22 @@ waitForJITServerTermination(JITServer *jitServer)\n \t}\n \treturn rc;\n }\n+\n+/**\n+ * Stops the JITServer.\n+ *\n+ * @param jitServer pointer to the JITServer interface\n+ *\n+ * @returns void\n+ */\n+static void\n+stopJITServer(JITServer *jitServer)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI1OTExNQ=="}, "originalCommit": {"oid": "85f9af8d79769368bec576c717038cbdc2018ba8"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MjYyMTU0OnYy", "diffSide": "RIGHT", "path": "runtime/j9vm/jvm.c", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxNTo0OToyM1rOF62ywQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxNDo0ODo0NFrOF8Kj5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI1OTQ1Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tfree(jitServer);\n          \n          \n            \n            \tfree(*jitServer);\n          \n          \n            \n            \t*jitServer = NULL;", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r397259457", "createdAt": "2020-03-24T15:49:23Z", "author": {"login": "DanHeidinga"}, "path": "runtime/j9vm/jvm.c", "diffHunk": "@@ -1567,6 +1571,22 @@ waitForJITServerTermination(JITServer *jitServer)\n \t}\n \treturn rc;\n }\n+\n+/**\n+ * Stops the JITServer.\n+ *\n+ * @param jitServer pointer to the JITServer interface\n+ *\n+ * @returns void\n+ */\n+static void\n+stopJITServer(JITServer *jitServer)\n+{\n+\tJavaVM *vm = jitServer->jvm;\n+\t(*vm)->DestroyJavaVM(vm);\n+\tfree(jitServer);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85f9af8d79769368bec576c717038cbdc2018ba8"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODYzMTkxMA==", "bodyText": "Done", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r398631910", "createdAt": "2020-03-26T14:48:44Z", "author": {"login": "ashu-mehra"}, "path": "runtime/j9vm/jvm.c", "diffHunk": "@@ -1567,6 +1571,22 @@ waitForJITServerTermination(JITServer *jitServer)\n \t}\n \treturn rc;\n }\n+\n+/**\n+ * Stops the JITServer.\n+ *\n+ * @param jitServer pointer to the JITServer interface\n+ *\n+ * @returns void\n+ */\n+static void\n+stopJITServer(JITServer *jitServer)\n+{\n+\tJavaVM *vm = jitServer->jvm;\n+\t(*vm)->DestroyJavaVM(vm);\n+\tfree(jitServer);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI1OTQ1Nw=="}, "originalCommit": {"oid": "85f9af8d79769368bec576c717038cbdc2018ba8"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MjY3MDQ5OnYy", "diffSide": "RIGHT", "path": "runtime/j9vm/jvm.c", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxNTo1OToyMlrOF63SVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxNDo0ODo1NVrOF8Kkkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI2NzU0MQ==", "bodyText": "Should this return a jint /int32_t?  It would allow propagating the result from DestroyJavaVM", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r397267541", "createdAt": "2020-03-24T15:59:22Z", "author": {"login": "DanHeidinga"}, "path": "runtime/j9vm/jvm.c", "diffHunk": "@@ -1567,6 +1571,22 @@ waitForJITServerTermination(JITServer *jitServer)\n \t}\n \treturn rc;\n }\n+\n+/**\n+ * Stops the JITServer.\n+ *\n+ * @param jitServer pointer to the JITServer interface\n+ *\n+ * @returns void\n+ */\n+static void", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85f9af8d79769368bec576c717038cbdc2018ba8"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODYzMjA4Mg==", "bodyText": "Done", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r398632082", "createdAt": "2020-03-26T14:48:55Z", "author": {"login": "ashu-mehra"}, "path": "runtime/j9vm/jvm.c", "diffHunk": "@@ -1567,6 +1571,22 @@ waitForJITServerTermination(JITServer *jitServer)\n \t}\n \treturn rc;\n }\n+\n+/**\n+ * Stops the JITServer.\n+ *\n+ * @param jitServer pointer to the JITServer interface\n+ *\n+ * @returns void\n+ */\n+static void", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI2NzU0MQ=="}, "originalCommit": {"oid": "85f9af8d79769368bec576c717038cbdc2018ba8"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MjY3MjY1OnYy", "diffSide": "RIGHT", "path": "runtime/oti/jitserver_api.h", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxNTo1OTo1MVrOF63T1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxODoxODozN1rOF8UW2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI2NzkyNg==", "bodyText": "nitpick to make it consistent with the other 2 functions\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tvoid (*stopJITServer)(struct JITServer *);\n          \n          \n            \n            \tvoid (* stopJITServer)(struct JITServer *);", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r397267926", "createdAt": "2020-03-24T15:59:51Z", "author": {"login": "DanHeidinga"}, "path": "runtime/oti/jitserver_api.h", "diffHunk": "@@ -34,6 +34,7 @@ struct JITServer; /* Forward declaration */\n typedef struct JITServer {\n \tint32_t (* startJITServer)(struct JITServer *);\n \tint32_t (* waitForJITServerTermination)(struct JITServer *);\n+\tvoid (*stopJITServer)(struct JITServer *);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85f9af8d79769368bec576c717038cbdc2018ba8"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI3MTg1NQ==", "bodyText": "It would be good to document each of these functions if they are intended to be used by end users akin to Java's Invocation API", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r397271855", "createdAt": "2020-03-24T16:04:45Z", "author": {"login": "DanHeidinga"}, "path": "runtime/oti/jitserver_api.h", "diffHunk": "@@ -34,6 +34,7 @@ struct JITServer; /* Forward declaration */\n typedef struct JITServer {\n \tint32_t (* startJITServer)(struct JITServer *);\n \tint32_t (* waitForJITServerTermination)(struct JITServer *);\n+\tvoid (*stopJITServer)(struct JITServer *);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI2NzkyNg=="}, "originalCommit": {"oid": "85f9af8d79769368bec576c717038cbdc2018ba8"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODE3MDI5Ng==", "bodyText": "Do you want me to add comments like this to the function pointers in JITServer structure, or you are referring to documenting these APIs separately in a markdown doc?", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r398170296", "createdAt": "2020-03-25T21:08:16Z", "author": {"login": "ashu-mehra"}, "path": "runtime/oti/jitserver_api.h", "diffHunk": "@@ -34,6 +34,7 @@ struct JITServer; /* Forward declaration */\n typedef struct JITServer {\n \tint32_t (* startJITServer)(struct JITServer *);\n \tint32_t (* waitForJITServerTermination)(struct JITServer *);\n+\tvoid (*stopJITServer)(struct JITServer *);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI2NzkyNg=="}, "originalCommit": {"oid": "85f9af8d79769368bec576c717038cbdc2018ba8"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODc5MjQwOA==", "bodyText": "Those kinds of comments would be a good start.  Eventually we'll want the markdown file that describes the API and how to use it but that can be done in a separate PR", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r398792408", "createdAt": "2020-03-26T18:18:37Z", "author": {"login": "DanHeidinga"}, "path": "runtime/oti/jitserver_api.h", "diffHunk": "@@ -34,6 +34,7 @@ struct JITServer; /* Forward declaration */\n typedef struct JITServer {\n \tint32_t (* startJITServer)(struct JITServer *);\n \tint32_t (* waitForJITServerTermination)(struct JITServer *);\n+\tvoid (*stopJITServer)(struct JITServer *);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI2NzkyNg=="}, "originalCommit": {"oid": "85f9af8d79769368bec576c717038cbdc2018ba8"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MjY4NDEzOnYy", "diffSide": "RIGHT", "path": "runtime/j9vm/jvm.c", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxNjowMjoxOVrOF63bfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxODozODowN1rOF7pJzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI2OTg4Ng==", "bodyText": "Does this actually stop the server?  DestroyJavaVM typically waits until there are no-non daemon threads - are you intentionally depending on that behaviour?  Would be good to add a comment here if that's the intention", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r397269886", "createdAt": "2020-03-24T16:02:19Z", "author": {"login": "DanHeidinga"}, "path": "runtime/j9vm/jvm.c", "diffHunk": "@@ -1567,6 +1571,22 @@ waitForJITServerTermination(JITServer *jitServer)\n \t}\n \treturn rc;\n }\n+\n+/**\n+ * Stops the JITServer.\n+ *\n+ * @param jitServer pointer to the JITServer interface\n+ *\n+ * @returns void\n+ */\n+static void\n+stopJITServer(JITServer *jitServer)\n+{\n+\tJavaVM *vm = jitServer->jvm;\n+\t(*vm)->DestroyJavaVM(vm);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85f9af8d79769368bec576c717038cbdc2018ba8"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODA2Njk4Mw==", "bodyText": "From JITServer point of view we only want to terminate the Listener thread and we get this chance when DestroyJavaVM is invoked (protectedDestroyJavaVM -> runExitStages -> jitExclusiveVMShutdownPending -> listener->stop).", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r398066983", "createdAt": "2020-03-25T18:10:50Z", "author": {"login": "ashu-mehra"}, "path": "runtime/j9vm/jvm.c", "diffHunk": "@@ -1567,6 +1571,22 @@ waitForJITServerTermination(JITServer *jitServer)\n \t}\n \treturn rc;\n }\n+\n+/**\n+ * Stops the JITServer.\n+ *\n+ * @param jitServer pointer to the JITServer interface\n+ *\n+ * @returns void\n+ */\n+static void\n+stopJITServer(JITServer *jitServer)\n+{\n+\tJavaVM *vm = jitServer->jvm;\n+\t(*vm)->DestroyJavaVM(vm);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI2OTg4Ng=="}, "originalCommit": {"oid": "85f9af8d79769368bec576c717038cbdc2018ba8"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODA3MTUwMw==", "bodyText": "Then I'm very unclear on the way to use the APIs here.  When does stopJITServer get called vs waitForJITServerTermination?", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r398071503", "createdAt": "2020-03-25T18:17:42Z", "author": {"login": "DanHeidinga"}, "path": "runtime/j9vm/jvm.c", "diffHunk": "@@ -1567,6 +1571,22 @@ waitForJITServerTermination(JITServer *jitServer)\n \t}\n \treturn rc;\n }\n+\n+/**\n+ * Stops the JITServer.\n+ *\n+ * @param jitServer pointer to the JITServer interface\n+ *\n+ * @returns void\n+ */\n+static void\n+stopJITServer(JITServer *jitServer)\n+{\n+\tJavaVM *vm = jitServer->jvm;\n+\t(*vm)->DestroyJavaVM(vm);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI2OTg4Ng=="}, "originalCommit": {"oid": "85f9af8d79769368bec576c717038cbdc2018ba8"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODA4NDU1OQ==", "bodyText": "My reply here probably addresses your question to some extent.", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r398084559", "createdAt": "2020-03-25T18:38:07Z", "author": {"login": "ashu-mehra"}, "path": "runtime/j9vm/jvm.c", "diffHunk": "@@ -1567,6 +1571,22 @@ waitForJITServerTermination(JITServer *jitServer)\n \t}\n \treturn rc;\n }\n+\n+/**\n+ * Stops the JITServer.\n+ *\n+ * @param jitServer pointer to the JITServer interface\n+ *\n+ * @returns void\n+ */\n+static void\n+stopJITServer(JITServer *jitServer)\n+{\n+\tJavaVM *vm = jitServer->jvm;\n+\t(*vm)->DestroyJavaVM(vm);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI2OTg4Ng=="}, "originalCommit": {"oid": "85f9af8d79769368bec576c717038cbdc2018ba8"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MjY5OTk1OnYy", "diffSide": "RIGHT", "path": "runtime/j9vm/jvm.c", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxNjowNTo0NlrOF63mFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxOTowNzoxMVrOF8WRow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI3MjU5OA==", "bodyText": "I don't see a call to this function occurring anywhere.  Should the jitserver launcher be updated to call it after waiting for waitForJITServerTermination() to free resources?\nhttps://github.com/eclipse/openj9/blob/f2034099d7765870ecae55540642096e847fac52/runtime/jitserver_launcher/jitserver.c#L361", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r397272598", "createdAt": "2020-03-24T16:05:46Z", "author": {"login": "DanHeidinga"}, "path": "runtime/j9vm/jvm.c", "diffHunk": "@@ -1492,6 +1495,7 @@ JITServer_CreateServer(JITServer **jitServer, void *serverArgs)\n \t}\n \tserver->startJITServer = startJITServer;\n \tserver->waitForJITServerTermination = waitForJITServerTermination;\n+\tserver->stopJITServer = stopJITServer;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85f9af8d79769368bec576c717038cbdc2018ba8"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODA3MTA5MA==", "bodyText": "Yes, jitserver would need to be updated to call stopJITServer, but we don't yet have any trigger to call this function. waitForJITServerTermination API should ideally be waiting for some 'event' which would tell jitserver to call stopJITServer, but we don't yet have that \"event\" in place.\nAs per the discussion in the parent issue, the mechanism to call stopJITServer needs to be discussed separately.", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r398071090", "createdAt": "2020-03-25T18:17:05Z", "author": {"login": "ashu-mehra"}, "path": "runtime/j9vm/jvm.c", "diffHunk": "@@ -1492,6 +1495,7 @@ JITServer_CreateServer(JITServer **jitServer, void *serverArgs)\n \t}\n \tserver->startJITServer = startJITServer;\n \tserver->waitForJITServerTermination = waitForJITServerTermination;\n+\tserver->stopJITServer = stopJITServer;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI3MjU5OA=="}, "originalCommit": {"oid": "85f9af8d79769368bec576c717038cbdc2018ba8"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODc5ODI3Nw==", "bodyText": "Part of my problem with understanding the API is the rename from JITServer_DestroyServer -> stopJITServer as it confuses the purpose of the function and breaks the parallel with the JITServer_CreateServer call.\nIf this new function was changed back to destoryJITServer or similar name, the difference between it and waitForJITServerTermination would be clearer.  The expected pattern would then be something like:\nJITServer_CreateServer(&jitServer, ...);\n....\njitServer-> waitForJITServerTermination();\n//clean up resources\njitServer->destroyJITServer(&jitServer);\nwhere destroyJITServer would be responsible for freeing the resources allocated by CreateServer", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r398798277", "createdAt": "2020-03-26T18:27:19Z", "author": {"login": "DanHeidinga"}, "path": "runtime/j9vm/jvm.c", "diffHunk": "@@ -1492,6 +1495,7 @@ JITServer_CreateServer(JITServer **jitServer, void *serverArgs)\n \t}\n \tserver->startJITServer = startJITServer;\n \tserver->waitForJITServerTermination = waitForJITServerTermination;\n+\tserver->stopJITServer = stopJITServer;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI3MjU5OA=="}, "originalCommit": {"oid": "85f9af8d79769368bec576c717038cbdc2018ba8"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODgyMzg0Mw==", "bodyText": "ok, I don't mind changing the api from stopJITServer to destroyJITServer.", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r398823843", "createdAt": "2020-03-26T19:07:11Z", "author": {"login": "ashu-mehra"}, "path": "runtime/j9vm/jvm.c", "diffHunk": "@@ -1492,6 +1495,7 @@ JITServer_CreateServer(JITServer **jitServer, void *serverArgs)\n \t}\n \tserver->startJITServer = startJITServer;\n \tserver->waitForJITServerTermination = waitForJITServerTermination;\n+\tserver->stopJITServer = stopJITServer;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI3MjU5OA=="}, "originalCommit": {"oid": "85f9af8d79769368bec576c717038cbdc2018ba8"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4NzkzODI3OnYy", "diffSide": "RIGHT", "path": "runtime/j9vm/jvm.c", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQyMDowNjowMFrOF-mLKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQyMDowNjowMFrOF-mLKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE4MTQ4MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Stops the JITServer.\n          \n          \n            \n             * Frees the resources allocated by JITServer_CreateServer.", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r401181480", "createdAt": "2020-03-31T20:06:00Z", "author": {"login": "DanHeidinga"}, "path": "runtime/j9vm/jvm.c", "diffHunk": "@@ -1567,6 +1572,31 @@ waitForJITServerTermination(JITServer *jitServer)\n \t}\n \treturn rc;\n }\n+\n+/**\n+ * Stops the JITServer.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a197144440bc0248e5ca915ee06838cdf8ee11d"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4Nzk0MDAxOnYy", "diffSide": "RIGHT", "path": "runtime/j9vm/jvm.c", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQyMDowNjozNVrOF-mMSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQyMDowNjozNVrOF-mMSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE4MTc2OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * @param jitServer double pointer to the JITServer interface\n          \n          \n            \n             * @param jitServer double pointer to the JITServer interface.  Must not be null", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r401181768", "createdAt": "2020-03-31T20:06:35Z", "author": {"login": "DanHeidinga"}, "path": "runtime/j9vm/jvm.c", "diffHunk": "@@ -1567,6 +1572,31 @@ waitForJITServerTermination(JITServer *jitServer)\n \t}\n \treturn rc;\n }\n+\n+/**\n+ * Stops the JITServer.\n+ *\n+ * @param jitServer double pointer to the JITServer interface", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a197144440bc0248e5ca915ee06838cdf8ee11d"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4Nzk0MjMxOnYy", "diffSide": "RIGHT", "path": "runtime/oti/jitserver_api.h", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQyMDowNzowM1rOF-mNmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQyMDowNzowM1rOF-mNmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE4MjEwNA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t * Stops the JITServer.\n          \n          \n            \n            \t * Frees the resources allocated by JITServer_CreateServer.", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r401182104", "createdAt": "2020-03-31T20:07:03Z", "author": {"login": "DanHeidinga"}, "path": "runtime/oti/jitserver_api.h", "diffHunk": "@@ -32,8 +32,32 @@ extern \"C\" {\n struct JITServer; /* Forward declaration */\n \n typedef struct JITServer {\n+\t/**\n+\t * Starts an instance of JITServer.\n+\t *\n+\t * @param jitServer pointer to the JITServer interface\n+\t *\n+\t * @returns JITSERVER_OK on success, else negative error code\n+\t */\n \tint32_t (* startJITServer)(struct JITServer *);\n+\t/**\n+\t * Wait for JITServer to terminate.\n+\t *\n+\t * @param jitServer pointer to the JITServer interface\n+\t *\n+\t * @returns JITSERVER_OK on success, else negative error code\n+\t */\n \tint32_t (* waitForJITServerTermination)(struct JITServer *);\n+\t/**\n+\t * Stops the JITServer.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a197144440bc0248e5ca915ee06838cdf8ee11d"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4Nzk0OTc0OnYy", "diffSide": "RIGHT", "path": "runtime/j9vm/jvm.c", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQyMDowOTowNVrOF-mSKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQyMDowOTowNVrOF-mSKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE4MzI3NQ==", "bodyText": "This loses the reason for why DestroyJavaVM failed.  Unfortunate given this is returning JITSERVER error codes.  Tracepoints would help here - something to consider for the future - but not for this PR.", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r401183275", "createdAt": "2020-03-31T20:09:05Z", "author": {"login": "DanHeidinga"}, "path": "runtime/j9vm/jvm.c", "diffHunk": "@@ -1567,6 +1572,31 @@ waitForJITServerTermination(JITServer *jitServer)\n \t}\n \treturn rc;\n }\n+\n+/**\n+ * Stops the JITServer.\n+ *\n+ * @param jitServer double pointer to the JITServer interface\n+ *\n+ * @returns JITSERVER_OK on success, else negative error code\n+ *\n+ * @note on return *jitServer is set to NULL\n+ */\n+static int32_t\n+destroyJITServer(JITServer **jitServer)\n+{\n+\tJavaVM *vm = (*jitServer)->jvm;\n+\tjint rc = (*vm)->DestroyJavaVM(vm);\n+\tfree(*jitServer);\n+\t*jitServer = NULL;\n+\tif (JNI_OK == rc) {\n+\t\trc = JITSERVER_OK;\n+\t} else {\n+\t\trc = JITSERVER_DESTROY_ERROR;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a197144440bc0248e5ca915ee06838cdf8ee11d"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4Nzk1MzM4OnYy", "diffSide": "RIGHT", "path": "runtime/oti/jitserver_api.h", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQyMDoxMDowMlrOF-mUVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxNToyMDo0MFrOF_FwhA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE4MzgyOA==", "bodyText": "Now that it's clear this frees the resources, I'd like to see it called by the jitserver launcher.  It can be called after 1 waitForJITServerTermination` returns", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r401183828", "createdAt": "2020-03-31T20:10:02Z", "author": {"login": "DanHeidinga"}, "path": "runtime/oti/jitserver_api.h", "diffHunk": "@@ -32,8 +32,32 @@ extern \"C\" {\n struct JITServer; /* Forward declaration */\n \n typedef struct JITServer {\n+\t/**\n+\t * Starts an instance of JITServer.\n+\t *\n+\t * @param jitServer pointer to the JITServer interface\n+\t *\n+\t * @returns JITSERVER_OK on success, else negative error code\n+\t */\n \tint32_t (* startJITServer)(struct JITServer *);\n+\t/**\n+\t * Wait for JITServer to terminate.\n+\t *\n+\t * @param jitServer pointer to the JITServer interface\n+\t *\n+\t * @returns JITSERVER_OK on success, else negative error code\n+\t */\n \tint32_t (* waitForJITServerTermination)(struct JITServer *);\n+\t/**\n+\t * Stops the JITServer.\n+\t *\n+\t * @param jitServer double pointer to the JITServer interface\n+\t *\n+\t * @returns JITSERVER_OK on success, else negative error code\n+\t *\n+\t * @note on return *jitServer is set to NULL\n+\t */\n+\tint32_t (* destroyJITServer)(struct JITServer **);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a197144440bc0248e5ca915ee06838cdf8ee11d"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTY5ODk0OA==", "bodyText": "Added the call to destroyJITServer in jitserver launcher.", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r401698948", "createdAt": "2020-04-01T15:20:40Z", "author": {"login": "ashu-mehra"}, "path": "runtime/oti/jitserver_api.h", "diffHunk": "@@ -32,8 +32,32 @@ extern \"C\" {\n struct JITServer; /* Forward declaration */\n \n typedef struct JITServer {\n+\t/**\n+\t * Starts an instance of JITServer.\n+\t *\n+\t * @param jitServer pointer to the JITServer interface\n+\t *\n+\t * @returns JITSERVER_OK on success, else negative error code\n+\t */\n \tint32_t (* startJITServer)(struct JITServer *);\n+\t/**\n+\t * Wait for JITServer to terminate.\n+\t *\n+\t * @param jitServer pointer to the JITServer interface\n+\t *\n+\t * @returns JITSERVER_OK on success, else negative error code\n+\t */\n \tint32_t (* waitForJITServerTermination)(struct JITServer *);\n+\t/**\n+\t * Stops the JITServer.\n+\t *\n+\t * @param jitServer double pointer to the JITServer interface\n+\t *\n+\t * @returns JITSERVER_OK on success, else negative error code\n+\t *\n+\t * @note on return *jitServer is set to NULL\n+\t */\n+\tint32_t (* destroyJITServer)(struct JITServer **);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE4MzgyOA=="}, "originalCommit": {"oid": "3a197144440bc0248e5ca915ee06838cdf8ee11d"}, "originalPosition": 29}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 528, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}