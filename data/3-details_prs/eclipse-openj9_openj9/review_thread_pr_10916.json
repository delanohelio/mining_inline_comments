{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA1MDgzMTQ2", "number": 10916, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQxODo1MDo1OFrOEvdVDQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxNzoxMzozMVrOE4wUMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4MTk5MDUzOnYy", "diffSide": "LEFT", "path": "runtime/compiler/codegen/J9AheadOfTimeCompile.cpp", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQxODo1MDo1OFrOHkdEKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQxNjozMzoxM1rOH0G_aw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzk4Njk4NQ==", "bodyText": "The reason for this is because of an ordering issue, namely:\n\nDo platform specific way of gathering data for the relocation header, if it exists\nOtherwse, do common way of gathering data for the relocation header\n\nIf a relo type has both a platform specific implementation and a common implementation, the platform specific implementation must be done. This means that even though this deleted code is common regardless of the relotype, we cannot move it into the code that does the common way of gathering data, because we might not call into it. Therefore, this code is moved into each of the platform specific versions of initializeAOTRelocationHeader", "url": "https://github.com/eclipse-openj9/openj9/pull/10916#discussion_r507986985", "createdAt": "2020-10-19T18:50:58Z", "author": {"login": "dsouzai"}, "path": "runtime/compiler/codegen/J9AheadOfTimeCompile.cpp", "diffHunk": "@@ -994,12 +994,6 @@ J9::AheadOfTimeCompile::initializeCommonAOTRelocationHeader(TR::IteratedExternal\n          return cursor;\n       }\n \n-   reloRecord->setSize(reloTarget, relocation->getSizeOfRelocationData());\n-   reloRecord->setType(reloTarget, kind);\n-\n-   uint8_t wideOffsets = relocation->needsWideOffsets() ? RELOCATION_TYPE_WIDE_OFFSET : 0;\n-   reloRecord->setFlag(reloTarget, wideOffsets);\n-", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "211b73a5ee22b4d99daa7a56d3b7f86443260a6d"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzA1MjMxOQ==", "bodyText": "not a huge fan of spraying code like that. Did you consider defining a \"common\" initialization routine that must be called for all platforms followed/preceded by a call to either the platform or \"default\" initialization code? You'd still have the flexibility to move stuff from the \"common\" initialization routine to all the platform routines if needed, but if you could share it, it can go into that common routine.", "url": "https://github.com/eclipse-openj9/openj9/pull/10916#discussion_r523052319", "createdAt": "2020-11-13T16:13:45Z", "author": {"login": "mstoodle"}, "path": "runtime/compiler/codegen/J9AheadOfTimeCompile.cpp", "diffHunk": "@@ -994,12 +994,6 @@ J9::AheadOfTimeCompile::initializeCommonAOTRelocationHeader(TR::IteratedExternal\n          return cursor;\n       }\n \n-   reloRecord->setSize(reloTarget, relocation->getSizeOfRelocationData());\n-   reloRecord->setType(reloTarget, kind);\n-\n-   uint8_t wideOffsets = relocation->needsWideOffsets() ? RELOCATION_TYPE_WIDE_OFFSET : 0;\n-   reloRecord->setFlag(reloTarget, wideOffsets);\n-", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzk4Njk4NQ=="}, "originalCommit": {"oid": "211b73a5ee22b4d99daa7a56d3b7f86443260a6d"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQwMjUzOQ==", "bodyText": "FWIW, this code was technically redundant because the the TR_RelocationRecordBinaryTemplate fields were being initialized in each of the various implementations via the raw pointer manipulation, before executing this code, so I definitely didn't increase the code duplication, I just didn't decrease it heh :).\nHowever, adding a common pre-initialization routine is definitely a good idea; I will add it in the misc clean up PR that I'll open after this. Given how big this PR is I don't want to complicate it further or introduce some stupid bug.", "url": "https://github.com/eclipse-openj9/openj9/pull/10916#discussion_r524402539", "createdAt": "2020-11-16T16:33:13Z", "author": {"login": "dsouzai"}, "path": "runtime/compiler/codegen/J9AheadOfTimeCompile.cpp", "diffHunk": "@@ -994,12 +994,6 @@ J9::AheadOfTimeCompile::initializeCommonAOTRelocationHeader(TR::IteratedExternal\n          return cursor;\n       }\n \n-   reloRecord->setSize(reloTarget, relocation->getSizeOfRelocationData());\n-   reloRecord->setType(reloTarget, kind);\n-\n-   uint8_t wideOffsets = relocation->needsWideOffsets() ? RELOCATION_TYPE_WIDE_OFFSET : 0;\n-   reloRecord->setFlag(reloTarget, wideOffsets);\n-", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzk4Njk4NQ=="}, "originalCommit": {"oid": "211b73a5ee22b4d99daa7a56d3b7f86443260a6d"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4MTk5ODg4OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/aarch64/codegen/J9AheadOfTimeCompile.cpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQxODo1MzowN1rOHkdJRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQxODo1MzowN1rOHkdJRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzk4ODI5NA==", "bodyText": "This is extremely necessary. Prior to this change, the flags were written in via a pointer. Now, it is written in using the setFlag API, which masks it in. Therefore, we need to make sure that buffer does not contain random data or it could result in that random data being interpreted as valid bits in the flag field.", "url": "https://github.com/eclipse-openj9/openj9/pull/10916#discussion_r507988294", "createdAt": "2020-10-19T18:53:07Z", "author": {"login": "dsouzai"}, "path": "runtime/compiler/aarch64/codegen/J9AheadOfTimeCompile.cpp", "diffHunk": "@@ -96,43 +96,27 @@ uint8_t *J9::ARM64::AheadOfTimeCompile::initializeAOTRelocationHeader(TR::Iterat\n    TR::Compilation* comp = TR::comp();\n    TR_J9VMBase *fej9 = (TR_J9VMBase *)(_cg->fe());\n    TR_SharedCache *sharedCache = fej9->sharedCache();\n-   TR::SymbolValidationManager *symValManager = comp->getSymbolValidationManager();\n-\n-   TR_VirtualGuard *guard;\n-   uint8_t flags = 0;\n-   TR_ResolvedMethod *resolvedMethod;\n-\n-   uint8_t *cursor = relocation->getRelocationData();\n-\n    TR_RelocationRuntime *reloRuntime = comp->reloRuntime();\n    TR_RelocationTarget *reloTarget = reloRuntime->reloTarget();\n \n-   uint8_t * aotMethodCodeStart = (uint8_t *) comp->getRelocatableMethodCodeStart();\n-   // size of relocation goes first in all types\n-   *(uint16_t *) cursor = relocation->getSizeOfRelocationData();\n+   uint8_t flags = 0;\n \n-   cursor += 2;\n+   uint8_t *cursor         = relocation->getRelocationData();\n+   uint8_t targetKind      = relocation->getTargetKind();\n+   uint16_t sizeOfReloData = relocation->getSizeOfRelocationData();\n \n-   uint8_t modifier = 0;\n-   uint8_t *relativeBitCursor = cursor;\n-   TR::LabelSymbol *table;\n-   uint8_t *codeLocation;\n+   // Zero-initialize header\n+   memset(cursor, 0, sizeOfReloData);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "211b73a5ee22b4d99daa7a56d3b7f86443260a6d"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4MjAwNzkzOnYy", "diffSide": "RIGHT", "path": "runtime/compiler/aarch64/codegen/J9AheadOfTimeCompile.cpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQxODo1NToxNlrOHkdOqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQxODo1NToxNlrOHkdOqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzk4OTY3NQ==", "bodyText": "Temporary in this commit, this is removed in the last commit in this PR. It was needed because the yet to be consolidated relocation records assume the position of the cursor is past the TR_RelocationRecordBinaryTemplate portion of the header.", "url": "https://github.com/eclipse-openj9/openj9/pull/10916#discussion_r507989675", "createdAt": "2020-10-19T18:55:16Z", "author": {"login": "dsouzai"}, "path": "runtime/compiler/aarch64/codegen/J9AheadOfTimeCompile.cpp", "diffHunk": "@@ -96,43 +96,27 @@ uint8_t *J9::ARM64::AheadOfTimeCompile::initializeAOTRelocationHeader(TR::Iterat\n    TR::Compilation* comp = TR::comp();\n    TR_J9VMBase *fej9 = (TR_J9VMBase *)(_cg->fe());\n    TR_SharedCache *sharedCache = fej9->sharedCache();\n-   TR::SymbolValidationManager *symValManager = comp->getSymbolValidationManager();\n-\n-   TR_VirtualGuard *guard;\n-   uint8_t flags = 0;\n-   TR_ResolvedMethod *resolvedMethod;\n-\n-   uint8_t *cursor = relocation->getRelocationData();\n-\n    TR_RelocationRuntime *reloRuntime = comp->reloRuntime();\n    TR_RelocationTarget *reloTarget = reloRuntime->reloTarget();\n \n-   uint8_t * aotMethodCodeStart = (uint8_t *) comp->getRelocatableMethodCodeStart();\n-   // size of relocation goes first in all types\n-   *(uint16_t *) cursor = relocation->getSizeOfRelocationData();\n+   uint8_t flags = 0;\n \n-   cursor += 2;\n+   uint8_t *cursor         = relocation->getRelocationData();\n+   uint8_t targetKind      = relocation->getTargetKind();\n+   uint16_t sizeOfReloData = relocation->getSizeOfRelocationData();\n \n-   uint8_t modifier = 0;\n-   uint8_t *relativeBitCursor = cursor;\n-   TR::LabelSymbol *table;\n-   uint8_t *codeLocation;\n+   // Zero-initialize header\n+   memset(cursor, 0, sizeOfReloData);\n \n-   if (relocation->needsWideOffsets())\n-      modifier |= RELOCATION_TYPE_WIDE_OFFSET;\n+   TR_RelocationRecord storage;\n+   TR_RelocationRecord *reloRecord = TR_RelocationRecord::create(&storage, reloRuntime, targetKind, reinterpret_cast<TR_RelocationRecordBinaryTemplate *>(cursor));\n \n-   uint8_t targetKind = relocation->getTargetKind();\n-   *cursor++ = targetKind;\n-   uint8_t *flagsCursor = cursor++;\n-   *flagsCursor = modifier;\n-   uint32_t *wordAfterHeader = (uint32_t*)cursor;\n-#if defined(TR_HOST_64BIT)\n-   cursor += 4; // padding\n-#endif\n+   uint8_t wideOffsets = relocation->needsWideOffsets() ? RELOCATION_TYPE_WIDE_OFFSET : 0;\n+   reloRecord->setSize(reloTarget, sizeOfReloData);\n+   reloRecord->setType(reloTarget, static_cast<TR_RelocationRecordType>(targetKind));\n+   reloRecord->setFlag(reloTarget, wideOffsets);\n \n-   // This has to be created after the kind has been written into the header\n-   TR_RelocationRecord storage;\n-   TR_RelocationRecord *reloRecord = TR_RelocationRecord::create(&storage, reloRuntime, reloTarget, reinterpret_cast<TR_RelocationRecordBinaryTemplate *>(relocation->getRelocationData()));\n+   cursor += sizeof(TR_RelocationRecordBinaryTemplate);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "211b73a5ee22b4d99daa7a56d3b7f86443260a6d"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4MjAxMzY4OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/x/codegen/J9AheadOfTimeCompile.cpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQxODo1NjozNFrOHkdSGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQxODo1NjozNFrOHkdSGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzk5MDU1Mg==", "bodyText": "Temporary, this is removed by the end of the PR. Consequence of the hacky\n#if defined(TR_HOST_64BIT)\n   uint32_t _extra;\n#endif\n\nfield in TR_RelocationRecordBinaryTemplate", "url": "https://github.com/eclipse-openj9/openj9/pull/10916#discussion_r507990552", "createdAt": "2020-10-19T18:56:34Z", "author": {"login": "dsouzai"}, "path": "runtime/compiler/x/codegen/J9AheadOfTimeCompile.cpp", "diffHunk": "@@ -123,34 +123,30 @@ uint8_t *J9::X86::AheadOfTimeCompile::initializeAOTRelocationHeader(TR::Iterated\n    TR_J9VMBase *fej9 = (TR_J9VMBase *)(_cg->fe());\n    TR_SharedCache *sharedCache = fej9->sharedCache();\n    TR::Compilation *comp = _cg->comp();\n-   TR::SymbolValidationManager *symValManager = comp->getSymbolValidationManager();\n-   uintptr_t numTrampolines;\n-   TR::LabelSymbol *label;\n-   TR_ResolvedMethod *resolvedMethod;\n-   TR_VirtualGuard *guard;\n-   uint8_t flags = 0;\n-   uint8_t *cursor = relocation->getRelocationData();\n-\n    TR_RelocationRuntime *reloRuntime = comp->reloRuntime();\n    TR_RelocationTarget *reloTarget = reloRuntime->reloTarget();\n+   uintptr_t numTrampolines;\n \n-   // size of relocation goes first in all types\n-   *(uint16_t *)cursor = relocation->getSizeOfRelocationData();\n-   cursor += 2;\n-   uint8_t  wideOffsets = relocation->needsWideOffsets() ? RELOCATION_TYPE_WIDE_OFFSET : 0;\n-   *cursor++ = (uint8_t)relocation->getTargetKind();\n-   uint8_t *flagsCursor = cursor++;\n-   *flagsCursor = wideOffsets;\n-   uint32_t *wordAfterHeader = (uint32_t*)cursor;\n-#if defined(TR_HOST_64BIT)\n-   cursor += 4; // padding\n-#endif\n+   uint8_t *cursor         = relocation->getRelocationData();\n+   uint8_t targetKind      = relocation->getTargetKind();\n+   uint16_t sizeOfReloData = relocation->getSizeOfRelocationData();\n+\n+   // Zero-initialize header\n+   memset(cursor, 0, sizeOfReloData);\n \n-   // This has to be created after the kind has been written into the header\n    TR_RelocationRecord storage;\n-   TR_RelocationRecord *reloRecord = TR_RelocationRecord::create(&storage, reloRuntime, reloTarget, reinterpret_cast<TR_RelocationRecordBinaryTemplate *>(relocation->getRelocationData()));\n+   TR_RelocationRecord *reloRecord = TR_RelocationRecord::create(&storage, reloRuntime, targetKind, reinterpret_cast<TR_RelocationRecordBinaryTemplate *>(cursor));\n+\n+   uint8_t wideOffsets = relocation->needsWideOffsets() ? RELOCATION_TYPE_WIDE_OFFSET : 0;\n+   uint32_t *wordAfterHeader = &reinterpret_cast<TR_RelocationRecordPicTrampolineBinaryTemplate *>(cursor)->_numTrampolines;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "211b73a5ee22b4d99daa7a56d3b7f86443260a6d"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3OTIzMzk3OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/arm/codegen/J9AheadOfTimeCompile.cpp", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxNjoyNDozN1rOHy1AVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQyMTozMzowMVrOH0TpSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzA1OTI4NQ==", "bodyText": "the fact that this relocation is implemented differently for this platform should probably be fixed at some point. Would you please create an issue for someone to bring these two implementations in line?", "url": "https://github.com/eclipse-openj9/openj9/pull/10916#discussion_r523059285", "createdAt": "2020-11-13T16:24:37Z", "author": {"login": "mstoodle"}, "path": "runtime/compiler/arm/codegen/J9AheadOfTimeCompile.cpp", "diffHunk": "@@ -133,18 +133,20 @@ uint8_t *J9::ARM::AheadOfTimeCompile::initializeAOTRelocationHeader(TR::Iterated\n       {\n       case TR_MethodObject:\n          {\n+         TR_RelocationRecordMethodObject *moRecord = reinterpret_cast<TR_RelocationRecordMethodObject *>(reloRecord);\n          TR_RelocationRecordInformation *recordInfo = (TR_RelocationRecordInformation*) relocation->getTargetAddress();\n-         TR::SymbolReference *tempSR = (TR::SymbolReference *) recordInfo->data1;\n-         uintptr_t inlinedSiteIndex = self()->findCorrectInlinedSiteIndex(tempSR->getOwningMethod(comp)->constantPool(), recordInfo->data2);\n-         uint8_t flags = (uint8_t) recordInfo->data3;//Sequence ID\n-         //TODO\n-         *(uintptr_t *)cursor = inlinedSiteIndex;\n-         cursor += SIZEPOINTER;\n-         // next word is the address of the constant pool to\n-         // which the index refers\n-         *(uintptr_t *)cursor =\n-            (uintptr_t)tempSR->getOwningMethod(TR::comp())->constantPool();\n-         cursor += SIZEPOINTER;\n+\n+         TR::SymbolReference *symRef = reinterpret_cast<TR::SymbolReference *>(recordInfo->data1);\n+         uintptr_t inlinedSiteIndex = self()->findCorrectInlinedSiteIndex(symRef->getOwningMethod(comp)->constantPool(), recordInfo->data2);\n+         uint8_t flags = static_cast<uint8_t>(reinterpret_cast<uintptr_t>(recordInfo->data3));\n+\n+         TR_ASSERT((flags & RELOCATION_CROSS_PLATFORM_FLAGS_MASK) == 0,  \"reloFlags bits overlap cross-platform flags bits\\n\");\n+\n+         moRecord->setInlinedSiteIndex(reloTarget, reinterpret_cast<uintptr_t>(inlinedSiteIndex));\n+         moRecord->setConstantPool(reloTarget, reinterpret_cast<uintptr_t>(symRef->getOwningMethod(comp)->constantPool()));\n+         moRecord->setReloFlags(reloTarget, flags);\n+\n+         cursor = relocation->getRelocationData() + TR_RelocationRecord::getSizeOfAOTRelocationHeader(static_cast<TR_RelocationRecordType>(targetKind));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e552771d1b2728862c96b69b61387ee137b0c4f"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDYwOTg2Nw==", "bodyText": "Opened #11201", "url": "https://github.com/eclipse-openj9/openj9/pull/10916#discussion_r524609867", "createdAt": "2020-11-16T21:33:01Z", "author": {"login": "dsouzai"}, "path": "runtime/compiler/arm/codegen/J9AheadOfTimeCompile.cpp", "diffHunk": "@@ -133,18 +133,20 @@ uint8_t *J9::ARM::AheadOfTimeCompile::initializeAOTRelocationHeader(TR::Iterated\n       {\n       case TR_MethodObject:\n          {\n+         TR_RelocationRecordMethodObject *moRecord = reinterpret_cast<TR_RelocationRecordMethodObject *>(reloRecord);\n          TR_RelocationRecordInformation *recordInfo = (TR_RelocationRecordInformation*) relocation->getTargetAddress();\n-         TR::SymbolReference *tempSR = (TR::SymbolReference *) recordInfo->data1;\n-         uintptr_t inlinedSiteIndex = self()->findCorrectInlinedSiteIndex(tempSR->getOwningMethod(comp)->constantPool(), recordInfo->data2);\n-         uint8_t flags = (uint8_t) recordInfo->data3;//Sequence ID\n-         //TODO\n-         *(uintptr_t *)cursor = inlinedSiteIndex;\n-         cursor += SIZEPOINTER;\n-         // next word is the address of the constant pool to\n-         // which the index refers\n-         *(uintptr_t *)cursor =\n-            (uintptr_t)tempSR->getOwningMethod(TR::comp())->constantPool();\n-         cursor += SIZEPOINTER;\n+\n+         TR::SymbolReference *symRef = reinterpret_cast<TR::SymbolReference *>(recordInfo->data1);\n+         uintptr_t inlinedSiteIndex = self()->findCorrectInlinedSiteIndex(symRef->getOwningMethod(comp)->constantPool(), recordInfo->data2);\n+         uint8_t flags = static_cast<uint8_t>(reinterpret_cast<uintptr_t>(recordInfo->data3));\n+\n+         TR_ASSERT((flags & RELOCATION_CROSS_PLATFORM_FLAGS_MASK) == 0,  \"reloFlags bits overlap cross-platform flags bits\\n\");\n+\n+         moRecord->setInlinedSiteIndex(reloTarget, reinterpret_cast<uintptr_t>(inlinedSiteIndex));\n+         moRecord->setConstantPool(reloTarget, reinterpret_cast<uintptr_t>(symRef->getOwningMethod(comp)->constantPool()));\n+         moRecord->setReloFlags(reloTarget, flags);\n+\n+         cursor = relocation->getRelocationData() + TR_RelocationRecord::getSizeOfAOTRelocationHeader(static_cast<TR_RelocationRecordType>(targetKind));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzA1OTI4NQ=="}, "originalCommit": {"oid": "1e552771d1b2728862c96b69b61387ee137b0c4f"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3OTQ1ODcwOnYy", "diffSide": "RIGHT", "path": "runtime/compiler/arm/codegen/J9AheadOfTimeCompile.cpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxNzoxMToxMlrOHy3Q8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxNzoxMToxMlrOHy3Q8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzA5NjMwNA==", "bodyText": "similar comment here for the ARM and P implementations, which only seem to differ in the requirement for flags? Seems like it could be folded into the common implementation. Another issue or maybe combine into one issue?", "url": "https://github.com/eclipse-openj9/openj9/pull/10916#discussion_r523096304", "createdAt": "2020-11-13T17:11:12Z", "author": {"login": "mstoodle"}, "path": "runtime/compiler/arm/codegen/J9AheadOfTimeCompile.cpp", "diffHunk": "@@ -149,28 +149,29 @@ uint8_t *J9::ARM::AheadOfTimeCompile::initializeAOTRelocationHeader(TR::Iterated\n          cursor = relocation->getRelocationData() + TR_RelocationRecord::getSizeOfAOTRelocationHeader(static_cast<TR_RelocationRecordType>(targetKind));\n          }\n          break;\n+\n       case TR_ClassAddress:\n          {\n+         TR_RelocationRecordClassAddress *caRecord = reinterpret_cast<TR_RelocationRecordClassAddress *>(reloRecord);\n          TR_RelocationRecordInformation *recordInfo = (TR_RelocationRecordInformation*) relocation->getTargetAddress();\n-         TR::SymbolReference *tempSR = (TR::SymbolReference *) recordInfo->data1;\n-\n-         // These flags are unused at the moment. If they're needed later,\n-         // they'll be needed for TR_ArbitraryClassAddress as well\n-         uint8_t flags = (uint8_t) recordInfo->data3;\n \n-         uintptr_t inlinedSiteIndex = self()->findCorrectInlinedSiteIndex(tempSR->getOwningMethod(comp)->constantPool(), recordInfo->data2);\n+         TR::SymbolReference *symRef = reinterpret_cast<TR::SymbolReference *>(recordInfo->data1);\n+         uintptr_t inlinedSiteIndex = reinterpret_cast<uintptr_t>(recordInfo->data2);\n+         uint8_t flags = static_cast<uint8_t>(recordInfo->data3);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d555e4015c383576b4b9157f0f917e58f9145ab"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3OTQ3MzEzOnYy", "diffSide": "RIGHT", "path": "runtime/compiler/codegen/J9AheadOfTimeCompile.cpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxNzoxMzozMVrOHy3aag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxNzoxMzozMVrOHy3aag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzA5ODczMA==", "bodyText": "Shouldn't the flags also be printed by this code? Same comment for the MethodObject and ClassAddress relocations, I think.", "url": "https://github.com/eclipse-openj9/openj9/pull/10916#discussion_r523098730", "createdAt": "2020-11-13T17:13:31Z", "author": {"login": "mstoodle"}, "path": "runtime/compiler/codegen/J9AheadOfTimeCompile.cpp", "diffHunk": "@@ -1706,6 +1723,22 @@ J9::AheadOfTimeCompile::dumpRelocationHeaderData(uint8_t *cursor, bool isVerbose\n          }\n          break;\n \n+      case TR_DataAddress:\n+         {\n+         TR_RelocationRecordDataAddress *daRecord = reinterpret_cast<TR_RelocationRecordDataAddress *>(reloRecord);\n+\n+         self()->traceRelocationOffsets(cursor, offsetSize, endOfCurrentRecord, orderedPair);\n+         if (isVerbose)\n+            {\n+            traceMsg(self()->comp(), \"\\nTR_DataAddress: InlinedCallSite index = %d, Constant pool = %x, cpIndex = %d, offset = %x\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d991e85850e808e2c2e774df2fe89f97227f59ca"}, "originalPosition": 35}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1169, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}