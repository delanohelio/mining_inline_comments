{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU3OTQxNTMx", "number": 10274, "title": "JEP383 Support Part 4", "bodyText": "Add support for IndirectVarHandle.\nScan for checked exceptions in OpenJ9 MethodHandles.\n\nibmruntimes/openj9-openjdk-jdk15#11 depends on this PR.\nRelated: #9625.\nSigned-off-by: Babneet Singh sbabneet@ca.ibm.com", "createdAt": "2020-07-28T17:11:47Z", "url": "https://github.com/eclipse-openj9/openj9/pull/10274", "merged": true, "mergeCommit": {"oid": "d7e27c5115f6001b7b94af8ff6572b84367d5c1d"}, "closed": true, "closedAt": "2020-08-14T12:34:58Z", "author": {"login": "babsingh"}, "timelineItems": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc5ew35AFqTQ1NzA3OTg3MA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABc-i4gqgBqjM2NTI5NDUwOTA=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU3MDc5ODcw", "url": "https://github.com/eclipse-openj9/openj9/pull/10274#pullrequestreview-457079870", "createdAt": "2020-07-28T22:44:42Z", "commit": {"oid": "d86d846e1829eca5afe7fff14ba305bb078bc864"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQyMjo0NDo0MlrOG4iSlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQyMzowNjozMlrOG4ixvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTkzNTI1Mg==", "bodyText": "This IAE was triggered by JEP383 tests. I initially disabled it for Java15 but it didn't look correct. I have introduced a better solution in the HEAD commit, Avoid Lookup doCheck if full privilege access is acquired.", "url": "https://github.com/eclipse-openj9/openj9/pull/10274#discussion_r461935252", "createdAt": "2020-07-28T22:44:42Z", "author": {"login": "babsingh"}, "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodHandles.java", "diffHunk": "@@ -204,12 +204,14 @@\n \t\t\n \t\tLookup(Class<?> lookupClass, Class<?> prevLookupClass, int lookupMode, boolean doCheck) {\n \t\t\tthis.performSecurityCheck = doCheck;\n+\t\t\t/*[IF !Java15]*/\n \t\t\tif (doCheck && (INTERNAL_PRIVILEGED != lookupMode)) {\n \t\t\t\tif (lookupClass.getName().startsWith(\"java.lang.invoke.\")) {  //$NON-NLS-1$\n \t\t\t\t\t/*[MSG \"K0588\", \"Illegal Lookup object - originated from java.lang.invoke: {0}\"]*/\n \t\t\t\t\tthrow new IllegalArgumentException(com.ibm.oti.util.Msg.getString(\"K0588\", lookupClass.getName())); //$NON-NLS-1$", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d86d846e1829eca5afe7fff14ba305bb078bc864"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTkzOTc3MQ==", "bodyText": "The below code is indented into an else block. It is just old code.", "url": "https://github.com/eclipse-openj9/openj9/pull/10274#discussion_r461939771", "createdAt": "2020-07-28T22:56:12Z", "author": {"login": "babsingh"}, "path": "jcl/src/java.base/share/classes/java/lang/invoke/VarHandle.java", "diffHunk": "@@ -375,64 +375,75 @@ MethodType accessModeType(Class<?> receiver, Class<?> type, Class<?>... args) {\n \t * @param varForm an instance of VarForm.\n \t */\n \tVarHandle(VarForm varForm) {\n-\t\tAccessMode[] accessModes = AccessMode.values();\n-\t\tint numAccessModes = accessModes.length;\n-\n-\t\t/* The first argument in AccessType.GET MethodType is the receiver class. */\n-\t\tClass<?> receiverActual = accessModeTypeUncached(AccessMode.GET).parameterType(0);\n-\t\tClass<?> receiverVarForm = varForm.methodType_table[AccessType.GET.ordinal()].parameterType(0);\n-\t\t\n-\t\t/* Specify the exact operation method types if the actual receiver doesn't match the\n-\t\t * receiver derived from VarForm.\n-\t\t */\n-\t\tMethodType[] operationMTsExact = null;\n-\t\tif (receiverActual != receiverVarForm) {\n-\t\t\toperationMTsExact = new MethodType[numAccessModes];\n-\t\t}\n-\t\t\n-\t\tMethodType[] operationMTs = new MethodType[numAccessModes];\n-\t\tClass<?> operationsClass = null;\n-\n-\t\tfor (int i = 0; i < numAccessModes; i++) {\n-\t\t\tMemberName memberName = varForm.memberName_table[i];\n-\t\t\tif (memberName != null) {\n-\t\t\t\toperationMTs[i] = memberName.getMethodType();\n-\t\t\t\tif (operationMTsExact != null) {\n-\t\t\t\t\t/* Replace with the actual receiver, which is expected when the operation method\n-\t\t\t\t\t * is invoked. The receiver is the second argument.\n-\t\t\t\t\t */\n-\t\t\t\t\toperationMTsExact[i] = operationMTs[i].changeParameterType(1, receiverActual);\n-\t\t\t\t}\n-\t\t\t\tif (operationsClass == null) {\n-\t\t\t\t\toperationsClass = memberName.getDeclaringClass();\n+\t\tif (varForm.memberName_table == null) {\n+\t\t\t/* Indirect VarHandle. */\n+\t\t\tMethodType getter = varForm.methodType_table[VarHandle.AccessType.GET.ordinal()];\n+\t\t\tthis.fieldType = getter.returnType();\n+\t\t\tthis.coordinateTypes = getter.parameterArray();\n+\t\t\tthis.modifiers = 0;\n+\t\t\tthis.vform = varForm;\n+\t\t\treturn;\n+\t\t} else {\n+\t\t\t/* Direct VarHandle. */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d86d846e1829eca5afe7fff14ba305bb078bc864"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk0MDE3Nw==", "bodyText": "These new changes for IndirectVarHandle don't set handleTable. It is set in the constructor of IndirectVarHandle.", "url": "https://github.com/eclipse-openj9/openj9/pull/10274#discussion_r461940177", "createdAt": "2020-07-28T22:57:27Z", "author": {"login": "babsingh"}, "path": "jcl/src/java.base/share/classes/java/lang/invoke/VarHandle.java", "diffHunk": "@@ -375,64 +375,75 @@ MethodType accessModeType(Class<?> receiver, Class<?> type, Class<?>... args) {\n \t * @param varForm an instance of VarForm.\n \t */\n \tVarHandle(VarForm varForm) {\n-\t\tAccessMode[] accessModes = AccessMode.values();\n-\t\tint numAccessModes = accessModes.length;\n-\n-\t\t/* The first argument in AccessType.GET MethodType is the receiver class. */\n-\t\tClass<?> receiverActual = accessModeTypeUncached(AccessMode.GET).parameterType(0);\n-\t\tClass<?> receiverVarForm = varForm.methodType_table[AccessType.GET.ordinal()].parameterType(0);\n-\t\t\n-\t\t/* Specify the exact operation method types if the actual receiver doesn't match the\n-\t\t * receiver derived from VarForm.\n-\t\t */\n-\t\tMethodType[] operationMTsExact = null;\n-\t\tif (receiverActual != receiverVarForm) {\n-\t\t\toperationMTsExact = new MethodType[numAccessModes];\n-\t\t}\n-\t\t\n-\t\tMethodType[] operationMTs = new MethodType[numAccessModes];\n-\t\tClass<?> operationsClass = null;\n-\n-\t\tfor (int i = 0; i < numAccessModes; i++) {\n-\t\t\tMemberName memberName = varForm.memberName_table[i];\n-\t\t\tif (memberName != null) {\n-\t\t\t\toperationMTs[i] = memberName.getMethodType();\n-\t\t\t\tif (operationMTsExact != null) {\n-\t\t\t\t\t/* Replace with the actual receiver, which is expected when the operation method\n-\t\t\t\t\t * is invoked. The receiver is the second argument.\n-\t\t\t\t\t */\n-\t\t\t\t\toperationMTsExact[i] = operationMTs[i].changeParameterType(1, receiverActual);\n-\t\t\t\t}\n-\t\t\t\tif (operationsClass == null) {\n-\t\t\t\t\toperationsClass = memberName.getDeclaringClass();\n+\t\tif (varForm.memberName_table == null) {\n+\t\t\t/* Indirect VarHandle. */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d86d846e1829eca5afe7fff14ba305bb078bc864"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk0MTk4Mg==", "bodyText": "Creates a MethodHandle (MH) with MethodType (MT) for a VarHandle (VH) similar to the reference implementation and permutes/translates it to a MH/MT for an OpenJ9 VarHandle.", "url": "https://github.com/eclipse-openj9/openj9/pull/10274#discussion_r461941982", "createdAt": "2020-07-28T23:02:39Z", "author": {"login": "babsingh"}, "path": "jcl/src/java.base/share/classes/java/lang/invoke/VarHandle.java", "diffHunk": "@@ -515,6 +526,91 @@ static MethodHandle permuateHandleJEP370(MethodHandle methodHandle) {\n \t}\n /*[ENDIF] Java14 */\n \n+/*[IF Java15]*/\n+    /**\n+     * Generate a MethodHandle which translates:\n+     *     FROM {VarHandle, Receiver, Intermediate ..., Value}ReturnType\n+     *     TO   {Receiver, Intermediate ..., Value, VarHandle}ReturnType\n+     *\n+     * @param methodHandle to be permuted.\n+     * @return the adapter MethodHandle which performs the translation.\n+     */\n+    static MethodHandle permuateHandleReferenceToJ9(MethodHandle methodHandle) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d86d846e1829eca5afe7fff14ba305bb078bc864"}, "originalPosition": 180}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk0MjY4Mw==", "bodyText": "This is set from java.lang.invoke.IndirectVarHandle. So, it can no longer be private or final. We can possibly add a protected method to set it, which will allow us to keep it private. Also, we can tag these changes with the Java15 flag to avoid perf impact on previous versions.", "url": "https://github.com/eclipse-openj9/openj9/pull/10274#discussion_r461942683", "createdAt": "2020-07-28T23:04:54Z", "author": {"login": "babsingh"}, "path": "jcl/src/java.base/share/classes/java/lang/invoke/VarHandle.java", "diffHunk": "@@ -345,7 +345,7 @@ MethodType accessModeType(Class<?> receiver, Class<?> type, Class<?>... args) {\n \tVarForm vform = null;\n /*[ENDIF] Java14 */\n \t\n-\tprivate final MethodHandle[] handleTable;\n+\tMethodHandle[] handleTable;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d86d846e1829eca5afe7fff14ba305bb078bc864"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk0Mjk4MA==", "bodyText": "This method generates the handleTable for IndirectVarHandle. In this method, the permutations can be avoided if OpenJ9 VarHandle moves the VarHandle argument to the start of the MH invocation. But, it will require a massive rewrite of OpenJ9 VarHandles (Java, VM and JIT code). The current approach is taken since OpenJ9 plans to adopt OpenJDK VarHandles soon.", "url": "https://github.com/eclipse-openj9/openj9/pull/10274#discussion_r461942980", "createdAt": "2020-07-28T23:05:45Z", "author": {"login": "babsingh"}, "path": "jcl/src/java.base/share/classes/java/lang/invoke/VarHandle.java", "diffHunk": "@@ -515,6 +526,91 @@ static MethodHandle permuateHandleJEP370(MethodHandle methodHandle) {\n \t}\n /*[ENDIF] Java14 */\n \n+/*[IF Java15]*/\n+    /**\n+     * Generate a MethodHandle which translates:\n+     *     FROM {VarHandle, Receiver, Intermediate ..., Value}ReturnType\n+     *     TO   {Receiver, Intermediate ..., Value, VarHandle}ReturnType\n+     *\n+     * @param methodHandle to be permuted.\n+     * @return the adapter MethodHandle which performs the translation.\n+     */\n+    static MethodHandle permuateHandleReferenceToJ9(MethodHandle methodHandle) {\n+        /* HandleType = {Receiver, Intermediate ..., Value, VarHandle}\n+         * PermuteType = {VarHandle, Receiver, Intermediate ..., Value}\n+         */\n+\t\tMethodType permuteMethodType = methodHandle.type();\n+\t\tint parameterCount = permuteMethodType.parameterCount();\n+\t\tClass<?>[] params = permuteMethodType.parameterArray();\n+\n+\t\tfor (int i = 0; i < parameterCount; i++) {\n+\t\t\tif (i == 0) {\n+\t\t\t\tpermuteMethodType = permuteMethodType.changeParameterType(i, params[parameterCount - 1]);\n+\t\t\t} else {\n+\t\t\t\tpermuteMethodType = permuteMethodType.changeParameterType(i, params[i - 1]);\n+\t\t\t}\n+\t\t}\n+\n+\t\t/**\n+\t\t * reorder specifies the mapping between PermuteType and HandleType.\n+\t\t * reorder = {1, 2, ..., parameterCount - 1, 0}\n+\t\t */\n+\t\tint[] reorder = new int[parameterCount];\n+\t\tfor (int i = 0; i < parameterCount; i++) {\n+\t\t\tif (i == (parameterCount - 1)) {\n+\t\t\t\treorder[i] = 0;\n+\t\t\t} else {\n+\t\t\t\treorder[i] = i + 1;\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn MethodHandles.permuteArguments(methodHandle, permuteMethodType, reorder);\n+    }\n+\n+\t/**\n+\t * Generates handleTable for Indirect VarHandles (supports JEP383).\n+\t *\n+\t * @param target the target VarHandle for the Indirect VarHandle.\n+\t * @param handleFactory used to transform an AccessMode MethodHandle accordingly.\n+\t * \n+\t * @return a MethodHandle array which is used to initialize the handleTable.\n+\t */\n+\tstatic MethodHandle[] populateMHsJEP383(VarHandle target, BiFunction<AccessMode, MethodHandle, MethodHandle> handleFactory) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d86d846e1829eca5afe7fff14ba305bb078bc864"}, "originalPosition": 220}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk0MzEyMA==", "bodyText": "1st MH permutation. J9 -> Reference conversion, before applying handleFactory.", "url": "https://github.com/eclipse-openj9/openj9/pull/10274#discussion_r461943120", "createdAt": "2020-07-28T23:06:11Z", "author": {"login": "babsingh"}, "path": "jcl/src/java.base/share/classes/java/lang/invoke/VarHandle.java", "diffHunk": "@@ -515,6 +526,91 @@ static MethodHandle permuateHandleJEP370(MethodHandle methodHandle) {\n \t}\n /*[ENDIF] Java14 */\n \n+/*[IF Java15]*/\n+    /**\n+     * Generate a MethodHandle which translates:\n+     *     FROM {VarHandle, Receiver, Intermediate ..., Value}ReturnType\n+     *     TO   {Receiver, Intermediate ..., Value, VarHandle}ReturnType\n+     *\n+     * @param methodHandle to be permuted.\n+     * @return the adapter MethodHandle which performs the translation.\n+     */\n+    static MethodHandle permuateHandleReferenceToJ9(MethodHandle methodHandle) {\n+        /* HandleType = {Receiver, Intermediate ..., Value, VarHandle}\n+         * PermuteType = {VarHandle, Receiver, Intermediate ..., Value}\n+         */\n+\t\tMethodType permuteMethodType = methodHandle.type();\n+\t\tint parameterCount = permuteMethodType.parameterCount();\n+\t\tClass<?>[] params = permuteMethodType.parameterArray();\n+\n+\t\tfor (int i = 0; i < parameterCount; i++) {\n+\t\t\tif (i == 0) {\n+\t\t\t\tpermuteMethodType = permuteMethodType.changeParameterType(i, params[parameterCount - 1]);\n+\t\t\t} else {\n+\t\t\t\tpermuteMethodType = permuteMethodType.changeParameterType(i, params[i - 1]);\n+\t\t\t}\n+\t\t}\n+\n+\t\t/**\n+\t\t * reorder specifies the mapping between PermuteType and HandleType.\n+\t\t * reorder = {1, 2, ..., parameterCount - 1, 0}\n+\t\t */\n+\t\tint[] reorder = new int[parameterCount];\n+\t\tfor (int i = 0; i < parameterCount; i++) {\n+\t\t\tif (i == (parameterCount - 1)) {\n+\t\t\t\treorder[i] = 0;\n+\t\t\t} else {\n+\t\t\t\treorder[i] = i + 1;\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn MethodHandles.permuteArguments(methodHandle, permuteMethodType, reorder);\n+    }\n+\n+\t/**\n+\t * Generates handleTable for Indirect VarHandles (supports JEP383).\n+\t *\n+\t * @param target the target VarHandle for the Indirect VarHandle.\n+\t * @param handleFactory used to transform an AccessMode MethodHandle accordingly.\n+\t * \n+\t * @return a MethodHandle array which is used to initialize the handleTable.\n+\t */\n+\tstatic MethodHandle[] populateMHsJEP383(VarHandle target, BiFunction<AccessMode, MethodHandle, MethodHandle> handleFactory) {\n+\t\tMethodHandle[] operationMHs = new MethodHandle[AccessMode.values().length];\n+\n+\t\ttry {\n+\t\t\tMethodType replaceWithDirectType = MethodType.methodType(VarHandle.class, VarHandle.class);\n+\t\t\tMethodHandle replaceWithDirect = MethodHandles.publicLookup().findStatic(VarHandle.class, \"asDirect\", replaceWithDirectType);\n+\n+\t\t\tfor (AccessMode mode : AccessMode.values()) {\n+\t\t\t\tint index = mode.ordinal();\n+\t\t\t\tMethodHandle targetHandle = target.getMethodHandle(index);\n+\n+\t\t\t\tif (targetHandle != null) {\n+\t\t\t\t\tMethodType targetType = targetHandle.type();\n+\t\t\t\t\tif (targetType.parameterType(targetType.parameterCount() - 1) == VarHandle.class) {\n+\t\t\t\t\t\t/*\n+\t\t\t\t\t\t * Permute a J9 VarHandle to an equivalent reference implementation VarHandle\n+\t\t\t\t\t\t * before applying handleFactory.\n+\t\t\t\t\t\t */\n+\t\t\t\t\t\ttargetHandle = permuateHandleReferenceToJ9(targetHandle);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d86d846e1829eca5afe7fff14ba305bb078bc864"}, "originalPosition": 238}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk0MzE4Mg==", "bodyText": "2nd MH permutation. Reference -> J9 conversion, in order to work with the J9 interpreter.", "url": "https://github.com/eclipse-openj9/openj9/pull/10274#discussion_r461943182", "createdAt": "2020-07-28T23:06:21Z", "author": {"login": "babsingh"}, "path": "jcl/src/java.base/share/classes/java/lang/invoke/VarHandle.java", "diffHunk": "@@ -515,6 +526,91 @@ static MethodHandle permuateHandleJEP370(MethodHandle methodHandle) {\n \t}\n /*[ENDIF] Java14 */\n \n+/*[IF Java15]*/\n+    /**\n+     * Generate a MethodHandle which translates:\n+     *     FROM {VarHandle, Receiver, Intermediate ..., Value}ReturnType\n+     *     TO   {Receiver, Intermediate ..., Value, VarHandle}ReturnType\n+     *\n+     * @param methodHandle to be permuted.\n+     * @return the adapter MethodHandle which performs the translation.\n+     */\n+    static MethodHandle permuateHandleReferenceToJ9(MethodHandle methodHandle) {\n+        /* HandleType = {Receiver, Intermediate ..., Value, VarHandle}\n+         * PermuteType = {VarHandle, Receiver, Intermediate ..., Value}\n+         */\n+\t\tMethodType permuteMethodType = methodHandle.type();\n+\t\tint parameterCount = permuteMethodType.parameterCount();\n+\t\tClass<?>[] params = permuteMethodType.parameterArray();\n+\n+\t\tfor (int i = 0; i < parameterCount; i++) {\n+\t\t\tif (i == 0) {\n+\t\t\t\tpermuteMethodType = permuteMethodType.changeParameterType(i, params[parameterCount - 1]);\n+\t\t\t} else {\n+\t\t\t\tpermuteMethodType = permuteMethodType.changeParameterType(i, params[i - 1]);\n+\t\t\t}\n+\t\t}\n+\n+\t\t/**\n+\t\t * reorder specifies the mapping between PermuteType and HandleType.\n+\t\t * reorder = {1, 2, ..., parameterCount - 1, 0}\n+\t\t */\n+\t\tint[] reorder = new int[parameterCount];\n+\t\tfor (int i = 0; i < parameterCount; i++) {\n+\t\t\tif (i == (parameterCount - 1)) {\n+\t\t\t\treorder[i] = 0;\n+\t\t\t} else {\n+\t\t\t\treorder[i] = i + 1;\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn MethodHandles.permuteArguments(methodHandle, permuteMethodType, reorder);\n+    }\n+\n+\t/**\n+\t * Generates handleTable for Indirect VarHandles (supports JEP383).\n+\t *\n+\t * @param target the target VarHandle for the Indirect VarHandle.\n+\t * @param handleFactory used to transform an AccessMode MethodHandle accordingly.\n+\t * \n+\t * @return a MethodHandle array which is used to initialize the handleTable.\n+\t */\n+\tstatic MethodHandle[] populateMHsJEP383(VarHandle target, BiFunction<AccessMode, MethodHandle, MethodHandle> handleFactory) {\n+\t\tMethodHandle[] operationMHs = new MethodHandle[AccessMode.values().length];\n+\n+\t\ttry {\n+\t\t\tMethodType replaceWithDirectType = MethodType.methodType(VarHandle.class, VarHandle.class);\n+\t\t\tMethodHandle replaceWithDirect = MethodHandles.publicLookup().findStatic(VarHandle.class, \"asDirect\", replaceWithDirectType);\n+\n+\t\t\tfor (AccessMode mode : AccessMode.values()) {\n+\t\t\t\tint index = mode.ordinal();\n+\t\t\t\tMethodHandle targetHandle = target.getMethodHandle(index);\n+\n+\t\t\t\tif (targetHandle != null) {\n+\t\t\t\t\tMethodType targetType = targetHandle.type();\n+\t\t\t\t\tif (targetType.parameterType(targetType.parameterCount() - 1) == VarHandle.class) {\n+\t\t\t\t\t\t/*\n+\t\t\t\t\t\t * Permute a J9 VarHandle to an equivalent reference implementation VarHandle\n+\t\t\t\t\t\t * before applying handleFactory.\n+\t\t\t\t\t\t */\n+\t\t\t\t\t\ttargetHandle = permuateHandleReferenceToJ9(targetHandle);\n+\t\t\t\t\t}\n+\t\t\t\t\toperationMHs[index] = handleFactory.apply(mode, targetHandle);\n+\t\t\t\t\toperationMHs[index] = permuateHandleJ9ToReference(operationMHs[index]);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d86d846e1829eca5afe7fff14ba305bb078bc864"}, "originalPosition": 241}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk0MzIyOA==", "bodyText": "3rd MH permutation. Retrieve the direct-target VarHandle and pass it as an input before invoking the AccessMode MethodHandle since an IndirectVarHandle cannot be used during MH invocation.", "url": "https://github.com/eclipse-openj9/openj9/pull/10274#discussion_r461943228", "createdAt": "2020-07-28T23:06:32Z", "author": {"login": "babsingh"}, "path": "jcl/src/java.base/share/classes/java/lang/invoke/VarHandle.java", "diffHunk": "@@ -515,6 +526,91 @@ static MethodHandle permuateHandleJEP370(MethodHandle methodHandle) {\n \t}\n /*[ENDIF] Java14 */\n \n+/*[IF Java15]*/\n+    /**\n+     * Generate a MethodHandle which translates:\n+     *     FROM {VarHandle, Receiver, Intermediate ..., Value}ReturnType\n+     *     TO   {Receiver, Intermediate ..., Value, VarHandle}ReturnType\n+     *\n+     * @param methodHandle to be permuted.\n+     * @return the adapter MethodHandle which performs the translation.\n+     */\n+    static MethodHandle permuateHandleReferenceToJ9(MethodHandle methodHandle) {\n+        /* HandleType = {Receiver, Intermediate ..., Value, VarHandle}\n+         * PermuteType = {VarHandle, Receiver, Intermediate ..., Value}\n+         */\n+\t\tMethodType permuteMethodType = methodHandle.type();\n+\t\tint parameterCount = permuteMethodType.parameterCount();\n+\t\tClass<?>[] params = permuteMethodType.parameterArray();\n+\n+\t\tfor (int i = 0; i < parameterCount; i++) {\n+\t\t\tif (i == 0) {\n+\t\t\t\tpermuteMethodType = permuteMethodType.changeParameterType(i, params[parameterCount - 1]);\n+\t\t\t} else {\n+\t\t\t\tpermuteMethodType = permuteMethodType.changeParameterType(i, params[i - 1]);\n+\t\t\t}\n+\t\t}\n+\n+\t\t/**\n+\t\t * reorder specifies the mapping between PermuteType and HandleType.\n+\t\t * reorder = {1, 2, ..., parameterCount - 1, 0}\n+\t\t */\n+\t\tint[] reorder = new int[parameterCount];\n+\t\tfor (int i = 0; i < parameterCount; i++) {\n+\t\t\tif (i == (parameterCount - 1)) {\n+\t\t\t\treorder[i] = 0;\n+\t\t\t} else {\n+\t\t\t\treorder[i] = i + 1;\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn MethodHandles.permuteArguments(methodHandle, permuteMethodType, reorder);\n+    }\n+\n+\t/**\n+\t * Generates handleTable for Indirect VarHandles (supports JEP383).\n+\t *\n+\t * @param target the target VarHandle for the Indirect VarHandle.\n+\t * @param handleFactory used to transform an AccessMode MethodHandle accordingly.\n+\t * \n+\t * @return a MethodHandle array which is used to initialize the handleTable.\n+\t */\n+\tstatic MethodHandle[] populateMHsJEP383(VarHandle target, BiFunction<AccessMode, MethodHandle, MethodHandle> handleFactory) {\n+\t\tMethodHandle[] operationMHs = new MethodHandle[AccessMode.values().length];\n+\n+\t\ttry {\n+\t\t\tMethodType replaceWithDirectType = MethodType.methodType(VarHandle.class, VarHandle.class);\n+\t\t\tMethodHandle replaceWithDirect = MethodHandles.publicLookup().findStatic(VarHandle.class, \"asDirect\", replaceWithDirectType);\n+\n+\t\t\tfor (AccessMode mode : AccessMode.values()) {\n+\t\t\t\tint index = mode.ordinal();\n+\t\t\t\tMethodHandle targetHandle = target.getMethodHandle(index);\n+\n+\t\t\t\tif (targetHandle != null) {\n+\t\t\t\t\tMethodType targetType = targetHandle.type();\n+\t\t\t\t\tif (targetType.parameterType(targetType.parameterCount() - 1) == VarHandle.class) {\n+\t\t\t\t\t\t/*\n+\t\t\t\t\t\t * Permute a J9 VarHandle to an equivalent reference implementation VarHandle\n+\t\t\t\t\t\t * before applying handleFactory.\n+\t\t\t\t\t\t */\n+\t\t\t\t\t\ttargetHandle = permuateHandleReferenceToJ9(targetHandle);\n+\t\t\t\t\t}\n+\t\t\t\t\toperationMHs[index] = handleFactory.apply(mode, targetHandle);\n+\t\t\t\t\toperationMHs[index] = permuateHandleJ9ToReference(operationMHs[index]);\n+\t\t\t\t\toperationMHs[index] = MethodHandles.collectArguments(operationMHs[index], operationMHs[index].type().parameterCount() - 1, replaceWithDirect);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d86d846e1829eca5afe7fff14ba305bb078bc864"}, "originalPosition": 242}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "64f497f47d7dc6d89a20a23b851cfe33f0f131c8", "author": {"user": {"login": "babsingh", "name": "Babneet Singh"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/64f497f47d7dc6d89a20a23b851cfe33f0f131c8", "committedDate": "2020-07-28T22:39:00Z", "message": "Avoid Lookup doCheck if full privilege access is acquired\n\nMethodHandles.lookup() and Lookup.defineHiddenClass*() have full\nprivilege access. Performing Lookup doCheck for these methods causes an\nIAE, \"Illegal Lookup object\", from the Lookup constructor. This behavior\nwas noticed for JEP383 tests. For the above methods with full privilege\naccess, the Lookup doCheck is not needed and thus, disabled.\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>"}, "afterCommit": {"oid": "07024e46399fea0a8bb59491f4fdeb98229d6289", "author": {"user": {"login": "babsingh", "name": "Babneet Singh"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/07024e46399fea0a8bb59491f4fdeb98229d6289", "committedDate": "2020-08-06T20:33:14Z", "message": "Lookup for checked exceptions in OpenJ9 MethodHandles\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYyNzQ2NDI5", "url": "https://github.com/eclipse-openj9/openj9/pull/10274#pullrequestreview-462746429", "createdAt": "2020-08-06T17:49:47Z", "commit": {"oid": "d86d846e1829eca5afe7fff14ba305bb078bc864"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNzo0OTo0N1rOG8-DkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNzo1NzoxNVrOG8-UhA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU4NDQ2NA==", "bodyText": "@JasonFengJ9 has a PR to address the java.lang.invoke package check that's being reviewed now.  It takes a different approach to handle the existing APIs but should cover this case as well", "url": "https://github.com/eclipse-openj9/openj9/pull/10274#discussion_r466584464", "createdAt": "2020-08-06T17:49:47Z", "author": {"login": "DanHeidinga"}, "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodHandles.java", "diffHunk": "@@ -204,12 +204,14 @@\n \t\t\n \t\tLookup(Class<?> lookupClass, Class<?> prevLookupClass, int lookupMode, boolean doCheck) {\n \t\t\tthis.performSecurityCheck = doCheck;\n+\t\t\t/*[IF !Java15]*/\n \t\t\tif (doCheck && (INTERNAL_PRIVILEGED != lookupMode)) {\n \t\t\t\tif (lookupClass.getName().startsWith(\"java.lang.invoke.\")) {  //$NON-NLS-1$\n \t\t\t\t\t/*[MSG \"K0588\", \"Illegal Lookup object - originated from java.lang.invoke: {0}\"]*/\n \t\t\t\t\tthrow new IllegalArgumentException(com.ibm.oti.util.Msg.getString(\"K0588\", lookupClass.getName())); //$NON-NLS-1$", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTkzNTI1Mg=="}, "originalCommit": {"oid": "d86d846e1829eca5afe7fff14ba305bb078bc864"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU4NTE5NQ==", "bodyText": "Can you add the preprocessor tags for the private final bit so JDK11 still has the existing behaviour  (and any optimizations keyed off the access flags)", "url": "https://github.com/eclipse-openj9/openj9/pull/10274#discussion_r466585195", "createdAt": "2020-08-06T17:51:03Z", "author": {"login": "DanHeidinga"}, "path": "jcl/src/java.base/share/classes/java/lang/invoke/VarHandle.java", "diffHunk": "@@ -345,7 +345,7 @@ MethodType accessModeType(Class<?> receiver, Class<?> type, Class<?>... args) {\n \tVarForm vform = null;\n /*[ENDIF] Java14 */\n \t\n-\tprivate final MethodHandle[] handleTable;\n+\tMethodHandle[] handleTable;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk0MjY4Mw=="}, "originalCommit": {"oid": "d86d846e1829eca5afe7fff14ba305bb078bc864"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU4ODAyMg==", "bodyText": "Can the zero case be moved out of the loop?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tfor (int i = 0; i < parameterCount; i++) {\n          \n          \n            \n            \t\t\tif (i == 0) {\n          \n          \n            \n            \t\t\t\tpermuteMethodType = permuteMethodType.changeParameterType(i, params[parameterCount - 1]);\n          \n          \n            \n            \t\t\t} else {\n          \n          \n            \n            \t\t\t\tpermuteMethodType = permuteMethodType.changeParameterType(i, params[i - 1]);\n          \n          \n            \n            \t\t\t}\n          \n          \n            \n            \t\t}\n          \n          \n            \n            \tif (parameterCount > 0) {\n          \n          \n            \n            \t\tpermuteMethodType = permuteMethodType.changeParameterType(i, params[parameterCount - 1]);\n          \n          \n            \n            \t\tfor (int i = 1; i < parameterCount; i++) {\n          \n          \n            \n            \t\t\tpermuteMethodType = permuteMethodType.changeParameterType(i, params[i - 1]);\n          \n          \n            \n            \t\t}\n          \n          \n            \n            \t}", "url": "https://github.com/eclipse-openj9/openj9/pull/10274#discussion_r466588022", "createdAt": "2020-08-06T17:55:58Z", "author": {"login": "DanHeidinga"}, "path": "jcl/src/java.base/share/classes/java/lang/invoke/VarHandle.java", "diffHunk": "@@ -515,6 +526,91 @@ static MethodHandle permuateHandleJEP370(MethodHandle methodHandle) {\n \t}\n /*[ENDIF] Java14 */\n \n+/*[IF Java15]*/\n+    /**\n+     * Generate a MethodHandle which translates:\n+     *     FROM {VarHandle, Receiver, Intermediate ..., Value}ReturnType\n+     *     TO   {Receiver, Intermediate ..., Value, VarHandle}ReturnType\n+     *\n+     * @param methodHandle to be permuted.\n+     * @return the adapter MethodHandle which performs the translation.\n+     */\n+    static MethodHandle permuateHandleReferenceToJ9(MethodHandle methodHandle) {\n+        /* HandleType = {Receiver, Intermediate ..., Value, VarHandle}\n+         * PermuteType = {VarHandle, Receiver, Intermediate ..., Value}\n+         */\n+\t\tMethodType permuteMethodType = methodHandle.type();\n+\t\tint parameterCount = permuteMethodType.parameterCount();\n+\t\tClass<?>[] params = permuteMethodType.parameterArray();\n+\n+\t\tfor (int i = 0; i < parameterCount; i++) {\n+\t\t\tif (i == 0) {\n+\t\t\t\tpermuteMethodType = permuteMethodType.changeParameterType(i, params[parameterCount - 1]);\n+\t\t\t} else {\n+\t\t\t\tpermuteMethodType = permuteMethodType.changeParameterType(i, params[i - 1]);\n+\t\t\t}\n+\t\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d86d846e1829eca5afe7fff14ba305bb078bc864"}, "originalPosition": 194}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU4ODgwNA==", "bodyText": "Same here and it can sit inside the same if (parameterCount > 0) { as above:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tint[] reorder = new int[parameterCount];\n          \n          \n            \n            \t\tfor (int i = 0; i < parameterCount; i++) {\n          \n          \n            \n            \t\t\tif (i == (parameterCount - 1)) {\n          \n          \n            \n            \t\t\t\treorder[i] = 0;\n          \n          \n            \n            \t\t\t} else {\n          \n          \n            \n            \t\t\t\treorder[i] = i + 1;\n          \n          \n            \n            \t\t\t}\n          \n          \n            \n            \t\t}\n          \n          \n            \n            \t\tint[] reorder = new int[parameterCount];\n          \n          \n            \n            \t\treorder[i] = 0;\n          \n          \n            \n            \t\tfor (int i = 0; i < parameterCount; i++) {\n          \n          \n            \n            \t\t\treorder[i] = i + 1;\n          \n          \n            \n            \t\t}", "url": "https://github.com/eclipse-openj9/openj9/pull/10274#discussion_r466588804", "createdAt": "2020-08-06T17:57:15Z", "author": {"login": "DanHeidinga"}, "path": "jcl/src/java.base/share/classes/java/lang/invoke/VarHandle.java", "diffHunk": "@@ -515,6 +526,91 @@ static MethodHandle permuateHandleJEP370(MethodHandle methodHandle) {\n \t}\n /*[ENDIF] Java14 */\n \n+/*[IF Java15]*/\n+    /**\n+     * Generate a MethodHandle which translates:\n+     *     FROM {VarHandle, Receiver, Intermediate ..., Value}ReturnType\n+     *     TO   {Receiver, Intermediate ..., Value, VarHandle}ReturnType\n+     *\n+     * @param methodHandle to be permuted.\n+     * @return the adapter MethodHandle which performs the translation.\n+     */\n+    static MethodHandle permuateHandleReferenceToJ9(MethodHandle methodHandle) {\n+        /* HandleType = {Receiver, Intermediate ..., Value, VarHandle}\n+         * PermuteType = {VarHandle, Receiver, Intermediate ..., Value}\n+         */\n+\t\tMethodType permuteMethodType = methodHandle.type();\n+\t\tint parameterCount = permuteMethodType.parameterCount();\n+\t\tClass<?>[] params = permuteMethodType.parameterArray();\n+\n+\t\tfor (int i = 0; i < parameterCount; i++) {\n+\t\t\tif (i == 0) {\n+\t\t\t\tpermuteMethodType = permuteMethodType.changeParameterType(i, params[parameterCount - 1]);\n+\t\t\t} else {\n+\t\t\t\tpermuteMethodType = permuteMethodType.changeParameterType(i, params[i - 1]);\n+\t\t\t}\n+\t\t}\n+\n+\t\t/**\n+\t\t * reorder specifies the mapping between PermuteType and HandleType.\n+\t\t * reorder = {1, 2, ..., parameterCount - 1, 0}\n+\t\t */\n+\t\tint[] reorder = new int[parameterCount];\n+\t\tfor (int i = 0; i < parameterCount; i++) {\n+\t\t\tif (i == (parameterCount - 1)) {\n+\t\t\t\treorder[i] = 0;\n+\t\t\t} else {\n+\t\t\t\treorder[i] = i + 1;\n+\t\t\t}\n+\t\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d86d846e1829eca5afe7fff14ba305bb078bc864"}, "originalPosition": 207}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzNDg4MTIz", "url": "https://github.com/eclipse-openj9/openj9/pull/10274#pullrequestreview-463488123", "createdAt": "2020-08-07T17:37:03Z", "commit": {"oid": "07024e46399fea0a8bb59491f4fdeb98229d6289"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNzozNzowM1rOG9iSgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxODowODoxNlrOG9jONQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE3ODExMw==", "bodyText": "Include the reference kind in the exception message to help with debugging", "url": "https://github.com/eclipse-openj9/openj9/pull/10274#discussion_r467178113", "createdAt": "2020-08-07T17:37:03Z", "author": {"login": "DanHeidinga"}, "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodHandles.java", "diffHunk": "@@ -5466,12 +5494,255 @@ public Object helper(Object[] arguments) throws Throwable {\n \t}\n \n \t/*[IF Java15]*/\n-\tstatic boolean permuteArgumentChecks(int[] arr, MethodType mt1, MethodType mt2) {\n-\t\tthrow OpenJDKCompileStub.OpenJDKCompileStubThrowError();\n+\t/**\n+\t * Validates that the permute[] specifies a valid permutation from permuteType to handleType.\n+\t * This method throws IllegalArgumentException on failure and returns true on success. This\n+\t * disjointness allows it to be used in asserts.\n+\t * \n+\t * @param permute array specifies the conversion from permuteType to handleType.\n+\t * @param permuteType source method type.\n+\t * @param handleType target method type.\n+\t * \n+\t * @return true on success.\n+\t * @throws IllegalArgumentException on failure.\n+\t */\n+\tstatic boolean permuteArgumentChecks(int[] permute, MethodType permuteType, MethodType handleType) {\n+\t\treturn validatePermutationArray(permuteType, handleType, permute);\n \t}\n \t\n-\tstatic MethodHandle collectReturnValue(MethodHandle mh1, MethodHandle mh2) {\n-\t\tthrow OpenJDKCompileStub.OpenJDKCompileStubThrowError();\n+\t/**\n+\t * Return the classData stored in the accessClass of the Lookup object.\n+\t * \n+\t * @param caller Lookup object used to verify privileged access and retrieve classData.\n+\t * @param unused.\n+\t * @param type used to cast the classData of the accessClass.\n+\t * \n+\t * @return the classData casted to the appropriate type.\n+\t * @throws IllegalAccessException in the absence of full privilege access.\n+\t */\n+\tstatic <T> T classData(Lookup caller, String unused, Class<T> type) throws IllegalAccessException {\n+\t\tif (caller.hasFullPrivilegeAccess()) {\n+\t\t\tObject classData = MethodHandleNatives.classData(caller.accessClass);\n+\t\t\treturn type.cast(classData);\n+\t\t}\n+\t\tthrow new IllegalAccessException(\"No full privilege access found for \" + caller);\n+\t}\n+\n+\t/**\n+\t * Helper class used by collectReturnValue.\n+\t */\n+\tprivate static final class CollectReturnHelper implements ArgumentHelper {\n+\t\tprivate final MethodHandle target;\n+\t\tprivate final MethodHandle filter;\n+\n+\t\tCollectReturnHelper(MethodHandle target, MethodHandle filter) {\n+\t\t\tthis.target = target;\n+\t\t\tthis.filter = filter;\n+\t\t}\n+\n+\t\tpublic Object helper(Object[] arguments) throws Throwable {\n+\t\t\t// Invoke target\n+\t\t\tint targetArity = target.type.parameterCount();\n+\t\t\tObject targetReturn = target.invokeWithArguments(Arrays.copyOfRange(arguments, 0, targetArity));\n+\n+\t\t\t// Construct filter arguments\n+\t\t\tint filterArity = filter.type.parameterCount();\n+\t\t\tObject[] newArguments = new Object[filterArity];\n+\t\t\tSystem.arraycopy(arguments, targetArity, newArguments, 0, filterArity - 1);\n+\t\t\tnewArguments[filterArity - 1] = targetReturn;\n+\n+\t\t\t// Invoke filter\n+\t\t\treturn filter.invokeWithArguments(newArguments);\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Creates an adapter MethodHandle (MH) which invokes the target MH and then\n+\t * invokes the filter MH while passing the output from the target MH as an\n+\t * input to the filter MH.\n+\t * \n+\t * targetMH:  O target(P...)\n+\t * filterMH:  Q filter(R..., O)\n+\t * adapterMH: Q adapter(P... p, R... r) {\n+\t *                O o = target(p);\n+\t *                return filter(r, o);  \n+\t *            }\n+\t *\n+\t * @param target represents the above targetMH.\n+\t * @param filter represent the above filterMH.\n+\t * \n+\t * @return a MH similar to the above adapterMH.\n+\t */\n+\tstatic MethodHandle collectReturnValue(MethodHandle target, MethodHandle filter) {\n+\t\tMethodType targetType = target.type();\n+\t\tMethodType filterType = filter.type();\n+\t\tMethodType resultType = targetType.changeReturnType(filterType.returnType());\n+\t\tint filterParamCount = filterType.parameterCount();\n+\t\tif (filterParamCount > 1) {\n+\t\t\tfor (int i = 0; i < filterParamCount - 1; i++) {\n+\t\t\t\tresultType = resultType.appendParameterTypes(filterType.parameterType(i));\n+\t\t\t}\n+\t\t}\n+\t\treturn buildTransformHandle(new CollectReturnHelper(target, filter), resultType);\n+\t}\n+\t\n+\t/**\n+\t * Return an array of checked exceptions for a MethodHandle.\n+\t * \n+\t * @param mh A MethodHandle to lookup for checked exceptions.\n+\t * \n+\t * @return an array of checked exception classes if any or null.\n+\t * \n+\t * @throws InternalError for an error.\n+\t */\n+\tstatic Class<?>[] checkedExceptions(MethodHandle mh) {\n+\t\tif (mh == null) {\n+\t\t\treturn null;\n+\t\t}\n+\t\tList<MethodHandle> relatedMHsList = null;\n+\t\tList<Class<?>> exceptionTypesList = null;\n+\t\twhile (mh != null) {\n+\t\t\tif (mh instanceof PrimitiveHandle) {\n+\t\t\t\tClass<?>[] exceptionTypes = null;\n+\t\t\t\tMethodHandleInfoImpl mhi = new MethodHandleInfoImpl((PrimitiveHandle)mh);\n+\t\t\t\tif (mhi.isConstructor()) {\n+\t\t\t\t\texceptionTypes = mhi.reflectAs(Constructor.class, Lookup.IMPL_LOOKUP).getExceptionTypes();\n+\t\t\t\t} else if (mhi.isMethod()) {\n+\t\t\t\t\texceptionTypes = mhi.reflectAs(Method.class, Lookup.IMPL_LOOKUP).getExceptionTypes();\n+\t\t\t\t} else if (mhi.isField()) {\n+\t\t\t\t\t/* Field reference kind has no checked exceptions. */\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new InternalError(\"Unknown reference kind.\"); //$NON-NLS-1$", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "07024e46399fea0a8bb59491f4fdeb98229d6289"}, "originalPosition": 239}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE3ODQ4OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t\t\tif (relatedMHsList == null) {\n          \n          \n            \n            \t\t\t\t\t\t\treturn exceptionTypes;\n          \n          \n            \n            \t\t\t\t\t\t} else {\n          \n          \n            \n            \t\t\t\t\t\t\texceptionTypesList = new ArrayList<>();\n          \n          \n            \n            \t\t\t\t\t\t}\n          \n          \n            \n            \t\t\t\t\t\tif (relatedMHsList == null) {\n          \n          \n            \n            \t\t\t\t\t\t\treturn exceptionTypes;\n          \n          \n            \n            \t\t\t\t\t\t}\n          \n          \n            \n            \t\t\t\t\t\texceptionTypesList = new ArrayList<>();", "url": "https://github.com/eclipse-openj9/openj9/pull/10274#discussion_r467178488", "createdAt": "2020-08-07T17:37:47Z", "author": {"login": "DanHeidinga"}, "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodHandles.java", "diffHunk": "@@ -5466,12 +5494,255 @@ public Object helper(Object[] arguments) throws Throwable {\n \t}\n \n \t/*[IF Java15]*/\n-\tstatic boolean permuteArgumentChecks(int[] arr, MethodType mt1, MethodType mt2) {\n-\t\tthrow OpenJDKCompileStub.OpenJDKCompileStubThrowError();\n+\t/**\n+\t * Validates that the permute[] specifies a valid permutation from permuteType to handleType.\n+\t * This method throws IllegalArgumentException on failure and returns true on success. This\n+\t * disjointness allows it to be used in asserts.\n+\t * \n+\t * @param permute array specifies the conversion from permuteType to handleType.\n+\t * @param permuteType source method type.\n+\t * @param handleType target method type.\n+\t * \n+\t * @return true on success.\n+\t * @throws IllegalArgumentException on failure.\n+\t */\n+\tstatic boolean permuteArgumentChecks(int[] permute, MethodType permuteType, MethodType handleType) {\n+\t\treturn validatePermutationArray(permuteType, handleType, permute);\n \t}\n \t\n-\tstatic MethodHandle collectReturnValue(MethodHandle mh1, MethodHandle mh2) {\n-\t\tthrow OpenJDKCompileStub.OpenJDKCompileStubThrowError();\n+\t/**\n+\t * Return the classData stored in the accessClass of the Lookup object.\n+\t * \n+\t * @param caller Lookup object used to verify privileged access and retrieve classData.\n+\t * @param unused.\n+\t * @param type used to cast the classData of the accessClass.\n+\t * \n+\t * @return the classData casted to the appropriate type.\n+\t * @throws IllegalAccessException in the absence of full privilege access.\n+\t */\n+\tstatic <T> T classData(Lookup caller, String unused, Class<T> type) throws IllegalAccessException {\n+\t\tif (caller.hasFullPrivilegeAccess()) {\n+\t\t\tObject classData = MethodHandleNatives.classData(caller.accessClass);\n+\t\t\treturn type.cast(classData);\n+\t\t}\n+\t\tthrow new IllegalAccessException(\"No full privilege access found for \" + caller);\n+\t}\n+\n+\t/**\n+\t * Helper class used by collectReturnValue.\n+\t */\n+\tprivate static final class CollectReturnHelper implements ArgumentHelper {\n+\t\tprivate final MethodHandle target;\n+\t\tprivate final MethodHandle filter;\n+\n+\t\tCollectReturnHelper(MethodHandle target, MethodHandle filter) {\n+\t\t\tthis.target = target;\n+\t\t\tthis.filter = filter;\n+\t\t}\n+\n+\t\tpublic Object helper(Object[] arguments) throws Throwable {\n+\t\t\t// Invoke target\n+\t\t\tint targetArity = target.type.parameterCount();\n+\t\t\tObject targetReturn = target.invokeWithArguments(Arrays.copyOfRange(arguments, 0, targetArity));\n+\n+\t\t\t// Construct filter arguments\n+\t\t\tint filterArity = filter.type.parameterCount();\n+\t\t\tObject[] newArguments = new Object[filterArity];\n+\t\t\tSystem.arraycopy(arguments, targetArity, newArguments, 0, filterArity - 1);\n+\t\t\tnewArguments[filterArity - 1] = targetReturn;\n+\n+\t\t\t// Invoke filter\n+\t\t\treturn filter.invokeWithArguments(newArguments);\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Creates an adapter MethodHandle (MH) which invokes the target MH and then\n+\t * invokes the filter MH while passing the output from the target MH as an\n+\t * input to the filter MH.\n+\t * \n+\t * targetMH:  O target(P...)\n+\t * filterMH:  Q filter(R..., O)\n+\t * adapterMH: Q adapter(P... p, R... r) {\n+\t *                O o = target(p);\n+\t *                return filter(r, o);  \n+\t *            }\n+\t *\n+\t * @param target represents the above targetMH.\n+\t * @param filter represent the above filterMH.\n+\t * \n+\t * @return a MH similar to the above adapterMH.\n+\t */\n+\tstatic MethodHandle collectReturnValue(MethodHandle target, MethodHandle filter) {\n+\t\tMethodType targetType = target.type();\n+\t\tMethodType filterType = filter.type();\n+\t\tMethodType resultType = targetType.changeReturnType(filterType.returnType());\n+\t\tint filterParamCount = filterType.parameterCount();\n+\t\tif (filterParamCount > 1) {\n+\t\t\tfor (int i = 0; i < filterParamCount - 1; i++) {\n+\t\t\t\tresultType = resultType.appendParameterTypes(filterType.parameterType(i));\n+\t\t\t}\n+\t\t}\n+\t\treturn buildTransformHandle(new CollectReturnHelper(target, filter), resultType);\n+\t}\n+\t\n+\t/**\n+\t * Return an array of checked exceptions for a MethodHandle.\n+\t * \n+\t * @param mh A MethodHandle to lookup for checked exceptions.\n+\t * \n+\t * @return an array of checked exception classes if any or null.\n+\t * \n+\t * @throws InternalError for an error.\n+\t */\n+\tstatic Class<?>[] checkedExceptions(MethodHandle mh) {\n+\t\tif (mh == null) {\n+\t\t\treturn null;\n+\t\t}\n+\t\tList<MethodHandle> relatedMHsList = null;\n+\t\tList<Class<?>> exceptionTypesList = null;\n+\t\twhile (mh != null) {\n+\t\t\tif (mh instanceof PrimitiveHandle) {\n+\t\t\t\tClass<?>[] exceptionTypes = null;\n+\t\t\t\tMethodHandleInfoImpl mhi = new MethodHandleInfoImpl((PrimitiveHandle)mh);\n+\t\t\t\tif (mhi.isConstructor()) {\n+\t\t\t\t\texceptionTypes = mhi.reflectAs(Constructor.class, Lookup.IMPL_LOOKUP).getExceptionTypes();\n+\t\t\t\t} else if (mhi.isMethod()) {\n+\t\t\t\t\texceptionTypes = mhi.reflectAs(Method.class, Lookup.IMPL_LOOKUP).getExceptionTypes();\n+\t\t\t\t} else if (mhi.isField()) {\n+\t\t\t\t\t/* Field reference kind has no checked exceptions. */\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new InternalError(\"Unknown reference kind.\"); //$NON-NLS-1$\n+\t\t\t\t}\n+\t\t\t\tif (exceptionTypes != null) {\n+\t\t\t\t\tif (exceptionTypesList == null) {\n+\t\t\t\t\t\tif (relatedMHsList == null) {\n+\t\t\t\t\t\t\treturn exceptionTypes;\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\texceptionTypesList = new ArrayList<>();\n+\t\t\t\t\t\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "07024e46399fea0a8bb59491f4fdeb98229d6289"}, "originalPosition": 247}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE4NTkwNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t * @param mh A MethodHandle to lookup for checked exceptions.\n          \n          \n            \n            \t * @param mh A MethodHandle to lookup for checked exceptions.\n          \n      \n    \n    \n  \n\nlookup tends to be a loaded word here.  Might be better to rephrase this", "url": "https://github.com/eclipse-openj9/openj9/pull/10274#discussion_r467185905", "createdAt": "2020-08-07T17:52:45Z", "author": {"login": "DanHeidinga"}, "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodHandles.java", "diffHunk": "@@ -5466,12 +5494,255 @@ public Object helper(Object[] arguments) throws Throwable {\n \t}\n \n \t/*[IF Java15]*/\n-\tstatic boolean permuteArgumentChecks(int[] arr, MethodType mt1, MethodType mt2) {\n-\t\tthrow OpenJDKCompileStub.OpenJDKCompileStubThrowError();\n+\t/**\n+\t * Validates that the permute[] specifies a valid permutation from permuteType to handleType.\n+\t * This method throws IllegalArgumentException on failure and returns true on success. This\n+\t * disjointness allows it to be used in asserts.\n+\t * \n+\t * @param permute array specifies the conversion from permuteType to handleType.\n+\t * @param permuteType source method type.\n+\t * @param handleType target method type.\n+\t * \n+\t * @return true on success.\n+\t * @throws IllegalArgumentException on failure.\n+\t */\n+\tstatic boolean permuteArgumentChecks(int[] permute, MethodType permuteType, MethodType handleType) {\n+\t\treturn validatePermutationArray(permuteType, handleType, permute);\n \t}\n \t\n-\tstatic MethodHandle collectReturnValue(MethodHandle mh1, MethodHandle mh2) {\n-\t\tthrow OpenJDKCompileStub.OpenJDKCompileStubThrowError();\n+\t/**\n+\t * Return the classData stored in the accessClass of the Lookup object.\n+\t * \n+\t * @param caller Lookup object used to verify privileged access and retrieve classData.\n+\t * @param unused.\n+\t * @param type used to cast the classData of the accessClass.\n+\t * \n+\t * @return the classData casted to the appropriate type.\n+\t * @throws IllegalAccessException in the absence of full privilege access.\n+\t */\n+\tstatic <T> T classData(Lookup caller, String unused, Class<T> type) throws IllegalAccessException {\n+\t\tif (caller.hasFullPrivilegeAccess()) {\n+\t\t\tObject classData = MethodHandleNatives.classData(caller.accessClass);\n+\t\t\treturn type.cast(classData);\n+\t\t}\n+\t\tthrow new IllegalAccessException(\"No full privilege access found for \" + caller);\n+\t}\n+\n+\t/**\n+\t * Helper class used by collectReturnValue.\n+\t */\n+\tprivate static final class CollectReturnHelper implements ArgumentHelper {\n+\t\tprivate final MethodHandle target;\n+\t\tprivate final MethodHandle filter;\n+\n+\t\tCollectReturnHelper(MethodHandle target, MethodHandle filter) {\n+\t\t\tthis.target = target;\n+\t\t\tthis.filter = filter;\n+\t\t}\n+\n+\t\tpublic Object helper(Object[] arguments) throws Throwable {\n+\t\t\t// Invoke target\n+\t\t\tint targetArity = target.type.parameterCount();\n+\t\t\tObject targetReturn = target.invokeWithArguments(Arrays.copyOfRange(arguments, 0, targetArity));\n+\n+\t\t\t// Construct filter arguments\n+\t\t\tint filterArity = filter.type.parameterCount();\n+\t\t\tObject[] newArguments = new Object[filterArity];\n+\t\t\tSystem.arraycopy(arguments, targetArity, newArguments, 0, filterArity - 1);\n+\t\t\tnewArguments[filterArity - 1] = targetReturn;\n+\n+\t\t\t// Invoke filter\n+\t\t\treturn filter.invokeWithArguments(newArguments);\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Creates an adapter MethodHandle (MH) which invokes the target MH and then\n+\t * invokes the filter MH while passing the output from the target MH as an\n+\t * input to the filter MH.\n+\t * \n+\t * targetMH:  O target(P...)\n+\t * filterMH:  Q filter(R..., O)\n+\t * adapterMH: Q adapter(P... p, R... r) {\n+\t *                O o = target(p);\n+\t *                return filter(r, o);  \n+\t *            }\n+\t *\n+\t * @param target represents the above targetMH.\n+\t * @param filter represent the above filterMH.\n+\t * \n+\t * @return a MH similar to the above adapterMH.\n+\t */\n+\tstatic MethodHandle collectReturnValue(MethodHandle target, MethodHandle filter) {\n+\t\tMethodType targetType = target.type();\n+\t\tMethodType filterType = filter.type();\n+\t\tMethodType resultType = targetType.changeReturnType(filterType.returnType());\n+\t\tint filterParamCount = filterType.parameterCount();\n+\t\tif (filterParamCount > 1) {\n+\t\t\tfor (int i = 0; i < filterParamCount - 1; i++) {\n+\t\t\t\tresultType = resultType.appendParameterTypes(filterType.parameterType(i));\n+\t\t\t}\n+\t\t}\n+\t\treturn buildTransformHandle(new CollectReturnHelper(target, filter), resultType);\n+\t}\n+\t\n+\t/**\n+\t * Return an array of checked exceptions for a MethodHandle.\n+\t * \n+\t * @param mh A MethodHandle to lookup for checked exceptions.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "07024e46399fea0a8bb59491f4fdeb98229d6289"}, "originalPosition": 216}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE4NzkzNw==", "bodyText": "Is this method as in the RI?  The OO way to do something like this is to add a helper method to each of the MH subclasses that returns its \"next\" methodhandles, similar to a visitor pattern.\nThis avoids needing to make the fields non-private\nie: each MH subclass would add a MH[] getRelatedMHs() method.", "url": "https://github.com/eclipse-openj9/openj9/pull/10274#discussion_r467187937", "createdAt": "2020-08-07T17:56:57Z", "author": {"login": "DanHeidinga"}, "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodHandles.java", "diffHunk": "@@ -5466,12 +5494,255 @@ public Object helper(Object[] arguments) throws Throwable {\n \t}\n \n \t/*[IF Java15]*/\n-\tstatic boolean permuteArgumentChecks(int[] arr, MethodType mt1, MethodType mt2) {\n-\t\tthrow OpenJDKCompileStub.OpenJDKCompileStubThrowError();\n+\t/**\n+\t * Validates that the permute[] specifies a valid permutation from permuteType to handleType.\n+\t * This method throws IllegalArgumentException on failure and returns true on success. This\n+\t * disjointness allows it to be used in asserts.\n+\t * \n+\t * @param permute array specifies the conversion from permuteType to handleType.\n+\t * @param permuteType source method type.\n+\t * @param handleType target method type.\n+\t * \n+\t * @return true on success.\n+\t * @throws IllegalArgumentException on failure.\n+\t */\n+\tstatic boolean permuteArgumentChecks(int[] permute, MethodType permuteType, MethodType handleType) {\n+\t\treturn validatePermutationArray(permuteType, handleType, permute);\n \t}\n \t\n-\tstatic MethodHandle collectReturnValue(MethodHandle mh1, MethodHandle mh2) {\n-\t\tthrow OpenJDKCompileStub.OpenJDKCompileStubThrowError();\n+\t/**\n+\t * Return the classData stored in the accessClass of the Lookup object.\n+\t * \n+\t * @param caller Lookup object used to verify privileged access and retrieve classData.\n+\t * @param unused.\n+\t * @param type used to cast the classData of the accessClass.\n+\t * \n+\t * @return the classData casted to the appropriate type.\n+\t * @throws IllegalAccessException in the absence of full privilege access.\n+\t */\n+\tstatic <T> T classData(Lookup caller, String unused, Class<T> type) throws IllegalAccessException {\n+\t\tif (caller.hasFullPrivilegeAccess()) {\n+\t\t\tObject classData = MethodHandleNatives.classData(caller.accessClass);\n+\t\t\treturn type.cast(classData);\n+\t\t}\n+\t\tthrow new IllegalAccessException(\"No full privilege access found for \" + caller);\n+\t}\n+\n+\t/**\n+\t * Helper class used by collectReturnValue.\n+\t */\n+\tprivate static final class CollectReturnHelper implements ArgumentHelper {\n+\t\tprivate final MethodHandle target;\n+\t\tprivate final MethodHandle filter;\n+\n+\t\tCollectReturnHelper(MethodHandle target, MethodHandle filter) {\n+\t\t\tthis.target = target;\n+\t\t\tthis.filter = filter;\n+\t\t}\n+\n+\t\tpublic Object helper(Object[] arguments) throws Throwable {\n+\t\t\t// Invoke target\n+\t\t\tint targetArity = target.type.parameterCount();\n+\t\t\tObject targetReturn = target.invokeWithArguments(Arrays.copyOfRange(arguments, 0, targetArity));\n+\n+\t\t\t// Construct filter arguments\n+\t\t\tint filterArity = filter.type.parameterCount();\n+\t\t\tObject[] newArguments = new Object[filterArity];\n+\t\t\tSystem.arraycopy(arguments, targetArity, newArguments, 0, filterArity - 1);\n+\t\t\tnewArguments[filterArity - 1] = targetReturn;\n+\n+\t\t\t// Invoke filter\n+\t\t\treturn filter.invokeWithArguments(newArguments);\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Creates an adapter MethodHandle (MH) which invokes the target MH and then\n+\t * invokes the filter MH while passing the output from the target MH as an\n+\t * input to the filter MH.\n+\t * \n+\t * targetMH:  O target(P...)\n+\t * filterMH:  Q filter(R..., O)\n+\t * adapterMH: Q adapter(P... p, R... r) {\n+\t *                O o = target(p);\n+\t *                return filter(r, o);  \n+\t *            }\n+\t *\n+\t * @param target represents the above targetMH.\n+\t * @param filter represent the above filterMH.\n+\t * \n+\t * @return a MH similar to the above adapterMH.\n+\t */\n+\tstatic MethodHandle collectReturnValue(MethodHandle target, MethodHandle filter) {\n+\t\tMethodType targetType = target.type();\n+\t\tMethodType filterType = filter.type();\n+\t\tMethodType resultType = targetType.changeReturnType(filterType.returnType());\n+\t\tint filterParamCount = filterType.parameterCount();\n+\t\tif (filterParamCount > 1) {\n+\t\t\tfor (int i = 0; i < filterParamCount - 1; i++) {\n+\t\t\t\tresultType = resultType.appendParameterTypes(filterType.parameterType(i));\n+\t\t\t}\n+\t\t}\n+\t\treturn buildTransformHandle(new CollectReturnHelper(target, filter), resultType);\n+\t}\n+\t\n+\t/**\n+\t * Return an array of checked exceptions for a MethodHandle.\n+\t * \n+\t * @param mh A MethodHandle to lookup for checked exceptions.\n+\t * \n+\t * @return an array of checked exception classes if any or null.\n+\t * \n+\t * @throws InternalError for an error.\n+\t */\n+\tstatic Class<?>[] checkedExceptions(MethodHandle mh) {\n+\t\tif (mh == null) {\n+\t\t\treturn null;\n+\t\t}\n+\t\tList<MethodHandle> relatedMHsList = null;\n+\t\tList<Class<?>> exceptionTypesList = null;\n+\t\twhile (mh != null) {\n+\t\t\tif (mh instanceof PrimitiveHandle) {\n+\t\t\t\tClass<?>[] exceptionTypes = null;\n+\t\t\t\tMethodHandleInfoImpl mhi = new MethodHandleInfoImpl((PrimitiveHandle)mh);\n+\t\t\t\tif (mhi.isConstructor()) {\n+\t\t\t\t\texceptionTypes = mhi.reflectAs(Constructor.class, Lookup.IMPL_LOOKUP).getExceptionTypes();\n+\t\t\t\t} else if (mhi.isMethod()) {\n+\t\t\t\t\texceptionTypes = mhi.reflectAs(Method.class, Lookup.IMPL_LOOKUP).getExceptionTypes();\n+\t\t\t\t} else if (mhi.isField()) {\n+\t\t\t\t\t/* Field reference kind has no checked exceptions. */\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new InternalError(\"Unknown reference kind.\"); //$NON-NLS-1$\n+\t\t\t\t}\n+\t\t\t\tif (exceptionTypes != null) {\n+\t\t\t\t\tif (exceptionTypesList == null) {\n+\t\t\t\t\t\tif (relatedMHsList == null) {\n+\t\t\t\t\t\t\treturn exceptionTypes;\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\texceptionTypesList = new ArrayList<>();\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tCollections.addAll(exceptionTypesList, exceptionTypes);\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tif (relatedMHsList == null) {\n+\t\t\t\t\trelatedMHsList = new ArrayList<>();\n+\t\t\t\t}\n+\t\t\t\tfindRelatedMHs(mh, relatedMHsList);\n+\t\t\t}\n+\t\t\tif ((relatedMHsList == null) || relatedMHsList.isEmpty()) {\n+\t\t\t\tbreak;\n+\t\t\t} else {\n+\t\t\t\tmh = relatedMHsList.remove(relatedMHsList.size() - 1);\n+\t\t\t}\n+\t\t}\n+\t\tClass<?>[] exceptionTypesArray = null;\n+\t\tif (exceptionTypesList != null) {\n+\t\t\texceptionTypesArray = exceptionTypesList.toArray(new Class<?>[exceptionTypesList.size()]);\n+\t\t}\n+\t\treturn exceptionTypesArray;\n+\t}\n+\t\n+\t/**\n+\t * A MethodHandle can be combination of multiple MethodHandles. This helper finds all the related\n+\t * MethodHandles for a MethodHandle and appends the related MethodHandles to the relatedMHs list.\n+\t * \n+\t * @param mh The MethodHandle to evaluate.\n+\t * @param[out] relatedMHs A list of related MethodHandles.\n+\t * \n+\t * @return void.\n+\t * @throws InternalError for an unknown MethodHandle kind or an exception during a privileged\n+\t * operation for ReceiverBoundHandle.\n+\t */\n+\tprivate static void findRelatedMHs(MethodHandle mh, List<MethodHandle> relatedMHs) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "07024e46399fea0a8bb59491f4fdeb98229d6289"}, "originalPosition": 281}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE5MzM5Nw==", "bodyText": "Is this the expected behaviour?  I think you can create an infinite loop here by doing something like:\nMutableCallSite mcs = new MutableCallSite(MethodType.type(void.class));\nMH dynInvoker = mcs.dynamicInvoker();\nmcs.setTarget(dynInvoker);\ncheckedExceptions.dynInvoker();", "url": "https://github.com/eclipse-openj9/openj9/pull/10274#discussion_r467193397", "createdAt": "2020-08-07T18:08:16Z", "author": {"login": "DanHeidinga"}, "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodHandles.java", "diffHunk": "@@ -5466,12 +5494,255 @@ public Object helper(Object[] arguments) throws Throwable {\n \t}\n \n \t/*[IF Java15]*/\n-\tstatic boolean permuteArgumentChecks(int[] arr, MethodType mt1, MethodType mt2) {\n-\t\tthrow OpenJDKCompileStub.OpenJDKCompileStubThrowError();\n+\t/**\n+\t * Validates that the permute[] specifies a valid permutation from permuteType to handleType.\n+\t * This method throws IllegalArgumentException on failure and returns true on success. This\n+\t * disjointness allows it to be used in asserts.\n+\t * \n+\t * @param permute array specifies the conversion from permuteType to handleType.\n+\t * @param permuteType source method type.\n+\t * @param handleType target method type.\n+\t * \n+\t * @return true on success.\n+\t * @throws IllegalArgumentException on failure.\n+\t */\n+\tstatic boolean permuteArgumentChecks(int[] permute, MethodType permuteType, MethodType handleType) {\n+\t\treturn validatePermutationArray(permuteType, handleType, permute);\n \t}\n \t\n-\tstatic MethodHandle collectReturnValue(MethodHandle mh1, MethodHandle mh2) {\n-\t\tthrow OpenJDKCompileStub.OpenJDKCompileStubThrowError();\n+\t/**\n+\t * Return the classData stored in the accessClass of the Lookup object.\n+\t * \n+\t * @param caller Lookup object used to verify privileged access and retrieve classData.\n+\t * @param unused.\n+\t * @param type used to cast the classData of the accessClass.\n+\t * \n+\t * @return the classData casted to the appropriate type.\n+\t * @throws IllegalAccessException in the absence of full privilege access.\n+\t */\n+\tstatic <T> T classData(Lookup caller, String unused, Class<T> type) throws IllegalAccessException {\n+\t\tif (caller.hasFullPrivilegeAccess()) {\n+\t\t\tObject classData = MethodHandleNatives.classData(caller.accessClass);\n+\t\t\treturn type.cast(classData);\n+\t\t}\n+\t\tthrow new IllegalAccessException(\"No full privilege access found for \" + caller);\n+\t}\n+\n+\t/**\n+\t * Helper class used by collectReturnValue.\n+\t */\n+\tprivate static final class CollectReturnHelper implements ArgumentHelper {\n+\t\tprivate final MethodHandle target;\n+\t\tprivate final MethodHandle filter;\n+\n+\t\tCollectReturnHelper(MethodHandle target, MethodHandle filter) {\n+\t\t\tthis.target = target;\n+\t\t\tthis.filter = filter;\n+\t\t}\n+\n+\t\tpublic Object helper(Object[] arguments) throws Throwable {\n+\t\t\t// Invoke target\n+\t\t\tint targetArity = target.type.parameterCount();\n+\t\t\tObject targetReturn = target.invokeWithArguments(Arrays.copyOfRange(arguments, 0, targetArity));\n+\n+\t\t\t// Construct filter arguments\n+\t\t\tint filterArity = filter.type.parameterCount();\n+\t\t\tObject[] newArguments = new Object[filterArity];\n+\t\t\tSystem.arraycopy(arguments, targetArity, newArguments, 0, filterArity - 1);\n+\t\t\tnewArguments[filterArity - 1] = targetReturn;\n+\n+\t\t\t// Invoke filter\n+\t\t\treturn filter.invokeWithArguments(newArguments);\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Creates an adapter MethodHandle (MH) which invokes the target MH and then\n+\t * invokes the filter MH while passing the output from the target MH as an\n+\t * input to the filter MH.\n+\t * \n+\t * targetMH:  O target(P...)\n+\t * filterMH:  Q filter(R..., O)\n+\t * adapterMH: Q adapter(P... p, R... r) {\n+\t *                O o = target(p);\n+\t *                return filter(r, o);  \n+\t *            }\n+\t *\n+\t * @param target represents the above targetMH.\n+\t * @param filter represent the above filterMH.\n+\t * \n+\t * @return a MH similar to the above adapterMH.\n+\t */\n+\tstatic MethodHandle collectReturnValue(MethodHandle target, MethodHandle filter) {\n+\t\tMethodType targetType = target.type();\n+\t\tMethodType filterType = filter.type();\n+\t\tMethodType resultType = targetType.changeReturnType(filterType.returnType());\n+\t\tint filterParamCount = filterType.parameterCount();\n+\t\tif (filterParamCount > 1) {\n+\t\t\tfor (int i = 0; i < filterParamCount - 1; i++) {\n+\t\t\t\tresultType = resultType.appendParameterTypes(filterType.parameterType(i));\n+\t\t\t}\n+\t\t}\n+\t\treturn buildTransformHandle(new CollectReturnHelper(target, filter), resultType);\n+\t}\n+\t\n+\t/**\n+\t * Return an array of checked exceptions for a MethodHandle.\n+\t * \n+\t * @param mh A MethodHandle to lookup for checked exceptions.\n+\t * \n+\t * @return an array of checked exception classes if any or null.\n+\t * \n+\t * @throws InternalError for an error.\n+\t */\n+\tstatic Class<?>[] checkedExceptions(MethodHandle mh) {\n+\t\tif (mh == null) {\n+\t\t\treturn null;\n+\t\t}\n+\t\tList<MethodHandle> relatedMHsList = null;\n+\t\tList<Class<?>> exceptionTypesList = null;\n+\t\twhile (mh != null) {\n+\t\t\tif (mh instanceof PrimitiveHandle) {\n+\t\t\t\tClass<?>[] exceptionTypes = null;\n+\t\t\t\tMethodHandleInfoImpl mhi = new MethodHandleInfoImpl((PrimitiveHandle)mh);\n+\t\t\t\tif (mhi.isConstructor()) {\n+\t\t\t\t\texceptionTypes = mhi.reflectAs(Constructor.class, Lookup.IMPL_LOOKUP).getExceptionTypes();\n+\t\t\t\t} else if (mhi.isMethod()) {\n+\t\t\t\t\texceptionTypes = mhi.reflectAs(Method.class, Lookup.IMPL_LOOKUP).getExceptionTypes();\n+\t\t\t\t} else if (mhi.isField()) {\n+\t\t\t\t\t/* Field reference kind has no checked exceptions. */\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new InternalError(\"Unknown reference kind.\"); //$NON-NLS-1$\n+\t\t\t\t}\n+\t\t\t\tif (exceptionTypes != null) {\n+\t\t\t\t\tif (exceptionTypesList == null) {\n+\t\t\t\t\t\tif (relatedMHsList == null) {\n+\t\t\t\t\t\t\treturn exceptionTypes;\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\texceptionTypesList = new ArrayList<>();\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tCollections.addAll(exceptionTypesList, exceptionTypes);\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tif (relatedMHsList == null) {\n+\t\t\t\t\trelatedMHsList = new ArrayList<>();\n+\t\t\t\t}\n+\t\t\t\tfindRelatedMHs(mh, relatedMHsList);\n+\t\t\t}\n+\t\t\tif ((relatedMHsList == null) || relatedMHsList.isEmpty()) {\n+\t\t\t\tbreak;\n+\t\t\t} else {\n+\t\t\t\tmh = relatedMHsList.remove(relatedMHsList.size() - 1);\n+\t\t\t}\n+\t\t}\n+\t\tClass<?>[] exceptionTypesArray = null;\n+\t\tif (exceptionTypesList != null) {\n+\t\t\texceptionTypesArray = exceptionTypesList.toArray(new Class<?>[exceptionTypesList.size()]);\n+\t\t}\n+\t\treturn exceptionTypesArray;\n+\t}\n+\t\n+\t/**\n+\t * A MethodHandle can be combination of multiple MethodHandles. This helper finds all the related\n+\t * MethodHandles for a MethodHandle and appends the related MethodHandles to the relatedMHs list.\n+\t * \n+\t * @param mh The MethodHandle to evaluate.\n+\t * @param[out] relatedMHs A list of related MethodHandles.\n+\t * \n+\t * @return void.\n+\t * @throws InternalError for an unknown MethodHandle kind or an exception during a privileged\n+\t * operation for ReceiverBoundHandle.\n+\t */\n+\tprivate static void findRelatedMHs(MethodHandle mh, List<MethodHandle> relatedMHs) {\n+\t\tbyte kind = mh.kind;\n+\t\tif (mh instanceof PrimitiveHandle) {\n+\t\t\t/* Do not append to relatedMHs. */\n+\t\t} else if ((kind == MethodHandle.KIND_CONSTANTOBJECT)\n+\t\t\t|| (kind == MethodHandle.KIND_CONSTANTINT)\n+\t\t\t|| (kind == MethodHandle.KIND_CONSTANTFLOAT)\n+\t\t\t|| (kind == MethodHandle.KIND_CONSTANTFLOAT)\n+\t\t\t|| (kind == MethodHandle.KIND_CONSTANTLONG)\n+\t\t\t|| (kind == MethodHandle.KIND_CONSTANTDOUBLE)\n+\t\t) {\n+\t\t\t/* Does not support checked exceptions. */\n+\t\t} else if (kind == MethodHandle.KIND_VARARGSCOLLECT) {\n+\t\t\trelatedMHs.add(((VarargsCollectorHandle)mh).next);\n+\t\t} else if (kind == MethodHandle.KIND_ASTYPE) {\n+\t\t\trelatedMHs.add(((AsTypeHandle)mh).next);\n+\t\t} else if (kind == MethodHandle.KIND_FILTERRETURN) {\n+\t\t\trelatedMHs.add(((FilterReturnHandle)mh).next);\n+\t\t} else if (kind == MethodHandle.KIND_EXPLICITCAST) {\n+\t\t\trelatedMHs.add(((ExplicitCastHandle)mh).next);\n+\t\t} else if (kind == MethodHandle.KIND_SPREAD) {\n+\t\t\trelatedMHs.add(((SpreadHandle)mh).next);\n+\t\t} else if (kind == MethodHandle.KIND_FOLDHANDLE) {\n+\t\t\trelatedMHs.add(((FoldHandle)mh).next);\n+\t\t\trelatedMHs.add(((FoldHandle)mh).combiner);\n+\t\t} else if (kind == MethodHandle.KIND_GUARDWITHTEST) {\n+\t\t\trelatedMHs.add(((GuardWithTestHandle)mh).guard);\n+\t\t\trelatedMHs.add(((GuardWithTestHandle)mh).trueTarget);\n+\t\t\trelatedMHs.add(((GuardWithTestHandle)mh).falseTarget);\n+\t\t} else if (kind == MethodHandle.KIND_FILTERARGUMENTS) {\n+\t\t\trelatedMHs.add(((FilterArgumentsHandle)mh).next);\n+\t\t\tCollections.addAll(relatedMHs, ((FilterArgumentsHandle)mh).filters);\n+\t\t} else if (kind == MethodHandle.KIND_FILTERARGUMENTS_WITHCOMBINER) {\n+\t\t\trelatedMHs.add(((FilterArgumentsWithCombinerHandle)mh).next);\n+\t\t\trelatedMHs.add(((FilterArgumentsWithCombinerHandle)mh).combiner);\n+\t\t} else if (kind == MethodHandle.KIND_DYNAMICINVOKER) {\n+\t\t\trelatedMHs.add(((DynamicInvokerHandle)mh).site.getTarget());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "07024e46399fea0a8bb59491f4fdeb98229d6289"}, "originalPosition": 317}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "07024e46399fea0a8bb59491f4fdeb98229d6289", "author": {"user": {"login": "babsingh", "name": "Babneet Singh"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/07024e46399fea0a8bb59491f4fdeb98229d6289", "committedDate": "2020-08-06T20:33:14Z", "message": "Lookup for checked exceptions in OpenJ9 MethodHandles\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>"}, "afterCommit": {"oid": "aead271667c0c8ad48cd40119aa6e1158ae65f49", "author": {"user": {"login": "babsingh", "name": "Babneet Singh"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/aead271667c0c8ad48cd40119aa6e1158ae65f49", "committedDate": "2020-08-10T15:32:53Z", "message": "Lookup for checked exceptions in OpenJ9 MethodHandles\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "aead271667c0c8ad48cd40119aa6e1158ae65f49", "author": {"user": {"login": "babsingh", "name": "Babneet Singh"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/aead271667c0c8ad48cd40119aa6e1158ae65f49", "committedDate": "2020-08-10T15:32:53Z", "message": "Lookup for checked exceptions in OpenJ9 MethodHandles\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>"}, "afterCommit": {"oid": "70b0510c6656df24641c0861c781ab3b4e27c496", "author": {"user": {"login": "babsingh", "name": "Babneet Singh"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/70b0510c6656df24641c0861c781ab3b4e27c496", "committedDate": "2020-08-10T16:25:28Z", "message": "Lookup for checked exceptions in OpenJ9 MethodHandles\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "70b0510c6656df24641c0861c781ab3b4e27c496", "author": {"user": {"login": "babsingh", "name": "Babneet Singh"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/70b0510c6656df24641c0861c781ab3b4e27c496", "committedDate": "2020-08-10T16:25:28Z", "message": "Lookup for checked exceptions in OpenJ9 MethodHandles\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>"}, "afterCommit": {"oid": "b98401b8e5b4d5a8ef8071369435b85b8e718a82", "author": {"user": {"login": "babsingh", "name": "Babneet Singh"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/b98401b8e5b4d5a8ef8071369435b85b8e718a82", "committedDate": "2020-08-10T16:33:31Z", "message": "Lookup for checked exceptions in OpenJ9 MethodHandles\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b98401b8e5b4d5a8ef8071369435b85b8e718a82", "author": {"user": {"login": "babsingh", "name": "Babneet Singh"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/b98401b8e5b4d5a8ef8071369435b85b8e718a82", "committedDate": "2020-08-10T16:33:31Z", "message": "Lookup for checked exceptions in OpenJ9 MethodHandles\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>"}, "afterCommit": {"oid": "8e9a4a37981a6ac8680a0876da8c0b9a4ff6d475", "author": {"user": {"login": "babsingh", "name": "Babneet Singh"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/8e9a4a37981a6ac8680a0876da8c0b9a4ff6d475", "committedDate": "2020-08-10T16:37:40Z", "message": "Lookup for checked exceptions in OpenJ9 MethodHandles\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "612ab9fe0382a0db5e21ef2d1d0395ba7c1fa16b", "author": {"user": {"login": "babsingh", "name": "Babneet Singh"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/612ab9fe0382a0db5e21ef2d1d0395ba7c1fa16b", "committedDate": "2020-08-10T21:28:37Z", "message": "Lookup for checked exceptions in OpenJ9 MethodHandles (OO variant)\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>"}, "afterCommit": {"oid": "9d633ae41513568aca528e49694291e21f725cc4", "author": {"user": {"login": "babsingh", "name": "Babneet Singh"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/9d633ae41513568aca528e49694291e21f725cc4", "committedDate": "2020-08-10T21:36:48Z", "message": "Lookup for checked exceptions in OpenJ9 MethodHandles (OO variant)\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9d633ae41513568aca528e49694291e21f725cc4", "author": {"user": {"login": "babsingh", "name": "Babneet Singh"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/9d633ae41513568aca528e49694291e21f725cc4", "committedDate": "2020-08-10T21:36:48Z", "message": "Lookup for checked exceptions in OpenJ9 MethodHandles (OO variant)\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>"}, "afterCommit": {"oid": "83356acc89db2f53fb42ecbfb5a0156f8498b6ab", "author": {"user": {"login": "babsingh", "name": "Babneet Singh"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/83356acc89db2f53fb42ecbfb5a0156f8498b6ab", "committedDate": "2020-08-10T21:43:51Z", "message": "Lookup for checked exceptions in OpenJ9 MethodHandles (OO variant)\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "83356acc89db2f53fb42ecbfb5a0156f8498b6ab", "author": {"user": {"login": "babsingh", "name": "Babneet Singh"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/83356acc89db2f53fb42ecbfb5a0156f8498b6ab", "committedDate": "2020-08-10T21:43:51Z", "message": "Lookup for checked exceptions in OpenJ9 MethodHandles (OO variant)\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>"}, "afterCommit": {"oid": "c09bb8a374ea3cd4550a480d9b888da1a5441d65", "author": {"user": {"login": "babsingh", "name": "Babneet Singh"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/c09bb8a374ea3cd4550a480d9b888da1a5441d65", "committedDate": "2020-08-10T22:05:08Z", "message": "Lookup for checked exceptions in OpenJ9 MethodHandles (OO variant)\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c09bb8a374ea3cd4550a480d9b888da1a5441d65", "author": {"user": {"login": "babsingh", "name": "Babneet Singh"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/c09bb8a374ea3cd4550a480d9b888da1a5441d65", "committedDate": "2020-08-10T22:05:08Z", "message": "Lookup for checked exceptions in OpenJ9 MethodHandles (OO variant)\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>"}, "afterCommit": {"oid": "981e4d98777631a5ed1a97e70d0cb70a7bbc33e3", "author": {"user": {"login": "babsingh", "name": "Babneet Singh"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/981e4d98777631a5ed1a97e70d0cb70a7bbc33e3", "committedDate": "2020-08-10T22:45:52Z", "message": "[JEP383] Scan for checked exceptions in OpenJ9 MethodHandles\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY1MTQ5MTgw", "url": "https://github.com/eclipse-openj9/openj9/pull/10274#pullrequestreview-465149180", "createdAt": "2020-08-11T14:54:08Z", "commit": {"oid": "981e4d98777631a5ed1a97e70d0cb70a7bbc33e3"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNDo1NDowOFrOG-7xrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwNTo0Njo0NFrOG_SnLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY0NDI3MQ==", "bodyText": "Should this depend on the type of the site?  ie: a ConstantCallSite should include the target and others shouldn't?", "url": "https://github.com/eclipse-openj9/openj9/pull/10274#discussion_r468644271", "createdAt": "2020-08-11T14:54:08Z", "author": {"login": "DanHeidinga"}, "path": "jcl/src/java.base/share/classes/java/lang/invoke/DynamicInvokerHandle.java", "diffHunk": "@@ -37,6 +37,16 @@\n \t\tthis.site = originalHandle.site;\n \t}\n \n+/*[IF Java15]*/\n+\tMethodHandle[] getRelatedMHs() {\n+\t\tMethodHandle targetMH = site.getTarget();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "981e4d98777631a5ed1a97e70d0cb70a7bbc33e3"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY0NjIxMg==", "bodyText": "How often will this API get called?  It generates a lot of garbage arrays.\nIf it's rare, then I won't worry.  If it's a lot, then a API that adds the next handles to an existing ArrayList is probably better - boolean addRelatedMHs(List<? extends MH> relatedMHs)", "url": "https://github.com/eclipse-openj9/openj9/pull/10274#discussion_r468646212", "createdAt": "2020-08-11T14:56:45Z", "author": {"login": "DanHeidinga"}, "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodHandle.java", "diffHunk": "@@ -1587,6 +1587,15 @@ String mapKindToBytecode() {\n \t\treturn \"KIND_#\"+kind; //$NON-NLS-1$\n \t}\n \n+/*[IF Java15]*/\n+\t/**\n+\t * Get an array of child MethodHandle(s) which form \"this\" (parent MethodHandle).\n+\t * \n+\t * @return an array of MethodHandles, or null if no child MethodHandles are found.\n+\t */\n+\tabstract MethodHandle[] getRelatedMHs();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "981e4d98777631a5ed1a97e70d0cb70a7bbc33e3"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTAxODE2OQ==", "bodyText": "This is more complicated than it needs to be as it tries to lazy init the lists.  Something like the code below is more explicit that it's processing the MH chain as a worklist until it has found all the ExceptionTypes in the MH chain:\n\tstatic Class<?>[] getExceptions(MethodHandle mh) {\n\t\tif (mh == null) {\n\t\t\treturn null;\n\t\t}\n\t\tDeque<MethodHandle> workList = = new ArrayDeque<>();\n\t\trelatedMHsList.push(mh);\n\t\tList<Class<?>> exceptionTypesList = new ArrayList<>(4);\n\n\t\twhile (!workList.isEmpty()) {\n\t\t\tmh = workList.pop();\n\t\t\tif (mh instanceof PrimitiveHandle) {\n\t\t\t\tClass<?>[] exceptionTypes = null;\n\t\t\t\tMethodHandleInfoImpl mhi = new MethodHandleInfoImpl((PrimitiveHandle)mh);\n\t\t\t\tif (mhi.isConstructor()) {\n\t\t\t\t\texceptionTypes = mhi.reflectAs(Constructor.class, Lookup.IMPL_LOOKUP).getExceptionTypes();\n\t\t\t\t} else if (mhi.isMethod()) {\n\t\t\t\t\texceptionTypes = mhi.reflectAs(Method.class, Lookup.IMPL_LOOKUP).getExceptionTypes();\n\t\t\t\t} else if (mhi.isField()) {\n\t\t\t\t\t/* Field reference kind has no checked exceptions. */\n\t\t\t\t} else {\n\t\t\t\t\t/*[MSG \"K0686\", \"Unknown reference kind: '{0}'\"]*/\n\t\t\t\t\tthrow new InternalError(com.ibm.oti.util.Msg.getString(\"K0686\", mhi.getReferenceKind())); //$NON-NLS-1$\n\t\t\t\t}\n\t\t\t\tCollections.addAll(exceptionTypesList, exceptionTypes);\n\t\t\t} else {\n\t\t\t\tMethodHandle[] relatedMHs = mh.getRelatedMHs();\n\t\t\t\tworkList.addAll(relatedMHs);\n\t\t\t}\n\t\t}\n\t\tClass<?>[] exceptionTypesArray = null;\n\t\tif (!exceptionTypesList.isEmpty()) {\n\t\t\texceptionTypesArray = exceptionTypesList.toArray(new Class<?>[0]);\n\t\t}\n\t\treturn exceptionTypesArray;\n\t}\nI left exceptionTypesList as a List though it may be better as a HashSet to avoid repeated processing of the same exception classes.  An even better approach may be to check the exception types as they are fetched to see if any are checked or not.  The caller only cares for a boolean response, correct?", "url": "https://github.com/eclipse-openj9/openj9/pull/10274#discussion_r469018169", "createdAt": "2020-08-12T05:45:53Z", "author": {"login": "DanHeidinga"}, "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodHandles.java", "diffHunk": "@@ -5599,6 +5600,66 @@ static MethodHandle collectReturnValue(MethodHandle target, MethodHandle filter)\n \t\t}\n \t\treturn buildTransformHandle(new CollectReturnHelper(target, filter), resultType);\n \t}\n+\t\n+\t/**\n+\t * Return an array of checked exceptions for a MethodHandle.\n+\t * \n+\t * @param mh A MethodHandle to scan for checked exceptions.\n+\t * \n+\t * @return an array of checked exception classes if any or null.\n+\t * \n+\t * @throws InternalError for an error.\n+\t */\n+\tstatic Class<?>[] checkedExceptions(MethodHandle mh) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "981e4d98777631a5ed1a97e70d0cb70a7bbc33e3"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTAxODQxMg==", "bodyText": "Also, I think this method should be renamed as currently implemented, it's about exceptions in general, not just checked ones.", "url": "https://github.com/eclipse-openj9/openj9/pull/10274#discussion_r469018412", "createdAt": "2020-08-12T05:46:44Z", "author": {"login": "DanHeidinga"}, "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodHandles.java", "diffHunk": "@@ -5599,6 +5600,66 @@ static MethodHandle collectReturnValue(MethodHandle target, MethodHandle filter)\n \t\t}\n \t\treturn buildTransformHandle(new CollectReturnHelper(target, filter), resultType);\n \t}\n+\t\n+\t/**\n+\t * Return an array of checked exceptions for a MethodHandle.\n+\t * \n+\t * @param mh A MethodHandle to scan for checked exceptions.\n+\t * \n+\t * @return an array of checked exception classes if any or null.\n+\t * \n+\t * @throws InternalError for an error.\n+\t */\n+\tstatic Class<?>[] checkedExceptions(MethodHandle mh) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "981e4d98777631a5ed1a97e70d0cb70a7bbc33e3"}, "originalPosition": 22}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "981e4d98777631a5ed1a97e70d0cb70a7bbc33e3", "author": {"user": {"login": "babsingh", "name": "Babneet Singh"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/981e4d98777631a5ed1a97e70d0cb70a7bbc33e3", "committedDate": "2020-08-10T22:45:52Z", "message": "[JEP383] Scan for checked exceptions in OpenJ9 MethodHandles\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>"}, "afterCommit": {"oid": "e43950c7c96cb2fbb47c4fc39ae2e641472638f8", "author": {"user": {"login": "babsingh", "name": "Babneet Singh"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/e43950c7c96cb2fbb47c4fc39ae2e641472638f8", "committedDate": "2020-08-12T19:33:57Z", "message": "[JEP383] Scan for checked exceptions in OpenJ9 MethodHandles\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2ODEyNjQ5", "url": "https://github.com/eclipse-openj9/openj9/pull/10274#pullrequestreview-466812649", "createdAt": "2020-08-13T14:23:55Z", "commit": {"oid": "e43950c7c96cb2fbb47c4fc39ae2e641472638f8"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxNDoyMzo1NlrOHAN8kg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxNDoyNDowNlrOHAN9Dg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk5MDU0Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tstatic MethodHandle permuateHandleJ9ToReference(MethodHandle methodHandle) {\n          \n          \n            \n            \tstatic MethodHandle permuteHandleJ9ToReference(MethodHandle methodHandle) {", "url": "https://github.com/eclipse-openj9/openj9/pull/10274#discussion_r469990546", "createdAt": "2020-08-13T14:23:56Z", "author": {"login": "DanHeidinga"}, "path": "jcl/src/java.base/share/classes/java/lang/invoke/VarHandle.java", "diffHunk": "@@ -489,7 +505,7 @@ MethodType accessModeType(Class<?> receiver, Class<?> type, Class<?>... args) {\n \t * @param methodHandle to be permuted.\n \t * @return the adapter MethodHandle which performs the translation.\n \t */\n-\tstatic MethodHandle permuateHandleJEP370(MethodHandle methodHandle) {\n+\tstatic MethodHandle permuateHandleJ9ToReference(MethodHandle methodHandle) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e43950c7c96cb2fbb47c4fc39ae2e641472638f8"}, "originalPosition": 167}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk5MDY3MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tstatic MethodHandle permuateHandleReferenceToJ9(MethodHandle methodHandle) {\n          \n          \n            \n            \tstatic MethodHandle permuteHandleReferenceToJ9(MethodHandle methodHandle) {", "url": "https://github.com/eclipse-openj9/openj9/pull/10274#discussion_r469990670", "createdAt": "2020-08-13T14:24:06Z", "author": {"login": "DanHeidinga"}, "path": "jcl/src/java.base/share/classes/java/lang/invoke/VarHandle.java", "diffHunk": "@@ -515,6 +530,87 @@ static MethodHandle permuateHandleJEP370(MethodHandle methodHandle) {\n \t}\n /*[ENDIF] Java14 */\n \n+/*[IF Java15]*/\n+\t/**\n+\t * Generate a MethodHandle which translates:\n+\t *     FROM {VarHandle, Receiver, Intermediate ..., Value}ReturnType\n+\t *     TO   {Receiver, Intermediate ..., Value, VarHandle}ReturnType\n+\t *\n+\t * @param methodHandle to be permuted.\n+\t * @return the adapter MethodHandle which performs the translation.\n+\t */\n+\tstatic MethodHandle permuateHandleReferenceToJ9(MethodHandle methodHandle) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e43950c7c96cb2fbb47c4fc39ae2e641472638f8"}, "originalPosition": 198}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e99e1296209e44d7ea90dea176cc34836bab5e41", "author": {"user": {"login": "babsingh", "name": "Babneet Singh"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/e99e1296209e44d7ea90dea176cc34836bab5e41", "committedDate": "2020-08-13T16:33:18Z", "message": "[JEP383] Add support for IndirectVarHandle\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "71b3455ea8e331d335188ed5a6873419881002a8", "author": {"user": {"login": "babsingh", "name": "Babneet Singh"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/71b3455ea8e331d335188ed5a6873419881002a8", "committedDate": "2020-08-13T16:41:02Z", "message": "[JEP383] Scan for checked exceptions in OpenJ9 MethodHandles\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e43950c7c96cb2fbb47c4fc39ae2e641472638f8", "author": {"user": {"login": "babsingh", "name": "Babneet Singh"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/e43950c7c96cb2fbb47c4fc39ae2e641472638f8", "committedDate": "2020-08-12T19:33:57Z", "message": "[JEP383] Scan for checked exceptions in OpenJ9 MethodHandles\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>"}, "afterCommit": {"oid": "71b3455ea8e331d335188ed5a6873419881002a8", "author": {"user": {"login": "babsingh", "name": "Babneet Singh"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/71b3455ea8e331d335188ed5a6873419881002a8", "committedDate": "2020-08-13T16:41:02Z", "message": "[JEP383] Scan for checked exceptions in OpenJ9 MethodHandles\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 376, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}