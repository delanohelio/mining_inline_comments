{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg0NDk5MDA4", "number": 8761, "title": "Correct numberOfAnnotations in Runtime*Annotations", "bodyText": "Port to v0.20.0: #8873\nCurrently it is assumed that the length of a RuntimeVisibleAnnotation or RuntimeVisibleTypeAnnotation will be at least 2. This may not be the case for a malformed annotation. Deal with the cases where the length is 0 or 1 and ensure that the error is properly handled.\nSigned-off-by: Theresa Mammarella Theresa.T.Mammarella@ibm.com", "createdAt": "2020-03-05T21:02:47Z", "url": "https://github.com/eclipse-openj9/openj9/pull/8761", "merged": true, "mergeCommit": {"oid": "b542db86f655d22d1697c64d071bd483c3da3695"}, "closed": true, "closedAt": "2020-03-16T19:36:52Z", "author": {"login": "theresa-m"}, "timelineItems": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcLGU9DABqjMxMDY4MTE0Nzc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcOOvtKAFqTM3NTI1MzEzMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "df747dbd699b4b48fbb233a3b512f2f9ef29206e", "author": {"user": {"login": "theresa-m", "name": "Theresa Mammarella"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/df747dbd699b4b48fbb233a3b512f2f9ef29206e", "committedDate": "2020-03-05T19:25:30Z", "message": "Correct numberOfAnnotations in Runtime*Annotations\n\nCurrently in cfreader erroneaus annotations are fully read, and the class file index is only reset at the end if the annotation is calculated to be malformed.\nIn the case of RuntimeVisibleAnnotations and RuntimeVisibleTypeAnnotations, num_annotations may not exist if the length of the annotation is 0. Because it is assumed to exist and not corrected until later, in this scenario an invalid value will be read from the classfile and used as numberOfAnnotations.\nThis may cause issues later on when the annotation is being read back and an incorrect number of annotations is expected to exist. The other issue is that an array for annotations will be allocated with an incorrect amount of memory.\n\nThis change deals with this scenario proactively by checking the length of the attribute to see if num_annotations exists. If it does not, numberOfAnnotations is set to be 0.\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>"}, "afterCommit": {"oid": "576be579059a29dd3bac890e25af6eb523444f13", "author": {"user": {"login": "theresa-m", "name": "Theresa Mammarella"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/576be579059a29dd3bac890e25af6eb523444f13", "committedDate": "2020-03-06T20:41:20Z", "message": "Runtime*Annotations malformat edge cases\n\nCurrently it is assumed that the length of a RuntimeVisibleAnnotation or RuntimeVisibleTypeAnnotation will be at least 2. This may not be the case for a malformatted annotation. Deal with the cases where the length is 0 or 1 and ensure that the error is properly handled.\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "576be579059a29dd3bac890e25af6eb523444f13", "author": {"user": {"login": "theresa-m", "name": "Theresa Mammarella"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/576be579059a29dd3bac890e25af6eb523444f13", "committedDate": "2020-03-06T20:41:20Z", "message": "Runtime*Annotations malformat edge cases\n\nCurrently it is assumed that the length of a RuntimeVisibleAnnotation or RuntimeVisibleTypeAnnotation will be at least 2. This may not be the case for a malformatted annotation. Deal with the cases where the length is 0 or 1 and ensure that the error is properly handled.\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>"}, "afterCommit": {"oid": "4a2b816ff465573ca986d94376219911fff67402", "author": {"user": {"login": "theresa-m", "name": "Theresa Mammarella"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/4a2b816ff465573ca986d94376219911fff67402", "committedDate": "2020-03-06T20:42:50Z", "message": "Runtime*Annotations malformed edge cases\n\nCurrently it is assumed that the length of a RuntimeVisibleAnnotation or RuntimeVisibleTypeAnnotation will be at least 2. This may not be the case for a malformed annotation. Deal with the cases where the length is 0 or 1 and ensure that the error is properly handled.\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4a2b816ff465573ca986d94376219911fff67402", "author": {"user": {"login": "theresa-m", "name": "Theresa Mammarella"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/4a2b816ff465573ca986d94376219911fff67402", "committedDate": "2020-03-06T20:42:50Z", "message": "Runtime*Annotations malformed edge cases\n\nCurrently it is assumed that the length of a RuntimeVisibleAnnotation or RuntimeVisibleTypeAnnotation will be at least 2. This may not be the case for a malformed annotation. Deal with the cases where the length is 0 or 1 and ensure that the error is properly handled.\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>"}, "afterCommit": {"oid": "40f6444ea75e2f276093071688a75db5cc76c559", "author": {"user": {"login": "theresa-m", "name": "Theresa Mammarella"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/40f6444ea75e2f276093071688a75db5cc76c559", "committedDate": "2020-03-06T21:09:26Z", "message": "Runtime*Annotations malformed edge cases\n\nCurrently it is assumed that the length of a RuntimeVisibleAnnotation or RuntimeVisibleTypeAnnotation will be at least 2. This may not be the case for a malformed annotation. Deal with the cases where the length is 0 or 1 and ensure that the error is properly handled.\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "40f6444ea75e2f276093071688a75db5cc76c559", "author": {"user": {"login": "theresa-m", "name": "Theresa Mammarella"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/40f6444ea75e2f276093071688a75db5cc76c559", "committedDate": "2020-03-06T21:09:26Z", "message": "Runtime*Annotations malformed edge cases\n\nCurrently it is assumed that the length of a RuntimeVisibleAnnotation or RuntimeVisibleTypeAnnotation will be at least 2. This may not be the case for a malformed annotation. Deal with the cases where the length is 0 or 1 and ensure that the error is properly handled.\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>"}, "afterCommit": {"oid": "36f52759cc5d2ccf9343e8eb9ea171f67fd0ee2a", "author": {"user": {"login": "theresa-m", "name": "Theresa Mammarella"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/36f52759cc5d2ccf9343e8eb9ea171f67fd0ee2a", "committedDate": "2020-03-09T19:19:37Z", "message": "Runtime*Annotations malformed edge cases\n\nCurrently it is assumed that the length of a RuntimeVisibleAnnotation or RuntimeVisibleTypeAnnotation will be at least 2. This may not be the case for a malformed annotation. Deal with the cases where the length is 0 or 1 and ensure that the error is properly handled.\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcyNzE2MDE1", "url": "https://github.com/eclipse-openj9/openj9/pull/8761#pullrequestreview-372716015", "createdAt": "2020-03-11T12:33:59Z", "commit": {"oid": "36f52759cc5d2ccf9343e8eb9ea171f67fd0ee2a"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxMjozMzo1OVrOF00_FQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxMzowMTowMlrOF012rg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDkzODM4OQ==", "bodyText": "What about the case where length == 1?  The code checks for > 1 here and handles 0 == length below - what happens to length == 1?", "url": "https://github.com/eclipse-openj9/openj9/pull/8761#discussion_r390938389", "createdAt": "2020-03-11T12:33:59Z", "author": {"login": "DanHeidinga"}, "path": "runtime/bcutil/cfreader.c", "diffHunk": "@@ -418,33 +418,51 @@ readAttributes(J9CfrClassFile * classfile, J9CfrAttribute *** pAttributes, U_32\n \t\t\t}\n \n \t\t\tannotations = (J9CfrAttributeRuntimeVisibleAnnotations *)attrib;\n+\t\t\tannotations->numberOfAnnotations = 0;\n+\t\t\tannotations->annotations = NULL;\n \t\t\tannotations->rawAttributeData = NULL;\n \t\t\tannotations->rawDataLength = 0; /* 0 indicates attribute is well-formed */\n-\t\t\tCHECK_EOF(2);\n-\t\t\tNEXT_U16(annotations->numberOfAnnotations, index);\n \n-\t\t\tif (!ALLOC_ARRAY(annotations->annotations, annotations->numberOfAnnotations, J9CfrAnnotation))\n-\t\t\t{\n-\t\t\t\treturn BCT_ERR_OUT_OF_ROM;\n-\t\t\t}\n+\t\t\t/* In the case of a malformed attribute numberOfAnnotations may not exist even if the file did not end. \n+\t\t\t * Don't read a bogus numberOfAnnotations.\n+\t\t\t */\n+\t\t\tif (length > 1) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36f52759cc5d2ccf9343e8eb9ea171f67fd0ee2a"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDkzODYwOA==", "bodyText": "nitpick\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\tif (!ALLOC_ARRAY(annotations->annotations, annotations->numberOfAnnotations, J9CfrAnnotation))\n          \n          \n            \n            \t\t\t\t{\n          \n          \n            \n            \t\t\t\tif (!ALLOC_ARRAY(annotations->annotations, annotations->numberOfAnnotations, J9CfrAnnotation)) {", "url": "https://github.com/eclipse-openj9/openj9/pull/8761#discussion_r390938608", "createdAt": "2020-03-11T12:34:26Z", "author": {"login": "DanHeidinga"}, "path": "runtime/bcutil/cfreader.c", "diffHunk": "@@ -418,33 +418,51 @@ readAttributes(J9CfrClassFile * classfile, J9CfrAttribute *** pAttributes, U_32\n \t\t\t}\n \n \t\t\tannotations = (J9CfrAttributeRuntimeVisibleAnnotations *)attrib;\n+\t\t\tannotations->numberOfAnnotations = 0;\n+\t\t\tannotations->annotations = NULL;\n \t\t\tannotations->rawAttributeData = NULL;\n \t\t\tannotations->rawDataLength = 0; /* 0 indicates attribute is well-formed */\n-\t\t\tCHECK_EOF(2);\n-\t\t\tNEXT_U16(annotations->numberOfAnnotations, index);\n \n-\t\t\tif (!ALLOC_ARRAY(annotations->annotations, annotations->numberOfAnnotations, J9CfrAnnotation))\n-\t\t\t{\n-\t\t\t\treturn BCT_ERR_OUT_OF_ROM;\n-\t\t\t}\n+\t\t\t/* In the case of a malformed attribute numberOfAnnotations may not exist even if the file did not end. \n+\t\t\t * Don't read a bogus numberOfAnnotations.\n+\t\t\t */\n+\t\t\tif (length > 1) {\n+\t\t\t\tCHECK_EOF(2);\n+\t\t\t\tNEXT_U16(annotations->numberOfAnnotations, index);\n \n-\t\t\tresult = readAnnotations(classfile, annotations->annotations, annotations->numberOfAnnotations, data, dataEnd, segment, segmentEnd, &index, &freePointer, flags);\n+\t\t\t\tif (!ALLOC_ARRAY(annotations->annotations, annotations->numberOfAnnotations, J9CfrAnnotation))\n+\t\t\t\t{", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36f52759cc5d2ccf9343e8eb9ea171f67fd0ee2a"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDk0NzA3Mw==", "bodyText": "the lengths of 4 & 3 here aren't immediately obvious to me.  Is it the size of a the visible annotation + 1?", "url": "https://github.com/eclipse-openj9/openj9/pull/8761#discussion_r390947073", "createdAt": "2020-03-11T12:50:36Z", "author": {"login": "DanHeidinga"}, "path": "runtime/bcutil/cfreader.c", "diffHunk": "@@ -655,24 +681,55 @@ readAttributes(J9CfrClassFile * classfile, J9CfrAttribute *** pAttributes, U_32\n \t\t\t\t * to indicate that the attribute is malformed.\n \t\t\t\t */\n \t\t\t\tTrc_BCU_MalformedTypeAnnotation(address);\n-\t\t\t\tif (!ALLOC_ARRAY(annotations->rawAttributeData, length + 1, U_8)) {\n+\n+\t\t\t\t/* calculate the length needed to insert the illegal type_annotation.\n+\t\t\t\t * The minimum number of bytes needed is three for\n+\t\t\t\t * num_annotations and target_type\n+\t\t\t\t */\n+\t\t\t\tif (1 == length) {\n+\t\t\t\t\t/* Treat one byte as part of the type_annotation to reach the correct index. */\n+\t\t\t\t\tannotations->rawDataLength = 4;\n+\t\t\t\t} else if (length < 3) {\n+\t\t\t\t\tannotations->rawDataLength = 3;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36f52759cc5d2ccf9343e8eb9ea171f67fd0ee2a"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDk1MjI2Ng==", "bodyText": "It might be clearer to have a minimum number of byes required and take the max(min_required_bytes, length + 1)", "url": "https://github.com/eclipse-openj9/openj9/pull/8761#discussion_r390952266", "createdAt": "2020-03-11T13:00:24Z", "author": {"login": "DanHeidinga"}, "path": "runtime/bcutil/cfreader.c", "diffHunk": "@@ -655,24 +681,55 @@ readAttributes(J9CfrClassFile * classfile, J9CfrAttribute *** pAttributes, U_32\n \t\t\t\t * to indicate that the attribute is malformed.\n \t\t\t\t */\n \t\t\t\tTrc_BCU_MalformedTypeAnnotation(address);\n-\t\t\t\tif (!ALLOC_ARRAY(annotations->rawAttributeData, length + 1, U_8)) {\n+\n+\t\t\t\t/* calculate the length needed to insert the illegal type_annotation.\n+\t\t\t\t * The minimum number of bytes needed is three for\n+\t\t\t\t * num_annotations and target_type\n+\t\t\t\t */\n+\t\t\t\tif (1 == length) {\n+\t\t\t\t\t/* Treat one byte as part of the type_annotation to reach the correct index. */\n+\t\t\t\t\tannotations->rawDataLength = 4;\n+\t\t\t\t} else if (length < 3) {\n+\t\t\t\t\tannotations->rawDataLength = 3;\n+\t\t\t\t} else {\n+\t\t\t\t\t/* Extra slot for illegal target_type */\n+\t\t\t\t\tannotations->rawDataLength = length + 1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36f52759cc5d2ccf9343e8eb9ea171f67fd0ee2a"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDk1MjYyMg==", "bodyText": "Why = 1 here?", "url": "https://github.com/eclipse-openj9/openj9/pull/8761#discussion_r390952622", "createdAt": "2020-03-11T13:01:02Z", "author": {"login": "DanHeidinga"}, "path": "runtime/bcutil/cfreader.c", "diffHunk": "@@ -655,24 +681,55 @@ readAttributes(J9CfrClassFile * classfile, J9CfrAttribute *** pAttributes, U_32\n \t\t\t\t * to indicate that the attribute is malformed.\n \t\t\t\t */\n \t\t\t\tTrc_BCU_MalformedTypeAnnotation(address);\n-\t\t\t\tif (!ALLOC_ARRAY(annotations->rawAttributeData, length + 1, U_8)) {\n+\n+\t\t\t\t/* calculate the length needed to insert the illegal type_annotation.\n+\t\t\t\t * The minimum number of bytes needed is three for\n+\t\t\t\t * num_annotations and target_type\n+\t\t\t\t */\n+\t\t\t\tif (1 == length) {\n+\t\t\t\t\t/* Treat one byte as part of the type_annotation to reach the correct index. */\n+\t\t\t\t\tannotations->rawDataLength = 4;\n+\t\t\t\t} else if (length < 3) {\n+\t\t\t\t\tannotations->rawDataLength = 3;\n+\t\t\t\t} else {\n+\t\t\t\t\t/* Extra slot for illegal target_type */\n+\t\t\t\t\tannotations->rawDataLength = length + 1;\n+\t\t\t\t}\n+\n+\t\t\t\tif (!ALLOC_ARRAY(annotations->rawAttributeData, annotations->rawDataLength, U_8)) {\n \t\t\t\t\treturn -2;\n \t\t\t\t}\n \t\t\t\tindex = attributeStart; /* rewind to the start of the attribute */\n-\t\t\t\tNEXT_U16(annotations->rawAttributeData[0], index); /* put in the num_annotations */\n-\t\t\t\tNEXT_U8(annotations->rawAttributeData[2], index);\n-\t\t\t\tif (CFR_TARGET_TYPE_ErrorInAttribute != annotations->rawAttributeData[2]) {\n-\t\t\t\t\t/* insert an error marker */\n-\t\t\t\t\tannotations->rawAttributeData[3] = annotations->rawAttributeData[2];\n-\t\t\t\t\tannotations->rawAttributeData[2] = CFR_TARGET_TYPE_ErrorInAttribute;\n-\t\t\t\t\tannotations->rawDataLength = length + 1;\n-\t\t\t\t} else { /* the attribute is already marked bad */\n-\t\t\t\t\tNEXT_U8(annotations->rawAttributeData[3], index);\n-\t\t\t\t\tannotations->rawDataLength = length;\n+\n+\t\t\t\t/* read num_annotations or set dummy if these bytes do not exist. */\n+\t\t\t\tif (length >= 2) {\n+\t\t\t\t\tNEXT_U16(annotations->rawAttributeData[0], index);\n+\t\t\t\t} else {\n+\t\t\t\t\tannotations->rawAttributeData[0] = 0;\n+\t\t\t\t\tannotations->rawAttributeData[1] = 1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36f52759cc5d2ccf9343e8eb9ea171f67fd0ee2a"}, "originalPosition": 162}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc0MzY5MDE4", "url": "https://github.com/eclipse-openj9/openj9/pull/8761#pullrequestreview-374369018", "createdAt": "2020-03-13T14:58:50Z", "commit": {"oid": "f6d3c25f5bc44314c577ebba23e70389f07c7c4e"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxNDo1ODo1MFrOF2G6rg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxNTowMzowMFrOF2HEyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI4MDc1MA==", "bodyText": "Is this special case needed?  rawDataLength will be max(3, length+1).\nIf length is 1, then rawDataLength would be 3.  Does the minimumRawDataBytes need to be 4 to cover the +1 here?", "url": "https://github.com/eclipse-openj9/openj9/pull/8761#discussion_r392280750", "createdAt": "2020-03-13T14:58:50Z", "author": {"login": "DanHeidinga"}, "path": "runtime/bcutil/cfreader.c", "diffHunk": "@@ -623,56 +642,102 @@ readAttributes(J9CfrClassFile * classfile, J9CfrAttribute *** pAttributes, U_32\n \t\t\t\treturn -2;\n \t\t\t}\n \t\t\tannotations = (J9CfrAttributeRuntimeVisibleTypeAnnotations *)attrib;\n+\t\t\tannotations->numberOfAnnotations = 0;\n+\t\t\tannotations->typeAnnotations = NULL;\n \t\t\tannotations->rawAttributeData = NULL;\n \t\t\tannotations->rawDataLength = 0; /* 0 indicates attribute is well-formed */\n-\t\t\tCHECK_EOF(2);\n-\t\t\tNEXT_U16(annotations->numberOfAnnotations, index);\n-\t\t\tif (!ALLOC_ARRAY(annotations->typeAnnotations, annotations->numberOfAnnotations, J9CfrTypeAnnotation))\n-\t\t\t{\n-\t\t\t\treturn -2;\n-\t\t\t}\n-\t\t\ttypeAnnotations = annotations->typeAnnotations;\n-\t\t\t/*\n-\t\t\t * we are now at the start of the first type_annotation\n-\t\t\t * Silently ignore errors.\n+\n+\t\t\t/* In the case of a malformed attribute numberOfAnnotations may not exist even if the file did not end. \n+\t\t\t * There must be at least two bytes to have a valid numberOfAnnotations.\n+\t\t\t * Length of 0 will be treated as an error below. Length of 1 will be an error as well since the index\n+\t\t\t * will not match the end value.\n \t\t\t */\n-\t\t\tfor (j = 0; j < annotations->numberOfAnnotations; j++, typeAnnotations++) {\n-\t\t\t\tresult = readTypeAnnotation(classfile, typeAnnotations, data, dataEnd, segment, segmentEnd, &index, &freePointer, flags);\n-\t\t\t\tif (BCT_ERR_NO_ERROR != result) {\n-\t\t\t\t\tbreak;\n+\t\t\tif (length > 1) {\n+\t\t\t\tCHECK_EOF(2);\n+\t\t\t\tNEXT_U16(annotations->numberOfAnnotations, index);\n+\n+\t\t\t\tif (!ALLOC_ARRAY(annotations->typeAnnotations, annotations->numberOfAnnotations, J9CfrTypeAnnotation)) {\n+\t\t\t\t\treturn -2;\n+\t\t\t\t}\n+\t\t\t\ttypeAnnotations = annotations->typeAnnotations;\n+\t\t\t\t/*\n+\t\t\t\t* we are now at the start of the first type_annotation\n+\t\t\t\t* Silently ignore errors.\n+\t\t\t\t*/\n+\t\t\t\tfor (j = 0; j < annotations->numberOfAnnotations; j++, typeAnnotations++) {\n+\t\t\t\t\tresult = readTypeAnnotation(classfile, typeAnnotations, data, dataEnd, segment, segmentEnd, &index, &freePointer, flags);\n+\t\t\t\t\tif (BCT_ERR_NO_ERROR != result) {\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (BCT_ERR_OUT_OF_ROM == result) {\n \t\t\t\t/* Return out of memory error code to allocate larger buffer for classfile */\n \t\t\t\treturn result;\n-\t\t\t} else if ((BCT_ERR_NO_ERROR != result) || (index != end)) {\n-\t\t\t\tU_32 cursor = 0;\n+\t\t\t} else if ((BCT_ERR_NO_ERROR != result) || (0 == length) || (index != end)) {\n \t\t\t\t/*\n \t\t\t\t * give up parsing.\n \t\t\t\t * Copy the raw data, insert a bogus type_annotation,\n \t\t\t\t * i.e. an illegal target_type byte immediately after the num_annotations field,\n \t\t\t\t * to indicate that the attribute is malformed.\n \t\t\t\t */\n+\t\t\t\tU_32 cursor = 0;\n+\n+\t\t\t\t/* The minimum number of raw data bytes needed to create a bogus type_annotation is:\n+\t\t\t\t * num_annotations (2 bytes)\n+\t\t\t\t * target_type (1 byte)\n+\t\t\t\t */\n+\t\t\t\tconst U_32 minimumRawDataBytes = 3;\n+\n \t\t\t\tTrc_BCU_MalformedTypeAnnotation(address);\n-\t\t\t\tif (!ALLOC_ARRAY(annotations->rawAttributeData, length + 1, U_8)) {\n+\n+\t\t\t\t/* use at least the minimum number of bytes, or add an extra slot for the illegal target_type */\n+\t\t\t\tannotations->rawDataLength = OMR_MAX(minimumRawDataBytes, length + 1);\n+\n+\t\t\t\t/* special case for length = 1. To ensure index is incremented correctly, \n+\t\t\t\t * add this extra byte to the end of the raw data array. */\n+\t\t\t\tif (1 == length) {\n+\t\t\t\t\tannotations->rawDataLength++;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f6d3c25f5bc44314c577ebba23e70389f07c7c4e"}, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI4MjQwMA==", "bodyText": "Reading the code below that writes to annotations->rawAttributeData[3] = 0;, min length here needs to be 4, not 3", "url": "https://github.com/eclipse-openj9/openj9/pull/8761#discussion_r392282400", "createdAt": "2020-03-13T15:01:34Z", "author": {"login": "DanHeidinga"}, "path": "runtime/bcutil/cfreader.c", "diffHunk": "@@ -623,56 +642,102 @@ readAttributes(J9CfrClassFile * classfile, J9CfrAttribute *** pAttributes, U_32\n \t\t\t\treturn -2;\n \t\t\t}\n \t\t\tannotations = (J9CfrAttributeRuntimeVisibleTypeAnnotations *)attrib;\n+\t\t\tannotations->numberOfAnnotations = 0;\n+\t\t\tannotations->typeAnnotations = NULL;\n \t\t\tannotations->rawAttributeData = NULL;\n \t\t\tannotations->rawDataLength = 0; /* 0 indicates attribute is well-formed */\n-\t\t\tCHECK_EOF(2);\n-\t\t\tNEXT_U16(annotations->numberOfAnnotations, index);\n-\t\t\tif (!ALLOC_ARRAY(annotations->typeAnnotations, annotations->numberOfAnnotations, J9CfrTypeAnnotation))\n-\t\t\t{\n-\t\t\t\treturn -2;\n-\t\t\t}\n-\t\t\ttypeAnnotations = annotations->typeAnnotations;\n-\t\t\t/*\n-\t\t\t * we are now at the start of the first type_annotation\n-\t\t\t * Silently ignore errors.\n+\n+\t\t\t/* In the case of a malformed attribute numberOfAnnotations may not exist even if the file did not end. \n+\t\t\t * There must be at least two bytes to have a valid numberOfAnnotations.\n+\t\t\t * Length of 0 will be treated as an error below. Length of 1 will be an error as well since the index\n+\t\t\t * will not match the end value.\n \t\t\t */\n-\t\t\tfor (j = 0; j < annotations->numberOfAnnotations; j++, typeAnnotations++) {\n-\t\t\t\tresult = readTypeAnnotation(classfile, typeAnnotations, data, dataEnd, segment, segmentEnd, &index, &freePointer, flags);\n-\t\t\t\tif (BCT_ERR_NO_ERROR != result) {\n-\t\t\t\t\tbreak;\n+\t\t\tif (length > 1) {\n+\t\t\t\tCHECK_EOF(2);\n+\t\t\t\tNEXT_U16(annotations->numberOfAnnotations, index);\n+\n+\t\t\t\tif (!ALLOC_ARRAY(annotations->typeAnnotations, annotations->numberOfAnnotations, J9CfrTypeAnnotation)) {\n+\t\t\t\t\treturn -2;\n+\t\t\t\t}\n+\t\t\t\ttypeAnnotations = annotations->typeAnnotations;\n+\t\t\t\t/*\n+\t\t\t\t* we are now at the start of the first type_annotation\n+\t\t\t\t* Silently ignore errors.\n+\t\t\t\t*/\n+\t\t\t\tfor (j = 0; j < annotations->numberOfAnnotations; j++, typeAnnotations++) {\n+\t\t\t\t\tresult = readTypeAnnotation(classfile, typeAnnotations, data, dataEnd, segment, segmentEnd, &index, &freePointer, flags);\n+\t\t\t\t\tif (BCT_ERR_NO_ERROR != result) {\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (BCT_ERR_OUT_OF_ROM == result) {\n \t\t\t\t/* Return out of memory error code to allocate larger buffer for classfile */\n \t\t\t\treturn result;\n-\t\t\t} else if ((BCT_ERR_NO_ERROR != result) || (index != end)) {\n-\t\t\t\tU_32 cursor = 0;\n+\t\t\t} else if ((BCT_ERR_NO_ERROR != result) || (0 == length) || (index != end)) {\n \t\t\t\t/*\n \t\t\t\t * give up parsing.\n \t\t\t\t * Copy the raw data, insert a bogus type_annotation,\n \t\t\t\t * i.e. an illegal target_type byte immediately after the num_annotations field,\n \t\t\t\t * to indicate that the attribute is malformed.\n \t\t\t\t */\n+\t\t\t\tU_32 cursor = 0;\n+\n+\t\t\t\t/* The minimum number of raw data bytes needed to create a bogus type_annotation is:\n+\t\t\t\t * num_annotations (2 bytes)\n+\t\t\t\t * target_type (1 byte)\n+\t\t\t\t */\n+\t\t\t\tconst U_32 minimumRawDataBytes = 3;\n+\n \t\t\t\tTrc_BCU_MalformedTypeAnnotation(address);\n-\t\t\t\tif (!ALLOC_ARRAY(annotations->rawAttributeData, length + 1, U_8)) {\n+\n+\t\t\t\t/* use at least the minimum number of bytes, or add an extra slot for the illegal target_type */\n+\t\t\t\tannotations->rawDataLength = OMR_MAX(minimumRawDataBytes, length + 1);\n+\n+\t\t\t\t/* special case for length = 1. To ensure index is incremented correctly, \n+\t\t\t\t * add this extra byte to the end of the raw data array. */\n+\t\t\t\tif (1 == length) {\n+\t\t\t\t\tannotations->rawDataLength++;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI4MDc1MA=="}, "originalCommit": {"oid": "f6d3c25f5bc44314c577ebba23e70389f07c7c4e"}, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI4MzMzNw==", "bodyText": "This is the case I'm most unsure of.  Maybe an example would help here? Or an assert that rawDataLength > 4, assuming that's the right condition", "url": "https://github.com/eclipse-openj9/openj9/pull/8761#discussion_r392283337", "createdAt": "2020-03-13T15:03:00Z", "author": {"login": "DanHeidinga"}, "path": "runtime/bcutil/cfreader.c", "diffHunk": "@@ -623,56 +642,102 @@ readAttributes(J9CfrClassFile * classfile, J9CfrAttribute *** pAttributes, U_32\n \t\t\t\treturn -2;\n \t\t\t}\n \t\t\tannotations = (J9CfrAttributeRuntimeVisibleTypeAnnotations *)attrib;\n+\t\t\tannotations->numberOfAnnotations = 0;\n+\t\t\tannotations->typeAnnotations = NULL;\n \t\t\tannotations->rawAttributeData = NULL;\n \t\t\tannotations->rawDataLength = 0; /* 0 indicates attribute is well-formed */\n-\t\t\tCHECK_EOF(2);\n-\t\t\tNEXT_U16(annotations->numberOfAnnotations, index);\n-\t\t\tif (!ALLOC_ARRAY(annotations->typeAnnotations, annotations->numberOfAnnotations, J9CfrTypeAnnotation))\n-\t\t\t{\n-\t\t\t\treturn -2;\n-\t\t\t}\n-\t\t\ttypeAnnotations = annotations->typeAnnotations;\n-\t\t\t/*\n-\t\t\t * we are now at the start of the first type_annotation\n-\t\t\t * Silently ignore errors.\n+\n+\t\t\t/* In the case of a malformed attribute numberOfAnnotations may not exist even if the file did not end. \n+\t\t\t * There must be at least two bytes to have a valid numberOfAnnotations.\n+\t\t\t * Length of 0 will be treated as an error below. Length of 1 will be an error as well since the index\n+\t\t\t * will not match the end value.\n \t\t\t */\n-\t\t\tfor (j = 0; j < annotations->numberOfAnnotations; j++, typeAnnotations++) {\n-\t\t\t\tresult = readTypeAnnotation(classfile, typeAnnotations, data, dataEnd, segment, segmentEnd, &index, &freePointer, flags);\n-\t\t\t\tif (BCT_ERR_NO_ERROR != result) {\n-\t\t\t\t\tbreak;\n+\t\t\tif (length > 1) {\n+\t\t\t\tCHECK_EOF(2);\n+\t\t\t\tNEXT_U16(annotations->numberOfAnnotations, index);\n+\n+\t\t\t\tif (!ALLOC_ARRAY(annotations->typeAnnotations, annotations->numberOfAnnotations, J9CfrTypeAnnotation)) {\n+\t\t\t\t\treturn -2;\n+\t\t\t\t}\n+\t\t\t\ttypeAnnotations = annotations->typeAnnotations;\n+\t\t\t\t/*\n+\t\t\t\t* we are now at the start of the first type_annotation\n+\t\t\t\t* Silently ignore errors.\n+\t\t\t\t*/\n+\t\t\t\tfor (j = 0; j < annotations->numberOfAnnotations; j++, typeAnnotations++) {\n+\t\t\t\t\tresult = readTypeAnnotation(classfile, typeAnnotations, data, dataEnd, segment, segmentEnd, &index, &freePointer, flags);\n+\t\t\t\t\tif (BCT_ERR_NO_ERROR != result) {\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (BCT_ERR_OUT_OF_ROM == result) {\n \t\t\t\t/* Return out of memory error code to allocate larger buffer for classfile */\n \t\t\t\treturn result;\n-\t\t\t} else if ((BCT_ERR_NO_ERROR != result) || (index != end)) {\n-\t\t\t\tU_32 cursor = 0;\n+\t\t\t} else if ((BCT_ERR_NO_ERROR != result) || (0 == length) || (index != end)) {\n \t\t\t\t/*\n \t\t\t\t * give up parsing.\n \t\t\t\t * Copy the raw data, insert a bogus type_annotation,\n \t\t\t\t * i.e. an illegal target_type byte immediately after the num_annotations field,\n \t\t\t\t * to indicate that the attribute is malformed.\n \t\t\t\t */\n+\t\t\t\tU_32 cursor = 0;\n+\n+\t\t\t\t/* The minimum number of raw data bytes needed to create a bogus type_annotation is:\n+\t\t\t\t * num_annotations (2 bytes)\n+\t\t\t\t * target_type (1 byte)\n+\t\t\t\t */\n+\t\t\t\tconst U_32 minimumRawDataBytes = 3;\n+\n \t\t\t\tTrc_BCU_MalformedTypeAnnotation(address);\n-\t\t\t\tif (!ALLOC_ARRAY(annotations->rawAttributeData, length + 1, U_8)) {\n+\n+\t\t\t\t/* use at least the minimum number of bytes, or add an extra slot for the illegal target_type */\n+\t\t\t\tannotations->rawDataLength = OMR_MAX(minimumRawDataBytes, length + 1);\n+\n+\t\t\t\t/* special case for length = 1. To ensure index is incremented correctly, \n+\t\t\t\t * add this extra byte to the end of the raw data array. */\n+\t\t\t\tif (1 == length) {\n+\t\t\t\t\tannotations->rawDataLength++;\n+\t\t\t\t}\n+\n+\t\t\t\t/* create raw data array. */\n+\t\t\t\tif (!ALLOC_ARRAY(annotations->rawAttributeData, annotations->rawDataLength, U_8)) {\n \t\t\t\t\treturn -2;\n \t\t\t\t}\n \t\t\t\tindex = attributeStart; /* rewind to the start of the attribute */\n-\t\t\t\tNEXT_U16(annotations->rawAttributeData[0], index); /* put in the num_annotations */\n-\t\t\t\tNEXT_U8(annotations->rawAttributeData[2], index);\n-\t\t\t\tif (CFR_TARGET_TYPE_ErrorInAttribute != annotations->rawAttributeData[2]) {\n-\t\t\t\t\t/* insert an error marker */\n-\t\t\t\t\tannotations->rawAttributeData[3] = annotations->rawAttributeData[2];\n-\t\t\t\t\tannotations->rawAttributeData[2] = CFR_TARGET_TYPE_ErrorInAttribute;\n-\t\t\t\t\tannotations->rawDataLength = length + 1;\n-\t\t\t\t} else { /* the attribute is already marked bad */\n-\t\t\t\t\tNEXT_U8(annotations->rawAttributeData[3], index);\n-\t\t\t\t\tannotations->rawDataLength = length;\n+\n+\t\t\t\t/* read num_annotations or set dummy if these bytes do not exist. */\n+\t\t\t\tif (length >= 2) {\n+\t\t\t\t\tNEXT_U16(annotations->rawAttributeData[0], index);\n+\t\t\t\t} else {\n+\t\t\t\t\t/* there should be at least one type_annotation here for the illegal \n+\t\t\t\t\t * entry that is being created. */\n+\t\t\t\t\tannotations->rawAttributeData[0] = 0;\n+\t\t\t\t\tannotations->rawAttributeData[1] = 1;\n \t\t\t\t}\n-\t\t\t\tfor (cursor = 4; cursor < annotations->rawDataLength; ++cursor) {\n-\t\t\t\t\tCHECK_EOF(1);\n-\t\t\t\t\tNEXT_U8(annotations->rawAttributeData[cursor], index);\n+\n+\t\t\t\t/* set illegal target_type followed by raw data */\n+\t\t\t\tif (minimumRawDataBytes == annotations->rawDataLength) { /* final slot is reserved for illegal target_type */\n+\t\t\t\t\tannotations->rawAttributeData[2] = CFR_TARGET_TYPE_ErrorInAttribute;\n+\t\t\t\t} else {\n+\t\t\t\t\tNEXT_U8(annotations->rawAttributeData[2], index);\n+\n+\t\t\t\t\tif (CFR_TARGET_TYPE_ErrorInAttribute != annotations->rawAttributeData[2]) {\n+\t\t\t\t\t\t/* insert an error marker */\n+\t\t\t\t\t\tannotations->rawAttributeData[3] = annotations->rawAttributeData[2];\n+\t\t\t\t\t\tannotations->rawAttributeData[2] = CFR_TARGET_TYPE_ErrorInAttribute;\n+\t\t\t\t\t} else { /* the attribute is already marked bad */\n+\t\t\t\t\t\tannotations->rawAttributeData[3] = 0;\n+\t\t\t\t\t\tif (index != end) {\n+\t\t\t\t\t\t\tNEXT_U8(annotations->rawAttributeData[3], index);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tannotations->rawDataLength = length - 1; /* won't be using the extra slot */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f6d3c25f5bc44314c577ebba23e70389f07c7c4e"}, "originalPosition": 193}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f6d3c25f5bc44314c577ebba23e70389f07c7c4e", "author": {"user": {"login": "theresa-m", "name": "Theresa Mammarella"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/f6d3c25f5bc44314c577ebba23e70389f07c7c4e", "committedDate": "2020-03-11T18:17:05Z", "message": "Additional comments and clean up\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>"}, "afterCommit": {"oid": "0f972102e1b6b8328662691d099d9b85bf4adf3e", "author": {"user": {"login": "theresa-m", "name": "Theresa Mammarella"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/0f972102e1b6b8328662691d099d9b85bf4adf3e", "committedDate": "2020-03-13T21:21:23Z", "message": "Additional comments and clean up\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc1MTcxNjM2", "url": "https://github.com/eclipse-openj9/openj9/pull/8761#pullrequestreview-375171636", "createdAt": "2020-03-16T12:33:06Z", "commit": {"oid": "0f972102e1b6b8328662691d099d9b85bf4adf3e"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxMjozMzowNlrOF2x_OQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxMjozNDo1NFrOF2yFLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjk4NjQyNQ==", "bodyText": "We've tried to use -- and ++ less in the code base outside of for /  while loops\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t\tannotations->rawDataLength--;\n          \n          \n            \n            \t\t\t\t\tannotations->rawDataLength -= 1;", "url": "https://github.com/eclipse-openj9/openj9/pull/8761#discussion_r392986425", "createdAt": "2020-03-16T12:33:06Z", "author": {"login": "DanHeidinga"}, "path": "runtime/bcutil/cfreader.c", "diffHunk": "@@ -623,56 +642,106 @@ readAttributes(J9CfrClassFile * classfile, J9CfrAttribute *** pAttributes, U_32\n \t\t\t\treturn -2;\n \t\t\t}\n \t\t\tannotations = (J9CfrAttributeRuntimeVisibleTypeAnnotations *)attrib;\n+\t\t\tannotations->numberOfAnnotations = 0;\n+\t\t\tannotations->typeAnnotations = NULL;\n \t\t\tannotations->rawAttributeData = NULL;\n \t\t\tannotations->rawDataLength = 0; /* 0 indicates attribute is well-formed */\n-\t\t\tCHECK_EOF(2);\n-\t\t\tNEXT_U16(annotations->numberOfAnnotations, index);\n-\t\t\tif (!ALLOC_ARRAY(annotations->typeAnnotations, annotations->numberOfAnnotations, J9CfrTypeAnnotation))\n-\t\t\t{\n-\t\t\t\treturn -2;\n-\t\t\t}\n-\t\t\ttypeAnnotations = annotations->typeAnnotations;\n-\t\t\t/*\n-\t\t\t * we are now at the start of the first type_annotation\n-\t\t\t * Silently ignore errors.\n+\n+\t\t\t/* In the case of a malformed attribute numberOfAnnotations may not exist even if the file did not end. \n+\t\t\t * There must be at least two bytes to have a valid numberOfAnnotations.\n+\t\t\t * Length of 0 will be treated as an error below. Length of 1 will be an error as well since the index\n+\t\t\t * will not match the end value.\n \t\t\t */\n-\t\t\tfor (j = 0; j < annotations->numberOfAnnotations; j++, typeAnnotations++) {\n-\t\t\t\tresult = readTypeAnnotation(classfile, typeAnnotations, data, dataEnd, segment, segmentEnd, &index, &freePointer, flags);\n-\t\t\t\tif (BCT_ERR_NO_ERROR != result) {\n-\t\t\t\t\tbreak;\n+\t\t\tif (length > 1) {\n+\t\t\t\tCHECK_EOF(2);\n+\t\t\t\tNEXT_U16(annotations->numberOfAnnotations, index);\n+\n+\t\t\t\tif (!ALLOC_ARRAY(annotations->typeAnnotations, annotations->numberOfAnnotations, J9CfrTypeAnnotation)) {\n+\t\t\t\t\treturn -2;\n+\t\t\t\t}\n+\t\t\t\ttypeAnnotations = annotations->typeAnnotations;\n+\t\t\t\t/*\n+\t\t\t\t* we are now at the start of the first type_annotation\n+\t\t\t\t* Silently ignore errors.\n+\t\t\t\t*/\n+\t\t\t\tfor (j = 0; j < annotations->numberOfAnnotations; j++, typeAnnotations++) {\n+\t\t\t\t\tresult = readTypeAnnotation(classfile, typeAnnotations, data, dataEnd, segment, segmentEnd, &index, &freePointer, flags);\n+\t\t\t\t\tif (BCT_ERR_NO_ERROR != result) {\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (BCT_ERR_OUT_OF_ROM == result) {\n \t\t\t\t/* Return out of memory error code to allocate larger buffer for classfile */\n \t\t\t\treturn result;\n-\t\t\t} else if ((BCT_ERR_NO_ERROR != result) || (index != end)) {\n-\t\t\t\tU_32 cursor = 0;\n+\t\t\t} else if ((BCT_ERR_NO_ERROR != result) || (0 == length) || (index != end)) {\n \t\t\t\t/*\n-\t\t\t\t * give up parsing.\n+\t\t\t\t * Give up parsing.\n+\t\t\t\t * \n \t\t\t\t * Copy the raw data, insert a bogus type_annotation,\n-\t\t\t\t * i.e. an illegal target_type byte immediately after the num_annotations field,\n-\t\t\t\t * to indicate that the attribute is malformed.\n+\t\t\t\t * i.e. an illegal target_type byte immediately after the num_annotations field\n+\t\t\t\t * to indicate that the attribute is malformed. The remaining raw data should follow\n+\t\t\t\t * the illegal target_type.\n+\t\t\t\t * \n+\t\t\t\t * The minimum number of raw data bytes needed to create a bogus type_annotation is:\n+\t\t\t\t * num_annotations (2 bytes)\n+\t\t\t\t * target_type (1 byte)\n+\t\t\t\t * extra raw data (at least 1 byte)\n+\t\t\t\t * \n+\t\t\t\t * Length will be adjusted during rawAttributeData assignment if it is determined that \n+\t\t\t\t * an extra slot is not needed.\n \t\t\t\t */\n+\t\t\t\tconst U_32 minimumRawDataBytes = 4;\n+\n \t\t\t\tTrc_BCU_MalformedTypeAnnotation(address);\n-\t\t\t\tif (!ALLOC_ARRAY(annotations->rawAttributeData, length + 1, U_8)) {\n+\n+\t\t\t\tannotations->rawDataLength = OMR_MAX(minimumRawDataBytes, length + 1);\n+\n+\t\t\t\tif (!ALLOC_ARRAY(annotations->rawAttributeData, annotations->rawDataLength, U_8)) {\n \t\t\t\t\treturn -2;\n \t\t\t\t}\n \t\t\t\tindex = attributeStart; /* rewind to the start of the attribute */\n-\t\t\t\tNEXT_U16(annotations->rawAttributeData[0], index); /* put in the num_annotations */\n-\t\t\t\tNEXT_U8(annotations->rawAttributeData[2], index);\n-\t\t\t\tif (CFR_TARGET_TYPE_ErrorInAttribute != annotations->rawAttributeData[2]) {\n-\t\t\t\t\t/* insert an error marker */\n-\t\t\t\t\tannotations->rawAttributeData[3] = annotations->rawAttributeData[2];\n-\t\t\t\t\tannotations->rawAttributeData[2] = CFR_TARGET_TYPE_ErrorInAttribute;\n-\t\t\t\t\tannotations->rawDataLength = length + 1;\n-\t\t\t\t} else { /* the attribute is already marked bad */\n-\t\t\t\t\tNEXT_U8(annotations->rawAttributeData[3], index);\n-\t\t\t\t\tannotations->rawDataLength = length;\n+\n+\t\t\t\t/* read num_annotations or set dummy if these bytes do not exist. */\n+\t\t\t\tif (length >= 2) {\n+\t\t\t\t\tNEXT_U16(annotations->rawAttributeData[0], index);\n+\t\t\t\t} else {\n+\t\t\t\t\t/* there should be at least one type_annotation here for the illegal \n+\t\t\t\t\t * entry that is being created. */\n+\t\t\t\t\tannotations->rawAttributeData[0] = 0;\n+\t\t\t\t\tannotations->rawAttributeData[1] = 1;\n \t\t\t\t}\n-\t\t\t\tfor (cursor = 4; cursor < annotations->rawDataLength; ++cursor) {\n-\t\t\t\t\tCHECK_EOF(1);\n-\t\t\t\t\tNEXT_U8(annotations->rawAttributeData[cursor], index);\n+\n+\t\t\t\t/* Insert illegal target_type followed by remaining raw data. */\n+\t\t\t\tif (index == end) {\n+\t\t\t\t\t/* There is no remaining raw data. */\n+\t\t\t\t\tannotations->rawAttributeData[2] = CFR_TARGET_TYPE_ErrorInAttribute;\n+\n+\t\t\t\t\t/* Adjust rawDataLength since there was no need to insert an extra byte. */\n+\t\t\t\t\tannotations->rawDataLength--;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f972102e1b6b8328662691d099d9b85bf4adf3e"}, "originalPosition": 183}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjk4NzcyMQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t\t} else { /* the attribute is already marked bad */\n          \n          \n            \n            \t\t\t\t\t\t/* Adjust rawDataLength since there was no need to insert an extra byte. */\n          \n          \n            \n            \t\t\t\t\t} else { \n          \n          \n            \n            \t\t\t\t\t\t/* The attribute is already marked bad.\n          \n          \n            \n            \t\t\t\t\t\t * Adjust rawDataLength since there was no need to insert an extra byte.\n          \n          \n            \n            \t\t\t\t\t\t */", "url": "https://github.com/eclipse-openj9/openj9/pull/8761#discussion_r392987721", "createdAt": "2020-03-16T12:34:38Z", "author": {"login": "DanHeidinga"}, "path": "runtime/bcutil/cfreader.c", "diffHunk": "@@ -623,56 +642,106 @@ readAttributes(J9CfrClassFile * classfile, J9CfrAttribute *** pAttributes, U_32\n \t\t\t\treturn -2;\n \t\t\t}\n \t\t\tannotations = (J9CfrAttributeRuntimeVisibleTypeAnnotations *)attrib;\n+\t\t\tannotations->numberOfAnnotations = 0;\n+\t\t\tannotations->typeAnnotations = NULL;\n \t\t\tannotations->rawAttributeData = NULL;\n \t\t\tannotations->rawDataLength = 0; /* 0 indicates attribute is well-formed */\n-\t\t\tCHECK_EOF(2);\n-\t\t\tNEXT_U16(annotations->numberOfAnnotations, index);\n-\t\t\tif (!ALLOC_ARRAY(annotations->typeAnnotations, annotations->numberOfAnnotations, J9CfrTypeAnnotation))\n-\t\t\t{\n-\t\t\t\treturn -2;\n-\t\t\t}\n-\t\t\ttypeAnnotations = annotations->typeAnnotations;\n-\t\t\t/*\n-\t\t\t * we are now at the start of the first type_annotation\n-\t\t\t * Silently ignore errors.\n+\n+\t\t\t/* In the case of a malformed attribute numberOfAnnotations may not exist even if the file did not end. \n+\t\t\t * There must be at least two bytes to have a valid numberOfAnnotations.\n+\t\t\t * Length of 0 will be treated as an error below. Length of 1 will be an error as well since the index\n+\t\t\t * will not match the end value.\n \t\t\t */\n-\t\t\tfor (j = 0; j < annotations->numberOfAnnotations; j++, typeAnnotations++) {\n-\t\t\t\tresult = readTypeAnnotation(classfile, typeAnnotations, data, dataEnd, segment, segmentEnd, &index, &freePointer, flags);\n-\t\t\t\tif (BCT_ERR_NO_ERROR != result) {\n-\t\t\t\t\tbreak;\n+\t\t\tif (length > 1) {\n+\t\t\t\tCHECK_EOF(2);\n+\t\t\t\tNEXT_U16(annotations->numberOfAnnotations, index);\n+\n+\t\t\t\tif (!ALLOC_ARRAY(annotations->typeAnnotations, annotations->numberOfAnnotations, J9CfrTypeAnnotation)) {\n+\t\t\t\t\treturn -2;\n+\t\t\t\t}\n+\t\t\t\ttypeAnnotations = annotations->typeAnnotations;\n+\t\t\t\t/*\n+\t\t\t\t* we are now at the start of the first type_annotation\n+\t\t\t\t* Silently ignore errors.\n+\t\t\t\t*/\n+\t\t\t\tfor (j = 0; j < annotations->numberOfAnnotations; j++, typeAnnotations++) {\n+\t\t\t\t\tresult = readTypeAnnotation(classfile, typeAnnotations, data, dataEnd, segment, segmentEnd, &index, &freePointer, flags);\n+\t\t\t\t\tif (BCT_ERR_NO_ERROR != result) {\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (BCT_ERR_OUT_OF_ROM == result) {\n \t\t\t\t/* Return out of memory error code to allocate larger buffer for classfile */\n \t\t\t\treturn result;\n-\t\t\t} else if ((BCT_ERR_NO_ERROR != result) || (index != end)) {\n-\t\t\t\tU_32 cursor = 0;\n+\t\t\t} else if ((BCT_ERR_NO_ERROR != result) || (0 == length) || (index != end)) {\n \t\t\t\t/*\n-\t\t\t\t * give up parsing.\n+\t\t\t\t * Give up parsing.\n+\t\t\t\t * \n \t\t\t\t * Copy the raw data, insert a bogus type_annotation,\n-\t\t\t\t * i.e. an illegal target_type byte immediately after the num_annotations field,\n-\t\t\t\t * to indicate that the attribute is malformed.\n+\t\t\t\t * i.e. an illegal target_type byte immediately after the num_annotations field\n+\t\t\t\t * to indicate that the attribute is malformed. The remaining raw data should follow\n+\t\t\t\t * the illegal target_type.\n+\t\t\t\t * \n+\t\t\t\t * The minimum number of raw data bytes needed to create a bogus type_annotation is:\n+\t\t\t\t * num_annotations (2 bytes)\n+\t\t\t\t * target_type (1 byte)\n+\t\t\t\t * extra raw data (at least 1 byte)\n+\t\t\t\t * \n+\t\t\t\t * Length will be adjusted during rawAttributeData assignment if it is determined that \n+\t\t\t\t * an extra slot is not needed.\n \t\t\t\t */\n+\t\t\t\tconst U_32 minimumRawDataBytes = 4;\n+\n \t\t\t\tTrc_BCU_MalformedTypeAnnotation(address);\n-\t\t\t\tif (!ALLOC_ARRAY(annotations->rawAttributeData, length + 1, U_8)) {\n+\n+\t\t\t\tannotations->rawDataLength = OMR_MAX(minimumRawDataBytes, length + 1);\n+\n+\t\t\t\tif (!ALLOC_ARRAY(annotations->rawAttributeData, annotations->rawDataLength, U_8)) {\n \t\t\t\t\treturn -2;\n \t\t\t\t}\n \t\t\t\tindex = attributeStart; /* rewind to the start of the attribute */\n-\t\t\t\tNEXT_U16(annotations->rawAttributeData[0], index); /* put in the num_annotations */\n-\t\t\t\tNEXT_U8(annotations->rawAttributeData[2], index);\n-\t\t\t\tif (CFR_TARGET_TYPE_ErrorInAttribute != annotations->rawAttributeData[2]) {\n-\t\t\t\t\t/* insert an error marker */\n-\t\t\t\t\tannotations->rawAttributeData[3] = annotations->rawAttributeData[2];\n-\t\t\t\t\tannotations->rawAttributeData[2] = CFR_TARGET_TYPE_ErrorInAttribute;\n-\t\t\t\t\tannotations->rawDataLength = length + 1;\n-\t\t\t\t} else { /* the attribute is already marked bad */\n-\t\t\t\t\tNEXT_U8(annotations->rawAttributeData[3], index);\n-\t\t\t\t\tannotations->rawDataLength = length;\n+\n+\t\t\t\t/* read num_annotations or set dummy if these bytes do not exist. */\n+\t\t\t\tif (length >= 2) {\n+\t\t\t\t\tNEXT_U16(annotations->rawAttributeData[0], index);\n+\t\t\t\t} else {\n+\t\t\t\t\t/* there should be at least one type_annotation here for the illegal \n+\t\t\t\t\t * entry that is being created. */\n+\t\t\t\t\tannotations->rawAttributeData[0] = 0;\n+\t\t\t\t\tannotations->rawAttributeData[1] = 1;\n \t\t\t\t}\n-\t\t\t\tfor (cursor = 4; cursor < annotations->rawDataLength; ++cursor) {\n-\t\t\t\t\tCHECK_EOF(1);\n-\t\t\t\t\tNEXT_U8(annotations->rawAttributeData[cursor], index);\n+\n+\t\t\t\t/* Insert illegal target_type followed by remaining raw data. */\n+\t\t\t\tif (index == end) {\n+\t\t\t\t\t/* There is no remaining raw data. */\n+\t\t\t\t\tannotations->rawAttributeData[2] = CFR_TARGET_TYPE_ErrorInAttribute;\n+\n+\t\t\t\t\t/* Adjust rawDataLength since there was no need to insert an extra byte. */\n+\t\t\t\t\tannotations->rawDataLength--;\n+\t\t\t\t} else {\n+\t\t\t\t\t/* cursor is the starting point in raw data array to write remaining raw data. */\n+\t\t\t\t\tU_32 cursor = 0;\n+\n+\t\t\t\t\tNEXT_U8(annotations->rawAttributeData[2], index);\n+\n+\t\t\t\t\tif (CFR_TARGET_TYPE_ErrorInAttribute != annotations->rawAttributeData[2]) {\n+\t\t\t\t\t\t/* insert an error marker */\n+\t\t\t\t\t\tannotations->rawAttributeData[3] = annotations->rawAttributeData[2];\n+\t\t\t\t\t\tannotations->rawAttributeData[2] = CFR_TARGET_TYPE_ErrorInAttribute;\n+\t\t\t\t\t\tcursor = 4;\n+\t\t\t\t\t} else { /* the attribute is already marked bad */\n+\t\t\t\t\t\t/* Adjust rawDataLength since there was no need to insert an extra byte. */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f972102e1b6b8328662691d099d9b85bf4adf3e"}, "originalPosition": 196}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjk4Nzk1MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t\t\tannotations->rawDataLength--;\n          \n          \n            \n            \t\t\t\t\t\tannotations->rawDataLength -= 1;", "url": "https://github.com/eclipse-openj9/openj9/pull/8761#discussion_r392987950", "createdAt": "2020-03-16T12:34:54Z", "author": {"login": "DanHeidinga"}, "path": "runtime/bcutil/cfreader.c", "diffHunk": "@@ -623,56 +642,106 @@ readAttributes(J9CfrClassFile * classfile, J9CfrAttribute *** pAttributes, U_32\n \t\t\t\treturn -2;\n \t\t\t}\n \t\t\tannotations = (J9CfrAttributeRuntimeVisibleTypeAnnotations *)attrib;\n+\t\t\tannotations->numberOfAnnotations = 0;\n+\t\t\tannotations->typeAnnotations = NULL;\n \t\t\tannotations->rawAttributeData = NULL;\n \t\t\tannotations->rawDataLength = 0; /* 0 indicates attribute is well-formed */\n-\t\t\tCHECK_EOF(2);\n-\t\t\tNEXT_U16(annotations->numberOfAnnotations, index);\n-\t\t\tif (!ALLOC_ARRAY(annotations->typeAnnotations, annotations->numberOfAnnotations, J9CfrTypeAnnotation))\n-\t\t\t{\n-\t\t\t\treturn -2;\n-\t\t\t}\n-\t\t\ttypeAnnotations = annotations->typeAnnotations;\n-\t\t\t/*\n-\t\t\t * we are now at the start of the first type_annotation\n-\t\t\t * Silently ignore errors.\n+\n+\t\t\t/* In the case of a malformed attribute numberOfAnnotations may not exist even if the file did not end. \n+\t\t\t * There must be at least two bytes to have a valid numberOfAnnotations.\n+\t\t\t * Length of 0 will be treated as an error below. Length of 1 will be an error as well since the index\n+\t\t\t * will not match the end value.\n \t\t\t */\n-\t\t\tfor (j = 0; j < annotations->numberOfAnnotations; j++, typeAnnotations++) {\n-\t\t\t\tresult = readTypeAnnotation(classfile, typeAnnotations, data, dataEnd, segment, segmentEnd, &index, &freePointer, flags);\n-\t\t\t\tif (BCT_ERR_NO_ERROR != result) {\n-\t\t\t\t\tbreak;\n+\t\t\tif (length > 1) {\n+\t\t\t\tCHECK_EOF(2);\n+\t\t\t\tNEXT_U16(annotations->numberOfAnnotations, index);\n+\n+\t\t\t\tif (!ALLOC_ARRAY(annotations->typeAnnotations, annotations->numberOfAnnotations, J9CfrTypeAnnotation)) {\n+\t\t\t\t\treturn -2;\n+\t\t\t\t}\n+\t\t\t\ttypeAnnotations = annotations->typeAnnotations;\n+\t\t\t\t/*\n+\t\t\t\t* we are now at the start of the first type_annotation\n+\t\t\t\t* Silently ignore errors.\n+\t\t\t\t*/\n+\t\t\t\tfor (j = 0; j < annotations->numberOfAnnotations; j++, typeAnnotations++) {\n+\t\t\t\t\tresult = readTypeAnnotation(classfile, typeAnnotations, data, dataEnd, segment, segmentEnd, &index, &freePointer, flags);\n+\t\t\t\t\tif (BCT_ERR_NO_ERROR != result) {\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (BCT_ERR_OUT_OF_ROM == result) {\n \t\t\t\t/* Return out of memory error code to allocate larger buffer for classfile */\n \t\t\t\treturn result;\n-\t\t\t} else if ((BCT_ERR_NO_ERROR != result) || (index != end)) {\n-\t\t\t\tU_32 cursor = 0;\n+\t\t\t} else if ((BCT_ERR_NO_ERROR != result) || (0 == length) || (index != end)) {\n \t\t\t\t/*\n-\t\t\t\t * give up parsing.\n+\t\t\t\t * Give up parsing.\n+\t\t\t\t * \n \t\t\t\t * Copy the raw data, insert a bogus type_annotation,\n-\t\t\t\t * i.e. an illegal target_type byte immediately after the num_annotations field,\n-\t\t\t\t * to indicate that the attribute is malformed.\n+\t\t\t\t * i.e. an illegal target_type byte immediately after the num_annotations field\n+\t\t\t\t * to indicate that the attribute is malformed. The remaining raw data should follow\n+\t\t\t\t * the illegal target_type.\n+\t\t\t\t * \n+\t\t\t\t * The minimum number of raw data bytes needed to create a bogus type_annotation is:\n+\t\t\t\t * num_annotations (2 bytes)\n+\t\t\t\t * target_type (1 byte)\n+\t\t\t\t * extra raw data (at least 1 byte)\n+\t\t\t\t * \n+\t\t\t\t * Length will be adjusted during rawAttributeData assignment if it is determined that \n+\t\t\t\t * an extra slot is not needed.\n \t\t\t\t */\n+\t\t\t\tconst U_32 minimumRawDataBytes = 4;\n+\n \t\t\t\tTrc_BCU_MalformedTypeAnnotation(address);\n-\t\t\t\tif (!ALLOC_ARRAY(annotations->rawAttributeData, length + 1, U_8)) {\n+\n+\t\t\t\tannotations->rawDataLength = OMR_MAX(minimumRawDataBytes, length + 1);\n+\n+\t\t\t\tif (!ALLOC_ARRAY(annotations->rawAttributeData, annotations->rawDataLength, U_8)) {\n \t\t\t\t\treturn -2;\n \t\t\t\t}\n \t\t\t\tindex = attributeStart; /* rewind to the start of the attribute */\n-\t\t\t\tNEXT_U16(annotations->rawAttributeData[0], index); /* put in the num_annotations */\n-\t\t\t\tNEXT_U8(annotations->rawAttributeData[2], index);\n-\t\t\t\tif (CFR_TARGET_TYPE_ErrorInAttribute != annotations->rawAttributeData[2]) {\n-\t\t\t\t\t/* insert an error marker */\n-\t\t\t\t\tannotations->rawAttributeData[3] = annotations->rawAttributeData[2];\n-\t\t\t\t\tannotations->rawAttributeData[2] = CFR_TARGET_TYPE_ErrorInAttribute;\n-\t\t\t\t\tannotations->rawDataLength = length + 1;\n-\t\t\t\t} else { /* the attribute is already marked bad */\n-\t\t\t\t\tNEXT_U8(annotations->rawAttributeData[3], index);\n-\t\t\t\t\tannotations->rawDataLength = length;\n+\n+\t\t\t\t/* read num_annotations or set dummy if these bytes do not exist. */\n+\t\t\t\tif (length >= 2) {\n+\t\t\t\t\tNEXT_U16(annotations->rawAttributeData[0], index);\n+\t\t\t\t} else {\n+\t\t\t\t\t/* there should be at least one type_annotation here for the illegal \n+\t\t\t\t\t * entry that is being created. */\n+\t\t\t\t\tannotations->rawAttributeData[0] = 0;\n+\t\t\t\t\tannotations->rawAttributeData[1] = 1;\n \t\t\t\t}\n-\t\t\t\tfor (cursor = 4; cursor < annotations->rawDataLength; ++cursor) {\n-\t\t\t\t\tCHECK_EOF(1);\n-\t\t\t\t\tNEXT_U8(annotations->rawAttributeData[cursor], index);\n+\n+\t\t\t\t/* Insert illegal target_type followed by remaining raw data. */\n+\t\t\t\tif (index == end) {\n+\t\t\t\t\t/* There is no remaining raw data. */\n+\t\t\t\t\tannotations->rawAttributeData[2] = CFR_TARGET_TYPE_ErrorInAttribute;\n+\n+\t\t\t\t\t/* Adjust rawDataLength since there was no need to insert an extra byte. */\n+\t\t\t\t\tannotations->rawDataLength--;\n+\t\t\t\t} else {\n+\t\t\t\t\t/* cursor is the starting point in raw data array to write remaining raw data. */\n+\t\t\t\t\tU_32 cursor = 0;\n+\n+\t\t\t\t\tNEXT_U8(annotations->rawAttributeData[2], index);\n+\n+\t\t\t\t\tif (CFR_TARGET_TYPE_ErrorInAttribute != annotations->rawAttributeData[2]) {\n+\t\t\t\t\t\t/* insert an error marker */\n+\t\t\t\t\t\tannotations->rawAttributeData[3] = annotations->rawAttributeData[2];\n+\t\t\t\t\t\tannotations->rawAttributeData[2] = CFR_TARGET_TYPE_ErrorInAttribute;\n+\t\t\t\t\t\tcursor = 4;\n+\t\t\t\t\t} else { /* the attribute is already marked bad */\n+\t\t\t\t\t\t/* Adjust rawDataLength since there was no need to insert an extra byte. */\n+\t\t\t\t\t\tannotations->rawDataLength--;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f972102e1b6b8328662691d099d9b85bf4adf3e"}, "originalPosition": 197}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8fa94fc7c0d95fc813f032fd4528773cac80817e", "author": {"user": {"login": "theresa-m", "name": "Theresa Mammarella"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/8fa94fc7c0d95fc813f032fd4528773cac80817e", "committedDate": "2020-03-16T14:07:39Z", "message": "Runtime*Annotations malformed edge cases\n\nCurrently it is assumed that the length of a RuntimeVisibleAnnotation or RuntimeVisibleTypeAnnotation will be at least 2. This may not be the case for a malformed annotation. Deal with the cases where the length is 0 or 1 and ensure that the error is properly handled.\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "53976813878cdcd646ae2d92da154614de1780aa", "author": {"user": {"login": "theresa-m", "name": "Theresa Mammarella"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/53976813878cdcd646ae2d92da154614de1780aa", "committedDate": "2020-03-16T14:04:10Z", "message": "Update runtime/bcutil/cfreader.c\n\nCo-Authored-By: Dan Heidinga <daniel_heidinga@ca.ibm.com>"}, "afterCommit": {"oid": "8fa94fc7c0d95fc813f032fd4528773cac80817e", "author": {"user": {"login": "theresa-m", "name": "Theresa Mammarella"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/8fa94fc7c0d95fc813f032fd4528773cac80817e", "committedDate": "2020-03-16T14:07:39Z", "message": "Runtime*Annotations malformed edge cases\n\nCurrently it is assumed that the length of a RuntimeVisibleAnnotation or RuntimeVisibleTypeAnnotation will be at least 2. This may not be the case for a malformed annotation. Deal with the cases where the length is 0 or 1 and ensure that the error is properly handled.\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc1MjUzMTMw", "url": "https://github.com/eclipse-openj9/openj9/pull/8761#pullrequestreview-375253130", "createdAt": "2020-03-16T14:11:49Z", "commit": {"oid": "8fa94fc7c0d95fc813f032fd4528773cac80817e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 401, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}