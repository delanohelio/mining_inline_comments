{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA1ODEwNzMw", "number": 10923, "title": "AArch64: Implement VMinstanceofEvaluator", "bodyText": "This commit adds inlined version of evaluator for instanceof.\nAs in p/z version, this evaluator uses a common method that\ndetermines which sequences need to be generated.\nDepends on:\n\neclipse/omr#5603\neclipse/omr#5617\n\nSigned-off-by: Akira Saitoh saiaki@jp.ibm.com", "createdAt": "2020-10-19T09:01:34Z", "url": "https://github.com/eclipse-openj9/openj9/pull/10923", "merged": true, "mergeCommit": {"oid": "6098880e9ba07d60c00fff4086863690707fce65"}, "closed": true, "closedAt": "2020-10-22T03:15:52Z", "author": {"login": "Akira1Saitoh"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdUq3W-AFqTUxMzUzMzIxNQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdU5N9AgFqTUxNDMzMDY3Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzNTMzMjE1", "url": "https://github.com/eclipse-openj9/openj9/pull/10923#pullrequestreview-513533215", "createdAt": "2020-10-21T10:32:12Z", "commit": {"oid": "72f1c9b26a2f6dd94c294dcbbc0866811f2c0939"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxMDozMjoxMlrOHllOlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxMDozMjoxMlrOHllOlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTE2OTMwMA==", "bodyText": "Two styles are mixed here for variable declaration:\n\nTR::Register* j9classReg (space after *)\nTR::Register *objReg (space before *)", "url": "https://github.com/eclipse-openj9/openj9/pull/10923#discussion_r509169300", "createdAt": "2020-10-21T10:32:12Z", "author": {"login": "knn-k"}, "path": "runtime/compiler/aarch64/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -682,12 +684,470 @@ J9::ARM64::TreeEvaluator::asynccheckEvaluator(TR::Node *node, TR::CodeGenerator\n TR::Register *\n J9::ARM64::TreeEvaluator::instanceofEvaluator(TR::Node *node, TR::CodeGenerator *cg)\n    {\n-   // Call helper\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::icall);\n-   TR::Register *targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n+   TR::Compilation *comp = cg->comp();\n+\n+   if (comp->getOption(TR_DisableInlineInstanceOf))\n+      {\n+      // Call helper\n+      TR::ILOpCodes opCode = node->getOpCodeValue();\n+      TR::Node::recreate(node, TR::icall);\n+      TR::Register *targetRegister = directCallEvaluator(node, cg);\n+      TR::Node::recreate(node, opCode);\n+      return targetRegister;\n+      }\n+   else\n+      {\n+      return VMinstanceofEvaluator(node, cg);\n+      }\n+   }\n+\n+/**\n+ * @brief Generates instructions to load j9class from object pointer\n+ * \n+ * @param[in]       node: node\n+ * @param[in] j9classReg: register j9class value is assigned to\n+ * @param[in]     objReg: register holding object pointer\n+ * @param[in]         cg: code generator\n+ */\n+static void \n+generateLoadJ9Class(TR::Node* node, TR::Register* j9classReg, TR::Register *objReg, TR::CodeGenerator* cg)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "72f1c9b26a2f6dd94c294dcbbc0866811f2c0939"}, "originalPosition": 52}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzNTQwNjM5", "url": "https://github.com/eclipse-openj9/openj9/pull/10923#pullrequestreview-513540639", "createdAt": "2020-10-21T10:42:13Z", "commit": {"oid": "72f1c9b26a2f6dd94c294dcbbc0866811f2c0939"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxMDo0MjoxM1rOHllk8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxMDo0MjoxM1rOHllk8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTE3NTAyNA==", "bodyText": "ldrimmx expects a MemoryReference with a base register and a integer offset.\nPerhaps you mean ldroffx?", "url": "https://github.com/eclipse-openj9/openj9/pull/10923#discussion_r509175024", "createdAt": "2020-10-21T10:42:13Z", "author": {"login": "knn-k"}, "path": "runtime/compiler/aarch64/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -682,12 +684,470 @@ J9::ARM64::TreeEvaluator::asynccheckEvaluator(TR::Node *node, TR::CodeGenerator\n TR::Register *\n J9::ARM64::TreeEvaluator::instanceofEvaluator(TR::Node *node, TR::CodeGenerator *cg)\n    {\n-   // Call helper\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::icall);\n-   TR::Register *targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n+   TR::Compilation *comp = cg->comp();\n+\n+   if (comp->getOption(TR_DisableInlineInstanceOf))\n+      {\n+      // Call helper\n+      TR::ILOpCodes opCode = node->getOpCodeValue();\n+      TR::Node::recreate(node, TR::icall);\n+      TR::Register *targetRegister = directCallEvaluator(node, cg);\n+      TR::Node::recreate(node, opCode);\n+      return targetRegister;\n+      }\n+   else\n+      {\n+      return VMinstanceofEvaluator(node, cg);\n+      }\n+   }\n+\n+/**\n+ * @brief Generates instructions to load j9class from object pointer\n+ * \n+ * @param[in]       node: node\n+ * @param[in] j9classReg: register j9class value is assigned to\n+ * @param[in]     objReg: register holding object pointer\n+ * @param[in]         cg: code generator\n+ */\n+static void \n+generateLoadJ9Class(TR::Node* node, TR::Register* j9classReg, TR::Register *objReg, TR::CodeGenerator* cg)\n+   {\n+   generateTrg1MemInstruction(cg, TR::Compiler->om.compressObjectReferences() ? TR::InstOpCode::ldrimmw : TR::InstOpCode::ldrimmx, node, j9classReg,\n+      new (cg->trHeapMemory()) TR::MemoryReference(objReg, static_cast<int32_t>(TR::Compiler->om.offsetOfObjectVftField()), cg));\n+   TR::TreeEvaluator::generateVFTMaskInstruction(cg, node, j9classReg);\n+   }\n+\n+/**\n+ *  @brief Generates Superclass Test for both checkcast and instanceof nodes.\n+ *  @details\n+ *    It will generate pseudocode as follows.\n+ *    if (objectClassDepth <= castClassDepth) call Helper\n+ *    else\n+ *    load superClassArrReg,superClassOfObjectClass\n+ *    cmp superClassArrReg[castClassDepth], castClass\n+ *    Here It sets up the condition code for callee to react on.\n+ */\n+static\n+void genInstanceOfOrCheckCastSuperClassTest(TR::Node *node, TR::Register *instanceClassReg, TR::Register *castClassReg, int32_t castClassDepth,\n+                                            TR::LabelSymbol *falseLabel, TR_ARM64ScratchRegisterManager *srm, TR::CodeGenerator *cg)\n+   {\n+   TR::Compilation *comp = cg->comp();\n+\n+   // Compare the instance class depth to the cast class depth. If the instance class depth is less than or equal to\n+   // to the cast class depth then the cast class cannot be a superclass of the instance class.\n+   //\n+   TR::Register *instanceClassDepthReg = srm->findOrCreateScratchRegister();\n+   TR::Register *castClassDepthReg = NULL;\n+   static_assert(J9AccClassDepthMask == 0xffff, \"J9_JAVA_CLASS_DEPTH_MASK must be 0xffff\");\n+   // load lower 16bit of classDepthAndFlags\n+   generateTrg1MemInstruction(cg, TR::InstOpCode::ldrhimm, node, instanceClassDepthReg,\n+                              new (cg->trHeapMemory()) TR::MemoryReference(instanceClassReg, offsetof(J9Class, classDepthAndFlags), cg));\n+   if (constantIsUnsignedImm12(castClassDepth))\n+      {\n+      generateCompareImmInstruction(cg, node, instanceClassDepthReg, castClassDepth);\n+      }\n+   else\n+      {\n+      castClassDepthReg = srm->findOrCreateScratchRegister();\n+      loadConstant32(cg, node, castClassDepth, castClassDepthReg);\n+      generateCompareInstruction(cg, node, instanceClassDepthReg, castClassDepthReg);\n+      }\n+   srm->reclaimScratchRegister(instanceClassDepthReg);\n+\n+   // if objectClassDepth is less than or equal to castClassDepth, then call Helper\n+   generateConditionalBranchInstruction(cg, TR::InstOpCode::b_cond, node, falseLabel, TR::CC_LE);\n+\n+   // Load the superclasses array of the instance class and check if the superclass that appears at the depth of the cast class is in fact the cast class.\n+   // If not, the instance class and cast class are not in the same hierarchy.\n+   //\n+   TR::Register *instanceClassSuperClassesArrayReg = srm->findOrCreateScratchRegister();\n+   TR::Register *instanceClassSuperClassReg = srm->findOrCreateScratchRegister();\n+\n+   generateTrg1MemInstruction(cg,TR::InstOpCode::ldrimmx, node, instanceClassSuperClassesArrayReg,\n+                              new (cg->trHeapMemory()) TR::MemoryReference(instanceClassReg, offsetof(J9Class, superclasses), cg));\n+\n+   int32_t castClassDepthOffset = castClassDepth * TR::Compiler->om.sizeofReferenceAddress();\n+   if (constantIsUnsignedImm12(castClassDepthOffset))\n+      {\n+      generateTrg1MemInstruction(cg, TR::InstOpCode::ldrimmx, node, instanceClassSuperClassReg,\n+                                 new (cg->trHeapMemory()) TR::MemoryReference(instanceClassSuperClassesArrayReg, castClassDepthOffset, cg));\n+      }\n+   else\n+      {\n+      if (!castClassDepthReg)\n+         {\n+         castClassDepthReg = srm->findOrCreateScratchRegister();\n+         loadConstant32(cg, node, castClassDepth, castClassDepthReg);\n+         }\n+      generateLogicalShiftLeftImmInstruction(cg, node, castClassDepthReg, castClassDepthReg, 3, false);\n+      generateTrg1MemInstruction(cg, TR::InstOpCode::ldrimmx, node, instanceClassSuperClassReg, new (cg->trHeapMemory()) TR::MemoryReference(instanceClassSuperClassesArrayReg, castClassDepthReg, cg));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "72f1c9b26a2f6dd94c294dcbbc0866811f2c0939"}, "originalPosition": 122}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzNTQ1Mzc1", "url": "https://github.com/eclipse-openj9/openj9/pull/10923#pullrequestreview-513545375", "createdAt": "2020-10-21T10:48:50Z", "commit": {"oid": "72f1c9b26a2f6dd94c294dcbbc0866811f2c0939"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxMDo0ODo1MFrOHllzGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxMDo0ODo1MFrOHllzGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTE3ODY0OA==", "bodyText": "This variable comp is not used in this function.", "url": "https://github.com/eclipse-openj9/openj9/pull/10923#discussion_r509178648", "createdAt": "2020-10-21T10:48:50Z", "author": {"login": "knn-k"}, "path": "runtime/compiler/aarch64/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -682,12 +684,470 @@ J9::ARM64::TreeEvaluator::asynccheckEvaluator(TR::Node *node, TR::CodeGenerator\n TR::Register *\n J9::ARM64::TreeEvaluator::instanceofEvaluator(TR::Node *node, TR::CodeGenerator *cg)\n    {\n-   // Call helper\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::icall);\n-   TR::Register *targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n+   TR::Compilation *comp = cg->comp();\n+\n+   if (comp->getOption(TR_DisableInlineInstanceOf))\n+      {\n+      // Call helper\n+      TR::ILOpCodes opCode = node->getOpCodeValue();\n+      TR::Node::recreate(node, TR::icall);\n+      TR::Register *targetRegister = directCallEvaluator(node, cg);\n+      TR::Node::recreate(node, opCode);\n+      return targetRegister;\n+      }\n+   else\n+      {\n+      return VMinstanceofEvaluator(node, cg);\n+      }\n+   }\n+\n+/**\n+ * @brief Generates instructions to load j9class from object pointer\n+ * \n+ * @param[in]       node: node\n+ * @param[in] j9classReg: register j9class value is assigned to\n+ * @param[in]     objReg: register holding object pointer\n+ * @param[in]         cg: code generator\n+ */\n+static void \n+generateLoadJ9Class(TR::Node* node, TR::Register* j9classReg, TR::Register *objReg, TR::CodeGenerator* cg)\n+   {\n+   generateTrg1MemInstruction(cg, TR::Compiler->om.compressObjectReferences() ? TR::InstOpCode::ldrimmw : TR::InstOpCode::ldrimmx, node, j9classReg,\n+      new (cg->trHeapMemory()) TR::MemoryReference(objReg, static_cast<int32_t>(TR::Compiler->om.offsetOfObjectVftField()), cg));\n+   TR::TreeEvaluator::generateVFTMaskInstruction(cg, node, j9classReg);\n+   }\n+\n+/**\n+ *  @brief Generates Superclass Test for both checkcast and instanceof nodes.\n+ *  @details\n+ *    It will generate pseudocode as follows.\n+ *    if (objectClassDepth <= castClassDepth) call Helper\n+ *    else\n+ *    load superClassArrReg,superClassOfObjectClass\n+ *    cmp superClassArrReg[castClassDepth], castClass\n+ *    Here It sets up the condition code for callee to react on.\n+ */\n+static\n+void genInstanceOfOrCheckCastSuperClassTest(TR::Node *node, TR::Register *instanceClassReg, TR::Register *castClassReg, int32_t castClassDepth,\n+                                            TR::LabelSymbol *falseLabel, TR_ARM64ScratchRegisterManager *srm, TR::CodeGenerator *cg)\n+   {\n+   TR::Compilation *comp = cg->comp();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "72f1c9b26a2f6dd94c294dcbbc0866811f2c0939"}, "originalPosition": 73}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzNTQ2Nzgw", "url": "https://github.com/eclipse-openj9/openj9/pull/10923#pullrequestreview-513546780", "createdAt": "2020-10-21T10:50:43Z", "commit": {"oid": "72f1c9b26a2f6dd94c294dcbbc0866811f2c0939"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxMDo1MDo0M1rOHll3MQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxMDo1MDo0M1rOHll3MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTE3OTY5Nw==", "bodyText": "comp is not used in this function.", "url": "https://github.com/eclipse-openj9/openj9/pull/10923#discussion_r509179697", "createdAt": "2020-10-21T10:50:43Z", "author": {"login": "knn-k"}, "path": "runtime/compiler/aarch64/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -682,12 +684,470 @@ J9::ARM64::TreeEvaluator::asynccheckEvaluator(TR::Node *node, TR::CodeGenerator\n TR::Register *\n J9::ARM64::TreeEvaluator::instanceofEvaluator(TR::Node *node, TR::CodeGenerator *cg)\n    {\n-   // Call helper\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::icall);\n-   TR::Register *targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n+   TR::Compilation *comp = cg->comp();\n+\n+   if (comp->getOption(TR_DisableInlineInstanceOf))\n+      {\n+      // Call helper\n+      TR::ILOpCodes opCode = node->getOpCodeValue();\n+      TR::Node::recreate(node, TR::icall);\n+      TR::Register *targetRegister = directCallEvaluator(node, cg);\n+      TR::Node::recreate(node, opCode);\n+      return targetRegister;\n+      }\n+   else\n+      {\n+      return VMinstanceofEvaluator(node, cg);\n+      }\n+   }\n+\n+/**\n+ * @brief Generates instructions to load j9class from object pointer\n+ * \n+ * @param[in]       node: node\n+ * @param[in] j9classReg: register j9class value is assigned to\n+ * @param[in]     objReg: register holding object pointer\n+ * @param[in]         cg: code generator\n+ */\n+static void \n+generateLoadJ9Class(TR::Node* node, TR::Register* j9classReg, TR::Register *objReg, TR::CodeGenerator* cg)\n+   {\n+   generateTrg1MemInstruction(cg, TR::Compiler->om.compressObjectReferences() ? TR::InstOpCode::ldrimmw : TR::InstOpCode::ldrimmx, node, j9classReg,\n+      new (cg->trHeapMemory()) TR::MemoryReference(objReg, static_cast<int32_t>(TR::Compiler->om.offsetOfObjectVftField()), cg));\n+   TR::TreeEvaluator::generateVFTMaskInstruction(cg, node, j9classReg);\n+   }\n+\n+/**\n+ *  @brief Generates Superclass Test for both checkcast and instanceof nodes.\n+ *  @details\n+ *    It will generate pseudocode as follows.\n+ *    if (objectClassDepth <= castClassDepth) call Helper\n+ *    else\n+ *    load superClassArrReg,superClassOfObjectClass\n+ *    cmp superClassArrReg[castClassDepth], castClass\n+ *    Here It sets up the condition code for callee to react on.\n+ */\n+static\n+void genInstanceOfOrCheckCastSuperClassTest(TR::Node *node, TR::Register *instanceClassReg, TR::Register *castClassReg, int32_t castClassDepth,\n+                                            TR::LabelSymbol *falseLabel, TR_ARM64ScratchRegisterManager *srm, TR::CodeGenerator *cg)\n+   {\n+   TR::Compilation *comp = cg->comp();\n+\n+   // Compare the instance class depth to the cast class depth. If the instance class depth is less than or equal to\n+   // to the cast class depth then the cast class cannot be a superclass of the instance class.\n+   //\n+   TR::Register *instanceClassDepthReg = srm->findOrCreateScratchRegister();\n+   TR::Register *castClassDepthReg = NULL;\n+   static_assert(J9AccClassDepthMask == 0xffff, \"J9_JAVA_CLASS_DEPTH_MASK must be 0xffff\");\n+   // load lower 16bit of classDepthAndFlags\n+   generateTrg1MemInstruction(cg, TR::InstOpCode::ldrhimm, node, instanceClassDepthReg,\n+                              new (cg->trHeapMemory()) TR::MemoryReference(instanceClassReg, offsetof(J9Class, classDepthAndFlags), cg));\n+   if (constantIsUnsignedImm12(castClassDepth))\n+      {\n+      generateCompareImmInstruction(cg, node, instanceClassDepthReg, castClassDepth);\n+      }\n+   else\n+      {\n+      castClassDepthReg = srm->findOrCreateScratchRegister();\n+      loadConstant32(cg, node, castClassDepth, castClassDepthReg);\n+      generateCompareInstruction(cg, node, instanceClassDepthReg, castClassDepthReg);\n+      }\n+   srm->reclaimScratchRegister(instanceClassDepthReg);\n+\n+   // if objectClassDepth is less than or equal to castClassDepth, then call Helper\n+   generateConditionalBranchInstruction(cg, TR::InstOpCode::b_cond, node, falseLabel, TR::CC_LE);\n+\n+   // Load the superclasses array of the instance class and check if the superclass that appears at the depth of the cast class is in fact the cast class.\n+   // If not, the instance class and cast class are not in the same hierarchy.\n+   //\n+   TR::Register *instanceClassSuperClassesArrayReg = srm->findOrCreateScratchRegister();\n+   TR::Register *instanceClassSuperClassReg = srm->findOrCreateScratchRegister();\n+\n+   generateTrg1MemInstruction(cg,TR::InstOpCode::ldrimmx, node, instanceClassSuperClassesArrayReg,\n+                              new (cg->trHeapMemory()) TR::MemoryReference(instanceClassReg, offsetof(J9Class, superclasses), cg));\n+\n+   int32_t castClassDepthOffset = castClassDepth * TR::Compiler->om.sizeofReferenceAddress();\n+   if (constantIsUnsignedImm12(castClassDepthOffset))\n+      {\n+      generateTrg1MemInstruction(cg, TR::InstOpCode::ldrimmx, node, instanceClassSuperClassReg,\n+                                 new (cg->trHeapMemory()) TR::MemoryReference(instanceClassSuperClassesArrayReg, castClassDepthOffset, cg));\n+      }\n+   else\n+      {\n+      if (!castClassDepthReg)\n+         {\n+         castClassDepthReg = srm->findOrCreateScratchRegister();\n+         loadConstant32(cg, node, castClassDepth, castClassDepthReg);\n+         }\n+      generateLogicalShiftLeftImmInstruction(cg, node, castClassDepthReg, castClassDepthReg, 3, false);\n+      generateTrg1MemInstruction(cg, TR::InstOpCode::ldrimmx, node, instanceClassSuperClassReg, new (cg->trHeapMemory()) TR::MemoryReference(instanceClassSuperClassesArrayReg, castClassDepthReg, cg));\n+      }\n+   generateCompareInstruction(cg, node, instanceClassSuperClassReg, castClassReg);\n+\n+   if (castClassDepthReg)\n+      srm->reclaimScratchRegister(castClassDepthReg);\n+   srm->reclaimScratchRegister(instanceClassSuperClassesArrayReg);\n+   srm->reclaimScratchRegister(instanceClassSuperClassReg);\n+\n+   // At this point EQ flag will be set if the cast class is a superclass of the instance class. Caller is responsible for acting on the result.\n+   }\n+\n+/** \n+ * @brief Generates Arbitrary Class Test for instanceOf or checkCast node\n+ */\n+static\n+void genInstanceOfOrCheckCastArbitraryClassTest(TR::Node *node, TR::Register *instanceClassReg, TR_OpaqueClassBlock *arbitraryClass,\n+                                                TR_ARM64ScratchRegisterManager *srm, TR::CodeGenerator *cg)\n+   {\n+   TR::Compilation *comp = cg->comp();\n+   TR::Register *arbitraryClassReg = srm->findOrCreateScratchRegister();\n+   if (comp->compileRelocatableCode())\n+      {\n+      loadAddressConstantInSnippet(cg, node, reinterpret_cast<intptr_t>(arbitraryClass), arbitraryClassReg, TR_ClassPointer);\n+      }\n+   else\n+      {\n+      loadAddressConstant(cg, node, reinterpret_cast<intptr_t>(arbitraryClass), arbitraryClassReg, NULL, true);\n+      }\n+   generateCompareInstruction(cg, node, instanceClassReg, arbitraryClassReg, true);\n+   \n+   srm->reclaimScratchRegister(arbitraryClassReg);\n+\n+   // At this point EQ flag will be set if the cast class matches the arbitrary class. Caller is responsible for acting on the result.\n+   }\n+\n+/** \n+ * @brief Generates ArrayOfJavaLangObjectTest (object class is reference array) for instanceOf or checkCast node\n+ * @details\n+ *    scratchReg1 = load (objectClassReg+offset_romClass)\n+ *    scratchReg1 = load (ROMClass+J9ROMClass+modifiers)\n+ *    tstImmediate with J9AccClassArray(0x10000)\n+ *    If not Array -> Branch to Fail Label\n+ *    testerReg = load (objectClassReg + leafcomponent_offset)\n+ *    testerReg = load (objectClassReg + offset_romClass)\n+ *    testerReg = load (objectClassReg + offset_modifiers)\n+ *    tstImmediate with J9AccClassInternalPrimitiveType(0x20000)\n+ *    if not arrays of primitive set condition code to Zero indicating true result\n+ */\n+static\n+void genInstanceOfOrCheckCastObjectArrayTest(TR::Node *node, TR::Register *instanceClassReg, TR::LabelSymbol *falseLabel,\n+                                             TR_ARM64ScratchRegisterManager *srm, TR::CodeGenerator *cg)\n+   {\n+   TR::Compilation *comp = cg->comp();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "72f1c9b26a2f6dd94c294dcbbc0866811f2c0939"}, "originalPosition": 175}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzNTUzNDc4", "url": "https://github.com/eclipse-openj9/openj9/pull/10923#pullrequestreview-513553478", "createdAt": "2020-10-21T10:59:32Z", "commit": {"oid": "72f1c9b26a2f6dd94c294dcbbc0866811f2c0939"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxMDo1OTozMlrOHlmKsg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxMDo1OTozMlrOHlmKsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTE4NDY5MA==", "bodyText": "Perhaps the message should be ... is not implemented on AArch64.\nThe same comment for the next case.", "url": "https://github.com/eclipse-openj9/openj9/pull/10923#discussion_r509184690", "createdAt": "2020-10-21T10:59:32Z", "author": {"login": "knn-k"}, "path": "runtime/compiler/aarch64/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -682,12 +684,470 @@ J9::ARM64::TreeEvaluator::asynccheckEvaluator(TR::Node *node, TR::CodeGenerator\n TR::Register *\n J9::ARM64::TreeEvaluator::instanceofEvaluator(TR::Node *node, TR::CodeGenerator *cg)\n    {\n-   // Call helper\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::icall);\n-   TR::Register *targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n+   TR::Compilation *comp = cg->comp();\n+\n+   if (comp->getOption(TR_DisableInlineInstanceOf))\n+      {\n+      // Call helper\n+      TR::ILOpCodes opCode = node->getOpCodeValue();\n+      TR::Node::recreate(node, TR::icall);\n+      TR::Register *targetRegister = directCallEvaluator(node, cg);\n+      TR::Node::recreate(node, opCode);\n+      return targetRegister;\n+      }\n+   else\n+      {\n+      return VMinstanceofEvaluator(node, cg);\n+      }\n+   }\n+\n+/**\n+ * @brief Generates instructions to load j9class from object pointer\n+ * \n+ * @param[in]       node: node\n+ * @param[in] j9classReg: register j9class value is assigned to\n+ * @param[in]     objReg: register holding object pointer\n+ * @param[in]         cg: code generator\n+ */\n+static void \n+generateLoadJ9Class(TR::Node* node, TR::Register* j9classReg, TR::Register *objReg, TR::CodeGenerator* cg)\n+   {\n+   generateTrg1MemInstruction(cg, TR::Compiler->om.compressObjectReferences() ? TR::InstOpCode::ldrimmw : TR::InstOpCode::ldrimmx, node, j9classReg,\n+      new (cg->trHeapMemory()) TR::MemoryReference(objReg, static_cast<int32_t>(TR::Compiler->om.offsetOfObjectVftField()), cg));\n+   TR::TreeEvaluator::generateVFTMaskInstruction(cg, node, j9classReg);\n+   }\n+\n+/**\n+ *  @brief Generates Superclass Test for both checkcast and instanceof nodes.\n+ *  @details\n+ *    It will generate pseudocode as follows.\n+ *    if (objectClassDepth <= castClassDepth) call Helper\n+ *    else\n+ *    load superClassArrReg,superClassOfObjectClass\n+ *    cmp superClassArrReg[castClassDepth], castClass\n+ *    Here It sets up the condition code for callee to react on.\n+ */\n+static\n+void genInstanceOfOrCheckCastSuperClassTest(TR::Node *node, TR::Register *instanceClassReg, TR::Register *castClassReg, int32_t castClassDepth,\n+                                            TR::LabelSymbol *falseLabel, TR_ARM64ScratchRegisterManager *srm, TR::CodeGenerator *cg)\n+   {\n+   TR::Compilation *comp = cg->comp();\n+\n+   // Compare the instance class depth to the cast class depth. If the instance class depth is less than or equal to\n+   // to the cast class depth then the cast class cannot be a superclass of the instance class.\n+   //\n+   TR::Register *instanceClassDepthReg = srm->findOrCreateScratchRegister();\n+   TR::Register *castClassDepthReg = NULL;\n+   static_assert(J9AccClassDepthMask == 0xffff, \"J9_JAVA_CLASS_DEPTH_MASK must be 0xffff\");\n+   // load lower 16bit of classDepthAndFlags\n+   generateTrg1MemInstruction(cg, TR::InstOpCode::ldrhimm, node, instanceClassDepthReg,\n+                              new (cg->trHeapMemory()) TR::MemoryReference(instanceClassReg, offsetof(J9Class, classDepthAndFlags), cg));\n+   if (constantIsUnsignedImm12(castClassDepth))\n+      {\n+      generateCompareImmInstruction(cg, node, instanceClassDepthReg, castClassDepth);\n+      }\n+   else\n+      {\n+      castClassDepthReg = srm->findOrCreateScratchRegister();\n+      loadConstant32(cg, node, castClassDepth, castClassDepthReg);\n+      generateCompareInstruction(cg, node, instanceClassDepthReg, castClassDepthReg);\n+      }\n+   srm->reclaimScratchRegister(instanceClassDepthReg);\n+\n+   // if objectClassDepth is less than or equal to castClassDepth, then call Helper\n+   generateConditionalBranchInstruction(cg, TR::InstOpCode::b_cond, node, falseLabel, TR::CC_LE);\n+\n+   // Load the superclasses array of the instance class and check if the superclass that appears at the depth of the cast class is in fact the cast class.\n+   // If not, the instance class and cast class are not in the same hierarchy.\n+   //\n+   TR::Register *instanceClassSuperClassesArrayReg = srm->findOrCreateScratchRegister();\n+   TR::Register *instanceClassSuperClassReg = srm->findOrCreateScratchRegister();\n+\n+   generateTrg1MemInstruction(cg,TR::InstOpCode::ldrimmx, node, instanceClassSuperClassesArrayReg,\n+                              new (cg->trHeapMemory()) TR::MemoryReference(instanceClassReg, offsetof(J9Class, superclasses), cg));\n+\n+   int32_t castClassDepthOffset = castClassDepth * TR::Compiler->om.sizeofReferenceAddress();\n+   if (constantIsUnsignedImm12(castClassDepthOffset))\n+      {\n+      generateTrg1MemInstruction(cg, TR::InstOpCode::ldrimmx, node, instanceClassSuperClassReg,\n+                                 new (cg->trHeapMemory()) TR::MemoryReference(instanceClassSuperClassesArrayReg, castClassDepthOffset, cg));\n+      }\n+   else\n+      {\n+      if (!castClassDepthReg)\n+         {\n+         castClassDepthReg = srm->findOrCreateScratchRegister();\n+         loadConstant32(cg, node, castClassDepth, castClassDepthReg);\n+         }\n+      generateLogicalShiftLeftImmInstruction(cg, node, castClassDepthReg, castClassDepthReg, 3, false);\n+      generateTrg1MemInstruction(cg, TR::InstOpCode::ldrimmx, node, instanceClassSuperClassReg, new (cg->trHeapMemory()) TR::MemoryReference(instanceClassSuperClassesArrayReg, castClassDepthReg, cg));\n+      }\n+   generateCompareInstruction(cg, node, instanceClassSuperClassReg, castClassReg);\n+\n+   if (castClassDepthReg)\n+      srm->reclaimScratchRegister(castClassDepthReg);\n+   srm->reclaimScratchRegister(instanceClassSuperClassesArrayReg);\n+   srm->reclaimScratchRegister(instanceClassSuperClassReg);\n+\n+   // At this point EQ flag will be set if the cast class is a superclass of the instance class. Caller is responsible for acting on the result.\n+   }\n+\n+/** \n+ * @brief Generates Arbitrary Class Test for instanceOf or checkCast node\n+ */\n+static\n+void genInstanceOfOrCheckCastArbitraryClassTest(TR::Node *node, TR::Register *instanceClassReg, TR_OpaqueClassBlock *arbitraryClass,\n+                                                TR_ARM64ScratchRegisterManager *srm, TR::CodeGenerator *cg)\n+   {\n+   TR::Compilation *comp = cg->comp();\n+   TR::Register *arbitraryClassReg = srm->findOrCreateScratchRegister();\n+   if (comp->compileRelocatableCode())\n+      {\n+      loadAddressConstantInSnippet(cg, node, reinterpret_cast<intptr_t>(arbitraryClass), arbitraryClassReg, TR_ClassPointer);\n+      }\n+   else\n+      {\n+      loadAddressConstant(cg, node, reinterpret_cast<intptr_t>(arbitraryClass), arbitraryClassReg, NULL, true);\n+      }\n+   generateCompareInstruction(cg, node, instanceClassReg, arbitraryClassReg, true);\n+   \n+   srm->reclaimScratchRegister(arbitraryClassReg);\n+\n+   // At this point EQ flag will be set if the cast class matches the arbitrary class. Caller is responsible for acting on the result.\n+   }\n+\n+/** \n+ * @brief Generates ArrayOfJavaLangObjectTest (object class is reference array) for instanceOf or checkCast node\n+ * @details\n+ *    scratchReg1 = load (objectClassReg+offset_romClass)\n+ *    scratchReg1 = load (ROMClass+J9ROMClass+modifiers)\n+ *    tstImmediate with J9AccClassArray(0x10000)\n+ *    If not Array -> Branch to Fail Label\n+ *    testerReg = load (objectClassReg + leafcomponent_offset)\n+ *    testerReg = load (objectClassReg + offset_romClass)\n+ *    testerReg = load (objectClassReg + offset_modifiers)\n+ *    tstImmediate with J9AccClassInternalPrimitiveType(0x20000)\n+ *    if not arrays of primitive set condition code to Zero indicating true result\n+ */\n+static\n+void genInstanceOfOrCheckCastObjectArrayTest(TR::Node *node, TR::Register *instanceClassReg, TR::LabelSymbol *falseLabel,\n+                                             TR_ARM64ScratchRegisterManager *srm, TR::CodeGenerator *cg)\n+   {\n+   TR::Compilation *comp = cg->comp();\n+\n+   // Load the object ROM class and test the modifiers to see if this is an array.\n+   //\n+   TR::Register *scratchReg = srm->findOrCreateScratchRegister();\n+   generateTrg1MemInstruction(cg, TR::InstOpCode::ldrimmx, node, scratchReg, new (cg->trHeapMemory()) TR::MemoryReference(instanceClassReg, offsetof(J9Class, romClass), cg));\n+   generateTrg1MemInstruction(cg, TR::InstOpCode::ldrimmw, node, scratchReg, new (cg->trHeapMemory()) TR::MemoryReference(scratchReg, offsetof(J9ROMClass, modifiers), cg));\n+   static_assert(J9AccClassArray == 0x10000, \"J9AccClassArray must be 0x10000\");\n+   // If not array, branch to falseLabel\n+   generateTestBitBranchInstruction(cg, TR::InstOpCode::tbz, node, scratchReg, 16, falseLabel);\n+\n+   // If it's an array, load the component ROM class and test the modifiers to see if this is a primitive array.\n+   //\n+   generateTrg1MemInstruction(cg, TR::InstOpCode::ldrimmx, node, scratchReg, new (cg->trHeapMemory()) TR::MemoryReference(instanceClassReg, offsetof(J9ArrayClass, componentType), cg));\n+   generateTrg1MemInstruction(cg, TR::InstOpCode::ldrimmx, node, scratchReg, new (cg->trHeapMemory()) TR::MemoryReference(scratchReg, offsetof(J9Class, romClass), cg));\n+   generateTrg1MemInstruction(cg, TR::InstOpCode::ldrimmw, node, scratchReg, new (cg->trHeapMemory()) TR::MemoryReference(scratchReg, offsetof(J9ROMClass, modifiers), cg));\n+\n+   static_assert(J9AccClassInternalPrimitiveType == 0x20000, \"J9AccClassInternalPrimitiveType must be 0x20000\");\n+   generateTestImmInstruction(cg, node, scratchReg, 0x3c0); // 0x3c0 is immr:imms for 0x20000\n+\n+   srm->reclaimScratchRegister(scratchReg);\n+\n+   // At this point EQ flag will be set if this is not a primitive array. Caller is responsible acting on the result.\n+   }\n+\n+template<class It>\n+bool\n+isTerminalSequence(It it, It itEnd)\n+   {\n+   return (it + 1) == itEnd;\n+   }\n+\n+template<class It>\n+bool\n+isNextItemGoToTrue(It it, It itEnd)\n+   {\n+   return (!isTerminalSequence(it, itEnd)) && *(it + 1) == J9::TreeEvaluator::GoToTrue;\n+   }\n+\n+template<class It>\n+bool\n+isNextItemGoToFalse(It it, It itEnd)\n+   {\n+   return (!isTerminalSequence(it, itEnd)) && *(it + 1) == J9::TreeEvaluator::GoToFalse;\n+   }\n+\n+template<class It>\n+bool\n+isNextItemHelperCall(It it, It itEnd)\n+   {\n+   return (!isTerminalSequence(it, itEnd)) && *(it + 1) == J9::TreeEvaluator::HelperCall;\n+   }\n+\n+TR::Register *\n+J9::ARM64::TreeEvaluator::VMinstanceofEvaluator(TR::Node *node, TR::CodeGenerator *cg)\n+   {\n+   TR::Compilation                      *comp = cg->comp();\n+   TR_OpaqueClassBlock                  *compileTimeGuessClass;\n+   int32_t                               maxProfiledClasses = comp->getOptions()->getCheckcastMaxProfiledClassTests();\n+   traceMsg(comp, \"%s:Maximum Profiled Classes = %d\\n\", node->getOpCode().getName(),maxProfiledClasses);\n+   TR_ASSERT_FATAL(maxProfiledClasses <= 4, \"Maximum 4 profiled classes per site allowed because we use a fixed stack allocated buffer for profiled classes\\n\");\n+   InstanceOfOrCheckCastSequences        sequences[InstanceOfOrCheckCastMaxSequences];\n+   bool                                  topClassWasCastClass = false;\n+   float                                 topClassProbability = 0.0;\n+\n+   bool                                  profiledClassIsInstanceOf;\n+   InstanceOfOrCheckCastProfiledClasses  profiledClassesList[4];\n+   uint32_t                              numberOfProfiledClass;\n+   uint32_t                              numSequencesRemaining = calculateInstanceOfOrCheckCastSequences(node, sequences, &compileTimeGuessClass, cg, profiledClassesList, &numberOfProfiledClass, maxProfiledClasses, &topClassProbability, &topClassWasCastClass);\n+\n+\n+   TR::Node                       *objectNode = node->getFirstChild();\n+   TR::Node                       *castClassNode = node->getSecondChild();\n+   TR::Register                   *objectReg = cg->evaluate(objectNode);\n+   TR::Register                   *castClassReg = NULL;\n+   TR::Register                   *resultReg = cg->allocateRegister();\n+\n+   TR::LabelSymbol *doneLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *callHelperLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nextSequenceLabel = generateLabelSymbol(cg);\n+\n+   TR::Instruction *gcPoint;\n+\n+   TR_ARM64ScratchRegisterManager *srm = cg->generateScratchRegisterManager();\n+   TR::Register                 *objectClassReg = NULL;\n+\n+   // initial result is false\n+   generateTrg1ImmInstruction(cg, TR::InstOpCode::movzx, node, resultReg, 0);\n+\n+   auto it = std::begin(sequences);\n+   const auto itEnd = std::next(it, numSequencesRemaining);\n+   \n+   while (it != itEnd)\n+      {\n+      auto current = *it;\n+      switch (current)\n+         {\n+         case EvaluateCastClass:\n+            TR_ASSERT(!castClassReg, \"Cast class already evaluated\");\n+            castClassReg = cg->gprClobberEvaluate(castClassNode);\n+            break;\n+         case LoadObjectClass:\n+            TR_ASSERT(!objectClassReg, \"Object class already loaded\");\n+            objectClassReg = srm->findOrCreateScratchRegister();\n+            generateLoadJ9Class(node, objectClassReg, objectReg, cg);\n+            break;\n+         case NullTest:\n+            if (comp->getOption(TR_TraceCG)) traceMsg(comp, \"%s: Emitting NullTest\\n\", node->getOpCode().getName());\n+            TR_ASSERT(!objectNode->isNonNull(), \"Object is known to be non-null, no need for a null test\");\n+            if (isNextItemGoToTrue(it, itEnd))\n+               {\n+               generateCompareImmInstruction(cg, node, objectReg, 0, true);\n+               generateCSetInstruction(cg, node, resultReg, TR::CC_NE);\n+               // consume GoToTrue\n+               it++;\n+               }\n+            else\n+               {\n+               // branching to doneLabel to return false\n+               generateCompareBranchInstruction(cg, TR::InstOpCode::cbzx, node, objectReg, doneLabel);\n+               }\n+            break;\n+         case GoToTrue:\n+            TR_ASSERT_FATAL(isTerminalSequence(it, itEnd), \"GoToTrue should be the terminal sequence\");\n+            if (comp->getOption(TR_TraceCG)) traceMsg(comp, \"%s: Emitting GoToTrue\\n\", node->getOpCode().getName());\n+            generateTrg1ImmInstruction(cg, TR::InstOpCode::movzx, node, resultReg, 1);\n+            break;\n+         case GoToFalse:\n+            TR_ASSERT_FATAL(isTerminalSequence(it, itEnd), \"GoToFalse should be the terminal sequence\");\n+            if (comp->getOption(TR_TraceCG)) traceMsg(comp, \"%s: Emitting GoToFalse\\n\", node->getOpCode().getName());\n+            break;\n+         case ClassEqualityTest:\n+            if (comp->getOption(TR_TraceCG)) traceMsg(comp, \"%s: Emitting ClassEqualityTest\\n\", node->getOpCode().getName());\n+            cg->generateDebugCounter(TR::DebugCounter::debugCounterName(comp, \"instanceOfStats/(%s)/Equality\", comp->signature()),1,TR::DebugCounter::Undetermined);\n+\n+            generateCompareInstruction(cg, node, objectClassReg, castClassReg, true);\n+            generateCSetInstruction(cg, node, resultReg, TR::CC_EQ);\n+            break;\n+         case SuperClassTest:\n+            {\n+            if (comp->getOption(TR_TraceCG)) traceMsg(comp, \"%s: Emitting SuperClassTest\\n\", node->getOpCode().getName());\n+            cg->generateDebugCounter(TR::DebugCounter::debugCounterName(comp, \"instanceOfStats/(%s)/SuperClassTest\", comp->signature()),1,TR::DebugCounter::Undetermined);\n+\n+            int32_t castClassDepth = castClassNode->getSymbolReference()->classDepth(comp);\n+            auto falseLabel = isNextItemGoToFalse(it, itEnd) ? doneLabel : (isNextItemHelperCall(it, itEnd) ? callHelperLabel : nextSequenceLabel);\n+            genInstanceOfOrCheckCastSuperClassTest(node, objectClassReg, castClassReg, castClassDepth, falseLabel, srm, cg);\n+            generateCSetInstruction(cg, node, resultReg, TR::CC_EQ);\n+            break;\n+            }\n+         case ProfiledClassTest:\n+            {\n+            if (comp->getOption(TR_TraceCG)) traceMsg(comp, \"%s: Emitting ProfiledClassTest\\n\", node->getOpCode().getName());\n+            cg->generateDebugCounter(TR::DebugCounter::debugCounterName(comp, \"instanceOfStats/(%s)/Profile\", comp->signature()),1,TR::DebugCounter::Undetermined);\n+\n+            auto profiledClassesIt = std::begin(profiledClassesList);\n+            auto profiledClassesItEnd = std::next(profiledClassesIt, numberOfProfiledClass);\n+            while (profiledClassesIt != profiledClassesItEnd)\n+               {\n+               if (comp->getOption(TR_TraceCG)) traceMsg(comp, \"%s: ProfiledClassTest: profiledClass = %p, isProfiledClassInstanceOfCastClass = %s\\n\",\n+                                                         node->getOpCode().getName(), profiledClassesIt->profiledClass,\n+                                                         (profiledClassesIt->isProfiledClassInstanceOfCastClass) ? \"true\" : \"false\");\n+\n+               genInstanceOfOrCheckCastArbitraryClassTest(node, objectClassReg, profiledClassesIt->profiledClass, srm, cg);\n+               /**\n+                *  At this point EQ flag will be set if the profiledClass matches the cast class.\n+                *  Set resultReg to 1 if isProfiledClassInstanceOfCastClass is true\n+                */ \n+               if (profiledClassesIt->isProfiledClassInstanceOfCastClass)\n+                  {\n+                  generateCSetInstruction(cg, node, resultReg, TR::CC_EQ);\n+                  }\n+               profiledClassesIt++;\n+               if (profiledClassesIt != profiledClassesItEnd)\n+                  {\n+                  generateConditionalBranchInstruction(cg, TR::InstOpCode::b_cond, node, doneLabel, TR::CC_EQ);\n+                  }\n+               }\n+            }\n+            break;\n+         case CompileTimeGuessClassTest:\n+            if (comp->getOption(TR_TraceCG)) traceMsg(comp, \"%s: Emitting CompileTimeGuessClassTest\\n\", node->getOpCode().getName());\n+            cg->generateDebugCounter(TR::DebugCounter::debugCounterName(comp, \"instanceOfStats/(%s)/compTimeGuess\", comp->signature()),1,TR::DebugCounter::Undetermined);\n+ \n+            genInstanceOfOrCheckCastArbitraryClassTest(node, objectClassReg, compileTimeGuessClass, srm, cg);\n+            generateCSetInstruction(cg, node, resultReg, TR::CC_EQ);\n+\n+            break;\n+         case CastClassCacheTest:\n+            {\n+            if (comp->getOption(TR_TraceCG)) traceMsg(comp, \"%s: Emitting CastClassCacheTest\\n\", node->getOpCode().getName());\n+            cg->generateDebugCounter(TR::DebugCounter::debugCounterName(comp, \"instanceOfStats/(%s)/CastClassCache\", comp->signature()),1,TR::DebugCounter::Undetermined);\n+\n+            /**\n+             * Compare the cast class against the cache on the instance class.\n+             * If they are the same the cast is successful.\n+             * If not it's either because the cache class does not match the cast class, \n+             * or it does match except the cache class has the low bit set, which means the cast is not successful.\n+             */\n+            TR::Register *castClassCacheReg = srm->findOrCreateScratchRegister();\n+            generateTrg1MemInstruction(cg, TR::InstOpCode::ldrimmx, node, castClassCacheReg,\n+                              new (cg->trHeapMemory()) TR::MemoryReference(objectClassReg, offsetof(J9Class, castClassCache), cg));\n+            generateTrg1Src2Instruction(cg, TR::InstOpCode::eorx, node, castClassCacheReg, castClassCacheReg, castClassReg);\n+            generateCompareImmInstruction(cg, node, castClassCacheReg, 1, true);\n+\n+            /**\n+             *  At this point LT flag will be set if the cast is successful, EQ flag will be set if the cast is unsuccessful,\n+             *  and GT flag will be set if the cache class did not match the cast class.\n+             */ \n+            generateCSetInstruction(cg, node, resultReg, TR::CC_LT);\n+            srm->reclaimScratchRegister(castClassCacheReg);\n+            }\n+            break;\n+         case ArrayOfJavaLangObjectTest:\n+            {\n+            if (comp->getOption(TR_TraceCG)) traceMsg(comp, \"%s: Emitting ArrayOfJavaLangObjectTest\\n\", node->getOpCode().getName());\n+            cg->generateDebugCounter(TR::DebugCounter::debugCounterName(comp, \"instanceOfStats/(%s)/ArrayTest\", comp->signature()),1,TR::DebugCounter::Undetermined);\n+\n+            auto falseLabel = isNextItemGoToFalse(it, itEnd) ? doneLabel : (isNextItemHelperCall(it, itEnd) ? callHelperLabel : nextSequenceLabel);\n+            genInstanceOfOrCheckCastObjectArrayTest(node, objectClassReg, nextSequenceLabel, srm, cg);\n+            generateCSetInstruction(cg, node, resultReg, TR::CC_EQ);\n+            }\n+            break;\n+         case DynamicCacheObjectClassTest:\n+            TR_ASSERT_FATAL(false, \"%s: DynamicCacheObjectClassTest is not implemented on P\\n\", node->getOpCode().getName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "72f1c9b26a2f6dd94c294dcbbc0866811f2c0939"}, "originalPosition": 398}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "623e72be841eccb70c99f3c05990d0f0ef6f1d2b", "author": {"user": {"login": "Akira1Saitoh", "name": "Akira Saito"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/623e72be841eccb70c99f3c05990d0f0ef6f1d2b", "committedDate": "2020-10-21T13:32:09Z", "message": "AArch64: Implement VMinstanceofEvaluator\n\nThis commit adds inlined version of evaluator for `instanceof`.\nAs in p/z version, this evaluator uses a common method that\ndetermines which sequences need to be generated.\n\nSigned-off-by: Akira Saitoh <saiaki@jp.ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "72f1c9b26a2f6dd94c294dcbbc0866811f2c0939", "author": {"user": {"login": "Akira1Saitoh", "name": "Akira Saito"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/72f1c9b26a2f6dd94c294dcbbc0866811f2c0939", "committedDate": "2020-10-19T08:20:58Z", "message": "AArch64: Implement VMinstanceofEvaluator\n\nThis commit adds inlined version of evaluator for `instanceof`.\nAs in p/z version, this evaluator uses a common method that\ndetermines which sequences need to be generated.\n\nSigned-off-by: Akira Saitoh <saiaki@jp.ibm.com>"}, "afterCommit": {"oid": "623e72be841eccb70c99f3c05990d0f0ef6f1d2b", "author": {"user": {"login": "Akira1Saitoh", "name": "Akira Saito"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/623e72be841eccb70c99f3c05990d0f0ef6f1d2b", "committedDate": "2020-10-21T13:32:09Z", "message": "AArch64: Implement VMinstanceofEvaluator\n\nThis commit adds inlined version of evaluator for `instanceof`.\nAs in p/z version, this evaluator uses a common method that\ndetermines which sequences need to be generated.\n\nSigned-off-by: Akira Saitoh <saiaki@jp.ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0MzMwNjcy", "url": "https://github.com/eclipse-openj9/openj9/pull/10923#pullrequestreview-514330672", "createdAt": "2020-10-22T03:15:33Z", "commit": {"oid": "623e72be841eccb70c99f3c05990d0f0ef6f1d2b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 209, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}