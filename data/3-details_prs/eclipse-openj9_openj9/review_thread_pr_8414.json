{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY3MzIyOTU2", "number": 8414, "reviewThreads": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQxNTowNzoyOVrODdAtzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxNDozOToxMFrODfkfBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxNzQ3MDIyOnYy", "diffSide": "RIGHT", "path": "jcl/src/java.base/share/classes/java/lang/invoke/LambdaForm.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQxNTowNzoyOVrOFlXeQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxNzozMToyNFrOFmArQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDcyNjIwOQ==", "bodyText": "This feels like it's missing some cases.  The basicType() api should be total for all types - Either one of the primitive ones or L_TYPE", "url": "https://github.com/eclipse-openj9/openj9/pull/8414#discussion_r374726209", "createdAt": "2020-02-04T15:07:29Z", "author": {"login": "DanHeidinga"}, "path": "jcl/src/java.base/share/classes/java/lang/invoke/LambdaForm.java", "diffHunk": "@@ -108,10 +109,36 @@ MethodHandle resolve() {\n \t}\n \t\n \tenum BasicType {\n-\t\tL_TYPE;\n-\t\t\n+\t\tL_TYPE,\n+\t\tI_TYPE,\n+\t\tJ_TYPE,\n+\t\tF_TYPE,\n+\t\tD_TYPE,\n+\t\tV_TYPE;\n+\n \t\tstatic BasicType basicType(Class<?> cls) {\n-\t\t\tthrow OpenJDKCompileStub.OpenJDKCompileStubThrowError();\n+\t\t\tWrapper wrapper = Wrapper.forPrimitiveType(cls);\n+\t\t\tBasicType basicType = null;\n+\t\t\tif (wrapper != null) {\n+\t\t\t\tchar basicTypeChar = wrapper.basicTypeChar();\n+\t\t\t\tif (basicTypeChar == 'L') {\n+\t\t\t\t\tbasicType = L_TYPE;\n+\t\t\t\t} else if ((basicTypeChar == 'C') || (basicTypeChar == 'B') || (basicTypeChar == 'Z')\n+\t\t\t\t\t\t|| (basicTypeChar == 'I') || (basicTypeChar == 'S')) {\n+\t\t\t\t\tbasicType = I_TYPE;\n+\t\t\t\t} else if (basicTypeChar == 'J') {\n+\t\t\t\t\tbasicType = J_TYPE;\n+\t\t\t\t} else if (basicTypeChar == 'F') {\n+\t\t\t\t\tbasicType = F_TYPE;\n+\t\t\t\t} else if (basicTypeChar == 'D') {\n+\t\t\t\t\tbasicType = D_TYPE;\n+\t\t\t\t} else if (basicTypeChar == 'V') {\n+\t\t\t\t\tbasicType = V_TYPE;\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new InternalError(\"Unknown basic type char: \" + basicTypeChar);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn basicType;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe3507ecef6e9b968ee9d2ed5c4d20d0d3e03c6f"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQwMTI4Mw==", "bodyText": "as per sun.misc.Wrapper enum values, all cases are covered.", "url": "https://github.com/eclipse-openj9/openj9/pull/8414#discussion_r375401283", "createdAt": "2020-02-05T17:31:24Z", "author": {"login": "babsingh"}, "path": "jcl/src/java.base/share/classes/java/lang/invoke/LambdaForm.java", "diffHunk": "@@ -108,10 +109,36 @@ MethodHandle resolve() {\n \t}\n \t\n \tenum BasicType {\n-\t\tL_TYPE;\n-\t\t\n+\t\tL_TYPE,\n+\t\tI_TYPE,\n+\t\tJ_TYPE,\n+\t\tF_TYPE,\n+\t\tD_TYPE,\n+\t\tV_TYPE;\n+\n \t\tstatic BasicType basicType(Class<?> cls) {\n-\t\t\tthrow OpenJDKCompileStub.OpenJDKCompileStubThrowError();\n+\t\t\tWrapper wrapper = Wrapper.forPrimitiveType(cls);\n+\t\t\tBasicType basicType = null;\n+\t\t\tif (wrapper != null) {\n+\t\t\t\tchar basicTypeChar = wrapper.basicTypeChar();\n+\t\t\t\tif (basicTypeChar == 'L') {\n+\t\t\t\t\tbasicType = L_TYPE;\n+\t\t\t\t} else if ((basicTypeChar == 'C') || (basicTypeChar == 'B') || (basicTypeChar == 'Z')\n+\t\t\t\t\t\t|| (basicTypeChar == 'I') || (basicTypeChar == 'S')) {\n+\t\t\t\t\tbasicType = I_TYPE;\n+\t\t\t\t} else if (basicTypeChar == 'J') {\n+\t\t\t\t\tbasicType = J_TYPE;\n+\t\t\t\t} else if (basicTypeChar == 'F') {\n+\t\t\t\t\tbasicType = F_TYPE;\n+\t\t\t\t} else if (basicTypeChar == 'D') {\n+\t\t\t\t\tbasicType = D_TYPE;\n+\t\t\t\t} else if (basicTypeChar == 'V') {\n+\t\t\t\t\tbasicType = V_TYPE;\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new InternalError(\"Unknown basic type char: \" + basicTypeChar);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn basicType;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDcyNjIwOQ=="}, "originalCommit": {"oid": "fe3507ecef6e9b968ee9d2ed5c4d20d0d3e03c6f"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMTU2Njk1OnYy", "diffSide": "RIGHT", "path": "jcl/src/java.base/share/classes/java/lang/invoke/LambdaForm.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxNjo0MTo0MFrOFl-8gQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQyMDoxMDo0NlrOFmFn5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM3MjkyOQ==", "bodyText": "Having called Wrapper.forPrimitiveType(cls), it should never be possible to get L_Type here", "url": "https://github.com/eclipse-openj9/openj9/pull/8414#discussion_r375372929", "createdAt": "2020-02-05T16:41:40Z", "author": {"login": "DanHeidinga"}, "path": "jcl/src/java.base/share/classes/java/lang/invoke/LambdaForm.java", "diffHunk": "@@ -108,10 +109,36 @@ MethodHandle resolve() {\n \t}\n \t\n \tenum BasicType {\n-\t\tL_TYPE;\n-\t\t\n+\t\tL_TYPE,\n+\t\tI_TYPE,\n+\t\tJ_TYPE,\n+\t\tF_TYPE,\n+\t\tD_TYPE,\n+\t\tV_TYPE;\n+\n \t\tstatic BasicType basicType(Class<?> cls) {\n-\t\t\tthrow OpenJDKCompileStub.OpenJDKCompileStubThrowError();\n+\t\t\tWrapper wrapper = Wrapper.forPrimitiveType(cls);\n+\t\t\tBasicType basicType = null;\n+\t\t\tif (wrapper != null) {\n+\t\t\t\tchar basicTypeChar = wrapper.basicTypeChar();\n+\t\t\t\tif (basicTypeChar == 'L') {\n+\t\t\t\t\tbasicType = L_TYPE;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5978d5d20bedb88ca150558722bbb4556f59909"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQwMDY5Mg==", "bodyText": "correct, IAE is thrown from Wrapper.forPrimitveType(cls) for a non-primitive type. i will remove the L_TYPE check.", "url": "https://github.com/eclipse-openj9/openj9/pull/8414#discussion_r375400692", "createdAt": "2020-02-05T17:30:12Z", "author": {"login": "babsingh"}, "path": "jcl/src/java.base/share/classes/java/lang/invoke/LambdaForm.java", "diffHunk": "@@ -108,10 +109,36 @@ MethodHandle resolve() {\n \t}\n \t\n \tenum BasicType {\n-\t\tL_TYPE;\n-\t\t\n+\t\tL_TYPE,\n+\t\tI_TYPE,\n+\t\tJ_TYPE,\n+\t\tF_TYPE,\n+\t\tD_TYPE,\n+\t\tV_TYPE;\n+\n \t\tstatic BasicType basicType(Class<?> cls) {\n-\t\t\tthrow OpenJDKCompileStub.OpenJDKCompileStubThrowError();\n+\t\t\tWrapper wrapper = Wrapper.forPrimitiveType(cls);\n+\t\t\tBasicType basicType = null;\n+\t\t\tif (wrapper != null) {\n+\t\t\t\tchar basicTypeChar = wrapper.basicTypeChar();\n+\t\t\t\tif (basicTypeChar == 'L') {\n+\t\t\t\t\tbasicType = L_TYPE;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM3MjkyOQ=="}, "originalCommit": {"oid": "f5978d5d20bedb88ca150558722bbb4556f59909"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQ4MjM0Mg==", "bodyText": "removed.", "url": "https://github.com/eclipse-openj9/openj9/pull/8414#discussion_r375482342", "createdAt": "2020-02-05T20:10:46Z", "author": {"login": "babsingh"}, "path": "jcl/src/java.base/share/classes/java/lang/invoke/LambdaForm.java", "diffHunk": "@@ -108,10 +109,36 @@ MethodHandle resolve() {\n \t}\n \t\n \tenum BasicType {\n-\t\tL_TYPE;\n-\t\t\n+\t\tL_TYPE,\n+\t\tI_TYPE,\n+\t\tJ_TYPE,\n+\t\tF_TYPE,\n+\t\tD_TYPE,\n+\t\tV_TYPE;\n+\n \t\tstatic BasicType basicType(Class<?> cls) {\n-\t\t\tthrow OpenJDKCompileStub.OpenJDKCompileStubThrowError();\n+\t\t\tWrapper wrapper = Wrapper.forPrimitiveType(cls);\n+\t\t\tBasicType basicType = null;\n+\t\t\tif (wrapper != null) {\n+\t\t\t\tchar basicTypeChar = wrapper.basicTypeChar();\n+\t\t\t\tif (basicTypeChar == 'L') {\n+\t\t\t\t\tbasicType = L_TYPE;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM3MjkyOQ=="}, "originalCommit": {"oid": "f5978d5d20bedb88ca150558722bbb4556f59909"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMTU3MjA5OnYy", "diffSide": "RIGHT", "path": "jcl/src/java.base/share/classes/java/lang/invoke/VarHandle.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxNjo0MzoxM1rOFl_AEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQyMDoxMDo1OFrOFmFoMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM3Mzg0MQ==", "bodyText": "Can you move these closer to their first use?", "url": "https://github.com/eclipse-openj9/openj9/pull/8414#discussion_r375373841", "createdAt": "2020-02-05T16:43:13Z", "author": {"login": "DanHeidinga"}, "path": "jcl/src/java.base/share/classes/java/lang/invoke/VarHandle.java", "diffHunk": "@@ -287,7 +358,147 @@ public static AccessMode valueFromMethodName(String methodName) {\n \t\tthis.handleTable = handleTable;\n \t\tthis.modifiers = modifiers;\n \t}\n-\t\n+\n+/*[IF Java14]*/\n+\t/**\n+\t * Constructs a generic VarHandle instance.\n+\t *\n+\t * @param varForm an instance of VarForm.\n+\t */\n+\tVarHandle(VarForm varForm) {\n+\t\tAccessMode accessModes[] = AccessMode.values();\n+\t\tint numAccessModes = accessModes.length;\n+\n+\t\tMethodType[] operationMTs = new MethodType[numAccessModes];\n+\t\tMethodType[] operationMTsExact = null;\n+\n+\t\tMethodType getter = null;\n+\t\tMethodType setter = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5978d5d20bedb88ca150558722bbb4556f59909"}, "originalPosition": 354}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQwOTUzNw==", "bodyText": "yes.", "url": "https://github.com/eclipse-openj9/openj9/pull/8414#discussion_r375409537", "createdAt": "2020-02-05T17:48:00Z", "author": {"login": "babsingh"}, "path": "jcl/src/java.base/share/classes/java/lang/invoke/VarHandle.java", "diffHunk": "@@ -287,7 +358,147 @@ public static AccessMode valueFromMethodName(String methodName) {\n \t\tthis.handleTable = handleTable;\n \t\tthis.modifiers = modifiers;\n \t}\n-\t\n+\n+/*[IF Java14]*/\n+\t/**\n+\t * Constructs a generic VarHandle instance.\n+\t *\n+\t * @param varForm an instance of VarForm.\n+\t */\n+\tVarHandle(VarForm varForm) {\n+\t\tAccessMode accessModes[] = AccessMode.values();\n+\t\tint numAccessModes = accessModes.length;\n+\n+\t\tMethodType[] operationMTs = new MethodType[numAccessModes];\n+\t\tMethodType[] operationMTsExact = null;\n+\n+\t\tMethodType getter = null;\n+\t\tMethodType setter = null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM3Mzg0MQ=="}, "originalCommit": {"oid": "f5978d5d20bedb88ca150558722bbb4556f59909"}, "originalPosition": 354}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQ4MjQxOQ==", "bodyText": "moved closer.", "url": "https://github.com/eclipse-openj9/openj9/pull/8414#discussion_r375482419", "createdAt": "2020-02-05T20:10:58Z", "author": {"login": "babsingh"}, "path": "jcl/src/java.base/share/classes/java/lang/invoke/VarHandle.java", "diffHunk": "@@ -287,7 +358,147 @@ public static AccessMode valueFromMethodName(String methodName) {\n \t\tthis.handleTable = handleTable;\n \t\tthis.modifiers = modifiers;\n \t}\n-\t\n+\n+/*[IF Java14]*/\n+\t/**\n+\t * Constructs a generic VarHandle instance.\n+\t *\n+\t * @param varForm an instance of VarForm.\n+\t */\n+\tVarHandle(VarForm varForm) {\n+\t\tAccessMode accessModes[] = AccessMode.values();\n+\t\tint numAccessModes = accessModes.length;\n+\n+\t\tMethodType[] operationMTs = new MethodType[numAccessModes];\n+\t\tMethodType[] operationMTsExact = null;\n+\n+\t\tMethodType getter = null;\n+\t\tMethodType setter = null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM3Mzg0MQ=="}, "originalCommit": {"oid": "f5978d5d20bedb88ca150558722bbb4556f59909"}, "originalPosition": 354}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMTU3ODQ1OnYy", "diffSide": "RIGHT", "path": "jcl/src/java.base/share/classes/java/lang/invoke/VarHandle.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxNjo0NTowMVrOFl_EMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQyMDoxMToxMFrOFmFokA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM3NDg5Nw==", "bodyText": "Can you move the declarations of operationMTs & operationMTsExact closer to this code?", "url": "https://github.com/eclipse-openj9/openj9/pull/8414#discussion_r375374897", "createdAt": "2020-02-05T16:45:01Z", "author": {"login": "DanHeidinga"}, "path": "jcl/src/java.base/share/classes/java/lang/invoke/VarHandle.java", "diffHunk": "@@ -287,7 +358,147 @@ public static AccessMode valueFromMethodName(String methodName) {\n \t\tthis.handleTable = handleTable;\n \t\tthis.modifiers = modifiers;\n \t}\n-\t\n+\n+/*[IF Java14]*/\n+\t/**\n+\t * Constructs a generic VarHandle instance.\n+\t *\n+\t * @param varForm an instance of VarForm.\n+\t */\n+\tVarHandle(VarForm varForm) {\n+\t\tAccessMode accessModes[] = AccessMode.values();\n+\t\tint numAccessModes = accessModes.length;\n+\n+\t\tMethodType[] operationMTs = new MethodType[numAccessModes];\n+\t\tMethodType[] operationMTsExact = null;\n+\n+\t\tMethodType getter = null;\n+\t\tMethodType setter = null;\n+\t\t\n+\t\tClass<?> operationsClass = null;\n+\t\t\n+\t\t/* The first argument in AccessType.GET MethodType is the receiver class. */\n+\t\tClass<?> receiverActual = accessModeTypeUncached(AccessMode.GET).parameterType(0);\n+\t\tClass<?> receiverVarForm = varForm.methodType_table[AccessType.GET.ordinal()].parameterType(0);\n+\t\t\n+\t\t/* Specify the exact operation method types if the actual receiver doesn't match the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5978d5d20bedb88ca150558722bbb4556f59909"}, "originalPosition": 362}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQwOTQzOA==", "bodyText": "yes.", "url": "https://github.com/eclipse-openj9/openj9/pull/8414#discussion_r375409438", "createdAt": "2020-02-05T17:47:51Z", "author": {"login": "babsingh"}, "path": "jcl/src/java.base/share/classes/java/lang/invoke/VarHandle.java", "diffHunk": "@@ -287,7 +358,147 @@ public static AccessMode valueFromMethodName(String methodName) {\n \t\tthis.handleTable = handleTable;\n \t\tthis.modifiers = modifiers;\n \t}\n-\t\n+\n+/*[IF Java14]*/\n+\t/**\n+\t * Constructs a generic VarHandle instance.\n+\t *\n+\t * @param varForm an instance of VarForm.\n+\t */\n+\tVarHandle(VarForm varForm) {\n+\t\tAccessMode accessModes[] = AccessMode.values();\n+\t\tint numAccessModes = accessModes.length;\n+\n+\t\tMethodType[] operationMTs = new MethodType[numAccessModes];\n+\t\tMethodType[] operationMTsExact = null;\n+\n+\t\tMethodType getter = null;\n+\t\tMethodType setter = null;\n+\t\t\n+\t\tClass<?> operationsClass = null;\n+\t\t\n+\t\t/* The first argument in AccessType.GET MethodType is the receiver class. */\n+\t\tClass<?> receiverActual = accessModeTypeUncached(AccessMode.GET).parameterType(0);\n+\t\tClass<?> receiverVarForm = varForm.methodType_table[AccessType.GET.ordinal()].parameterType(0);\n+\t\t\n+\t\t/* Specify the exact operation method types if the actual receiver doesn't match the", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM3NDg5Nw=="}, "originalCommit": {"oid": "f5978d5d20bedb88ca150558722bbb4556f59909"}, "originalPosition": 362}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQ4MjUxMg==", "bodyText": "moved closer.", "url": "https://github.com/eclipse-openj9/openj9/pull/8414#discussion_r375482512", "createdAt": "2020-02-05T20:11:10Z", "author": {"login": "babsingh"}, "path": "jcl/src/java.base/share/classes/java/lang/invoke/VarHandle.java", "diffHunk": "@@ -287,7 +358,147 @@ public static AccessMode valueFromMethodName(String methodName) {\n \t\tthis.handleTable = handleTable;\n \t\tthis.modifiers = modifiers;\n \t}\n-\t\n+\n+/*[IF Java14]*/\n+\t/**\n+\t * Constructs a generic VarHandle instance.\n+\t *\n+\t * @param varForm an instance of VarForm.\n+\t */\n+\tVarHandle(VarForm varForm) {\n+\t\tAccessMode accessModes[] = AccessMode.values();\n+\t\tint numAccessModes = accessModes.length;\n+\n+\t\tMethodType[] operationMTs = new MethodType[numAccessModes];\n+\t\tMethodType[] operationMTsExact = null;\n+\n+\t\tMethodType getter = null;\n+\t\tMethodType setter = null;\n+\t\t\n+\t\tClass<?> operationsClass = null;\n+\t\t\n+\t\t/* The first argument in AccessType.GET MethodType is the receiver class. */\n+\t\tClass<?> receiverActual = accessModeTypeUncached(AccessMode.GET).parameterType(0);\n+\t\tClass<?> receiverVarForm = varForm.methodType_table[AccessType.GET.ordinal()].parameterType(0);\n+\t\t\n+\t\t/* Specify the exact operation method types if the actual receiver doesn't match the", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM3NDg5Nw=="}, "originalCommit": {"oid": "f5978d5d20bedb88ca150558722bbb4556f59909"}, "originalPosition": 362}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMTYxMzAyOnYy", "diffSide": "RIGHT", "path": "jcl/src/java.base/share/classes/java/lang/invoke/VarHandle.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxNjo1NDoyMlrOFl_Z5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQxNDo1MToyMlrOFmdzgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM4MDQ1NQ==", "bodyText": "Is any of this data already available on the VarForm?", "url": "https://github.com/eclipse-openj9/openj9/pull/8414#discussion_r375380455", "createdAt": "2020-02-05T16:54:22Z", "author": {"login": "DanHeidinga"}, "path": "jcl/src/java.base/share/classes/java/lang/invoke/VarHandle.java", "diffHunk": "@@ -287,7 +358,147 @@ public static AccessMode valueFromMethodName(String methodName) {\n \t\tthis.handleTable = handleTable;\n \t\tthis.modifiers = modifiers;\n \t}\n-\t\n+\n+/*[IF Java14]*/\n+\t/**\n+\t * Constructs a generic VarHandle instance.\n+\t *\n+\t * @param varForm an instance of VarForm.\n+\t */\n+\tVarHandle(VarForm varForm) {\n+\t\tAccessMode accessModes[] = AccessMode.values();\n+\t\tint numAccessModes = accessModes.length;\n+\n+\t\tMethodType[] operationMTs = new MethodType[numAccessModes];\n+\t\tMethodType[] operationMTsExact = null;\n+\n+\t\tMethodType getter = null;\n+\t\tMethodType setter = null;\n+\t\t\n+\t\tClass<?> operationsClass = null;\n+\t\t\n+\t\t/* The first argument in AccessType.GET MethodType is the receiver class. */\n+\t\tClass<?> receiverActual = accessModeTypeUncached(AccessMode.GET).parameterType(0);\n+\t\tClass<?> receiverVarForm = varForm.methodType_table[AccessType.GET.ordinal()].parameterType(0);\n+\t\t\n+\t\t/* Specify the exact operation method types if the actual receiver doesn't match the\n+\t\t * receiver derived from VarForm.\n+\t\t */\n+\t\tif (receiverActual != receiverVarForm) {\n+\t\t\toperationMTsExact = new MethodType[numAccessModes];\n+\t\t}\n+\t\t\n+\t\tfor (int i = 0; i < numAccessModes; i++) {\n+\t\t\tMemberName memberName = varForm.memberName_table[i];\n+\t\t\tif (memberName != null) {\n+\t\t\t\tMethod method = memberName.method;\n+\t\t\t\tif (method != null) {\n+\t\t\t\t\toperationMTs[i] = MethodType.methodType(method.getReturnType(), method.getParameterTypes());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5978d5d20bedb88ca150558722bbb4556f59909"}, "originalPosition": 374}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQwODc0NA==", "bodyText": "No, this data is not already available in VarForm. VarForm has a list of MemberNames (one for each access mode) and a list of MethodTypes (one for each access type). Also, we use a stub implementation for MemberName where we only cache the Method passed to the constructor.", "url": "https://github.com/eclipse-openj9/openj9/pull/8414#discussion_r375408744", "createdAt": "2020-02-05T17:46:30Z", "author": {"login": "babsingh"}, "path": "jcl/src/java.base/share/classes/java/lang/invoke/VarHandle.java", "diffHunk": "@@ -287,7 +358,147 @@ public static AccessMode valueFromMethodName(String methodName) {\n \t\tthis.handleTable = handleTable;\n \t\tthis.modifiers = modifiers;\n \t}\n-\t\n+\n+/*[IF Java14]*/\n+\t/**\n+\t * Constructs a generic VarHandle instance.\n+\t *\n+\t * @param varForm an instance of VarForm.\n+\t */\n+\tVarHandle(VarForm varForm) {\n+\t\tAccessMode accessModes[] = AccessMode.values();\n+\t\tint numAccessModes = accessModes.length;\n+\n+\t\tMethodType[] operationMTs = new MethodType[numAccessModes];\n+\t\tMethodType[] operationMTsExact = null;\n+\n+\t\tMethodType getter = null;\n+\t\tMethodType setter = null;\n+\t\t\n+\t\tClass<?> operationsClass = null;\n+\t\t\n+\t\t/* The first argument in AccessType.GET MethodType is the receiver class. */\n+\t\tClass<?> receiverActual = accessModeTypeUncached(AccessMode.GET).parameterType(0);\n+\t\tClass<?> receiverVarForm = varForm.methodType_table[AccessType.GET.ordinal()].parameterType(0);\n+\t\t\n+\t\t/* Specify the exact operation method types if the actual receiver doesn't match the\n+\t\t * receiver derived from VarForm.\n+\t\t */\n+\t\tif (receiverActual != receiverVarForm) {\n+\t\t\toperationMTsExact = new MethodType[numAccessModes];\n+\t\t}\n+\t\t\n+\t\tfor (int i = 0; i < numAccessModes; i++) {\n+\t\t\tMemberName memberName = varForm.memberName_table[i];\n+\t\t\tif (memberName != null) {\n+\t\t\t\tMethod method = memberName.method;\n+\t\t\t\tif (method != null) {\n+\t\t\t\t\toperationMTs[i] = MethodType.methodType(method.getReturnType(), method.getParameterTypes());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM4MDQ1NQ=="}, "originalCommit": {"oid": "f5978d5d20bedb88ca150558722bbb4556f59909"}, "originalPosition": 374}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY1MzA4MQ==", "bodyText": "In the future, when we fully implement MemberName we should probably look at this again to see if it's still necessary or can be done more efficiently", "url": "https://github.com/eclipse-openj9/openj9/pull/8414#discussion_r375653081", "createdAt": "2020-02-06T05:59:09Z", "author": {"login": "DanHeidinga"}, "path": "jcl/src/java.base/share/classes/java/lang/invoke/VarHandle.java", "diffHunk": "@@ -287,7 +358,147 @@ public static AccessMode valueFromMethodName(String methodName) {\n \t\tthis.handleTable = handleTable;\n \t\tthis.modifiers = modifiers;\n \t}\n-\t\n+\n+/*[IF Java14]*/\n+\t/**\n+\t * Constructs a generic VarHandle instance.\n+\t *\n+\t * @param varForm an instance of VarForm.\n+\t */\n+\tVarHandle(VarForm varForm) {\n+\t\tAccessMode accessModes[] = AccessMode.values();\n+\t\tint numAccessModes = accessModes.length;\n+\n+\t\tMethodType[] operationMTs = new MethodType[numAccessModes];\n+\t\tMethodType[] operationMTsExact = null;\n+\n+\t\tMethodType getter = null;\n+\t\tMethodType setter = null;\n+\t\t\n+\t\tClass<?> operationsClass = null;\n+\t\t\n+\t\t/* The first argument in AccessType.GET MethodType is the receiver class. */\n+\t\tClass<?> receiverActual = accessModeTypeUncached(AccessMode.GET).parameterType(0);\n+\t\tClass<?> receiverVarForm = varForm.methodType_table[AccessType.GET.ordinal()].parameterType(0);\n+\t\t\n+\t\t/* Specify the exact operation method types if the actual receiver doesn't match the\n+\t\t * receiver derived from VarForm.\n+\t\t */\n+\t\tif (receiverActual != receiverVarForm) {\n+\t\t\toperationMTsExact = new MethodType[numAccessModes];\n+\t\t}\n+\t\t\n+\t\tfor (int i = 0; i < numAccessModes; i++) {\n+\t\t\tMemberName memberName = varForm.memberName_table[i];\n+\t\t\tif (memberName != null) {\n+\t\t\t\tMethod method = memberName.method;\n+\t\t\t\tif (method != null) {\n+\t\t\t\t\toperationMTs[i] = MethodType.methodType(method.getReturnType(), method.getParameterTypes());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM4MDQ1NQ=="}, "originalCommit": {"oid": "f5978d5d20bedb88ca150558722bbb4556f59909"}, "originalPosition": 374}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTg3ODUzMQ==", "bodyText": "@fengxue-IS plans to use OpenJDK MemberName and VarHandle via #7680, which is part of #7352. Minimal effort was put from an optimization side since these changes will be removed in the future.", "url": "https://github.com/eclipse-openj9/openj9/pull/8414#discussion_r375878531", "createdAt": "2020-02-06T14:51:22Z", "author": {"login": "babsingh"}, "path": "jcl/src/java.base/share/classes/java/lang/invoke/VarHandle.java", "diffHunk": "@@ -287,7 +358,147 @@ public static AccessMode valueFromMethodName(String methodName) {\n \t\tthis.handleTable = handleTable;\n \t\tthis.modifiers = modifiers;\n \t}\n-\t\n+\n+/*[IF Java14]*/\n+\t/**\n+\t * Constructs a generic VarHandle instance.\n+\t *\n+\t * @param varForm an instance of VarForm.\n+\t */\n+\tVarHandle(VarForm varForm) {\n+\t\tAccessMode accessModes[] = AccessMode.values();\n+\t\tint numAccessModes = accessModes.length;\n+\n+\t\tMethodType[] operationMTs = new MethodType[numAccessModes];\n+\t\tMethodType[] operationMTsExact = null;\n+\n+\t\tMethodType getter = null;\n+\t\tMethodType setter = null;\n+\t\t\n+\t\tClass<?> operationsClass = null;\n+\t\t\n+\t\t/* The first argument in AccessType.GET MethodType is the receiver class. */\n+\t\tClass<?> receiverActual = accessModeTypeUncached(AccessMode.GET).parameterType(0);\n+\t\tClass<?> receiverVarForm = varForm.methodType_table[AccessType.GET.ordinal()].parameterType(0);\n+\t\t\n+\t\t/* Specify the exact operation method types if the actual receiver doesn't match the\n+\t\t * receiver derived from VarForm.\n+\t\t */\n+\t\tif (receiverActual != receiverVarForm) {\n+\t\t\toperationMTsExact = new MethodType[numAccessModes];\n+\t\t}\n+\t\t\n+\t\tfor (int i = 0; i < numAccessModes; i++) {\n+\t\t\tMemberName memberName = varForm.memberName_table[i];\n+\t\t\tif (memberName != null) {\n+\t\t\t\tMethod method = memberName.method;\n+\t\t\t\tif (method != null) {\n+\t\t\t\t\toperationMTs[i] = MethodType.methodType(method.getReturnType(), method.getParameterTypes());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM4MDQ1NQ=="}, "originalCommit": {"oid": "f5978d5d20bedb88ca150558722bbb4556f59909"}, "originalPosition": 374}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMTYyNDA0OnYy", "diffSide": "RIGHT", "path": "runtime/jcl/common/sun_misc_Unsafe.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxNjo1NzoxM1rOFl_gow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxNzoxODowOFrOFmAQIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM4MjE3OQ==", "bodyText": "Needs a null check to ensure the memory is successfully allocated", "url": "https://github.com/eclipse-openj9/openj9/pull/8414#discussion_r375382179", "createdAt": "2020-02-05T16:57:13Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/sun_misc_Unsafe.cpp", "diffHunk": "@@ -96,19 +95,66 @@ Java_sun_misc_Unsafe_defineAnonymousClass(JNIEnv *env, jobject receiver, jclass\n \t\thostClassLoader = vm->systemClassLoader->classLoaderObject;\n \t}\n \tjobject hostClassLoaderLocalRef = vmFuncs->j9jni_createLocalRef(env, hostClassLoader);\n+\n+\tJ9ClassPatchMap cpPatchMap = {0, NULL};\n+\tj9array_t patchArray = NULL;\n+\tPORT_ACCESS_FROM_ENV(env);\n+\n+\tU_16 indexMap[BUFFER_SIZE];\n+\tif (constPatches != NULL) {\n+\t\tpatchArray = (j9array_t)J9_JNI_UNWRAP_REFERENCE(constPatches);\n+\t\tcpPatchMap.size = (U_16)J9INDEXABLEOBJECT_SIZE(currentThread, patchArray);\n+\t\tif (cpPatchMap.size <= BUFFER_SIZE) {\n+\t\t\tcpPatchMap.indexMap = indexMap;\n+\t\t} else {\n+\t\t\tcpPatchMap.indexMap = (U_16 *)j9mem_allocate_memory(cpPatchMap.size * sizeof(U_16), J9MEM_CATEGORY_VM);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5978d5d20bedb88ca150558722bbb4556f59909"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM5NDMzOQ==", "bodyText": "These are @fengxue-IS changes for Constant Pool Patching (#8460). These should go away after #8460 is merged, and this pull request is rebased. Only the seven commits listed in the header description need to be reviewed for this pull request.", "url": "https://github.com/eclipse-openj9/openj9/pull/8414#discussion_r375394339", "createdAt": "2020-02-05T17:18:08Z", "author": {"login": "babsingh"}, "path": "runtime/jcl/common/sun_misc_Unsafe.cpp", "diffHunk": "@@ -96,19 +95,66 @@ Java_sun_misc_Unsafe_defineAnonymousClass(JNIEnv *env, jobject receiver, jclass\n \t\thostClassLoader = vm->systemClassLoader->classLoaderObject;\n \t}\n \tjobject hostClassLoaderLocalRef = vmFuncs->j9jni_createLocalRef(env, hostClassLoader);\n+\n+\tJ9ClassPatchMap cpPatchMap = {0, NULL};\n+\tj9array_t patchArray = NULL;\n+\tPORT_ACCESS_FROM_ENV(env);\n+\n+\tU_16 indexMap[BUFFER_SIZE];\n+\tif (constPatches != NULL) {\n+\t\tpatchArray = (j9array_t)J9_JNI_UNWRAP_REFERENCE(constPatches);\n+\t\tcpPatchMap.size = (U_16)J9INDEXABLEOBJECT_SIZE(currentThread, patchArray);\n+\t\tif (cpPatchMap.size <= BUFFER_SIZE) {\n+\t\t\tcpPatchMap.indexMap = indexMap;\n+\t\t} else {\n+\t\t\tcpPatchMap.indexMap = (U_16 *)j9mem_allocate_memory(cpPatchMap.size * sizeof(U_16), J9MEM_CATEGORY_VM);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM4MjE3OQ=="}, "originalCommit": {"oid": "f5978d5d20bedb88ca150558722bbb4556f59909"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMTYyNzYxOnYy", "diffSide": "RIGHT", "path": "runtime/jcl/common/sun_misc_Unsafe.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxNjo1ODowOVrOFl_i5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxNzoxODowM1rOFmAP5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM4Mjc1OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\titem = J9JAVAARRAYOFOBJECT_LOAD(currentThread, patchArray, i);\n          \n          \n            \n            \t\t\tj9object_t item = J9JAVAARRAYOFOBJECT_LOAD(currentThread, patchArray, i);\n          \n      \n    \n    \n  \n\nMove the declaration to here", "url": "https://github.com/eclipse-openj9/openj9/pull/8414#discussion_r375382758", "createdAt": "2020-02-05T16:58:09Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/sun_misc_Unsafe.cpp", "diffHunk": "@@ -96,19 +95,66 @@ Java_sun_misc_Unsafe_defineAnonymousClass(JNIEnv *env, jobject receiver, jclass\n \t\thostClassLoader = vm->systemClassLoader->classLoaderObject;\n \t}\n \tjobject hostClassLoaderLocalRef = vmFuncs->j9jni_createLocalRef(env, hostClassLoader);\n+\n+\tJ9ClassPatchMap cpPatchMap = {0, NULL};\n+\tj9array_t patchArray = NULL;\n+\tPORT_ACCESS_FROM_ENV(env);\n+\n+\tU_16 indexMap[BUFFER_SIZE];\n+\tif (constPatches != NULL) {\n+\t\tpatchArray = (j9array_t)J9_JNI_UNWRAP_REFERENCE(constPatches);\n+\t\tcpPatchMap.size = (U_16)J9INDEXABLEOBJECT_SIZE(currentThread, patchArray);\n+\t\tif (cpPatchMap.size <= BUFFER_SIZE) {\n+\t\t\tcpPatchMap.indexMap = indexMap;\n+\t\t} else {\n+\t\t\tcpPatchMap.indexMap = (U_16 *)j9mem_allocate_memory(cpPatchMap.size * sizeof(U_16), J9MEM_CATEGORY_VM);\n+\t\t}\n+\t}\n+\n \tvmFuncs->internalExitVMToJNI(currentThread);\n \n \tjsize length = env->GetArrayLength(bytecodes);\n \n \t/* acquires access internally */\n-\tjclass anonClass = defineClassCommon(env, hostClassLoaderLocalRef, NULL,bytecodes, 0, length, protectionDomainLocalRef, J9_FINDCLASS_FLAG_UNSAFE | J9_FINDCLASS_FLAG_ANON, hostClazz);\n+\tjclass anonClass = defineClassCommon(env, hostClassLoaderLocalRef, NULL,bytecodes, 0, length, protectionDomainLocalRef, J9_FINDCLASS_FLAG_UNSAFE | J9_FINDCLASS_FLAG_ANON, hostClazz, &cpPatchMap);\n \tif (env->ExceptionCheck()) {\n \t\treturn NULL;\n \t} else if (NULL == anonClass) {\n \t\tthrowNewInternalError(env, NULL);\n \t\treturn NULL;\n \t}\n \n+\tif (constPatches != NULL) {\n+\t\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\t\tJ9Class *clazz = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, J9_JNI_UNWRAP_REFERENCE(anonClass));\n+\n+\t\tj9object_t item = NULL;\n+\t\tU_32 *cpShapeDescription = J9ROMCLASS_CPSHAPEDESCRIPTION(clazz->romClass);\n+\t\tJ9ConstantPool *ramCP = J9_CP_FROM_CLASS(clazz);\n+\t\tJ9ROMConstantPoolItem *romCP = ramCP->romConstantPool;\n+\n+\t\tfor (U_16 i = 0; i < cpPatchMap.size; i++) {\n+\t\t\titem = J9JAVAARRAYOFOBJECT_LOAD(currentThread, patchArray, i);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5978d5d20bedb88ca150558722bbb4556f59909"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM5NDI3OQ==", "bodyText": "These are @fengxue-IS changes for Constant Pool Patching (#8460). These should go away after #8460 is merged, and this pull request is rebased. Only the seven commits listed in the header description need to be reviewed for this pull request.", "url": "https://github.com/eclipse-openj9/openj9/pull/8414#discussion_r375394279", "createdAt": "2020-02-05T17:18:03Z", "author": {"login": "babsingh"}, "path": "runtime/jcl/common/sun_misc_Unsafe.cpp", "diffHunk": "@@ -96,19 +95,66 @@ Java_sun_misc_Unsafe_defineAnonymousClass(JNIEnv *env, jobject receiver, jclass\n \t\thostClassLoader = vm->systemClassLoader->classLoaderObject;\n \t}\n \tjobject hostClassLoaderLocalRef = vmFuncs->j9jni_createLocalRef(env, hostClassLoader);\n+\n+\tJ9ClassPatchMap cpPatchMap = {0, NULL};\n+\tj9array_t patchArray = NULL;\n+\tPORT_ACCESS_FROM_ENV(env);\n+\n+\tU_16 indexMap[BUFFER_SIZE];\n+\tif (constPatches != NULL) {\n+\t\tpatchArray = (j9array_t)J9_JNI_UNWRAP_REFERENCE(constPatches);\n+\t\tcpPatchMap.size = (U_16)J9INDEXABLEOBJECT_SIZE(currentThread, patchArray);\n+\t\tif (cpPatchMap.size <= BUFFER_SIZE) {\n+\t\t\tcpPatchMap.indexMap = indexMap;\n+\t\t} else {\n+\t\t\tcpPatchMap.indexMap = (U_16 *)j9mem_allocate_memory(cpPatchMap.size * sizeof(U_16), J9MEM_CATEGORY_VM);\n+\t\t}\n+\t}\n+\n \tvmFuncs->internalExitVMToJNI(currentThread);\n \n \tjsize length = env->GetArrayLength(bytecodes);\n \n \t/* acquires access internally */\n-\tjclass anonClass = defineClassCommon(env, hostClassLoaderLocalRef, NULL,bytecodes, 0, length, protectionDomainLocalRef, J9_FINDCLASS_FLAG_UNSAFE | J9_FINDCLASS_FLAG_ANON, hostClazz);\n+\tjclass anonClass = defineClassCommon(env, hostClassLoaderLocalRef, NULL,bytecodes, 0, length, protectionDomainLocalRef, J9_FINDCLASS_FLAG_UNSAFE | J9_FINDCLASS_FLAG_ANON, hostClazz, &cpPatchMap);\n \tif (env->ExceptionCheck()) {\n \t\treturn NULL;\n \t} else if (NULL == anonClass) {\n \t\tthrowNewInternalError(env, NULL);\n \t\treturn NULL;\n \t}\n \n+\tif (constPatches != NULL) {\n+\t\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\t\tJ9Class *clazz = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, J9_JNI_UNWRAP_REFERENCE(anonClass));\n+\n+\t\tj9object_t item = NULL;\n+\t\tU_32 *cpShapeDescription = J9ROMCLASS_CPSHAPEDESCRIPTION(clazz->romClass);\n+\t\tJ9ConstantPool *ramCP = J9_CP_FROM_CLASS(clazz);\n+\t\tJ9ROMConstantPoolItem *romCP = ramCP->romConstantPool;\n+\n+\t\tfor (U_16 i = 0; i < cpPatchMap.size; i++) {\n+\t\t\titem = J9JAVAARRAYOFOBJECT_LOAD(currentThread, patchArray, i);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM4Mjc1OA=="}, "originalCommit": {"oid": "f5978d5d20bedb88ca150558722bbb4556f59909"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMTYzMzAwOnYy", "diffSide": "RIGHT", "path": "runtime/jcl/common/sun_misc_Unsafe.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxNjo1OToyOVrOFl_mRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxNzoxNzozOFrOFmAO_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM4MzYyMg==", "bodyText": "Can you add a comment explaining why this is walking the whole CP?  I know the reason now but won't remember by the next time I look at the code...", "url": "https://github.com/eclipse-openj9/openj9/pull/8414#discussion_r375383622", "createdAt": "2020-02-05T16:59:29Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/sun_misc_Unsafe.cpp", "diffHunk": "@@ -96,19 +95,66 @@ Java_sun_misc_Unsafe_defineAnonymousClass(JNIEnv *env, jobject receiver, jclass\n \t\thostClassLoader = vm->systemClassLoader->classLoaderObject;\n \t}\n \tjobject hostClassLoaderLocalRef = vmFuncs->j9jni_createLocalRef(env, hostClassLoader);\n+\n+\tJ9ClassPatchMap cpPatchMap = {0, NULL};\n+\tj9array_t patchArray = NULL;\n+\tPORT_ACCESS_FROM_ENV(env);\n+\n+\tU_16 indexMap[BUFFER_SIZE];\n+\tif (constPatches != NULL) {\n+\t\tpatchArray = (j9array_t)J9_JNI_UNWRAP_REFERENCE(constPatches);\n+\t\tcpPatchMap.size = (U_16)J9INDEXABLEOBJECT_SIZE(currentThread, patchArray);\n+\t\tif (cpPatchMap.size <= BUFFER_SIZE) {\n+\t\t\tcpPatchMap.indexMap = indexMap;\n+\t\t} else {\n+\t\t\tcpPatchMap.indexMap = (U_16 *)j9mem_allocate_memory(cpPatchMap.size * sizeof(U_16), J9MEM_CATEGORY_VM);\n+\t\t}\n+\t}\n+\n \tvmFuncs->internalExitVMToJNI(currentThread);\n \n \tjsize length = env->GetArrayLength(bytecodes);\n \n \t/* acquires access internally */\n-\tjclass anonClass = defineClassCommon(env, hostClassLoaderLocalRef, NULL,bytecodes, 0, length, protectionDomainLocalRef, J9_FINDCLASS_FLAG_UNSAFE | J9_FINDCLASS_FLAG_ANON, hostClazz);\n+\tjclass anonClass = defineClassCommon(env, hostClassLoaderLocalRef, NULL,bytecodes, 0, length, protectionDomainLocalRef, J9_FINDCLASS_FLAG_UNSAFE | J9_FINDCLASS_FLAG_ANON, hostClazz, &cpPatchMap);\n \tif (env->ExceptionCheck()) {\n \t\treturn NULL;\n \t} else if (NULL == anonClass) {\n \t\tthrowNewInternalError(env, NULL);\n \t\treturn NULL;\n \t}\n \n+\tif (constPatches != NULL) {\n+\t\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\t\tJ9Class *clazz = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, J9_JNI_UNWRAP_REFERENCE(anonClass));\n+\n+\t\tj9object_t item = NULL;\n+\t\tU_32 *cpShapeDescription = J9ROMCLASS_CPSHAPEDESCRIPTION(clazz->romClass);\n+\t\tJ9ConstantPool *ramCP = J9_CP_FROM_CLASS(clazz);\n+\t\tJ9ROMConstantPoolItem *romCP = ramCP->romConstantPool;\n+\n+\t\tfor (U_16 i = 0; i < cpPatchMap.size; i++) {\n+\t\t\titem = J9JAVAARRAYOFOBJECT_LOAD(currentThread, patchArray, i);\n+\t\t\tif ((item != NULL) && (J9_CP_TYPE(cpShapeDescription, cpPatchMap.indexMap[i]) == J9CPTYPE_STRING)) {\n+\t\t\t\tJ9UTF8 *romString = J9ROMSTRINGREF_UTF8DATA((J9ROMStringRef *)&romCP[cpPatchMap.indexMap[i]]);\n+\n+\t\t\t\tfor (U_16 j = 1; j < clazz->romClass->ramConstantPoolCount; j++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5978d5d20bedb88ca150558722bbb4556f59909"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM5NDA0NA==", "bodyText": "These are @fengxue-IS changes for Constant Pool Patching (#8460). These should go away after #8460 is merged, and this pull request is rebased. Only the seven commits listed in the header description need to be reviewed for this pull request.", "url": "https://github.com/eclipse-openj9/openj9/pull/8414#discussion_r375394044", "createdAt": "2020-02-05T17:17:38Z", "author": {"login": "babsingh"}, "path": "runtime/jcl/common/sun_misc_Unsafe.cpp", "diffHunk": "@@ -96,19 +95,66 @@ Java_sun_misc_Unsafe_defineAnonymousClass(JNIEnv *env, jobject receiver, jclass\n \t\thostClassLoader = vm->systemClassLoader->classLoaderObject;\n \t}\n \tjobject hostClassLoaderLocalRef = vmFuncs->j9jni_createLocalRef(env, hostClassLoader);\n+\n+\tJ9ClassPatchMap cpPatchMap = {0, NULL};\n+\tj9array_t patchArray = NULL;\n+\tPORT_ACCESS_FROM_ENV(env);\n+\n+\tU_16 indexMap[BUFFER_SIZE];\n+\tif (constPatches != NULL) {\n+\t\tpatchArray = (j9array_t)J9_JNI_UNWRAP_REFERENCE(constPatches);\n+\t\tcpPatchMap.size = (U_16)J9INDEXABLEOBJECT_SIZE(currentThread, patchArray);\n+\t\tif (cpPatchMap.size <= BUFFER_SIZE) {\n+\t\t\tcpPatchMap.indexMap = indexMap;\n+\t\t} else {\n+\t\t\tcpPatchMap.indexMap = (U_16 *)j9mem_allocate_memory(cpPatchMap.size * sizeof(U_16), J9MEM_CATEGORY_VM);\n+\t\t}\n+\t}\n+\n \tvmFuncs->internalExitVMToJNI(currentThread);\n \n \tjsize length = env->GetArrayLength(bytecodes);\n \n \t/* acquires access internally */\n-\tjclass anonClass = defineClassCommon(env, hostClassLoaderLocalRef, NULL,bytecodes, 0, length, protectionDomainLocalRef, J9_FINDCLASS_FLAG_UNSAFE | J9_FINDCLASS_FLAG_ANON, hostClazz);\n+\tjclass anonClass = defineClassCommon(env, hostClassLoaderLocalRef, NULL,bytecodes, 0, length, protectionDomainLocalRef, J9_FINDCLASS_FLAG_UNSAFE | J9_FINDCLASS_FLAG_ANON, hostClazz, &cpPatchMap);\n \tif (env->ExceptionCheck()) {\n \t\treturn NULL;\n \t} else if (NULL == anonClass) {\n \t\tthrowNewInternalError(env, NULL);\n \t\treturn NULL;\n \t}\n \n+\tif (constPatches != NULL) {\n+\t\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\t\tJ9Class *clazz = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, J9_JNI_UNWRAP_REFERENCE(anonClass));\n+\n+\t\tj9object_t item = NULL;\n+\t\tU_32 *cpShapeDescription = J9ROMCLASS_CPSHAPEDESCRIPTION(clazz->romClass);\n+\t\tJ9ConstantPool *ramCP = J9_CP_FROM_CLASS(clazz);\n+\t\tJ9ROMConstantPoolItem *romCP = ramCP->romConstantPool;\n+\n+\t\tfor (U_16 i = 0; i < cpPatchMap.size; i++) {\n+\t\t\titem = J9JAVAARRAYOFOBJECT_LOAD(currentThread, patchArray, i);\n+\t\t\tif ((item != NULL) && (J9_CP_TYPE(cpShapeDescription, cpPatchMap.indexMap[i]) == J9CPTYPE_STRING)) {\n+\t\t\t\tJ9UTF8 *romString = J9ROMSTRINGREF_UTF8DATA((J9ROMStringRef *)&romCP[cpPatchMap.indexMap[i]]);\n+\n+\t\t\t\tfor (U_16 j = 1; j < clazz->romClass->ramConstantPoolCount; j++) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM4MzYyMg=="}, "originalCommit": {"oid": "f5978d5d20bedb88ca150558722bbb4556f59909"}, "originalPosition": 83}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMTYzNTQwOnYy", "diffSide": "RIGHT", "path": "runtime/jcl/common/sun_misc_Unsafe.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxNzowMDoxMVrOFl_nyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxNzoxNzoyNVrOFmAObA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM4NDAwOQ==", "bodyText": "Good practice to immediately cpPatchMap.indexMap = NULL here", "url": "https://github.com/eclipse-openj9/openj9/pull/8414#discussion_r375384009", "createdAt": "2020-02-05T17:00:11Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/sun_misc_Unsafe.cpp", "diffHunk": "@@ -96,19 +95,66 @@ Java_sun_misc_Unsafe_defineAnonymousClass(JNIEnv *env, jobject receiver, jclass\n \t\thostClassLoader = vm->systemClassLoader->classLoaderObject;\n \t}\n \tjobject hostClassLoaderLocalRef = vmFuncs->j9jni_createLocalRef(env, hostClassLoader);\n+\n+\tJ9ClassPatchMap cpPatchMap = {0, NULL};\n+\tj9array_t patchArray = NULL;\n+\tPORT_ACCESS_FROM_ENV(env);\n+\n+\tU_16 indexMap[BUFFER_SIZE];\n+\tif (constPatches != NULL) {\n+\t\tpatchArray = (j9array_t)J9_JNI_UNWRAP_REFERENCE(constPatches);\n+\t\tcpPatchMap.size = (U_16)J9INDEXABLEOBJECT_SIZE(currentThread, patchArray);\n+\t\tif (cpPatchMap.size <= BUFFER_SIZE) {\n+\t\t\tcpPatchMap.indexMap = indexMap;\n+\t\t} else {\n+\t\t\tcpPatchMap.indexMap = (U_16 *)j9mem_allocate_memory(cpPatchMap.size * sizeof(U_16), J9MEM_CATEGORY_VM);\n+\t\t}\n+\t}\n+\n \tvmFuncs->internalExitVMToJNI(currentThread);\n \n \tjsize length = env->GetArrayLength(bytecodes);\n \n \t/* acquires access internally */\n-\tjclass anonClass = defineClassCommon(env, hostClassLoaderLocalRef, NULL,bytecodes, 0, length, protectionDomainLocalRef, J9_FINDCLASS_FLAG_UNSAFE | J9_FINDCLASS_FLAG_ANON, hostClazz);\n+\tjclass anonClass = defineClassCommon(env, hostClassLoaderLocalRef, NULL,bytecodes, 0, length, protectionDomainLocalRef, J9_FINDCLASS_FLAG_UNSAFE | J9_FINDCLASS_FLAG_ANON, hostClazz, &cpPatchMap);\n \tif (env->ExceptionCheck()) {\n \t\treturn NULL;\n \t} else if (NULL == anonClass) {\n \t\tthrowNewInternalError(env, NULL);\n \t\treturn NULL;\n \t}\n \n+\tif (constPatches != NULL) {\n+\t\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\t\tJ9Class *clazz = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, J9_JNI_UNWRAP_REFERENCE(anonClass));\n+\n+\t\tj9object_t item = NULL;\n+\t\tU_32 *cpShapeDescription = J9ROMCLASS_CPSHAPEDESCRIPTION(clazz->romClass);\n+\t\tJ9ConstantPool *ramCP = J9_CP_FROM_CLASS(clazz);\n+\t\tJ9ROMConstantPoolItem *romCP = ramCP->romConstantPool;\n+\n+\t\tfor (U_16 i = 0; i < cpPatchMap.size; i++) {\n+\t\t\titem = J9JAVAARRAYOFOBJECT_LOAD(currentThread, patchArray, i);\n+\t\t\tif ((item != NULL) && (J9_CP_TYPE(cpShapeDescription, cpPatchMap.indexMap[i]) == J9CPTYPE_STRING)) {\n+\t\t\t\tJ9UTF8 *romString = J9ROMSTRINGREF_UTF8DATA((J9ROMStringRef *)&romCP[cpPatchMap.indexMap[i]]);\n+\n+\t\t\t\tfor (U_16 j = 1; j < clazz->romClass->ramConstantPoolCount; j++) {\n+\t\t\t\t\tif ((J9_CP_TYPE(cpShapeDescription, j) == J9CPTYPE_STRING)\n+\t\t\t\t\t\t&& J9UTF8_EQUALS(romString, J9ROMSTRINGREF_UTF8DATA((J9ROMStringRef *)&romCP[j]))\n+\t\t\t\t\t) {\n+\t\t\t\t\t\tJ9RAMStringRef *ramStringRef = ((J9RAMStringRef *)ramCP) + j;\n+\t\t\t\t\t\tJ9STATIC_OBJECT_STORE(currentThread, clazz, &ramStringRef->stringObject, item);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (cpPatchMap.size > BUFFER_SIZE) {\n+\t\t\tj9mem_free_memory(cpPatchMap.indexMap);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5978d5d20bedb88ca150558722bbb4556f59909"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM5MzkwMA==", "bodyText": "These are @fengxue-IS changes for Constant Pool Patching (#8460). These should go away after #8460 is merged, and this pull request is rebased. Only the seven commits listed in the header description need to be reviewed for this pull request.", "url": "https://github.com/eclipse-openj9/openj9/pull/8414#discussion_r375393900", "createdAt": "2020-02-05T17:17:25Z", "author": {"login": "babsingh"}, "path": "runtime/jcl/common/sun_misc_Unsafe.cpp", "diffHunk": "@@ -96,19 +95,66 @@ Java_sun_misc_Unsafe_defineAnonymousClass(JNIEnv *env, jobject receiver, jclass\n \t\thostClassLoader = vm->systemClassLoader->classLoaderObject;\n \t}\n \tjobject hostClassLoaderLocalRef = vmFuncs->j9jni_createLocalRef(env, hostClassLoader);\n+\n+\tJ9ClassPatchMap cpPatchMap = {0, NULL};\n+\tj9array_t patchArray = NULL;\n+\tPORT_ACCESS_FROM_ENV(env);\n+\n+\tU_16 indexMap[BUFFER_SIZE];\n+\tif (constPatches != NULL) {\n+\t\tpatchArray = (j9array_t)J9_JNI_UNWRAP_REFERENCE(constPatches);\n+\t\tcpPatchMap.size = (U_16)J9INDEXABLEOBJECT_SIZE(currentThread, patchArray);\n+\t\tif (cpPatchMap.size <= BUFFER_SIZE) {\n+\t\t\tcpPatchMap.indexMap = indexMap;\n+\t\t} else {\n+\t\t\tcpPatchMap.indexMap = (U_16 *)j9mem_allocate_memory(cpPatchMap.size * sizeof(U_16), J9MEM_CATEGORY_VM);\n+\t\t}\n+\t}\n+\n \tvmFuncs->internalExitVMToJNI(currentThread);\n \n \tjsize length = env->GetArrayLength(bytecodes);\n \n \t/* acquires access internally */\n-\tjclass anonClass = defineClassCommon(env, hostClassLoaderLocalRef, NULL,bytecodes, 0, length, protectionDomainLocalRef, J9_FINDCLASS_FLAG_UNSAFE | J9_FINDCLASS_FLAG_ANON, hostClazz);\n+\tjclass anonClass = defineClassCommon(env, hostClassLoaderLocalRef, NULL,bytecodes, 0, length, protectionDomainLocalRef, J9_FINDCLASS_FLAG_UNSAFE | J9_FINDCLASS_FLAG_ANON, hostClazz, &cpPatchMap);\n \tif (env->ExceptionCheck()) {\n \t\treturn NULL;\n \t} else if (NULL == anonClass) {\n \t\tthrowNewInternalError(env, NULL);\n \t\treturn NULL;\n \t}\n \n+\tif (constPatches != NULL) {\n+\t\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\t\tJ9Class *clazz = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, J9_JNI_UNWRAP_REFERENCE(anonClass));\n+\n+\t\tj9object_t item = NULL;\n+\t\tU_32 *cpShapeDescription = J9ROMCLASS_CPSHAPEDESCRIPTION(clazz->romClass);\n+\t\tJ9ConstantPool *ramCP = J9_CP_FROM_CLASS(clazz);\n+\t\tJ9ROMConstantPoolItem *romCP = ramCP->romConstantPool;\n+\n+\t\tfor (U_16 i = 0; i < cpPatchMap.size; i++) {\n+\t\t\titem = J9JAVAARRAYOFOBJECT_LOAD(currentThread, patchArray, i);\n+\t\t\tif ((item != NULL) && (J9_CP_TYPE(cpShapeDescription, cpPatchMap.indexMap[i]) == J9CPTYPE_STRING)) {\n+\t\t\t\tJ9UTF8 *romString = J9ROMSTRINGREF_UTF8DATA((J9ROMStringRef *)&romCP[cpPatchMap.indexMap[i]]);\n+\n+\t\t\t\tfor (U_16 j = 1; j < clazz->romClass->ramConstantPoolCount; j++) {\n+\t\t\t\t\tif ((J9_CP_TYPE(cpShapeDescription, j) == J9CPTYPE_STRING)\n+\t\t\t\t\t\t&& J9UTF8_EQUALS(romString, J9ROMSTRINGREF_UTF8DATA((J9ROMStringRef *)&romCP[j]))\n+\t\t\t\t\t) {\n+\t\t\t\t\t\tJ9RAMStringRef *ramStringRef = ((J9RAMStringRef *)ramCP) + j;\n+\t\t\t\t\t\tJ9STATIC_OBJECT_STORE(currentThread, clazz, &ramStringRef->stringObject, item);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (cpPatchMap.size > BUFFER_SIZE) {\n+\t\t\tj9mem_free_memory(cpPatchMap.indexMap);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM4NDAwOQ=="}, "originalCommit": {"oid": "f5978d5d20bedb88ca150558722bbb4556f59909"}, "originalPosition": 95}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NDMwMjEyOnYy", "diffSide": "RIGHT", "path": "jcl/src/java.base/share/classes/java/lang/invoke/VarHandle.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxNDozOToxMFrOFpWPnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxNTowMToyOVrOFpXIrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODkwMDM4MQ==", "bodyText": "Is this used?", "url": "https://github.com/eclipse-openj9/openj9/pull/8414#discussion_r378900381", "createdAt": "2020-02-13T14:39:10Z", "author": {"login": "DanHeidinga"}, "path": "jcl/src/java.base/share/classes/java/lang/invoke/VarHandle.java", "diffHunk": "@@ -269,13 +276,65 @@ public static AccessMode valueFromMethodName(String methodName) {\n \t\tCOMPARE_AND_EXCHANGE,\n \t\tGET_AND_UPDATE;\n \n-\t\tMethodType accessModeType(Class<?> param1, Class<?> param2, Class<?>... params) {\n-\t\t\tthrow OpenJDKCompileStub.OpenJDKCompileStubThrowError();\n+\t\t/**\n+\t\t * Gets the MethodType associated with the AccessType.\n+\t\t * \n+\t\t * This method gets invoked by the derived VarHandle classes through accessModeTypeUncached.\n+\t\t * \n+\t\t * OpenJ9 only uses it to retrieve the receiver class, which is not available from VarForm.\n+\t\t * \n+\t\t * @param receiver class of the derived VarHandle.\n+\t\t * @param type is the field type or value type.\n+\t\t * @param args is the list of intermediate argument classes in the derived VarHandle's\n+\t\t * AccessMode methods.\n+\t\t * @return the MethodType for the corresponding AccessType.\n+\t\t */\n+\t\tMethodType accessModeType(Class<?> receiver, Class<?> type, Class<?>... args) {\n+\t\t\tList<Class<?>> paramList = new ArrayList<>();\n+\t\t\tClass<?> returnType = null;\n+\t\t\tswitch (this) {\n+\t\t\tcase GET:\n+\t\t\t\treturnType = type;\n+\t\t\t\tparamList.add(receiver);\n+\t\t\t\tCollections.addAll(paramList, args);\n+\t\t\t\tbreak;\n+\t\t\tcase SET:\n+\t\t\t\treturnType = void.class;\n+\t\t\t\tparamList.add(receiver);\n+\t\t\t\tCollections.addAll(paramList, args);\n+\t\t\t\tparamList.add(type);\n+\t\t\t\tbreak;\n+\t\t\tcase COMPARE_AND_SET:\n+\t\t\t\treturnType = boolean.class;\n+\t\t\t\tparamList.add(receiver);\n+\t\t\t\tCollections.addAll(paramList, args);\n+\t\t\t\tCollections.addAll(paramList, type, type);\n+\t\t\t\tbreak;\n+\t\t\tcase COMPARE_AND_EXCHANGE:\n+\t\t\t\treturnType = type;\n+\t\t\t\tparamList.add(receiver);\n+\t\t\t\tCollections.addAll(paramList, args);\n+\t\t\t\tCollections.addAll(paramList, type, type);\n+\t\t\t\tbreak;\n+\t\t\tcase GET_AND_UPDATE:\n+\t\t\t\treturnType = type;\n+\t\t\t\tparamList.add(receiver);\n+\t\t\t\tCollections.addAll(paramList, args);\n+\t\t\t\tparamList.add(type);\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tthrow new InternalError(\"Invalid AccessType.\");\n+\t\t\t}\n+\t\t\treturn MethodType.methodType(returnType, paramList);\n \t\t}\n \t}\n \t\n \tstatic final Unsafe _unsafe = Unsafe.getUnsafe();\n \tstatic final Lookup _lookup = Lookup.internalPrivilegedLookup;\n+\n+/*[IF Java14]*/\n+\tstatic final BiFunction<String, List<Integer>, ArrayIndexOutOfBoundsException> AIOOBE_SUPPLIER = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "604dd591f5a2ae2d22dc0c1cbe46cf2065eee38e"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODkxNDk4OQ==", "bodyText": "OpenJDK VarHandle<Type> classes (X-VarHandle.java.template; generated Java code) utilizes AIOOBE_SUPPLIER. OpenJ9 doesn't use the generated Java code from X-VarHandle.java.template since it has its own implementation. So, AIOOBE_SUPPLIER is left uninitialized in OpenJ9's VarHandle class.", "url": "https://github.com/eclipse-openj9/openj9/pull/8414#discussion_r378914989", "createdAt": "2020-02-13T15:01:29Z", "author": {"login": "babsingh"}, "path": "jcl/src/java.base/share/classes/java/lang/invoke/VarHandle.java", "diffHunk": "@@ -269,13 +276,65 @@ public static AccessMode valueFromMethodName(String methodName) {\n \t\tCOMPARE_AND_EXCHANGE,\n \t\tGET_AND_UPDATE;\n \n-\t\tMethodType accessModeType(Class<?> param1, Class<?> param2, Class<?>... params) {\n-\t\t\tthrow OpenJDKCompileStub.OpenJDKCompileStubThrowError();\n+\t\t/**\n+\t\t * Gets the MethodType associated with the AccessType.\n+\t\t * \n+\t\t * This method gets invoked by the derived VarHandle classes through accessModeTypeUncached.\n+\t\t * \n+\t\t * OpenJ9 only uses it to retrieve the receiver class, which is not available from VarForm.\n+\t\t * \n+\t\t * @param receiver class of the derived VarHandle.\n+\t\t * @param type is the field type or value type.\n+\t\t * @param args is the list of intermediate argument classes in the derived VarHandle's\n+\t\t * AccessMode methods.\n+\t\t * @return the MethodType for the corresponding AccessType.\n+\t\t */\n+\t\tMethodType accessModeType(Class<?> receiver, Class<?> type, Class<?>... args) {\n+\t\t\tList<Class<?>> paramList = new ArrayList<>();\n+\t\t\tClass<?> returnType = null;\n+\t\t\tswitch (this) {\n+\t\t\tcase GET:\n+\t\t\t\treturnType = type;\n+\t\t\t\tparamList.add(receiver);\n+\t\t\t\tCollections.addAll(paramList, args);\n+\t\t\t\tbreak;\n+\t\t\tcase SET:\n+\t\t\t\treturnType = void.class;\n+\t\t\t\tparamList.add(receiver);\n+\t\t\t\tCollections.addAll(paramList, args);\n+\t\t\t\tparamList.add(type);\n+\t\t\t\tbreak;\n+\t\t\tcase COMPARE_AND_SET:\n+\t\t\t\treturnType = boolean.class;\n+\t\t\t\tparamList.add(receiver);\n+\t\t\t\tCollections.addAll(paramList, args);\n+\t\t\t\tCollections.addAll(paramList, type, type);\n+\t\t\t\tbreak;\n+\t\t\tcase COMPARE_AND_EXCHANGE:\n+\t\t\t\treturnType = type;\n+\t\t\t\tparamList.add(receiver);\n+\t\t\t\tCollections.addAll(paramList, args);\n+\t\t\t\tCollections.addAll(paramList, type, type);\n+\t\t\t\tbreak;\n+\t\t\tcase GET_AND_UPDATE:\n+\t\t\t\treturnType = type;\n+\t\t\t\tparamList.add(receiver);\n+\t\t\t\tCollections.addAll(paramList, args);\n+\t\t\t\tparamList.add(type);\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tthrow new InternalError(\"Invalid AccessType.\");\n+\t\t\t}\n+\t\t\treturn MethodType.methodType(returnType, paramList);\n \t\t}\n \t}\n \t\n \tstatic final Unsafe _unsafe = Unsafe.getUnsafe();\n \tstatic final Lookup _lookup = Lookup.internalPrivilegedLookup;\n+\n+/*[IF Java14]*/\n+\tstatic final BiFunction<String, List<Integer>, ArrayIndexOutOfBoundsException> AIOOBE_SUPPLIER = null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODkwMDM4MQ=="}, "originalCommit": {"oid": "604dd591f5a2ae2d22dc0c1cbe46cf2065eee38e"}, "originalPosition": 116}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 659, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}