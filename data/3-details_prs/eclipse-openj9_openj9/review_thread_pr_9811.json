{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI4NTI5Mjk1", "number": 9811, "reviewThreads": {"totalCount": 26, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxODozNjozMFrOEDDyIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNzowNzowNlrOEExdcw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNjQzMTcxOnYy", "diffSide": "RIGHT", "path": "runtime/shared_common/CacheMap.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxODozNjozMFrOGf5U1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxOTo0MTozMVrOGgttxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA5ODI2MQ==", "bodyText": "The function comment \"If VM class segment is held, hasClassSegmentMutex must be true\" seems obsolete even before this change.", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436098261", "createdAt": "2020-06-05T18:36:30Z", "author": {"login": "pshipton"}, "path": "runtime/shared_common/CacheMap.cpp", "diffHunk": "@@ -1735,9 +1736,10 @@ SH_CacheMap::addClasspathToCache(J9VMThread* currentThread, ClasspathItem* obj)\n  * @return the number of items read, or -1 on error\n  */\n IDATA \n-SH_CacheMap::runEntryPointChecks(J9VMThread* currentThread, void* address, const char** p_subcstr)\n+SH_CacheMap::runEntryPointChecks(J9VMThread* currentThread, void* address, const char** p_subcstr, bool acquireClassSegmentMutex)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b70681c95131a2d4c73bc2d203ff2cd8436e53d"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk1NjYxNA==", "bodyText": "Fixed.", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436956614", "createdAt": "2020-06-08T19:41:31Z", "author": {"login": "hangshao0"}, "path": "runtime/shared_common/CacheMap.cpp", "diffHunk": "@@ -1735,9 +1736,10 @@ SH_CacheMap::addClasspathToCache(J9VMThread* currentThread, ClasspathItem* obj)\n  * @return the number of items read, or -1 on error\n  */\n IDATA \n-SH_CacheMap::runEntryPointChecks(J9VMThread* currentThread, void* address, const char** p_subcstr)\n+SH_CacheMap::runEntryPointChecks(J9VMThread* currentThread, void* address, const char** p_subcstr, bool acquireClassSegmentMutex)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA5ODI2MQ=="}, "originalCommit": {"oid": "1b70681c95131a2d4c73bc2d203ff2cd8436e53d"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNjQzNzQ0OnYy", "diffSide": "RIGHT", "path": "runtime/shared_common/CacheMap.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxODozODoxNlrOGf5YRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxOTo0Mjo1MFrOGgtwNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA5OTE0MA==", "bodyText": "Pls fix the function comment, \"findROMClass and storeROMClass prereq that the class segment mutex is held\"", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436099140", "createdAt": "2020-06-05T18:38:16Z", "author": {"login": "pshipton"}, "path": "runtime/shared_common/CacheMap.cpp", "diffHunk": "@@ -932,6 +932,7 @@ SH_CacheMap::updateROMSegmentList(J9VMThread* currentThread, bool hasClassSegmen\n #if defined(J9VM_THR_PREEMPTIVE)\n \tif (!hasClassSegmentMutex) {\n \t\tTrc_SHR_Assert_ShouldNotHaveLocalMutex(classSegmentMutex);\n+\t\tTrc_SHR_Assert_False(_ccHead->hasWriteMutex(currentThread));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b70681c95131a2d4c73bc2d203ff2cd8436e53d"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk1NzIzOQ==", "bodyText": "Fixed", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436957239", "createdAt": "2020-06-08T19:42:50Z", "author": {"login": "hangshao0"}, "path": "runtime/shared_common/CacheMap.cpp", "diffHunk": "@@ -932,6 +932,7 @@ SH_CacheMap::updateROMSegmentList(J9VMThread* currentThread, bool hasClassSegmen\n #if defined(J9VM_THR_PREEMPTIVE)\n \tif (!hasClassSegmentMutex) {\n \t\tTrc_SHR_Assert_ShouldNotHaveLocalMutex(classSegmentMutex);\n+\t\tTrc_SHR_Assert_False(_ccHead->hasWriteMutex(currentThread));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA5OTE0MA=="}, "originalCommit": {"oid": "1b70681c95131a2d4c73bc2d203ff2cd8436e53d"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNjQ0MDI5OnYy", "diffSide": "LEFT", "path": "runtime/shared_common/CacheMap.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxODozOToyMVrOGf5aGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxOTo0MzoyMFrOGgtxIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA5OTYwOA==", "bodyText": "Pls fix the function comment \"Caller must have VM class segment mutex.\"", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436099608", "createdAt": "2020-06-05T18:39:21Z", "author": {"login": "pshipton"}, "path": "runtime/shared_common/CacheMap.cpp", "diffHunk": "@@ -2692,8 +2707,6 @@ SH_CacheMap::findROMClass(J9VMThread* currentThread, const char* path, Classpath\n \tUDATA hash = 0;\n \tbool useWriteHash = _ccHead->isUsingWriteHash();\n \n-\tTrc_SHR_Assert_ShouldHaveLocalMutex(currentThread->javaVM->classMemorySegments->segmentMutex);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b70681c95131a2d4c73bc2d203ff2cd8436e53d"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk1NzQ3Mw==", "bodyText": "Fixed.", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436957473", "createdAt": "2020-06-08T19:43:20Z", "author": {"login": "hangshao0"}, "path": "runtime/shared_common/CacheMap.cpp", "diffHunk": "@@ -2692,8 +2707,6 @@ SH_CacheMap::findROMClass(J9VMThread* currentThread, const char* path, Classpath\n \tUDATA hash = 0;\n \tbool useWriteHash = _ccHead->isUsingWriteHash();\n \n-\tTrc_SHR_Assert_ShouldHaveLocalMutex(currentThread->javaVM->classMemorySegments->segmentMutex);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA5OTYwOA=="}, "originalCommit": {"oid": "1b70681c95131a2d4c73bc2d203ff2cd8436e53d"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNjQ4MDg4OnYy", "diffSide": "RIGHT", "path": "runtime/shared_common/CacheMap.cpp", "isResolved": true, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxODo1MzowN1rOGf5zug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxOTo0NDoyN1rOGgtzOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEwNjE3MA==", "bodyText": "The call to markStale() above needs to have the segmentMutex.", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436106170", "createdAt": "2020-06-05T18:53:07Z", "author": {"login": "pshipton"}, "path": "runtime/shared_common/CacheMap.cpp", "diffHunk": "@@ -2913,7 +2935,7 @@ SH_CacheMap::findROMClass(J9VMThread* currentThread, const char* path, Classpath\n \n \tif (returnVal) {\n \t\t/* Call updateROMSegmentList() to ensure that heapAlloc of the romClass segment is always updated to include the returned romClass */\n-\t\tupdateROMSegmentList(currentThread, true);\n+\t\tupdateROMSegmentList(currentThread, omrthread_monitor_owned_by_self(currentThread->javaVM->classMemorySegments->segmentMutex) != 0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b70681c95131a2d4c73bc2d203ff2cd8436e53d"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE1Njc4Ng==", "bodyText": "I guess markStale() only touches metadata, not romclass segment.  Why do we need segmentMutex ?", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436156786", "createdAt": "2020-06-05T20:47:16Z", "author": {"login": "hangshao0"}, "path": "runtime/shared_common/CacheMap.cpp", "diffHunk": "@@ -2913,7 +2935,7 @@ SH_CacheMap::findROMClass(J9VMThread* currentThread, const char* path, Classpath\n \n \tif (returnVal) {\n \t\t/* Call updateROMSegmentList() to ensure that heapAlloc of the romClass segment is always updated to include the returned romClass */\n-\t\tupdateROMSegmentList(currentThread, true);\n+\t\tupdateROMSegmentList(currentThread, omrthread_monitor_owned_by_self(currentThread->javaVM->classMemorySegments->segmentMutex) != 0);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEwNjE3MA=="}, "originalCommit": {"oid": "1b70681c95131a2d4c73bc2d203ff2cd8436e53d"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE2NDQ5OA==", "bodyText": "I was going by the comment which says THREADING: Caller must have VM class segment mutex.", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436164498", "createdAt": "2020-06-05T21:06:45Z", "author": {"login": "pshipton"}, "path": "runtime/shared_common/CacheMap.cpp", "diffHunk": "@@ -2913,7 +2935,7 @@ SH_CacheMap::findROMClass(J9VMThread* currentThread, const char* path, Classpath\n \n \tif (returnVal) {\n \t\t/* Call updateROMSegmentList() to ensure that heapAlloc of the romClass segment is always updated to include the returned romClass */\n-\t\tupdateROMSegmentList(currentThread, true);\n+\t\tupdateROMSegmentList(currentThread, omrthread_monitor_owned_by_self(currentThread->javaVM->classMemorySegments->segmentMutex) != 0);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEwNjE3MA=="}, "originalCommit": {"oid": "1b70681c95131a2d4c73bc2d203ff2cd8436e53d"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE2NjYzNQ==", "bodyText": "I see a call to localCPM->markClasspathsStale, something needs to protect that.", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436166635", "createdAt": "2020-06-05T21:12:47Z", "author": {"login": "pshipton"}, "path": "runtime/shared_common/CacheMap.cpp", "diffHunk": "@@ -2913,7 +2935,7 @@ SH_CacheMap::findROMClass(J9VMThread* currentThread, const char* path, Classpath\n \n \tif (returnVal) {\n \t\t/* Call updateROMSegmentList() to ensure that heapAlloc of the romClass segment is always updated to include the returned romClass */\n-\t\tupdateROMSegmentList(currentThread, true);\n+\t\tupdateROMSegmentList(currentThread, omrthread_monitor_owned_by_self(currentThread->javaVM->classMemorySegments->segmentMutex) != 0);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEwNjE3MA=="}, "originalCommit": {"oid": "1b70681c95131a2d4c73bc2d203ff2cd8436e53d"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE2Nzc1MQ==", "bodyText": "I guess the write mutex does that. Not sure why the comment.", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436167751", "createdAt": "2020-06-05T21:15:42Z", "author": {"login": "pshipton"}, "path": "runtime/shared_common/CacheMap.cpp", "diffHunk": "@@ -2913,7 +2935,7 @@ SH_CacheMap::findROMClass(J9VMThread* currentThread, const char* path, Classpath\n \n \tif (returnVal) {\n \t\t/* Call updateROMSegmentList() to ensure that heapAlloc of the romClass segment is always updated to include the returned romClass */\n-\t\tupdateROMSegmentList(currentThread, true);\n+\t\tupdateROMSegmentList(currentThread, omrthread_monitor_owned_by_self(currentThread->javaVM->classMemorySegments->segmentMutex) != 0);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEwNjE3MA=="}, "originalCommit": {"oid": "1b70681c95131a2d4c73bc2d203ff2cd8436e53d"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE2OTg4Mg==", "bodyText": "I guess in the previous code, we should have class segmentMutex when reaching markStale(). But it is not true anymore after this change. I will delete the comment THREADING: Caller must have VM class segment mutex.", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436169882", "createdAt": "2020-06-05T21:21:51Z", "author": {"login": "hangshao0"}, "path": "runtime/shared_common/CacheMap.cpp", "diffHunk": "@@ -2913,7 +2935,7 @@ SH_CacheMap::findROMClass(J9VMThread* currentThread, const char* path, Classpath\n \n \tif (returnVal) {\n \t\t/* Call updateROMSegmentList() to ensure that heapAlloc of the romClass segment is always updated to include the returned romClass */\n-\t\tupdateROMSegmentList(currentThread, true);\n+\t\tupdateROMSegmentList(currentThread, omrthread_monitor_owned_by_self(currentThread->javaVM->classMemorySegments->segmentMutex) != 0);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEwNjE3MA=="}, "originalCommit": {"oid": "1b70681c95131a2d4c73bc2d203ff2cd8436e53d"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk1ODAxMQ==", "bodyText": "Fixed.", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436958011", "createdAt": "2020-06-08T19:44:27Z", "author": {"login": "hangshao0"}, "path": "runtime/shared_common/CacheMap.cpp", "diffHunk": "@@ -2913,7 +2935,7 @@ SH_CacheMap::findROMClass(J9VMThread* currentThread, const char* path, Classpath\n \n \tif (returnVal) {\n \t\t/* Call updateROMSegmentList() to ensure that heapAlloc of the romClass segment is always updated to include the returned romClass */\n-\t\tupdateROMSegmentList(currentThread, true);\n+\t\tupdateROMSegmentList(currentThread, omrthread_monitor_owned_by_self(currentThread->javaVM->classMemorySegments->segmentMutex) != 0);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEwNjE3MA=="}, "originalCommit": {"oid": "1b70681c95131a2d4c73bc2d203ff2cd8436e53d"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNjQ5MTcyOnYy", "diffSide": "RIGHT", "path": "runtime/shared_common/shrinit.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxODo1NzowMlrOGf56uQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxOTo1MDo1MFrOGguAAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEwNzk2MQ==", "bodyText": "The calls to getBootstrapClasspathItem() above needs to have the segmentMutex as well.\nI think technically we don't need the segmentMutex for these calls, but it was protecting them in the past. Another mutex could be used to reduce contention on the segmentMutex, although this also affects storing classes. Suggest sticking with segmentMutex in this PR, and consider future optimization. Similarly for registerStoreFilter().", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436107961", "createdAt": "2020-06-05T18:57:02Z", "author": {"login": "pshipton"}, "path": "runtime/shared_common/shrinit.cpp", "diffHunk": "@@ -1515,7 +1517,15 @@ hookFindSharedClass(J9HookInterface** hookInterface, UDATA eventNum, void* voidD\n \tif (!classpath) {\n \t\t/* No cached classpath found. Need to create a new one. */\n \t\tif ((NULL != eventData->classPathEntries) || (eventData->classloader == vm->systemClassLoader)) {\n+\t\t\tif (omrthread_monitor_owned_by_self(classSegmentMutex) == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b70681c95131a2d4c73bc2d203ff2cd8436e53d"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk2MTI4MQ==", "bodyText": "Put getBootstrapClasspathItem() inside class segmentMutex.", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436961281", "createdAt": "2020-06-08T19:50:50Z", "author": {"login": "hangshao0"}, "path": "runtime/shared_common/shrinit.cpp", "diffHunk": "@@ -1515,7 +1517,15 @@ hookFindSharedClass(J9HookInterface** hookInterface, UDATA eventNum, void* voidD\n \tif (!classpath) {\n \t\t/* No cached classpath found. Need to create a new one. */\n \t\tif ((NULL != eventData->classPathEntries) || (eventData->classloader == vm->systemClassLoader)) {\n+\t\t\tif (omrthread_monitor_owned_by_self(classSegmentMutex) == 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEwNzk2MQ=="}, "originalCommit": {"oid": "1b70681c95131a2d4c73bc2d203ff2cd8436e53d"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNjUyMTM3OnYy", "diffSide": "RIGHT", "path": "runtime/shared_common/shrinit.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxOTowODowNFrOGf6OFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxOTo0NTowOVrOGgt0tw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjExMjkxOA==", "bodyText": "Pls fix the function comment \"The caller must hold the VM class segment mutex\".", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436112918", "createdAt": "2020-06-05T19:08:04Z", "author": {"login": "pshipton"}, "path": "runtime/shared_common/shrinit.cpp", "diffHunk": "@@ -1427,6 +1427,8 @@ hookFindSharedClass(J9HookInterface** hookInterface, UDATA eventNum, void* voidD\n \tUDATA localVerboseFlags;\n \tJ9SharedClassConfig* sharedClassConfig = vm->sharedClassConfig;\n \tbool isBootLoader = false;\n+\tbool releaseSegmentMutex = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b70681c95131a2d4c73bc2d203ff2cd8436e53d"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk1ODM5MQ==", "bodyText": "Fixed.", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436958391", "createdAt": "2020-06-08T19:45:09Z", "author": {"login": "hangshao0"}, "path": "runtime/shared_common/shrinit.cpp", "diffHunk": "@@ -1427,6 +1427,8 @@ hookFindSharedClass(J9HookInterface** hookInterface, UDATA eventNum, void* voidD\n \tUDATA localVerboseFlags;\n \tJ9SharedClassConfig* sharedClassConfig = vm->sharedClassConfig;\n \tbool isBootLoader = false;\n+\tbool releaseSegmentMutex = false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjExMjkxOA=="}, "originalCommit": {"oid": "1b70681c95131a2d4c73bc2d203ff2cd8436e53d"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNjU4ODk3OnYy", "diffSide": "RIGHT", "path": "jcl/src/openj9.sharedclasses/share/classes/com/ibm/oti/shared/SharedClassURLClasspathHelperImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxOTozNDo1MFrOGf65yA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxOTo1MDoxMVrOGgt-nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEyNDEwNA==", "bodyText": "This needs to move back before if (confirmedCount <= foundAtIndex)", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436124104", "createdAt": "2020-06-05T19:34:50Z", "author": {"login": "pshipton"}, "path": "jcl/src/openj9.sharedclasses/share/classes/com/ibm/oti/shared/SharedClassURLClasspathHelperImpl.java", "diffHunk": "@@ -166,53 +175,62 @@ public synchronized boolean storeSharedClass(String partition, Class<?> clazz, i\n \t\t\tprintVerboseError(Msg.getString(\"K05a3\")); //$NON-NLS-1$\n \t\t\treturn false;\n \t\t}\n-\t\tif (urlCount==0) {\n-\t\t\t/*[MSG \"K05a6\", \"Classpath has zero elements. Cannot call storeSharedClass without classpath. Returning false.\"]*/\n-\t\t\tprintVerboseError(Msg.getString(\"K05a6\")); //$NON-NLS-1$\n-\t\t\treturn false;\n-\t\t}\n+\t\t\n \t\tif (foundAtIndex<0) {\n \t\t\t/*[MSG \"K05a7\", \"foundAtIndex cannot be <0 for storeSharedClass. Returning false.\"]*/\n \t\t\tprintVerboseError(Msg.getString(\"K05a7\")); //$NON-NLS-1$\n \t\t\treturn false;\n \t\t}\n-\t\tif (foundAtIndex>=urlCount) {\n-\t\t\t/*[MSG \"K05a8\", \"foundAtIndex cannot be >= urls in classpath for storeSharedClass. Returning false.\"]*/\n-\t\t\tprintVerboseError(Msg.getString(\"K05a8\")); //$NON-NLS-1$\n-\t\t\treturn false;\n-\t\t}\n-\t\tif (invalidURLExists) {\n-\t\t\t/* Any URL which has its protocol other than 'jar:' or 'file:' is not supported by\n-\t\t\t * shared class cache and is considered invalid.\n-\t\t\t * invalidURLExists = true indicates classpath contains an invalid URL,\n-\t\t\t * As such there is no point in calling native method storeSharedClassImpl2() \n-\t\t\t * since it is bound to fail when creating classpath entries.\n-\t\t\t */\t\t\t\n-\t\t\t/*[MSG \"K05a9\", \"Classpath contains an invalid URL. Returning false.\"]*/\n-\t\t\tprintVerboseInfo(Msg.getString(\"K05a9\")); //$NON-NLS-1$\n-\t\t\treturn false;\n-\t\t}\n-\t\tif (!validated[foundAtIndex]) {\n-\t\t\t/* Because we only check each element once, we can afford to also check whether the URL exists */\n-\t\t\tif (!validateURL(urls[foundAtIndex], true)) {\n-\t\t\t\treturn false;\n-\t\t\t}\n-\t\t\tvalidated[foundAtIndex]=true;\n-\t\t}\n \t\tClassLoader actualLoader = getClassLoader();\n \t\tif (!validateClassLoader(actualLoader, clazz)) {\n \t\t\t/* Attempt to call storeSharedClass with class defined by a different classloader */\n \t\t\treturn false;\n \t\t}\n-\t\tif (confirmedCount <= foundAtIndex) {\n-\t\t\tconfirmedCount = foundAtIndex+1;\n-\t\t\t/*[MSG \"K05aa\", \"Number of confirmed entries is now {0}\"]*/\n-\t\t\tprintVerboseInfo(Msg.getString(\"K05aa\", confirmedCount)); //$NON-NLS-1$\n-\t\t}\n-\t\treturn storeSharedClassImpl2(this.id, partition, actualLoader, this.urls, this.urlCount, foundAtIndex, clazz, nativeFlags);\n+\t\turlcpReadWriteLock.readLock().lock();\n+\t\ttry {\n+\t\t\tif (urlCount==0) {\n+\t\t\t\t/*[MSG \"K05a6\", \"Classpath has zero elements. Cannot call storeSharedClass without classpath. Returning false.\"]*/\n+\t\t\t\tprintVerboseError(Msg.getString(\"K05a6\")); //$NON-NLS-1$\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tif (foundAtIndex>=urlCount) {\n+\t\t\t\t/*[MSG \"K05a8\", \"foundAtIndex cannot be >= urls in classpath for storeSharedClass. Returning false.\"]*/\n+\t\t\t\tprintVerboseError(Msg.getString(\"K05a8\")); //$NON-NLS-1$\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tif (invalidURLExists) {\n+\t\t\t\t/* Any URL which has its protocol other than 'jar:' or 'file:' is not supported by\n+\t\t\t\t * shared class cache and is considered invalid.\n+\t\t\t\t * invalidURLExists = true indicates classpath contains an invalid URL,\n+\t\t\t\t * As such there is no point in calling native method storeSharedClassImpl2() \n+\t\t\t\t * since it is bound to fail when creating classpath entries.\n+\t\t\t\t */\t\t\t\n+\t\t\t\t/*[MSG \"K05a9\", \"Classpath contains an invalid URL. Returning false.\"]*/\n+\t\t\t\tprintVerboseInfo(Msg.getString(\"K05a9\")); //$NON-NLS-1$\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tif (confirmedCount <= foundAtIndex) {\n+\t\t\t\tconfirmedCount = foundAtIndex+1;\n+\t\t\t\t/*[MSG \"K05aa\", \"Number of confirmed entries is now {0}\"]*/\n+\t\t\t\tprintVerboseInfo(Msg.getString(\"K05aa\", confirmedCount)); //$NON-NLS-1$\n+\t\t\t}\n+\t\t\tif (!validated[foundAtIndex]) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b70681c95131a2d4c73bc2d203ff2cd8436e53d"}, "originalPosition": 197}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk2MDkyNw==", "bodyText": "Fixed.", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436960927", "createdAt": "2020-06-08T19:50:11Z", "author": {"login": "hangshao0"}, "path": "jcl/src/openj9.sharedclasses/share/classes/com/ibm/oti/shared/SharedClassURLClasspathHelperImpl.java", "diffHunk": "@@ -166,53 +175,62 @@ public synchronized boolean storeSharedClass(String partition, Class<?> clazz, i\n \t\t\tprintVerboseError(Msg.getString(\"K05a3\")); //$NON-NLS-1$\n \t\t\treturn false;\n \t\t}\n-\t\tif (urlCount==0) {\n-\t\t\t/*[MSG \"K05a6\", \"Classpath has zero elements. Cannot call storeSharedClass without classpath. Returning false.\"]*/\n-\t\t\tprintVerboseError(Msg.getString(\"K05a6\")); //$NON-NLS-1$\n-\t\t\treturn false;\n-\t\t}\n+\t\t\n \t\tif (foundAtIndex<0) {\n \t\t\t/*[MSG \"K05a7\", \"foundAtIndex cannot be <0 for storeSharedClass. Returning false.\"]*/\n \t\t\tprintVerboseError(Msg.getString(\"K05a7\")); //$NON-NLS-1$\n \t\t\treturn false;\n \t\t}\n-\t\tif (foundAtIndex>=urlCount) {\n-\t\t\t/*[MSG \"K05a8\", \"foundAtIndex cannot be >= urls in classpath for storeSharedClass. Returning false.\"]*/\n-\t\t\tprintVerboseError(Msg.getString(\"K05a8\")); //$NON-NLS-1$\n-\t\t\treturn false;\n-\t\t}\n-\t\tif (invalidURLExists) {\n-\t\t\t/* Any URL which has its protocol other than 'jar:' or 'file:' is not supported by\n-\t\t\t * shared class cache and is considered invalid.\n-\t\t\t * invalidURLExists = true indicates classpath contains an invalid URL,\n-\t\t\t * As such there is no point in calling native method storeSharedClassImpl2() \n-\t\t\t * since it is bound to fail when creating classpath entries.\n-\t\t\t */\t\t\t\n-\t\t\t/*[MSG \"K05a9\", \"Classpath contains an invalid URL. Returning false.\"]*/\n-\t\t\tprintVerboseInfo(Msg.getString(\"K05a9\")); //$NON-NLS-1$\n-\t\t\treturn false;\n-\t\t}\n-\t\tif (!validated[foundAtIndex]) {\n-\t\t\t/* Because we only check each element once, we can afford to also check whether the URL exists */\n-\t\t\tif (!validateURL(urls[foundAtIndex], true)) {\n-\t\t\t\treturn false;\n-\t\t\t}\n-\t\t\tvalidated[foundAtIndex]=true;\n-\t\t}\n \t\tClassLoader actualLoader = getClassLoader();\n \t\tif (!validateClassLoader(actualLoader, clazz)) {\n \t\t\t/* Attempt to call storeSharedClass with class defined by a different classloader */\n \t\t\treturn false;\n \t\t}\n-\t\tif (confirmedCount <= foundAtIndex) {\n-\t\t\tconfirmedCount = foundAtIndex+1;\n-\t\t\t/*[MSG \"K05aa\", \"Number of confirmed entries is now {0}\"]*/\n-\t\t\tprintVerboseInfo(Msg.getString(\"K05aa\", confirmedCount)); //$NON-NLS-1$\n-\t\t}\n-\t\treturn storeSharedClassImpl2(this.id, partition, actualLoader, this.urls, this.urlCount, foundAtIndex, clazz, nativeFlags);\n+\t\turlcpReadWriteLock.readLock().lock();\n+\t\ttry {\n+\t\t\tif (urlCount==0) {\n+\t\t\t\t/*[MSG \"K05a6\", \"Classpath has zero elements. Cannot call storeSharedClass without classpath. Returning false.\"]*/\n+\t\t\t\tprintVerboseError(Msg.getString(\"K05a6\")); //$NON-NLS-1$\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tif (foundAtIndex>=urlCount) {\n+\t\t\t\t/*[MSG \"K05a8\", \"foundAtIndex cannot be >= urls in classpath for storeSharedClass. Returning false.\"]*/\n+\t\t\t\tprintVerboseError(Msg.getString(\"K05a8\")); //$NON-NLS-1$\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tif (invalidURLExists) {\n+\t\t\t\t/* Any URL which has its protocol other than 'jar:' or 'file:' is not supported by\n+\t\t\t\t * shared class cache and is considered invalid.\n+\t\t\t\t * invalidURLExists = true indicates classpath contains an invalid URL,\n+\t\t\t\t * As such there is no point in calling native method storeSharedClassImpl2() \n+\t\t\t\t * since it is bound to fail when creating classpath entries.\n+\t\t\t\t */\t\t\t\n+\t\t\t\t/*[MSG \"K05a9\", \"Classpath contains an invalid URL. Returning false.\"]*/\n+\t\t\t\tprintVerboseInfo(Msg.getString(\"K05a9\")); //$NON-NLS-1$\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tif (confirmedCount <= foundAtIndex) {\n+\t\t\t\tconfirmedCount = foundAtIndex+1;\n+\t\t\t\t/*[MSG \"K05aa\", \"Number of confirmed entries is now {0}\"]*/\n+\t\t\t\tprintVerboseInfo(Msg.getString(\"K05aa\", confirmedCount)); //$NON-NLS-1$\n+\t\t\t}\n+\t\t\tif (!validated[foundAtIndex]) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEyNDEwNA=="}, "originalCommit": {"oid": "1b70681c95131a2d4c73bc2d203ff2cd8436e53d"}, "originalPosition": 197}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNjY3MDEyOnYy", "diffSide": "RIGHT", "path": "jcl/src/openj9.sharedclasses/share/classes/com/ibm/oti/shared/SharedClassURLClasspathHelperImpl.java", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxOTo1Nzo1NVrOGf7q4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxOTo0NzoyNFrOGgt5Ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEzNjY3Mw==", "bodyText": "readLock() should be sufficient.", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436136673", "createdAt": "2020-06-05T19:57:55Z", "author": {"login": "pshipton"}, "path": "jcl/src/openj9.sharedclasses/share/classes/com/ibm/oti/shared/SharedClassURLClasspathHelperImpl.java", "diffHunk": "@@ -228,137 +246,160 @@ private synchronized void growURLs(int toMinSize) {\n \t}\n \n \t@Override\n-\tpublic synchronized void addClasspathEntry(URL cpe) {\n+\tpublic void addClasspathEntry(URL cpe) {\n \t\tClassLoader loader = getClassLoader();\n \t\tif (loader != null) {\n \t\t\tif (cpe==null) {\n \t\t\t\t/*[MSG \"K05ac\", \"URL is null for addClasspathEntry.\"]*/\n \t\t\t\tprintVerboseError(Msg.getString(\"K05ac\")); //$NON-NLS-1$\n \t\t\t\treturn;\n \t\t\t}\n-\t\t\t/* If array is not big enough, grow it */\n-\t\t\tif (urls.length < (urlCount+1)) {\n-\t\t\t\tgrowURLs(urlCount+1);\n-\t\t\t}\n-\t\t\torigurls[urlCount] = cpe;\n-\t\t\turls[urlCount] = convertJarURL(cpe);\n-\t\t\tif (!validateURL(urls[urlCount], false)) {\n-\t\t\t\tinvalidURLExists = true;\n+\t\t\tURL convertedurl = convertJarURL(cpe);\n+\t\t\tboolean invalidUrl = false;\n+\t\t\tif (!validateURL(convertedurl, false)) {\n+\t\t\t\tinvalidUrl = true;\n \t\t\t}\n-\t\t\tnotifyClasspathChange2(loader);\n-\t\t\tif (!invalidURLExists) {\n-\t\t\t\tnotifyClasspathChange3(id, loader, urls, urlCount, (urlCount + 1), true);\n+\t\t\turlcpReadWriteLock.writeLock().lock();\n+\t\t\ttry {\n+\t\t\t\t/* If array is not big enough, grow it */\n+\t\t\t\tif (urls.length < (urlCount+1)) {\n+\t\t\t\t\tgrowURLs(urlCount+1);\n+\t\t\t\t}\n+\t\t\t\torigurls[urlCount] = cpe;\n+\t\t\t\turls[urlCount] = convertedurl;\n+\t\t\t\tinvalidURLExists = invalidUrl;\n+\t\t\t\tnotifyClasspathChange2(loader);\n+\t\t\t\tif (!invalidURLExists) {\n+\t\t\t\t\tnotifyClasspathChange3(id, loader, urls, urlCount, (urlCount + 1), true);\n+\t\t\t\t}\n+\t\t\t\t++urlCount;\n+\t\t\t} finally {\n+\t\t\t\turlcpReadWriteLock.writeLock().unlock();\n \t\t\t}\n-\t\t\t++urlCount;\n \t\t}\n \t}\n \n \t/* Function required by the factory */\n-\tsynchronized URL[] getClasspath() {\n+\tURL[] getClasspath() {\n \t\tURL[] correctLengthArray = new URL[urlCount];\n-\t\tSystem.arraycopy(origurls, 0, correctLengthArray, 0, urlCount);\n+\t\turlcpReadWriteLock.readLock().lock();\n+\t\ttry {\n+\t\t\tSystem.arraycopy(origurls, 0, correctLengthArray, 0, urlCount);\n+\t\t} finally {\n+\t\t\turlcpReadWriteLock.readLock().unlock();\n+\t\t}\n \t\treturn correctLengthArray;\n \t}\n \n \t@Override\n-\tpublic synchronized void confirmAllEntries() {\n-\t\tconfirmedCount = urlCount;\n+\tpublic void confirmAllEntries() {\n+\t\turlcpReadWriteLock.writeLock().lock();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b70681c95131a2d4c73bc2d203ff2cd8436e53d"}, "originalPosition": 286}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE3MDk1Mg==", "bodyText": "Field confirmedCount is updated by this function. readLock() only is fine ?", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436170952", "createdAt": "2020-06-05T21:24:58Z", "author": {"login": "hangshao0"}, "path": "jcl/src/openj9.sharedclasses/share/classes/com/ibm/oti/shared/SharedClassURLClasspathHelperImpl.java", "diffHunk": "@@ -228,137 +246,160 @@ private synchronized void growURLs(int toMinSize) {\n \t}\n \n \t@Override\n-\tpublic synchronized void addClasspathEntry(URL cpe) {\n+\tpublic void addClasspathEntry(URL cpe) {\n \t\tClassLoader loader = getClassLoader();\n \t\tif (loader != null) {\n \t\t\tif (cpe==null) {\n \t\t\t\t/*[MSG \"K05ac\", \"URL is null for addClasspathEntry.\"]*/\n \t\t\t\tprintVerboseError(Msg.getString(\"K05ac\")); //$NON-NLS-1$\n \t\t\t\treturn;\n \t\t\t}\n-\t\t\t/* If array is not big enough, grow it */\n-\t\t\tif (urls.length < (urlCount+1)) {\n-\t\t\t\tgrowURLs(urlCount+1);\n-\t\t\t}\n-\t\t\torigurls[urlCount] = cpe;\n-\t\t\turls[urlCount] = convertJarURL(cpe);\n-\t\t\tif (!validateURL(urls[urlCount], false)) {\n-\t\t\t\tinvalidURLExists = true;\n+\t\t\tURL convertedurl = convertJarURL(cpe);\n+\t\t\tboolean invalidUrl = false;\n+\t\t\tif (!validateURL(convertedurl, false)) {\n+\t\t\t\tinvalidUrl = true;\n \t\t\t}\n-\t\t\tnotifyClasspathChange2(loader);\n-\t\t\tif (!invalidURLExists) {\n-\t\t\t\tnotifyClasspathChange3(id, loader, urls, urlCount, (urlCount + 1), true);\n+\t\t\turlcpReadWriteLock.writeLock().lock();\n+\t\t\ttry {\n+\t\t\t\t/* If array is not big enough, grow it */\n+\t\t\t\tif (urls.length < (urlCount+1)) {\n+\t\t\t\t\tgrowURLs(urlCount+1);\n+\t\t\t\t}\n+\t\t\t\torigurls[urlCount] = cpe;\n+\t\t\t\turls[urlCount] = convertedurl;\n+\t\t\t\tinvalidURLExists = invalidUrl;\n+\t\t\t\tnotifyClasspathChange2(loader);\n+\t\t\t\tif (!invalidURLExists) {\n+\t\t\t\t\tnotifyClasspathChange3(id, loader, urls, urlCount, (urlCount + 1), true);\n+\t\t\t\t}\n+\t\t\t\t++urlCount;\n+\t\t\t} finally {\n+\t\t\t\turlcpReadWriteLock.writeLock().unlock();\n \t\t\t}\n-\t\t\t++urlCount;\n \t\t}\n \t}\n \n \t/* Function required by the factory */\n-\tsynchronized URL[] getClasspath() {\n+\tURL[] getClasspath() {\n \t\tURL[] correctLengthArray = new URL[urlCount];\n-\t\tSystem.arraycopy(origurls, 0, correctLengthArray, 0, urlCount);\n+\t\turlcpReadWriteLock.readLock().lock();\n+\t\ttry {\n+\t\t\tSystem.arraycopy(origurls, 0, correctLengthArray, 0, urlCount);\n+\t\t} finally {\n+\t\t\turlcpReadWriteLock.readLock().unlock();\n+\t\t}\n \t\treturn correctLengthArray;\n \t}\n \n \t@Override\n-\tpublic synchronized void confirmAllEntries() {\n-\t\tconfirmedCount = urlCount;\n+\tpublic void confirmAllEntries() {\n+\t\turlcpReadWriteLock.writeLock().lock();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEzNjY3Mw=="}, "originalCommit": {"oid": "1b70681c95131a2d4c73bc2d203ff2cd8436e53d"}, "originalPosition": 286}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE3NjQ0MA==", "bodyText": "I think so. urlCount is only modified with the writeLock(), so all readers will just get the same value.", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436176440", "createdAt": "2020-06-05T21:40:54Z", "author": {"login": "pshipton"}, "path": "jcl/src/openj9.sharedclasses/share/classes/com/ibm/oti/shared/SharedClassURLClasspathHelperImpl.java", "diffHunk": "@@ -228,137 +246,160 @@ private synchronized void growURLs(int toMinSize) {\n \t}\n \n \t@Override\n-\tpublic synchronized void addClasspathEntry(URL cpe) {\n+\tpublic void addClasspathEntry(URL cpe) {\n \t\tClassLoader loader = getClassLoader();\n \t\tif (loader != null) {\n \t\t\tif (cpe==null) {\n \t\t\t\t/*[MSG \"K05ac\", \"URL is null for addClasspathEntry.\"]*/\n \t\t\t\tprintVerboseError(Msg.getString(\"K05ac\")); //$NON-NLS-1$\n \t\t\t\treturn;\n \t\t\t}\n-\t\t\t/* If array is not big enough, grow it */\n-\t\t\tif (urls.length < (urlCount+1)) {\n-\t\t\t\tgrowURLs(urlCount+1);\n-\t\t\t}\n-\t\t\torigurls[urlCount] = cpe;\n-\t\t\turls[urlCount] = convertJarURL(cpe);\n-\t\t\tif (!validateURL(urls[urlCount], false)) {\n-\t\t\t\tinvalidURLExists = true;\n+\t\t\tURL convertedurl = convertJarURL(cpe);\n+\t\t\tboolean invalidUrl = false;\n+\t\t\tif (!validateURL(convertedurl, false)) {\n+\t\t\t\tinvalidUrl = true;\n \t\t\t}\n-\t\t\tnotifyClasspathChange2(loader);\n-\t\t\tif (!invalidURLExists) {\n-\t\t\t\tnotifyClasspathChange3(id, loader, urls, urlCount, (urlCount + 1), true);\n+\t\t\turlcpReadWriteLock.writeLock().lock();\n+\t\t\ttry {\n+\t\t\t\t/* If array is not big enough, grow it */\n+\t\t\t\tif (urls.length < (urlCount+1)) {\n+\t\t\t\t\tgrowURLs(urlCount+1);\n+\t\t\t\t}\n+\t\t\t\torigurls[urlCount] = cpe;\n+\t\t\t\turls[urlCount] = convertedurl;\n+\t\t\t\tinvalidURLExists = invalidUrl;\n+\t\t\t\tnotifyClasspathChange2(loader);\n+\t\t\t\tif (!invalidURLExists) {\n+\t\t\t\t\tnotifyClasspathChange3(id, loader, urls, urlCount, (urlCount + 1), true);\n+\t\t\t\t}\n+\t\t\t\t++urlCount;\n+\t\t\t} finally {\n+\t\t\t\turlcpReadWriteLock.writeLock().unlock();\n \t\t\t}\n-\t\t\t++urlCount;\n \t\t}\n \t}\n \n \t/* Function required by the factory */\n-\tsynchronized URL[] getClasspath() {\n+\tURL[] getClasspath() {\n \t\tURL[] correctLengthArray = new URL[urlCount];\n-\t\tSystem.arraycopy(origurls, 0, correctLengthArray, 0, urlCount);\n+\t\turlcpReadWriteLock.readLock().lock();\n+\t\ttry {\n+\t\t\tSystem.arraycopy(origurls, 0, correctLengthArray, 0, urlCount);\n+\t\t} finally {\n+\t\t\turlcpReadWriteLock.readLock().unlock();\n+\t\t}\n \t\treturn correctLengthArray;\n \t}\n \n \t@Override\n-\tpublic synchronized void confirmAllEntries() {\n-\t\tconfirmedCount = urlCount;\n+\tpublic void confirmAllEntries() {\n+\t\turlcpReadWriteLock.writeLock().lock();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEzNjY3Mw=="}, "originalCommit": {"oid": "1b70681c95131a2d4c73bc2d203ff2cd8436e53d"}, "originalPosition": 286}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE3ODI5Ng==", "bodyText": "Note that storeSharedClass() is also modifying confirmedCount using the readLock().", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436178296", "createdAt": "2020-06-05T21:46:12Z", "author": {"login": "pshipton"}, "path": "jcl/src/openj9.sharedclasses/share/classes/com/ibm/oti/shared/SharedClassURLClasspathHelperImpl.java", "diffHunk": "@@ -228,137 +246,160 @@ private synchronized void growURLs(int toMinSize) {\n \t}\n \n \t@Override\n-\tpublic synchronized void addClasspathEntry(URL cpe) {\n+\tpublic void addClasspathEntry(URL cpe) {\n \t\tClassLoader loader = getClassLoader();\n \t\tif (loader != null) {\n \t\t\tif (cpe==null) {\n \t\t\t\t/*[MSG \"K05ac\", \"URL is null for addClasspathEntry.\"]*/\n \t\t\t\tprintVerboseError(Msg.getString(\"K05ac\")); //$NON-NLS-1$\n \t\t\t\treturn;\n \t\t\t}\n-\t\t\t/* If array is not big enough, grow it */\n-\t\t\tif (urls.length < (urlCount+1)) {\n-\t\t\t\tgrowURLs(urlCount+1);\n-\t\t\t}\n-\t\t\torigurls[urlCount] = cpe;\n-\t\t\turls[urlCount] = convertJarURL(cpe);\n-\t\t\tif (!validateURL(urls[urlCount], false)) {\n-\t\t\t\tinvalidURLExists = true;\n+\t\t\tURL convertedurl = convertJarURL(cpe);\n+\t\t\tboolean invalidUrl = false;\n+\t\t\tif (!validateURL(convertedurl, false)) {\n+\t\t\t\tinvalidUrl = true;\n \t\t\t}\n-\t\t\tnotifyClasspathChange2(loader);\n-\t\t\tif (!invalidURLExists) {\n-\t\t\t\tnotifyClasspathChange3(id, loader, urls, urlCount, (urlCount + 1), true);\n+\t\t\turlcpReadWriteLock.writeLock().lock();\n+\t\t\ttry {\n+\t\t\t\t/* If array is not big enough, grow it */\n+\t\t\t\tif (urls.length < (urlCount+1)) {\n+\t\t\t\t\tgrowURLs(urlCount+1);\n+\t\t\t\t}\n+\t\t\t\torigurls[urlCount] = cpe;\n+\t\t\t\turls[urlCount] = convertedurl;\n+\t\t\t\tinvalidURLExists = invalidUrl;\n+\t\t\t\tnotifyClasspathChange2(loader);\n+\t\t\t\tif (!invalidURLExists) {\n+\t\t\t\t\tnotifyClasspathChange3(id, loader, urls, urlCount, (urlCount + 1), true);\n+\t\t\t\t}\n+\t\t\t\t++urlCount;\n+\t\t\t} finally {\n+\t\t\t\turlcpReadWriteLock.writeLock().unlock();\n \t\t\t}\n-\t\t\t++urlCount;\n \t\t}\n \t}\n \n \t/* Function required by the factory */\n-\tsynchronized URL[] getClasspath() {\n+\tURL[] getClasspath() {\n \t\tURL[] correctLengthArray = new URL[urlCount];\n-\t\tSystem.arraycopy(origurls, 0, correctLengthArray, 0, urlCount);\n+\t\turlcpReadWriteLock.readLock().lock();\n+\t\ttry {\n+\t\t\tSystem.arraycopy(origurls, 0, correctLengthArray, 0, urlCount);\n+\t\t} finally {\n+\t\t\turlcpReadWriteLock.readLock().unlock();\n+\t\t}\n \t\treturn correctLengthArray;\n \t}\n \n \t@Override\n-\tpublic synchronized void confirmAllEntries() {\n-\t\tconfirmedCount = urlCount;\n+\tpublic void confirmAllEntries() {\n+\t\turlcpReadWriteLock.writeLock().lock();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEzNjY3Mw=="}, "originalCommit": {"oid": "1b70681c95131a2d4c73bc2d203ff2cd8436e53d"}, "originalPosition": 286}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE5NTQ1OA==", "bodyText": "Actually this does seems problematic, I think confirmAllEntries() should stay as it is, and storeSharedClass() needs a fix.", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436195458", "createdAt": "2020-06-05T22:41:36Z", "author": {"login": "pshipton"}, "path": "jcl/src/openj9.sharedclasses/share/classes/com/ibm/oti/shared/SharedClassURLClasspathHelperImpl.java", "diffHunk": "@@ -228,137 +246,160 @@ private synchronized void growURLs(int toMinSize) {\n \t}\n \n \t@Override\n-\tpublic synchronized void addClasspathEntry(URL cpe) {\n+\tpublic void addClasspathEntry(URL cpe) {\n \t\tClassLoader loader = getClassLoader();\n \t\tif (loader != null) {\n \t\t\tif (cpe==null) {\n \t\t\t\t/*[MSG \"K05ac\", \"URL is null for addClasspathEntry.\"]*/\n \t\t\t\tprintVerboseError(Msg.getString(\"K05ac\")); //$NON-NLS-1$\n \t\t\t\treturn;\n \t\t\t}\n-\t\t\t/* If array is not big enough, grow it */\n-\t\t\tif (urls.length < (urlCount+1)) {\n-\t\t\t\tgrowURLs(urlCount+1);\n-\t\t\t}\n-\t\t\torigurls[urlCount] = cpe;\n-\t\t\turls[urlCount] = convertJarURL(cpe);\n-\t\t\tif (!validateURL(urls[urlCount], false)) {\n-\t\t\t\tinvalidURLExists = true;\n+\t\t\tURL convertedurl = convertJarURL(cpe);\n+\t\t\tboolean invalidUrl = false;\n+\t\t\tif (!validateURL(convertedurl, false)) {\n+\t\t\t\tinvalidUrl = true;\n \t\t\t}\n-\t\t\tnotifyClasspathChange2(loader);\n-\t\t\tif (!invalidURLExists) {\n-\t\t\t\tnotifyClasspathChange3(id, loader, urls, urlCount, (urlCount + 1), true);\n+\t\t\turlcpReadWriteLock.writeLock().lock();\n+\t\t\ttry {\n+\t\t\t\t/* If array is not big enough, grow it */\n+\t\t\t\tif (urls.length < (urlCount+1)) {\n+\t\t\t\t\tgrowURLs(urlCount+1);\n+\t\t\t\t}\n+\t\t\t\torigurls[urlCount] = cpe;\n+\t\t\t\turls[urlCount] = convertedurl;\n+\t\t\t\tinvalidURLExists = invalidUrl;\n+\t\t\t\tnotifyClasspathChange2(loader);\n+\t\t\t\tif (!invalidURLExists) {\n+\t\t\t\t\tnotifyClasspathChange3(id, loader, urls, urlCount, (urlCount + 1), true);\n+\t\t\t\t}\n+\t\t\t\t++urlCount;\n+\t\t\t} finally {\n+\t\t\t\turlcpReadWriteLock.writeLock().unlock();\n \t\t\t}\n-\t\t\t++urlCount;\n \t\t}\n \t}\n \n \t/* Function required by the factory */\n-\tsynchronized URL[] getClasspath() {\n+\tURL[] getClasspath() {\n \t\tURL[] correctLengthArray = new URL[urlCount];\n-\t\tSystem.arraycopy(origurls, 0, correctLengthArray, 0, urlCount);\n+\t\turlcpReadWriteLock.readLock().lock();\n+\t\ttry {\n+\t\t\tSystem.arraycopy(origurls, 0, correctLengthArray, 0, urlCount);\n+\t\t} finally {\n+\t\t\turlcpReadWriteLock.readLock().unlock();\n+\t\t}\n \t\treturn correctLengthArray;\n \t}\n \n \t@Override\n-\tpublic synchronized void confirmAllEntries() {\n-\t\tconfirmedCount = urlCount;\n+\tpublic void confirmAllEntries() {\n+\t\turlcpReadWriteLock.writeLock().lock();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEzNjY3Mw=="}, "originalCommit": {"oid": "1b70681c95131a2d4c73bc2d203ff2cd8436e53d"}, "originalPosition": 286}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk1OTU0Mg==", "bodyText": "Added a new function increaseConfirmedCount() that increases confirmedCount inside writeLock().", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436959542", "createdAt": "2020-06-08T19:47:24Z", "author": {"login": "hangshao0"}, "path": "jcl/src/openj9.sharedclasses/share/classes/com/ibm/oti/shared/SharedClassURLClasspathHelperImpl.java", "diffHunk": "@@ -228,137 +246,160 @@ private synchronized void growURLs(int toMinSize) {\n \t}\n \n \t@Override\n-\tpublic synchronized void addClasspathEntry(URL cpe) {\n+\tpublic void addClasspathEntry(URL cpe) {\n \t\tClassLoader loader = getClassLoader();\n \t\tif (loader != null) {\n \t\t\tif (cpe==null) {\n \t\t\t\t/*[MSG \"K05ac\", \"URL is null for addClasspathEntry.\"]*/\n \t\t\t\tprintVerboseError(Msg.getString(\"K05ac\")); //$NON-NLS-1$\n \t\t\t\treturn;\n \t\t\t}\n-\t\t\t/* If array is not big enough, grow it */\n-\t\t\tif (urls.length < (urlCount+1)) {\n-\t\t\t\tgrowURLs(urlCount+1);\n-\t\t\t}\n-\t\t\torigurls[urlCount] = cpe;\n-\t\t\turls[urlCount] = convertJarURL(cpe);\n-\t\t\tif (!validateURL(urls[urlCount], false)) {\n-\t\t\t\tinvalidURLExists = true;\n+\t\t\tURL convertedurl = convertJarURL(cpe);\n+\t\t\tboolean invalidUrl = false;\n+\t\t\tif (!validateURL(convertedurl, false)) {\n+\t\t\t\tinvalidUrl = true;\n \t\t\t}\n-\t\t\tnotifyClasspathChange2(loader);\n-\t\t\tif (!invalidURLExists) {\n-\t\t\t\tnotifyClasspathChange3(id, loader, urls, urlCount, (urlCount + 1), true);\n+\t\t\turlcpReadWriteLock.writeLock().lock();\n+\t\t\ttry {\n+\t\t\t\t/* If array is not big enough, grow it */\n+\t\t\t\tif (urls.length < (urlCount+1)) {\n+\t\t\t\t\tgrowURLs(urlCount+1);\n+\t\t\t\t}\n+\t\t\t\torigurls[urlCount] = cpe;\n+\t\t\t\turls[urlCount] = convertedurl;\n+\t\t\t\tinvalidURLExists = invalidUrl;\n+\t\t\t\tnotifyClasspathChange2(loader);\n+\t\t\t\tif (!invalidURLExists) {\n+\t\t\t\t\tnotifyClasspathChange3(id, loader, urls, urlCount, (urlCount + 1), true);\n+\t\t\t\t}\n+\t\t\t\t++urlCount;\n+\t\t\t} finally {\n+\t\t\t\turlcpReadWriteLock.writeLock().unlock();\n \t\t\t}\n-\t\t\t++urlCount;\n \t\t}\n \t}\n \n \t/* Function required by the factory */\n-\tsynchronized URL[] getClasspath() {\n+\tURL[] getClasspath() {\n \t\tURL[] correctLengthArray = new URL[urlCount];\n-\t\tSystem.arraycopy(origurls, 0, correctLengthArray, 0, urlCount);\n+\t\turlcpReadWriteLock.readLock().lock();\n+\t\ttry {\n+\t\t\tSystem.arraycopy(origurls, 0, correctLengthArray, 0, urlCount);\n+\t\t} finally {\n+\t\t\turlcpReadWriteLock.readLock().unlock();\n+\t\t}\n \t\treturn correctLengthArray;\n \t}\n \n \t@Override\n-\tpublic synchronized void confirmAllEntries() {\n-\t\tconfirmedCount = urlCount;\n+\tpublic void confirmAllEntries() {\n+\t\turlcpReadWriteLock.writeLock().lock();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEzNjY3Mw=="}, "originalCommit": {"oid": "1b70681c95131a2d4c73bc2d203ff2cd8436e53d"}, "originalPosition": 286}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNjY4ODQ3OnYy", "diffSide": "RIGHT", "path": "jcl/src/openj9.sharedclasses/share/classes/com/ibm/oti/shared/SharedClassURLHelperImpl.java", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMDowNToyNlrOGf726w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxOTo0OTowOVrOGgt8fQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEzOTc1NQ==", "bodyText": "newJarFileCheck() needs internal synchronization. Also the SharedClassFilter doesn't mention synchronization, but removing synchronized changes the behavior for calling acceptFind() and acceptStore(), these calls should remain protected.", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436139755", "createdAt": "2020-06-05T20:05:26Z", "author": {"login": "pshipton"}, "path": "jcl/src/openj9.sharedclasses/share/classes/com/ibm/oti/shared/SharedClassURLHelperImpl.java", "diffHunk": "@@ -103,7 +103,7 @@ public boolean setMinimizeUpdateChecks() {\n \t}\n \n \t@Override\n-\tpublic synchronized byte[] findSharedClass(String partition, URL path, String className) {\n+\tpublic byte[] findSharedClass(String partition, URL path, String className) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b70681c95131a2d4c73bc2d203ff2cd8436e53d"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE2NTMwNw==", "bodyText": "Also the SharedClassFilter doesn't mention synchronization, but removing synchronized changes the behavior for calling acceptFind() and acceptStore(), these calls should remain protected.\n\nYou mean removing synchronized from getSharingFilter()/setSharingFilter(), then protect the calls of getSharingFilter(), setSharingFilter(), acceptFind() and acceptStore() within readWriteLock ?", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436165307", "createdAt": "2020-06-05T21:09:16Z", "author": {"login": "hangshao0"}, "path": "jcl/src/openj9.sharedclasses/share/classes/com/ibm/oti/shared/SharedClassURLHelperImpl.java", "diffHunk": "@@ -103,7 +103,7 @@ public boolean setMinimizeUpdateChecks() {\n \t}\n \n \t@Override\n-\tpublic synchronized byte[] findSharedClass(String partition, URL path, String className) {\n+\tpublic byte[] findSharedClass(String partition, URL path, String className) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEzOTc1NQ=="}, "originalCommit": {"oid": "1b70681c95131a2d4c73bc2d203ff2cd8436e53d"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE3NDU0MQ==", "bodyText": "newJarFileCheck() needs internal synchronization.\n\nI am thinking about changing jarFileNameCache from a regular Set to ConcurrentHashMap.newKeySet().", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436174541", "createdAt": "2020-06-05T21:35:21Z", "author": {"login": "hangshao0"}, "path": "jcl/src/openj9.sharedclasses/share/classes/com/ibm/oti/shared/SharedClassURLHelperImpl.java", "diffHunk": "@@ -103,7 +103,7 @@ public boolean setMinimizeUpdateChecks() {\n \t}\n \n \t@Override\n-\tpublic synchronized byte[] findSharedClass(String partition, URL path, String className) {\n+\tpublic byte[] findSharedClass(String partition, URL path, String className) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEzOTc1NQ=="}, "originalCommit": {"oid": "1b70681c95131a2d4c73bc2d203ff2cd8436e53d"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE3NDkyMw==", "bodyText": "It doesn't need to use the readWriteLock(), but something should keep the synchronized behavior of calling acceptFind() and acceptStore() the same. Similarly, getSharingFilter()/setSharingFilter() are fine the way they are since they are already synchronized.", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436174923", "createdAt": "2020-06-05T21:36:28Z", "author": {"login": "pshipton"}, "path": "jcl/src/openj9.sharedclasses/share/classes/com/ibm/oti/shared/SharedClassURLHelperImpl.java", "diffHunk": "@@ -103,7 +103,7 @@ public boolean setMinimizeUpdateChecks() {\n \t}\n \n \t@Override\n-\tpublic synchronized byte[] findSharedClass(String partition, URL path, String className) {\n+\tpublic byte[] findSharedClass(String partition, URL path, String className) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEzOTc1NQ=="}, "originalCommit": {"oid": "1b70681c95131a2d4c73bc2d203ff2cd8436e53d"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE3NzAwMQ==", "bodyText": "I am thinking about changing jarFileNameCache from a regular Set to ConcurrentHashMap.newKeySet()\n\nAs long as it doesn't cause a measurable increase in footprint.", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436177001", "createdAt": "2020-06-05T21:42:32Z", "author": {"login": "pshipton"}, "path": "jcl/src/openj9.sharedclasses/share/classes/com/ibm/oti/shared/SharedClassURLHelperImpl.java", "diffHunk": "@@ -103,7 +103,7 @@ public boolean setMinimizeUpdateChecks() {\n \t}\n \n \t@Override\n-\tpublic synchronized byte[] findSharedClass(String partition, URL path, String className) {\n+\tpublic byte[] findSharedClass(String partition, URL path, String className) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEzOTc1NQ=="}, "originalCommit": {"oid": "1b70681c95131a2d4c73bc2d203ff2cd8436e53d"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk2MDM4MQ==", "bodyText": "Changed jarFileNameCache to a concurrent Set and wrap acceptFind()/acceptStore() inside a synchronized block.", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436960381", "createdAt": "2020-06-08T19:49:09Z", "author": {"login": "hangshao0"}, "path": "jcl/src/openj9.sharedclasses/share/classes/com/ibm/oti/shared/SharedClassURLHelperImpl.java", "diffHunk": "@@ -103,7 +103,7 @@ public boolean setMinimizeUpdateChecks() {\n \t}\n \n \t@Override\n-\tpublic synchronized byte[] findSharedClass(String partition, URL path, String className) {\n+\tpublic byte[] findSharedClass(String partition, URL path, String className) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEzOTc1NQ=="}, "originalCommit": {"oid": "1b70681c95131a2d4c73bc2d203ff2cd8436e53d"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyMjI0MDU2OnYy", "diffSide": "RIGHT", "path": "jcl/src/openj9.sharedclasses/share/classes/com/ibm/oti/shared/SharedClassURLHelperImpl.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQyMDoyMTowN1rOGgu8Vg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQyMToxODo0NVrOGgwzaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk3NjcyNg==", "bodyText": "Better to keep the old behavior and synchronize on the instance of SharedClassURLHelperImpl than to start synchronizing on the user supplied object, which could have unexpected side effects. Or best is to synchronize on an internal Object.", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436976726", "createdAt": "2020-06-08T20:21:07Z", "author": {"login": "pshipton"}, "path": "jcl/src/openj9.sharedclasses/share/classes/com/ibm/oti/shared/SharedClassURLHelperImpl.java", "diffHunk": "@@ -126,12 +125,14 @@ public boolean setMinimizeUpdateChecks() {\n \t\tSharedClassFilter theFilter = getSharingFilter();\n \t\tboolean doFind, doStore;\n \t\tif (theFilter!=null) {\n-\t\t\tdoFind = theFilter.acceptFind(className);\n-\t\t\t/* Don't invoke the store filter if the cache is full */\n-\t\t\tif (nativeFlags[CACHE_FULL_FLAG] == 0) {\n-\t\t\t\tdoStore = theFilter.acceptStore(className);\n-\t\t\t} else {\n-\t\t\t\tdoStore = true;\n+\t\t\tsynchronized(theFilter) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7849dead8a04a198c372dc35dcfc218aa5db8cd0"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk3OTMwOA==", "bodyText": "Note the same synchronization changes are also needed in SharedClassURLClasspathHelperImpl and SharedClassTokenHelperImpl.", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436979308", "createdAt": "2020-06-08T20:26:02Z", "author": {"login": "pshipton"}, "path": "jcl/src/openj9.sharedclasses/share/classes/com/ibm/oti/shared/SharedClassURLHelperImpl.java", "diffHunk": "@@ -126,12 +125,14 @@ public boolean setMinimizeUpdateChecks() {\n \t\tSharedClassFilter theFilter = getSharingFilter();\n \t\tboolean doFind, doStore;\n \t\tif (theFilter!=null) {\n-\t\t\tdoFind = theFilter.acceptFind(className);\n-\t\t\t/* Don't invoke the store filter if the cache is full */\n-\t\t\tif (nativeFlags[CACHE_FULL_FLAG] == 0) {\n-\t\t\t\tdoStore = theFilter.acceptStore(className);\n-\t\t\t} else {\n-\t\t\t\tdoStore = true;\n+\t\t\tsynchronized(theFilter) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk3NjcyNg=="}, "originalCommit": {"oid": "7849dead8a04a198c372dc35dcfc218aa5db8cd0"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAwNzIwOQ==", "bodyText": "I didn't find proper internal obj to sync in SharedClassURLHelperImpl and SharedClassTokenHelperImpl, so I am synchronizing on this.", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r437007209", "createdAt": "2020-06-08T21:18:45Z", "author": {"login": "hangshao0"}, "path": "jcl/src/openj9.sharedclasses/share/classes/com/ibm/oti/shared/SharedClassURLHelperImpl.java", "diffHunk": "@@ -126,12 +125,14 @@ public boolean setMinimizeUpdateChecks() {\n \t\tSharedClassFilter theFilter = getSharingFilter();\n \t\tboolean doFind, doStore;\n \t\tif (theFilter!=null) {\n-\t\t\tdoFind = theFilter.acceptFind(className);\n-\t\t\t/* Don't invoke the store filter if the cache is full */\n-\t\t\tif (nativeFlags[CACHE_FULL_FLAG] == 0) {\n-\t\t\t\tdoStore = theFilter.acceptStore(className);\n-\t\t\t} else {\n-\t\t\t\tdoStore = true;\n+\t\t\tsynchronized(theFilter) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk3NjcyNg=="}, "originalCommit": {"oid": "7849dead8a04a198c372dc35dcfc218aa5db8cd0"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyMjI4MTY5OnYy", "diffSide": "RIGHT", "path": "jcl/src/openj9.sharedclasses/share/classes/com/ibm/oti/shared/SharedClassURLClasspathHelperImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQyMDozMzoyMVrOGgvXVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQyMToxMToyNlrOGgwk0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk4MzYzOA==", "bodyText": "This is another writer.", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436983638", "createdAt": "2020-06-08T20:33:21Z", "author": {"login": "pshipton"}, "path": "jcl/src/openj9.sharedclasses/share/classes/com/ibm/oti/shared/SharedClassURLClasspathHelperImpl.java", "diffHunk": "@@ -166,53 +175,66 @@ public synchronized boolean storeSharedClass(String partition, Class<?> clazz, i\n \t\t\tprintVerboseError(Msg.getString(\"K05a3\")); //$NON-NLS-1$\n \t\t\treturn false;\n \t\t}\n-\t\tif (urlCount==0) {\n-\t\t\t/*[MSG \"K05a6\", \"Classpath has zero elements. Cannot call storeSharedClass without classpath. Returning false.\"]*/\n-\t\t\tprintVerboseError(Msg.getString(\"K05a6\")); //$NON-NLS-1$\n-\t\t\treturn false;\n-\t\t}\n+\t\t\n \t\tif (foundAtIndex<0) {\n \t\t\t/*[MSG \"K05a7\", \"foundAtIndex cannot be <0 for storeSharedClass. Returning false.\"]*/\n \t\t\tprintVerboseError(Msg.getString(\"K05a7\")); //$NON-NLS-1$\n \t\t\treturn false;\n \t\t}\n-\t\tif (foundAtIndex>=urlCount) {\n-\t\t\t/*[MSG \"K05a8\", \"foundAtIndex cannot be >= urls in classpath for storeSharedClass. Returning false.\"]*/\n-\t\t\tprintVerboseError(Msg.getString(\"K05a8\")); //$NON-NLS-1$\n-\t\t\treturn false;\n-\t\t}\n-\t\tif (invalidURLExists) {\n-\t\t\t/* Any URL which has its protocol other than 'jar:' or 'file:' is not supported by\n-\t\t\t * shared class cache and is considered invalid.\n-\t\t\t * invalidURLExists = true indicates classpath contains an invalid URL,\n-\t\t\t * As such there is no point in calling native method storeSharedClassImpl2() \n-\t\t\t * since it is bound to fail when creating classpath entries.\n-\t\t\t */\t\t\t\n-\t\t\t/*[MSG \"K05a9\", \"Classpath contains an invalid URL. Returning false.\"]*/\n-\t\t\tprintVerboseInfo(Msg.getString(\"K05a9\")); //$NON-NLS-1$\n-\t\t\treturn false;\n-\t\t}\n-\t\tif (!validated[foundAtIndex]) {\n-\t\t\t/* Because we only check each element once, we can afford to also check whether the URL exists */\n-\t\t\tif (!validateURL(urls[foundAtIndex], true)) {\n-\t\t\t\treturn false;\n-\t\t\t}\n-\t\t\tvalidated[foundAtIndex]=true;\n-\t\t}\n \t\tClassLoader actualLoader = getClassLoader();\n \t\tif (!validateClassLoader(actualLoader, clazz)) {\n \t\t\t/* Attempt to call storeSharedClass with class defined by a different classloader */\n \t\t\treturn false;\n \t\t}\n-\t\tif (confirmedCount <= foundAtIndex) {\n-\t\t\tconfirmedCount = foundAtIndex+1;\n-\t\t\t/*[MSG \"K05aa\", \"Number of confirmed entries is now {0}\"]*/\n-\t\t\tprintVerboseInfo(Msg.getString(\"K05aa\", confirmedCount)); //$NON-NLS-1$\n+\t\tboolean storeRet = false;\n+\t\tboolean incConfirmedCount = false;\n+\t\turlcpReadWriteLock.readLock().lock();\n+\t\ttry {\n+\t\t\tif (urlCount==0) {\n+\t\t\t\t/*[MSG \"K05a6\", \"Classpath has zero elements. Cannot call storeSharedClass without classpath. Returning false.\"]*/\n+\t\t\t\tprintVerboseError(Msg.getString(\"K05a6\")); //$NON-NLS-1$\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tif (foundAtIndex>=urlCount) {\n+\t\t\t\t/*[MSG \"K05a8\", \"foundAtIndex cannot be >= urls in classpath for storeSharedClass. Returning false.\"]*/\n+\t\t\t\tprintVerboseError(Msg.getString(\"K05a8\")); //$NON-NLS-1$\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tif (invalidURLExists) {\n+\t\t\t\t/* Any URL which has its protocol other than 'jar:' or 'file:' is not supported by\n+\t\t\t\t * shared class cache and is considered invalid.\n+\t\t\t\t * invalidURLExists = true indicates classpath contains an invalid URL,\n+\t\t\t\t * As such there is no point in calling native method storeSharedClassImpl2() \n+\t\t\t\t * since it is bound to fail when creating classpath entries.\n+\t\t\t\t */\t\t\t\n+\t\t\t\t/*[MSG \"K05a9\", \"Classpath contains an invalid URL. Returning false.\"]*/\n+\t\t\t\tprintVerboseInfo(Msg.getString(\"K05a9\")); //$NON-NLS-1$\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tif (!validated[foundAtIndex]) {\n+\t\t\t\t/* Because we only check each element once, we can afford to also check whether the URL exists */\n+\t\t\t\tif (!validateURL(urls[foundAtIndex], true)) {\n+\t\t\t\t\treturn false;\n+\t\t\t\t}\n+\t\t\t\tvalidated[foundAtIndex]=true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7849dead8a04a198c372dc35dcfc218aa5db8cd0"}, "originalPosition": 197}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAwMzQ3NQ==", "bodyText": "Fixed.", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r437003475", "createdAt": "2020-06-08T21:11:26Z", "author": {"login": "hangshao0"}, "path": "jcl/src/openj9.sharedclasses/share/classes/com/ibm/oti/shared/SharedClassURLClasspathHelperImpl.java", "diffHunk": "@@ -166,53 +175,66 @@ public synchronized boolean storeSharedClass(String partition, Class<?> clazz, i\n \t\t\tprintVerboseError(Msg.getString(\"K05a3\")); //$NON-NLS-1$\n \t\t\treturn false;\n \t\t}\n-\t\tif (urlCount==0) {\n-\t\t\t/*[MSG \"K05a6\", \"Classpath has zero elements. Cannot call storeSharedClass without classpath. Returning false.\"]*/\n-\t\t\tprintVerboseError(Msg.getString(\"K05a6\")); //$NON-NLS-1$\n-\t\t\treturn false;\n-\t\t}\n+\t\t\n \t\tif (foundAtIndex<0) {\n \t\t\t/*[MSG \"K05a7\", \"foundAtIndex cannot be <0 for storeSharedClass. Returning false.\"]*/\n \t\t\tprintVerboseError(Msg.getString(\"K05a7\")); //$NON-NLS-1$\n \t\t\treturn false;\n \t\t}\n-\t\tif (foundAtIndex>=urlCount) {\n-\t\t\t/*[MSG \"K05a8\", \"foundAtIndex cannot be >= urls in classpath for storeSharedClass. Returning false.\"]*/\n-\t\t\tprintVerboseError(Msg.getString(\"K05a8\")); //$NON-NLS-1$\n-\t\t\treturn false;\n-\t\t}\n-\t\tif (invalidURLExists) {\n-\t\t\t/* Any URL which has its protocol other than 'jar:' or 'file:' is not supported by\n-\t\t\t * shared class cache and is considered invalid.\n-\t\t\t * invalidURLExists = true indicates classpath contains an invalid URL,\n-\t\t\t * As such there is no point in calling native method storeSharedClassImpl2() \n-\t\t\t * since it is bound to fail when creating classpath entries.\n-\t\t\t */\t\t\t\n-\t\t\t/*[MSG \"K05a9\", \"Classpath contains an invalid URL. Returning false.\"]*/\n-\t\t\tprintVerboseInfo(Msg.getString(\"K05a9\")); //$NON-NLS-1$\n-\t\t\treturn false;\n-\t\t}\n-\t\tif (!validated[foundAtIndex]) {\n-\t\t\t/* Because we only check each element once, we can afford to also check whether the URL exists */\n-\t\t\tif (!validateURL(urls[foundAtIndex], true)) {\n-\t\t\t\treturn false;\n-\t\t\t}\n-\t\t\tvalidated[foundAtIndex]=true;\n-\t\t}\n \t\tClassLoader actualLoader = getClassLoader();\n \t\tif (!validateClassLoader(actualLoader, clazz)) {\n \t\t\t/* Attempt to call storeSharedClass with class defined by a different classloader */\n \t\t\treturn false;\n \t\t}\n-\t\tif (confirmedCount <= foundAtIndex) {\n-\t\t\tconfirmedCount = foundAtIndex+1;\n-\t\t\t/*[MSG \"K05aa\", \"Number of confirmed entries is now {0}\"]*/\n-\t\t\tprintVerboseInfo(Msg.getString(\"K05aa\", confirmedCount)); //$NON-NLS-1$\n+\t\tboolean storeRet = false;\n+\t\tboolean incConfirmedCount = false;\n+\t\turlcpReadWriteLock.readLock().lock();\n+\t\ttry {\n+\t\t\tif (urlCount==0) {\n+\t\t\t\t/*[MSG \"K05a6\", \"Classpath has zero elements. Cannot call storeSharedClass without classpath. Returning false.\"]*/\n+\t\t\t\tprintVerboseError(Msg.getString(\"K05a6\")); //$NON-NLS-1$\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tif (foundAtIndex>=urlCount) {\n+\t\t\t\t/*[MSG \"K05a8\", \"foundAtIndex cannot be >= urls in classpath for storeSharedClass. Returning false.\"]*/\n+\t\t\t\tprintVerboseError(Msg.getString(\"K05a8\")); //$NON-NLS-1$\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tif (invalidURLExists) {\n+\t\t\t\t/* Any URL which has its protocol other than 'jar:' or 'file:' is not supported by\n+\t\t\t\t * shared class cache and is considered invalid.\n+\t\t\t\t * invalidURLExists = true indicates classpath contains an invalid URL,\n+\t\t\t\t * As such there is no point in calling native method storeSharedClassImpl2() \n+\t\t\t\t * since it is bound to fail when creating classpath entries.\n+\t\t\t\t */\t\t\t\n+\t\t\t\t/*[MSG \"K05a9\", \"Classpath contains an invalid URL. Returning false.\"]*/\n+\t\t\t\tprintVerboseInfo(Msg.getString(\"K05a9\")); //$NON-NLS-1$\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tif (!validated[foundAtIndex]) {\n+\t\t\t\t/* Because we only check each element once, we can afford to also check whether the URL exists */\n+\t\t\t\tif (!validateURL(urls[foundAtIndex], true)) {\n+\t\t\t\t\treturn false;\n+\t\t\t\t}\n+\t\t\t\tvalidated[foundAtIndex]=true;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk4MzYzOA=="}, "originalCommit": {"oid": "7849dead8a04a198c372dc35dcfc218aa5db8cd0"}, "originalPosition": 197}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyMjQ0MjM3OnYy", "diffSide": "RIGHT", "path": "jcl/src/openj9.sharedclasses/share/classes/com/ibm/oti/shared/SharedClassURLClasspathHelperImpl.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQyMToyMzoxNVrOGgw8Hg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQyMjowMToyMFrOGgx8Cg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAwOTQzOA==", "bodyText": "Might as well combine updating validated and confirmedCount to use a single writeLock().lock().", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r437009438", "createdAt": "2020-06-08T21:23:15Z", "author": {"login": "pshipton"}, "path": "jcl/src/openj9.sharedclasses/share/classes/com/ibm/oti/shared/SharedClassURLClasspathHelperImpl.java", "diffHunk": "@@ -166,53 +177,70 @@ public synchronized boolean storeSharedClass(String partition, Class<?> clazz, i\n \t\t\tprintVerboseError(Msg.getString(\"K05a3\")); //$NON-NLS-1$\n \t\t\treturn false;\n \t\t}\n-\t\tif (urlCount==0) {\n-\t\t\t/*[MSG \"K05a6\", \"Classpath has zero elements. Cannot call storeSharedClass without classpath. Returning false.\"]*/\n-\t\t\tprintVerboseError(Msg.getString(\"K05a6\")); //$NON-NLS-1$\n-\t\t\treturn false;\n-\t\t}\n+\t\t\n \t\tif (foundAtIndex<0) {\n \t\t\t/*[MSG \"K05a7\", \"foundAtIndex cannot be <0 for storeSharedClass. Returning false.\"]*/\n \t\t\tprintVerboseError(Msg.getString(\"K05a7\")); //$NON-NLS-1$\n \t\t\treturn false;\n \t\t}\n-\t\tif (foundAtIndex>=urlCount) {\n-\t\t\t/*[MSG \"K05a8\", \"foundAtIndex cannot be >= urls in classpath for storeSharedClass. Returning false.\"]*/\n-\t\t\tprintVerboseError(Msg.getString(\"K05a8\")); //$NON-NLS-1$\n-\t\t\treturn false;\n-\t\t}\n-\t\tif (invalidURLExists) {\n-\t\t\t/* Any URL which has its protocol other than 'jar:' or 'file:' is not supported by\n-\t\t\t * shared class cache and is considered invalid.\n-\t\t\t * invalidURLExists = true indicates classpath contains an invalid URL,\n-\t\t\t * As such there is no point in calling native method storeSharedClassImpl2() \n-\t\t\t * since it is bound to fail when creating classpath entries.\n-\t\t\t */\t\t\t\n-\t\t\t/*[MSG \"K05a9\", \"Classpath contains an invalid URL. Returning false.\"]*/\n-\t\t\tprintVerboseInfo(Msg.getString(\"K05a9\")); //$NON-NLS-1$\n+\t\tClassLoader actualLoader = getClassLoader();\n+\t\tif (!validateClassLoader(actualLoader, clazz)) {\n+\t\t\t/* Attempt to call storeSharedClass with class defined by a different classloader */\n \t\t\treturn false;\n \t\t}\n-\t\tif (!validated[foundAtIndex]) {\n-\t\t\t/* Because we only check each element once, we can afford to also check whether the URL exists */\n-\t\t\tif (!validateURL(urls[foundAtIndex], true)) {\n+\t\tboolean storeRet = false;\n+\t\tboolean incConfirmedCount = false;\n+\t\tboolean urlValidated = false;\n+\t\turlcpReadWriteLock.readLock().lock();\n+\t\ttry {\n+\t\t\tif (urlCount==0) {\n+\t\t\t\t/*[MSG \"K05a6\", \"Classpath has zero elements. Cannot call storeSharedClass without classpath. Returning false.\"]*/\n+\t\t\t\tprintVerboseError(Msg.getString(\"K05a6\")); //$NON-NLS-1$\n \t\t\t\treturn false;\n \t\t\t}\n-\t\t\tvalidated[foundAtIndex]=true;\n+\t\t\tif (foundAtIndex>=urlCount) {\n+\t\t\t\t/*[MSG \"K05a8\", \"foundAtIndex cannot be >= urls in classpath for storeSharedClass. Returning false.\"]*/\n+\t\t\t\tprintVerboseError(Msg.getString(\"K05a8\")); //$NON-NLS-1$\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tif (invalidURLExists) {\n+\t\t\t\t/* Any URL which has its protocol other than 'jar:' or 'file:' is not supported by\n+\t\t\t\t * shared class cache and is considered invalid.\n+\t\t\t\t * invalidURLExists = true indicates classpath contains an invalid URL,\n+\t\t\t\t * As such there is no point in calling native method storeSharedClassImpl2() \n+\t\t\t\t * since it is bound to fail when creating classpath entries.\n+\t\t\t\t */\t\t\t\n+\t\t\t\t/*[MSG \"K05a9\", \"Classpath contains an invalid URL. Returning false.\"]*/\n+\t\t\t\tprintVerboseInfo(Msg.getString(\"K05a9\")); //$NON-NLS-1$\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tif (!validated[foundAtIndex]) {\n+\t\t\t\t/* Because we only check each element once, we can afford to also check whether the URL exists */\n+\t\t\t\tif (!validateURL(urls[foundAtIndex], true)) {\n+\t\t\t\t\treturn false;\n+\t\t\t\t} \n+\t\t\t\turlValidated = true;\n+\t\t\t}\n+\t\t\tif (confirmedCount <= foundAtIndex) {\n+\t\t\t\tincConfirmedCount = true;\n+\t\t\t}\n+\t\t\tstoreRet = storeSharedClassImpl2(this.id, partition, actualLoader, this.urls, this.urlCount, foundAtIndex, clazz, nativeFlags);\n+\t\t} finally {\n+\t\t\turlcpReadWriteLock.readLock().unlock();\n \t\t}\n-\t\tClassLoader actualLoader = getClassLoader();\n-\t\tif (!validateClassLoader(actualLoader, clazz)) {\n-\t\t\t/* Attempt to call storeSharedClass with class defined by a different classloader */\n-\t\t\treturn false;\n+\t\tif (urlValidated) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf41616c6fd61ef9d10289c8261bcfda7f53c33f"}, "originalPosition": 218}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAxMzc0Mw==", "bodyText": "I added setValidatedAtIndex(), but I am wondering if we really need that. I guess the previous code that sets validated[foundAtIndex]=true; inside readLock should be fine, we just may have multiple threads setting it to true, which won't have any negative impact.", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r437013743", "createdAt": "2020-06-08T21:32:53Z", "author": {"login": "hangshao0"}, "path": "jcl/src/openj9.sharedclasses/share/classes/com/ibm/oti/shared/SharedClassURLClasspathHelperImpl.java", "diffHunk": "@@ -166,53 +177,70 @@ public synchronized boolean storeSharedClass(String partition, Class<?> clazz, i\n \t\t\tprintVerboseError(Msg.getString(\"K05a3\")); //$NON-NLS-1$\n \t\t\treturn false;\n \t\t}\n-\t\tif (urlCount==0) {\n-\t\t\t/*[MSG \"K05a6\", \"Classpath has zero elements. Cannot call storeSharedClass without classpath. Returning false.\"]*/\n-\t\t\tprintVerboseError(Msg.getString(\"K05a6\")); //$NON-NLS-1$\n-\t\t\treturn false;\n-\t\t}\n+\t\t\n \t\tif (foundAtIndex<0) {\n \t\t\t/*[MSG \"K05a7\", \"foundAtIndex cannot be <0 for storeSharedClass. Returning false.\"]*/\n \t\t\tprintVerboseError(Msg.getString(\"K05a7\")); //$NON-NLS-1$\n \t\t\treturn false;\n \t\t}\n-\t\tif (foundAtIndex>=urlCount) {\n-\t\t\t/*[MSG \"K05a8\", \"foundAtIndex cannot be >= urls in classpath for storeSharedClass. Returning false.\"]*/\n-\t\t\tprintVerboseError(Msg.getString(\"K05a8\")); //$NON-NLS-1$\n-\t\t\treturn false;\n-\t\t}\n-\t\tif (invalidURLExists) {\n-\t\t\t/* Any URL which has its protocol other than 'jar:' or 'file:' is not supported by\n-\t\t\t * shared class cache and is considered invalid.\n-\t\t\t * invalidURLExists = true indicates classpath contains an invalid URL,\n-\t\t\t * As such there is no point in calling native method storeSharedClassImpl2() \n-\t\t\t * since it is bound to fail when creating classpath entries.\n-\t\t\t */\t\t\t\n-\t\t\t/*[MSG \"K05a9\", \"Classpath contains an invalid URL. Returning false.\"]*/\n-\t\t\tprintVerboseInfo(Msg.getString(\"K05a9\")); //$NON-NLS-1$\n+\t\tClassLoader actualLoader = getClassLoader();\n+\t\tif (!validateClassLoader(actualLoader, clazz)) {\n+\t\t\t/* Attempt to call storeSharedClass with class defined by a different classloader */\n \t\t\treturn false;\n \t\t}\n-\t\tif (!validated[foundAtIndex]) {\n-\t\t\t/* Because we only check each element once, we can afford to also check whether the URL exists */\n-\t\t\tif (!validateURL(urls[foundAtIndex], true)) {\n+\t\tboolean storeRet = false;\n+\t\tboolean incConfirmedCount = false;\n+\t\tboolean urlValidated = false;\n+\t\turlcpReadWriteLock.readLock().lock();\n+\t\ttry {\n+\t\t\tif (urlCount==0) {\n+\t\t\t\t/*[MSG \"K05a6\", \"Classpath has zero elements. Cannot call storeSharedClass without classpath. Returning false.\"]*/\n+\t\t\t\tprintVerboseError(Msg.getString(\"K05a6\")); //$NON-NLS-1$\n \t\t\t\treturn false;\n \t\t\t}\n-\t\t\tvalidated[foundAtIndex]=true;\n+\t\t\tif (foundAtIndex>=urlCount) {\n+\t\t\t\t/*[MSG \"K05a8\", \"foundAtIndex cannot be >= urls in classpath for storeSharedClass. Returning false.\"]*/\n+\t\t\t\tprintVerboseError(Msg.getString(\"K05a8\")); //$NON-NLS-1$\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tif (invalidURLExists) {\n+\t\t\t\t/* Any URL which has its protocol other than 'jar:' or 'file:' is not supported by\n+\t\t\t\t * shared class cache and is considered invalid.\n+\t\t\t\t * invalidURLExists = true indicates classpath contains an invalid URL,\n+\t\t\t\t * As such there is no point in calling native method storeSharedClassImpl2() \n+\t\t\t\t * since it is bound to fail when creating classpath entries.\n+\t\t\t\t */\t\t\t\n+\t\t\t\t/*[MSG \"K05a9\", \"Classpath contains an invalid URL. Returning false.\"]*/\n+\t\t\t\tprintVerboseInfo(Msg.getString(\"K05a9\")); //$NON-NLS-1$\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tif (!validated[foundAtIndex]) {\n+\t\t\t\t/* Because we only check each element once, we can afford to also check whether the URL exists */\n+\t\t\t\tif (!validateURL(urls[foundAtIndex], true)) {\n+\t\t\t\t\treturn false;\n+\t\t\t\t} \n+\t\t\t\turlValidated = true;\n+\t\t\t}\n+\t\t\tif (confirmedCount <= foundAtIndex) {\n+\t\t\t\tincConfirmedCount = true;\n+\t\t\t}\n+\t\t\tstoreRet = storeSharedClassImpl2(this.id, partition, actualLoader, this.urls, this.urlCount, foundAtIndex, clazz, nativeFlags);\n+\t\t} finally {\n+\t\t\turlcpReadWriteLock.readLock().unlock();\n \t\t}\n-\t\tClassLoader actualLoader = getClassLoader();\n-\t\tif (!validateClassLoader(actualLoader, clazz)) {\n-\t\t\t/* Attempt to call storeSharedClass with class defined by a different classloader */\n-\t\t\treturn false;\n+\t\tif (urlValidated) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAwOTQzOA=="}, "originalCommit": {"oid": "cf41616c6fd61ef9d10289c8261bcfda7f53c33f"}, "originalPosition": 218}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAyMzAxMQ==", "bodyText": "I'm ok with that.", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r437023011", "createdAt": "2020-06-08T21:54:38Z", "author": {"login": "pshipton"}, "path": "jcl/src/openj9.sharedclasses/share/classes/com/ibm/oti/shared/SharedClassURLClasspathHelperImpl.java", "diffHunk": "@@ -166,53 +177,70 @@ public synchronized boolean storeSharedClass(String partition, Class<?> clazz, i\n \t\t\tprintVerboseError(Msg.getString(\"K05a3\")); //$NON-NLS-1$\n \t\t\treturn false;\n \t\t}\n-\t\tif (urlCount==0) {\n-\t\t\t/*[MSG \"K05a6\", \"Classpath has zero elements. Cannot call storeSharedClass without classpath. Returning false.\"]*/\n-\t\t\tprintVerboseError(Msg.getString(\"K05a6\")); //$NON-NLS-1$\n-\t\t\treturn false;\n-\t\t}\n+\t\t\n \t\tif (foundAtIndex<0) {\n \t\t\t/*[MSG \"K05a7\", \"foundAtIndex cannot be <0 for storeSharedClass. Returning false.\"]*/\n \t\t\tprintVerboseError(Msg.getString(\"K05a7\")); //$NON-NLS-1$\n \t\t\treturn false;\n \t\t}\n-\t\tif (foundAtIndex>=urlCount) {\n-\t\t\t/*[MSG \"K05a8\", \"foundAtIndex cannot be >= urls in classpath for storeSharedClass. Returning false.\"]*/\n-\t\t\tprintVerboseError(Msg.getString(\"K05a8\")); //$NON-NLS-1$\n-\t\t\treturn false;\n-\t\t}\n-\t\tif (invalidURLExists) {\n-\t\t\t/* Any URL which has its protocol other than 'jar:' or 'file:' is not supported by\n-\t\t\t * shared class cache and is considered invalid.\n-\t\t\t * invalidURLExists = true indicates classpath contains an invalid URL,\n-\t\t\t * As such there is no point in calling native method storeSharedClassImpl2() \n-\t\t\t * since it is bound to fail when creating classpath entries.\n-\t\t\t */\t\t\t\n-\t\t\t/*[MSG \"K05a9\", \"Classpath contains an invalid URL. Returning false.\"]*/\n-\t\t\tprintVerboseInfo(Msg.getString(\"K05a9\")); //$NON-NLS-1$\n+\t\tClassLoader actualLoader = getClassLoader();\n+\t\tif (!validateClassLoader(actualLoader, clazz)) {\n+\t\t\t/* Attempt to call storeSharedClass with class defined by a different classloader */\n \t\t\treturn false;\n \t\t}\n-\t\tif (!validated[foundAtIndex]) {\n-\t\t\t/* Because we only check each element once, we can afford to also check whether the URL exists */\n-\t\t\tif (!validateURL(urls[foundAtIndex], true)) {\n+\t\tboolean storeRet = false;\n+\t\tboolean incConfirmedCount = false;\n+\t\tboolean urlValidated = false;\n+\t\turlcpReadWriteLock.readLock().lock();\n+\t\ttry {\n+\t\t\tif (urlCount==0) {\n+\t\t\t\t/*[MSG \"K05a6\", \"Classpath has zero elements. Cannot call storeSharedClass without classpath. Returning false.\"]*/\n+\t\t\t\tprintVerboseError(Msg.getString(\"K05a6\")); //$NON-NLS-1$\n \t\t\t\treturn false;\n \t\t\t}\n-\t\t\tvalidated[foundAtIndex]=true;\n+\t\t\tif (foundAtIndex>=urlCount) {\n+\t\t\t\t/*[MSG \"K05a8\", \"foundAtIndex cannot be >= urls in classpath for storeSharedClass. Returning false.\"]*/\n+\t\t\t\tprintVerboseError(Msg.getString(\"K05a8\")); //$NON-NLS-1$\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tif (invalidURLExists) {\n+\t\t\t\t/* Any URL which has its protocol other than 'jar:' or 'file:' is not supported by\n+\t\t\t\t * shared class cache and is considered invalid.\n+\t\t\t\t * invalidURLExists = true indicates classpath contains an invalid URL,\n+\t\t\t\t * As such there is no point in calling native method storeSharedClassImpl2() \n+\t\t\t\t * since it is bound to fail when creating classpath entries.\n+\t\t\t\t */\t\t\t\n+\t\t\t\t/*[MSG \"K05a9\", \"Classpath contains an invalid URL. Returning false.\"]*/\n+\t\t\t\tprintVerboseInfo(Msg.getString(\"K05a9\")); //$NON-NLS-1$\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tif (!validated[foundAtIndex]) {\n+\t\t\t\t/* Because we only check each element once, we can afford to also check whether the URL exists */\n+\t\t\t\tif (!validateURL(urls[foundAtIndex], true)) {\n+\t\t\t\t\treturn false;\n+\t\t\t\t} \n+\t\t\t\turlValidated = true;\n+\t\t\t}\n+\t\t\tif (confirmedCount <= foundAtIndex) {\n+\t\t\t\tincConfirmedCount = true;\n+\t\t\t}\n+\t\t\tstoreRet = storeSharedClassImpl2(this.id, partition, actualLoader, this.urls, this.urlCount, foundAtIndex, clazz, nativeFlags);\n+\t\t} finally {\n+\t\t\turlcpReadWriteLock.readLock().unlock();\n \t\t}\n-\t\tClassLoader actualLoader = getClassLoader();\n-\t\tif (!validateClassLoader(actualLoader, clazz)) {\n-\t\t\t/* Attempt to call storeSharedClass with class defined by a different classloader */\n-\t\t\treturn false;\n+\t\tif (urlValidated) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAwOTQzOA=="}, "originalCommit": {"oid": "cf41616c6fd61ef9d10289c8261bcfda7f53c33f"}, "originalPosition": 218}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAyNTgwMg==", "bodyText": "setValidatedAtIndex() removed.", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r437025802", "createdAt": "2020-06-08T22:01:20Z", "author": {"login": "hangshao0"}, "path": "jcl/src/openj9.sharedclasses/share/classes/com/ibm/oti/shared/SharedClassURLClasspathHelperImpl.java", "diffHunk": "@@ -166,53 +177,70 @@ public synchronized boolean storeSharedClass(String partition, Class<?> clazz, i\n \t\t\tprintVerboseError(Msg.getString(\"K05a3\")); //$NON-NLS-1$\n \t\t\treturn false;\n \t\t}\n-\t\tif (urlCount==0) {\n-\t\t\t/*[MSG \"K05a6\", \"Classpath has zero elements. Cannot call storeSharedClass without classpath. Returning false.\"]*/\n-\t\t\tprintVerboseError(Msg.getString(\"K05a6\")); //$NON-NLS-1$\n-\t\t\treturn false;\n-\t\t}\n+\t\t\n \t\tif (foundAtIndex<0) {\n \t\t\t/*[MSG \"K05a7\", \"foundAtIndex cannot be <0 for storeSharedClass. Returning false.\"]*/\n \t\t\tprintVerboseError(Msg.getString(\"K05a7\")); //$NON-NLS-1$\n \t\t\treturn false;\n \t\t}\n-\t\tif (foundAtIndex>=urlCount) {\n-\t\t\t/*[MSG \"K05a8\", \"foundAtIndex cannot be >= urls in classpath for storeSharedClass. Returning false.\"]*/\n-\t\t\tprintVerboseError(Msg.getString(\"K05a8\")); //$NON-NLS-1$\n-\t\t\treturn false;\n-\t\t}\n-\t\tif (invalidURLExists) {\n-\t\t\t/* Any URL which has its protocol other than 'jar:' or 'file:' is not supported by\n-\t\t\t * shared class cache and is considered invalid.\n-\t\t\t * invalidURLExists = true indicates classpath contains an invalid URL,\n-\t\t\t * As such there is no point in calling native method storeSharedClassImpl2() \n-\t\t\t * since it is bound to fail when creating classpath entries.\n-\t\t\t */\t\t\t\n-\t\t\t/*[MSG \"K05a9\", \"Classpath contains an invalid URL. Returning false.\"]*/\n-\t\t\tprintVerboseInfo(Msg.getString(\"K05a9\")); //$NON-NLS-1$\n+\t\tClassLoader actualLoader = getClassLoader();\n+\t\tif (!validateClassLoader(actualLoader, clazz)) {\n+\t\t\t/* Attempt to call storeSharedClass with class defined by a different classloader */\n \t\t\treturn false;\n \t\t}\n-\t\tif (!validated[foundAtIndex]) {\n-\t\t\t/* Because we only check each element once, we can afford to also check whether the URL exists */\n-\t\t\tif (!validateURL(urls[foundAtIndex], true)) {\n+\t\tboolean storeRet = false;\n+\t\tboolean incConfirmedCount = false;\n+\t\tboolean urlValidated = false;\n+\t\turlcpReadWriteLock.readLock().lock();\n+\t\ttry {\n+\t\t\tif (urlCount==0) {\n+\t\t\t\t/*[MSG \"K05a6\", \"Classpath has zero elements. Cannot call storeSharedClass without classpath. Returning false.\"]*/\n+\t\t\t\tprintVerboseError(Msg.getString(\"K05a6\")); //$NON-NLS-1$\n \t\t\t\treturn false;\n \t\t\t}\n-\t\t\tvalidated[foundAtIndex]=true;\n+\t\t\tif (foundAtIndex>=urlCount) {\n+\t\t\t\t/*[MSG \"K05a8\", \"foundAtIndex cannot be >= urls in classpath for storeSharedClass. Returning false.\"]*/\n+\t\t\t\tprintVerboseError(Msg.getString(\"K05a8\")); //$NON-NLS-1$\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tif (invalidURLExists) {\n+\t\t\t\t/* Any URL which has its protocol other than 'jar:' or 'file:' is not supported by\n+\t\t\t\t * shared class cache and is considered invalid.\n+\t\t\t\t * invalidURLExists = true indicates classpath contains an invalid URL,\n+\t\t\t\t * As such there is no point in calling native method storeSharedClassImpl2() \n+\t\t\t\t * since it is bound to fail when creating classpath entries.\n+\t\t\t\t */\t\t\t\n+\t\t\t\t/*[MSG \"K05a9\", \"Classpath contains an invalid URL. Returning false.\"]*/\n+\t\t\t\tprintVerboseInfo(Msg.getString(\"K05a9\")); //$NON-NLS-1$\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tif (!validated[foundAtIndex]) {\n+\t\t\t\t/* Because we only check each element once, we can afford to also check whether the URL exists */\n+\t\t\t\tif (!validateURL(urls[foundAtIndex], true)) {\n+\t\t\t\t\treturn false;\n+\t\t\t\t} \n+\t\t\t\turlValidated = true;\n+\t\t\t}\n+\t\t\tif (confirmedCount <= foundAtIndex) {\n+\t\t\t\tincConfirmedCount = true;\n+\t\t\t}\n+\t\t\tstoreRet = storeSharedClassImpl2(this.id, partition, actualLoader, this.urls, this.urlCount, foundAtIndex, clazz, nativeFlags);\n+\t\t} finally {\n+\t\t\turlcpReadWriteLock.readLock().unlock();\n \t\t}\n-\t\tClassLoader actualLoader = getClassLoader();\n-\t\tif (!validateClassLoader(actualLoader, clazz)) {\n-\t\t\t/* Attempt to call storeSharedClass with class defined by a different classloader */\n-\t\t\treturn false;\n+\t\tif (urlValidated) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAwOTQzOA=="}, "originalCommit": {"oid": "cf41616c6fd61ef9d10289c8261bcfda7f53c33f"}, "originalPosition": 218}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMTYwNDk1OnYy", "diffSide": "RIGHT", "path": "runtime/shared_common/j9shr.tdf", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQwMDo1Mzo1OVrOGiK-9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNjowOToxMlrOGikmCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ4NDcyNA==", "bodyText": "Pls add a newline.", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r438484724", "createdAt": "2020-06-11T00:53:59Z", "author": {"login": "pshipton"}, "path": "runtime/shared_common/j9shr.tdf", "diffHunk": "@@ -2987,3 +2987,6 @@ TraceEvent=Trc_SHR_CC_startup_getCacheUniqueID_after Overhead=1 Level=7 Template\n \n TraceEvent=Trc_SHR_API_j9shr_classStoreTransaction_start_cacheFull_Event Overhead=1 Level=3 Template=\"API j9shr_classStoreTransaction_start : J9SHR_RUNTIMEFLAG_BLOCK_SPACE_FULL is set. The shared cache is full\"\n TraceEvent=Trc_SHR_API_j9shr_classStoreTransaction_start_cacheSoftFull_Event Overhead=1 Level=3 Template=\"API j9shr_classStoreTransaction_start : J9SHR_RUNTIMEFLAG_AVAILABLE_SPACE_FULL is set. The shared cache is soft full\"\n+\n+TraceExit-Exception=Trc_SHR_CMI_Update_Exit5 Overhead=1 Level=2 Template=\"CMI Update: StoreIdentified failed to acquire _identifiedMutex. Returning -1.\"\n+TraceExit-Exception=Trc_SHR_CMI_validate_Exit_IdentifiedMutex_Failed Overhead=1 Level=2 Template=\"CMI validate: Failed to acquire _identifiedMutex. Returning -1\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b37b5ef92cf08713207384362e796f99a46aa5bd"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkwNDMyOQ==", "bodyText": "Fixed.", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r438904329", "createdAt": "2020-06-11T16:09:12Z", "author": {"login": "hangshao0"}, "path": "runtime/shared_common/j9shr.tdf", "diffHunk": "@@ -2987,3 +2987,6 @@ TraceEvent=Trc_SHR_CC_startup_getCacheUniqueID_after Overhead=1 Level=7 Template\n \n TraceEvent=Trc_SHR_API_j9shr_classStoreTransaction_start_cacheFull_Event Overhead=1 Level=3 Template=\"API j9shr_classStoreTransaction_start : J9SHR_RUNTIMEFLAG_BLOCK_SPACE_FULL is set. The shared cache is full\"\n TraceEvent=Trc_SHR_API_j9shr_classStoreTransaction_start_cacheSoftFull_Event Overhead=1 Level=3 Template=\"API j9shr_classStoreTransaction_start : J9SHR_RUNTIMEFLAG_AVAILABLE_SPACE_FULL is set. The shared cache is soft full\"\n+\n+TraceExit-Exception=Trc_SHR_CMI_Update_Exit5 Overhead=1 Level=2 Template=\"CMI Update: StoreIdentified failed to acquire _identifiedMutex. Returning -1.\"\n+TraceExit-Exception=Trc_SHR_CMI_validate_Exit_IdentifiedMutex_Failed Overhead=1 Level=2 Template=\"CMI validate: Failed to acquire _identifiedMutex. Returning -1\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ4NDcyNA=="}, "originalCommit": {"oid": "b37b5ef92cf08713207384362e796f99a46aa5bd"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMTYyNjg0OnYy", "diffSide": "RIGHT", "path": "runtime/shared_common/ClasspathManagerImpl2.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQwMTowNzo0NlrOGiLMVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNjoxMjoyMFrOGikt5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ4ODE1MQ==", "bodyText": "Since the condition tested to get here isn't the same as the condition where identifiedMutex is entered further above, it seems possible for the assertion in local_StoreIdentified() to occur. Shouldn't identifiedMutex be entered if it's not already?", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r438488151", "createdAt": "2020-06-11T01:07:46Z", "author": {"login": "pshipton"}, "path": "runtime/shared_common/ClasspathManagerImpl2.cpp", "diffHunk": "@@ -1099,7 +1114,26 @@ SH_ClasspathManagerImpl2::validate(J9VMThread* currentThread, ROMClassWrapper* f\n \tif (localFoundAtIndex == -1) {\n \t\t/* We didn't find an exact classpath match. Walk the classpaths and check for validity. Note that the timestamp check is incorporated for efficiency. */\n \t\tlocalFoundAtIndex = localValidate_CheckAndTimestampManually(currentThread, testCP, testCPIndex, compareTo, foundIdentified, &addToIdentified, staleItem);\n+\t\t/* If the classpath has just been identified by localValidate_CheckAndTimestampManually, store it in the identified array */\n+\t\tif (addToIdentified && (compareTo->getType()==CP_TYPE_CLASSPATH) && (*_runtimeFlagsPtr & J9SHR_RUNTIMEFLAG_ENABLE_LOCAL_CACHEING)) {\n+\t\t\t/* Identification succeeded. Store identified classpath. */\n+\t\t\tif (local_StoreIdentified(currentThread, compareTo, testCP)==-1) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b37b5ef92cf08713207384362e796f99a46aa5bd"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkwNjM0Mg==", "bodyText": "Yes, it should enter identifiedMutex if it has not. I thought about this case yesterday in the morning, but after lunch, I forgot.  Fixed now.", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r438906342", "createdAt": "2020-06-11T16:12:20Z", "author": {"login": "hangshao0"}, "path": "runtime/shared_common/ClasspathManagerImpl2.cpp", "diffHunk": "@@ -1099,7 +1114,26 @@ SH_ClasspathManagerImpl2::validate(J9VMThread* currentThread, ROMClassWrapper* f\n \tif (localFoundAtIndex == -1) {\n \t\t/* We didn't find an exact classpath match. Walk the classpaths and check for validity. Note that the timestamp check is incorporated for efficiency. */\n \t\tlocalFoundAtIndex = localValidate_CheckAndTimestampManually(currentThread, testCP, testCPIndex, compareTo, foundIdentified, &addToIdentified, staleItem);\n+\t\t/* If the classpath has just been identified by localValidate_CheckAndTimestampManually, store it in the identified array */\n+\t\tif (addToIdentified && (compareTo->getType()==CP_TYPE_CLASSPATH) && (*_runtimeFlagsPtr & J9SHR_RUNTIMEFLAG_ENABLE_LOCAL_CACHEING)) {\n+\t\t\t/* Identification succeeded. Store identified classpath. */\n+\t\t\tif (local_StoreIdentified(currentThread, compareTo, testCP)==-1) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ4ODE1MQ=="}, "originalCommit": {"oid": "b37b5ef92cf08713207384362e796f99a46aa5bd"}, "originalPosition": 174}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMTYyNzU0OnYy", "diffSide": "RIGHT", "path": "runtime/shared_common/ClasspathManagerImpl2.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQwMTowODoxMlrOGiLMvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNjoxMDowNlrOGikoNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ4ODI1Mg==", "bodyText": "I don't see why releaseIdentifiedMutex is needed here.", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r438488252", "createdAt": "2020-06-11T01:08:12Z", "author": {"login": "pshipton"}, "path": "runtime/shared_common/ClasspathManagerImpl2.cpp", "diffHunk": "@@ -1065,29 +1072,37 @@ SH_ClasspathManagerImpl2::validate(J9VMThread* currentThread, ROMClassWrapper* f\n \t\tIDATA prevMatch = ID_NOT_FOUND;\n \n \t\tfoundIdentified = -1;\n-\n-\t\t/* Multiple ClassLoaders could have the same classpath, so search until the matching helperID is found */\n-\t\tdo {\n-\t\t\tif ((foundIdentified = localValidate_FindIdentified(currentThread, testCP, foundIdentified+1)) != ID_NOT_FOUND) {\n-\t\t\t\tprevMatch = foundIdentified;\n-\t\t\t}\n-\t\t} while ((foundIdentified != ID_NOT_FOUND) && (foundIdentified != compareToID));\n-\n-\t\t/* This means we have a positive match - testCP is the same classpath as that of the caller classloader */\n-\t\tif (foundIdentified==compareToID) {\n-\t\t\tlocalFoundAtIndex = testCPIndex;\n-\t\t} else {\n-\t\t\t/* At this point, foundIdentified will always be ID_NOT_FOUND. This means that testCP is not exactly the same classpath as the caller\n-\t\t\t * classloader's, but we have identified it and it could still be a valid match. Test to see if we have tried this match before and failed it. */\n-\t\t\tfoundIdentified = prevMatch;\n-\t\t\tif (foundIdentified != ID_NOT_FOUND) {\n-\t\t\t\tif (hasMatchFailedBefore(currentThread, _identifiedClasspaths, compareToID, foundIdentified, testCPIndex, NULL, 0)) {\n-\t\t\t\t\t/* trace event is at level 1 and trace exit message is at level 2 as per CMVC 155318/157683 */\n-\t\t\t\t\tTrc_SHR_CMI_validate_ExitFailedBefore_Event(currentThread, foundROMClass, compareTo, confirmedEntries);\n-\t\t\t\t\tTrc_SHR_CMI_validate_ExitFailedBefore(currentThread);\n-\t\t\t\t\tgoto _done;\n+\t\tif (0 == _cache->enterLocalMutex(currentThread, _identifiedMutex, \"identifiedMutex\", \"validate\")) {\n+\t\t\treleaseIdentifiedMutex = true;\n+\t\t\t/* Multiple ClassLoaders could have the same classpath, so search until the matching helperID is found */\n+\t\t\tdo {\n+\t\t\t\tif ((foundIdentified = localValidate_FindIdentified(currentThread, testCP, foundIdentified+1)) != ID_NOT_FOUND) {\n+\t\t\t\t\tprevMatch = foundIdentified;\n+\t\t\t\t}\n+\t\t\t} while ((foundIdentified != ID_NOT_FOUND) && (foundIdentified != compareToID));\n+\t\n+\t\t\t/* This means we have a positive match - testCP is the same classpath as that of the caller classloader */\n+\t\t\tif (foundIdentified==compareToID) {\n+\t\t\t\tlocalFoundAtIndex = testCPIndex;\n+\t\t\t} else {\n+\t\t\t\t/* At this point, foundIdentified will always be ID_NOT_FOUND. This means that testCP is not exactly the same classpath as the caller\n+\t\t\t\t * classloader's, but we have identified it and it could still be a valid match. Test to see if we have tried this match before and failed it. */\n+\t\t\t\tfoundIdentified = prevMatch;\n+\t\t\t\tif (foundIdentified != ID_NOT_FOUND) {\n+\t\t\t\t\tif (hasMatchFailedBefore(currentThread, _identifiedClasspaths, compareToID, foundIdentified, testCPIndex, NULL, 0)) {\n+\t\t\t\t\t\t/* trace event is at level 1 and trace exit message is at level 2 as per CMVC 155318/157683 */\n+\t\t\t\t\t\tTrc_SHR_CMI_validate_ExitFailedBefore_Event(currentThread, foundROMClass, compareTo, confirmedEntries);\n+\t\t\t\t\t\tTrc_SHR_CMI_validate_ExitFailedBefore(currentThread);\n+\t\t\t\t\t\tif (releaseIdentifiedMutex) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b37b5ef92cf08713207384362e796f99a46aa5bd"}, "originalPosition": 154}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkwNDg4NA==", "bodyText": "Fixed.", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r438904884", "createdAt": "2020-06-11T16:10:06Z", "author": {"login": "hangshao0"}, "path": "runtime/shared_common/ClasspathManagerImpl2.cpp", "diffHunk": "@@ -1065,29 +1072,37 @@ SH_ClasspathManagerImpl2::validate(J9VMThread* currentThread, ROMClassWrapper* f\n \t\tIDATA prevMatch = ID_NOT_FOUND;\n \n \t\tfoundIdentified = -1;\n-\n-\t\t/* Multiple ClassLoaders could have the same classpath, so search until the matching helperID is found */\n-\t\tdo {\n-\t\t\tif ((foundIdentified = localValidate_FindIdentified(currentThread, testCP, foundIdentified+1)) != ID_NOT_FOUND) {\n-\t\t\t\tprevMatch = foundIdentified;\n-\t\t\t}\n-\t\t} while ((foundIdentified != ID_NOT_FOUND) && (foundIdentified != compareToID));\n-\n-\t\t/* This means we have a positive match - testCP is the same classpath as that of the caller classloader */\n-\t\tif (foundIdentified==compareToID) {\n-\t\t\tlocalFoundAtIndex = testCPIndex;\n-\t\t} else {\n-\t\t\t/* At this point, foundIdentified will always be ID_NOT_FOUND. This means that testCP is not exactly the same classpath as the caller\n-\t\t\t * classloader's, but we have identified it and it could still be a valid match. Test to see if we have tried this match before and failed it. */\n-\t\t\tfoundIdentified = prevMatch;\n-\t\t\tif (foundIdentified != ID_NOT_FOUND) {\n-\t\t\t\tif (hasMatchFailedBefore(currentThread, _identifiedClasspaths, compareToID, foundIdentified, testCPIndex, NULL, 0)) {\n-\t\t\t\t\t/* trace event is at level 1 and trace exit message is at level 2 as per CMVC 155318/157683 */\n-\t\t\t\t\tTrc_SHR_CMI_validate_ExitFailedBefore_Event(currentThread, foundROMClass, compareTo, confirmedEntries);\n-\t\t\t\t\tTrc_SHR_CMI_validate_ExitFailedBefore(currentThread);\n-\t\t\t\t\tgoto _done;\n+\t\tif (0 == _cache->enterLocalMutex(currentThread, _identifiedMutex, \"identifiedMutex\", \"validate\")) {\n+\t\t\treleaseIdentifiedMutex = true;\n+\t\t\t/* Multiple ClassLoaders could have the same classpath, so search until the matching helperID is found */\n+\t\t\tdo {\n+\t\t\t\tif ((foundIdentified = localValidate_FindIdentified(currentThread, testCP, foundIdentified+1)) != ID_NOT_FOUND) {\n+\t\t\t\t\tprevMatch = foundIdentified;\n+\t\t\t\t}\n+\t\t\t} while ((foundIdentified != ID_NOT_FOUND) && (foundIdentified != compareToID));\n+\t\n+\t\t\t/* This means we have a positive match - testCP is the same classpath as that of the caller classloader */\n+\t\t\tif (foundIdentified==compareToID) {\n+\t\t\t\tlocalFoundAtIndex = testCPIndex;\n+\t\t\t} else {\n+\t\t\t\t/* At this point, foundIdentified will always be ID_NOT_FOUND. This means that testCP is not exactly the same classpath as the caller\n+\t\t\t\t * classloader's, but we have identified it and it could still be a valid match. Test to see if we have tried this match before and failed it. */\n+\t\t\t\tfoundIdentified = prevMatch;\n+\t\t\t\tif (foundIdentified != ID_NOT_FOUND) {\n+\t\t\t\t\tif (hasMatchFailedBefore(currentThread, _identifiedClasspaths, compareToID, foundIdentified, testCPIndex, NULL, 0)) {\n+\t\t\t\t\t\t/* trace event is at level 1 and trace exit message is at level 2 as per CMVC 155318/157683 */\n+\t\t\t\t\t\tTrc_SHR_CMI_validate_ExitFailedBefore_Event(currentThread, foundROMClass, compareTo, confirmedEntries);\n+\t\t\t\t\t\tTrc_SHR_CMI_validate_ExitFailedBefore(currentThread);\n+\t\t\t\t\t\tif (releaseIdentifiedMutex) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ4ODI1Mg=="}, "originalCommit": {"oid": "b37b5ef92cf08713207384362e796f99a46aa5bd"}, "originalPosition": 154}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMTYyOTM4OnYy", "diffSide": "RIGHT", "path": "runtime/shared_common/ClasspathManagerImpl2.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQwMTowOTozMlrOGiLN8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNjoxMjozMFrOGikuWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ4ODU2Mg==", "bodyText": "Seems if releaseIdentifiedMutex is false, the assert in local_StoreIdentified() would occur before getting here.", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r438488562", "createdAt": "2020-06-11T01:09:32Z", "author": {"login": "pshipton"}, "path": "runtime/shared_common/ClasspathManagerImpl2.cpp", "diffHunk": "@@ -1099,7 +1114,26 @@ SH_ClasspathManagerImpl2::validate(J9VMThread* currentThread, ROMClassWrapper* f\n \tif (localFoundAtIndex == -1) {\n \t\t/* We didn't find an exact classpath match. Walk the classpaths and check for validity. Note that the timestamp check is incorporated for efficiency. */\n \t\tlocalFoundAtIndex = localValidate_CheckAndTimestampManually(currentThread, testCP, testCPIndex, compareTo, foundIdentified, &addToIdentified, staleItem);\n+\t\t/* If the classpath has just been identified by localValidate_CheckAndTimestampManually, store it in the identified array */\n+\t\tif (addToIdentified && (compareTo->getType()==CP_TYPE_CLASSPATH) && (*_runtimeFlagsPtr & J9SHR_RUNTIMEFLAG_ENABLE_LOCAL_CACHEING)) {\n+\t\t\t/* Identification succeeded. Store identified classpath. */\n+\t\t\tif (local_StoreIdentified(currentThread, compareTo, testCP)==-1) {\n+\t\t\t\t/* trace event is at level 1 and trace exit message is at level 2 as per CMVC 155318/157683  */\n+\t\t\t\tTrc_SHR_CMI_validate_ExitError_Event(currentThread, foundROMClass, compareTo, confirmedEntries);\n+\t\t\t\tTrc_SHR_CMI_validate_ExitError(currentThread);\n+\t\t\t\tif (releaseIdentifiedMutex) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b37b5ef92cf08713207384362e796f99a46aa5bd"}, "originalPosition": 178}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkwNjQ1Ng==", "bodyText": "Fixed.", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r438906456", "createdAt": "2020-06-11T16:12:30Z", "author": {"login": "hangshao0"}, "path": "runtime/shared_common/ClasspathManagerImpl2.cpp", "diffHunk": "@@ -1099,7 +1114,26 @@ SH_ClasspathManagerImpl2::validate(J9VMThread* currentThread, ROMClassWrapper* f\n \tif (localFoundAtIndex == -1) {\n \t\t/* We didn't find an exact classpath match. Walk the classpaths and check for validity. Note that the timestamp check is incorporated for efficiency. */\n \t\tlocalFoundAtIndex = localValidate_CheckAndTimestampManually(currentThread, testCP, testCPIndex, compareTo, foundIdentified, &addToIdentified, staleItem);\n+\t\t/* If the classpath has just been identified by localValidate_CheckAndTimestampManually, store it in the identified array */\n+\t\tif (addToIdentified && (compareTo->getType()==CP_TYPE_CLASSPATH) && (*_runtimeFlagsPtr & J9SHR_RUNTIMEFLAG_ENABLE_LOCAL_CACHEING)) {\n+\t\t\t/* Identification succeeded. Store identified classpath. */\n+\t\t\tif (local_StoreIdentified(currentThread, compareTo, testCP)==-1) {\n+\t\t\t\t/* trace event is at level 1 and trace exit message is at level 2 as per CMVC 155318/157683  */\n+\t\t\t\tTrc_SHR_CMI_validate_ExitError_Event(currentThread, foundROMClass, compareTo, confirmedEntries);\n+\t\t\t\tTrc_SHR_CMI_validate_ExitError(currentThread);\n+\t\t\t\tif (releaseIdentifiedMutex) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ4ODU2Mg=="}, "originalCommit": {"oid": "b37b5ef92cf08713207384362e796f99a46aa5bd"}, "originalPosition": 178}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczNDM3OTM1OnYy", "diffSide": "RIGHT", "path": "jcl/src/openj9.sharedclasses/share/classes/com/ibm/oti/shared/SharedClassURLClasspathHelperImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNzowMDoxMVrOGimeXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxODo0NzowOVrOGiqVPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkzNTEzMw==", "bodyText": "Pls use ! instead of false ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r438935133", "createdAt": "2020-06-11T17:00:11Z", "author": {"login": "pshipton"}, "path": "jcl/src/openj9.sharedclasses/share/classes/com/ibm/oti/shared/SharedClassURLClasspathHelperImpl.java", "diffHunk": "@@ -166,53 +177,66 @@ public synchronized boolean storeSharedClass(String partition, Class<?> clazz, i\n \t\t\tprintVerboseError(Msg.getString(\"K05a3\")); //$NON-NLS-1$\n \t\t\treturn false;\n \t\t}\n-\t\tif (urlCount==0) {\n-\t\t\t/*[MSG \"K05a6\", \"Classpath has zero elements. Cannot call storeSharedClass without classpath. Returning false.\"]*/\n-\t\t\tprintVerboseError(Msg.getString(\"K05a6\")); //$NON-NLS-1$\n-\t\t\treturn false;\n-\t\t}\n+\t\t\n \t\tif (foundAtIndex<0) {\n \t\t\t/*[MSG \"K05a7\", \"foundAtIndex cannot be <0 for storeSharedClass. Returning false.\"]*/\n \t\t\tprintVerboseError(Msg.getString(\"K05a7\")); //$NON-NLS-1$\n \t\t\treturn false;\n \t\t}\n-\t\tif (foundAtIndex>=urlCount) {\n-\t\t\t/*[MSG \"K05a8\", \"foundAtIndex cannot be >= urls in classpath for storeSharedClass. Returning false.\"]*/\n-\t\t\tprintVerboseError(Msg.getString(\"K05a8\")); //$NON-NLS-1$\n-\t\t\treturn false;\n-\t\t}\n-\t\tif (invalidURLExists) {\n-\t\t\t/* Any URL which has its protocol other than 'jar:' or 'file:' is not supported by\n-\t\t\t * shared class cache and is considered invalid.\n-\t\t\t * invalidURLExists = true indicates classpath contains an invalid URL,\n-\t\t\t * As such there is no point in calling native method storeSharedClassImpl2() \n-\t\t\t * since it is bound to fail when creating classpath entries.\n-\t\t\t */\t\t\t\n-\t\t\t/*[MSG \"K05a9\", \"Classpath contains an invalid URL. Returning false.\"]*/\n-\t\t\tprintVerboseInfo(Msg.getString(\"K05a9\")); //$NON-NLS-1$\n-\t\t\treturn false;\n-\t\t}\n-\t\tif (!validated[foundAtIndex]) {\n-\t\t\t/* Because we only check each element once, we can afford to also check whether the URL exists */\n-\t\t\tif (!validateURL(urls[foundAtIndex], true)) {\n-\t\t\t\treturn false;\n-\t\t\t}\n-\t\t\tvalidated[foundAtIndex]=true;\n-\t\t}\n \t\tClassLoader actualLoader = getClassLoader();\n \t\tif (!validateClassLoader(actualLoader, clazz)) {\n \t\t\t/* Attempt to call storeSharedClass with class defined by a different classloader */\n \t\t\treturn false;\n \t\t}\n-\t\tif (confirmedCount <= foundAtIndex) {\n-\t\t\tconfirmedCount = foundAtIndex+1;\n-\t\t\t/*[MSG \"K05aa\", \"Number of confirmed entries is now {0}\"]*/\n-\t\t\tprintVerboseInfo(Msg.getString(\"K05aa\", confirmedCount)); //$NON-NLS-1$\n+\t\tboolean storeRet = false;\n+\t\tboolean incConfirmedCount = false;\n+\t\turlcpReadWriteLock.readLock().lock();\n+\t\ttry {\n+\t\t\tif (urlCount==0) {\n+\t\t\t\t/*[MSG \"K05a6\", \"Classpath has zero elements. Cannot call storeSharedClass without classpath. Returning false.\"]*/\n+\t\t\t\tprintVerboseError(Msg.getString(\"K05a6\")); //$NON-NLS-1$\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tif (foundAtIndex>=urlCount) {\n+\t\t\t\t/*[MSG \"K05a8\", \"foundAtIndex cannot be >= urls in classpath for storeSharedClass. Returning false.\"]*/\n+\t\t\t\tprintVerboseError(Msg.getString(\"K05a8\")); //$NON-NLS-1$\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tif (invalidURLExists) {\n+\t\t\t\t/* Any URL which has its protocol other than 'jar:' or 'file:' is not supported by\n+\t\t\t\t * shared class cache and is considered invalid.\n+\t\t\t\t * invalidURLExists = true indicates classpath contains an invalid URL,\n+\t\t\t\t * As such there is no point in calling native method storeSharedClassImpl2() \n+\t\t\t\t * since it is bound to fail when creating classpath entries.\n+\t\t\t\t */\t\t\t\n+\t\t\t\t/*[MSG \"K05a9\", \"Classpath contains an invalid URL. Returning false.\"]*/\n+\t\t\t\tprintVerboseInfo(Msg.getString(\"K05a9\")); //$NON-NLS-1$\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tif (!validated[foundAtIndex]) {\n+\t\t\t\t/* Because we only check each element once, we can afford to also check whether the URL exists */\n+\t\t\t\tif (!validateURL(urls[foundAtIndex], true)) {\n+\t\t\t\t\treturn false;\n+\t\t\t\t}\n+\t\t\t\tvalidated[foundAtIndex]=true;\n+\t\t\t}\n+\t\t\tif (confirmedCount <= foundAtIndex) {\n+\t\t\t\tincConfirmedCount = true;\n+\t\t\t}\n+\t\t\tstoreRet = storeSharedClassImpl2(this.id, partition, actualLoader, this.urls, this.urlCount, foundAtIndex, clazz, nativeFlags);\n+\t\t} finally {\n+\t\t\turlcpReadWriteLock.readLock().unlock();\n+\t\t}\n+\t\tif (incConfirmedCount) {\n+\t\t\tincreaseConfirmedCount(foundAtIndex + 1);\n \t\t}\n-\t\treturn storeSharedClassImpl2(this.id, partition, actualLoader, this.urls, this.urlCount, foundAtIndex, clazz, nativeFlags);\n+\t\treturn storeRet;\n \t}\n \n-\tprivate synchronized void growURLs(int toMinSize) {\n+\tprivate void growURLs(int toMinSize) {\n+\t\tif (false == urlcpReadWriteLock.writeLock().isHeldByCurrentThread()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "979d5b7c97340f72db2d679e287235a889eb808b"}, "originalPosition": 231}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk5ODMzNA==", "bodyText": "Fixed.", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r438998334", "createdAt": "2020-06-11T18:47:09Z", "author": {"login": "hangshao0"}, "path": "jcl/src/openj9.sharedclasses/share/classes/com/ibm/oti/shared/SharedClassURLClasspathHelperImpl.java", "diffHunk": "@@ -166,53 +177,66 @@ public synchronized boolean storeSharedClass(String partition, Class<?> clazz, i\n \t\t\tprintVerboseError(Msg.getString(\"K05a3\")); //$NON-NLS-1$\n \t\t\treturn false;\n \t\t}\n-\t\tif (urlCount==0) {\n-\t\t\t/*[MSG \"K05a6\", \"Classpath has zero elements. Cannot call storeSharedClass without classpath. Returning false.\"]*/\n-\t\t\tprintVerboseError(Msg.getString(\"K05a6\")); //$NON-NLS-1$\n-\t\t\treturn false;\n-\t\t}\n+\t\t\n \t\tif (foundAtIndex<0) {\n \t\t\t/*[MSG \"K05a7\", \"foundAtIndex cannot be <0 for storeSharedClass. Returning false.\"]*/\n \t\t\tprintVerboseError(Msg.getString(\"K05a7\")); //$NON-NLS-1$\n \t\t\treturn false;\n \t\t}\n-\t\tif (foundAtIndex>=urlCount) {\n-\t\t\t/*[MSG \"K05a8\", \"foundAtIndex cannot be >= urls in classpath for storeSharedClass. Returning false.\"]*/\n-\t\t\tprintVerboseError(Msg.getString(\"K05a8\")); //$NON-NLS-1$\n-\t\t\treturn false;\n-\t\t}\n-\t\tif (invalidURLExists) {\n-\t\t\t/* Any URL which has its protocol other than 'jar:' or 'file:' is not supported by\n-\t\t\t * shared class cache and is considered invalid.\n-\t\t\t * invalidURLExists = true indicates classpath contains an invalid URL,\n-\t\t\t * As such there is no point in calling native method storeSharedClassImpl2() \n-\t\t\t * since it is bound to fail when creating classpath entries.\n-\t\t\t */\t\t\t\n-\t\t\t/*[MSG \"K05a9\", \"Classpath contains an invalid URL. Returning false.\"]*/\n-\t\t\tprintVerboseInfo(Msg.getString(\"K05a9\")); //$NON-NLS-1$\n-\t\t\treturn false;\n-\t\t}\n-\t\tif (!validated[foundAtIndex]) {\n-\t\t\t/* Because we only check each element once, we can afford to also check whether the URL exists */\n-\t\t\tif (!validateURL(urls[foundAtIndex], true)) {\n-\t\t\t\treturn false;\n-\t\t\t}\n-\t\t\tvalidated[foundAtIndex]=true;\n-\t\t}\n \t\tClassLoader actualLoader = getClassLoader();\n \t\tif (!validateClassLoader(actualLoader, clazz)) {\n \t\t\t/* Attempt to call storeSharedClass with class defined by a different classloader */\n \t\t\treturn false;\n \t\t}\n-\t\tif (confirmedCount <= foundAtIndex) {\n-\t\t\tconfirmedCount = foundAtIndex+1;\n-\t\t\t/*[MSG \"K05aa\", \"Number of confirmed entries is now {0}\"]*/\n-\t\t\tprintVerboseInfo(Msg.getString(\"K05aa\", confirmedCount)); //$NON-NLS-1$\n+\t\tboolean storeRet = false;\n+\t\tboolean incConfirmedCount = false;\n+\t\turlcpReadWriteLock.readLock().lock();\n+\t\ttry {\n+\t\t\tif (urlCount==0) {\n+\t\t\t\t/*[MSG \"K05a6\", \"Classpath has zero elements. Cannot call storeSharedClass without classpath. Returning false.\"]*/\n+\t\t\t\tprintVerboseError(Msg.getString(\"K05a6\")); //$NON-NLS-1$\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tif (foundAtIndex>=urlCount) {\n+\t\t\t\t/*[MSG \"K05a8\", \"foundAtIndex cannot be >= urls in classpath for storeSharedClass. Returning false.\"]*/\n+\t\t\t\tprintVerboseError(Msg.getString(\"K05a8\")); //$NON-NLS-1$\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tif (invalidURLExists) {\n+\t\t\t\t/* Any URL which has its protocol other than 'jar:' or 'file:' is not supported by\n+\t\t\t\t * shared class cache and is considered invalid.\n+\t\t\t\t * invalidURLExists = true indicates classpath contains an invalid URL,\n+\t\t\t\t * As such there is no point in calling native method storeSharedClassImpl2() \n+\t\t\t\t * since it is bound to fail when creating classpath entries.\n+\t\t\t\t */\t\t\t\n+\t\t\t\t/*[MSG \"K05a9\", \"Classpath contains an invalid URL. Returning false.\"]*/\n+\t\t\t\tprintVerboseInfo(Msg.getString(\"K05a9\")); //$NON-NLS-1$\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tif (!validated[foundAtIndex]) {\n+\t\t\t\t/* Because we only check each element once, we can afford to also check whether the URL exists */\n+\t\t\t\tif (!validateURL(urls[foundAtIndex], true)) {\n+\t\t\t\t\treturn false;\n+\t\t\t\t}\n+\t\t\t\tvalidated[foundAtIndex]=true;\n+\t\t\t}\n+\t\t\tif (confirmedCount <= foundAtIndex) {\n+\t\t\t\tincConfirmedCount = true;\n+\t\t\t}\n+\t\t\tstoreRet = storeSharedClassImpl2(this.id, partition, actualLoader, this.urls, this.urlCount, foundAtIndex, clazz, nativeFlags);\n+\t\t} finally {\n+\t\t\turlcpReadWriteLock.readLock().unlock();\n+\t\t}\n+\t\tif (incConfirmedCount) {\n+\t\t\tincreaseConfirmedCount(foundAtIndex + 1);\n \t\t}\n-\t\treturn storeSharedClassImpl2(this.id, partition, actualLoader, this.urls, this.urlCount, foundAtIndex, clazz, nativeFlags);\n+\t\treturn storeRet;\n \t}\n \n-\tprivate synchronized void growURLs(int toMinSize) {\n+\tprivate void growURLs(int toMinSize) {\n+\t\tif (false == urlcpReadWriteLock.writeLock().isHeldByCurrentThread()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkzNTEzMw=="}, "originalCommit": {"oid": "979d5b7c97340f72db2d679e287235a889eb808b"}, "originalPosition": 231}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczNDM4Mzc3OnYy", "diffSide": "RIGHT", "path": "runtime/shared_common/CacheMap.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNzowMToyOVrOGimhSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxODo0NzoxNVrOGiqVcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkzNTg4Mg==", "bodyText": "Constant on the left.", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r438935882", "createdAt": "2020-06-11T17:01:29Z", "author": {"login": "pshipton"}, "path": "runtime/shared_common/CacheMap.cpp", "diffHunk": "@@ -2810,7 +2821,16 @@ SH_CacheMap::findROMClass(J9VMThread* currentThread, const char* path, Classpath\n \t\t\t\t\t\t\tTrc_SHR_CM_findROMClass_FailedMutex(currentThread, path, cp->getHelperID());\n \t\t\t\t\t\t\tbreak;\n \t\t\t\t\t\t}\n-\t\t\t\t\t\tIDATA rv = refreshHashtables(currentThread, true);\t\t/* We do have the class segment mutex - this is a prereq of findROMClass */\n+\t\t\t\t\t\tbool segmentMutexEntered = false;\n+\t\t\t\t\t\tif (omrthread_monitor_owned_by_self(currentThread->javaVM->classMemorySegments->segmentMutex) == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "979d5b7c97340f72db2d679e287235a889eb808b"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk5ODM4NA==", "bodyText": "Fixed.", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r438998384", "createdAt": "2020-06-11T18:47:15Z", "author": {"login": "hangshao0"}, "path": "runtime/shared_common/CacheMap.cpp", "diffHunk": "@@ -2810,7 +2821,16 @@ SH_CacheMap::findROMClass(J9VMThread* currentThread, const char* path, Classpath\n \t\t\t\t\t\t\tTrc_SHR_CM_findROMClass_FailedMutex(currentThread, path, cp->getHelperID());\n \t\t\t\t\t\t\tbreak;\n \t\t\t\t\t\t}\n-\t\t\t\t\t\tIDATA rv = refreshHashtables(currentThread, true);\t\t/* We do have the class segment mutex - this is a prereq of findROMClass */\n+\t\t\t\t\t\tbool segmentMutexEntered = false;\n+\t\t\t\t\t\tif (omrthread_monitor_owned_by_self(currentThread->javaVM->classMemorySegments->segmentMutex) == 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkzNTg4Mg=="}, "originalCommit": {"oid": "979d5b7c97340f72db2d679e287235a889eb808b"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczNDM4NDkwOnYy", "diffSide": "RIGHT", "path": "runtime/shared_common/CacheMap.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNzowMTo0OVrOGimiAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxODo0NzoyMFrOGiqVtQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkzNjA2Ng==", "bodyText": "Pls add a space.", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r438936066", "createdAt": "2020-06-11T17:01:49Z", "author": {"login": "pshipton"}, "path": "runtime/shared_common/CacheMap.cpp", "diffHunk": "@@ -2810,7 +2821,16 @@ SH_CacheMap::findROMClass(J9VMThread* currentThread, const char* path, Classpath\n \t\t\t\t\t\t\tTrc_SHR_CM_findROMClass_FailedMutex(currentThread, path, cp->getHelperID());\n \t\t\t\t\t\t\tbreak;\n \t\t\t\t\t\t}\n-\t\t\t\t\t\tIDATA rv = refreshHashtables(currentThread, true);\t\t/* We do have the class segment mutex - this is a prereq of findROMClass */\n+\t\t\t\t\t\tbool segmentMutexEntered = false;\n+\t\t\t\t\t\tif (omrthread_monitor_owned_by_self(currentThread->javaVM->classMemorySegments->segmentMutex) == 0) {\n+\t\t\t\t\t\t\tTrc_SHR_Assert_False(_ccHead->hasWriteMutex(currentThread));\n+\t\t\t\t\t\t\tenterLocalMutex(currentThread, currentThread->javaVM->classMemorySegments->segmentMutex, \"class segment mutex\", \"CM findROMClass\");\n+\t\t\t\t\t\t\tsegmentMutexEntered= true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "979d5b7c97340f72db2d679e287235a889eb808b"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk5ODQ1Mw==", "bodyText": "Fixed.", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r438998453", "createdAt": "2020-06-11T18:47:20Z", "author": {"login": "hangshao0"}, "path": "runtime/shared_common/CacheMap.cpp", "diffHunk": "@@ -2810,7 +2821,16 @@ SH_CacheMap::findROMClass(J9VMThread* currentThread, const char* path, Classpath\n \t\t\t\t\t\t\tTrc_SHR_CM_findROMClass_FailedMutex(currentThread, path, cp->getHelperID());\n \t\t\t\t\t\t\tbreak;\n \t\t\t\t\t\t}\n-\t\t\t\t\t\tIDATA rv = refreshHashtables(currentThread, true);\t\t/* We do have the class segment mutex - this is a prereq of findROMClass */\n+\t\t\t\t\t\tbool segmentMutexEntered = false;\n+\t\t\t\t\t\tif (omrthread_monitor_owned_by_self(currentThread->javaVM->classMemorySegments->segmentMutex) == 0) {\n+\t\t\t\t\t\t\tTrc_SHR_Assert_False(_ccHead->hasWriteMutex(currentThread));\n+\t\t\t\t\t\t\tenterLocalMutex(currentThread, currentThread->javaVM->classMemorySegments->segmentMutex, \"class segment mutex\", \"CM findROMClass\");\n+\t\t\t\t\t\t\tsegmentMutexEntered= true;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkzNjA2Ng=="}, "originalCommit": {"oid": "979d5b7c97340f72db2d679e287235a889eb808b"}, "originalPosition": 95}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczNDM5NDE1OnYy", "diffSide": "RIGHT", "path": "runtime/shared_common/ClasspathManagerImpl2.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNzowNDo1MVrOGimoQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxODo0NzoyNlrOGiqV-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkzNzY2NA==", "bodyText": "Pls add spaces and put constants on the left. The (*_runtimeFlagsPtr & J9SHR_RUNTIMEFLAG_ENABLE_LOCAL_CACHEING) should use OMR_ARE_ANY_BITS_SET", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r438937664", "createdAt": "2020-06-11T17:04:51Z", "author": {"login": "pshipton"}, "path": "runtime/shared_common/ClasspathManagerImpl2.cpp", "diffHunk": "@@ -1099,7 +1112,31 @@ SH_ClasspathManagerImpl2::validate(J9VMThread* currentThread, ROMClassWrapper* f\n \tif (localFoundAtIndex == -1) {\n \t\t/* We didn't find an exact classpath match. Walk the classpaths and check for validity. Note that the timestamp check is incorporated for efficiency. */\n \t\tlocalFoundAtIndex = localValidate_CheckAndTimestampManually(currentThread, testCP, testCPIndex, compareTo, foundIdentified, &addToIdentified, staleItem);\n+\t\t/* If the classpath has just been identified by localValidate_CheckAndTimestampManually, store it in the identified array */\n+\t\tif (addToIdentified && (compareTo->getType()==CP_TYPE_CLASSPATH) && (*_runtimeFlagsPtr & J9SHR_RUNTIMEFLAG_ENABLE_LOCAL_CACHEING)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "979d5b7c97340f72db2d679e287235a889eb808b"}, "originalPosition": 170}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk5ODUyMw==", "bodyText": "Fixed.", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r438998523", "createdAt": "2020-06-11T18:47:26Z", "author": {"login": "hangshao0"}, "path": "runtime/shared_common/ClasspathManagerImpl2.cpp", "diffHunk": "@@ -1099,7 +1112,31 @@ SH_ClasspathManagerImpl2::validate(J9VMThread* currentThread, ROMClassWrapper* f\n \tif (localFoundAtIndex == -1) {\n \t\t/* We didn't find an exact classpath match. Walk the classpaths and check for validity. Note that the timestamp check is incorporated for efficiency. */\n \t\tlocalFoundAtIndex = localValidate_CheckAndTimestampManually(currentThread, testCP, testCPIndex, compareTo, foundIdentified, &addToIdentified, staleItem);\n+\t\t/* If the classpath has just been identified by localValidate_CheckAndTimestampManually, store it in the identified array */\n+\t\tif (addToIdentified && (compareTo->getType()==CP_TYPE_CLASSPATH) && (*_runtimeFlagsPtr & J9SHR_RUNTIMEFLAG_ENABLE_LOCAL_CACHEING)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkzNzY2NA=="}, "originalCommit": {"oid": "979d5b7c97340f72db2d679e287235a889eb808b"}, "originalPosition": 170}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczNDM5NjA5OnYy", "diffSide": "RIGHT", "path": "runtime/shared_common/ClasspathManagerImpl2.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNzowNTozMFrOGimpow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxODo0NzozM1rOGiqWMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkzODAxOQ==", "bodyText": "Pls add spaces and put constants on the left.", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r438938019", "createdAt": "2020-06-11T17:05:30Z", "author": {"login": "pshipton"}, "path": "runtime/shared_common/ClasspathManagerImpl2.cpp", "diffHunk": "@@ -1099,7 +1112,31 @@ SH_ClasspathManagerImpl2::validate(J9VMThread* currentThread, ROMClassWrapper* f\n \tif (localFoundAtIndex == -1) {\n \t\t/* We didn't find an exact classpath match. Walk the classpaths and check for validity. Note that the timestamp check is incorporated for efficiency. */\n \t\tlocalFoundAtIndex = localValidate_CheckAndTimestampManually(currentThread, testCP, testCPIndex, compareTo, foundIdentified, &addToIdentified, staleItem);\n+\t\t/* If the classpath has just been identified by localValidate_CheckAndTimestampManually, store it in the identified array */\n+\t\tif (addToIdentified && (compareTo->getType()==CP_TYPE_CLASSPATH) && (*_runtimeFlagsPtr & J9SHR_RUNTIMEFLAG_ENABLE_LOCAL_CACHEING)) {\n+\t\t\tif (!releaseIdentifiedMutex) {\n+\t\t\t\tif (0 == _cache->enterLocalMutex(currentThread, _identifiedMutex, \"identifiedMutex\", \"validate\")) {\n+\t\t\t\t\treleaseIdentifiedMutex = true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\t/* Identification succeeded. Store identified classpath. */\n+\t\t\tif (releaseIdentifiedMutex) {\n+\t\t\t\tif (local_StoreIdentified(currentThread, compareTo, testCP)==-1) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "979d5b7c97340f72db2d679e287235a889eb808b"}, "originalPosition": 178}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk5ODU3Ng==", "bodyText": "Fixed.", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r438998576", "createdAt": "2020-06-11T18:47:33Z", "author": {"login": "hangshao0"}, "path": "runtime/shared_common/ClasspathManagerImpl2.cpp", "diffHunk": "@@ -1099,7 +1112,31 @@ SH_ClasspathManagerImpl2::validate(J9VMThread* currentThread, ROMClassWrapper* f\n \tif (localFoundAtIndex == -1) {\n \t\t/* We didn't find an exact classpath match. Walk the classpaths and check for validity. Note that the timestamp check is incorporated for efficiency. */\n \t\tlocalFoundAtIndex = localValidate_CheckAndTimestampManually(currentThread, testCP, testCPIndex, compareTo, foundIdentified, &addToIdentified, staleItem);\n+\t\t/* If the classpath has just been identified by localValidate_CheckAndTimestampManually, store it in the identified array */\n+\t\tif (addToIdentified && (compareTo->getType()==CP_TYPE_CLASSPATH) && (*_runtimeFlagsPtr & J9SHR_RUNTIMEFLAG_ENABLE_LOCAL_CACHEING)) {\n+\t\t\tif (!releaseIdentifiedMutex) {\n+\t\t\t\tif (0 == _cache->enterLocalMutex(currentThread, _identifiedMutex, \"identifiedMutex\", \"validate\")) {\n+\t\t\t\t\treleaseIdentifiedMutex = true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\t/* Identification succeeded. Store identified classpath. */\n+\t\t\tif (releaseIdentifiedMutex) {\n+\t\t\t\tif (local_StoreIdentified(currentThread, compareTo, testCP)==-1) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkzODAxOQ=="}, "originalCommit": {"oid": "979d5b7c97340f72db2d679e287235a889eb808b"}, "originalPosition": 178}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczNDM5NzU4OnYy", "diffSide": "RIGHT", "path": "runtime/shared_common/shrinit.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNzowNTo1N1rOGimqrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxODo0NzozOFrOGiqWYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkzODI4NQ==", "bodyText": "Constant on the left.", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r438938285", "createdAt": "2020-06-11T17:05:57Z", "author": {"login": "pshipton"}, "path": "runtime/shared_common/shrinit.cpp", "diffHunk": "@@ -1505,17 +1506,41 @@ hookFindSharedClass(J9HookInterface** hookInterface, UDATA eventNum, void* voidD\n \t\t\tif (eventData->classloader == vm->systemClassLoader) {\n \t\t\t\tisBootLoader = true;\n \t\t\t\tpathEntryCount += 1;\n+\t\t\t\tif (omrthread_monitor_owned_by_self(classSegmentMutex) == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "979d5b7c97340f72db2d679e287235a889eb808b"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk5ODYyNg==", "bodyText": "Fixed.", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r438998626", "createdAt": "2020-06-11T18:47:38Z", "author": {"login": "hangshao0"}, "path": "runtime/shared_common/shrinit.cpp", "diffHunk": "@@ -1505,17 +1506,41 @@ hookFindSharedClass(J9HookInterface** hookInterface, UDATA eventNum, void* voidD\n \t\t\tif (eventData->classloader == vm->systemClassLoader) {\n \t\t\t\tisBootLoader = true;\n \t\t\t\tpathEntryCount += 1;\n+\t\t\t\tif (omrthread_monitor_owned_by_self(classSegmentMutex) == 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkzODI4NQ=="}, "originalCommit": {"oid": "979d5b7c97340f72db2d679e287235a889eb808b"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczNDM5ODY5OnYy", "diffSide": "RIGHT", "path": "runtime/shared_common/shrinit.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNzowNjoxN1rOGimrgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxODo0Nzo0NlrOGiqWow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkzODQ5Ng==", "bodyText": "Constant on the left.", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r438938496", "createdAt": "2020-06-11T17:06:17Z", "author": {"login": "pshipton"}, "path": "runtime/shared_common/shrinit.cpp", "diffHunk": "@@ -1505,17 +1506,41 @@ hookFindSharedClass(J9HookInterface** hookInterface, UDATA eventNum, void* voidD\n \t\t\tif (eventData->classloader == vm->systemClassLoader) {\n \t\t\t\tisBootLoader = true;\n \t\t\t\tpathEntryCount += 1;\n+\t\t\t\tif (omrthread_monitor_owned_by_self(classSegmentMutex) == 0) {\n+\t\t\t\t\tomrthread_monitor_enter(classSegmentMutex);\n+\t\t\t\t\treleaseSegmentMutex = true;\n+\t\t\t\t}\n \t\t\t\tclasspath = getBootstrapClasspathItem(currentThread, vm->modulesPathEntry, pathEntryCount);\n+\t\t\t\tif (releaseSegmentMutex) {\n+\t\t\t\t\tomrthread_monitor_exit(classSegmentMutex);\n+\t\t\t\t\treleaseSegmentMutex = false;\n+\t\t\t\t}\n \t\t\t}\n \t\t} else {\n+\t\t\tif (omrthread_monitor_owned_by_self(classSegmentMutex) == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "979d5b7c97340f72db2d679e287235a889eb808b"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk5ODY5MQ==", "bodyText": "Fixed.", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r438998691", "createdAt": "2020-06-11T18:47:46Z", "author": {"login": "hangshao0"}, "path": "runtime/shared_common/shrinit.cpp", "diffHunk": "@@ -1505,17 +1506,41 @@ hookFindSharedClass(J9HookInterface** hookInterface, UDATA eventNum, void* voidD\n \t\t\tif (eventData->classloader == vm->systemClassLoader) {\n \t\t\t\tisBootLoader = true;\n \t\t\t\tpathEntryCount += 1;\n+\t\t\t\tif (omrthread_monitor_owned_by_self(classSegmentMutex) == 0) {\n+\t\t\t\t\tomrthread_monitor_enter(classSegmentMutex);\n+\t\t\t\t\treleaseSegmentMutex = true;\n+\t\t\t\t}\n \t\t\t\tclasspath = getBootstrapClasspathItem(currentThread, vm->modulesPathEntry, pathEntryCount);\n+\t\t\t\tif (releaseSegmentMutex) {\n+\t\t\t\t\tomrthread_monitor_exit(classSegmentMutex);\n+\t\t\t\t\treleaseSegmentMutex = false;\n+\t\t\t\t}\n \t\t\t}\n \t\t} else {\n+\t\t\tif (omrthread_monitor_owned_by_self(classSegmentMutex) == 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkzODQ5Ng=="}, "originalCommit": {"oid": "979d5b7c97340f72db2d679e287235a889eb808b"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczNDM5OTcxOnYy", "diffSide": "RIGHT", "path": "runtime/shared_common/shrinit.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNzowNjozNVrOGimsKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxODo0ODowMVrOGiqXKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkzODY2Nw==", "bodyText": "Constant on the left.", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r438938667", "createdAt": "2020-06-11T17:06:35Z", "author": {"login": "pshipton"}, "path": "runtime/shared_common/shrinit.cpp", "diffHunk": "@@ -1505,17 +1506,41 @@ hookFindSharedClass(J9HookInterface** hookInterface, UDATA eventNum, void* voidD\n \t\t\tif (eventData->classloader == vm->systemClassLoader) {\n \t\t\t\tisBootLoader = true;\n \t\t\t\tpathEntryCount += 1;\n+\t\t\t\tif (omrthread_monitor_owned_by_self(classSegmentMutex) == 0) {\n+\t\t\t\t\tomrthread_monitor_enter(classSegmentMutex);\n+\t\t\t\t\treleaseSegmentMutex = true;\n+\t\t\t\t}\n \t\t\t\tclasspath = getBootstrapClasspathItem(currentThread, vm->modulesPathEntry, pathEntryCount);\n+\t\t\t\tif (releaseSegmentMutex) {\n+\t\t\t\t\tomrthread_monitor_exit(classSegmentMutex);\n+\t\t\t\t\treleaseSegmentMutex = false;\n+\t\t\t\t}\n \t\t\t}\n \t\t} else {\n+\t\t\tif (omrthread_monitor_owned_by_self(classSegmentMutex) == 0) {\n+\t\t\t\tomrthread_monitor_enter(classSegmentMutex);\n+\t\t\t\treleaseSegmentMutex = true;\n+\t\t\t}\n \t\t\tclasspath = getBootstrapClasspathItem(currentThread, eventData->classPathEntries, pathEntryCount);\n+\t\t\tif (releaseSegmentMutex) {\n+\t\t\t\tomrthread_monitor_exit(classSegmentMutex);\n+\t\t\t\treleaseSegmentMutex = false;\n+\t\t\t}\n \t\t}\n \t}\n \n \tif (!classpath) {\n \t\t/* No cached classpath found. Need to create a new one. */\n \t\tif ((NULL != eventData->classPathEntries) || (eventData->classloader == vm->systemClassLoader)) {\n+\t\t\tif (omrthread_monitor_owned_by_self(classSegmentMutex) == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "979d5b7c97340f72db2d679e287235a889eb808b"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk5ODgyNg==", "bodyText": "Fixed.", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r438998826", "createdAt": "2020-06-11T18:48:01Z", "author": {"login": "hangshao0"}, "path": "runtime/shared_common/shrinit.cpp", "diffHunk": "@@ -1505,17 +1506,41 @@ hookFindSharedClass(J9HookInterface** hookInterface, UDATA eventNum, void* voidD\n \t\t\tif (eventData->classloader == vm->systemClassLoader) {\n \t\t\t\tisBootLoader = true;\n \t\t\t\tpathEntryCount += 1;\n+\t\t\t\tif (omrthread_monitor_owned_by_self(classSegmentMutex) == 0) {\n+\t\t\t\t\tomrthread_monitor_enter(classSegmentMutex);\n+\t\t\t\t\treleaseSegmentMutex = true;\n+\t\t\t\t}\n \t\t\t\tclasspath = getBootstrapClasspathItem(currentThread, vm->modulesPathEntry, pathEntryCount);\n+\t\t\t\tif (releaseSegmentMutex) {\n+\t\t\t\t\tomrthread_monitor_exit(classSegmentMutex);\n+\t\t\t\t\treleaseSegmentMutex = false;\n+\t\t\t\t}\n \t\t\t}\n \t\t} else {\n+\t\t\tif (omrthread_monitor_owned_by_self(classSegmentMutex) == 0) {\n+\t\t\t\tomrthread_monitor_enter(classSegmentMutex);\n+\t\t\t\treleaseSegmentMutex = true;\n+\t\t\t}\n \t\t\tclasspath = getBootstrapClasspathItem(currentThread, eventData->classPathEntries, pathEntryCount);\n+\t\t\tif (releaseSegmentMutex) {\n+\t\t\t\tomrthread_monitor_exit(classSegmentMutex);\n+\t\t\t\treleaseSegmentMutex = false;\n+\t\t\t}\n \t\t}\n \t}\n \n \tif (!classpath) {\n \t\t/* No cached classpath found. Need to create a new one. */\n \t\tif ((NULL != eventData->classPathEntries) || (eventData->classloader == vm->systemClassLoader)) {\n+\t\t\tif (omrthread_monitor_owned_by_self(classSegmentMutex) == 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkzODY2Nw=="}, "originalCommit": {"oid": "979d5b7c97340f72db2d679e287235a889eb808b"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczNDQwMDQyOnYy", "diffSide": "RIGHT", "path": "runtime/shared_common/shrinit.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNzowNjo1MFrOGimspA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxODo0ODowN1rOGiqXYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkzODc4OA==", "bodyText": "Constants on the left.", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r438938788", "createdAt": "2020-06-11T17:06:50Z", "author": {"login": "pshipton"}, "path": "runtime/shared_common/shrinit.cpp", "diffHunk": "@@ -1537,7 +1562,15 @@ hookFindSharedClass(J9HookInterface** hookInterface, UDATA eventNum, void* voidD\n \n \tif (eventData->doPreventFind) {\n \t\tif (eventData->doPreventStore) {\n+\t\t\tif (omrthread_monitor_owned_by_self(classSegmentMutex) == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "979d5b7c97340f72db2d679e287235a889eb808b"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk5ODg4Mg==", "bodyText": "Fixed.", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r438998882", "createdAt": "2020-06-11T18:48:07Z", "author": {"login": "hangshao0"}, "path": "runtime/shared_common/shrinit.cpp", "diffHunk": "@@ -1537,7 +1562,15 @@ hookFindSharedClass(J9HookInterface** hookInterface, UDATA eventNum, void* voidD\n \n \tif (eventData->doPreventFind) {\n \t\tif (eventData->doPreventStore) {\n+\t\t\tif (omrthread_monitor_owned_by_self(classSegmentMutex) == 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkzODc4OA=="}, "originalCommit": {"oid": "979d5b7c97340f72db2d679e287235a889eb808b"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczNDQwMTE1OnYy", "diffSide": "RIGHT", "path": "runtime/shared_common/shrinit.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNzowNzowNlrOGimtMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxODo0ODoxMlrOGiqXoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkzODkzMA==", "bodyText": "Constant on the left.", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r438938930", "createdAt": "2020-06-11T17:07:06Z", "author": {"login": "pshipton"}, "path": "runtime/shared_common/shrinit.cpp", "diffHunk": "@@ -1564,7 +1597,14 @@ hookFindSharedClass(J9HookInterface** hookInterface, UDATA eventNum, void* voidD\n \t}\n \n \tif (eventData->doPreventStore && (NULL == eventData->result)) {\n+\t\tif (omrthread_monitor_owned_by_self(classSegmentMutex) == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "979d5b7c97340f72db2d679e287235a889eb808b"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk5ODk0NA==", "bodyText": "Fixed.", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r438998944", "createdAt": "2020-06-11T18:48:12Z", "author": {"login": "hangshao0"}, "path": "runtime/shared_common/shrinit.cpp", "diffHunk": "@@ -1564,7 +1597,14 @@ hookFindSharedClass(J9HookInterface** hookInterface, UDATA eventNum, void* voidD\n \t}\n \n \tif (eventData->doPreventStore && (NULL == eventData->result)) {\n+\t\tif (omrthread_monitor_owned_by_self(classSegmentMutex) == 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkzODkzMA=="}, "originalCommit": {"oid": "979d5b7c97340f72db2d679e287235a889eb808b"}, "originalPosition": 88}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4973, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}