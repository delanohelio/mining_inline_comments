{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY1MDEzOTM5", "number": 8351, "reviewThreads": {"totalCount": 24, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxMTo0ODo0NlrODdTdSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxNDozNDo1OVrODfkYxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMDU0MDkwOnYy", "diffSide": "RIGHT", "path": "jcl/src/java.base/share/classes/java/lang/Class.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxMTo0ODo0NlrOFl1BpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxNzowODoyMVrOFl_6Kg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTIxMDQwNA==", "bodyText": "Is the For a class that is not a record, null is returned. case handled in the native?  Wouldn't it be easier (and faster) to do the isRecord() before calling the native?", "url": "https://github.com/eclipse-openj9/openj9/pull/8351#discussion_r375210404", "createdAt": "2020-02-05T11:48:46Z", "author": {"login": "DanHeidinga"}, "path": "jcl/src/java.base/share/classes/java/lang/Class.java", "diffHunk": "@@ -4707,11 +4711,22 @@ public boolean isRecord() {\n \t * Returns an array of RecordComponent objects for a record class.\n \t * \n \t * @return array of RecordComponent objects, one for each component in the record.\n-\t * For a class that is not a record an empty array is returned.\n+\t * For a class that is not a record, null is returned.\n \t * For a record with no components an empty array is returned.\n+\t * \n+\t * @throws SecurityException \n \t */\n+\t@CallerSensitive\n \tpublic RecordComponent[] getRecordComponents() {\n-\t\tthrow new InternalError(\"Compile stub invoked! For JEP 359 support see https://github.com/eclipse/openj9/pull/7946\"); //$NON-NLS-1$\n+\t\tSecurityManager security = System.getSecurityManager();\n+\t\tif (security != null) {\n+\t\t\tClassLoader callerClassLoader = ClassLoader.getStackClassLoader(1);\n+\t\t\tcheckMemberAccess(security, callerClassLoader, Member.DECLARED);\n+\t\t}\n+\n+\t\treturn getRecordComponentsImpl();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab79d5f5a953145a9eab5d3d060425ca65e952d3"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM2NzM1NQ==", "bodyText": "Yes that case is handled in getRecordComponentsImpl. My thought was since isRecord() is also a native it would make more sense to have only one native call here instead of two.", "url": "https://github.com/eclipse-openj9/openj9/pull/8351#discussion_r375367355", "createdAt": "2020-02-05T16:32:31Z", "author": {"login": "theresa-m"}, "path": "jcl/src/java.base/share/classes/java/lang/Class.java", "diffHunk": "@@ -4707,11 +4711,22 @@ public boolean isRecord() {\n \t * Returns an array of RecordComponent objects for a record class.\n \t * \n \t * @return array of RecordComponent objects, one for each component in the record.\n-\t * For a class that is not a record an empty array is returned.\n+\t * For a class that is not a record, null is returned.\n \t * For a record with no components an empty array is returned.\n+\t * \n+\t * @throws SecurityException \n \t */\n+\t@CallerSensitive\n \tpublic RecordComponent[] getRecordComponents() {\n-\t\tthrow new InternalError(\"Compile stub invoked! For JEP 359 support see https://github.com/eclipse/openj9/pull/7946\"); //$NON-NLS-1$\n+\t\tSecurityManager security = System.getSecurityManager();\n+\t\tif (security != null) {\n+\t\t\tClassLoader callerClassLoader = ClassLoader.getStackClassLoader(1);\n+\t\t\tcheckMemberAccess(security, callerClassLoader, Member.DECLARED);\n+\t\t}\n+\n+\t\treturn getRecordComponentsImpl();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTIxMDQwNA=="}, "originalCommit": {"oid": "ab79d5f5a953145a9eab5d3d060425ca65e952d3"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM4ODcxNA==", "bodyText": "It's, after jitting, a FastJNI that will run quickly.  Much cheaper than the getRecordComponentsImpl JNI call", "url": "https://github.com/eclipse-openj9/openj9/pull/8351#discussion_r375388714", "createdAt": "2020-02-05T17:08:21Z", "author": {"login": "DanHeidinga"}, "path": "jcl/src/java.base/share/classes/java/lang/Class.java", "diffHunk": "@@ -4707,11 +4711,22 @@ public boolean isRecord() {\n \t * Returns an array of RecordComponent objects for a record class.\n \t * \n \t * @return array of RecordComponent objects, one for each component in the record.\n-\t * For a class that is not a record an empty array is returned.\n+\t * For a class that is not a record, null is returned.\n \t * For a record with no components an empty array is returned.\n+\t * \n+\t * @throws SecurityException \n \t */\n+\t@CallerSensitive\n \tpublic RecordComponent[] getRecordComponents() {\n-\t\tthrow new InternalError(\"Compile stub invoked! For JEP 359 support see https://github.com/eclipse/openj9/pull/7946\"); //$NON-NLS-1$\n+\t\tSecurityManager security = System.getSecurityManager();\n+\t\tif (security != null) {\n+\t\t\tClassLoader callerClassLoader = ClassLoader.getStackClassLoader(1);\n+\t\t\tcheckMemberAccess(security, callerClassLoader, Member.DECLARED);\n+\t\t}\n+\n+\t\treturn getRecordComponentsImpl();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTIxMDQwNA=="}, "originalCommit": {"oid": "ab79d5f5a953145a9eab5d3d060425ca65e952d3"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMDU0MzIxOnYy", "diffSide": "RIGHT", "path": "runtime/jcl/common/reflecthelp.c", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxMTo0OTozM1rOFl1DEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxMTo0OTozM1rOFl1DEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTIxMDc2OQ==", "bodyText": "Please add a newline to the end of the file", "url": "https://github.com/eclipse-openj9/openj9/pull/8351#discussion_r375210769", "createdAt": "2020-02-05T11:49:33Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/reflecthelp.c", "diffHunk": "@@ -1720,3 +1720,202 @@ getFieldsHelper(JNIEnv *env, jobject cls)\n \tvmFuncs->internalExitVMToJNI(vmThread);\n \treturn result;\n }\n+\n+static j9object_t\n+findRecordComponentAccessorMethod(J9VMThread* currentThread, J9Class* clazz, const U_8* componentName)\n+{\n+\tJ9Method *currentMethod = clazz->ramMethods;\n+\tU_32 romMethodCount = clazz->romClass->romMethodCount;\n+\tJ9Method *resultMethod = NULL;\n+\tj9object_t resultObject = NULL;\n+\t\n+\tfor (; romMethodCount > 0; romMethodCount--) {\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(currentMethod);\n+\t\tconst U_8 *methodName = J9UTF8_DATA(J9ROMMETHOD_NAME(romMethod));\n+\t\tif (0 == strcmp((const char*)methodName, (const char*)componentName)) {\n+\t\t\t/* verify parameters. An accessor will not have any input parameters. */\n+\t\t\tconst U_8 *methodSignature = J9UTF8_DATA(J9ROMMETHOD_SIGNATURE(romMethod));\n+\t\t\tif (('(' == methodSignature[0]) && (')' == methodSignature[1])) {\n+\t\t\t\tresultMethod = currentMethod;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\t\tcurrentMethod += 1;\n+\t}\n+\t/* An accessor method exists for every record component */\n+\tAssert_JCL_true(NULL != resultMethod);\n+\n+\tresultObject = createMethodObject(resultMethod, clazz, NULL, currentThread);\n+\n+\treturn resultObject;\n+}\n+\n+/* Creates an array of RecordComponents for the given class and sets the following fields:\n+ * - Class<?> clazz \n+ * - String name\n+ * - Class<?> type\n+ * - Method accessor\n+ * - String signature\n+ * - byte[] annotations\n+ * - byte[] typeAnnotations\n+ * - RecordComponent root (currently always null)\n+ */\n+jarray\n+getRecordComponentsHelper(JNIEnv *env, jobject cls)\n+{\n+\tJ9VMThread *vmThread = (J9VMThread *)env;\n+\tJ9JavaVM *vm = vmThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tJ9MemoryManagerFunctions *mmFuncs = vm->memoryManagerFunctions;\n+\tjarray result = NULL;\n+\tJ9Class *recordComponentClass = NULL;\n+\tJ9Class *recordComponentArrayClass = NULL;\n+\tU_32 recordComponentCount = 0;\n+\tj9array_t recordComponentArrayObject = NULL;\n+\n+\tvmFuncs->internalEnterVMFromJNI(vmThread);\n+\n+\tJ9Class *clazz = J9VM_J9CLASS_FROM_JCLASS(vmThread, (jclass)cls);\n+\tJ9ROMClass *romClass = clazz->romClass;\n+\n+\tif (FALSE == J9ROMCLASS_IS_RECORD(romClass)) {\n+\t\tgoto done;\n+\t}\n+\n+\t/* allocate an array of RecordComponent objects */\n+\trecordComponentClass = J9VMJAVALANGREFLECTRECORDCOMPONENT(vm);\n+\tif (NULL != vmThread->currentException) {\n+\t\tgoto done;\n+\t}\n+\n+\trecordComponentArrayClass = fetchArrayClass(vmThread, recordComponentClass);\n+\tif (NULL != vmThread->currentException) {\n+\t\tgoto done;\n+\t}\n+\n+\trecordComponentCount = getNumberOfRecordComponents(romClass);\n+\n+\trecordComponentArrayObject = (j9array_t) mmFuncs->J9AllocateIndexableObject(vmThread, recordComponentArrayClass,\n+\t\t\trecordComponentCount, J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\tif (NULL == recordComponentArrayObject) {\n+\t\tgoto heapoutofmemory;\n+\t}\n+\n+\tresult = vmFuncs->j9jni_createLocalRef(env, (j9object_t)recordComponentArrayObject);\n+\tif (NULL == result) {\n+\t\tgoto nativeoutofmemory;\n+\t}\n+\n+\tif (recordComponentCount > 0) {\n+\t\tJ9ROMRecordComponentShape* recordComponent = recordComponentStartDo(romClass);\n+\t\tfor (U_32 rcIndex = 0; rcIndex < recordComponentCount; rcIndex++) {\n+\t\t\tj9object_t recordComponentObject = NULL;\n+\t\t\tJ9UTF8* nameUTF = NULL;\n+\t\t\tj9object_t nameString = NULL;\n+\t\t\tU_8 *typeData = NULL;\n+\t\t\tj9object_t accessorMethod = NULL;\n+\t\t\tJ9Class *typeClass = NULL;\n+\n+\t\t\trecordComponentObject = mmFuncs->J9AllocateObject(vmThread, recordComponentClass, J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tif (NULL == recordComponentObject) {\n+\t\t\t\tgoto heapoutofmemory;\n+\t\t\t}\n+\n+\t\t\t/** set RecordComponent fields **/\n+\n+\t\t\tPUSH_OBJECT_IN_SPECIAL_FRAME(vmThread, recordComponentObject);\n+\n+\t\t\t/* String name */\n+\t\t\tnameUTF = J9ROMRECORDCOMPONENTSHAPE_NAME(recordComponent);\n+\t\t\tnameString = mmFuncs->j9gc_createJavaLangString(vmThread, J9UTF8_DATA(nameUTF), (U_32) J9UTF8_LENGTH(nameUTF), J9_STR_INTERN);\n+\t\t\tif (NULL == nameString) {\n+\t\t\t \tDROP_OBJECT_IN_SPECIAL_FRAME(vmThread); /* recordComponentObject */\n+\t\t\t \tgoto heapoutofmemory;\n+\t\t\t}\n+\t\t\trecordComponentObject = PEEK_OBJECT_IN_SPECIAL_FRAME(vmThread, 0);\n+\t\t\tJ9VMJAVALANGREFLECTRECORDCOMPONENT_SET_NAME(vmThread, recordComponentObject, nameString);\n+\n+\t\t\t/* Class<?> type */\n+\t\t\ttypeData = J9UTF8_DATA(J9ROMRECORDCOMPONENTSHAPE_SIGNATURE(recordComponent));\n+\t\t\ttypeClass = classForSignature(vmThread, &typeData, clazz->classLoader);\n+\t\t\tif (NULL == typeClass) {\n+\t\t\t\tDROP_OBJECT_IN_SPECIAL_FRAME(vmThread); /* recordComponentObject */\n+\t\t\t\tgoto heapoutofmemory;\n+\t\t\t}\n+\t\t\trecordComponentObject = PEEK_OBJECT_IN_SPECIAL_FRAME(vmThread, 0);\n+\t\t\tJ9VMJAVALANGREFLECTRECORDCOMPONENT_SET_TYPE(vmThread, recordComponentObject, J9VM_J9CLASS_TO_HEAPCLASS(typeClass));\n+\n+\t\t\t/* Method accessor - this is the components getter method which will have the same name as the component itself. */\n+\t\t\taccessorMethod = findRecordComponentAccessorMethod(vmThread, clazz, J9UTF8_DATA(J9ROMRECORDCOMPONENTSHAPE_NAME(recordComponent)));\n+\t\t\tif (NULL == accessorMethod) {\n+\t\t\t\tDROP_OBJECT_IN_SPECIAL_FRAME(vmThread); /* recordComponentObject */\n+\t\t\t\tgoto heapoutofmemory;\n+\t\t\t}\n+\t\t\trecordComponentObject = PEEK_OBJECT_IN_SPECIAL_FRAME(vmThread, 0);\n+\t\t\tJ9VMJAVALANGREFLECTRECORDCOMPONENT_SET_ACCESSOR(vmThread, recordComponentObject, accessorMethod);\n+\n+\t\t\t/* String signature */\n+\t\t\tif (recordComponentHasSignature(recordComponent)) {\n+\t\t\t\tJ9UTF8* signatureUTF = getRecordComponentGenericSignature(recordComponent);\n+\t\t\t\tj9object_t signatureString = mmFuncs->j9gc_createJavaLangString(vmThread, J9UTF8_DATA(signatureUTF), (U_32) J9UTF8_LENGTH(signatureUTF), J9_STR_INTERN);\n+\t\t\t\tif (NULL == signatureString) {\n+\t\t\t\t\tDROP_OBJECT_IN_SPECIAL_FRAME(vmThread); /* recordComponentObject */\n+\t\t\t\t\tgoto heapoutofmemory;\n+\t\t\t\t}\n+\t\t\t\trecordComponentObject = PEEK_OBJECT_IN_SPECIAL_FRAME(vmThread, 0);\n+\t\t\t\tJ9VMJAVALANGREFLECTRECORDCOMPONENT_SET_SIGNATURE(vmThread, recordComponentObject, signatureString);\n+\t\t\t}\n+\n+\t\t\t/* byte[] annotations */\n+\t\t\tif (recordComponentHasAnnotations(recordComponent)) {\n+\t\t\t\tU_32* annotationData = getRecordComponentAnnotationData(recordComponent);\n+\t\t\t\tj9object_t byteArray = getAnnotationDataAsByteArray(vmThread, annotationData);\n+\t\t\t\tif (NULL != vmThread->currentException) {\n+\t\t\t\t\tDROP_OBJECT_IN_SPECIAL_FRAME(vmThread); /* recordComponentObject */\n+\t\t\t\t\tgoto done;\n+\t\t\t\t}\n+\t\t\t\trecordComponentObject = PEEK_OBJECT_IN_SPECIAL_FRAME(vmThread, 0);\n+\t\t\t\tJ9VMJAVALANGREFLECTRECORDCOMPONENT_SET_ANNOTATIONS(vmThread, recordComponentObject, byteArray);\n+\t\t\t}\n+\n+\t\t\t/* byte[] typeAnnotations */\n+\t\t\tif (recordComponentHasTypeAnnotations(recordComponent)) {\n+\t\t\t\tU_32* typeAnnotationData = getRecordComponentTypeAnnotationData(recordComponent);\n+\t\t\t\tj9object_t byteArray = getAnnotationDataAsByteArray(vmThread, typeAnnotationData);\n+\t\t\t\tif (NULL != vmThread->currentException) {\n+\t\t\t\t\tDROP_OBJECT_IN_SPECIAL_FRAME(vmThread); /* recordComponentObject */\n+\t\t\t\t\tgoto done;\n+\t\t\t\t}\n+\t\t\t\trecordComponentObject = PEEK_OBJECT_IN_SPECIAL_FRAME(vmThread, 0);\n+\t\t\t\tJ9VMJAVALANGREFLECTRECORDCOMPONENT_SET_TYPEANNOTATIONS(vmThread, recordComponentObject, byteArray);\n+\t\t\t}\n+\n+\t\t\t/* end of setting parameters where class loading may occur */\n+\t\t\trecordComponentObject = POP_OBJECT_IN_SPECIAL_FRAME(vmThread);\n+\n+\t\t\t/* Class<?> clazz */\n+\t\t\tJ9VMJAVALANGREFLECTRECORDCOMPONENT_SET_DECLARINGCLASS(vmThread, recordComponentObject, J9VM_J9CLASS_TO_HEAPCLASS(clazz));\n+\n+\t\t\t/* refetch array object because vmaccess could have been released */\n+\t\t\trecordComponentArrayObject = (j9array_t)J9_JNI_UNWRAP_REFERENCE(result);\n+\n+\t\t\t/* store record component object into final array */\n+\t\t\tJ9JAVAARRAYOFOBJECT_STORE(vmThread, recordComponentArrayObject, rcIndex, recordComponentObject);\n+\n+\t\t\trecordComponent = recordComponentNextDo(recordComponent);\n+\t\t}\n+\t}\n+\tgoto done;\n+\n+nativeoutofmemory:\n+\tvmFuncs->setNativeOutOfMemoryError(vmThread, 0, 0);\n+\tgoto done;\n+\n+heapoutofmemory:\n+\tvmFuncs->setHeapOutOfMemoryError(vmThread);\n+\tgoto done;\n+\n+done:\n+\tvmFuncs->internalExitVMToJNI(vmThread);\n+\treturn result;\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab79d5f5a953145a9eab5d3d060425ca65e952d3"}, "originalPosition": 209}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMDU1NzM4OnYy", "diffSide": "RIGHT", "path": "runtime/jcl/common/reflecthelp.c", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxMTo1NTowM1rOFl1LwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxMTo1NTowM1rOFl1LwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTIxMjk5Mw==", "bodyText": "This won't compile on no-c99 platforms.  The variables have to be declared before the vmFuncs->internalEnterVMFromJNI(vmThread); call", "url": "https://github.com/eclipse-openj9/openj9/pull/8351#discussion_r375212993", "createdAt": "2020-02-05T11:55:03Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/reflecthelp.c", "diffHunk": "@@ -1720,3 +1720,202 @@ getFieldsHelper(JNIEnv *env, jobject cls)\n \tvmFuncs->internalExitVMToJNI(vmThread);\n \treturn result;\n }\n+\n+static j9object_t\n+findRecordComponentAccessorMethod(J9VMThread* currentThread, J9Class* clazz, const U_8* componentName)\n+{\n+\tJ9Method *currentMethod = clazz->ramMethods;\n+\tU_32 romMethodCount = clazz->romClass->romMethodCount;\n+\tJ9Method *resultMethod = NULL;\n+\tj9object_t resultObject = NULL;\n+\t\n+\tfor (; romMethodCount > 0; romMethodCount--) {\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(currentMethod);\n+\t\tconst U_8 *methodName = J9UTF8_DATA(J9ROMMETHOD_NAME(romMethod));\n+\t\tif (0 == strcmp((const char*)methodName, (const char*)componentName)) {\n+\t\t\t/* verify parameters. An accessor will not have any input parameters. */\n+\t\t\tconst U_8 *methodSignature = J9UTF8_DATA(J9ROMMETHOD_SIGNATURE(romMethod));\n+\t\t\tif (('(' == methodSignature[0]) && (')' == methodSignature[1])) {\n+\t\t\t\tresultMethod = currentMethod;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\t\tcurrentMethod += 1;\n+\t}\n+\t/* An accessor method exists for every record component */\n+\tAssert_JCL_true(NULL != resultMethod);\n+\n+\tresultObject = createMethodObject(resultMethod, clazz, NULL, currentThread);\n+\n+\treturn resultObject;\n+}\n+\n+/* Creates an array of RecordComponents for the given class and sets the following fields:\n+ * - Class<?> clazz \n+ * - String name\n+ * - Class<?> type\n+ * - Method accessor\n+ * - String signature\n+ * - byte[] annotations\n+ * - byte[] typeAnnotations\n+ * - RecordComponent root (currently always null)\n+ */\n+jarray\n+getRecordComponentsHelper(JNIEnv *env, jobject cls)\n+{\n+\tJ9VMThread *vmThread = (J9VMThread *)env;\n+\tJ9JavaVM *vm = vmThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tJ9MemoryManagerFunctions *mmFuncs = vm->memoryManagerFunctions;\n+\tjarray result = NULL;\n+\tJ9Class *recordComponentClass = NULL;\n+\tJ9Class *recordComponentArrayClass = NULL;\n+\tU_32 recordComponentCount = 0;\n+\tj9array_t recordComponentArrayObject = NULL;\n+\n+\tvmFuncs->internalEnterVMFromJNI(vmThread);\n+\n+\tJ9Class *clazz = J9VM_J9CLASS_FROM_JCLASS(vmThread, (jclass)cls);\n+\tJ9ROMClass *romClass = clazz->romClass;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab79d5f5a953145a9eab5d3d060425ca65e952d3"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMDcyNjg2OnYy", "diffSide": "RIGHT", "path": "runtime/jcl/common/reflecthelp.c", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxMjo1NzozOFrOFl2yRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxNzowOTozNVrOFl_82w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTIzOTIzOQ==", "bodyText": "Are the components spec'd to be interned?  I'm OK with them being interned but if its a spec requirement we should call that out in the code", "url": "https://github.com/eclipse-openj9/openj9/pull/8351#discussion_r375239239", "createdAt": "2020-02-05T12:57:38Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/reflecthelp.c", "diffHunk": "@@ -1720,3 +1720,202 @@ getFieldsHelper(JNIEnv *env, jobject cls)\n \tvmFuncs->internalExitVMToJNI(vmThread);\n \treturn result;\n }\n+\n+static j9object_t\n+findRecordComponentAccessorMethod(J9VMThread* currentThread, J9Class* clazz, const U_8* componentName)\n+{\n+\tJ9Method *currentMethod = clazz->ramMethods;\n+\tU_32 romMethodCount = clazz->romClass->romMethodCount;\n+\tJ9Method *resultMethod = NULL;\n+\tj9object_t resultObject = NULL;\n+\t\n+\tfor (; romMethodCount > 0; romMethodCount--) {\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(currentMethod);\n+\t\tconst U_8 *methodName = J9UTF8_DATA(J9ROMMETHOD_NAME(romMethod));\n+\t\tif (0 == strcmp((const char*)methodName, (const char*)componentName)) {\n+\t\t\t/* verify parameters. An accessor will not have any input parameters. */\n+\t\t\tconst U_8 *methodSignature = J9UTF8_DATA(J9ROMMETHOD_SIGNATURE(romMethod));\n+\t\t\tif (('(' == methodSignature[0]) && (')' == methodSignature[1])) {\n+\t\t\t\tresultMethod = currentMethod;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\t\tcurrentMethod += 1;\n+\t}\n+\t/* An accessor method exists for every record component */\n+\tAssert_JCL_true(NULL != resultMethod);\n+\n+\tresultObject = createMethodObject(resultMethod, clazz, NULL, currentThread);\n+\n+\treturn resultObject;\n+}\n+\n+/* Creates an array of RecordComponents for the given class and sets the following fields:\n+ * - Class<?> clazz \n+ * - String name\n+ * - Class<?> type\n+ * - Method accessor\n+ * - String signature\n+ * - byte[] annotations\n+ * - byte[] typeAnnotations\n+ * - RecordComponent root (currently always null)\n+ */\n+jarray\n+getRecordComponentsHelper(JNIEnv *env, jobject cls)\n+{\n+\tJ9VMThread *vmThread = (J9VMThread *)env;\n+\tJ9JavaVM *vm = vmThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tJ9MemoryManagerFunctions *mmFuncs = vm->memoryManagerFunctions;\n+\tjarray result = NULL;\n+\tJ9Class *recordComponentClass = NULL;\n+\tJ9Class *recordComponentArrayClass = NULL;\n+\tU_32 recordComponentCount = 0;\n+\tj9array_t recordComponentArrayObject = NULL;\n+\n+\tvmFuncs->internalEnterVMFromJNI(vmThread);\n+\n+\tJ9Class *clazz = J9VM_J9CLASS_FROM_JCLASS(vmThread, (jclass)cls);\n+\tJ9ROMClass *romClass = clazz->romClass;\n+\n+\tif (FALSE == J9ROMCLASS_IS_RECORD(romClass)) {\n+\t\tgoto done;\n+\t}\n+\n+\t/* allocate an array of RecordComponent objects */\n+\trecordComponentClass = J9VMJAVALANGREFLECTRECORDCOMPONENT(vm);\n+\tif (NULL != vmThread->currentException) {\n+\t\tgoto done;\n+\t}\n+\n+\trecordComponentArrayClass = fetchArrayClass(vmThread, recordComponentClass);\n+\tif (NULL != vmThread->currentException) {\n+\t\tgoto done;\n+\t}\n+\n+\trecordComponentCount = getNumberOfRecordComponents(romClass);\n+\n+\trecordComponentArrayObject = (j9array_t) mmFuncs->J9AllocateIndexableObject(vmThread, recordComponentArrayClass,\n+\t\t\trecordComponentCount, J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\tif (NULL == recordComponentArrayObject) {\n+\t\tgoto heapoutofmemory;\n+\t}\n+\n+\tresult = vmFuncs->j9jni_createLocalRef(env, (j9object_t)recordComponentArrayObject);\n+\tif (NULL == result) {\n+\t\tgoto nativeoutofmemory;\n+\t}\n+\n+\tif (recordComponentCount > 0) {\n+\t\tJ9ROMRecordComponentShape* recordComponent = recordComponentStartDo(romClass);\n+\t\tfor (U_32 rcIndex = 0; rcIndex < recordComponentCount; rcIndex++) {\n+\t\t\tj9object_t recordComponentObject = NULL;\n+\t\t\tJ9UTF8* nameUTF = NULL;\n+\t\t\tj9object_t nameString = NULL;\n+\t\t\tU_8 *typeData = NULL;\n+\t\t\tj9object_t accessorMethod = NULL;\n+\t\t\tJ9Class *typeClass = NULL;\n+\n+\t\t\trecordComponentObject = mmFuncs->J9AllocateObject(vmThread, recordComponentClass, J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tif (NULL == recordComponentObject) {\n+\t\t\t\tgoto heapoutofmemory;\n+\t\t\t}\n+\n+\t\t\t/** set RecordComponent fields **/\n+\n+\t\t\tPUSH_OBJECT_IN_SPECIAL_FRAME(vmThread, recordComponentObject);\n+\n+\t\t\t/* String name */\n+\t\t\tnameUTF = J9ROMRECORDCOMPONENTSHAPE_NAME(recordComponent);\n+\t\t\tnameString = mmFuncs->j9gc_createJavaLangString(vmThread, J9UTF8_DATA(nameUTF), (U_32) J9UTF8_LENGTH(nameUTF), J9_STR_INTERN);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab79d5f5a953145a9eab5d3d060425ca65e952d3"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM3NzMwOA==", "bodyText": "The spec did not mention anything about interning. https://cr.openjdk.java.net/~iris/se/14/spec/pr/java-se-14-pr-spec-01/apidiffs/java.base/java/lang/Class-report.html#method:getRecordComponents()\nI don't think I've seen that kind of information mentioned in a spec before. Where would I find that?", "url": "https://github.com/eclipse-openj9/openj9/pull/8351#discussion_r375377308", "createdAt": "2020-02-05T16:48:56Z", "author": {"login": "theresa-m"}, "path": "runtime/jcl/common/reflecthelp.c", "diffHunk": "@@ -1720,3 +1720,202 @@ getFieldsHelper(JNIEnv *env, jobject cls)\n \tvmFuncs->internalExitVMToJNI(vmThread);\n \treturn result;\n }\n+\n+static j9object_t\n+findRecordComponentAccessorMethod(J9VMThread* currentThread, J9Class* clazz, const U_8* componentName)\n+{\n+\tJ9Method *currentMethod = clazz->ramMethods;\n+\tU_32 romMethodCount = clazz->romClass->romMethodCount;\n+\tJ9Method *resultMethod = NULL;\n+\tj9object_t resultObject = NULL;\n+\t\n+\tfor (; romMethodCount > 0; romMethodCount--) {\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(currentMethod);\n+\t\tconst U_8 *methodName = J9UTF8_DATA(J9ROMMETHOD_NAME(romMethod));\n+\t\tif (0 == strcmp((const char*)methodName, (const char*)componentName)) {\n+\t\t\t/* verify parameters. An accessor will not have any input parameters. */\n+\t\t\tconst U_8 *methodSignature = J9UTF8_DATA(J9ROMMETHOD_SIGNATURE(romMethod));\n+\t\t\tif (('(' == methodSignature[0]) && (')' == methodSignature[1])) {\n+\t\t\t\tresultMethod = currentMethod;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\t\tcurrentMethod += 1;\n+\t}\n+\t/* An accessor method exists for every record component */\n+\tAssert_JCL_true(NULL != resultMethod);\n+\n+\tresultObject = createMethodObject(resultMethod, clazz, NULL, currentThread);\n+\n+\treturn resultObject;\n+}\n+\n+/* Creates an array of RecordComponents for the given class and sets the following fields:\n+ * - Class<?> clazz \n+ * - String name\n+ * - Class<?> type\n+ * - Method accessor\n+ * - String signature\n+ * - byte[] annotations\n+ * - byte[] typeAnnotations\n+ * - RecordComponent root (currently always null)\n+ */\n+jarray\n+getRecordComponentsHelper(JNIEnv *env, jobject cls)\n+{\n+\tJ9VMThread *vmThread = (J9VMThread *)env;\n+\tJ9JavaVM *vm = vmThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tJ9MemoryManagerFunctions *mmFuncs = vm->memoryManagerFunctions;\n+\tjarray result = NULL;\n+\tJ9Class *recordComponentClass = NULL;\n+\tJ9Class *recordComponentArrayClass = NULL;\n+\tU_32 recordComponentCount = 0;\n+\tj9array_t recordComponentArrayObject = NULL;\n+\n+\tvmFuncs->internalEnterVMFromJNI(vmThread);\n+\n+\tJ9Class *clazz = J9VM_J9CLASS_FROM_JCLASS(vmThread, (jclass)cls);\n+\tJ9ROMClass *romClass = clazz->romClass;\n+\n+\tif (FALSE == J9ROMCLASS_IS_RECORD(romClass)) {\n+\t\tgoto done;\n+\t}\n+\n+\t/* allocate an array of RecordComponent objects */\n+\trecordComponentClass = J9VMJAVALANGREFLECTRECORDCOMPONENT(vm);\n+\tif (NULL != vmThread->currentException) {\n+\t\tgoto done;\n+\t}\n+\n+\trecordComponentArrayClass = fetchArrayClass(vmThread, recordComponentClass);\n+\tif (NULL != vmThread->currentException) {\n+\t\tgoto done;\n+\t}\n+\n+\trecordComponentCount = getNumberOfRecordComponents(romClass);\n+\n+\trecordComponentArrayObject = (j9array_t) mmFuncs->J9AllocateIndexableObject(vmThread, recordComponentArrayClass,\n+\t\t\trecordComponentCount, J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\tif (NULL == recordComponentArrayObject) {\n+\t\tgoto heapoutofmemory;\n+\t}\n+\n+\tresult = vmFuncs->j9jni_createLocalRef(env, (j9object_t)recordComponentArrayObject);\n+\tif (NULL == result) {\n+\t\tgoto nativeoutofmemory;\n+\t}\n+\n+\tif (recordComponentCount > 0) {\n+\t\tJ9ROMRecordComponentShape* recordComponent = recordComponentStartDo(romClass);\n+\t\tfor (U_32 rcIndex = 0; rcIndex < recordComponentCount; rcIndex++) {\n+\t\t\tj9object_t recordComponentObject = NULL;\n+\t\t\tJ9UTF8* nameUTF = NULL;\n+\t\t\tj9object_t nameString = NULL;\n+\t\t\tU_8 *typeData = NULL;\n+\t\t\tj9object_t accessorMethod = NULL;\n+\t\t\tJ9Class *typeClass = NULL;\n+\n+\t\t\trecordComponentObject = mmFuncs->J9AllocateObject(vmThread, recordComponentClass, J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tif (NULL == recordComponentObject) {\n+\t\t\t\tgoto heapoutofmemory;\n+\t\t\t}\n+\n+\t\t\t/** set RecordComponent fields **/\n+\n+\t\t\tPUSH_OBJECT_IN_SPECIAL_FRAME(vmThread, recordComponentObject);\n+\n+\t\t\t/* String name */\n+\t\t\tnameUTF = J9ROMRECORDCOMPONENTSHAPE_NAME(recordComponent);\n+\t\t\tnameString = mmFuncs->j9gc_createJavaLangString(vmThread, J9UTF8_DATA(nameUTF), (U_32) J9UTF8_LENGTH(nameUTF), J9_STR_INTERN);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTIzOTIzOQ=="}, "originalCommit": {"oid": "ab79d5f5a953145a9eab5d3d060425ca65e952d3"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM4OTQwMw==", "bodyText": "That would be the place.  Since it's not mentioned, it's an implementation detail.  Fine to leave as it is since we intern for Reflect objects", "url": "https://github.com/eclipse-openj9/openj9/pull/8351#discussion_r375389403", "createdAt": "2020-02-05T17:09:35Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/reflecthelp.c", "diffHunk": "@@ -1720,3 +1720,202 @@ getFieldsHelper(JNIEnv *env, jobject cls)\n \tvmFuncs->internalExitVMToJNI(vmThread);\n \treturn result;\n }\n+\n+static j9object_t\n+findRecordComponentAccessorMethod(J9VMThread* currentThread, J9Class* clazz, const U_8* componentName)\n+{\n+\tJ9Method *currentMethod = clazz->ramMethods;\n+\tU_32 romMethodCount = clazz->romClass->romMethodCount;\n+\tJ9Method *resultMethod = NULL;\n+\tj9object_t resultObject = NULL;\n+\t\n+\tfor (; romMethodCount > 0; romMethodCount--) {\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(currentMethod);\n+\t\tconst U_8 *methodName = J9UTF8_DATA(J9ROMMETHOD_NAME(romMethod));\n+\t\tif (0 == strcmp((const char*)methodName, (const char*)componentName)) {\n+\t\t\t/* verify parameters. An accessor will not have any input parameters. */\n+\t\t\tconst U_8 *methodSignature = J9UTF8_DATA(J9ROMMETHOD_SIGNATURE(romMethod));\n+\t\t\tif (('(' == methodSignature[0]) && (')' == methodSignature[1])) {\n+\t\t\t\tresultMethod = currentMethod;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\t\tcurrentMethod += 1;\n+\t}\n+\t/* An accessor method exists for every record component */\n+\tAssert_JCL_true(NULL != resultMethod);\n+\n+\tresultObject = createMethodObject(resultMethod, clazz, NULL, currentThread);\n+\n+\treturn resultObject;\n+}\n+\n+/* Creates an array of RecordComponents for the given class and sets the following fields:\n+ * - Class<?> clazz \n+ * - String name\n+ * - Class<?> type\n+ * - Method accessor\n+ * - String signature\n+ * - byte[] annotations\n+ * - byte[] typeAnnotations\n+ * - RecordComponent root (currently always null)\n+ */\n+jarray\n+getRecordComponentsHelper(JNIEnv *env, jobject cls)\n+{\n+\tJ9VMThread *vmThread = (J9VMThread *)env;\n+\tJ9JavaVM *vm = vmThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tJ9MemoryManagerFunctions *mmFuncs = vm->memoryManagerFunctions;\n+\tjarray result = NULL;\n+\tJ9Class *recordComponentClass = NULL;\n+\tJ9Class *recordComponentArrayClass = NULL;\n+\tU_32 recordComponentCount = 0;\n+\tj9array_t recordComponentArrayObject = NULL;\n+\n+\tvmFuncs->internalEnterVMFromJNI(vmThread);\n+\n+\tJ9Class *clazz = J9VM_J9CLASS_FROM_JCLASS(vmThread, (jclass)cls);\n+\tJ9ROMClass *romClass = clazz->romClass;\n+\n+\tif (FALSE == J9ROMCLASS_IS_RECORD(romClass)) {\n+\t\tgoto done;\n+\t}\n+\n+\t/* allocate an array of RecordComponent objects */\n+\trecordComponentClass = J9VMJAVALANGREFLECTRECORDCOMPONENT(vm);\n+\tif (NULL != vmThread->currentException) {\n+\t\tgoto done;\n+\t}\n+\n+\trecordComponentArrayClass = fetchArrayClass(vmThread, recordComponentClass);\n+\tif (NULL != vmThread->currentException) {\n+\t\tgoto done;\n+\t}\n+\n+\trecordComponentCount = getNumberOfRecordComponents(romClass);\n+\n+\trecordComponentArrayObject = (j9array_t) mmFuncs->J9AllocateIndexableObject(vmThread, recordComponentArrayClass,\n+\t\t\trecordComponentCount, J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\tif (NULL == recordComponentArrayObject) {\n+\t\tgoto heapoutofmemory;\n+\t}\n+\n+\tresult = vmFuncs->j9jni_createLocalRef(env, (j9object_t)recordComponentArrayObject);\n+\tif (NULL == result) {\n+\t\tgoto nativeoutofmemory;\n+\t}\n+\n+\tif (recordComponentCount > 0) {\n+\t\tJ9ROMRecordComponentShape* recordComponent = recordComponentStartDo(romClass);\n+\t\tfor (U_32 rcIndex = 0; rcIndex < recordComponentCount; rcIndex++) {\n+\t\t\tj9object_t recordComponentObject = NULL;\n+\t\t\tJ9UTF8* nameUTF = NULL;\n+\t\t\tj9object_t nameString = NULL;\n+\t\t\tU_8 *typeData = NULL;\n+\t\t\tj9object_t accessorMethod = NULL;\n+\t\t\tJ9Class *typeClass = NULL;\n+\n+\t\t\trecordComponentObject = mmFuncs->J9AllocateObject(vmThread, recordComponentClass, J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tif (NULL == recordComponentObject) {\n+\t\t\t\tgoto heapoutofmemory;\n+\t\t\t}\n+\n+\t\t\t/** set RecordComponent fields **/\n+\n+\t\t\tPUSH_OBJECT_IN_SPECIAL_FRAME(vmThread, recordComponentObject);\n+\n+\t\t\t/* String name */\n+\t\t\tnameUTF = J9ROMRECORDCOMPONENTSHAPE_NAME(recordComponent);\n+\t\t\tnameString = mmFuncs->j9gc_createJavaLangString(vmThread, J9UTF8_DATA(nameUTF), (U_32) J9UTF8_LENGTH(nameUTF), J9_STR_INTERN);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTIzOTIzOQ=="}, "originalCommit": {"oid": "ab79d5f5a953145a9eab5d3d060425ca65e952d3"}, "originalPosition": 118}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMDc1MTQ0OnYy", "diffSide": "RIGHT", "path": "runtime/util/optinfo.c", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxMzowNjoxNVrOFl3A7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxMzowNjoxNVrOFl3A7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTI0Mjk5MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tptr = getSRPPtr(J9ROMCLASS_OPTIONALINFO(romClass), romClass->optionalFlags, J9_ROMCLASS_OPTINFO_RECORD_ATTRIBUTE);\n          \n          \n            \n            \tU_32 *ptr = getSRPPtr(J9ROMCLASS_OPTIONALINFO(romClass), romClass->optionalFlags, J9_ROMCLASS_OPTINFO_RECORD_ATTRIBUTE);\n          \n      \n    \n    \n  \n\nDeclare and assign in one line", "url": "https://github.com/eclipse-openj9/openj9/pull/8351#discussion_r375242991", "createdAt": "2020-02-05T13:06:15Z", "author": {"login": "DanHeidinga"}, "path": "runtime/util/optinfo.c", "diffHunk": "@@ -672,3 +673,119 @@ getLineNumberForROMClassFromROMMethod(J9JavaVM *vm, J9ROMMethod *romMethod, J9RO\n \treturn number;\n }\n \n+U_32\n+getNumberOfRecordComponents(J9ROMClass *romClass)\n+{\n+\tU_32 *ptr;\n+\n+\tptr = getSRPPtr(J9ROMCLASS_OPTIONALINFO(romClass), romClass->optionalFlags, J9_ROMCLASS_OPTINFO_RECORD_ATTRIBUTE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab79d5f5a953145a9eab5d3d060425ca65e952d3"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMDc1NjgwOnYy", "diffSide": "RIGHT", "path": "runtime/util/optinfo.c", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxMzowNzo1OFrOFl3EJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxMzowNzo1OFrOFl3EJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTI0MzgxNQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tUDATA size = sizeof(U_32);\t\t\t\t\t\t\t/* size of length */\n          \n          \n            \n            \tUDATA size = sizeof(U_32);\t\t/* size of length */", "url": "https://github.com/eclipse-openj9/openj9/pull/8351#discussion_r375243815", "createdAt": "2020-02-05T13:07:58Z", "author": {"login": "DanHeidinga"}, "path": "runtime/util/optinfo.c", "diffHunk": "@@ -672,3 +673,119 @@ getLineNumberForROMClassFromROMMethod(J9JavaVM *vm, J9ROMMethod *romMethod, J9RO\n \treturn number;\n }\n \n+U_32\n+getNumberOfRecordComponents(J9ROMClass *romClass)\n+{\n+\tU_32 *ptr;\n+\n+\tptr = getSRPPtr(J9ROMCLASS_OPTIONALINFO(romClass), romClass->optionalFlags, J9_ROMCLASS_OPTINFO_RECORD_ATTRIBUTE);\n+\n+\tAssert_VMUtil_true(ptr != NULL);\n+\n+\treturn *SRP_PTR_GET(ptr, U_32*);\n+}\n+\n+BOOLEAN\n+recordComponentHasSignature(J9ROMRecordComponentShape* recordComponent)\n+{\n+\treturn (recordComponent->attributeFlags & J9RecordComponentFlagHasGenericSignature);\n+}\n+\n+BOOLEAN\n+recordComponentHasAnnotations(J9ROMRecordComponentShape* recordComponent)\n+{\n+\treturn (recordComponent->attributeFlags & J9RecordComponentFlagHasAnnotations);\n+}\n+\n+BOOLEAN\n+recordComponentHasTypeAnnotations(J9ROMRecordComponentShape* recordComponent)\n+{\n+\treturn (recordComponent->attributeFlags & J9RecordComponentFlagHasTypeAnnotations);\n+}\n+\n+J9UTF8*\n+getRecordComponentGenericSignature(J9ROMRecordComponentShape* recordComponent)\n+{\n+\tif (recordComponentHasSignature(recordComponent)) {\t\n+\t\tU_32* signaturePtr = (U_32*) ((UDATA)recordComponent + sizeof(J9ROMRecordComponentShape));\n+\t\treturn NNSRP_PTR_GET(signaturePtr, J9UTF8*);\n+\t}\n+\treturn NULL;\n+}\n+\n+U_32*\n+getRecordComponentAnnotationData(J9ROMRecordComponentShape* recordComponent)\n+{\n+\tU_32* result = NULL;\n+\tif (recordComponentHasAnnotations(recordComponent)) {\n+\t\t/* calculate offset from start of record component */\n+\t\tUDATA offset = sizeof(J9ROMRecordComponentShape);\n+\t\t/* U_32 for generic signature if it exists */\n+\t\tif (recordComponentHasSignature(recordComponent)) {\n+\t\t\toffset += sizeof(U_32);\n+\t\t}\n+\t\tresult = (U_32*)((UDATA)recordComponent + offset);\n+\t}\n+\treturn result;\n+}\n+\n+static UDATA\n+annotationAttributeSize(U_8* annotationAttribute) {\n+\tAssert_VMUtil_true(((UDATA)annotationAttribute % sizeof(U_32)) == 0);\n+\tUDATA size = sizeof(U_32);\t\t\t\t\t\t\t/* size of length */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab79d5f5a953145a9eab5d3d060425ca65e952d3"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMDc1NzM3OnYy", "diffSide": "RIGHT", "path": "runtime/util/optinfo.c", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxMzowODoxMVrOFl3Ehw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxMzowODoxMVrOFl3Ehw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTI0MzkxMQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tsize += *((U_32 *)annotationAttribute);\t\t\t\t\t\t/* length of attribute */\n          \n          \n            \n            \tsize += *((U_32 *)annotationAttribute);\t/* length of attribute */", "url": "https://github.com/eclipse-openj9/openj9/pull/8351#discussion_r375243911", "createdAt": "2020-02-05T13:08:11Z", "author": {"login": "DanHeidinga"}, "path": "runtime/util/optinfo.c", "diffHunk": "@@ -672,3 +673,119 @@ getLineNumberForROMClassFromROMMethod(J9JavaVM *vm, J9ROMMethod *romMethod, J9RO\n \treturn number;\n }\n \n+U_32\n+getNumberOfRecordComponents(J9ROMClass *romClass)\n+{\n+\tU_32 *ptr;\n+\n+\tptr = getSRPPtr(J9ROMCLASS_OPTIONALINFO(romClass), romClass->optionalFlags, J9_ROMCLASS_OPTINFO_RECORD_ATTRIBUTE);\n+\n+\tAssert_VMUtil_true(ptr != NULL);\n+\n+\treturn *SRP_PTR_GET(ptr, U_32*);\n+}\n+\n+BOOLEAN\n+recordComponentHasSignature(J9ROMRecordComponentShape* recordComponent)\n+{\n+\treturn (recordComponent->attributeFlags & J9RecordComponentFlagHasGenericSignature);\n+}\n+\n+BOOLEAN\n+recordComponentHasAnnotations(J9ROMRecordComponentShape* recordComponent)\n+{\n+\treturn (recordComponent->attributeFlags & J9RecordComponentFlagHasAnnotations);\n+}\n+\n+BOOLEAN\n+recordComponentHasTypeAnnotations(J9ROMRecordComponentShape* recordComponent)\n+{\n+\treturn (recordComponent->attributeFlags & J9RecordComponentFlagHasTypeAnnotations);\n+}\n+\n+J9UTF8*\n+getRecordComponentGenericSignature(J9ROMRecordComponentShape* recordComponent)\n+{\n+\tif (recordComponentHasSignature(recordComponent)) {\t\n+\t\tU_32* signaturePtr = (U_32*) ((UDATA)recordComponent + sizeof(J9ROMRecordComponentShape));\n+\t\treturn NNSRP_PTR_GET(signaturePtr, J9UTF8*);\n+\t}\n+\treturn NULL;\n+}\n+\n+U_32*\n+getRecordComponentAnnotationData(J9ROMRecordComponentShape* recordComponent)\n+{\n+\tU_32* result = NULL;\n+\tif (recordComponentHasAnnotations(recordComponent)) {\n+\t\t/* calculate offset from start of record component */\n+\t\tUDATA offset = sizeof(J9ROMRecordComponentShape);\n+\t\t/* U_32 for generic signature if it exists */\n+\t\tif (recordComponentHasSignature(recordComponent)) {\n+\t\t\toffset += sizeof(U_32);\n+\t\t}\n+\t\tresult = (U_32*)((UDATA)recordComponent + offset);\n+\t}\n+\treturn result;\n+}\n+\n+static UDATA\n+annotationAttributeSize(U_8* annotationAttribute) {\n+\tAssert_VMUtil_true(((UDATA)annotationAttribute % sizeof(U_32)) == 0);\n+\tUDATA size = sizeof(U_32);\t\t\t\t\t\t\t/* size of length */\n+\tsize += *((U_32 *)annotationAttribute);\t\t\t\t\t\t/* length of attribute */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab79d5f5a953145a9eab5d3d060425ca65e952d3"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMDc2MTgxOnYy", "diffSide": "RIGHT", "path": "runtime/util/optinfo.c", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxMzowOTo0MVrOFl3HLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxMzowOTo0MVrOFl3HLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTI0NDU5MQ==", "bodyText": "These need initial values.  For ptr you can declear and assign the getSRPPtr() result in 1 line.  Set srp to NULL", "url": "https://github.com/eclipse-openj9/openj9/pull/8351#discussion_r375244591", "createdAt": "2020-02-05T13:09:41Z", "author": {"login": "DanHeidinga"}, "path": "runtime/util/optinfo.c", "diffHunk": "@@ -672,3 +673,119 @@ getLineNumberForROMClassFromROMMethod(J9JavaVM *vm, J9ROMMethod *romMethod, J9RO\n \treturn number;\n }\n \n+U_32\n+getNumberOfRecordComponents(J9ROMClass *romClass)\n+{\n+\tU_32 *ptr;\n+\n+\tptr = getSRPPtr(J9ROMCLASS_OPTIONALINFO(romClass), romClass->optionalFlags, J9_ROMCLASS_OPTINFO_RECORD_ATTRIBUTE);\n+\n+\tAssert_VMUtil_true(ptr != NULL);\n+\n+\treturn *SRP_PTR_GET(ptr, U_32*);\n+}\n+\n+BOOLEAN\n+recordComponentHasSignature(J9ROMRecordComponentShape* recordComponent)\n+{\n+\treturn (recordComponent->attributeFlags & J9RecordComponentFlagHasGenericSignature);\n+}\n+\n+BOOLEAN\n+recordComponentHasAnnotations(J9ROMRecordComponentShape* recordComponent)\n+{\n+\treturn (recordComponent->attributeFlags & J9RecordComponentFlagHasAnnotations);\n+}\n+\n+BOOLEAN\n+recordComponentHasTypeAnnotations(J9ROMRecordComponentShape* recordComponent)\n+{\n+\treturn (recordComponent->attributeFlags & J9RecordComponentFlagHasTypeAnnotations);\n+}\n+\n+J9UTF8*\n+getRecordComponentGenericSignature(J9ROMRecordComponentShape* recordComponent)\n+{\n+\tif (recordComponentHasSignature(recordComponent)) {\t\n+\t\tU_32* signaturePtr = (U_32*) ((UDATA)recordComponent + sizeof(J9ROMRecordComponentShape));\n+\t\treturn NNSRP_PTR_GET(signaturePtr, J9UTF8*);\n+\t}\n+\treturn NULL;\n+}\n+\n+U_32*\n+getRecordComponentAnnotationData(J9ROMRecordComponentShape* recordComponent)\n+{\n+\tU_32* result = NULL;\n+\tif (recordComponentHasAnnotations(recordComponent)) {\n+\t\t/* calculate offset from start of record component */\n+\t\tUDATA offset = sizeof(J9ROMRecordComponentShape);\n+\t\t/* U_32 for generic signature if it exists */\n+\t\tif (recordComponentHasSignature(recordComponent)) {\n+\t\t\toffset += sizeof(U_32);\n+\t\t}\n+\t\tresult = (U_32*)((UDATA)recordComponent + offset);\n+\t}\n+\treturn result;\n+}\n+\n+static UDATA\n+annotationAttributeSize(U_8* annotationAttribute) {\n+\tAssert_VMUtil_true(((UDATA)annotationAttribute % sizeof(U_32)) == 0);\n+\tUDATA size = sizeof(U_32);\t\t\t\t\t\t\t/* size of length */\n+\tsize += *((U_32 *)annotationAttribute);\t\t\t\t\t\t/* length of attribute */\n+\treturn ROUND_UP_TO_POWEROF2(size, sizeof(U_32));\t/* padding */\n+} \n+\n+U_32*\n+getRecordComponentTypeAnnotationData(J9ROMRecordComponentShape* recordComponent)\n+{\n+\tU_32* result = NULL;\n+\tif (recordComponentHasTypeAnnotations(recordComponent)) {\n+\t\tif (recordComponentHasAnnotations(recordComponent)) {\n+\t\t\t/* use previous annotation result to calculate offset since size is not known */\n+\t\t\tU_8 *recordComponentAnnotationData = (U_8 *)getRecordComponentAnnotationData(recordComponent);\n+\t\t\tresult = (U_32*)(recordComponentAnnotationData + annotationAttributeSize(recordComponentAnnotationData));\n+\t\t} else {\n+\t\t\tUDATA offset = sizeof(J9ROMRecordComponentShape);\n+\t\t\tif (recordComponentHasSignature(recordComponent)) {\n+\t\t\t\toffset += sizeof(U_32);\n+\t\t\t}\n+\t\t\tresult = (U_32*)((UDATA)recordComponent + offset);\n+\t\t}\n+\t}\n+\treturn result;\n+}\n+\n+J9ROMRecordComponentShape* \n+recordComponentStartDo(J9ROMClass *romClass)\n+{\n+\tU_32 *ptr;\n+\tU_32 *srp;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab79d5f5a953145a9eab5d3d060425ca65e952d3"}, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMDc2MjU2OnYy", "diffSide": "RIGHT", "path": "runtime/util/optinfo.c", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxMzowOTo1NVrOFl3Hng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxMzowOTo1NVrOFl3Hng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTI0NDcwMg==", "bodyText": "missing newline", "url": "https://github.com/eclipse-openj9/openj9/pull/8351#discussion_r375244702", "createdAt": "2020-02-05T13:09:55Z", "author": {"login": "DanHeidinga"}, "path": "runtime/util/optinfo.c", "diffHunk": "@@ -672,3 +673,119 @@ getLineNumberForROMClassFromROMMethod(J9JavaVM *vm, J9ROMMethod *romMethod, J9RO\n \treturn number;\n }\n \n+U_32\n+getNumberOfRecordComponents(J9ROMClass *romClass)\n+{\n+\tU_32 *ptr;\n+\n+\tptr = getSRPPtr(J9ROMCLASS_OPTIONALINFO(romClass), romClass->optionalFlags, J9_ROMCLASS_OPTINFO_RECORD_ATTRIBUTE);\n+\n+\tAssert_VMUtil_true(ptr != NULL);\n+\n+\treturn *SRP_PTR_GET(ptr, U_32*);\n+}\n+\n+BOOLEAN\n+recordComponentHasSignature(J9ROMRecordComponentShape* recordComponent)\n+{\n+\treturn (recordComponent->attributeFlags & J9RecordComponentFlagHasGenericSignature);\n+}\n+\n+BOOLEAN\n+recordComponentHasAnnotations(J9ROMRecordComponentShape* recordComponent)\n+{\n+\treturn (recordComponent->attributeFlags & J9RecordComponentFlagHasAnnotations);\n+}\n+\n+BOOLEAN\n+recordComponentHasTypeAnnotations(J9ROMRecordComponentShape* recordComponent)\n+{\n+\treturn (recordComponent->attributeFlags & J9RecordComponentFlagHasTypeAnnotations);\n+}\n+\n+J9UTF8*\n+getRecordComponentGenericSignature(J9ROMRecordComponentShape* recordComponent)\n+{\n+\tif (recordComponentHasSignature(recordComponent)) {\t\n+\t\tU_32* signaturePtr = (U_32*) ((UDATA)recordComponent + sizeof(J9ROMRecordComponentShape));\n+\t\treturn NNSRP_PTR_GET(signaturePtr, J9UTF8*);\n+\t}\n+\treturn NULL;\n+}\n+\n+U_32*\n+getRecordComponentAnnotationData(J9ROMRecordComponentShape* recordComponent)\n+{\n+\tU_32* result = NULL;\n+\tif (recordComponentHasAnnotations(recordComponent)) {\n+\t\t/* calculate offset from start of record component */\n+\t\tUDATA offset = sizeof(J9ROMRecordComponentShape);\n+\t\t/* U_32 for generic signature if it exists */\n+\t\tif (recordComponentHasSignature(recordComponent)) {\n+\t\t\toffset += sizeof(U_32);\n+\t\t}\n+\t\tresult = (U_32*)((UDATA)recordComponent + offset);\n+\t}\n+\treturn result;\n+}\n+\n+static UDATA\n+annotationAttributeSize(U_8* annotationAttribute) {\n+\tAssert_VMUtil_true(((UDATA)annotationAttribute % sizeof(U_32)) == 0);\n+\tUDATA size = sizeof(U_32);\t\t\t\t\t\t\t/* size of length */\n+\tsize += *((U_32 *)annotationAttribute);\t\t\t\t\t\t/* length of attribute */\n+\treturn ROUND_UP_TO_POWEROF2(size, sizeof(U_32));\t/* padding */\n+} \n+\n+U_32*\n+getRecordComponentTypeAnnotationData(J9ROMRecordComponentShape* recordComponent)\n+{\n+\tU_32* result = NULL;\n+\tif (recordComponentHasTypeAnnotations(recordComponent)) {\n+\t\tif (recordComponentHasAnnotations(recordComponent)) {\n+\t\t\t/* use previous annotation result to calculate offset since size is not known */\n+\t\t\tU_8 *recordComponentAnnotationData = (U_8 *)getRecordComponentAnnotationData(recordComponent);\n+\t\t\tresult = (U_32*)(recordComponentAnnotationData + annotationAttributeSize(recordComponentAnnotationData));\n+\t\t} else {\n+\t\t\tUDATA offset = sizeof(J9ROMRecordComponentShape);\n+\t\t\tif (recordComponentHasSignature(recordComponent)) {\n+\t\t\t\toffset += sizeof(U_32);\n+\t\t\t}\n+\t\t\tresult = (U_32*)((UDATA)recordComponent + offset);\n+\t\t}\n+\t}\n+\treturn result;\n+}\n+\n+J9ROMRecordComponentShape* \n+recordComponentStartDo(J9ROMClass *romClass)\n+{\n+\tU_32 *ptr;\n+\tU_32 *srp;\n+\n+\tptr = getSRPPtr(J9ROMCLASS_OPTIONALINFO(romClass), romClass->optionalFlags, J9_ROMCLASS_OPTINFO_RECORD_ATTRIBUTE);\n+\n+\tAssert_VMUtil_true(ptr != NULL);\n+\n+\t/* first 4 bytes of record entry is the size */\n+\tsrp = SRP_PTR_GET(ptr, U_32*);\n+\tsrp += 1;\n+\treturn (J9ROMRecordComponentShape *)srp;\n+}\n+\n+J9ROMRecordComponentShape* \n+recordComponentNextDo(J9ROMRecordComponentShape* recordComponent)\n+{\n+\tUDATA recordComponentSize = sizeof(J9ROMRecordComponentShape);\n+\n+\tif (recordComponentHasSignature(recordComponent)) {\n+\t\trecordComponentSize += sizeof(U_32);\n+\t}\n+\tif (recordComponentHasAnnotations(recordComponent)) {\n+\t\trecordComponentSize += annotationAttributeSize((U_8*)recordComponent + recordComponentSize);\n+\t}\n+\tif (recordComponentHasTypeAnnotations(recordComponent)) {\n+\t\trecordComponentSize += annotationAttributeSize((U_8*)recordComponent + recordComponentSize);\n+\t}\n+\treturn (J9ROMRecordComponentShape*)((U_8*)recordComponent + recordComponentSize);\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab79d5f5a953145a9eab5d3d060425ca65e952d3"}, "originalPosition": 134}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMDg0NDUwOnYy", "diffSide": "RIGHT", "path": "runtime/jcl/common/reflecthelp.c", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxMzozNjoxNFrOFl35PQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxMzozNjoxNFrOFl35PQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTI1NzQwNQ==", "bodyText": "It's usually faster to check the lengths of both the name and the signature before doing any strcmps", "url": "https://github.com/eclipse-openj9/openj9/pull/8351#discussion_r375257405", "createdAt": "2020-02-05T13:36:14Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/reflecthelp.c", "diffHunk": "@@ -1720,3 +1720,202 @@ getFieldsHelper(JNIEnv *env, jobject cls)\n \tvmFuncs->internalExitVMToJNI(vmThread);\n \treturn result;\n }\n+\n+static j9object_t\n+findRecordComponentAccessorMethod(J9VMThread* currentThread, J9Class* clazz, const U_8* componentName)\n+{\n+\tJ9Method *currentMethod = clazz->ramMethods;\n+\tU_32 romMethodCount = clazz->romClass->romMethodCount;\n+\tJ9Method *resultMethod = NULL;\n+\tj9object_t resultObject = NULL;\n+\t\n+\tfor (; romMethodCount > 0; romMethodCount--) {\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(currentMethod);\n+\t\tconst U_8 *methodName = J9UTF8_DATA(J9ROMMETHOD_NAME(romMethod));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab79d5f5a953145a9eab5d3d060425ca65e952d3"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMDg1OTg2OnYy", "diffSide": "RIGHT", "path": "runtime/jcl/common/reflecthelp.c", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxMzo0MTowMlrOFl4C6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQxNDo0NDowMlrOFmdhiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTI1OTg4Mw==", "bodyText": "Should this throw an exception rather than bring the VM down?  Might be a good test case to make a record that's missing an accessor method and see if / how it's detected", "url": "https://github.com/eclipse-openj9/openj9/pull/8351#discussion_r375259883", "createdAt": "2020-02-05T13:41:02Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/reflecthelp.c", "diffHunk": "@@ -1720,3 +1720,202 @@ getFieldsHelper(JNIEnv *env, jobject cls)\n \tvmFuncs->internalExitVMToJNI(vmThread);\n \treturn result;\n }\n+\n+static j9object_t\n+findRecordComponentAccessorMethod(J9VMThread* currentThread, J9Class* clazz, const U_8* componentName)\n+{\n+\tJ9Method *currentMethod = clazz->ramMethods;\n+\tU_32 romMethodCount = clazz->romClass->romMethodCount;\n+\tJ9Method *resultMethod = NULL;\n+\tj9object_t resultObject = NULL;\n+\t\n+\tfor (; romMethodCount > 0; romMethodCount--) {\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(currentMethod);\n+\t\tconst U_8 *methodName = J9UTF8_DATA(J9ROMMETHOD_NAME(romMethod));\n+\t\tif (0 == strcmp((const char*)methodName, (const char*)componentName)) {\n+\t\t\t/* verify parameters. An accessor will not have any input parameters. */\n+\t\t\tconst U_8 *methodSignature = J9UTF8_DATA(J9ROMMETHOD_SIGNATURE(romMethod));\n+\t\t\tif (('(' == methodSignature[0]) && (')' == methodSignature[1])) {\n+\t\t\t\tresultMethod = currentMethod;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\t\tcurrentMethod += 1;\n+\t}\n+\t/* An accessor method exists for every record component */\n+\tAssert_JCL_true(NULL != resultMethod);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab79d5f5a953145a9eab5d3d060425ca65e952d3"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTg3MzkyOQ==", "bodyText": "looks like the ri allows a record component with no accessor.", "url": "https://github.com/eclipse-openj9/openj9/pull/8351#discussion_r375873929", "createdAt": "2020-02-06T14:44:02Z", "author": {"login": "theresa-m"}, "path": "runtime/jcl/common/reflecthelp.c", "diffHunk": "@@ -1720,3 +1720,202 @@ getFieldsHelper(JNIEnv *env, jobject cls)\n \tvmFuncs->internalExitVMToJNI(vmThread);\n \treturn result;\n }\n+\n+static j9object_t\n+findRecordComponentAccessorMethod(J9VMThread* currentThread, J9Class* clazz, const U_8* componentName)\n+{\n+\tJ9Method *currentMethod = clazz->ramMethods;\n+\tU_32 romMethodCount = clazz->romClass->romMethodCount;\n+\tJ9Method *resultMethod = NULL;\n+\tj9object_t resultObject = NULL;\n+\t\n+\tfor (; romMethodCount > 0; romMethodCount--) {\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(currentMethod);\n+\t\tconst U_8 *methodName = J9UTF8_DATA(J9ROMMETHOD_NAME(romMethod));\n+\t\tif (0 == strcmp((const char*)methodName, (const char*)componentName)) {\n+\t\t\t/* verify parameters. An accessor will not have any input parameters. */\n+\t\t\tconst U_8 *methodSignature = J9UTF8_DATA(J9ROMMETHOD_SIGNATURE(romMethod));\n+\t\t\tif (('(' == methodSignature[0]) && (')' == methodSignature[1])) {\n+\t\t\t\tresultMethod = currentMethod;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\t\tcurrentMethod += 1;\n+\t}\n+\t/* An accessor method exists for every record component */\n+\tAssert_JCL_true(NULL != resultMethod);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTI1OTg4Mw=="}, "originalCommit": {"oid": "ab79d5f5a953145a9eab5d3d060425ca65e952d3"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMTA4NTI4OnYy", "diffSide": "RIGHT", "path": "runtime/jcl/common/reflecthelp.c", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxNDo0MjoxNlrOFl6ONw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxOTowOTozOVrOFmDubg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTI5NTU0Mw==", "bodyText": "Can you doc this function as well?\nIs there a relationship between the accessors and the order they get generated in?  Can we probe the ith method as a first check when looking at the ith component?  Or does javac not generate them in a particular order?", "url": "https://github.com/eclipse-openj9/openj9/pull/8351#discussion_r375295543", "createdAt": "2020-02-05T14:42:16Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/reflecthelp.c", "diffHunk": "@@ -1720,3 +1720,202 @@ getFieldsHelper(JNIEnv *env, jobject cls)\n \tvmFuncs->internalExitVMToJNI(vmThread);\n \treturn result;\n }\n+\n+static j9object_t", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab79d5f5a953145a9eab5d3d060425ca65e952d3"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQ1MTI0Ng==", "bodyText": "yes this can be optimized.", "url": "https://github.com/eclipse-openj9/openj9/pull/8351#discussion_r375451246", "createdAt": "2020-02-05T19:09:39Z", "author": {"login": "theresa-m"}, "path": "runtime/jcl/common/reflecthelp.c", "diffHunk": "@@ -1720,3 +1720,202 @@ getFieldsHelper(JNIEnv *env, jobject cls)\n \tvmFuncs->internalExitVMToJNI(vmThread);\n \treturn result;\n }\n+\n+static j9object_t", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTI5NTU0Mw=="}, "originalCommit": {"oid": "ab79d5f5a953145a9eab5d3d060425ca65e952d3"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMTA5ODQ0OnYy", "diffSide": "RIGHT", "path": "test/functional/Java14andUp/src/org/openj9/test/java/lang/Test_Class.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxNDo0NTo0NVrOFl6Wow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxNDo0NTo0NVrOFl6Wow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTI5NzY5OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                String signature, Class annotationsClass, Class typeAnnotationsClass) throws Throwable {\n          \n          \n            \n                                String signature, Class<?> annotationsClass, Class<?> typeAnnotationsClass) throws Throwable {", "url": "https://github.com/eclipse-openj9/openj9/pull/8351#discussion_r375297699", "createdAt": "2020-02-05T14:45:45Z", "author": {"login": "DanHeidinga"}, "path": "test/functional/Java14andUp/src/org/openj9/test/java/lang/Test_Class.java", "diffHunk": "@@ -0,0 +1,186 @@\n+package org.openj9.test.java.lang;\n+\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+import org.testng.annotations.Test;\n+import org.testng.log4testng.Logger;\n+\n+import org.testng.AssertJUnit;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Inherited;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import java.lang.reflect.AnnotatedType;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.RecordComponent;\n+\n+import org.openj9.test.utilities.RecordClassGenerator;\n+import org.openj9.test.utilities.CustomClassLoader;\n+\n+/**\n+ * Test JCL additions to java.lang.Class from JEP 359: Records preview.\n+ * \n+ * New methods include:\n+ * - boolean isRecord()\n+ * - Object[] getRecordComponents()\n+ */\n+\n+ @Test(groups = { \"level.sanity\" })\n+ public class Test_Class {\n+    /* annotations */\n+    @Retention(RetentionPolicy.RUNTIME)\n+    @Inherited()\n+    @interface TestAnnotation {}\n+\n+    @Retention(RetentionPolicy.RUNTIME)\n+    @Target(ElementType.TYPE_USE)\n+    @interface TestTypeAnnotation {}\n+\n+    /* Test classes and records */\n+    class TestClass {}\n+    record TestRecordEmpty() {}\n+    record TestRecordPrim(int x, long y) {}\n+    record TestRecordObj(String x, Double y, Object[] z) {}\n+    record TestRecordWithAnnotation(@TestAnnotation int x) {}\n+    record TestRecordWithTypeAnnotation(@TestTypeAnnotation int x) {}\n+    record TestRecordWithMultipleAnnotations(@TestAnnotation @TestTypeAnnotation int x) {}\n+\n+    /* constants for asm tests */\n+    String name = \"TestRecordComponents\";\n+    String rcName = \"x\";\n+    String rcType = \"I\";\n+    String rcSignature = \"I\";\n+\n+    @Test\n+    public void test_isRecord() {\n+        AssertJUnit.assertTrue(\"TestRecordEmpty is a record\", TestRecordEmpty.class.isRecord());\n+        AssertJUnit.assertTrue(\"TestClass is not a record\", !TestClass.class.isRecord());\n+    }\n+\n+    @Test\n+    public void test_getRecordComponent_nonRecordClass() throws Throwable {\n+        RecordComponent[] rc = TestClass.class.getRecordComponents();\n+        AssertJUnit.assertNull(rc);\n+    }\n+\n+    @Test\n+    public void test_getRecordComponent_recordWithNoComponents() throws Throwable {\n+        /* record with no components */\n+        RecordComponent[] rc1 = TestRecordEmpty.class.getRecordComponents();\n+        AssertJUnit.assertEquals(0, rc1.length);\n+    }\n+\n+    @Test\n+    public void test_getRecordComponent_noOptionalAttributes() throws Throwable {\n+        /* record with primitive type components */\n+        RecordComponent[] rc2 = TestRecordPrim.class.getRecordComponents();\n+        AssertJUnit.assertEquals(2, rc2.length);\n+        test_RecordComponentContents_noAttributes(rc2[0], TestRecordPrim.class, \"x\", int.class);\n+        test_RecordComponentContents_noAttributes(rc2[1], TestRecordPrim.class, \"y\", long.class);\n+\n+        /* record with Object components */\n+        RecordComponent[] rc3 = TestRecordObj.class.getRecordComponents();\n+        AssertJUnit.assertEquals(3, rc3.length);\n+        test_RecordComponentContents_noAttributes(rc3[0], TestRecordObj.class, \"x\", String.class);\n+        test_RecordComponentContents_noAttributes(rc3[1], TestRecordObj.class, \"y\", Double.class);\n+        test_RecordComponentContents_noAttributes(rc3[2], TestRecordObj.class, \"z\", Object[].class);\n+    }\n+\n+    @Test\n+    public void test_getRecordComponent_signatureAttribute() throws Throwable {\n+        CustomClassLoader classloader = new CustomClassLoader();\n+        byte[] bytes = RecordClassGenerator.generateRecordAttributes(name, rcName, rcType, rcSignature);\n+        Class<?> clazz = classloader.getClass(name, bytes);\n+\n+        RecordComponent[] rc = clazz.getRecordComponents();\n+        AssertJUnit.assertEquals(1, rc.length);\n+        test_RecordComponentContents(rc[0], clazz, rcName, int.class, rcSignature, null, null);\n+    }\n+\n+    @Test\n+    public void test_getRecordComponent_annotationsAttribute() throws Throwable {\n+        RecordComponent[] rc = TestRecordWithAnnotation.class.getRecordComponents();\n+        AssertJUnit.assertEquals(1, rc.length);\n+        test_RecordComponentContents(rc[0], TestRecordWithAnnotation.class, rcName, int.class, null, TestAnnotation.class, null);\n+    }\n+\n+    @Test\n+    public void test_getRecordComponent_typeAnnotationsAttribute() throws Throwable {\n+        RecordComponent[] rc = TestRecordWithTypeAnnotation.class.getRecordComponents();\n+        AssertJUnit.assertEquals(1, rc.length);\n+        test_RecordComponentContents(rc[0], TestRecordWithTypeAnnotation.class, rcName, int.class, null, null, TestTypeAnnotation.class);\n+    }\n+\n+    @Test\n+    public void test_getRecordComponent_multipleAttributes() throws Throwable {\n+        RecordComponent[] rc = TestRecordWithMultipleAnnotations.class.getRecordComponents();\n+        AssertJUnit.assertEquals(1, rc.length);\n+        test_RecordComponentContents(rc[0], TestRecordWithMultipleAnnotations.class, rcName, int.class, null, TestAnnotation.class, TestTypeAnnotation.class);\n+    }\n+\n+    private void test_RecordComponentContents_noAttributes(RecordComponent rc, Class<?> declaringRecord, String name, \n+                    Class<?> type) throws Throwable {\n+        test_RecordComponentContents(rc, declaringRecord, name, type, null, null, null);\n+    }\n+\n+    /* test all fields that are set from record_component_info attribute */\n+    private void test_RecordComponentContents(RecordComponent rc, Class<?> declaringRecord, String name, Class<?> type,\n+                    String signature, Class annotationsClass, Class typeAnnotationsClass) throws Throwable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab79d5f5a953145a9eab5d3d060425ca65e952d3"}, "originalPosition": 151}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyOTQyMTU5OnYy", "diffSide": "RIGHT", "path": "runtime/jcl/common/reflecthelp.c", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMTowNTozOFrOFnKR3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wOFQwMDo1NDozMlrOFnOKjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYwNzE5OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t/* The compiler should generate each of the record components in order as the final recordComponentCount methods in the record class. \n          \n          \n            \n            \t/* javac typically generates each of the record components in order as the final recordComponentCount methods in the record class. \n          \n      \n    \n    \n  \n\nIs this true even when there are other user methods in the record?", "url": "https://github.com/eclipse-openj9/openj9/pull/8351#discussion_r376607198", "createdAt": "2020-02-07T21:05:38Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/reflecthelp.c", "diffHunk": "@@ -1720,3 +1720,225 @@ getFieldsHelper(JNIEnv *env, jobject cls)\n \tvmFuncs->internalExitVMToJNI(vmThread);\n \treturn result;\n }\n+\n+/* Determine whether currentMethod is the accessor method for a record component with name componentName.\n+ * an accessor method will have the same name as the component and take zero parameters.\n+ */\n+static U_8\n+isRecordComponentAccessorMethodMatch(J9Method *currentMethod, const char* componentName) {\n+\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(currentMethod);\n+\tJ9UTF8 *methodNameUtf8 = J9ROMMETHOD_NAME(romMethod);\n+\tU_16 methodLength = J9UTF8_LENGTH(methodNameUtf8);\n+\tconst U_8 *methodName = J9UTF8_DATA(methodNameUtf8);\n+\tif ((methodLength == strlen(componentName)) \n+\t\t&& (0 == strcmp((const char*)methodName, componentName))\n+\t) {\n+\t\t/* verify parameters. An accessor will not have any input parameters. */\n+\t\tJ9UTF8 *methodSignatureUtf8 = J9ROMMETHOD_SIGNATURE(romMethod);\n+\t\tconst U_8 *methodSignature = J9UTF8_DATA(methodSignatureUtf8);\n+\t\tif ((J9UTF8_LENGTH(methodSignatureUtf8) >= 2)\n+\t\t\t&& ('(' == methodSignature[0]) && (')' == methodSignature[1])\n+\t\t) {\n+\t\t\treturn TRUE;\n+\t\t}\n+\t}\n+\treturn FALSE;\n+}\n+\n+/* Find the accessor method for a record component with name componantName. \n+ * recordComponentSlot slot for current record component will be used to optimize search\n+ */\n+static J9Method*\n+findRecordComponentAccessorMethod(J9VMThread* currentThread, J9Class* clazz, U_32 recordComponentSlot, U_32 recordComponentCount, const char* componentName)\n+{\n+\tJ9Method *currentMethod = clazz->ramMethods;\n+\tU_32 romMethodCount = clazz->romClass->romMethodCount;\n+\tJ9Method *resultMethod = NULL;\n+\n+\t/* The compiler should generate each of the record components in order as the final recordComponentCount methods in the record class. ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "951d4e9955f51183de08fea5cccedd4631f301ef"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY3MDg2Mw==", "bodyText": "yes. Custom methods are generated first, then the generated methods (toString, hashCode, equals), then the accessor methods.", "url": "https://github.com/eclipse-openj9/openj9/pull/8351#discussion_r376670863", "createdAt": "2020-02-08T00:54:32Z", "author": {"login": "theresa-m"}, "path": "runtime/jcl/common/reflecthelp.c", "diffHunk": "@@ -1720,3 +1720,225 @@ getFieldsHelper(JNIEnv *env, jobject cls)\n \tvmFuncs->internalExitVMToJNI(vmThread);\n \treturn result;\n }\n+\n+/* Determine whether currentMethod is the accessor method for a record component with name componentName.\n+ * an accessor method will have the same name as the component and take zero parameters.\n+ */\n+static U_8\n+isRecordComponentAccessorMethodMatch(J9Method *currentMethod, const char* componentName) {\n+\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(currentMethod);\n+\tJ9UTF8 *methodNameUtf8 = J9ROMMETHOD_NAME(romMethod);\n+\tU_16 methodLength = J9UTF8_LENGTH(methodNameUtf8);\n+\tconst U_8 *methodName = J9UTF8_DATA(methodNameUtf8);\n+\tif ((methodLength == strlen(componentName)) \n+\t\t&& (0 == strcmp((const char*)methodName, componentName))\n+\t) {\n+\t\t/* verify parameters. An accessor will not have any input parameters. */\n+\t\tJ9UTF8 *methodSignatureUtf8 = J9ROMMETHOD_SIGNATURE(romMethod);\n+\t\tconst U_8 *methodSignature = J9UTF8_DATA(methodSignatureUtf8);\n+\t\tif ((J9UTF8_LENGTH(methodSignatureUtf8) >= 2)\n+\t\t\t&& ('(' == methodSignature[0]) && (')' == methodSignature[1])\n+\t\t) {\n+\t\t\treturn TRUE;\n+\t\t}\n+\t}\n+\treturn FALSE;\n+}\n+\n+/* Find the accessor method for a record component with name componantName. \n+ * recordComponentSlot slot for current record component will be used to optimize search\n+ */\n+static J9Method*\n+findRecordComponentAccessorMethod(J9VMThread* currentThread, J9Class* clazz, U_32 recordComponentSlot, U_32 recordComponentCount, const char* componentName)\n+{\n+\tJ9Method *currentMethod = clazz->ramMethods;\n+\tU_32 romMethodCount = clazz->romClass->romMethodCount;\n+\tJ9Method *resultMethod = NULL;\n+\n+\t/* The compiler should generate each of the record components in order as the final recordComponentCount methods in the record class. ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYwNzE5OA=="}, "originalCommit": {"oid": "951d4e9955f51183de08fea5cccedd4631f301ef"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyOTQyNDQ5OnYy", "diffSide": "RIGHT", "path": "runtime/jcl/common/reflecthelp.c", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMTowNjo0NVrOFnKToQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMTowNjo0NVrOFnKToQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYwNzY0OQ==", "bodyText": "recordComponentSlot --> componentIndex?", "url": "https://github.com/eclipse-openj9/openj9/pull/8351#discussion_r376607649", "createdAt": "2020-02-07T21:06:45Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/reflecthelp.c", "diffHunk": "@@ -1720,3 +1720,225 @@ getFieldsHelper(JNIEnv *env, jobject cls)\n \tvmFuncs->internalExitVMToJNI(vmThread);\n \treturn result;\n }\n+\n+/* Determine whether currentMethod is the accessor method for a record component with name componentName.\n+ * an accessor method will have the same name as the component and take zero parameters.\n+ */\n+static U_8\n+isRecordComponentAccessorMethodMatch(J9Method *currentMethod, const char* componentName) {\n+\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(currentMethod);\n+\tJ9UTF8 *methodNameUtf8 = J9ROMMETHOD_NAME(romMethod);\n+\tU_16 methodLength = J9UTF8_LENGTH(methodNameUtf8);\n+\tconst U_8 *methodName = J9UTF8_DATA(methodNameUtf8);\n+\tif ((methodLength == strlen(componentName)) \n+\t\t&& (0 == strcmp((const char*)methodName, componentName))\n+\t) {\n+\t\t/* verify parameters. An accessor will not have any input parameters. */\n+\t\tJ9UTF8 *methodSignatureUtf8 = J9ROMMETHOD_SIGNATURE(romMethod);\n+\t\tconst U_8 *methodSignature = J9UTF8_DATA(methodSignatureUtf8);\n+\t\tif ((J9UTF8_LENGTH(methodSignatureUtf8) >= 2)\n+\t\t\t&& ('(' == methodSignature[0]) && (')' == methodSignature[1])\n+\t\t) {\n+\t\t\treturn TRUE;\n+\t\t}\n+\t}\n+\treturn FALSE;\n+}\n+\n+/* Find the accessor method for a record component with name componantName. \n+ * recordComponentSlot slot for current record component will be used to optimize search\n+ */\n+static J9Method*\n+findRecordComponentAccessorMethod(J9VMThread* currentThread, J9Class* clazz, U_32 recordComponentSlot, U_32 recordComponentCount, const char* componentName)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "951d4e9955f51183de08fea5cccedd4631f301ef"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyOTQyNjYyOnYy", "diffSide": "RIGHT", "path": "runtime/jcl/common/reflecthelp.c", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMTowNzozNVrOFnKU6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMTowNzozNVrOFnKU6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYwNzk3Nw==", "bodyText": "Why make this a U_16 when the other values are U_32?", "url": "https://github.com/eclipse-openj9/openj9/pull/8351#discussion_r376607977", "createdAt": "2020-02-07T21:07:35Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/reflecthelp.c", "diffHunk": "@@ -1720,3 +1720,225 @@ getFieldsHelper(JNIEnv *env, jobject cls)\n \tvmFuncs->internalExitVMToJNI(vmThread);\n \treturn result;\n }\n+\n+/* Determine whether currentMethod is the accessor method for a record component with name componentName.\n+ * an accessor method will have the same name as the component and take zero parameters.\n+ */\n+static U_8\n+isRecordComponentAccessorMethodMatch(J9Method *currentMethod, const char* componentName) {\n+\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(currentMethod);\n+\tJ9UTF8 *methodNameUtf8 = J9ROMMETHOD_NAME(romMethod);\n+\tU_16 methodLength = J9UTF8_LENGTH(methodNameUtf8);\n+\tconst U_8 *methodName = J9UTF8_DATA(methodNameUtf8);\n+\tif ((methodLength == strlen(componentName)) \n+\t\t&& (0 == strcmp((const char*)methodName, componentName))\n+\t) {\n+\t\t/* verify parameters. An accessor will not have any input parameters. */\n+\t\tJ9UTF8 *methodSignatureUtf8 = J9ROMMETHOD_SIGNATURE(romMethod);\n+\t\tconst U_8 *methodSignature = J9UTF8_DATA(methodSignatureUtf8);\n+\t\tif ((J9UTF8_LENGTH(methodSignatureUtf8) >= 2)\n+\t\t\t&& ('(' == methodSignature[0]) && (')' == methodSignature[1])\n+\t\t) {\n+\t\t\treturn TRUE;\n+\t\t}\n+\t}\n+\treturn FALSE;\n+}\n+\n+/* Find the accessor method for a record component with name componantName. \n+ * recordComponentSlot slot for current record component will be used to optimize search\n+ */\n+static J9Method*\n+findRecordComponentAccessorMethod(J9VMThread* currentThread, J9Class* clazz, U_32 recordComponentSlot, U_32 recordComponentCount, const char* componentName)\n+{\n+\tJ9Method *currentMethod = clazz->ramMethods;\n+\tU_32 romMethodCount = clazz->romClass->romMethodCount;\n+\tJ9Method *resultMethod = NULL;\n+\n+\t/* The compiler should generate each of the record components in order as the final recordComponentCount methods in the record class. \n+\t* Probe the ramMethods array for a match at this point first before iterating through the entire method list. */\n+\tU_16 testSlot = romMethodCount - recordComponentCount + recordComponentSlot;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "951d4e9955f51183de08fea5cccedd4631f301ef"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyOTQzOTU5OnYy", "diffSide": "RIGHT", "path": "runtime/jcl/common/reflecthelp.c", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMToxMzozMlrOFnKdLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wOFQwMTowMDoyMlrOFnONrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYxMDA5NA==", "bodyText": "This doesn't look correct as it doesn't handle the return types of the signature.\nFor a Record like:\n record Foo(int x)\nhaving the following methods:\nx()I\nx()Ljava/lang/Integer;\nx()LFoo;\nonly the first is an accessor.\nThe current code would accept any of the 3 as the accessor method", "url": "https://github.com/eclipse-openj9/openj9/pull/8351#discussion_r376610094", "createdAt": "2020-02-07T21:13:32Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/reflecthelp.c", "diffHunk": "@@ -1720,3 +1720,225 @@ getFieldsHelper(JNIEnv *env, jobject cls)\n \tvmFuncs->internalExitVMToJNI(vmThread);\n \treturn result;\n }\n+\n+/* Determine whether currentMethod is the accessor method for a record component with name componentName.\n+ * an accessor method will have the same name as the component and take zero parameters.\n+ */\n+static U_8\n+isRecordComponentAccessorMethodMatch(J9Method *currentMethod, const char* componentName) {\n+\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(currentMethod);\n+\tJ9UTF8 *methodNameUtf8 = J9ROMMETHOD_NAME(romMethod);\n+\tU_16 methodLength = J9UTF8_LENGTH(methodNameUtf8);\n+\tconst U_8 *methodName = J9UTF8_DATA(methodNameUtf8);\n+\tif ((methodLength == strlen(componentName)) \n+\t\t&& (0 == strcmp((const char*)methodName, componentName))\n+\t) {\n+\t\t/* verify parameters. An accessor will not have any input parameters. */\n+\t\tJ9UTF8 *methodSignatureUtf8 = J9ROMMETHOD_SIGNATURE(romMethod);\n+\t\tconst U_8 *methodSignature = J9UTF8_DATA(methodSignatureUtf8);\n+\t\tif ((J9UTF8_LENGTH(methodSignatureUtf8) >= 2)\n+\t\t\t&& ('(' == methodSignature[0]) && (')' == methodSignature[1])\n+\t\t) {\n+\t\t\treturn TRUE;\n+\t\t}\n+\t}\n+\treturn FALSE;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "951d4e9955f51183de08fea5cccedd4631f301ef"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY3MTY2MQ==", "bodyText": "I left it without checking the return type because javac will generate an error that accessor methods with the wrong return type are invalid so it should not be possible to generate the other options normally.\nI'll try it out with ASM as well and likely it won't work for that.", "url": "https://github.com/eclipse-openj9/openj9/pull/8351#discussion_r376671661", "createdAt": "2020-02-08T01:00:22Z", "author": {"login": "theresa-m"}, "path": "runtime/jcl/common/reflecthelp.c", "diffHunk": "@@ -1720,3 +1720,225 @@ getFieldsHelper(JNIEnv *env, jobject cls)\n \tvmFuncs->internalExitVMToJNI(vmThread);\n \treturn result;\n }\n+\n+/* Determine whether currentMethod is the accessor method for a record component with name componentName.\n+ * an accessor method will have the same name as the component and take zero parameters.\n+ */\n+static U_8\n+isRecordComponentAccessorMethodMatch(J9Method *currentMethod, const char* componentName) {\n+\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(currentMethod);\n+\tJ9UTF8 *methodNameUtf8 = J9ROMMETHOD_NAME(romMethod);\n+\tU_16 methodLength = J9UTF8_LENGTH(methodNameUtf8);\n+\tconst U_8 *methodName = J9UTF8_DATA(methodNameUtf8);\n+\tif ((methodLength == strlen(componentName)) \n+\t\t&& (0 == strcmp((const char*)methodName, componentName))\n+\t) {\n+\t\t/* verify parameters. An accessor will not have any input parameters. */\n+\t\tJ9UTF8 *methodSignatureUtf8 = J9ROMMETHOD_SIGNATURE(romMethod);\n+\t\tconst U_8 *methodSignature = J9UTF8_DATA(methodSignatureUtf8);\n+\t\tif ((J9UTF8_LENGTH(methodSignatureUtf8) >= 2)\n+\t\t\t&& ('(' == methodSignature[0]) && (')' == methodSignature[1])\n+\t\t) {\n+\t\t\treturn TRUE;\n+\t\t}\n+\t}\n+\treturn FALSE;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYxMDA5NA=="}, "originalCommit": {"oid": "951d4e9955f51183de08fea5cccedd4631f301ef"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NDIwNTMxOnYy", "diffSide": "RIGHT", "path": "runtime/oti/vmconstantpool.xml", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxNDoxNDo0NlrOFpVUNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxNDoxNDo0NlrOFpVUNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODg4NTE3Mg==", "bodyText": "This needs a a versions=\"14-\" tag as well as the class won't exist on earlier releases", "url": "https://github.com/eclipse-openj9/openj9/pull/8351#discussion_r378885172", "createdAt": "2020-02-13T14:14:46Z", "author": {"login": "DanHeidinga"}, "path": "runtime/oti/vmconstantpool.xml", "diffHunk": "@@ -62,6 +62,7 @@ SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-excepti\n \t<classref name=\"java/lang/LayerInstantiationException\" flags=\"opt_module\" versions=\"9-\"/>\n \t<classref name=\"java/lang/reflect/Method\" flags=\"opt_reflect\"/>\n \t<classref name=\"java/lang/reflect/Field\" flags=\"opt_reflect\"/>\n+\t<classref name=\"java/lang/reflect/RecordComponent\" flags=\"opt_reflect\"/>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b272983b8338ffc97d846b4130b4b2da3523cad1"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NDIxNTA0OnYy", "diffSide": "RIGHT", "path": "runtime/oti/vmconstantpool.xml", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxNDoxNzoxN1rOFpVaJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxNDoxNzoxN1rOFpVaJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODg4NjY5NA==", "bodyText": "These all need version tags as well", "url": "https://github.com/eclipse-openj9/openj9/pull/8351#discussion_r378886694", "createdAt": "2020-02-13T14:17:17Z", "author": {"login": "DanHeidinga"}, "path": "runtime/oti/vmconstantpool.xml", "diffHunk": "@@ -239,6 +240,15 @@ SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-excepti\n \t<fieldref class=\"java/lang/reflect/Constructor\" name=\"declaringClass\" signature=\"Ljava/lang/Class;\">\n \t\t<fieldalias name=\"clazz\"/>\n \t</fieldref>\n+\t<fieldref class=\"java/lang/reflect/RecordComponent\" name=\"declaringClass\" signature=\"Ljava/lang/Class;\">", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b272983b8338ffc97d846b4130b4b2da3523cad1"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NDIxNjM2OnYy", "diffSide": "RIGHT", "path": "runtime/oti/vmconstantpool.xml", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxNDoxNzo0MFrOFpVbDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxNToxNjozN1rOFpXvFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODg4NjkyNg==", "bodyText": "why the fieldalias?  What does this give over using the existing name?", "url": "https://github.com/eclipse-openj9/openj9/pull/8351#discussion_r378886926", "createdAt": "2020-02-13T14:17:40Z", "author": {"login": "DanHeidinga"}, "path": "runtime/oti/vmconstantpool.xml", "diffHunk": "@@ -239,6 +240,15 @@ SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-excepti\n \t<fieldref class=\"java/lang/reflect/Constructor\" name=\"declaringClass\" signature=\"Ljava/lang/Class;\">\n \t\t<fieldalias name=\"clazz\"/>\n \t</fieldref>\n+\t<fieldref class=\"java/lang/reflect/RecordComponent\" name=\"declaringClass\" signature=\"Ljava/lang/Class;\">\n+\t\t<fieldalias name=\"clazz\"/>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b272983b8338ffc97d846b4130b4b2da3523cad1"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODkxOTE2Mg==", "bodyText": "following convention from  the declaringClass entries for Constructor/Field/Method classes.", "url": "https://github.com/eclipse-openj9/openj9/pull/8351#discussion_r378919162", "createdAt": "2020-02-13T15:08:05Z", "author": {"login": "theresa-m"}, "path": "runtime/oti/vmconstantpool.xml", "diffHunk": "@@ -239,6 +240,15 @@ SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-excepti\n \t<fieldref class=\"java/lang/reflect/Constructor\" name=\"declaringClass\" signature=\"Ljava/lang/Class;\">\n \t\t<fieldalias name=\"clazz\"/>\n \t</fieldref>\n+\t<fieldref class=\"java/lang/reflect/RecordComponent\" name=\"declaringClass\" signature=\"Ljava/lang/Class;\">\n+\t\t<fieldalias name=\"clazz\"/>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODg4NjkyNg=="}, "originalCommit": {"oid": "b272983b8338ffc97d846b4130b4b2da3523cad1"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODkyNDgyMQ==", "bodyText": "That may be a historical hold-over from when we had a separate implementation of Reflection.  I'd prefer not to add aliases unless they're required.", "url": "https://github.com/eclipse-openj9/openj9/pull/8351#discussion_r378924821", "createdAt": "2020-02-13T15:16:37Z", "author": {"login": "DanHeidinga"}, "path": "runtime/oti/vmconstantpool.xml", "diffHunk": "@@ -239,6 +240,15 @@ SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-excepti\n \t<fieldref class=\"java/lang/reflect/Constructor\" name=\"declaringClass\" signature=\"Ljava/lang/Class;\">\n \t\t<fieldalias name=\"clazz\"/>\n \t</fieldref>\n+\t<fieldref class=\"java/lang/reflect/RecordComponent\" name=\"declaringClass\" signature=\"Ljava/lang/Class;\">\n+\t\t<fieldalias name=\"clazz\"/>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODg4NjkyNg=="}, "originalCommit": {"oid": "b272983b8338ffc97d846b4130b4b2da3523cad1"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NDI0NDMxOnYy", "diffSide": "RIGHT", "path": "runtime/jcl/common/reflecthelp.c", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxNDoyNDo1OVrOFpVskA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxNDoyNDo1OVrOFpVskA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODg5MTQwOA==", "bodyText": "This would be more efficient if the componentName length was passed in as well as there is a potential for loop calling this and it would save doing strlen over and over again", "url": "https://github.com/eclipse-openj9/openj9/pull/8351#discussion_r378891408", "createdAt": "2020-02-13T14:24:59Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/reflecthelp.c", "diffHunk": "@@ -1720,3 +1720,233 @@ getFieldsHelper(JNIEnv *env, jobject cls)\n \tvmFuncs->internalExitVMToJNI(vmThread);\n \treturn result;\n }\n+\n+/* Determine whether currentMethod is the accessor method for a record component with name componentName.\n+ * an accessor method will have the same name as the component and take zero parameters.\n+ */\n+static U_8\n+isRecordComponentAccessorMethodMatch(J9Method *currentMethod, const char* componentName, const char* componentSignature) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b272983b8338ffc97d846b4130b4b2da3523cad1"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NDI4MDYxOnYy", "diffSide": "RIGHT", "path": "runtime/jcl/common/reflecthelp.c", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxNDozMzoyOFrOFpWCLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxNDozMzoyOFrOFpWCLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODg5Njk0MQ==", "bodyText": "We've seen when doing other name/sig searches that it is more efficient to check the lengths first before doing any strcmps.  Something like this (not tested) does the length checks up front and has them passed in as this is called in a loop:\nstatic U_8\nisRecordComponentAccessorMethodMatch(J9Method *currentMethod, const char* componentName, const U_16 nameLength, const char* componentSignature, const U_16 sigLength) {\n        J9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(currentMethod);\n\tJ9UTF8 *methodNameUtf8 = J9ROMMETHOD_NAME(romMethod);\n\tU_16 methodLength = J9UTF8_LENGTH(methodNameUtf8);\n\tconst U_8 *methodName = J9UTF8_DATA(methodNameUtf8);\n\n\t/* verify parameters. An accessor will not have any input parameters. */\n\tJ9UTF8 *methodSignatureUtf8 = J9ROMMETHOD_SIGNATURE(romMethod);\n\tconst U_8 *methodSignature = J9UTF8_DATA(methodSignatureUtf8);\n\tU_16 methodSignatureLength = J9UTF8_LENGTH(methodSignatureUtf8);\n\n\t/* Compare name and signature including the `()` for the accessor */\n\tif ((methodLength == nameLength) \n\t&& (methodSignatureLength == (sigLength + 2))\n\t) {\n\t\tif (0 == strcmp((const char*)methodName, componentName)) {\n \t\t\tif (0 == strncmp((const char*)methodSignature + 2, componentSignature, methodSignatureLength - 2)) {\n\t\t\t\treturn TRUE;\n\t\t\t}\n\t\t}\n\t}\n\treturn FALSE;\n}", "url": "https://github.com/eclipse-openj9/openj9/pull/8351#discussion_r378896941", "createdAt": "2020-02-13T14:33:28Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/reflecthelp.c", "diffHunk": "@@ -1720,3 +1720,233 @@ getFieldsHelper(JNIEnv *env, jobject cls)\n \tvmFuncs->internalExitVMToJNI(vmThread);\n \treturn result;\n }\n+\n+/* Determine whether currentMethod is the accessor method for a record component with name componentName.\n+ * an accessor method will have the same name as the component and take zero parameters.\n+ */\n+static U_8\n+isRecordComponentAccessorMethodMatch(J9Method *currentMethod, const char* componentName, const char* componentSignature) {\n+\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(currentMethod);\n+\tJ9UTF8 *methodNameUtf8 = J9ROMMETHOD_NAME(romMethod);\n+\tU_16 methodLength = J9UTF8_LENGTH(methodNameUtf8);\n+\tconst U_8 *methodName = J9UTF8_DATA(methodNameUtf8);\n+\tif ((methodLength == strlen(componentName)) \n+\t\t&& (0 == strcmp((const char*)methodName, componentName))\n+\t) {\n+\t\t/* verify parameters. An accessor will not have any input parameters. */\n+\t\tJ9UTF8 *methodSignatureUtf8 = J9ROMMETHOD_SIGNATURE(romMethod);\n+\t\tconst U_8 *methodSignature = J9UTF8_DATA(methodSignatureUtf8);\n+\t\tU_16 methodSignatureLength = J9UTF8_LENGTH(methodSignatureUtf8);\n+\n+\t\tif ((methodSignatureLength >= 2)\n+\t\t\t&& ('(' == methodSignature[0]) && (')' == methodSignature[1])\n+\t\t\t&& (((methodSignatureLength == 3) && componentSignature[2] == methodSignature[2])\n+\t\t\t\t|| (0 == strncmp((const char*)methodSignature + 2, componentSignature, methodSignatureLength - 2))\n+\t\t\t)\n+\t\t) {\n+\t\t\treturn TRUE;\n+\t\t}\n+\t}\n+\treturn FALSE;\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b272983b8338ffc97d846b4130b4b2da3523cad1"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NDI4NTQzOnYy", "diffSide": "RIGHT", "path": "runtime/jcl/common/reflecthelp.c", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxNDozNDo0OVrOFpWFOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxNDozNDo0OVrOFpWFOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODg5NzcyMw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tJ9Class *clazz;\n          \n          \n            \n            \tJ9Class *clazz = NULL;", "url": "https://github.com/eclipse-openj9/openj9/pull/8351#discussion_r378897723", "createdAt": "2020-02-13T14:34:49Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/reflecthelp.c", "diffHunk": "@@ -1720,3 +1720,233 @@ getFieldsHelper(JNIEnv *env, jobject cls)\n \tvmFuncs->internalExitVMToJNI(vmThread);\n \treturn result;\n }\n+\n+/* Determine whether currentMethod is the accessor method for a record component with name componentName.\n+ * an accessor method will have the same name as the component and take zero parameters.\n+ */\n+static U_8\n+isRecordComponentAccessorMethodMatch(J9Method *currentMethod, const char* componentName, const char* componentSignature) {\n+\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(currentMethod);\n+\tJ9UTF8 *methodNameUtf8 = J9ROMMETHOD_NAME(romMethod);\n+\tU_16 methodLength = J9UTF8_LENGTH(methodNameUtf8);\n+\tconst U_8 *methodName = J9UTF8_DATA(methodNameUtf8);\n+\tif ((methodLength == strlen(componentName)) \n+\t\t&& (0 == strcmp((const char*)methodName, componentName))\n+\t) {\n+\t\t/* verify parameters. An accessor will not have any input parameters. */\n+\t\tJ9UTF8 *methodSignatureUtf8 = J9ROMMETHOD_SIGNATURE(romMethod);\n+\t\tconst U_8 *methodSignature = J9UTF8_DATA(methodSignatureUtf8);\n+\t\tU_16 methodSignatureLength = J9UTF8_LENGTH(methodSignatureUtf8);\n+\n+\t\tif ((methodSignatureLength >= 2)\n+\t\t\t&& ('(' == methodSignature[0]) && (')' == methodSignature[1])\n+\t\t\t&& (((methodSignatureLength == 3) && componentSignature[2] == methodSignature[2])\n+\t\t\t\t|| (0 == strncmp((const char*)methodSignature + 2, componentSignature, methodSignatureLength - 2))\n+\t\t\t)\n+\t\t) {\n+\t\t\treturn TRUE;\n+\t\t}\n+\t}\n+\treturn FALSE;\n+}\n+\n+/* Find the accessor method for a record component with name componantName. \n+ * componentIndex slot for current record component will be used to optimize search\n+ */\n+static J9Method*\n+findRecordComponentAccessorMethod(J9VMThread* currentThread, J9Class* clazz, J9ROMRecordComponentShape* recordComponent, U_32 componentIndex, U_32 recordComponentCount)\n+{\n+\tJ9Method *currentMethod = clazz->ramMethods;\n+\tU_32 romMethodCount = clazz->romClass->romMethodCount;\n+\tJ9Method *resultMethod = NULL;\n+\n+\tconst char* componentName = (const char*)J9UTF8_DATA(J9ROMRECORDCOMPONENTSHAPE_NAME(recordComponent));\n+\tconst char* componentSignature = (const char*)J9UTF8_DATA(J9ROMRECORDCOMPONENTSHAPE_SIGNATURE(recordComponent));\n+\n+\t/* javac typically generates each of the record components in order as the final recordComponentCount methods in the record class. \n+\t* Probe the ramMethods array for a match at this point first before iterating through the entire method list. */\n+\tU_32 testSlot = romMethodCount - recordComponentCount + componentIndex;\n+\tif ((testSlot < romMethodCount) && isRecordComponentAccessorMethodMatch(currentMethod + testSlot, componentName, componentSignature)) {\n+\t\tresultMethod = currentMethod + testSlot;\n+\t} else {\n+\t\tfor (; romMethodCount > 0; romMethodCount--) {\n+\t\t\tif (isRecordComponentAccessorMethodMatch(currentMethod, componentName, componentSignature)) {\n+\t\t\t\tresultMethod = currentMethod;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tcurrentMethod += 1;\n+\t\t}\n+\t}\n+\n+\treturn resultMethod;\n+}\n+\n+/* Creates an array of RecordComponents for the given class and sets the following fields:\n+ * - Class<?> clazz \n+ * - String name\n+ * - Class<?> type\n+ * - Method accessor\n+ * - String signature\n+ * - byte[] annotations\n+ * - byte[] typeAnnotations\n+ * - RecordComponent root (currently always null)\n+ */\n+jarray\n+getRecordComponentsHelper(JNIEnv *env, jobject cls)\n+{\n+\tJ9VMThread *vmThread = (J9VMThread *)env;\n+\tJ9JavaVM *vm = vmThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tJ9MemoryManagerFunctions *mmFuncs = vm->memoryManagerFunctions;\n+\tjarray result = NULL;\n+\tJ9Class *recordComponentClass = NULL;\n+\tJ9Class *recordComponentArrayClass = NULL;\n+\tU_32 recordComponentCount = 0;\n+\tj9array_t recordComponentArrayObject = NULL;\n+\tJ9Class *clazz;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b272983b8338ffc97d846b4130b4b2da3523cad1"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NDI4NjE0OnYy", "diffSide": "RIGHT", "path": "runtime/jcl/common/reflecthelp.c", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxNDozNDo1OVrOFpWFpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxNDozNDo1OVrOFpWFpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODg5NzgyOQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tJ9ROMClass *romClass;\n          \n          \n            \n            \tJ9ROMClass *romClass = NULL;", "url": "https://github.com/eclipse-openj9/openj9/pull/8351#discussion_r378897829", "createdAt": "2020-02-13T14:34:59Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/reflecthelp.c", "diffHunk": "@@ -1720,3 +1720,233 @@ getFieldsHelper(JNIEnv *env, jobject cls)\n \tvmFuncs->internalExitVMToJNI(vmThread);\n \treturn result;\n }\n+\n+/* Determine whether currentMethod is the accessor method for a record component with name componentName.\n+ * an accessor method will have the same name as the component and take zero parameters.\n+ */\n+static U_8\n+isRecordComponentAccessorMethodMatch(J9Method *currentMethod, const char* componentName, const char* componentSignature) {\n+\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(currentMethod);\n+\tJ9UTF8 *methodNameUtf8 = J9ROMMETHOD_NAME(romMethod);\n+\tU_16 methodLength = J9UTF8_LENGTH(methodNameUtf8);\n+\tconst U_8 *methodName = J9UTF8_DATA(methodNameUtf8);\n+\tif ((methodLength == strlen(componentName)) \n+\t\t&& (0 == strcmp((const char*)methodName, componentName))\n+\t) {\n+\t\t/* verify parameters. An accessor will not have any input parameters. */\n+\t\tJ9UTF8 *methodSignatureUtf8 = J9ROMMETHOD_SIGNATURE(romMethod);\n+\t\tconst U_8 *methodSignature = J9UTF8_DATA(methodSignatureUtf8);\n+\t\tU_16 methodSignatureLength = J9UTF8_LENGTH(methodSignatureUtf8);\n+\n+\t\tif ((methodSignatureLength >= 2)\n+\t\t\t&& ('(' == methodSignature[0]) && (')' == methodSignature[1])\n+\t\t\t&& (((methodSignatureLength == 3) && componentSignature[2] == methodSignature[2])\n+\t\t\t\t|| (0 == strncmp((const char*)methodSignature + 2, componentSignature, methodSignatureLength - 2))\n+\t\t\t)\n+\t\t) {\n+\t\t\treturn TRUE;\n+\t\t}\n+\t}\n+\treturn FALSE;\n+}\n+\n+/* Find the accessor method for a record component with name componantName. \n+ * componentIndex slot for current record component will be used to optimize search\n+ */\n+static J9Method*\n+findRecordComponentAccessorMethod(J9VMThread* currentThread, J9Class* clazz, J9ROMRecordComponentShape* recordComponent, U_32 componentIndex, U_32 recordComponentCount)\n+{\n+\tJ9Method *currentMethod = clazz->ramMethods;\n+\tU_32 romMethodCount = clazz->romClass->romMethodCount;\n+\tJ9Method *resultMethod = NULL;\n+\n+\tconst char* componentName = (const char*)J9UTF8_DATA(J9ROMRECORDCOMPONENTSHAPE_NAME(recordComponent));\n+\tconst char* componentSignature = (const char*)J9UTF8_DATA(J9ROMRECORDCOMPONENTSHAPE_SIGNATURE(recordComponent));\n+\n+\t/* javac typically generates each of the record components in order as the final recordComponentCount methods in the record class. \n+\t* Probe the ramMethods array for a match at this point first before iterating through the entire method list. */\n+\tU_32 testSlot = romMethodCount - recordComponentCount + componentIndex;\n+\tif ((testSlot < romMethodCount) && isRecordComponentAccessorMethodMatch(currentMethod + testSlot, componentName, componentSignature)) {\n+\t\tresultMethod = currentMethod + testSlot;\n+\t} else {\n+\t\tfor (; romMethodCount > 0; romMethodCount--) {\n+\t\t\tif (isRecordComponentAccessorMethodMatch(currentMethod, componentName, componentSignature)) {\n+\t\t\t\tresultMethod = currentMethod;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tcurrentMethod += 1;\n+\t\t}\n+\t}\n+\n+\treturn resultMethod;\n+}\n+\n+/* Creates an array of RecordComponents for the given class and sets the following fields:\n+ * - Class<?> clazz \n+ * - String name\n+ * - Class<?> type\n+ * - Method accessor\n+ * - String signature\n+ * - byte[] annotations\n+ * - byte[] typeAnnotations\n+ * - RecordComponent root (currently always null)\n+ */\n+jarray\n+getRecordComponentsHelper(JNIEnv *env, jobject cls)\n+{\n+\tJ9VMThread *vmThread = (J9VMThread *)env;\n+\tJ9JavaVM *vm = vmThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tJ9MemoryManagerFunctions *mmFuncs = vm->memoryManagerFunctions;\n+\tjarray result = NULL;\n+\tJ9Class *recordComponentClass = NULL;\n+\tJ9Class *recordComponentArrayClass = NULL;\n+\tU_32 recordComponentCount = 0;\n+\tj9array_t recordComponentArrayObject = NULL;\n+\tJ9Class *clazz;\n+\tJ9ROMClass *romClass;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b272983b8338ffc97d846b4130b4b2da3523cad1"}, "originalPosition": 95}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 775, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}