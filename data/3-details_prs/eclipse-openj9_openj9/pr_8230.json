{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYwMTg5NTIy", "number": 8230, "title": "Fix Class.getMethod() and Class.getMethods() missing cases", "bodyText": "@ChengJin01 's changes from #7985 plus an add on (see #7985 (comment))\nFixes: #7897\nFixes: #7623\nSigned-off-by: Theresa Mammarella Theresa.T.Mammarella@ibm.com", "createdAt": "2020-01-07T21:54:00Z", "url": "https://github.com/eclipse-openj9/openj9/pull/8230", "merged": true, "mergeCommit": {"oid": "7e2412c58171f429453e117e0c059cff27b2222e"}, "closed": true, "closedAt": "2020-09-03T13:59:59Z", "author": {"login": "theresa-m"}, "timelineItems": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb4X79oABqjI5MzE4ODEwMzY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdFREN9gFqTQ4MTg2ODM2OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "efcb285b0ee47f79f40765555473c56fc2eac345", "author": {"user": {"login": "theresa-m", "name": "Theresa Mammarella"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/efcb285b0ee47f79f40765555473c56fc2eac345", "committedDate": "2020-01-07T21:47:53Z", "message": "Search all superinterfaces with base interfaces\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>"}, "afterCommit": {"oid": "4901aa8880abf63122a4de12e76d48ab782cca88", "author": {"user": {"login": "theresa-m", "name": "Theresa Mammarella"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/4901aa8880abf63122a4de12e76d48ab782cca88", "committedDate": "2020-01-08T16:27:52Z", "message": "Search all superinterfaces with base interfaces\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4901aa8880abf63122a4de12e76d48ab782cca88", "author": {"user": {"login": "theresa-m", "name": "Theresa Mammarella"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/4901aa8880abf63122a4de12e76d48ab782cca88", "committedDate": "2020-01-08T16:27:52Z", "message": "Search all superinterfaces with base interfaces\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>"}, "afterCommit": {"oid": "8bf4dc691e37ba4c7cfc0ebe85f78e8c12736625", "author": {"user": {"login": "theresa-m", "name": "Theresa Mammarella"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/8bf4dc691e37ba4c7cfc0ebe85f78e8c12736625", "committedDate": "2020-01-09T14:43:27Z", "message": "Search all superinterfaces with base interfaces\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyNzAxOTk4", "url": "https://github.com/eclipse-openj9/openj9/pull/8230#pullrequestreview-342701998", "createdAt": "2020-01-14T17:17:02Z", "commit": {"oid": "8bf4dc691e37ba4c7cfc0ebe85f78e8c12736625"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQxNzoxNzowM1rOFdfZyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQxNzoyMjozNVrOFdfj5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjQ2NzUzMQ==", "bodyText": "Is the check this != Object.class necessary?", "url": "https://github.com/eclipse-openj9/openj9/pull/8230#discussion_r366467531", "createdAt": "2020-01-14T17:17:03Z", "author": {"login": "JasonFengJ9"}, "path": "jcl/src/java.base/share/classes/java/lang/Class.java", "diffHunk": "@@ -1488,13 +1489,33 @@ Method getMethodHelper(\n \t\t\treturn null;\n \t\t}\n \t}\n-\tresult = forDeclaredMethod ? getDeclaredMethodImpl(name, parameterTypes, strSig, null) : getMethodImpl(name, parameterTypes, strSig);\n+\t\n+\tif (forDeclaredMethod) {\n+\t\tresult = getDeclaredMethodImpl(name, parameterTypes, strSig, null);\n+\t} else {\n+\t\tresult = getMethodImpl(name, parameterTypes, strSig);\n+\t\t/* Retrieve the specified method implemented by the superclass from the top to the bottom\n+\t\t * Note: there is no need do so when the method is declared by the current class.\n+\t\t */\n+\t\tif ((result != null) && result.getDeclaringClass().isInterface() && (this != Object.class)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8bf4dc691e37ba4c7cfc0ebe85f78e8c12736625"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjQ2ODQzOA==", "bodyText": "It appears this method is going to repeat getMethodImpl(name, parameterTypes, strSig) regardless of other conditions which is not desirable.", "url": "https://github.com/eclipse-openj9/openj9/pull/8230#discussion_r366468438", "createdAt": "2020-01-14T17:19:03Z", "author": {"login": "JasonFengJ9"}, "path": "jcl/src/java.base/share/classes/java/lang/Class.java", "diffHunk": "@@ -1488,13 +1489,33 @@ Method getMethodHelper(\n \t\t\treturn null;\n \t\t}\n \t}\n-\tresult = forDeclaredMethod ? getDeclaredMethodImpl(name, parameterTypes, strSig, null) : getMethodImpl(name, parameterTypes, strSig);\n+\t\n+\tif (forDeclaredMethod) {\n+\t\tresult = getDeclaredMethodImpl(name, parameterTypes, strSig, null);\n+\t} else {\n+\t\tresult = getMethodImpl(name, parameterTypes, strSig);\n+\t\t/* Retrieve the specified method implemented by the superclass from the top to the bottom\n+\t\t * Note: there is no need do so when the method is declared by the current class.\n+\t\t */\n+\t\tif ((result != null) && result.getDeclaringClass().isInterface() && (this != Object.class)) {\n+\t\t\tif (!this.isInterface()) {\n+\t\t\t\tHashSet<Class<?>> interfaceSet = new HashSet();\n+\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(this, interfaceSet, name, strSig, parameterTypes);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8bf4dc691e37ba4c7cfc0ebe85f78e8c12736625"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjQ2OTEyMg==", "bodyText": "This method might return null while initial result isn't, this doesn't seem right.", "url": "https://github.com/eclipse-openj9/openj9/pull/8230#discussion_r366469122", "createdAt": "2020-01-14T17:20:29Z", "author": {"login": "JasonFengJ9"}, "path": "jcl/src/java.base/share/classes/java/lang/Class.java", "diffHunk": "@@ -1488,13 +1489,33 @@ Method getMethodHelper(\n \t\t\treturn null;\n \t\t}\n \t}\n-\tresult = forDeclaredMethod ? getDeclaredMethodImpl(name, parameterTypes, strSig, null) : getMethodImpl(name, parameterTypes, strSig);\n+\t\n+\tif (forDeclaredMethod) {\n+\t\tresult = getDeclaredMethodImpl(name, parameterTypes, strSig, null);\n+\t} else {\n+\t\tresult = getMethodImpl(name, parameterTypes, strSig);\n+\t\t/* Retrieve the specified method implemented by the superclass from the top to the bottom\n+\t\t * Note: there is no need do so when the method is declared by the current class.\n+\t\t */\n+\t\tif ((result != null) && result.getDeclaringClass().isInterface() && (this != Object.class)) {\n+\t\t\tif (!this.isInterface()) {\n+\t\t\t\tHashSet<Class<?>> interfaceSet = new HashSet();\n+\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(this, interfaceSet, name, strSig, parameterTypes);\n+\t\t\t\tcandidateFromInteface = true;\n+\t\t\t} else if (result.getDeclaringClass() != this) { /* only applies if resulting class is not the base class */\n+\t\t\t\tHashSet<Class<?>> interfaceSet = new HashSet();\n+\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfCurrentClass(this, interfaceSet, null, name, strSig, parameterTypes);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8bf4dc691e37ba4c7cfc0ebe85f78e8c12736625"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjQ2OTg1OA==", "bodyText": "Any particular reason to create new HashSet() without actual usage after the following method call?", "url": "https://github.com/eclipse-openj9/openj9/pull/8230#discussion_r366469858", "createdAt": "2020-01-14T17:22:06Z", "author": {"login": "JasonFengJ9"}, "path": "jcl/src/java.base/share/classes/java/lang/Class.java", "diffHunk": "@@ -1488,13 +1489,33 @@ Method getMethodHelper(\n \t\t\treturn null;\n \t\t}\n \t}\n-\tresult = forDeclaredMethod ? getDeclaredMethodImpl(name, parameterTypes, strSig, null) : getMethodImpl(name, parameterTypes, strSig);\n+\t\n+\tif (forDeclaredMethod) {\n+\t\tresult = getDeclaredMethodImpl(name, parameterTypes, strSig, null);\n+\t} else {\n+\t\tresult = getMethodImpl(name, parameterTypes, strSig);\n+\t\t/* Retrieve the specified method implemented by the superclass from the top to the bottom\n+\t\t * Note: there is no need do so when the method is declared by the current class.\n+\t\t */\n+\t\tif ((result != null) && result.getDeclaringClass().isInterface() && (this != Object.class)) {\n+\t\t\tif (!this.isInterface()) {\n+\t\t\t\tHashSet<Class<?>> interfaceSet = new HashSet();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8bf4dc691e37ba4c7cfc0ebe85f78e8c12736625"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjQ3MDExOQ==", "bodyText": "Similar comment about this interfaceSet as well.", "url": "https://github.com/eclipse-openj9/openj9/pull/8230#discussion_r366470119", "createdAt": "2020-01-14T17:22:35Z", "author": {"login": "JasonFengJ9"}, "path": "jcl/src/java.base/share/classes/java/lang/Class.java", "diffHunk": "@@ -1488,13 +1489,33 @@ Method getMethodHelper(\n \t\t\treturn null;\n \t\t}\n \t}\n-\tresult = forDeclaredMethod ? getDeclaredMethodImpl(name, parameterTypes, strSig, null) : getMethodImpl(name, parameterTypes, strSig);\n+\t\n+\tif (forDeclaredMethod) {\n+\t\tresult = getDeclaredMethodImpl(name, parameterTypes, strSig, null);\n+\t} else {\n+\t\tresult = getMethodImpl(name, parameterTypes, strSig);\n+\t\t/* Retrieve the specified method implemented by the superclass from the top to the bottom\n+\t\t * Note: there is no need do so when the method is declared by the current class.\n+\t\t */\n+\t\tif ((result != null) && result.getDeclaringClass().isInterface() && (this != Object.class)) {\n+\t\t\tif (!this.isInterface()) {\n+\t\t\t\tHashSet<Class<?>> interfaceSet = new HashSet();\n+\t\t\t\tresult = getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(this, interfaceSet, name, strSig, parameterTypes);\n+\t\t\t\tcandidateFromInteface = true;\n+\t\t\t} else if (result.getDeclaringClass() != this) { /* only applies if resulting class is not the base class */\n+\t\t\t\tHashSet<Class<?>> interfaceSet = new HashSet();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8bf4dc691e37ba4c7cfc0ebe85f78e8c12736625"}, "originalPosition": 35}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8bf4dc691e37ba4c7cfc0ebe85f78e8c12736625", "author": {"user": {"login": "theresa-m", "name": "Theresa Mammarella"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/8bf4dc691e37ba4c7cfc0ebe85f78e8c12736625", "committedDate": "2020-01-09T14:43:27Z", "message": "Search all superinterfaces with base interfaces\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>"}, "afterCommit": {"oid": "7eedaee3f27228e8837b6490e809b2895035c718", "author": {"user": {"login": "theresa-m", "name": "Theresa Mammarella"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/7eedaee3f27228e8837b6490e809b2895035c718", "committedDate": "2020-01-29T14:57:40Z", "message": "Search all superinterfaces with base interfaces\n\n- Class.getMethods jteg fixes, and make more similar to hotspot output\n- Class.getMethod interface search logic\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUyMzQ0MDEw", "url": "https://github.com/eclipse-openj9/openj9/pull/8230#pullrequestreview-352344010", "createdAt": "2020-02-03T15:34:11Z", "commit": {"oid": "7eedaee3f27228e8837b6490e809b2895035c718"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QxNTozNDoxMVrOFk1lJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QxNTozNDoxMVrOFk1lJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDE3MDkxOA==", "bodyText": "getMethods() is going to be invoked for the superclasses from the top to the bottom, and the later invocations include the results of previous calls which seems an overkill.\ncan we modify getMethodImpl(name, parameterTypes, strSig) to introduce a startingPoint, particularly for the case that the method found is declared by an interface class?", "url": "https://github.com/eclipse-openj9/openj9/pull/8230#discussion_r374170918", "createdAt": "2020-02-03T15:34:11Z", "author": {"login": "JasonFengJ9"}, "path": "jcl/src/java.base/share/classes/java/lang/Class.java", "diffHunk": "@@ -1530,26 +1551,127 @@ Method getMethodHelper(\n \t * Otherwise, the result method is chosen arbitrarily from specific methods.\n \t */\n \tbestCandidate = result;\n-\tClass<?> declaringClass = forDeclaredMethod ? this : result.getDeclaringClass();\n-\twhile (true) {\n-\t\tresult = declaringClass.getDeclaredMethodImpl(name, parameterTypes, strSig, result);\n-\t\tif (result == null) {\n-\t\t\tbreak;\n+\tif (!candidateFromInterface) {\n+\t\tClass<?> declaringClass = forDeclaredMethod ? this : result.getDeclaringClass();\n+\t\twhile (true) {\n+\t\t\tresult = declaringClass.getDeclaredMethodImpl(name, parameterTypes, strSig, result);\n+\t\t\tif (result == null) {\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tboolean publicMethod = ((result.getModifiers() & Modifier.PUBLIC) != 0);\n+\t\t\tif ((methodList != null) && publicMethod) {\n+\t\t\t\tmethodList.add(result);\n+\t\t\t}\n+\t\t\tif (forDeclaredMethod || publicMethod) {\n+\t\t\t\t// bestCandidate and result have same declaringClass.\n+\t\t\t\tClass<?> candidateRetType = bestCandidate.getReturnType();\n+\t\t\t\tClass<?> resultRetType = result.getReturnType();\n+\t\t\t\tif ((candidateRetType != resultRetType) && candidateRetType.isAssignableFrom(resultRetType)) {\n+\t\t\t\t\tbestCandidate = result;\n+\t\t\t\t}\n+\t\t\t}\n \t\t}\n-\t\tboolean publicMethod = ((result.getModifiers() & Modifier.PUBLIC) != 0);\n-\t\tif ((methodList != null) && publicMethod) {\n-\t\t\tmethodList.add(result);\n+\t}\n+\treturn cacheMethod(bestCandidate);\n+}\n+\n+/**\n+ * Helper method searches all interfaces implemented by superclasses from the top to the bottom\n+ * for the most specific method declared in one of these interfaces.\n+ *\n+ * @param currentClass the class to be searched, including the current class and all superclasses\n+ * @param name the specified method's name\n+ * @param strSig the string of the specified method's signature\n+ * @param parameterTypes the types of the arguments of the specified method\n+ * @return the most specific method selected from all interfaces from each superclass of the current class;\n+ *         otherwise, return the method of the first interface from the top superclass\n+ *         if the return types of all specified methods are identical.\n+ */\n+private static Method getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(Class<?> currentClass, String name, String strSig, Class<?>... parameterTypes) {\n+\tMethod candidateMethod = null;\n+\tif (currentClass != Object.class) {\n+\t\t/* get to the top superclass first. if all return types end up being the same the interfaces from this superclass have priority. */\n+\t\tcandidateMethod = getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(currentClass.getSuperclass(), name, strSig, parameterTypes);\n+\t\t\n+\t\t/* search all interfaces of current class, comparing against result from previous superclass. */\n+\t\tcandidateMethod = getMostSpecificMethodFromAllInterfacesOfCurrentClass(currentClass, candidateMethod, name, strSig, parameterTypes);\n+\t}\n+\treturn candidateMethod;\n+}\n+\n+/**\n+ * Helper method searches all interfaces implemented by the current class or interface \n+ * for the most specific method declared in one of these interfaces.\n+ *\n+ * @param currentClass the class or interface to be searched\n+ * @param potentialCandidate potential candidate from superclass, null if currentClass is an interface\n+ * @param name the specified method's name\n+ * @param strSig the string of the specified method's signature\n+ * @param parameterTypes the types of the arguments of the specified method\n+ * @return the most specific method selected from all interfaces;\n+ *         otherwise if return types from all qualifying methods are identical, return an arbitrary method.\n+ */\n+private static Method getMostSpecificMethodFromAllInterfacesOfCurrentClass(Class<?> currentClass, Method potentialCandidate, String name, String strSig, Class<?>... parameterTypes) {\n+\tMethod bestMethod = potentialCandidate;\n+\tMethod[] methodCandidates = currentClass.getMethods();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7eedaee3f27228e8837b6490e809b2895035c718"}, "originalPosition": 119}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7eedaee3f27228e8837b6490e809b2895035c718", "author": {"user": {"login": "theresa-m", "name": "Theresa Mammarella"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/7eedaee3f27228e8837b6490e809b2895035c718", "committedDate": "2020-01-29T14:57:40Z", "message": "Search all superinterfaces with base interfaces\n\n- Class.getMethods jteg fixes, and make more similar to hotspot output\n- Class.getMethod interface search logic\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>"}, "afterCommit": {"oid": "0715f9f8f7a3b2920884c427409dff8877a64373", "author": {"user": {"login": "theresa-m", "name": "Theresa Mammarella"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/0715f9f8f7a3b2920884c427409dff8877a64373", "committedDate": "2020-02-04T21:29:12Z", "message": "Search all superinterfaces with base interfaces\n\n- Class.getMethods jteg fixes, and make more similar to hotspot output\n- Class.getMethod interface search logic\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0715f9f8f7a3b2920884c427409dff8877a64373", "author": {"user": {"login": "theresa-m", "name": "Theresa Mammarella"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/0715f9f8f7a3b2920884c427409dff8877a64373", "committedDate": "2020-02-04T21:29:12Z", "message": "Search all superinterfaces with base interfaces\n\n- Class.getMethods jteg fixes, and make more similar to hotspot output\n- Class.getMethod interface search logic\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>"}, "afterCommit": {"oid": "bbc2ff27a563388dd938aa3e7391d367fed07c36", "author": {"user": {"login": "theresa-m", "name": "Theresa Mammarella"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/bbc2ff27a563388dd938aa3e7391d367fed07c36", "committedDate": "2020-02-12T11:39:05Z", "message": "Caching for find interface in superclasses\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU3NTYyMzMw", "url": "https://github.com/eclipse-openj9/openj9/pull/8230#pullrequestreview-357562330", "createdAt": "2020-02-12T15:46:28Z", "commit": {"oid": "bbc2ff27a563388dd938aa3e7391d367fed07c36"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxNTo0NjoyOFrOFoz1WA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxNTo0NjoyOFrOFoz1WA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMzNjYwMA==", "bodyText": "is there a chance that infoCache could be confused by localInterfacesOnly since the key is always this class?\nI didn't go thorough all use cases, but just wondering if such possibility has been considered.", "url": "https://github.com/eclipse-openj9/openj9/pull/8230#discussion_r378336600", "createdAt": "2020-02-12T15:46:28Z", "author": {"login": "JasonFengJ9"}, "path": "jcl/src/java.base/share/classes/java/lang/Class.java", "diffHunk": "@@ -1530,28 +1552,146 @@ Method getMethodHelper(\n \t * Otherwise, the result method is chosen arbitrarily from specific methods.\n \t */\n \tbestCandidate = result;\n-\tClass<?> declaringClass = forDeclaredMethod ? this : result.getDeclaringClass();\n-\twhile (true) {\n-\t\tresult = declaringClass.getDeclaredMethodImpl(name, parameterTypes, strSig, result);\n-\t\tif (result == null) {\n-\t\t\tbreak;\n-\t\t}\n-\t\tboolean publicMethod = ((result.getModifiers() & Modifier.PUBLIC) != 0);\n-\t\tif ((methodList != null) && publicMethod) {\n-\t\t\tmethodList.add(result);\n-\t\t}\n-\t\tif (forDeclaredMethod || publicMethod) {\n-\t\t\t// bestCandidate and result have same declaringClass.\n-\t\t\tClass<?> candidateRetType = bestCandidate.getReturnType();\n-\t\t\tClass<?> resultRetType = result.getReturnType();\n-\t\t\tif ((candidateRetType != resultRetType) && candidateRetType.isAssignableFrom(resultRetType)) {\n-\t\t\t\tbestCandidate = result;\n+\tif (!candidateFromInterface) {\n+\t\tClass<?> declaringClass = forDeclaredMethod ? this : result.getDeclaringClass();\n+\t\twhile (true) {\n+\t\t\tresult = declaringClass.getDeclaredMethodImpl(name, parameterTypes, strSig, result);\n+\t\t\tif (result == null) {\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tboolean publicMethod = ((result.getModifiers() & Modifier.PUBLIC) != 0);\n+\t\t\tif ((methodList != null) && publicMethod) {\n+\t\t\t\tmethodList.add(result);\n+\t\t\t}\n+\t\t\tif (forDeclaredMethod || publicMethod) {\n+\t\t\t\t// bestCandidate and result have same declaringClass.\n+\t\t\t\tClass<?> candidateRetType = bestCandidate.getReturnType();\n+\t\t\t\tClass<?> resultRetType = result.getReturnType();\n+\t\t\t\tif ((candidateRetType != resultRetType) && candidateRetType.isAssignableFrom(resultRetType)) {\n+\t\t\t\t\tbestCandidate = result;\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n \treturn cacheMethod(bestCandidate);\n }\n \n+/**\n+ * Helper method searches all interfaces implemented by superclasses from the top to the bottom\n+ * for the most specific method declared in one of these interfaces.\n+ *\n+ * @param currentClass the class to be searched, including the current class and all superclasses\n+ * @param name the specified method's name\n+ * @param parameterTypes the types of the arguments of the specified method\n+ * @return the most specific method selected from all interfaces from each superclass of the current class;\n+ *         otherwise, return the method of the first interface from the top superclass\n+ *         if the return types of all specified methods are identical.\n+ */\n+private Method getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(Class<?> currentClass, HashMap<Class<?>, HashMap<MethodInfo, MethodInfo>> infoCache, \n+\tString name, Class<?>... parameterTypes) \n+{\n+\tMethod candidateMethod = null;\n+\tif (currentClass != Object.class) {\n+\t\t/* get to the top superclass first. if all return types end up being the same the interfaces from this superclass have priority. */\n+\t\tcandidateMethod = getMostSpecificMethodFromAllInterfacesOfAllSuperclasses(currentClass.getSuperclass(), infoCache, name, parameterTypes);\n+\t\t\n+\t\t/* search all interfaces of current class, comparing against result from previous superclass. */\n+\t\tcandidateMethod = getMostSpecificMethodFromAllInterfacesOfCurrentClass(currentClass, infoCache, candidateMethod, name, parameterTypes);\n+\t}\n+\treturn candidateMethod;\n+}\n+\n+/**\n+ * Helper method searches all interfaces implemented by the current class or interface \n+ * for the most specific method declared in one of these interfaces.\n+ *\n+ * @param currentClass the class or interface to be searched\n+ * @param potentialCandidate potential candidate from superclass, null if currentClass is an interface\n+ * @param name the specified method's name\n+ * @param parameterTypes the types of the arguments of the specified method\n+ * @return the most specific method selected from all interfaces;\n+ *         otherwise if return types from all qualifying methods are identical, return an arbitrary method.\n+ */\n+private Method getMostSpecificMethodFromAllInterfacesOfCurrentClass(Class<?> currentClass, HashMap<Class<?>, HashMap<MethodInfo, MethodInfo>> infoCache,\n+\tMethod potentialCandidate, String name, Class<?>... parameterTypes) \n+{\n+\tMethod bestMethod = potentialCandidate;\n+\t/* if infoCache is passed in, reuse from superclass */\n+\tif (null == infoCache) {\n+\t\tinfoCache = new HashMap<>(16);\n+\t}\n+\tHashMap<MethodInfo, MethodInfo> methodCandidates = getMethodSet(infoCache, false, true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bbc2ff27a563388dd938aa3e7391d367fed07c36"}, "originalPosition": 126}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "bbc2ff27a563388dd938aa3e7391d367fed07c36", "author": {"user": {"login": "theresa-m", "name": "Theresa Mammarella"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/bbc2ff27a563388dd938aa3e7391d367fed07c36", "committedDate": "2020-02-12T11:39:05Z", "message": "Caching for find interface in superclasses\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>"}, "afterCommit": {"oid": "b09b8df1b275eb94e149adf9805c810c72cc95e1", "author": {"user": {"login": "theresa-m", "name": "Theresa Mammarella"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/b09b8df1b275eb94e149adf9805c810c72cc95e1", "committedDate": "2020-02-13T12:02:41Z", "message": "Caching for find interface in superclasses\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b09b8df1b275eb94e149adf9805c810c72cc95e1", "author": {"user": {"login": "theresa-m", "name": "Theresa Mammarella"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/b09b8df1b275eb94e149adf9805c810c72cc95e1", "committedDate": "2020-02-13T12:02:41Z", "message": "Caching for find interface in superclasses\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>"}, "afterCommit": {"oid": "1ed4919d1a2f9eb58ce7bd4facc99bcb76068bf9", "author": {"user": {"login": "theresa-m", "name": "Theresa Mammarella"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/1ed4919d1a2f9eb58ce7bd4facc99bcb76068bf9", "committedDate": "2020-02-13T14:15:07Z", "message": "Caching for find interface in superclasses\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc1NDc3Mjk2", "url": "https://github.com/eclipse-openj9/openj9/pull/8230#pullrequestreview-475477296", "createdAt": "2020-08-26T13:17:44Z", "commit": {"oid": "1ed4919d1a2f9eb58ce7bd4facc99bcb76068bf9"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc1NTI1MjMz", "url": "https://github.com/eclipse-openj9/openj9/pull/8230#pullrequestreview-475525233", "createdAt": "2020-08-26T14:06:44Z", "commit": {"oid": "1ed4919d1a2f9eb58ce7bd4facc99bcb76068bf9"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "57ec2470aba0d567200e7754f76d4fed5b4110d3", "author": {"user": {"login": "ChengJin01", "name": "Cheng Jin"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/57ec2470aba0d567200e7754f76d4fed5b4110d3", "committedDate": "2020-08-27T12:41:53Z", "message": "Fix the missing case of Class.getMethod()\n\nThe change is adding code in the helper method\nof getMethod() to address the missing case when\nthe two specific methods are both declared\nby interfaces.\n\nFixes: #7897\n\nSigned-off-by: Cheng Jin <jincheng@ca.ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ce60704e9678db4056d8afe08c13d3a02d554df0", "author": {"user": {"login": "theresa-m", "name": "Theresa Mammarella"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/ce60704e9678db4056d8afe08c13d3a02d554df0", "committedDate": "2020-08-27T12:41:53Z", "message": "Search all superinterfaces with base interfaces\n\n- Class.getMethods jteg fixes, and make more similar to hotspot output\n- Class.getMethod interface search logic\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2d998299562752395d25a9a94f1f5c3721ff3906", "author": {"user": {"login": "theresa-m", "name": "Theresa Mammarella"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/2d998299562752395d25a9a94f1f5c3721ff3906", "committedDate": "2020-08-27T12:41:53Z", "message": "Caching for find interface in superclasses\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1ed4919d1a2f9eb58ce7bd4facc99bcb76068bf9", "author": {"user": {"login": "theresa-m", "name": "Theresa Mammarella"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/1ed4919d1a2f9eb58ce7bd4facc99bcb76068bf9", "committedDate": "2020-02-13T14:15:07Z", "message": "Caching for find interface in superclasses\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>"}, "afterCommit": {"oid": "2d998299562752395d25a9a94f1f5c3721ff3906", "author": {"user": {"login": "theresa-m", "name": "Theresa Mammarella"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/2d998299562752395d25a9a94f1f5c3721ff3906", "committedDate": "2020-08-27T12:41:53Z", "message": "Caching for find interface in superclasses\n\nSigned-off-by: Theresa Mammarella <Theresa.T.Mammarella@ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxODY4MzY4", "url": "https://github.com/eclipse-openj9/openj9/pull/8230#pullrequestreview-481868368", "createdAt": "2020-09-03T13:59:51Z", "commit": {"oid": "2d998299562752395d25a9a94f1f5c3721ff3906"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 946, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}