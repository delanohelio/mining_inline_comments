{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc2MzQ0MjA1", "number": 10497, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxNDo1NTo1NlrOEeV6wA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxNDo1NjoxOVrOEeV7aA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMjUxODQwOnYy", "diffSide": "RIGHT", "path": "runtime/tests/jvmtitests/src/com/ibm/jvmti/tests/retransformClasses/rtc002.c", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxNDo1NTo1NlrOHJ8QPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxNDo1NTo1NlrOHJ8QPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDE4NjQzMQ==", "bodyText": "Probably better to use the JVMTI Allocate function instead of malloc.", "url": "https://github.com/eclipse-openj9/openj9/pull/10497#discussion_r480186431", "createdAt": "2020-08-31T14:55:56Z", "author": {"login": "gacholio"}, "path": "runtime/tests/jvmtitests/src/com/ibm/jvmti/tests/retransformClasses/rtc002.c", "diffHunk": "@@ -0,0 +1,141 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2019 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+#include <string.h>\n+\n+#include \"jvmti_test.h\"\n+\n+static agentEnv * env;\n+\n+typedef struct TransformerData {\n+\tjint action;\n+\tchar *retransformedClassName;\n+\tjsize classDataSize;\n+\tunsigned char *transformedClassData;\n+} TransformerData;\n+\n+static TransformerData transformerData;\n+\n+static void JNICALL\n+classFileLoadHook(jvmtiEnv *jvmti_env,\n+            JNIEnv* jni_env,\n+            jclass class_being_redefined,\n+            jobject loader,\n+            const char* name,\n+            jobject protection_domain,\n+            jint class_data_len,\n+            const unsigned char* class_data,\n+            jint* new_class_data_len,\n+            unsigned char** new_class_data)\n+{\n+\tif ((NULL != transformerData.retransformedClassName) && (0 == strcmp(name, transformerData.retransformedClassName))) {\n+\t\tif (NULL != transformerData.transformedClassData) {\n+\t\t\t*new_class_data = transformerData.transformedClassData;\n+\t\t\t*new_class_data_len = (jint)transformerData.classDataSize;\n+\t\t}\n+\t}\n+}\n+\n+jint JNICALL\n+rtc002(agentEnv * agent_env, char * args)\n+{\n+\tjvmtiError err;\n+\tjvmtiEventCallbacks callbacks;\n+\tjvmtiCapabilities capabilities;\n+\tJVMTI_ACCESS_FROM_AGENT(agent_env);\n+\n+\tenv = agent_env;\n+\n+\tmemset(&capabilities, 0, sizeof(jvmtiCapabilities));\n+\tcapabilities.can_retransform_classes = 1;\n+\terr = (*jvmti_env)->AddCapabilities(jvmti_env, &capabilities);\n+\tif (JVMTI_ERROR_NONE != err) {\n+\t\terror(env, err, \"Failed to AddCapabilities\");\n+\t\treturn JNI_ERR;\n+\t}\n+\n+\t/* Set the ClassFileLoadHook event callback */\n+\tmemset(&callbacks, 0, sizeof(jvmtiEventCallbacks));\n+\tcallbacks.ClassFileLoadHook = classFileLoadHook;\n+\terr = (*jvmti_env)->SetEventCallbacks(jvmti_env, &callbacks, sizeof(jvmtiEventCallbacks));\n+\tif (JVMTI_ERROR_NONE != err) {\n+\t\terror(env, err, \"Failed to set callback for ClassFileLoadHook events\");\n+\t\treturn JNI_ERR;\n+\t}\n+\n+\t/* Enable the JVMTI_EVENT_CLASS_FILE_LOAD_HOOK callback */\n+\terr = (*jvmti_env)->SetEventNotificationMode(jvmti_env, JVMTI_ENABLE, JVMTI_EVENT_CLASS_FILE_LOAD_HOOK, NULL);\n+\tif (JVMTI_ERROR_NONE != err) {\n+\t\terror(env, err, \"Failed to enable ClassFileLoadHook event\");\n+\t\treturn JNI_ERR;\n+\t}\n+\n+\tmemset(&transformerData, 0, sizeof(TransformerData));\n+\treturn JNI_OK;\n+}\n+\n+jboolean JNICALL\n+Java_com_ibm_jvmti_tests_retransformClasses_rtc002_retransformClass(JNIEnv * jni_env, jclass clazz, jclass originalClass, jstring className, jbyteArray transformedClassBytes)\n+{\n+\tJVMTI_ACCESS_FROM_AGENT(env);\n+\tjvmtiError err;\n+\tunsigned char *newClassData = NULL;\n+\tjsize classNameLength;\n+\tchar *utfClassName;\n+\n+\t/* Set fields to be used by the transformer */\n+\tclassNameLength = (*jni_env)->GetStringLength(jni_env, className);\n+\tutfClassName = (char *)(*jni_env)->GetStringUTFChars(jni_env, className, NULL);\n+\tif (NULL == utfClassName) {\n+\t\tfprintf(stderr, \"Failed to get UTF characters for class name string\\n\");\n+\t\treturn JNI_FALSE;\n+\t}\n+\ttransformerData.retransformedClassName = malloc(classNameLength+1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ca69871ae761b3e3a75476b509fde15f3d3edfa"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMjUyMDA4OnYy", "diffSide": "RIGHT", "path": "runtime/tests/jvmtitests/src/com/ibm/jvmti/tests/retransformClasses/rtc002.c", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxNDo1NjoxOVrOHJ8RQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxNDo1NjoxOVrOHJ8RQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDE4NjY5MA==", "bodyText": "Bad formatting here.", "url": "https://github.com/eclipse-openj9/openj9/pull/10497#discussion_r480186690", "createdAt": "2020-08-31T14:56:19Z", "author": {"login": "gacholio"}, "path": "runtime/tests/jvmtitests/src/com/ibm/jvmti/tests/retransformClasses/rtc002.c", "diffHunk": "@@ -0,0 +1,141 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2019 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+#include <string.h>\n+\n+#include \"jvmti_test.h\"\n+\n+static agentEnv * env;\n+\n+typedef struct TransformerData {\n+\tjint action;\n+\tchar *retransformedClassName;\n+\tjsize classDataSize;\n+\tunsigned char *transformedClassData;\n+} TransformerData;\n+\n+static TransformerData transformerData;\n+\n+static void JNICALL\n+classFileLoadHook(jvmtiEnv *jvmti_env,\n+            JNIEnv* jni_env,\n+            jclass class_being_redefined,\n+            jobject loader,\n+            const char* name,\n+            jobject protection_domain,\n+            jint class_data_len,\n+            const unsigned char* class_data,\n+            jint* new_class_data_len,\n+            unsigned char** new_class_data)\n+{\n+\tif ((NULL != transformerData.retransformedClassName) && (0 == strcmp(name, transformerData.retransformedClassName))) {\n+\t\tif (NULL != transformerData.transformedClassData) {\n+\t\t\t*new_class_data = transformerData.transformedClassData;\n+\t\t\t*new_class_data_len = (jint)transformerData.classDataSize;\n+\t\t}\n+\t}\n+}\n+\n+jint JNICALL\n+rtc002(agentEnv * agent_env, char * args)\n+{\n+\tjvmtiError err;\n+\tjvmtiEventCallbacks callbacks;\n+\tjvmtiCapabilities capabilities;\n+\tJVMTI_ACCESS_FROM_AGENT(agent_env);\n+\n+\tenv = agent_env;\n+\n+\tmemset(&capabilities, 0, sizeof(jvmtiCapabilities));\n+\tcapabilities.can_retransform_classes = 1;\n+\terr = (*jvmti_env)->AddCapabilities(jvmti_env, &capabilities);\n+\tif (JVMTI_ERROR_NONE != err) {\n+\t\terror(env, err, \"Failed to AddCapabilities\");\n+\t\treturn JNI_ERR;\n+\t}\n+\n+\t/* Set the ClassFileLoadHook event callback */\n+\tmemset(&callbacks, 0, sizeof(jvmtiEventCallbacks));\n+\tcallbacks.ClassFileLoadHook = classFileLoadHook;\n+\terr = (*jvmti_env)->SetEventCallbacks(jvmti_env, &callbacks, sizeof(jvmtiEventCallbacks));\n+\tif (JVMTI_ERROR_NONE != err) {\n+\t\terror(env, err, \"Failed to set callback for ClassFileLoadHook events\");\n+\t\treturn JNI_ERR;\n+\t}\n+\n+\t/* Enable the JVMTI_EVENT_CLASS_FILE_LOAD_HOOK callback */\n+\terr = (*jvmti_env)->SetEventNotificationMode(jvmti_env, JVMTI_ENABLE, JVMTI_EVENT_CLASS_FILE_LOAD_HOOK, NULL);\n+\tif (JVMTI_ERROR_NONE != err) {\n+\t\terror(env, err, \"Failed to enable ClassFileLoadHook event\");\n+\t\treturn JNI_ERR;\n+\t}\n+\n+\tmemset(&transformerData, 0, sizeof(TransformerData));\n+\treturn JNI_OK;\n+}\n+\n+jboolean JNICALL\n+Java_com_ibm_jvmti_tests_retransformClasses_rtc002_retransformClass(JNIEnv * jni_env, jclass clazz, jclass originalClass, jstring className, jbyteArray transformedClassBytes)\n+{\n+\tJVMTI_ACCESS_FROM_AGENT(env);\n+\tjvmtiError err;\n+\tunsigned char *newClassData = NULL;\n+\tjsize classNameLength;\n+\tchar *utfClassName;\n+\n+\t/* Set fields to be used by the transformer */\n+\tclassNameLength = (*jni_env)->GetStringLength(jni_env, className);\n+\tutfClassName = (char *)(*jni_env)->GetStringUTFChars(jni_env, className, NULL);\n+\tif (NULL == utfClassName) {\n+\t\tfprintf(stderr, \"Failed to get UTF characters for class name string\\n\");\n+\t\treturn JNI_FALSE;\n+\t}\n+\ttransformerData.retransformedClassName = malloc(classNameLength+1);\n+\tif (NULL == transformerData.retransformedClassName) {\n+\t\tfprintf(stderr, \"Failed to allocate memory for class name\\n\");\n+\t\t(*jni_env)->ReleaseStringUTFChars(jni_env, className, utfClassName);\n+\t\treturn JNI_FALSE;\n+\t}\n+\tstrcpy(transformerData.retransformedClassName, utfClassName);\n+\t(*jni_env)->ReleaseStringUTFChars(jni_env, className, utfClassName);\n+\n+\tif (NULL != transformedClassBytes) {\n+\t\ttransformerData.classDataSize = (*jni_env)->GetArrayLength(jni_env, (jarray) transformedClassBytes);\n+\t\terr = (*jvmti_env)->Allocate(jvmti_env, transformerData.classDataSize, &newClassData);\n+\t\tif (JVMTI_ERROR_NONE != err) {\n+\t\t\terror(env, err, \"Failed to allocate memory for new class data\");\n+\t\t\treturn JNI_FALSE;\n+\t\t}\n+\t\t(*jni_env)->GetByteArrayRegion(jni_env, transformedClassBytes, 0, transformerData.classDataSize, (jbyte *)newClassData);\n+\t} else {\n+\t\ttransformerData.classDataSize = 0;\n+\t}\n+\n+\ttransformerData.transformedClassData = newClassData;\n+\n+    err = (*jvmti_env)->RetransformClasses(jvmti_env, 1, &originalClass);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ca69871ae761b3e3a75476b509fde15f3d3edfa"}, "originalPosition": 134}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4764, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}