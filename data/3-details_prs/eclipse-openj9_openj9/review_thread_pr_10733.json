{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk0NDMxMDI4", "number": 10733, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxOToxMTo1N1rOEotMRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQwNDo0ODozN1rOEpUBbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExMTE4OTE2OnYy", "diffSide": "RIGHT", "path": "runtime/vm/BytecodeInterpreter.hpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxOToxMTo1N1rOHZ8-1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxNToxNjoxN1rOHair4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk3NTU3NA==", "bodyText": "I dont think we really need volatile here?", "url": "https://github.com/eclipse-openj9/openj9/pull/10733#discussion_r496975574", "createdAt": "2020-09-29T19:11:57Z", "author": {"login": "fengxue-IS"}, "path": "runtime/vm/BytecodeInterpreter.hpp", "diffHunk": "@@ -8054,26 +8109,75 @@ class INTERPRETER_CLASS\n \t\t}\n done:\n \t\treturn rc;\n-#else\n-\tAssert_VM_unreachable();\n-\treturn EXECUTE_BYTECODE;\n-#endif /* J9VM_OPT_METHOD_HANDLE */\n \t}\n+#elif defined(J9VM_OPT_OPENJDK_METHODHANDLE) /* defined(J9VM_OPT_METHOD_HANDLE) */\n+\tVMINLINE VM_BytecodeAction\n+\tinvokehandle(REGISTER_ARGS_LIST)\n+\t{\n+retry:\n+\t\tVM_BytecodeAction rc = GOTO_RUN_METHOD;\n+\t\tU_16 index = *(U_16 *)(_pc + 1);\n+\n+\t\tJ9ConstantPool *ramConstantPool = J9_CP_FROM_METHOD(_literals);\n+\t\tJ9RAMMethodRef *ramMethodRef = ((J9RAMMethodRef *)ramConstantPool) + index;\n+\n+\t\tUDATA invokeCacheIndex = ramMethodRef->methodIndexAndArgCount >> 8;\n+\t\tJ9InvokeCacheEntry *resultEntry = ((J9InvokeCacheEntry *)J9_CLASS_FROM_CP(ramConstantPool)->invokeCache) + invokeCacheIndex;\n+\n+\t\tj9object_t volatile memberNameObject = resultEntry->target;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1ab36bbac1ffd18fdef13d6e67e6d59c99f533a9"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU5MzMxNQ==", "bodyText": "Updated.", "url": "https://github.com/eclipse-openj9/openj9/pull/10733#discussion_r497593315", "createdAt": "2020-09-30T15:16:17Z", "author": {"login": "babsingh"}, "path": "runtime/vm/BytecodeInterpreter.hpp", "diffHunk": "@@ -8054,26 +8109,75 @@ class INTERPRETER_CLASS\n \t\t}\n done:\n \t\treturn rc;\n-#else\n-\tAssert_VM_unreachable();\n-\treturn EXECUTE_BYTECODE;\n-#endif /* J9VM_OPT_METHOD_HANDLE */\n \t}\n+#elif defined(J9VM_OPT_OPENJDK_METHODHANDLE) /* defined(J9VM_OPT_METHOD_HANDLE) */\n+\tVMINLINE VM_BytecodeAction\n+\tinvokehandle(REGISTER_ARGS_LIST)\n+\t{\n+retry:\n+\t\tVM_BytecodeAction rc = GOTO_RUN_METHOD;\n+\t\tU_16 index = *(U_16 *)(_pc + 1);\n+\n+\t\tJ9ConstantPool *ramConstantPool = J9_CP_FROM_METHOD(_literals);\n+\t\tJ9RAMMethodRef *ramMethodRef = ((J9RAMMethodRef *)ramConstantPool) + index;\n+\n+\t\tUDATA invokeCacheIndex = ramMethodRef->methodIndexAndArgCount >> 8;\n+\t\tJ9InvokeCacheEntry *resultEntry = ((J9InvokeCacheEntry *)J9_CLASS_FROM_CP(ramConstantPool)->invokeCache) + invokeCacheIndex;\n+\n+\t\tj9object_t volatile memberNameObject = resultEntry->target;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk3NTU3NA=="}, "originalCommit": {"oid": "1ab36bbac1ffd18fdef13d6e67e6d59c99f533a9"}, "originalPosition": 145}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExMTE5MDI3OnYy", "diffSide": "RIGHT", "path": "runtime/vm/BytecodeInterpreter.hpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxOToxMjowM1rOHZ8_Ww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxNToxNjoyM1rOHaisNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk3NTcwNw==", "bodyText": "Maybe put the casting in brackets? This help to make the pointer addition target more clear\n((J9InvokeCacheEntry *)ramConstantPool->ramClass->callSites) + index;", "url": "https://github.com/eclipse-openj9/openj9/pull/10733#discussion_r496975707", "createdAt": "2020-09-29T19:12:03Z", "author": {"login": "fengxue-IS"}, "path": "runtime/vm/BytecodeInterpreter.hpp", "diffHunk": "@@ -8004,35 +8007,87 @@ class INTERPRETER_CLASS\n \t\t\t\tgoto retry;\n \t\t\t}\n \t\t}\n+\n \t\treturn rc;\n-#else\n-\tAssert_VM_unreachable();\n-\treturn EXECUTE_BYTECODE;\n-#endif /* J9VM_OPT_METHOD_HANDLE */\n \t}\n+#elif defined(J9VM_OPT_OPENJDK_METHODHANDLE) /* defined(J9VM_OPT_METHOD_HANDLE) */\n+\tVMINLINE VM_BytecodeAction\n+\tinvokedynamic(REGISTER_ARGS_LIST)\n+\t{\n+retry:\n+\t\tVM_BytecodeAction rc = GOTO_RUN_METHOD;\n+\t\tU_16 index = *(U_16 *)(_pc + 1);\n+\n+\t\tJ9ConstantPool *ramConstantPool = J9_CP_FROM_METHOD(_literals);\n+\t\tJ9InvokeCacheEntry *invokeCache = (J9InvokeCacheEntry *)ramConstantPool->ramClass->callSites + index;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1ab36bbac1ffd18fdef13d6e67e6d59c99f533a9"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU5MzM5Ng==", "bodyText": "Updated.", "url": "https://github.com/eclipse-openj9/openj9/pull/10733#discussion_r497593396", "createdAt": "2020-09-30T15:16:23Z", "author": {"login": "babsingh"}, "path": "runtime/vm/BytecodeInterpreter.hpp", "diffHunk": "@@ -8004,35 +8007,87 @@ class INTERPRETER_CLASS\n \t\t\t\tgoto retry;\n \t\t\t}\n \t\t}\n+\n \t\treturn rc;\n-#else\n-\tAssert_VM_unreachable();\n-\treturn EXECUTE_BYTECODE;\n-#endif /* J9VM_OPT_METHOD_HANDLE */\n \t}\n+#elif defined(J9VM_OPT_OPENJDK_METHODHANDLE) /* defined(J9VM_OPT_METHOD_HANDLE) */\n+\tVMINLINE VM_BytecodeAction\n+\tinvokedynamic(REGISTER_ARGS_LIST)\n+\t{\n+retry:\n+\t\tVM_BytecodeAction rc = GOTO_RUN_METHOD;\n+\t\tU_16 index = *(U_16 *)(_pc + 1);\n+\n+\t\tJ9ConstantPool *ramConstantPool = J9_CP_FROM_METHOD(_literals);\n+\t\tJ9InvokeCacheEntry *invokeCache = (J9InvokeCacheEntry *)ramConstantPool->ramClass->callSites + index;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk3NTcwNw=="}, "originalCommit": {"oid": "1ab36bbac1ffd18fdef13d6e67e6d59c99f533a9"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExNTI3NTA3OnYy", "diffSide": "RIGHT", "path": "runtime/vm/BytecodeInterpreter.hpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxNTo1MjowNFrOHakRZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQyMTowOTowMlrOHavaJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzYxOTMwMg==", "bodyText": "Please use sp -= 1", "url": "https://github.com/eclipse-openj9/openj9/pull/10733#discussion_r497619302", "createdAt": "2020-09-30T15:52:04Z", "author": {"login": "gacholio"}, "path": "runtime/vm/BytecodeInterpreter.hpp", "diffHunk": "@@ -8119,11 +8223,186 @@ class INTERPRETER_CLASS\n \t\t}\n done:\n \t\treturn rc;\n-#else\n+#else /* defined(J9VM_OPT_METHOD_HANDLE) */\n+\t/* When J9VM_OPT_OPENJDK_METHODHANDLE is enabled, MH.invoke and MH.invokeExact are\n+\t * both translated to invokehandle. So, invokehandlegeneric is not used with OpenJDK\n+\t * MethodHandles.\n+\t */\n \tAssert_VM_unreachable();\n \treturn EXECUTE_BYTECODE;\n-#endif /* J9VM_OPT_METHOD_HANDLE */\n+#endif /* defined(J9VM_OPT_METHOD_HANDLE) */\n+\t}\n+\n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+\tVMINLINE VM_BytecodeAction\n+\tinvokeBasic(REGISTER_ARGS_LIST)\n+\t{\n+\t\tVM_BytecodeAction rc = GOTO_RUN_METHOD;\n+\t\tbool fromJIT = J9_ARE_ANY_BITS_SET(_currentThread->jitStackFrameFlags, J9_SSF_JIT_NATIVE_TRANSITION_FRAME);\n+\t\tUDATA methodArgCount = 0;\n+\n+\t\tif (fromJIT) {\n+\t\t\tmethodArgCount = _currentThread->tempSlot;\n+\t\t} else {\n+\t\t\tU_16 index = *(U_16 *)(_pc + 1);\n+\t\t\tJ9ConstantPool *ramConstantPool = J9_CP_FROM_METHOD(_literals);\n+\t\t\tJ9RAMMethodRef *ramMethodRef = ((J9RAMMethodRef *)ramConstantPool) + index;\n+\t\t\tUDATA volatile methodIndexAndArgCount = ramMethodRef->methodIndexAndArgCount;\n+\t\t\tmethodArgCount = (methodIndexAndArgCount & 0xFF);\n+\t\t}\n+\n+\t\tj9object_t mhReceiver = ((j9object_t *)_sp)[methodArgCount];\n+\t\tif (J9_UNEXPECTED(NULL == mhReceiver)) {\n+\t\t\treturn THROW_NPE;\n+\t\t}\n+\n+\t\tj9object_t lambdaForm = J9VMJAVALANGINVOKEMETHODHANDLE_FORM(_currentThread, mhReceiver);\n+\t\tj9object_t memberName = J9VMJAVALANGINVOKELAMBDAFORM_VMENTRY(_currentThread, lambdaForm);\n+\t\t_sendMethod = (J9Method *)(UDATA)J9OBJECT_U64_LOAD(_currentThread, memberName, _vm->vmtargetOffset);\n+\n+\t\tif (fromJIT) {\n+\t\t\t_currentThread->jitStackFrameFlags = 0;\n+\t\t\tVM_JITInterface::restoreJITReturnAddress(_currentThread, _sp, (void *)_literals);\n+\t\t\trc = j2iTransition(REGISTER_ARGS);\n+\t\t}\n+\n+\t\treturn rc;\n+\t}\n+\n+\tVMINLINE VM_BytecodeAction\n+\tlinkToStaticSpecial(REGISTER_ARGS_LIST)\n+\t{\n+\t\tVM_BytecodeAction rc = GOTO_RUN_METHOD;\n+\t\tbool fromJIT = J9_ARE_ANY_BITS_SET(_currentThread->jitStackFrameFlags, J9_SSF_JIT_NATIVE_TRANSITION_FRAME);\n+\n+\t\t/* Pop memberNameObject from the stack. */\n+\t\tj9object_t memberNameObject = *(j9object_t *)_sp++;\n+\t\tif (J9_UNEXPECTED(NULL == memberNameObject)) {\n+\t\t\treturn THROW_NPE;\n+\t\t}\n+\n+\t\t_sendMethod = (J9Method *)(UDATA)J9OBJECT_U64_LOAD(_currentThread, memberNameObject, _vm->vmtargetOffset);\n+\n+\t\tif (fromJIT) {\n+\t\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(_sendMethod);\n+\t\t\tUDATA methodArgCount = romMethod->argCount;\n+\t\t\t/* Restore sp position before popping memberNameObject. */\n+\t\t\t--_sp;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f43a6978bcb3a63dfad417ad18bf80ac0ccd6030"}, "originalPosition": 298}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzgwMTc2NQ==", "bodyText": "Updated.", "url": "https://github.com/eclipse-openj9/openj9/pull/10733#discussion_r497801765", "createdAt": "2020-09-30T21:09:02Z", "author": {"login": "babsingh"}, "path": "runtime/vm/BytecodeInterpreter.hpp", "diffHunk": "@@ -8119,11 +8223,186 @@ class INTERPRETER_CLASS\n \t\t}\n done:\n \t\treturn rc;\n-#else\n+#else /* defined(J9VM_OPT_METHOD_HANDLE) */\n+\t/* When J9VM_OPT_OPENJDK_METHODHANDLE is enabled, MH.invoke and MH.invokeExact are\n+\t * both translated to invokehandle. So, invokehandlegeneric is not used with OpenJDK\n+\t * MethodHandles.\n+\t */\n \tAssert_VM_unreachable();\n \treturn EXECUTE_BYTECODE;\n-#endif /* J9VM_OPT_METHOD_HANDLE */\n+#endif /* defined(J9VM_OPT_METHOD_HANDLE) */\n+\t}\n+\n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+\tVMINLINE VM_BytecodeAction\n+\tinvokeBasic(REGISTER_ARGS_LIST)\n+\t{\n+\t\tVM_BytecodeAction rc = GOTO_RUN_METHOD;\n+\t\tbool fromJIT = J9_ARE_ANY_BITS_SET(_currentThread->jitStackFrameFlags, J9_SSF_JIT_NATIVE_TRANSITION_FRAME);\n+\t\tUDATA methodArgCount = 0;\n+\n+\t\tif (fromJIT) {\n+\t\t\tmethodArgCount = _currentThread->tempSlot;\n+\t\t} else {\n+\t\t\tU_16 index = *(U_16 *)(_pc + 1);\n+\t\t\tJ9ConstantPool *ramConstantPool = J9_CP_FROM_METHOD(_literals);\n+\t\t\tJ9RAMMethodRef *ramMethodRef = ((J9RAMMethodRef *)ramConstantPool) + index;\n+\t\t\tUDATA volatile methodIndexAndArgCount = ramMethodRef->methodIndexAndArgCount;\n+\t\t\tmethodArgCount = (methodIndexAndArgCount & 0xFF);\n+\t\t}\n+\n+\t\tj9object_t mhReceiver = ((j9object_t *)_sp)[methodArgCount];\n+\t\tif (J9_UNEXPECTED(NULL == mhReceiver)) {\n+\t\t\treturn THROW_NPE;\n+\t\t}\n+\n+\t\tj9object_t lambdaForm = J9VMJAVALANGINVOKEMETHODHANDLE_FORM(_currentThread, mhReceiver);\n+\t\tj9object_t memberName = J9VMJAVALANGINVOKELAMBDAFORM_VMENTRY(_currentThread, lambdaForm);\n+\t\t_sendMethod = (J9Method *)(UDATA)J9OBJECT_U64_LOAD(_currentThread, memberName, _vm->vmtargetOffset);\n+\n+\t\tif (fromJIT) {\n+\t\t\t_currentThread->jitStackFrameFlags = 0;\n+\t\t\tVM_JITInterface::restoreJITReturnAddress(_currentThread, _sp, (void *)_literals);\n+\t\t\trc = j2iTransition(REGISTER_ARGS);\n+\t\t}\n+\n+\t\treturn rc;\n+\t}\n+\n+\tVMINLINE VM_BytecodeAction\n+\tlinkToStaticSpecial(REGISTER_ARGS_LIST)\n+\t{\n+\t\tVM_BytecodeAction rc = GOTO_RUN_METHOD;\n+\t\tbool fromJIT = J9_ARE_ANY_BITS_SET(_currentThread->jitStackFrameFlags, J9_SSF_JIT_NATIVE_TRANSITION_FRAME);\n+\n+\t\t/* Pop memberNameObject from the stack. */\n+\t\tj9object_t memberNameObject = *(j9object_t *)_sp++;\n+\t\tif (J9_UNEXPECTED(NULL == memberNameObject)) {\n+\t\t\treturn THROW_NPE;\n+\t\t}\n+\n+\t\t_sendMethod = (J9Method *)(UDATA)J9OBJECT_U64_LOAD(_currentThread, memberNameObject, _vm->vmtargetOffset);\n+\n+\t\tif (fromJIT) {\n+\t\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(_sendMethod);\n+\t\t\tUDATA methodArgCount = romMethod->argCount;\n+\t\t\t/* Restore sp position before popping memberNameObject. */\n+\t\t\t--_sp;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzYxOTMwMg=="}, "originalCommit": {"oid": "f43a6978bcb3a63dfad417ad18bf80ac0ccd6030"}, "originalPosition": 298}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExNTI3Njk0OnYy", "diffSide": "RIGHT", "path": "runtime/vm/BytecodeInterpreter.hpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxNTo1MjozMlrOHakSlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQyMTowNzo1N1rOHavYDA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzYxOTYwNQ==", "bodyText": "Same comment as above.", "url": "https://github.com/eclipse-openj9/openj9/pull/10733#discussion_r497619605", "createdAt": "2020-09-30T15:52:32Z", "author": {"login": "gacholio"}, "path": "runtime/vm/BytecodeInterpreter.hpp", "diffHunk": "@@ -8119,11 +8223,186 @@ class INTERPRETER_CLASS\n \t\t}\n done:\n \t\treturn rc;\n-#else\n+#else /* defined(J9VM_OPT_METHOD_HANDLE) */\n+\t/* When J9VM_OPT_OPENJDK_METHODHANDLE is enabled, MH.invoke and MH.invokeExact are\n+\t * both translated to invokehandle. So, invokehandlegeneric is not used with OpenJDK\n+\t * MethodHandles.\n+\t */\n \tAssert_VM_unreachable();\n \treturn EXECUTE_BYTECODE;\n-#endif /* J9VM_OPT_METHOD_HANDLE */\n+#endif /* defined(J9VM_OPT_METHOD_HANDLE) */\n+\t}\n+\n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+\tVMINLINE VM_BytecodeAction\n+\tinvokeBasic(REGISTER_ARGS_LIST)\n+\t{\n+\t\tVM_BytecodeAction rc = GOTO_RUN_METHOD;\n+\t\tbool fromJIT = J9_ARE_ANY_BITS_SET(_currentThread->jitStackFrameFlags, J9_SSF_JIT_NATIVE_TRANSITION_FRAME);\n+\t\tUDATA methodArgCount = 0;\n+\n+\t\tif (fromJIT) {\n+\t\t\tmethodArgCount = _currentThread->tempSlot;\n+\t\t} else {\n+\t\t\tU_16 index = *(U_16 *)(_pc + 1);\n+\t\t\tJ9ConstantPool *ramConstantPool = J9_CP_FROM_METHOD(_literals);\n+\t\t\tJ9RAMMethodRef *ramMethodRef = ((J9RAMMethodRef *)ramConstantPool) + index;\n+\t\t\tUDATA volatile methodIndexAndArgCount = ramMethodRef->methodIndexAndArgCount;\n+\t\t\tmethodArgCount = (methodIndexAndArgCount & 0xFF);\n+\t\t}\n+\n+\t\tj9object_t mhReceiver = ((j9object_t *)_sp)[methodArgCount];\n+\t\tif (J9_UNEXPECTED(NULL == mhReceiver)) {\n+\t\t\treturn THROW_NPE;\n+\t\t}\n+\n+\t\tj9object_t lambdaForm = J9VMJAVALANGINVOKEMETHODHANDLE_FORM(_currentThread, mhReceiver);\n+\t\tj9object_t memberName = J9VMJAVALANGINVOKELAMBDAFORM_VMENTRY(_currentThread, lambdaForm);\n+\t\t_sendMethod = (J9Method *)(UDATA)J9OBJECT_U64_LOAD(_currentThread, memberName, _vm->vmtargetOffset);\n+\n+\t\tif (fromJIT) {\n+\t\t\t_currentThread->jitStackFrameFlags = 0;\n+\t\t\tVM_JITInterface::restoreJITReturnAddress(_currentThread, _sp, (void *)_literals);\n+\t\t\trc = j2iTransition(REGISTER_ARGS);\n+\t\t}\n+\n+\t\treturn rc;\n+\t}\n+\n+\tVMINLINE VM_BytecodeAction\n+\tlinkToStaticSpecial(REGISTER_ARGS_LIST)\n+\t{\n+\t\tVM_BytecodeAction rc = GOTO_RUN_METHOD;\n+\t\tbool fromJIT = J9_ARE_ANY_BITS_SET(_currentThread->jitStackFrameFlags, J9_SSF_JIT_NATIVE_TRANSITION_FRAME);\n+\n+\t\t/* Pop memberNameObject from the stack. */\n+\t\tj9object_t memberNameObject = *(j9object_t *)_sp++;\n+\t\tif (J9_UNEXPECTED(NULL == memberNameObject)) {\n+\t\t\treturn THROW_NPE;\n+\t\t}\n+\n+\t\t_sendMethod = (J9Method *)(UDATA)J9OBJECT_U64_LOAD(_currentThread, memberNameObject, _vm->vmtargetOffset);\n+\n+\t\tif (fromJIT) {\n+\t\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(_sendMethod);\n+\t\t\tUDATA methodArgCount = romMethod->argCount;\n+\t\t\t/* Restore sp position before popping memberNameObject. */\n+\t\t\t--_sp;\n+\t\t\t\n+\t\t\t/* Shift arguments by 1 and place memberNameObject before the first argument. */\n+\t\t\tmemmove(_sp, _sp + 1, methodArgCount * sizeof(UDATA));\n+\t\t\t_sp[methodArgCount] = (UDATA)memberNameObject;\n+\n+\t\t\t_currentThread->jitStackFrameFlags = 0;\n+\t\t\tVM_JITInterface::restoreJITReturnAddress(_currentThread, _sp, (void *)_literals);\n+\t\t\trc = j2iTransition(REGISTER_ARGS);\n+\t\t}\n+\n+\t\treturn rc;\n+\t}\n+\n+\tVMINLINE VM_BytecodeAction\n+\tlinkToVirtual(REGISTER_ARGS_LIST)\n+\t{\n+\t\tVM_BytecodeAction rc = GOTO_RUN_METHOD;\n+\t\tbool fromJIT = J9_ARE_ANY_BITS_SET(_currentThread->jitStackFrameFlags, J9_SSF_JIT_NATIVE_TRANSITION_FRAME);\n+\n+\t\t/* Pop memberNameObject from the stack. */\n+\t\tj9object_t memberNameObject = *(j9object_t *)_sp++;\n+\t\tif (J9_UNEXPECTED(NULL == memberNameObject)) {\n+\t\t\treturn THROW_NPE;\n+\t\t}\n+\n+\t\tJ9JNIMethodID *methodID = (J9JNIMethodID *)(UDATA)J9OBJECT_U64_LOAD(_currentThread, memberNameObject, _vm->vmindexOffset);\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\t\tUDATA methodArgCount = romMethod->argCount;\n+\n+\t\tj9object_t receiverObject = ((j9object_t *)_sp)[methodArgCount - 1];\n+\t\tif (J9_UNEXPECTED(NULL == receiverObject)) {\n+\t\t\treturn THROW_NPE;\n+\t\t}\n+\t\tJ9Class *receiverClass = J9OBJECT_CLAZZ(currentThread, receiverObject);\n+\t\t_sendMethod = *(J9Method **)(((UDATA)receiverClass) + methodID->vTableIndex);\n+\n+\t\tif (fromJIT) {\n+\t\t\t/* Restore sp position before popping memberNameObject. */\n+\t\t\t--_sp;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f43a6978bcb3a63dfad417ad18bf80ac0ccd6030"}, "originalPosition": 337}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzgwMTIyOA==", "bodyText": "Updated.", "url": "https://github.com/eclipse-openj9/openj9/pull/10733#discussion_r497801228", "createdAt": "2020-09-30T21:07:57Z", "author": {"login": "babsingh"}, "path": "runtime/vm/BytecodeInterpreter.hpp", "diffHunk": "@@ -8119,11 +8223,186 @@ class INTERPRETER_CLASS\n \t\t}\n done:\n \t\treturn rc;\n-#else\n+#else /* defined(J9VM_OPT_METHOD_HANDLE) */\n+\t/* When J9VM_OPT_OPENJDK_METHODHANDLE is enabled, MH.invoke and MH.invokeExact are\n+\t * both translated to invokehandle. So, invokehandlegeneric is not used with OpenJDK\n+\t * MethodHandles.\n+\t */\n \tAssert_VM_unreachable();\n \treturn EXECUTE_BYTECODE;\n-#endif /* J9VM_OPT_METHOD_HANDLE */\n+#endif /* defined(J9VM_OPT_METHOD_HANDLE) */\n+\t}\n+\n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+\tVMINLINE VM_BytecodeAction\n+\tinvokeBasic(REGISTER_ARGS_LIST)\n+\t{\n+\t\tVM_BytecodeAction rc = GOTO_RUN_METHOD;\n+\t\tbool fromJIT = J9_ARE_ANY_BITS_SET(_currentThread->jitStackFrameFlags, J9_SSF_JIT_NATIVE_TRANSITION_FRAME);\n+\t\tUDATA methodArgCount = 0;\n+\n+\t\tif (fromJIT) {\n+\t\t\tmethodArgCount = _currentThread->tempSlot;\n+\t\t} else {\n+\t\t\tU_16 index = *(U_16 *)(_pc + 1);\n+\t\t\tJ9ConstantPool *ramConstantPool = J9_CP_FROM_METHOD(_literals);\n+\t\t\tJ9RAMMethodRef *ramMethodRef = ((J9RAMMethodRef *)ramConstantPool) + index;\n+\t\t\tUDATA volatile methodIndexAndArgCount = ramMethodRef->methodIndexAndArgCount;\n+\t\t\tmethodArgCount = (methodIndexAndArgCount & 0xFF);\n+\t\t}\n+\n+\t\tj9object_t mhReceiver = ((j9object_t *)_sp)[methodArgCount];\n+\t\tif (J9_UNEXPECTED(NULL == mhReceiver)) {\n+\t\t\treturn THROW_NPE;\n+\t\t}\n+\n+\t\tj9object_t lambdaForm = J9VMJAVALANGINVOKEMETHODHANDLE_FORM(_currentThread, mhReceiver);\n+\t\tj9object_t memberName = J9VMJAVALANGINVOKELAMBDAFORM_VMENTRY(_currentThread, lambdaForm);\n+\t\t_sendMethod = (J9Method *)(UDATA)J9OBJECT_U64_LOAD(_currentThread, memberName, _vm->vmtargetOffset);\n+\n+\t\tif (fromJIT) {\n+\t\t\t_currentThread->jitStackFrameFlags = 0;\n+\t\t\tVM_JITInterface::restoreJITReturnAddress(_currentThread, _sp, (void *)_literals);\n+\t\t\trc = j2iTransition(REGISTER_ARGS);\n+\t\t}\n+\n+\t\treturn rc;\n+\t}\n+\n+\tVMINLINE VM_BytecodeAction\n+\tlinkToStaticSpecial(REGISTER_ARGS_LIST)\n+\t{\n+\t\tVM_BytecodeAction rc = GOTO_RUN_METHOD;\n+\t\tbool fromJIT = J9_ARE_ANY_BITS_SET(_currentThread->jitStackFrameFlags, J9_SSF_JIT_NATIVE_TRANSITION_FRAME);\n+\n+\t\t/* Pop memberNameObject from the stack. */\n+\t\tj9object_t memberNameObject = *(j9object_t *)_sp++;\n+\t\tif (J9_UNEXPECTED(NULL == memberNameObject)) {\n+\t\t\treturn THROW_NPE;\n+\t\t}\n+\n+\t\t_sendMethod = (J9Method *)(UDATA)J9OBJECT_U64_LOAD(_currentThread, memberNameObject, _vm->vmtargetOffset);\n+\n+\t\tif (fromJIT) {\n+\t\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(_sendMethod);\n+\t\t\tUDATA methodArgCount = romMethod->argCount;\n+\t\t\t/* Restore sp position before popping memberNameObject. */\n+\t\t\t--_sp;\n+\t\t\t\n+\t\t\t/* Shift arguments by 1 and place memberNameObject before the first argument. */\n+\t\t\tmemmove(_sp, _sp + 1, methodArgCount * sizeof(UDATA));\n+\t\t\t_sp[methodArgCount] = (UDATA)memberNameObject;\n+\n+\t\t\t_currentThread->jitStackFrameFlags = 0;\n+\t\t\tVM_JITInterface::restoreJITReturnAddress(_currentThread, _sp, (void *)_literals);\n+\t\t\trc = j2iTransition(REGISTER_ARGS);\n+\t\t}\n+\n+\t\treturn rc;\n+\t}\n+\n+\tVMINLINE VM_BytecodeAction\n+\tlinkToVirtual(REGISTER_ARGS_LIST)\n+\t{\n+\t\tVM_BytecodeAction rc = GOTO_RUN_METHOD;\n+\t\tbool fromJIT = J9_ARE_ANY_BITS_SET(_currentThread->jitStackFrameFlags, J9_SSF_JIT_NATIVE_TRANSITION_FRAME);\n+\n+\t\t/* Pop memberNameObject from the stack. */\n+\t\tj9object_t memberNameObject = *(j9object_t *)_sp++;\n+\t\tif (J9_UNEXPECTED(NULL == memberNameObject)) {\n+\t\t\treturn THROW_NPE;\n+\t\t}\n+\n+\t\tJ9JNIMethodID *methodID = (J9JNIMethodID *)(UDATA)J9OBJECT_U64_LOAD(_currentThread, memberNameObject, _vm->vmindexOffset);\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\t\tUDATA methodArgCount = romMethod->argCount;\n+\n+\t\tj9object_t receiverObject = ((j9object_t *)_sp)[methodArgCount - 1];\n+\t\tif (J9_UNEXPECTED(NULL == receiverObject)) {\n+\t\t\treturn THROW_NPE;\n+\t\t}\n+\t\tJ9Class *receiverClass = J9OBJECT_CLAZZ(currentThread, receiverObject);\n+\t\t_sendMethod = *(J9Method **)(((UDATA)receiverClass) + methodID->vTableIndex);\n+\n+\t\tif (fromJIT) {\n+\t\t\t/* Restore sp position before popping memberNameObject. */\n+\t\t\t--_sp;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzYxOTYwNQ=="}, "originalCommit": {"oid": "f43a6978bcb3a63dfad417ad18bf80ac0ccd6030"}, "originalPosition": 337}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExNTI3ODQxOnYy", "diffSide": "RIGHT", "path": "runtime/vm/BytecodeInterpreter.hpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxNTo1Mjo1MVrOHakTeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQyMTowODoyN1rOHavZEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzYxOTgzMw==", "bodyText": "Extra line.", "url": "https://github.com/eclipse-openj9/openj9/pull/10733#discussion_r497619833", "createdAt": "2020-09-30T15:52:51Z", "author": {"login": "gacholio"}, "path": "runtime/vm/BytecodeInterpreter.hpp", "diffHunk": "@@ -8119,11 +8223,186 @@ class INTERPRETER_CLASS\n \t\t}\n done:\n \t\treturn rc;\n-#else\n+#else /* defined(J9VM_OPT_METHOD_HANDLE) */\n+\t/* When J9VM_OPT_OPENJDK_METHODHANDLE is enabled, MH.invoke and MH.invokeExact are\n+\t * both translated to invokehandle. So, invokehandlegeneric is not used with OpenJDK\n+\t * MethodHandles.\n+\t */\n \tAssert_VM_unreachable();\n \treturn EXECUTE_BYTECODE;\n-#endif /* J9VM_OPT_METHOD_HANDLE */\n+#endif /* defined(J9VM_OPT_METHOD_HANDLE) */\n+\t}\n+\n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+\tVMINLINE VM_BytecodeAction\n+\tinvokeBasic(REGISTER_ARGS_LIST)\n+\t{\n+\t\tVM_BytecodeAction rc = GOTO_RUN_METHOD;\n+\t\tbool fromJIT = J9_ARE_ANY_BITS_SET(_currentThread->jitStackFrameFlags, J9_SSF_JIT_NATIVE_TRANSITION_FRAME);\n+\t\tUDATA methodArgCount = 0;\n+\n+\t\tif (fromJIT) {\n+\t\t\tmethodArgCount = _currentThread->tempSlot;\n+\t\t} else {\n+\t\t\tU_16 index = *(U_16 *)(_pc + 1);\n+\t\t\tJ9ConstantPool *ramConstantPool = J9_CP_FROM_METHOD(_literals);\n+\t\t\tJ9RAMMethodRef *ramMethodRef = ((J9RAMMethodRef *)ramConstantPool) + index;\n+\t\t\tUDATA volatile methodIndexAndArgCount = ramMethodRef->methodIndexAndArgCount;\n+\t\t\tmethodArgCount = (methodIndexAndArgCount & 0xFF);\n+\t\t}\n+\n+\t\tj9object_t mhReceiver = ((j9object_t *)_sp)[methodArgCount];\n+\t\tif (J9_UNEXPECTED(NULL == mhReceiver)) {\n+\t\t\treturn THROW_NPE;\n+\t\t}\n+\n+\t\tj9object_t lambdaForm = J9VMJAVALANGINVOKEMETHODHANDLE_FORM(_currentThread, mhReceiver);\n+\t\tj9object_t memberName = J9VMJAVALANGINVOKELAMBDAFORM_VMENTRY(_currentThread, lambdaForm);\n+\t\t_sendMethod = (J9Method *)(UDATA)J9OBJECT_U64_LOAD(_currentThread, memberName, _vm->vmtargetOffset);\n+\n+\t\tif (fromJIT) {\n+\t\t\t_currentThread->jitStackFrameFlags = 0;\n+\t\t\tVM_JITInterface::restoreJITReturnAddress(_currentThread, _sp, (void *)_literals);\n+\t\t\trc = j2iTransition(REGISTER_ARGS);\n+\t\t}\n+\n+\t\treturn rc;\n+\t}\n+\n+\tVMINLINE VM_BytecodeAction\n+\tlinkToStaticSpecial(REGISTER_ARGS_LIST)\n+\t{\n+\t\tVM_BytecodeAction rc = GOTO_RUN_METHOD;\n+\t\tbool fromJIT = J9_ARE_ANY_BITS_SET(_currentThread->jitStackFrameFlags, J9_SSF_JIT_NATIVE_TRANSITION_FRAME);\n+\n+\t\t/* Pop memberNameObject from the stack. */\n+\t\tj9object_t memberNameObject = *(j9object_t *)_sp++;\n+\t\tif (J9_UNEXPECTED(NULL == memberNameObject)) {\n+\t\t\treturn THROW_NPE;\n+\t\t}\n+\n+\t\t_sendMethod = (J9Method *)(UDATA)J9OBJECT_U64_LOAD(_currentThread, memberNameObject, _vm->vmtargetOffset);\n+\n+\t\tif (fromJIT) {\n+\t\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(_sendMethod);\n+\t\t\tUDATA methodArgCount = romMethod->argCount;\n+\t\t\t/* Restore sp position before popping memberNameObject. */\n+\t\t\t--_sp;\n+\t\t\t\n+\t\t\t/* Shift arguments by 1 and place memberNameObject before the first argument. */\n+\t\t\tmemmove(_sp, _sp + 1, methodArgCount * sizeof(UDATA));\n+\t\t\t_sp[methodArgCount] = (UDATA)memberNameObject;\n+\n+\t\t\t_currentThread->jitStackFrameFlags = 0;\n+\t\t\tVM_JITInterface::restoreJITReturnAddress(_currentThread, _sp, (void *)_literals);\n+\t\t\trc = j2iTransition(REGISTER_ARGS);\n+\t\t}\n+\n+\t\treturn rc;\n+\t}\n+\n+\tVMINLINE VM_BytecodeAction\n+\tlinkToVirtual(REGISTER_ARGS_LIST)\n+\t{\n+\t\tVM_BytecodeAction rc = GOTO_RUN_METHOD;\n+\t\tbool fromJIT = J9_ARE_ANY_BITS_SET(_currentThread->jitStackFrameFlags, J9_SSF_JIT_NATIVE_TRANSITION_FRAME);\n+\n+\t\t/* Pop memberNameObject from the stack. */\n+\t\tj9object_t memberNameObject = *(j9object_t *)_sp++;\n+\t\tif (J9_UNEXPECTED(NULL == memberNameObject)) {\n+\t\t\treturn THROW_NPE;\n+\t\t}\n+\n+\t\tJ9JNIMethodID *methodID = (J9JNIMethodID *)(UDATA)J9OBJECT_U64_LOAD(_currentThread, memberNameObject, _vm->vmindexOffset);\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\t\tUDATA methodArgCount = romMethod->argCount;\n+\n+\t\tj9object_t receiverObject = ((j9object_t *)_sp)[methodArgCount - 1];\n+\t\tif (J9_UNEXPECTED(NULL == receiverObject)) {\n+\t\t\treturn THROW_NPE;\n+\t\t}\n+\t\tJ9Class *receiverClass = J9OBJECT_CLAZZ(currentThread, receiverObject);\n+\t\t_sendMethod = *(J9Method **)(((UDATA)receiverClass) + methodID->vTableIndex);\n+\n+\t\tif (fromJIT) {\n+\t\t\t/* Restore sp position before popping memberNameObject. */\n+\t\t\t--_sp;\n+\t\t\t\n+\t\t\t/* Shift arguments by 1 and place memberNameObject before the first argument. */\n+\t\t\tmemmove(_sp, _sp + 1, methodArgCount * sizeof(UDATA));\n+\t\t\t_sp[methodArgCount] = (UDATA)memberNameObject;\n+\n+\t\t\t_currentThread->jitStackFrameFlags = 0;\n+\t\t\tVM_JITInterface::restoreJITReturnAddress(_currentThread, _sp, (void *)_literals);\n+\t\t\trc = j2iTransition(REGISTER_ARGS);\n+\t\t}\n+\n+\t\treturn rc;\n+\t}\n+\n+\tVMINLINE VM_BytecodeAction\n+\tlinkToInterface(REGISTER_ARGS_LIST)\n+\t{\n+\t\tVM_BytecodeAction rc = GOTO_RUN_METHOD;\n+\t\tbool fromJIT = J9_ARE_ANY_BITS_SET(_currentThread->jitStackFrameFlags, J9_SSF_JIT_NATIVE_TRANSITION_FRAME);\n+\n+\t\t/* Pop memberNameObject from the stack. */\n+\t\tj9object_t memberNameObject = *(j9object_t *)_sp++;\n+\t\tif (J9_UNEXPECTED(NULL == memberNameObject)) {\n+\t\t\treturn THROW_NPE;\n+\t\t}\n+\n+\t\tJ9JNIMethodID *methodID = (J9JNIMethodID *)(UDATA)J9OBJECT_U64_LOAD(_currentThread, memberNameObject, _vm->vmindexOffset);\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\t\tUDATA methodArgCount = romMethod->argCount;\n+\n+\t\tj9object_t receiverObject = ((j9object_t *)_sp)[methodArgCount - 1];\n+\t\tif (J9_UNEXPECTED(NULL == receiverObject)) {\n+\t\t\treturn THROW_NPE;\n+\t\t}\n+\t\tJ9Class *receiverClass = J9OBJECT_CLAZZ(currentThread, receiverObject);\n+\t\tJ9Method *method = (J9Method *)(UDATA)J9OBJECT_U64_LOAD(_currentThread, memberNameObject, _vm->vmtargetOffset);\n+\t\tUDATA vTableOffset = methodID->vTableIndex;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f43a6978bcb3a63dfad417ad18bf80ac0ccd6030"}, "originalPosition": 374}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzgwMTQ4OA==", "bodyText": "Updated.", "url": "https://github.com/eclipse-openj9/openj9/pull/10733#discussion_r497801488", "createdAt": "2020-09-30T21:08:27Z", "author": {"login": "babsingh"}, "path": "runtime/vm/BytecodeInterpreter.hpp", "diffHunk": "@@ -8119,11 +8223,186 @@ class INTERPRETER_CLASS\n \t\t}\n done:\n \t\treturn rc;\n-#else\n+#else /* defined(J9VM_OPT_METHOD_HANDLE) */\n+\t/* When J9VM_OPT_OPENJDK_METHODHANDLE is enabled, MH.invoke and MH.invokeExact are\n+\t * both translated to invokehandle. So, invokehandlegeneric is not used with OpenJDK\n+\t * MethodHandles.\n+\t */\n \tAssert_VM_unreachable();\n \treturn EXECUTE_BYTECODE;\n-#endif /* J9VM_OPT_METHOD_HANDLE */\n+#endif /* defined(J9VM_OPT_METHOD_HANDLE) */\n+\t}\n+\n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+\tVMINLINE VM_BytecodeAction\n+\tinvokeBasic(REGISTER_ARGS_LIST)\n+\t{\n+\t\tVM_BytecodeAction rc = GOTO_RUN_METHOD;\n+\t\tbool fromJIT = J9_ARE_ANY_BITS_SET(_currentThread->jitStackFrameFlags, J9_SSF_JIT_NATIVE_TRANSITION_FRAME);\n+\t\tUDATA methodArgCount = 0;\n+\n+\t\tif (fromJIT) {\n+\t\t\tmethodArgCount = _currentThread->tempSlot;\n+\t\t} else {\n+\t\t\tU_16 index = *(U_16 *)(_pc + 1);\n+\t\t\tJ9ConstantPool *ramConstantPool = J9_CP_FROM_METHOD(_literals);\n+\t\t\tJ9RAMMethodRef *ramMethodRef = ((J9RAMMethodRef *)ramConstantPool) + index;\n+\t\t\tUDATA volatile methodIndexAndArgCount = ramMethodRef->methodIndexAndArgCount;\n+\t\t\tmethodArgCount = (methodIndexAndArgCount & 0xFF);\n+\t\t}\n+\n+\t\tj9object_t mhReceiver = ((j9object_t *)_sp)[methodArgCount];\n+\t\tif (J9_UNEXPECTED(NULL == mhReceiver)) {\n+\t\t\treturn THROW_NPE;\n+\t\t}\n+\n+\t\tj9object_t lambdaForm = J9VMJAVALANGINVOKEMETHODHANDLE_FORM(_currentThread, mhReceiver);\n+\t\tj9object_t memberName = J9VMJAVALANGINVOKELAMBDAFORM_VMENTRY(_currentThread, lambdaForm);\n+\t\t_sendMethod = (J9Method *)(UDATA)J9OBJECT_U64_LOAD(_currentThread, memberName, _vm->vmtargetOffset);\n+\n+\t\tif (fromJIT) {\n+\t\t\t_currentThread->jitStackFrameFlags = 0;\n+\t\t\tVM_JITInterface::restoreJITReturnAddress(_currentThread, _sp, (void *)_literals);\n+\t\t\trc = j2iTransition(REGISTER_ARGS);\n+\t\t}\n+\n+\t\treturn rc;\n+\t}\n+\n+\tVMINLINE VM_BytecodeAction\n+\tlinkToStaticSpecial(REGISTER_ARGS_LIST)\n+\t{\n+\t\tVM_BytecodeAction rc = GOTO_RUN_METHOD;\n+\t\tbool fromJIT = J9_ARE_ANY_BITS_SET(_currentThread->jitStackFrameFlags, J9_SSF_JIT_NATIVE_TRANSITION_FRAME);\n+\n+\t\t/* Pop memberNameObject from the stack. */\n+\t\tj9object_t memberNameObject = *(j9object_t *)_sp++;\n+\t\tif (J9_UNEXPECTED(NULL == memberNameObject)) {\n+\t\t\treturn THROW_NPE;\n+\t\t}\n+\n+\t\t_sendMethod = (J9Method *)(UDATA)J9OBJECT_U64_LOAD(_currentThread, memberNameObject, _vm->vmtargetOffset);\n+\n+\t\tif (fromJIT) {\n+\t\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(_sendMethod);\n+\t\t\tUDATA methodArgCount = romMethod->argCount;\n+\t\t\t/* Restore sp position before popping memberNameObject. */\n+\t\t\t--_sp;\n+\t\t\t\n+\t\t\t/* Shift arguments by 1 and place memberNameObject before the first argument. */\n+\t\t\tmemmove(_sp, _sp + 1, methodArgCount * sizeof(UDATA));\n+\t\t\t_sp[methodArgCount] = (UDATA)memberNameObject;\n+\n+\t\t\t_currentThread->jitStackFrameFlags = 0;\n+\t\t\tVM_JITInterface::restoreJITReturnAddress(_currentThread, _sp, (void *)_literals);\n+\t\t\trc = j2iTransition(REGISTER_ARGS);\n+\t\t}\n+\n+\t\treturn rc;\n+\t}\n+\n+\tVMINLINE VM_BytecodeAction\n+\tlinkToVirtual(REGISTER_ARGS_LIST)\n+\t{\n+\t\tVM_BytecodeAction rc = GOTO_RUN_METHOD;\n+\t\tbool fromJIT = J9_ARE_ANY_BITS_SET(_currentThread->jitStackFrameFlags, J9_SSF_JIT_NATIVE_TRANSITION_FRAME);\n+\n+\t\t/* Pop memberNameObject from the stack. */\n+\t\tj9object_t memberNameObject = *(j9object_t *)_sp++;\n+\t\tif (J9_UNEXPECTED(NULL == memberNameObject)) {\n+\t\t\treturn THROW_NPE;\n+\t\t}\n+\n+\t\tJ9JNIMethodID *methodID = (J9JNIMethodID *)(UDATA)J9OBJECT_U64_LOAD(_currentThread, memberNameObject, _vm->vmindexOffset);\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\t\tUDATA methodArgCount = romMethod->argCount;\n+\n+\t\tj9object_t receiverObject = ((j9object_t *)_sp)[methodArgCount - 1];\n+\t\tif (J9_UNEXPECTED(NULL == receiverObject)) {\n+\t\t\treturn THROW_NPE;\n+\t\t}\n+\t\tJ9Class *receiverClass = J9OBJECT_CLAZZ(currentThread, receiverObject);\n+\t\t_sendMethod = *(J9Method **)(((UDATA)receiverClass) + methodID->vTableIndex);\n+\n+\t\tif (fromJIT) {\n+\t\t\t/* Restore sp position before popping memberNameObject. */\n+\t\t\t--_sp;\n+\t\t\t\n+\t\t\t/* Shift arguments by 1 and place memberNameObject before the first argument. */\n+\t\t\tmemmove(_sp, _sp + 1, methodArgCount * sizeof(UDATA));\n+\t\t\t_sp[methodArgCount] = (UDATA)memberNameObject;\n+\n+\t\t\t_currentThread->jitStackFrameFlags = 0;\n+\t\t\tVM_JITInterface::restoreJITReturnAddress(_currentThread, _sp, (void *)_literals);\n+\t\t\trc = j2iTransition(REGISTER_ARGS);\n+\t\t}\n+\n+\t\treturn rc;\n+\t}\n+\n+\tVMINLINE VM_BytecodeAction\n+\tlinkToInterface(REGISTER_ARGS_LIST)\n+\t{\n+\t\tVM_BytecodeAction rc = GOTO_RUN_METHOD;\n+\t\tbool fromJIT = J9_ARE_ANY_BITS_SET(_currentThread->jitStackFrameFlags, J9_SSF_JIT_NATIVE_TRANSITION_FRAME);\n+\n+\t\t/* Pop memberNameObject from the stack. */\n+\t\tj9object_t memberNameObject = *(j9object_t *)_sp++;\n+\t\tif (J9_UNEXPECTED(NULL == memberNameObject)) {\n+\t\t\treturn THROW_NPE;\n+\t\t}\n+\n+\t\tJ9JNIMethodID *methodID = (J9JNIMethodID *)(UDATA)J9OBJECT_U64_LOAD(_currentThread, memberNameObject, _vm->vmindexOffset);\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\t\tUDATA methodArgCount = romMethod->argCount;\n+\n+\t\tj9object_t receiverObject = ((j9object_t *)_sp)[methodArgCount - 1];\n+\t\tif (J9_UNEXPECTED(NULL == receiverObject)) {\n+\t\t\treturn THROW_NPE;\n+\t\t}\n+\t\tJ9Class *receiverClass = J9OBJECT_CLAZZ(currentThread, receiverObject);\n+\t\tJ9Method *method = (J9Method *)(UDATA)J9OBJECT_U64_LOAD(_currentThread, memberNameObject, _vm->vmtargetOffset);\n+\t\tUDATA vTableOffset = methodID->vTableIndex;\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzYxOTgzMw=="}, "originalCommit": {"oid": "f43a6978bcb3a63dfad417ad18bf80ac0ccd6030"}, "originalPosition": 374}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExNTI4Mjg2OnYy", "diffSide": "RIGHT", "path": "runtime/vm/BytecodeInterpreter.hpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxNTo1Mzo1N1rOHakWUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQyMTowODo1MFrOHavZzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzYyMDU2Mw==", "bodyText": "And again.", "url": "https://github.com/eclipse-openj9/openj9/pull/10733#discussion_r497620563", "createdAt": "2020-09-30T15:53:57Z", "author": {"login": "gacholio"}, "path": "runtime/vm/BytecodeInterpreter.hpp", "diffHunk": "@@ -8119,11 +8223,186 @@ class INTERPRETER_CLASS\n \t\t}\n done:\n \t\treturn rc;\n-#else\n+#else /* defined(J9VM_OPT_METHOD_HANDLE) */\n+\t/* When J9VM_OPT_OPENJDK_METHODHANDLE is enabled, MH.invoke and MH.invokeExact are\n+\t * both translated to invokehandle. So, invokehandlegeneric is not used with OpenJDK\n+\t * MethodHandles.\n+\t */\n \tAssert_VM_unreachable();\n \treturn EXECUTE_BYTECODE;\n-#endif /* J9VM_OPT_METHOD_HANDLE */\n+#endif /* defined(J9VM_OPT_METHOD_HANDLE) */\n+\t}\n+\n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+\tVMINLINE VM_BytecodeAction\n+\tinvokeBasic(REGISTER_ARGS_LIST)\n+\t{\n+\t\tVM_BytecodeAction rc = GOTO_RUN_METHOD;\n+\t\tbool fromJIT = J9_ARE_ANY_BITS_SET(_currentThread->jitStackFrameFlags, J9_SSF_JIT_NATIVE_TRANSITION_FRAME);\n+\t\tUDATA methodArgCount = 0;\n+\n+\t\tif (fromJIT) {\n+\t\t\tmethodArgCount = _currentThread->tempSlot;\n+\t\t} else {\n+\t\t\tU_16 index = *(U_16 *)(_pc + 1);\n+\t\t\tJ9ConstantPool *ramConstantPool = J9_CP_FROM_METHOD(_literals);\n+\t\t\tJ9RAMMethodRef *ramMethodRef = ((J9RAMMethodRef *)ramConstantPool) + index;\n+\t\t\tUDATA volatile methodIndexAndArgCount = ramMethodRef->methodIndexAndArgCount;\n+\t\t\tmethodArgCount = (methodIndexAndArgCount & 0xFF);\n+\t\t}\n+\n+\t\tj9object_t mhReceiver = ((j9object_t *)_sp)[methodArgCount];\n+\t\tif (J9_UNEXPECTED(NULL == mhReceiver)) {\n+\t\t\treturn THROW_NPE;\n+\t\t}\n+\n+\t\tj9object_t lambdaForm = J9VMJAVALANGINVOKEMETHODHANDLE_FORM(_currentThread, mhReceiver);\n+\t\tj9object_t memberName = J9VMJAVALANGINVOKELAMBDAFORM_VMENTRY(_currentThread, lambdaForm);\n+\t\t_sendMethod = (J9Method *)(UDATA)J9OBJECT_U64_LOAD(_currentThread, memberName, _vm->vmtargetOffset);\n+\n+\t\tif (fromJIT) {\n+\t\t\t_currentThread->jitStackFrameFlags = 0;\n+\t\t\tVM_JITInterface::restoreJITReturnAddress(_currentThread, _sp, (void *)_literals);\n+\t\t\trc = j2iTransition(REGISTER_ARGS);\n+\t\t}\n+\n+\t\treturn rc;\n+\t}\n+\n+\tVMINLINE VM_BytecodeAction\n+\tlinkToStaticSpecial(REGISTER_ARGS_LIST)\n+\t{\n+\t\tVM_BytecodeAction rc = GOTO_RUN_METHOD;\n+\t\tbool fromJIT = J9_ARE_ANY_BITS_SET(_currentThread->jitStackFrameFlags, J9_SSF_JIT_NATIVE_TRANSITION_FRAME);\n+\n+\t\t/* Pop memberNameObject from the stack. */\n+\t\tj9object_t memberNameObject = *(j9object_t *)_sp++;\n+\t\tif (J9_UNEXPECTED(NULL == memberNameObject)) {\n+\t\t\treturn THROW_NPE;\n+\t\t}\n+\n+\t\t_sendMethod = (J9Method *)(UDATA)J9OBJECT_U64_LOAD(_currentThread, memberNameObject, _vm->vmtargetOffset);\n+\n+\t\tif (fromJIT) {\n+\t\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(_sendMethod);\n+\t\t\tUDATA methodArgCount = romMethod->argCount;\n+\t\t\t/* Restore sp position before popping memberNameObject. */\n+\t\t\t--_sp;\n+\t\t\t\n+\t\t\t/* Shift arguments by 1 and place memberNameObject before the first argument. */\n+\t\t\tmemmove(_sp, _sp + 1, methodArgCount * sizeof(UDATA));\n+\t\t\t_sp[methodArgCount] = (UDATA)memberNameObject;\n+\n+\t\t\t_currentThread->jitStackFrameFlags = 0;\n+\t\t\tVM_JITInterface::restoreJITReturnAddress(_currentThread, _sp, (void *)_literals);\n+\t\t\trc = j2iTransition(REGISTER_ARGS);\n+\t\t}\n+\n+\t\treturn rc;\n+\t}\n+\n+\tVMINLINE VM_BytecodeAction\n+\tlinkToVirtual(REGISTER_ARGS_LIST)\n+\t{\n+\t\tVM_BytecodeAction rc = GOTO_RUN_METHOD;\n+\t\tbool fromJIT = J9_ARE_ANY_BITS_SET(_currentThread->jitStackFrameFlags, J9_SSF_JIT_NATIVE_TRANSITION_FRAME);\n+\n+\t\t/* Pop memberNameObject from the stack. */\n+\t\tj9object_t memberNameObject = *(j9object_t *)_sp++;\n+\t\tif (J9_UNEXPECTED(NULL == memberNameObject)) {\n+\t\t\treturn THROW_NPE;\n+\t\t}\n+\n+\t\tJ9JNIMethodID *methodID = (J9JNIMethodID *)(UDATA)J9OBJECT_U64_LOAD(_currentThread, memberNameObject, _vm->vmindexOffset);\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\t\tUDATA methodArgCount = romMethod->argCount;\n+\n+\t\tj9object_t receiverObject = ((j9object_t *)_sp)[methodArgCount - 1];\n+\t\tif (J9_UNEXPECTED(NULL == receiverObject)) {\n+\t\t\treturn THROW_NPE;\n+\t\t}\n+\t\tJ9Class *receiverClass = J9OBJECT_CLAZZ(currentThread, receiverObject);\n+\t\t_sendMethod = *(J9Method **)(((UDATA)receiverClass) + methodID->vTableIndex);\n+\n+\t\tif (fromJIT) {\n+\t\t\t/* Restore sp position before popping memberNameObject. */\n+\t\t\t--_sp;\n+\t\t\t\n+\t\t\t/* Shift arguments by 1 and place memberNameObject before the first argument. */\n+\t\t\tmemmove(_sp, _sp + 1, methodArgCount * sizeof(UDATA));\n+\t\t\t_sp[methodArgCount] = (UDATA)memberNameObject;\n+\n+\t\t\t_currentThread->jitStackFrameFlags = 0;\n+\t\t\tVM_JITInterface::restoreJITReturnAddress(_currentThread, _sp, (void *)_literals);\n+\t\t\trc = j2iTransition(REGISTER_ARGS);\n+\t\t}\n+\n+\t\treturn rc;\n+\t}\n+\n+\tVMINLINE VM_BytecodeAction\n+\tlinkToInterface(REGISTER_ARGS_LIST)\n+\t{\n+\t\tVM_BytecodeAction rc = GOTO_RUN_METHOD;\n+\t\tbool fromJIT = J9_ARE_ANY_BITS_SET(_currentThread->jitStackFrameFlags, J9_SSF_JIT_NATIVE_TRANSITION_FRAME);\n+\n+\t\t/* Pop memberNameObject from the stack. */\n+\t\tj9object_t memberNameObject = *(j9object_t *)_sp++;\n+\t\tif (J9_UNEXPECTED(NULL == memberNameObject)) {\n+\t\t\treturn THROW_NPE;\n+\t\t}\n+\n+\t\tJ9JNIMethodID *methodID = (J9JNIMethodID *)(UDATA)J9OBJECT_U64_LOAD(_currentThread, memberNameObject, _vm->vmindexOffset);\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\t\tUDATA methodArgCount = romMethod->argCount;\n+\n+\t\tj9object_t receiverObject = ((j9object_t *)_sp)[methodArgCount - 1];\n+\t\tif (J9_UNEXPECTED(NULL == receiverObject)) {\n+\t\t\treturn THROW_NPE;\n+\t\t}\n+\t\tJ9Class *receiverClass = J9OBJECT_CLAZZ(currentThread, receiverObject);\n+\t\tJ9Method *method = (J9Method *)(UDATA)J9OBJECT_U64_LOAD(_currentThread, memberNameObject, _vm->vmtargetOffset);\n+\t\tUDATA vTableOffset = methodID->vTableIndex;\n+\n+\n+\t\tif (J9_ARE_ANY_BITS_SET(vTableOffset, J9_JNI_MID_INTERFACE)) {\n+\t\t\tUDATA iTableIndex = vTableOffset & ~(UDATA)J9_JNI_MID_INTERFACE;\n+\t\t\tJ9Class *interfaceClass = J9_CLASS_FROM_METHOD(method);\n+\t\t\tvTableOffset = 0;\n+\t\t\tJ9ITable * iTable = receiverClass->lastITable;\n+\t\t\tif (interfaceClass == iTable->interfaceClass) {\n+\t\t\t\tgoto foundITable;\n+\t\t\t}\n+\t\t\tiTable = (J9ITable*)receiverClass->iTable;\n+\t\t\twhile (NULL != iTable) {\n+\t\t\t\tif (interfaceClass == iTable->interfaceClass) {\n+\t\t\t\t\treceiverClass->lastITable = iTable;\n+foundITable:\n+\t\t\t\t\tvTableOffset = ((UDATA*)(iTable + 1))[iTableIndex];\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t\tiTable = iTable->next;\n+\t\t\t}\n+\t\t}\n+\n+\t\t_sendMethod = *(J9Method **)(((UDATA)receiverClass) + vTableOffset);\n+\n+\t\tif (fromJIT) {\n+\t\t\t/* Restore sp position before popping memberNameObject. */\n+\t\t\t--_sp;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f43a6978bcb3a63dfad417ad18bf80ac0ccd6030"}, "originalPosition": 400}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzgwMTY3OA==", "bodyText": "Updated.", "url": "https://github.com/eclipse-openj9/openj9/pull/10733#discussion_r497801678", "createdAt": "2020-09-30T21:08:50Z", "author": {"login": "babsingh"}, "path": "runtime/vm/BytecodeInterpreter.hpp", "diffHunk": "@@ -8119,11 +8223,186 @@ class INTERPRETER_CLASS\n \t\t}\n done:\n \t\treturn rc;\n-#else\n+#else /* defined(J9VM_OPT_METHOD_HANDLE) */\n+\t/* When J9VM_OPT_OPENJDK_METHODHANDLE is enabled, MH.invoke and MH.invokeExact are\n+\t * both translated to invokehandle. So, invokehandlegeneric is not used with OpenJDK\n+\t * MethodHandles.\n+\t */\n \tAssert_VM_unreachable();\n \treturn EXECUTE_BYTECODE;\n-#endif /* J9VM_OPT_METHOD_HANDLE */\n+#endif /* defined(J9VM_OPT_METHOD_HANDLE) */\n+\t}\n+\n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+\tVMINLINE VM_BytecodeAction\n+\tinvokeBasic(REGISTER_ARGS_LIST)\n+\t{\n+\t\tVM_BytecodeAction rc = GOTO_RUN_METHOD;\n+\t\tbool fromJIT = J9_ARE_ANY_BITS_SET(_currentThread->jitStackFrameFlags, J9_SSF_JIT_NATIVE_TRANSITION_FRAME);\n+\t\tUDATA methodArgCount = 0;\n+\n+\t\tif (fromJIT) {\n+\t\t\tmethodArgCount = _currentThread->tempSlot;\n+\t\t} else {\n+\t\t\tU_16 index = *(U_16 *)(_pc + 1);\n+\t\t\tJ9ConstantPool *ramConstantPool = J9_CP_FROM_METHOD(_literals);\n+\t\t\tJ9RAMMethodRef *ramMethodRef = ((J9RAMMethodRef *)ramConstantPool) + index;\n+\t\t\tUDATA volatile methodIndexAndArgCount = ramMethodRef->methodIndexAndArgCount;\n+\t\t\tmethodArgCount = (methodIndexAndArgCount & 0xFF);\n+\t\t}\n+\n+\t\tj9object_t mhReceiver = ((j9object_t *)_sp)[methodArgCount];\n+\t\tif (J9_UNEXPECTED(NULL == mhReceiver)) {\n+\t\t\treturn THROW_NPE;\n+\t\t}\n+\n+\t\tj9object_t lambdaForm = J9VMJAVALANGINVOKEMETHODHANDLE_FORM(_currentThread, mhReceiver);\n+\t\tj9object_t memberName = J9VMJAVALANGINVOKELAMBDAFORM_VMENTRY(_currentThread, lambdaForm);\n+\t\t_sendMethod = (J9Method *)(UDATA)J9OBJECT_U64_LOAD(_currentThread, memberName, _vm->vmtargetOffset);\n+\n+\t\tif (fromJIT) {\n+\t\t\t_currentThread->jitStackFrameFlags = 0;\n+\t\t\tVM_JITInterface::restoreJITReturnAddress(_currentThread, _sp, (void *)_literals);\n+\t\t\trc = j2iTransition(REGISTER_ARGS);\n+\t\t}\n+\n+\t\treturn rc;\n+\t}\n+\n+\tVMINLINE VM_BytecodeAction\n+\tlinkToStaticSpecial(REGISTER_ARGS_LIST)\n+\t{\n+\t\tVM_BytecodeAction rc = GOTO_RUN_METHOD;\n+\t\tbool fromJIT = J9_ARE_ANY_BITS_SET(_currentThread->jitStackFrameFlags, J9_SSF_JIT_NATIVE_TRANSITION_FRAME);\n+\n+\t\t/* Pop memberNameObject from the stack. */\n+\t\tj9object_t memberNameObject = *(j9object_t *)_sp++;\n+\t\tif (J9_UNEXPECTED(NULL == memberNameObject)) {\n+\t\t\treturn THROW_NPE;\n+\t\t}\n+\n+\t\t_sendMethod = (J9Method *)(UDATA)J9OBJECT_U64_LOAD(_currentThread, memberNameObject, _vm->vmtargetOffset);\n+\n+\t\tif (fromJIT) {\n+\t\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(_sendMethod);\n+\t\t\tUDATA methodArgCount = romMethod->argCount;\n+\t\t\t/* Restore sp position before popping memberNameObject. */\n+\t\t\t--_sp;\n+\t\t\t\n+\t\t\t/* Shift arguments by 1 and place memberNameObject before the first argument. */\n+\t\t\tmemmove(_sp, _sp + 1, methodArgCount * sizeof(UDATA));\n+\t\t\t_sp[methodArgCount] = (UDATA)memberNameObject;\n+\n+\t\t\t_currentThread->jitStackFrameFlags = 0;\n+\t\t\tVM_JITInterface::restoreJITReturnAddress(_currentThread, _sp, (void *)_literals);\n+\t\t\trc = j2iTransition(REGISTER_ARGS);\n+\t\t}\n+\n+\t\treturn rc;\n+\t}\n+\n+\tVMINLINE VM_BytecodeAction\n+\tlinkToVirtual(REGISTER_ARGS_LIST)\n+\t{\n+\t\tVM_BytecodeAction rc = GOTO_RUN_METHOD;\n+\t\tbool fromJIT = J9_ARE_ANY_BITS_SET(_currentThread->jitStackFrameFlags, J9_SSF_JIT_NATIVE_TRANSITION_FRAME);\n+\n+\t\t/* Pop memberNameObject from the stack. */\n+\t\tj9object_t memberNameObject = *(j9object_t *)_sp++;\n+\t\tif (J9_UNEXPECTED(NULL == memberNameObject)) {\n+\t\t\treturn THROW_NPE;\n+\t\t}\n+\n+\t\tJ9JNIMethodID *methodID = (J9JNIMethodID *)(UDATA)J9OBJECT_U64_LOAD(_currentThread, memberNameObject, _vm->vmindexOffset);\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\t\tUDATA methodArgCount = romMethod->argCount;\n+\n+\t\tj9object_t receiverObject = ((j9object_t *)_sp)[methodArgCount - 1];\n+\t\tif (J9_UNEXPECTED(NULL == receiverObject)) {\n+\t\t\treturn THROW_NPE;\n+\t\t}\n+\t\tJ9Class *receiverClass = J9OBJECT_CLAZZ(currentThread, receiverObject);\n+\t\t_sendMethod = *(J9Method **)(((UDATA)receiverClass) + methodID->vTableIndex);\n+\n+\t\tif (fromJIT) {\n+\t\t\t/* Restore sp position before popping memberNameObject. */\n+\t\t\t--_sp;\n+\t\t\t\n+\t\t\t/* Shift arguments by 1 and place memberNameObject before the first argument. */\n+\t\t\tmemmove(_sp, _sp + 1, methodArgCount * sizeof(UDATA));\n+\t\t\t_sp[methodArgCount] = (UDATA)memberNameObject;\n+\n+\t\t\t_currentThread->jitStackFrameFlags = 0;\n+\t\t\tVM_JITInterface::restoreJITReturnAddress(_currentThread, _sp, (void *)_literals);\n+\t\t\trc = j2iTransition(REGISTER_ARGS);\n+\t\t}\n+\n+\t\treturn rc;\n+\t}\n+\n+\tVMINLINE VM_BytecodeAction\n+\tlinkToInterface(REGISTER_ARGS_LIST)\n+\t{\n+\t\tVM_BytecodeAction rc = GOTO_RUN_METHOD;\n+\t\tbool fromJIT = J9_ARE_ANY_BITS_SET(_currentThread->jitStackFrameFlags, J9_SSF_JIT_NATIVE_TRANSITION_FRAME);\n+\n+\t\t/* Pop memberNameObject from the stack. */\n+\t\tj9object_t memberNameObject = *(j9object_t *)_sp++;\n+\t\tif (J9_UNEXPECTED(NULL == memberNameObject)) {\n+\t\t\treturn THROW_NPE;\n+\t\t}\n+\n+\t\tJ9JNIMethodID *methodID = (J9JNIMethodID *)(UDATA)J9OBJECT_U64_LOAD(_currentThread, memberNameObject, _vm->vmindexOffset);\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\t\tUDATA methodArgCount = romMethod->argCount;\n+\n+\t\tj9object_t receiverObject = ((j9object_t *)_sp)[methodArgCount - 1];\n+\t\tif (J9_UNEXPECTED(NULL == receiverObject)) {\n+\t\t\treturn THROW_NPE;\n+\t\t}\n+\t\tJ9Class *receiverClass = J9OBJECT_CLAZZ(currentThread, receiverObject);\n+\t\tJ9Method *method = (J9Method *)(UDATA)J9OBJECT_U64_LOAD(_currentThread, memberNameObject, _vm->vmtargetOffset);\n+\t\tUDATA vTableOffset = methodID->vTableIndex;\n+\n+\n+\t\tif (J9_ARE_ANY_BITS_SET(vTableOffset, J9_JNI_MID_INTERFACE)) {\n+\t\t\tUDATA iTableIndex = vTableOffset & ~(UDATA)J9_JNI_MID_INTERFACE;\n+\t\t\tJ9Class *interfaceClass = J9_CLASS_FROM_METHOD(method);\n+\t\t\tvTableOffset = 0;\n+\t\t\tJ9ITable * iTable = receiverClass->lastITable;\n+\t\t\tif (interfaceClass == iTable->interfaceClass) {\n+\t\t\t\tgoto foundITable;\n+\t\t\t}\n+\t\t\tiTable = (J9ITable*)receiverClass->iTable;\n+\t\t\twhile (NULL != iTable) {\n+\t\t\t\tif (interfaceClass == iTable->interfaceClass) {\n+\t\t\t\t\treceiverClass->lastITable = iTable;\n+foundITable:\n+\t\t\t\t\tvTableOffset = ((UDATA*)(iTable + 1))[iTableIndex];\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t\tiTable = iTable->next;\n+\t\t\t}\n+\t\t}\n+\n+\t\t_sendMethod = *(J9Method **)(((UDATA)receiverClass) + vTableOffset);\n+\n+\t\tif (fromJIT) {\n+\t\t\t/* Restore sp position before popping memberNameObject. */\n+\t\t\t--_sp;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzYyMDU2Mw=="}, "originalCommit": {"oid": "f43a6978bcb3a63dfad417ad18bf80ac0ccd6030"}, "originalPosition": 400}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExNzUyNDM2OnYy", "diffSide": "RIGHT", "path": "runtime/vm/BytecodeInterpreter.hpp", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQwNDozMTozMlrOHa6JZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxMzoxMDoyNFrOHbJoIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk3NzcwMw==", "bodyText": "This doesn't handle the J9_ITABLE_OFFSET_TAG_BITS special cases.  Are they filtered somewhere else?", "url": "https://github.com/eclipse-openj9/openj9/pull/10733#discussion_r497977703", "createdAt": "2020-10-01T04:31:32Z", "author": {"login": "DanHeidinga"}, "path": "runtime/vm/BytecodeInterpreter.hpp", "diffHunk": "@@ -8119,11 +8223,186 @@ class INTERPRETER_CLASS\n \t\t}\n done:\n \t\treturn rc;\n-#else\n+#else /* defined(J9VM_OPT_METHOD_HANDLE) */\n+\t/* When J9VM_OPT_OPENJDK_METHODHANDLE is enabled, MH.invoke and MH.invokeExact are\n+\t * both translated to invokehandle. So, invokehandlegeneric is not used with OpenJDK\n+\t * MethodHandles.\n+\t */\n \tAssert_VM_unreachable();\n \treturn EXECUTE_BYTECODE;\n-#endif /* J9VM_OPT_METHOD_HANDLE */\n+#endif /* defined(J9VM_OPT_METHOD_HANDLE) */\n+\t}\n+\n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+\tVMINLINE VM_BytecodeAction\n+\tinvokeBasic(REGISTER_ARGS_LIST)\n+\t{\n+\t\tVM_BytecodeAction rc = GOTO_RUN_METHOD;\n+\t\tbool fromJIT = J9_ARE_ANY_BITS_SET(_currentThread->jitStackFrameFlags, J9_SSF_JIT_NATIVE_TRANSITION_FRAME);\n+\t\tUDATA methodArgCount = 0;\n+\n+\t\tif (fromJIT) {\n+\t\t\tmethodArgCount = _currentThread->tempSlot;\n+\t\t} else {\n+\t\t\tU_16 index = *(U_16 *)(_pc + 1);\n+\t\t\tJ9ConstantPool *ramConstantPool = J9_CP_FROM_METHOD(_literals);\n+\t\t\tJ9RAMMethodRef *ramMethodRef = ((J9RAMMethodRef *)ramConstantPool) + index;\n+\t\t\tUDATA volatile methodIndexAndArgCount = ramMethodRef->methodIndexAndArgCount;\n+\t\t\tmethodArgCount = (methodIndexAndArgCount & 0xFF);\n+\t\t}\n+\n+\t\tj9object_t mhReceiver = ((j9object_t *)_sp)[methodArgCount];\n+\t\tif (J9_UNEXPECTED(NULL == mhReceiver)) {\n+\t\t\treturn THROW_NPE;\n+\t\t}\n+\n+\t\tj9object_t lambdaForm = J9VMJAVALANGINVOKEMETHODHANDLE_FORM(_currentThread, mhReceiver);\n+\t\tj9object_t memberName = J9VMJAVALANGINVOKELAMBDAFORM_VMENTRY(_currentThread, lambdaForm);\n+\t\t_sendMethod = (J9Method *)(UDATA)J9OBJECT_U64_LOAD(_currentThread, memberName, _vm->vmtargetOffset);\n+\n+\t\tif (fromJIT) {\n+\t\t\t_currentThread->jitStackFrameFlags = 0;\n+\t\t\tVM_JITInterface::restoreJITReturnAddress(_currentThread, _sp, (void *)_literals);\n+\t\t\trc = j2iTransition(REGISTER_ARGS);\n+\t\t}\n+\n+\t\treturn rc;\n+\t}\n+\n+\tVMINLINE VM_BytecodeAction\n+\tlinkToStaticSpecial(REGISTER_ARGS_LIST)\n+\t{\n+\t\tVM_BytecodeAction rc = GOTO_RUN_METHOD;\n+\t\tbool fromJIT = J9_ARE_ANY_BITS_SET(_currentThread->jitStackFrameFlags, J9_SSF_JIT_NATIVE_TRANSITION_FRAME);\n+\n+\t\t/* Pop memberNameObject from the stack. */\n+\t\tj9object_t memberNameObject = *(j9object_t *)_sp++;\n+\t\tif (J9_UNEXPECTED(NULL == memberNameObject)) {\n+\t\t\treturn THROW_NPE;\n+\t\t}\n+\n+\t\t_sendMethod = (J9Method *)(UDATA)J9OBJECT_U64_LOAD(_currentThread, memberNameObject, _vm->vmtargetOffset);\n+\n+\t\tif (fromJIT) {\n+\t\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(_sendMethod);\n+\t\t\tUDATA methodArgCount = romMethod->argCount;\n+\n+\t\t\t/* Restore sp position before popping memberNameObject. */\n+\t\t\t_sp -= 1;\n+\n+\t\t\t/* Shift arguments by 1 and place memberNameObject before the first argument. */\n+\t\t\tmemmove(_sp, _sp + 1, methodArgCount * sizeof(UDATA));\n+\t\t\t_sp[methodArgCount] = (UDATA)memberNameObject;\n+\n+\t\t\t_currentThread->jitStackFrameFlags = 0;\n+\t\t\tVM_JITInterface::restoreJITReturnAddress(_currentThread, _sp, (void *)_literals);\n+\t\t\trc = j2iTransition(REGISTER_ARGS);\n+\t\t}\n+\n+\t\treturn rc;\n+\t}\n+\n+\tVMINLINE VM_BytecodeAction\n+\tlinkToVirtual(REGISTER_ARGS_LIST)\n+\t{\n+\t\tVM_BytecodeAction rc = GOTO_RUN_METHOD;\n+\t\tbool fromJIT = J9_ARE_ANY_BITS_SET(_currentThread->jitStackFrameFlags, J9_SSF_JIT_NATIVE_TRANSITION_FRAME);\n+\n+\t\t/* Pop memberNameObject from the stack. */\n+\t\tj9object_t memberNameObject = *(j9object_t *)_sp++;\n+\t\tif (J9_UNEXPECTED(NULL == memberNameObject)) {\n+\t\t\treturn THROW_NPE;\n+\t\t}\n+\n+\t\tJ9JNIMethodID *methodID = (J9JNIMethodID *)(UDATA)J9OBJECT_U64_LOAD(_currentThread, memberNameObject, _vm->vmindexOffset);\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\t\tUDATA methodArgCount = romMethod->argCount;\n+\n+\t\tj9object_t receiverObject = ((j9object_t *)_sp)[methodArgCount - 1];\n+\t\tif (J9_UNEXPECTED(NULL == receiverObject)) {\n+\t\t\treturn THROW_NPE;\n+\t\t}\n+\t\tJ9Class *receiverClass = J9OBJECT_CLAZZ(currentThread, receiverObject);\n+\t\t_sendMethod = *(J9Method **)(((UDATA)receiverClass) + methodID->vTableIndex);\n+\n+\t\tif (fromJIT) {\n+\t\t\t/* Restore sp position before popping memberNameObject. */\n+\t\t\t_sp -= 1;\n+\n+\t\t\t/* Shift arguments by 1 and place memberNameObject before the first argument. */\n+\t\t\tmemmove(_sp, _sp + 1, methodArgCount * sizeof(UDATA));\n+\t\t\t_sp[methodArgCount] = (UDATA)memberNameObject;\n+\n+\t\t\t_currentThread->jitStackFrameFlags = 0;\n+\t\t\tVM_JITInterface::restoreJITReturnAddress(_currentThread, _sp, (void *)_literals);\n+\t\t\trc = j2iTransition(REGISTER_ARGS);\n+\t\t}\n+\n+\t\treturn rc;\n+\t}\n+\n+\tVMINLINE VM_BytecodeAction\n+\tlinkToInterface(REGISTER_ARGS_LIST)\n+\t{\n+\t\tVM_BytecodeAction rc = GOTO_RUN_METHOD;\n+\t\tbool fromJIT = J9_ARE_ANY_BITS_SET(_currentThread->jitStackFrameFlags, J9_SSF_JIT_NATIVE_TRANSITION_FRAME);\n+\n+\t\t/* Pop memberNameObject from the stack. */\n+\t\tj9object_t memberNameObject = *(j9object_t *)_sp++;\n+\t\tif (J9_UNEXPECTED(NULL == memberNameObject)) {\n+\t\t\treturn THROW_NPE;\n+\t\t}\n+\n+\t\tJ9JNIMethodID *methodID = (J9JNIMethodID *)(UDATA)J9OBJECT_U64_LOAD(_currentThread, memberNameObject, _vm->vmindexOffset);\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\t\tUDATA methodArgCount = romMethod->argCount;\n+\n+\t\tj9object_t receiverObject = ((j9object_t *)_sp)[methodArgCount - 1];\n+\t\tif (J9_UNEXPECTED(NULL == receiverObject)) {\n+\t\t\treturn THROW_NPE;\n+\t\t}\n+\t\tJ9Class *receiverClass = J9OBJECT_CLAZZ(currentThread, receiverObject);\n+\t\tJ9Method *method = (J9Method *)(UDATA)J9OBJECT_U64_LOAD(_currentThread, memberNameObject, _vm->vmtargetOffset);\n+\t\tUDATA vTableOffset = methodID->vTableIndex;\n+\n+\t\tif (J9_ARE_ANY_BITS_SET(vTableOffset, J9_JNI_MID_INTERFACE)) {\n+\t\t\tUDATA iTableIndex = vTableOffset & ~(UDATA)J9_JNI_MID_INTERFACE;\n+\t\t\tJ9Class *interfaceClass = J9_CLASS_FROM_METHOD(method);\n+\t\t\tvTableOffset = 0;\n+\t\t\tJ9ITable * iTable = receiverClass->lastITable;\n+\t\t\tif (interfaceClass == iTable->interfaceClass) {\n+\t\t\t\tgoto foundITable;\n+\t\t\t}\n+\t\t\tiTable = (J9ITable*)receiverClass->iTable;\n+\t\t\twhile (NULL != iTable) {\n+\t\t\t\tif (interfaceClass == iTable->interfaceClass) {\n+\t\t\t\t\treceiverClass->lastITable = iTable;\n+foundITable:\n+\t\t\t\t\tvTableOffset = ((UDATA*)(iTable + 1))[iTableIndex];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de2822dc95c6e752972651cdca0e17109d3c67b7"}, "originalPosition": 389}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODIzMTMyOQ==", "bodyText": "I don't think they are being filtered (++ @fengxue-IS to confirm?). We have missed the J9_ITABLE_OFFSET_TAG_BITS special cases.\nhttps://github.com/eclipse/openj9/blob/bdd5791eebf1356c6736dffab8b9e8edfc0c89c1/runtime/codert_vm/cnathelp.cpp#L123-L131\nWe will add similar code here to handle J9_ITABLE_OFFSET_TAG_BITS.", "url": "https://github.com/eclipse-openj9/openj9/pull/10733#discussion_r498231329", "createdAt": "2020-10-01T13:10:24Z", "author": {"login": "babsingh"}, "path": "runtime/vm/BytecodeInterpreter.hpp", "diffHunk": "@@ -8119,11 +8223,186 @@ class INTERPRETER_CLASS\n \t\t}\n done:\n \t\treturn rc;\n-#else\n+#else /* defined(J9VM_OPT_METHOD_HANDLE) */\n+\t/* When J9VM_OPT_OPENJDK_METHODHANDLE is enabled, MH.invoke and MH.invokeExact are\n+\t * both translated to invokehandle. So, invokehandlegeneric is not used with OpenJDK\n+\t * MethodHandles.\n+\t */\n \tAssert_VM_unreachable();\n \treturn EXECUTE_BYTECODE;\n-#endif /* J9VM_OPT_METHOD_HANDLE */\n+#endif /* defined(J9VM_OPT_METHOD_HANDLE) */\n+\t}\n+\n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+\tVMINLINE VM_BytecodeAction\n+\tinvokeBasic(REGISTER_ARGS_LIST)\n+\t{\n+\t\tVM_BytecodeAction rc = GOTO_RUN_METHOD;\n+\t\tbool fromJIT = J9_ARE_ANY_BITS_SET(_currentThread->jitStackFrameFlags, J9_SSF_JIT_NATIVE_TRANSITION_FRAME);\n+\t\tUDATA methodArgCount = 0;\n+\n+\t\tif (fromJIT) {\n+\t\t\tmethodArgCount = _currentThread->tempSlot;\n+\t\t} else {\n+\t\t\tU_16 index = *(U_16 *)(_pc + 1);\n+\t\t\tJ9ConstantPool *ramConstantPool = J9_CP_FROM_METHOD(_literals);\n+\t\t\tJ9RAMMethodRef *ramMethodRef = ((J9RAMMethodRef *)ramConstantPool) + index;\n+\t\t\tUDATA volatile methodIndexAndArgCount = ramMethodRef->methodIndexAndArgCount;\n+\t\t\tmethodArgCount = (methodIndexAndArgCount & 0xFF);\n+\t\t}\n+\n+\t\tj9object_t mhReceiver = ((j9object_t *)_sp)[methodArgCount];\n+\t\tif (J9_UNEXPECTED(NULL == mhReceiver)) {\n+\t\t\treturn THROW_NPE;\n+\t\t}\n+\n+\t\tj9object_t lambdaForm = J9VMJAVALANGINVOKEMETHODHANDLE_FORM(_currentThread, mhReceiver);\n+\t\tj9object_t memberName = J9VMJAVALANGINVOKELAMBDAFORM_VMENTRY(_currentThread, lambdaForm);\n+\t\t_sendMethod = (J9Method *)(UDATA)J9OBJECT_U64_LOAD(_currentThread, memberName, _vm->vmtargetOffset);\n+\n+\t\tif (fromJIT) {\n+\t\t\t_currentThread->jitStackFrameFlags = 0;\n+\t\t\tVM_JITInterface::restoreJITReturnAddress(_currentThread, _sp, (void *)_literals);\n+\t\t\trc = j2iTransition(REGISTER_ARGS);\n+\t\t}\n+\n+\t\treturn rc;\n+\t}\n+\n+\tVMINLINE VM_BytecodeAction\n+\tlinkToStaticSpecial(REGISTER_ARGS_LIST)\n+\t{\n+\t\tVM_BytecodeAction rc = GOTO_RUN_METHOD;\n+\t\tbool fromJIT = J9_ARE_ANY_BITS_SET(_currentThread->jitStackFrameFlags, J9_SSF_JIT_NATIVE_TRANSITION_FRAME);\n+\n+\t\t/* Pop memberNameObject from the stack. */\n+\t\tj9object_t memberNameObject = *(j9object_t *)_sp++;\n+\t\tif (J9_UNEXPECTED(NULL == memberNameObject)) {\n+\t\t\treturn THROW_NPE;\n+\t\t}\n+\n+\t\t_sendMethod = (J9Method *)(UDATA)J9OBJECT_U64_LOAD(_currentThread, memberNameObject, _vm->vmtargetOffset);\n+\n+\t\tif (fromJIT) {\n+\t\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(_sendMethod);\n+\t\t\tUDATA methodArgCount = romMethod->argCount;\n+\n+\t\t\t/* Restore sp position before popping memberNameObject. */\n+\t\t\t_sp -= 1;\n+\n+\t\t\t/* Shift arguments by 1 and place memberNameObject before the first argument. */\n+\t\t\tmemmove(_sp, _sp + 1, methodArgCount * sizeof(UDATA));\n+\t\t\t_sp[methodArgCount] = (UDATA)memberNameObject;\n+\n+\t\t\t_currentThread->jitStackFrameFlags = 0;\n+\t\t\tVM_JITInterface::restoreJITReturnAddress(_currentThread, _sp, (void *)_literals);\n+\t\t\trc = j2iTransition(REGISTER_ARGS);\n+\t\t}\n+\n+\t\treturn rc;\n+\t}\n+\n+\tVMINLINE VM_BytecodeAction\n+\tlinkToVirtual(REGISTER_ARGS_LIST)\n+\t{\n+\t\tVM_BytecodeAction rc = GOTO_RUN_METHOD;\n+\t\tbool fromJIT = J9_ARE_ANY_BITS_SET(_currentThread->jitStackFrameFlags, J9_SSF_JIT_NATIVE_TRANSITION_FRAME);\n+\n+\t\t/* Pop memberNameObject from the stack. */\n+\t\tj9object_t memberNameObject = *(j9object_t *)_sp++;\n+\t\tif (J9_UNEXPECTED(NULL == memberNameObject)) {\n+\t\t\treturn THROW_NPE;\n+\t\t}\n+\n+\t\tJ9JNIMethodID *methodID = (J9JNIMethodID *)(UDATA)J9OBJECT_U64_LOAD(_currentThread, memberNameObject, _vm->vmindexOffset);\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\t\tUDATA methodArgCount = romMethod->argCount;\n+\n+\t\tj9object_t receiverObject = ((j9object_t *)_sp)[methodArgCount - 1];\n+\t\tif (J9_UNEXPECTED(NULL == receiverObject)) {\n+\t\t\treturn THROW_NPE;\n+\t\t}\n+\t\tJ9Class *receiverClass = J9OBJECT_CLAZZ(currentThread, receiverObject);\n+\t\t_sendMethod = *(J9Method **)(((UDATA)receiverClass) + methodID->vTableIndex);\n+\n+\t\tif (fromJIT) {\n+\t\t\t/* Restore sp position before popping memberNameObject. */\n+\t\t\t_sp -= 1;\n+\n+\t\t\t/* Shift arguments by 1 and place memberNameObject before the first argument. */\n+\t\t\tmemmove(_sp, _sp + 1, methodArgCount * sizeof(UDATA));\n+\t\t\t_sp[methodArgCount] = (UDATA)memberNameObject;\n+\n+\t\t\t_currentThread->jitStackFrameFlags = 0;\n+\t\t\tVM_JITInterface::restoreJITReturnAddress(_currentThread, _sp, (void *)_literals);\n+\t\t\trc = j2iTransition(REGISTER_ARGS);\n+\t\t}\n+\n+\t\treturn rc;\n+\t}\n+\n+\tVMINLINE VM_BytecodeAction\n+\tlinkToInterface(REGISTER_ARGS_LIST)\n+\t{\n+\t\tVM_BytecodeAction rc = GOTO_RUN_METHOD;\n+\t\tbool fromJIT = J9_ARE_ANY_BITS_SET(_currentThread->jitStackFrameFlags, J9_SSF_JIT_NATIVE_TRANSITION_FRAME);\n+\n+\t\t/* Pop memberNameObject from the stack. */\n+\t\tj9object_t memberNameObject = *(j9object_t *)_sp++;\n+\t\tif (J9_UNEXPECTED(NULL == memberNameObject)) {\n+\t\t\treturn THROW_NPE;\n+\t\t}\n+\n+\t\tJ9JNIMethodID *methodID = (J9JNIMethodID *)(UDATA)J9OBJECT_U64_LOAD(_currentThread, memberNameObject, _vm->vmindexOffset);\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\t\tUDATA methodArgCount = romMethod->argCount;\n+\n+\t\tj9object_t receiverObject = ((j9object_t *)_sp)[methodArgCount - 1];\n+\t\tif (J9_UNEXPECTED(NULL == receiverObject)) {\n+\t\t\treturn THROW_NPE;\n+\t\t}\n+\t\tJ9Class *receiverClass = J9OBJECT_CLAZZ(currentThread, receiverObject);\n+\t\tJ9Method *method = (J9Method *)(UDATA)J9OBJECT_U64_LOAD(_currentThread, memberNameObject, _vm->vmtargetOffset);\n+\t\tUDATA vTableOffset = methodID->vTableIndex;\n+\n+\t\tif (J9_ARE_ANY_BITS_SET(vTableOffset, J9_JNI_MID_INTERFACE)) {\n+\t\t\tUDATA iTableIndex = vTableOffset & ~(UDATA)J9_JNI_MID_INTERFACE;\n+\t\t\tJ9Class *interfaceClass = J9_CLASS_FROM_METHOD(method);\n+\t\t\tvTableOffset = 0;\n+\t\t\tJ9ITable * iTable = receiverClass->lastITable;\n+\t\t\tif (interfaceClass == iTable->interfaceClass) {\n+\t\t\t\tgoto foundITable;\n+\t\t\t}\n+\t\t\tiTable = (J9ITable*)receiverClass->iTable;\n+\t\t\twhile (NULL != iTable) {\n+\t\t\t\tif (interfaceClass == iTable->interfaceClass) {\n+\t\t\t\t\treceiverClass->lastITable = iTable;\n+foundITable:\n+\t\t\t\t\tvTableOffset = ((UDATA*)(iTable + 1))[iTableIndex];", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk3NzcwMw=="}, "originalCommit": {"oid": "de2822dc95c6e752972651cdca0e17109d3c67b7"}, "originalPosition": 389}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExNzU1MTE5OnYy", "diffSide": "RIGHT", "path": "runtime/vm/BytecodeInterpreter.hpp", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQwNDo0ODozN1rOHa6Ylw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxMzo0MDoxM1rOHbK5ag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk4MTU5MQ==", "bodyText": "I don't see the definition of J9InvokeCacheEntry in this PR or in the already committed code.  Am I missing it?\nHard to tell if the barriers are correct in this path without seeing that code and the updates to resolveInvokeDynmaic", "url": "https://github.com/eclipse-openj9/openj9/pull/10733#discussion_r497981591", "createdAt": "2020-10-01T04:48:37Z", "author": {"login": "DanHeidinga"}, "path": "runtime/vm/BytecodeInterpreter.hpp", "diffHunk": "@@ -8004,35 +8007,87 @@ class INTERPRETER_CLASS\n \t\t\t\tgoto retry;\n \t\t\t}\n \t\t}\n+\n \t\treturn rc;\n-#else\n-\tAssert_VM_unreachable();\n-\treturn EXECUTE_BYTECODE;\n-#endif /* J9VM_OPT_METHOD_HANDLE */\n \t}\n+#elif defined(J9VM_OPT_OPENJDK_METHODHANDLE) /* defined(J9VM_OPT_METHOD_HANDLE) */\n+\tVMINLINE VM_BytecodeAction\n+\tinvokedynamic(REGISTER_ARGS_LIST)\n+\t{\n+retry:\n+\t\tVM_BytecodeAction rc = GOTO_RUN_METHOD;\n+\t\tU_16 index = *(U_16 *)(_pc + 1);\n+\n+\t\tJ9ConstantPool *ramConstantPool = J9_CP_FROM_METHOD(_literals);\n+\t\tJ9InvokeCacheEntry *invokeCache = ((J9InvokeCacheEntry *)ramConstantPool->ramClass->callSites) + index;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de2822dc95c6e752972651cdca0e17109d3c67b7"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODIyMzEwNg==", "bodyText": "J9InvokeCacheEntry is not part of this PR.\ntypedef struct J9InvokeCacheEntry {\n\tj9object_t target;\n\tj9object_t appendix;\n} J9InvokeCacheEntry;\n\nJ9InvokeCacheEntry is planned to be added in the resolvesupport.cpp changes (separate PR).", "url": "https://github.com/eclipse-openj9/openj9/pull/10733#discussion_r498223106", "createdAt": "2020-10-01T12:57:40Z", "author": {"login": "babsingh"}, "path": "runtime/vm/BytecodeInterpreter.hpp", "diffHunk": "@@ -8004,35 +8007,87 @@ class INTERPRETER_CLASS\n \t\t\t\tgoto retry;\n \t\t\t}\n \t\t}\n+\n \t\treturn rc;\n-#else\n-\tAssert_VM_unreachable();\n-\treturn EXECUTE_BYTECODE;\n-#endif /* J9VM_OPT_METHOD_HANDLE */\n \t}\n+#elif defined(J9VM_OPT_OPENJDK_METHODHANDLE) /* defined(J9VM_OPT_METHOD_HANDLE) */\n+\tVMINLINE VM_BytecodeAction\n+\tinvokedynamic(REGISTER_ARGS_LIST)\n+\t{\n+retry:\n+\t\tVM_BytecodeAction rc = GOTO_RUN_METHOD;\n+\t\tU_16 index = *(U_16 *)(_pc + 1);\n+\n+\t\tJ9ConstantPool *ramConstantPool = J9_CP_FROM_METHOD(_literals);\n+\t\tJ9InvokeCacheEntry *invokeCache = ((J9InvokeCacheEntry *)ramConstantPool->ramClass->callSites) + index;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk4MTU5MQ=="}, "originalCommit": {"oid": "de2822dc95c6e752972651cdca0e17109d3c67b7"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODIzMjg3Mw==", "bodyText": "We read both values from the cache here without a memory barrier.  How do we ensure that both are visible at this point?  Are they always written such that:\ncache->appendix = ....;\n<membarrier>\ncache->target = ....;\n\nso that the store of appendix can't be moved passed the store of target or another racing thread can read incompletely resolved values", "url": "https://github.com/eclipse-openj9/openj9/pull/10733#discussion_r498232873", "createdAt": "2020-10-01T13:12:45Z", "author": {"login": "DanHeidinga"}, "path": "runtime/vm/BytecodeInterpreter.hpp", "diffHunk": "@@ -8004,35 +8007,87 @@ class INTERPRETER_CLASS\n \t\t\t\tgoto retry;\n \t\t\t}\n \t\t}\n+\n \t\treturn rc;\n-#else\n-\tAssert_VM_unreachable();\n-\treturn EXECUTE_BYTECODE;\n-#endif /* J9VM_OPT_METHOD_HANDLE */\n \t}\n+#elif defined(J9VM_OPT_OPENJDK_METHODHANDLE) /* defined(J9VM_OPT_METHOD_HANDLE) */\n+\tVMINLINE VM_BytecodeAction\n+\tinvokedynamic(REGISTER_ARGS_LIST)\n+\t{\n+retry:\n+\t\tVM_BytecodeAction rc = GOTO_RUN_METHOD;\n+\t\tU_16 index = *(U_16 *)(_pc + 1);\n+\n+\t\tJ9ConstantPool *ramConstantPool = J9_CP_FROM_METHOD(_literals);\n+\t\tJ9InvokeCacheEntry *invokeCache = ((J9InvokeCacheEntry *)ramConstantPool->ramClass->callSites) + index;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk4MTU5MQ=="}, "originalCommit": {"oid": "de2822dc95c6e752972651cdca0e17109d3c67b7"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODIzNDA0Mg==", "bodyText": "Can you link the separate PR here?  We need to review both parts together to tell if there's a problem.\nAlso, multiple threads can race to resolve an invokedynamic.  The old resolve code used a CAS to resolve the race.  How is that handled with the two slot solution?", "url": "https://github.com/eclipse-openj9/openj9/pull/10733#discussion_r498234042", "createdAt": "2020-10-01T13:14:28Z", "author": {"login": "DanHeidinga"}, "path": "runtime/vm/BytecodeInterpreter.hpp", "diffHunk": "@@ -8004,35 +8007,87 @@ class INTERPRETER_CLASS\n \t\t\t\tgoto retry;\n \t\t\t}\n \t\t}\n+\n \t\treturn rc;\n-#else\n-\tAssert_VM_unreachable();\n-\treturn EXECUTE_BYTECODE;\n-#endif /* J9VM_OPT_METHOD_HANDLE */\n \t}\n+#elif defined(J9VM_OPT_OPENJDK_METHODHANDLE) /* defined(J9VM_OPT_METHOD_HANDLE) */\n+\tVMINLINE VM_BytecodeAction\n+\tinvokedynamic(REGISTER_ARGS_LIST)\n+\t{\n+retry:\n+\t\tVM_BytecodeAction rc = GOTO_RUN_METHOD;\n+\t\tU_16 index = *(U_16 *)(_pc + 1);\n+\n+\t\tJ9ConstantPool *ramConstantPool = J9_CP_FROM_METHOD(_literals);\n+\t\tJ9InvokeCacheEntry *invokeCache = ((J9InvokeCacheEntry *)ramConstantPool->ramClass->callSites) + index;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk4MTU5MQ=="}, "originalCommit": {"oid": "de2822dc95c6e752972651cdca0e17109d3c67b7"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI0MzQ1Ng==", "bodyText": "In resolvesupport.cpp, @fengxue-IS has added sync code. The sync code will assure that both values are written before any thread reads them.\ntarget will be NULL until the resolution is complete. So, all threads will take the resolve path if target is NULL. In the resolve path, there will be a spin loop which will prevent the threads to proceed until the resolved values are successfully written. target will be written last to indicate the completion of resolution.\n@fengxue-IS thumbs up to confirm?", "url": "https://github.com/eclipse-openj9/openj9/pull/10733#discussion_r498243456", "createdAt": "2020-10-01T13:27:49Z", "author": {"login": "babsingh"}, "path": "runtime/vm/BytecodeInterpreter.hpp", "diffHunk": "@@ -8004,35 +8007,87 @@ class INTERPRETER_CLASS\n \t\t\t\tgoto retry;\n \t\t\t}\n \t\t}\n+\n \t\treturn rc;\n-#else\n-\tAssert_VM_unreachable();\n-\treturn EXECUTE_BYTECODE;\n-#endif /* J9VM_OPT_METHOD_HANDLE */\n \t}\n+#elif defined(J9VM_OPT_OPENJDK_METHODHANDLE) /* defined(J9VM_OPT_METHOD_HANDLE) */\n+\tVMINLINE VM_BytecodeAction\n+\tinvokedynamic(REGISTER_ARGS_LIST)\n+\t{\n+retry:\n+\t\tVM_BytecodeAction rc = GOTO_RUN_METHOD;\n+\t\tU_16 index = *(U_16 *)(_pc + 1);\n+\n+\t\tJ9ConstantPool *ramConstantPool = J9_CP_FROM_METHOD(_literals);\n+\t\tJ9InvokeCacheEntry *invokeCache = ((J9InvokeCacheEntry *)ramConstantPool->ramClass->callSites) + index;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk4MTU5MQ=="}, "originalCommit": {"oid": "de2822dc95c6e752972651cdca0e17109d3c67b7"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI1MjEzOA==", "bodyText": "Can you link the separate PR here?\n\nyes, the resolution PR will be linked with this PR. it still needs to be created.\n\nThe old resolve code used a CAS to resolve the race. How is that handled with the two slot solution?\n\nSimilar spin loop / CAS approach. The last slot to be written is used to indicate the end of resolution. The first slot is used to indicate the start of resolution.", "url": "https://github.com/eclipse-openj9/openj9/pull/10733#discussion_r498252138", "createdAt": "2020-10-01T13:40:13Z", "author": {"login": "babsingh"}, "path": "runtime/vm/BytecodeInterpreter.hpp", "diffHunk": "@@ -8004,35 +8007,87 @@ class INTERPRETER_CLASS\n \t\t\t\tgoto retry;\n \t\t\t}\n \t\t}\n+\n \t\treturn rc;\n-#else\n-\tAssert_VM_unreachable();\n-\treturn EXECUTE_BYTECODE;\n-#endif /* J9VM_OPT_METHOD_HANDLE */\n \t}\n+#elif defined(J9VM_OPT_OPENJDK_METHODHANDLE) /* defined(J9VM_OPT_METHOD_HANDLE) */\n+\tVMINLINE VM_BytecodeAction\n+\tinvokedynamic(REGISTER_ARGS_LIST)\n+\t{\n+retry:\n+\t\tVM_BytecodeAction rc = GOTO_RUN_METHOD;\n+\t\tU_16 index = *(U_16 *)(_pc + 1);\n+\n+\t\tJ9ConstantPool *ramConstantPool = J9_CP_FROM_METHOD(_literals);\n+\t\tJ9InvokeCacheEntry *invokeCache = ((J9InvokeCacheEntry *)ramConstantPool->ramClass->callSites) + index;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk4MTU5MQ=="}, "originalCommit": {"oid": "de2822dc95c6e752972651cdca0e17109d3c67b7"}, "originalPosition": 45}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1255, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}