{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMzOTkxNjMy", "number": 11393, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMToxOTowOVrOFL52-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMToxOTowOVrOFL52-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4MDI2NjE5OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/x/codegen/J9TreeEvaluator.cpp", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMToxOTowOVrOIPWX7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQxNjo0MzozMlrOIWXUQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk2NjEyNA==", "bodyText": "Found the issue. It appears that the code is slightly different on x86 than on Z and Power in this area. The mistake here is the new line we added should be cg->evaluate(node->getFirstChild());. This is because on x86 we modify the value of firstChild where as on Z and Power we do not.\nHere is explicitly where we do this in the code on x86:\nhttps://github.com/eclipse/openj9/blob/137829daa49943b5129f54bdac8aa5754b2e3186/runtime/compiler/x/codegen/J9TreeEvaluator.cpp#L1665-L1688\nAnd for reference here it is on Z for example (where we use a separate variable n to do this):\nhttps://github.com/eclipse/openj9/blob/137829daa49943b5129f54bdac8aa5754b2e3186/runtime/compiler/z/codegen/J9TreeEvaluator.cpp#L5571-L5590\nAnd here it is on Power:\nhttps://github.com/eclipse/openj9/blob/137829daa49943b5129f54bdac8aa5754b2e3186/runtime/compiler/p/codegen/J9TreeEvaluator.cpp#L13111-L13124", "url": "https://github.com/eclipse-openj9/openj9/pull/11393#discussion_r552966124", "createdAt": "2021-01-06T21:19:09Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/x/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2001,25 +2001,7 @@ TR::Register *J9::X86::TreeEvaluator::evaluateNULLCHKWithPossibleResolve(\n    //\n    if (needLateEvaluation)\n       {\n-      if (comp->useCompressedPointers())\n-         {\n-         // for stores under NULLCHKs, artificially bump\n-         // down the reference count before evaluation (since stores\n-         // return null as registers)\n-         //\n-         bool fixRefCount = false;\n-         if (node->getFirstChild()->getOpCode().isStoreIndirect() &&\n-               node->getFirstChild()->getReferenceCount() > 1)\n-            {\n-            node->getFirstChild()->decReferenceCount();\n-            fixRefCount = true;\n-            }\n-         cg->evaluate(node->getFirstChild());\n-         if (fixRefCount)\n-            node->getFirstChild()->incReferenceCount();\n-         }\n-      else\n-         cg->evaluate(firstChild);\n+      cg->evaluate(firstChild);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "602e95240bd6a245c0e2ff0c95dd61918cd11792"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk3OTA5MQ==", "bodyText": "In fact I believe x86 has a bug here, or at the very least we are missing opportunities. Because we modify the value of firstChild the computation on line 1684:\nhttps://github.com/eclipse/openj9/blob/137829daa49943b5129f54bdac8aa5754b2e3186/runtime/compiler/x/codegen/J9TreeEvaluator.cpp#L1659-L1713\nthis subsequent line:\nhttps://github.com/eclipse/openj9/blob/137829daa49943b5129f54bdac8aa5754b2e3186/runtime/compiler/x/codegen/J9TreeEvaluator.cpp#L1690\nMeans that all the subsequent if and else if checks will fail! This is because opcode is an indirect load IL, and all the checks are checking for something else, for example:\n   if (opCode.isLoadVar() || (comp->target().is64Bit() && opCode.getOpCodeValue()==TR::l2i))\n...\n   else if (opCode.isStore())\n...\n   else if (opCode.isCall()     &&\n            opCode.isIndirect() &&\n            cg->getNumberBytesReadInaccessible() > TR::Compiler->om.offsetOfObjectVftField())\n...\n   else if (opCode.getOpCodeValue() == TR::monent ||\n            opCode.getOpCodeValue() == TR::monexit)\n...\n   else if (!disableBranchlessPassThroughNULLCHK && opCode.getOpCodeValue () == TR::PassThrough\n            && !needResolution && cg->getHasResumableTrapHandler())\n...\n\nAll of these checks will fail. Surely this is a bug right?", "url": "https://github.com/eclipse-openj9/openj9/pull/11393#discussion_r552979091", "createdAt": "2021-01-06T21:52:41Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/x/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2001,25 +2001,7 @@ TR::Register *J9::X86::TreeEvaluator::evaluateNULLCHKWithPossibleResolve(\n    //\n    if (needLateEvaluation)\n       {\n-      if (comp->useCompressedPointers())\n-         {\n-         // for stores under NULLCHKs, artificially bump\n-         // down the reference count before evaluation (since stores\n-         // return null as registers)\n-         //\n-         bool fixRefCount = false;\n-         if (node->getFirstChild()->getOpCode().isStoreIndirect() &&\n-               node->getFirstChild()->getReferenceCount() > 1)\n-            {\n-            node->getFirstChild()->decReferenceCount();\n-            fixRefCount = true;\n-            }\n-         cg->evaluate(node->getFirstChild());\n-         if (fixRefCount)\n-            node->getFirstChild()->incReferenceCount();\n-         }\n-      else\n-         cg->evaluate(firstChild);\n+      cg->evaluate(firstChild);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk2NjEyNA=="}, "originalCommit": {"oid": "602e95240bd6a245c0e2ff0c95dd61918cd11792"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk3OTg3MQ==", "bodyText": "@0xdaryl I think this may be outside the scope of this PR to fix because the above code has been dead for quite a while. I'm not sure what will happen if we suddenly start running all that code. Let me know what you think on how we should proceed here. The way I see it we have a few options:\n\nLeave the code as is for now and open up an issue\nTry enabling the code and see if any tests fail\nWait until we can common up this evaluator as much of it can be shared across platforms and fix it then\n???\n\nNote to fix the failures observed in this PR is a trivial fix as noted in the first comment in this chain. I'll definitely be making that change. The question here is what to do about reusing firstChild and updating it incorrectly thus making a bunch of subsequent code effectively dead.", "url": "https://github.com/eclipse-openj9/openj9/pull/11393#discussion_r552979871", "createdAt": "2021-01-06T21:54:36Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/x/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2001,25 +2001,7 @@ TR::Register *J9::X86::TreeEvaluator::evaluateNULLCHKWithPossibleResolve(\n    //\n    if (needLateEvaluation)\n       {\n-      if (comp->useCompressedPointers())\n-         {\n-         // for stores under NULLCHKs, artificially bump\n-         // down the reference count before evaluation (since stores\n-         // return null as registers)\n-         //\n-         bool fixRefCount = false;\n-         if (node->getFirstChild()->getOpCode().isStoreIndirect() &&\n-               node->getFirstChild()->getReferenceCount() > 1)\n-            {\n-            node->getFirstChild()->decReferenceCount();\n-            fixRefCount = true;\n-            }\n-         cg->evaluate(node->getFirstChild());\n-         if (fixRefCount)\n-            node->getFirstChild()->incReferenceCount();\n-         }\n-      else\n-         cg->evaluate(firstChild);\n+      cg->evaluate(firstChild);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk2NjEyNA=="}, "originalCommit": {"oid": "602e95240bd6a245c0e2ff0c95dd61918cd11792"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDMyMTYwMA==", "bodyText": "Thanks for the thorough scouring of this code.\nI think the output of the loop on L1683-L1684 will either be an indirect load opcode or a readbar opcode.  If it is an indirect load opcode then the condition on L1710 will still succeed because an indirect load will answer true for an isLoadVar() query.  readbars do seem to skip this logic and will generate an explicit NULLCHK (it isn't clear to me if that is the expected behaviour or not).\nCan you push a fix for just the problem found in this PR?  Any further work we need to investigate can be handled in a separate issue.", "url": "https://github.com/eclipse-openj9/openj9/pull/11393#discussion_r560321600", "createdAt": "2021-01-19T16:43:32Z", "author": {"login": "0xdaryl"}, "path": "runtime/compiler/x/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2001,25 +2001,7 @@ TR::Register *J9::X86::TreeEvaluator::evaluateNULLCHKWithPossibleResolve(\n    //\n    if (needLateEvaluation)\n       {\n-      if (comp->useCompressedPointers())\n-         {\n-         // for stores under NULLCHKs, artificially bump\n-         // down the reference count before evaluation (since stores\n-         // return null as registers)\n-         //\n-         bool fixRefCount = false;\n-         if (node->getFirstChild()->getOpCode().isStoreIndirect() &&\n-               node->getFirstChild()->getReferenceCount() > 1)\n-            {\n-            node->getFirstChild()->decReferenceCount();\n-            fixRefCount = true;\n-            }\n-         cg->evaluate(node->getFirstChild());\n-         if (fixRefCount)\n-            node->getFirstChild()->incReferenceCount();\n-         }\n-      else\n-         cg->evaluate(firstChild);\n+      cg->evaluate(firstChild);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk2NjEyNA=="}, "originalCommit": {"oid": "602e95240bd6a245c0e2ff0c95dd61918cd11792"}, "originalPosition": 23}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 850, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}