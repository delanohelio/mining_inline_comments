{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE4NTE0ODA0", "number": 11141, "title": "Support Static and Special Direct calls on Z for Snapshot", "bodyText": "Implement patchless dispatch sequence for Direct Static or Special calls on Z for Snahoshot configuration.\nSigned-off-by: Rahil Shah rahil@ca.ibm.com", "createdAt": "2020-11-10T14:09:03Z", "url": "https://github.com/eclipse-openj9/openj9/pull/11141", "merged": true, "mergeCommit": {"oid": "a329a02ad7b0bc156193ec9f56c108eb5ddebfc3"}, "closed": true, "closedAt": "2020-11-19T20:10:40Z", "author": {"login": "r30shah"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdbLoYNgBqjM5Nzk3MDcxMjI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdeIhLzgFqTUzNDgxMDU4NQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "52be403fb1a28d6973b058fa2f07d0f8ee134318", "author": {"user": {"login": "r30shah", "name": "Rahil Shah"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/52be403fb1a28d6973b058fa2f07d0f8ee134318", "committedDate": "2020-11-10T14:05:01Z", "message": "Support Static and Special Direct calls on Z for Snapshot\n\nImplement patchless dispatch sequence for Direct Static or Special calls\non Z for Snahoshot configuration.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>"}, "afterCommit": {"oid": "3e8a13d47b78cf5db056d240e5539707d7cc96a7", "author": {"user": {"login": "r30shah", "name": "Rahil Shah"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/3e8a13d47b78cf5db056d240e5539707d7cc96a7", "committedDate": "2020-11-10T16:06:00Z", "message": "Support Static and Special Direct calls on Z for Snapshot\n\nImplement patchless dispatch sequence for Direct Static or Special calls\non Z for Snahoshot configuration.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3e8a13d47b78cf5db056d240e5539707d7cc96a7", "author": {"user": {"login": "r30shah", "name": "Rahil Shah"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/3e8a13d47b78cf5db056d240e5539707d7cc96a7", "committedDate": "2020-11-10T16:06:00Z", "message": "Support Static and Special Direct calls on Z for Snapshot\n\nImplement patchless dispatch sequence for Direct Static or Special calls\non Z for Snahoshot configuration.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>"}, "afterCommit": {"oid": "e8887726f2511f10c68bdf11d17f6f485b1775b6", "author": {"user": {"login": "r30shah", "name": "Rahil Shah"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/e8887726f2511f10c68bdf11d17f6f485b1775b6", "committedDate": "2020-11-16T22:05:33Z", "message": "Support Static and Special Direct calls on Z for Snapshot\n\nImplement patchless dispatch sequence for Direct Static or Special calls\non Z for Snahoshot configuration.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e8887726f2511f10c68bdf11d17f6f485b1775b6", "author": {"user": {"login": "r30shah", "name": "Rahil Shah"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/e8887726f2511f10c68bdf11d17f6f485b1775b6", "committedDate": "2020-11-16T22:05:33Z", "message": "Support Static and Special Direct calls on Z for Snapshot\n\nImplement patchless dispatch sequence for Direct Static or Special calls\non Z for Snahoshot configuration.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>"}, "afterCommit": {"oid": "1fcc8e3db54652281d81f8934ade48d03e9818ec", "author": {"user": {"login": "r30shah", "name": "Rahil Shah"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/1fcc8e3db54652281d81f8934ade48d03e9818ec", "committedDate": "2020-11-17T13:47:12Z", "message": "Support Static and Special Direct calls on Z for Snapshot\n\nImplement patchless dispatch sequence for Direct Static or Special calls\non Z for Snahoshot configuration.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1fcc8e3db54652281d81f8934ade48d03e9818ec", "author": {"user": {"login": "r30shah", "name": "Rahil Shah"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/1fcc8e3db54652281d81f8934ade48d03e9818ec", "committedDate": "2020-11-17T13:47:12Z", "message": "Support Static and Special Direct calls on Z for Snapshot\n\nImplement patchless dispatch sequence for Direct Static or Special calls\non Z for Snahoshot configuration.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>"}, "afterCommit": {"oid": "9a9d9b37daeb983c8d4e295fcc785afeecde5d78", "author": {"user": {"login": "r30shah", "name": "Rahil Shah"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/9a9d9b37daeb983c8d4e295fcc785afeecde5d78", "committedDate": "2020-11-17T13:55:31Z", "message": "Support Static and Special Direct calls on Z for Snapshot\n\nImplement patchless dispatch sequence for Direct Static or Special calls\non Z for Snahoshot configuration.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyNTY0OTY0", "url": "https://github.com/eclipse-openj9/openj9/pull/11141#pullrequestreview-532564964", "createdAt": "2020-11-17T16:38:53Z", "commit": {"oid": "9a9d9b37daeb983c8d4e295fcc785afeecde5d78"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxNjozODo1M1rOH0-Uag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxNzoxMjozOFrOH1ADJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTMwOTAzNA==", "bodyText": "I think we need to place the RI on/off sequence for both RX and RWX dispatches. We need to move this outside the if / else.", "url": "https://github.com/eclipse-openj9/openj9/pull/11141#discussion_r525309034", "createdAt": "2020-11-17T16:38:53Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/S390PrivateLinkage.cpp", "diffHunk": "@@ -2631,29 +2740,36 @@ J9::Z::PrivateLinkage::buildDirectCall(TR::Node * callNode, TR::SymbolReference\n       }\n    else\n       {\n-      if (cg()->getSupportsRuntimeInstrumentation())\n-         TR::TreeEvaluator::generateRuntimeInstrumentationOnOffSequence(cg(), TR::InstOpCode::RIOFF, callNode);\n-\n-      // call through snippet if the method is not resolved or not jitted yet\n-      TR::LabelSymbol * label = generateLabelSymbol(cg());\n-      TR::Snippet * snippet;\n-\n-      if (callSymRef->isUnresolved() || (comp()->compileRelocatableCode() && !comp()->getOption(TR_UseSymbolValidationManager)))\n+      if (comp()->getGenerateReadOnlyCode())\n          {\n-         snippet = new (trHeapMemory()) TR::S390UnresolvedCallSnippet(cg(), callNode, label, argSize);\n+         gcPoint = buildNoPatchingStaticOrSpecialCall(callNode, callSymRef, dependencies, argSize);\n          }\n       else\n-         {\n-         snippet = new (trHeapMemory()) TR::S390J9CallSnippet(cg(), callNode, label, callSymRef, argSize);\n-         }\n+         { \n+         if (cg()->getSupportsRuntimeInstrumentation())\n+            TR::TreeEvaluator::generateRuntimeInstrumentationOnOffSequence(cg(), TR::InstOpCode::RIOFF, callNode);\n \n-      cg()->addSnippet(snippet);\n+         // call through snippet if the method is not resolved or not jitted yet\n+         TR::LabelSymbol * label = generateLabelSymbol(cg());\n+         TR::Snippet * snippet;\n+\n+         if (callSymRef->isUnresolved() || (comp()->compileRelocatableCode() && !comp()->getOption(TR_UseSymbolValidationManager)))\n+            {\n+            snippet = new (trHeapMemory()) TR::S390UnresolvedCallSnippet(cg(), callNode, label, argSize);\n+            }\n+         else\n+            {\n+            snippet = new (trHeapMemory()) TR::S390J9CallSnippet(cg(), callNode, label, callSymRef, argSize);\n+            }\n \n+         cg()->addSnippet(snippet);\n \n-      gcPoint = generateSnippetCall(cg(), callNode, snippet, dependencies, callSymRef);\n \n-      if (cg()->getSupportsRuntimeInstrumentation())\n-         TR::TreeEvaluator::generateRuntimeInstrumentationOnOffSequence(cg(), TR::InstOpCode::RION, callNode);\n+         gcPoint = generateSnippetCall(cg(), callNode, snippet, dependencies, callSymRef);\n+\n+         if (cg()->getSupportsRuntimeInstrumentation())\n+            TR::TreeEvaluator::generateRuntimeInstrumentationOnOffSequence(cg(), TR::InstOpCode::RION, callNode);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a9d9b37daeb983c8d4e295fcc785afeecde5d78"}, "originalPosition": 187}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTMxMjIyNQ==", "bodyText": "We should keep the name of this the same as the field for searchability.", "url": "https://github.com/eclipse-openj9/openj9/pull/11141#discussion_r525312225", "createdAt": "2020-11-17T16:42:16Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/runtime/PicBuilder.m4", "diffHunk": "@@ -167,6 +167,16 @@ SETVAL(eq_InterfaceCallHelperReadOnly_RA,4)\n SETVAL(eq_offsetOfMethodAddrInPICSlot,8)\n SETVAL(eq_sizeOfPICSlotForInterfaceCall,16)\n \n+ZZ Unresolved/Resolved Static and Special Calls Glue\n+SETVAL(eq_ccUnresolvedStaticSpecialCall_methodAddress,0)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a9d9b37daeb983c8d4e295fcc785afeecde5d78"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTMxMzEwMA==", "bodyText": "These seem to have different names. The struct is named ccStaticSpecialData. Should we use the same name here?", "url": "https://github.com/eclipse-openj9/openj9/pull/11141#discussion_r525313100", "createdAt": "2020-11-17T16:43:24Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/runtime/PicBuilder.m4", "diffHunk": "@@ -167,6 +167,16 @@ SETVAL(eq_InterfaceCallHelperReadOnly_RA,4)\n SETVAL(eq_offsetOfMethodAddrInPICSlot,8)\n SETVAL(eq_sizeOfPICSlotForInterfaceCall,16)\n \n+ZZ Unresolved/Resolved Static and Special Calls Glue\n+SETVAL(eq_ccUnresolvedStaticSpecialCall_methodAddress,0)\n+SETVAL(eq_ccUnresolvedStaticSpecialCall_ramMethod,8)\n+SETVAL(eq_ccUnresolvedStaticSpecialCall_cpAddress,16)\n+SETVAL(eq_ccUnresolvedStaticSpecialCall_cpIndex,24)\n+SETVAL(eq_ccStaticOrSpecialCalls_methodAddress,0)\n+SETVAL(eq_ccResolvedStaticSpecialCall_ramMethod,8)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a9d9b37daeb983c8d4e295fcc785afeecde5d78"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTMxNDk4OA==", "bodyText": "Is OSR currently allowed with read only code? Wondering if this should be a fatal assert under read-only mode.", "url": "https://github.com/eclipse-openj9/openj9/pull/11141#discussion_r525314988", "createdAt": "2020-11-17T16:45:51Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/S390PrivateLinkage.cpp", "diffHunk": "@@ -2592,7 +2699,9 @@ J9::Z::PrivateLinkage::buildDirectCall(TR::Node * callNode, TR::SymbolReference\n \n    if (comp()->getOption(TR_TraceCG))\n       traceMsg(comp(), \"Build Direct Call\\n\");\n-\n+   // TODO: For read only code cache, we will need to change the jitInduceOSR\n+   // call below to use the sequence that is works for RXi, Probably a new\n+   // buildDirectCall makes sense here to handle all the cases more cleanly\n    // generate call", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a9d9b37daeb983c8d4e295fcc785afeecde5d78"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTMyMTMwMQ==", "bodyText": "This comment is not very useful. It does not say anything more than the code already does.", "url": "https://github.com/eclipse-openj9/openj9/pull/11141#discussion_r525321301", "createdAt": "2020-11-17T16:54:27Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/S390PrivateLinkage.cpp", "diffHunk": "@@ -2562,6 +2564,111 @@ J9::Z::PrivateLinkage::buildVirtualDispatch(TR::Node * callNode, TR::RegisterDep\n    gcPoint->setNeedsGCMap(getPreservedRegisterMapForGC());\n    }\n \n+TR::Instruction *\n+J9::Z::PrivateLinkage::buildNoPatchingStaticOrSpecialCall(TR::Node *callNode, TR::SymbolReference *callSymRef,\n+   TR::RegisterDependencyConditions *dependencies, int32_t argSize)\n+   {\n+   OMR::CCData *codeCacheData = cg()->getCodeCache()->manager()->getCodeCacheData();\n+   OMR::CCData::index_t index;\n+   intptr_t callSnippetCCDataAddress = NULL;\n+   int32_t  offsetOfSnippetOrCompiledMethod = 0;\n+   if (callSymRef->isUnresolved() || (comp()->compileRelocatableCode() && !comp()->getOption(TR_UseSymbolValidationManager)))\n+      {\n+      // Call Is unresolved. Allocate a CCData.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a9d9b37daeb983c8d4e295fcc785afeecde5d78"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTMyMjUzNA==", "bodyText": "We should initialize this.", "url": "https://github.com/eclipse-openj9/openj9/pull/11141#discussion_r525322534", "createdAt": "2020-11-17T16:55:55Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/S390PrivateLinkage.cpp", "diffHunk": "@@ -2562,6 +2564,111 @@ J9::Z::PrivateLinkage::buildVirtualDispatch(TR::Node * callNode, TR::RegisterDep\n    gcPoint->setNeedsGCMap(getPreservedRegisterMapForGC());\n    }\n \n+TR::Instruction *\n+J9::Z::PrivateLinkage::buildNoPatchingStaticOrSpecialCall(TR::Node *callNode, TR::SymbolReference *callSymRef,\n+   TR::RegisterDependencyConditions *dependencies, int32_t argSize)\n+   {\n+   OMR::CCData *codeCacheData = cg()->getCodeCache()->manager()->getCodeCacheData();\n+   OMR::CCData::index_t index;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a9d9b37daeb983c8d4e295fcc785afeecde5d78"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTMyMzc5NA==", "bodyText": "Shouldn't this be an offsetof(ccStaticSpecialData, ...)? Perhaps a copy/paste error.", "url": "https://github.com/eclipse-openj9/openj9/pull/11141#discussion_r525323794", "createdAt": "2020-11-17T16:57:40Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/S390PrivateLinkage.cpp", "diffHunk": "@@ -2562,6 +2564,111 @@ J9::Z::PrivateLinkage::buildVirtualDispatch(TR::Node * callNode, TR::RegisterDep\n    gcPoint->setNeedsGCMap(getPreservedRegisterMapForGC());\n    }\n \n+TR::Instruction *\n+J9::Z::PrivateLinkage::buildNoPatchingStaticOrSpecialCall(TR::Node *callNode, TR::SymbolReference *callSymRef,\n+   TR::RegisterDependencyConditions *dependencies, int32_t argSize)\n+   {\n+   OMR::CCData *codeCacheData = cg()->getCodeCache()->manager()->getCodeCacheData();\n+   OMR::CCData::index_t index;\n+   intptr_t callSnippetCCDataAddress = NULL;\n+   int32_t  offsetOfSnippetOrCompiledMethod = 0;\n+   if (callSymRef->isUnresolved() || (comp()->compileRelocatableCode() && !comp()->getOption(TR_UseSymbolValidationManager)))\n+      {\n+      // Call Is unresolved. Allocate a CCData.\n+      if (!(codeCacheData->put(NULL, sizeof(ccUnresolvedStaticSpecialData), alignof(ccUnresolvedStaticSpecialData), NULL, index)))\n+         {\n+         cg()->comp()->failCompilation<TR::CompilationException>(\"Could not allocate metadata for static or special call\");\n+         }\n+\n+      ccUnresolvedStaticSpecialData *ccUnresolvedStaticSpecialDataAddress = codeCacheData->get<ccUnresolvedStaticSpecialData>(index);\n+\n+      // Shape of the ccData\n+      // snippetOrCompiledMethod -> to be updated in binary encoding while emitting snippet body\n+      // ramMethod -> Should be NULL for Unresolved\n+      // cpAddress -> Filled here\n+      // cpIndex   -> Filled here\n+\n+      ccUnresolvedStaticSpecialDataAddress->cpAddress = reinterpret_cast<intptr_t>(callNode->getSymbolReference()->getOwningMethod(cg()->comp())->constantPool());\n+      ccUnresolvedStaticSpecialDataAddress->ramMethod = 0;\n+      ccUnresolvedStaticSpecialDataAddress->cpIndex   = static_cast<intptr_t>(callNode->getSymbolReference()->getCPIndexForVM());\n+      callSnippetCCDataAddress = reinterpret_cast<intptr_t>(ccUnresolvedStaticSpecialDataAddress);\n+      offsetOfSnippetOrCompiledMethod = static_cast<int32_t>(offsetof(ccUnresolvedStaticSpecialData, snippetOrCompiledMethod));\n+      }\n+   else\n+      {\n+      if (!(codeCacheData->put(NULL, sizeof(ccStaticSpecialData), alignof(ccStaticSpecialData), NULL, index)))\n+         {\n+         cg()->comp()->failCompilation<TR::CompilationException>(\"Could not allocate metadata for static or special call\");\n+         }\n+\n+      ccStaticSpecialData *ccStaticSpecialDataAddress = codeCacheData->get<ccStaticSpecialData>(index);\n+\n+      // Shape of the ccData\n+      // snippetOrCompiledMethod -> to be updated in binary encoding while emitting snippet body\n+      // ramMethod -> Filled Here\n+      TR::MethodSymbol *methodSymbol = callSymRef->getSymbol()->castToMethodSymbol();\n+      intptr_t ramMethod;\n+#if defined(J9VM_OPT_JITSERVER)\n+      ramMethod = comp()->isOutOfProcessCompilation() && methodSymbol->isInterpreted() ?\n+                     static_cast<intptr_t>(callSymRef->getSymbol()->castToResolvedMethodSymbol()->getResolvedMethod()->getPersistentIdentifier()) :\n+                     static_cast<intptr_t>(methodSymbol->getMethodAddress());\n+#else\n+      ramMethod = reinterpret_cast<intptr_t>(methodSymbol->getMethodAddress());\n+#endif\n+      ccStaticSpecialDataAddress->ramMethod = ramMethod;\n+      callSnippetCCDataAddress = reinterpret_cast<intptr_t>(ccStaticSpecialDataAddress);\n+      offsetOfSnippetOrCompiledMethod = static_cast<int32_t>(offsetof(ccUnresolvedStaticSpecialData, snippetOrCompiledMethod));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a9d9b37daeb983c8d4e295fcc785afeecde5d78"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTMzMDI3NQ==", "bodyText": "Spaces around operators.", "url": "https://github.com/eclipse-openj9/openj9/pull/11141#discussion_r525330275", "createdAt": "2020-11-17T17:04:53Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/S390PrivateLinkage.cpp", "diffHunk": "@@ -2562,6 +2564,111 @@ J9::Z::PrivateLinkage::buildVirtualDispatch(TR::Node * callNode, TR::RegisterDep\n    gcPoint->setNeedsGCMap(getPreservedRegisterMapForGC());\n    }\n \n+TR::Instruction *\n+J9::Z::PrivateLinkage::buildNoPatchingStaticOrSpecialCall(TR::Node *callNode, TR::SymbolReference *callSymRef,\n+   TR::RegisterDependencyConditions *dependencies, int32_t argSize)\n+   {\n+   OMR::CCData *codeCacheData = cg()->getCodeCache()->manager()->getCodeCacheData();\n+   OMR::CCData::index_t index;\n+   intptr_t callSnippetCCDataAddress = NULL;\n+   int32_t  offsetOfSnippetOrCompiledMethod = 0;\n+   if (callSymRef->isUnresolved() || (comp()->compileRelocatableCode() && !comp()->getOption(TR_UseSymbolValidationManager)))\n+      {\n+      // Call Is unresolved. Allocate a CCData.\n+      if (!(codeCacheData->put(NULL, sizeof(ccUnresolvedStaticSpecialData), alignof(ccUnresolvedStaticSpecialData), NULL, index)))\n+         {\n+         cg()->comp()->failCompilation<TR::CompilationException>(\"Could not allocate metadata for static or special call\");\n+         }\n+\n+      ccUnresolvedStaticSpecialData *ccUnresolvedStaticSpecialDataAddress = codeCacheData->get<ccUnresolvedStaticSpecialData>(index);\n+\n+      // Shape of the ccData\n+      // snippetOrCompiledMethod -> to be updated in binary encoding while emitting snippet body\n+      // ramMethod -> Should be NULL for Unresolved\n+      // cpAddress -> Filled here\n+      // cpIndex   -> Filled here\n+\n+      ccUnresolvedStaticSpecialDataAddress->cpAddress = reinterpret_cast<intptr_t>(callNode->getSymbolReference()->getOwningMethod(cg()->comp())->constantPool());\n+      ccUnresolvedStaticSpecialDataAddress->ramMethod = 0;\n+      ccUnresolvedStaticSpecialDataAddress->cpIndex   = static_cast<intptr_t>(callNode->getSymbolReference()->getCPIndexForVM());\n+      callSnippetCCDataAddress = reinterpret_cast<intptr_t>(ccUnresolvedStaticSpecialDataAddress);\n+      offsetOfSnippetOrCompiledMethod = static_cast<int32_t>(offsetof(ccUnresolvedStaticSpecialData, snippetOrCompiledMethod));\n+      }\n+   else\n+      {\n+      if (!(codeCacheData->put(NULL, sizeof(ccStaticSpecialData), alignof(ccStaticSpecialData), NULL, index)))\n+         {\n+         cg()->comp()->failCompilation<TR::CompilationException>(\"Could not allocate metadata for static or special call\");\n+         }\n+\n+      ccStaticSpecialData *ccStaticSpecialDataAddress = codeCacheData->get<ccStaticSpecialData>(index);\n+\n+      // Shape of the ccData\n+      // snippetOrCompiledMethod -> to be updated in binary encoding while emitting snippet body\n+      // ramMethod -> Filled Here\n+      TR::MethodSymbol *methodSymbol = callSymRef->getSymbol()->castToMethodSymbol();\n+      intptr_t ramMethod;\n+#if defined(J9VM_OPT_JITSERVER)\n+      ramMethod = comp()->isOutOfProcessCompilation() && methodSymbol->isInterpreted() ?\n+                     static_cast<intptr_t>(callSymRef->getSymbol()->castToResolvedMethodSymbol()->getResolvedMethod()->getPersistentIdentifier()) :\n+                     static_cast<intptr_t>(methodSymbol->getMethodAddress());\n+#else\n+      ramMethod = reinterpret_cast<intptr_t>(methodSymbol->getMethodAddress());\n+#endif\n+      ccStaticSpecialDataAddress->ramMethod = ramMethod;\n+      callSnippetCCDataAddress = reinterpret_cast<intptr_t>(ccStaticSpecialDataAddress);\n+      offsetOfSnippetOrCompiledMethod = static_cast<int32_t>(offsetof(ccUnresolvedStaticSpecialData, snippetOrCompiledMethod));\n+      }\n+\n+   TR::LabelSymbol *snippetLabel = generateLabelSymbol(cg());\n+   TR::LabelSymbol *doneLabel = generateLabelSymbol(cg());\n+   TR::Snippet *callSnippet = new (trHeapMemory()) TR::S390J9CallSnippetRX(cg(),\n+                                                                           callNode,\n+                                                                           snippetLabel,\n+                                                                           doneLabel,\n+                                                                           callSymRef,\n+                                                                           argSize,\n+                                                                           callSnippetCCDataAddress);\n+   void *targetAddress = reinterpret_cast<void *>(callSnippetCCDataAddress + static_cast<intptr_t>(offsetOfSnippetOrCompiledMethod));\n+   TR::StaticSymbol *snippetOrCompiledSlotSymbol = TR::StaticSymbol::createWithAddress(comp()->trHeapMemory(), TR::Address, targetAddress);\n+   TR::SymbolReference *snippetOrCompiledSlotSymRef = new (comp()->trHeapMemory()) TR::SymbolReference(comp()->getSymRefTab(), snippetOrCompiledSlotSymbol, 0);\n+   snippetOrCompiledSlotSymbol->setNotDataAddress();\n+\n+   TR::RegisterDependencyConditions *preDeps = new (trHeapMemory()) TR::RegisterDependencyConditions(dependencies->getPreConditions(), NULL,\n+                                                                                                      dependencies->getAddCursorForPre(), 0, cg());\n+\n+   int32_t numOfAdditionalPostDeps = 0;\n+   TR::Register *regRA = dependencies->searchPostConditionRegister(getReturnAddressRegister());\n+   if (regRA == NULL)\n+      {\n+      regRA = cg()->allocateRegister();\n+      numOfAdditionalPostDeps+=1;\n+      }\n+\n+   TR::Register *regEP = dependencies->searchPostConditionRegister(getEntryPointRegister());\n+   if (regEP == NULL)\n+      {\n+      regEP = cg()->allocateRegister();\n+      numOfAdditionalPostDeps+=1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a9d9b37daeb983c8d4e295fcc785afeecde5d78"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTMzMTA4OA==", "bodyText": "Why do we need to do this if we already specified 0 preconditions when we allocated the register dependency?", "url": "https://github.com/eclipse-openj9/openj9/pull/11141#discussion_r525331088", "createdAt": "2020-11-17T17:05:30Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/S390PrivateLinkage.cpp", "diffHunk": "@@ -2562,6 +2564,111 @@ J9::Z::PrivateLinkage::buildVirtualDispatch(TR::Node * callNode, TR::RegisterDep\n    gcPoint->setNeedsGCMap(getPreservedRegisterMapForGC());\n    }\n \n+TR::Instruction *\n+J9::Z::PrivateLinkage::buildNoPatchingStaticOrSpecialCall(TR::Node *callNode, TR::SymbolReference *callSymRef,\n+   TR::RegisterDependencyConditions *dependencies, int32_t argSize)\n+   {\n+   OMR::CCData *codeCacheData = cg()->getCodeCache()->manager()->getCodeCacheData();\n+   OMR::CCData::index_t index;\n+   intptr_t callSnippetCCDataAddress = NULL;\n+   int32_t  offsetOfSnippetOrCompiledMethod = 0;\n+   if (callSymRef->isUnresolved() || (comp()->compileRelocatableCode() && !comp()->getOption(TR_UseSymbolValidationManager)))\n+      {\n+      // Call Is unresolved. Allocate a CCData.\n+      if (!(codeCacheData->put(NULL, sizeof(ccUnresolvedStaticSpecialData), alignof(ccUnresolvedStaticSpecialData), NULL, index)))\n+         {\n+         cg()->comp()->failCompilation<TR::CompilationException>(\"Could not allocate metadata for static or special call\");\n+         }\n+\n+      ccUnresolvedStaticSpecialData *ccUnresolvedStaticSpecialDataAddress = codeCacheData->get<ccUnresolvedStaticSpecialData>(index);\n+\n+      // Shape of the ccData\n+      // snippetOrCompiledMethod -> to be updated in binary encoding while emitting snippet body\n+      // ramMethod -> Should be NULL for Unresolved\n+      // cpAddress -> Filled here\n+      // cpIndex   -> Filled here\n+\n+      ccUnresolvedStaticSpecialDataAddress->cpAddress = reinterpret_cast<intptr_t>(callNode->getSymbolReference()->getOwningMethod(cg()->comp())->constantPool());\n+      ccUnresolvedStaticSpecialDataAddress->ramMethod = 0;\n+      ccUnresolvedStaticSpecialDataAddress->cpIndex   = static_cast<intptr_t>(callNode->getSymbolReference()->getCPIndexForVM());\n+      callSnippetCCDataAddress = reinterpret_cast<intptr_t>(ccUnresolvedStaticSpecialDataAddress);\n+      offsetOfSnippetOrCompiledMethod = static_cast<int32_t>(offsetof(ccUnresolvedStaticSpecialData, snippetOrCompiledMethod));\n+      }\n+   else\n+      {\n+      if (!(codeCacheData->put(NULL, sizeof(ccStaticSpecialData), alignof(ccStaticSpecialData), NULL, index)))\n+         {\n+         cg()->comp()->failCompilation<TR::CompilationException>(\"Could not allocate metadata for static or special call\");\n+         }\n+\n+      ccStaticSpecialData *ccStaticSpecialDataAddress = codeCacheData->get<ccStaticSpecialData>(index);\n+\n+      // Shape of the ccData\n+      // snippetOrCompiledMethod -> to be updated in binary encoding while emitting snippet body\n+      // ramMethod -> Filled Here\n+      TR::MethodSymbol *methodSymbol = callSymRef->getSymbol()->castToMethodSymbol();\n+      intptr_t ramMethod;\n+#if defined(J9VM_OPT_JITSERVER)\n+      ramMethod = comp()->isOutOfProcessCompilation() && methodSymbol->isInterpreted() ?\n+                     static_cast<intptr_t>(callSymRef->getSymbol()->castToResolvedMethodSymbol()->getResolvedMethod()->getPersistentIdentifier()) :\n+                     static_cast<intptr_t>(methodSymbol->getMethodAddress());\n+#else\n+      ramMethod = reinterpret_cast<intptr_t>(methodSymbol->getMethodAddress());\n+#endif\n+      ccStaticSpecialDataAddress->ramMethod = ramMethod;\n+      callSnippetCCDataAddress = reinterpret_cast<intptr_t>(ccStaticSpecialDataAddress);\n+      offsetOfSnippetOrCompiledMethod = static_cast<int32_t>(offsetof(ccUnresolvedStaticSpecialData, snippetOrCompiledMethod));\n+      }\n+\n+   TR::LabelSymbol *snippetLabel = generateLabelSymbol(cg());\n+   TR::LabelSymbol *doneLabel = generateLabelSymbol(cg());\n+   TR::Snippet *callSnippet = new (trHeapMemory()) TR::S390J9CallSnippetRX(cg(),\n+                                                                           callNode,\n+                                                                           snippetLabel,\n+                                                                           doneLabel,\n+                                                                           callSymRef,\n+                                                                           argSize,\n+                                                                           callSnippetCCDataAddress);\n+   void *targetAddress = reinterpret_cast<void *>(callSnippetCCDataAddress + static_cast<intptr_t>(offsetOfSnippetOrCompiledMethod));\n+   TR::StaticSymbol *snippetOrCompiledSlotSymbol = TR::StaticSymbol::createWithAddress(comp()->trHeapMemory(), TR::Address, targetAddress);\n+   TR::SymbolReference *snippetOrCompiledSlotSymRef = new (comp()->trHeapMemory()) TR::SymbolReference(comp()->getSymRefTab(), snippetOrCompiledSlotSymbol, 0);\n+   snippetOrCompiledSlotSymbol->setNotDataAddress();\n+\n+   TR::RegisterDependencyConditions *preDeps = new (trHeapMemory()) TR::RegisterDependencyConditions(dependencies->getPreConditions(), NULL,\n+                                                                                                      dependencies->getAddCursorForPre(), 0, cg());\n+\n+   int32_t numOfAdditionalPostDeps = 0;\n+   TR::Register *regRA = dependencies->searchPostConditionRegister(getReturnAddressRegister());\n+   if (regRA == NULL)\n+      {\n+      regRA = cg()->allocateRegister();\n+      numOfAdditionalPostDeps+=1;\n+      }\n+\n+   TR::Register *regEP = dependencies->searchPostConditionRegister(getEntryPointRegister());\n+   if (regEP == NULL)\n+      {\n+      regEP = cg()->allocateRegister();\n+      numOfAdditionalPostDeps+=1;\n+      }\n+\n+   TR::RegisterDependencyConditions *postDeps = new (trHeapMemory()) TR::RegisterDependencyConditions(dependencies, 0, numOfAdditionalPostDeps, cg());\n+   postDeps->setAddCursorForPre(0);\n+   postDeps->setNumPreConditions(0, trMemory());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a9d9b37daeb983c8d4e295fcc785afeecde5d78"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTMzMzk3Ng==", "bodyText": "Why not change the type of callSnippet to be TR::S390J9CallSnippetRX* at the declaration point so we can avoid this cast here?", "url": "https://github.com/eclipse-openj9/openj9/pull/11141#discussion_r525333976", "createdAt": "2020-11-17T17:07:45Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/S390PrivateLinkage.cpp", "diffHunk": "@@ -2562,6 +2564,111 @@ J9::Z::PrivateLinkage::buildVirtualDispatch(TR::Node * callNode, TR::RegisterDep\n    gcPoint->setNeedsGCMap(getPreservedRegisterMapForGC());\n    }\n \n+TR::Instruction *\n+J9::Z::PrivateLinkage::buildNoPatchingStaticOrSpecialCall(TR::Node *callNode, TR::SymbolReference *callSymRef,\n+   TR::RegisterDependencyConditions *dependencies, int32_t argSize)\n+   {\n+   OMR::CCData *codeCacheData = cg()->getCodeCache()->manager()->getCodeCacheData();\n+   OMR::CCData::index_t index;\n+   intptr_t callSnippetCCDataAddress = NULL;\n+   int32_t  offsetOfSnippetOrCompiledMethod = 0;\n+   if (callSymRef->isUnresolved() || (comp()->compileRelocatableCode() && !comp()->getOption(TR_UseSymbolValidationManager)))\n+      {\n+      // Call Is unresolved. Allocate a CCData.\n+      if (!(codeCacheData->put(NULL, sizeof(ccUnresolvedStaticSpecialData), alignof(ccUnresolvedStaticSpecialData), NULL, index)))\n+         {\n+         cg()->comp()->failCompilation<TR::CompilationException>(\"Could not allocate metadata for static or special call\");\n+         }\n+\n+      ccUnresolvedStaticSpecialData *ccUnresolvedStaticSpecialDataAddress = codeCacheData->get<ccUnresolvedStaticSpecialData>(index);\n+\n+      // Shape of the ccData\n+      // snippetOrCompiledMethod -> to be updated in binary encoding while emitting snippet body\n+      // ramMethod -> Should be NULL for Unresolved\n+      // cpAddress -> Filled here\n+      // cpIndex   -> Filled here\n+\n+      ccUnresolvedStaticSpecialDataAddress->cpAddress = reinterpret_cast<intptr_t>(callNode->getSymbolReference()->getOwningMethod(cg()->comp())->constantPool());\n+      ccUnresolvedStaticSpecialDataAddress->ramMethod = 0;\n+      ccUnresolvedStaticSpecialDataAddress->cpIndex   = static_cast<intptr_t>(callNode->getSymbolReference()->getCPIndexForVM());\n+      callSnippetCCDataAddress = reinterpret_cast<intptr_t>(ccUnresolvedStaticSpecialDataAddress);\n+      offsetOfSnippetOrCompiledMethod = static_cast<int32_t>(offsetof(ccUnresolvedStaticSpecialData, snippetOrCompiledMethod));\n+      }\n+   else\n+      {\n+      if (!(codeCacheData->put(NULL, sizeof(ccStaticSpecialData), alignof(ccStaticSpecialData), NULL, index)))\n+         {\n+         cg()->comp()->failCompilation<TR::CompilationException>(\"Could not allocate metadata for static or special call\");\n+         }\n+\n+      ccStaticSpecialData *ccStaticSpecialDataAddress = codeCacheData->get<ccStaticSpecialData>(index);\n+\n+      // Shape of the ccData\n+      // snippetOrCompiledMethod -> to be updated in binary encoding while emitting snippet body\n+      // ramMethod -> Filled Here\n+      TR::MethodSymbol *methodSymbol = callSymRef->getSymbol()->castToMethodSymbol();\n+      intptr_t ramMethod;\n+#if defined(J9VM_OPT_JITSERVER)\n+      ramMethod = comp()->isOutOfProcessCompilation() && methodSymbol->isInterpreted() ?\n+                     static_cast<intptr_t>(callSymRef->getSymbol()->castToResolvedMethodSymbol()->getResolvedMethod()->getPersistentIdentifier()) :\n+                     static_cast<intptr_t>(methodSymbol->getMethodAddress());\n+#else\n+      ramMethod = reinterpret_cast<intptr_t>(methodSymbol->getMethodAddress());\n+#endif\n+      ccStaticSpecialDataAddress->ramMethod = ramMethod;\n+      callSnippetCCDataAddress = reinterpret_cast<intptr_t>(ccStaticSpecialDataAddress);\n+      offsetOfSnippetOrCompiledMethod = static_cast<int32_t>(offsetof(ccUnresolvedStaticSpecialData, snippetOrCompiledMethod));\n+      }\n+\n+   TR::LabelSymbol *snippetLabel = generateLabelSymbol(cg());\n+   TR::LabelSymbol *doneLabel = generateLabelSymbol(cg());\n+   TR::Snippet *callSnippet = new (trHeapMemory()) TR::S390J9CallSnippetRX(cg(),\n+                                                                           callNode,\n+                                                                           snippetLabel,\n+                                                                           doneLabel,\n+                                                                           callSymRef,\n+                                                                           argSize,\n+                                                                           callSnippetCCDataAddress);\n+   void *targetAddress = reinterpret_cast<void *>(callSnippetCCDataAddress + static_cast<intptr_t>(offsetOfSnippetOrCompiledMethod));\n+   TR::StaticSymbol *snippetOrCompiledSlotSymbol = TR::StaticSymbol::createWithAddress(comp()->trHeapMemory(), TR::Address, targetAddress);\n+   TR::SymbolReference *snippetOrCompiledSlotSymRef = new (comp()->trHeapMemory()) TR::SymbolReference(comp()->getSymRefTab(), snippetOrCompiledSlotSymbol, 0);\n+   snippetOrCompiledSlotSymbol->setNotDataAddress();\n+\n+   TR::RegisterDependencyConditions *preDeps = new (trHeapMemory()) TR::RegisterDependencyConditions(dependencies->getPreConditions(), NULL,\n+                                                                                                      dependencies->getAddCursorForPre(), 0, cg());\n+\n+   int32_t numOfAdditionalPostDeps = 0;\n+   TR::Register *regRA = dependencies->searchPostConditionRegister(getReturnAddressRegister());\n+   if (regRA == NULL)\n+      {\n+      regRA = cg()->allocateRegister();\n+      numOfAdditionalPostDeps+=1;\n+      }\n+\n+   TR::Register *regEP = dependencies->searchPostConditionRegister(getEntryPointRegister());\n+   if (regEP == NULL)\n+      {\n+      regEP = cg()->allocateRegister();\n+      numOfAdditionalPostDeps+=1;\n+      }\n+\n+   TR::RegisterDependencyConditions *postDeps = new (trHeapMemory()) TR::RegisterDependencyConditions(dependencies, 0, numOfAdditionalPostDeps, cg());\n+   postDeps->setAddCursorForPre(0);\n+   postDeps->setNumPreConditions(0, trMemory());\n+   postDeps->addPostConditionIfNotAlreadyInserted(regRA, getReturnAddressRegister());\n+   postDeps->addPostConditionIfNotAlreadyInserted(regEP, getEntryPointRegister());\n+\n+   TR::Instruction *cursor = generateS390LabelInstruction(cg(), TR::InstOpCode::LABEL, callNode, generateLabelSymbol(cg()), preDeps);\n+   cursor = generateRILInstruction(cg(), TR::InstOpCode::LGRL, callNode, regRA, snippetOrCompiledSlotSymRef, targetAddress, cursor);\n+   cursor = generateRRInstruction(cg(), TR::InstOpCode::BASR, callNode, regRA, regRA, postDeps, cursor);\n+   ((TR::S390J9CallSnippetRX *)callSnippet)->setBranchInstruction(cursor);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a9d9b37daeb983c8d4e295fcc785afeecde5d78"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTMzNTM0Mg==", "bodyText": "This comment is not very useful. It does not say anything more than the code already does.", "url": "https://github.com/eclipse-openj9/openj9/pull/11141#discussion_r525335342", "createdAt": "2020-11-17T17:09:47Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/S390J9CallSnippet.cpp", "diffHunk": "@@ -1718,3 +1720,183 @@ TR::S390InterfaceCallReadOnlySnippet::getLength(int32_t estimatedSnippetStart)\n            + sizeof(int32_t)  /*RIP offset to PICSlot data address*/\n            + sizeof(int32_t);  /*RIP offset to instruction in mainline*/\n    }\n+ \n+uint8_t *\n+TR::S390J9CallSnippetRX::emitSnippetBody()\n+   {\n+   uint8_t *cursor = cg()->getBinaryBufferCursor();\n+   TR::SymbolReference *callSymRef = getRealMethodSymbolReference();\n+   TR::Node *callNode = getNode();\n+   getSnippetLabel()->setCodeLocation(cursor);\n+   cursor = S390flushArgumentsToStack(cursor, getNode(), getSizeOfArguments(), cg());\n+\n+   //Check if the call is unresolved", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a9d9b37daeb983c8d4e295fcc785afeecde5d78"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTMzNjg1NA==", "bodyText": "Adding a new line right before a comment can go a long way to improve readability and emphasize a logical block of code. Otherwise it just looks like one giant blob of code.", "url": "https://github.com/eclipse-openj9/openj9/pull/11141#discussion_r525336854", "createdAt": "2020-11-17T17:11:49Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/S390J9CallSnippet.cpp", "diffHunk": "@@ -1718,3 +1720,183 @@ TR::S390InterfaceCallReadOnlySnippet::getLength(int32_t estimatedSnippetStart)\n            + sizeof(int32_t)  /*RIP offset to PICSlot data address*/\n            + sizeof(int32_t);  /*RIP offset to instruction in mainline*/\n    }\n+ \n+uint8_t *\n+TR::S390J9CallSnippetRX::emitSnippetBody()\n+   {\n+   uint8_t *cursor = cg()->getBinaryBufferCursor();\n+   TR::SymbolReference *callSymRef = getRealMethodSymbolReference();\n+   TR::Node *callNode = getNode();\n+   getSnippetLabel()->setCodeLocation(cursor);\n+   cursor = S390flushArgumentsToStack(cursor, getNode(), getSizeOfArguments(), cg());\n+\n+   //Check if the call is unresolved\n+   if (callSymRef->isUnresolved() || (cg()->comp()->compileRelocatableCode() && !cg()->comp()->getOption(TR_UseSymbolValidationManager)))\n+      {\n+      typedef J9::Z::PrivateLinkage::ccUnresolvedStaticSpecialData ccUnresolvedStaticSpecialData;\n+      ccUnresolvedStaticSpecialData *ccDataAddress = reinterpret_cast<ccUnresolvedStaticSpecialData *>(callSnippetCCDataAddress);\n+      ccDataAddress->snippetOrCompiledMethod = reinterpret_cast<intptr_t>(getSnippetLabel()->getCodeLocation());\n+      // LGRL  rEP, @(CCUnresolvedStaticOrSpecialData + ramMethod)\n+      intptr_t instrAddr = reinterpret_cast<intptr_t>(cursor);\n+      *cursor = static_cast<uint8_t>(0xC4);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a9d9b37daeb983c8d4e295fcc785afeecde5d78"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTMzNzM4MQ==", "bodyText": "This comment looks incomplete.", "url": "https://github.com/eclipse-openj9/openj9/pull/11141#discussion_r525337381", "createdAt": "2020-11-17T17:12:38Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/S390J9CallSnippet.cpp", "diffHunk": "@@ -1718,3 +1720,183 @@ TR::S390InterfaceCallReadOnlySnippet::getLength(int32_t estimatedSnippetStart)\n            + sizeof(int32_t)  /*RIP offset to PICSlot data address*/\n            + sizeof(int32_t);  /*RIP offset to instruction in mainline*/\n    }\n+ \n+uint8_t *\n+TR::S390J9CallSnippetRX::emitSnippetBody()\n+   {\n+   uint8_t *cursor = cg()->getBinaryBufferCursor();\n+   TR::SymbolReference *callSymRef = getRealMethodSymbolReference();\n+   TR::Node *callNode = getNode();\n+   getSnippetLabel()->setCodeLocation(cursor);\n+   cursor = S390flushArgumentsToStack(cursor, getNode(), getSizeOfArguments(), cg());\n+\n+   //Check if the call is unresolved\n+   if (callSymRef->isUnresolved() || (cg()->comp()->compileRelocatableCode() && !cg()->comp()->getOption(TR_UseSymbolValidationManager)))\n+      {\n+      typedef J9::Z::PrivateLinkage::ccUnresolvedStaticSpecialData ccUnresolvedStaticSpecialData;\n+      ccUnresolvedStaticSpecialData *ccDataAddress = reinterpret_cast<ccUnresolvedStaticSpecialData *>(callSnippetCCDataAddress);\n+      ccDataAddress->snippetOrCompiledMethod = reinterpret_cast<intptr_t>(getSnippetLabel()->getCodeLocation());\n+      // LGRL  rEP, @(CCUnresolvedStaticOrSpecialData + ramMethod)\n+      intptr_t instrAddr = reinterpret_cast<intptr_t>(cursor);\n+      *cursor = static_cast<uint8_t>(0xC4);\n+      cursor += sizeof(uint8_t);\n+      *reinterpret_cast<int8_t *>(cursor) = static_cast<int8_t>(((cg()->getEntryPointRegister() - 1) << 4 ) + 0x8 );\n+      cursor += sizeof(int8_t);\n+      *reinterpret_cast<int32_t *>(cursor) = static_cast<int32_t>((callSnippetCCDataAddress + offsetof(ccUnresolvedStaticSpecialData, ramMethod) - instrAddr) / 2 );\n+      cursor += sizeof(int32_t);\n+\n+      // CGIJ rEP,0,Label\n+      instrAddr = reinterpret_cast<intptr_t>(cursor);\n+      *reinterpret_cast<int8_t *>(cursor) = static_cast<int8_t>(0xEC);\n+      cursor += sizeof(int8_t);\n+      *reinterpret_cast<int8_t *>(cursor) = static_cast<int16_t>(((cg()->getEntryPointRegister() - 1) << 4 ) + 0x6 );\n+      cursor += sizeof(int8_t);\n+\n+      // Now we need to calculate the instruction address for the resolved case, for now Just Skipping the 4 bytes\n+      cursor += sizeof(int32_t);\n+\n+      TR::SymbolReference *helperGlueSymRef = cg()->symRefTab()->findOrCreateRuntimeHelper(callSymRef->getSymbol()->castToMethodSymbol()->isStatic() ? TR_S390interpretedUnresolvedStaticCallGlueRX : TR_S390interpretedUnresolvedSpecialCallGlueRX,\n+                                                                                             false, false, false);\n+      TR::GlobalFunctionCallData dataDestination(helperGlueSymRef, callNode, cursor, cg(), self());\n+\n+      cursor = cg()->getObjFmt()->encodeGlobalFunctionCall(dataDestination);\n+      // Calling the Encode Global FunctionCall and now update the \n+      ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a9d9b37daeb983c8d4e295fcc785afeecde5d78"}, "originalPosition": 61}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "de725983cd06ff96468a76b30321d3f8bb48caea", "author": {"user": {"login": "r30shah", "name": "Rahil Shah"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/de725983cd06ff96468a76b30321d3f8bb48caea", "committedDate": "2020-11-18T16:40:31Z", "message": "Support Static and Special Direct calls on Z for Snapshot\n\nImplement patchless dispatch sequence for Direct Static or Special calls\non Z for Snahoshot configuration.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9a9d9b37daeb983c8d4e295fcc785afeecde5d78", "author": {"user": {"login": "r30shah", "name": "Rahil Shah"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/9a9d9b37daeb983c8d4e295fcc785afeecde5d78", "committedDate": "2020-11-17T13:55:31Z", "message": "Support Static and Special Direct calls on Z for Snapshot\n\nImplement patchless dispatch sequence for Direct Static or Special calls\non Z for Snahoshot configuration.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>"}, "afterCommit": {"oid": "de725983cd06ff96468a76b30321d3f8bb48caea", "author": {"user": {"login": "r30shah", "name": "Rahil Shah"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/de725983cd06ff96468a76b30321d3f8bb48caea", "committedDate": "2020-11-18T16:40:31Z", "message": "Support Static and Special Direct calls on Z for Snapshot\n\nImplement patchless dispatch sequence for Direct Static or Special calls\non Z for Snahoshot configuration.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM0ODEwNTg1", "url": "https://github.com/eclipse-openj9/openj9/pull/11141#pullrequestreview-534810585", "createdAt": "2020-11-19T20:10:27Z", "commit": {"oid": "de725983cd06ff96468a76b30321d3f8bb48caea"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 123, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}