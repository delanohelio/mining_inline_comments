{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMwOTk0NzQ3", "number": 11331, "title": "Fully serialize ROMClasses sent to JITServer", "bodyText": "Packed ROMClasses that JIT client sends to the server do not always include UTF8 strings due to interning. In the current implementation, JITServer requests missing strings from the client and caches them in the client session. To avoid these requests, in this PR the ROMClass is fully serialized with all the required strings that it refers to.\nAll the strings are written at the end of the serialized ROMClass in a fixed order that is determined by the ROMClass walk implementation, regardless of whether they are stored within the bounds of the original ROMClass or interned.\nThe following data is not used by JITServer and is excluded from the resulting packed ROMClass, with their SRPs set to 0:\n\nIntermediate class data.\nStrings that are part of inline method debug info. (The rest of method debug info data is stored in ROMMethod, and removing it would require shifting everything after it and updating SRPs, which is not easy to implement.)\nOther strings that are guaranteed not to be used by JITServer can also be excluded in the future.\n\nNote: this PR depends on #11330\nCloses: #11329", "createdAt": "2020-12-02T12:49:53Z", "url": "https://github.com/eclipse-openj9/openj9/pull/11331", "merged": true, "mergeCommit": {"oid": "899bd1cdf052a81c072f625c15eb695ba489fffc"}, "closed": true, "closedAt": "2021-01-23T02:03:48Z", "author": {"login": "AlexeyKhrabrov"}, "timelineItems": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdi9s70gBqjQwNzQzMzcyMzg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdyZzx9AFqTU3MzY3MjcwNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "01341134b373bea68968721f7af0287770fee39a", "author": {"user": {"login": "AlexeyKhrabrov", "name": "Alexey Khrabrov"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/01341134b373bea68968721f7af0287770fee39a", "committedDate": "2020-12-02T06:18:47Z", "message": "Increment JITServer protocol version\n\nSigned-off-by: Alexey Khrabrov <khrabrov@cs.toronto.edu>"}, "afterCommit": {"oid": "cf8bac93c10483471c4cef95c99e5644d0834e99", "author": {"user": {"login": "AlexeyKhrabrov", "name": "Alexey Khrabrov"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/cf8bac93c10483471c4cef95c99e5644d0834e99", "committedDate": "2020-12-04T20:01:52Z", "message": "Increment JITServer protocol version\n\nSigned-off-by: Alexey Khrabrov <khrabrov@cs.toronto.edu>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ2NTQ1NjY1", "url": "https://github.com/eclipse-openj9/openj9/pull/11331#pullrequestreview-546545665", "createdAt": "2020-12-07T21:20:28Z", "commit": {"oid": "cf8bac93c10483471c4cef95c99e5644d0834e99"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QyMToyMDoyOFrOIA7NJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwMjozMToxMVrOIBEC8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzg0MDkzNQ==", "bodyText": "So, here src is a non-padded string, while dst is padded, correct? I would like a comment of that sort.", "url": "https://github.com/eclipse-openj9/openj9/pull/11331#discussion_r537840935", "createdAt": "2020-12-07T21:20:28Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/control/JITServerHelpers.cpp", "diffHunk": "@@ -44,84 +47,309 @@ TR::Monitor *JITServerHelpers::_clientStreamMonitor = NULL;\n static size_t\n getUTF8Size(const J9UTF8 *str)\n    {\n-   return OMR::alignNoCheck(str->length, sizeof(*str)) + sizeof(*str);\n+   return OMR::alignNoCheck(J9UTF8_TOTAL_SIZE(str), sizeof(*str));\n    }\n \n+// Copies a UTF8 string with padding and returns its total size\n static size_t\n-getPackedUTF8Size(const J9UTF8 *str, const J9ROMClass *romClass)\n+copyUTF8(J9UTF8 *dst, const J9UTF8 *src)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf8bac93c10483471c4cef95c99e5644d0834e99"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzg0MjU2Ng==", "bodyText": "Also please add a comment of what this function returns.\nIsn't easier if we return J9UTF8_TOTAL_SIZE(dst) ?", "url": "https://github.com/eclipse-openj9/openj9/pull/11331#discussion_r537842566", "createdAt": "2020-12-07T21:23:09Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/control/JITServerHelpers.cpp", "diffHunk": "@@ -44,84 +47,309 @@ TR::Monitor *JITServerHelpers::_clientStreamMonitor = NULL;\n static size_t\n getUTF8Size(const J9UTF8 *str)\n    {\n-   return OMR::alignNoCheck(str->length, sizeof(*str)) + sizeof(*str);\n+   return OMR::alignNoCheck(J9UTF8_TOTAL_SIZE(str), sizeof(*str));\n    }\n \n+// Copies a UTF8 string with padding and returns its total size\n static size_t\n-getPackedUTF8Size(const J9UTF8 *str, const J9ROMClass *romClass)\n+copyUTF8(J9UTF8 *dst, const J9UTF8 *src)\n    {\n-   return JITServerHelpers::isAddressInROMClass(str, romClass) ? 0 : getUTF8Size(str);\n+   size_t size = J9UTF8_TOTAL_SIZE(src);\n+   memcpy(dst, src, size);\n+   static_assert(sizeof(*src) == 2, \"UTF8 header is not 2 bytes large\");\n+   if (!OMR::alignedNoCheck(size, sizeof(*src)))\n+      dst->data[src->length] = '\\0';\n+   return OMR::alignNoCheck(size, sizeof(*src));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf8bac93c10483471c4cef95c99e5644d0834e99"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzg0NDE4MA==", "bodyText": "Please add a leading underscore to fields of data structures", "url": "https://github.com/eclipse-openj9/openj9/pull/11331#discussion_r537844180", "createdAt": "2020-12-07T21:25:47Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/control/JITServerHelpers.cpp", "diffHunk": "@@ -44,84 +47,309 @@ TR::Monitor *JITServerHelpers::_clientStreamMonitor = NULL;\n static size_t\n getUTF8Size(const J9UTF8 *str)\n    {\n-   return OMR::alignNoCheck(str->length, sizeof(*str)) + sizeof(*str);\n+   return OMR::alignNoCheck(J9UTF8_TOTAL_SIZE(str), sizeof(*str));\n    }\n \n+// Copies a UTF8 string with padding and returns its total size\n static size_t\n-getPackedUTF8Size(const J9UTF8 *str, const J9ROMClass *romClass)\n+copyUTF8(J9UTF8 *dst, const J9UTF8 *src)\n    {\n-   return JITServerHelpers::isAddressInROMClass(str, romClass) ? 0 : getUTF8Size(str);\n+   size_t size = J9UTF8_TOTAL_SIZE(src);\n+   memcpy(dst, src, size);\n+   static_assert(sizeof(*src) == 2, \"UTF8 header is not 2 bytes large\");\n+   if (!OMR::alignedNoCheck(size, sizeof(*src)))\n+      dst->data[src->length] = '\\0';\n+   return OMR::alignNoCheck(size, sizeof(*src));\n    }\n \n-// If the string points outside of the contiguous part of origRomClass, appends\n-// it (with padding) at curPos and updates the SRP to the string in the packed\n-// ROMClass. Returns the new value of curPos.\n-static uint8_t *\n-packUTF8(uint8_t *curPos, const J9UTF8 *origStr, const J9ROMClass *origRomClass, J9SRP &srp)\n+// State maintained while iterating over UTF8 strings in a ROMClass\n+struct ROMClassPackContext\n    {\n-   if (JITServerHelpers::isAddressInROMClass(origStr, origRomClass))\n-      return curPos;\n+   ROMClassPackContext(TR_Memory *trMemory, size_t origRomSize) :\n+      origSize(origRomSize), callback(NULL), stringsSize(0),\n+      utf8SectionStart((const uint8_t *)-1), utf8SectionEnd(NULL), utf8SectionSize(0),\n+      strToOffsetMap(decltype(strToOffsetMap)::allocator_type(trMemory->currentStackRegion())),\n+      packedRomClass(NULL), cursor(NULL) {}\n \n-   size_t size = getUTF8Size(origStr);\n-   memcpy(curPos, origStr, origStr->length + sizeof(*origStr));\n-   static_assert(sizeof(*origStr) == 2, \"UTF8 header is not 2 bytes large\");\n-   if (!OMR::alignedNoCheck(origStr->length, sizeof(*origStr)))\n-      curPos[size - 1] = '\\0';\n-   NNSRP_SET(srp, curPos);\n-   return curPos + size;\n+   bool isInline(const void *address, const J9ROMClass *romClass)\n+      {\n+      return (address >= romClass) && (address < (uint8_t *)romClass + origSize);\n+      }\n+\n+   typedef void (*Callback)(const J9ROMClass *, const J9SRP *, const char *, ROMClassPackContext &);\n+\n+   const size_t origSize;\n+   Callback callback;\n+   size_t stringsSize;\n+   const uint8_t *utf8SectionStart;\n+   const uint8_t *utf8SectionEnd;// only needed for assertions\n+   size_t utf8SectionSize;// only needed for assertions\n+   // Maps original strings to their offsets from UTF8 section start in the packed ROMClass\n+   // Offset value -1 signifies that the string is skipped\n+   UnorderedMap<const J9UTF8 *, size_t> strToOffsetMap;\n+   J9ROMClass *packedRomClass;\n+   uint8_t *cursor;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf8bac93c10483471c4cef95c99e5644d0834e99"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzg3OTk1Ng==", "bodyText": "is the hint it useful?", "url": "https://github.com/eclipse-openj9/openj9/pull/11331#discussion_r537879956", "createdAt": "2020-12-07T22:26:05Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/control/JITServerHelpers.cpp", "diffHunk": "@@ -44,84 +47,309 @@ TR::Monitor *JITServerHelpers::_clientStreamMonitor = NULL;\n static size_t\n getUTF8Size(const J9UTF8 *str)\n    {\n-   return OMR::alignNoCheck(str->length, sizeof(*str)) + sizeof(*str);\n+   return OMR::alignNoCheck(J9UTF8_TOTAL_SIZE(str), sizeof(*str));\n    }\n \n+// Copies a UTF8 string with padding and returns its total size\n static size_t\n-getPackedUTF8Size(const J9UTF8 *str, const J9ROMClass *romClass)\n+copyUTF8(J9UTF8 *dst, const J9UTF8 *src)\n    {\n-   return JITServerHelpers::isAddressInROMClass(str, romClass) ? 0 : getUTF8Size(str);\n+   size_t size = J9UTF8_TOTAL_SIZE(src);\n+   memcpy(dst, src, size);\n+   static_assert(sizeof(*src) == 2, \"UTF8 header is not 2 bytes large\");\n+   if (!OMR::alignedNoCheck(size, sizeof(*src)))\n+      dst->data[src->length] = '\\0';\n+   return OMR::alignNoCheck(size, sizeof(*src));\n    }\n \n-// If the string points outside of the contiguous part of origRomClass, appends\n-// it (with padding) at curPos and updates the SRP to the string in the packed\n-// ROMClass. Returns the new value of curPos.\n-static uint8_t *\n-packUTF8(uint8_t *curPos, const J9UTF8 *origStr, const J9ROMClass *origRomClass, J9SRP &srp)\n+// State maintained while iterating over UTF8 strings in a ROMClass\n+struct ROMClassPackContext\n    {\n-   if (JITServerHelpers::isAddressInROMClass(origStr, origRomClass))\n-      return curPos;\n+   ROMClassPackContext(TR_Memory *trMemory, size_t origRomSize) :\n+      origSize(origRomSize), callback(NULL), stringsSize(0),\n+      utf8SectionStart((const uint8_t *)-1), utf8SectionEnd(NULL), utf8SectionSize(0),\n+      strToOffsetMap(decltype(strToOffsetMap)::allocator_type(trMemory->currentStackRegion())),\n+      packedRomClass(NULL), cursor(NULL) {}\n \n-   size_t size = getUTF8Size(origStr);\n-   memcpy(curPos, origStr, origStr->length + sizeof(*origStr));\n-   static_assert(sizeof(*origStr) == 2, \"UTF8 header is not 2 bytes large\");\n-   if (!OMR::alignedNoCheck(origStr->length, sizeof(*origStr)))\n-      curPos[size - 1] = '\\0';\n-   NNSRP_SET(srp, curPos);\n-   return curPos + size;\n+   bool isInline(const void *address, const J9ROMClass *romClass)\n+      {\n+      return (address >= romClass) && (address < (uint8_t *)romClass + origSize);\n+      }\n+\n+   typedef void (*Callback)(const J9ROMClass *, const J9SRP *, const char *, ROMClassPackContext &);\n+\n+   const size_t origSize;\n+   Callback callback;\n+   size_t stringsSize;\n+   const uint8_t *utf8SectionStart;\n+   const uint8_t *utf8SectionEnd;// only needed for assertions\n+   size_t utf8SectionSize;// only needed for assertions\n+   // Maps original strings to their offsets from UTF8 section start in the packed ROMClass\n+   // Offset value -1 signifies that the string is skipped\n+   UnorderedMap<const J9UTF8 *, size_t> strToOffsetMap;\n+   J9ROMClass *packedRomClass;\n+   uint8_t *cursor;\n+   };\n+\n+static bool\n+shouldSkipSlot(const char *slotName)\n+   {\n+   // Skip variable names and signatures in method debug info; only their slot names have prefix \"variable\"\n+   static const char prefix[] = \"variable\";\n+   return strncmp(slotName, prefix, sizeof(prefix) - 1) == 0;\n+   }\n+\n+// Updates size info and maps original string to its future location in the packed ROMClass\n+static void\n+sizeInfoCallback(const J9ROMClass *romClass, const J9SRP *origSrp, const char *slotName, ROMClassPackContext &ctx)\n+   {\n+   // Skip SRPs stored outside of the ROMClass bounds such as the ones in out-of-line\n+   // method debug info, and the ones that point to strings not used by the JIT.\n+   bool skip = !ctx.isInline(origSrp, romClass) || shouldSkipSlot(slotName);\n+   auto str = NNSRP_PTR_GET(origSrp, const J9UTF8 *);\n+   auto it = ctx.strToOffsetMap.find(str);\n+   if (it != ctx.strToOffsetMap.end())// duplicate - already visited\n+      {\n+      if (!skip && (it->second == (size_t)-1))\n+         {\n+         // Previously visited SRPs to this string were skipped, but this one isn't\n+         it->second = ctx.stringsSize;\n+         ctx.stringsSize += getUTF8Size(str);\n+         }\n+      return;\n+      }\n+\n+   ctx.strToOffsetMap.insert(it, { str, skip ? (size_t)-1 : ctx.stringsSize });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf8bac93c10483471c4cef95c99e5644d0834e99"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkxNDEwMQ==", "bodyText": "Do strings that were inside the definition of a ROMClass keep their offsets in the packed version?", "url": "https://github.com/eclipse-openj9/openj9/pull/11331#discussion_r537914101", "createdAt": "2020-12-07T23:29:18Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/control/JITServerHelpers.cpp", "diffHunk": "@@ -44,84 +47,309 @@ TR::Monitor *JITServerHelpers::_clientStreamMonitor = NULL;\n static size_t\n getUTF8Size(const J9UTF8 *str)\n    {\n-   return OMR::alignNoCheck(str->length, sizeof(*str)) + sizeof(*str);\n+   return OMR::alignNoCheck(J9UTF8_TOTAL_SIZE(str), sizeof(*str));\n    }\n \n+// Copies a UTF8 string with padding and returns its total size\n static size_t\n-getPackedUTF8Size(const J9UTF8 *str, const J9ROMClass *romClass)\n+copyUTF8(J9UTF8 *dst, const J9UTF8 *src)\n    {\n-   return JITServerHelpers::isAddressInROMClass(str, romClass) ? 0 : getUTF8Size(str);\n+   size_t size = J9UTF8_TOTAL_SIZE(src);\n+   memcpy(dst, src, size);\n+   static_assert(sizeof(*src) == 2, \"UTF8 header is not 2 bytes large\");\n+   if (!OMR::alignedNoCheck(size, sizeof(*src)))\n+      dst->data[src->length] = '\\0';\n+   return OMR::alignNoCheck(size, sizeof(*src));\n    }\n \n-// If the string points outside of the contiguous part of origRomClass, appends\n-// it (with padding) at curPos and updates the SRP to the string in the packed\n-// ROMClass. Returns the new value of curPos.\n-static uint8_t *\n-packUTF8(uint8_t *curPos, const J9UTF8 *origStr, const J9ROMClass *origRomClass, J9SRP &srp)\n+// State maintained while iterating over UTF8 strings in a ROMClass\n+struct ROMClassPackContext\n    {\n-   if (JITServerHelpers::isAddressInROMClass(origStr, origRomClass))\n-      return curPos;\n+   ROMClassPackContext(TR_Memory *trMemory, size_t origRomSize) :\n+      origSize(origRomSize), callback(NULL), stringsSize(0),\n+      utf8SectionStart((const uint8_t *)-1), utf8SectionEnd(NULL), utf8SectionSize(0),\n+      strToOffsetMap(decltype(strToOffsetMap)::allocator_type(trMemory->currentStackRegion())),\n+      packedRomClass(NULL), cursor(NULL) {}\n \n-   size_t size = getUTF8Size(origStr);\n-   memcpy(curPos, origStr, origStr->length + sizeof(*origStr));\n-   static_assert(sizeof(*origStr) == 2, \"UTF8 header is not 2 bytes large\");\n-   if (!OMR::alignedNoCheck(origStr->length, sizeof(*origStr)))\n-      curPos[size - 1] = '\\0';\n-   NNSRP_SET(srp, curPos);\n-   return curPos + size;\n+   bool isInline(const void *address, const J9ROMClass *romClass)\n+      {\n+      return (address >= romClass) && (address < (uint8_t *)romClass + origSize);\n+      }\n+\n+   typedef void (*Callback)(const J9ROMClass *, const J9SRP *, const char *, ROMClassPackContext &);\n+\n+   const size_t origSize;\n+   Callback callback;\n+   size_t stringsSize;\n+   const uint8_t *utf8SectionStart;\n+   const uint8_t *utf8SectionEnd;// only needed for assertions\n+   size_t utf8SectionSize;// only needed for assertions\n+   // Maps original strings to their offsets from UTF8 section start in the packed ROMClass\n+   // Offset value -1 signifies that the string is skipped\n+   UnorderedMap<const J9UTF8 *, size_t> strToOffsetMap;\n+   J9ROMClass *packedRomClass;\n+   uint8_t *cursor;\n+   };\n+\n+static bool\n+shouldSkipSlot(const char *slotName)\n+   {\n+   // Skip variable names and signatures in method debug info; only their slot names have prefix \"variable\"\n+   static const char prefix[] = \"variable\";\n+   return strncmp(slotName, prefix, sizeof(prefix) - 1) == 0;\n+   }\n+\n+// Updates size info and maps original string to its future location in the packed ROMClass\n+static void\n+sizeInfoCallback(const J9ROMClass *romClass, const J9SRP *origSrp, const char *slotName, ROMClassPackContext &ctx)\n+   {\n+   // Skip SRPs stored outside of the ROMClass bounds such as the ones in out-of-line\n+   // method debug info, and the ones that point to strings not used by the JIT.\n+   bool skip = !ctx.isInline(origSrp, romClass) || shouldSkipSlot(slotName);\n+   auto str = NNSRP_PTR_GET(origSrp, const J9UTF8 *);\n+   auto it = ctx.strToOffsetMap.find(str);\n+   if (it != ctx.strToOffsetMap.end())// duplicate - already visited\n+      {\n+      if (!skip && (it->second == (size_t)-1))\n+         {\n+         // Previously visited SRPs to this string were skipped, but this one isn't\n+         it->second = ctx.stringsSize;\n+         ctx.stringsSize += getUTF8Size(str);\n+         }\n+      return;\n+      }\n+\n+   ctx.strToOffsetMap.insert(it, { str, skip ? (size_t)-1 : ctx.stringsSize });\n+   size_t size = getUTF8Size(str);\n+   ctx.stringsSize += skip ? 0 : size;\n+\n+   if (ctx.isInline(str, romClass))\n+      {\n+      ctx.utf8SectionStart = std::min(ctx.utf8SectionStart, (const uint8_t *)str);\n+      ctx.utf8SectionEnd = std::max(ctx.utf8SectionEnd, (const uint8_t *)str + size);\n+      ctx.utf8SectionSize += size;\n+      }\n+   }\n+\n+// Copies original string into its location in the packed ROMClass and updates the SRP to it\n+static void\n+packCallback(const J9ROMClass *romClass, const J9SRP *origSrp, const char *slotName, ROMClassPackContext &ctx)\n+   {\n+   // Skip SRPs stored outside of the ROMClass bounds such as the ones in out-of-line method debug info\n+   if (!ctx.isInline(origSrp, romClass))\n+      return;\n+\n+   auto str = NNSRP_PTR_GET(origSrp, const J9UTF8 *);\n+   auto srp = (J9SRP *)((uint8_t *)ctx.packedRomClass + ((uint8_t *)origSrp - (uint8_t *)romClass));\n+\n+   // Zero out skipped string SRPs\n+   if (shouldSkipSlot(slotName))\n+      {\n+      TR_ASSERT(ctx.strToOffsetMap.find(str) != ctx.strToOffsetMap.end(),\n+                \"UTF8 slot %s not visited in 1st pass\", slotName);\n+      *srp = 0;\n+      return;\n+      }\n+\n+   auto it = ctx.strToOffsetMap.find(str);\n+   TR_ASSERT(it != ctx.strToOffsetMap.end(), \"UTF8 slot %s not visited in 1st pass\", slotName);\n+   auto dst = (uint8_t *)ctx.packedRomClass + (ctx.utf8SectionStart - (uint8_t *)romClass) + it->second;\n+\n+   NNSRP_PTR_SET(srp, dst);\n+   if (dst == ctx.cursor)\n+      ctx.cursor += copyUTF8((J9UTF8 *)dst, str);\n+   else\n+      TR_ASSERT((dst < ctx.cursor) && (memcmp(dst, str, J9UTF8_TOTAL_SIZE(str)) == 0), \"Must be already copied\");\n+   }\n+\n+static void\n+utf8SlotCallback(const J9ROMClass *romClass, const J9SRP *srp, const char *slotName, void *userData)\n+   {\n+   auto &ctx = *(ROMClassPackContext *)userData;\n+   if (*srp)\n+      ctx.callback(romClass, srp, slotName, ctx);\n+   }\n+\n+// Invoked for each slot in a ROMClass. Calls ctx.callback() for all non-null SRPs to UTF8 strings.\n+static void\n+slotCallback(J9ROMClass *romClass, uint32_t slotType, void *slotPtr, const char *slotName, void *userData)\n+   {\n+   switch (slotType)\n+      {\n+      case J9ROM_UTF8:\n+         utf8SlotCallback(romClass, (const J9SRP *)slotPtr, slotName, userData);\n+         break;\n+\n+      case J9ROM_NAS:\n+         if (auto nas = SRP_PTR_GET(slotPtr, const J9ROMNameAndSignature *))\n+            {\n+            utf8SlotCallback(romClass, &nas->name, slotName, userData);\n+            utf8SlotCallback(romClass, &nas->signature, slotName, userData);\n+            }\n+         break;\n+      }\n+   }\n+\n+static bool\n+isArrayROMClass(const J9ROMClass *romClass)\n+   {\n+   if (!J9ROMCLASS_IS_ARRAY(romClass))\n+      return false;\n+\n+   auto name = J9ROMCLASS_CLASSNAME(romClass);\n+   TR_ASSERT((name->length == 2) && (name->data[0] == '['),\n+             \"Unexpected array ROMClass name: %.*s\", name->length, name->data);\n+   return true;\n+   }\n+\n+// Array ROMClasses have a different layout (see runtime/vm/romclasses.c):\n+// they all share the same SRP array of interfaces, which breaks the generic\n+// packing implementation. Instead, we manually pack all the data stored\n+// outside of the ROMClass header: class name, superclass name, interfaces.\n+// This function returns the total size of the packed array ROMClass.\n+static size_t\n+getArrayROMClassPackedSize(const J9ROMClass *romClass)\n+   {\n+   size_t totalSize = sizeof(*romClass);\n+   totalSize += getUTF8Size(J9ROMCLASS_CLASSNAME(romClass));\n+   totalSize += getUTF8Size(J9ROMCLASS_SUPERCLASSNAME(romClass));\n+\n+   totalSize += romClass->interfaceCount * sizeof(J9SRP);\n+   for (size_t i = 0; i < romClass->interfaceCount; ++i)\n+      {\n+      auto name = NNSRP_GET(J9ROMCLASS_INTERFACES(romClass)[i], const J9UTF8 *);\n+      totalSize += getUTF8Size(name);\n+      }\n+\n+   return OMR::alignNoCheck(totalSize, sizeof(uint64_t));\n+   }\n+\n+static void\n+packUTF8(const J9UTF8 *str, J9SRP &srp, ROMClassPackContext &ctx)\n+   {\n+   NNSRP_SET(srp, ctx.cursor);\n+   ctx.cursor += copyUTF8((J9UTF8 *)ctx.cursor, str);\n+   }\n+\n+// Packs the data stored outside of the array ROMClass header\n+static void\n+packArrayROMClassData(const J9ROMClass *romClass, ROMClassPackContext &ctx)\n+   {\n+   NNSRP_SET(ctx.packedRomClass->interfaces, ctx.cursor);\n+   ctx.cursor += ctx.packedRomClass->interfaceCount * sizeof(J9SRP);\n+\n+   packUTF8(J9ROMCLASS_CLASSNAME(romClass), ctx.packedRomClass->className, ctx);\n+   packUTF8(J9ROMCLASS_SUPERCLASSNAME(romClass), ctx.packedRomClass->superclassName, ctx);\n+\n+   for (size_t i = 0; i < romClass->interfaceCount; ++i)\n+      {\n+      auto name = NNSRP_GET(J9ROMCLASS_INTERFACES(romClass)[i], const J9UTF8 *);\n+      packUTF8(name, J9ROMCLASS_INTERFACES(ctx.packedRomClass)[i], ctx);\n+      }\n    }\n \n // Packs a ROMClass into a std::string to be transferred to the server.\n-// Some of the name and signature strings are interned and stored outside\n-// of the ROMClass body. Such strings are appended to the end of the cloned\n-// ROMClass body and the self referential pointers to them are updated.\n+// UTF8 strings that a ROMClass refers to can be interned and stored outside of\n+// the ROMClass body. This function puts all the strings (including interned ones)\n+// at the end of the cloned ROMClass in deterministic order and updates the SRPs\n+// to them. It also removes some of the data that is not used by the JIT compiler.\n+//\n+// Packing involves 2 passes over all the strings that a ROMClass refers to:\n+// 1. Compute total size and map original strings to their locations in the packed ROMClass.\n+// 2. Copy each original string to its location in the packed ROMClass.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf8bac93c10483471c4cef95c99e5644d0834e99"}, "originalPosition": 247}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk2MDQxNA==", "bodyText": "What is intermediate class data?", "url": "https://github.com/eclipse-openj9/openj9/pull/11331#discussion_r537960414", "createdAt": "2020-12-08T01:24:32Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/control/JITServerHelpers.cpp", "diffHunk": "@@ -44,84 +47,309 @@ TR::Monitor *JITServerHelpers::_clientStreamMonitor = NULL;\n static size_t\n getUTF8Size(const J9UTF8 *str)\n    {\n-   return OMR::alignNoCheck(str->length, sizeof(*str)) + sizeof(*str);\n+   return OMR::alignNoCheck(J9UTF8_TOTAL_SIZE(str), sizeof(*str));\n    }\n \n+// Copies a UTF8 string with padding and returns its total size\n static size_t\n-getPackedUTF8Size(const J9UTF8 *str, const J9ROMClass *romClass)\n+copyUTF8(J9UTF8 *dst, const J9UTF8 *src)\n    {\n-   return JITServerHelpers::isAddressInROMClass(str, romClass) ? 0 : getUTF8Size(str);\n+   size_t size = J9UTF8_TOTAL_SIZE(src);\n+   memcpy(dst, src, size);\n+   static_assert(sizeof(*src) == 2, \"UTF8 header is not 2 bytes large\");\n+   if (!OMR::alignedNoCheck(size, sizeof(*src)))\n+      dst->data[src->length] = '\\0';\n+   return OMR::alignNoCheck(size, sizeof(*src));\n    }\n \n-// If the string points outside of the contiguous part of origRomClass, appends\n-// it (with padding) at curPos and updates the SRP to the string in the packed\n-// ROMClass. Returns the new value of curPos.\n-static uint8_t *\n-packUTF8(uint8_t *curPos, const J9UTF8 *origStr, const J9ROMClass *origRomClass, J9SRP &srp)\n+// State maintained while iterating over UTF8 strings in a ROMClass\n+struct ROMClassPackContext\n    {\n-   if (JITServerHelpers::isAddressInROMClass(origStr, origRomClass))\n-      return curPos;\n+   ROMClassPackContext(TR_Memory *trMemory, size_t origRomSize) :\n+      origSize(origRomSize), callback(NULL), stringsSize(0),\n+      utf8SectionStart((const uint8_t *)-1), utf8SectionEnd(NULL), utf8SectionSize(0),\n+      strToOffsetMap(decltype(strToOffsetMap)::allocator_type(trMemory->currentStackRegion())),\n+      packedRomClass(NULL), cursor(NULL) {}\n \n-   size_t size = getUTF8Size(origStr);\n-   memcpy(curPos, origStr, origStr->length + sizeof(*origStr));\n-   static_assert(sizeof(*origStr) == 2, \"UTF8 header is not 2 bytes large\");\n-   if (!OMR::alignedNoCheck(origStr->length, sizeof(*origStr)))\n-      curPos[size - 1] = '\\0';\n-   NNSRP_SET(srp, curPos);\n-   return curPos + size;\n+   bool isInline(const void *address, const J9ROMClass *romClass)\n+      {\n+      return (address >= romClass) && (address < (uint8_t *)romClass + origSize);\n+      }\n+\n+   typedef void (*Callback)(const J9ROMClass *, const J9SRP *, const char *, ROMClassPackContext &);\n+\n+   const size_t origSize;\n+   Callback callback;\n+   size_t stringsSize;\n+   const uint8_t *utf8SectionStart;\n+   const uint8_t *utf8SectionEnd;// only needed for assertions\n+   size_t utf8SectionSize;// only needed for assertions\n+   // Maps original strings to their offsets from UTF8 section start in the packed ROMClass\n+   // Offset value -1 signifies that the string is skipped\n+   UnorderedMap<const J9UTF8 *, size_t> strToOffsetMap;\n+   J9ROMClass *packedRomClass;\n+   uint8_t *cursor;\n+   };\n+\n+static bool\n+shouldSkipSlot(const char *slotName)\n+   {\n+   // Skip variable names and signatures in method debug info; only their slot names have prefix \"variable\"\n+   static const char prefix[] = \"variable\";\n+   return strncmp(slotName, prefix, sizeof(prefix) - 1) == 0;\n+   }\n+\n+// Updates size info and maps original string to its future location in the packed ROMClass\n+static void\n+sizeInfoCallback(const J9ROMClass *romClass, const J9SRP *origSrp, const char *slotName, ROMClassPackContext &ctx)\n+   {\n+   // Skip SRPs stored outside of the ROMClass bounds such as the ones in out-of-line\n+   // method debug info, and the ones that point to strings not used by the JIT.\n+   bool skip = !ctx.isInline(origSrp, romClass) || shouldSkipSlot(slotName);\n+   auto str = NNSRP_PTR_GET(origSrp, const J9UTF8 *);\n+   auto it = ctx.strToOffsetMap.find(str);\n+   if (it != ctx.strToOffsetMap.end())// duplicate - already visited\n+      {\n+      if (!skip && (it->second == (size_t)-1))\n+         {\n+         // Previously visited SRPs to this string were skipped, but this one isn't\n+         it->second = ctx.stringsSize;\n+         ctx.stringsSize += getUTF8Size(str);\n+         }\n+      return;\n+      }\n+\n+   ctx.strToOffsetMap.insert(it, { str, skip ? (size_t)-1 : ctx.stringsSize });\n+   size_t size = getUTF8Size(str);\n+   ctx.stringsSize += skip ? 0 : size;\n+\n+   if (ctx.isInline(str, romClass))\n+      {\n+      ctx.utf8SectionStart = std::min(ctx.utf8SectionStart, (const uint8_t *)str);\n+      ctx.utf8SectionEnd = std::max(ctx.utf8SectionEnd, (const uint8_t *)str + size);\n+      ctx.utf8SectionSize += size;\n+      }\n+   }\n+\n+// Copies original string into its location in the packed ROMClass and updates the SRP to it\n+static void\n+packCallback(const J9ROMClass *romClass, const J9SRP *origSrp, const char *slotName, ROMClassPackContext &ctx)\n+   {\n+   // Skip SRPs stored outside of the ROMClass bounds such as the ones in out-of-line method debug info\n+   if (!ctx.isInline(origSrp, romClass))\n+      return;\n+\n+   auto str = NNSRP_PTR_GET(origSrp, const J9UTF8 *);\n+   auto srp = (J9SRP *)((uint8_t *)ctx.packedRomClass + ((uint8_t *)origSrp - (uint8_t *)romClass));\n+\n+   // Zero out skipped string SRPs\n+   if (shouldSkipSlot(slotName))\n+      {\n+      TR_ASSERT(ctx.strToOffsetMap.find(str) != ctx.strToOffsetMap.end(),\n+                \"UTF8 slot %s not visited in 1st pass\", slotName);\n+      *srp = 0;\n+      return;\n+      }\n+\n+   auto it = ctx.strToOffsetMap.find(str);\n+   TR_ASSERT(it != ctx.strToOffsetMap.end(), \"UTF8 slot %s not visited in 1st pass\", slotName);\n+   auto dst = (uint8_t *)ctx.packedRomClass + (ctx.utf8SectionStart - (uint8_t *)romClass) + it->second;\n+\n+   NNSRP_PTR_SET(srp, dst);\n+   if (dst == ctx.cursor)\n+      ctx.cursor += copyUTF8((J9UTF8 *)dst, str);\n+   else\n+      TR_ASSERT((dst < ctx.cursor) && (memcmp(dst, str, J9UTF8_TOTAL_SIZE(str)) == 0), \"Must be already copied\");\n+   }\n+\n+static void\n+utf8SlotCallback(const J9ROMClass *romClass, const J9SRP *srp, const char *slotName, void *userData)\n+   {\n+   auto &ctx = *(ROMClassPackContext *)userData;\n+   if (*srp)\n+      ctx.callback(romClass, srp, slotName, ctx);\n+   }\n+\n+// Invoked for each slot in a ROMClass. Calls ctx.callback() for all non-null SRPs to UTF8 strings.\n+static void\n+slotCallback(J9ROMClass *romClass, uint32_t slotType, void *slotPtr, const char *slotName, void *userData)\n+   {\n+   switch (slotType)\n+      {\n+      case J9ROM_UTF8:\n+         utf8SlotCallback(romClass, (const J9SRP *)slotPtr, slotName, userData);\n+         break;\n+\n+      case J9ROM_NAS:\n+         if (auto nas = SRP_PTR_GET(slotPtr, const J9ROMNameAndSignature *))\n+            {\n+            utf8SlotCallback(romClass, &nas->name, slotName, userData);\n+            utf8SlotCallback(romClass, &nas->signature, slotName, userData);\n+            }\n+         break;\n+      }\n+   }\n+\n+static bool\n+isArrayROMClass(const J9ROMClass *romClass)\n+   {\n+   if (!J9ROMCLASS_IS_ARRAY(romClass))\n+      return false;\n+\n+   auto name = J9ROMCLASS_CLASSNAME(romClass);\n+   TR_ASSERT((name->length == 2) && (name->data[0] == '['),\n+             \"Unexpected array ROMClass name: %.*s\", name->length, name->data);\n+   return true;\n+   }\n+\n+// Array ROMClasses have a different layout (see runtime/vm/romclasses.c):\n+// they all share the same SRP array of interfaces, which breaks the generic\n+// packing implementation. Instead, we manually pack all the data stored\n+// outside of the ROMClass header: class name, superclass name, interfaces.\n+// This function returns the total size of the packed array ROMClass.\n+static size_t\n+getArrayROMClassPackedSize(const J9ROMClass *romClass)\n+   {\n+   size_t totalSize = sizeof(*romClass);\n+   totalSize += getUTF8Size(J9ROMCLASS_CLASSNAME(romClass));\n+   totalSize += getUTF8Size(J9ROMCLASS_SUPERCLASSNAME(romClass));\n+\n+   totalSize += romClass->interfaceCount * sizeof(J9SRP);\n+   for (size_t i = 0; i < romClass->interfaceCount; ++i)\n+      {\n+      auto name = NNSRP_GET(J9ROMCLASS_INTERFACES(romClass)[i], const J9UTF8 *);\n+      totalSize += getUTF8Size(name);\n+      }\n+\n+   return OMR::alignNoCheck(totalSize, sizeof(uint64_t));\n+   }\n+\n+static void\n+packUTF8(const J9UTF8 *str, J9SRP &srp, ROMClassPackContext &ctx)\n+   {\n+   NNSRP_SET(srp, ctx.cursor);\n+   ctx.cursor += copyUTF8((J9UTF8 *)ctx.cursor, str);\n+   }\n+\n+// Packs the data stored outside of the array ROMClass header\n+static void\n+packArrayROMClassData(const J9ROMClass *romClass, ROMClassPackContext &ctx)\n+   {\n+   NNSRP_SET(ctx.packedRomClass->interfaces, ctx.cursor);\n+   ctx.cursor += ctx.packedRomClass->interfaceCount * sizeof(J9SRP);\n+\n+   packUTF8(J9ROMCLASS_CLASSNAME(romClass), ctx.packedRomClass->className, ctx);\n+   packUTF8(J9ROMCLASS_SUPERCLASSNAME(romClass), ctx.packedRomClass->superclassName, ctx);\n+\n+   for (size_t i = 0; i < romClass->interfaceCount; ++i)\n+      {\n+      auto name = NNSRP_GET(J9ROMCLASS_INTERFACES(romClass)[i], const J9UTF8 *);\n+      packUTF8(name, J9ROMCLASS_INTERFACES(ctx.packedRomClass)[i], ctx);\n+      }\n    }\n \n // Packs a ROMClass into a std::string to be transferred to the server.\n-// Some of the name and signature strings are interned and stored outside\n-// of the ROMClass body. Such strings are appended to the end of the cloned\n-// ROMClass body and the self referential pointers to them are updated.\n+// UTF8 strings that a ROMClass refers to can be interned and stored outside of\n+// the ROMClass body. This function puts all the strings (including interned ones)\n+// at the end of the cloned ROMClass in deterministic order and updates the SRPs\n+// to them. It also removes some of the data that is not used by the JIT compiler.\n+//\n+// Packing involves 2 passes over all the strings that a ROMClass refers to:\n+// 1. Compute total size and map original strings to their locations in the packed ROMClass.\n+// 2. Copy each original string to its location in the packed ROMClass.\n static std::string\n-packROMClass(J9ROMClass *origRomClass, TR_Memory *trMemory)\n+packROMClass(J9ROMClass *romClass, TR_Memory *trMemory)\n    {\n-   size_t totalSize = origRomClass->romSize;\n-   J9UTF8 *className = J9ROMCLASS_CLASSNAME(origRomClass);\n-   totalSize += getPackedUTF8Size(className, origRomClass);\n-\n-   J9ROMMethod *romMethod = J9ROMCLASS_ROMMETHODS(origRomClass);\n-   for (size_t i = 0; i < origRomClass->romMethodCount; ++i)\n+   auto name = J9ROMCLASS_CLASSNAME(romClass);\n+   // Primitive ROMClasses have different layout (see runtime/vm/romclasses.c): the last\n+   // ROMClass includes all the others' UTF8 name strings in its romSize, which breaks the\n+   // generic packing implementation. Pretend that its romSize only includes the header.\n+   size_t origRomSize = J9ROMCLASS_IS_PRIMITIVE_TYPE(romClass) ? sizeof(*romClass) : romClass->romSize;\n+   size_t totalSize = origRomSize;\n+\n+   // Remove intermediate class data (not used by JIT)\n+   uint8_t *icData = J9ROMCLASS_INTERMEDIATECLASSDATA(romClass);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf8bac93c10483471c4cef95c99e5644d0834e99"}, "originalPosition": 266}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk2MDk3Nw==", "bodyText": "I am guessing that you cannot have intermediate class data for primitive classes that only have the \"header\"", "url": "https://github.com/eclipse-openj9/openj9/pull/11331#discussion_r537960977", "createdAt": "2020-12-08T01:26:11Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/control/JITServerHelpers.cpp", "diffHunk": "@@ -44,84 +47,309 @@ TR::Monitor *JITServerHelpers::_clientStreamMonitor = NULL;\n static size_t\n getUTF8Size(const J9UTF8 *str)\n    {\n-   return OMR::alignNoCheck(str->length, sizeof(*str)) + sizeof(*str);\n+   return OMR::alignNoCheck(J9UTF8_TOTAL_SIZE(str), sizeof(*str));\n    }\n \n+// Copies a UTF8 string with padding and returns its total size\n static size_t\n-getPackedUTF8Size(const J9UTF8 *str, const J9ROMClass *romClass)\n+copyUTF8(J9UTF8 *dst, const J9UTF8 *src)\n    {\n-   return JITServerHelpers::isAddressInROMClass(str, romClass) ? 0 : getUTF8Size(str);\n+   size_t size = J9UTF8_TOTAL_SIZE(src);\n+   memcpy(dst, src, size);\n+   static_assert(sizeof(*src) == 2, \"UTF8 header is not 2 bytes large\");\n+   if (!OMR::alignedNoCheck(size, sizeof(*src)))\n+      dst->data[src->length] = '\\0';\n+   return OMR::alignNoCheck(size, sizeof(*src));\n    }\n \n-// If the string points outside of the contiguous part of origRomClass, appends\n-// it (with padding) at curPos and updates the SRP to the string in the packed\n-// ROMClass. Returns the new value of curPos.\n-static uint8_t *\n-packUTF8(uint8_t *curPos, const J9UTF8 *origStr, const J9ROMClass *origRomClass, J9SRP &srp)\n+// State maintained while iterating over UTF8 strings in a ROMClass\n+struct ROMClassPackContext\n    {\n-   if (JITServerHelpers::isAddressInROMClass(origStr, origRomClass))\n-      return curPos;\n+   ROMClassPackContext(TR_Memory *trMemory, size_t origRomSize) :\n+      origSize(origRomSize), callback(NULL), stringsSize(0),\n+      utf8SectionStart((const uint8_t *)-1), utf8SectionEnd(NULL), utf8SectionSize(0),\n+      strToOffsetMap(decltype(strToOffsetMap)::allocator_type(trMemory->currentStackRegion())),\n+      packedRomClass(NULL), cursor(NULL) {}\n \n-   size_t size = getUTF8Size(origStr);\n-   memcpy(curPos, origStr, origStr->length + sizeof(*origStr));\n-   static_assert(sizeof(*origStr) == 2, \"UTF8 header is not 2 bytes large\");\n-   if (!OMR::alignedNoCheck(origStr->length, sizeof(*origStr)))\n-      curPos[size - 1] = '\\0';\n-   NNSRP_SET(srp, curPos);\n-   return curPos + size;\n+   bool isInline(const void *address, const J9ROMClass *romClass)\n+      {\n+      return (address >= romClass) && (address < (uint8_t *)romClass + origSize);\n+      }\n+\n+   typedef void (*Callback)(const J9ROMClass *, const J9SRP *, const char *, ROMClassPackContext &);\n+\n+   const size_t origSize;\n+   Callback callback;\n+   size_t stringsSize;\n+   const uint8_t *utf8SectionStart;\n+   const uint8_t *utf8SectionEnd;// only needed for assertions\n+   size_t utf8SectionSize;// only needed for assertions\n+   // Maps original strings to their offsets from UTF8 section start in the packed ROMClass\n+   // Offset value -1 signifies that the string is skipped\n+   UnorderedMap<const J9UTF8 *, size_t> strToOffsetMap;\n+   J9ROMClass *packedRomClass;\n+   uint8_t *cursor;\n+   };\n+\n+static bool\n+shouldSkipSlot(const char *slotName)\n+   {\n+   // Skip variable names and signatures in method debug info; only their slot names have prefix \"variable\"\n+   static const char prefix[] = \"variable\";\n+   return strncmp(slotName, prefix, sizeof(prefix) - 1) == 0;\n+   }\n+\n+// Updates size info and maps original string to its future location in the packed ROMClass\n+static void\n+sizeInfoCallback(const J9ROMClass *romClass, const J9SRP *origSrp, const char *slotName, ROMClassPackContext &ctx)\n+   {\n+   // Skip SRPs stored outside of the ROMClass bounds such as the ones in out-of-line\n+   // method debug info, and the ones that point to strings not used by the JIT.\n+   bool skip = !ctx.isInline(origSrp, romClass) || shouldSkipSlot(slotName);\n+   auto str = NNSRP_PTR_GET(origSrp, const J9UTF8 *);\n+   auto it = ctx.strToOffsetMap.find(str);\n+   if (it != ctx.strToOffsetMap.end())// duplicate - already visited\n+      {\n+      if (!skip && (it->second == (size_t)-1))\n+         {\n+         // Previously visited SRPs to this string were skipped, but this one isn't\n+         it->second = ctx.stringsSize;\n+         ctx.stringsSize += getUTF8Size(str);\n+         }\n+      return;\n+      }\n+\n+   ctx.strToOffsetMap.insert(it, { str, skip ? (size_t)-1 : ctx.stringsSize });\n+   size_t size = getUTF8Size(str);\n+   ctx.stringsSize += skip ? 0 : size;\n+\n+   if (ctx.isInline(str, romClass))\n+      {\n+      ctx.utf8SectionStart = std::min(ctx.utf8SectionStart, (const uint8_t *)str);\n+      ctx.utf8SectionEnd = std::max(ctx.utf8SectionEnd, (const uint8_t *)str + size);\n+      ctx.utf8SectionSize += size;\n+      }\n+   }\n+\n+// Copies original string into its location in the packed ROMClass and updates the SRP to it\n+static void\n+packCallback(const J9ROMClass *romClass, const J9SRP *origSrp, const char *slotName, ROMClassPackContext &ctx)\n+   {\n+   // Skip SRPs stored outside of the ROMClass bounds such as the ones in out-of-line method debug info\n+   if (!ctx.isInline(origSrp, romClass))\n+      return;\n+\n+   auto str = NNSRP_PTR_GET(origSrp, const J9UTF8 *);\n+   auto srp = (J9SRP *)((uint8_t *)ctx.packedRomClass + ((uint8_t *)origSrp - (uint8_t *)romClass));\n+\n+   // Zero out skipped string SRPs\n+   if (shouldSkipSlot(slotName))\n+      {\n+      TR_ASSERT(ctx.strToOffsetMap.find(str) != ctx.strToOffsetMap.end(),\n+                \"UTF8 slot %s not visited in 1st pass\", slotName);\n+      *srp = 0;\n+      return;\n+      }\n+\n+   auto it = ctx.strToOffsetMap.find(str);\n+   TR_ASSERT(it != ctx.strToOffsetMap.end(), \"UTF8 slot %s not visited in 1st pass\", slotName);\n+   auto dst = (uint8_t *)ctx.packedRomClass + (ctx.utf8SectionStart - (uint8_t *)romClass) + it->second;\n+\n+   NNSRP_PTR_SET(srp, dst);\n+   if (dst == ctx.cursor)\n+      ctx.cursor += copyUTF8((J9UTF8 *)dst, str);\n+   else\n+      TR_ASSERT((dst < ctx.cursor) && (memcmp(dst, str, J9UTF8_TOTAL_SIZE(str)) == 0), \"Must be already copied\");\n+   }\n+\n+static void\n+utf8SlotCallback(const J9ROMClass *romClass, const J9SRP *srp, const char *slotName, void *userData)\n+   {\n+   auto &ctx = *(ROMClassPackContext *)userData;\n+   if (*srp)\n+      ctx.callback(romClass, srp, slotName, ctx);\n+   }\n+\n+// Invoked for each slot in a ROMClass. Calls ctx.callback() for all non-null SRPs to UTF8 strings.\n+static void\n+slotCallback(J9ROMClass *romClass, uint32_t slotType, void *slotPtr, const char *slotName, void *userData)\n+   {\n+   switch (slotType)\n+      {\n+      case J9ROM_UTF8:\n+         utf8SlotCallback(romClass, (const J9SRP *)slotPtr, slotName, userData);\n+         break;\n+\n+      case J9ROM_NAS:\n+         if (auto nas = SRP_PTR_GET(slotPtr, const J9ROMNameAndSignature *))\n+            {\n+            utf8SlotCallback(romClass, &nas->name, slotName, userData);\n+            utf8SlotCallback(romClass, &nas->signature, slotName, userData);\n+            }\n+         break;\n+      }\n+   }\n+\n+static bool\n+isArrayROMClass(const J9ROMClass *romClass)\n+   {\n+   if (!J9ROMCLASS_IS_ARRAY(romClass))\n+      return false;\n+\n+   auto name = J9ROMCLASS_CLASSNAME(romClass);\n+   TR_ASSERT((name->length == 2) && (name->data[0] == '['),\n+             \"Unexpected array ROMClass name: %.*s\", name->length, name->data);\n+   return true;\n+   }\n+\n+// Array ROMClasses have a different layout (see runtime/vm/romclasses.c):\n+// they all share the same SRP array of interfaces, which breaks the generic\n+// packing implementation. Instead, we manually pack all the data stored\n+// outside of the ROMClass header: class name, superclass name, interfaces.\n+// This function returns the total size of the packed array ROMClass.\n+static size_t\n+getArrayROMClassPackedSize(const J9ROMClass *romClass)\n+   {\n+   size_t totalSize = sizeof(*romClass);\n+   totalSize += getUTF8Size(J9ROMCLASS_CLASSNAME(romClass));\n+   totalSize += getUTF8Size(J9ROMCLASS_SUPERCLASSNAME(romClass));\n+\n+   totalSize += romClass->interfaceCount * sizeof(J9SRP);\n+   for (size_t i = 0; i < romClass->interfaceCount; ++i)\n+      {\n+      auto name = NNSRP_GET(J9ROMCLASS_INTERFACES(romClass)[i], const J9UTF8 *);\n+      totalSize += getUTF8Size(name);\n+      }\n+\n+   return OMR::alignNoCheck(totalSize, sizeof(uint64_t));\n+   }\n+\n+static void\n+packUTF8(const J9UTF8 *str, J9SRP &srp, ROMClassPackContext &ctx)\n+   {\n+   NNSRP_SET(srp, ctx.cursor);\n+   ctx.cursor += copyUTF8((J9UTF8 *)ctx.cursor, str);\n+   }\n+\n+// Packs the data stored outside of the array ROMClass header\n+static void\n+packArrayROMClassData(const J9ROMClass *romClass, ROMClassPackContext &ctx)\n+   {\n+   NNSRP_SET(ctx.packedRomClass->interfaces, ctx.cursor);\n+   ctx.cursor += ctx.packedRomClass->interfaceCount * sizeof(J9SRP);\n+\n+   packUTF8(J9ROMCLASS_CLASSNAME(romClass), ctx.packedRomClass->className, ctx);\n+   packUTF8(J9ROMCLASS_SUPERCLASSNAME(romClass), ctx.packedRomClass->superclassName, ctx);\n+\n+   for (size_t i = 0; i < romClass->interfaceCount; ++i)\n+      {\n+      auto name = NNSRP_GET(J9ROMCLASS_INTERFACES(romClass)[i], const J9UTF8 *);\n+      packUTF8(name, J9ROMCLASS_INTERFACES(ctx.packedRomClass)[i], ctx);\n+      }\n    }\n \n // Packs a ROMClass into a std::string to be transferred to the server.\n-// Some of the name and signature strings are interned and stored outside\n-// of the ROMClass body. Such strings are appended to the end of the cloned\n-// ROMClass body and the self referential pointers to them are updated.\n+// UTF8 strings that a ROMClass refers to can be interned and stored outside of\n+// the ROMClass body. This function puts all the strings (including interned ones)\n+// at the end of the cloned ROMClass in deterministic order and updates the SRPs\n+// to them. It also removes some of the data that is not used by the JIT compiler.\n+//\n+// Packing involves 2 passes over all the strings that a ROMClass refers to:\n+// 1. Compute total size and map original strings to their locations in the packed ROMClass.\n+// 2. Copy each original string to its location in the packed ROMClass.\n static std::string\n-packROMClass(J9ROMClass *origRomClass, TR_Memory *trMemory)\n+packROMClass(J9ROMClass *romClass, TR_Memory *trMemory)\n    {\n-   size_t totalSize = origRomClass->romSize;\n-   J9UTF8 *className = J9ROMCLASS_CLASSNAME(origRomClass);\n-   totalSize += getPackedUTF8Size(className, origRomClass);\n-\n-   J9ROMMethod *romMethod = J9ROMCLASS_ROMMETHODS(origRomClass);\n-   for (size_t i = 0; i < origRomClass->romMethodCount; ++i)\n+   auto name = J9ROMCLASS_CLASSNAME(romClass);\n+   // Primitive ROMClasses have different layout (see runtime/vm/romclasses.c): the last\n+   // ROMClass includes all the others' UTF8 name strings in its romSize, which breaks the\n+   // generic packing implementation. Pretend that its romSize only includes the header.\n+   size_t origRomSize = J9ROMCLASS_IS_PRIMITIVE_TYPE(romClass) ? sizeof(*romClass) : romClass->romSize;\n+   size_t totalSize = origRomSize;\n+\n+   // Remove intermediate class data (not used by JIT)\n+   uint8_t *icData = J9ROMCLASS_INTERMEDIATECLASSDATA(romClass);\n+   if (JITServerHelpers::isAddressInROMClass(icData, romClass) && (icData != (uint8_t *)romClass))\n       {\n-      totalSize += getPackedUTF8Size(J9ROMMETHOD_NAME(romMethod), origRomClass);\n-      totalSize += getPackedUTF8Size(J9ROMMETHOD_SIGNATURE(romMethod), origRomClass);\n-      romMethod = nextROMMethod(romMethod);\n+      TR_ASSERT_FATAL(icData + romClass->intermediateClassDataLength == (uint8_t *)romClass + romClass->romSize,\n+                      \"Intermediate class data not stored at the end of ROMClass %.*s\", name->length, name->data);\n+      totalSize -= romClass->intermediateClassDataLength;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf8bac93c10483471c4cef95c99e5644d0834e99"}, "originalPosition": 274}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk3NzUxNg==", "bodyText": "Why does end need to be the same as classEnd?\nend is what we computed with interned and non-interned strings.\nclassEnd is romClass+romClass->romSize which I thought it did not include the interned strings", "url": "https://github.com/eclipse-openj9/openj9/pull/11331#discussion_r537977516", "createdAt": "2020-12-08T02:07:54Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/control/JITServerHelpers.cpp", "diffHunk": "@@ -44,84 +47,309 @@ TR::Monitor *JITServerHelpers::_clientStreamMonitor = NULL;\n static size_t\n getUTF8Size(const J9UTF8 *str)\n    {\n-   return OMR::alignNoCheck(str->length, sizeof(*str)) + sizeof(*str);\n+   return OMR::alignNoCheck(J9UTF8_TOTAL_SIZE(str), sizeof(*str));\n    }\n \n+// Copies a UTF8 string with padding and returns its total size\n static size_t\n-getPackedUTF8Size(const J9UTF8 *str, const J9ROMClass *romClass)\n+copyUTF8(J9UTF8 *dst, const J9UTF8 *src)\n    {\n-   return JITServerHelpers::isAddressInROMClass(str, romClass) ? 0 : getUTF8Size(str);\n+   size_t size = J9UTF8_TOTAL_SIZE(src);\n+   memcpy(dst, src, size);\n+   static_assert(sizeof(*src) == 2, \"UTF8 header is not 2 bytes large\");\n+   if (!OMR::alignedNoCheck(size, sizeof(*src)))\n+      dst->data[src->length] = '\\0';\n+   return OMR::alignNoCheck(size, sizeof(*src));\n    }\n \n-// If the string points outside of the contiguous part of origRomClass, appends\n-// it (with padding) at curPos and updates the SRP to the string in the packed\n-// ROMClass. Returns the new value of curPos.\n-static uint8_t *\n-packUTF8(uint8_t *curPos, const J9UTF8 *origStr, const J9ROMClass *origRomClass, J9SRP &srp)\n+// State maintained while iterating over UTF8 strings in a ROMClass\n+struct ROMClassPackContext\n    {\n-   if (JITServerHelpers::isAddressInROMClass(origStr, origRomClass))\n-      return curPos;\n+   ROMClassPackContext(TR_Memory *trMemory, size_t origRomSize) :\n+      origSize(origRomSize), callback(NULL), stringsSize(0),\n+      utf8SectionStart((const uint8_t *)-1), utf8SectionEnd(NULL), utf8SectionSize(0),\n+      strToOffsetMap(decltype(strToOffsetMap)::allocator_type(trMemory->currentStackRegion())),\n+      packedRomClass(NULL), cursor(NULL) {}\n \n-   size_t size = getUTF8Size(origStr);\n-   memcpy(curPos, origStr, origStr->length + sizeof(*origStr));\n-   static_assert(sizeof(*origStr) == 2, \"UTF8 header is not 2 bytes large\");\n-   if (!OMR::alignedNoCheck(origStr->length, sizeof(*origStr)))\n-      curPos[size - 1] = '\\0';\n-   NNSRP_SET(srp, curPos);\n-   return curPos + size;\n+   bool isInline(const void *address, const J9ROMClass *romClass)\n+      {\n+      return (address >= romClass) && (address < (uint8_t *)romClass + origSize);\n+      }\n+\n+   typedef void (*Callback)(const J9ROMClass *, const J9SRP *, const char *, ROMClassPackContext &);\n+\n+   const size_t origSize;\n+   Callback callback;\n+   size_t stringsSize;\n+   const uint8_t *utf8SectionStart;\n+   const uint8_t *utf8SectionEnd;// only needed for assertions\n+   size_t utf8SectionSize;// only needed for assertions\n+   // Maps original strings to their offsets from UTF8 section start in the packed ROMClass\n+   // Offset value -1 signifies that the string is skipped\n+   UnorderedMap<const J9UTF8 *, size_t> strToOffsetMap;\n+   J9ROMClass *packedRomClass;\n+   uint8_t *cursor;\n+   };\n+\n+static bool\n+shouldSkipSlot(const char *slotName)\n+   {\n+   // Skip variable names and signatures in method debug info; only their slot names have prefix \"variable\"\n+   static const char prefix[] = \"variable\";\n+   return strncmp(slotName, prefix, sizeof(prefix) - 1) == 0;\n+   }\n+\n+// Updates size info and maps original string to its future location in the packed ROMClass\n+static void\n+sizeInfoCallback(const J9ROMClass *romClass, const J9SRP *origSrp, const char *slotName, ROMClassPackContext &ctx)\n+   {\n+   // Skip SRPs stored outside of the ROMClass bounds such as the ones in out-of-line\n+   // method debug info, and the ones that point to strings not used by the JIT.\n+   bool skip = !ctx.isInline(origSrp, romClass) || shouldSkipSlot(slotName);\n+   auto str = NNSRP_PTR_GET(origSrp, const J9UTF8 *);\n+   auto it = ctx.strToOffsetMap.find(str);\n+   if (it != ctx.strToOffsetMap.end())// duplicate - already visited\n+      {\n+      if (!skip && (it->second == (size_t)-1))\n+         {\n+         // Previously visited SRPs to this string were skipped, but this one isn't\n+         it->second = ctx.stringsSize;\n+         ctx.stringsSize += getUTF8Size(str);\n+         }\n+      return;\n+      }\n+\n+   ctx.strToOffsetMap.insert(it, { str, skip ? (size_t)-1 : ctx.stringsSize });\n+   size_t size = getUTF8Size(str);\n+   ctx.stringsSize += skip ? 0 : size;\n+\n+   if (ctx.isInline(str, romClass))\n+      {\n+      ctx.utf8SectionStart = std::min(ctx.utf8SectionStart, (const uint8_t *)str);\n+      ctx.utf8SectionEnd = std::max(ctx.utf8SectionEnd, (const uint8_t *)str + size);\n+      ctx.utf8SectionSize += size;\n+      }\n+   }\n+\n+// Copies original string into its location in the packed ROMClass and updates the SRP to it\n+static void\n+packCallback(const J9ROMClass *romClass, const J9SRP *origSrp, const char *slotName, ROMClassPackContext &ctx)\n+   {\n+   // Skip SRPs stored outside of the ROMClass bounds such as the ones in out-of-line method debug info\n+   if (!ctx.isInline(origSrp, romClass))\n+      return;\n+\n+   auto str = NNSRP_PTR_GET(origSrp, const J9UTF8 *);\n+   auto srp = (J9SRP *)((uint8_t *)ctx.packedRomClass + ((uint8_t *)origSrp - (uint8_t *)romClass));\n+\n+   // Zero out skipped string SRPs\n+   if (shouldSkipSlot(slotName))\n+      {\n+      TR_ASSERT(ctx.strToOffsetMap.find(str) != ctx.strToOffsetMap.end(),\n+                \"UTF8 slot %s not visited in 1st pass\", slotName);\n+      *srp = 0;\n+      return;\n+      }\n+\n+   auto it = ctx.strToOffsetMap.find(str);\n+   TR_ASSERT(it != ctx.strToOffsetMap.end(), \"UTF8 slot %s not visited in 1st pass\", slotName);\n+   auto dst = (uint8_t *)ctx.packedRomClass + (ctx.utf8SectionStart - (uint8_t *)romClass) + it->second;\n+\n+   NNSRP_PTR_SET(srp, dst);\n+   if (dst == ctx.cursor)\n+      ctx.cursor += copyUTF8((J9UTF8 *)dst, str);\n+   else\n+      TR_ASSERT((dst < ctx.cursor) && (memcmp(dst, str, J9UTF8_TOTAL_SIZE(str)) == 0), \"Must be already copied\");\n+   }\n+\n+static void\n+utf8SlotCallback(const J9ROMClass *romClass, const J9SRP *srp, const char *slotName, void *userData)\n+   {\n+   auto &ctx = *(ROMClassPackContext *)userData;\n+   if (*srp)\n+      ctx.callback(romClass, srp, slotName, ctx);\n+   }\n+\n+// Invoked for each slot in a ROMClass. Calls ctx.callback() for all non-null SRPs to UTF8 strings.\n+static void\n+slotCallback(J9ROMClass *romClass, uint32_t slotType, void *slotPtr, const char *slotName, void *userData)\n+   {\n+   switch (slotType)\n+      {\n+      case J9ROM_UTF8:\n+         utf8SlotCallback(romClass, (const J9SRP *)slotPtr, slotName, userData);\n+         break;\n+\n+      case J9ROM_NAS:\n+         if (auto nas = SRP_PTR_GET(slotPtr, const J9ROMNameAndSignature *))\n+            {\n+            utf8SlotCallback(romClass, &nas->name, slotName, userData);\n+            utf8SlotCallback(romClass, &nas->signature, slotName, userData);\n+            }\n+         break;\n+      }\n+   }\n+\n+static bool\n+isArrayROMClass(const J9ROMClass *romClass)\n+   {\n+   if (!J9ROMCLASS_IS_ARRAY(romClass))\n+      return false;\n+\n+   auto name = J9ROMCLASS_CLASSNAME(romClass);\n+   TR_ASSERT((name->length == 2) && (name->data[0] == '['),\n+             \"Unexpected array ROMClass name: %.*s\", name->length, name->data);\n+   return true;\n+   }\n+\n+// Array ROMClasses have a different layout (see runtime/vm/romclasses.c):\n+// they all share the same SRP array of interfaces, which breaks the generic\n+// packing implementation. Instead, we manually pack all the data stored\n+// outside of the ROMClass header: class name, superclass name, interfaces.\n+// This function returns the total size of the packed array ROMClass.\n+static size_t\n+getArrayROMClassPackedSize(const J9ROMClass *romClass)\n+   {\n+   size_t totalSize = sizeof(*romClass);\n+   totalSize += getUTF8Size(J9ROMCLASS_CLASSNAME(romClass));\n+   totalSize += getUTF8Size(J9ROMCLASS_SUPERCLASSNAME(romClass));\n+\n+   totalSize += romClass->interfaceCount * sizeof(J9SRP);\n+   for (size_t i = 0; i < romClass->interfaceCount; ++i)\n+      {\n+      auto name = NNSRP_GET(J9ROMCLASS_INTERFACES(romClass)[i], const J9UTF8 *);\n+      totalSize += getUTF8Size(name);\n+      }\n+\n+   return OMR::alignNoCheck(totalSize, sizeof(uint64_t));\n+   }\n+\n+static void\n+packUTF8(const J9UTF8 *str, J9SRP &srp, ROMClassPackContext &ctx)\n+   {\n+   NNSRP_SET(srp, ctx.cursor);\n+   ctx.cursor += copyUTF8((J9UTF8 *)ctx.cursor, str);\n+   }\n+\n+// Packs the data stored outside of the array ROMClass header\n+static void\n+packArrayROMClassData(const J9ROMClass *romClass, ROMClassPackContext &ctx)\n+   {\n+   NNSRP_SET(ctx.packedRomClass->interfaces, ctx.cursor);\n+   ctx.cursor += ctx.packedRomClass->interfaceCount * sizeof(J9SRP);\n+\n+   packUTF8(J9ROMCLASS_CLASSNAME(romClass), ctx.packedRomClass->className, ctx);\n+   packUTF8(J9ROMCLASS_SUPERCLASSNAME(romClass), ctx.packedRomClass->superclassName, ctx);\n+\n+   for (size_t i = 0; i < romClass->interfaceCount; ++i)\n+      {\n+      auto name = NNSRP_GET(J9ROMCLASS_INTERFACES(romClass)[i], const J9UTF8 *);\n+      packUTF8(name, J9ROMCLASS_INTERFACES(ctx.packedRomClass)[i], ctx);\n+      }\n    }\n \n // Packs a ROMClass into a std::string to be transferred to the server.\n-// Some of the name and signature strings are interned and stored outside\n-// of the ROMClass body. Such strings are appended to the end of the cloned\n-// ROMClass body and the self referential pointers to them are updated.\n+// UTF8 strings that a ROMClass refers to can be interned and stored outside of\n+// the ROMClass body. This function puts all the strings (including interned ones)\n+// at the end of the cloned ROMClass in deterministic order and updates the SRPs\n+// to them. It also removes some of the data that is not used by the JIT compiler.\n+//\n+// Packing involves 2 passes over all the strings that a ROMClass refers to:\n+// 1. Compute total size and map original strings to their locations in the packed ROMClass.\n+// 2. Copy each original string to its location in the packed ROMClass.\n static std::string\n-packROMClass(J9ROMClass *origRomClass, TR_Memory *trMemory)\n+packROMClass(J9ROMClass *romClass, TR_Memory *trMemory)\n    {\n-   size_t totalSize = origRomClass->romSize;\n-   J9UTF8 *className = J9ROMCLASS_CLASSNAME(origRomClass);\n-   totalSize += getPackedUTF8Size(className, origRomClass);\n-\n-   J9ROMMethod *romMethod = J9ROMCLASS_ROMMETHODS(origRomClass);\n-   for (size_t i = 0; i < origRomClass->romMethodCount; ++i)\n+   auto name = J9ROMCLASS_CLASSNAME(romClass);\n+   // Primitive ROMClasses have different layout (see runtime/vm/romclasses.c): the last\n+   // ROMClass includes all the others' UTF8 name strings in its romSize, which breaks the\n+   // generic packing implementation. Pretend that its romSize only includes the header.\n+   size_t origRomSize = J9ROMCLASS_IS_PRIMITIVE_TYPE(romClass) ? sizeof(*romClass) : romClass->romSize;\n+   size_t totalSize = origRomSize;\n+\n+   // Remove intermediate class data (not used by JIT)\n+   uint8_t *icData = J9ROMCLASS_INTERMEDIATECLASSDATA(romClass);\n+   if (JITServerHelpers::isAddressInROMClass(icData, romClass) && (icData != (uint8_t *)romClass))\n       {\n-      totalSize += getPackedUTF8Size(J9ROMMETHOD_NAME(romMethod), origRomClass);\n-      totalSize += getPackedUTF8Size(J9ROMMETHOD_SIGNATURE(romMethod), origRomClass);\n-      romMethod = nextROMMethod(romMethod);\n+      TR_ASSERT_FATAL(icData + romClass->intermediateClassDataLength == (uint8_t *)romClass + romClass->romSize,\n+                      \"Intermediate class data not stored at the end of ROMClass %.*s\", name->length, name->data);\n+      totalSize -= romClass->intermediateClassDataLength;\n       }\n \n-   // Check if the contiguous part of the ROMClass already contains all the strings visited above\n-   if (totalSize == origRomClass->romSize)\n-      return std::string((char *)origRomClass, origRomClass->romSize);\n+   // All allocated memory is only used in this function\n+   TR::StackMemoryRegion stackMemoryRegion(*trMemory);\n+   ROMClassPackContext ctx(trMemory, origRomSize);\n \n-   J9ROMClass *romClass = (J9ROMClass *)trMemory->allocateHeapMemory(totalSize);\n-   if (!romClass)\n+   size_t copySize = 0;\n+   if (isArrayROMClass(romClass))\n+      {\n+      copySize = sizeof(*romClass);\n+      totalSize = getArrayROMClassPackedSize(romClass);\n+      }\n+   else\n+      {\n+      // 1st pass: iterate all strings in the ROMClass to compute its total size (including\n+      // interned strings) and map the strings to their locations in the packed ROMClass\n+      ctx.callback = sizeInfoCallback;\n+      allSlotsInROMClassDo(romClass, slotCallback, NULL, NULL, &ctx);\n+      // Handle the case when all strings are interned\n+      auto classEnd = (const uint8_t *)romClass + totalSize;\n+      ctx.utf8SectionStart = std::min(ctx.utf8SectionStart, classEnd);\n+\n+      auto end = ctx.utf8SectionEnd ? ctx.utf8SectionEnd : classEnd;\n+      TR_ASSERT_FATAL(ctx.utf8SectionSize == end - ctx.utf8SectionStart,\n+                      \"Missed strings in ROMClass %.*s UTF8 section: %zu != %zu\",\n+                      name->length, name->data, ctx.utf8SectionSize, end - ctx.utf8SectionStart);\n+      end = (const uint8_t *)OMR::alignNoCheck((uintptr_t)end, sizeof(uint64_t));\n+      TR_ASSERT_FATAL(end == classEnd, \"UTF8 section not stored at the end of ROMClass %.*s: %p != %p\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf8bac93c10483471c4cef95c99e5644d0834e99"}, "originalPosition": 307}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk4NTc3Nw==", "bodyText": "Does this mean that for array ROMClasses we may send interface names multiple times?", "url": "https://github.com/eclipse-openj9/openj9/pull/11331#discussion_r537985777", "createdAt": "2020-12-08T02:31:11Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/control/JITServerHelpers.cpp", "diffHunk": "@@ -44,84 +47,309 @@ TR::Monitor *JITServerHelpers::_clientStreamMonitor = NULL;\n static size_t\n getUTF8Size(const J9UTF8 *str)\n    {\n-   return OMR::alignNoCheck(str->length, sizeof(*str)) + sizeof(*str);\n+   return OMR::alignNoCheck(J9UTF8_TOTAL_SIZE(str), sizeof(*str));\n    }\n \n+// Copies a UTF8 string with padding and returns its total size\n static size_t\n-getPackedUTF8Size(const J9UTF8 *str, const J9ROMClass *romClass)\n+copyUTF8(J9UTF8 *dst, const J9UTF8 *src)\n    {\n-   return JITServerHelpers::isAddressInROMClass(str, romClass) ? 0 : getUTF8Size(str);\n+   size_t size = J9UTF8_TOTAL_SIZE(src);\n+   memcpy(dst, src, size);\n+   static_assert(sizeof(*src) == 2, \"UTF8 header is not 2 bytes large\");\n+   if (!OMR::alignedNoCheck(size, sizeof(*src)))\n+      dst->data[src->length] = '\\0';\n+   return OMR::alignNoCheck(size, sizeof(*src));\n    }\n \n-// If the string points outside of the contiguous part of origRomClass, appends\n-// it (with padding) at curPos and updates the SRP to the string in the packed\n-// ROMClass. Returns the new value of curPos.\n-static uint8_t *\n-packUTF8(uint8_t *curPos, const J9UTF8 *origStr, const J9ROMClass *origRomClass, J9SRP &srp)\n+// State maintained while iterating over UTF8 strings in a ROMClass\n+struct ROMClassPackContext\n    {\n-   if (JITServerHelpers::isAddressInROMClass(origStr, origRomClass))\n-      return curPos;\n+   ROMClassPackContext(TR_Memory *trMemory, size_t origRomSize) :\n+      origSize(origRomSize), callback(NULL), stringsSize(0),\n+      utf8SectionStart((const uint8_t *)-1), utf8SectionEnd(NULL), utf8SectionSize(0),\n+      strToOffsetMap(decltype(strToOffsetMap)::allocator_type(trMemory->currentStackRegion())),\n+      packedRomClass(NULL), cursor(NULL) {}\n \n-   size_t size = getUTF8Size(origStr);\n-   memcpy(curPos, origStr, origStr->length + sizeof(*origStr));\n-   static_assert(sizeof(*origStr) == 2, \"UTF8 header is not 2 bytes large\");\n-   if (!OMR::alignedNoCheck(origStr->length, sizeof(*origStr)))\n-      curPos[size - 1] = '\\0';\n-   NNSRP_SET(srp, curPos);\n-   return curPos + size;\n+   bool isInline(const void *address, const J9ROMClass *romClass)\n+      {\n+      return (address >= romClass) && (address < (uint8_t *)romClass + origSize);\n+      }\n+\n+   typedef void (*Callback)(const J9ROMClass *, const J9SRP *, const char *, ROMClassPackContext &);\n+\n+   const size_t origSize;\n+   Callback callback;\n+   size_t stringsSize;\n+   const uint8_t *utf8SectionStart;\n+   const uint8_t *utf8SectionEnd;// only needed for assertions\n+   size_t utf8SectionSize;// only needed for assertions\n+   // Maps original strings to their offsets from UTF8 section start in the packed ROMClass\n+   // Offset value -1 signifies that the string is skipped\n+   UnorderedMap<const J9UTF8 *, size_t> strToOffsetMap;\n+   J9ROMClass *packedRomClass;\n+   uint8_t *cursor;\n+   };\n+\n+static bool\n+shouldSkipSlot(const char *slotName)\n+   {\n+   // Skip variable names and signatures in method debug info; only their slot names have prefix \"variable\"\n+   static const char prefix[] = \"variable\";\n+   return strncmp(slotName, prefix, sizeof(prefix) - 1) == 0;\n+   }\n+\n+// Updates size info and maps original string to its future location in the packed ROMClass\n+static void\n+sizeInfoCallback(const J9ROMClass *romClass, const J9SRP *origSrp, const char *slotName, ROMClassPackContext &ctx)\n+   {\n+   // Skip SRPs stored outside of the ROMClass bounds such as the ones in out-of-line\n+   // method debug info, and the ones that point to strings not used by the JIT.\n+   bool skip = !ctx.isInline(origSrp, romClass) || shouldSkipSlot(slotName);\n+   auto str = NNSRP_PTR_GET(origSrp, const J9UTF8 *);\n+   auto it = ctx.strToOffsetMap.find(str);\n+   if (it != ctx.strToOffsetMap.end())// duplicate - already visited\n+      {\n+      if (!skip && (it->second == (size_t)-1))\n+         {\n+         // Previously visited SRPs to this string were skipped, but this one isn't\n+         it->second = ctx.stringsSize;\n+         ctx.stringsSize += getUTF8Size(str);\n+         }\n+      return;\n+      }\n+\n+   ctx.strToOffsetMap.insert(it, { str, skip ? (size_t)-1 : ctx.stringsSize });\n+   size_t size = getUTF8Size(str);\n+   ctx.stringsSize += skip ? 0 : size;\n+\n+   if (ctx.isInline(str, romClass))\n+      {\n+      ctx.utf8SectionStart = std::min(ctx.utf8SectionStart, (const uint8_t *)str);\n+      ctx.utf8SectionEnd = std::max(ctx.utf8SectionEnd, (const uint8_t *)str + size);\n+      ctx.utf8SectionSize += size;\n+      }\n+   }\n+\n+// Copies original string into its location in the packed ROMClass and updates the SRP to it\n+static void\n+packCallback(const J9ROMClass *romClass, const J9SRP *origSrp, const char *slotName, ROMClassPackContext &ctx)\n+   {\n+   // Skip SRPs stored outside of the ROMClass bounds such as the ones in out-of-line method debug info\n+   if (!ctx.isInline(origSrp, romClass))\n+      return;\n+\n+   auto str = NNSRP_PTR_GET(origSrp, const J9UTF8 *);\n+   auto srp = (J9SRP *)((uint8_t *)ctx.packedRomClass + ((uint8_t *)origSrp - (uint8_t *)romClass));\n+\n+   // Zero out skipped string SRPs\n+   if (shouldSkipSlot(slotName))\n+      {\n+      TR_ASSERT(ctx.strToOffsetMap.find(str) != ctx.strToOffsetMap.end(),\n+                \"UTF8 slot %s not visited in 1st pass\", slotName);\n+      *srp = 0;\n+      return;\n+      }\n+\n+   auto it = ctx.strToOffsetMap.find(str);\n+   TR_ASSERT(it != ctx.strToOffsetMap.end(), \"UTF8 slot %s not visited in 1st pass\", slotName);\n+   auto dst = (uint8_t *)ctx.packedRomClass + (ctx.utf8SectionStart - (uint8_t *)romClass) + it->second;\n+\n+   NNSRP_PTR_SET(srp, dst);\n+   if (dst == ctx.cursor)\n+      ctx.cursor += copyUTF8((J9UTF8 *)dst, str);\n+   else\n+      TR_ASSERT((dst < ctx.cursor) && (memcmp(dst, str, J9UTF8_TOTAL_SIZE(str)) == 0), \"Must be already copied\");\n+   }\n+\n+static void\n+utf8SlotCallback(const J9ROMClass *romClass, const J9SRP *srp, const char *slotName, void *userData)\n+   {\n+   auto &ctx = *(ROMClassPackContext *)userData;\n+   if (*srp)\n+      ctx.callback(romClass, srp, slotName, ctx);\n+   }\n+\n+// Invoked for each slot in a ROMClass. Calls ctx.callback() for all non-null SRPs to UTF8 strings.\n+static void\n+slotCallback(J9ROMClass *romClass, uint32_t slotType, void *slotPtr, const char *slotName, void *userData)\n+   {\n+   switch (slotType)\n+      {\n+      case J9ROM_UTF8:\n+         utf8SlotCallback(romClass, (const J9SRP *)slotPtr, slotName, userData);\n+         break;\n+\n+      case J9ROM_NAS:\n+         if (auto nas = SRP_PTR_GET(slotPtr, const J9ROMNameAndSignature *))\n+            {\n+            utf8SlotCallback(romClass, &nas->name, slotName, userData);\n+            utf8SlotCallback(romClass, &nas->signature, slotName, userData);\n+            }\n+         break;\n+      }\n+   }\n+\n+static bool\n+isArrayROMClass(const J9ROMClass *romClass)\n+   {\n+   if (!J9ROMCLASS_IS_ARRAY(romClass))\n+      return false;\n+\n+   auto name = J9ROMCLASS_CLASSNAME(romClass);\n+   TR_ASSERT((name->length == 2) && (name->data[0] == '['),\n+             \"Unexpected array ROMClass name: %.*s\", name->length, name->data);\n+   return true;\n+   }\n+\n+// Array ROMClasses have a different layout (see runtime/vm/romclasses.c):\n+// they all share the same SRP array of interfaces, which breaks the generic\n+// packing implementation. Instead, we manually pack all the data stored\n+// outside of the ROMClass header: class name, superclass name, interfaces.\n+// This function returns the total size of the packed array ROMClass.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf8bac93c10483471c4cef95c99e5644d0834e99"}, "originalPosition": 194}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "cf8bac93c10483471c4cef95c99e5644d0834e99", "author": {"user": {"login": "AlexeyKhrabrov", "name": "Alexey Khrabrov"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/cf8bac93c10483471c4cef95c99e5644d0834e99", "committedDate": "2020-12-04T20:01:52Z", "message": "Increment JITServer protocol version\n\nSigned-off-by: Alexey Khrabrov <khrabrov@cs.toronto.edu>"}, "afterCommit": {"oid": "82b20ffb8e468d432005c6e502b3c52430ce193b", "author": {"user": {"login": "AlexeyKhrabrov", "name": "Alexey Khrabrov"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/82b20ffb8e468d432005c6e502b3c52430ce193b", "committedDate": "2020-12-09T19:41:36Z", "message": "Increment JITServer protocol version\n\nSigned-off-by: Alexey Khrabrov <khrabrov@cs.toronto.edu>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ4Njg1MDUw", "url": "https://github.com/eclipse-openj9/openj9/pull/11331#pullrequestreview-548685050", "createdAt": "2020-12-09T23:00:24Z", "commit": {"oid": "82b20ffb8e468d432005c6e502b3c52430ce193b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "da35bc6db67fd8c89034713986f7e262d6a50508", "author": {"user": {"login": "AlexeyKhrabrov", "name": "Alexey Khrabrov"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/da35bc6db67fd8c89034713986f7e262d6a50508", "committedDate": "2021-01-20T21:48:52Z", "message": "Fully serialize ROMClasses sent to JITServer\n\nAll the UTF8 strings that a ROMClass refers to (including interned ones)\nare stored at the end in deterministic order. Strings that are only\nreferenced by SRPs stored outside the ROMClass bounds (such as method\ndebug info stored out-of-line) are excluded. Intermediate class data is\nremoved (if stored inside the ROMClass) and its SRP is set to 0. SRPs to\nout-of-line method debug info are set to 0.\n\nSigned-off-by: Alexey Khrabrov <khrabrov@cs.toronto.edu>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "26e3725cbb0b64c2411b1f8314a443cbb4809e11", "author": {"user": {"login": "AlexeyKhrabrov", "name": "Alexey Khrabrov"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/26e3725cbb0b64c2411b1f8314a443cbb4809e11", "committedDate": "2021-01-20T21:48:52Z", "message": "Exclude inline method debug info strings from serialized ROMClass\n\nThis data is not used by the JIT and can be safely excluded during\nserialization in order to reduce the size of the packed ROMClass.\n\nSigned-off-by: Alexey Khrabrov <khrabrov@cs.toronto.edu>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ed746f736d324b1b25298d973f79ec277bd6f3dd", "author": {"user": {"login": "AlexeyKhrabrov", "name": "Alexey Khrabrov"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/ed746f736d324b1b25298d973f79ec277bd6f3dd", "committedDate": "2021-01-20T21:48:53Z", "message": "Remove obsolete code for retrieving and caching remote ROM strings\n\nWith full serialization of ROMClasses, this code is now obsolete and\nshould be removed.\n\nSigned-off-by: Alexey Khrabrov <khrabrov@cs.toronto.edu>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "42c6e42fc6b139b163b7c2bbaa5aadaf5defbee9", "author": {"user": {"login": "AlexeyKhrabrov", "name": "Alexey Khrabrov"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/42c6e42fc6b139b163b7c2bbaa5aadaf5defbee9", "committedDate": "2021-01-20T21:48:53Z", "message": "Increment JITServer protocol version\n\nSigned-off-by: Alexey Khrabrov <khrabrov@cs.toronto.edu>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "82b20ffb8e468d432005c6e502b3c52430ce193b", "author": {"user": {"login": "AlexeyKhrabrov", "name": "Alexey Khrabrov"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/82b20ffb8e468d432005c6e502b3c52430ce193b", "committedDate": "2020-12-09T19:41:36Z", "message": "Increment JITServer protocol version\n\nSigned-off-by: Alexey Khrabrov <khrabrov@cs.toronto.edu>"}, "afterCommit": {"oid": "42c6e42fc6b139b163b7c2bbaa5aadaf5defbee9", "author": {"user": {"login": "AlexeyKhrabrov", "name": "Alexey Khrabrov"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/42c6e42fc6b139b163b7c2bbaa5aadaf5defbee9", "committedDate": "2021-01-20T21:48:53Z", "message": "Increment JITServer protocol version\n\nSigned-off-by: Alexey Khrabrov <khrabrov@cs.toronto.edu>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTczNjcyNzA2", "url": "https://github.com/eclipse-openj9/openj9/pull/11331#pullrequestreview-573672706", "createdAt": "2021-01-21T19:37:38Z", "commit": {"oid": "42c6e42fc6b139b163b7c2bbaa5aadaf5defbee9"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1694, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}