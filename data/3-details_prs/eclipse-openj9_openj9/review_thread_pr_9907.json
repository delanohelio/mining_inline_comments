{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM1NDA3MzYy", "number": 9907, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQyMDo1MjowMVrOEL1uaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQwMjo1NzoyM1rOEMuTpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwODUwMDI3OnYy", "diffSide": "RIGHT", "path": "runtime/jvmti/suspendhelper.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQyMDo1MjowMVrOGtmtog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQxNTowOTozM1rOGusrOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQ3MzM3OA==", "bodyText": "The local can't be re-used as the object may move while the thread is suspended.", "url": "https://github.com/eclipse-openj9/openj9/pull/9907#discussion_r450473378", "createdAt": "2020-07-06T20:52:01Z", "author": {"login": "gacholio"}, "path": "runtime/jvmti/suspendhelper.cpp", "diffHunk": "@@ -54,7 +62,11 @@ suspendThread(J9VMThread *currentThread, jthread thread, UDATA allowNull, UDATA\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tomrthread_monitor_exit(targetThread->publicFlagsMutex);\n+\n \t\t\t\t\tcurrentThread->javaVM->internalVMFunctions->internalEnterVMFromJNI(currentThread);\n+\n+\t\t\t\t\t/* Release java.lang.Thread.lock */\n+\t\t\t\t\tobjectMonitorExit(currentThread, threadLock);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "043ed1a4a0523fe97b874c0cef71c364772a8d0b"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTYxOTY0MQ==", "bodyText": "The lock object needs to be refetched from the vmThread.", "url": "https://github.com/eclipse-openj9/openj9/pull/9907#discussion_r451619641", "createdAt": "2020-07-08T15:09:33Z", "author": {"login": "gacholio"}, "path": "runtime/jvmti/suspendhelper.cpp", "diffHunk": "@@ -54,7 +62,11 @@ suspendThread(J9VMThread *currentThread, jthread thread, UDATA allowNull, UDATA\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tomrthread_monitor_exit(targetThread->publicFlagsMutex);\n+\n \t\t\t\t\tcurrentThread->javaVM->internalVMFunctions->internalEnterVMFromJNI(currentThread);\n+\n+\t\t\t\t\t/* Release java.lang.Thread.lock */\n+\t\t\t\t\tobjectMonitorExit(currentThread, threadLock);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQ3MzM3OA=="}, "originalCommit": {"oid": "043ed1a4a0523fe97b874c0cef71c364772a8d0b"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMjE5NDMyOnYy", "diffSide": "RIGHT", "path": "runtime/jvmti/suspendhelper.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxODoyMDo1M1rOGuKY-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxODo1Mzo0NVrOGuLclQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA1NzkxMg==", "bodyText": "Is the intention to match the java implementation of the Thread.suspend method by acquiring the lock for other threads before suspending?\nhttps://github.com/eclipse/openj9/blob/ea7b2e9783f21f186eb7ac087af77d74dc5a78ad/jcl/src/java.base/share/classes/java/lang/Thread.java#L1280-L1284\nMaking this match the Java implementation makes sense to me but I don't understand the comment above", "url": "https://github.com/eclipse-openj9/openj9/pull/9907#discussion_r451057912", "createdAt": "2020-07-07T18:20:53Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jvmti/suspendhelper.cpp", "diffHunk": "@@ -45,7 +45,15 @@ suspendThread(J9VMThread *currentThread, jthread thread, UDATA allowNull, UDATA\n \t\t\t\tif (currentThread == targetThread) {\n \t\t\t\t\t*currentThreadSuspended = TRUE;\n \t\t\t\t} else {\n+\t\t\t\t\t/* It is a well known problem that suspending a Java thread may cause deadlocks in the application if a resource is \n+\t\t\t\t\t * held while suspended. To prevent this happening in the Thread JCL library, check that the Object java.lang.Thread.lock \n+\t\t\t\t\t * has been released before suspending. To make sure of this, acquire the lock while halt is in progress.\n+\t\t\t\t\t */\n+\t\t\t\t\tj9object_t threadLock = J9VMJAVALANGTHREAD_LOCK(targetThread, targetThread->threadObject);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "043ed1a4a0523fe97b874c0cef71c364772a8d0b"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA3NTIyMQ==", "bodyText": "I suspect the lock here is to prevent the thread from dying while we attempt to suspend it. JVMTI uses a different mechanism (vmThreadListMutex and inspectorCount).", "url": "https://github.com/eclipse-openj9/openj9/pull/9907#discussion_r451075221", "createdAt": "2020-07-07T18:53:45Z", "author": {"login": "gacholio"}, "path": "runtime/jvmti/suspendhelper.cpp", "diffHunk": "@@ -45,7 +45,15 @@ suspendThread(J9VMThread *currentThread, jthread thread, UDATA allowNull, UDATA\n \t\t\t\tif (currentThread == targetThread) {\n \t\t\t\t\t*currentThreadSuspended = TRUE;\n \t\t\t\t} else {\n+\t\t\t\t\t/* It is a well known problem that suspending a Java thread may cause deadlocks in the application if a resource is \n+\t\t\t\t\t * held while suspended. To prevent this happening in the Thread JCL library, check that the Object java.lang.Thread.lock \n+\t\t\t\t\t * has been released before suspending. To make sure of this, acquire the lock while halt is in progress.\n+\t\t\t\t\t */\n+\t\t\t\t\tj9object_t threadLock = J9VMJAVALANGTHREAD_LOCK(targetThread, targetThread->threadObject);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA1NzkxMg=="}, "originalCommit": {"oid": "043ed1a4a0523fe97b874c0cef71c364772a8d0b"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxNjY3Njc2OnYy", "diffSide": "RIGHT", "path": "runtime/jvmti/suspendhelper.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQxOTowNzoyM1rOGu1l2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQxOTowNzoyM1rOGu1l2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc2NTcyMQ==", "bodyText": "VM can always be fetched from the current thread - there's no need to add the parameter.", "url": "https://github.com/eclipse-openj9/openj9/pull/9907#discussion_r451765721", "createdAt": "2020-07-08T19:07:23Z", "author": {"login": "gacholio"}, "path": "runtime/jvmti/suspendhelper.cpp", "diffHunk": "@@ -27,7 +27,7 @@\n extern \"C\" {\n \n jvmtiError\n-suspendThread(J9VMThread *currentThread, jthread thread, UDATA allowNull, UDATA *currentThreadSuspended)\n+suspendThread(J9JavaVM *vm, J9VMThread *currentThread, jthread thread, UDATA allowNull, UDATA *currentThreadSuspended)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7c5874765c7e6c6856e273e92b62b594027d083b"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxNjY4NzIxOnYy", "diffSide": "RIGHT", "path": "runtime/jvmti/suspendhelper.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQxOToxMDo0MlrOGu1sew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQyMjoyNjowM1rOGu7SNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc2NzQxOQ==", "bodyText": "Please cache the internal function table in a local (and change the other uses in this function to use the local).\nhttps://github.com/eclipse/openj9/blob/566007db997abe3f47f25565506c0f5a0a2f1b00/runtime/j9vm/java11vmi.c#L319", "url": "https://github.com/eclipse-openj9/openj9/pull/9907#discussion_r451767419", "createdAt": "2020-07-08T19:10:42Z", "author": {"login": "gacholio"}, "path": "runtime/jvmti/suspendhelper.cpp", "diffHunk": "@@ -45,7 +45,14 @@ suspendThread(J9VMThread *currentThread, jthread thread, UDATA allowNull, UDATA\n \t\t\t\tif (currentThread == targetThread) {\n \t\t\t\t\t*currentThreadSuspended = TRUE;\n \t\t\t\t} else {\n+\t\t\t\t\t/* It is a well known problem that suspending a Java thread may cause deadlocks in the application if a resource is \n+\t\t\t\t\t * held while suspended. To prevent this happening in the Thread JCL library, check that the Object java.lang.Thread.lock \n+\t\t\t\t\t * has been released before suspending. To make sure of this, acquire the lock while halt is in progress.\n+\t\t\t\t\t */\n+\t\t\t\t\tvm->internalVMFunctions->objectMonitorEnter(currentThread, J9VMJAVALANGTHREAD_LOCK(targetThread, targetThread->threadObject));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7c5874765c7e6c6856e273e92b62b594027d083b"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg1ODk5OQ==", "bodyText": "updated.", "url": "https://github.com/eclipse-openj9/openj9/pull/9907#discussion_r451858999", "createdAt": "2020-07-08T22:26:03Z", "author": {"login": "theresa-m"}, "path": "runtime/jvmti/suspendhelper.cpp", "diffHunk": "@@ -45,7 +45,14 @@ suspendThread(J9VMThread *currentThread, jthread thread, UDATA allowNull, UDATA\n \t\t\t\tif (currentThread == targetThread) {\n \t\t\t\t\t*currentThreadSuspended = TRUE;\n \t\t\t\t} else {\n+\t\t\t\t\t/* It is a well known problem that suspending a Java thread may cause deadlocks in the application if a resource is \n+\t\t\t\t\t * held while suspended. To prevent this happening in the Thread JCL library, check that the Object java.lang.Thread.lock \n+\t\t\t\t\t * has been released before suspending. To make sure of this, acquire the lock while halt is in progress.\n+\t\t\t\t\t */\n+\t\t\t\t\tvm->internalVMFunctions->objectMonitorEnter(currentThread, J9VMJAVALANGTHREAD_LOCK(targetThread, targetThread->threadObject));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc2NzQxOQ=="}, "originalCommit": {"oid": "7c5874765c7e6c6856e273e92b62b594027d083b"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxNzMzNjg2OnYy", "diffSide": "RIGHT", "path": "runtime/jvmti/suspendhelper.cpp", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQyMjo1OTowMFrOGu7-ew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxNjozODo0MlrOGwwqSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg3MDMzMQ==", "bodyText": "One final thing - the object field access macros should take currentThread not targetThread.", "url": "https://github.com/eclipse-openj9/openj9/pull/9907#discussion_r451870331", "createdAt": "2020-07-08T22:59:00Z", "author": {"login": "gacholio"}, "path": "runtime/jvmti/suspendhelper.cpp", "diffHunk": "@@ -45,7 +45,15 @@ suspendThread(J9VMThread *currentThread, jthread thread, UDATA allowNull, UDATA\n \t\t\t\tif (currentThread == targetThread) {\n \t\t\t\t\t*currentThreadSuspended = TRUE;\n \t\t\t\t} else {\n-\t\t\t\t\tcurrentThread->javaVM->internalVMFunctions->internalExitVMToJNI(currentThread);\n+\t\t\t\t\tJ9InternalVMFunctions *vmFuncs = currentThread->javaVM->internalVMFunctions;\n+\t\t\t\t\t/* It is a well known problem that suspending a Java thread may cause deadlocks in the application if a resource is \n+\t\t\t\t\t * held while suspended. To prevent this happening in the Thread JCL library, check that the Object java.lang.Thread.lock \n+\t\t\t\t\t * has been released before suspending. To make sure of this, acquire the lock while halt is in progress.\n+\t\t\t\t\t */\n+\t\t\t\t\tvmFuncs->objectMonitorEnter(currentThread, J9VMJAVALANGTHREAD_LOCK(targetThread, targetThread->threadObject));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b4f9208eb6e33e18151ff602614d9852d76eb20"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjMyMTMzOQ==", "bodyText": "vmFuncs->objectMonitorEnter(currentThread, J9VMJAVALANGTHREAD_LOCK(currentThread, currentThread->threadObject));\n\nWouldn't that make it so currentThread is acquiring the lock that belongs to its own class?\nThe way I'm reading the existing line is currentThread is acquiring targetThread's lock to make sure that no targetThread JCL methods are holding it.", "url": "https://github.com/eclipse-openj9/openj9/pull/9907#discussion_r452321339", "createdAt": "2020-07-09T15:54:38Z", "author": {"login": "theresa-m"}, "path": "runtime/jvmti/suspendhelper.cpp", "diffHunk": "@@ -45,7 +45,15 @@ suspendThread(J9VMThread *currentThread, jthread thread, UDATA allowNull, UDATA\n \t\t\t\tif (currentThread == targetThread) {\n \t\t\t\t\t*currentThreadSuspended = TRUE;\n \t\t\t\t} else {\n-\t\t\t\t\tcurrentThread->javaVM->internalVMFunctions->internalExitVMToJNI(currentThread);\n+\t\t\t\t\tJ9InternalVMFunctions *vmFuncs = currentThread->javaVM->internalVMFunctions;\n+\t\t\t\t\t/* It is a well known problem that suspending a Java thread may cause deadlocks in the application if a resource is \n+\t\t\t\t\t * held while suspended. To prevent this happening in the Thread JCL library, check that the Object java.lang.Thread.lock \n+\t\t\t\t\t * has been released before suspending. To make sure of this, acquire the lock while halt is in progress.\n+\t\t\t\t\t */\n+\t\t\t\t\tvmFuncs->objectMonitorEnter(currentThread, J9VMJAVALANGTHREAD_LOCK(targetThread, targetThread->threadObject));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg3MDMzMQ=="}, "originalCommit": {"oid": "4b4f9208eb6e33e18151ff602614d9852d76eb20"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjMyNDk5OA==", "bodyText": "Only the first parameter should be changed - it's used in some GC policies and must be the current thread.", "url": "https://github.com/eclipse-openj9/openj9/pull/9907#discussion_r452324998", "createdAt": "2020-07-09T16:00:15Z", "author": {"login": "gacholio"}, "path": "runtime/jvmti/suspendhelper.cpp", "diffHunk": "@@ -45,7 +45,15 @@ suspendThread(J9VMThread *currentThread, jthread thread, UDATA allowNull, UDATA\n \t\t\t\tif (currentThread == targetThread) {\n \t\t\t\t\t*currentThreadSuspended = TRUE;\n \t\t\t\t} else {\n-\t\t\t\t\tcurrentThread->javaVM->internalVMFunctions->internalExitVMToJNI(currentThread);\n+\t\t\t\t\tJ9InternalVMFunctions *vmFuncs = currentThread->javaVM->internalVMFunctions;\n+\t\t\t\t\t/* It is a well known problem that suspending a Java thread may cause deadlocks in the application if a resource is \n+\t\t\t\t\t * held while suspended. To prevent this happening in the Thread JCL library, check that the Object java.lang.Thread.lock \n+\t\t\t\t\t * has been released before suspending. To make sure of this, acquire the lock while halt is in progress.\n+\t\t\t\t\t */\n+\t\t\t\t\tvmFuncs->objectMonitorEnter(currentThread, J9VMJAVALANGTHREAD_LOCK(targetThread, targetThread->threadObject));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg3MDMzMQ=="}, "originalCommit": {"oid": "4b4f9208eb6e33e18151ff602614d9852d76eb20"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzc4MjA4OQ==", "bodyText": "Still waiting for this to be fixed before test/merge.", "url": "https://github.com/eclipse-openj9/openj9/pull/9907#discussion_r453782089", "createdAt": "2020-07-13T16:38:42Z", "author": {"login": "gacholio"}, "path": "runtime/jvmti/suspendhelper.cpp", "diffHunk": "@@ -45,7 +45,15 @@ suspendThread(J9VMThread *currentThread, jthread thread, UDATA allowNull, UDATA\n \t\t\t\tif (currentThread == targetThread) {\n \t\t\t\t\t*currentThreadSuspended = TRUE;\n \t\t\t\t} else {\n-\t\t\t\t\tcurrentThread->javaVM->internalVMFunctions->internalExitVMToJNI(currentThread);\n+\t\t\t\t\tJ9InternalVMFunctions *vmFuncs = currentThread->javaVM->internalVMFunctions;\n+\t\t\t\t\t/* It is a well known problem that suspending a Java thread may cause deadlocks in the application if a resource is \n+\t\t\t\t\t * held while suspended. To prevent this happening in the Thread JCL library, check that the Object java.lang.Thread.lock \n+\t\t\t\t\t * has been released before suspending. To make sure of this, acquire the lock while halt is in progress.\n+\t\t\t\t\t */\n+\t\t\t\t\tvmFuncs->objectMonitorEnter(currentThread, J9VMJAVALANGTHREAD_LOCK(targetThread, targetThread->threadObject));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg3MDMzMQ=="}, "originalCommit": {"oid": "4b4f9208eb6e33e18151ff602614d9852d76eb20"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxNzc3MDYyOnYy", "diffSide": "RIGHT", "path": "runtime/jvmti/suspendhelper.cpp", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQwMjo1NzoyM1rOGu_92g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNjowNTo0NVrOGvX7mA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTkzNTcwNg==", "bodyText": "Can this comment point to the Thread.suspend java implementation?  And clarify that the other Thread state calls like isAlive, etc will block forever if we suspend while the thread is holding the Thead.lock?", "url": "https://github.com/eclipse-openj9/openj9/pull/9907#discussion_r451935706", "createdAt": "2020-07-09T02:57:23Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jvmti/suspendhelper.cpp", "diffHunk": "@@ -45,7 +45,15 @@ suspendThread(J9VMThread *currentThread, jthread thread, UDATA allowNull, UDATA\n \t\t\t\tif (currentThread == targetThread) {\n \t\t\t\t\t*currentThreadSuspended = TRUE;\n \t\t\t\t} else {\n-\t\t\t\t\tcurrentThread->javaVM->internalVMFunctions->internalExitVMToJNI(currentThread);\n+\t\t\t\t\tJ9InternalVMFunctions *vmFuncs = currentThread->javaVM->internalVMFunctions;\n+\t\t\t\t\t/* It is a well known problem that suspending a Java thread may cause deadlocks in the application if a resource is \n+\t\t\t\t\t * held while suspended. To prevent this happening in the Thread JCL library, check that the Object java.lang.Thread.lock \n+\t\t\t\t\t * has been released before suspending. To make sure of this, acquire the lock while halt is in progress.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b4f9208eb6e33e18151ff602614d9852d76eb20"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjMwNjkwOQ==", "bodyText": "Also, the comment (and PR title) say exactly the opposite of what the code is doing - it's acquiring the lock around the suspension, not releasing it.", "url": "https://github.com/eclipse-openj9/openj9/pull/9907#discussion_r452306909", "createdAt": "2020-07-09T15:33:15Z", "author": {"login": "gacholio"}, "path": "runtime/jvmti/suspendhelper.cpp", "diffHunk": "@@ -45,7 +45,15 @@ suspendThread(J9VMThread *currentThread, jthread thread, UDATA allowNull, UDATA\n \t\t\t\tif (currentThread == targetThread) {\n \t\t\t\t\t*currentThreadSuspended = TRUE;\n \t\t\t\t} else {\n-\t\t\t\t\tcurrentThread->javaVM->internalVMFunctions->internalExitVMToJNI(currentThread);\n+\t\t\t\t\tJ9InternalVMFunctions *vmFuncs = currentThread->javaVM->internalVMFunctions;\n+\t\t\t\t\t/* It is a well known problem that suspending a Java thread may cause deadlocks in the application if a resource is \n+\t\t\t\t\t * held while suspended. To prevent this happening in the Thread JCL library, check that the Object java.lang.Thread.lock \n+\t\t\t\t\t * has been released before suspending. To make sure of this, acquire the lock while halt is in progress.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTkzNTcwNg=="}, "originalCommit": {"oid": "4b4f9208eb6e33e18151ff602614d9852d76eb20"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjMyODM0NA==", "bodyText": "I've updated the comments to make it more clear.", "url": "https://github.com/eclipse-openj9/openj9/pull/9907#discussion_r452328344", "createdAt": "2020-07-09T16:05:45Z", "author": {"login": "theresa-m"}, "path": "runtime/jvmti/suspendhelper.cpp", "diffHunk": "@@ -45,7 +45,15 @@ suspendThread(J9VMThread *currentThread, jthread thread, UDATA allowNull, UDATA\n \t\t\t\tif (currentThread == targetThread) {\n \t\t\t\t\t*currentThreadSuspended = TRUE;\n \t\t\t\t} else {\n-\t\t\t\t\tcurrentThread->javaVM->internalVMFunctions->internalExitVMToJNI(currentThread);\n+\t\t\t\t\tJ9InternalVMFunctions *vmFuncs = currentThread->javaVM->internalVMFunctions;\n+\t\t\t\t\t/* It is a well known problem that suspending a Java thread may cause deadlocks in the application if a resource is \n+\t\t\t\t\t * held while suspended. To prevent this happening in the Thread JCL library, check that the Object java.lang.Thread.lock \n+\t\t\t\t\t * has been released before suspending. To make sure of this, acquire the lock while halt is in progress.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTkzNTcwNg=="}, "originalCommit": {"oid": "4b4f9208eb6e33e18151ff602614d9852d76eb20"}, "originalPosition": 15}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 31, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}