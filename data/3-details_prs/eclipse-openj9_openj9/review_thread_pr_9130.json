{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk5NjQ2NzEx", "number": 9130, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxMzo0ODowMVrODvIsoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxMzo0ODowMVrODvIsoQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwNzUyMTYxOnYy", "diffSide": "RIGHT", "path": "runtime/compiler/p/codegen/J9TreeEvaluator.cpp", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxMzo0ODowMVrOGBYiwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNDowNTozMlrOGBZYFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDEwMzg3NA==", "bodyText": "Since we're reading the value of scratchReg as an address-sized value using Op_load, shouldn't this be an address-sized compare (i.e. Op_cmpi)?", "url": "https://github.com/eclipse-openj9/openj9/pull/9130#discussion_r404103874", "createdAt": "2020-04-06T13:48:01Z", "author": {"login": "aviansie-ben"}, "path": "runtime/compiler/p/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -988,8 +988,8 @@ J9::Power::TreeEvaluator::generateFillInDataBlockSequenceForUnresolvedField(TR::\n    TR::Register *cndReg = cg->allocateRegister(TR_CCR);\n    generateTrg1MemInstruction(cg, TR::InstOpCode::Op_load, node, scratchReg,\n                      new (cg->trHeapMemory()) TR::MemoryReference(dataSnippetRegister, offsetInDataBlock, TR::Compiler->om.sizeofReferenceAddress(), cg));\n-   generateTrg1Src1ImmInstruction(cg, TR::InstOpCode::andi_r, node, scratchReg, scratchReg, cndReg, -1);\n-   generateConditionalBranchInstruction(cg, TR::InstOpCode::bne, node, unresolvedLabel, cndReg);\n+   generateTrg1Src1ImmInstruction(cg, TR::InstOpCode::cmpi4, node, cndReg, scratchReg, -1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6443fbd14e98a93ac4d96fa217a959223f4eb465"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDExMzQ2MA==", "bodyText": "I think you're right @aviansie-ben. On Z it is an address-sized compare as well (via getCmpOpCode()):\nhttps://github.com/eclipse/openj9/blob/9ef399f4f32fdf48b8bbae6bacd1ac3949e73940/runtime/compiler/z/codegen/J9TreeEvaluator.cpp#L3748-L3757\nGood catch!", "url": "https://github.com/eclipse-openj9/openj9/pull/9130#discussion_r404113460", "createdAt": "2020-04-06T14:00:11Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/p/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -988,8 +988,8 @@ J9::Power::TreeEvaluator::generateFillInDataBlockSequenceForUnresolvedField(TR::\n    TR::Register *cndReg = cg->allocateRegister(TR_CCR);\n    generateTrg1MemInstruction(cg, TR::InstOpCode::Op_load, node, scratchReg,\n                      new (cg->trHeapMemory()) TR::MemoryReference(dataSnippetRegister, offsetInDataBlock, TR::Compiler->om.sizeofReferenceAddress(), cg));\n-   generateTrg1Src1ImmInstruction(cg, TR::InstOpCode::andi_r, node, scratchReg, scratchReg, cndReg, -1);\n-   generateConditionalBranchInstruction(cg, TR::InstOpCode::bne, node, unresolvedLabel, cndReg);\n+   generateTrg1Src1ImmInstruction(cg, TR::InstOpCode::cmpi4, node, cndReg, scratchReg, -1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDEwMzg3NA=="}, "originalCommit": {"oid": "6443fbd14e98a93ac4d96fa217a959223f4eb465"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDExNzUyNQ==", "bodyText": "Right. I was thinking of the offset being 32 bits longs. This will be changed to the 64 bit flavor Op_cmpi.\nSee 46e2850", "url": "https://github.com/eclipse-openj9/openj9/pull/9130#discussion_r404117525", "createdAt": "2020-04-06T14:05:32Z", "author": {"login": "AlenBadel"}, "path": "runtime/compiler/p/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -988,8 +988,8 @@ J9::Power::TreeEvaluator::generateFillInDataBlockSequenceForUnresolvedField(TR::\n    TR::Register *cndReg = cg->allocateRegister(TR_CCR);\n    generateTrg1MemInstruction(cg, TR::InstOpCode::Op_load, node, scratchReg,\n                      new (cg->trHeapMemory()) TR::MemoryReference(dataSnippetRegister, offsetInDataBlock, TR::Compiler->om.sizeofReferenceAddress(), cg));\n-   generateTrg1Src1ImmInstruction(cg, TR::InstOpCode::andi_r, node, scratchReg, scratchReg, cndReg, -1);\n-   generateConditionalBranchInstruction(cg, TR::InstOpCode::bne, node, unresolvedLabel, cndReg);\n+   generateTrg1Src1ImmInstruction(cg, TR::InstOpCode::cmpi4, node, cndReg, scratchReg, -1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDEwMzg3NA=="}, "originalCommit": {"oid": "6443fbd14e98a93ac4d96fa217a959223f4eb465"}, "originalPosition": 6}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 338, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}