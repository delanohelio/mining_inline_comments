{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQzNjYzNTQx", "number": 11529, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxNTo1Mjo1NlrOFK8gEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxNjo0MDoyMlrOFK9tdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3MDIxMzI4OnYy", "diffSide": "RIGHT", "path": "doc/compiler/jitserver/Caching.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxNTo1Mjo1NlrOIN2z9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxNTo1Mjo1NlrOIN2z9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQwMDQzOA==", "bodyText": "I would prefer passive voice here: \"This document will explain why caching is important ...\"", "url": "https://github.com/eclipse-openj9/openj9/pull/11529#discussion_r551400438", "createdAt": "2021-01-04T15:52:56Z", "author": {"login": "mpirvu"}, "path": "doc/compiler/jitserver/Caching.md", "diffHunk": "@@ -22,12 +22,12 @@ SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-excepti\n # Caching in JITServer\n Caching is an important aspect of `JITServer` and one of the main reasons for why `JITServer` client consumes less CPU time compared to local compilation. In this document I will explain why caching is important, what kind of entities we cache, and how some specific caches work.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "993de4eb727379a698840dce79383973912900e3"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3MDIyMjEwOnYy", "diffSide": "RIGHT", "path": "doc/compiler/jitserver/Problem.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxNTo1NTowMFrOIN25Ig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxNTo1NTowMFrOIN25Ig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQwMTc2Mg==", "bodyText": "Connect these two sentences: \".. con be followed for JITServer, but there are ...\"", "url": "https://github.com/eclipse-openj9/openj9/pull/11529#discussion_r551401762", "createdAt": "2021-01-04T15:55:00Z", "author": {"login": "mpirvu"}, "path": "doc/compiler/jitserver/Problem.md", "diffHunk": "@@ -19,9 +19,40 @@ OpenJDK Assembly Exception [2].\n \n SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n -->\n+# Debugging JITServer\n \n-Usually typical OpenJ9 debugging procedures can be followed for JITServer. But there are a few JITServer specific tips and tricks.\n+Typical OpenJ9 debugging procedures can be followed for JITServer. But there are a few JITServer specific tips and tricks.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "993de4eb727379a698840dce79383973912900e3"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3MDI0NzI5OnYy", "diffSide": "RIGHT", "path": "doc/compiler/jitserver/Problem.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxNjowMDo1MVrOIN3HzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxNzozMzoxMlrOIN6iXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQwNTUxNw==", "bodyText": "Can we add somewhere in here about the double compilation debugging feature? This is the one where a method is compiled both at the server and at the client for the purpose of comparing the two compilation logs.", "url": "https://github.com/eclipse-openj9/openj9/pull/11529#discussion_r551405517", "createdAt": "2021-01-04T16:00:51Z", "author": {"login": "mpirvu"}, "path": "doc/compiler/jitserver/Problem.md", "diffHunk": "@@ -19,9 +19,40 @@ OpenJDK Assembly Exception [2].\n \n SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n -->\n+# Debugging JITServer\n \n-Usually typical OpenJ9 debugging procedures can be followed for JITServer. But there are a few JITServer specific tips and tricks.\n+Typical OpenJ9 debugging procedures can be followed for JITServer. But there are a few JITServer specific tips and tricks.\n+Unlike regular OpenJ9, where everything runs in one process, JITServer separates JIT compiler into a separate process while constantly\n+working with addresses/objects that are only valid on the client. This makes it very easy to cause a bug on JITServer and may make it hard to catch.\n+In this document we will explore some common types of bugs and crashes that are encountered in JITServer development and how to deal with them.\n+This document should be expanded upon whenever possible.\n \n+## Server-side crashes\n+The most common type of a server crash is a segmentation fault caused by the compiler trying to dereference an address that is only valid on the client.\n+For example, dereferencing `J9Class` pointer will lead to immediate crash in the best case, or some corrupt data being written in the worst case.\n+If you suddenly discover a crash on the server that you haven't seen before, it's most likely caused by a change to mainline JIT code that did not account\n+for JITServer. If that's the case, the crash should be in the newly added code. You should find the commit that introduced it, and rewrite it in such a way\n+that accounts for JITServer, i.e. do not dereference client pointers directly but fetch the result from the client first.\n+\n+## Client-side crashes\n If the client crashes in `handleServerMessage` after receiving some bad data from the server, you will need to find out what the server was doing when it sent the message. The easiest way to do this is by running both the server and client in gdb, then sending the server a Ctrl-C after the client crashes. From the gdb prompt on the server you can type `thread apply all backtrace` and find the appropriate compilation thread to determine where the server was.\n \n-Please add to this file!!\n+## Crashes in compiled code\n+Another way a client can crash is when it runs the compiled method but something is wrong with it. These can be some of the tougher bugs to fix\n+because you will need to find the failing method and look at its trace log to find the problem. Sometimes, the failure is not caused by one compilation\n+but by a series of them, which makes debugging even harder.\n+\n+Tracing method compilation is the same as for non-JITServer - use `-Xjit:{<method_name>}(traceFull,log=<log_name>)` in the client options and both client", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "993de4eb727379a698840dce79383973912900e3"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ2MTQ3MQ==", "bodyText": "Right, I actually forgot that this option exists.", "url": "https://github.com/eclipse-openj9/openj9/pull/11529#discussion_r551461471", "createdAt": "2021-01-04T17:33:12Z", "author": {"login": "dmitry-ten"}, "path": "doc/compiler/jitserver/Problem.md", "diffHunk": "@@ -19,9 +19,40 @@ OpenJDK Assembly Exception [2].\n \n SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n -->\n+# Debugging JITServer\n \n-Usually typical OpenJ9 debugging procedures can be followed for JITServer. But there are a few JITServer specific tips and tricks.\n+Typical OpenJ9 debugging procedures can be followed for JITServer. But there are a few JITServer specific tips and tricks.\n+Unlike regular OpenJ9, where everything runs in one process, JITServer separates JIT compiler into a separate process while constantly\n+working with addresses/objects that are only valid on the client. This makes it very easy to cause a bug on JITServer and may make it hard to catch.\n+In this document we will explore some common types of bugs and crashes that are encountered in JITServer development and how to deal with them.\n+This document should be expanded upon whenever possible.\n \n+## Server-side crashes\n+The most common type of a server crash is a segmentation fault caused by the compiler trying to dereference an address that is only valid on the client.\n+For example, dereferencing `J9Class` pointer will lead to immediate crash in the best case, or some corrupt data being written in the worst case.\n+If you suddenly discover a crash on the server that you haven't seen before, it's most likely caused by a change to mainline JIT code that did not account\n+for JITServer. If that's the case, the crash should be in the newly added code. You should find the commit that introduced it, and rewrite it in such a way\n+that accounts for JITServer, i.e. do not dereference client pointers directly but fetch the result from the client first.\n+\n+## Client-side crashes\n If the client crashes in `handleServerMessage` after receiving some bad data from the server, you will need to find out what the server was doing when it sent the message. The easiest way to do this is by running both the server and client in gdb, then sending the server a Ctrl-C after the client crashes. From the gdb prompt on the server you can type `thread apply all backtrace` and find the appropriate compilation thread to determine where the server was.\n \n-Please add to this file!!\n+## Crashes in compiled code\n+Another way a client can crash is when it runs the compiled method but something is wrong with it. These can be some of the tougher bugs to fix\n+because you will need to find the failing method and look at its trace log to find the problem. Sometimes, the failure is not caused by one compilation\n+but by a series of them, which makes debugging even harder.\n+\n+Tracing method compilation is the same as for non-JITServer - use `-Xjit:{<method_name>}(traceFull,log=<log_name>)` in the client options and both client", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQwNTUxNw=="}, "originalCommit": {"oid": "993de4eb727379a698840dce79383973912900e3"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3MDI1MzkyOnYy", "diffSide": "RIGHT", "path": "doc/compiler/jitserver/Problem.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxNjowMjo0MFrOIN3L_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxNjowMjo0MFrOIN3L_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQwNjU5MA==", "bodyText": "\"Unlike regular OpenJ9 where everything runs in one process, JITServer technology moves the JIT compiler activity into a separate process while ...\"", "url": "https://github.com/eclipse-openj9/openj9/pull/11529#discussion_r551406590", "createdAt": "2021-01-04T16:02:40Z", "author": {"login": "mpirvu"}, "path": "doc/compiler/jitserver/Problem.md", "diffHunk": "@@ -19,9 +19,40 @@ OpenJDK Assembly Exception [2].\n \n SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n -->\n+# Debugging JITServer\n \n-Usually typical OpenJ9 debugging procedures can be followed for JITServer. But there are a few JITServer specific tips and tricks.\n+Typical OpenJ9 debugging procedures can be followed for JITServer. But there are a few JITServer specific tips and tricks.\n+Unlike regular OpenJ9, where everything runs in one process, JITServer separates JIT compiler into a separate process while constantly", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "993de4eb727379a698840dce79383973912900e3"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3MDMwOTk1OnYy", "diffSide": "RIGHT", "path": "doc/compiler/jitserver/ResolvedMethod.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxNjoxNToyNFrOIN3uFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxNjoxNToyNFrOIN3uFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQxNTMxOA==", "bodyText": "\"This means that minimizing\" --> \"Therefore, minimizing...\"", "url": "https://github.com/eclipse-openj9/openj9/pull/11529#discussion_r551415318", "createdAt": "2021-01-04T16:15:24Z", "author": {"login": "mpirvu"}, "path": "doc/compiler/jitserver/ResolvedMethod.md", "diffHunk": "@@ -20,8 +20,52 @@ OpenJDK Assembly Exception [2].\n SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n -->\n \n-ResolvedMethod is a wrapper around a Java method which exists for the duration of a single compilation. It collects and manages information about a method and related classes. We need to extend it \n+# Resolved Methods\n+## What are resolved methods?\n \n-On the server, we extend `TR_ResolvedJ9JITServerMethod` from `TR_ResolvedJ9Method`. Upon instantiation, a mirror instance is created on the client. Instantiation happens either directly via the `createResolvedMethod` family, or indirectly using one of multiple `getResolvedXXXMethod` methods, which perform operations to locate a method of interest and then create the corresponding `ResolvedMethod`.\n+Resolved methods are wrappers around Java methods which exist for the duration of a single compilation. They collect and manage information about a method and related classes.\n+Resolved methods are some of the most commonly used entitites by the JIT compiler, thus it is important to handle them correctly and efficiently on JITServer.\n+\n+For non-JITServer, we mostly care about 2 classes representing a resolved method - `TR_ResolvedJ9Method` and `TR_ResolvedRelocatableJ9Method`.\n+The former represents resolved methods in a regular compilation, and the latter in an AOT compilation.\n+\n+## JITServer implementation\n+\n+### Class hierarchy\n+On the server, we implement two new classes to represent resolved methods - `TR_ResolvedJ9JITServerMethod` and `TR_ResolvedRelocatableJ9JITServerMethod`.\n+Same as for non-JITServer, the former is for regular compilations and the latter is for AOT. `TR_ResolvedJ9JITServerMethod` is extended from `TR_ResolvedJ9Method` and \n+`TR_ResolvedRelocatableJ9JITServerMethod` is extended from `TR_ResolvedJ9JITServerMethod`.\n+\n+### Client-side mirrors\n+Upon instantiation of a server-side resolved method, a resolved method is also created on the client that represents the same Java method. We call that client-side copy \"mirror\".\n+\n+Instantiation happens either directly via the `createResolvedMethod` family, or indirectly using one of multiple `getResolvedXXXMethod` methods, which perform operations to locate a method of interest and then create the corresponding `ResolvedMethod`.\n+\n+### Caching inside resolved methods\n+Some answers to resolved method queries are cached at the server to avoid sending remote messages.\n+All of this information is sent during method instantiation, inside `TR_ResolvedJ9JITServerMethodInfo`.\n+The cached values either won't change during the lifetime of a resolved method (i.e. constant pool pointer, J9 class pointer)\n+or having incorrect value cached for the duration of one compilation does not have impact on correctness or performance (i.e. whether a method is interpreted).\n+\n+Resolved methods could also be used as more general per-compilation caches, containing information that does not directly describe the resolved method itself.\n+Since resolved methods are destroyed at the end of compilation, this would be functionally correct.\n+However, such usage is discouraged because `TR::CompilationInfoPerThreadRemote` is a better place for such caches. Placing caches there makes them more visible\n+and it makes more sense to store information not related to resolved methods outside of them.\n+\n+### Performance considerations\n+\n+Since resolved methods are so frequently created and used, the number of remote messages associated with them is normally a large portion of total messages. This means that minimizing the number of requests for resolved method creation is important for improving CPU consumption.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "993de4eb727379a698840dce79383973912900e3"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3MDMyMjcxOnYy", "diffSide": "RIGHT", "path": "doc/compiler/jitserver/ResolvedMethod.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxNjoxODozNVrOIN314A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxNjoxODozNVrOIN314A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQxNzMxMg==", "bodyText": "Please delete the last two sentences: \"Maybe there exists...\"", "url": "https://github.com/eclipse-openj9/openj9/pull/11529#discussion_r551417312", "createdAt": "2021-01-04T16:18:35Z", "author": {"login": "mpirvu"}, "path": "doc/compiler/jitserver/ResolvedMethod.md", "diffHunk": "@@ -20,8 +20,52 @@ OpenJDK Assembly Exception [2].\n SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n -->\n \n-ResolvedMethod is a wrapper around a Java method which exists for the duration of a single compilation. It collects and manages information about a method and related classes. We need to extend it \n+# Resolved Methods\n+## What are resolved methods?\n \n-On the server, we extend `TR_ResolvedJ9JITServerMethod` from `TR_ResolvedJ9Method`. Upon instantiation, a mirror instance is created on the client. Instantiation happens either directly via the `createResolvedMethod` family, or indirectly using one of multiple `getResolvedXXXMethod` methods, which perform operations to locate a method of interest and then create the corresponding `ResolvedMethod`.\n+Resolved methods are wrappers around Java methods which exist for the duration of a single compilation. They collect and manage information about a method and related classes.\n+Resolved methods are some of the most commonly used entitites by the JIT compiler, thus it is important to handle them correctly and efficiently on JITServer.\n+\n+For non-JITServer, we mostly care about 2 classes representing a resolved method - `TR_ResolvedJ9Method` and `TR_ResolvedRelocatableJ9Method`.\n+The former represents resolved methods in a regular compilation, and the latter in an AOT compilation.\n+\n+## JITServer implementation\n+\n+### Class hierarchy\n+On the server, we implement two new classes to represent resolved methods - `TR_ResolvedJ9JITServerMethod` and `TR_ResolvedRelocatableJ9JITServerMethod`.\n+Same as for non-JITServer, the former is for regular compilations and the latter is for AOT. `TR_ResolvedJ9JITServerMethod` is extended from `TR_ResolvedJ9Method` and \n+`TR_ResolvedRelocatableJ9JITServerMethod` is extended from `TR_ResolvedJ9JITServerMethod`.\n+\n+### Client-side mirrors\n+Upon instantiation of a server-side resolved method, a resolved method is also created on the client that represents the same Java method. We call that client-side copy \"mirror\".\n+\n+Instantiation happens either directly via the `createResolvedMethod` family, or indirectly using one of multiple `getResolvedXXXMethod` methods, which perform operations to locate a method of interest and then create the corresponding `ResolvedMethod`.\n+\n+### Caching inside resolved methods\n+Some answers to resolved method queries are cached at the server to avoid sending remote messages.\n+All of this information is sent during method instantiation, inside `TR_ResolvedJ9JITServerMethodInfo`.\n+The cached values either won't change during the lifetime of a resolved method (i.e. constant pool pointer, J9 class pointer)\n+or having incorrect value cached for the duration of one compilation does not have impact on correctness or performance (i.e. whether a method is interpreted).\n+\n+Resolved methods could also be used as more general per-compilation caches, containing information that does not directly describe the resolved method itself.\n+Since resolved methods are destroyed at the end of compilation, this would be functionally correct.\n+However, such usage is discouraged because `TR::CompilationInfoPerThreadRemote` is a better place for such caches. Placing caches there makes them more visible\n+and it makes more sense to store information not related to resolved methods outside of them.\n+\n+### Performance considerations\n+\n+Since resolved methods are so frequently created and used, the number of remote messages associated with them is normally a large portion of total messages. This means that minimizing the number of requests for resolved method creation is important for improving CPU consumption.\n+\n+There are two main ways we optimize resolved method creation:\n+1. Caching all newly created resolved methods in a per-compilation cache on the server. We use `TR_ResolvedMethodInfoCache` and put it in `TR::CompilationInfoPerThreadRemote`.\n+Whenever a resolved method needs to be created, server will first check the cache and recreate the resolved method from there, if possible.\n+2. Prefetching multiple resolved methods before they are first requested. There are parts of the compiler that request many resolved methods in a loop.\n+For example, ILGen and inliner will walk through method bytecodes and create a resolved method for every method call bytecode. \n+We use `TR_ResolvedJ9JITServerMethod::cacheResolvedMethodsCallees` to do a preliminary walk and cache all required methods in one remote call.\n+Techniques like these do not reduce the total number of resolved methods created or data transferred through the network but it reduces the total number of remote calls,\n+which still has a positive impact on CPU consumption.\n+\n+Despite all these optimizations, resolved methods are still responsible for most of the remote messages. This is due to the fact that resolved methods only exist\n+for the duration of a single compilation so any type of persistent caching is not available to us. Maybe there exists some way to get around this limitation", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "993de4eb727379a698840dce79383973912900e3"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3MDQxMTQxOnYy", "diffSide": "RIGHT", "path": "doc/compiler/jitserver/Usage.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxNjo0MDoyMlrOIN4q2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxNjo0MDoyMlrOIN4q2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQzMDg3Mg==", "bodyText": "Maybe we should also mention about the heart-beat?", "url": "https://github.com/eclipse-openj9/openj9/pull/11529#discussion_r551430872", "createdAt": "2021-01-04T16:40:22Z", "author": {"login": "mpirvu"}, "path": "doc/compiler/jitserver/Usage.md", "diffHunk": "@@ -53,23 +53,37 @@ With verbose logging, if a client connects successfully then server output shoul\n ```\n $ jitserver -Xjit:verbose=\\{JITServer\\}\n \n-JITServer is currently a technology preview. Its use is not yet supported\n-\n+JITServer is currently a technology preview. Its use is not yet supported.\n+#JITServer: JITServer version: 1.17.0\n #JITServer: JITServer Server Mode. Port: 38400. Connection Timeout 30000ms\n-#JITServer: Started JITServer listener thread: 0000000000226C00\n+#JITServer: Started JITServer listener thread: 000000000022AD00\n+\n JITServer is ready to accept incoming requests\n \n-#JITServer: Server received request for stream 00007FEC658EF720\n-#JITServer: Server allocated data for a new clientUID 11129135271614904954\n-#JITServer: compThreadID=0 created clientSessionData=00007FEC658EFBE0 for clientUID=11129135271614904954 seqNo=0\n-#JITServer: Server will process a list of 0 unloaded classes for clientUID 11129135271614904954\n-#JITServer: compThreadID=0 has successfully compiled java/lang/Double.longBitsToDouble(J)D\n-#JITServer: compThreadID=0 found clientSessionData=00007FEC658EFBE0 for clientUID=11129135271614904954 seqNo=1\n-#JITServer: Server will process a list of 0 unloaded classes for clientUID 11129135271614904954\n-#JITServer: compThreadID=0 has successfully compiled jdk/internal/reflect/Reflection.getCallerClass()Ljava/lang/Class;\n-#JITServer: compThreadID=0 found clientSessionData=00007FEC658EFBE0 for clientUID=11129135271614904954 seqNo=2\n-#JITServer: Server will process a list of 0 unloaded classes for clientUID 11129135271614904954\n-#JITServer: compThreadID=0 has successfully compiled java/lang/System.getEncoding(I)Ljava/lang/String;\n+#JITServer: Server received request for stream 00007F50BC4E7AB0\n+#JITServer: Server allocated data for a new clientUID 7315883206984276314\n+#JITServer: compThreadID=0 created clientSessionData=00007F50BC4F0880 for clientUID=7315883206984276314 seqNo=1 (isCritical=1) (criticalSeqNo=0 lastProcessedCriticalReq=0)\n+#JITServer: compThreadID=0 will ask for address ranges of unloaded classes and CHTable for clientUID 7315883206984276314\n+#JITServer: compThreadID=0 will initialize CHTable for clientUID 7315883206984276314 size=1152\n+#JITServer: compThreadID=0 has successfully compiled java/lang/Object.<init>()V\n+#JITServer: compThreadID=0 found clientSessionData=00007F50BC4F0880 for clientUID=7315883206984276314 seqNo=2 (isCritical=1) (criticalSeqNo=1 lastProcessedCriticalReq=1)\n+#JITServer: compThreadID=0 has successfully compiled com/ibm/jit/JITHelpers.classIsInterfaceFlag()I\n+#JITServer: compThreadID=0 found clientSessionData=00007F50BC4F0880 for clientUID=7315883206984276314 seqNo=3 (isCritical=1) (criticalSeqNo=2 lastProcessedCriticalReq=2)\n+#JITServer: compThreadID=0 has successfully compiled jdk/internal/misc/Unsafe.arrayBaseOffset(Ljava/lang/Class;)I\n+#JITServer: compThreadID=0 found clientSessionData=00007F50BC4F0880 for clientUID=7315883206984276314 seqNo=4 (isCritical=1) (criticalSeqNo=3 lastProcessedCriticalReq=3)\n+...\n+```\n+\n+Note that JITServer prints out version information that is different from `java -version` output.\n+To use JITServer, client and server must have matching versions.\n+To check client's version pass it `verbose=\\{JITServer\\}` option as well.\n+```\n+$ java -XX:+UseJITServer -Xjit:verbose=\\{JITServer\\} -version\n+\n+JITServer is currently a technology preview. Its use is not yet supported\n+#JITServer: JITServer version: 1.17.0\n+#JITServer: JITServer Client Mode. Server address: localhost port: 38400. Connection Timeout 2000ms\n+#JITServer: Identifier for current client JVM: 9238414254742342824\n ...\n ```\n ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "993de4eb727379a698840dce79383973912900e3"}, "originalPosition": 51}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 893, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}