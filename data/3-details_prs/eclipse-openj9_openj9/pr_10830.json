{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk5NTU2MDc4", "number": 10830, "title": "Add support for OpenJDK (OJDK) MethodHandle (MH) in MethodHandleResolver", "bodyText": "1. Update sendResolveMethodHandle and resolveFieldHandleHelper for OJDK MH\nFor OJDK MH, the usage of accessCheckArgRetTypes has been commented from\nsendResolveMethodHandle and resolveFieldHandleHelper since this method\nis not available in OpenJDK Lookup.\nTODO: Investigate if an equivalent for lookup.accessCheckArgRetTypes is\nneeded for OJDK MH. If needed, find an alternative for\nlookup.accessCheckArgRetTypes.\nOpenJDK Lookup does not have constructor Lookup(Class<?>, boolean). So,\nit has been replaced with constructor Lookup(Class<?>) in\nsendResolveMethodHandle.\n2. Add support to resolve invokedynamic under OpenJDK MethodHandles\nMethodHandleNatives.linkCallSite is used to resolve invokedynamic.\nThe resolved values are returned in a two element array. The first array\nelement is a MemberName object, and the second array element is a\nMethodHandle object.\nThe return type of resolveInvokeDynamic is changed to Object in order to\nsupport both the OpenJ9 and OpenJDK implementations for resolving\ninvokedynamic. For OpenJDK MethodHandles, the two element array is\ncasted to an Object before being returned. For OpenJ9 MethodHandles, the\nMethodHandle object automatically qualifies as an Object. The change in\nreturn type is reflected in vmconstantpool.xml.\n3. Add support to resolve constantdynamic under OpenJDK MethodHandles\nFor OpenJDK MethodHandles, MethodHandleNatives.linkDynamicConstant is\nused to resolve constantdynamic.\nThe resolve value is returned in the form of an Object, which is\nidentical to the OpenJ9 implementation.\n4. Add the implementation for resolveMethodHandle\nlinkCallerMethod was previously named as resolveMethodHandle.\nIt's a wrapper for MethodHandleNatives.linkMethod. It is used in\ninvokehandle for MethodHandle and VarHandle polymorphic methods. The\nresolution yields two values. The two values are returned in a two\nelement array. The first array element is a MemberName object, which\nspecifies the caller method to be invoked. The second array element is a\nMethodType object if the defining class is a MethodHandle and an\nAccessDescriptor object if the defining class is a VarHandle.\nlinkCallerMethod is only needed for OJDK MH. InternalError will be\nthrown if it is invoked for OpenJ9 MH.\n5. Disable invokeBsm for OJDK MH\ninvokeBsm is unused for OpenJDK MethodHandles.\nDepends on #10096.\nRebase needed after #10096 is merged.\nRelated: #7352.\nCo-authored-by: Jack Lu Jack.S.Lu@ibm.com\nSigned-off-by: Babneet Singh sbabneet@ca.ibm.com", "createdAt": "2020-10-07T22:43:25Z", "url": "https://github.com/eclipse-openj9/openj9/pull/10830", "merged": true, "mergeCommit": {"oid": "b403bb1f0f9286fe847f68cddce3daa40fc0fc4f"}, "closed": true, "closedAt": "2020-10-22T17:24:26Z", "author": {"login": "babsingh"}, "timelineItems": {"totalCount": 19, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdQibgBAFqTUwNDgzMzkzNQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdUhHYZgBqjM5MDExNjA4NTg=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0ODMzOTM1", "url": "https://github.com/eclipse-openj9/openj9/pull/10830#pullrequestreview-504833935", "createdAt": "2020-10-08T14:18:56Z", "commit": {"oid": "628621af13063ff19389e32968006a10049e2edc"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxNDoxODo1NlrOHeg6iw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxNDoyNDoyNFrOHehMFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc1ODYwMw==", "bodyText": "Why does OpenJDK methodHandles not need this access check?", "url": "https://github.com/eclipse-openj9/openj9/pull/10830#discussion_r501758603", "createdAt": "2020-10-08T14:18:56Z", "author": {"login": "DanHeidinga"}, "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodHandleHelper.java", "diffHunk": "@@ -0,0 +1,699 @@\n+/*[INCLUDE-IF Sidecar18-SE]*/\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+package java.lang.invoke;\n+\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.util.ArrayList;\n+import java.util.Objects;\n+\n+import com.ibm.oti.util.Msg;\n+import com.ibm.oti.vm.VM;\n+import com.ibm.oti.vm.VMLangAccess;\n+\n+/*[IF Sidecar19-SE]\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.reflect.ConstantPool;\n+/*[ELSE]*/\n+import sun.misc.Unsafe;\n+import sun.reflect.ConstantPool;\n+/*[ENDIF]*/\n+\n+import com.ibm.jit.JITHelpers;\n+\n+/**\n+ * Static methods for the MethodHandle class.\n+ */\n+public final class MethodHandleHelper {\n+\tstatic final Unsafe UNSAFE = Unsafe.getUnsafe();\n+\n+\tstatic final JITHelpers JITHELPERS = JITHelpers.getHelpers();\n+\t\n+\tprivate static final int BSM_ARGUMENT_SIZE = Short.SIZE / Byte.SIZE;\n+\tprivate static final int BSM_ARGUMENT_COUNT_OFFSET = BSM_ARGUMENT_SIZE;\n+\tprivate static final int BSM_ARGUMENTS_OFFSET = BSM_ARGUMENT_SIZE * 2;\n+\tprivate static final int BSM_LOOKUP_ARGUMENT_INDEX = 0;\n+\tprivate static final int BSM_NAME_ARGUMENT_INDEX = 1;\n+\tprivate static final int BSM_TYPE_ARGUMENT_INDEX = 2;\n+\tprivate static final int BSM_OPTIONAL_ARGUMENTS_START_INDEX = 3;\n+\n+\t/*\n+\t * Return the result of J9_CP_TYPE(J9Class->romClass->cpShapeDescription, index)\n+\t */\n+\tprivate static final native int getCPTypeAt(Object internalRamClass, int index);\n+\n+\t/*\n+\t * sun.reflect.ConstantPool doesn't have a getMethodTypeAt method.  This is the \n+\t * equivalent for MethodType.\n+\t */\n+\tprivate static final native MethodType getCPMethodTypeAt(Object internalRamClass, int index);\n+\n+\t/*\n+\t * sun.reflect.ConstantPool doesn't have a getMethodHandleAt method.  This is the \n+\t * equivalent for MethodHandle.\n+\t */\n+\tprivate static final native MethodHandle getCPMethodHandleAt(Object internalRamClass, int index);\n+\n+\t\n+\t/**\n+\t * Get the class name from a constant pool class element, which is located\n+\t * at the specified <i>index</i> in <i>clazz</i>'s constant pool.\n+\t * \n+\t * @param   an instance of class - its constant pool is accessed\n+\t * @param   the constant pool index\n+\t * \n+\t * @return  instance of String which contains the class name or NULL in\n+\t *          case of error\n+\t * \n+\t * @throws  NullPointerException if <i>clazz</i> is null\n+\t * @throws  IllegalArgumentException if <i>index</i> has wrong constant pool type\n+\t */\n+\tprivate static final native String getCPClassNameAt(Class<?> clazz, int index);\n+\t\n+/*[IF Java11]*/\n+\t/*\n+\t * sun.reflect.ConstantPool doesn't have a getConstantDynamicAt method.  This is the \n+\t * equivalent for ConstantDynamic.\n+\t */\n+\tprivate static final native Object getCPConstantDynamicAt(Object internalRamClass, int index);\n+\n+\t@SuppressWarnings(\"unused\")\n+\tprivate static final Object resolveConstantDynamic(long j9class, String name, String fieldDescriptor, long bsmData) throws Throwable {\n+/*[IF OPENJDK_METHODHANDLES]*/\n+\t\tObject result = null;\n+\n+\t\tVMLangAccess access = VM.getVMLangAccess();\n+\t\tObject internalRamClass = access.createInternalRamClass(j9class);\n+\t\tClass<?> classObject = getClassFromJ9Class(j9class);\n+\n+\t\tClass<?> typeClass = fromFieldDescriptorString(fieldDescriptor, access.getClassloader(classObject));\n+\n+\t\tint bsmIndex = UNSAFE.getShort(bsmData);\n+\t\tint bsmArgCount = UNSAFE.getShort(bsmData + BSM_ARGUMENT_COUNT_OFFSET);\n+\t\tlong bsmArgs = bsmData + BSM_ARGUMENTS_OFFSET;\n+\t\tMethodHandle bsm = getCPMethodHandleAt(internalRamClass, bsmIndex);\n+\t\tif (null == bsm) {\n+\t\t\t/*[MSG \"K05cd\", \"unable to resolve 'bootstrap_method_ref' in '{0}' at index {1}\"]*/\n+\t\t\tthrow new NullPointerException(Msg.getString(\"K05cd\", classObject.toString(), bsmIndex)); //$NON-NLS-1$\n+\t\t}\n+\t\tObject[] staticArgs = new Object[bsmArgCount];\n+\n+\t\t/* Static optional arguments */\n+\t\tint bsmTypeArgCount = bsm.type().parameterCount();\n+\n+\t\t/* JVMS JDK11 5.4.3.6 Dynamically-Computed Constant and Call Site Resolution\n+\t\t * requires the first parameter of the bootstrap method to be java.lang.invoke.MethodHandles.Lookup\n+\t\t * else fail resolution with BootstrapMethodError\n+\t\t */\n+\t\tif (bsmTypeArgCount < 1 || MethodHandles.Lookup.class != bsm.type().parameterType(0)) {\n+\t\t\t/*[MSG \"K0A01\", \"Constant_Dynamic references bootstrap method '{0}' does not have java.lang.invoke.MethodHandles.Lookup as first parameter.\"]*/\n+\t\t\tthrow new BootstrapMethodError(Msg.getString(\"K0A01\", bsm)); //$NON-NLS-1$\n+\t\t}\n+\n+\t\tfor (int i = 0; i < bsmArgCount; i++) {\n+\t\t\tstaticArgs[i] = getAdditionalBsmArg(access, internalRamClass, classObject, bsm, bsmArgs, bsmTypeArgCount, i);\n+\t\t}\n+\n+\t\t/* JVMS JDK11 5.4.3.6 Dynamically-Computed Constant and Call Site Resolution\n+\t\t * requires that exceptions from BSM invocation be wrapped in a BootstrapMethodError\n+\t\t * unless the exception thrown is a sub-class of Error.\n+\t\t * Exceptions thrown before invocation should be passed through unwrapped.\n+\t\t */\n+\t\ttry {\n+\t\t\tresult = MethodHandleNatives.linkDynamicConstant(classObject, 0, bsm, name, typeClass, (Object)staticArgs);\n+\t\t\t/* result validation */\n+\t\t\tresult = MethodHandles.identity(typeClass).invoke(result);\n+\t\t} catch(Throwable e) {\n+\t\t\tif (e instanceof Error) {\n+\t\t\t\tthrow e;\n+\t\t\t} else {\n+\t\t\t\t/*[MSG \"K0A00\", \"Failed to resolve Constant Dynamic entry with j9class: {0}, name: {1}, descriptor: {2}, bsmData: {3}\"]*/\n+\t\t\t\tString msg = Msg.getString(\"K0A00\", new Object[] {String.valueOf(j9class), name, fieldDescriptor, String.valueOf(bsmData)}); //$NON-NLS-1$\n+\t\t\t\tthrow new BootstrapMethodError(msg, e);\n+\t\t\t}\n+\t\t}\n+\t\t\n+\t\treturn result;\n+/*[ELSE]*/\n+\t\tObject result = null;\n+\n+\t\tVMLangAccess access = VM.getVMLangAccess();\n+\t\tObject internalRamClass = access.createInternalRamClass(j9class);\n+\t\tClass<?> classObject = getClassFromJ9Class(j9class);\n+\n+\t\tClass<?> typeClass = fromFieldDescriptorString(fieldDescriptor, access.getClassloader(classObject));\n+\n+\t\tint bsmIndex = UNSAFE.getShort(bsmData);\n+\t\tint bsmArgCount = UNSAFE.getShort(bsmData + BSM_ARGUMENT_COUNT_OFFSET);\n+\t\tlong bsmArgs = bsmData + BSM_ARGUMENTS_OFFSET;\n+\t\tMethodHandle bsm = getCPMethodHandleAt(internalRamClass, bsmIndex);\n+\t\tif (null == bsm) {\n+\t\t\t/*[MSG \"K05cd\", \"unable to resolve 'bootstrap_method_ref' in '{0}' at index {1}\"]*/\n+\t\t\tthrow new NullPointerException(Msg.getString(\"K05cd\", classObject.toString(), bsmIndex)); //$NON-NLS-1$\n+\t\t}\n+\t\tObject[] staticArgs = new Object[BSM_OPTIONAL_ARGUMENTS_START_INDEX + bsmArgCount];\n+\t\t/* Mandatory arguments */\n+\t\tstaticArgs[BSM_LOOKUP_ARGUMENT_INDEX] = new MethodHandles.Lookup(classObject, false);\n+\t\tstaticArgs[BSM_NAME_ARGUMENT_INDEX] = name;\n+\t\tstaticArgs[BSM_TYPE_ARGUMENT_INDEX] = typeClass;\n+\n+\t\t/* Static optional arguments */\n+\t\tint bsmTypeArgCount = bsm.type().parameterCount();\n+\n+\t\t/* JVMS JDK11 5.4.3.6 Dynamically-Computed Constant and Call Site Resolution\n+\t\t * requires the first parameter of the bootstrap method to be java.lang.invoke.MethodHandles.Lookup\n+\t\t * else fail resolution with BootstrapMethodError\n+\t\t */\n+\t\tif (bsmTypeArgCount < 1 || MethodHandles.Lookup.class != bsm.type().parameterType(0)) {\n+\t\t\t/*[MSG \"K0A01\", \"Constant_Dynamic references bootstrap method '{0}' does not have java.lang.invoke.MethodHandles.Lookup as first parameter.\"]*/\n+\t\t\tthrow new BootstrapMethodError(Msg.getString(\"K0A01\", bsm.getMethodName())); //$NON-NLS-1$\n+\t\t}\n+\n+\t\tfor (int i = 0; i < bsmArgCount; i++) {\n+\t\t\tstaticArgs[BSM_OPTIONAL_ARGUMENTS_START_INDEX + i] = getAdditionalBsmArg(access, internalRamClass, classObject, bsm, bsmArgs, bsmTypeArgCount, i);\n+\t\t}\n+\n+\t\t/* JVMS JDK11 5.4.3.6 Dynamically-Computed Constant and Call Site Resolution\n+\t\t * requires that exceptions from BSM invocation be wrapped in a BootstrapMethodError\n+\t\t * unless the exception thrown is a sub-class of Error.\n+\t\t * Exceptions thrown before invocation should be passed through unwrapped.\n+\t\t */\n+\t\ttry {\n+\t\t\tresult = (Object)invokeBsm(bsm, staticArgs);\n+\t\t\t/* result validation */\n+\t\t\tresult = MethodHandles.identity(typeClass).invoke(result);\n+\t\t} catch(Throwable e) {\n+\t\t\tif (e instanceof Error) {\n+\t\t\t\tthrow e;\n+\t\t\t} else {\n+\t\t\t\t/*[MSG \"K0A00\", \"Failed to resolve Constant Dynamic entry with j9class: {0}, name: {1}, descriptor: {2}, bsmData: {3}\"]*/\n+\t\t\t\tString msg = Msg.getString(\"K0A00\", new Object[] {String.valueOf(j9class), name, fieldDescriptor, String.valueOf(bsmData)}); //$NON-NLS-1$\n+\t\t\t\tthrow new BootstrapMethodError(msg, e);\n+\t\t\t}\n+\t\t}\n+\t\t\n+\t\treturn result;\n+/*[ENDIF] OPENJDK_METHODHANDLES*/\n+\t}\n+/*[ENDIF] Java11*/\n+\n+\t/*[IF ]*/\n+\t/*\n+\t * Used to preserve the new objectRef on the stack when avoiding the call-in for\n+\t * constructorHandles.  Must return 'this' so stackmapper will keep the object\n+\t * alive.\n+\t */\n+\t/*[ENDIF]*/\n+\t@SuppressWarnings(\"unused\")\n+\t@VMCONSTANTPOOL_METHOD\n+\tprivate static Object constructorPlaceHolder(Object newObjectRef) {\n+\t\treturn newObjectRef;\n+\t}\n+\n+\t/**\n+\t * Invoke bootstrap method with its static arguments\n+\t * @param bsm\n+\t * @param staticArgs\n+\t * @return result of bsm invocation\n+\t * @throws Throwable any throwable will be handled by the caller\n+\t */\n+\tprivate static final Object invokeBsm(MethodHandle bsm, Object[] staticArgs) throws Throwable {\n+\t\tObject result = null;\n+\t\t/* Take advantage of the per-MH asType cache */\n+\t\tswitch(staticArgs.length) {\n+\t\tcase 3:\n+\t\t\tresult = bsm.invoke(staticArgs[0], staticArgs[1], staticArgs[2]);\n+\t\t\tbreak;\n+\t\tcase 4:\n+\t\t\tresult = bsm.invoke(staticArgs[0], staticArgs[1], staticArgs[2], staticArgs[3]);\n+\t\t\tbreak;\n+\t\tcase 5:\n+\t\t\tresult = bsm.invoke(staticArgs[0], staticArgs[1], staticArgs[2], staticArgs[3], staticArgs[4]);\n+\t\t\tbreak;\n+\t\tcase 6:\n+\t\t\tresult = bsm.invoke(staticArgs[0], staticArgs[1], staticArgs[2], staticArgs[3], staticArgs[4], staticArgs[5]);\n+\t\t\tbreak;\n+\t\tcase 7:\n+\t\t\tresult = bsm.invoke(staticArgs[0], staticArgs[1], staticArgs[2], staticArgs[3], staticArgs[4], staticArgs[5], staticArgs[6]);\n+\t\t\tbreak;\n+\t\tdefault:\n+\t\t\tresult = bsm.invokeWithArguments(staticArgs);\n+\t\t\tbreak;\n+\t\t}\n+\t\treturn result;\n+\t}\n+\t\n+\t@SuppressWarnings(\"unused\")\n+\tprivate static final Object resolveInvokeDynamic(long j9class, String name, String methodDescriptor, long bsmData) throws Throwable {\n+/*[IF OPENJDK_METHODHANDLES]*/\n+\t\tObject[] result = new Object[2];\n+\t\tMethodType type = null;\n+\n+\t\ttry {\n+\t\t\tVMLangAccess access = VM.getVMLangAccess();\n+\t\t\tObject internalRamClass = access.createInternalRamClass(j9class);\n+\t\t\tClass<?> classObject = getClassFromJ9Class(j9class);\n+\t\t\t\n+\t\t\ttype = MethodType.vmResolveFromMethodDescriptorString(methodDescriptor, access.getClassloader(classObject), null);\n+\n+\t\t\tint bsmIndex = UNSAFE.getShort(bsmData);\n+\t\t\tint bsmArgCount = UNSAFE.getShort(bsmData + BSM_ARGUMENT_COUNT_OFFSET);\n+\t\t\tlong bsmArgs = bsmData + BSM_ARGUMENTS_OFFSET;\n+\t\t\tMethodHandle bsm = getCPMethodHandleAt(internalRamClass, bsmIndex);\n+\t\t\tif (null == bsm) {\n+\t\t\t\t/*[MSG \"K05cd\", \"unable to resolve 'bootstrap_method_ref' in '{0}' at index {1}\"]*/\n+\t\t\t\tthrow new NullPointerException(Msg.getString(\"K05cd\", classObject.toString(), bsmIndex)); //$NON-NLS-1$\n+\t\t\t}\n+\t\t\tObject[] staticArgs = new Object[bsmArgCount];\n+\n+\t\t\t/* Static optional arguments */\n+\t\t\tint bsmTypeArgCount = bsm.type().parameterCount();\n+\t\t\tfor (int i = 0; i < bsmArgCount; i++) {\n+\t\t\t\tstaticArgs[i] = getAdditionalBsmArg(access, internalRamClass, classObject, bsm, bsmArgs, bsmTypeArgCount, i);\n+\t\t\t}\n+\n+\t\t\tObject[] appendixResult = new Object[1];\n+\t\t\tappendixResult[0] = null;\n+\t\t\ttry {\n+\t\t\t\tMemberName mname = MethodHandleNatives.linkCallSite(classObject, 0, bsm, name, type, (Object)staticArgs, appendixResult);\n+\n+\t\t\t\tresult[0] = mname;\n+\t\t\t\tresult[1] = appendixResult[0];\n+\t\t\t} catch (Throwable e) {\n+\t\t\t\tif (e instanceof Error) {\n+\t\t\t\t\tresult[0] = e;\n+\t\t\t\t} else {\n+\t\t\t\t\tresult[0] = new BootstrapMethodError(e);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable e) {\n+\t\t\tresult[0] = e;\n+\t\t}\n+\n+\t\treturn (Object)result;\n+/*[ELSE]*/\t\n+\t\tMethodHandle result = null;\n+\t\tMethodType type = null;\n+\n+/*[IF !Java11]*/\n+\t\ttry {\n+/*[ENDIF]*/\n+\t\t\tVMLangAccess access = VM.getVMLangAccess();\n+\t\t\tObject internalRamClass = access.createInternalRamClass(j9class);\n+\t\t\tClass<?> classObject = getClassFromJ9Class(j9class);\n+\t\t\t\n+\t\t\ttype = MethodType.vmResolveFromMethodDescriptorString(methodDescriptor, access.getClassloader(classObject), null);\n+\t\t\tfinal MethodHandles.Lookup lookup = new MethodHandles.Lookup(classObject, false);\n+\t\t\ttry {\n+\t\t\t\tlookup.accessCheckArgRetTypes(type);\n+\t\t\t} catch (IllegalAccessException e) {\n+\t\t\t\tIllegalAccessError err = new IllegalAccessError();\n+\t\t\t\terr.initCause(e);\n+\t\t\t\tthrow err;\n+\t\t\t}\n+\t\t\tint bsmIndex = UNSAFE.getShort(bsmData);\n+\t\t\tint bsmArgCount = UNSAFE.getShort(bsmData + BSM_ARGUMENT_COUNT_OFFSET);\n+\t\t\tlong bsmArgs = bsmData + BSM_ARGUMENTS_OFFSET;\n+\t\t\tMethodHandle bsm = getCPMethodHandleAt(internalRamClass, bsmIndex);\n+\t\t\tif (null == bsm) {\n+\t\t\t\t/*[MSG \"K05cd\", \"unable to resolve 'bootstrap_method_ref' in '{0}' at index {1}\"]*/\n+\t\t\t\tthrow new NullPointerException(Msg.getString(\"K05cd\", classObject.toString(), bsmIndex)); //$NON-NLS-1$\n+\t\t\t}\n+\t\t\tObject[] staticArgs = new Object[BSM_OPTIONAL_ARGUMENTS_START_INDEX + bsmArgCount];\n+\t\t\t/* Mandatory arguments */\n+\t\t\tstaticArgs[BSM_LOOKUP_ARGUMENT_INDEX] = lookup;\n+\t\t\tstaticArgs[BSM_NAME_ARGUMENT_INDEX] = name;\n+\t\t\tstaticArgs[BSM_TYPE_ARGUMENT_INDEX] = type;\n+\t\t\n+\t\t\t/* Static optional arguments */\n+\t\t\tint bsmTypeArgCount = bsm.type().parameterCount();\n+\t\t\tfor (int i = 0; i < bsmArgCount; i++) {\n+\t\t\t\tstaticArgs[BSM_OPTIONAL_ARGUMENTS_START_INDEX + i] = getAdditionalBsmArg(access, internalRamClass, classObject, bsm, bsmArgs, bsmTypeArgCount, i);\n+\t\t\t}\n+\n+/*[IF Java11]*/\n+\t\t/* JVMS JDK11 5.4.3.6 Dynamically-Computed Constant and Call Site Resolution\n+\t\t * requires that exceptions from BSM invocation be wrapped in a BootstrapMethodError\n+\t\t * unless the exception thrown is a sub-class of Error.\n+\t\t * Exceptions thrown before invocation should be passed through unwrapped.\n+\t\t */\n+\t\ttry {\n+/*[ENDIF]*/\n+\t\t\tCallSite cs = (CallSite)invokeBsm(bsm, staticArgs);\n+\t\t\tif (cs != null) {\n+\t\t\t\tMethodType callsiteType = cs.type();\n+\t\t\t\tif (callsiteType != type) {\n+\t\t\t\t\tthrow WrongMethodTypeException.newWrongMethodTypeException(type, callsiteType);\n+\t\t\t\t}\n+\t\t\t\tresult = cs.dynamicInvoker();\n+\t\t\t} \n+\t\t\t/*[IF Java11]*/\n+\t\t\telse {\n+\t\t\t\t/* The result of the resolution of a dynamically-computed call site must not be null. */\n+\t\t\t\t/*[MSG \"K0A02\", \"Bootstrap method returned null.\"]*/\n+\t\t\t\tthrow new ClassCastException(Msg.getString(\"K0A02\")); //$NON-NLS-1$\n+\t\t\t}\n+\t\t\t/*[ENDIF]*/\n+\t\t} catch(Throwable e) {\n+\n+\t\t\t/*[IF Sidecar19-SE]*/\n+\t\t\tif (e instanceof Error) {\n+\t\t\t\tthrow e;\n+\t\t\t}\n+\t\t\t/*[ENDIF]*/\n+\n+\t\t\tif (type == null) {\n+\t\t\t\tthrow new BootstrapMethodError(e);\n+\t\t\t}\n+\t\t\t\n+\t\t\t/* create an exceptionHandle with appropriate drop adapter and install that */\n+\t\t\ttry {\n+\t\t\t\tMethodHandle thrower = MethodHandles.throwException(type.returnType(), BootstrapMethodError.class);\n+\t\t\t\tMethodHandle constructor = MethodHandles.Lookup.IMPL_LOOKUP.findConstructor(BootstrapMethodError.class, MethodType.methodType(void.class, Throwable.class));\n+\t\t\t\tresult = MethodHandles.foldArguments(thrower, constructor.bindTo(e));\n+\t\t\t\tresult = MethodHandles.dropArguments(result, 0, type.parameterList()); \n+\t\t\t} catch (IllegalAccessException iae) {\n+\t\t\t\tthrow new Error(iae);\n+\t\t\t} catch (NoSuchMethodException nsme) {\n+\t\t\t\tthrow new Error(nsme);\n+\t\t\t}\n+\t\t}\n+\t\t\n+\t\treturn result;\n+/*[ENDIF] OPENJDK_METHODHANDLES*/\n+\t}\n+\n+\t@SuppressWarnings(\"unused\")\n+\t@VMCONSTANTPOOL_METHOD\n+\tprivate static final MethodHandle sendResolveMethodHandle(\n+\t\t\tint cpRefKind,\n+\t\t\tClass<?> currentClass,\n+\t\t\tClass<?> referenceClazz,\n+\t\t\tString name,\n+\t\t\tString typeDescriptor,\n+\t\t\tClassLoader loader) throws Throwable {\n+/*[IF OPENJDK_METHODHANDLES]*/\n+\t\ttry {\n+\t\t\tMethodHandles.Lookup lookup = new MethodHandles.Lookup(currentClass);\n+\t\t\tMethodType type = null;\n+\t\t\tMethodHandle result = null;\n+\n+\t\t\tswitch (cpRefKind) {\n+\t\t\tcase 1: /* getField */\n+\t\t\t\tresult = lookup.findGetter(referenceClazz, name, resolveFieldHandleHelper(typeDescriptor, lookup, loader));\n+\t\t\t\tbreak;\n+\t\t\tcase 2: /* getStatic */\n+\t\t\t\tresult = lookup.findStaticGetter(referenceClazz, name, resolveFieldHandleHelper(typeDescriptor, lookup, loader));\n+\t\t\t\tbreak;\n+\t\t\tcase 3: /* putField */\n+\t\t\t\tresult = lookup.findSetter(referenceClazz, name, resolveFieldHandleHelper(typeDescriptor, lookup, loader));\n+\t\t\t\tbreak;\n+\t\t\tcase 4: /* putStatic */\n+\t\t\t\tresult = lookup.findStaticSetter(referenceClazz, name, resolveFieldHandleHelper(typeDescriptor, lookup, loader));\n+\t\t\t\tbreak;\n+\t\t\tcase 5: /* invokeVirtual */\n+\t\t\t\ttype = MethodType.vmResolveFromMethodDescriptorString(typeDescriptor, loader, null);\n+\t\t\t\tresult = lookup.findVirtual(referenceClazz, name, type);\n+\t\t\t\tbreak;\n+\t\t\tcase 6: /* invokeStatic */\n+\t\t\t\ttype = MethodType.vmResolveFromMethodDescriptorString(typeDescriptor, loader, null);\n+\t\t\t\tresult = lookup.findStatic(referenceClazz, name, type);\n+\t\t\t\tbreak;\n+\t\t\tcase 7: /* invokeSpecial */ \n+\t\t\t\ttype = MethodType.vmResolveFromMethodDescriptorString(typeDescriptor, loader, null);\n+\t\t\t\tresult = lookup.findSpecial(referenceClazz, name, type, currentClass);\n+\t\t\t\tbreak;\n+\t\t\tcase 8: /* newInvokeSpecial */\n+\t\t\t\ttype = MethodType.vmResolveFromMethodDescriptorString(typeDescriptor, loader, null);\n+\t\t\t\tresult = lookup.findConstructor(referenceClazz, type);\n+\t\t\t\tbreak;\n+\t\t\tcase 9: /* invokeInterface */\n+\t\t\t\ttype = MethodType.vmResolveFromMethodDescriptorString(typeDescriptor, loader, null);\n+\t\t\t\tresult = lookup.findVirtual(referenceClazz, name, type);\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\t/* Can never happen */\n+\t\t\t\tthrow new UnsupportedOperationException();\n+\t\t\t}\n+\t\t\treturn result;\n+\t\t} catch (IllegalAccessException iae) {\n+\t\t\t// Java spec expects an IllegalAccessError instead of IllegalAccessException thrown when an application attempts \n+\t\t\t// (not reflectively) to access or modify a field, or to invoke a method that it doesn't have access to.\n+\t\t\tthrow new IllegalAccessError(iae.getMessage()).initCause(iae);\n+\t\t}\n+/*[ELSE]*/\n+\t\ttry {\n+\t\t\tMethodHandles.Lookup lookup = new MethodHandles.Lookup(currentClass, false);\n+\t\t\tMethodType type = null;\n+\t\t\tMethodHandle result = null;\n+\n+\t\t\tswitch (cpRefKind) {\n+\t\t\tcase 1: /* getField */\n+\t\t\t\tresult = lookup.findGetter(referenceClazz, name, resolveFieldHandleHelper(typeDescriptor, lookup, loader));\n+\t\t\t\tbreak;\n+\t\t\tcase 2: /* getStatic */\n+\t\t\t\tresult = lookup.findStaticGetter(referenceClazz, name, resolveFieldHandleHelper(typeDescriptor, lookup, loader));\n+\t\t\t\tbreak;\n+\t\t\tcase 3: /* putField */\n+\t\t\t\tresult = lookup.findSetter(referenceClazz, name, resolveFieldHandleHelper(typeDescriptor, lookup, loader));\n+\t\t\t\tbreak;\n+\t\t\tcase 4: /* putStatic */\n+\t\t\t\tresult = lookup.findStaticSetter(referenceClazz, name, resolveFieldHandleHelper(typeDescriptor, lookup, loader));\n+\t\t\t\tbreak;\n+\t\t\tcase 5: /* invokeVirtual */\n+\t\t\t\ttype = MethodType.vmResolveFromMethodDescriptorString(typeDescriptor, loader, null);\n+\t\t\t\tlookup.accessCheckArgRetTypes(type);\n+\t\t\t\tresult = lookup.findVirtual(referenceClazz, name, type);\n+\t\t\t\tbreak;\n+\t\t\tcase 6: /* invokeStatic */\n+\t\t\t\ttype = MethodType.vmResolveFromMethodDescriptorString(typeDescriptor, loader, null);\n+\t\t\t\tlookup.accessCheckArgRetTypes(type);\n+\t\t\t\tresult = lookup.findStatic(referenceClazz, name, type);\n+\t\t\t\tbreak;\n+\t\t\tcase 7: /* invokeSpecial */ \n+\t\t\t\ttype = MethodType.vmResolveFromMethodDescriptorString(typeDescriptor, loader, null);\n+\t\t\t\tlookup.accessCheckArgRetTypes(type);\n+\t\t\t\tresult = lookup.findSpecial(referenceClazz, name, type, currentClass);\n+\t\t\t\tbreak;\n+\t\t\tcase 8: /* newInvokeSpecial */\n+\t\t\t\ttype = MethodType.vmResolveFromMethodDescriptorString(typeDescriptor, loader, null);\n+\t\t\t\tlookup.accessCheckArgRetTypes(type);\n+\t\t\t\tresult = lookup.findConstructor(referenceClazz, type);\n+\t\t\t\tbreak;\n+\t\t\tcase 9: /* invokeInterface */\n+\t\t\t\ttype = MethodType.vmResolveFromMethodDescriptorString(typeDescriptor, loader, null);\n+\t\t\t\tlookup.accessCheckArgRetTypes(type);\n+\t\t\t\tresult = lookup.findVirtual(referenceClazz, name, type);\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\t/* Can never happen */\n+\t\t\t\tthrow new UnsupportedOperationException();\n+\t\t\t}\n+\t\t\treturn result;\n+\t\t} catch (IllegalAccessException iae) {\n+\t\t\t// Java spec expects an IllegalAccessError instead of IllegalAccessException thrown when an application attempts \n+\t\t\t// (not reflectively) to access or modify a field, or to invoke a method that it doesn't have access to.\n+\t\t\tthrow new IllegalAccessError(iae.getMessage()).initCause(iae);\n+\t\t}\n+/*[ENDIF] OPENJDK_METHODHANDLES*/\n+\t}\n+\t\n+\t/* Convert the field type descriptor into a MethodType so we can reuse the parsing logic in \n+\t * #fromMethodDescriptorString().  The verifier checks to ensure that the typeDescriptor is\n+\t * a valid field descriptor so adding the \"()V\" around it is valid.\n+\t */\n+\tprivate static final Class<?> resolveFieldHandleHelper(String typeDescriptor, Lookup lookup, ClassLoader loader) throws Throwable {\n+/*[IF OPENJDK_METHODHANDLES]*/\n+\t\tMethodType mt = MethodType.vmResolveFromMethodDescriptorString(\"(\" + typeDescriptor + \")V\", loader, null); //$NON-NLS-1$ //$NON-NLS-2$\n+\t\treturn mt.parameterType(0);\n+/*[ELSE]*/\n+\t\tMethodType mt = MethodType.vmResolveFromMethodDescriptorString(\"(\" + typeDescriptor + \")V\", loader, null); //$NON-NLS-1$ //$NON-NLS-2$\n+\t\tlookup.accessCheckArgRetTypes(mt);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "628621af13063ff19389e32968006a10049e2edc"}, "originalPosition": 530}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc2MzA5NQ==", "bodyText": "Why do we have both sendResolveMethodHandle code for OpenJDK MHs and a new resolveMethodHandle method?  Is there a relationship between them?  Should there be?", "url": "https://github.com/eclipse-openj9/openj9/pull/10830#discussion_r501763095", "createdAt": "2020-10-08T14:24:24Z", "author": {"login": "DanHeidinga"}, "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodHandleHelper.java", "diffHunk": "@@ -0,0 +1,699 @@\n+/*[INCLUDE-IF Sidecar18-SE]*/\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+package java.lang.invoke;\n+\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.util.ArrayList;\n+import java.util.Objects;\n+\n+import com.ibm.oti.util.Msg;\n+import com.ibm.oti.vm.VM;\n+import com.ibm.oti.vm.VMLangAccess;\n+\n+/*[IF Sidecar19-SE]\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.reflect.ConstantPool;\n+/*[ELSE]*/\n+import sun.misc.Unsafe;\n+import sun.reflect.ConstantPool;\n+/*[ENDIF]*/\n+\n+import com.ibm.jit.JITHelpers;\n+\n+/**\n+ * Static methods for the MethodHandle class.\n+ */\n+public final class MethodHandleHelper {\n+\tstatic final Unsafe UNSAFE = Unsafe.getUnsafe();\n+\n+\tstatic final JITHelpers JITHELPERS = JITHelpers.getHelpers();\n+\t\n+\tprivate static final int BSM_ARGUMENT_SIZE = Short.SIZE / Byte.SIZE;\n+\tprivate static final int BSM_ARGUMENT_COUNT_OFFSET = BSM_ARGUMENT_SIZE;\n+\tprivate static final int BSM_ARGUMENTS_OFFSET = BSM_ARGUMENT_SIZE * 2;\n+\tprivate static final int BSM_LOOKUP_ARGUMENT_INDEX = 0;\n+\tprivate static final int BSM_NAME_ARGUMENT_INDEX = 1;\n+\tprivate static final int BSM_TYPE_ARGUMENT_INDEX = 2;\n+\tprivate static final int BSM_OPTIONAL_ARGUMENTS_START_INDEX = 3;\n+\n+\t/*\n+\t * Return the result of J9_CP_TYPE(J9Class->romClass->cpShapeDescription, index)\n+\t */\n+\tprivate static final native int getCPTypeAt(Object internalRamClass, int index);\n+\n+\t/*\n+\t * sun.reflect.ConstantPool doesn't have a getMethodTypeAt method.  This is the \n+\t * equivalent for MethodType.\n+\t */\n+\tprivate static final native MethodType getCPMethodTypeAt(Object internalRamClass, int index);\n+\n+\t/*\n+\t * sun.reflect.ConstantPool doesn't have a getMethodHandleAt method.  This is the \n+\t * equivalent for MethodHandle.\n+\t */\n+\tprivate static final native MethodHandle getCPMethodHandleAt(Object internalRamClass, int index);\n+\n+\t\n+\t/**\n+\t * Get the class name from a constant pool class element, which is located\n+\t * at the specified <i>index</i> in <i>clazz</i>'s constant pool.\n+\t * \n+\t * @param   an instance of class - its constant pool is accessed\n+\t * @param   the constant pool index\n+\t * \n+\t * @return  instance of String which contains the class name or NULL in\n+\t *          case of error\n+\t * \n+\t * @throws  NullPointerException if <i>clazz</i> is null\n+\t * @throws  IllegalArgumentException if <i>index</i> has wrong constant pool type\n+\t */\n+\tprivate static final native String getCPClassNameAt(Class<?> clazz, int index);\n+\t\n+/*[IF Java11]*/\n+\t/*\n+\t * sun.reflect.ConstantPool doesn't have a getConstantDynamicAt method.  This is the \n+\t * equivalent for ConstantDynamic.\n+\t */\n+\tprivate static final native Object getCPConstantDynamicAt(Object internalRamClass, int index);\n+\n+\t@SuppressWarnings(\"unused\")\n+\tprivate static final Object resolveConstantDynamic(long j9class, String name, String fieldDescriptor, long bsmData) throws Throwable {\n+/*[IF OPENJDK_METHODHANDLES]*/\n+\t\tObject result = null;\n+\n+\t\tVMLangAccess access = VM.getVMLangAccess();\n+\t\tObject internalRamClass = access.createInternalRamClass(j9class);\n+\t\tClass<?> classObject = getClassFromJ9Class(j9class);\n+\n+\t\tClass<?> typeClass = fromFieldDescriptorString(fieldDescriptor, access.getClassloader(classObject));\n+\n+\t\tint bsmIndex = UNSAFE.getShort(bsmData);\n+\t\tint bsmArgCount = UNSAFE.getShort(bsmData + BSM_ARGUMENT_COUNT_OFFSET);\n+\t\tlong bsmArgs = bsmData + BSM_ARGUMENTS_OFFSET;\n+\t\tMethodHandle bsm = getCPMethodHandleAt(internalRamClass, bsmIndex);\n+\t\tif (null == bsm) {\n+\t\t\t/*[MSG \"K05cd\", \"unable to resolve 'bootstrap_method_ref' in '{0}' at index {1}\"]*/\n+\t\t\tthrow new NullPointerException(Msg.getString(\"K05cd\", classObject.toString(), bsmIndex)); //$NON-NLS-1$\n+\t\t}\n+\t\tObject[] staticArgs = new Object[bsmArgCount];\n+\n+\t\t/* Static optional arguments */\n+\t\tint bsmTypeArgCount = bsm.type().parameterCount();\n+\n+\t\t/* JVMS JDK11 5.4.3.6 Dynamically-Computed Constant and Call Site Resolution\n+\t\t * requires the first parameter of the bootstrap method to be java.lang.invoke.MethodHandles.Lookup\n+\t\t * else fail resolution with BootstrapMethodError\n+\t\t */\n+\t\tif (bsmTypeArgCount < 1 || MethodHandles.Lookup.class != bsm.type().parameterType(0)) {\n+\t\t\t/*[MSG \"K0A01\", \"Constant_Dynamic references bootstrap method '{0}' does not have java.lang.invoke.MethodHandles.Lookup as first parameter.\"]*/\n+\t\t\tthrow new BootstrapMethodError(Msg.getString(\"K0A01\", bsm)); //$NON-NLS-1$\n+\t\t}\n+\n+\t\tfor (int i = 0; i < bsmArgCount; i++) {\n+\t\t\tstaticArgs[i] = getAdditionalBsmArg(access, internalRamClass, classObject, bsm, bsmArgs, bsmTypeArgCount, i);\n+\t\t}\n+\n+\t\t/* JVMS JDK11 5.4.3.6 Dynamically-Computed Constant and Call Site Resolution\n+\t\t * requires that exceptions from BSM invocation be wrapped in a BootstrapMethodError\n+\t\t * unless the exception thrown is a sub-class of Error.\n+\t\t * Exceptions thrown before invocation should be passed through unwrapped.\n+\t\t */\n+\t\ttry {\n+\t\t\tresult = MethodHandleNatives.linkDynamicConstant(classObject, 0, bsm, name, typeClass, (Object)staticArgs);\n+\t\t\t/* result validation */\n+\t\t\tresult = MethodHandles.identity(typeClass).invoke(result);\n+\t\t} catch(Throwable e) {\n+\t\t\tif (e instanceof Error) {\n+\t\t\t\tthrow e;\n+\t\t\t} else {\n+\t\t\t\t/*[MSG \"K0A00\", \"Failed to resolve Constant Dynamic entry with j9class: {0}, name: {1}, descriptor: {2}, bsmData: {3}\"]*/\n+\t\t\t\tString msg = Msg.getString(\"K0A00\", new Object[] {String.valueOf(j9class), name, fieldDescriptor, String.valueOf(bsmData)}); //$NON-NLS-1$\n+\t\t\t\tthrow new BootstrapMethodError(msg, e);\n+\t\t\t}\n+\t\t}\n+\t\t\n+\t\treturn result;\n+/*[ELSE]*/\n+\t\tObject result = null;\n+\n+\t\tVMLangAccess access = VM.getVMLangAccess();\n+\t\tObject internalRamClass = access.createInternalRamClass(j9class);\n+\t\tClass<?> classObject = getClassFromJ9Class(j9class);\n+\n+\t\tClass<?> typeClass = fromFieldDescriptorString(fieldDescriptor, access.getClassloader(classObject));\n+\n+\t\tint bsmIndex = UNSAFE.getShort(bsmData);\n+\t\tint bsmArgCount = UNSAFE.getShort(bsmData + BSM_ARGUMENT_COUNT_OFFSET);\n+\t\tlong bsmArgs = bsmData + BSM_ARGUMENTS_OFFSET;\n+\t\tMethodHandle bsm = getCPMethodHandleAt(internalRamClass, bsmIndex);\n+\t\tif (null == bsm) {\n+\t\t\t/*[MSG \"K05cd\", \"unable to resolve 'bootstrap_method_ref' in '{0}' at index {1}\"]*/\n+\t\t\tthrow new NullPointerException(Msg.getString(\"K05cd\", classObject.toString(), bsmIndex)); //$NON-NLS-1$\n+\t\t}\n+\t\tObject[] staticArgs = new Object[BSM_OPTIONAL_ARGUMENTS_START_INDEX + bsmArgCount];\n+\t\t/* Mandatory arguments */\n+\t\tstaticArgs[BSM_LOOKUP_ARGUMENT_INDEX] = new MethodHandles.Lookup(classObject, false);\n+\t\tstaticArgs[BSM_NAME_ARGUMENT_INDEX] = name;\n+\t\tstaticArgs[BSM_TYPE_ARGUMENT_INDEX] = typeClass;\n+\n+\t\t/* Static optional arguments */\n+\t\tint bsmTypeArgCount = bsm.type().parameterCount();\n+\n+\t\t/* JVMS JDK11 5.4.3.6 Dynamically-Computed Constant and Call Site Resolution\n+\t\t * requires the first parameter of the bootstrap method to be java.lang.invoke.MethodHandles.Lookup\n+\t\t * else fail resolution with BootstrapMethodError\n+\t\t */\n+\t\tif (bsmTypeArgCount < 1 || MethodHandles.Lookup.class != bsm.type().parameterType(0)) {\n+\t\t\t/*[MSG \"K0A01\", \"Constant_Dynamic references bootstrap method '{0}' does not have java.lang.invoke.MethodHandles.Lookup as first parameter.\"]*/\n+\t\t\tthrow new BootstrapMethodError(Msg.getString(\"K0A01\", bsm.getMethodName())); //$NON-NLS-1$\n+\t\t}\n+\n+\t\tfor (int i = 0; i < bsmArgCount; i++) {\n+\t\t\tstaticArgs[BSM_OPTIONAL_ARGUMENTS_START_INDEX + i] = getAdditionalBsmArg(access, internalRamClass, classObject, bsm, bsmArgs, bsmTypeArgCount, i);\n+\t\t}\n+\n+\t\t/* JVMS JDK11 5.4.3.6 Dynamically-Computed Constant and Call Site Resolution\n+\t\t * requires that exceptions from BSM invocation be wrapped in a BootstrapMethodError\n+\t\t * unless the exception thrown is a sub-class of Error.\n+\t\t * Exceptions thrown before invocation should be passed through unwrapped.\n+\t\t */\n+\t\ttry {\n+\t\t\tresult = (Object)invokeBsm(bsm, staticArgs);\n+\t\t\t/* result validation */\n+\t\t\tresult = MethodHandles.identity(typeClass).invoke(result);\n+\t\t} catch(Throwable e) {\n+\t\t\tif (e instanceof Error) {\n+\t\t\t\tthrow e;\n+\t\t\t} else {\n+\t\t\t\t/*[MSG \"K0A00\", \"Failed to resolve Constant Dynamic entry with j9class: {0}, name: {1}, descriptor: {2}, bsmData: {3}\"]*/\n+\t\t\t\tString msg = Msg.getString(\"K0A00\", new Object[] {String.valueOf(j9class), name, fieldDescriptor, String.valueOf(bsmData)}); //$NON-NLS-1$\n+\t\t\t\tthrow new BootstrapMethodError(msg, e);\n+\t\t\t}\n+\t\t}\n+\t\t\n+\t\treturn result;\n+/*[ENDIF] OPENJDK_METHODHANDLES*/\n+\t}\n+/*[ENDIF] Java11*/\n+\n+\t/*[IF ]*/\n+\t/*\n+\t * Used to preserve the new objectRef on the stack when avoiding the call-in for\n+\t * constructorHandles.  Must return 'this' so stackmapper will keep the object\n+\t * alive.\n+\t */\n+\t/*[ENDIF]*/\n+\t@SuppressWarnings(\"unused\")\n+\t@VMCONSTANTPOOL_METHOD\n+\tprivate static Object constructorPlaceHolder(Object newObjectRef) {\n+\t\treturn newObjectRef;\n+\t}\n+\n+\t/**\n+\t * Invoke bootstrap method with its static arguments\n+\t * @param bsm\n+\t * @param staticArgs\n+\t * @return result of bsm invocation\n+\t * @throws Throwable any throwable will be handled by the caller\n+\t */\n+\tprivate static final Object invokeBsm(MethodHandle bsm, Object[] staticArgs) throws Throwable {\n+\t\tObject result = null;\n+\t\t/* Take advantage of the per-MH asType cache */\n+\t\tswitch(staticArgs.length) {\n+\t\tcase 3:\n+\t\t\tresult = bsm.invoke(staticArgs[0], staticArgs[1], staticArgs[2]);\n+\t\t\tbreak;\n+\t\tcase 4:\n+\t\t\tresult = bsm.invoke(staticArgs[0], staticArgs[1], staticArgs[2], staticArgs[3]);\n+\t\t\tbreak;\n+\t\tcase 5:\n+\t\t\tresult = bsm.invoke(staticArgs[0], staticArgs[1], staticArgs[2], staticArgs[3], staticArgs[4]);\n+\t\t\tbreak;\n+\t\tcase 6:\n+\t\t\tresult = bsm.invoke(staticArgs[0], staticArgs[1], staticArgs[2], staticArgs[3], staticArgs[4], staticArgs[5]);\n+\t\t\tbreak;\n+\t\tcase 7:\n+\t\t\tresult = bsm.invoke(staticArgs[0], staticArgs[1], staticArgs[2], staticArgs[3], staticArgs[4], staticArgs[5], staticArgs[6]);\n+\t\t\tbreak;\n+\t\tdefault:\n+\t\t\tresult = bsm.invokeWithArguments(staticArgs);\n+\t\t\tbreak;\n+\t\t}\n+\t\treturn result;\n+\t}\n+\t\n+\t@SuppressWarnings(\"unused\")\n+\tprivate static final Object resolveInvokeDynamic(long j9class, String name, String methodDescriptor, long bsmData) throws Throwable {\n+/*[IF OPENJDK_METHODHANDLES]*/\n+\t\tObject[] result = new Object[2];\n+\t\tMethodType type = null;\n+\n+\t\ttry {\n+\t\t\tVMLangAccess access = VM.getVMLangAccess();\n+\t\t\tObject internalRamClass = access.createInternalRamClass(j9class);\n+\t\t\tClass<?> classObject = getClassFromJ9Class(j9class);\n+\t\t\t\n+\t\t\ttype = MethodType.vmResolveFromMethodDescriptorString(methodDescriptor, access.getClassloader(classObject), null);\n+\n+\t\t\tint bsmIndex = UNSAFE.getShort(bsmData);\n+\t\t\tint bsmArgCount = UNSAFE.getShort(bsmData + BSM_ARGUMENT_COUNT_OFFSET);\n+\t\t\tlong bsmArgs = bsmData + BSM_ARGUMENTS_OFFSET;\n+\t\t\tMethodHandle bsm = getCPMethodHandleAt(internalRamClass, bsmIndex);\n+\t\t\tif (null == bsm) {\n+\t\t\t\t/*[MSG \"K05cd\", \"unable to resolve 'bootstrap_method_ref' in '{0}' at index {1}\"]*/\n+\t\t\t\tthrow new NullPointerException(Msg.getString(\"K05cd\", classObject.toString(), bsmIndex)); //$NON-NLS-1$\n+\t\t\t}\n+\t\t\tObject[] staticArgs = new Object[bsmArgCount];\n+\n+\t\t\t/* Static optional arguments */\n+\t\t\tint bsmTypeArgCount = bsm.type().parameterCount();\n+\t\t\tfor (int i = 0; i < bsmArgCount; i++) {\n+\t\t\t\tstaticArgs[i] = getAdditionalBsmArg(access, internalRamClass, classObject, bsm, bsmArgs, bsmTypeArgCount, i);\n+\t\t\t}\n+\n+\t\t\tObject[] appendixResult = new Object[1];\n+\t\t\tappendixResult[0] = null;\n+\t\t\ttry {\n+\t\t\t\tMemberName mname = MethodHandleNatives.linkCallSite(classObject, 0, bsm, name, type, (Object)staticArgs, appendixResult);\n+\n+\t\t\t\tresult[0] = mname;\n+\t\t\t\tresult[1] = appendixResult[0];\n+\t\t\t} catch (Throwable e) {\n+\t\t\t\tif (e instanceof Error) {\n+\t\t\t\t\tresult[0] = e;\n+\t\t\t\t} else {\n+\t\t\t\t\tresult[0] = new BootstrapMethodError(e);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable e) {\n+\t\t\tresult[0] = e;\n+\t\t}\n+\n+\t\treturn (Object)result;\n+/*[ELSE]*/\t\n+\t\tMethodHandle result = null;\n+\t\tMethodType type = null;\n+\n+/*[IF !Java11]*/\n+\t\ttry {\n+/*[ENDIF]*/\n+\t\t\tVMLangAccess access = VM.getVMLangAccess();\n+\t\t\tObject internalRamClass = access.createInternalRamClass(j9class);\n+\t\t\tClass<?> classObject = getClassFromJ9Class(j9class);\n+\t\t\t\n+\t\t\ttype = MethodType.vmResolveFromMethodDescriptorString(methodDescriptor, access.getClassloader(classObject), null);\n+\t\t\tfinal MethodHandles.Lookup lookup = new MethodHandles.Lookup(classObject, false);\n+\t\t\ttry {\n+\t\t\t\tlookup.accessCheckArgRetTypes(type);\n+\t\t\t} catch (IllegalAccessException e) {\n+\t\t\t\tIllegalAccessError err = new IllegalAccessError();\n+\t\t\t\terr.initCause(e);\n+\t\t\t\tthrow err;\n+\t\t\t}\n+\t\t\tint bsmIndex = UNSAFE.getShort(bsmData);\n+\t\t\tint bsmArgCount = UNSAFE.getShort(bsmData + BSM_ARGUMENT_COUNT_OFFSET);\n+\t\t\tlong bsmArgs = bsmData + BSM_ARGUMENTS_OFFSET;\n+\t\t\tMethodHandle bsm = getCPMethodHandleAt(internalRamClass, bsmIndex);\n+\t\t\tif (null == bsm) {\n+\t\t\t\t/*[MSG \"K05cd\", \"unable to resolve 'bootstrap_method_ref' in '{0}' at index {1}\"]*/\n+\t\t\t\tthrow new NullPointerException(Msg.getString(\"K05cd\", classObject.toString(), bsmIndex)); //$NON-NLS-1$\n+\t\t\t}\n+\t\t\tObject[] staticArgs = new Object[BSM_OPTIONAL_ARGUMENTS_START_INDEX + bsmArgCount];\n+\t\t\t/* Mandatory arguments */\n+\t\t\tstaticArgs[BSM_LOOKUP_ARGUMENT_INDEX] = lookup;\n+\t\t\tstaticArgs[BSM_NAME_ARGUMENT_INDEX] = name;\n+\t\t\tstaticArgs[BSM_TYPE_ARGUMENT_INDEX] = type;\n+\t\t\n+\t\t\t/* Static optional arguments */\n+\t\t\tint bsmTypeArgCount = bsm.type().parameterCount();\n+\t\t\tfor (int i = 0; i < bsmArgCount; i++) {\n+\t\t\t\tstaticArgs[BSM_OPTIONAL_ARGUMENTS_START_INDEX + i] = getAdditionalBsmArg(access, internalRamClass, classObject, bsm, bsmArgs, bsmTypeArgCount, i);\n+\t\t\t}\n+\n+/*[IF Java11]*/\n+\t\t/* JVMS JDK11 5.4.3.6 Dynamically-Computed Constant and Call Site Resolution\n+\t\t * requires that exceptions from BSM invocation be wrapped in a BootstrapMethodError\n+\t\t * unless the exception thrown is a sub-class of Error.\n+\t\t * Exceptions thrown before invocation should be passed through unwrapped.\n+\t\t */\n+\t\ttry {\n+/*[ENDIF]*/\n+\t\t\tCallSite cs = (CallSite)invokeBsm(bsm, staticArgs);\n+\t\t\tif (cs != null) {\n+\t\t\t\tMethodType callsiteType = cs.type();\n+\t\t\t\tif (callsiteType != type) {\n+\t\t\t\t\tthrow WrongMethodTypeException.newWrongMethodTypeException(type, callsiteType);\n+\t\t\t\t}\n+\t\t\t\tresult = cs.dynamicInvoker();\n+\t\t\t} \n+\t\t\t/*[IF Java11]*/\n+\t\t\telse {\n+\t\t\t\t/* The result of the resolution of a dynamically-computed call site must not be null. */\n+\t\t\t\t/*[MSG \"K0A02\", \"Bootstrap method returned null.\"]*/\n+\t\t\t\tthrow new ClassCastException(Msg.getString(\"K0A02\")); //$NON-NLS-1$\n+\t\t\t}\n+\t\t\t/*[ENDIF]*/\n+\t\t} catch(Throwable e) {\n+\n+\t\t\t/*[IF Sidecar19-SE]*/\n+\t\t\tif (e instanceof Error) {\n+\t\t\t\tthrow e;\n+\t\t\t}\n+\t\t\t/*[ENDIF]*/\n+\n+\t\t\tif (type == null) {\n+\t\t\t\tthrow new BootstrapMethodError(e);\n+\t\t\t}\n+\t\t\t\n+\t\t\t/* create an exceptionHandle with appropriate drop adapter and install that */\n+\t\t\ttry {\n+\t\t\t\tMethodHandle thrower = MethodHandles.throwException(type.returnType(), BootstrapMethodError.class);\n+\t\t\t\tMethodHandle constructor = MethodHandles.Lookup.IMPL_LOOKUP.findConstructor(BootstrapMethodError.class, MethodType.methodType(void.class, Throwable.class));\n+\t\t\t\tresult = MethodHandles.foldArguments(thrower, constructor.bindTo(e));\n+\t\t\t\tresult = MethodHandles.dropArguments(result, 0, type.parameterList()); \n+\t\t\t} catch (IllegalAccessException iae) {\n+\t\t\t\tthrow new Error(iae);\n+\t\t\t} catch (NoSuchMethodException nsme) {\n+\t\t\t\tthrow new Error(nsme);\n+\t\t\t}\n+\t\t}\n+\t\t\n+\t\treturn result;\n+/*[ENDIF] OPENJDK_METHODHANDLES*/\n+\t}\n+\n+\t@SuppressWarnings(\"unused\")\n+\t@VMCONSTANTPOOL_METHOD\n+\tprivate static final MethodHandle sendResolveMethodHandle(\n+\t\t\tint cpRefKind,\n+\t\t\tClass<?> currentClass,\n+\t\t\tClass<?> referenceClazz,\n+\t\t\tString name,\n+\t\t\tString typeDescriptor,\n+\t\t\tClassLoader loader) throws Throwable {\n+/*[IF OPENJDK_METHODHANDLES]*/", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "628621af13063ff19389e32968006a10049e2edc"}, "originalPosition": 414}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0ODQ4NzE2", "url": "https://github.com/eclipse-openj9/openj9/pull/10830#pullrequestreview-504848716", "createdAt": "2020-10-08T14:32:54Z", "commit": {"oid": "628621af13063ff19389e32968006a10049e2edc"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxNDozMjo1NFrOHehm7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxNDozMjo1NFrOHehm7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc2OTk2NA==", "bodyText": "If the only difference between the two cases - openj9 mh & openjdk mh - is this call, it's better to keep the 90% the same code the same and add preprocessor tags around this.\nIt also makes it clear that this is the piece that's different, and allows adding a comment to indicate the access checks haven't occurred here\nie:\n/*[IF OPENJDK_METHODHANDLES]*/\n/* TODO: Investigate if an equivalent for lookup.accessCheckArgRetTypes is\n * needed for OJDK MH. If needed, find an alternative for\n * lookup.accessCheckArgRetTypes.\n */\n/*[ELSE]*/\nlookup.accessCheckArgRetTypes(type);\n/*[ENDIF]*/", "url": "https://github.com/eclipse-openj9/openj9/pull/10830#discussion_r501769964", "createdAt": "2020-10-08T14:32:54Z", "author": {"login": "DanHeidinga"}, "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodHandleHelper.java", "diffHunk": "@@ -0,0 +1,699 @@\n+/*[INCLUDE-IF Sidecar18-SE]*/\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+package java.lang.invoke;\n+\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.util.ArrayList;\n+import java.util.Objects;\n+\n+import com.ibm.oti.util.Msg;\n+import com.ibm.oti.vm.VM;\n+import com.ibm.oti.vm.VMLangAccess;\n+\n+/*[IF Sidecar19-SE]\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.reflect.ConstantPool;\n+/*[ELSE]*/\n+import sun.misc.Unsafe;\n+import sun.reflect.ConstantPool;\n+/*[ENDIF]*/\n+\n+import com.ibm.jit.JITHelpers;\n+\n+/**\n+ * Static methods for the MethodHandle class.\n+ */\n+public final class MethodHandleHelper {\n+\tstatic final Unsafe UNSAFE = Unsafe.getUnsafe();\n+\n+\tstatic final JITHelpers JITHELPERS = JITHelpers.getHelpers();\n+\t\n+\tprivate static final int BSM_ARGUMENT_SIZE = Short.SIZE / Byte.SIZE;\n+\tprivate static final int BSM_ARGUMENT_COUNT_OFFSET = BSM_ARGUMENT_SIZE;\n+\tprivate static final int BSM_ARGUMENTS_OFFSET = BSM_ARGUMENT_SIZE * 2;\n+\tprivate static final int BSM_LOOKUP_ARGUMENT_INDEX = 0;\n+\tprivate static final int BSM_NAME_ARGUMENT_INDEX = 1;\n+\tprivate static final int BSM_TYPE_ARGUMENT_INDEX = 2;\n+\tprivate static final int BSM_OPTIONAL_ARGUMENTS_START_INDEX = 3;\n+\n+\t/*\n+\t * Return the result of J9_CP_TYPE(J9Class->romClass->cpShapeDescription, index)\n+\t */\n+\tprivate static final native int getCPTypeAt(Object internalRamClass, int index);\n+\n+\t/*\n+\t * sun.reflect.ConstantPool doesn't have a getMethodTypeAt method.  This is the \n+\t * equivalent for MethodType.\n+\t */\n+\tprivate static final native MethodType getCPMethodTypeAt(Object internalRamClass, int index);\n+\n+\t/*\n+\t * sun.reflect.ConstantPool doesn't have a getMethodHandleAt method.  This is the \n+\t * equivalent for MethodHandle.\n+\t */\n+\tprivate static final native MethodHandle getCPMethodHandleAt(Object internalRamClass, int index);\n+\n+\t\n+\t/**\n+\t * Get the class name from a constant pool class element, which is located\n+\t * at the specified <i>index</i> in <i>clazz</i>'s constant pool.\n+\t * \n+\t * @param   an instance of class - its constant pool is accessed\n+\t * @param   the constant pool index\n+\t * \n+\t * @return  instance of String which contains the class name or NULL in\n+\t *          case of error\n+\t * \n+\t * @throws  NullPointerException if <i>clazz</i> is null\n+\t * @throws  IllegalArgumentException if <i>index</i> has wrong constant pool type\n+\t */\n+\tprivate static final native String getCPClassNameAt(Class<?> clazz, int index);\n+\t\n+/*[IF Java11]*/\n+\t/*\n+\t * sun.reflect.ConstantPool doesn't have a getConstantDynamicAt method.  This is the \n+\t * equivalent for ConstantDynamic.\n+\t */\n+\tprivate static final native Object getCPConstantDynamicAt(Object internalRamClass, int index);\n+\n+\t@SuppressWarnings(\"unused\")\n+\tprivate static final Object resolveConstantDynamic(long j9class, String name, String fieldDescriptor, long bsmData) throws Throwable {\n+/*[IF OPENJDK_METHODHANDLES]*/\n+\t\tObject result = null;\n+\n+\t\tVMLangAccess access = VM.getVMLangAccess();\n+\t\tObject internalRamClass = access.createInternalRamClass(j9class);\n+\t\tClass<?> classObject = getClassFromJ9Class(j9class);\n+\n+\t\tClass<?> typeClass = fromFieldDescriptorString(fieldDescriptor, access.getClassloader(classObject));\n+\n+\t\tint bsmIndex = UNSAFE.getShort(bsmData);\n+\t\tint bsmArgCount = UNSAFE.getShort(bsmData + BSM_ARGUMENT_COUNT_OFFSET);\n+\t\tlong bsmArgs = bsmData + BSM_ARGUMENTS_OFFSET;\n+\t\tMethodHandle bsm = getCPMethodHandleAt(internalRamClass, bsmIndex);\n+\t\tif (null == bsm) {\n+\t\t\t/*[MSG \"K05cd\", \"unable to resolve 'bootstrap_method_ref' in '{0}' at index {1}\"]*/\n+\t\t\tthrow new NullPointerException(Msg.getString(\"K05cd\", classObject.toString(), bsmIndex)); //$NON-NLS-1$\n+\t\t}\n+\t\tObject[] staticArgs = new Object[bsmArgCount];\n+\n+\t\t/* Static optional arguments */\n+\t\tint bsmTypeArgCount = bsm.type().parameterCount();\n+\n+\t\t/* JVMS JDK11 5.4.3.6 Dynamically-Computed Constant and Call Site Resolution\n+\t\t * requires the first parameter of the bootstrap method to be java.lang.invoke.MethodHandles.Lookup\n+\t\t * else fail resolution with BootstrapMethodError\n+\t\t */\n+\t\tif (bsmTypeArgCount < 1 || MethodHandles.Lookup.class != bsm.type().parameterType(0)) {\n+\t\t\t/*[MSG \"K0A01\", \"Constant_Dynamic references bootstrap method '{0}' does not have java.lang.invoke.MethodHandles.Lookup as first parameter.\"]*/\n+\t\t\tthrow new BootstrapMethodError(Msg.getString(\"K0A01\", bsm)); //$NON-NLS-1$\n+\t\t}\n+\n+\t\tfor (int i = 0; i < bsmArgCount; i++) {\n+\t\t\tstaticArgs[i] = getAdditionalBsmArg(access, internalRamClass, classObject, bsm, bsmArgs, bsmTypeArgCount, i);\n+\t\t}\n+\n+\t\t/* JVMS JDK11 5.4.3.6 Dynamically-Computed Constant and Call Site Resolution\n+\t\t * requires that exceptions from BSM invocation be wrapped in a BootstrapMethodError\n+\t\t * unless the exception thrown is a sub-class of Error.\n+\t\t * Exceptions thrown before invocation should be passed through unwrapped.\n+\t\t */\n+\t\ttry {\n+\t\t\tresult = MethodHandleNatives.linkDynamicConstant(classObject, 0, bsm, name, typeClass, (Object)staticArgs);\n+\t\t\t/* result validation */\n+\t\t\tresult = MethodHandles.identity(typeClass).invoke(result);\n+\t\t} catch(Throwable e) {\n+\t\t\tif (e instanceof Error) {\n+\t\t\t\tthrow e;\n+\t\t\t} else {\n+\t\t\t\t/*[MSG \"K0A00\", \"Failed to resolve Constant Dynamic entry with j9class: {0}, name: {1}, descriptor: {2}, bsmData: {3}\"]*/\n+\t\t\t\tString msg = Msg.getString(\"K0A00\", new Object[] {String.valueOf(j9class), name, fieldDescriptor, String.valueOf(bsmData)}); //$NON-NLS-1$\n+\t\t\t\tthrow new BootstrapMethodError(msg, e);\n+\t\t\t}\n+\t\t}\n+\t\t\n+\t\treturn result;\n+/*[ELSE]*/\n+\t\tObject result = null;\n+\n+\t\tVMLangAccess access = VM.getVMLangAccess();\n+\t\tObject internalRamClass = access.createInternalRamClass(j9class);\n+\t\tClass<?> classObject = getClassFromJ9Class(j9class);\n+\n+\t\tClass<?> typeClass = fromFieldDescriptorString(fieldDescriptor, access.getClassloader(classObject));\n+\n+\t\tint bsmIndex = UNSAFE.getShort(bsmData);\n+\t\tint bsmArgCount = UNSAFE.getShort(bsmData + BSM_ARGUMENT_COUNT_OFFSET);\n+\t\tlong bsmArgs = bsmData + BSM_ARGUMENTS_OFFSET;\n+\t\tMethodHandle bsm = getCPMethodHandleAt(internalRamClass, bsmIndex);\n+\t\tif (null == bsm) {\n+\t\t\t/*[MSG \"K05cd\", \"unable to resolve 'bootstrap_method_ref' in '{0}' at index {1}\"]*/\n+\t\t\tthrow new NullPointerException(Msg.getString(\"K05cd\", classObject.toString(), bsmIndex)); //$NON-NLS-1$\n+\t\t}\n+\t\tObject[] staticArgs = new Object[BSM_OPTIONAL_ARGUMENTS_START_INDEX + bsmArgCount];\n+\t\t/* Mandatory arguments */\n+\t\tstaticArgs[BSM_LOOKUP_ARGUMENT_INDEX] = new MethodHandles.Lookup(classObject, false);\n+\t\tstaticArgs[BSM_NAME_ARGUMENT_INDEX] = name;\n+\t\tstaticArgs[BSM_TYPE_ARGUMENT_INDEX] = typeClass;\n+\n+\t\t/* Static optional arguments */\n+\t\tint bsmTypeArgCount = bsm.type().parameterCount();\n+\n+\t\t/* JVMS JDK11 5.4.3.6 Dynamically-Computed Constant and Call Site Resolution\n+\t\t * requires the first parameter of the bootstrap method to be java.lang.invoke.MethodHandles.Lookup\n+\t\t * else fail resolution with BootstrapMethodError\n+\t\t */\n+\t\tif (bsmTypeArgCount < 1 || MethodHandles.Lookup.class != bsm.type().parameterType(0)) {\n+\t\t\t/*[MSG \"K0A01\", \"Constant_Dynamic references bootstrap method '{0}' does not have java.lang.invoke.MethodHandles.Lookup as first parameter.\"]*/\n+\t\t\tthrow new BootstrapMethodError(Msg.getString(\"K0A01\", bsm.getMethodName())); //$NON-NLS-1$\n+\t\t}\n+\n+\t\tfor (int i = 0; i < bsmArgCount; i++) {\n+\t\t\tstaticArgs[BSM_OPTIONAL_ARGUMENTS_START_INDEX + i] = getAdditionalBsmArg(access, internalRamClass, classObject, bsm, bsmArgs, bsmTypeArgCount, i);\n+\t\t}\n+\n+\t\t/* JVMS JDK11 5.4.3.6 Dynamically-Computed Constant and Call Site Resolution\n+\t\t * requires that exceptions from BSM invocation be wrapped in a BootstrapMethodError\n+\t\t * unless the exception thrown is a sub-class of Error.\n+\t\t * Exceptions thrown before invocation should be passed through unwrapped.\n+\t\t */\n+\t\ttry {\n+\t\t\tresult = (Object)invokeBsm(bsm, staticArgs);\n+\t\t\t/* result validation */\n+\t\t\tresult = MethodHandles.identity(typeClass).invoke(result);\n+\t\t} catch(Throwable e) {\n+\t\t\tif (e instanceof Error) {\n+\t\t\t\tthrow e;\n+\t\t\t} else {\n+\t\t\t\t/*[MSG \"K0A00\", \"Failed to resolve Constant Dynamic entry with j9class: {0}, name: {1}, descriptor: {2}, bsmData: {3}\"]*/\n+\t\t\t\tString msg = Msg.getString(\"K0A00\", new Object[] {String.valueOf(j9class), name, fieldDescriptor, String.valueOf(bsmData)}); //$NON-NLS-1$\n+\t\t\t\tthrow new BootstrapMethodError(msg, e);\n+\t\t\t}\n+\t\t}\n+\t\t\n+\t\treturn result;\n+/*[ENDIF] OPENJDK_METHODHANDLES*/\n+\t}\n+/*[ENDIF] Java11*/\n+\n+\t/*[IF ]*/\n+\t/*\n+\t * Used to preserve the new objectRef on the stack when avoiding the call-in for\n+\t * constructorHandles.  Must return 'this' so stackmapper will keep the object\n+\t * alive.\n+\t */\n+\t/*[ENDIF]*/\n+\t@SuppressWarnings(\"unused\")\n+\t@VMCONSTANTPOOL_METHOD\n+\tprivate static Object constructorPlaceHolder(Object newObjectRef) {\n+\t\treturn newObjectRef;\n+\t}\n+\n+\t/**\n+\t * Invoke bootstrap method with its static arguments\n+\t * @param bsm\n+\t * @param staticArgs\n+\t * @return result of bsm invocation\n+\t * @throws Throwable any throwable will be handled by the caller\n+\t */\n+\tprivate static final Object invokeBsm(MethodHandle bsm, Object[] staticArgs) throws Throwable {\n+\t\tObject result = null;\n+\t\t/* Take advantage of the per-MH asType cache */\n+\t\tswitch(staticArgs.length) {\n+\t\tcase 3:\n+\t\t\tresult = bsm.invoke(staticArgs[0], staticArgs[1], staticArgs[2]);\n+\t\t\tbreak;\n+\t\tcase 4:\n+\t\t\tresult = bsm.invoke(staticArgs[0], staticArgs[1], staticArgs[2], staticArgs[3]);\n+\t\t\tbreak;\n+\t\tcase 5:\n+\t\t\tresult = bsm.invoke(staticArgs[0], staticArgs[1], staticArgs[2], staticArgs[3], staticArgs[4]);\n+\t\t\tbreak;\n+\t\tcase 6:\n+\t\t\tresult = bsm.invoke(staticArgs[0], staticArgs[1], staticArgs[2], staticArgs[3], staticArgs[4], staticArgs[5]);\n+\t\t\tbreak;\n+\t\tcase 7:\n+\t\t\tresult = bsm.invoke(staticArgs[0], staticArgs[1], staticArgs[2], staticArgs[3], staticArgs[4], staticArgs[5], staticArgs[6]);\n+\t\t\tbreak;\n+\t\tdefault:\n+\t\t\tresult = bsm.invokeWithArguments(staticArgs);\n+\t\t\tbreak;\n+\t\t}\n+\t\treturn result;\n+\t}\n+\t\n+\t@SuppressWarnings(\"unused\")\n+\tprivate static final Object resolveInvokeDynamic(long j9class, String name, String methodDescriptor, long bsmData) throws Throwable {\n+/*[IF OPENJDK_METHODHANDLES]*/\n+\t\tObject[] result = new Object[2];\n+\t\tMethodType type = null;\n+\n+\t\ttry {\n+\t\t\tVMLangAccess access = VM.getVMLangAccess();\n+\t\t\tObject internalRamClass = access.createInternalRamClass(j9class);\n+\t\t\tClass<?> classObject = getClassFromJ9Class(j9class);\n+\t\t\t\n+\t\t\ttype = MethodType.vmResolveFromMethodDescriptorString(methodDescriptor, access.getClassloader(classObject), null);\n+\n+\t\t\tint bsmIndex = UNSAFE.getShort(bsmData);\n+\t\t\tint bsmArgCount = UNSAFE.getShort(bsmData + BSM_ARGUMENT_COUNT_OFFSET);\n+\t\t\tlong bsmArgs = bsmData + BSM_ARGUMENTS_OFFSET;\n+\t\t\tMethodHandle bsm = getCPMethodHandleAt(internalRamClass, bsmIndex);\n+\t\t\tif (null == bsm) {\n+\t\t\t\t/*[MSG \"K05cd\", \"unable to resolve 'bootstrap_method_ref' in '{0}' at index {1}\"]*/\n+\t\t\t\tthrow new NullPointerException(Msg.getString(\"K05cd\", classObject.toString(), bsmIndex)); //$NON-NLS-1$\n+\t\t\t}\n+\t\t\tObject[] staticArgs = new Object[bsmArgCount];\n+\n+\t\t\t/* Static optional arguments */\n+\t\t\tint bsmTypeArgCount = bsm.type().parameterCount();\n+\t\t\tfor (int i = 0; i < bsmArgCount; i++) {\n+\t\t\t\tstaticArgs[i] = getAdditionalBsmArg(access, internalRamClass, classObject, bsm, bsmArgs, bsmTypeArgCount, i);\n+\t\t\t}\n+\n+\t\t\tObject[] appendixResult = new Object[1];\n+\t\t\tappendixResult[0] = null;\n+\t\t\ttry {\n+\t\t\t\tMemberName mname = MethodHandleNatives.linkCallSite(classObject, 0, bsm, name, type, (Object)staticArgs, appendixResult);\n+\n+\t\t\t\tresult[0] = mname;\n+\t\t\t\tresult[1] = appendixResult[0];\n+\t\t\t} catch (Throwable e) {\n+\t\t\t\tif (e instanceof Error) {\n+\t\t\t\t\tresult[0] = e;\n+\t\t\t\t} else {\n+\t\t\t\t\tresult[0] = new BootstrapMethodError(e);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable e) {\n+\t\t\tresult[0] = e;\n+\t\t}\n+\n+\t\treturn (Object)result;\n+/*[ELSE]*/\t\n+\t\tMethodHandle result = null;\n+\t\tMethodType type = null;\n+\n+/*[IF !Java11]*/\n+\t\ttry {\n+/*[ENDIF]*/\n+\t\t\tVMLangAccess access = VM.getVMLangAccess();\n+\t\t\tObject internalRamClass = access.createInternalRamClass(j9class);\n+\t\t\tClass<?> classObject = getClassFromJ9Class(j9class);\n+\t\t\t\n+\t\t\ttype = MethodType.vmResolveFromMethodDescriptorString(methodDescriptor, access.getClassloader(classObject), null);\n+\t\t\tfinal MethodHandles.Lookup lookup = new MethodHandles.Lookup(classObject, false);\n+\t\t\ttry {\n+\t\t\t\tlookup.accessCheckArgRetTypes(type);\n+\t\t\t} catch (IllegalAccessException e) {\n+\t\t\t\tIllegalAccessError err = new IllegalAccessError();\n+\t\t\t\terr.initCause(e);\n+\t\t\t\tthrow err;\n+\t\t\t}\n+\t\t\tint bsmIndex = UNSAFE.getShort(bsmData);\n+\t\t\tint bsmArgCount = UNSAFE.getShort(bsmData + BSM_ARGUMENT_COUNT_OFFSET);\n+\t\t\tlong bsmArgs = bsmData + BSM_ARGUMENTS_OFFSET;\n+\t\t\tMethodHandle bsm = getCPMethodHandleAt(internalRamClass, bsmIndex);\n+\t\t\tif (null == bsm) {\n+\t\t\t\t/*[MSG \"K05cd\", \"unable to resolve 'bootstrap_method_ref' in '{0}' at index {1}\"]*/\n+\t\t\t\tthrow new NullPointerException(Msg.getString(\"K05cd\", classObject.toString(), bsmIndex)); //$NON-NLS-1$\n+\t\t\t}\n+\t\t\tObject[] staticArgs = new Object[BSM_OPTIONAL_ARGUMENTS_START_INDEX + bsmArgCount];\n+\t\t\t/* Mandatory arguments */\n+\t\t\tstaticArgs[BSM_LOOKUP_ARGUMENT_INDEX] = lookup;\n+\t\t\tstaticArgs[BSM_NAME_ARGUMENT_INDEX] = name;\n+\t\t\tstaticArgs[BSM_TYPE_ARGUMENT_INDEX] = type;\n+\t\t\n+\t\t\t/* Static optional arguments */\n+\t\t\tint bsmTypeArgCount = bsm.type().parameterCount();\n+\t\t\tfor (int i = 0; i < bsmArgCount; i++) {\n+\t\t\t\tstaticArgs[BSM_OPTIONAL_ARGUMENTS_START_INDEX + i] = getAdditionalBsmArg(access, internalRamClass, classObject, bsm, bsmArgs, bsmTypeArgCount, i);\n+\t\t\t}\n+\n+/*[IF Java11]*/\n+\t\t/* JVMS JDK11 5.4.3.6 Dynamically-Computed Constant and Call Site Resolution\n+\t\t * requires that exceptions from BSM invocation be wrapped in a BootstrapMethodError\n+\t\t * unless the exception thrown is a sub-class of Error.\n+\t\t * Exceptions thrown before invocation should be passed through unwrapped.\n+\t\t */\n+\t\ttry {\n+/*[ENDIF]*/\n+\t\t\tCallSite cs = (CallSite)invokeBsm(bsm, staticArgs);\n+\t\t\tif (cs != null) {\n+\t\t\t\tMethodType callsiteType = cs.type();\n+\t\t\t\tif (callsiteType != type) {\n+\t\t\t\t\tthrow WrongMethodTypeException.newWrongMethodTypeException(type, callsiteType);\n+\t\t\t\t}\n+\t\t\t\tresult = cs.dynamicInvoker();\n+\t\t\t} \n+\t\t\t/*[IF Java11]*/\n+\t\t\telse {\n+\t\t\t\t/* The result of the resolution of a dynamically-computed call site must not be null. */\n+\t\t\t\t/*[MSG \"K0A02\", \"Bootstrap method returned null.\"]*/\n+\t\t\t\tthrow new ClassCastException(Msg.getString(\"K0A02\")); //$NON-NLS-1$\n+\t\t\t}\n+\t\t\t/*[ENDIF]*/\n+\t\t} catch(Throwable e) {\n+\n+\t\t\t/*[IF Sidecar19-SE]*/\n+\t\t\tif (e instanceof Error) {\n+\t\t\t\tthrow e;\n+\t\t\t}\n+\t\t\t/*[ENDIF]*/\n+\n+\t\t\tif (type == null) {\n+\t\t\t\tthrow new BootstrapMethodError(e);\n+\t\t\t}\n+\t\t\t\n+\t\t\t/* create an exceptionHandle with appropriate drop adapter and install that */\n+\t\t\ttry {\n+\t\t\t\tMethodHandle thrower = MethodHandles.throwException(type.returnType(), BootstrapMethodError.class);\n+\t\t\t\tMethodHandle constructor = MethodHandles.Lookup.IMPL_LOOKUP.findConstructor(BootstrapMethodError.class, MethodType.methodType(void.class, Throwable.class));\n+\t\t\t\tresult = MethodHandles.foldArguments(thrower, constructor.bindTo(e));\n+\t\t\t\tresult = MethodHandles.dropArguments(result, 0, type.parameterList()); \n+\t\t\t} catch (IllegalAccessException iae) {\n+\t\t\t\tthrow new Error(iae);\n+\t\t\t} catch (NoSuchMethodException nsme) {\n+\t\t\t\tthrow new Error(nsme);\n+\t\t\t}\n+\t\t}\n+\t\t\n+\t\treturn result;\n+/*[ENDIF] OPENJDK_METHODHANDLES*/\n+\t}\n+\n+\t@SuppressWarnings(\"unused\")\n+\t@VMCONSTANTPOOL_METHOD\n+\tprivate static final MethodHandle sendResolveMethodHandle(\n+\t\t\tint cpRefKind,\n+\t\t\tClass<?> currentClass,\n+\t\t\tClass<?> referenceClazz,\n+\t\t\tString name,\n+\t\t\tString typeDescriptor,\n+\t\t\tClassLoader loader) throws Throwable {\n+/*[IF OPENJDK_METHODHANDLES]*/\n+\t\ttry {\n+\t\t\tMethodHandles.Lookup lookup = new MethodHandles.Lookup(currentClass);\n+\t\t\tMethodType type = null;\n+\t\t\tMethodHandle result = null;\n+\n+\t\t\tswitch (cpRefKind) {\n+\t\t\tcase 1: /* getField */\n+\t\t\t\tresult = lookup.findGetter(referenceClazz, name, resolveFieldHandleHelper(typeDescriptor, lookup, loader));\n+\t\t\t\tbreak;\n+\t\t\tcase 2: /* getStatic */\n+\t\t\t\tresult = lookup.findStaticGetter(referenceClazz, name, resolveFieldHandleHelper(typeDescriptor, lookup, loader));\n+\t\t\t\tbreak;\n+\t\t\tcase 3: /* putField */\n+\t\t\t\tresult = lookup.findSetter(referenceClazz, name, resolveFieldHandleHelper(typeDescriptor, lookup, loader));\n+\t\t\t\tbreak;\n+\t\t\tcase 4: /* putStatic */\n+\t\t\t\tresult = lookup.findStaticSetter(referenceClazz, name, resolveFieldHandleHelper(typeDescriptor, lookup, loader));\n+\t\t\t\tbreak;\n+\t\t\tcase 5: /* invokeVirtual */\n+\t\t\t\ttype = MethodType.vmResolveFromMethodDescriptorString(typeDescriptor, loader, null);\n+\t\t\t\tresult = lookup.findVirtual(referenceClazz, name, type);\n+\t\t\t\tbreak;\n+\t\t\tcase 6: /* invokeStatic */\n+\t\t\t\ttype = MethodType.vmResolveFromMethodDescriptorString(typeDescriptor, loader, null);\n+\t\t\t\tresult = lookup.findStatic(referenceClazz, name, type);\n+\t\t\t\tbreak;\n+\t\t\tcase 7: /* invokeSpecial */ \n+\t\t\t\ttype = MethodType.vmResolveFromMethodDescriptorString(typeDescriptor, loader, null);\n+\t\t\t\tresult = lookup.findSpecial(referenceClazz, name, type, currentClass);\n+\t\t\t\tbreak;\n+\t\t\tcase 8: /* newInvokeSpecial */\n+\t\t\t\ttype = MethodType.vmResolveFromMethodDescriptorString(typeDescriptor, loader, null);\n+\t\t\t\tresult = lookup.findConstructor(referenceClazz, type);\n+\t\t\t\tbreak;\n+\t\t\tcase 9: /* invokeInterface */\n+\t\t\t\ttype = MethodType.vmResolveFromMethodDescriptorString(typeDescriptor, loader, null);\n+\t\t\t\tresult = lookup.findVirtual(referenceClazz, name, type);\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\t/* Can never happen */\n+\t\t\t\tthrow new UnsupportedOperationException();\n+\t\t\t}\n+\t\t\treturn result;\n+\t\t} catch (IllegalAccessException iae) {\n+\t\t\t// Java spec expects an IllegalAccessError instead of IllegalAccessException thrown when an application attempts \n+\t\t\t// (not reflectively) to access or modify a field, or to invoke a method that it doesn't have access to.\n+\t\t\tthrow new IllegalAccessError(iae.getMessage()).initCause(iae);\n+\t\t}\n+/*[ELSE]*/\n+\t\ttry {\n+\t\t\tMethodHandles.Lookup lookup = new MethodHandles.Lookup(currentClass, false);\n+\t\t\tMethodType type = null;\n+\t\t\tMethodHandle result = null;\n+\n+\t\t\tswitch (cpRefKind) {\n+\t\t\tcase 1: /* getField */\n+\t\t\t\tresult = lookup.findGetter(referenceClazz, name, resolveFieldHandleHelper(typeDescriptor, lookup, loader));\n+\t\t\t\tbreak;\n+\t\t\tcase 2: /* getStatic */\n+\t\t\t\tresult = lookup.findStaticGetter(referenceClazz, name, resolveFieldHandleHelper(typeDescriptor, lookup, loader));\n+\t\t\t\tbreak;\n+\t\t\tcase 3: /* putField */\n+\t\t\t\tresult = lookup.findSetter(referenceClazz, name, resolveFieldHandleHelper(typeDescriptor, lookup, loader));\n+\t\t\t\tbreak;\n+\t\t\tcase 4: /* putStatic */\n+\t\t\t\tresult = lookup.findStaticSetter(referenceClazz, name, resolveFieldHandleHelper(typeDescriptor, lookup, loader));\n+\t\t\t\tbreak;\n+\t\t\tcase 5: /* invokeVirtual */\n+\t\t\t\ttype = MethodType.vmResolveFromMethodDescriptorString(typeDescriptor, loader, null);\n+\t\t\t\tlookup.accessCheckArgRetTypes(type);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "628621af13063ff19389e32968006a10049e2edc"}, "originalPosition": 484}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0ODY4ODA4", "url": "https://github.com/eclipse-openj9/openj9/pull/10830#pullrequestreview-504868808", "createdAt": "2020-10-08T14:51:43Z", "commit": {"oid": "903a7cb3c4ca3cec1c5a9c3b187eed65bd932781"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxNDo1MTo0M1rOHeihZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxNDo1MTo0M1rOHeihZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc4NDkzNQ==", "bodyText": "Which PR has the code that does the invokedynamic?  I need to review that and this code at the same time to have any chance of telling if it's correct or not", "url": "https://github.com/eclipse-openj9/openj9/pull/10830#discussion_r501784935", "createdAt": "2020-10-08T14:51:43Z", "author": {"login": "DanHeidinga"}, "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodHandleHelper.java", "diffHunk": "@@ -206,7 +206,54 @@ private static final Object invokeBsm(MethodHandle bsm, Object[] staticArgs) thr\n \t}\n \t\n \t@SuppressWarnings(\"unused\")\n-\tprivate static final MethodHandle resolveInvokeDynamic(long j9class, String name, String methodDescriptor, long bsmData) throws Throwable {\n+\tprivate static final Object resolveInvokeDynamic(long j9class, String name, String methodDescriptor, long bsmData) throws Throwable {\n+/*[IF OPENJDK_METHODHANDLES]*/\n+\t\tObject[] result = new Object[2];\n+\t\tMethodType type = null;\n+\n+\t\ttry {\n+\t\t\tVMLangAccess access = VM.getVMLangAccess();\n+\t\t\tObject internalRamClass = access.createInternalRamClass(j9class);\n+\t\t\tClass<?> classObject = getClassFromJ9Class(j9class);\n+\t\t\t\n+\t\t\ttype = MethodType.vmResolveFromMethodDescriptorString(methodDescriptor, access.getClassloader(classObject), null);\n+\n+\t\t\tint bsmIndex = UNSAFE.getShort(bsmData);\n+\t\t\tint bsmArgCount = UNSAFE.getShort(bsmData + BSM_ARGUMENT_COUNT_OFFSET);\n+\t\t\tlong bsmArgs = bsmData + BSM_ARGUMENTS_OFFSET;\n+\t\t\tMethodHandle bsm = getCPMethodHandleAt(internalRamClass, bsmIndex);\n+\t\t\tif (null == bsm) {\n+\t\t\t\t/*[MSG \"K05cd\", \"unable to resolve 'bootstrap_method_ref' in '{0}' at index {1}\"]*/\n+\t\t\t\tthrow new NullPointerException(Msg.getString(\"K05cd\", classObject.toString(), bsmIndex)); //$NON-NLS-1$\n+\t\t\t}\n+\t\t\tObject[] staticArgs = new Object[bsmArgCount];\n+\n+\t\t\t/* Static optional arguments */\n+\t\t\tint bsmTypeArgCount = bsm.type().parameterCount();\n+\t\t\tfor (int i = 0; i < bsmArgCount; i++) {\n+\t\t\t\tstaticArgs[i] = getAdditionalBsmArg(access, internalRamClass, classObject, bsm, bsmArgs, bsmTypeArgCount, i);\n+\t\t\t}\n+\n+\t\t\tObject[] appendixResult = new Object[1];\n+\t\t\tappendixResult[0] = null;\n+\t\t\ttry {\n+\t\t\t\tMemberName mname = MethodHandleNatives.linkCallSite(classObject, 0, bsm, name, type, (Object)staticArgs, appendixResult);\n+\n+\t\t\t\tresult[0] = mname;\n+\t\t\t\tresult[1] = appendixResult[0];\n+\t\t\t} catch (Throwable e) {\n+\t\t\t\tif (e instanceof Error) {\n+\t\t\t\t\tresult[0] = e;\n+\t\t\t\t} else {\n+\t\t\t\t\tresult[0] = new BootstrapMethodError(e);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable e) {\n+\t\t\tresult[0] = e;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "903a7cb3c4ca3cec1c5a9c3b187eed65bd932781"}, "originalPosition": 48}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0ODcxNjM5", "url": "https://github.com/eclipse-openj9/openj9/pull/10830#pullrequestreview-504871639", "createdAt": "2020-10-08T14:54:28Z", "commit": {"oid": "89c5941d8f83c487c8edff2edc4277fb9a5ae718"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxNDo1NDoyOFrOHeipnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxNDo1NDoyOFrOHeipnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc4NzAzNg==", "bodyText": "Is the only difference between the old and new paths that the new path calls linkDynamicConstant and the old calls result = (Object)invokeBsm(bsm, staticArgs);?  If so, please keep the 90% the same code the same and only preprocess to chose the correct call here", "url": "https://github.com/eclipse-openj9/openj9/pull/10830#discussion_r501787036", "createdAt": "2020-10-08T14:54:28Z", "author": {"login": "DanHeidinga"}, "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodHandleHelper.java", "diffHunk": "@@ -98,6 +98,62 @@\n \n \t@SuppressWarnings(\"unused\")\n \tprivate static final Object resolveConstantDynamic(long j9class, String name, String fieldDescriptor, long bsmData) throws Throwable {\n+/*[IF OPENJDK_METHODHANDLES]*/\n+\t\tObject result = null;\n+\n+\t\tVMLangAccess access = VM.getVMLangAccess();\n+\t\tObject internalRamClass = access.createInternalRamClass(j9class);\n+\t\tClass<?> classObject = getClassFromJ9Class(j9class);\n+\n+\t\tClass<?> typeClass = fromFieldDescriptorString(fieldDescriptor, access.getClassloader(classObject));\n+\n+\t\tint bsmIndex = UNSAFE.getShort(bsmData);\n+\t\tint bsmArgCount = UNSAFE.getShort(bsmData + BSM_ARGUMENT_COUNT_OFFSET);\n+\t\tlong bsmArgs = bsmData + BSM_ARGUMENTS_OFFSET;\n+\t\tMethodHandle bsm = getCPMethodHandleAt(internalRamClass, bsmIndex);\n+\t\tif (null == bsm) {\n+\t\t\t/*[MSG \"K05cd\", \"unable to resolve 'bootstrap_method_ref' in '{0}' at index {1}\"]*/\n+\t\t\tthrow new NullPointerException(Msg.getString(\"K05cd\", classObject.toString(), bsmIndex)); //$NON-NLS-1$\n+\t\t}\n+\t\tObject[] staticArgs = new Object[bsmArgCount];\n+\n+\t\t/* Static optional arguments */\n+\t\tint bsmTypeArgCount = bsm.type().parameterCount();\n+\n+\t\t/* JVMS JDK11 5.4.3.6 Dynamically-Computed Constant and Call Site Resolution\n+\t\t * requires the first parameter of the bootstrap method to be java.lang.invoke.MethodHandles.Lookup\n+\t\t * else fail resolution with BootstrapMethodError\n+\t\t */\n+\t\tif (bsmTypeArgCount < 1 || MethodHandles.Lookup.class != bsm.type().parameterType(0)) {\n+\t\t\t/*[MSG \"K0A01\", \"Constant_Dynamic references bootstrap method '{0}' does not have java.lang.invoke.MethodHandles.Lookup as first parameter.\"]*/\n+\t\t\tthrow new BootstrapMethodError(Msg.getString(\"K0A01\", bsm)); //$NON-NLS-1$\n+\t\t}\n+\n+\t\tfor (int i = 0; i < bsmArgCount; i++) {\n+\t\t\tstaticArgs[i] = getAdditionalBsmArg(access, internalRamClass, classObject, bsm, bsmArgs, bsmTypeArgCount, i);\n+\t\t}\n+\n+\t\t/* JVMS JDK11 5.4.3.6 Dynamically-Computed Constant and Call Site Resolution\n+\t\t * requires that exceptions from BSM invocation be wrapped in a BootstrapMethodError\n+\t\t * unless the exception thrown is a sub-class of Error.\n+\t\t * Exceptions thrown before invocation should be passed through unwrapped.\n+\t\t */\n+\t\ttry {\n+\t\t\tresult = MethodHandleNatives.linkDynamicConstant(classObject, 0, bsm, name, typeClass, (Object)staticArgs);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89c5941d8f83c487c8edff2edc4277fb9a5ae718"}, "originalPosition": 45}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "628621af13063ff19389e32968006a10049e2edc", "author": {"user": {"login": "babsingh", "name": "Babneet Singh"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/628621af13063ff19389e32968006a10049e2edc", "committedDate": "2020-10-07T22:33:14Z", "message": "Add the implementation for resolveMethodHandle\n\nIt's a wrapper for MethodHandleNatives.linkMethod. It is used in\ninvokehandle for MH.invoke and MH.invokeExact. The resolution yields two\nvalues. One is returned and the other value is stored in an one element\narray named, appendixResult. The value returned is a MemberName object,\nwhich specifies the caller method to be invoked. The value stored in\nappendixResult is a MethodType object in case the defining class is a\nMethodHandle and an AccessDescriptor object in case the defining class\nis a VarHandle.\n\nresolveMethodHandle is only needed for OJDK MH.\n\nCo-authored-by: Jack Lu <Jack.S.Lu@ibm.com>\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>"}, "afterCommit": {"oid": "9bc3a7e58c4694499420deb5d74bc3d12e992fa7", "author": {"user": {"login": "babsingh", "name": "Babneet Singh"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/9bc3a7e58c4694499420deb5d74bc3d12e992fa7", "committedDate": "2020-10-13T20:23:24Z", "message": "Disabling invokeBsm for OJDK MH\n\ninvokeBsm is unused for OpenJDK MethodHandles.\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA3ODA2MjA5", "url": "https://github.com/eclipse-openj9/openj9/pull/10830#pullrequestreview-507806209", "createdAt": "2020-10-13T20:31:58Z", "commit": {"oid": "9bc3a7e58c4694499420deb5d74bc3d12e992fa7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QyMDozMTo1OFrOHg4aqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QyMDozMTo1OFrOHg4aqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDI0MDgxMQ==", "bodyText": "What is the difference in output between the bsm's toString() and bsm.getMethodName()?", "url": "https://github.com/eclipse-openj9/openj9/pull/10830#discussion_r504240811", "createdAt": "2020-10-13T20:31:58Z", "author": {"login": "DanHeidinga"}, "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodHandleResolver.java", "diffHunk": "@@ -129,21 +125,41 @@ private static final Object resolveConstantDynamic(long j9class, String name, St\n \t\t */\n \t\tif (bsmTypeArgCount < 1 || MethodHandles.Lookup.class != bsm.type().parameterType(0)) {\n \t\t\t/*[MSG \"K0A01\", \"Constant_Dynamic references bootstrap method '{0}' does not have java.lang.invoke.MethodHandles.Lookup as first parameter.\"]*/\n+/*[IF OPENJDK_METHODHANDLES]*/\n+\t\t\tthrow new BootstrapMethodError(Msg.getString(\"K0A01\", bsm)); //$NON-NLS-1$\n+/*[ELSE] OPENJDK_METHODHANDLES*/\n \t\t\tthrow new BootstrapMethodError(Msg.getString(\"K0A01\", bsm.getMethodName())); //$NON-NLS-1$", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9bc3a7e58c4694499420deb5d74bc3d12e992fa7"}, "originalPosition": 25}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9bc3a7e58c4694499420deb5d74bc3d12e992fa7", "author": {"user": {"login": "babsingh", "name": "Babneet Singh"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/9bc3a7e58c4694499420deb5d74bc3d12e992fa7", "committedDate": "2020-10-13T20:23:24Z", "message": "Disabling invokeBsm for OJDK MH\n\ninvokeBsm is unused for OpenJDK MethodHandles.\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>"}, "afterCommit": {"oid": "0684d74d066d85e8bada0b5c386d4094d0eaf8fc", "author": {"user": {"login": "babsingh", "name": "Babneet Singh"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/0684d74d066d85e8bada0b5c386d4094d0eaf8fc", "committedDate": "2020-10-13T20:34:58Z", "message": "Disable invokeBsm for OJDK MH\n\ninvokeBsm is unused for OpenJDK MethodHandles.\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA3ODA4MzQ0", "url": "https://github.com/eclipse-openj9/openj9/pull/10830#pullrequestreview-507808344", "createdAt": "2020-10-13T20:35:24Z", "commit": {"oid": "9bc3a7e58c4694499420deb5d74bc3d12e992fa7"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QyMDozNjozMFrOHg4j5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QyMDozNzoxNVrOHg4liA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDI0MzE3Mw==", "bodyText": "The false indicates the Lookup object should skip the package check.  How does the equivalent behaviour get exposed in the OJDK Lookups?", "url": "https://github.com/eclipse-openj9/openj9/pull/10830#discussion_r504243173", "createdAt": "2020-10-13T20:36:30Z", "author": {"login": "DanHeidinga"}, "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodHandleResolver.java", "diffHunk": "@@ -307,7 +373,14 @@ private static final MethodHandle sendResolveMethodHandle(\n \t\t\tString typeDescriptor,\n \t\t\tClassLoader loader) throws Throwable {\n \t\ttry {\n+/*[IF OPENJDK_METHODHANDLES]*/\n+\t\t\t/* OpenJDK Lookup does not have a constructor Lookup(Class<?>, boolean). So, it has been replaced\n+\t\t\t * with Lookup(Class<?>). */\n+\t\t\tMethodHandles.Lookup lookup = new MethodHandles.Lookup(currentClass);\n+/*[ELSE] OPENJDK_METHODHANDLES*/\n \t\t\tMethodHandles.Lookup lookup = new MethodHandles.Lookup(currentClass, false);\n+/*[ENDIF] OPENJDK_METHODHANDLES*/", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0684d74d066d85e8bada0b5c386d4094d0eaf8fc"}, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDI0MzU5Mg==", "bodyText": "please javadoc this function", "url": "https://github.com/eclipse-openj9/openj9/pull/10830#discussion_r504243592", "createdAt": "2020-10-13T20:37:15Z", "author": {"login": "DanHeidinga"}, "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodHandleResolver.java", "diffHunk": "@@ -525,4 +622,25 @@ static long getJ9ClassFromClass(Class<?> c) {\n \t\t\treturn JITHELPERS.getJ9ClassFromClass64(c);\n \t\t}\n \t}\n+\n+\t@SuppressWarnings(\"unused\")\n+\tprivate static final Object linkCallerMethod(Class<?> callerClass, int refKind, Class<?> defc, String name, String type) throws Throwable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0684d74d066d85e8bada0b5c386d4094d0eaf8fc"}, "originalPosition": 217}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0684d74d066d85e8bada0b5c386d4094d0eaf8fc", "author": {"user": {"login": "babsingh", "name": "Babneet Singh"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/0684d74d066d85e8bada0b5c386d4094d0eaf8fc", "committedDate": "2020-10-13T20:34:58Z", "message": "Disable invokeBsm for OJDK MH\n\ninvokeBsm is unused for OpenJDK MethodHandles.\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>"}, "afterCommit": {"oid": "4c3ef5f82c4a32f94a443ec8b9c20d5d602c1ff4", "author": {"user": {"login": "babsingh", "name": "Babneet Singh"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/4c3ef5f82c4a32f94a443ec8b9c20d5d602c1ff4", "committedDate": "2020-10-13T20:40:46Z", "message": "Disable invokeBsm for OJDK MH\n\ninvokeBsm is unused for OpenJDK MethodHandles.\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4c3ef5f82c4a32f94a443ec8b9c20d5d602c1ff4", "author": {"user": {"login": "babsingh", "name": "Babneet Singh"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/4c3ef5f82c4a32f94a443ec8b9c20d5d602c1ff4", "committedDate": "2020-10-13T20:40:46Z", "message": "Disable invokeBsm for OJDK MH\n\ninvokeBsm is unused for OpenJDK MethodHandles.\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>"}, "afterCommit": {"oid": "6d9aeb17944dc352db929d3543198ace345a2db7", "author": {"user": {"login": "babsingh", "name": "Babneet Singh"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/6d9aeb17944dc352db929d3543198ace345a2db7", "committedDate": "2020-10-13T20:43:32Z", "message": "Disable invokeBsm for OJDK MH\n\ninvokeBsm is unused for OpenJDK MethodHandles.\n\nCo-authored-by: Jack Lu <Jack.S.Lu@ibm.com>\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6d9aeb17944dc352db929d3543198ace345a2db7", "author": {"user": {"login": "babsingh", "name": "Babneet Singh"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/6d9aeb17944dc352db929d3543198ace345a2db7", "committedDate": "2020-10-13T20:43:32Z", "message": "Disable invokeBsm for OJDK MH\n\ninvokeBsm is unused for OpenJDK MethodHandles.\n\nCo-authored-by: Jack Lu <Jack.S.Lu@ibm.com>\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>"}, "afterCommit": {"oid": "2534b206ab18a2809b3cbe65414b762a975dce39", "author": {"user": {"login": "babsingh", "name": "Babneet Singh"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/2534b206ab18a2809b3cbe65414b762a975dce39", "committedDate": "2020-10-15T16:09:04Z", "message": "Disable invokeBsm for OJDK MH\n\ninvokeBsm is unused for OpenJDK MethodHandles.\n\nCo-authored-by: Jack Lu <Jack.S.Lu@ibm.com>\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwMDk1MDEz", "url": "https://github.com/eclipse-openj9/openj9/pull/10830#pullrequestreview-510095013", "createdAt": "2020-10-16T05:12:59Z", "commit": {"oid": "2534b206ab18a2809b3cbe65414b762a975dce39"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQwNToxMjo1OVrOHinMfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQwNToxMjo1OVrOHinMfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjA1NTgwNw==", "bodyText": "This is an error path that is very very unlikely to happen in production.  Use the common code sequence for both OJ9 & OJDK implementations\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            /*[IF OPENJDK_METHODHANDLES]*/\n          \n          \n            \n            \t\t\tthrow new BootstrapMethodError(Msg.getString(\"K0A01\", Lookup.IMPL_LOOKUP.revealDirect(bsm).getName())); //$NON-NLS-1$\n          \n          \n            \n            /*[ELSE] OPENJDK_METHODHANDLES*/\n          \n          \n            \n            \t\t\tthrow new BootstrapMethodError(Msg.getString(\"K0A01\", bsm.getMethodName())); //$NON-NLS-1$\n          \n          \n            \n            /*[ENDIF] OPENJDK_METHODHANDLES*/\n          \n          \n            \n            \t\t\tthrow new BootstrapMethodError(Msg.getString(\"K0A01\", Lookup.IMPL_LOOKUP.revealDirect(bsm).getName())); //$NON-NLS-1$", "url": "https://github.com/eclipse-openj9/openj9/pull/10830#discussion_r506055807", "createdAt": "2020-10-16T05:12:59Z", "author": {"login": "DanHeidinga"}, "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodHandleResolver.java", "diffHunk": "@@ -129,21 +125,41 @@ private static final Object resolveConstantDynamic(long j9class, String name, St\n \t\t */\n \t\tif (bsmTypeArgCount < 1 || MethodHandles.Lookup.class != bsm.type().parameterType(0)) {\n \t\t\t/*[MSG \"K0A01\", \"Constant_Dynamic references bootstrap method '{0}' does not have java.lang.invoke.MethodHandles.Lookup as first parameter.\"]*/\n+/*[IF OPENJDK_METHODHANDLES]*/\n+\t\t\tthrow new BootstrapMethodError(Msg.getString(\"K0A01\", Lookup.IMPL_LOOKUP.revealDirect(bsm).getName())); //$NON-NLS-1$\n+/*[ELSE] OPENJDK_METHODHANDLES*/\n \t\t\tthrow new BootstrapMethodError(Msg.getString(\"K0A01\", bsm.getMethodName())); //$NON-NLS-1$\n+/*[ENDIF] OPENJDK_METHODHANDLES*/", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2534b206ab18a2809b3cbe65414b762a975dce39"}, "originalPosition": 26}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwMTI2MzQ2", "url": "https://github.com/eclipse-openj9/openj9/pull/10830#pullrequestreview-510126346", "createdAt": "2020-10-16T05:34:16Z", "commit": {"oid": "2534b206ab18a2809b3cbe65414b762a975dce39"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQwNTozNDoxNlrOHinjUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQwNTozNDoxNlrOHinjUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjA2MTY1MQ==", "bodyText": "Does this throw IllegalAccessException or IllegalAccessError for MHs that fail access checking?  The spec expects the Error version but at least with the OJ9 handles, we java code threw the Exception and we had to convert to the Error", "url": "https://github.com/eclipse-openj9/openj9/pull/10830#discussion_r506061651", "createdAt": "2020-10-16T05:34:16Z", "author": {"login": "DanHeidinga"}, "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodHandleResolver.java", "diffHunk": "@@ -525,4 +623,46 @@ static long getJ9ClassFromClass(Class<?> c) {\n \t\t\treturn JITHELPERS.getJ9ClassFromClass64(c);\n \t\t}\n \t}\n+\n+\t/**\n+\t * Used during the invokehandle bytecode for resolving calls to the polymorphic\n+\t * MethodHandle and VarHandle methods. The resolution yields two values, which\n+\t * are returned in a two element array. The first array element is a MemberName\n+\t * object, which specifies the caller method to be invoked. The second array\n+\t * element is a MethodType object if the defining class is a MethodHandle and\n+\t * an AccessDescriptor object if the defining class is a VarHandle.\n+\t *\n+\t * This is only used for the OpenJDK MethodHandles, and an InternalError will\n+\t * be thrown if it is used for the OpenJ9 MethodHandles.\n+\t *\n+\t * @param callerClass the caller class\n+\t * @param refKind the reference kind used by the CONSTANT_MethodHandle entries\n+\t * @param definingClass the defining class\n+\t * @param name contains the method name\n+\t * @param type contains the method description\n+\t *\n+\t * @return a two element array, which contains the resolved values\n+\t *\n+\t * @throws InternalError if invoked for the OpenJ9 MethodHandles\n+\t */\n+\t@SuppressWarnings(\"unused\")\n+\tprivate static final Object linkCallerMethod(Class<?> callerClass, int refKind, Class<?> definingClass, String name, String type) throws Throwable {\n+/*[IF OPENJDK_METHODHANDLES]*/\n+\t\tVMLangAccess access = VM.getVMLangAccess();\n+\t\tMethodType mt = MethodType.fromMethodDescriptorString(type, access.getClassloader(callerClass));\n+\n+\t\tObject[] result = new Object[2];\n+\t\tObject[] appendixResult = new Object[1];\n+\n+\t\t/* result[0] contains the MemberName object, which specifies the caller method (generated bytecodes). */\n+\t\tresult[0] = MethodHandleNatives.linkMethod(callerClass, refKind, definingClass, name, mt, appendixResult);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2534b206ab18a2809b3cbe65414b762a975dce39"}, "originalPosition": 248}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwMTI4MzQ1", "url": "https://github.com/eclipse-openj9/openj9/pull/10830#pullrequestreview-510128345", "createdAt": "2020-10-16T05:35:41Z", "commit": {"oid": "2534b206ab18a2809b3cbe65414b762a975dce39"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQwNTozNTo0MVrOHinlDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQwNTozNTo0MVrOHinlDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjA2MjA5NQ==", "bodyText": "Thanks for updating this comment - it's much clearer.  Is there an issue to track addressing this?", "url": "https://github.com/eclipse-openj9/openj9/pull/10830#discussion_r506062095", "createdAt": "2020-10-16T05:35:41Z", "author": {"login": "DanHeidinga"}, "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodHandleResolver.java", "diffHunk": "@@ -326,27 +400,47 @@ private static final MethodHandle sendResolveMethodHandle(\n \t\t\t\tbreak;\n \t\t\tcase 5: /* invokeVirtual */\n \t\t\t\ttype = MethodTypeHelper.vmResolveFromMethodDescriptorString(typeDescriptor, loader, null);\n+/*[IF OPENJDK_METHODHANDLES]*/\n+\t\t\t\t/* TODO: Investigate if an equivalent for lookup.accessCheckArgRetTypes is needed for OpenJDK MH. */\n+/*[ELSE] OPENJDK_METHODHANDLES*/\n \t\t\t\tlookup.accessCheckArgRetTypes(type);\n+/*[ENDIF] OPENJDK_METHODHANDLES*/\n \t\t\t\tresult = lookup.findVirtual(referenceClazz, name, type);\n \t\t\t\tbreak;\n \t\t\tcase 6: /* invokeStatic */\n \t\t\t\ttype = MethodTypeHelper.vmResolveFromMethodDescriptorString(typeDescriptor, loader, null);\n+/*[IF OPENJDK_METHODHANDLES]*/\n+\t\t\t\t/* TODO: Investigate if an equivalent for lookup.accessCheckArgRetTypes is needed for OpenJDK MH. */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2534b206ab18a2809b3cbe65414b762a975dce39"}, "originalPosition": 166}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2534b206ab18a2809b3cbe65414b762a975dce39", "author": {"user": {"login": "babsingh", "name": "Babneet Singh"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/2534b206ab18a2809b3cbe65414b762a975dce39", "committedDate": "2020-10-15T16:09:04Z", "message": "Disable invokeBsm for OJDK MH\n\ninvokeBsm is unused for OpenJDK MethodHandles.\n\nCo-authored-by: Jack Lu <Jack.S.Lu@ibm.com>\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>"}, "afterCommit": {"oid": "94b67ffab1c70fdb3689bc8c08af5ce149385312", "author": {"user": {"login": "babsingh", "name": "Babneet Singh"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/94b67ffab1c70fdb3689bc8c08af5ce149385312", "committedDate": "2020-10-16T14:54:54Z", "message": "Disable invokeBsm for OJDK MH\n\ninvokeBsm is unused for OpenJDK MethodHandles.\n\nCo-authored-by: Jack Lu <Jack.S.Lu@ibm.com>\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "94b67ffab1c70fdb3689bc8c08af5ce149385312", "author": {"user": {"login": "babsingh", "name": "Babneet Singh"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/94b67ffab1c70fdb3689bc8c08af5ce149385312", "committedDate": "2020-10-16T14:54:54Z", "message": "Disable invokeBsm for OJDK MH\n\ninvokeBsm is unused for OpenJDK MethodHandles.\n\nCo-authored-by: Jack Lu <Jack.S.Lu@ibm.com>\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>"}, "afterCommit": {"oid": "72d4325132269e1622894b3a8b315fc0e04815f5", "author": {"user": {"login": "babsingh", "name": "Babneet Singh"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/72d4325132269e1622894b3a8b315fc0e04815f5", "committedDate": "2020-10-19T17:57:45Z", "message": "Disable invokeBsm for OJDK MH\n\ninvokeBsm is unused for OpenJDK MethodHandles.\n\nCo-authored-by: Jack Lu <Jack.S.Lu@ibm.com>\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyODgwMDY3", "url": "https://github.com/eclipse-openj9/openj9/pull/10830#pullrequestreview-512880067", "createdAt": "2020-10-20T15:45:30Z", "commit": {"oid": "72d4325132269e1622894b3a8b315fc0e04815f5"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bddd2b936f8b01e725d8046846428cfe7c79fc56", "author": {"user": {"login": "babsingh", "name": "Babneet Singh"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/bddd2b936f8b01e725d8046846428cfe7c79fc56", "committedDate": "2020-10-20T23:09:03Z", "message": "Add support for OpenJDK (OJDK) MethodHandle (MH) in MethodHandleResolver\n\n1. Update sendResolveMethodHandle and resolveFieldHandleHelper for OJDK MH\n\nFor OJDK MH, the usage of accessCheckArgRetTypes has been commented from\nsendResolveMethodHandle and resolveFieldHandleHelper since this method\nis not available in OpenJDK Lookup.\n\nTODO: Investigate if an equivalent for lookup.accessCheckArgRetTypes is\nneeded for OJDK MH. If needed, find an alternative for\nlookup.accessCheckArgRetTypes.\n\nOpenJDK Lookup does not have constructor Lookup(Class<?>, boolean). So,\nit has been replaced with constructor Lookup(Class<?>) in\nsendResolveMethodHandle.\n\n2. Add support to resolve invokedynamic under OpenJDK MethodHandles\n\nMethodHandleNatives.linkCallSite is used to resolve invokedynamic.\n\nThe resolved values are returned in a two element array. The first array\nelement is a MemberName object, and the second array element is a\nMethodHandle object.\n\nThe return type of resolveInvokeDynamic is changed to Object in order to\nsupport both the OpenJ9 and OpenJDK implementations for resolving\ninvokedynamic. For OpenJDK MethodHandles, the two element array is\ncasted to an Object before being returned. For OpenJ9 MethodHandles, the\nMethodHandle object automatically qualifies as an Object. The change in\nreturn type is reflected in vmconstantpool.xml.\n\n3. Add support to resolve constantdynamic under OpenJDK MethodHandles\n\nFor OpenJDK MethodHandles, MethodHandleNatives.linkDynamicConstant is\nused to resolve constantdynamic.\n\nThe resolve value is returned in the form of an Object, which is\nidentical to the OpenJ9 implementation.\n\n4. Add the implementation for linkCallerMethod\n\nlinkCallerMethod was previously named as resolveMethodHandle.\n\nIt's a wrapper for MethodHandleNatives.linkMethod. It is used in\ninvokehandle for MethodHandle and VarHandle polymorphic methods. The\nresolution yields two values. The two values are returned in a two\nelement array. The first array element is a MemberName object, which\nspecifies the caller method to be invoked. The second array element is a\nMethodType object if the defining class is a MethodHandle and an\nAccessDescriptor object if the defining class is a VarHandle.\n\nlinkCallerMethod is only needed for OJDK MH. InternalError will be\nthrown if it is invoked for OpenJ9 MH.\n\n5. Disable invokeBsm for OJDK MH\n\ninvokeBsm is unused for OpenJDK MethodHandles.\n\nCo-authored-by: Jack Lu <Jack.S.Lu@ibm.com>\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "72d4325132269e1622894b3a8b315fc0e04815f5", "author": {"user": {"login": "babsingh", "name": "Babneet Singh"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/72d4325132269e1622894b3a8b315fc0e04815f5", "committedDate": "2020-10-19T17:57:45Z", "message": "Disable invokeBsm for OJDK MH\n\ninvokeBsm is unused for OpenJDK MethodHandles.\n\nCo-authored-by: Jack Lu <Jack.S.Lu@ibm.com>\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>"}, "afterCommit": {"oid": "bddd2b936f8b01e725d8046846428cfe7c79fc56", "author": {"user": {"login": "babsingh", "name": "Babneet Singh"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/bddd2b936f8b01e725d8046846428cfe7c79fc56", "committedDate": "2020-10-20T23:09:03Z", "message": "Add support for OpenJDK (OJDK) MethodHandle (MH) in MethodHandleResolver\n\n1. Update sendResolveMethodHandle and resolveFieldHandleHelper for OJDK MH\n\nFor OJDK MH, the usage of accessCheckArgRetTypes has been commented from\nsendResolveMethodHandle and resolveFieldHandleHelper since this method\nis not available in OpenJDK Lookup.\n\nTODO: Investigate if an equivalent for lookup.accessCheckArgRetTypes is\nneeded for OJDK MH. If needed, find an alternative for\nlookup.accessCheckArgRetTypes.\n\nOpenJDK Lookup does not have constructor Lookup(Class<?>, boolean). So,\nit has been replaced with constructor Lookup(Class<?>) in\nsendResolveMethodHandle.\n\n2. Add support to resolve invokedynamic under OpenJDK MethodHandles\n\nMethodHandleNatives.linkCallSite is used to resolve invokedynamic.\n\nThe resolved values are returned in a two element array. The first array\nelement is a MemberName object, and the second array element is a\nMethodHandle object.\n\nThe return type of resolveInvokeDynamic is changed to Object in order to\nsupport both the OpenJ9 and OpenJDK implementations for resolving\ninvokedynamic. For OpenJDK MethodHandles, the two element array is\ncasted to an Object before being returned. For OpenJ9 MethodHandles, the\nMethodHandle object automatically qualifies as an Object. The change in\nreturn type is reflected in vmconstantpool.xml.\n\n3. Add support to resolve constantdynamic under OpenJDK MethodHandles\n\nFor OpenJDK MethodHandles, MethodHandleNatives.linkDynamicConstant is\nused to resolve constantdynamic.\n\nThe resolve value is returned in the form of an Object, which is\nidentical to the OpenJ9 implementation.\n\n4. Add the implementation for linkCallerMethod\n\nlinkCallerMethod was previously named as resolveMethodHandle.\n\nIt's a wrapper for MethodHandleNatives.linkMethod. It is used in\ninvokehandle for MethodHandle and VarHandle polymorphic methods. The\nresolution yields two values. The two values are returned in a two\nelement array. The first array element is a MemberName object, which\nspecifies the caller method to be invoked. The second array element is a\nMethodType object if the defining class is a MethodHandle and an\nAccessDescriptor object if the defining class is a VarHandle.\n\nlinkCallerMethod is only needed for OJDK MH. InternalError will be\nthrown if it is invoked for OpenJ9 MH.\n\n5. Disable invokeBsm for OJDK MH\n\ninvokeBsm is unused for OpenJDK MethodHandles.\n\nCo-authored-by: Jack Lu <Jack.S.Lu@ibm.com>\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 135, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}