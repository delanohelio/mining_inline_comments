{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAxNTUyNTcx", "number": 9202, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMjoxNzo1M1rODwldsw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMjoxNzo1M1rODwldsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyMjcyMDUxOnYy", "diffSide": "RIGHT", "path": "runtime/gc_glue_java/FlattenedArrayObjectScanner.hpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMjoxNzo1M1rOGDrTlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMjoxNzo1M1rOGDrTlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUwODQzNg==", "bodyText": "This one line was added.", "url": "https://github.com/eclipse-openj9/openj9/pull/9202#discussion_r406508436", "createdAt": "2020-04-09T22:17:53Z", "author": {"login": "youngar"}, "path": "runtime/gc_glue_java/FlattenedArrayObjectScanner.hpp", "diffHunk": "@@ -0,0 +1,256 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#if !defined(FLATTENEDARRAYOBJECTSCANNER_HPP_)\n+#define FLATTENEDARRAYOBJECTSCANNER_HPP_\n+\n+#include \"j9.h\"\n+#include \"j9cfg.h\"\n+#include \"modron.h\"\n+\n+#include \"objectdescription.h\"\n+#include \"ArrayObjectModel.hpp\"\n+#include \"GCExtensionsBase.hpp\"\n+#include \"HeadlessMixedObjectScanner.hpp\"\n+#include \"IndexableObjectScanner.hpp\"\n+\n+class GC_FlattenedArrayObjectScanner : public GC_HeadlessMixedObjectScanner\n+{\n+\t/* Data Members */\n+private:\n+\n+\tMM_EnvironmentBase *_env;\n+\tuintptr_t _elementSizeWithoutPadding; /**< Size of the flattened element, without padding */\n+\tuintptr_t *_descriptionBasePtr; /**< Pointer to the description base */\n+#if defined(OMR_GC_LEAF_BITS)\n+\tuintptr_t *_leafBasePtr; /**< Pointer to the leaf description base */\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\tGC_IndexableObjectScanner _indexableScanner; /**< Used to iterate the array by element */\n+\n+protected:\n+\n+public:\n+\n+\t/* Methods */\n+private:\n+\n+protected:\n+\n+\t/**\n+\t * @param env The scanning thread environment\n+\t * @param arrayPtr pointer to the array to be processed\n+\t * @param basePtr pointer to the first contiguous array cell\n+\t * @param limitPtr pointer to end of last contiguous array cell\n+\t * @param scanPtr pointer to the array cell where scanning will start\n+\t * @param endPtr pointer to the array cell where scanning will stop\n+\t * @param scanMap The first scan map\n+\t * @param elementSize The size of each element, without padding\n+\t * @param elementStride The stride of each element, including element padding\n+\t * @param flags Scanning context flags\n+\t */\n+\tMMINLINE GC_FlattenedArrayObjectScanner(\n+\t\tMM_EnvironmentBase *env\n+\t\t, omrobjectptr_t arrayPtr\n+\t\t, fomrobject_t *basePtr\n+\t\t, fomrobject_t *limitPtr\n+\t\t, fomrobject_t *scanPtr\n+\t\t, fomrobject_t *endPtr\n+\t\t, uintptr_t elementSize\n+\t\t, uintptr_t elementStride\n+\t\t, uintptr_t *descriptionBasePtr\n+#if defined(OMR_GC_LEAF_BITS)\n+\t\t, uintptr_t *leafBasePtr\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\t\t, uintptr_t flags)\n+\t: GC_HeadlessMixedObjectScanner(env, scanPtr, elementSize, flags | GC_ObjectScanner::indexableObject)\n+\t, _env(env)\n+\t, _elementSizeWithoutPadding(elementSize)\n+\t, _descriptionBasePtr(descriptionBasePtr)\n+#if defined(OMR_GC_LEAF_BITS)\n+\t, _leafBasePtr(leafBasePtr)\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\t/* Pass 0 for scanMap, as the indexable iterator does not use the scanMap */\n+\t, _indexableScanner(env, arrayPtr, basePtr, limitPtr, scanPtr, endPtr, 0, elementStride, flags)\n+\t{\n+\t\t_typeId = __FUNCTION__;\n+\t}\n+\n+\tMMINLINE void\n+\tinitialize(MM_EnvironmentBase *env)\n+\t{\n+#if defined(OMR_GC_LEAF_BITS)\n+\t\tGC_HeadlessMixedObjectScanner::initialize(env, _descriptionBasePtr, _leafBasePtr);\n+#else /* defined(OMR_GC_LEAF_BITS) */\n+\t\tGC_HeadlessMixedObjectScanner::initialize(env, _descriptionBasePtr);\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\n+\t\t_indexableScanner.initialize(env);\n+\n+\t\t/* The HeadlessMixedObjectScanner will setNoMoreSlots() causing us\n+\t\t * to miss other elements of the array\n+\t\t */\n+\t\tsetMoreSlots();\n+\t}\n+\n+public:\n+\n+\t/**\n+\t * @param[in] env The scanning thread environment\n+\t * @param[in] objectPtr pointer to the array to be processed\n+\t * @param[in] allocSpace pointer to space within which the scanner should be instantiated (in-place)\n+\t * @param[in] flags Scanning context flags\n+\t * @param[in] splitAmount If >0, the number of elements to include for this scanner instance; if 0, include all elements\n+\t * @param[in] startIndex The index of the first element to scan\n+\t */\n+\tMMINLINE static GC_FlattenedArrayObjectScanner *\n+\tnewInstance(MM_EnvironmentBase *env, omrobjectptr_t objectPtr, void *allocSpace, uintptr_t flags, uintptr_t splitAmount, uintptr_t startIndex = 0)\n+\t{\n+\t\tGC_FlattenedArrayObjectScanner *objectScanner = (GC_FlattenedArrayObjectScanner *)allocSpace;\n+\t\tGC_ArrayObjectModel *arrayObjectModel = &(env->getExtensions()->indexableObjectModel);\n+\t\tJ9Class *clazzPtr = J9GC_J9OBJECT_CLAZZ(objectPtr, env);\n+\t\tJ9ArrayClass *j9ArrayClass = (J9ArrayClass *) clazzPtr;\n+\n+\t\t/* TODO are these always the same? */\n+\t\tAssert_MM_true(j9ArrayClass->componentType == j9ArrayClass->leafComponentType);\n+\n+\t\tJ9Class *elementClass = j9ArrayClass->componentType;\n+\t\tomrarrayptr_t arrayPtr = (omrarrayptr_t)objectPtr;\n+\t\t\n+\t\tuintptr_t sizeInElements = arrayObjectModel->getSizeInElements(arrayPtr);\n+\t\tuintptr_t elementSize = J9_VALUETYPE_FLATTENED_SIZE(elementClass);\n+\t\tuintptr_t elementStride = J9ARRAYCLASS_GET_STRIDE(clazzPtr);\n+\t\tfomrobject_t *basePtr = (fomrobject_t *)arrayObjectModel->getDataPointerForContiguous(arrayPtr);\n+\t\tfomrobject_t *limitPtr = (fomrobject_t *)((uintptr_t)basePtr + (sizeInElements * elementStride));\n+\t\tfomrobject_t *scanPtr = (fomrobject_t *)((uintptr_t)basePtr + (startIndex * elementStride));\n+\t\tfomrobject_t *endPtr = limitPtr;\n+\t\tif (!GC_ObjectScanner::isIndexableObjectNoSplit(flags) && (splitAmount != 0)) {\n+\t\t\tAssert_MM_unreachable();\n+\t\t\tendPtr = (fomrobject_t *)((uintptr_t)scanPtr + (splitAmount * elementStride));\n+\t\t\tif (endPtr > limitPtr) {\n+\t\t\t\tendPtr = limitPtr;\n+\t\t\t}\n+\t\t}\n+\t\tuintptr_t *instanceDescription = elementClass->instanceDescription;\n+#if defined(OMR_GC_LEAF_BITS)\n+\t\tuintptr_t *leafDescription = elementClass->instanceLeafDescription;\n+\t\tnew(objectScanner) GC_FlattenedArrayObjectScanner(env, objectPtr, basePtr, limitPtr, scanPtr, endPtr, elementSize, elementStride, instanceDescription, leafDescription, flags);\n+#else /* defined(OMR_GC_LEAF_BITS) */\n+\t\tnew(objectScanner) GC_FlattenedArrayObjectScanner(env, objectPtr, basePtr, limitPtr, scanPtr, endPtr, elementSize, elementStride, instanceDescription, flags);\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\n+\t\tobjectScanner->initialize(env);\n+\t\tif (0 != startIndex) {\n+\t\t\tobjectScanner->clearHeadObjectScanner();\n+\t\t}\n+\t\treturn objectScanner;\n+\t}\n+\n+\tMMINLINE uintptr_t getBytesRemaining() { return sizeof(fomrobject_t) * (_endPtr - _scanPtr); }\n+\n+\t/**\n+\t * @param env The scanning thread environment\n+\t * @param allocSpace pointer to space within which the scanner should be instantiated (in-place)\n+\t * @param splitAmount The maximum number of array elements to include\n+\t * @return Pointer to split scanner in allocSpace\n+\t */\n+\tGC_IndexableObjectScanner *\n+\tsplitTo(MM_EnvironmentBase *env, void *allocSpace, uintptr_t splitAmount)\n+\t{\n+\t\tAssert_MM_unimplemented();\n+\t\treturn NULL;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e6f32ce18ebe8a83759e5c828929dd92c9ec9d9"}, "originalPosition": 179}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 377, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}