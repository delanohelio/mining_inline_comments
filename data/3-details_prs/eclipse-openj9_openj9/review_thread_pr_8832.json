{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg2ODI2NzUw", "number": 8832, "reviewThreads": {"totalCount": 19, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxODo1ODozMVrODoduBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxNjoxMTozNVrODoye6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzNzU2NTUwOnYy", "diffSide": "RIGHT", "path": "runtime/compiler/control/JITServerHelpers.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxODo1ODozMVrOF3B54g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxMjozNDoxM1rOF3aOLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzI0NzIwMg==", "bodyText": "Remove?", "url": "https://github.com/eclipse-openj9/openj9/pull/8832#discussion_r393247202", "createdAt": "2020-03-16T18:58:31Z", "author": {"login": "ymanton"}, "path": "runtime/compiler/control/JITServerHelpers.cpp", "diffHunk": "@@ -123,11 +123,12 @@ JITServerHelpers::printJITServerMsgStats(J9JITConfig *jitConfig)\n    PORT_ACCESS_FROM_JITCONFIG(jitConfig);\n    j9tty_printf(PORTLIB, \"JITServer Message Type Statistics:\\n\");\n    j9tty_printf(PORTLIB, \"Type# #called TypeName\\n\");\n-   const ::google::protobuf::EnumDescriptor *descriptor = JITServer::MessageType_descriptor();\n+   // const ::google::protobuf::EnumDescriptor *descriptor = JITServer::MessageType_descriptor();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14b78a158949a862ee4a58ab036bb658beaee15c"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY0NTYxMg==", "bodyText": "Done", "url": "https://github.com/eclipse-openj9/openj9/pull/8832#discussion_r393645612", "createdAt": "2020-03-17T12:34:13Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/control/JITServerHelpers.cpp", "diffHunk": "@@ -123,11 +123,12 @@ JITServerHelpers::printJITServerMsgStats(J9JITConfig *jitConfig)\n    PORT_ACCESS_FROM_JITCONFIG(jitConfig);\n    j9tty_printf(PORTLIB, \"JITServer Message Type Statistics:\\n\");\n    j9tty_printf(PORTLIB, \"Type# #called TypeName\\n\");\n-   const ::google::protobuf::EnumDescriptor *descriptor = JITServer::MessageType_descriptor();\n+   // const ::google::protobuf::EnumDescriptor *descriptor = JITServer::MessageType_descriptor();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzI0NzIwMg=="}, "originalCommit": {"oid": "14b78a158949a862ee4a58ab036bb658beaee15c"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzNzU3NDY0OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/control/JITServerHelpers.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxOTowMDoxMFrOF3B_Zw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxMjozNToxOVrOF3aQiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzI0ODYxNQ==", "bodyText": "Remove?", "url": "https://github.com/eclipse-openj9/openj9/pull/8832#discussion_r393248615", "createdAt": "2020-03-16T19:00:10Z", "author": {"login": "ymanton"}, "path": "runtime/compiler/control/JITServerHelpers.cpp", "diffHunk": "@@ -123,11 +123,12 @@ JITServerHelpers::printJITServerMsgStats(J9JITConfig *jitConfig)\n    PORT_ACCESS_FROM_JITCONFIG(jitConfig);\n    j9tty_printf(PORTLIB, \"JITServer Message Type Statistics:\\n\");\n    j9tty_printf(PORTLIB, \"Type# #called TypeName\\n\");\n-   const ::google::protobuf::EnumDescriptor *descriptor = JITServer::MessageType_descriptor();\n+   // const ::google::protobuf::EnumDescriptor *descriptor = JITServer::MessageType_descriptor();\n    for (int i = 0; i < JITServer::MessageType_ARRAYSIZE; ++i)\n       {\n       if (JITServerHelpers::serverMsgTypeCount[i] > 0)\n-         j9tty_printf(PORTLIB, \"#%04d %7u %s\\n\", i, JITServerHelpers::serverMsgTypeCount[i], descriptor->FindValueByNumber(i)->name().c_str());\n+         // j9tty_printf(PORTLIB, \"#%04d %7u %s\\n\", i, JITServerHelpers::serverMsgTypeCount[i], descriptor->FindValueByNumber(i)->name().c_str());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14b78a158949a862ee4a58ab036bb658beaee15c"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY0NjIxOQ==", "bodyText": "Done", "url": "https://github.com/eclipse-openj9/openj9/pull/8832#discussion_r393646219", "createdAt": "2020-03-17T12:35:19Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/control/JITServerHelpers.cpp", "diffHunk": "@@ -123,11 +123,12 @@ JITServerHelpers::printJITServerMsgStats(J9JITConfig *jitConfig)\n    PORT_ACCESS_FROM_JITCONFIG(jitConfig);\n    j9tty_printf(PORTLIB, \"JITServer Message Type Statistics:\\n\");\n    j9tty_printf(PORTLIB, \"Type# #called TypeName\\n\");\n-   const ::google::protobuf::EnumDescriptor *descriptor = JITServer::MessageType_descriptor();\n+   // const ::google::protobuf::EnumDescriptor *descriptor = JITServer::MessageType_descriptor();\n    for (int i = 0; i < JITServer::MessageType_ARRAYSIZE; ++i)\n       {\n       if (JITServerHelpers::serverMsgTypeCount[i] > 0)\n-         j9tty_printf(PORTLIB, \"#%04d %7u %s\\n\", i, JITServerHelpers::serverMsgTypeCount[i], descriptor->FindValueByNumber(i)->name().c_str());\n+         // j9tty_printf(PORTLIB, \"#%04d %7u %s\\n\", i, JITServerHelpers::serverMsgTypeCount[i], descriptor->FindValueByNumber(i)->name().c_str());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzI0ODYxNQ=="}, "originalCommit": {"oid": "14b78a158949a862ee4a58ab036bb658beaee15c"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzNzU4NzAyOnYy", "diffSide": "RIGHT", "path": "runtime/compiler/net/CommunicationStream.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxOTowMzowOVrOF3CHdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxMjozNDozMFrOF3aO1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzI1MDY3OA==", "bodyText": "Remove?", "url": "https://github.com/eclipse-openj9/openj9/pull/8832#discussion_r393250678", "createdAt": "2020-03-16T19:03:09Z", "author": {"login": "ymanton"}, "path": "runtime/compiler/net/CommunicationStream.cpp", "diffHunk": "@@ -57,4 +56,35 @@ void CommunicationStream::initSSL()\n    // It's redundant, should be able to remove it later\n    // OpenSSL_add_ssl_algorithms();\n    }\n-};\n+\n+void\n+CommunicationStream::readMessage(Message &msg)\n+   {\n+   msg.clearForRead();\n+\n+   // read message size\n+   uint32_t serializedSize;\n+   readBlocking(serializedSize);\n+   msg.setSerializedSize(serializedSize);\n+\n+   //TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"Will receive a message of size %lu\\n\", serializedSize);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14b78a158949a862ee4a58ab036bb658beaee15c"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY0NTc4MQ==", "bodyText": "Done", "url": "https://github.com/eclipse-openj9/openj9/pull/8832#discussion_r393645781", "createdAt": "2020-03-17T12:34:30Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/net/CommunicationStream.cpp", "diffHunk": "@@ -57,4 +56,35 @@ void CommunicationStream::initSSL()\n    // It's redundant, should be able to remove it later\n    // OpenSSL_add_ssl_algorithms();\n    }\n-};\n+\n+void\n+CommunicationStream::readMessage(Message &msg)\n+   {\n+   msg.clearForRead();\n+\n+   // read message size\n+   uint32_t serializedSize;\n+   readBlocking(serializedSize);\n+   msg.setSerializedSize(serializedSize);\n+\n+   //TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"Will receive a message of size %lu\\n\", serializedSize);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzI1MDY3OA=="}, "originalCommit": {"oid": "14b78a158949a862ee4a58ab036bb658beaee15c"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzNzU4NzUwOnYy", "diffSide": "RIGHT", "path": "runtime/compiler/net/CommunicationStream.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxOTowMzoyMVrOF3CHzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxMjozNDo0NFrOF3aPVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzI1MDc2NA==", "bodyText": "Remove?", "url": "https://github.com/eclipse-openj9/openj9/pull/8832#discussion_r393250764", "createdAt": "2020-03-16T19:03:21Z", "author": {"login": "ymanton"}, "path": "runtime/compiler/net/CommunicationStream.cpp", "diffHunk": "@@ -57,4 +56,35 @@ void CommunicationStream::initSSL()\n    // It's redundant, should be able to remove it later\n    // OpenSSL_add_ssl_algorithms();\n    }\n-};\n+\n+void\n+CommunicationStream::readMessage(Message &msg)\n+   {\n+   msg.clearForRead();\n+\n+   // read message size\n+   uint32_t serializedSize;\n+   readBlocking(serializedSize);\n+   msg.setSerializedSize(serializedSize);\n+\n+   //TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"Will receive a message of size %lu\\n\", serializedSize);\n+\n+   // read the rest of the message\n+   uint32_t messageSize = serializedSize - sizeof(uint32_t);\n+   readBlocking(msg.getBufferStartForRead() + sizeof(uint32_t), messageSize);\n+\n+   // rebuild the message\n+   msg.deserialize();\n+   }\n+\n+void\n+CommunicationStream::writeMessage(Message &msg)\n+   {\n+   char *serialMsg = msg.serialize();\n+   //TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"Will send a message of size %lu\\n\", msg.serializedSize());\n+   //msg.print();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14b78a158949a862ee4a58ab036bb658beaee15c"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY0NTkxMA==", "bodyText": "Done", "url": "https://github.com/eclipse-openj9/openj9/pull/8832#discussion_r393645910", "createdAt": "2020-03-17T12:34:44Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/net/CommunicationStream.cpp", "diffHunk": "@@ -57,4 +56,35 @@ void CommunicationStream::initSSL()\n    // It's redundant, should be able to remove it later\n    // OpenSSL_add_ssl_algorithms();\n    }\n-};\n+\n+void\n+CommunicationStream::readMessage(Message &msg)\n+   {\n+   msg.clearForRead();\n+\n+   // read message size\n+   uint32_t serializedSize;\n+   readBlocking(serializedSize);\n+   msg.setSerializedSize(serializedSize);\n+\n+   //TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"Will receive a message of size %lu\\n\", serializedSize);\n+\n+   // read the rest of the message\n+   uint32_t messageSize = serializedSize - sizeof(uint32_t);\n+   readBlocking(msg.getBufferStartForRead() + sizeof(uint32_t), messageSize);\n+\n+   // rebuild the message\n+   msg.deserialize();\n+   }\n+\n+void\n+CommunicationStream::writeMessage(Message &msg)\n+   {\n+   char *serialMsg = msg.serialize();\n+   //TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"Will send a message of size %lu\\n\", msg.serializedSize());\n+   //msg.print();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzI1MDc2NA=="}, "originalCommit": {"oid": "14b78a158949a862ee4a58ab036bb658beaee15c"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzNzYxMTY0OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/net/CommunicationStream.hpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxOToxMTo0OFrOF3CXlg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxMjozNDo1NVrOF3aPxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzI1NDgwNg==", "bodyText": "For the object to be correctly written, it needs to be contiguous.\n\nWe should check for this at compile-time with:\nstatic_assert(std::is_trivially_copyable<T>::value == true, \"T must be trivially copyable.\");", "url": "https://github.com/eclipse-openj9/openj9/pull/8832#discussion_r393254806", "createdAt": "2020-03-16T19:11:48Z", "author": {"login": "ymanton"}, "path": "runtime/compiler/net/CommunicationStream.hpp", "diffHunk": "@@ -35,134 +37,141 @@ enum JITServerCompatibilityFlags\n    JITServerJavaVersionMask    = 0x00000FFF,\n    JITServerCompressedRef      = 0x00001000,\n    };\n-// list of features that client and server must match in order for remote compilations to work\n-\n-using namespace google::protobuf::io;\n \n class CommunicationStream\n    {\n public:\n    static bool useSSL();\n    static void initSSL();\n \n-   static void initVersion();\n+   static void initConfigurationFlags();\n+\n+   static uint32_t getJITServerVersion()\n+      {\n+      return (MAJOR_NUMBER << 24) | (MINOR_NUMBER << 8); // PATCH_NUMBER is ignored\n+      }\n \n-   static uint64_t getJITServerVersion()\n+   static uint64_t getJITServerFullVersion()\n       {\n-      return ((((uint64_t)CONFIGURATION_FLAGS) << 32) | (MAJOR_NUMBER << 24) | (MINOR_NUMBER << 8));\n+      return Message::buildFullVersion(getJITServerVersion(), CONFIGURATION_FLAGS);\n       }\n \n protected:\n-   CommunicationStream()\n-      : _inputStream(NULL),\n-      _outputStream(NULL),\n+   CommunicationStream() :\n       _ssl(NULL),\n-      _sslInputStream(NULL),\n-      _sslOutputStream(NULL),\n       _connfd(-1)\n       {\n-      // set everything to NULL, in case the child stream fails to call initStream\n-      // which initializes these variables\n+      }\n+\n+   virtual ~CommunicationStream()\n+      {\n+      if (_connfd != -1)\n+         close(_connfd);\n+\n+      if (_ssl)\n+         (*OBIO_free_all)(_ssl);\n       }\n \n    void initStream(int connfd, BIO *ssl)\n-   {\n+      {\n       _connfd = connfd;\n       _ssl = ssl;\n-      if (_ssl)\n-         {\n-         _sslInputStream = new (PERSISTENT_NEW) SSLInputStream(_ssl);\n-         _sslOutputStream = new (PERSISTENT_NEW) SSLOutputStream(_ssl);\n-         _inputStream = new (PERSISTENT_NEW) CopyingInputStreamAdaptor(_sslInputStream);\n-         _outputStream = new (PERSISTENT_NEW) CopyingOutputStreamAdaptor(_sslOutputStream);\n-         }\n-      else\n-         {\n-         _inputStream = new (PERSISTENT_NEW) FileInputStream(_connfd);\n-         _outputStream = new (PERSISTENT_NEW) FileOutputStream(_connfd);\n-         }\n       }\n \n-   virtual ~CommunicationStream()\n+   void readMessage(Message &msg);\n+   void writeMessage(Message &msg);\n+\n+   int getConnFD() const { return _connfd; }\n+   \n+   BIO *_ssl; // SSL connection, null if not using SSL\n+   int _connfd;\n+   ServerMessage _sMsg;\n+   ClientMessage _cMsg;\n+\n+   static const uint8_t MAJOR_NUMBER = 1;\n+   static const uint16_t MINOR_NUMBER = 0;\n+   static const uint8_t PATCH_NUMBER = 0;\n+   static uint32_t CONFIGURATION_FLAGS;\n+\n+private:\n+   // readBlocking and writeBlocking are functions that directly read/write\n+   // passed object from/to the socket. For the object to be correctly written,\n+   // it needs to be contiguous.\n+   template <typename T>\n+   void readBlocking(T &val)\n+      {\n+      readBlocking((char*)&val, sizeof(T));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14b78a158949a862ee4a58ab036bb658beaee15c"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY0NjAyMQ==", "bodyText": "Done", "url": "https://github.com/eclipse-openj9/openj9/pull/8832#discussion_r393646021", "createdAt": "2020-03-17T12:34:55Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/net/CommunicationStream.hpp", "diffHunk": "@@ -35,134 +37,141 @@ enum JITServerCompatibilityFlags\n    JITServerJavaVersionMask    = 0x00000FFF,\n    JITServerCompressedRef      = 0x00001000,\n    };\n-// list of features that client and server must match in order for remote compilations to work\n-\n-using namespace google::protobuf::io;\n \n class CommunicationStream\n    {\n public:\n    static bool useSSL();\n    static void initSSL();\n \n-   static void initVersion();\n+   static void initConfigurationFlags();\n+\n+   static uint32_t getJITServerVersion()\n+      {\n+      return (MAJOR_NUMBER << 24) | (MINOR_NUMBER << 8); // PATCH_NUMBER is ignored\n+      }\n \n-   static uint64_t getJITServerVersion()\n+   static uint64_t getJITServerFullVersion()\n       {\n-      return ((((uint64_t)CONFIGURATION_FLAGS) << 32) | (MAJOR_NUMBER << 24) | (MINOR_NUMBER << 8));\n+      return Message::buildFullVersion(getJITServerVersion(), CONFIGURATION_FLAGS);\n       }\n \n protected:\n-   CommunicationStream()\n-      : _inputStream(NULL),\n-      _outputStream(NULL),\n+   CommunicationStream() :\n       _ssl(NULL),\n-      _sslInputStream(NULL),\n-      _sslOutputStream(NULL),\n       _connfd(-1)\n       {\n-      // set everything to NULL, in case the child stream fails to call initStream\n-      // which initializes these variables\n+      }\n+\n+   virtual ~CommunicationStream()\n+      {\n+      if (_connfd != -1)\n+         close(_connfd);\n+\n+      if (_ssl)\n+         (*OBIO_free_all)(_ssl);\n       }\n \n    void initStream(int connfd, BIO *ssl)\n-   {\n+      {\n       _connfd = connfd;\n       _ssl = ssl;\n-      if (_ssl)\n-         {\n-         _sslInputStream = new (PERSISTENT_NEW) SSLInputStream(_ssl);\n-         _sslOutputStream = new (PERSISTENT_NEW) SSLOutputStream(_ssl);\n-         _inputStream = new (PERSISTENT_NEW) CopyingInputStreamAdaptor(_sslInputStream);\n-         _outputStream = new (PERSISTENT_NEW) CopyingOutputStreamAdaptor(_sslOutputStream);\n-         }\n-      else\n-         {\n-         _inputStream = new (PERSISTENT_NEW) FileInputStream(_connfd);\n-         _outputStream = new (PERSISTENT_NEW) FileOutputStream(_connfd);\n-         }\n       }\n \n-   virtual ~CommunicationStream()\n+   void readMessage(Message &msg);\n+   void writeMessage(Message &msg);\n+\n+   int getConnFD() const { return _connfd; }\n+   \n+   BIO *_ssl; // SSL connection, null if not using SSL\n+   int _connfd;\n+   ServerMessage _sMsg;\n+   ClientMessage _cMsg;\n+\n+   static const uint8_t MAJOR_NUMBER = 1;\n+   static const uint16_t MINOR_NUMBER = 0;\n+   static const uint8_t PATCH_NUMBER = 0;\n+   static uint32_t CONFIGURATION_FLAGS;\n+\n+private:\n+   // readBlocking and writeBlocking are functions that directly read/write\n+   // passed object from/to the socket. For the object to be correctly written,\n+   // it needs to be contiguous.\n+   template <typename T>\n+   void readBlocking(T &val)\n+      {\n+      readBlocking((char*)&val, sizeof(T));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzI1NDgwNg=="}, "originalCommit": {"oid": "14b78a158949a862ee4a58ab036bb658beaee15c"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzNzYxNDE2OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/net/CommunicationStream.hpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxOToxMjozOFrOF3CZNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxMjozNTozM1rOF3aQ_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzI1NTIyMQ==", "bodyText": "Likewise here:\nstatic_assert(std::is_trivially_copyable<T>::value == true, \"T must be trivially copyable.\");", "url": "https://github.com/eclipse-openj9/openj9/pull/8832#discussion_r393255221", "createdAt": "2020-03-16T19:12:38Z", "author": {"login": "ymanton"}, "path": "runtime/compiler/net/CommunicationStream.hpp", "diffHunk": "@@ -35,134 +37,141 @@ enum JITServerCompatibilityFlags\n    JITServerJavaVersionMask    = 0x00000FFF,\n    JITServerCompressedRef      = 0x00001000,\n    };\n-// list of features that client and server must match in order for remote compilations to work\n-\n-using namespace google::protobuf::io;\n \n class CommunicationStream\n    {\n public:\n    static bool useSSL();\n    static void initSSL();\n \n-   static void initVersion();\n+   static void initConfigurationFlags();\n+\n+   static uint32_t getJITServerVersion()\n+      {\n+      return (MAJOR_NUMBER << 24) | (MINOR_NUMBER << 8); // PATCH_NUMBER is ignored\n+      }\n \n-   static uint64_t getJITServerVersion()\n+   static uint64_t getJITServerFullVersion()\n       {\n-      return ((((uint64_t)CONFIGURATION_FLAGS) << 32) | (MAJOR_NUMBER << 24) | (MINOR_NUMBER << 8));\n+      return Message::buildFullVersion(getJITServerVersion(), CONFIGURATION_FLAGS);\n       }\n \n protected:\n-   CommunicationStream()\n-      : _inputStream(NULL),\n-      _outputStream(NULL),\n+   CommunicationStream() :\n       _ssl(NULL),\n-      _sslInputStream(NULL),\n-      _sslOutputStream(NULL),\n       _connfd(-1)\n       {\n-      // set everything to NULL, in case the child stream fails to call initStream\n-      // which initializes these variables\n+      }\n+\n+   virtual ~CommunicationStream()\n+      {\n+      if (_connfd != -1)\n+         close(_connfd);\n+\n+      if (_ssl)\n+         (*OBIO_free_all)(_ssl);\n       }\n \n    void initStream(int connfd, BIO *ssl)\n-   {\n+      {\n       _connfd = connfd;\n       _ssl = ssl;\n-      if (_ssl)\n-         {\n-         _sslInputStream = new (PERSISTENT_NEW) SSLInputStream(_ssl);\n-         _sslOutputStream = new (PERSISTENT_NEW) SSLOutputStream(_ssl);\n-         _inputStream = new (PERSISTENT_NEW) CopyingInputStreamAdaptor(_sslInputStream);\n-         _outputStream = new (PERSISTENT_NEW) CopyingOutputStreamAdaptor(_sslOutputStream);\n-         }\n-      else\n-         {\n-         _inputStream = new (PERSISTENT_NEW) FileInputStream(_connfd);\n-         _outputStream = new (PERSISTENT_NEW) FileOutputStream(_connfd);\n-         }\n       }\n \n-   virtual ~CommunicationStream()\n+   void readMessage(Message &msg);\n+   void writeMessage(Message &msg);\n+\n+   int getConnFD() const { return _connfd; }\n+   \n+   BIO *_ssl; // SSL connection, null if not using SSL\n+   int _connfd;\n+   ServerMessage _sMsg;\n+   ClientMessage _cMsg;\n+\n+   static const uint8_t MAJOR_NUMBER = 1;\n+   static const uint16_t MINOR_NUMBER = 0;\n+   static const uint8_t PATCH_NUMBER = 0;\n+   static uint32_t CONFIGURATION_FLAGS;\n+\n+private:\n+   // readBlocking and writeBlocking are functions that directly read/write\n+   // passed object from/to the socket. For the object to be correctly written,\n+   // it needs to be contiguous.\n+   template <typename T>\n+   void readBlocking(T &val)\n+      {\n+      readBlocking((char*)&val, sizeof(T));\n+      }\n+\n+   void readBlocking(char *data, size_t size)\n       {\n-      if (_inputStream)\n-         {\n-         _inputStream->~ZeroCopyInputStream();\n-         TR_Memory::jitPersistentFree(_inputStream);\n-         }\n-      if (_outputStream)\n-         {\n-         _outputStream->~ZeroCopyOutputStream();\n-         TR_Memory::jitPersistentFree(_outputStream);\n-         }\n       if (_ssl)\n          {\n-         _sslInputStream->~SSLInputStream();\n-         TR_Memory::jitPersistentFree(_sslInputStream);\n-         _sslOutputStream->~SSLOutputStream();\n-         TR_Memory::jitPersistentFree(_sslOutputStream);\n-         (*OBIO_free_all)(_ssl);\n+         int32_t totalBytesRead = 0;\n+         while (totalBytesRead < size)\n+            {\n+            int bytesRead = (*OBIO_read)(_ssl, data + totalBytesRead, size - totalBytesRead);\n+            if (bytesRead <= 0)\n+               {\n+               (*OERR_print_errors_fp)(stderr);\n+               throw JITServer::StreamFailure(\"JITServer I/O error: read error\");\n+               }\n+            totalBytesRead += bytesRead;\n+            }\n          }\n-      if (_connfd != -1)\n+      else\n          {\n-         close(_connfd);\n-         _connfd = -1;\n+         int32_t totalBytesRead = 0;\n+         while (totalBytesRead < size)\n+            {\n+            int32_t bytesRead = read(_connfd, data + totalBytesRead, size - totalBytesRead);\n+            if (bytesRead <= 0)\n+               {\n+               throw JITServer::StreamFailure(\"JITServer I/O error: read error\");\n+               }\n+            totalBytesRead += bytesRead;\n+            }\n          }\n       }\n \n    template <typename T>\n-   void readBlocking(T &val)\n+   void writeBlocking(const T &val)\n       {\n-      val.mutable_data()->clear_data();\n-      CodedInputStream codedInputStream(_inputStream);\n-      uint32_t messageSize;\n-      if (!codedInputStream.ReadLittleEndian32(&messageSize))\n-         throw JITServer::StreamFailure(\"JITServer I/O error: reading message size\");\n-      auto limit = codedInputStream.PushLimit(messageSize);\n-      if (!val.ParseFromCodedStream(&codedInputStream))\n-         throw JITServer::StreamFailure(\"JITServer I/O error: reading from stream\");\n-      if (!codedInputStream.ConsumedEntireMessage())\n-         throw JITServer::StreamFailure(\"JITServer I/O error: did not receive entire message\");\n-      codedInputStream.PopLimit(limit);\n+      writeBlocking(&val, sizeof(T));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14b78a158949a862ee4a58ab036bb658beaee15c"}, "originalPosition": 178}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY0NjMzNA==", "bodyText": "Done", "url": "https://github.com/eclipse-openj9/openj9/pull/8832#discussion_r393646334", "createdAt": "2020-03-17T12:35:33Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/net/CommunicationStream.hpp", "diffHunk": "@@ -35,134 +37,141 @@ enum JITServerCompatibilityFlags\n    JITServerJavaVersionMask    = 0x00000FFF,\n    JITServerCompressedRef      = 0x00001000,\n    };\n-// list of features that client and server must match in order for remote compilations to work\n-\n-using namespace google::protobuf::io;\n \n class CommunicationStream\n    {\n public:\n    static bool useSSL();\n    static void initSSL();\n \n-   static void initVersion();\n+   static void initConfigurationFlags();\n+\n+   static uint32_t getJITServerVersion()\n+      {\n+      return (MAJOR_NUMBER << 24) | (MINOR_NUMBER << 8); // PATCH_NUMBER is ignored\n+      }\n \n-   static uint64_t getJITServerVersion()\n+   static uint64_t getJITServerFullVersion()\n       {\n-      return ((((uint64_t)CONFIGURATION_FLAGS) << 32) | (MAJOR_NUMBER << 24) | (MINOR_NUMBER << 8));\n+      return Message::buildFullVersion(getJITServerVersion(), CONFIGURATION_FLAGS);\n       }\n \n protected:\n-   CommunicationStream()\n-      : _inputStream(NULL),\n-      _outputStream(NULL),\n+   CommunicationStream() :\n       _ssl(NULL),\n-      _sslInputStream(NULL),\n-      _sslOutputStream(NULL),\n       _connfd(-1)\n       {\n-      // set everything to NULL, in case the child stream fails to call initStream\n-      // which initializes these variables\n+      }\n+\n+   virtual ~CommunicationStream()\n+      {\n+      if (_connfd != -1)\n+         close(_connfd);\n+\n+      if (_ssl)\n+         (*OBIO_free_all)(_ssl);\n       }\n \n    void initStream(int connfd, BIO *ssl)\n-   {\n+      {\n       _connfd = connfd;\n       _ssl = ssl;\n-      if (_ssl)\n-         {\n-         _sslInputStream = new (PERSISTENT_NEW) SSLInputStream(_ssl);\n-         _sslOutputStream = new (PERSISTENT_NEW) SSLOutputStream(_ssl);\n-         _inputStream = new (PERSISTENT_NEW) CopyingInputStreamAdaptor(_sslInputStream);\n-         _outputStream = new (PERSISTENT_NEW) CopyingOutputStreamAdaptor(_sslOutputStream);\n-         }\n-      else\n-         {\n-         _inputStream = new (PERSISTENT_NEW) FileInputStream(_connfd);\n-         _outputStream = new (PERSISTENT_NEW) FileOutputStream(_connfd);\n-         }\n       }\n \n-   virtual ~CommunicationStream()\n+   void readMessage(Message &msg);\n+   void writeMessage(Message &msg);\n+\n+   int getConnFD() const { return _connfd; }\n+   \n+   BIO *_ssl; // SSL connection, null if not using SSL\n+   int _connfd;\n+   ServerMessage _sMsg;\n+   ClientMessage _cMsg;\n+\n+   static const uint8_t MAJOR_NUMBER = 1;\n+   static const uint16_t MINOR_NUMBER = 0;\n+   static const uint8_t PATCH_NUMBER = 0;\n+   static uint32_t CONFIGURATION_FLAGS;\n+\n+private:\n+   // readBlocking and writeBlocking are functions that directly read/write\n+   // passed object from/to the socket. For the object to be correctly written,\n+   // it needs to be contiguous.\n+   template <typename T>\n+   void readBlocking(T &val)\n+      {\n+      readBlocking((char*)&val, sizeof(T));\n+      }\n+\n+   void readBlocking(char *data, size_t size)\n       {\n-      if (_inputStream)\n-         {\n-         _inputStream->~ZeroCopyInputStream();\n-         TR_Memory::jitPersistentFree(_inputStream);\n-         }\n-      if (_outputStream)\n-         {\n-         _outputStream->~ZeroCopyOutputStream();\n-         TR_Memory::jitPersistentFree(_outputStream);\n-         }\n       if (_ssl)\n          {\n-         _sslInputStream->~SSLInputStream();\n-         TR_Memory::jitPersistentFree(_sslInputStream);\n-         _sslOutputStream->~SSLOutputStream();\n-         TR_Memory::jitPersistentFree(_sslOutputStream);\n-         (*OBIO_free_all)(_ssl);\n+         int32_t totalBytesRead = 0;\n+         while (totalBytesRead < size)\n+            {\n+            int bytesRead = (*OBIO_read)(_ssl, data + totalBytesRead, size - totalBytesRead);\n+            if (bytesRead <= 0)\n+               {\n+               (*OERR_print_errors_fp)(stderr);\n+               throw JITServer::StreamFailure(\"JITServer I/O error: read error\");\n+               }\n+            totalBytesRead += bytesRead;\n+            }\n          }\n-      if (_connfd != -1)\n+      else\n          {\n-         close(_connfd);\n-         _connfd = -1;\n+         int32_t totalBytesRead = 0;\n+         while (totalBytesRead < size)\n+            {\n+            int32_t bytesRead = read(_connfd, data + totalBytesRead, size - totalBytesRead);\n+            if (bytesRead <= 0)\n+               {\n+               throw JITServer::StreamFailure(\"JITServer I/O error: read error\");\n+               }\n+            totalBytesRead += bytesRead;\n+            }\n          }\n       }\n \n    template <typename T>\n-   void readBlocking(T &val)\n+   void writeBlocking(const T &val)\n       {\n-      val.mutable_data()->clear_data();\n-      CodedInputStream codedInputStream(_inputStream);\n-      uint32_t messageSize;\n-      if (!codedInputStream.ReadLittleEndian32(&messageSize))\n-         throw JITServer::StreamFailure(\"JITServer I/O error: reading message size\");\n-      auto limit = codedInputStream.PushLimit(messageSize);\n-      if (!val.ParseFromCodedStream(&codedInputStream))\n-         throw JITServer::StreamFailure(\"JITServer I/O error: reading from stream\");\n-      if (!codedInputStream.ConsumedEntireMessage())\n-         throw JITServer::StreamFailure(\"JITServer I/O error: did not receive entire message\");\n-      codedInputStream.PopLimit(limit);\n+      writeBlocking(&val, sizeof(T));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzI1NTIyMQ=="}, "originalCommit": {"oid": "14b78a158949a862ee4a58ab036bb658beaee15c"}, "originalPosition": 178}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzNzc4MzI4OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/net/Message.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQyMDowOTozNFrOF3EFNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxMjozNTo0NVrOF3aRbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzI4Mjg2OA==", "bodyText": "Remove?", "url": "https://github.com/eclipse-openj9/openj9/pull/8832#discussion_r393282868", "createdAt": "2020-03-16T20:09:34Z", "author": {"login": "ymanton"}, "path": "runtime/compiler/net/Message.cpp", "diffHunk": "@@ -0,0 +1,139 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"net/Message.hpp\"\n+#include \"infra/Assert.hpp\"\n+#include \"env/VerboseLog.hpp\"\n+\n+namespace JITServer\n+{\n+   const char* const Message::DataDescriptor::_descriptorNames[] = {\n+      \"UINT32\",\n+      \"INT64\",\n+      \"UINT32\",\n+      \"UINT64\",\n+      \"BOOL\",\n+      \"STRING\",\n+      \"OBJECT\",\n+      \"ENUM\",\n+      \"VECTOR\",\n+      \"SIMPLE_VECTOR\",\n+      \"EMPTY_VECTOR\",\n+      \"TUPLE\",\n+      \"INVALID\"\n+   };\n+\n+uint32_t\n+Message::addData(const DataDescriptor &desc, const void *dataStart, bool needs64BitAlignment)\n+   {\n+   // Write the descriptor itself\n+   uint32_t descOffset = _buffer.writeValue(desc);\n+\n+   //TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"addData(dataStart=%p):  DataDescriptor(@%u): type=%d payload_size=%u dataOffset=%u, padding=%u\",\n+   //   dataStart, descOffset, desc.getDataType(), desc.getPayloadSize(), desc.getDataOffset(), desc.getPaddingSize());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14b78a158949a862ee4a58ab036bb658beaee15c"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY0NjQ0NQ==", "bodyText": "Done", "url": "https://github.com/eclipse-openj9/openj9/pull/8832#discussion_r393646445", "createdAt": "2020-03-17T12:35:45Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/net/Message.cpp", "diffHunk": "@@ -0,0 +1,139 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"net/Message.hpp\"\n+#include \"infra/Assert.hpp\"\n+#include \"env/VerboseLog.hpp\"\n+\n+namespace JITServer\n+{\n+   const char* const Message::DataDescriptor::_descriptorNames[] = {\n+      \"UINT32\",\n+      \"INT64\",\n+      \"UINT32\",\n+      \"UINT64\",\n+      \"BOOL\",\n+      \"STRING\",\n+      \"OBJECT\",\n+      \"ENUM\",\n+      \"VECTOR\",\n+      \"SIMPLE_VECTOR\",\n+      \"EMPTY_VECTOR\",\n+      \"TUPLE\",\n+      \"INVALID\"\n+   };\n+\n+uint32_t\n+Message::addData(const DataDescriptor &desc, const void *dataStart, bool needs64BitAlignment)\n+   {\n+   // Write the descriptor itself\n+   uint32_t descOffset = _buffer.writeValue(desc);\n+\n+   //TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"addData(dataStart=%p):  DataDescriptor(@%u): type=%d payload_size=%u dataOffset=%u, padding=%u\",\n+   //   dataStart, descOffset, desc.getDataType(), desc.getPayloadSize(), desc.getDataOffset(), desc.getPaddingSize());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzI4Mjg2OA=="}, "originalCommit": {"oid": "14b78a158949a862ee4a58ab036bb658beaee15c"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzNzc4ODA5OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/net/Message.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQyMDoxMToxM1rOF3EIQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxMjozNjoxMlrOF3aSWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzI4MzY0OQ==", "bodyText": "Remove?", "url": "https://github.com/eclipse-openj9/openj9/pull/8832#discussion_r393283649", "createdAt": "2020-03-16T20:11:13Z", "author": {"login": "ymanton"}, "path": "runtime/compiler/net/Message.cpp", "diffHunk": "@@ -0,0 +1,139 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"net/Message.hpp\"\n+#include \"infra/Assert.hpp\"\n+#include \"env/VerboseLog.hpp\"\n+\n+namespace JITServer\n+{\n+   const char* const Message::DataDescriptor::_descriptorNames[] = {\n+      \"UINT32\",\n+      \"INT64\",\n+      \"UINT32\",\n+      \"UINT64\",\n+      \"BOOL\",\n+      \"STRING\",\n+      \"OBJECT\",\n+      \"ENUM\",\n+      \"VECTOR\",\n+      \"SIMPLE_VECTOR\",\n+      \"EMPTY_VECTOR\",\n+      \"TUPLE\",\n+      \"INVALID\"\n+   };\n+\n+uint32_t\n+Message::addData(const DataDescriptor &desc, const void *dataStart, bool needs64BitAlignment)\n+   {\n+   // Write the descriptor itself\n+   uint32_t descOffset = _buffer.writeValue(desc);\n+\n+   //TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"addData(dataStart=%p):  DataDescriptor(@%u): type=%d payload_size=%u dataOffset=%u, padding=%u\",\n+   //   dataStart, descOffset, desc.getDataType(), desc.getPayloadSize(), desc.getDataOffset(), desc.getPaddingSize());\n+\n+   // If the data following the descriptor needs to be 64-bit aligned,\n+   // add some initial padding in the outgoing buffer and write the\n+   // offset to the real payload into the descriptor\n+   uint8_t initialPadding = 0;\n+   if (needs64BitAlignment && !_buffer.is64BitAligned())\n+      {\n+      initialPadding = _buffer.alignCurrentPositionOn64Bit();\n+      TR_ASSERT(initialPadding != 0, \"Initial padding must be non zero because we checked alignment\");\n+      DataDescriptor *serializedDescriptor = _buffer.getValueAtOffset<DataDescriptor>(descOffset);\n+      serializedDescriptor->addInitialPadding(initialPadding);\n+      }\n+\n+   // Write the real data and possibly some padding at the end\n+   _buffer.writeData(dataStart, desc.getPayloadSize(), desc.getPaddingSize()); \n+   _descriptorOffsets.push_back(descOffset);\n+   return desc.getTotalSize() + initialPadding;\n+   }\n+\n+void\n+Message::deserialize()\n+   {\n+   // Assume that buffer is populated with data that defines a valid message\n+   // Reconstruct the message by setting metadata and pointers to descriptors\n+   // Note that the size of the entire message buffer has already been stripped\n+   //\n+   _buffer.readValue<MetaData>(); // This only advances curPtr in the MessageBuffer\n+\n+   uint32_t numDataPoints = getMetaData()->_numDataPoints;\n+\n+   //TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"Metadata: type=%u numDataPoints=%u\\n\", type(), numDataPoints);\n+\n+   _descriptorOffsets.reserve(numDataPoints);\n+   // TODO: do I need to clear the vector of _descriptorOffsets just in case?\n+   for (uint32_t i = 0; i < numDataPoints; ++i)\n+      {\n+      uint32_t descOffset = _buffer.readValue<DataDescriptor>(); // Read the descriptor itself\n+      _descriptorOffsets.push_back(descOffset);\n+\n+      //DataDescriptor *desc = getLastDescriptor();\n+      //TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"DataDescriptor: type=%d payload_size=%u dataOffset=%u, padding=%u\\n\",\n+      //   desc->getDataType(), desc->getPayloadSize(), desc->getDataOffset(), desc->getPaddingSize());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14b78a158949a862ee4a58ab036bb658beaee15c"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY0NjY4Mw==", "bodyText": "Done", "url": "https://github.com/eclipse-openj9/openj9/pull/8832#discussion_r393646683", "createdAt": "2020-03-17T12:36:12Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/net/Message.cpp", "diffHunk": "@@ -0,0 +1,139 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"net/Message.hpp\"\n+#include \"infra/Assert.hpp\"\n+#include \"env/VerboseLog.hpp\"\n+\n+namespace JITServer\n+{\n+   const char* const Message::DataDescriptor::_descriptorNames[] = {\n+      \"UINT32\",\n+      \"INT64\",\n+      \"UINT32\",\n+      \"UINT64\",\n+      \"BOOL\",\n+      \"STRING\",\n+      \"OBJECT\",\n+      \"ENUM\",\n+      \"VECTOR\",\n+      \"SIMPLE_VECTOR\",\n+      \"EMPTY_VECTOR\",\n+      \"TUPLE\",\n+      \"INVALID\"\n+   };\n+\n+uint32_t\n+Message::addData(const DataDescriptor &desc, const void *dataStart, bool needs64BitAlignment)\n+   {\n+   // Write the descriptor itself\n+   uint32_t descOffset = _buffer.writeValue(desc);\n+\n+   //TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"addData(dataStart=%p):  DataDescriptor(@%u): type=%d payload_size=%u dataOffset=%u, padding=%u\",\n+   //   dataStart, descOffset, desc.getDataType(), desc.getPayloadSize(), desc.getDataOffset(), desc.getPaddingSize());\n+\n+   // If the data following the descriptor needs to be 64-bit aligned,\n+   // add some initial padding in the outgoing buffer and write the\n+   // offset to the real payload into the descriptor\n+   uint8_t initialPadding = 0;\n+   if (needs64BitAlignment && !_buffer.is64BitAligned())\n+      {\n+      initialPadding = _buffer.alignCurrentPositionOn64Bit();\n+      TR_ASSERT(initialPadding != 0, \"Initial padding must be non zero because we checked alignment\");\n+      DataDescriptor *serializedDescriptor = _buffer.getValueAtOffset<DataDescriptor>(descOffset);\n+      serializedDescriptor->addInitialPadding(initialPadding);\n+      }\n+\n+   // Write the real data and possibly some padding at the end\n+   _buffer.writeData(dataStart, desc.getPayloadSize(), desc.getPaddingSize()); \n+   _descriptorOffsets.push_back(descOffset);\n+   return desc.getTotalSize() + initialPadding;\n+   }\n+\n+void\n+Message::deserialize()\n+   {\n+   // Assume that buffer is populated with data that defines a valid message\n+   // Reconstruct the message by setting metadata and pointers to descriptors\n+   // Note that the size of the entire message buffer has already been stripped\n+   //\n+   _buffer.readValue<MetaData>(); // This only advances curPtr in the MessageBuffer\n+\n+   uint32_t numDataPoints = getMetaData()->_numDataPoints;\n+\n+   //TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"Metadata: type=%u numDataPoints=%u\\n\", type(), numDataPoints);\n+\n+   _descriptorOffsets.reserve(numDataPoints);\n+   // TODO: do I need to clear the vector of _descriptorOffsets just in case?\n+   for (uint32_t i = 0; i < numDataPoints; ++i)\n+      {\n+      uint32_t descOffset = _buffer.readValue<DataDescriptor>(); // Read the descriptor itself\n+      _descriptorOffsets.push_back(descOffset);\n+\n+      //DataDescriptor *desc = getLastDescriptor();\n+      //TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"DataDescriptor: type=%d payload_size=%u dataOffset=%u, padding=%u\\n\",\n+      //   desc->getDataType(), desc->getPayloadSize(), desc->getDataOffset(), desc->getPaddingSize());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzI4MzY0OQ=="}, "originalCommit": {"oid": "14b78a158949a862ee4a58ab036bb658beaee15c"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzNzc4ODg0OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/net/Message.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQyMDoxMTozMVrOF3EIwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxMjozNjo0MFrOF3aTdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzI4Mzc3Nw==", "bodyText": "Remove?", "url": "https://github.com/eclipse-openj9/openj9/pull/8832#discussion_r393283777", "createdAt": "2020-03-16T20:11:31Z", "author": {"login": "ymanton"}, "path": "runtime/compiler/net/Message.cpp", "diffHunk": "@@ -0,0 +1,139 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"net/Message.hpp\"\n+#include \"infra/Assert.hpp\"\n+#include \"env/VerboseLog.hpp\"\n+\n+namespace JITServer\n+{\n+   const char* const Message::DataDescriptor::_descriptorNames[] = {\n+      \"UINT32\",\n+      \"INT64\",\n+      \"UINT32\",\n+      \"UINT64\",\n+      \"BOOL\",\n+      \"STRING\",\n+      \"OBJECT\",\n+      \"ENUM\",\n+      \"VECTOR\",\n+      \"SIMPLE_VECTOR\",\n+      \"EMPTY_VECTOR\",\n+      \"TUPLE\",\n+      \"INVALID\"\n+   };\n+\n+uint32_t\n+Message::addData(const DataDescriptor &desc, const void *dataStart, bool needs64BitAlignment)\n+   {\n+   // Write the descriptor itself\n+   uint32_t descOffset = _buffer.writeValue(desc);\n+\n+   //TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"addData(dataStart=%p):  DataDescriptor(@%u): type=%d payload_size=%u dataOffset=%u, padding=%u\",\n+   //   dataStart, descOffset, desc.getDataType(), desc.getPayloadSize(), desc.getDataOffset(), desc.getPaddingSize());\n+\n+   // If the data following the descriptor needs to be 64-bit aligned,\n+   // add some initial padding in the outgoing buffer and write the\n+   // offset to the real payload into the descriptor\n+   uint8_t initialPadding = 0;\n+   if (needs64BitAlignment && !_buffer.is64BitAligned())\n+      {\n+      initialPadding = _buffer.alignCurrentPositionOn64Bit();\n+      TR_ASSERT(initialPadding != 0, \"Initial padding must be non zero because we checked alignment\");\n+      DataDescriptor *serializedDescriptor = _buffer.getValueAtOffset<DataDescriptor>(descOffset);\n+      serializedDescriptor->addInitialPadding(initialPadding);\n+      }\n+\n+   // Write the real data and possibly some padding at the end\n+   _buffer.writeData(dataStart, desc.getPayloadSize(), desc.getPaddingSize()); \n+   _descriptorOffsets.push_back(descOffset);\n+   return desc.getTotalSize() + initialPadding;\n+   }\n+\n+void\n+Message::deserialize()\n+   {\n+   // Assume that buffer is populated with data that defines a valid message\n+   // Reconstruct the message by setting metadata and pointers to descriptors\n+   // Note that the size of the entire message buffer has already been stripped\n+   //\n+   _buffer.readValue<MetaData>(); // This only advances curPtr in the MessageBuffer\n+\n+   uint32_t numDataPoints = getMetaData()->_numDataPoints;\n+\n+   //TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"Metadata: type=%u numDataPoints=%u\\n\", type(), numDataPoints);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14b78a158949a862ee4a58ab036bb658beaee15c"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY0Njk2NQ==", "bodyText": "Done", "url": "https://github.com/eclipse-openj9/openj9/pull/8832#discussion_r393646965", "createdAt": "2020-03-17T12:36:40Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/net/Message.cpp", "diffHunk": "@@ -0,0 +1,139 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"net/Message.hpp\"\n+#include \"infra/Assert.hpp\"\n+#include \"env/VerboseLog.hpp\"\n+\n+namespace JITServer\n+{\n+   const char* const Message::DataDescriptor::_descriptorNames[] = {\n+      \"UINT32\",\n+      \"INT64\",\n+      \"UINT32\",\n+      \"UINT64\",\n+      \"BOOL\",\n+      \"STRING\",\n+      \"OBJECT\",\n+      \"ENUM\",\n+      \"VECTOR\",\n+      \"SIMPLE_VECTOR\",\n+      \"EMPTY_VECTOR\",\n+      \"TUPLE\",\n+      \"INVALID\"\n+   };\n+\n+uint32_t\n+Message::addData(const DataDescriptor &desc, const void *dataStart, bool needs64BitAlignment)\n+   {\n+   // Write the descriptor itself\n+   uint32_t descOffset = _buffer.writeValue(desc);\n+\n+   //TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"addData(dataStart=%p):  DataDescriptor(@%u): type=%d payload_size=%u dataOffset=%u, padding=%u\",\n+   //   dataStart, descOffset, desc.getDataType(), desc.getPayloadSize(), desc.getDataOffset(), desc.getPaddingSize());\n+\n+   // If the data following the descriptor needs to be 64-bit aligned,\n+   // add some initial padding in the outgoing buffer and write the\n+   // offset to the real payload into the descriptor\n+   uint8_t initialPadding = 0;\n+   if (needs64BitAlignment && !_buffer.is64BitAligned())\n+      {\n+      initialPadding = _buffer.alignCurrentPositionOn64Bit();\n+      TR_ASSERT(initialPadding != 0, \"Initial padding must be non zero because we checked alignment\");\n+      DataDescriptor *serializedDescriptor = _buffer.getValueAtOffset<DataDescriptor>(descOffset);\n+      serializedDescriptor->addInitialPadding(initialPadding);\n+      }\n+\n+   // Write the real data and possibly some padding at the end\n+   _buffer.writeData(dataStart, desc.getPayloadSize(), desc.getPaddingSize()); \n+   _descriptorOffsets.push_back(descOffset);\n+   return desc.getTotalSize() + initialPadding;\n+   }\n+\n+void\n+Message::deserialize()\n+   {\n+   // Assume that buffer is populated with data that defines a valid message\n+   // Reconstruct the message by setting metadata and pointers to descriptors\n+   // Note that the size of the entire message buffer has already been stripped\n+   //\n+   _buffer.readValue<MetaData>(); // This only advances curPtr in the MessageBuffer\n+\n+   uint32_t numDataPoints = getMetaData()->_numDataPoints;\n+\n+   //TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"Metadata: type=%u numDataPoints=%u\\n\", type(), numDataPoints);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzI4Mzc3Nw=="}, "originalCommit": {"oid": "14b78a158949a862ee4a58ab036bb658beaee15c"}, "originalPosition": 83}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzNzgyMjg0OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/net/Message.cpp", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQyMDoyMzozNFrOF3EeIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QwMzoxNjozNFrOF3Motw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzI4OTI0OA==", "bodyText": "Why is 64-bit alignment special? If the incoming data requires a certain alignment wouldn't it make it easier to just specify that alignment? It makes it easier for this code to evolve in the future if 64-bits isn't treated so specifically.", "url": "https://github.com/eclipse-openj9/openj9/pull/8832#discussion_r393289248", "createdAt": "2020-03-16T20:23:34Z", "author": {"login": "ymanton"}, "path": "runtime/compiler/net/Message.cpp", "diffHunk": "@@ -0,0 +1,139 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"net/Message.hpp\"\n+#include \"infra/Assert.hpp\"\n+#include \"env/VerboseLog.hpp\"\n+\n+namespace JITServer\n+{\n+   const char* const Message::DataDescriptor::_descriptorNames[] = {\n+      \"UINT32\",\n+      \"INT64\",\n+      \"UINT32\",\n+      \"UINT64\",\n+      \"BOOL\",\n+      \"STRING\",\n+      \"OBJECT\",\n+      \"ENUM\",\n+      \"VECTOR\",\n+      \"SIMPLE_VECTOR\",\n+      \"EMPTY_VECTOR\",\n+      \"TUPLE\",\n+      \"INVALID\"\n+   };\n+\n+uint32_t\n+Message::addData(const DataDescriptor &desc, const void *dataStart, bool needs64BitAlignment)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14b78a158949a862ee4a58ab036bb658beaee15c"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQyMzAzMQ==", "bodyText": "Data points are already padded to 32-bit values in order to be able to access the fields from the descriptor on their natural boundary. However, for 64-bit data we still need to ensure alignment.  Initially I was planning of reordering the fields in a tuple to start with the ones requiring 64-bit alignment first, but that is too much work and error prone. In the end I decided on adding a 32-bit empty slot as padding for cases where 64-bit data is not 64-bit aligned.", "url": "https://github.com/eclipse-openj9/openj9/pull/8832#discussion_r393423031", "createdAt": "2020-03-17T03:16:34Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/net/Message.cpp", "diffHunk": "@@ -0,0 +1,139 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"net/Message.hpp\"\n+#include \"infra/Assert.hpp\"\n+#include \"env/VerboseLog.hpp\"\n+\n+namespace JITServer\n+{\n+   const char* const Message::DataDescriptor::_descriptorNames[] = {\n+      \"UINT32\",\n+      \"INT64\",\n+      \"UINT32\",\n+      \"UINT64\",\n+      \"BOOL\",\n+      \"STRING\",\n+      \"OBJECT\",\n+      \"ENUM\",\n+      \"VECTOR\",\n+      \"SIMPLE_VECTOR\",\n+      \"EMPTY_VECTOR\",\n+      \"TUPLE\",\n+      \"INVALID\"\n+   };\n+\n+uint32_t\n+Message::addData(const DataDescriptor &desc, const void *dataStart, bool needs64BitAlignment)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzI4OTI0OA=="}, "originalCommit": {"oid": "14b78a158949a862ee4a58ab036bb658beaee15c"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzNzgzMjk1OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/net/Message.cpp", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQyMDoyNzoxNVrOF3EkvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxOTowMTo1NFrOF3qDng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzI5MDk0MQ==", "bodyText": "Is there an answer to this question? I'm guessing the vector doesn't need to be cleared and the comment can be removed?", "url": "https://github.com/eclipse-openj9/openj9/pull/8832#discussion_r393290941", "createdAt": "2020-03-16T20:27:15Z", "author": {"login": "ymanton"}, "path": "runtime/compiler/net/Message.cpp", "diffHunk": "@@ -0,0 +1,139 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"net/Message.hpp\"\n+#include \"infra/Assert.hpp\"\n+#include \"env/VerboseLog.hpp\"\n+\n+namespace JITServer\n+{\n+   const char* const Message::DataDescriptor::_descriptorNames[] = {\n+      \"UINT32\",\n+      \"INT64\",\n+      \"UINT32\",\n+      \"UINT64\",\n+      \"BOOL\",\n+      \"STRING\",\n+      \"OBJECT\",\n+      \"ENUM\",\n+      \"VECTOR\",\n+      \"SIMPLE_VECTOR\",\n+      \"EMPTY_VECTOR\",\n+      \"TUPLE\",\n+      \"INVALID\"\n+   };\n+\n+uint32_t\n+Message::addData(const DataDescriptor &desc, const void *dataStart, bool needs64BitAlignment)\n+   {\n+   // Write the descriptor itself\n+   uint32_t descOffset = _buffer.writeValue(desc);\n+\n+   //TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"addData(dataStart=%p):  DataDescriptor(@%u): type=%d payload_size=%u dataOffset=%u, padding=%u\",\n+   //   dataStart, descOffset, desc.getDataType(), desc.getPayloadSize(), desc.getDataOffset(), desc.getPaddingSize());\n+\n+   // If the data following the descriptor needs to be 64-bit aligned,\n+   // add some initial padding in the outgoing buffer and write the\n+   // offset to the real payload into the descriptor\n+   uint8_t initialPadding = 0;\n+   if (needs64BitAlignment && !_buffer.is64BitAligned())\n+      {\n+      initialPadding = _buffer.alignCurrentPositionOn64Bit();\n+      TR_ASSERT(initialPadding != 0, \"Initial padding must be non zero because we checked alignment\");\n+      DataDescriptor *serializedDescriptor = _buffer.getValueAtOffset<DataDescriptor>(descOffset);\n+      serializedDescriptor->addInitialPadding(initialPadding);\n+      }\n+\n+   // Write the real data and possibly some padding at the end\n+   _buffer.writeData(dataStart, desc.getPayloadSize(), desc.getPaddingSize()); \n+   _descriptorOffsets.push_back(descOffset);\n+   return desc.getTotalSize() + initialPadding;\n+   }\n+\n+void\n+Message::deserialize()\n+   {\n+   // Assume that buffer is populated with data that defines a valid message\n+   // Reconstruct the message by setting metadata and pointers to descriptors\n+   // Note that the size of the entire message buffer has already been stripped\n+   //\n+   _buffer.readValue<MetaData>(); // This only advances curPtr in the MessageBuffer\n+\n+   uint32_t numDataPoints = getMetaData()->_numDataPoints;\n+\n+   //TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"Metadata: type=%u numDataPoints=%u\\n\", type(), numDataPoints);\n+\n+   _descriptorOffsets.reserve(numDataPoints);\n+   // TODO: do I need to clear the vector of _descriptorOffsets just in case?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14b78a158949a862ee4a58ab036bb658beaee15c"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQyNTgyMA==", "bodyText": "_descriptorOffsets is cleared in msg.clearForWrite(); right after we send a message (basically we prepare for the next message).\nvoid\nCommunicationStream::writeMessage(Message &msg)\n   {\n   char *serialMsg = msg.serialize();\n   // write serialized message to the socket\n   writeBlocking(serialMsg, msg.serializedSize());\n   msg.clearForWrite();\n   }\n\nI was afraid that it may be possible for the routine above to exit abruptly (through an exception) and the clearing to not be done. Currently the only exception explicitely thrown is\nthrow JITServer::StreamFailure(\"JITServer I/O error: write error\"); which destroys the connection, so we are safe. I don't know if int32_t bytesWritten = (*OBIO_write)(_ssl, data + totalBytesWritten, size - totalBytesWritten); can throw something.\nIn my opinion it's safer to do the clearing just before you need to do the send, but in my tests with SSL enabled I didn't find a case where the existing solution caused a problem.", "url": "https://github.com/eclipse-openj9/openj9/pull/8832#discussion_r393425820", "createdAt": "2020-03-17T03:28:37Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/net/Message.cpp", "diffHunk": "@@ -0,0 +1,139 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"net/Message.hpp\"\n+#include \"infra/Assert.hpp\"\n+#include \"env/VerboseLog.hpp\"\n+\n+namespace JITServer\n+{\n+   const char* const Message::DataDescriptor::_descriptorNames[] = {\n+      \"UINT32\",\n+      \"INT64\",\n+      \"UINT32\",\n+      \"UINT64\",\n+      \"BOOL\",\n+      \"STRING\",\n+      \"OBJECT\",\n+      \"ENUM\",\n+      \"VECTOR\",\n+      \"SIMPLE_VECTOR\",\n+      \"EMPTY_VECTOR\",\n+      \"TUPLE\",\n+      \"INVALID\"\n+   };\n+\n+uint32_t\n+Message::addData(const DataDescriptor &desc, const void *dataStart, bool needs64BitAlignment)\n+   {\n+   // Write the descriptor itself\n+   uint32_t descOffset = _buffer.writeValue(desc);\n+\n+   //TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"addData(dataStart=%p):  DataDescriptor(@%u): type=%d payload_size=%u dataOffset=%u, padding=%u\",\n+   //   dataStart, descOffset, desc.getDataType(), desc.getPayloadSize(), desc.getDataOffset(), desc.getPaddingSize());\n+\n+   // If the data following the descriptor needs to be 64-bit aligned,\n+   // add some initial padding in the outgoing buffer and write the\n+   // offset to the real payload into the descriptor\n+   uint8_t initialPadding = 0;\n+   if (needs64BitAlignment && !_buffer.is64BitAligned())\n+      {\n+      initialPadding = _buffer.alignCurrentPositionOn64Bit();\n+      TR_ASSERT(initialPadding != 0, \"Initial padding must be non zero because we checked alignment\");\n+      DataDescriptor *serializedDescriptor = _buffer.getValueAtOffset<DataDescriptor>(descOffset);\n+      serializedDescriptor->addInitialPadding(initialPadding);\n+      }\n+\n+   // Write the real data and possibly some padding at the end\n+   _buffer.writeData(dataStart, desc.getPayloadSize(), desc.getPaddingSize()); \n+   _descriptorOffsets.push_back(descOffset);\n+   return desc.getTotalSize() + initialPadding;\n+   }\n+\n+void\n+Message::deserialize()\n+   {\n+   // Assume that buffer is populated with data that defines a valid message\n+   // Reconstruct the message by setting metadata and pointers to descriptors\n+   // Note that the size of the entire message buffer has already been stripped\n+   //\n+   _buffer.readValue<MetaData>(); // This only advances curPtr in the MessageBuffer\n+\n+   uint32_t numDataPoints = getMetaData()->_numDataPoints;\n+\n+   //TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"Metadata: type=%u numDataPoints=%u\\n\", type(), numDataPoints);\n+\n+   _descriptorOffsets.reserve(numDataPoints);\n+   // TODO: do I need to clear the vector of _descriptorOffsets just in case?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzI5MDk0MQ=="}, "originalCommit": {"oid": "14b78a158949a862ee4a58ab036bb658beaee15c"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzkwNTA1NA==", "bodyText": "I don't have anything against clearing vector of offsets in Message::deserialize.\nThe functionality of clearForWrite would just need to be spread out between writeMessage and deserialize in that case.", "url": "https://github.com/eclipse-openj9/openj9/pull/8832#discussion_r393905054", "createdAt": "2020-03-17T19:01:54Z", "author": {"login": "dmitry-ten"}, "path": "runtime/compiler/net/Message.cpp", "diffHunk": "@@ -0,0 +1,139 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"net/Message.hpp\"\n+#include \"infra/Assert.hpp\"\n+#include \"env/VerboseLog.hpp\"\n+\n+namespace JITServer\n+{\n+   const char* const Message::DataDescriptor::_descriptorNames[] = {\n+      \"UINT32\",\n+      \"INT64\",\n+      \"UINT32\",\n+      \"UINT64\",\n+      \"BOOL\",\n+      \"STRING\",\n+      \"OBJECT\",\n+      \"ENUM\",\n+      \"VECTOR\",\n+      \"SIMPLE_VECTOR\",\n+      \"EMPTY_VECTOR\",\n+      \"TUPLE\",\n+      \"INVALID\"\n+   };\n+\n+uint32_t\n+Message::addData(const DataDescriptor &desc, const void *dataStart, bool needs64BitAlignment)\n+   {\n+   // Write the descriptor itself\n+   uint32_t descOffset = _buffer.writeValue(desc);\n+\n+   //TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"addData(dataStart=%p):  DataDescriptor(@%u): type=%d payload_size=%u dataOffset=%u, padding=%u\",\n+   //   dataStart, descOffset, desc.getDataType(), desc.getPayloadSize(), desc.getDataOffset(), desc.getPaddingSize());\n+\n+   // If the data following the descriptor needs to be 64-bit aligned,\n+   // add some initial padding in the outgoing buffer and write the\n+   // offset to the real payload into the descriptor\n+   uint8_t initialPadding = 0;\n+   if (needs64BitAlignment && !_buffer.is64BitAligned())\n+      {\n+      initialPadding = _buffer.alignCurrentPositionOn64Bit();\n+      TR_ASSERT(initialPadding != 0, \"Initial padding must be non zero because we checked alignment\");\n+      DataDescriptor *serializedDescriptor = _buffer.getValueAtOffset<DataDescriptor>(descOffset);\n+      serializedDescriptor->addInitialPadding(initialPadding);\n+      }\n+\n+   // Write the real data and possibly some padding at the end\n+   _buffer.writeData(dataStart, desc.getPayloadSize(), desc.getPaddingSize()); \n+   _descriptorOffsets.push_back(descOffset);\n+   return desc.getTotalSize() + initialPadding;\n+   }\n+\n+void\n+Message::deserialize()\n+   {\n+   // Assume that buffer is populated with data that defines a valid message\n+   // Reconstruct the message by setting metadata and pointers to descriptors\n+   // Note that the size of the entire message buffer has already been stripped\n+   //\n+   _buffer.readValue<MetaData>(); // This only advances curPtr in the MessageBuffer\n+\n+   uint32_t numDataPoints = getMetaData()->_numDataPoints;\n+\n+   //TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"Metadata: type=%u numDataPoints=%u\\n\", type(), numDataPoints);\n+\n+   _descriptorOffsets.reserve(numDataPoints);\n+   // TODO: do I need to clear the vector of _descriptorOffsets just in case?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzI5MDk0MQ=="}, "originalCommit": {"oid": "14b78a158949a862ee4a58ab036bb658beaee15c"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzNzgzOTI5OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/net/Message.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQyMDoyOTozMlrOF3EosQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxMjozNzowMVrOF3aUGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzI5MTk1Mw==", "bodyText": "\"UINT32\" appears twice, the corresponding enum has INT32 in this position.", "url": "https://github.com/eclipse-openj9/openj9/pull/8832#discussion_r393291953", "createdAt": "2020-03-16T20:29:32Z", "author": {"login": "ymanton"}, "path": "runtime/compiler/net/Message.cpp", "diffHunk": "@@ -0,0 +1,139 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"net/Message.hpp\"\n+#include \"infra/Assert.hpp\"\n+#include \"env/VerboseLog.hpp\"\n+\n+namespace JITServer\n+{\n+   const char* const Message::DataDescriptor::_descriptorNames[] = {\n+      \"UINT32\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14b78a158949a862ee4a58ab036bb658beaee15c"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY0NzEzMA==", "bodyText": "Done", "url": "https://github.com/eclipse-openj9/openj9/pull/8832#discussion_r393647130", "createdAt": "2020-03-17T12:37:01Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/net/Message.cpp", "diffHunk": "@@ -0,0 +1,139 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"net/Message.hpp\"\n+#include \"infra/Assert.hpp\"\n+#include \"env/VerboseLog.hpp\"\n+\n+namespace JITServer\n+{\n+   const char* const Message::DataDescriptor::_descriptorNames[] = {\n+      \"UINT32\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzI5MTk1Mw=="}, "originalCommit": {"oid": "14b78a158949a862ee4a58ab036bb658beaee15c"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzNzg1NTY1OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/net/Message.hpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQyMDozNToyOFrOF3EzBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxMjozNzoxMVrOF3aUbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzI5NDU5OQ==", "bodyText": "Is this supposed to be used to access one of the existing offsets or the empty space in the vector? An assert checking against either size() or capacity() would help clarify and catch OOB indices.", "url": "https://github.com/eclipse-openj9/openj9/pull/8832#discussion_r393294599", "createdAt": "2020-03-16T20:35:28Z", "author": {"login": "ymanton"}, "path": "runtime/compiler/net/Message.hpp", "diffHunk": "@@ -0,0 +1,376 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#ifndef MESSAGE_H\n+#define MESSAGE_H\n+\n+#include <vector>\n+#include <stdlib.h>\n+#include \"net/MessageBuffer.hpp\"\n+#include \"net/MessageTypes.hpp\"\n+\n+namespace JITServer\n+{\n+/**\n+   @class Message\n+   @brief Representation of a JITServer remote message.\n+   \n+   All of the actual data and metadata is stored inside MessageBuffer,\n+   this class just provides an interface to access/add it.\n+   This is done to minimize the amount of copying when sending/receiving\n+   messages over the network.\n+\n+   Each message contains an offset to metadata and a vector of offsets to data descriptors,\n+   where each descriptor describes a single value sent inside the message.\n+*/\n+class Message\n+   {\n+public:\n+   /**\n+      @class MetaData\n+      @brief Describes general parameters of a message: number of datapoints, message type, and version.\n+\n+      It is assumed that the MetaData immediately follows the messages size\n+      which is encoded as a uint32_t\n+   */\n+   struct MetaData\n+      {\n+      MetaData() :\n+         _version(0), _config(0), _type(MessageType_MAXTYPE), _numDataPoints(0)\n+         {}\n+      uint32_t _version;\n+      uint32_t _config; // includes JITServerCompatibilityFlags which must match\n+      MessageType _type; // uint16_t\n+      uint16_t _numDataPoints; // number of data points in a message\n+      };\n+\n+   /**\n+   @brief Utility function that builds the \"full version\" of client/server as \n+   a composition of the version number and compatibility flags.\n+   */\n+   static uint64_t buildFullVersion(uint32_t version, uint32_t config) \n+      { \n+      return (((uint64_t)config) << 32) | version;\n+      }\n+\n+   /**\n+      @class DataDescriptor\n+      @brief Metadata containing the type and size of a single value in a message\n+\n+      A DataDescriptor needs to be aligned on a 32-bit boundary. Because of this\n+      requirement, the data following the descriptor needs to be padded to a \n+      32-bit boundary\n+   */\n+   struct DataDescriptor\n+      {\n+      // Data types that can be sent in a message\n+      // Adding new types is possible, as long as\n+      // serialization/deserialization functions\n+      // are added to RawTypeConvert\n+      enum DataType : uint8_t\n+         {\n+         INT32,\n+         INT64,\n+         UINT32,\n+         UINT64,\n+         BOOL,\n+         STRING,\n+         OBJECT, // only trivially-copyable; pointers fall into this category\n+         ENUM,\n+         VECTOR,\n+         SIMPLE_VECTOR, // vector whose elements are trivially-copyable and less than 256 bytes\n+         EMPTY_VECTOR,\n+         TUPLE,\n+         LAST_TYPE\n+         };\n+      static const char* const _descriptorNames[];\n+      /**\n+         @brief Constructor\n+\n+         @param type The type of the data described by the descriptor\n+         @param payloadSize Size of the real data (excluding any required padding)\n+\n+      */\n+      DataDescriptor(DataType type, uint32_t payloadSize) : _type(type), _dataOffset(0), _vectorElementSize(0)\n+         {\n+         // align on 4 byte boundary\n+         _size = (payloadSize + 3) & 0xfffffffc;\n+         _paddingSize = static_cast<uint8_t>(_size - payloadSize);    \n+         }\n+      DataType getDataType() const { return _type; }\n+      uint32_t getPayloadSize() const { return _size - _paddingSize - _dataOffset; }\n+      uint32_t getTotalSize() const { return _size; }\n+      uint8_t getPaddingSize() const { return _paddingSize; }\n+      uint8_t getDataOffset() const { return _dataOffset; }\n+      uint8_t getVectorElementSize() const { return _vectorElementSize; }\n+      void setVectorElementSize(uint8_t sz) { _vectorElementSize = sz; }\n+\n+      /**\n+         @brief Initialize descriptor with values give as parameters.\n+\n+         @param type   The type of data described by descriptor\n+         @param totalSize   Total size of data following the descriptor\n+         @param paddingSize   Size of padding added after the real payload (included in totalSize)\n+         @param dataOffset   Distance from end of descriptor to start of real payload (included in totalSize)\n+      */\n+      void init(DataType type, uint32_t totalSize, uint8_t paddingSize, uint8_t dataOffset)\n+         {\n+         _type = type;\n+         _paddingSize = paddingSize;\n+         _dataOffset = dataOffset;\n+         _vectorElementSize = 0;\n+         _size = totalSize;\n+         }\n+\n+      /**\n+         @brief Adjust an existing descriptor by adding some offset to real payload\n+\n+         @param initialPadding   Distance from end of descriptor to start of real payload (included in totalSize)\n+      */\n+      void addInitialPadding(uint8_t initialPadding)\n+         {\n+         TR_ASSERT(_dataOffset == 0, \"Initial padding added twice\");\n+         TR_ASSERT(initialPadding == 4, \"Current implementation assumes only 4 bytes of padding\"); // because we add 4 bytes to align on a 8-byte boundary\n+         _dataOffset = initialPadding;\n+         _size += initialPadding; // Total size increases as well\n+         }\n+\n+      /**\n+         @brief Tells if data attached to this descriptor is a type that\n+         can be directly copied from its address into the contiguous buffer.\n+\n+         Currently, vectors and tuples are the only non-primitive supported types.\n+         Note: while vectors of primitive types could be copied directly if you copy\n+         from &v[0], it will not work if it's a vector of vectors, or a vector of tuples.\n+\n+         @return Whether the data descriptor is primitive\n+      */\n+      bool isPrimitive() const { return _type != VECTOR && _type != TUPLE; }\n+\n+      /**\n+         @brief Get the pointer to the beginning of data attached to this descriptor.\n+\n+         This assumes that the data is located after the descriptor at some\n+         some offset, no more than 255 bytes away (typically such offset is 0).\n+         This allows us to align data on a natural boundary.\n+\n+         @return A pointer to the beginning of the data\n+      */\n+      void *getDataStart()\n+         {\n+         return static_cast<void *>(static_cast<char*>(static_cast<void*>(this + 1)) + _dataOffset);\n+         }\n+\n+      /**\n+          @brief Get a pointer to the beginning of the next descriptor in the MessageBuffer.\n+\n+          @return Returns a pointer to the following descriptor in the MessageBuffer\n+      */\n+      DataDescriptor* getNextDescriptor()\n+         {\n+         return static_cast<DataDescriptor*>(static_cast<void*>(static_cast<char*>(static_cast<void*>(this + 1)) + _size));\n+         }\n+\n+      uint32_t print(uint32_t nestingLevel);\n+      private:\n+      DataType _type; // Message type on 8 bits\n+      uint8_t  _paddingSize; // How many bytes are actually used for padding (0-3)\n+      uint8_t  _dataOffset; // Offset from DataDescriptor to actual data\n+      uint8_t  _vectorElementSize; // Size of an element for SIMPLE_VECTORs\n+      uint32_t _size; // Size of the data segment, which can include nested data\n+      }; // struct DataDescriptor\n+\n+   Message()\n+      {\n+      // Reserve space for encoding the size and MetaData.\n+      // These will be populated at a later time\n+      _buffer.reserveValue<uint32_t>(); // Reserve space for encoding the size\n+      _buffer.reserveValue<Message::MetaData>();\n+      }\n+\n+   MetaData *getMetaData() const\n+      {\n+      return _buffer.getValueAtOffset<MetaData>(sizeof(uint32_t)); // sizeof(uint32_t) represents the space for message size\n+      }\n+\n+   /**\n+      @brief Add a new data point to the message.\n+\n+      Writes the descriptor and attached data to the MessageBuffer\n+      and updates the message structure. If the attached data is not\n+      aligned on a 32-bit boundary, some padding will be written as well.\n+\n+      @param desc Descriptor for the new data\n+      @param dataStart Pointer to the new data\n+      @param needs64BitAlignment Whether data following the descriptor needs to be 64-bit aligned\n+\n+      @return The total amount of data written (including padding, but not including the descriptor)\n+   */\n+   uint32_t addData(const DataDescriptor &desc, const void *dataStart, bool needs64BitAlignment = false);\n+\n+   /**\n+      @brief Allocate space for a descriptor in the MessageBuffer\n+      and update the message structure without writing any actual data.\n+\n+      This method is needed for some specific cases, mainly for writing\n+      non-primitive data points.\n+\n+      @return The offset to the descriptor reserved\n+   */\n+   uint32_t reserveDescriptor()\n+      {\n+      uint32_t descOffset = _buffer.reserveValue<DataDescriptor>();\n+      _descriptorOffsets.push_back(descOffset);\n+      return descOffset;\n+      }\n+\n+   /**\n+      @brief Get a pointer to the descriptor at given index\n+\n+      @param idx Index of the descriptor\n+\n+      @return A pointer to the descriptor\n+   */\n+   DataDescriptor *getDescriptor(size_t idx) const\n+      {\n+      uint32_t offset = _descriptorOffsets[idx];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14b78a158949a862ee4a58ab036bb658beaee15c"}, "originalPosition": 255}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY0NzIxNA==", "bodyText": "Done", "url": "https://github.com/eclipse-openj9/openj9/pull/8832#discussion_r393647214", "createdAt": "2020-03-17T12:37:11Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/net/Message.hpp", "diffHunk": "@@ -0,0 +1,376 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#ifndef MESSAGE_H\n+#define MESSAGE_H\n+\n+#include <vector>\n+#include <stdlib.h>\n+#include \"net/MessageBuffer.hpp\"\n+#include \"net/MessageTypes.hpp\"\n+\n+namespace JITServer\n+{\n+/**\n+   @class Message\n+   @brief Representation of a JITServer remote message.\n+   \n+   All of the actual data and metadata is stored inside MessageBuffer,\n+   this class just provides an interface to access/add it.\n+   This is done to minimize the amount of copying when sending/receiving\n+   messages over the network.\n+\n+   Each message contains an offset to metadata and a vector of offsets to data descriptors,\n+   where each descriptor describes a single value sent inside the message.\n+*/\n+class Message\n+   {\n+public:\n+   /**\n+      @class MetaData\n+      @brief Describes general parameters of a message: number of datapoints, message type, and version.\n+\n+      It is assumed that the MetaData immediately follows the messages size\n+      which is encoded as a uint32_t\n+   */\n+   struct MetaData\n+      {\n+      MetaData() :\n+         _version(0), _config(0), _type(MessageType_MAXTYPE), _numDataPoints(0)\n+         {}\n+      uint32_t _version;\n+      uint32_t _config; // includes JITServerCompatibilityFlags which must match\n+      MessageType _type; // uint16_t\n+      uint16_t _numDataPoints; // number of data points in a message\n+      };\n+\n+   /**\n+   @brief Utility function that builds the \"full version\" of client/server as \n+   a composition of the version number and compatibility flags.\n+   */\n+   static uint64_t buildFullVersion(uint32_t version, uint32_t config) \n+      { \n+      return (((uint64_t)config) << 32) | version;\n+      }\n+\n+   /**\n+      @class DataDescriptor\n+      @brief Metadata containing the type and size of a single value in a message\n+\n+      A DataDescriptor needs to be aligned on a 32-bit boundary. Because of this\n+      requirement, the data following the descriptor needs to be padded to a \n+      32-bit boundary\n+   */\n+   struct DataDescriptor\n+      {\n+      // Data types that can be sent in a message\n+      // Adding new types is possible, as long as\n+      // serialization/deserialization functions\n+      // are added to RawTypeConvert\n+      enum DataType : uint8_t\n+         {\n+         INT32,\n+         INT64,\n+         UINT32,\n+         UINT64,\n+         BOOL,\n+         STRING,\n+         OBJECT, // only trivially-copyable; pointers fall into this category\n+         ENUM,\n+         VECTOR,\n+         SIMPLE_VECTOR, // vector whose elements are trivially-copyable and less than 256 bytes\n+         EMPTY_VECTOR,\n+         TUPLE,\n+         LAST_TYPE\n+         };\n+      static const char* const _descriptorNames[];\n+      /**\n+         @brief Constructor\n+\n+         @param type The type of the data described by the descriptor\n+         @param payloadSize Size of the real data (excluding any required padding)\n+\n+      */\n+      DataDescriptor(DataType type, uint32_t payloadSize) : _type(type), _dataOffset(0), _vectorElementSize(0)\n+         {\n+         // align on 4 byte boundary\n+         _size = (payloadSize + 3) & 0xfffffffc;\n+         _paddingSize = static_cast<uint8_t>(_size - payloadSize);    \n+         }\n+      DataType getDataType() const { return _type; }\n+      uint32_t getPayloadSize() const { return _size - _paddingSize - _dataOffset; }\n+      uint32_t getTotalSize() const { return _size; }\n+      uint8_t getPaddingSize() const { return _paddingSize; }\n+      uint8_t getDataOffset() const { return _dataOffset; }\n+      uint8_t getVectorElementSize() const { return _vectorElementSize; }\n+      void setVectorElementSize(uint8_t sz) { _vectorElementSize = sz; }\n+\n+      /**\n+         @brief Initialize descriptor with values give as parameters.\n+\n+         @param type   The type of data described by descriptor\n+         @param totalSize   Total size of data following the descriptor\n+         @param paddingSize   Size of padding added after the real payload (included in totalSize)\n+         @param dataOffset   Distance from end of descriptor to start of real payload (included in totalSize)\n+      */\n+      void init(DataType type, uint32_t totalSize, uint8_t paddingSize, uint8_t dataOffset)\n+         {\n+         _type = type;\n+         _paddingSize = paddingSize;\n+         _dataOffset = dataOffset;\n+         _vectorElementSize = 0;\n+         _size = totalSize;\n+         }\n+\n+      /**\n+         @brief Adjust an existing descriptor by adding some offset to real payload\n+\n+         @param initialPadding   Distance from end of descriptor to start of real payload (included in totalSize)\n+      */\n+      void addInitialPadding(uint8_t initialPadding)\n+         {\n+         TR_ASSERT(_dataOffset == 0, \"Initial padding added twice\");\n+         TR_ASSERT(initialPadding == 4, \"Current implementation assumes only 4 bytes of padding\"); // because we add 4 bytes to align on a 8-byte boundary\n+         _dataOffset = initialPadding;\n+         _size += initialPadding; // Total size increases as well\n+         }\n+\n+      /**\n+         @brief Tells if data attached to this descriptor is a type that\n+         can be directly copied from its address into the contiguous buffer.\n+\n+         Currently, vectors and tuples are the only non-primitive supported types.\n+         Note: while vectors of primitive types could be copied directly if you copy\n+         from &v[0], it will not work if it's a vector of vectors, or a vector of tuples.\n+\n+         @return Whether the data descriptor is primitive\n+      */\n+      bool isPrimitive() const { return _type != VECTOR && _type != TUPLE; }\n+\n+      /**\n+         @brief Get the pointer to the beginning of data attached to this descriptor.\n+\n+         This assumes that the data is located after the descriptor at some\n+         some offset, no more than 255 bytes away (typically such offset is 0).\n+         This allows us to align data on a natural boundary.\n+\n+         @return A pointer to the beginning of the data\n+      */\n+      void *getDataStart()\n+         {\n+         return static_cast<void *>(static_cast<char*>(static_cast<void*>(this + 1)) + _dataOffset);\n+         }\n+\n+      /**\n+          @brief Get a pointer to the beginning of the next descriptor in the MessageBuffer.\n+\n+          @return Returns a pointer to the following descriptor in the MessageBuffer\n+      */\n+      DataDescriptor* getNextDescriptor()\n+         {\n+         return static_cast<DataDescriptor*>(static_cast<void*>(static_cast<char*>(static_cast<void*>(this + 1)) + _size));\n+         }\n+\n+      uint32_t print(uint32_t nestingLevel);\n+      private:\n+      DataType _type; // Message type on 8 bits\n+      uint8_t  _paddingSize; // How many bytes are actually used for padding (0-3)\n+      uint8_t  _dataOffset; // Offset from DataDescriptor to actual data\n+      uint8_t  _vectorElementSize; // Size of an element for SIMPLE_VECTORs\n+      uint32_t _size; // Size of the data segment, which can include nested data\n+      }; // struct DataDescriptor\n+\n+   Message()\n+      {\n+      // Reserve space for encoding the size and MetaData.\n+      // These will be populated at a later time\n+      _buffer.reserveValue<uint32_t>(); // Reserve space for encoding the size\n+      _buffer.reserveValue<Message::MetaData>();\n+      }\n+\n+   MetaData *getMetaData() const\n+      {\n+      return _buffer.getValueAtOffset<MetaData>(sizeof(uint32_t)); // sizeof(uint32_t) represents the space for message size\n+      }\n+\n+   /**\n+      @brief Add a new data point to the message.\n+\n+      Writes the descriptor and attached data to the MessageBuffer\n+      and updates the message structure. If the attached data is not\n+      aligned on a 32-bit boundary, some padding will be written as well.\n+\n+      @param desc Descriptor for the new data\n+      @param dataStart Pointer to the new data\n+      @param needs64BitAlignment Whether data following the descriptor needs to be 64-bit aligned\n+\n+      @return The total amount of data written (including padding, but not including the descriptor)\n+   */\n+   uint32_t addData(const DataDescriptor &desc, const void *dataStart, bool needs64BitAlignment = false);\n+\n+   /**\n+      @brief Allocate space for a descriptor in the MessageBuffer\n+      and update the message structure without writing any actual data.\n+\n+      This method is needed for some specific cases, mainly for writing\n+      non-primitive data points.\n+\n+      @return The offset to the descriptor reserved\n+   */\n+   uint32_t reserveDescriptor()\n+      {\n+      uint32_t descOffset = _buffer.reserveValue<DataDescriptor>();\n+      _descriptorOffsets.push_back(descOffset);\n+      return descOffset;\n+      }\n+\n+   /**\n+      @brief Get a pointer to the descriptor at given index\n+\n+      @param idx Index of the descriptor\n+\n+      @return A pointer to the descriptor\n+   */\n+   DataDescriptor *getDescriptor(size_t idx) const\n+      {\n+      uint32_t offset = _descriptorOffsets[idx];", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzI5NDU5OQ=="}, "originalCommit": {"oid": "14b78a158949a862ee4a58ab036bb658beaee15c"}, "originalPosition": 255}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzNzg5OTEyOnYy", "diffSide": "RIGHT", "path": "runtime/compiler/net/Message.hpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQyMDo0ODoyOVrOF3FOTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxMjozNzoyNFrOF3aU3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzMwMTU4Mw==", "bodyText": "Can we get rid of these comments? They don't add much.", "url": "https://github.com/eclipse-openj9/openj9/pull/8832#discussion_r393301583", "createdAt": "2020-03-16T20:48:29Z", "author": {"login": "ymanton"}, "path": "runtime/compiler/net/Message.hpp", "diffHunk": "@@ -0,0 +1,376 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#ifndef MESSAGE_H\n+#define MESSAGE_H\n+\n+#include <vector>\n+#include <stdlib.h>\n+#include \"net/MessageBuffer.hpp\"\n+#include \"net/MessageTypes.hpp\"\n+\n+namespace JITServer\n+{\n+/**\n+   @class Message\n+   @brief Representation of a JITServer remote message.\n+   \n+   All of the actual data and metadata is stored inside MessageBuffer,\n+   this class just provides an interface to access/add it.\n+   This is done to minimize the amount of copying when sending/receiving\n+   messages over the network.\n+\n+   Each message contains an offset to metadata and a vector of offsets to data descriptors,\n+   where each descriptor describes a single value sent inside the message.\n+*/\n+class Message\n+   {\n+public:\n+   /**\n+      @class MetaData\n+      @brief Describes general parameters of a message: number of datapoints, message type, and version.\n+\n+      It is assumed that the MetaData immediately follows the messages size\n+      which is encoded as a uint32_t\n+   */\n+   struct MetaData\n+      {\n+      MetaData() :\n+         _version(0), _config(0), _type(MessageType_MAXTYPE), _numDataPoints(0)\n+         {}\n+      uint32_t _version;\n+      uint32_t _config; // includes JITServerCompatibilityFlags which must match\n+      MessageType _type; // uint16_t\n+      uint16_t _numDataPoints; // number of data points in a message", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14b78a158949a862ee4a58ab036bb658beaee15c"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY0NzMyNA==", "bodyText": "Done", "url": "https://github.com/eclipse-openj9/openj9/pull/8832#discussion_r393647324", "createdAt": "2020-03-17T12:37:24Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/net/Message.hpp", "diffHunk": "@@ -0,0 +1,376 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#ifndef MESSAGE_H\n+#define MESSAGE_H\n+\n+#include <vector>\n+#include <stdlib.h>\n+#include \"net/MessageBuffer.hpp\"\n+#include \"net/MessageTypes.hpp\"\n+\n+namespace JITServer\n+{\n+/**\n+   @class Message\n+   @brief Representation of a JITServer remote message.\n+   \n+   All of the actual data and metadata is stored inside MessageBuffer,\n+   this class just provides an interface to access/add it.\n+   This is done to minimize the amount of copying when sending/receiving\n+   messages over the network.\n+\n+   Each message contains an offset to metadata and a vector of offsets to data descriptors,\n+   where each descriptor describes a single value sent inside the message.\n+*/\n+class Message\n+   {\n+public:\n+   /**\n+      @class MetaData\n+      @brief Describes general parameters of a message: number of datapoints, message type, and version.\n+\n+      It is assumed that the MetaData immediately follows the messages size\n+      which is encoded as a uint32_t\n+   */\n+   struct MetaData\n+      {\n+      MetaData() :\n+         _version(0), _config(0), _type(MessageType_MAXTYPE), _numDataPoints(0)\n+         {}\n+      uint32_t _version;\n+      uint32_t _config; // includes JITServerCompatibilityFlags which must match\n+      MessageType _type; // uint16_t\n+      uint16_t _numDataPoints; // number of data points in a message", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzMwMTU4Mw=="}, "originalCommit": {"oid": "14b78a158949a862ee4a58ab036bb658beaee15c"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzNzkyNTc4OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/net/Message.hpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQyMDo1NjozOVrOF3Fe2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxMjozNzo0MVrOF3aVaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzMwNTgxOQ==", "bodyText": "Can we add some sort of constant that clearly defines what alignment this is exactly? I see 3 and 4 and 0xfffffffc and a lot of sizeof(uint32_t) that seem to all be related to the alignment of the buffer, we're allocating to hold the message, but it would be better if that sort of thing was defined in one place.", "url": "https://github.com/eclipse-openj9/openj9/pull/8832#discussion_r393305819", "createdAt": "2020-03-16T20:56:39Z", "author": {"login": "ymanton"}, "path": "runtime/compiler/net/Message.hpp", "diffHunk": "@@ -0,0 +1,376 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#ifndef MESSAGE_H\n+#define MESSAGE_H\n+\n+#include <vector>\n+#include <stdlib.h>\n+#include \"net/MessageBuffer.hpp\"\n+#include \"net/MessageTypes.hpp\"\n+\n+namespace JITServer\n+{\n+/**\n+   @class Message\n+   @brief Representation of a JITServer remote message.\n+   \n+   All of the actual data and metadata is stored inside MessageBuffer,\n+   this class just provides an interface to access/add it.\n+   This is done to minimize the amount of copying when sending/receiving\n+   messages over the network.\n+\n+   Each message contains an offset to metadata and a vector of offsets to data descriptors,\n+   where each descriptor describes a single value sent inside the message.\n+*/\n+class Message\n+   {\n+public:\n+   /**\n+      @class MetaData\n+      @brief Describes general parameters of a message: number of datapoints, message type, and version.\n+\n+      It is assumed that the MetaData immediately follows the messages size\n+      which is encoded as a uint32_t\n+   */\n+   struct MetaData\n+      {\n+      MetaData() :\n+         _version(0), _config(0), _type(MessageType_MAXTYPE), _numDataPoints(0)\n+         {}\n+      uint32_t _version;\n+      uint32_t _config; // includes JITServerCompatibilityFlags which must match\n+      MessageType _type; // uint16_t\n+      uint16_t _numDataPoints; // number of data points in a message\n+      };\n+\n+   /**\n+   @brief Utility function that builds the \"full version\" of client/server as \n+   a composition of the version number and compatibility flags.\n+   */\n+   static uint64_t buildFullVersion(uint32_t version, uint32_t config) \n+      { \n+      return (((uint64_t)config) << 32) | version;\n+      }\n+\n+   /**\n+      @class DataDescriptor\n+      @brief Metadata containing the type and size of a single value in a message\n+\n+      A DataDescriptor needs to be aligned on a 32-bit boundary. Because of this\n+      requirement, the data following the descriptor needs to be padded to a \n+      32-bit boundary\n+   */\n+   struct DataDescriptor\n+      {\n+      // Data types that can be sent in a message\n+      // Adding new types is possible, as long as\n+      // serialization/deserialization functions\n+      // are added to RawTypeConvert\n+      enum DataType : uint8_t\n+         {\n+         INT32,\n+         INT64,\n+         UINT32,\n+         UINT64,\n+         BOOL,\n+         STRING,\n+         OBJECT, // only trivially-copyable; pointers fall into this category\n+         ENUM,\n+         VECTOR,\n+         SIMPLE_VECTOR, // vector whose elements are trivially-copyable and less than 256 bytes\n+         EMPTY_VECTOR,\n+         TUPLE,\n+         LAST_TYPE\n+         };\n+      static const char* const _descriptorNames[];\n+      /**\n+         @brief Constructor\n+\n+         @param type The type of the data described by the descriptor\n+         @param payloadSize Size of the real data (excluding any required padding)\n+\n+      */\n+      DataDescriptor(DataType type, uint32_t payloadSize) : _type(type), _dataOffset(0), _vectorElementSize(0)\n+         {\n+         // align on 4 byte boundary\n+         _size = (payloadSize + 3) & 0xfffffffc;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14b78a158949a862ee4a58ab036bb658beaee15c"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY0NzQ2NQ==", "bodyText": "Done", "url": "https://github.com/eclipse-openj9/openj9/pull/8832#discussion_r393647465", "createdAt": "2020-03-17T12:37:41Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/net/Message.hpp", "diffHunk": "@@ -0,0 +1,376 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#ifndef MESSAGE_H\n+#define MESSAGE_H\n+\n+#include <vector>\n+#include <stdlib.h>\n+#include \"net/MessageBuffer.hpp\"\n+#include \"net/MessageTypes.hpp\"\n+\n+namespace JITServer\n+{\n+/**\n+   @class Message\n+   @brief Representation of a JITServer remote message.\n+   \n+   All of the actual data and metadata is stored inside MessageBuffer,\n+   this class just provides an interface to access/add it.\n+   This is done to minimize the amount of copying when sending/receiving\n+   messages over the network.\n+\n+   Each message contains an offset to metadata and a vector of offsets to data descriptors,\n+   where each descriptor describes a single value sent inside the message.\n+*/\n+class Message\n+   {\n+public:\n+   /**\n+      @class MetaData\n+      @brief Describes general parameters of a message: number of datapoints, message type, and version.\n+\n+      It is assumed that the MetaData immediately follows the messages size\n+      which is encoded as a uint32_t\n+   */\n+   struct MetaData\n+      {\n+      MetaData() :\n+         _version(0), _config(0), _type(MessageType_MAXTYPE), _numDataPoints(0)\n+         {}\n+      uint32_t _version;\n+      uint32_t _config; // includes JITServerCompatibilityFlags which must match\n+      MessageType _type; // uint16_t\n+      uint16_t _numDataPoints; // number of data points in a message\n+      };\n+\n+   /**\n+   @brief Utility function that builds the \"full version\" of client/server as \n+   a composition of the version number and compatibility flags.\n+   */\n+   static uint64_t buildFullVersion(uint32_t version, uint32_t config) \n+      { \n+      return (((uint64_t)config) << 32) | version;\n+      }\n+\n+   /**\n+      @class DataDescriptor\n+      @brief Metadata containing the type and size of a single value in a message\n+\n+      A DataDescriptor needs to be aligned on a 32-bit boundary. Because of this\n+      requirement, the data following the descriptor needs to be padded to a \n+      32-bit boundary\n+   */\n+   struct DataDescriptor\n+      {\n+      // Data types that can be sent in a message\n+      // Adding new types is possible, as long as\n+      // serialization/deserialization functions\n+      // are added to RawTypeConvert\n+      enum DataType : uint8_t\n+         {\n+         INT32,\n+         INT64,\n+         UINT32,\n+         UINT64,\n+         BOOL,\n+         STRING,\n+         OBJECT, // only trivially-copyable; pointers fall into this category\n+         ENUM,\n+         VECTOR,\n+         SIMPLE_VECTOR, // vector whose elements are trivially-copyable and less than 256 bytes\n+         EMPTY_VECTOR,\n+         TUPLE,\n+         LAST_TYPE\n+         };\n+      static const char* const _descriptorNames[];\n+      /**\n+         @brief Constructor\n+\n+         @param type The type of the data described by the descriptor\n+         @param payloadSize Size of the real data (excluding any required padding)\n+\n+      */\n+      DataDescriptor(DataType type, uint32_t payloadSize) : _type(type), _dataOffset(0), _vectorElementSize(0)\n+         {\n+         // align on 4 byte boundary\n+         _size = (payloadSize + 3) & 0xfffffffc;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzMwNTgxOQ=="}, "originalCommit": {"oid": "14b78a158949a862ee4a58ab036bb658beaee15c"}, "originalPosition": 116}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzNzk0ODMyOnYy", "diffSide": "RIGHT", "path": "runtime/compiler/net/MessageBuffer.hpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQyMTowNDozMFrOF3FtUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxMjozODowN1rOF3aWRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzMwOTUyMg==", "bodyText": "Can we use symbols for the 3 and 0xfffffffc and add static_assert(std::is_trivially_copyable<T>::value == true, \"T must be trivially copyable.\");?", "url": "https://github.com/eclipse-openj9/openj9/pull/8832#discussion_r393309522", "createdAt": "2020-03-16T21:04:30Z", "author": {"login": "ymanton"}, "path": "runtime/compiler/net/MessageBuffer.hpp", "diffHunk": "@@ -0,0 +1,199 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#ifndef MESSAGE_BUFFER_H\n+#define MESSAGE_BUFFER_H\n+\n+#include \"env/jittypes.h\"\n+#include \"env/TRMemory.hpp\"\n+\n+namespace JITServer\n+{\n+/**\n+   @class MessageBuffer\n+   @brief A wrapper around a contiguous, persistent memory allocated buffer\n+   for storing a JITServer message.\n+\n+   The buffer is extensible, i.e. when the current capacity is reached, a new,\n+   larger buffer can be allocated and data copied there.\n+   Since reallocation causes addresses of values inside the buffer to change, read/write operations\n+   return an offset into the buffer to indicate the location of data, instead of pointers.\n+\n+   Method getValueAtOffset returns a pointer to data at a given offset, but be mindful that\n+   the pointer might become invalid if more data is added to the buffer.\n+\n+   Variable _curPtr defines the boundary of the current data. Reading/writing to/from buffer\n+   will always advance the pointer.\n+ */\n+class MessageBuffer\n+   {\n+public:\n+   MessageBuffer();\n+\n+   ~MessageBuffer()\n+      {\n+      TR_Memory::jitPersistentFree(_storage);\n+      }\n+\n+\n+   /**\n+      @brief Get the current active size of the buffer.\n+\n+      Note: this returns the number of bytes written to the buffer so far,\n+      NOT the overall capacity of the buffer. Capacity is the number of\n+      bytes allocated, but not necessarily used.\n+\n+      @return the size of the buffer\n+   */\n+   uint32_t size() const { return _curPtr - _storage; }\n+\n+   char *getBufferStart() const { return _storage; }\n+\n+   /**\n+      @brief Return a pointer to the value at given offset inside the buffer.\n+\n+      Given a type and offset, returns the pointer of that type.\n+      Behavior is only defined if offset does not exceed populated buffer size.\n+\n+      @return ponter of the specified type at given offset\n+   */\n+   template <typename T>\n+   T *getValueAtOffset(uint32_t offset) const\n+      {\n+      TR_ASSERT_FATAL(offset < size(), \"Offset is outside of buffer bounds\");\n+      return reinterpret_cast<T *>(_storage + offset);\n+      }\n+\n+   /**\n+      @brief Write value of type T to the buffer.\n+\n+      Copies the value into buffer, expanding it if needed,\n+      and advances _curPtr by sizeof(T) bytes plus some padding\n+      so that the data inside the buffer is always 32-bit aligned\n+      Behavior is undefined if T is not trivially copyable (i.e. not contiguous in memory).\n+\n+      @param val value to be written\n+\n+      @return offset to the beginning of written value inside the buffer\n+   */\n+   template <typename T>\n+   uint32_t writeValue(const T &val)\n+      {\n+      uint8_t paddingSize = static_cast<uint8_t>(((sizeof(T) + 3) & 0xfffffffc) - sizeof(T));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14b78a158949a862ee4a58ab036bb658beaee15c"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY0NzY4Ng==", "bodyText": "Done", "url": "https://github.com/eclipse-openj9/openj9/pull/8832#discussion_r393647686", "createdAt": "2020-03-17T12:38:07Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/net/MessageBuffer.hpp", "diffHunk": "@@ -0,0 +1,199 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#ifndef MESSAGE_BUFFER_H\n+#define MESSAGE_BUFFER_H\n+\n+#include \"env/jittypes.h\"\n+#include \"env/TRMemory.hpp\"\n+\n+namespace JITServer\n+{\n+/**\n+   @class MessageBuffer\n+   @brief A wrapper around a contiguous, persistent memory allocated buffer\n+   for storing a JITServer message.\n+\n+   The buffer is extensible, i.e. when the current capacity is reached, a new,\n+   larger buffer can be allocated and data copied there.\n+   Since reallocation causes addresses of values inside the buffer to change, read/write operations\n+   return an offset into the buffer to indicate the location of data, instead of pointers.\n+\n+   Method getValueAtOffset returns a pointer to data at a given offset, but be mindful that\n+   the pointer might become invalid if more data is added to the buffer.\n+\n+   Variable _curPtr defines the boundary of the current data. Reading/writing to/from buffer\n+   will always advance the pointer.\n+ */\n+class MessageBuffer\n+   {\n+public:\n+   MessageBuffer();\n+\n+   ~MessageBuffer()\n+      {\n+      TR_Memory::jitPersistentFree(_storage);\n+      }\n+\n+\n+   /**\n+      @brief Get the current active size of the buffer.\n+\n+      Note: this returns the number of bytes written to the buffer so far,\n+      NOT the overall capacity of the buffer. Capacity is the number of\n+      bytes allocated, but not necessarily used.\n+\n+      @return the size of the buffer\n+   */\n+   uint32_t size() const { return _curPtr - _storage; }\n+\n+   char *getBufferStart() const { return _storage; }\n+\n+   /**\n+      @brief Return a pointer to the value at given offset inside the buffer.\n+\n+      Given a type and offset, returns the pointer of that type.\n+      Behavior is only defined if offset does not exceed populated buffer size.\n+\n+      @return ponter of the specified type at given offset\n+   */\n+   template <typename T>\n+   T *getValueAtOffset(uint32_t offset) const\n+      {\n+      TR_ASSERT_FATAL(offset < size(), \"Offset is outside of buffer bounds\");\n+      return reinterpret_cast<T *>(_storage + offset);\n+      }\n+\n+   /**\n+      @brief Write value of type T to the buffer.\n+\n+      Copies the value into buffer, expanding it if needed,\n+      and advances _curPtr by sizeof(T) bytes plus some padding\n+      so that the data inside the buffer is always 32-bit aligned\n+      Behavior is undefined if T is not trivially copyable (i.e. not contiguous in memory).\n+\n+      @param val value to be written\n+\n+      @return offset to the beginning of written value inside the buffer\n+   */\n+   template <typename T>\n+   uint32_t writeValue(const T &val)\n+      {\n+      uint8_t paddingSize = static_cast<uint8_t>(((sizeof(T) + 3) & 0xfffffffc) - sizeof(T));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzMwOTUyMg=="}, "originalCommit": {"oid": "14b78a158949a862ee4a58ab036bb658beaee15c"}, "originalPosition": 101}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzNzk2NTYyOnYy", "diffSide": "RIGHT", "path": "runtime/compiler/net/RawTypeConvert.hpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQyMToxMDoyM1rOF3F4Bw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxMjozODoxNVrOF3aWhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzMxMjI2Mw==", "bodyText": "Remove?", "url": "https://github.com/eclipse-openj9/openj9/pull/8832#discussion_r393312263", "createdAt": "2020-03-16T21:10:23Z", "author": {"login": "ymanton"}, "path": "runtime/compiler/net/RawTypeConvert.hpp", "diffHunk": "@@ -0,0 +1,346 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+#ifndef RAW_TYPE_CONVERT_H\n+#define RAW_TYPE_CONVERT_H\n+\n+#include <cstdint>\n+#include <utility>\n+#include <type_traits>\n+#include \"StreamExceptions.hpp\"\n+#include \"omrcomp.h\"\n+#include \"net/Message.hpp\"\n+\n+class J9Class;\n+class TR_ResolvedJ9Method;\n+\n+namespace JITServer\n+{\n+// Sending void over the network is awkward, so we just\n+// wrap a bool.\n+struct Void\n+   {\n+   Void() {}\n+   Void(bool) {}\n+   operator bool() const { return false; }\n+   };\n+\n+// The following are the template functions used to serialize/deserialize data.\n+// RawTypeConvert<T>::onRecv(Message::DataDescriptor *desc) - given a data descriptor,\n+// deserializes it into a value of type T and returns it.\n+//\n+// RawTypeConvert::onSend(Message &msg, const T&val) - given a value of type T,\n+// serializes it into an instance of Message::DataDescriptor and adds it to the message.\n+// Returns the number of data bytes written.\n+template <typename T, typename = void> struct RawTypeConvert { };\n+template <> struct RawTypeConvert<uint32_t>\n+   {\n+   static inline uint32_t onRecv(Message::DataDescriptor *desc) \n+      {\n+      TR_ASSERT(desc->getDataType() == Message::DataDescriptor::DataType::UINT32, \"onRecv type missmatch UINT32\");\n+      TR_ASSERT(desc->getPayloadSize() == sizeof(uint32_t), \"onRecv size missmatch\");\n+      return *static_cast<uint32_t *>(desc->getDataStart()); \n+      }\n+   static inline uint32_t onSend(Message &msg, const uint32_t &val)\n+      {\n+      return msg.addData(Message::DataDescriptor(Message::DataDescriptor::DataType::UINT32, sizeof(uint32_t)), &val);\n+      }\n+   };\n+template <> struct RawTypeConvert<uint64_t>\n+   {\n+   static inline uint64_t onRecv(Message::DataDescriptor *desc) \n+      {\n+      TR_ASSERT(desc->getDataType() == Message::DataDescriptor::DataType::UINT64, \"onRecv type missmatch UINT64\");\n+      TR_ASSERT(desc->getPayloadSize() == sizeof(uint64_t), \"onRecv size missmatch\");\n+      return *static_cast<uint64_t *>(desc->getDataStart()); \n+      }\n+   static inline uint32_t onSend(Message &msg, const uint64_t &val)\n+      {\n+      return msg.addData(Message::DataDescriptor(Message::DataDescriptor::DataType::UINT64, sizeof(uint64_t)), &val, true);\n+      }\n+   };\n+template <> struct RawTypeConvert<int32_t>\n+   {\n+   static inline int32_t onRecv(Message::DataDescriptor *desc) \n+      {\n+      TR_ASSERT(desc->getDataType() == Message::DataDescriptor::DataType::INT32, \"onRecv type missmatch INT32\");\n+      TR_ASSERT(desc->getPayloadSize() == sizeof(int32_t), \"onRecv size missmatch\");\n+      return *static_cast<int32_t *>(desc->getDataStart()); \n+      }\n+   static inline uint32_t onSend(Message &msg, const int32_t &val)\n+      {\n+      return msg.addData(Message::DataDescriptor(Message::DataDescriptor::DataType::INT32, sizeof(int32_t)), &val);\n+      }\n+   };\n+template <> struct RawTypeConvert<int64_t>\n+   {\n+   static inline int64_t onRecv(Message::DataDescriptor *desc) \n+      {\n+      TR_ASSERT(desc->getDataType() == Message::DataDescriptor::DataType::INT64, \"onRecv type missmatch INT64\");\n+      TR_ASSERT(desc->getPayloadSize() == sizeof(int64_t), \"onRecv size missmatch\");\n+      return *static_cast<int64_t *>(desc->getDataStart()); \n+      }\n+   static inline uint32_t onSend(Message &msg, const int64_t &val)\n+      {\n+      return msg.addData(Message::DataDescriptor(Message::DataDescriptor::DataType::INT64, sizeof(int64_t)), &val, true);\n+      }\n+   };\n+template <> struct RawTypeConvert<bool>\n+   {\n+   static inline bool onRecv(Message::DataDescriptor *desc) \n+      {\n+      TR_ASSERT(desc->getDataType() == Message::DataDescriptor::DataType::BOOL, \"onRecv type missmatch BOOL\");\n+      TR_ASSERT(desc->getTotalSize() == 4 && desc->getPaddingSize() == 3, \"onRecv size missmatch\");\n+      return *static_cast<bool *>(desc->getDataStart()); \n+      }\n+   static inline uint32_t onSend(Message &msg, const bool &val)\n+      {\n+      return msg.addData(Message::DataDescriptor(Message::DataDescriptor::DataType::BOOL, sizeof(bool)), &val);\n+      }\n+   };\n+template <> struct RawTypeConvert<const std::string>\n+   {\n+   static inline std::string onRecv(Message::DataDescriptor *desc)\n+      {\n+      TR_ASSERT(desc->getDataType() == Message::DataDescriptor::DataType::STRING, \"onRecv type missmatch STRING\");\n+      return std::string(static_cast<char *>(desc->getDataStart()), desc->getPayloadSize());\n+      }\n+   static inline uint32_t onSend(Message &msg, const std::string &value)\n+      {\n+      return msg.addData(Message::DataDescriptor(Message::DataDescriptor::DataType::STRING, value.length()), &value[0]);\n+      }\n+   };\n+\n+template <> struct RawTypeConvert<std::string> : RawTypeConvert<const std::string> {};\n+\n+// For trivially copyable classes\n+template <typename T> struct RawTypeConvert<T, typename std::enable_if<std::is_trivially_copyable<T>::value>::type>\n+   {\n+   static inline T onRecv(Message::DataDescriptor *desc) \n+      {\n+      TR_ASSERT(desc->getDataType() == Message::DataDescriptor::DataType::OBJECT, \"onRecv type missmatch OBJECT\");\n+      return *static_cast<T *>(desc->getDataStart()); \n+      }\n+   static inline uint32_t onSend(Message &msg, const T &value)\n+      {\n+      return msg.addData(Message::DataDescriptor(Message::DataDescriptor::DataType::OBJECT, sizeof(T)), &value, sizeof(T) > 4);\n+      }\n+   };\n+\n+// For vectors\n+template <typename T> struct RawTypeConvert<T, typename std::enable_if<std::is_same<T, std::vector<typename T::value_type>>::value>::type>\n+   {\n+   static inline T onRecv(Message::DataDescriptor *desc)\n+      {\n+      if (desc->getDataType() == Message::DataDescriptor::DataType::EMPTY_VECTOR)\n+         {\n+         return std::vector<typename T::value_type>();\n+         }\n+      if (desc->getDataType() == Message::DataDescriptor::DataType::SIMPLE_VECTOR)\n+         {\n+         TR_ASSERT(desc->getVectorElementSize() == sizeof(typename T::value_type), \"Vector element size missmatch\");\n+         typename T::value_type *dataStart = static_cast<typename T::value_type *>(desc->getDataStart());\n+         typename T::value_type *dataEnd = reinterpret_cast<typename T::value_type *>(reinterpret_cast<uintptr_t>(dataStart) + desc->getPayloadSize());\n+         return T(dataStart, dataEnd);\n+         }\n+\n+      TR_ASSERT(desc->getDataType() == Message::DataDescriptor::DataType::VECTOR, \"onRecv type missmatch VECTOR\");\n+      // The first element is another descriptor to represent the number of elements in the vector\n+      Message::DataDescriptor *sizeDesc = static_cast<Message::DataDescriptor *>(desc->getDataStart());\n+      uint32_t size = RawTypeConvert<uint32_t>::onRecv(sizeDesc);\n+\n+      std::vector<typename T::value_type> values;\n+      values.reserve(size);\n+\n+      // Find the descriptor of the first element in the array\n+      auto curDesc = sizeDesc->getNextDescriptor();\n+      for (uint32_t i = 0; i < size; ++i)\n+         {\n+         values.push_back(RawTypeConvert<typename T::value_type>::onRecv(curDesc));\n+         curDesc = curDesc->getNextDescriptor();\n+         }\n+      return values;\n+      }\n+   static inline uint32_t onSend(Message &msg, const T &value)\n+      {\n+      if (value.size() == 0)\n+         {\n+         // Empty vector. Write just a descriptor followed by no data\n+         return msg.addData(Message::DataDescriptor(Message::DataDescriptor::DataType::EMPTY_VECTOR, 0), 0);\n+         }\n+      // If the vector is for trivially copyable elements and\n+      // the size of such an element is smaller than 256,\n+      // copy the data as a contiguous region of memory\n+      if (std::is_trivially_copyable<typename T::value_type>::value)\n+         {\n+         size_t elemSize = sizeof(typename T::value_type);\n+         if (elemSize <= 0xff)\n+            {\n+            uint32_t payloadSize = elemSize * value.size();\n+            Message::DataDescriptor desc(Message::DataDescriptor::DataType::SIMPLE_VECTOR, payloadSize);\n+            // Need to store the size of an element in the descriptor\n+            desc.setVectorElementSize(elemSize);\n+            return msg.addData(desc, value.data(), elemSize > 4);\n+            }\n+         }\n+      // Complex vectors here\n+      uint32_t descIndex = msg.getNumDescriptors();\n+      uint32_t descOffset = msg.reserveDescriptor();\n+\n+      // Write the size of the vector as a data point\n+      uint32_t totalSize = (value.size() + 1) * sizeof(Message::DataDescriptor);\n+      totalSize += RawTypeConvert<uint32_t>::onSend(msg, value.size());\n+      for (int32_t i = 0; i < value.size(); ++i)\n+         {\n+         // Serialize each element in a vector as its own datapoint\n+         totalSize += RawTypeConvert<typename T::value_type>::onSend(msg, value[i]);\n+         }\n+\n+      // Only get pointer to the vector descriptor after all of its elements were serialized,\n+      // because buffer might have been reallocated\n+      Message::DataDescriptor *desc = msg.getDescriptor(descIndex);\n+      // If each element is 32-bit aligned, then the entire vector is 32-bit aligned and padding is 0\n+      desc->init(Message::DataDescriptor::DataType::VECTOR, totalSize, 0, 0);\n+      return totalSize;\n+      }\n+   };\n+// For tuples\n+//\n+// used to unpack a tuple into variadic args\n+template <size_t... I> struct index_tuple_raw { template <size_t N> using type = index_tuple_raw<I..., N>; };\n+template <size_t N> struct index_tuple_gen_raw { using type = typename index_tuple_gen_raw<N - 1>::type::template type<N - 1>; };\n+template <> struct index_tuple_gen_raw<0> { using type = index_tuple_raw<>; };\n+\n+template <size_t n, typename Arg1, typename... Args>\n+struct TupleTypeConvert\n+   {\n+   static inline std::tuple<Arg1, Args...> onRecvImpl(Message::DataDescriptor *desc)\n+      {\n+      return std::tuple_cat(TupleTypeConvert<n, Arg1>::onRecvImpl(desc),\n+                            TupleTypeConvert<n + 1, Args...>::onRecvImpl(desc->getNextDescriptor()));\n+      }\n+   static inline uint32_t onSendImpl(Message &msg, const Arg1 &arg1, const Args&... args)\n+      {\n+      uint32_t totalSize = TupleTypeConvert<n, Arg1>::onSendImpl(msg, arg1);\n+      totalSize += TupleTypeConvert<n + 1, Args...>::onSendImpl(msg, args...);\n+      return totalSize;\n+      }\n+   };\n+\n+template <size_t n, typename Arg1>\n+struct TupleTypeConvert<n, Arg1>\n+   {\n+   static inline std::tuple<Arg1> onRecvImpl(Message::DataDescriptor *desc)\n+      {\n+      return std::make_tuple(RawTypeConvert<Arg1>::onRecv(desc));\n+      }\n+   static inline uint32_t onSendImpl(Message &msg, const Arg1 &arg1)\n+      {\n+      return RawTypeConvert<Arg1>::onSend(msg, arg1) + sizeof(Message::DataDescriptor);\n+      }\n+   };\n+\n+template <typename... T> struct RawTypeConvert<const std::tuple<T...>>\n+   {\n+   static inline std::tuple<T...> onRecv(Message::DataDescriptor *desc)\n+      {\n+      TR_ASSERT(desc->getDataType() == Message::DataDescriptor::DataType::TUPLE, \"onRecv type missmatch TUPLE\");\n+      return TupleTypeConvert<0, T...>::onRecvImpl(static_cast<Message::DataDescriptor *>(desc->getDataStart()));\n+      }\n+\n+   template <typename Tuple, size_t... Idx>\n+   static inline uint32_t onSendImpl(Message &msg, const Tuple &val, index_tuple_raw<Idx...>)\n+      {\n+      uint32_t descIndex = msg.getNumDescriptors();\n+      uint32_t descOffset = msg.reserveDescriptor();\n+      uint32_t totalSize = TupleTypeConvert<0, T...>::onSendImpl(msg, std::get<Idx>(val)...);\n+      // Only get pointer to the tuple descriptor after all of its elements were serialized,\n+      // because buffer might have been reallocated\n+      Message::DataDescriptor *desc = msg.getDescriptor(descIndex);\n+      // If each element is 32-bit aligned, then the entire tuple is 32-bit aligned and padding is 0\n+      desc->init(Message::DataDescriptor::DataType::TUPLE, totalSize, 0, 0);\n+      return totalSize;\n+      }\n+   \n+   static inline uint32_t onSend(Message &msg, const std::tuple<T...> &val)\n+      {\n+      using Idx = typename index_tuple_gen_raw<sizeof...(T)>::type;\n+      return onSendImpl(msg, val, Idx());\n+      }\n+   };\n+\n+template <typename... T> struct RawTypeConvert<std::tuple<T...>> : RawTypeConvert<const std::tuple<T...>> { };\n+\n+// setArgs fills out a message with values from a variadic argument list.\n+// calls RawTypeConvert::onSend for each argument.\n+template <typename Arg1, typename... Args>\n+struct SetArgsRaw\n+   {\n+   static void setArgs(Message &message, Arg1 &arg1, Args&... args)\n+      {\n+      SetArgsRaw<Arg1>::setArgs(message, arg1);\n+      SetArgsRaw<Args...>::setArgs(message, args...);\n+      }\n+   };\n+template <typename Arg1>\n+struct SetArgsRaw<Arg1>\n+   {\n+   static void setArgs(Message &message, Arg1 &arg1)\n+      {\n+      RawTypeConvert<Arg1>::onSend(message, arg1);\n+      }\n+   };\n+template <typename... Args>\n+void setArgsRaw(Message &message, Args&... args)\n+   {\n+   message.getMetaData()->_numDataPoints = sizeof...(args);\n+   SetArgsRaw<Args...>::setArgs(message, args...);\n+   }\n+\n+template <typename Arg1, typename... Args>\n+struct GetArgsRaw\n+   {\n+   static std::tuple<Arg1, Args...> getArgs(const Message &message, size_t n)\n+      {\n+      return std::tuple_cat(GetArgsRaw<Arg1>::getArgs(message, n), GetArgsRaw<Args...>::getArgs(message, n + 1));\n+      }\n+   };\n+template <typename Arg>\n+struct GetArgsRaw<Arg>\n+   {\n+   static std::tuple<Arg> getArgs(const Message &message, size_t n)\n+      {\n+      Message::DataDescriptor *desc = message.getDescriptor(n);\n+      // TODO: add type checking functionality\n+      // if (data.type_case() != AnyPrimitive<typename ProtobufTypeConvert<Arg>::ProtoType>::typeCase())\n+         // throw StreamTypeMismatch(\"Received type \" + std::to_string(data.type_case()) + \" but expect type \" + std::to_string(AnyPrimitive<typename ProtobufTypeConvert<Arg>::ProtoType>::typeCase()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14b78a158949a862ee4a58ab036bb658beaee15c"}, "originalPosition": 334}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY0Nzc1MQ==", "bodyText": "Done", "url": "https://github.com/eclipse-openj9/openj9/pull/8832#discussion_r393647751", "createdAt": "2020-03-17T12:38:15Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/net/RawTypeConvert.hpp", "diffHunk": "@@ -0,0 +1,346 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+#ifndef RAW_TYPE_CONVERT_H\n+#define RAW_TYPE_CONVERT_H\n+\n+#include <cstdint>\n+#include <utility>\n+#include <type_traits>\n+#include \"StreamExceptions.hpp\"\n+#include \"omrcomp.h\"\n+#include \"net/Message.hpp\"\n+\n+class J9Class;\n+class TR_ResolvedJ9Method;\n+\n+namespace JITServer\n+{\n+// Sending void over the network is awkward, so we just\n+// wrap a bool.\n+struct Void\n+   {\n+   Void() {}\n+   Void(bool) {}\n+   operator bool() const { return false; }\n+   };\n+\n+// The following are the template functions used to serialize/deserialize data.\n+// RawTypeConvert<T>::onRecv(Message::DataDescriptor *desc) - given a data descriptor,\n+// deserializes it into a value of type T and returns it.\n+//\n+// RawTypeConvert::onSend(Message &msg, const T&val) - given a value of type T,\n+// serializes it into an instance of Message::DataDescriptor and adds it to the message.\n+// Returns the number of data bytes written.\n+template <typename T, typename = void> struct RawTypeConvert { };\n+template <> struct RawTypeConvert<uint32_t>\n+   {\n+   static inline uint32_t onRecv(Message::DataDescriptor *desc) \n+      {\n+      TR_ASSERT(desc->getDataType() == Message::DataDescriptor::DataType::UINT32, \"onRecv type missmatch UINT32\");\n+      TR_ASSERT(desc->getPayloadSize() == sizeof(uint32_t), \"onRecv size missmatch\");\n+      return *static_cast<uint32_t *>(desc->getDataStart()); \n+      }\n+   static inline uint32_t onSend(Message &msg, const uint32_t &val)\n+      {\n+      return msg.addData(Message::DataDescriptor(Message::DataDescriptor::DataType::UINT32, sizeof(uint32_t)), &val);\n+      }\n+   };\n+template <> struct RawTypeConvert<uint64_t>\n+   {\n+   static inline uint64_t onRecv(Message::DataDescriptor *desc) \n+      {\n+      TR_ASSERT(desc->getDataType() == Message::DataDescriptor::DataType::UINT64, \"onRecv type missmatch UINT64\");\n+      TR_ASSERT(desc->getPayloadSize() == sizeof(uint64_t), \"onRecv size missmatch\");\n+      return *static_cast<uint64_t *>(desc->getDataStart()); \n+      }\n+   static inline uint32_t onSend(Message &msg, const uint64_t &val)\n+      {\n+      return msg.addData(Message::DataDescriptor(Message::DataDescriptor::DataType::UINT64, sizeof(uint64_t)), &val, true);\n+      }\n+   };\n+template <> struct RawTypeConvert<int32_t>\n+   {\n+   static inline int32_t onRecv(Message::DataDescriptor *desc) \n+      {\n+      TR_ASSERT(desc->getDataType() == Message::DataDescriptor::DataType::INT32, \"onRecv type missmatch INT32\");\n+      TR_ASSERT(desc->getPayloadSize() == sizeof(int32_t), \"onRecv size missmatch\");\n+      return *static_cast<int32_t *>(desc->getDataStart()); \n+      }\n+   static inline uint32_t onSend(Message &msg, const int32_t &val)\n+      {\n+      return msg.addData(Message::DataDescriptor(Message::DataDescriptor::DataType::INT32, sizeof(int32_t)), &val);\n+      }\n+   };\n+template <> struct RawTypeConvert<int64_t>\n+   {\n+   static inline int64_t onRecv(Message::DataDescriptor *desc) \n+      {\n+      TR_ASSERT(desc->getDataType() == Message::DataDescriptor::DataType::INT64, \"onRecv type missmatch INT64\");\n+      TR_ASSERT(desc->getPayloadSize() == sizeof(int64_t), \"onRecv size missmatch\");\n+      return *static_cast<int64_t *>(desc->getDataStart()); \n+      }\n+   static inline uint32_t onSend(Message &msg, const int64_t &val)\n+      {\n+      return msg.addData(Message::DataDescriptor(Message::DataDescriptor::DataType::INT64, sizeof(int64_t)), &val, true);\n+      }\n+   };\n+template <> struct RawTypeConvert<bool>\n+   {\n+   static inline bool onRecv(Message::DataDescriptor *desc) \n+      {\n+      TR_ASSERT(desc->getDataType() == Message::DataDescriptor::DataType::BOOL, \"onRecv type missmatch BOOL\");\n+      TR_ASSERT(desc->getTotalSize() == 4 && desc->getPaddingSize() == 3, \"onRecv size missmatch\");\n+      return *static_cast<bool *>(desc->getDataStart()); \n+      }\n+   static inline uint32_t onSend(Message &msg, const bool &val)\n+      {\n+      return msg.addData(Message::DataDescriptor(Message::DataDescriptor::DataType::BOOL, sizeof(bool)), &val);\n+      }\n+   };\n+template <> struct RawTypeConvert<const std::string>\n+   {\n+   static inline std::string onRecv(Message::DataDescriptor *desc)\n+      {\n+      TR_ASSERT(desc->getDataType() == Message::DataDescriptor::DataType::STRING, \"onRecv type missmatch STRING\");\n+      return std::string(static_cast<char *>(desc->getDataStart()), desc->getPayloadSize());\n+      }\n+   static inline uint32_t onSend(Message &msg, const std::string &value)\n+      {\n+      return msg.addData(Message::DataDescriptor(Message::DataDescriptor::DataType::STRING, value.length()), &value[0]);\n+      }\n+   };\n+\n+template <> struct RawTypeConvert<std::string> : RawTypeConvert<const std::string> {};\n+\n+// For trivially copyable classes\n+template <typename T> struct RawTypeConvert<T, typename std::enable_if<std::is_trivially_copyable<T>::value>::type>\n+   {\n+   static inline T onRecv(Message::DataDescriptor *desc) \n+      {\n+      TR_ASSERT(desc->getDataType() == Message::DataDescriptor::DataType::OBJECT, \"onRecv type missmatch OBJECT\");\n+      return *static_cast<T *>(desc->getDataStart()); \n+      }\n+   static inline uint32_t onSend(Message &msg, const T &value)\n+      {\n+      return msg.addData(Message::DataDescriptor(Message::DataDescriptor::DataType::OBJECT, sizeof(T)), &value, sizeof(T) > 4);\n+      }\n+   };\n+\n+// For vectors\n+template <typename T> struct RawTypeConvert<T, typename std::enable_if<std::is_same<T, std::vector<typename T::value_type>>::value>::type>\n+   {\n+   static inline T onRecv(Message::DataDescriptor *desc)\n+      {\n+      if (desc->getDataType() == Message::DataDescriptor::DataType::EMPTY_VECTOR)\n+         {\n+         return std::vector<typename T::value_type>();\n+         }\n+      if (desc->getDataType() == Message::DataDescriptor::DataType::SIMPLE_VECTOR)\n+         {\n+         TR_ASSERT(desc->getVectorElementSize() == sizeof(typename T::value_type), \"Vector element size missmatch\");\n+         typename T::value_type *dataStart = static_cast<typename T::value_type *>(desc->getDataStart());\n+         typename T::value_type *dataEnd = reinterpret_cast<typename T::value_type *>(reinterpret_cast<uintptr_t>(dataStart) + desc->getPayloadSize());\n+         return T(dataStart, dataEnd);\n+         }\n+\n+      TR_ASSERT(desc->getDataType() == Message::DataDescriptor::DataType::VECTOR, \"onRecv type missmatch VECTOR\");\n+      // The first element is another descriptor to represent the number of elements in the vector\n+      Message::DataDescriptor *sizeDesc = static_cast<Message::DataDescriptor *>(desc->getDataStart());\n+      uint32_t size = RawTypeConvert<uint32_t>::onRecv(sizeDesc);\n+\n+      std::vector<typename T::value_type> values;\n+      values.reserve(size);\n+\n+      // Find the descriptor of the first element in the array\n+      auto curDesc = sizeDesc->getNextDescriptor();\n+      for (uint32_t i = 0; i < size; ++i)\n+         {\n+         values.push_back(RawTypeConvert<typename T::value_type>::onRecv(curDesc));\n+         curDesc = curDesc->getNextDescriptor();\n+         }\n+      return values;\n+      }\n+   static inline uint32_t onSend(Message &msg, const T &value)\n+      {\n+      if (value.size() == 0)\n+         {\n+         // Empty vector. Write just a descriptor followed by no data\n+         return msg.addData(Message::DataDescriptor(Message::DataDescriptor::DataType::EMPTY_VECTOR, 0), 0);\n+         }\n+      // If the vector is for trivially copyable elements and\n+      // the size of such an element is smaller than 256,\n+      // copy the data as a contiguous region of memory\n+      if (std::is_trivially_copyable<typename T::value_type>::value)\n+         {\n+         size_t elemSize = sizeof(typename T::value_type);\n+         if (elemSize <= 0xff)\n+            {\n+            uint32_t payloadSize = elemSize * value.size();\n+            Message::DataDescriptor desc(Message::DataDescriptor::DataType::SIMPLE_VECTOR, payloadSize);\n+            // Need to store the size of an element in the descriptor\n+            desc.setVectorElementSize(elemSize);\n+            return msg.addData(desc, value.data(), elemSize > 4);\n+            }\n+         }\n+      // Complex vectors here\n+      uint32_t descIndex = msg.getNumDescriptors();\n+      uint32_t descOffset = msg.reserveDescriptor();\n+\n+      // Write the size of the vector as a data point\n+      uint32_t totalSize = (value.size() + 1) * sizeof(Message::DataDescriptor);\n+      totalSize += RawTypeConvert<uint32_t>::onSend(msg, value.size());\n+      for (int32_t i = 0; i < value.size(); ++i)\n+         {\n+         // Serialize each element in a vector as its own datapoint\n+         totalSize += RawTypeConvert<typename T::value_type>::onSend(msg, value[i]);\n+         }\n+\n+      // Only get pointer to the vector descriptor after all of its elements were serialized,\n+      // because buffer might have been reallocated\n+      Message::DataDescriptor *desc = msg.getDescriptor(descIndex);\n+      // If each element is 32-bit aligned, then the entire vector is 32-bit aligned and padding is 0\n+      desc->init(Message::DataDescriptor::DataType::VECTOR, totalSize, 0, 0);\n+      return totalSize;\n+      }\n+   };\n+// For tuples\n+//\n+// used to unpack a tuple into variadic args\n+template <size_t... I> struct index_tuple_raw { template <size_t N> using type = index_tuple_raw<I..., N>; };\n+template <size_t N> struct index_tuple_gen_raw { using type = typename index_tuple_gen_raw<N - 1>::type::template type<N - 1>; };\n+template <> struct index_tuple_gen_raw<0> { using type = index_tuple_raw<>; };\n+\n+template <size_t n, typename Arg1, typename... Args>\n+struct TupleTypeConvert\n+   {\n+   static inline std::tuple<Arg1, Args...> onRecvImpl(Message::DataDescriptor *desc)\n+      {\n+      return std::tuple_cat(TupleTypeConvert<n, Arg1>::onRecvImpl(desc),\n+                            TupleTypeConvert<n + 1, Args...>::onRecvImpl(desc->getNextDescriptor()));\n+      }\n+   static inline uint32_t onSendImpl(Message &msg, const Arg1 &arg1, const Args&... args)\n+      {\n+      uint32_t totalSize = TupleTypeConvert<n, Arg1>::onSendImpl(msg, arg1);\n+      totalSize += TupleTypeConvert<n + 1, Args...>::onSendImpl(msg, args...);\n+      return totalSize;\n+      }\n+   };\n+\n+template <size_t n, typename Arg1>\n+struct TupleTypeConvert<n, Arg1>\n+   {\n+   static inline std::tuple<Arg1> onRecvImpl(Message::DataDescriptor *desc)\n+      {\n+      return std::make_tuple(RawTypeConvert<Arg1>::onRecv(desc));\n+      }\n+   static inline uint32_t onSendImpl(Message &msg, const Arg1 &arg1)\n+      {\n+      return RawTypeConvert<Arg1>::onSend(msg, arg1) + sizeof(Message::DataDescriptor);\n+      }\n+   };\n+\n+template <typename... T> struct RawTypeConvert<const std::tuple<T...>>\n+   {\n+   static inline std::tuple<T...> onRecv(Message::DataDescriptor *desc)\n+      {\n+      TR_ASSERT(desc->getDataType() == Message::DataDescriptor::DataType::TUPLE, \"onRecv type missmatch TUPLE\");\n+      return TupleTypeConvert<0, T...>::onRecvImpl(static_cast<Message::DataDescriptor *>(desc->getDataStart()));\n+      }\n+\n+   template <typename Tuple, size_t... Idx>\n+   static inline uint32_t onSendImpl(Message &msg, const Tuple &val, index_tuple_raw<Idx...>)\n+      {\n+      uint32_t descIndex = msg.getNumDescriptors();\n+      uint32_t descOffset = msg.reserveDescriptor();\n+      uint32_t totalSize = TupleTypeConvert<0, T...>::onSendImpl(msg, std::get<Idx>(val)...);\n+      // Only get pointer to the tuple descriptor after all of its elements were serialized,\n+      // because buffer might have been reallocated\n+      Message::DataDescriptor *desc = msg.getDescriptor(descIndex);\n+      // If each element is 32-bit aligned, then the entire tuple is 32-bit aligned and padding is 0\n+      desc->init(Message::DataDescriptor::DataType::TUPLE, totalSize, 0, 0);\n+      return totalSize;\n+      }\n+   \n+   static inline uint32_t onSend(Message &msg, const std::tuple<T...> &val)\n+      {\n+      using Idx = typename index_tuple_gen_raw<sizeof...(T)>::type;\n+      return onSendImpl(msg, val, Idx());\n+      }\n+   };\n+\n+template <typename... T> struct RawTypeConvert<std::tuple<T...>> : RawTypeConvert<const std::tuple<T...>> { };\n+\n+// setArgs fills out a message with values from a variadic argument list.\n+// calls RawTypeConvert::onSend for each argument.\n+template <typename Arg1, typename... Args>\n+struct SetArgsRaw\n+   {\n+   static void setArgs(Message &message, Arg1 &arg1, Args&... args)\n+      {\n+      SetArgsRaw<Arg1>::setArgs(message, arg1);\n+      SetArgsRaw<Args...>::setArgs(message, args...);\n+      }\n+   };\n+template <typename Arg1>\n+struct SetArgsRaw<Arg1>\n+   {\n+   static void setArgs(Message &message, Arg1 &arg1)\n+      {\n+      RawTypeConvert<Arg1>::onSend(message, arg1);\n+      }\n+   };\n+template <typename... Args>\n+void setArgsRaw(Message &message, Args&... args)\n+   {\n+   message.getMetaData()->_numDataPoints = sizeof...(args);\n+   SetArgsRaw<Args...>::setArgs(message, args...);\n+   }\n+\n+template <typename Arg1, typename... Args>\n+struct GetArgsRaw\n+   {\n+   static std::tuple<Arg1, Args...> getArgs(const Message &message, size_t n)\n+      {\n+      return std::tuple_cat(GetArgsRaw<Arg1>::getArgs(message, n), GetArgsRaw<Args...>::getArgs(message, n + 1));\n+      }\n+   };\n+template <typename Arg>\n+struct GetArgsRaw<Arg>\n+   {\n+   static std::tuple<Arg> getArgs(const Message &message, size_t n)\n+      {\n+      Message::DataDescriptor *desc = message.getDescriptor(n);\n+      // TODO: add type checking functionality\n+      // if (data.type_case() != AnyPrimitive<typename ProtobufTypeConvert<Arg>::ProtoType>::typeCase())\n+         // throw StreamTypeMismatch(\"Received type \" + std::to_string(data.type_case()) + \" but expect type \" + std::to_string(AnyPrimitive<typename ProtobufTypeConvert<Arg>::ProtoType>::typeCase()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzMxMjI2Mw=="}, "originalCommit": {"oid": "14b78a158949a862ee4a58ab036bb658beaee15c"}, "originalPosition": 334}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzNzk3MTYxOnYy", "diffSide": "RIGHT", "path": "runtime/compiler/net/MessageBuffer.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQyMToxMjoxOVrOF3F7vA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxMjozODoyNFrOF3aW1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzMxMzIxMg==", "bodyText": "Can we use a symbol for this 10000?", "url": "https://github.com/eclipse-openj9/openj9/pull/8832#discussion_r393313212", "createdAt": "2020-03-16T21:12:19Z", "author": {"login": "ymanton"}, "path": "runtime/compiler/net/MessageBuffer.cpp", "diffHunk": "@@ -0,0 +1,87 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"net/MessageBuffer.hpp\"\n+#include <cstring>\n+\n+namespace JITServer\n+{\n+MessageBuffer::MessageBuffer() :\n+   _capacity(10000)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14b78a158949a862ee4a58ab036bb658beaee15c"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY0NzgyOA==", "bodyText": "Done", "url": "https://github.com/eclipse-openj9/openj9/pull/8832#discussion_r393647828", "createdAt": "2020-03-17T12:38:24Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/net/MessageBuffer.cpp", "diffHunk": "@@ -0,0 +1,87 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"net/MessageBuffer.hpp\"\n+#include <cstring>\n+\n+namespace JITServer\n+{\n+MessageBuffer::MessageBuffer() :\n+   _capacity(10000)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzMxMzIxMg=="}, "originalCommit": {"oid": "14b78a158949a862ee4a58ab036bb658beaee15c"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0MDk2NzQ3OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/net/Message.hpp", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxNjoxMTozNVrOF3jdpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxNjo1ODozMFrOF3ldVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzc5NzAyOQ==", "bodyText": "I think including this file breaks the build because we have two unrelated definitions of align() in the codebase that clash.\nThe align() used here\nhttps://github.com/eclipse/omr/blob/d3401cf86613f355d826a7b2aef301ae35fc437b/compiler/runtime/OMRCodeCache.hpp#L85-L86\nrefers to this implementation:\nhttps://github.com/eclipse/omr/blob/d3401cf86613f355d826a7b2aef301ae35fc437b/compiler/runtime/Alignment.cpp#L30-L34\nbut since the use is not properly qualified once we include that header it will refer to OMR::align which is an incompatible function.\nI'll submit a PR to OMR to fix it.", "url": "https://github.com/eclipse-openj9/openj9/pull/8832#discussion_r393797029", "createdAt": "2020-03-17T16:11:35Z", "author": {"login": "ymanton"}, "path": "runtime/compiler/net/Message.hpp", "diffHunk": "@@ -0,0 +1,379 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#ifndef MESSAGE_H\n+#define MESSAGE_H\n+\n+#include <vector>\n+#include <stdlib.h>\n+#include \"net/MessageBuffer.hpp\"\n+#include \"net/MessageTypes.hpp\"\n+#include \"OMR/Bytes.hpp\" // for alignNoCheck", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f88706b4906091f7ab9b1ec85ea70fac03ebd11"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzgyOTcxOQ==", "bodyText": "I've opened eclipse/omr#4943 to get it fixed.", "url": "https://github.com/eclipse-openj9/openj9/pull/8832#discussion_r393829719", "createdAt": "2020-03-17T16:58:30Z", "author": {"login": "ymanton"}, "path": "runtime/compiler/net/Message.hpp", "diffHunk": "@@ -0,0 +1,379 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#ifndef MESSAGE_H\n+#define MESSAGE_H\n+\n+#include <vector>\n+#include <stdlib.h>\n+#include \"net/MessageBuffer.hpp\"\n+#include \"net/MessageTypes.hpp\"\n+#include \"OMR/Bytes.hpp\" // for alignNoCheck", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzc5NzAyOQ=="}, "originalCommit": {"oid": "2f88706b4906091f7ab9b1ec85ea70fac03ebd11"}, "originalPosition": 30}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 522, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}