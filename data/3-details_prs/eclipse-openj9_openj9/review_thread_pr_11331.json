{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMwOTk0NzQ3", "number": 11331, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QyMToyMDoyOFrOFB_hlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwMjozMToxMVrOFCFtwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3NjMzNjg0OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/control/JITServerHelpers.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QyMToyMDoyOFrOIA7NJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwMzoxODoxNlrOIBFGDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzg0MDkzNQ==", "bodyText": "So, here src is a non-padded string, while dst is padded, correct? I would like a comment of that sort.", "url": "https://github.com/eclipse-openj9/openj9/pull/11331#discussion_r537840935", "createdAt": "2020-12-07T21:20:28Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/control/JITServerHelpers.cpp", "diffHunk": "@@ -44,84 +47,309 @@ TR::Monitor *JITServerHelpers::_clientStreamMonitor = NULL;\n static size_t\n getUTF8Size(const J9UTF8 *str)\n    {\n-   return OMR::alignNoCheck(str->length, sizeof(*str)) + sizeof(*str);\n+   return OMR::alignNoCheck(J9UTF8_TOTAL_SIZE(str), sizeof(*str));\n    }\n \n+// Copies a UTF8 string with padding and returns its total size\n static size_t\n-getPackedUTF8Size(const J9UTF8 *str, const J9ROMClass *romClass)\n+copyUTF8(J9UTF8 *dst, const J9UTF8 *src)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf8bac93c10483471c4cef95c99e5644d0834e99"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODAwMjk1OQ==", "bodyText": "Correct. Will add a comment.", "url": "https://github.com/eclipse-openj9/openj9/pull/11331#discussion_r538002959", "createdAt": "2020-12-08T03:18:16Z", "author": {"login": "AlexeyKhrabrov"}, "path": "runtime/compiler/control/JITServerHelpers.cpp", "diffHunk": "@@ -44,84 +47,309 @@ TR::Monitor *JITServerHelpers::_clientStreamMonitor = NULL;\n static size_t\n getUTF8Size(const J9UTF8 *str)\n    {\n-   return OMR::alignNoCheck(str->length, sizeof(*str)) + sizeof(*str);\n+   return OMR::alignNoCheck(J9UTF8_TOTAL_SIZE(str), sizeof(*str));\n    }\n \n+// Copies a UTF8 string with padding and returns its total size\n static size_t\n-getPackedUTF8Size(const J9UTF8 *str, const J9ROMClass *romClass)\n+copyUTF8(J9UTF8 *dst, const J9UTF8 *src)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzg0MDkzNQ=="}, "originalCommit": {"oid": "cf8bac93c10483471c4cef95c99e5644d0834e99"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3NjM0ODE5OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/control/JITServerHelpers.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QyMToyMzowOVrOIA7Thg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwMzoyMDowMFrOIBFILw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzg0MjU2Ng==", "bodyText": "Also please add a comment of what this function returns.\nIsn't easier if we return J9UTF8_TOTAL_SIZE(dst) ?", "url": "https://github.com/eclipse-openj9/openj9/pull/11331#discussion_r537842566", "createdAt": "2020-12-07T21:23:09Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/control/JITServerHelpers.cpp", "diffHunk": "@@ -44,84 +47,309 @@ TR::Monitor *JITServerHelpers::_clientStreamMonitor = NULL;\n static size_t\n getUTF8Size(const J9UTF8 *str)\n    {\n-   return OMR::alignNoCheck(str->length, sizeof(*str)) + sizeof(*str);\n+   return OMR::alignNoCheck(J9UTF8_TOTAL_SIZE(str), sizeof(*str));\n    }\n \n+// Copies a UTF8 string with padding and returns its total size\n static size_t\n-getPackedUTF8Size(const J9UTF8 *str, const J9ROMClass *romClass)\n+copyUTF8(J9UTF8 *dst, const J9UTF8 *src)\n    {\n-   return JITServerHelpers::isAddressInROMClass(str, romClass) ? 0 : getUTF8Size(str);\n+   size_t size = J9UTF8_TOTAL_SIZE(src);\n+   memcpy(dst, src, size);\n+   static_assert(sizeof(*src) == 2, \"UTF8 header is not 2 bytes large\");\n+   if (!OMR::alignedNoCheck(size, sizeof(*src)))\n+      dst->data[src->length] = '\\0';\n+   return OMR::alignNoCheck(size, sizeof(*src));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf8bac93c10483471c4cef95c99e5644d0834e99"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODAwMzUwMw==", "bodyText": "It returns the padded size, i.e. getUTF8Size(src) == getUTF8Size(dst), but it's different from J9UTF8_TOTAL_SIZE(dst). I'll change it to return getUTF8Size(dst).", "url": "https://github.com/eclipse-openj9/openj9/pull/11331#discussion_r538003503", "createdAt": "2020-12-08T03:20:00Z", "author": {"login": "AlexeyKhrabrov"}, "path": "runtime/compiler/control/JITServerHelpers.cpp", "diffHunk": "@@ -44,84 +47,309 @@ TR::Monitor *JITServerHelpers::_clientStreamMonitor = NULL;\n static size_t\n getUTF8Size(const J9UTF8 *str)\n    {\n-   return OMR::alignNoCheck(str->length, sizeof(*str)) + sizeof(*str);\n+   return OMR::alignNoCheck(J9UTF8_TOTAL_SIZE(str), sizeof(*str));\n    }\n \n+// Copies a UTF8 string with padding and returns its total size\n static size_t\n-getPackedUTF8Size(const J9UTF8 *str, const J9ROMClass *romClass)\n+copyUTF8(J9UTF8 *dst, const J9UTF8 *src)\n    {\n-   return JITServerHelpers::isAddressInROMClass(str, romClass) ? 0 : getUTF8Size(str);\n+   size_t size = J9UTF8_TOTAL_SIZE(src);\n+   memcpy(dst, src, size);\n+   static_assert(sizeof(*src) == 2, \"UTF8 header is not 2 bytes large\");\n+   if (!OMR::alignedNoCheck(size, sizeof(*src)))\n+      dst->data[src->length] = '\\0';\n+   return OMR::alignNoCheck(size, sizeof(*src));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzg0MjU2Ng=="}, "originalCommit": {"oid": "cf8bac93c10483471c4cef95c99e5644d0834e99"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3NjM1ODk3OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/control/JITServerHelpers.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QyMToyNTo0N1rOIA7Z1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QyMToyNTo0N1rOIA7Z1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzg0NDE4MA==", "bodyText": "Please add a leading underscore to fields of data structures", "url": "https://github.com/eclipse-openj9/openj9/pull/11331#discussion_r537844180", "createdAt": "2020-12-07T21:25:47Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/control/JITServerHelpers.cpp", "diffHunk": "@@ -44,84 +47,309 @@ TR::Monitor *JITServerHelpers::_clientStreamMonitor = NULL;\n static size_t\n getUTF8Size(const J9UTF8 *str)\n    {\n-   return OMR::alignNoCheck(str->length, sizeof(*str)) + sizeof(*str);\n+   return OMR::alignNoCheck(J9UTF8_TOTAL_SIZE(str), sizeof(*str));\n    }\n \n+// Copies a UTF8 string with padding and returns its total size\n static size_t\n-getPackedUTF8Size(const J9UTF8 *str, const J9ROMClass *romClass)\n+copyUTF8(J9UTF8 *dst, const J9UTF8 *src)\n    {\n-   return JITServerHelpers::isAddressInROMClass(str, romClass) ? 0 : getUTF8Size(str);\n+   size_t size = J9UTF8_TOTAL_SIZE(src);\n+   memcpy(dst, src, size);\n+   static_assert(sizeof(*src) == 2, \"UTF8 header is not 2 bytes large\");\n+   if (!OMR::alignedNoCheck(size, sizeof(*src)))\n+      dst->data[src->length] = '\\0';\n+   return OMR::alignNoCheck(size, sizeof(*src));\n    }\n \n-// If the string points outside of the contiguous part of origRomClass, appends\n-// it (with padding) at curPos and updates the SRP to the string in the packed\n-// ROMClass. Returns the new value of curPos.\n-static uint8_t *\n-packUTF8(uint8_t *curPos, const J9UTF8 *origStr, const J9ROMClass *origRomClass, J9SRP &srp)\n+// State maintained while iterating over UTF8 strings in a ROMClass\n+struct ROMClassPackContext\n    {\n-   if (JITServerHelpers::isAddressInROMClass(origStr, origRomClass))\n-      return curPos;\n+   ROMClassPackContext(TR_Memory *trMemory, size_t origRomSize) :\n+      origSize(origRomSize), callback(NULL), stringsSize(0),\n+      utf8SectionStart((const uint8_t *)-1), utf8SectionEnd(NULL), utf8SectionSize(0),\n+      strToOffsetMap(decltype(strToOffsetMap)::allocator_type(trMemory->currentStackRegion())),\n+      packedRomClass(NULL), cursor(NULL) {}\n \n-   size_t size = getUTF8Size(origStr);\n-   memcpy(curPos, origStr, origStr->length + sizeof(*origStr));\n-   static_assert(sizeof(*origStr) == 2, \"UTF8 header is not 2 bytes large\");\n-   if (!OMR::alignedNoCheck(origStr->length, sizeof(*origStr)))\n-      curPos[size - 1] = '\\0';\n-   NNSRP_SET(srp, curPos);\n-   return curPos + size;\n+   bool isInline(const void *address, const J9ROMClass *romClass)\n+      {\n+      return (address >= romClass) && (address < (uint8_t *)romClass + origSize);\n+      }\n+\n+   typedef void (*Callback)(const J9ROMClass *, const J9SRP *, const char *, ROMClassPackContext &);\n+\n+   const size_t origSize;\n+   Callback callback;\n+   size_t stringsSize;\n+   const uint8_t *utf8SectionStart;\n+   const uint8_t *utf8SectionEnd;// only needed for assertions\n+   size_t utf8SectionSize;// only needed for assertions\n+   // Maps original strings to their offsets from UTF8 section start in the packed ROMClass\n+   // Offset value -1 signifies that the string is skipped\n+   UnorderedMap<const J9UTF8 *, size_t> strToOffsetMap;\n+   J9ROMClass *packedRomClass;\n+   uint8_t *cursor;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf8bac93c10483471c4cef95c99e5644d0834e99"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3NjYwNDQyOnYy", "diffSide": "RIGHT", "path": "runtime/compiler/control/JITServerHelpers.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QyMjoyNjowNVrOIA9llA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwMzoyMTo0OVrOIBFKZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzg3OTk1Ng==", "bodyText": "is the hint it useful?", "url": "https://github.com/eclipse-openj9/openj9/pull/11331#discussion_r537879956", "createdAt": "2020-12-07T22:26:05Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/control/JITServerHelpers.cpp", "diffHunk": "@@ -44,84 +47,309 @@ TR::Monitor *JITServerHelpers::_clientStreamMonitor = NULL;\n static size_t\n getUTF8Size(const J9UTF8 *str)\n    {\n-   return OMR::alignNoCheck(str->length, sizeof(*str)) + sizeof(*str);\n+   return OMR::alignNoCheck(J9UTF8_TOTAL_SIZE(str), sizeof(*str));\n    }\n \n+// Copies a UTF8 string with padding and returns its total size\n static size_t\n-getPackedUTF8Size(const J9UTF8 *str, const J9ROMClass *romClass)\n+copyUTF8(J9UTF8 *dst, const J9UTF8 *src)\n    {\n-   return JITServerHelpers::isAddressInROMClass(str, romClass) ? 0 : getUTF8Size(str);\n+   size_t size = J9UTF8_TOTAL_SIZE(src);\n+   memcpy(dst, src, size);\n+   static_assert(sizeof(*src) == 2, \"UTF8 header is not 2 bytes large\");\n+   if (!OMR::alignedNoCheck(size, sizeof(*src)))\n+      dst->data[src->length] = '\\0';\n+   return OMR::alignNoCheck(size, sizeof(*src));\n    }\n \n-// If the string points outside of the contiguous part of origRomClass, appends\n-// it (with padding) at curPos and updates the SRP to the string in the packed\n-// ROMClass. Returns the new value of curPos.\n-static uint8_t *\n-packUTF8(uint8_t *curPos, const J9UTF8 *origStr, const J9ROMClass *origRomClass, J9SRP &srp)\n+// State maintained while iterating over UTF8 strings in a ROMClass\n+struct ROMClassPackContext\n    {\n-   if (JITServerHelpers::isAddressInROMClass(origStr, origRomClass))\n-      return curPos;\n+   ROMClassPackContext(TR_Memory *trMemory, size_t origRomSize) :\n+      origSize(origRomSize), callback(NULL), stringsSize(0),\n+      utf8SectionStart((const uint8_t *)-1), utf8SectionEnd(NULL), utf8SectionSize(0),\n+      strToOffsetMap(decltype(strToOffsetMap)::allocator_type(trMemory->currentStackRegion())),\n+      packedRomClass(NULL), cursor(NULL) {}\n \n-   size_t size = getUTF8Size(origStr);\n-   memcpy(curPos, origStr, origStr->length + sizeof(*origStr));\n-   static_assert(sizeof(*origStr) == 2, \"UTF8 header is not 2 bytes large\");\n-   if (!OMR::alignedNoCheck(origStr->length, sizeof(*origStr)))\n-      curPos[size - 1] = '\\0';\n-   NNSRP_SET(srp, curPos);\n-   return curPos + size;\n+   bool isInline(const void *address, const J9ROMClass *romClass)\n+      {\n+      return (address >= romClass) && (address < (uint8_t *)romClass + origSize);\n+      }\n+\n+   typedef void (*Callback)(const J9ROMClass *, const J9SRP *, const char *, ROMClassPackContext &);\n+\n+   const size_t origSize;\n+   Callback callback;\n+   size_t stringsSize;\n+   const uint8_t *utf8SectionStart;\n+   const uint8_t *utf8SectionEnd;// only needed for assertions\n+   size_t utf8SectionSize;// only needed for assertions\n+   // Maps original strings to their offsets from UTF8 section start in the packed ROMClass\n+   // Offset value -1 signifies that the string is skipped\n+   UnorderedMap<const J9UTF8 *, size_t> strToOffsetMap;\n+   J9ROMClass *packedRomClass;\n+   uint8_t *cursor;\n+   };\n+\n+static bool\n+shouldSkipSlot(const char *slotName)\n+   {\n+   // Skip variable names and signatures in method debug info; only their slot names have prefix \"variable\"\n+   static const char prefix[] = \"variable\";\n+   return strncmp(slotName, prefix, sizeof(prefix) - 1) == 0;\n+   }\n+\n+// Updates size info and maps original string to its future location in the packed ROMClass\n+static void\n+sizeInfoCallback(const J9ROMClass *romClass, const J9SRP *origSrp, const char *slotName, ROMClassPackContext &ctx)\n+   {\n+   // Skip SRPs stored outside of the ROMClass bounds such as the ones in out-of-line\n+   // method debug info, and the ones that point to strings not used by the JIT.\n+   bool skip = !ctx.isInline(origSrp, romClass) || shouldSkipSlot(slotName);\n+   auto str = NNSRP_PTR_GET(origSrp, const J9UTF8 *);\n+   auto it = ctx.strToOffsetMap.find(str);\n+   if (it != ctx.strToOffsetMap.end())// duplicate - already visited\n+      {\n+      if (!skip && (it->second == (size_t)-1))\n+         {\n+         // Previously visited SRPs to this string were skipped, but this one isn't\n+         it->second = ctx.stringsSize;\n+         ctx.stringsSize += getUTF8Size(str);\n+         }\n+      return;\n+      }\n+\n+   ctx.strToOffsetMap.insert(it, { str, skip ? (size_t)-1 : ctx.stringsSize });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf8bac93c10483471c4cef95c99e5644d0834e99"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODAwNDA3MQ==", "bodyText": "Yes, it's a bit faster since it avoids a hash lookup.", "url": "https://github.com/eclipse-openj9/openj9/pull/11331#discussion_r538004071", "createdAt": "2020-12-08T03:21:49Z", "author": {"login": "AlexeyKhrabrov"}, "path": "runtime/compiler/control/JITServerHelpers.cpp", "diffHunk": "@@ -44,84 +47,309 @@ TR::Monitor *JITServerHelpers::_clientStreamMonitor = NULL;\n static size_t\n getUTF8Size(const J9UTF8 *str)\n    {\n-   return OMR::alignNoCheck(str->length, sizeof(*str)) + sizeof(*str);\n+   return OMR::alignNoCheck(J9UTF8_TOTAL_SIZE(str), sizeof(*str));\n    }\n \n+// Copies a UTF8 string with padding and returns its total size\n static size_t\n-getPackedUTF8Size(const J9UTF8 *str, const J9ROMClass *romClass)\n+copyUTF8(J9UTF8 *dst, const J9UTF8 *src)\n    {\n-   return JITServerHelpers::isAddressInROMClass(str, romClass) ? 0 : getUTF8Size(str);\n+   size_t size = J9UTF8_TOTAL_SIZE(src);\n+   memcpy(dst, src, size);\n+   static_assert(sizeof(*src) == 2, \"UTF8 header is not 2 bytes large\");\n+   if (!OMR::alignedNoCheck(size, sizeof(*src)))\n+      dst->data[src->length] = '\\0';\n+   return OMR::alignNoCheck(size, sizeof(*src));\n    }\n \n-// If the string points outside of the contiguous part of origRomClass, appends\n-// it (with padding) at curPos and updates the SRP to the string in the packed\n-// ROMClass. Returns the new value of curPos.\n-static uint8_t *\n-packUTF8(uint8_t *curPos, const J9UTF8 *origStr, const J9ROMClass *origRomClass, J9SRP &srp)\n+// State maintained while iterating over UTF8 strings in a ROMClass\n+struct ROMClassPackContext\n    {\n-   if (JITServerHelpers::isAddressInROMClass(origStr, origRomClass))\n-      return curPos;\n+   ROMClassPackContext(TR_Memory *trMemory, size_t origRomSize) :\n+      origSize(origRomSize), callback(NULL), stringsSize(0),\n+      utf8SectionStart((const uint8_t *)-1), utf8SectionEnd(NULL), utf8SectionSize(0),\n+      strToOffsetMap(decltype(strToOffsetMap)::allocator_type(trMemory->currentStackRegion())),\n+      packedRomClass(NULL), cursor(NULL) {}\n \n-   size_t size = getUTF8Size(origStr);\n-   memcpy(curPos, origStr, origStr->length + sizeof(*origStr));\n-   static_assert(sizeof(*origStr) == 2, \"UTF8 header is not 2 bytes large\");\n-   if (!OMR::alignedNoCheck(origStr->length, sizeof(*origStr)))\n-      curPos[size - 1] = '\\0';\n-   NNSRP_SET(srp, curPos);\n-   return curPos + size;\n+   bool isInline(const void *address, const J9ROMClass *romClass)\n+      {\n+      return (address >= romClass) && (address < (uint8_t *)romClass + origSize);\n+      }\n+\n+   typedef void (*Callback)(const J9ROMClass *, const J9SRP *, const char *, ROMClassPackContext &);\n+\n+   const size_t origSize;\n+   Callback callback;\n+   size_t stringsSize;\n+   const uint8_t *utf8SectionStart;\n+   const uint8_t *utf8SectionEnd;// only needed for assertions\n+   size_t utf8SectionSize;// only needed for assertions\n+   // Maps original strings to their offsets from UTF8 section start in the packed ROMClass\n+   // Offset value -1 signifies that the string is skipped\n+   UnorderedMap<const J9UTF8 *, size_t> strToOffsetMap;\n+   J9ROMClass *packedRomClass;\n+   uint8_t *cursor;\n+   };\n+\n+static bool\n+shouldSkipSlot(const char *slotName)\n+   {\n+   // Skip variable names and signatures in method debug info; only their slot names have prefix \"variable\"\n+   static const char prefix[] = \"variable\";\n+   return strncmp(slotName, prefix, sizeof(prefix) - 1) == 0;\n+   }\n+\n+// Updates size info and maps original string to its future location in the packed ROMClass\n+static void\n+sizeInfoCallback(const J9ROMClass *romClass, const J9SRP *origSrp, const char *slotName, ROMClassPackContext &ctx)\n+   {\n+   // Skip SRPs stored outside of the ROMClass bounds such as the ones in out-of-line\n+   // method debug info, and the ones that point to strings not used by the JIT.\n+   bool skip = !ctx.isInline(origSrp, romClass) || shouldSkipSlot(slotName);\n+   auto str = NNSRP_PTR_GET(origSrp, const J9UTF8 *);\n+   auto it = ctx.strToOffsetMap.find(str);\n+   if (it != ctx.strToOffsetMap.end())// duplicate - already visited\n+      {\n+      if (!skip && (it->second == (size_t)-1))\n+         {\n+         // Previously visited SRPs to this string were skipped, but this one isn't\n+         it->second = ctx.stringsSize;\n+         ctx.stringsSize += getUTF8Size(str);\n+         }\n+      return;\n+      }\n+\n+   ctx.strToOffsetMap.insert(it, { str, skip ? (size_t)-1 : ctx.stringsSize });", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzg3OTk1Ng=="}, "originalCommit": {"oid": "cf8bac93c10483471c4cef95c99e5644d0834e99"}, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3Njg0Mjc5OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/control/JITServerHelpers.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QyMzoyOToxOFrOIA_q9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwMzoyMjoyMVrOIBFLIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkxNDEwMQ==", "bodyText": "Do strings that were inside the definition of a ROMClass keep their offsets in the packed version?", "url": "https://github.com/eclipse-openj9/openj9/pull/11331#discussion_r537914101", "createdAt": "2020-12-07T23:29:18Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/control/JITServerHelpers.cpp", "diffHunk": "@@ -44,84 +47,309 @@ TR::Monitor *JITServerHelpers::_clientStreamMonitor = NULL;\n static size_t\n getUTF8Size(const J9UTF8 *str)\n    {\n-   return OMR::alignNoCheck(str->length, sizeof(*str)) + sizeof(*str);\n+   return OMR::alignNoCheck(J9UTF8_TOTAL_SIZE(str), sizeof(*str));\n    }\n \n+// Copies a UTF8 string with padding and returns its total size\n static size_t\n-getPackedUTF8Size(const J9UTF8 *str, const J9ROMClass *romClass)\n+copyUTF8(J9UTF8 *dst, const J9UTF8 *src)\n    {\n-   return JITServerHelpers::isAddressInROMClass(str, romClass) ? 0 : getUTF8Size(str);\n+   size_t size = J9UTF8_TOTAL_SIZE(src);\n+   memcpy(dst, src, size);\n+   static_assert(sizeof(*src) == 2, \"UTF8 header is not 2 bytes large\");\n+   if (!OMR::alignedNoCheck(size, sizeof(*src)))\n+      dst->data[src->length] = '\\0';\n+   return OMR::alignNoCheck(size, sizeof(*src));\n    }\n \n-// If the string points outside of the contiguous part of origRomClass, appends\n-// it (with padding) at curPos and updates the SRP to the string in the packed\n-// ROMClass. Returns the new value of curPos.\n-static uint8_t *\n-packUTF8(uint8_t *curPos, const J9UTF8 *origStr, const J9ROMClass *origRomClass, J9SRP &srp)\n+// State maintained while iterating over UTF8 strings in a ROMClass\n+struct ROMClassPackContext\n    {\n-   if (JITServerHelpers::isAddressInROMClass(origStr, origRomClass))\n-      return curPos;\n+   ROMClassPackContext(TR_Memory *trMemory, size_t origRomSize) :\n+      origSize(origRomSize), callback(NULL), stringsSize(0),\n+      utf8SectionStart((const uint8_t *)-1), utf8SectionEnd(NULL), utf8SectionSize(0),\n+      strToOffsetMap(decltype(strToOffsetMap)::allocator_type(trMemory->currentStackRegion())),\n+      packedRomClass(NULL), cursor(NULL) {}\n \n-   size_t size = getUTF8Size(origStr);\n-   memcpy(curPos, origStr, origStr->length + sizeof(*origStr));\n-   static_assert(sizeof(*origStr) == 2, \"UTF8 header is not 2 bytes large\");\n-   if (!OMR::alignedNoCheck(origStr->length, sizeof(*origStr)))\n-      curPos[size - 1] = '\\0';\n-   NNSRP_SET(srp, curPos);\n-   return curPos + size;\n+   bool isInline(const void *address, const J9ROMClass *romClass)\n+      {\n+      return (address >= romClass) && (address < (uint8_t *)romClass + origSize);\n+      }\n+\n+   typedef void (*Callback)(const J9ROMClass *, const J9SRP *, const char *, ROMClassPackContext &);\n+\n+   const size_t origSize;\n+   Callback callback;\n+   size_t stringsSize;\n+   const uint8_t *utf8SectionStart;\n+   const uint8_t *utf8SectionEnd;// only needed for assertions\n+   size_t utf8SectionSize;// only needed for assertions\n+   // Maps original strings to their offsets from UTF8 section start in the packed ROMClass\n+   // Offset value -1 signifies that the string is skipped\n+   UnorderedMap<const J9UTF8 *, size_t> strToOffsetMap;\n+   J9ROMClass *packedRomClass;\n+   uint8_t *cursor;\n+   };\n+\n+static bool\n+shouldSkipSlot(const char *slotName)\n+   {\n+   // Skip variable names and signatures in method debug info; only their slot names have prefix \"variable\"\n+   static const char prefix[] = \"variable\";\n+   return strncmp(slotName, prefix, sizeof(prefix) - 1) == 0;\n+   }\n+\n+// Updates size info and maps original string to its future location in the packed ROMClass\n+static void\n+sizeInfoCallback(const J9ROMClass *romClass, const J9SRP *origSrp, const char *slotName, ROMClassPackContext &ctx)\n+   {\n+   // Skip SRPs stored outside of the ROMClass bounds such as the ones in out-of-line\n+   // method debug info, and the ones that point to strings not used by the JIT.\n+   bool skip = !ctx.isInline(origSrp, romClass) || shouldSkipSlot(slotName);\n+   auto str = NNSRP_PTR_GET(origSrp, const J9UTF8 *);\n+   auto it = ctx.strToOffsetMap.find(str);\n+   if (it != ctx.strToOffsetMap.end())// duplicate - already visited\n+      {\n+      if (!skip && (it->second == (size_t)-1))\n+         {\n+         // Previously visited SRPs to this string were skipped, but this one isn't\n+         it->second = ctx.stringsSize;\n+         ctx.stringsSize += getUTF8Size(str);\n+         }\n+      return;\n+      }\n+\n+   ctx.strToOffsetMap.insert(it, { str, skip ? (size_t)-1 : ctx.stringsSize });\n+   size_t size = getUTF8Size(str);\n+   ctx.stringsSize += skip ? 0 : size;\n+\n+   if (ctx.isInline(str, romClass))\n+      {\n+      ctx.utf8SectionStart = std::min(ctx.utf8SectionStart, (const uint8_t *)str);\n+      ctx.utf8SectionEnd = std::max(ctx.utf8SectionEnd, (const uint8_t *)str + size);\n+      ctx.utf8SectionSize += size;\n+      }\n+   }\n+\n+// Copies original string into its location in the packed ROMClass and updates the SRP to it\n+static void\n+packCallback(const J9ROMClass *romClass, const J9SRP *origSrp, const char *slotName, ROMClassPackContext &ctx)\n+   {\n+   // Skip SRPs stored outside of the ROMClass bounds such as the ones in out-of-line method debug info\n+   if (!ctx.isInline(origSrp, romClass))\n+      return;\n+\n+   auto str = NNSRP_PTR_GET(origSrp, const J9UTF8 *);\n+   auto srp = (J9SRP *)((uint8_t *)ctx.packedRomClass + ((uint8_t *)origSrp - (uint8_t *)romClass));\n+\n+   // Zero out skipped string SRPs\n+   if (shouldSkipSlot(slotName))\n+      {\n+      TR_ASSERT(ctx.strToOffsetMap.find(str) != ctx.strToOffsetMap.end(),\n+                \"UTF8 slot %s not visited in 1st pass\", slotName);\n+      *srp = 0;\n+      return;\n+      }\n+\n+   auto it = ctx.strToOffsetMap.find(str);\n+   TR_ASSERT(it != ctx.strToOffsetMap.end(), \"UTF8 slot %s not visited in 1st pass\", slotName);\n+   auto dst = (uint8_t *)ctx.packedRomClass + (ctx.utf8SectionStart - (uint8_t *)romClass) + it->second;\n+\n+   NNSRP_PTR_SET(srp, dst);\n+   if (dst == ctx.cursor)\n+      ctx.cursor += copyUTF8((J9UTF8 *)dst, str);\n+   else\n+      TR_ASSERT((dst < ctx.cursor) && (memcmp(dst, str, J9UTF8_TOTAL_SIZE(str)) == 0), \"Must be already copied\");\n+   }\n+\n+static void\n+utf8SlotCallback(const J9ROMClass *romClass, const J9SRP *srp, const char *slotName, void *userData)\n+   {\n+   auto &ctx = *(ROMClassPackContext *)userData;\n+   if (*srp)\n+      ctx.callback(romClass, srp, slotName, ctx);\n+   }\n+\n+// Invoked for each slot in a ROMClass. Calls ctx.callback() for all non-null SRPs to UTF8 strings.\n+static void\n+slotCallback(J9ROMClass *romClass, uint32_t slotType, void *slotPtr, const char *slotName, void *userData)\n+   {\n+   switch (slotType)\n+      {\n+      case J9ROM_UTF8:\n+         utf8SlotCallback(romClass, (const J9SRP *)slotPtr, slotName, userData);\n+         break;\n+\n+      case J9ROM_NAS:\n+         if (auto nas = SRP_PTR_GET(slotPtr, const J9ROMNameAndSignature *))\n+            {\n+            utf8SlotCallback(romClass, &nas->name, slotName, userData);\n+            utf8SlotCallback(romClass, &nas->signature, slotName, userData);\n+            }\n+         break;\n+      }\n+   }\n+\n+static bool\n+isArrayROMClass(const J9ROMClass *romClass)\n+   {\n+   if (!J9ROMCLASS_IS_ARRAY(romClass))\n+      return false;\n+\n+   auto name = J9ROMCLASS_CLASSNAME(romClass);\n+   TR_ASSERT((name->length == 2) && (name->data[0] == '['),\n+             \"Unexpected array ROMClass name: %.*s\", name->length, name->data);\n+   return true;\n+   }\n+\n+// Array ROMClasses have a different layout (see runtime/vm/romclasses.c):\n+// they all share the same SRP array of interfaces, which breaks the generic\n+// packing implementation. Instead, we manually pack all the data stored\n+// outside of the ROMClass header: class name, superclass name, interfaces.\n+// This function returns the total size of the packed array ROMClass.\n+static size_t\n+getArrayROMClassPackedSize(const J9ROMClass *romClass)\n+   {\n+   size_t totalSize = sizeof(*romClass);\n+   totalSize += getUTF8Size(J9ROMCLASS_CLASSNAME(romClass));\n+   totalSize += getUTF8Size(J9ROMCLASS_SUPERCLASSNAME(romClass));\n+\n+   totalSize += romClass->interfaceCount * sizeof(J9SRP);\n+   for (size_t i = 0; i < romClass->interfaceCount; ++i)\n+      {\n+      auto name = NNSRP_GET(J9ROMCLASS_INTERFACES(romClass)[i], const J9UTF8 *);\n+      totalSize += getUTF8Size(name);\n+      }\n+\n+   return OMR::alignNoCheck(totalSize, sizeof(uint64_t));\n+   }\n+\n+static void\n+packUTF8(const J9UTF8 *str, J9SRP &srp, ROMClassPackContext &ctx)\n+   {\n+   NNSRP_SET(srp, ctx.cursor);\n+   ctx.cursor += copyUTF8((J9UTF8 *)ctx.cursor, str);\n+   }\n+\n+// Packs the data stored outside of the array ROMClass header\n+static void\n+packArrayROMClassData(const J9ROMClass *romClass, ROMClassPackContext &ctx)\n+   {\n+   NNSRP_SET(ctx.packedRomClass->interfaces, ctx.cursor);\n+   ctx.cursor += ctx.packedRomClass->interfaceCount * sizeof(J9SRP);\n+\n+   packUTF8(J9ROMCLASS_CLASSNAME(romClass), ctx.packedRomClass->className, ctx);\n+   packUTF8(J9ROMCLASS_SUPERCLASSNAME(romClass), ctx.packedRomClass->superclassName, ctx);\n+\n+   for (size_t i = 0; i < romClass->interfaceCount; ++i)\n+      {\n+      auto name = NNSRP_GET(J9ROMCLASS_INTERFACES(romClass)[i], const J9UTF8 *);\n+      packUTF8(name, J9ROMCLASS_INTERFACES(ctx.packedRomClass)[i], ctx);\n+      }\n    }\n \n // Packs a ROMClass into a std::string to be transferred to the server.\n-// Some of the name and signature strings are interned and stored outside\n-// of the ROMClass body. Such strings are appended to the end of the cloned\n-// ROMClass body and the self referential pointers to them are updated.\n+// UTF8 strings that a ROMClass refers to can be interned and stored outside of\n+// the ROMClass body. This function puts all the strings (including interned ones)\n+// at the end of the cloned ROMClass in deterministic order and updates the SRPs\n+// to them. It also removes some of the data that is not used by the JIT compiler.\n+//\n+// Packing involves 2 passes over all the strings that a ROMClass refers to:\n+// 1. Compute total size and map original strings to their locations in the packed ROMClass.\n+// 2. Copy each original string to its location in the packed ROMClass.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf8bac93c10483471c4cef95c99e5644d0834e99"}, "originalPosition": 247}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODAwNDI1OA==", "bodyText": "In general, no. I will add a comment about that.", "url": "https://github.com/eclipse-openj9/openj9/pull/11331#discussion_r538004258", "createdAt": "2020-12-08T03:22:21Z", "author": {"login": "AlexeyKhrabrov"}, "path": "runtime/compiler/control/JITServerHelpers.cpp", "diffHunk": "@@ -44,84 +47,309 @@ TR::Monitor *JITServerHelpers::_clientStreamMonitor = NULL;\n static size_t\n getUTF8Size(const J9UTF8 *str)\n    {\n-   return OMR::alignNoCheck(str->length, sizeof(*str)) + sizeof(*str);\n+   return OMR::alignNoCheck(J9UTF8_TOTAL_SIZE(str), sizeof(*str));\n    }\n \n+// Copies a UTF8 string with padding and returns its total size\n static size_t\n-getPackedUTF8Size(const J9UTF8 *str, const J9ROMClass *romClass)\n+copyUTF8(J9UTF8 *dst, const J9UTF8 *src)\n    {\n-   return JITServerHelpers::isAddressInROMClass(str, romClass) ? 0 : getUTF8Size(str);\n+   size_t size = J9UTF8_TOTAL_SIZE(src);\n+   memcpy(dst, src, size);\n+   static_assert(sizeof(*src) == 2, \"UTF8 header is not 2 bytes large\");\n+   if (!OMR::alignedNoCheck(size, sizeof(*src)))\n+      dst->data[src->length] = '\\0';\n+   return OMR::alignNoCheck(size, sizeof(*src));\n    }\n \n-// If the string points outside of the contiguous part of origRomClass, appends\n-// it (with padding) at curPos and updates the SRP to the string in the packed\n-// ROMClass. Returns the new value of curPos.\n-static uint8_t *\n-packUTF8(uint8_t *curPos, const J9UTF8 *origStr, const J9ROMClass *origRomClass, J9SRP &srp)\n+// State maintained while iterating over UTF8 strings in a ROMClass\n+struct ROMClassPackContext\n    {\n-   if (JITServerHelpers::isAddressInROMClass(origStr, origRomClass))\n-      return curPos;\n+   ROMClassPackContext(TR_Memory *trMemory, size_t origRomSize) :\n+      origSize(origRomSize), callback(NULL), stringsSize(0),\n+      utf8SectionStart((const uint8_t *)-1), utf8SectionEnd(NULL), utf8SectionSize(0),\n+      strToOffsetMap(decltype(strToOffsetMap)::allocator_type(trMemory->currentStackRegion())),\n+      packedRomClass(NULL), cursor(NULL) {}\n \n-   size_t size = getUTF8Size(origStr);\n-   memcpy(curPos, origStr, origStr->length + sizeof(*origStr));\n-   static_assert(sizeof(*origStr) == 2, \"UTF8 header is not 2 bytes large\");\n-   if (!OMR::alignedNoCheck(origStr->length, sizeof(*origStr)))\n-      curPos[size - 1] = '\\0';\n-   NNSRP_SET(srp, curPos);\n-   return curPos + size;\n+   bool isInline(const void *address, const J9ROMClass *romClass)\n+      {\n+      return (address >= romClass) && (address < (uint8_t *)romClass + origSize);\n+      }\n+\n+   typedef void (*Callback)(const J9ROMClass *, const J9SRP *, const char *, ROMClassPackContext &);\n+\n+   const size_t origSize;\n+   Callback callback;\n+   size_t stringsSize;\n+   const uint8_t *utf8SectionStart;\n+   const uint8_t *utf8SectionEnd;// only needed for assertions\n+   size_t utf8SectionSize;// only needed for assertions\n+   // Maps original strings to their offsets from UTF8 section start in the packed ROMClass\n+   // Offset value -1 signifies that the string is skipped\n+   UnorderedMap<const J9UTF8 *, size_t> strToOffsetMap;\n+   J9ROMClass *packedRomClass;\n+   uint8_t *cursor;\n+   };\n+\n+static bool\n+shouldSkipSlot(const char *slotName)\n+   {\n+   // Skip variable names and signatures in method debug info; only their slot names have prefix \"variable\"\n+   static const char prefix[] = \"variable\";\n+   return strncmp(slotName, prefix, sizeof(prefix) - 1) == 0;\n+   }\n+\n+// Updates size info and maps original string to its future location in the packed ROMClass\n+static void\n+sizeInfoCallback(const J9ROMClass *romClass, const J9SRP *origSrp, const char *slotName, ROMClassPackContext &ctx)\n+   {\n+   // Skip SRPs stored outside of the ROMClass bounds such as the ones in out-of-line\n+   // method debug info, and the ones that point to strings not used by the JIT.\n+   bool skip = !ctx.isInline(origSrp, romClass) || shouldSkipSlot(slotName);\n+   auto str = NNSRP_PTR_GET(origSrp, const J9UTF8 *);\n+   auto it = ctx.strToOffsetMap.find(str);\n+   if (it != ctx.strToOffsetMap.end())// duplicate - already visited\n+      {\n+      if (!skip && (it->second == (size_t)-1))\n+         {\n+         // Previously visited SRPs to this string were skipped, but this one isn't\n+         it->second = ctx.stringsSize;\n+         ctx.stringsSize += getUTF8Size(str);\n+         }\n+      return;\n+      }\n+\n+   ctx.strToOffsetMap.insert(it, { str, skip ? (size_t)-1 : ctx.stringsSize });\n+   size_t size = getUTF8Size(str);\n+   ctx.stringsSize += skip ? 0 : size;\n+\n+   if (ctx.isInline(str, romClass))\n+      {\n+      ctx.utf8SectionStart = std::min(ctx.utf8SectionStart, (const uint8_t *)str);\n+      ctx.utf8SectionEnd = std::max(ctx.utf8SectionEnd, (const uint8_t *)str + size);\n+      ctx.utf8SectionSize += size;\n+      }\n+   }\n+\n+// Copies original string into its location in the packed ROMClass and updates the SRP to it\n+static void\n+packCallback(const J9ROMClass *romClass, const J9SRP *origSrp, const char *slotName, ROMClassPackContext &ctx)\n+   {\n+   // Skip SRPs stored outside of the ROMClass bounds such as the ones in out-of-line method debug info\n+   if (!ctx.isInline(origSrp, romClass))\n+      return;\n+\n+   auto str = NNSRP_PTR_GET(origSrp, const J9UTF8 *);\n+   auto srp = (J9SRP *)((uint8_t *)ctx.packedRomClass + ((uint8_t *)origSrp - (uint8_t *)romClass));\n+\n+   // Zero out skipped string SRPs\n+   if (shouldSkipSlot(slotName))\n+      {\n+      TR_ASSERT(ctx.strToOffsetMap.find(str) != ctx.strToOffsetMap.end(),\n+                \"UTF8 slot %s not visited in 1st pass\", slotName);\n+      *srp = 0;\n+      return;\n+      }\n+\n+   auto it = ctx.strToOffsetMap.find(str);\n+   TR_ASSERT(it != ctx.strToOffsetMap.end(), \"UTF8 slot %s not visited in 1st pass\", slotName);\n+   auto dst = (uint8_t *)ctx.packedRomClass + (ctx.utf8SectionStart - (uint8_t *)romClass) + it->second;\n+\n+   NNSRP_PTR_SET(srp, dst);\n+   if (dst == ctx.cursor)\n+      ctx.cursor += copyUTF8((J9UTF8 *)dst, str);\n+   else\n+      TR_ASSERT((dst < ctx.cursor) && (memcmp(dst, str, J9UTF8_TOTAL_SIZE(str)) == 0), \"Must be already copied\");\n+   }\n+\n+static void\n+utf8SlotCallback(const J9ROMClass *romClass, const J9SRP *srp, const char *slotName, void *userData)\n+   {\n+   auto &ctx = *(ROMClassPackContext *)userData;\n+   if (*srp)\n+      ctx.callback(romClass, srp, slotName, ctx);\n+   }\n+\n+// Invoked for each slot in a ROMClass. Calls ctx.callback() for all non-null SRPs to UTF8 strings.\n+static void\n+slotCallback(J9ROMClass *romClass, uint32_t slotType, void *slotPtr, const char *slotName, void *userData)\n+   {\n+   switch (slotType)\n+      {\n+      case J9ROM_UTF8:\n+         utf8SlotCallback(romClass, (const J9SRP *)slotPtr, slotName, userData);\n+         break;\n+\n+      case J9ROM_NAS:\n+         if (auto nas = SRP_PTR_GET(slotPtr, const J9ROMNameAndSignature *))\n+            {\n+            utf8SlotCallback(romClass, &nas->name, slotName, userData);\n+            utf8SlotCallback(romClass, &nas->signature, slotName, userData);\n+            }\n+         break;\n+      }\n+   }\n+\n+static bool\n+isArrayROMClass(const J9ROMClass *romClass)\n+   {\n+   if (!J9ROMCLASS_IS_ARRAY(romClass))\n+      return false;\n+\n+   auto name = J9ROMCLASS_CLASSNAME(romClass);\n+   TR_ASSERT((name->length == 2) && (name->data[0] == '['),\n+             \"Unexpected array ROMClass name: %.*s\", name->length, name->data);\n+   return true;\n+   }\n+\n+// Array ROMClasses have a different layout (see runtime/vm/romclasses.c):\n+// they all share the same SRP array of interfaces, which breaks the generic\n+// packing implementation. Instead, we manually pack all the data stored\n+// outside of the ROMClass header: class name, superclass name, interfaces.\n+// This function returns the total size of the packed array ROMClass.\n+static size_t\n+getArrayROMClassPackedSize(const J9ROMClass *romClass)\n+   {\n+   size_t totalSize = sizeof(*romClass);\n+   totalSize += getUTF8Size(J9ROMCLASS_CLASSNAME(romClass));\n+   totalSize += getUTF8Size(J9ROMCLASS_SUPERCLASSNAME(romClass));\n+\n+   totalSize += romClass->interfaceCount * sizeof(J9SRP);\n+   for (size_t i = 0; i < romClass->interfaceCount; ++i)\n+      {\n+      auto name = NNSRP_GET(J9ROMCLASS_INTERFACES(romClass)[i], const J9UTF8 *);\n+      totalSize += getUTF8Size(name);\n+      }\n+\n+   return OMR::alignNoCheck(totalSize, sizeof(uint64_t));\n+   }\n+\n+static void\n+packUTF8(const J9UTF8 *str, J9SRP &srp, ROMClassPackContext &ctx)\n+   {\n+   NNSRP_SET(srp, ctx.cursor);\n+   ctx.cursor += copyUTF8((J9UTF8 *)ctx.cursor, str);\n+   }\n+\n+// Packs the data stored outside of the array ROMClass header\n+static void\n+packArrayROMClassData(const J9ROMClass *romClass, ROMClassPackContext &ctx)\n+   {\n+   NNSRP_SET(ctx.packedRomClass->interfaces, ctx.cursor);\n+   ctx.cursor += ctx.packedRomClass->interfaceCount * sizeof(J9SRP);\n+\n+   packUTF8(J9ROMCLASS_CLASSNAME(romClass), ctx.packedRomClass->className, ctx);\n+   packUTF8(J9ROMCLASS_SUPERCLASSNAME(romClass), ctx.packedRomClass->superclassName, ctx);\n+\n+   for (size_t i = 0; i < romClass->interfaceCount; ++i)\n+      {\n+      auto name = NNSRP_GET(J9ROMCLASS_INTERFACES(romClass)[i], const J9UTF8 *);\n+      packUTF8(name, J9ROMCLASS_INTERFACES(ctx.packedRomClass)[i], ctx);\n+      }\n    }\n \n // Packs a ROMClass into a std::string to be transferred to the server.\n-// Some of the name and signature strings are interned and stored outside\n-// of the ROMClass body. Such strings are appended to the end of the cloned\n-// ROMClass body and the self referential pointers to them are updated.\n+// UTF8 strings that a ROMClass refers to can be interned and stored outside of\n+// the ROMClass body. This function puts all the strings (including interned ones)\n+// at the end of the cloned ROMClass in deterministic order and updates the SRPs\n+// to them. It also removes some of the data that is not used by the JIT compiler.\n+//\n+// Packing involves 2 passes over all the strings that a ROMClass refers to:\n+// 1. Compute total size and map original strings to their locations in the packed ROMClass.\n+// 2. Copy each original string to its location in the packed ROMClass.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkxNDEwMQ=="}, "originalCommit": {"oid": "cf8bac93c10483471c4cef95c99e5644d0834e99"}, "originalPosition": 247}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3NzE3MzQzOnYy", "diffSide": "RIGHT", "path": "runtime/compiler/control/JITServerHelpers.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwMToyNDozMlrOIBCf3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwMzoyNDo1OVrOIBFOZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk2MDQxNA==", "bodyText": "What is intermediate class data?", "url": "https://github.com/eclipse-openj9/openj9/pull/11331#discussion_r537960414", "createdAt": "2020-12-08T01:24:32Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/control/JITServerHelpers.cpp", "diffHunk": "@@ -44,84 +47,309 @@ TR::Monitor *JITServerHelpers::_clientStreamMonitor = NULL;\n static size_t\n getUTF8Size(const J9UTF8 *str)\n    {\n-   return OMR::alignNoCheck(str->length, sizeof(*str)) + sizeof(*str);\n+   return OMR::alignNoCheck(J9UTF8_TOTAL_SIZE(str), sizeof(*str));\n    }\n \n+// Copies a UTF8 string with padding and returns its total size\n static size_t\n-getPackedUTF8Size(const J9UTF8 *str, const J9ROMClass *romClass)\n+copyUTF8(J9UTF8 *dst, const J9UTF8 *src)\n    {\n-   return JITServerHelpers::isAddressInROMClass(str, romClass) ? 0 : getUTF8Size(str);\n+   size_t size = J9UTF8_TOTAL_SIZE(src);\n+   memcpy(dst, src, size);\n+   static_assert(sizeof(*src) == 2, \"UTF8 header is not 2 bytes large\");\n+   if (!OMR::alignedNoCheck(size, sizeof(*src)))\n+      dst->data[src->length] = '\\0';\n+   return OMR::alignNoCheck(size, sizeof(*src));\n    }\n \n-// If the string points outside of the contiguous part of origRomClass, appends\n-// it (with padding) at curPos and updates the SRP to the string in the packed\n-// ROMClass. Returns the new value of curPos.\n-static uint8_t *\n-packUTF8(uint8_t *curPos, const J9UTF8 *origStr, const J9ROMClass *origRomClass, J9SRP &srp)\n+// State maintained while iterating over UTF8 strings in a ROMClass\n+struct ROMClassPackContext\n    {\n-   if (JITServerHelpers::isAddressInROMClass(origStr, origRomClass))\n-      return curPos;\n+   ROMClassPackContext(TR_Memory *trMemory, size_t origRomSize) :\n+      origSize(origRomSize), callback(NULL), stringsSize(0),\n+      utf8SectionStart((const uint8_t *)-1), utf8SectionEnd(NULL), utf8SectionSize(0),\n+      strToOffsetMap(decltype(strToOffsetMap)::allocator_type(trMemory->currentStackRegion())),\n+      packedRomClass(NULL), cursor(NULL) {}\n \n-   size_t size = getUTF8Size(origStr);\n-   memcpy(curPos, origStr, origStr->length + sizeof(*origStr));\n-   static_assert(sizeof(*origStr) == 2, \"UTF8 header is not 2 bytes large\");\n-   if (!OMR::alignedNoCheck(origStr->length, sizeof(*origStr)))\n-      curPos[size - 1] = '\\0';\n-   NNSRP_SET(srp, curPos);\n-   return curPos + size;\n+   bool isInline(const void *address, const J9ROMClass *romClass)\n+      {\n+      return (address >= romClass) && (address < (uint8_t *)romClass + origSize);\n+      }\n+\n+   typedef void (*Callback)(const J9ROMClass *, const J9SRP *, const char *, ROMClassPackContext &);\n+\n+   const size_t origSize;\n+   Callback callback;\n+   size_t stringsSize;\n+   const uint8_t *utf8SectionStart;\n+   const uint8_t *utf8SectionEnd;// only needed for assertions\n+   size_t utf8SectionSize;// only needed for assertions\n+   // Maps original strings to their offsets from UTF8 section start in the packed ROMClass\n+   // Offset value -1 signifies that the string is skipped\n+   UnorderedMap<const J9UTF8 *, size_t> strToOffsetMap;\n+   J9ROMClass *packedRomClass;\n+   uint8_t *cursor;\n+   };\n+\n+static bool\n+shouldSkipSlot(const char *slotName)\n+   {\n+   // Skip variable names and signatures in method debug info; only their slot names have prefix \"variable\"\n+   static const char prefix[] = \"variable\";\n+   return strncmp(slotName, prefix, sizeof(prefix) - 1) == 0;\n+   }\n+\n+// Updates size info and maps original string to its future location in the packed ROMClass\n+static void\n+sizeInfoCallback(const J9ROMClass *romClass, const J9SRP *origSrp, const char *slotName, ROMClassPackContext &ctx)\n+   {\n+   // Skip SRPs stored outside of the ROMClass bounds such as the ones in out-of-line\n+   // method debug info, and the ones that point to strings not used by the JIT.\n+   bool skip = !ctx.isInline(origSrp, romClass) || shouldSkipSlot(slotName);\n+   auto str = NNSRP_PTR_GET(origSrp, const J9UTF8 *);\n+   auto it = ctx.strToOffsetMap.find(str);\n+   if (it != ctx.strToOffsetMap.end())// duplicate - already visited\n+      {\n+      if (!skip && (it->second == (size_t)-1))\n+         {\n+         // Previously visited SRPs to this string were skipped, but this one isn't\n+         it->second = ctx.stringsSize;\n+         ctx.stringsSize += getUTF8Size(str);\n+         }\n+      return;\n+      }\n+\n+   ctx.strToOffsetMap.insert(it, { str, skip ? (size_t)-1 : ctx.stringsSize });\n+   size_t size = getUTF8Size(str);\n+   ctx.stringsSize += skip ? 0 : size;\n+\n+   if (ctx.isInline(str, romClass))\n+      {\n+      ctx.utf8SectionStart = std::min(ctx.utf8SectionStart, (const uint8_t *)str);\n+      ctx.utf8SectionEnd = std::max(ctx.utf8SectionEnd, (const uint8_t *)str + size);\n+      ctx.utf8SectionSize += size;\n+      }\n+   }\n+\n+// Copies original string into its location in the packed ROMClass and updates the SRP to it\n+static void\n+packCallback(const J9ROMClass *romClass, const J9SRP *origSrp, const char *slotName, ROMClassPackContext &ctx)\n+   {\n+   // Skip SRPs stored outside of the ROMClass bounds such as the ones in out-of-line method debug info\n+   if (!ctx.isInline(origSrp, romClass))\n+      return;\n+\n+   auto str = NNSRP_PTR_GET(origSrp, const J9UTF8 *);\n+   auto srp = (J9SRP *)((uint8_t *)ctx.packedRomClass + ((uint8_t *)origSrp - (uint8_t *)romClass));\n+\n+   // Zero out skipped string SRPs\n+   if (shouldSkipSlot(slotName))\n+      {\n+      TR_ASSERT(ctx.strToOffsetMap.find(str) != ctx.strToOffsetMap.end(),\n+                \"UTF8 slot %s not visited in 1st pass\", slotName);\n+      *srp = 0;\n+      return;\n+      }\n+\n+   auto it = ctx.strToOffsetMap.find(str);\n+   TR_ASSERT(it != ctx.strToOffsetMap.end(), \"UTF8 slot %s not visited in 1st pass\", slotName);\n+   auto dst = (uint8_t *)ctx.packedRomClass + (ctx.utf8SectionStart - (uint8_t *)romClass) + it->second;\n+\n+   NNSRP_PTR_SET(srp, dst);\n+   if (dst == ctx.cursor)\n+      ctx.cursor += copyUTF8((J9UTF8 *)dst, str);\n+   else\n+      TR_ASSERT((dst < ctx.cursor) && (memcmp(dst, str, J9UTF8_TOTAL_SIZE(str)) == 0), \"Must be already copied\");\n+   }\n+\n+static void\n+utf8SlotCallback(const J9ROMClass *romClass, const J9SRP *srp, const char *slotName, void *userData)\n+   {\n+   auto &ctx = *(ROMClassPackContext *)userData;\n+   if (*srp)\n+      ctx.callback(romClass, srp, slotName, ctx);\n+   }\n+\n+// Invoked for each slot in a ROMClass. Calls ctx.callback() for all non-null SRPs to UTF8 strings.\n+static void\n+slotCallback(J9ROMClass *romClass, uint32_t slotType, void *slotPtr, const char *slotName, void *userData)\n+   {\n+   switch (slotType)\n+      {\n+      case J9ROM_UTF8:\n+         utf8SlotCallback(romClass, (const J9SRP *)slotPtr, slotName, userData);\n+         break;\n+\n+      case J9ROM_NAS:\n+         if (auto nas = SRP_PTR_GET(slotPtr, const J9ROMNameAndSignature *))\n+            {\n+            utf8SlotCallback(romClass, &nas->name, slotName, userData);\n+            utf8SlotCallback(romClass, &nas->signature, slotName, userData);\n+            }\n+         break;\n+      }\n+   }\n+\n+static bool\n+isArrayROMClass(const J9ROMClass *romClass)\n+   {\n+   if (!J9ROMCLASS_IS_ARRAY(romClass))\n+      return false;\n+\n+   auto name = J9ROMCLASS_CLASSNAME(romClass);\n+   TR_ASSERT((name->length == 2) && (name->data[0] == '['),\n+             \"Unexpected array ROMClass name: %.*s\", name->length, name->data);\n+   return true;\n+   }\n+\n+// Array ROMClasses have a different layout (see runtime/vm/romclasses.c):\n+// they all share the same SRP array of interfaces, which breaks the generic\n+// packing implementation. Instead, we manually pack all the data stored\n+// outside of the ROMClass header: class name, superclass name, interfaces.\n+// This function returns the total size of the packed array ROMClass.\n+static size_t\n+getArrayROMClassPackedSize(const J9ROMClass *romClass)\n+   {\n+   size_t totalSize = sizeof(*romClass);\n+   totalSize += getUTF8Size(J9ROMCLASS_CLASSNAME(romClass));\n+   totalSize += getUTF8Size(J9ROMCLASS_SUPERCLASSNAME(romClass));\n+\n+   totalSize += romClass->interfaceCount * sizeof(J9SRP);\n+   for (size_t i = 0; i < romClass->interfaceCount; ++i)\n+      {\n+      auto name = NNSRP_GET(J9ROMCLASS_INTERFACES(romClass)[i], const J9UTF8 *);\n+      totalSize += getUTF8Size(name);\n+      }\n+\n+   return OMR::alignNoCheck(totalSize, sizeof(uint64_t));\n+   }\n+\n+static void\n+packUTF8(const J9UTF8 *str, J9SRP &srp, ROMClassPackContext &ctx)\n+   {\n+   NNSRP_SET(srp, ctx.cursor);\n+   ctx.cursor += copyUTF8((J9UTF8 *)ctx.cursor, str);\n+   }\n+\n+// Packs the data stored outside of the array ROMClass header\n+static void\n+packArrayROMClassData(const J9ROMClass *romClass, ROMClassPackContext &ctx)\n+   {\n+   NNSRP_SET(ctx.packedRomClass->interfaces, ctx.cursor);\n+   ctx.cursor += ctx.packedRomClass->interfaceCount * sizeof(J9SRP);\n+\n+   packUTF8(J9ROMCLASS_CLASSNAME(romClass), ctx.packedRomClass->className, ctx);\n+   packUTF8(J9ROMCLASS_SUPERCLASSNAME(romClass), ctx.packedRomClass->superclassName, ctx);\n+\n+   for (size_t i = 0; i < romClass->interfaceCount; ++i)\n+      {\n+      auto name = NNSRP_GET(J9ROMCLASS_INTERFACES(romClass)[i], const J9UTF8 *);\n+      packUTF8(name, J9ROMCLASS_INTERFACES(ctx.packedRomClass)[i], ctx);\n+      }\n    }\n \n // Packs a ROMClass into a std::string to be transferred to the server.\n-// Some of the name and signature strings are interned and stored outside\n-// of the ROMClass body. Such strings are appended to the end of the cloned\n-// ROMClass body and the self referential pointers to them are updated.\n+// UTF8 strings that a ROMClass refers to can be interned and stored outside of\n+// the ROMClass body. This function puts all the strings (including interned ones)\n+// at the end of the cloned ROMClass in deterministic order and updates the SRPs\n+// to them. It also removes some of the data that is not used by the JIT compiler.\n+//\n+// Packing involves 2 passes over all the strings that a ROMClass refers to:\n+// 1. Compute total size and map original strings to their locations in the packed ROMClass.\n+// 2. Copy each original string to its location in the packed ROMClass.\n static std::string\n-packROMClass(J9ROMClass *origRomClass, TR_Memory *trMemory)\n+packROMClass(J9ROMClass *romClass, TR_Memory *trMemory)\n    {\n-   size_t totalSize = origRomClass->romSize;\n-   J9UTF8 *className = J9ROMCLASS_CLASSNAME(origRomClass);\n-   totalSize += getPackedUTF8Size(className, origRomClass);\n-\n-   J9ROMMethod *romMethod = J9ROMCLASS_ROMMETHODS(origRomClass);\n-   for (size_t i = 0; i < origRomClass->romMethodCount; ++i)\n+   auto name = J9ROMCLASS_CLASSNAME(romClass);\n+   // Primitive ROMClasses have different layout (see runtime/vm/romclasses.c): the last\n+   // ROMClass includes all the others' UTF8 name strings in its romSize, which breaks the\n+   // generic packing implementation. Pretend that its romSize only includes the header.\n+   size_t origRomSize = J9ROMCLASS_IS_PRIMITIVE_TYPE(romClass) ? sizeof(*romClass) : romClass->romSize;\n+   size_t totalSize = origRomSize;\n+\n+   // Remove intermediate class data (not used by JIT)\n+   uint8_t *icData = J9ROMCLASS_INTERMEDIATECLASSDATA(romClass);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf8bac93c10483471c4cef95c99e5644d0834e99"}, "originalPosition": 266}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODAwNTA5NA==", "bodyText": "Not sure, I haven't explored enough VM code to fully understand it yet. But it looks like the JIT never accesses it, so it should be safe to exclude it if it's present.", "url": "https://github.com/eclipse-openj9/openj9/pull/11331#discussion_r538005094", "createdAt": "2020-12-08T03:24:59Z", "author": {"login": "AlexeyKhrabrov"}, "path": "runtime/compiler/control/JITServerHelpers.cpp", "diffHunk": "@@ -44,84 +47,309 @@ TR::Monitor *JITServerHelpers::_clientStreamMonitor = NULL;\n static size_t\n getUTF8Size(const J9UTF8 *str)\n    {\n-   return OMR::alignNoCheck(str->length, sizeof(*str)) + sizeof(*str);\n+   return OMR::alignNoCheck(J9UTF8_TOTAL_SIZE(str), sizeof(*str));\n    }\n \n+// Copies a UTF8 string with padding and returns its total size\n static size_t\n-getPackedUTF8Size(const J9UTF8 *str, const J9ROMClass *romClass)\n+copyUTF8(J9UTF8 *dst, const J9UTF8 *src)\n    {\n-   return JITServerHelpers::isAddressInROMClass(str, romClass) ? 0 : getUTF8Size(str);\n+   size_t size = J9UTF8_TOTAL_SIZE(src);\n+   memcpy(dst, src, size);\n+   static_assert(sizeof(*src) == 2, \"UTF8 header is not 2 bytes large\");\n+   if (!OMR::alignedNoCheck(size, sizeof(*src)))\n+      dst->data[src->length] = '\\0';\n+   return OMR::alignNoCheck(size, sizeof(*src));\n    }\n \n-// If the string points outside of the contiguous part of origRomClass, appends\n-// it (with padding) at curPos and updates the SRP to the string in the packed\n-// ROMClass. Returns the new value of curPos.\n-static uint8_t *\n-packUTF8(uint8_t *curPos, const J9UTF8 *origStr, const J9ROMClass *origRomClass, J9SRP &srp)\n+// State maintained while iterating over UTF8 strings in a ROMClass\n+struct ROMClassPackContext\n    {\n-   if (JITServerHelpers::isAddressInROMClass(origStr, origRomClass))\n-      return curPos;\n+   ROMClassPackContext(TR_Memory *trMemory, size_t origRomSize) :\n+      origSize(origRomSize), callback(NULL), stringsSize(0),\n+      utf8SectionStart((const uint8_t *)-1), utf8SectionEnd(NULL), utf8SectionSize(0),\n+      strToOffsetMap(decltype(strToOffsetMap)::allocator_type(trMemory->currentStackRegion())),\n+      packedRomClass(NULL), cursor(NULL) {}\n \n-   size_t size = getUTF8Size(origStr);\n-   memcpy(curPos, origStr, origStr->length + sizeof(*origStr));\n-   static_assert(sizeof(*origStr) == 2, \"UTF8 header is not 2 bytes large\");\n-   if (!OMR::alignedNoCheck(origStr->length, sizeof(*origStr)))\n-      curPos[size - 1] = '\\0';\n-   NNSRP_SET(srp, curPos);\n-   return curPos + size;\n+   bool isInline(const void *address, const J9ROMClass *romClass)\n+      {\n+      return (address >= romClass) && (address < (uint8_t *)romClass + origSize);\n+      }\n+\n+   typedef void (*Callback)(const J9ROMClass *, const J9SRP *, const char *, ROMClassPackContext &);\n+\n+   const size_t origSize;\n+   Callback callback;\n+   size_t stringsSize;\n+   const uint8_t *utf8SectionStart;\n+   const uint8_t *utf8SectionEnd;// only needed for assertions\n+   size_t utf8SectionSize;// only needed for assertions\n+   // Maps original strings to their offsets from UTF8 section start in the packed ROMClass\n+   // Offset value -1 signifies that the string is skipped\n+   UnorderedMap<const J9UTF8 *, size_t> strToOffsetMap;\n+   J9ROMClass *packedRomClass;\n+   uint8_t *cursor;\n+   };\n+\n+static bool\n+shouldSkipSlot(const char *slotName)\n+   {\n+   // Skip variable names and signatures in method debug info; only their slot names have prefix \"variable\"\n+   static const char prefix[] = \"variable\";\n+   return strncmp(slotName, prefix, sizeof(prefix) - 1) == 0;\n+   }\n+\n+// Updates size info and maps original string to its future location in the packed ROMClass\n+static void\n+sizeInfoCallback(const J9ROMClass *romClass, const J9SRP *origSrp, const char *slotName, ROMClassPackContext &ctx)\n+   {\n+   // Skip SRPs stored outside of the ROMClass bounds such as the ones in out-of-line\n+   // method debug info, and the ones that point to strings not used by the JIT.\n+   bool skip = !ctx.isInline(origSrp, romClass) || shouldSkipSlot(slotName);\n+   auto str = NNSRP_PTR_GET(origSrp, const J9UTF8 *);\n+   auto it = ctx.strToOffsetMap.find(str);\n+   if (it != ctx.strToOffsetMap.end())// duplicate - already visited\n+      {\n+      if (!skip && (it->second == (size_t)-1))\n+         {\n+         // Previously visited SRPs to this string were skipped, but this one isn't\n+         it->second = ctx.stringsSize;\n+         ctx.stringsSize += getUTF8Size(str);\n+         }\n+      return;\n+      }\n+\n+   ctx.strToOffsetMap.insert(it, { str, skip ? (size_t)-1 : ctx.stringsSize });\n+   size_t size = getUTF8Size(str);\n+   ctx.stringsSize += skip ? 0 : size;\n+\n+   if (ctx.isInline(str, romClass))\n+      {\n+      ctx.utf8SectionStart = std::min(ctx.utf8SectionStart, (const uint8_t *)str);\n+      ctx.utf8SectionEnd = std::max(ctx.utf8SectionEnd, (const uint8_t *)str + size);\n+      ctx.utf8SectionSize += size;\n+      }\n+   }\n+\n+// Copies original string into its location in the packed ROMClass and updates the SRP to it\n+static void\n+packCallback(const J9ROMClass *romClass, const J9SRP *origSrp, const char *slotName, ROMClassPackContext &ctx)\n+   {\n+   // Skip SRPs stored outside of the ROMClass bounds such as the ones in out-of-line method debug info\n+   if (!ctx.isInline(origSrp, romClass))\n+      return;\n+\n+   auto str = NNSRP_PTR_GET(origSrp, const J9UTF8 *);\n+   auto srp = (J9SRP *)((uint8_t *)ctx.packedRomClass + ((uint8_t *)origSrp - (uint8_t *)romClass));\n+\n+   // Zero out skipped string SRPs\n+   if (shouldSkipSlot(slotName))\n+      {\n+      TR_ASSERT(ctx.strToOffsetMap.find(str) != ctx.strToOffsetMap.end(),\n+                \"UTF8 slot %s not visited in 1st pass\", slotName);\n+      *srp = 0;\n+      return;\n+      }\n+\n+   auto it = ctx.strToOffsetMap.find(str);\n+   TR_ASSERT(it != ctx.strToOffsetMap.end(), \"UTF8 slot %s not visited in 1st pass\", slotName);\n+   auto dst = (uint8_t *)ctx.packedRomClass + (ctx.utf8SectionStart - (uint8_t *)romClass) + it->second;\n+\n+   NNSRP_PTR_SET(srp, dst);\n+   if (dst == ctx.cursor)\n+      ctx.cursor += copyUTF8((J9UTF8 *)dst, str);\n+   else\n+      TR_ASSERT((dst < ctx.cursor) && (memcmp(dst, str, J9UTF8_TOTAL_SIZE(str)) == 0), \"Must be already copied\");\n+   }\n+\n+static void\n+utf8SlotCallback(const J9ROMClass *romClass, const J9SRP *srp, const char *slotName, void *userData)\n+   {\n+   auto &ctx = *(ROMClassPackContext *)userData;\n+   if (*srp)\n+      ctx.callback(romClass, srp, slotName, ctx);\n+   }\n+\n+// Invoked for each slot in a ROMClass. Calls ctx.callback() for all non-null SRPs to UTF8 strings.\n+static void\n+slotCallback(J9ROMClass *romClass, uint32_t slotType, void *slotPtr, const char *slotName, void *userData)\n+   {\n+   switch (slotType)\n+      {\n+      case J9ROM_UTF8:\n+         utf8SlotCallback(romClass, (const J9SRP *)slotPtr, slotName, userData);\n+         break;\n+\n+      case J9ROM_NAS:\n+         if (auto nas = SRP_PTR_GET(slotPtr, const J9ROMNameAndSignature *))\n+            {\n+            utf8SlotCallback(romClass, &nas->name, slotName, userData);\n+            utf8SlotCallback(romClass, &nas->signature, slotName, userData);\n+            }\n+         break;\n+      }\n+   }\n+\n+static bool\n+isArrayROMClass(const J9ROMClass *romClass)\n+   {\n+   if (!J9ROMCLASS_IS_ARRAY(romClass))\n+      return false;\n+\n+   auto name = J9ROMCLASS_CLASSNAME(romClass);\n+   TR_ASSERT((name->length == 2) && (name->data[0] == '['),\n+             \"Unexpected array ROMClass name: %.*s\", name->length, name->data);\n+   return true;\n+   }\n+\n+// Array ROMClasses have a different layout (see runtime/vm/romclasses.c):\n+// they all share the same SRP array of interfaces, which breaks the generic\n+// packing implementation. Instead, we manually pack all the data stored\n+// outside of the ROMClass header: class name, superclass name, interfaces.\n+// This function returns the total size of the packed array ROMClass.\n+static size_t\n+getArrayROMClassPackedSize(const J9ROMClass *romClass)\n+   {\n+   size_t totalSize = sizeof(*romClass);\n+   totalSize += getUTF8Size(J9ROMCLASS_CLASSNAME(romClass));\n+   totalSize += getUTF8Size(J9ROMCLASS_SUPERCLASSNAME(romClass));\n+\n+   totalSize += romClass->interfaceCount * sizeof(J9SRP);\n+   for (size_t i = 0; i < romClass->interfaceCount; ++i)\n+      {\n+      auto name = NNSRP_GET(J9ROMCLASS_INTERFACES(romClass)[i], const J9UTF8 *);\n+      totalSize += getUTF8Size(name);\n+      }\n+\n+   return OMR::alignNoCheck(totalSize, sizeof(uint64_t));\n+   }\n+\n+static void\n+packUTF8(const J9UTF8 *str, J9SRP &srp, ROMClassPackContext &ctx)\n+   {\n+   NNSRP_SET(srp, ctx.cursor);\n+   ctx.cursor += copyUTF8((J9UTF8 *)ctx.cursor, str);\n+   }\n+\n+// Packs the data stored outside of the array ROMClass header\n+static void\n+packArrayROMClassData(const J9ROMClass *romClass, ROMClassPackContext &ctx)\n+   {\n+   NNSRP_SET(ctx.packedRomClass->interfaces, ctx.cursor);\n+   ctx.cursor += ctx.packedRomClass->interfaceCount * sizeof(J9SRP);\n+\n+   packUTF8(J9ROMCLASS_CLASSNAME(romClass), ctx.packedRomClass->className, ctx);\n+   packUTF8(J9ROMCLASS_SUPERCLASSNAME(romClass), ctx.packedRomClass->superclassName, ctx);\n+\n+   for (size_t i = 0; i < romClass->interfaceCount; ++i)\n+      {\n+      auto name = NNSRP_GET(J9ROMCLASS_INTERFACES(romClass)[i], const J9UTF8 *);\n+      packUTF8(name, J9ROMCLASS_INTERFACES(ctx.packedRomClass)[i], ctx);\n+      }\n    }\n \n // Packs a ROMClass into a std::string to be transferred to the server.\n-// Some of the name and signature strings are interned and stored outside\n-// of the ROMClass body. Such strings are appended to the end of the cloned\n-// ROMClass body and the self referential pointers to them are updated.\n+// UTF8 strings that a ROMClass refers to can be interned and stored outside of\n+// the ROMClass body. This function puts all the strings (including interned ones)\n+// at the end of the cloned ROMClass in deterministic order and updates the SRPs\n+// to them. It also removes some of the data that is not used by the JIT compiler.\n+//\n+// Packing involves 2 passes over all the strings that a ROMClass refers to:\n+// 1. Compute total size and map original strings to their locations in the packed ROMClass.\n+// 2. Copy each original string to its location in the packed ROMClass.\n static std::string\n-packROMClass(J9ROMClass *origRomClass, TR_Memory *trMemory)\n+packROMClass(J9ROMClass *romClass, TR_Memory *trMemory)\n    {\n-   size_t totalSize = origRomClass->romSize;\n-   J9UTF8 *className = J9ROMCLASS_CLASSNAME(origRomClass);\n-   totalSize += getPackedUTF8Size(className, origRomClass);\n-\n-   J9ROMMethod *romMethod = J9ROMCLASS_ROMMETHODS(origRomClass);\n-   for (size_t i = 0; i < origRomClass->romMethodCount; ++i)\n+   auto name = J9ROMCLASS_CLASSNAME(romClass);\n+   // Primitive ROMClasses have different layout (see runtime/vm/romclasses.c): the last\n+   // ROMClass includes all the others' UTF8 name strings in its romSize, which breaks the\n+   // generic packing implementation. Pretend that its romSize only includes the header.\n+   size_t origRomSize = J9ROMCLASS_IS_PRIMITIVE_TYPE(romClass) ? sizeof(*romClass) : romClass->romSize;\n+   size_t totalSize = origRomSize;\n+\n+   // Remove intermediate class data (not used by JIT)\n+   uint8_t *icData = J9ROMCLASS_INTERMEDIATECLASSDATA(romClass);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk2MDQxNA=="}, "originalCommit": {"oid": "cf8bac93c10483471c4cef95c99e5644d0834e99"}, "originalPosition": 266}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3NzE3NzM5OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/control/JITServerHelpers.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwMToyNjoxMVrOIBCiEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwMzoyMzowMVrOIBFMBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk2MDk3Nw==", "bodyText": "I am guessing that you cannot have intermediate class data for primitive classes that only have the \"header\"", "url": "https://github.com/eclipse-openj9/openj9/pull/11331#discussion_r537960977", "createdAt": "2020-12-08T01:26:11Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/control/JITServerHelpers.cpp", "diffHunk": "@@ -44,84 +47,309 @@ TR::Monitor *JITServerHelpers::_clientStreamMonitor = NULL;\n static size_t\n getUTF8Size(const J9UTF8 *str)\n    {\n-   return OMR::alignNoCheck(str->length, sizeof(*str)) + sizeof(*str);\n+   return OMR::alignNoCheck(J9UTF8_TOTAL_SIZE(str), sizeof(*str));\n    }\n \n+// Copies a UTF8 string with padding and returns its total size\n static size_t\n-getPackedUTF8Size(const J9UTF8 *str, const J9ROMClass *romClass)\n+copyUTF8(J9UTF8 *dst, const J9UTF8 *src)\n    {\n-   return JITServerHelpers::isAddressInROMClass(str, romClass) ? 0 : getUTF8Size(str);\n+   size_t size = J9UTF8_TOTAL_SIZE(src);\n+   memcpy(dst, src, size);\n+   static_assert(sizeof(*src) == 2, \"UTF8 header is not 2 bytes large\");\n+   if (!OMR::alignedNoCheck(size, sizeof(*src)))\n+      dst->data[src->length] = '\\0';\n+   return OMR::alignNoCheck(size, sizeof(*src));\n    }\n \n-// If the string points outside of the contiguous part of origRomClass, appends\n-// it (with padding) at curPos and updates the SRP to the string in the packed\n-// ROMClass. Returns the new value of curPos.\n-static uint8_t *\n-packUTF8(uint8_t *curPos, const J9UTF8 *origStr, const J9ROMClass *origRomClass, J9SRP &srp)\n+// State maintained while iterating over UTF8 strings in a ROMClass\n+struct ROMClassPackContext\n    {\n-   if (JITServerHelpers::isAddressInROMClass(origStr, origRomClass))\n-      return curPos;\n+   ROMClassPackContext(TR_Memory *trMemory, size_t origRomSize) :\n+      origSize(origRomSize), callback(NULL), stringsSize(0),\n+      utf8SectionStart((const uint8_t *)-1), utf8SectionEnd(NULL), utf8SectionSize(0),\n+      strToOffsetMap(decltype(strToOffsetMap)::allocator_type(trMemory->currentStackRegion())),\n+      packedRomClass(NULL), cursor(NULL) {}\n \n-   size_t size = getUTF8Size(origStr);\n-   memcpy(curPos, origStr, origStr->length + sizeof(*origStr));\n-   static_assert(sizeof(*origStr) == 2, \"UTF8 header is not 2 bytes large\");\n-   if (!OMR::alignedNoCheck(origStr->length, sizeof(*origStr)))\n-      curPos[size - 1] = '\\0';\n-   NNSRP_SET(srp, curPos);\n-   return curPos + size;\n+   bool isInline(const void *address, const J9ROMClass *romClass)\n+      {\n+      return (address >= romClass) && (address < (uint8_t *)romClass + origSize);\n+      }\n+\n+   typedef void (*Callback)(const J9ROMClass *, const J9SRP *, const char *, ROMClassPackContext &);\n+\n+   const size_t origSize;\n+   Callback callback;\n+   size_t stringsSize;\n+   const uint8_t *utf8SectionStart;\n+   const uint8_t *utf8SectionEnd;// only needed for assertions\n+   size_t utf8SectionSize;// only needed for assertions\n+   // Maps original strings to their offsets from UTF8 section start in the packed ROMClass\n+   // Offset value -1 signifies that the string is skipped\n+   UnorderedMap<const J9UTF8 *, size_t> strToOffsetMap;\n+   J9ROMClass *packedRomClass;\n+   uint8_t *cursor;\n+   };\n+\n+static bool\n+shouldSkipSlot(const char *slotName)\n+   {\n+   // Skip variable names and signatures in method debug info; only their slot names have prefix \"variable\"\n+   static const char prefix[] = \"variable\";\n+   return strncmp(slotName, prefix, sizeof(prefix) - 1) == 0;\n+   }\n+\n+// Updates size info and maps original string to its future location in the packed ROMClass\n+static void\n+sizeInfoCallback(const J9ROMClass *romClass, const J9SRP *origSrp, const char *slotName, ROMClassPackContext &ctx)\n+   {\n+   // Skip SRPs stored outside of the ROMClass bounds such as the ones in out-of-line\n+   // method debug info, and the ones that point to strings not used by the JIT.\n+   bool skip = !ctx.isInline(origSrp, romClass) || shouldSkipSlot(slotName);\n+   auto str = NNSRP_PTR_GET(origSrp, const J9UTF8 *);\n+   auto it = ctx.strToOffsetMap.find(str);\n+   if (it != ctx.strToOffsetMap.end())// duplicate - already visited\n+      {\n+      if (!skip && (it->second == (size_t)-1))\n+         {\n+         // Previously visited SRPs to this string were skipped, but this one isn't\n+         it->second = ctx.stringsSize;\n+         ctx.stringsSize += getUTF8Size(str);\n+         }\n+      return;\n+      }\n+\n+   ctx.strToOffsetMap.insert(it, { str, skip ? (size_t)-1 : ctx.stringsSize });\n+   size_t size = getUTF8Size(str);\n+   ctx.stringsSize += skip ? 0 : size;\n+\n+   if (ctx.isInline(str, romClass))\n+      {\n+      ctx.utf8SectionStart = std::min(ctx.utf8SectionStart, (const uint8_t *)str);\n+      ctx.utf8SectionEnd = std::max(ctx.utf8SectionEnd, (const uint8_t *)str + size);\n+      ctx.utf8SectionSize += size;\n+      }\n+   }\n+\n+// Copies original string into its location in the packed ROMClass and updates the SRP to it\n+static void\n+packCallback(const J9ROMClass *romClass, const J9SRP *origSrp, const char *slotName, ROMClassPackContext &ctx)\n+   {\n+   // Skip SRPs stored outside of the ROMClass bounds such as the ones in out-of-line method debug info\n+   if (!ctx.isInline(origSrp, romClass))\n+      return;\n+\n+   auto str = NNSRP_PTR_GET(origSrp, const J9UTF8 *);\n+   auto srp = (J9SRP *)((uint8_t *)ctx.packedRomClass + ((uint8_t *)origSrp - (uint8_t *)romClass));\n+\n+   // Zero out skipped string SRPs\n+   if (shouldSkipSlot(slotName))\n+      {\n+      TR_ASSERT(ctx.strToOffsetMap.find(str) != ctx.strToOffsetMap.end(),\n+                \"UTF8 slot %s not visited in 1st pass\", slotName);\n+      *srp = 0;\n+      return;\n+      }\n+\n+   auto it = ctx.strToOffsetMap.find(str);\n+   TR_ASSERT(it != ctx.strToOffsetMap.end(), \"UTF8 slot %s not visited in 1st pass\", slotName);\n+   auto dst = (uint8_t *)ctx.packedRomClass + (ctx.utf8SectionStart - (uint8_t *)romClass) + it->second;\n+\n+   NNSRP_PTR_SET(srp, dst);\n+   if (dst == ctx.cursor)\n+      ctx.cursor += copyUTF8((J9UTF8 *)dst, str);\n+   else\n+      TR_ASSERT((dst < ctx.cursor) && (memcmp(dst, str, J9UTF8_TOTAL_SIZE(str)) == 0), \"Must be already copied\");\n+   }\n+\n+static void\n+utf8SlotCallback(const J9ROMClass *romClass, const J9SRP *srp, const char *slotName, void *userData)\n+   {\n+   auto &ctx = *(ROMClassPackContext *)userData;\n+   if (*srp)\n+      ctx.callback(romClass, srp, slotName, ctx);\n+   }\n+\n+// Invoked for each slot in a ROMClass. Calls ctx.callback() for all non-null SRPs to UTF8 strings.\n+static void\n+slotCallback(J9ROMClass *romClass, uint32_t slotType, void *slotPtr, const char *slotName, void *userData)\n+   {\n+   switch (slotType)\n+      {\n+      case J9ROM_UTF8:\n+         utf8SlotCallback(romClass, (const J9SRP *)slotPtr, slotName, userData);\n+         break;\n+\n+      case J9ROM_NAS:\n+         if (auto nas = SRP_PTR_GET(slotPtr, const J9ROMNameAndSignature *))\n+            {\n+            utf8SlotCallback(romClass, &nas->name, slotName, userData);\n+            utf8SlotCallback(romClass, &nas->signature, slotName, userData);\n+            }\n+         break;\n+      }\n+   }\n+\n+static bool\n+isArrayROMClass(const J9ROMClass *romClass)\n+   {\n+   if (!J9ROMCLASS_IS_ARRAY(romClass))\n+      return false;\n+\n+   auto name = J9ROMCLASS_CLASSNAME(romClass);\n+   TR_ASSERT((name->length == 2) && (name->data[0] == '['),\n+             \"Unexpected array ROMClass name: %.*s\", name->length, name->data);\n+   return true;\n+   }\n+\n+// Array ROMClasses have a different layout (see runtime/vm/romclasses.c):\n+// they all share the same SRP array of interfaces, which breaks the generic\n+// packing implementation. Instead, we manually pack all the data stored\n+// outside of the ROMClass header: class name, superclass name, interfaces.\n+// This function returns the total size of the packed array ROMClass.\n+static size_t\n+getArrayROMClassPackedSize(const J9ROMClass *romClass)\n+   {\n+   size_t totalSize = sizeof(*romClass);\n+   totalSize += getUTF8Size(J9ROMCLASS_CLASSNAME(romClass));\n+   totalSize += getUTF8Size(J9ROMCLASS_SUPERCLASSNAME(romClass));\n+\n+   totalSize += romClass->interfaceCount * sizeof(J9SRP);\n+   for (size_t i = 0; i < romClass->interfaceCount; ++i)\n+      {\n+      auto name = NNSRP_GET(J9ROMCLASS_INTERFACES(romClass)[i], const J9UTF8 *);\n+      totalSize += getUTF8Size(name);\n+      }\n+\n+   return OMR::alignNoCheck(totalSize, sizeof(uint64_t));\n+   }\n+\n+static void\n+packUTF8(const J9UTF8 *str, J9SRP &srp, ROMClassPackContext &ctx)\n+   {\n+   NNSRP_SET(srp, ctx.cursor);\n+   ctx.cursor += copyUTF8((J9UTF8 *)ctx.cursor, str);\n+   }\n+\n+// Packs the data stored outside of the array ROMClass header\n+static void\n+packArrayROMClassData(const J9ROMClass *romClass, ROMClassPackContext &ctx)\n+   {\n+   NNSRP_SET(ctx.packedRomClass->interfaces, ctx.cursor);\n+   ctx.cursor += ctx.packedRomClass->interfaceCount * sizeof(J9SRP);\n+\n+   packUTF8(J9ROMCLASS_CLASSNAME(romClass), ctx.packedRomClass->className, ctx);\n+   packUTF8(J9ROMCLASS_SUPERCLASSNAME(romClass), ctx.packedRomClass->superclassName, ctx);\n+\n+   for (size_t i = 0; i < romClass->interfaceCount; ++i)\n+      {\n+      auto name = NNSRP_GET(J9ROMCLASS_INTERFACES(romClass)[i], const J9UTF8 *);\n+      packUTF8(name, J9ROMCLASS_INTERFACES(ctx.packedRomClass)[i], ctx);\n+      }\n    }\n \n // Packs a ROMClass into a std::string to be transferred to the server.\n-// Some of the name and signature strings are interned and stored outside\n-// of the ROMClass body. Such strings are appended to the end of the cloned\n-// ROMClass body and the self referential pointers to them are updated.\n+// UTF8 strings that a ROMClass refers to can be interned and stored outside of\n+// the ROMClass body. This function puts all the strings (including interned ones)\n+// at the end of the cloned ROMClass in deterministic order and updates the SRPs\n+// to them. It also removes some of the data that is not used by the JIT compiler.\n+//\n+// Packing involves 2 passes over all the strings that a ROMClass refers to:\n+// 1. Compute total size and map original strings to their locations in the packed ROMClass.\n+// 2. Copy each original string to its location in the packed ROMClass.\n static std::string\n-packROMClass(J9ROMClass *origRomClass, TR_Memory *trMemory)\n+packROMClass(J9ROMClass *romClass, TR_Memory *trMemory)\n    {\n-   size_t totalSize = origRomClass->romSize;\n-   J9UTF8 *className = J9ROMCLASS_CLASSNAME(origRomClass);\n-   totalSize += getPackedUTF8Size(className, origRomClass);\n-\n-   J9ROMMethod *romMethod = J9ROMCLASS_ROMMETHODS(origRomClass);\n-   for (size_t i = 0; i < origRomClass->romMethodCount; ++i)\n+   auto name = J9ROMCLASS_CLASSNAME(romClass);\n+   // Primitive ROMClasses have different layout (see runtime/vm/romclasses.c): the last\n+   // ROMClass includes all the others' UTF8 name strings in its romSize, which breaks the\n+   // generic packing implementation. Pretend that its romSize only includes the header.\n+   size_t origRomSize = J9ROMCLASS_IS_PRIMITIVE_TYPE(romClass) ? sizeof(*romClass) : romClass->romSize;\n+   size_t totalSize = origRomSize;\n+\n+   // Remove intermediate class data (not used by JIT)\n+   uint8_t *icData = J9ROMCLASS_INTERMEDIATECLASSDATA(romClass);\n+   if (JITServerHelpers::isAddressInROMClass(icData, romClass) && (icData != (uint8_t *)romClass))\n       {\n-      totalSize += getPackedUTF8Size(J9ROMMETHOD_NAME(romMethod), origRomClass);\n-      totalSize += getPackedUTF8Size(J9ROMMETHOD_SIGNATURE(romMethod), origRomClass);\n-      romMethod = nextROMMethod(romMethod);\n+      TR_ASSERT_FATAL(icData + romClass->intermediateClassDataLength == (uint8_t *)romClass + romClass->romSize,\n+                      \"Intermediate class data not stored at the end of ROMClass %.*s\", name->length, name->data);\n+      totalSize -= romClass->intermediateClassDataLength;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf8bac93c10483471c4cef95c99e5644d0834e99"}, "originalPosition": 274}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODAwNDQ4NQ==", "bodyText": "True, but this way the code is a bit simpler.", "url": "https://github.com/eclipse-openj9/openj9/pull/11331#discussion_r538004485", "createdAt": "2020-12-08T03:23:01Z", "author": {"login": "AlexeyKhrabrov"}, "path": "runtime/compiler/control/JITServerHelpers.cpp", "diffHunk": "@@ -44,84 +47,309 @@ TR::Monitor *JITServerHelpers::_clientStreamMonitor = NULL;\n static size_t\n getUTF8Size(const J9UTF8 *str)\n    {\n-   return OMR::alignNoCheck(str->length, sizeof(*str)) + sizeof(*str);\n+   return OMR::alignNoCheck(J9UTF8_TOTAL_SIZE(str), sizeof(*str));\n    }\n \n+// Copies a UTF8 string with padding and returns its total size\n static size_t\n-getPackedUTF8Size(const J9UTF8 *str, const J9ROMClass *romClass)\n+copyUTF8(J9UTF8 *dst, const J9UTF8 *src)\n    {\n-   return JITServerHelpers::isAddressInROMClass(str, romClass) ? 0 : getUTF8Size(str);\n+   size_t size = J9UTF8_TOTAL_SIZE(src);\n+   memcpy(dst, src, size);\n+   static_assert(sizeof(*src) == 2, \"UTF8 header is not 2 bytes large\");\n+   if (!OMR::alignedNoCheck(size, sizeof(*src)))\n+      dst->data[src->length] = '\\0';\n+   return OMR::alignNoCheck(size, sizeof(*src));\n    }\n \n-// If the string points outside of the contiguous part of origRomClass, appends\n-// it (with padding) at curPos and updates the SRP to the string in the packed\n-// ROMClass. Returns the new value of curPos.\n-static uint8_t *\n-packUTF8(uint8_t *curPos, const J9UTF8 *origStr, const J9ROMClass *origRomClass, J9SRP &srp)\n+// State maintained while iterating over UTF8 strings in a ROMClass\n+struct ROMClassPackContext\n    {\n-   if (JITServerHelpers::isAddressInROMClass(origStr, origRomClass))\n-      return curPos;\n+   ROMClassPackContext(TR_Memory *trMemory, size_t origRomSize) :\n+      origSize(origRomSize), callback(NULL), stringsSize(0),\n+      utf8SectionStart((const uint8_t *)-1), utf8SectionEnd(NULL), utf8SectionSize(0),\n+      strToOffsetMap(decltype(strToOffsetMap)::allocator_type(trMemory->currentStackRegion())),\n+      packedRomClass(NULL), cursor(NULL) {}\n \n-   size_t size = getUTF8Size(origStr);\n-   memcpy(curPos, origStr, origStr->length + sizeof(*origStr));\n-   static_assert(sizeof(*origStr) == 2, \"UTF8 header is not 2 bytes large\");\n-   if (!OMR::alignedNoCheck(origStr->length, sizeof(*origStr)))\n-      curPos[size - 1] = '\\0';\n-   NNSRP_SET(srp, curPos);\n-   return curPos + size;\n+   bool isInline(const void *address, const J9ROMClass *romClass)\n+      {\n+      return (address >= romClass) && (address < (uint8_t *)romClass + origSize);\n+      }\n+\n+   typedef void (*Callback)(const J9ROMClass *, const J9SRP *, const char *, ROMClassPackContext &);\n+\n+   const size_t origSize;\n+   Callback callback;\n+   size_t stringsSize;\n+   const uint8_t *utf8SectionStart;\n+   const uint8_t *utf8SectionEnd;// only needed for assertions\n+   size_t utf8SectionSize;// only needed for assertions\n+   // Maps original strings to their offsets from UTF8 section start in the packed ROMClass\n+   // Offset value -1 signifies that the string is skipped\n+   UnorderedMap<const J9UTF8 *, size_t> strToOffsetMap;\n+   J9ROMClass *packedRomClass;\n+   uint8_t *cursor;\n+   };\n+\n+static bool\n+shouldSkipSlot(const char *slotName)\n+   {\n+   // Skip variable names and signatures in method debug info; only their slot names have prefix \"variable\"\n+   static const char prefix[] = \"variable\";\n+   return strncmp(slotName, prefix, sizeof(prefix) - 1) == 0;\n+   }\n+\n+// Updates size info and maps original string to its future location in the packed ROMClass\n+static void\n+sizeInfoCallback(const J9ROMClass *romClass, const J9SRP *origSrp, const char *slotName, ROMClassPackContext &ctx)\n+   {\n+   // Skip SRPs stored outside of the ROMClass bounds such as the ones in out-of-line\n+   // method debug info, and the ones that point to strings not used by the JIT.\n+   bool skip = !ctx.isInline(origSrp, romClass) || shouldSkipSlot(slotName);\n+   auto str = NNSRP_PTR_GET(origSrp, const J9UTF8 *);\n+   auto it = ctx.strToOffsetMap.find(str);\n+   if (it != ctx.strToOffsetMap.end())// duplicate - already visited\n+      {\n+      if (!skip && (it->second == (size_t)-1))\n+         {\n+         // Previously visited SRPs to this string were skipped, but this one isn't\n+         it->second = ctx.stringsSize;\n+         ctx.stringsSize += getUTF8Size(str);\n+         }\n+      return;\n+      }\n+\n+   ctx.strToOffsetMap.insert(it, { str, skip ? (size_t)-1 : ctx.stringsSize });\n+   size_t size = getUTF8Size(str);\n+   ctx.stringsSize += skip ? 0 : size;\n+\n+   if (ctx.isInline(str, romClass))\n+      {\n+      ctx.utf8SectionStart = std::min(ctx.utf8SectionStart, (const uint8_t *)str);\n+      ctx.utf8SectionEnd = std::max(ctx.utf8SectionEnd, (const uint8_t *)str + size);\n+      ctx.utf8SectionSize += size;\n+      }\n+   }\n+\n+// Copies original string into its location in the packed ROMClass and updates the SRP to it\n+static void\n+packCallback(const J9ROMClass *romClass, const J9SRP *origSrp, const char *slotName, ROMClassPackContext &ctx)\n+   {\n+   // Skip SRPs stored outside of the ROMClass bounds such as the ones in out-of-line method debug info\n+   if (!ctx.isInline(origSrp, romClass))\n+      return;\n+\n+   auto str = NNSRP_PTR_GET(origSrp, const J9UTF8 *);\n+   auto srp = (J9SRP *)((uint8_t *)ctx.packedRomClass + ((uint8_t *)origSrp - (uint8_t *)romClass));\n+\n+   // Zero out skipped string SRPs\n+   if (shouldSkipSlot(slotName))\n+      {\n+      TR_ASSERT(ctx.strToOffsetMap.find(str) != ctx.strToOffsetMap.end(),\n+                \"UTF8 slot %s not visited in 1st pass\", slotName);\n+      *srp = 0;\n+      return;\n+      }\n+\n+   auto it = ctx.strToOffsetMap.find(str);\n+   TR_ASSERT(it != ctx.strToOffsetMap.end(), \"UTF8 slot %s not visited in 1st pass\", slotName);\n+   auto dst = (uint8_t *)ctx.packedRomClass + (ctx.utf8SectionStart - (uint8_t *)romClass) + it->second;\n+\n+   NNSRP_PTR_SET(srp, dst);\n+   if (dst == ctx.cursor)\n+      ctx.cursor += copyUTF8((J9UTF8 *)dst, str);\n+   else\n+      TR_ASSERT((dst < ctx.cursor) && (memcmp(dst, str, J9UTF8_TOTAL_SIZE(str)) == 0), \"Must be already copied\");\n+   }\n+\n+static void\n+utf8SlotCallback(const J9ROMClass *romClass, const J9SRP *srp, const char *slotName, void *userData)\n+   {\n+   auto &ctx = *(ROMClassPackContext *)userData;\n+   if (*srp)\n+      ctx.callback(romClass, srp, slotName, ctx);\n+   }\n+\n+// Invoked for each slot in a ROMClass. Calls ctx.callback() for all non-null SRPs to UTF8 strings.\n+static void\n+slotCallback(J9ROMClass *romClass, uint32_t slotType, void *slotPtr, const char *slotName, void *userData)\n+   {\n+   switch (slotType)\n+      {\n+      case J9ROM_UTF8:\n+         utf8SlotCallback(romClass, (const J9SRP *)slotPtr, slotName, userData);\n+         break;\n+\n+      case J9ROM_NAS:\n+         if (auto nas = SRP_PTR_GET(slotPtr, const J9ROMNameAndSignature *))\n+            {\n+            utf8SlotCallback(romClass, &nas->name, slotName, userData);\n+            utf8SlotCallback(romClass, &nas->signature, slotName, userData);\n+            }\n+         break;\n+      }\n+   }\n+\n+static bool\n+isArrayROMClass(const J9ROMClass *romClass)\n+   {\n+   if (!J9ROMCLASS_IS_ARRAY(romClass))\n+      return false;\n+\n+   auto name = J9ROMCLASS_CLASSNAME(romClass);\n+   TR_ASSERT((name->length == 2) && (name->data[0] == '['),\n+             \"Unexpected array ROMClass name: %.*s\", name->length, name->data);\n+   return true;\n+   }\n+\n+// Array ROMClasses have a different layout (see runtime/vm/romclasses.c):\n+// they all share the same SRP array of interfaces, which breaks the generic\n+// packing implementation. Instead, we manually pack all the data stored\n+// outside of the ROMClass header: class name, superclass name, interfaces.\n+// This function returns the total size of the packed array ROMClass.\n+static size_t\n+getArrayROMClassPackedSize(const J9ROMClass *romClass)\n+   {\n+   size_t totalSize = sizeof(*romClass);\n+   totalSize += getUTF8Size(J9ROMCLASS_CLASSNAME(romClass));\n+   totalSize += getUTF8Size(J9ROMCLASS_SUPERCLASSNAME(romClass));\n+\n+   totalSize += romClass->interfaceCount * sizeof(J9SRP);\n+   for (size_t i = 0; i < romClass->interfaceCount; ++i)\n+      {\n+      auto name = NNSRP_GET(J9ROMCLASS_INTERFACES(romClass)[i], const J9UTF8 *);\n+      totalSize += getUTF8Size(name);\n+      }\n+\n+   return OMR::alignNoCheck(totalSize, sizeof(uint64_t));\n+   }\n+\n+static void\n+packUTF8(const J9UTF8 *str, J9SRP &srp, ROMClassPackContext &ctx)\n+   {\n+   NNSRP_SET(srp, ctx.cursor);\n+   ctx.cursor += copyUTF8((J9UTF8 *)ctx.cursor, str);\n+   }\n+\n+// Packs the data stored outside of the array ROMClass header\n+static void\n+packArrayROMClassData(const J9ROMClass *romClass, ROMClassPackContext &ctx)\n+   {\n+   NNSRP_SET(ctx.packedRomClass->interfaces, ctx.cursor);\n+   ctx.cursor += ctx.packedRomClass->interfaceCount * sizeof(J9SRP);\n+\n+   packUTF8(J9ROMCLASS_CLASSNAME(romClass), ctx.packedRomClass->className, ctx);\n+   packUTF8(J9ROMCLASS_SUPERCLASSNAME(romClass), ctx.packedRomClass->superclassName, ctx);\n+\n+   for (size_t i = 0; i < romClass->interfaceCount; ++i)\n+      {\n+      auto name = NNSRP_GET(J9ROMCLASS_INTERFACES(romClass)[i], const J9UTF8 *);\n+      packUTF8(name, J9ROMCLASS_INTERFACES(ctx.packedRomClass)[i], ctx);\n+      }\n    }\n \n // Packs a ROMClass into a std::string to be transferred to the server.\n-// Some of the name and signature strings are interned and stored outside\n-// of the ROMClass body. Such strings are appended to the end of the cloned\n-// ROMClass body and the self referential pointers to them are updated.\n+// UTF8 strings that a ROMClass refers to can be interned and stored outside of\n+// the ROMClass body. This function puts all the strings (including interned ones)\n+// at the end of the cloned ROMClass in deterministic order and updates the SRPs\n+// to them. It also removes some of the data that is not used by the JIT compiler.\n+//\n+// Packing involves 2 passes over all the strings that a ROMClass refers to:\n+// 1. Compute total size and map original strings to their locations in the packed ROMClass.\n+// 2. Copy each original string to its location in the packed ROMClass.\n static std::string\n-packROMClass(J9ROMClass *origRomClass, TR_Memory *trMemory)\n+packROMClass(J9ROMClass *romClass, TR_Memory *trMemory)\n    {\n-   size_t totalSize = origRomClass->romSize;\n-   J9UTF8 *className = J9ROMCLASS_CLASSNAME(origRomClass);\n-   totalSize += getPackedUTF8Size(className, origRomClass);\n-\n-   J9ROMMethod *romMethod = J9ROMCLASS_ROMMETHODS(origRomClass);\n-   for (size_t i = 0; i < origRomClass->romMethodCount; ++i)\n+   auto name = J9ROMCLASS_CLASSNAME(romClass);\n+   // Primitive ROMClasses have different layout (see runtime/vm/romclasses.c): the last\n+   // ROMClass includes all the others' UTF8 name strings in its romSize, which breaks the\n+   // generic packing implementation. Pretend that its romSize only includes the header.\n+   size_t origRomSize = J9ROMCLASS_IS_PRIMITIVE_TYPE(romClass) ? sizeof(*romClass) : romClass->romSize;\n+   size_t totalSize = origRomSize;\n+\n+   // Remove intermediate class data (not used by JIT)\n+   uint8_t *icData = J9ROMCLASS_INTERMEDIATECLASSDATA(romClass);\n+   if (JITServerHelpers::isAddressInROMClass(icData, romClass) && (icData != (uint8_t *)romClass))\n       {\n-      totalSize += getPackedUTF8Size(J9ROMMETHOD_NAME(romMethod), origRomClass);\n-      totalSize += getPackedUTF8Size(J9ROMMETHOD_SIGNATURE(romMethod), origRomClass);\n-      romMethod = nextROMMethod(romMethod);\n+      TR_ASSERT_FATAL(icData + romClass->intermediateClassDataLength == (uint8_t *)romClass + romClass->romSize,\n+                      \"Intermediate class data not stored at the end of ROMClass %.*s\", name->length, name->data);\n+      totalSize -= romClass->intermediateClassDataLength;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk2MDk3Nw=="}, "originalCommit": {"oid": "cf8bac93c10483471c4cef95c99e5644d0834e99"}, "originalPosition": 274}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3NzI5MjM2OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/control/JITServerHelpers.cpp", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwMjowNzo1NFrOIBDirA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxNDo0Nzo1NlrOIBgnyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk3NzUxNg==", "bodyText": "Why does end need to be the same as classEnd?\nend is what we computed with interned and non-interned strings.\nclassEnd is romClass+romClass->romSize which I thought it did not include the interned strings", "url": "https://github.com/eclipse-openj9/openj9/pull/11331#discussion_r537977516", "createdAt": "2020-12-08T02:07:54Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/control/JITServerHelpers.cpp", "diffHunk": "@@ -44,84 +47,309 @@ TR::Monitor *JITServerHelpers::_clientStreamMonitor = NULL;\n static size_t\n getUTF8Size(const J9UTF8 *str)\n    {\n-   return OMR::alignNoCheck(str->length, sizeof(*str)) + sizeof(*str);\n+   return OMR::alignNoCheck(J9UTF8_TOTAL_SIZE(str), sizeof(*str));\n    }\n \n+// Copies a UTF8 string with padding and returns its total size\n static size_t\n-getPackedUTF8Size(const J9UTF8 *str, const J9ROMClass *romClass)\n+copyUTF8(J9UTF8 *dst, const J9UTF8 *src)\n    {\n-   return JITServerHelpers::isAddressInROMClass(str, romClass) ? 0 : getUTF8Size(str);\n+   size_t size = J9UTF8_TOTAL_SIZE(src);\n+   memcpy(dst, src, size);\n+   static_assert(sizeof(*src) == 2, \"UTF8 header is not 2 bytes large\");\n+   if (!OMR::alignedNoCheck(size, sizeof(*src)))\n+      dst->data[src->length] = '\\0';\n+   return OMR::alignNoCheck(size, sizeof(*src));\n    }\n \n-// If the string points outside of the contiguous part of origRomClass, appends\n-// it (with padding) at curPos and updates the SRP to the string in the packed\n-// ROMClass. Returns the new value of curPos.\n-static uint8_t *\n-packUTF8(uint8_t *curPos, const J9UTF8 *origStr, const J9ROMClass *origRomClass, J9SRP &srp)\n+// State maintained while iterating over UTF8 strings in a ROMClass\n+struct ROMClassPackContext\n    {\n-   if (JITServerHelpers::isAddressInROMClass(origStr, origRomClass))\n-      return curPos;\n+   ROMClassPackContext(TR_Memory *trMemory, size_t origRomSize) :\n+      origSize(origRomSize), callback(NULL), stringsSize(0),\n+      utf8SectionStart((const uint8_t *)-1), utf8SectionEnd(NULL), utf8SectionSize(0),\n+      strToOffsetMap(decltype(strToOffsetMap)::allocator_type(trMemory->currentStackRegion())),\n+      packedRomClass(NULL), cursor(NULL) {}\n \n-   size_t size = getUTF8Size(origStr);\n-   memcpy(curPos, origStr, origStr->length + sizeof(*origStr));\n-   static_assert(sizeof(*origStr) == 2, \"UTF8 header is not 2 bytes large\");\n-   if (!OMR::alignedNoCheck(origStr->length, sizeof(*origStr)))\n-      curPos[size - 1] = '\\0';\n-   NNSRP_SET(srp, curPos);\n-   return curPos + size;\n+   bool isInline(const void *address, const J9ROMClass *romClass)\n+      {\n+      return (address >= romClass) && (address < (uint8_t *)romClass + origSize);\n+      }\n+\n+   typedef void (*Callback)(const J9ROMClass *, const J9SRP *, const char *, ROMClassPackContext &);\n+\n+   const size_t origSize;\n+   Callback callback;\n+   size_t stringsSize;\n+   const uint8_t *utf8SectionStart;\n+   const uint8_t *utf8SectionEnd;// only needed for assertions\n+   size_t utf8SectionSize;// only needed for assertions\n+   // Maps original strings to their offsets from UTF8 section start in the packed ROMClass\n+   // Offset value -1 signifies that the string is skipped\n+   UnorderedMap<const J9UTF8 *, size_t> strToOffsetMap;\n+   J9ROMClass *packedRomClass;\n+   uint8_t *cursor;\n+   };\n+\n+static bool\n+shouldSkipSlot(const char *slotName)\n+   {\n+   // Skip variable names and signatures in method debug info; only their slot names have prefix \"variable\"\n+   static const char prefix[] = \"variable\";\n+   return strncmp(slotName, prefix, sizeof(prefix) - 1) == 0;\n+   }\n+\n+// Updates size info and maps original string to its future location in the packed ROMClass\n+static void\n+sizeInfoCallback(const J9ROMClass *romClass, const J9SRP *origSrp, const char *slotName, ROMClassPackContext &ctx)\n+   {\n+   // Skip SRPs stored outside of the ROMClass bounds such as the ones in out-of-line\n+   // method debug info, and the ones that point to strings not used by the JIT.\n+   bool skip = !ctx.isInline(origSrp, romClass) || shouldSkipSlot(slotName);\n+   auto str = NNSRP_PTR_GET(origSrp, const J9UTF8 *);\n+   auto it = ctx.strToOffsetMap.find(str);\n+   if (it != ctx.strToOffsetMap.end())// duplicate - already visited\n+      {\n+      if (!skip && (it->second == (size_t)-1))\n+         {\n+         // Previously visited SRPs to this string were skipped, but this one isn't\n+         it->second = ctx.stringsSize;\n+         ctx.stringsSize += getUTF8Size(str);\n+         }\n+      return;\n+      }\n+\n+   ctx.strToOffsetMap.insert(it, { str, skip ? (size_t)-1 : ctx.stringsSize });\n+   size_t size = getUTF8Size(str);\n+   ctx.stringsSize += skip ? 0 : size;\n+\n+   if (ctx.isInline(str, romClass))\n+      {\n+      ctx.utf8SectionStart = std::min(ctx.utf8SectionStart, (const uint8_t *)str);\n+      ctx.utf8SectionEnd = std::max(ctx.utf8SectionEnd, (const uint8_t *)str + size);\n+      ctx.utf8SectionSize += size;\n+      }\n+   }\n+\n+// Copies original string into its location in the packed ROMClass and updates the SRP to it\n+static void\n+packCallback(const J9ROMClass *romClass, const J9SRP *origSrp, const char *slotName, ROMClassPackContext &ctx)\n+   {\n+   // Skip SRPs stored outside of the ROMClass bounds such as the ones in out-of-line method debug info\n+   if (!ctx.isInline(origSrp, romClass))\n+      return;\n+\n+   auto str = NNSRP_PTR_GET(origSrp, const J9UTF8 *);\n+   auto srp = (J9SRP *)((uint8_t *)ctx.packedRomClass + ((uint8_t *)origSrp - (uint8_t *)romClass));\n+\n+   // Zero out skipped string SRPs\n+   if (shouldSkipSlot(slotName))\n+      {\n+      TR_ASSERT(ctx.strToOffsetMap.find(str) != ctx.strToOffsetMap.end(),\n+                \"UTF8 slot %s not visited in 1st pass\", slotName);\n+      *srp = 0;\n+      return;\n+      }\n+\n+   auto it = ctx.strToOffsetMap.find(str);\n+   TR_ASSERT(it != ctx.strToOffsetMap.end(), \"UTF8 slot %s not visited in 1st pass\", slotName);\n+   auto dst = (uint8_t *)ctx.packedRomClass + (ctx.utf8SectionStart - (uint8_t *)romClass) + it->second;\n+\n+   NNSRP_PTR_SET(srp, dst);\n+   if (dst == ctx.cursor)\n+      ctx.cursor += copyUTF8((J9UTF8 *)dst, str);\n+   else\n+      TR_ASSERT((dst < ctx.cursor) && (memcmp(dst, str, J9UTF8_TOTAL_SIZE(str)) == 0), \"Must be already copied\");\n+   }\n+\n+static void\n+utf8SlotCallback(const J9ROMClass *romClass, const J9SRP *srp, const char *slotName, void *userData)\n+   {\n+   auto &ctx = *(ROMClassPackContext *)userData;\n+   if (*srp)\n+      ctx.callback(romClass, srp, slotName, ctx);\n+   }\n+\n+// Invoked for each slot in a ROMClass. Calls ctx.callback() for all non-null SRPs to UTF8 strings.\n+static void\n+slotCallback(J9ROMClass *romClass, uint32_t slotType, void *slotPtr, const char *slotName, void *userData)\n+   {\n+   switch (slotType)\n+      {\n+      case J9ROM_UTF8:\n+         utf8SlotCallback(romClass, (const J9SRP *)slotPtr, slotName, userData);\n+         break;\n+\n+      case J9ROM_NAS:\n+         if (auto nas = SRP_PTR_GET(slotPtr, const J9ROMNameAndSignature *))\n+            {\n+            utf8SlotCallback(romClass, &nas->name, slotName, userData);\n+            utf8SlotCallback(romClass, &nas->signature, slotName, userData);\n+            }\n+         break;\n+      }\n+   }\n+\n+static bool\n+isArrayROMClass(const J9ROMClass *romClass)\n+   {\n+   if (!J9ROMCLASS_IS_ARRAY(romClass))\n+      return false;\n+\n+   auto name = J9ROMCLASS_CLASSNAME(romClass);\n+   TR_ASSERT((name->length == 2) && (name->data[0] == '['),\n+             \"Unexpected array ROMClass name: %.*s\", name->length, name->data);\n+   return true;\n+   }\n+\n+// Array ROMClasses have a different layout (see runtime/vm/romclasses.c):\n+// they all share the same SRP array of interfaces, which breaks the generic\n+// packing implementation. Instead, we manually pack all the data stored\n+// outside of the ROMClass header: class name, superclass name, interfaces.\n+// This function returns the total size of the packed array ROMClass.\n+static size_t\n+getArrayROMClassPackedSize(const J9ROMClass *romClass)\n+   {\n+   size_t totalSize = sizeof(*romClass);\n+   totalSize += getUTF8Size(J9ROMCLASS_CLASSNAME(romClass));\n+   totalSize += getUTF8Size(J9ROMCLASS_SUPERCLASSNAME(romClass));\n+\n+   totalSize += romClass->interfaceCount * sizeof(J9SRP);\n+   for (size_t i = 0; i < romClass->interfaceCount; ++i)\n+      {\n+      auto name = NNSRP_GET(J9ROMCLASS_INTERFACES(romClass)[i], const J9UTF8 *);\n+      totalSize += getUTF8Size(name);\n+      }\n+\n+   return OMR::alignNoCheck(totalSize, sizeof(uint64_t));\n+   }\n+\n+static void\n+packUTF8(const J9UTF8 *str, J9SRP &srp, ROMClassPackContext &ctx)\n+   {\n+   NNSRP_SET(srp, ctx.cursor);\n+   ctx.cursor += copyUTF8((J9UTF8 *)ctx.cursor, str);\n+   }\n+\n+// Packs the data stored outside of the array ROMClass header\n+static void\n+packArrayROMClassData(const J9ROMClass *romClass, ROMClassPackContext &ctx)\n+   {\n+   NNSRP_SET(ctx.packedRomClass->interfaces, ctx.cursor);\n+   ctx.cursor += ctx.packedRomClass->interfaceCount * sizeof(J9SRP);\n+\n+   packUTF8(J9ROMCLASS_CLASSNAME(romClass), ctx.packedRomClass->className, ctx);\n+   packUTF8(J9ROMCLASS_SUPERCLASSNAME(romClass), ctx.packedRomClass->superclassName, ctx);\n+\n+   for (size_t i = 0; i < romClass->interfaceCount; ++i)\n+      {\n+      auto name = NNSRP_GET(J9ROMCLASS_INTERFACES(romClass)[i], const J9UTF8 *);\n+      packUTF8(name, J9ROMCLASS_INTERFACES(ctx.packedRomClass)[i], ctx);\n+      }\n    }\n \n // Packs a ROMClass into a std::string to be transferred to the server.\n-// Some of the name and signature strings are interned and stored outside\n-// of the ROMClass body. Such strings are appended to the end of the cloned\n-// ROMClass body and the self referential pointers to them are updated.\n+// UTF8 strings that a ROMClass refers to can be interned and stored outside of\n+// the ROMClass body. This function puts all the strings (including interned ones)\n+// at the end of the cloned ROMClass in deterministic order and updates the SRPs\n+// to them. It also removes some of the data that is not used by the JIT compiler.\n+//\n+// Packing involves 2 passes over all the strings that a ROMClass refers to:\n+// 1. Compute total size and map original strings to their locations in the packed ROMClass.\n+// 2. Copy each original string to its location in the packed ROMClass.\n static std::string\n-packROMClass(J9ROMClass *origRomClass, TR_Memory *trMemory)\n+packROMClass(J9ROMClass *romClass, TR_Memory *trMemory)\n    {\n-   size_t totalSize = origRomClass->romSize;\n-   J9UTF8 *className = J9ROMCLASS_CLASSNAME(origRomClass);\n-   totalSize += getPackedUTF8Size(className, origRomClass);\n-\n-   J9ROMMethod *romMethod = J9ROMCLASS_ROMMETHODS(origRomClass);\n-   for (size_t i = 0; i < origRomClass->romMethodCount; ++i)\n+   auto name = J9ROMCLASS_CLASSNAME(romClass);\n+   // Primitive ROMClasses have different layout (see runtime/vm/romclasses.c): the last\n+   // ROMClass includes all the others' UTF8 name strings in its romSize, which breaks the\n+   // generic packing implementation. Pretend that its romSize only includes the header.\n+   size_t origRomSize = J9ROMCLASS_IS_PRIMITIVE_TYPE(romClass) ? sizeof(*romClass) : romClass->romSize;\n+   size_t totalSize = origRomSize;\n+\n+   // Remove intermediate class data (not used by JIT)\n+   uint8_t *icData = J9ROMCLASS_INTERMEDIATECLASSDATA(romClass);\n+   if (JITServerHelpers::isAddressInROMClass(icData, romClass) && (icData != (uint8_t *)romClass))\n       {\n-      totalSize += getPackedUTF8Size(J9ROMMETHOD_NAME(romMethod), origRomClass);\n-      totalSize += getPackedUTF8Size(J9ROMMETHOD_SIGNATURE(romMethod), origRomClass);\n-      romMethod = nextROMMethod(romMethod);\n+      TR_ASSERT_FATAL(icData + romClass->intermediateClassDataLength == (uint8_t *)romClass + romClass->romSize,\n+                      \"Intermediate class data not stored at the end of ROMClass %.*s\", name->length, name->data);\n+      totalSize -= romClass->intermediateClassDataLength;\n       }\n \n-   // Check if the contiguous part of the ROMClass already contains all the strings visited above\n-   if (totalSize == origRomClass->romSize)\n-      return std::string((char *)origRomClass, origRomClass->romSize);\n+   // All allocated memory is only used in this function\n+   TR::StackMemoryRegion stackMemoryRegion(*trMemory);\n+   ROMClassPackContext ctx(trMemory, origRomSize);\n \n-   J9ROMClass *romClass = (J9ROMClass *)trMemory->allocateHeapMemory(totalSize);\n-   if (!romClass)\n+   size_t copySize = 0;\n+   if (isArrayROMClass(romClass))\n+      {\n+      copySize = sizeof(*romClass);\n+      totalSize = getArrayROMClassPackedSize(romClass);\n+      }\n+   else\n+      {\n+      // 1st pass: iterate all strings in the ROMClass to compute its total size (including\n+      // interned strings) and map the strings to their locations in the packed ROMClass\n+      ctx.callback = sizeInfoCallback;\n+      allSlotsInROMClassDo(romClass, slotCallback, NULL, NULL, &ctx);\n+      // Handle the case when all strings are interned\n+      auto classEnd = (const uint8_t *)romClass + totalSize;\n+      ctx.utf8SectionStart = std::min(ctx.utf8SectionStart, classEnd);\n+\n+      auto end = ctx.utf8SectionEnd ? ctx.utf8SectionEnd : classEnd;\n+      TR_ASSERT_FATAL(ctx.utf8SectionSize == end - ctx.utf8SectionStart,\n+                      \"Missed strings in ROMClass %.*s UTF8 section: %zu != %zu\",\n+                      name->length, name->data, ctx.utf8SectionSize, end - ctx.utf8SectionStart);\n+      end = (const uint8_t *)OMR::alignNoCheck((uintptr_t)end, sizeof(uint64_t));\n+      TR_ASSERT_FATAL(end == classEnd, \"UTF8 section not stored at the end of ROMClass %.*s: %p != %p\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf8bac93c10483471c4cef95c99e5644d0834e99"}, "originalPosition": 307}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODAwNjIyMQ==", "bodyText": "end is computed with non-interned strings only.", "url": "https://github.com/eclipse-openj9/openj9/pull/11331#discussion_r538006221", "createdAt": "2020-12-08T03:28:32Z", "author": {"login": "AlexeyKhrabrov"}, "path": "runtime/compiler/control/JITServerHelpers.cpp", "diffHunk": "@@ -44,84 +47,309 @@ TR::Monitor *JITServerHelpers::_clientStreamMonitor = NULL;\n static size_t\n getUTF8Size(const J9UTF8 *str)\n    {\n-   return OMR::alignNoCheck(str->length, sizeof(*str)) + sizeof(*str);\n+   return OMR::alignNoCheck(J9UTF8_TOTAL_SIZE(str), sizeof(*str));\n    }\n \n+// Copies a UTF8 string with padding and returns its total size\n static size_t\n-getPackedUTF8Size(const J9UTF8 *str, const J9ROMClass *romClass)\n+copyUTF8(J9UTF8 *dst, const J9UTF8 *src)\n    {\n-   return JITServerHelpers::isAddressInROMClass(str, romClass) ? 0 : getUTF8Size(str);\n+   size_t size = J9UTF8_TOTAL_SIZE(src);\n+   memcpy(dst, src, size);\n+   static_assert(sizeof(*src) == 2, \"UTF8 header is not 2 bytes large\");\n+   if (!OMR::alignedNoCheck(size, sizeof(*src)))\n+      dst->data[src->length] = '\\0';\n+   return OMR::alignNoCheck(size, sizeof(*src));\n    }\n \n-// If the string points outside of the contiguous part of origRomClass, appends\n-// it (with padding) at curPos and updates the SRP to the string in the packed\n-// ROMClass. Returns the new value of curPos.\n-static uint8_t *\n-packUTF8(uint8_t *curPos, const J9UTF8 *origStr, const J9ROMClass *origRomClass, J9SRP &srp)\n+// State maintained while iterating over UTF8 strings in a ROMClass\n+struct ROMClassPackContext\n    {\n-   if (JITServerHelpers::isAddressInROMClass(origStr, origRomClass))\n-      return curPos;\n+   ROMClassPackContext(TR_Memory *trMemory, size_t origRomSize) :\n+      origSize(origRomSize), callback(NULL), stringsSize(0),\n+      utf8SectionStart((const uint8_t *)-1), utf8SectionEnd(NULL), utf8SectionSize(0),\n+      strToOffsetMap(decltype(strToOffsetMap)::allocator_type(trMemory->currentStackRegion())),\n+      packedRomClass(NULL), cursor(NULL) {}\n \n-   size_t size = getUTF8Size(origStr);\n-   memcpy(curPos, origStr, origStr->length + sizeof(*origStr));\n-   static_assert(sizeof(*origStr) == 2, \"UTF8 header is not 2 bytes large\");\n-   if (!OMR::alignedNoCheck(origStr->length, sizeof(*origStr)))\n-      curPos[size - 1] = '\\0';\n-   NNSRP_SET(srp, curPos);\n-   return curPos + size;\n+   bool isInline(const void *address, const J9ROMClass *romClass)\n+      {\n+      return (address >= romClass) && (address < (uint8_t *)romClass + origSize);\n+      }\n+\n+   typedef void (*Callback)(const J9ROMClass *, const J9SRP *, const char *, ROMClassPackContext &);\n+\n+   const size_t origSize;\n+   Callback callback;\n+   size_t stringsSize;\n+   const uint8_t *utf8SectionStart;\n+   const uint8_t *utf8SectionEnd;// only needed for assertions\n+   size_t utf8SectionSize;// only needed for assertions\n+   // Maps original strings to their offsets from UTF8 section start in the packed ROMClass\n+   // Offset value -1 signifies that the string is skipped\n+   UnorderedMap<const J9UTF8 *, size_t> strToOffsetMap;\n+   J9ROMClass *packedRomClass;\n+   uint8_t *cursor;\n+   };\n+\n+static bool\n+shouldSkipSlot(const char *slotName)\n+   {\n+   // Skip variable names and signatures in method debug info; only their slot names have prefix \"variable\"\n+   static const char prefix[] = \"variable\";\n+   return strncmp(slotName, prefix, sizeof(prefix) - 1) == 0;\n+   }\n+\n+// Updates size info and maps original string to its future location in the packed ROMClass\n+static void\n+sizeInfoCallback(const J9ROMClass *romClass, const J9SRP *origSrp, const char *slotName, ROMClassPackContext &ctx)\n+   {\n+   // Skip SRPs stored outside of the ROMClass bounds such as the ones in out-of-line\n+   // method debug info, and the ones that point to strings not used by the JIT.\n+   bool skip = !ctx.isInline(origSrp, romClass) || shouldSkipSlot(slotName);\n+   auto str = NNSRP_PTR_GET(origSrp, const J9UTF8 *);\n+   auto it = ctx.strToOffsetMap.find(str);\n+   if (it != ctx.strToOffsetMap.end())// duplicate - already visited\n+      {\n+      if (!skip && (it->second == (size_t)-1))\n+         {\n+         // Previously visited SRPs to this string were skipped, but this one isn't\n+         it->second = ctx.stringsSize;\n+         ctx.stringsSize += getUTF8Size(str);\n+         }\n+      return;\n+      }\n+\n+   ctx.strToOffsetMap.insert(it, { str, skip ? (size_t)-1 : ctx.stringsSize });\n+   size_t size = getUTF8Size(str);\n+   ctx.stringsSize += skip ? 0 : size;\n+\n+   if (ctx.isInline(str, romClass))\n+      {\n+      ctx.utf8SectionStart = std::min(ctx.utf8SectionStart, (const uint8_t *)str);\n+      ctx.utf8SectionEnd = std::max(ctx.utf8SectionEnd, (const uint8_t *)str + size);\n+      ctx.utf8SectionSize += size;\n+      }\n+   }\n+\n+// Copies original string into its location in the packed ROMClass and updates the SRP to it\n+static void\n+packCallback(const J9ROMClass *romClass, const J9SRP *origSrp, const char *slotName, ROMClassPackContext &ctx)\n+   {\n+   // Skip SRPs stored outside of the ROMClass bounds such as the ones in out-of-line method debug info\n+   if (!ctx.isInline(origSrp, romClass))\n+      return;\n+\n+   auto str = NNSRP_PTR_GET(origSrp, const J9UTF8 *);\n+   auto srp = (J9SRP *)((uint8_t *)ctx.packedRomClass + ((uint8_t *)origSrp - (uint8_t *)romClass));\n+\n+   // Zero out skipped string SRPs\n+   if (shouldSkipSlot(slotName))\n+      {\n+      TR_ASSERT(ctx.strToOffsetMap.find(str) != ctx.strToOffsetMap.end(),\n+                \"UTF8 slot %s not visited in 1st pass\", slotName);\n+      *srp = 0;\n+      return;\n+      }\n+\n+   auto it = ctx.strToOffsetMap.find(str);\n+   TR_ASSERT(it != ctx.strToOffsetMap.end(), \"UTF8 slot %s not visited in 1st pass\", slotName);\n+   auto dst = (uint8_t *)ctx.packedRomClass + (ctx.utf8SectionStart - (uint8_t *)romClass) + it->second;\n+\n+   NNSRP_PTR_SET(srp, dst);\n+   if (dst == ctx.cursor)\n+      ctx.cursor += copyUTF8((J9UTF8 *)dst, str);\n+   else\n+      TR_ASSERT((dst < ctx.cursor) && (memcmp(dst, str, J9UTF8_TOTAL_SIZE(str)) == 0), \"Must be already copied\");\n+   }\n+\n+static void\n+utf8SlotCallback(const J9ROMClass *romClass, const J9SRP *srp, const char *slotName, void *userData)\n+   {\n+   auto &ctx = *(ROMClassPackContext *)userData;\n+   if (*srp)\n+      ctx.callback(romClass, srp, slotName, ctx);\n+   }\n+\n+// Invoked for each slot in a ROMClass. Calls ctx.callback() for all non-null SRPs to UTF8 strings.\n+static void\n+slotCallback(J9ROMClass *romClass, uint32_t slotType, void *slotPtr, const char *slotName, void *userData)\n+   {\n+   switch (slotType)\n+      {\n+      case J9ROM_UTF8:\n+         utf8SlotCallback(romClass, (const J9SRP *)slotPtr, slotName, userData);\n+         break;\n+\n+      case J9ROM_NAS:\n+         if (auto nas = SRP_PTR_GET(slotPtr, const J9ROMNameAndSignature *))\n+            {\n+            utf8SlotCallback(romClass, &nas->name, slotName, userData);\n+            utf8SlotCallback(romClass, &nas->signature, slotName, userData);\n+            }\n+         break;\n+      }\n+   }\n+\n+static bool\n+isArrayROMClass(const J9ROMClass *romClass)\n+   {\n+   if (!J9ROMCLASS_IS_ARRAY(romClass))\n+      return false;\n+\n+   auto name = J9ROMCLASS_CLASSNAME(romClass);\n+   TR_ASSERT((name->length == 2) && (name->data[0] == '['),\n+             \"Unexpected array ROMClass name: %.*s\", name->length, name->data);\n+   return true;\n+   }\n+\n+// Array ROMClasses have a different layout (see runtime/vm/romclasses.c):\n+// they all share the same SRP array of interfaces, which breaks the generic\n+// packing implementation. Instead, we manually pack all the data stored\n+// outside of the ROMClass header: class name, superclass name, interfaces.\n+// This function returns the total size of the packed array ROMClass.\n+static size_t\n+getArrayROMClassPackedSize(const J9ROMClass *romClass)\n+   {\n+   size_t totalSize = sizeof(*romClass);\n+   totalSize += getUTF8Size(J9ROMCLASS_CLASSNAME(romClass));\n+   totalSize += getUTF8Size(J9ROMCLASS_SUPERCLASSNAME(romClass));\n+\n+   totalSize += romClass->interfaceCount * sizeof(J9SRP);\n+   for (size_t i = 0; i < romClass->interfaceCount; ++i)\n+      {\n+      auto name = NNSRP_GET(J9ROMCLASS_INTERFACES(romClass)[i], const J9UTF8 *);\n+      totalSize += getUTF8Size(name);\n+      }\n+\n+   return OMR::alignNoCheck(totalSize, sizeof(uint64_t));\n+   }\n+\n+static void\n+packUTF8(const J9UTF8 *str, J9SRP &srp, ROMClassPackContext &ctx)\n+   {\n+   NNSRP_SET(srp, ctx.cursor);\n+   ctx.cursor += copyUTF8((J9UTF8 *)ctx.cursor, str);\n+   }\n+\n+// Packs the data stored outside of the array ROMClass header\n+static void\n+packArrayROMClassData(const J9ROMClass *romClass, ROMClassPackContext &ctx)\n+   {\n+   NNSRP_SET(ctx.packedRomClass->interfaces, ctx.cursor);\n+   ctx.cursor += ctx.packedRomClass->interfaceCount * sizeof(J9SRP);\n+\n+   packUTF8(J9ROMCLASS_CLASSNAME(romClass), ctx.packedRomClass->className, ctx);\n+   packUTF8(J9ROMCLASS_SUPERCLASSNAME(romClass), ctx.packedRomClass->superclassName, ctx);\n+\n+   for (size_t i = 0; i < romClass->interfaceCount; ++i)\n+      {\n+      auto name = NNSRP_GET(J9ROMCLASS_INTERFACES(romClass)[i], const J9UTF8 *);\n+      packUTF8(name, J9ROMCLASS_INTERFACES(ctx.packedRomClass)[i], ctx);\n+      }\n    }\n \n // Packs a ROMClass into a std::string to be transferred to the server.\n-// Some of the name and signature strings are interned and stored outside\n-// of the ROMClass body. Such strings are appended to the end of the cloned\n-// ROMClass body and the self referential pointers to them are updated.\n+// UTF8 strings that a ROMClass refers to can be interned and stored outside of\n+// the ROMClass body. This function puts all the strings (including interned ones)\n+// at the end of the cloned ROMClass in deterministic order and updates the SRPs\n+// to them. It also removes some of the data that is not used by the JIT compiler.\n+//\n+// Packing involves 2 passes over all the strings that a ROMClass refers to:\n+// 1. Compute total size and map original strings to their locations in the packed ROMClass.\n+// 2. Copy each original string to its location in the packed ROMClass.\n static std::string\n-packROMClass(J9ROMClass *origRomClass, TR_Memory *trMemory)\n+packROMClass(J9ROMClass *romClass, TR_Memory *trMemory)\n    {\n-   size_t totalSize = origRomClass->romSize;\n-   J9UTF8 *className = J9ROMCLASS_CLASSNAME(origRomClass);\n-   totalSize += getPackedUTF8Size(className, origRomClass);\n-\n-   J9ROMMethod *romMethod = J9ROMCLASS_ROMMETHODS(origRomClass);\n-   for (size_t i = 0; i < origRomClass->romMethodCount; ++i)\n+   auto name = J9ROMCLASS_CLASSNAME(romClass);\n+   // Primitive ROMClasses have different layout (see runtime/vm/romclasses.c): the last\n+   // ROMClass includes all the others' UTF8 name strings in its romSize, which breaks the\n+   // generic packing implementation. Pretend that its romSize only includes the header.\n+   size_t origRomSize = J9ROMCLASS_IS_PRIMITIVE_TYPE(romClass) ? sizeof(*romClass) : romClass->romSize;\n+   size_t totalSize = origRomSize;\n+\n+   // Remove intermediate class data (not used by JIT)\n+   uint8_t *icData = J9ROMCLASS_INTERMEDIATECLASSDATA(romClass);\n+   if (JITServerHelpers::isAddressInROMClass(icData, romClass) && (icData != (uint8_t *)romClass))\n       {\n-      totalSize += getPackedUTF8Size(J9ROMMETHOD_NAME(romMethod), origRomClass);\n-      totalSize += getPackedUTF8Size(J9ROMMETHOD_SIGNATURE(romMethod), origRomClass);\n-      romMethod = nextROMMethod(romMethod);\n+      TR_ASSERT_FATAL(icData + romClass->intermediateClassDataLength == (uint8_t *)romClass + romClass->romSize,\n+                      \"Intermediate class data not stored at the end of ROMClass %.*s\", name->length, name->data);\n+      totalSize -= romClass->intermediateClassDataLength;\n       }\n \n-   // Check if the contiguous part of the ROMClass already contains all the strings visited above\n-   if (totalSize == origRomClass->romSize)\n-      return std::string((char *)origRomClass, origRomClass->romSize);\n+   // All allocated memory is only used in this function\n+   TR::StackMemoryRegion stackMemoryRegion(*trMemory);\n+   ROMClassPackContext ctx(trMemory, origRomSize);\n \n-   J9ROMClass *romClass = (J9ROMClass *)trMemory->allocateHeapMemory(totalSize);\n-   if (!romClass)\n+   size_t copySize = 0;\n+   if (isArrayROMClass(romClass))\n+      {\n+      copySize = sizeof(*romClass);\n+      totalSize = getArrayROMClassPackedSize(romClass);\n+      }\n+   else\n+      {\n+      // 1st pass: iterate all strings in the ROMClass to compute its total size (including\n+      // interned strings) and map the strings to their locations in the packed ROMClass\n+      ctx.callback = sizeInfoCallback;\n+      allSlotsInROMClassDo(romClass, slotCallback, NULL, NULL, &ctx);\n+      // Handle the case when all strings are interned\n+      auto classEnd = (const uint8_t *)romClass + totalSize;\n+      ctx.utf8SectionStart = std::min(ctx.utf8SectionStart, classEnd);\n+\n+      auto end = ctx.utf8SectionEnd ? ctx.utf8SectionEnd : classEnd;\n+      TR_ASSERT_FATAL(ctx.utf8SectionSize == end - ctx.utf8SectionStart,\n+                      \"Missed strings in ROMClass %.*s UTF8 section: %zu != %zu\",\n+                      name->length, name->data, ctx.utf8SectionSize, end - ctx.utf8SectionStart);\n+      end = (const uint8_t *)OMR::alignNoCheck((uintptr_t)end, sizeof(uint64_t));\n+      TR_ASSERT_FATAL(end == classEnd, \"UTF8 section not stored at the end of ROMClass %.*s: %p != %p\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk3NzUxNg=="}, "originalCommit": {"oid": "cf8bac93c10483471c4cef95c99e5644d0834e99"}, "originalPosition": 307}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQ1Mzk2Mw==", "bodyText": "Right", "url": "https://github.com/eclipse-openj9/openj9/pull/11331#discussion_r538453963", "createdAt": "2020-12-08T14:47:56Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/control/JITServerHelpers.cpp", "diffHunk": "@@ -44,84 +47,309 @@ TR::Monitor *JITServerHelpers::_clientStreamMonitor = NULL;\n static size_t\n getUTF8Size(const J9UTF8 *str)\n    {\n-   return OMR::alignNoCheck(str->length, sizeof(*str)) + sizeof(*str);\n+   return OMR::alignNoCheck(J9UTF8_TOTAL_SIZE(str), sizeof(*str));\n    }\n \n+// Copies a UTF8 string with padding and returns its total size\n static size_t\n-getPackedUTF8Size(const J9UTF8 *str, const J9ROMClass *romClass)\n+copyUTF8(J9UTF8 *dst, const J9UTF8 *src)\n    {\n-   return JITServerHelpers::isAddressInROMClass(str, romClass) ? 0 : getUTF8Size(str);\n+   size_t size = J9UTF8_TOTAL_SIZE(src);\n+   memcpy(dst, src, size);\n+   static_assert(sizeof(*src) == 2, \"UTF8 header is not 2 bytes large\");\n+   if (!OMR::alignedNoCheck(size, sizeof(*src)))\n+      dst->data[src->length] = '\\0';\n+   return OMR::alignNoCheck(size, sizeof(*src));\n    }\n \n-// If the string points outside of the contiguous part of origRomClass, appends\n-// it (with padding) at curPos and updates the SRP to the string in the packed\n-// ROMClass. Returns the new value of curPos.\n-static uint8_t *\n-packUTF8(uint8_t *curPos, const J9UTF8 *origStr, const J9ROMClass *origRomClass, J9SRP &srp)\n+// State maintained while iterating over UTF8 strings in a ROMClass\n+struct ROMClassPackContext\n    {\n-   if (JITServerHelpers::isAddressInROMClass(origStr, origRomClass))\n-      return curPos;\n+   ROMClassPackContext(TR_Memory *trMemory, size_t origRomSize) :\n+      origSize(origRomSize), callback(NULL), stringsSize(0),\n+      utf8SectionStart((const uint8_t *)-1), utf8SectionEnd(NULL), utf8SectionSize(0),\n+      strToOffsetMap(decltype(strToOffsetMap)::allocator_type(trMemory->currentStackRegion())),\n+      packedRomClass(NULL), cursor(NULL) {}\n \n-   size_t size = getUTF8Size(origStr);\n-   memcpy(curPos, origStr, origStr->length + sizeof(*origStr));\n-   static_assert(sizeof(*origStr) == 2, \"UTF8 header is not 2 bytes large\");\n-   if (!OMR::alignedNoCheck(origStr->length, sizeof(*origStr)))\n-      curPos[size - 1] = '\\0';\n-   NNSRP_SET(srp, curPos);\n-   return curPos + size;\n+   bool isInline(const void *address, const J9ROMClass *romClass)\n+      {\n+      return (address >= romClass) && (address < (uint8_t *)romClass + origSize);\n+      }\n+\n+   typedef void (*Callback)(const J9ROMClass *, const J9SRP *, const char *, ROMClassPackContext &);\n+\n+   const size_t origSize;\n+   Callback callback;\n+   size_t stringsSize;\n+   const uint8_t *utf8SectionStart;\n+   const uint8_t *utf8SectionEnd;// only needed for assertions\n+   size_t utf8SectionSize;// only needed for assertions\n+   // Maps original strings to their offsets from UTF8 section start in the packed ROMClass\n+   // Offset value -1 signifies that the string is skipped\n+   UnorderedMap<const J9UTF8 *, size_t> strToOffsetMap;\n+   J9ROMClass *packedRomClass;\n+   uint8_t *cursor;\n+   };\n+\n+static bool\n+shouldSkipSlot(const char *slotName)\n+   {\n+   // Skip variable names and signatures in method debug info; only their slot names have prefix \"variable\"\n+   static const char prefix[] = \"variable\";\n+   return strncmp(slotName, prefix, sizeof(prefix) - 1) == 0;\n+   }\n+\n+// Updates size info and maps original string to its future location in the packed ROMClass\n+static void\n+sizeInfoCallback(const J9ROMClass *romClass, const J9SRP *origSrp, const char *slotName, ROMClassPackContext &ctx)\n+   {\n+   // Skip SRPs stored outside of the ROMClass bounds such as the ones in out-of-line\n+   // method debug info, and the ones that point to strings not used by the JIT.\n+   bool skip = !ctx.isInline(origSrp, romClass) || shouldSkipSlot(slotName);\n+   auto str = NNSRP_PTR_GET(origSrp, const J9UTF8 *);\n+   auto it = ctx.strToOffsetMap.find(str);\n+   if (it != ctx.strToOffsetMap.end())// duplicate - already visited\n+      {\n+      if (!skip && (it->second == (size_t)-1))\n+         {\n+         // Previously visited SRPs to this string were skipped, but this one isn't\n+         it->second = ctx.stringsSize;\n+         ctx.stringsSize += getUTF8Size(str);\n+         }\n+      return;\n+      }\n+\n+   ctx.strToOffsetMap.insert(it, { str, skip ? (size_t)-1 : ctx.stringsSize });\n+   size_t size = getUTF8Size(str);\n+   ctx.stringsSize += skip ? 0 : size;\n+\n+   if (ctx.isInline(str, romClass))\n+      {\n+      ctx.utf8SectionStart = std::min(ctx.utf8SectionStart, (const uint8_t *)str);\n+      ctx.utf8SectionEnd = std::max(ctx.utf8SectionEnd, (const uint8_t *)str + size);\n+      ctx.utf8SectionSize += size;\n+      }\n+   }\n+\n+// Copies original string into its location in the packed ROMClass and updates the SRP to it\n+static void\n+packCallback(const J9ROMClass *romClass, const J9SRP *origSrp, const char *slotName, ROMClassPackContext &ctx)\n+   {\n+   // Skip SRPs stored outside of the ROMClass bounds such as the ones in out-of-line method debug info\n+   if (!ctx.isInline(origSrp, romClass))\n+      return;\n+\n+   auto str = NNSRP_PTR_GET(origSrp, const J9UTF8 *);\n+   auto srp = (J9SRP *)((uint8_t *)ctx.packedRomClass + ((uint8_t *)origSrp - (uint8_t *)romClass));\n+\n+   // Zero out skipped string SRPs\n+   if (shouldSkipSlot(slotName))\n+      {\n+      TR_ASSERT(ctx.strToOffsetMap.find(str) != ctx.strToOffsetMap.end(),\n+                \"UTF8 slot %s not visited in 1st pass\", slotName);\n+      *srp = 0;\n+      return;\n+      }\n+\n+   auto it = ctx.strToOffsetMap.find(str);\n+   TR_ASSERT(it != ctx.strToOffsetMap.end(), \"UTF8 slot %s not visited in 1st pass\", slotName);\n+   auto dst = (uint8_t *)ctx.packedRomClass + (ctx.utf8SectionStart - (uint8_t *)romClass) + it->second;\n+\n+   NNSRP_PTR_SET(srp, dst);\n+   if (dst == ctx.cursor)\n+      ctx.cursor += copyUTF8((J9UTF8 *)dst, str);\n+   else\n+      TR_ASSERT((dst < ctx.cursor) && (memcmp(dst, str, J9UTF8_TOTAL_SIZE(str)) == 0), \"Must be already copied\");\n+   }\n+\n+static void\n+utf8SlotCallback(const J9ROMClass *romClass, const J9SRP *srp, const char *slotName, void *userData)\n+   {\n+   auto &ctx = *(ROMClassPackContext *)userData;\n+   if (*srp)\n+      ctx.callback(romClass, srp, slotName, ctx);\n+   }\n+\n+// Invoked for each slot in a ROMClass. Calls ctx.callback() for all non-null SRPs to UTF8 strings.\n+static void\n+slotCallback(J9ROMClass *romClass, uint32_t slotType, void *slotPtr, const char *slotName, void *userData)\n+   {\n+   switch (slotType)\n+      {\n+      case J9ROM_UTF8:\n+         utf8SlotCallback(romClass, (const J9SRP *)slotPtr, slotName, userData);\n+         break;\n+\n+      case J9ROM_NAS:\n+         if (auto nas = SRP_PTR_GET(slotPtr, const J9ROMNameAndSignature *))\n+            {\n+            utf8SlotCallback(romClass, &nas->name, slotName, userData);\n+            utf8SlotCallback(romClass, &nas->signature, slotName, userData);\n+            }\n+         break;\n+      }\n+   }\n+\n+static bool\n+isArrayROMClass(const J9ROMClass *romClass)\n+   {\n+   if (!J9ROMCLASS_IS_ARRAY(romClass))\n+      return false;\n+\n+   auto name = J9ROMCLASS_CLASSNAME(romClass);\n+   TR_ASSERT((name->length == 2) && (name->data[0] == '['),\n+             \"Unexpected array ROMClass name: %.*s\", name->length, name->data);\n+   return true;\n+   }\n+\n+// Array ROMClasses have a different layout (see runtime/vm/romclasses.c):\n+// they all share the same SRP array of interfaces, which breaks the generic\n+// packing implementation. Instead, we manually pack all the data stored\n+// outside of the ROMClass header: class name, superclass name, interfaces.\n+// This function returns the total size of the packed array ROMClass.\n+static size_t\n+getArrayROMClassPackedSize(const J9ROMClass *romClass)\n+   {\n+   size_t totalSize = sizeof(*romClass);\n+   totalSize += getUTF8Size(J9ROMCLASS_CLASSNAME(romClass));\n+   totalSize += getUTF8Size(J9ROMCLASS_SUPERCLASSNAME(romClass));\n+\n+   totalSize += romClass->interfaceCount * sizeof(J9SRP);\n+   for (size_t i = 0; i < romClass->interfaceCount; ++i)\n+      {\n+      auto name = NNSRP_GET(J9ROMCLASS_INTERFACES(romClass)[i], const J9UTF8 *);\n+      totalSize += getUTF8Size(name);\n+      }\n+\n+   return OMR::alignNoCheck(totalSize, sizeof(uint64_t));\n+   }\n+\n+static void\n+packUTF8(const J9UTF8 *str, J9SRP &srp, ROMClassPackContext &ctx)\n+   {\n+   NNSRP_SET(srp, ctx.cursor);\n+   ctx.cursor += copyUTF8((J9UTF8 *)ctx.cursor, str);\n+   }\n+\n+// Packs the data stored outside of the array ROMClass header\n+static void\n+packArrayROMClassData(const J9ROMClass *romClass, ROMClassPackContext &ctx)\n+   {\n+   NNSRP_SET(ctx.packedRomClass->interfaces, ctx.cursor);\n+   ctx.cursor += ctx.packedRomClass->interfaceCount * sizeof(J9SRP);\n+\n+   packUTF8(J9ROMCLASS_CLASSNAME(romClass), ctx.packedRomClass->className, ctx);\n+   packUTF8(J9ROMCLASS_SUPERCLASSNAME(romClass), ctx.packedRomClass->superclassName, ctx);\n+\n+   for (size_t i = 0; i < romClass->interfaceCount; ++i)\n+      {\n+      auto name = NNSRP_GET(J9ROMCLASS_INTERFACES(romClass)[i], const J9UTF8 *);\n+      packUTF8(name, J9ROMCLASS_INTERFACES(ctx.packedRomClass)[i], ctx);\n+      }\n    }\n \n // Packs a ROMClass into a std::string to be transferred to the server.\n-// Some of the name and signature strings are interned and stored outside\n-// of the ROMClass body. Such strings are appended to the end of the cloned\n-// ROMClass body and the self referential pointers to them are updated.\n+// UTF8 strings that a ROMClass refers to can be interned and stored outside of\n+// the ROMClass body. This function puts all the strings (including interned ones)\n+// at the end of the cloned ROMClass in deterministic order and updates the SRPs\n+// to them. It also removes some of the data that is not used by the JIT compiler.\n+//\n+// Packing involves 2 passes over all the strings that a ROMClass refers to:\n+// 1. Compute total size and map original strings to their locations in the packed ROMClass.\n+// 2. Copy each original string to its location in the packed ROMClass.\n static std::string\n-packROMClass(J9ROMClass *origRomClass, TR_Memory *trMemory)\n+packROMClass(J9ROMClass *romClass, TR_Memory *trMemory)\n    {\n-   size_t totalSize = origRomClass->romSize;\n-   J9UTF8 *className = J9ROMCLASS_CLASSNAME(origRomClass);\n-   totalSize += getPackedUTF8Size(className, origRomClass);\n-\n-   J9ROMMethod *romMethod = J9ROMCLASS_ROMMETHODS(origRomClass);\n-   for (size_t i = 0; i < origRomClass->romMethodCount; ++i)\n+   auto name = J9ROMCLASS_CLASSNAME(romClass);\n+   // Primitive ROMClasses have different layout (see runtime/vm/romclasses.c): the last\n+   // ROMClass includes all the others' UTF8 name strings in its romSize, which breaks the\n+   // generic packing implementation. Pretend that its romSize only includes the header.\n+   size_t origRomSize = J9ROMCLASS_IS_PRIMITIVE_TYPE(romClass) ? sizeof(*romClass) : romClass->romSize;\n+   size_t totalSize = origRomSize;\n+\n+   // Remove intermediate class data (not used by JIT)\n+   uint8_t *icData = J9ROMCLASS_INTERMEDIATECLASSDATA(romClass);\n+   if (JITServerHelpers::isAddressInROMClass(icData, romClass) && (icData != (uint8_t *)romClass))\n       {\n-      totalSize += getPackedUTF8Size(J9ROMMETHOD_NAME(romMethod), origRomClass);\n-      totalSize += getPackedUTF8Size(J9ROMMETHOD_SIGNATURE(romMethod), origRomClass);\n-      romMethod = nextROMMethod(romMethod);\n+      TR_ASSERT_FATAL(icData + romClass->intermediateClassDataLength == (uint8_t *)romClass + romClass->romSize,\n+                      \"Intermediate class data not stored at the end of ROMClass %.*s\", name->length, name->data);\n+      totalSize -= romClass->intermediateClassDataLength;\n       }\n \n-   // Check if the contiguous part of the ROMClass already contains all the strings visited above\n-   if (totalSize == origRomClass->romSize)\n-      return std::string((char *)origRomClass, origRomClass->romSize);\n+   // All allocated memory is only used in this function\n+   TR::StackMemoryRegion stackMemoryRegion(*trMemory);\n+   ROMClassPackContext ctx(trMemory, origRomSize);\n \n-   J9ROMClass *romClass = (J9ROMClass *)trMemory->allocateHeapMemory(totalSize);\n-   if (!romClass)\n+   size_t copySize = 0;\n+   if (isArrayROMClass(romClass))\n+      {\n+      copySize = sizeof(*romClass);\n+      totalSize = getArrayROMClassPackedSize(romClass);\n+      }\n+   else\n+      {\n+      // 1st pass: iterate all strings in the ROMClass to compute its total size (including\n+      // interned strings) and map the strings to their locations in the packed ROMClass\n+      ctx.callback = sizeInfoCallback;\n+      allSlotsInROMClassDo(romClass, slotCallback, NULL, NULL, &ctx);\n+      // Handle the case when all strings are interned\n+      auto classEnd = (const uint8_t *)romClass + totalSize;\n+      ctx.utf8SectionStart = std::min(ctx.utf8SectionStart, classEnd);\n+\n+      auto end = ctx.utf8SectionEnd ? ctx.utf8SectionEnd : classEnd;\n+      TR_ASSERT_FATAL(ctx.utf8SectionSize == end - ctx.utf8SectionStart,\n+                      \"Missed strings in ROMClass %.*s UTF8 section: %zu != %zu\",\n+                      name->length, name->data, ctx.utf8SectionSize, end - ctx.utf8SectionStart);\n+      end = (const uint8_t *)OMR::alignNoCheck((uintptr_t)end, sizeof(uint64_t));\n+      TR_ASSERT_FATAL(end == classEnd, \"UTF8 section not stored at the end of ROMClass %.*s: %p != %p\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk3NzUxNg=="}, "originalCommit": {"oid": "cf8bac93c10483471c4cef95c99e5644d0834e99"}, "originalPosition": 307}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3NzM1MTA1OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/control/JITServerHelpers.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwMjozMToxMVrOIBEC8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwMzozOToyOFrOIBFguA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk4NTc3Nw==", "bodyText": "Does this mean that for array ROMClasses we may send interface names multiple times?", "url": "https://github.com/eclipse-openj9/openj9/pull/11331#discussion_r537985777", "createdAt": "2020-12-08T02:31:11Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/control/JITServerHelpers.cpp", "diffHunk": "@@ -44,84 +47,309 @@ TR::Monitor *JITServerHelpers::_clientStreamMonitor = NULL;\n static size_t\n getUTF8Size(const J9UTF8 *str)\n    {\n-   return OMR::alignNoCheck(str->length, sizeof(*str)) + sizeof(*str);\n+   return OMR::alignNoCheck(J9UTF8_TOTAL_SIZE(str), sizeof(*str));\n    }\n \n+// Copies a UTF8 string with padding and returns its total size\n static size_t\n-getPackedUTF8Size(const J9UTF8 *str, const J9ROMClass *romClass)\n+copyUTF8(J9UTF8 *dst, const J9UTF8 *src)\n    {\n-   return JITServerHelpers::isAddressInROMClass(str, romClass) ? 0 : getUTF8Size(str);\n+   size_t size = J9UTF8_TOTAL_SIZE(src);\n+   memcpy(dst, src, size);\n+   static_assert(sizeof(*src) == 2, \"UTF8 header is not 2 bytes large\");\n+   if (!OMR::alignedNoCheck(size, sizeof(*src)))\n+      dst->data[src->length] = '\\0';\n+   return OMR::alignNoCheck(size, sizeof(*src));\n    }\n \n-// If the string points outside of the contiguous part of origRomClass, appends\n-// it (with padding) at curPos and updates the SRP to the string in the packed\n-// ROMClass. Returns the new value of curPos.\n-static uint8_t *\n-packUTF8(uint8_t *curPos, const J9UTF8 *origStr, const J9ROMClass *origRomClass, J9SRP &srp)\n+// State maintained while iterating over UTF8 strings in a ROMClass\n+struct ROMClassPackContext\n    {\n-   if (JITServerHelpers::isAddressInROMClass(origStr, origRomClass))\n-      return curPos;\n+   ROMClassPackContext(TR_Memory *trMemory, size_t origRomSize) :\n+      origSize(origRomSize), callback(NULL), stringsSize(0),\n+      utf8SectionStart((const uint8_t *)-1), utf8SectionEnd(NULL), utf8SectionSize(0),\n+      strToOffsetMap(decltype(strToOffsetMap)::allocator_type(trMemory->currentStackRegion())),\n+      packedRomClass(NULL), cursor(NULL) {}\n \n-   size_t size = getUTF8Size(origStr);\n-   memcpy(curPos, origStr, origStr->length + sizeof(*origStr));\n-   static_assert(sizeof(*origStr) == 2, \"UTF8 header is not 2 bytes large\");\n-   if (!OMR::alignedNoCheck(origStr->length, sizeof(*origStr)))\n-      curPos[size - 1] = '\\0';\n-   NNSRP_SET(srp, curPos);\n-   return curPos + size;\n+   bool isInline(const void *address, const J9ROMClass *romClass)\n+      {\n+      return (address >= romClass) && (address < (uint8_t *)romClass + origSize);\n+      }\n+\n+   typedef void (*Callback)(const J9ROMClass *, const J9SRP *, const char *, ROMClassPackContext &);\n+\n+   const size_t origSize;\n+   Callback callback;\n+   size_t stringsSize;\n+   const uint8_t *utf8SectionStart;\n+   const uint8_t *utf8SectionEnd;// only needed for assertions\n+   size_t utf8SectionSize;// only needed for assertions\n+   // Maps original strings to their offsets from UTF8 section start in the packed ROMClass\n+   // Offset value -1 signifies that the string is skipped\n+   UnorderedMap<const J9UTF8 *, size_t> strToOffsetMap;\n+   J9ROMClass *packedRomClass;\n+   uint8_t *cursor;\n+   };\n+\n+static bool\n+shouldSkipSlot(const char *slotName)\n+   {\n+   // Skip variable names and signatures in method debug info; only their slot names have prefix \"variable\"\n+   static const char prefix[] = \"variable\";\n+   return strncmp(slotName, prefix, sizeof(prefix) - 1) == 0;\n+   }\n+\n+// Updates size info and maps original string to its future location in the packed ROMClass\n+static void\n+sizeInfoCallback(const J9ROMClass *romClass, const J9SRP *origSrp, const char *slotName, ROMClassPackContext &ctx)\n+   {\n+   // Skip SRPs stored outside of the ROMClass bounds such as the ones in out-of-line\n+   // method debug info, and the ones that point to strings not used by the JIT.\n+   bool skip = !ctx.isInline(origSrp, romClass) || shouldSkipSlot(slotName);\n+   auto str = NNSRP_PTR_GET(origSrp, const J9UTF8 *);\n+   auto it = ctx.strToOffsetMap.find(str);\n+   if (it != ctx.strToOffsetMap.end())// duplicate - already visited\n+      {\n+      if (!skip && (it->second == (size_t)-1))\n+         {\n+         // Previously visited SRPs to this string were skipped, but this one isn't\n+         it->second = ctx.stringsSize;\n+         ctx.stringsSize += getUTF8Size(str);\n+         }\n+      return;\n+      }\n+\n+   ctx.strToOffsetMap.insert(it, { str, skip ? (size_t)-1 : ctx.stringsSize });\n+   size_t size = getUTF8Size(str);\n+   ctx.stringsSize += skip ? 0 : size;\n+\n+   if (ctx.isInline(str, romClass))\n+      {\n+      ctx.utf8SectionStart = std::min(ctx.utf8SectionStart, (const uint8_t *)str);\n+      ctx.utf8SectionEnd = std::max(ctx.utf8SectionEnd, (const uint8_t *)str + size);\n+      ctx.utf8SectionSize += size;\n+      }\n+   }\n+\n+// Copies original string into its location in the packed ROMClass and updates the SRP to it\n+static void\n+packCallback(const J9ROMClass *romClass, const J9SRP *origSrp, const char *slotName, ROMClassPackContext &ctx)\n+   {\n+   // Skip SRPs stored outside of the ROMClass bounds such as the ones in out-of-line method debug info\n+   if (!ctx.isInline(origSrp, romClass))\n+      return;\n+\n+   auto str = NNSRP_PTR_GET(origSrp, const J9UTF8 *);\n+   auto srp = (J9SRP *)((uint8_t *)ctx.packedRomClass + ((uint8_t *)origSrp - (uint8_t *)romClass));\n+\n+   // Zero out skipped string SRPs\n+   if (shouldSkipSlot(slotName))\n+      {\n+      TR_ASSERT(ctx.strToOffsetMap.find(str) != ctx.strToOffsetMap.end(),\n+                \"UTF8 slot %s not visited in 1st pass\", slotName);\n+      *srp = 0;\n+      return;\n+      }\n+\n+   auto it = ctx.strToOffsetMap.find(str);\n+   TR_ASSERT(it != ctx.strToOffsetMap.end(), \"UTF8 slot %s not visited in 1st pass\", slotName);\n+   auto dst = (uint8_t *)ctx.packedRomClass + (ctx.utf8SectionStart - (uint8_t *)romClass) + it->second;\n+\n+   NNSRP_PTR_SET(srp, dst);\n+   if (dst == ctx.cursor)\n+      ctx.cursor += copyUTF8((J9UTF8 *)dst, str);\n+   else\n+      TR_ASSERT((dst < ctx.cursor) && (memcmp(dst, str, J9UTF8_TOTAL_SIZE(str)) == 0), \"Must be already copied\");\n+   }\n+\n+static void\n+utf8SlotCallback(const J9ROMClass *romClass, const J9SRP *srp, const char *slotName, void *userData)\n+   {\n+   auto &ctx = *(ROMClassPackContext *)userData;\n+   if (*srp)\n+      ctx.callback(romClass, srp, slotName, ctx);\n+   }\n+\n+// Invoked for each slot in a ROMClass. Calls ctx.callback() for all non-null SRPs to UTF8 strings.\n+static void\n+slotCallback(J9ROMClass *romClass, uint32_t slotType, void *slotPtr, const char *slotName, void *userData)\n+   {\n+   switch (slotType)\n+      {\n+      case J9ROM_UTF8:\n+         utf8SlotCallback(romClass, (const J9SRP *)slotPtr, slotName, userData);\n+         break;\n+\n+      case J9ROM_NAS:\n+         if (auto nas = SRP_PTR_GET(slotPtr, const J9ROMNameAndSignature *))\n+            {\n+            utf8SlotCallback(romClass, &nas->name, slotName, userData);\n+            utf8SlotCallback(romClass, &nas->signature, slotName, userData);\n+            }\n+         break;\n+      }\n+   }\n+\n+static bool\n+isArrayROMClass(const J9ROMClass *romClass)\n+   {\n+   if (!J9ROMCLASS_IS_ARRAY(romClass))\n+      return false;\n+\n+   auto name = J9ROMCLASS_CLASSNAME(romClass);\n+   TR_ASSERT((name->length == 2) && (name->data[0] == '['),\n+             \"Unexpected array ROMClass name: %.*s\", name->length, name->data);\n+   return true;\n+   }\n+\n+// Array ROMClasses have a different layout (see runtime/vm/romclasses.c):\n+// they all share the same SRP array of interfaces, which breaks the generic\n+// packing implementation. Instead, we manually pack all the data stored\n+// outside of the ROMClass header: class name, superclass name, interfaces.\n+// This function returns the total size of the packed array ROMClass.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf8bac93c10483471c4cef95c99e5644d0834e99"}, "originalPosition": 194}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODAwOTc4NA==", "bodyText": "For a given array ROMClass (or any ROMClass) we send all the strings it refers to (a single copy of each string). Overall, if we consider all the ROMClasses for a given client, there will be multiple copies of some strings (ones that were interned at the client). But it's the same for the current implementation - remote strings are retrieved and cached for each class separately. Deduplicating the strings on the server side would be non-trivial.", "url": "https://github.com/eclipse-openj9/openj9/pull/11331#discussion_r538009784", "createdAt": "2020-12-08T03:39:28Z", "author": {"login": "AlexeyKhrabrov"}, "path": "runtime/compiler/control/JITServerHelpers.cpp", "diffHunk": "@@ -44,84 +47,309 @@ TR::Monitor *JITServerHelpers::_clientStreamMonitor = NULL;\n static size_t\n getUTF8Size(const J9UTF8 *str)\n    {\n-   return OMR::alignNoCheck(str->length, sizeof(*str)) + sizeof(*str);\n+   return OMR::alignNoCheck(J9UTF8_TOTAL_SIZE(str), sizeof(*str));\n    }\n \n+// Copies a UTF8 string with padding and returns its total size\n static size_t\n-getPackedUTF8Size(const J9UTF8 *str, const J9ROMClass *romClass)\n+copyUTF8(J9UTF8 *dst, const J9UTF8 *src)\n    {\n-   return JITServerHelpers::isAddressInROMClass(str, romClass) ? 0 : getUTF8Size(str);\n+   size_t size = J9UTF8_TOTAL_SIZE(src);\n+   memcpy(dst, src, size);\n+   static_assert(sizeof(*src) == 2, \"UTF8 header is not 2 bytes large\");\n+   if (!OMR::alignedNoCheck(size, sizeof(*src)))\n+      dst->data[src->length] = '\\0';\n+   return OMR::alignNoCheck(size, sizeof(*src));\n    }\n \n-// If the string points outside of the contiguous part of origRomClass, appends\n-// it (with padding) at curPos and updates the SRP to the string in the packed\n-// ROMClass. Returns the new value of curPos.\n-static uint8_t *\n-packUTF8(uint8_t *curPos, const J9UTF8 *origStr, const J9ROMClass *origRomClass, J9SRP &srp)\n+// State maintained while iterating over UTF8 strings in a ROMClass\n+struct ROMClassPackContext\n    {\n-   if (JITServerHelpers::isAddressInROMClass(origStr, origRomClass))\n-      return curPos;\n+   ROMClassPackContext(TR_Memory *trMemory, size_t origRomSize) :\n+      origSize(origRomSize), callback(NULL), stringsSize(0),\n+      utf8SectionStart((const uint8_t *)-1), utf8SectionEnd(NULL), utf8SectionSize(0),\n+      strToOffsetMap(decltype(strToOffsetMap)::allocator_type(trMemory->currentStackRegion())),\n+      packedRomClass(NULL), cursor(NULL) {}\n \n-   size_t size = getUTF8Size(origStr);\n-   memcpy(curPos, origStr, origStr->length + sizeof(*origStr));\n-   static_assert(sizeof(*origStr) == 2, \"UTF8 header is not 2 bytes large\");\n-   if (!OMR::alignedNoCheck(origStr->length, sizeof(*origStr)))\n-      curPos[size - 1] = '\\0';\n-   NNSRP_SET(srp, curPos);\n-   return curPos + size;\n+   bool isInline(const void *address, const J9ROMClass *romClass)\n+      {\n+      return (address >= romClass) && (address < (uint8_t *)romClass + origSize);\n+      }\n+\n+   typedef void (*Callback)(const J9ROMClass *, const J9SRP *, const char *, ROMClassPackContext &);\n+\n+   const size_t origSize;\n+   Callback callback;\n+   size_t stringsSize;\n+   const uint8_t *utf8SectionStart;\n+   const uint8_t *utf8SectionEnd;// only needed for assertions\n+   size_t utf8SectionSize;// only needed for assertions\n+   // Maps original strings to their offsets from UTF8 section start in the packed ROMClass\n+   // Offset value -1 signifies that the string is skipped\n+   UnorderedMap<const J9UTF8 *, size_t> strToOffsetMap;\n+   J9ROMClass *packedRomClass;\n+   uint8_t *cursor;\n+   };\n+\n+static bool\n+shouldSkipSlot(const char *slotName)\n+   {\n+   // Skip variable names and signatures in method debug info; only their slot names have prefix \"variable\"\n+   static const char prefix[] = \"variable\";\n+   return strncmp(slotName, prefix, sizeof(prefix) - 1) == 0;\n+   }\n+\n+// Updates size info and maps original string to its future location in the packed ROMClass\n+static void\n+sizeInfoCallback(const J9ROMClass *romClass, const J9SRP *origSrp, const char *slotName, ROMClassPackContext &ctx)\n+   {\n+   // Skip SRPs stored outside of the ROMClass bounds such as the ones in out-of-line\n+   // method debug info, and the ones that point to strings not used by the JIT.\n+   bool skip = !ctx.isInline(origSrp, romClass) || shouldSkipSlot(slotName);\n+   auto str = NNSRP_PTR_GET(origSrp, const J9UTF8 *);\n+   auto it = ctx.strToOffsetMap.find(str);\n+   if (it != ctx.strToOffsetMap.end())// duplicate - already visited\n+      {\n+      if (!skip && (it->second == (size_t)-1))\n+         {\n+         // Previously visited SRPs to this string were skipped, but this one isn't\n+         it->second = ctx.stringsSize;\n+         ctx.stringsSize += getUTF8Size(str);\n+         }\n+      return;\n+      }\n+\n+   ctx.strToOffsetMap.insert(it, { str, skip ? (size_t)-1 : ctx.stringsSize });\n+   size_t size = getUTF8Size(str);\n+   ctx.stringsSize += skip ? 0 : size;\n+\n+   if (ctx.isInline(str, romClass))\n+      {\n+      ctx.utf8SectionStart = std::min(ctx.utf8SectionStart, (const uint8_t *)str);\n+      ctx.utf8SectionEnd = std::max(ctx.utf8SectionEnd, (const uint8_t *)str + size);\n+      ctx.utf8SectionSize += size;\n+      }\n+   }\n+\n+// Copies original string into its location in the packed ROMClass and updates the SRP to it\n+static void\n+packCallback(const J9ROMClass *romClass, const J9SRP *origSrp, const char *slotName, ROMClassPackContext &ctx)\n+   {\n+   // Skip SRPs stored outside of the ROMClass bounds such as the ones in out-of-line method debug info\n+   if (!ctx.isInline(origSrp, romClass))\n+      return;\n+\n+   auto str = NNSRP_PTR_GET(origSrp, const J9UTF8 *);\n+   auto srp = (J9SRP *)((uint8_t *)ctx.packedRomClass + ((uint8_t *)origSrp - (uint8_t *)romClass));\n+\n+   // Zero out skipped string SRPs\n+   if (shouldSkipSlot(slotName))\n+      {\n+      TR_ASSERT(ctx.strToOffsetMap.find(str) != ctx.strToOffsetMap.end(),\n+                \"UTF8 slot %s not visited in 1st pass\", slotName);\n+      *srp = 0;\n+      return;\n+      }\n+\n+   auto it = ctx.strToOffsetMap.find(str);\n+   TR_ASSERT(it != ctx.strToOffsetMap.end(), \"UTF8 slot %s not visited in 1st pass\", slotName);\n+   auto dst = (uint8_t *)ctx.packedRomClass + (ctx.utf8SectionStart - (uint8_t *)romClass) + it->second;\n+\n+   NNSRP_PTR_SET(srp, dst);\n+   if (dst == ctx.cursor)\n+      ctx.cursor += copyUTF8((J9UTF8 *)dst, str);\n+   else\n+      TR_ASSERT((dst < ctx.cursor) && (memcmp(dst, str, J9UTF8_TOTAL_SIZE(str)) == 0), \"Must be already copied\");\n+   }\n+\n+static void\n+utf8SlotCallback(const J9ROMClass *romClass, const J9SRP *srp, const char *slotName, void *userData)\n+   {\n+   auto &ctx = *(ROMClassPackContext *)userData;\n+   if (*srp)\n+      ctx.callback(romClass, srp, slotName, ctx);\n+   }\n+\n+// Invoked for each slot in a ROMClass. Calls ctx.callback() for all non-null SRPs to UTF8 strings.\n+static void\n+slotCallback(J9ROMClass *romClass, uint32_t slotType, void *slotPtr, const char *slotName, void *userData)\n+   {\n+   switch (slotType)\n+      {\n+      case J9ROM_UTF8:\n+         utf8SlotCallback(romClass, (const J9SRP *)slotPtr, slotName, userData);\n+         break;\n+\n+      case J9ROM_NAS:\n+         if (auto nas = SRP_PTR_GET(slotPtr, const J9ROMNameAndSignature *))\n+            {\n+            utf8SlotCallback(romClass, &nas->name, slotName, userData);\n+            utf8SlotCallback(romClass, &nas->signature, slotName, userData);\n+            }\n+         break;\n+      }\n+   }\n+\n+static bool\n+isArrayROMClass(const J9ROMClass *romClass)\n+   {\n+   if (!J9ROMCLASS_IS_ARRAY(romClass))\n+      return false;\n+\n+   auto name = J9ROMCLASS_CLASSNAME(romClass);\n+   TR_ASSERT((name->length == 2) && (name->data[0] == '['),\n+             \"Unexpected array ROMClass name: %.*s\", name->length, name->data);\n+   return true;\n+   }\n+\n+// Array ROMClasses have a different layout (see runtime/vm/romclasses.c):\n+// they all share the same SRP array of interfaces, which breaks the generic\n+// packing implementation. Instead, we manually pack all the data stored\n+// outside of the ROMClass header: class name, superclass name, interfaces.\n+// This function returns the total size of the packed array ROMClass.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk4NTc3Nw=="}, "originalCommit": {"oid": "cf8bac93c10483471c4cef95c99e5644d0834e99"}, "originalPosition": 194}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 995, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}