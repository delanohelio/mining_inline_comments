{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcyNTIwOTAy", "number": 8527, "title": "Support Known Object Table in JITServer", "bodyText": "Two main issues to consider when supporting KOT at the server:\n\nPrevent the object pointer from being dereferenced directly at the server since it requires the VM access.\nThe known object table is created at the client and the server. Some operations might cause the KOT to be updated directly at the client without going through the server first. Need to make sure the tables at the client and the server in sync.\n\nMajor changes include:\nAdd KnownObjectTable::updateKnownObjectTableAtServer() which is used to update KOT at the server.\nReplace the direct dereference of getPointerLocation() with getPointer(). When getPointer() is called at the server, it sends a message to the client to dereference it with the proper VM access.\nSend messages to the client to dereference the object pointer or retrieve the index if getIndex() is called.\nAlthough there are a few places the known object pointers are dereferenced directly, it wouldn\u2019t cause a problem if the critical section is created with VMAccessCriticalSection::tryToAcquireVMAccess, because at the server the VM access will not be granted.\n== TODOs ==\n\nRename getIndex() with a name that reflects this method could also create a new reference which ends up increasing the size of KOT.\nImplement KnownObjectTable::dumpTo() and KnownObjectTable::dumpObjectTo() at the server.\n\nSigned-off-by: Annabelle Huo Annabelle.Huo@ibm.com", "createdAt": "2020-02-07T17:28:27Z", "url": "https://github.com/eclipse-openj9/openj9/pull/8527", "merged": true, "mergeCommit": {"oid": "b593b3b86f029e4fd6575a000aa64dcc7f41b0c6"}, "closed": true, "closedAt": "2020-03-11T02:24:55Z", "author": {"login": "a7ehuo"}, "timelineItems": {"totalCount": 35, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcCGyGYgBqjMwMTkyNzAyNDc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcMYfsngFqTM3MjI5NTA4MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "dce3da59981eff53d769c6302c10b00770f48c28", "author": {"user": {"login": "a7ehuo", "name": "Annabelle Huo"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/dce3da59981eff53d769c6302c10b00770f48c28", "committedDate": "2020-02-07T17:26:27Z", "message": "WIP - Add Known Object Table support at the server\n\n[skip ci]\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>"}, "afterCommit": {"oid": "743a627411d21f76a473880c75c12788b51986eb", "author": {"user": {"login": "a7ehuo", "name": "Annabelle Huo"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/743a627411d21f76a473880c75c12788b51986eb", "committedDate": "2020-02-07T22:07:36Z", "message": "WIP - Add Known Object Table support at the server\n\n[skip ci]\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "743a627411d21f76a473880c75c12788b51986eb", "author": {"user": {"login": "a7ehuo", "name": "Annabelle Huo"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/743a627411d21f76a473880c75c12788b51986eb", "committedDate": "2020-02-07T22:07:36Z", "message": "WIP - Add Known Object Table support at the server\n\n[skip ci]\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>"}, "afterCommit": {"oid": "788cca78ca8fbf9808f223445e37fa9cf6682299", "author": {"user": {"login": "a7ehuo", "name": "Annabelle Huo"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/788cca78ca8fbf9808f223445e37fa9cf6682299", "committedDate": "2020-02-07T22:39:29Z", "message": "WIP - Add Known Object Table support at the server\n\n[skip ci]\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "788cca78ca8fbf9808f223445e37fa9cf6682299", "author": {"user": {"login": "a7ehuo", "name": "Annabelle Huo"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/788cca78ca8fbf9808f223445e37fa9cf6682299", "committedDate": "2020-02-07T22:39:29Z", "message": "WIP - Add Known Object Table support at the server\n\n[skip ci]\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>"}, "afterCommit": {"oid": "259b7a0e74e8e9e889750a42b4c07c6945d7c73d", "author": {"user": {"login": "a7ehuo", "name": "Annabelle Huo"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/259b7a0e74e8e9e889750a42b4c07c6945d7c73d", "committedDate": "2020-02-11T22:24:55Z", "message": "WIP - Add Known Object Table support at the server\n\n[skip ci]\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "259b7a0e74e8e9e889750a42b4c07c6945d7c73d", "author": {"user": {"login": "a7ehuo", "name": "Annabelle Huo"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/259b7a0e74e8e9e889750a42b4c07c6945d7c73d", "committedDate": "2020-02-11T22:24:55Z", "message": "WIP - Add Known Object Table support at the server\n\n[skip ci]\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>"}, "afterCommit": {"oid": "8cd30efd89f618b6ede6395407ddecf772e1f9f3", "author": {"user": {"login": "a7ehuo", "name": "Annabelle Huo"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/8cd30efd89f618b6ede6395407ddecf772e1f9f3", "committedDate": "2020-02-12T21:59:42Z", "message": "WIP - Add Known Object Table support at the server\n\n[skip ci]\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4Mjg2OTY5", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#pullrequestreview-358286969", "createdAt": "2020-02-13T15:01:46Z", "commit": {"oid": "8cd30efd89f618b6ede6395407ddecf772e1f9f3"}, "state": "COMMENTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxNTowMTo0NlrOFpXJew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxODozMToyN1rOFpe49w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODkxNTE5NQ==", "bodyText": "Could you please document why _compiler can be NULL here? This must be related to the client somehow.", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r378915195", "createdAt": "2020-02-13T15:01:46Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/control/CompilationThread.cpp", "diffHunk": "@@ -7370,7 +7371,7 @@ TR::CompilationInfoPerThreadBase::postCompilationTasks(J9VMThread * vmThread,\n       {\n       metaData = 0;\n       }\n-   else if (TR::CompilationInfo::shouldRetryCompilation(entry, _compiler))\n+   else if (_compiler && TR::CompilationInfo::shouldRetryCompilation(entry, _compiler))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8cd30efd89f618b6ede6395407ddecf772e1f9f3"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODkyMzc1Ng==", "bodyText": "Maybe this could be simplified to:\nif (_compiler->getKnownObjectTable() &&\n    (!_compiler->isOutOfProcessCompilation() || metadata)) // Compilation aborted early at the server\n\nWhy don't we delete those JNI references at the server if the compilation was aborted early?", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r378923756", "createdAt": "2020-02-13T15:15:11Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/control/CompilationThread.cpp", "diffHunk": "@@ -7550,7 +7546,18 @@ TR::CompilationInfoPerThreadBase::postCompilationTasks(J9VMThread * vmThread,\n #endif /* defined(JITSERVER_SUPPORT) */\n \n    if (_compiler)\n+      {\n+      bool isToFreeKnownObjectTable = true;\n+      // Compilation aborted early at the server\n+      if (_compiler->getPersistentInfo()->getRemoteCompilationMode() == JITServer::SERVER && !metaData)\n+         isToFreeKnownObjectTable = false;\n+\n+      // The KOT needs to survive at least until we're done committing virtual guards\n+      if (_compiler->getKnownObjectTable() && isToFreeKnownObjectTable)\n+         _compiler->freeKnownObjectTable();\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8cd30efd89f618b6ede6395407ddecf772e1f9f3"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODk4NzgwOA==", "bodyText": "Is this a bug fix?", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r378987808", "createdAt": "2020-02-13T16:52:31Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/control/CompilationThread.cpp", "diffHunk": "@@ -7720,44 +7727,54 @@ TR::CompilationInfoPerThreadBase::compile(J9VMThread * vmThread,\n       {\n       entry->_compErrCode = compilationFailure;\n \n-      if (TR::Options::isAnyVerboseOptionSet(TR_VerboseCompileEnd, TR_VerboseCompFailure, TR_VerbosePerformance))\n+      //if (TR::Options::isAnyVerboseOptionSet(TR_VerboseCompileEnd, TR_VerboseCompFailure, TR_VerbosePerformance))\n          {\n          try\n             {\n             throw;\n             }\n          catch (const J9::JITShutdown)\n             {\n-            TR_VerboseLog::writeLineLocked(TR_Vlog_FAILURE,\"<EARLY TRANSLATION FAILURE: JIT Shutdown signaled>\");\n+            printf(\"%s: <EARLY TRANSLATION FAILURE: JIT Shutdown signaled>\\n\", __PRETTY_FUNCTION__);\n+            //TR_VerboseLog::writeLineLocked(TR_Vlog_FAILURE,\"<EARLY TRANSLATION FAILURE: JIT Shutdown signaled>\");\n             }\n          catch (const std::bad_alloc &e)\n             {\n-            TR_VerboseLog::writeLineLocked(TR_Vlog_FAILURE,\"<EARLY TRANSLATION FAILURE: out of scratch memory>\");\n+            printf(\"%s: <EARLY TRANSLATION FAILURE: out of scratch memory>\\n\", __PRETTY_FUNCTION__);\n+            //TR_VerboseLog::writeLineLocked(TR_Vlog_FAILURE,\"<EARLY TRANSLATION FAILURE: out of scratch memory>\");\n             }\n          catch (const std::exception &e)\n             {\n-            TR_VerboseLog::writeLineLocked(TR_Vlog_FAILURE,\"<EARLY TRANSLATION FAILURE: compilation aborted>\");\n+            printf(\"%s: <EARLY TRANSLATION FAILURE: compilation aborted>: %s @ %s\\n\", __PRETTY_FUNCTION__, getCompilation()->signature(), getCompilation()->getHotnessName());\n+            //TR_VerboseLog::writeLineLocked(TR_Vlog_FAILURE,\"<EARLY TRANSLATION FAILURE: compilation aborted>\");\n+            //\n+            //\n+            //            \"Failed to load previously AOT compiled body for %s @ %s\",\n             }\n          }\n \n       Trc_JIT_outOfMemory(vmThread);\n+\n+#if 0\n #if defined(JITSERVER_SUPPORT)\n       if (getCompilation() && getCompilation()->getPersistentInfo()->getRemoteCompilationMode() == JITServer::SERVER)\n          {\n          getCompilation()->getOptions()->closeLogFileForClientOptions();\n          }\n #endif /* defined(JITSERVER_SUPPORT) */\n+\n       if (getCompilation())\n          {\n+         printf(\"%s: does knownObjectTable need to be freed at the client and the server here? How? What if there  a stream failure?\\n\", __PRETTY_FUNCTION__);\n          getCompilation()->~Compilation();\n          }\n       setCompilation(NULL);\n-\n+#endif\n       // This method has to be called from within the catch block,\n       // since moving it outside would result in it getting invoked\n       // twice on a successful compilation.\n       startPC = postCompilationTasks(vmThread, entry, method,\n-                                     aotCachedMethod, metaData,\n+                                     aotCachedMethod, NULL,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8cd30efd89f618b6ede6395407ddecf772e1f9f3"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTAxMDUyNQ==", "bodyText": "I would like a comment explaining why this statement does not need to be done at the server.", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r379010525", "createdAt": "2020-02-13T17:30:54Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/optimizer/InterpreterEmulator.cpp", "diffHunk": "@@ -706,7 +706,11 @@ InterpreterEmulator::visitInvokestatic()\n                _recursionDepth, allconsts);\n          if (mcsIndex != TR::KnownObjectTable::UNKNOWN)\n             {\n+#if defined(JITSERVER_SUPPORT)\n+            if (!comp()->isOutOfProcessCompilation() && comp()->getKnownObjectTable())\n+#else\n             if (comp()->getKnownObjectTable())\n+#endif /* defined(JITSERVER_SUPPORT) */\n                mcs->setMCSReferenceLocation(comp()->getKnownObjectTable()->getPointerLocation(mcsIndex));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8cd30efd89f618b6ede6395407ddecf772e1f9f3"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTAyNzE5NA==", "bodyText": "Why does this method need to be reimplemented? It should call the correct getIndex method, though addArrayWithConstantElements also needs to do the right thing (if the client also maintains a KOT, it may need to add the index to the bitvector represented by _arrayWithConstantElements though I am unsure).", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r379027194", "createdAt": "2020-02-13T18:02:43Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/env/J9KnownObjectTable.cpp", "diffHunk": "@@ -56,28 +65,167 @@ J9::KnownObjectTable::isNull(Index index)\n TR::KnownObjectTable::Index\n J9::KnownObjectTable::getIndex(uintptrj_t objectPointer)\n    {\n-   TR_J9VMBase *fej9 = (TR_J9VMBase *)(self()->fe());\n-   TR_ASSERT(fej9->haveAccess(), \"Must haveAccess in J9::KnownObjectTable::getIndex\");\n    if (objectPointer == 0)\n       return 0; // Special Index value for NULL\n \n-   // Search for existing matching entry\n-   //\n    uint32_t nextIndex = self()->getEndIndex();\n-   for (uint32_t i = 1; i < nextIndex; i++)\n-      if (*_references.element(i) == objectPointer)\n-         return i;\n-\n-   // No luck -- allocate a new one\n-   //\n-   J9VMThread *thread = getJ9VMThreadFromTR_VM(self()->fe());\n-   TR_ASSERT(thread, \"assertion failure\");\n-   _references.setSize(nextIndex+1);\n-   _references[nextIndex] = (uintptrj_t*)thread->javaVM->internalVMFunctions->j9jni_createLocalRef((JNIEnv*)thread, (j9object_t)objectPointer);\n+#if defined(JITSERVER_SUPPORT)\n+   if (self()->comp()->isOutOfProcessCompilation())\n+      {\n+      auto stream = TR::CompilationInfo::getStream();\n+      stream->write(JITServer::MessageType::KnownObjectTable_getIndex, objectPointer);\n+      auto recv = stream->read<TR::KnownObjectTable::Index, uintptrj_t *>();\n+\n+      TR::KnownObjectTable::Index index = std::get<0>(recv);\n+      if (index != nextIndex)\n+         {\n+         return index;\n+         }\n+      else\n+         {\n+         _references.setSize(nextIndex+1);\n+         _references[nextIndex] = std::get<1>(recv);\n+         }\n+      }\n+   else\n+#endif /* defined(JITSERVER_SUPPORT) */\n+      {\n+      TR_J9VMBase *fej9 = (TR_J9VMBase *)(self()->fe());\n+      TR_ASSERT(fej9->haveAccess(), \"Must haveAccess in J9::KnownObjectTable::getIndex\");\n+\n+      // Search for existing matching entry\n+      //\n+      for (uint32_t i = 1; i < nextIndex; i++)\n+         if (*_references.element(i) == objectPointer)\n+            return i;\n+\n+      // No luck -- allocate a new one\n+      //\n+      J9VMThread *thread = getJ9VMThreadFromTR_VM(self()->fe());\n+      TR_ASSERT(thread, \"assertion failure\");\n+      _references.setSize(nextIndex+1);\n+      _references[nextIndex] = (uintptrj_t*)thread->javaVM->internalVMFunctions->j9jni_createLocalRef((JNIEnv*)thread, (j9object_t)objectPointer);\n+      }\n+\n    return nextIndex;\n    }\n \n \n+TR::KnownObjectTable::Index\n+J9::KnownObjectTable::getIndex(uintptrj_t objectPointer, bool isArrayWithConstantElements)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8cd30efd89f618b6ede6395407ddecf772e1f9f3"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTAyNzk5MQ==", "bodyText": "I see a difference. In the original implementation we assume that we have VM access. However, I think that the server always holds VM access.", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r379027991", "createdAt": "2020-02-13T18:04:25Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/env/J9KnownObjectTable.cpp", "diffHunk": "@@ -56,28 +65,167 @@ J9::KnownObjectTable::isNull(Index index)\n TR::KnownObjectTable::Index\n J9::KnownObjectTable::getIndex(uintptrj_t objectPointer)\n    {\n-   TR_J9VMBase *fej9 = (TR_J9VMBase *)(self()->fe());\n-   TR_ASSERT(fej9->haveAccess(), \"Must haveAccess in J9::KnownObjectTable::getIndex\");\n    if (objectPointer == 0)\n       return 0; // Special Index value for NULL\n \n-   // Search for existing matching entry\n-   //\n    uint32_t nextIndex = self()->getEndIndex();\n-   for (uint32_t i = 1; i < nextIndex; i++)\n-      if (*_references.element(i) == objectPointer)\n-         return i;\n-\n-   // No luck -- allocate a new one\n-   //\n-   J9VMThread *thread = getJ9VMThreadFromTR_VM(self()->fe());\n-   TR_ASSERT(thread, \"assertion failure\");\n-   _references.setSize(nextIndex+1);\n-   _references[nextIndex] = (uintptrj_t*)thread->javaVM->internalVMFunctions->j9jni_createLocalRef((JNIEnv*)thread, (j9object_t)objectPointer);\n+#if defined(JITSERVER_SUPPORT)\n+   if (self()->comp()->isOutOfProcessCompilation())\n+      {\n+      auto stream = TR::CompilationInfo::getStream();\n+      stream->write(JITServer::MessageType::KnownObjectTable_getIndex, objectPointer);\n+      auto recv = stream->read<TR::KnownObjectTable::Index, uintptrj_t *>();\n+\n+      TR::KnownObjectTable::Index index = std::get<0>(recv);\n+      if (index != nextIndex)\n+         {\n+         return index;\n+         }\n+      else\n+         {\n+         _references.setSize(nextIndex+1);\n+         _references[nextIndex] = std::get<1>(recv);\n+         }\n+      }\n+   else\n+#endif /* defined(JITSERVER_SUPPORT) */\n+      {\n+      TR_J9VMBase *fej9 = (TR_J9VMBase *)(self()->fe());\n+      TR_ASSERT(fej9->haveAccess(), \"Must haveAccess in J9::KnownObjectTable::getIndex\");\n+\n+      // Search for existing matching entry\n+      //\n+      for (uint32_t i = 1; i < nextIndex; i++)\n+         if (*_references.element(i) == objectPointer)\n+            return i;\n+\n+      // No luck -- allocate a new one\n+      //\n+      J9VMThread *thread = getJ9VMThreadFromTR_VM(self()->fe());\n+      TR_ASSERT(thread, \"assertion failure\");\n+      _references.setSize(nextIndex+1);\n+      _references[nextIndex] = (uintptrj_t*)thread->javaVM->internalVMFunctions->j9jni_createLocalRef((JNIEnv*)thread, (j9object_t)objectPointer);\n+      }\n+\n    return nextIndex;\n    }\n \n \n+TR::KnownObjectTable::Index\n+J9::KnownObjectTable::getIndex(uintptrj_t objectPointer, bool isArrayWithConstantElements)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTAyNzE5NA=="}, "originalCommit": {"oid": "8cd30efd89f618b6ede6395407ddecf772e1f9f3"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTAyODc5OA==", "bodyText": "This is a new method. Does it need to be virtual?", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r379028798", "createdAt": "2020-02-13T18:06:00Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/env/J9KnownObjectTable.hpp", "diffHunk": "@@ -59,13 +59,24 @@ class OMR_EXTENSIBLE KnownObjectTable : public OMR::KnownObjectTableConnector\n \n    KnownObjectTable(TR::Compilation *comp);\n \n+   TR::KnownObjectTable *self();\n+\n    virtual Index getEndIndex();\n    virtual Index getIndex(uintptrj_t objectPointer);\n+   Index getIndex(uintptrj_t objectPointer, bool isArrayWithConstantElements);\n    virtual uintptrj_t *getPointerLocation(Index index);\n    virtual bool isNull(Index index);\n \n    virtual void dumpTo(TR::FILE *file, TR::Compilation *comp);\n \n+   virtual Index getIndexAt(uintptrj_t *objectReferenceLocation);\n+   virtual Index getIndexAt(uintptrj_t *objectReferenceLocation, bool isArrayWithConstantElements);\n+   virtual Index getExistingIndexAt(uintptrj_t *objectReferenceLocation);\n+\n+   virtual uintptrj_t getPointer(Index index);\n+\n+   virtual uintptrj_t dereferenceObjectPointerReference(uintptrj_t *objectReferenceLocation);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8cd30efd89f618b6ede6395407ddecf772e1f9f3"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTAzMzAxNg==", "bodyText": "Again, I don't know if addArrayWithConstantEelements() needs to be executed at the client as well.", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r379033016", "createdAt": "2020-02-13T18:14:29Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/env/J9KnownObjectTable.cpp", "diffHunk": "@@ -56,28 +65,167 @@ J9::KnownObjectTable::isNull(Index index)\n TR::KnownObjectTable::Index\n J9::KnownObjectTable::getIndex(uintptrj_t objectPointer)\n    {\n-   TR_J9VMBase *fej9 = (TR_J9VMBase *)(self()->fe());\n-   TR_ASSERT(fej9->haveAccess(), \"Must haveAccess in J9::KnownObjectTable::getIndex\");\n    if (objectPointer == 0)\n       return 0; // Special Index value for NULL\n \n-   // Search for existing matching entry\n-   //\n    uint32_t nextIndex = self()->getEndIndex();\n-   for (uint32_t i = 1; i < nextIndex; i++)\n-      if (*_references.element(i) == objectPointer)\n-         return i;\n-\n-   // No luck -- allocate a new one\n-   //\n-   J9VMThread *thread = getJ9VMThreadFromTR_VM(self()->fe());\n-   TR_ASSERT(thread, \"assertion failure\");\n-   _references.setSize(nextIndex+1);\n-   _references[nextIndex] = (uintptrj_t*)thread->javaVM->internalVMFunctions->j9jni_createLocalRef((JNIEnv*)thread, (j9object_t)objectPointer);\n+#if defined(JITSERVER_SUPPORT)\n+   if (self()->comp()->isOutOfProcessCompilation())\n+      {\n+      auto stream = TR::CompilationInfo::getStream();\n+      stream->write(JITServer::MessageType::KnownObjectTable_getIndex, objectPointer);\n+      auto recv = stream->read<TR::KnownObjectTable::Index, uintptrj_t *>();\n+\n+      TR::KnownObjectTable::Index index = std::get<0>(recv);\n+      if (index != nextIndex)\n+         {\n+         return index;\n+         }\n+      else\n+         {\n+         _references.setSize(nextIndex+1);\n+         _references[nextIndex] = std::get<1>(recv);\n+         }\n+      }\n+   else\n+#endif /* defined(JITSERVER_SUPPORT) */\n+      {\n+      TR_J9VMBase *fej9 = (TR_J9VMBase *)(self()->fe());\n+      TR_ASSERT(fej9->haveAccess(), \"Must haveAccess in J9::KnownObjectTable::getIndex\");\n+\n+      // Search for existing matching entry\n+      //\n+      for (uint32_t i = 1; i < nextIndex; i++)\n+         if (*_references.element(i) == objectPointer)\n+            return i;\n+\n+      // No luck -- allocate a new one\n+      //\n+      J9VMThread *thread = getJ9VMThreadFromTR_VM(self()->fe());\n+      TR_ASSERT(thread, \"assertion failure\");\n+      _references.setSize(nextIndex+1);\n+      _references[nextIndex] = (uintptrj_t*)thread->javaVM->internalVMFunctions->j9jni_createLocalRef((JNIEnv*)thread, (j9object_t)objectPointer);\n+      }\n+\n    return nextIndex;\n    }\n \n \n+TR::KnownObjectTable::Index\n+J9::KnownObjectTable::getIndex(uintptrj_t objectPointer, bool isArrayWithConstantElements)\n+   {\n+   TR::KnownObjectTable::Index index = self()->getIndex(objectPointer);\n+   if (isArrayWithConstantElements)\n+      {\n+      self()->addArrayWithConstantElements(index);\n+      }\n+   return index;\n+   }\n+\n+\n+uintptrj_t\n+J9::KnownObjectTable::dereferenceObjectPointerReference(uintptrj_t *objectReferenceLocation)\n+   {\n+   uintptrj_t objectPointer = 0;\n+#if defined(JITSERVER_SUPPORT)\n+   if (self()->comp()->isOutOfProcessCompilation())\n+      {\n+      auto stream = TR::CompilationInfo::getStream();\n+      stream->write(JITServer::MessageType::KnownObjectTable_dereferenceObjectPointerReference, objectReferenceLocation);\n+      objectPointer = std::get<0>(stream->read<uintptrj_t>());\n+      }\n+   else\n+#endif /* defined(JITSERVER_SUPPORT) */\n+      {\n+      TR::VMAccessCriticalSection dereferenceObjectPointerReferenceCriticalSection(self()->comp());\n+      objectPointer = *objectReferenceLocation;\n+      }\n+   return objectPointer;\n+   }\n+\n+\n+TR::KnownObjectTable::Index\n+J9::KnownObjectTable::getIndexAt(uintptrj_t *objectReferenceLocation)\n+   {\n+   TR::KnownObjectTable::Index result = UNKNOWN;\n+#if defined(JITSERVER_SUPPORT)\n+   if (self()->comp()->isOutOfProcessCompilation())\n+      {\n+      uintptrj_t objectPointer = self()->dereferenceObjectPointerReference(objectReferenceLocation);\n+      result = self()->getIndex(objectPointer);\n+      }\n+#endif /* defined(JITSERVER_SUPPORT) */\n+   else\n+      {\n+      TR::VMAccessCriticalSection getIndexAtCriticalSection(self()->comp());\n+      uintptrj_t objectPointer = *objectReferenceLocation; // Note: object references held as uintptrj_t must never be compressed refs\n+      result = self()->getIndex(objectPointer);\n+      }\n+   return result;\n+   }\n+\n+TR::KnownObjectTable::Index\n+J9::KnownObjectTable::getIndexAt(uintptrj_t *objectReferenceLocation, bool isArrayWithConstantElements)\n+   {\n+   Index result = self()->getIndexAt(objectReferenceLocation);\n+   if (isArrayWithConstantElements)\n+      self()->addArrayWithConstantElements(result);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8cd30efd89f618b6ede6395407ddecf772e1f9f3"}, "originalPosition": 152}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTAzMzkyMg==", "bodyText": "This implementation will send two messages: one for dereferencing the JNI reference given as parameter and another to do the search through the KOT. Maybe just send a message that will do both.", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r379033922", "createdAt": "2020-02-13T18:16:18Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/env/J9KnownObjectTable.cpp", "diffHunk": "@@ -56,28 +65,167 @@ J9::KnownObjectTable::isNull(Index index)\n TR::KnownObjectTable::Index\n J9::KnownObjectTable::getIndex(uintptrj_t objectPointer)\n    {\n-   TR_J9VMBase *fej9 = (TR_J9VMBase *)(self()->fe());\n-   TR_ASSERT(fej9->haveAccess(), \"Must haveAccess in J9::KnownObjectTable::getIndex\");\n    if (objectPointer == 0)\n       return 0; // Special Index value for NULL\n \n-   // Search for existing matching entry\n-   //\n    uint32_t nextIndex = self()->getEndIndex();\n-   for (uint32_t i = 1; i < nextIndex; i++)\n-      if (*_references.element(i) == objectPointer)\n-         return i;\n-\n-   // No luck -- allocate a new one\n-   //\n-   J9VMThread *thread = getJ9VMThreadFromTR_VM(self()->fe());\n-   TR_ASSERT(thread, \"assertion failure\");\n-   _references.setSize(nextIndex+1);\n-   _references[nextIndex] = (uintptrj_t*)thread->javaVM->internalVMFunctions->j9jni_createLocalRef((JNIEnv*)thread, (j9object_t)objectPointer);\n+#if defined(JITSERVER_SUPPORT)\n+   if (self()->comp()->isOutOfProcessCompilation())\n+      {\n+      auto stream = TR::CompilationInfo::getStream();\n+      stream->write(JITServer::MessageType::KnownObjectTable_getIndex, objectPointer);\n+      auto recv = stream->read<TR::KnownObjectTable::Index, uintptrj_t *>();\n+\n+      TR::KnownObjectTable::Index index = std::get<0>(recv);\n+      if (index != nextIndex)\n+         {\n+         return index;\n+         }\n+      else\n+         {\n+         _references.setSize(nextIndex+1);\n+         _references[nextIndex] = std::get<1>(recv);\n+         }\n+      }\n+   else\n+#endif /* defined(JITSERVER_SUPPORT) */\n+      {\n+      TR_J9VMBase *fej9 = (TR_J9VMBase *)(self()->fe());\n+      TR_ASSERT(fej9->haveAccess(), \"Must haveAccess in J9::KnownObjectTable::getIndex\");\n+\n+      // Search for existing matching entry\n+      //\n+      for (uint32_t i = 1; i < nextIndex; i++)\n+         if (*_references.element(i) == objectPointer)\n+            return i;\n+\n+      // No luck -- allocate a new one\n+      //\n+      J9VMThread *thread = getJ9VMThreadFromTR_VM(self()->fe());\n+      TR_ASSERT(thread, \"assertion failure\");\n+      _references.setSize(nextIndex+1);\n+      _references[nextIndex] = (uintptrj_t*)thread->javaVM->internalVMFunctions->j9jni_createLocalRef((JNIEnv*)thread, (j9object_t)objectPointer);\n+      }\n+\n    return nextIndex;\n    }\n \n \n+TR::KnownObjectTable::Index\n+J9::KnownObjectTable::getIndex(uintptrj_t objectPointer, bool isArrayWithConstantElements)\n+   {\n+   TR::KnownObjectTable::Index index = self()->getIndex(objectPointer);\n+   if (isArrayWithConstantElements)\n+      {\n+      self()->addArrayWithConstantElements(index);\n+      }\n+   return index;\n+   }\n+\n+\n+uintptrj_t\n+J9::KnownObjectTable::dereferenceObjectPointerReference(uintptrj_t *objectReferenceLocation)\n+   {\n+   uintptrj_t objectPointer = 0;\n+#if defined(JITSERVER_SUPPORT)\n+   if (self()->comp()->isOutOfProcessCompilation())\n+      {\n+      auto stream = TR::CompilationInfo::getStream();\n+      stream->write(JITServer::MessageType::KnownObjectTable_dereferenceObjectPointerReference, objectReferenceLocation);\n+      objectPointer = std::get<0>(stream->read<uintptrj_t>());\n+      }\n+   else\n+#endif /* defined(JITSERVER_SUPPORT) */\n+      {\n+      TR::VMAccessCriticalSection dereferenceObjectPointerReferenceCriticalSection(self()->comp());\n+      objectPointer = *objectReferenceLocation;\n+      }\n+   return objectPointer;\n+   }\n+\n+\n+TR::KnownObjectTable::Index\n+J9::KnownObjectTable::getIndexAt(uintptrj_t *objectReferenceLocation)\n+   {\n+   TR::KnownObjectTable::Index result = UNKNOWN;\n+#if defined(JITSERVER_SUPPORT)\n+   if (self()->comp()->isOutOfProcessCompilation())\n+      {\n+      uintptrj_t objectPointer = self()->dereferenceObjectPointerReference(objectReferenceLocation);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8cd30efd89f618b6ede6395407ddecf772e1f9f3"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTAzODY4MA==", "bodyText": "These existing methods have become virtual. Why? I thought that the extensible class framework was supposed to use static inheritance.", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r379038680", "createdAt": "2020-02-13T18:25:18Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/env/J9KnownObjectTable.hpp", "diffHunk": "@@ -59,13 +59,24 @@ class OMR_EXTENSIBLE KnownObjectTable : public OMR::KnownObjectTableConnector\n \n    KnownObjectTable(TR::Compilation *comp);\n \n+   TR::KnownObjectTable *self();\n+\n    virtual Index getEndIndex();\n    virtual Index getIndex(uintptrj_t objectPointer);\n+   Index getIndex(uintptrj_t objectPointer, bool isArrayWithConstantElements);\n    virtual uintptrj_t *getPointerLocation(Index index);\n    virtual bool isNull(Index index);\n \n    virtual void dumpTo(TR::FILE *file, TR::Compilation *comp);\n \n+   virtual Index getIndexAt(uintptrj_t *objectReferenceLocation);\n+   virtual Index getIndexAt(uintptrj_t *objectReferenceLocation, bool isArrayWithConstantElements);\n+   virtual Index getExistingIndexAt(uintptrj_t *objectReferenceLocation);\n+\n+   virtual uintptrj_t getPointer(Index index);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8cd30efd89f618b6ede6395407ddecf772e1f9f3"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTA0MjAzOQ==", "bodyText": "I guess this remains as a TODO", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r379042039", "createdAt": "2020-02-13T18:31:27Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/optimizer/J9TransformUtil.cpp", "diffHunk": "@@ -1472,6 +1472,10 @@ J9::TransformUtil::transformIndirectLoadChainAt(TR::Compilation *comp, TR::Node\n bool\n J9::TransformUtil::transformIndirectLoadChain(TR::Compilation *comp, TR::Node *node, TR::Node *baseExpression, TR::KnownObjectTable::Index baseKnownObject, TR::Node **removedNode)\n    {\n+#if defined(JITSERVER_SUPPORT)\n+   if (comp->isOutOfProcessCompilation())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8cd30efd89f618b6ede6395407ddecf772e1f9f3"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4NDg0Mjcw", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#pullrequestreview-358484270", "createdAt": "2020-02-13T19:18:49Z", "commit": {"oid": "8cd30efd89f618b6ede6395407ddecf772e1f9f3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxOToxODo1MFrOFpgYKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxOToxODo1MFrOFpgYKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTA2NjQwOQ==", "bodyText": "This piece is also problematic. It is executed with VMaccess in hand to prevent GC from moving objects. However, the server will send a few messages to the client and the client does not hold VMaccess throughout this sequence of operations. Somehow we need to create a big function out of this code and execute it atomically (that is under VMaccess) at the client.", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r379066409", "createdAt": "2020-02-13T19:18:50Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/optimizer/InterpreterEmulator.cpp", "diffHunk": "@@ -95,7 +95,7 @@ InterpreterEmulator::maintainStackForGetField()\n             {\n             TR::VMAccessCriticalSection dereferenceKnownObjectField(comp()->fej9());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8cd30efd89f618b6ede6395407ddecf772e1f9f3"}, "originalPosition": 9}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8cd30efd89f618b6ede6395407ddecf772e1f9f3", "author": {"user": {"login": "a7ehuo", "name": "Annabelle Huo"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/8cd30efd89f618b6ede6395407ddecf772e1f9f3", "committedDate": "2020-02-12T21:59:42Z", "message": "WIP - Add Known Object Table support at the server\n\n[skip ci]\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>"}, "afterCommit": {"oid": "049817c3175f0c234c9983c789bd07eb9b8fd297", "author": {"user": {"login": "a7ehuo", "name": "Annabelle Huo"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/049817c3175f0c234c9983c789bd07eb9b8fd297", "committedDate": "2020-02-14T16:40:04Z", "message": "WIP - Add Known Object Table support at the server\n\n[skip ci]\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "049817c3175f0c234c9983c789bd07eb9b8fd297", "author": {"user": {"login": "a7ehuo", "name": "Annabelle Huo"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/049817c3175f0c234c9983c789bd07eb9b8fd297", "committedDate": "2020-02-14T16:40:04Z", "message": "WIP - Add Known Object Table support at the server\n\n[skip ci]\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>"}, "afterCommit": {"oid": "dd19c43421254186ba3b321a2a7f7ba8acf1c952", "author": {"user": {"login": "a7ehuo", "name": "Annabelle Huo"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/dd19c43421254186ba3b321a2a7f7ba8acf1c952", "committedDate": "2020-02-14T20:56:34Z", "message": "WIP - Add Known Object Table support at the server\n\n[skip ci]\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "dd19c43421254186ba3b321a2a7f7ba8acf1c952", "author": {"user": {"login": "a7ehuo", "name": "Annabelle Huo"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/dd19c43421254186ba3b321a2a7f7ba8acf1c952", "committedDate": "2020-02-14T20:56:34Z", "message": "WIP - Add Known Object Table support at the server\n\n[skip ci]\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>"}, "afterCommit": {"oid": "a1be388a70b214617373e45dcbbe6123432754b2", "author": {"user": {"login": "a7ehuo", "name": "Annabelle Huo"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/a1be388a70b214617373e45dcbbe6123432754b2", "committedDate": "2020-02-14T21:32:37Z", "message": "WIP - Add Known Object Table support at the server\n\n[skip ci]\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a1be388a70b214617373e45dcbbe6123432754b2", "author": {"user": {"login": "a7ehuo", "name": "Annabelle Huo"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/a1be388a70b214617373e45dcbbe6123432754b2", "committedDate": "2020-02-14T21:32:37Z", "message": "WIP - Add Known Object Table support at the server\n\n[skip ci]\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>"}, "afterCommit": {"oid": "5ff8ab957b376d8f439979bb7fd2011b87eec225", "author": {"user": {"login": "a7ehuo", "name": "Annabelle Huo"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/5ff8ab957b376d8f439979bb7fd2011b87eec225", "committedDate": "2020-02-14T21:56:16Z", "message": "WIP - Add Known Object Table support at the server\n\n[skip ci]\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5ff8ab957b376d8f439979bb7fd2011b87eec225", "author": {"user": {"login": "a7ehuo", "name": "Annabelle Huo"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/5ff8ab957b376d8f439979bb7fd2011b87eec225", "committedDate": "2020-02-14T21:56:16Z", "message": "WIP - Add Known Object Table support at the server\n\n[skip ci]\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>"}, "afterCommit": {"oid": "e83b6e5c3adc40fb285ab49d5122f3fbfd2c0ed9", "author": {"user": {"login": "a7ehuo", "name": "Annabelle Huo"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/e83b6e5c3adc40fb285ab49d5122f3fbfd2c0ed9", "committedDate": "2020-02-18T21:22:44Z", "message": "WIP - Add Known Object Table support at the server\n\n[skip ci]\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e83b6e5c3adc40fb285ab49d5122f3fbfd2c0ed9", "author": {"user": {"login": "a7ehuo", "name": "Annabelle Huo"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/e83b6e5c3adc40fb285ab49d5122f3fbfd2c0ed9", "committedDate": "2020-02-18T21:22:44Z", "message": "WIP - Add Known Object Table support at the server\n\n[skip ci]\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>"}, "afterCommit": {"oid": "33005e156ec75a57a02df914d2e11da404da7342", "author": {"user": {"login": "a7ehuo", "name": "Annabelle Huo"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/33005e156ec75a57a02df914d2e11da404da7342", "committedDate": "2020-02-18T23:08:12Z", "message": "WIP - Add Known Object Table support at the server\n\n[skip ci]\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "33005e156ec75a57a02df914d2e11da404da7342", "author": {"user": {"login": "a7ehuo", "name": "Annabelle Huo"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/33005e156ec75a57a02df914d2e11da404da7342", "committedDate": "2020-02-18T23:08:12Z", "message": "WIP - Add Known Object Table support at the server\n\n[skip ci]\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>"}, "afterCommit": {"oid": "407335283f53c05ee9783055e465fd67eed973ba", "author": {"user": {"login": "a7ehuo", "name": "Annabelle Huo"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/407335283f53c05ee9783055e465fd67eed973ba", "committedDate": "2020-02-19T20:25:08Z", "message": "WIP - Add Known Object Table support at the server\n\n[skip ci]\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "407335283f53c05ee9783055e465fd67eed973ba", "author": {"user": {"login": "a7ehuo", "name": "Annabelle Huo"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/407335283f53c05ee9783055e465fd67eed973ba", "committedDate": "2020-02-19T20:25:08Z", "message": "WIP - Add Known Object Table support at the server\n\n[skip ci]\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>"}, "afterCommit": {"oid": "9f460f2b015e6f7af5f3f616a55c9d4570c6b232", "author": {"user": {"login": "a7ehuo", "name": "Annabelle Huo"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/9f460f2b015e6f7af5f3f616a55c9d4570c6b232", "committedDate": "2020-02-19T22:01:22Z", "message": "WIP - Add Known Object Table support at the server\n\n[skip ci]\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9f460f2b015e6f7af5f3f616a55c9d4570c6b232", "author": {"user": {"login": "a7ehuo", "name": "Annabelle Huo"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/9f460f2b015e6f7af5f3f616a55c9d4570c6b232", "committedDate": "2020-02-19T22:01:22Z", "message": "WIP - Add Known Object Table support at the server\n\n[skip ci]\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>"}, "afterCommit": {"oid": "9331481c084fd361e21efd5df9d70fef6ea2e7fc", "author": {"user": {"login": "a7ehuo", "name": "Annabelle Huo"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/9331481c084fd361e21efd5df9d70fef6ea2e7fc", "committedDate": "2020-02-19T22:14:59Z", "message": "WIP - Add Known Object Table support at the server\n\n[skip ci]\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYxOTk5NDM3", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#pullrequestreview-361999437", "createdAt": "2020-02-20T15:31:33Z", "commit": {"oid": "9331481c084fd361e21efd5df9d70fef6ea2e7fc"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxNTozMTozM1rOFsYBaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxNTozMTozM1rOFsYBaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjA3NTI0MQ==", "bodyText": "Another pair of curly brackets is not needed.", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r382075241", "createdAt": "2020-02-20T15:31:33Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/optimizer/J9Inliner.cpp", "diffHunk": "@@ -685,26 +685,51 @@ bool TR_J9MutableCallSite::findCallSiteTarget (TR_CallStack *callStack, TR_Inlin\n          heuristicTrace(inliner->tracer(),\"  Virtual guard NOPing disabled\");\n          return false;\n          }\n+\n       TR_VirtualGuardSelection *vgs = new (comp()->trHeapMemory()) TR_VirtualGuardSelection(TR_MutableCallSiteTargetGuard, TR_DummyTest);\n       vgs->_mutableCallSiteObject = _mcsReferenceLocation;\n       TR::KnownObjectTable *knot = comp()->getOrCreateKnownObjectTable();\n-\n+#if defined(JITSERVER_SUPPORT)\n+      if (comp()->isOutOfProcessCompilation())\n          {\n-         TR::VMAccessCriticalSection mutableCallSiteEpoch(comp()->fej9());\n          vgs->_mutableCallSiteEpoch = TR::KnownObjectTable::UNKNOWN;\n-         uintptrj_t mcsObject = comp()->fej9()->getStaticReferenceFieldAtAddress((uintptrj_t)_mcsReferenceLocation);\n-         if (mcsObject)\n+         auto stream = TR::CompilationInfo::getStream();\n+         stream->write(JITServer::MessageType::KnownObjectTable_mutableCallSiteEpoch, _mcsReferenceLocation);\n+\n+         auto recv = stream->read<TR::KnownObjectTable::Index, uintptrj_t*>();\n+         TR::KnownObjectTable::Index knotIndex = std::get<0>(recv);\n+         uintptrj_t *objectPointerReference = std::get<1>(recv);\n+\n+         if (knotIndex != TR::KnownObjectTable::UNKNOWN)\n             {\n-            TR_J9VMBase *fej9 = (TR_J9VMBase *)(comp()->fej9());\n-            uintptrj_t currentEpoch = fej9->getVolatileReferenceField(mcsObject, \"epoch\", \"Ljava/lang/invoke/MethodHandle;\");\n-            if (knot && currentEpoch)\n-               vgs->_mutableCallSiteEpoch = knot->getIndex(currentEpoch);\n+            vgs->_mutableCallSiteEpoch = knotIndex;\n+            knot->addIndexAndObjectPointerReferenceAtServer(knotIndex, objectPointerReference);\n             }\n          else\n             {\n             vgs->_mutableCallSiteObject = NULL;\n             }\n          }\n+      else\n+#endif /* defined(JITSERVER_SUPPORT) */\n+         {\n+            {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9331481c084fd361e21efd5df9d70fef6ea2e7fc"}, "originalPosition": 47}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9331481c084fd361e21efd5df9d70fef6ea2e7fc", "author": {"user": {"login": "a7ehuo", "name": "Annabelle Huo"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/9331481c084fd361e21efd5df9d70fef6ea2e7fc", "committedDate": "2020-02-19T22:14:59Z", "message": "WIP - Add Known Object Table support at the server\n\n[skip ci]\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>"}, "afterCommit": {"oid": "a369de4ae9b29270b7661e496f01d8b974866069", "author": {"user": {"login": "a7ehuo", "name": "Annabelle Huo"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/a369de4ae9b29270b7661e496f01d8b974866069", "committedDate": "2020-02-20T23:14:27Z", "message": "WIP - Add Known Object Table support at the server\n\n[skip ci]\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a369de4ae9b29270b7661e496f01d8b974866069", "author": {"user": {"login": "a7ehuo", "name": "Annabelle Huo"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/a369de4ae9b29270b7661e496f01d8b974866069", "committedDate": "2020-02-20T23:14:27Z", "message": "WIP - Add Known Object Table support at the server\n\n[skip ci]\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>"}, "afterCommit": {"oid": "c77c4f0dfa41ed04a138c41945f2cce63e4fbd8d", "author": {"user": {"login": "a7ehuo", "name": "Annabelle Huo"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/c77c4f0dfa41ed04a138c41945f2cce63e4fbd8d", "committedDate": "2020-02-20T23:24:04Z", "message": "WIP - Add Known Object Table support at the server\n\n[skip ci]\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c77c4f0dfa41ed04a138c41945f2cce63e4fbd8d", "author": {"user": {"login": "a7ehuo", "name": "Annabelle Huo"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/c77c4f0dfa41ed04a138c41945f2cce63e4fbd8d", "committedDate": "2020-02-20T23:24:04Z", "message": "WIP - Add Known Object Table support at the server\n\n[skip ci]\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>"}, "afterCommit": {"oid": "06b1ca76840273dc85c634fe8ba00602d6340f88", "author": {"user": {"login": "a7ehuo", "name": "Annabelle Huo"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/06b1ca76840273dc85c634fe8ba00602d6340f88", "committedDate": "2020-02-21T15:35:39Z", "message": "WIP - Add Known Object Table support at the server\n\n[skip ci]\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "06b1ca76840273dc85c634fe8ba00602d6340f88", "author": {"user": {"login": "a7ehuo", "name": "Annabelle Huo"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/06b1ca76840273dc85c634fe8ba00602d6340f88", "committedDate": "2020-02-21T15:35:39Z", "message": "WIP - Add Known Object Table support at the server\n\n[skip ci]\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>"}, "afterCommit": {"oid": "9d7c492d2bebbdad012c99d75cc6ba69f009dd08", "author": {"user": {"login": "a7ehuo", "name": "Annabelle Huo"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/9d7c492d2bebbdad012c99d75cc6ba69f009dd08", "committedDate": "2020-02-21T22:04:31Z", "message": "WIP - Add Known Object Table support at the server\n\n[skip ci]\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9d7c492d2bebbdad012c99d75cc6ba69f009dd08", "author": {"user": {"login": "a7ehuo", "name": "Annabelle Huo"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/9d7c492d2bebbdad012c99d75cc6ba69f009dd08", "committedDate": "2020-02-21T22:04:31Z", "message": "WIP - Add Known Object Table support at the server\n\n[skip ci]\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>"}, "afterCommit": {"oid": "90da570d6f0e9914ca1284ac2b8225c5e50317c8", "author": {"user": {"login": "a7ehuo", "name": "Annabelle Huo"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/90da570d6f0e9914ca1284ac2b8225c5e50317c8", "committedDate": "2020-02-24T19:51:18Z", "message": "Support Known Object Table at the server\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "90da570d6f0e9914ca1284ac2b8225c5e50317c8", "author": {"user": {"login": "a7ehuo", "name": "Annabelle Huo"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/90da570d6f0e9914ca1284ac2b8225c5e50317c8", "committedDate": "2020-02-24T19:51:18Z", "message": "Support Known Object Table at the server\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>"}, "afterCommit": {"oid": "a3e560cfdfcfe478b7aad3d56f3c8fe31c492c2f", "author": {"user": {"login": "a7ehuo", "name": "Annabelle Huo"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/a3e560cfdfcfe478b7aad3d56f3c8fe31c492c2f", "committedDate": "2020-02-24T22:31:31Z", "message": "Support Known Object Table at the server\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a3e560cfdfcfe478b7aad3d56f3c8fe31c492c2f", "author": {"user": {"login": "a7ehuo", "name": "Annabelle Huo"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/a3e560cfdfcfe478b7aad3d56f3c8fe31c492c2f", "committedDate": "2020-02-24T22:31:31Z", "message": "Support Known Object Table at the server\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>"}, "afterCommit": {"oid": "bc110d0e8fe05ae13d4feedfb6b77c216c59d41d", "author": {"user": {"login": "a7ehuo", "name": "Annabelle Huo"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/bc110d0e8fe05ae13d4feedfb6b77c216c59d41d", "committedDate": "2020-02-25T16:02:29Z", "message": "Support Known Object Table at the server\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0MzI2OTI3", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#pullrequestreview-364326927", "createdAt": "2020-02-25T17:43:53Z", "commit": {"oid": "9331481c084fd361e21efd5df9d70fef6ea2e7fc"}, "state": "COMMENTED", "comments": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxNzo0NDo1MlrOFuPSHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxOToxMDowNVrOFu4beA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDAyOTIxMg==", "bodyText": "Maybe an assert would be better here.", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r384029212", "createdAt": "2020-02-25T17:44:52Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/env/CHTable.cpp", "diffHunk": "@@ -556,7 +556,15 @@ TR_CHTable::commitVirtualGuard(TR_VirtualGuard *info, List<TR_VirtualGuardSite>\n    else if (info->getKind() == TR_MutableCallSiteTargetGuard)\n       {\n       static char *dontInvalidateMCSTargetGuards = feGetEnv(\"TR_dontInvalidateMCSTargetGuards\");\n-      if (!dontInvalidateMCSTargetGuards)\n+      if (!dontInvalidateMCSTargetGuards\n+#if defined(JITSERVER_SUPPORT)\n+         // JITServer KOT: At the moment this method is called only by TR_CHTable::commit().\n+         // TR_CHTable::commit() already checks comp->isOutOfProcessCompilation().\n+         // Adding the following check as a precaution in case commitVirtualGuard() is called", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc110d0e8fe05ae13d4feedfb6b77c216c59d41d"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDAzMzAxNg==", "bodyText": "Change \"it might not cause any issue\" --> \"and therefore it cannot cause any issues\"", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r384033016", "createdAt": "2020-02-25T18:03:56Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/env/JITServerCHTable.cpp", "diffHunk": "@@ -388,6 +388,12 @@ JITClientCommitVirtualGuard(const VirtualGuardInfoForCHTable *info, std::vector<\n \n             {\n             TR_J9VMBase *fej9 = (TR_J9VMBase *)(comp->fe());\n+            // JITServer KOT:\n+            // This method is called by JITClientCHTableCommit() at the client.\n+            // Although accessing VM is not an issue, getIndex() could update the KOT\n+            // at the client directly and the KOT at the server could be out of sync.\n+            // However, JITClientCHTableCommit() is called at the end of compilation,\n+            // it might not cause any issue.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc110d0e8fe05ae13d4feedfb6b77c216c59d41d"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA3MjY0Mw==", "bodyText": "Does it make sense to have this code if we are going to crash the JVM?", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r384072643", "createdAt": "2020-02-25T19:20:13Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/env/J9KnownObjectTable.cpp", "diffHunk": "@@ -86,6 +251,42 @@ J9::KnownObjectTable::getPointerLocation(Index index)\n    }\n \n \n+#if defined(JITSERVER_SUPPORT)\n+void\n+J9::KnownObjectTable::updateKnownObjectTableAtServer(Index index, uintptrj_t *objectReferenceLocation)\n+   {\n+   TR_ASSERT_FATAL(self()->comp()->isOutOfProcessCompilation(), \"updateKnownObjectTableAtServer should only be called at the server\");\n+\n+   if (index == TR::KnownObjectTable::UNKNOWN)\n+      return;\n+\n+   uint32_t nextIndex = self()->getEndIndex();\n+\n+   if (index == nextIndex)\n+      {\n+      _references.setSize(nextIndex+1);\n+      _references[nextIndex] = objectReferenceLocation;\n+      }\n+   else if (index < nextIndex)\n+      {\n+      TR_ASSERT((objectReferenceLocation == _references[index]), \"_references[%d]=%p is not the same as the client KOT[%d]=%p. _references.size()=%u\",\n+                  index, _references[index], index, objectReferenceLocation, nextIndex);\n+      _references[index] = objectReferenceLocation;\n+      }\n+   else\n+      {\n+      _references.setSize(index+1);\n+      _references[index] = objectReferenceLocation;\n+\n+      for (uint32_t i = nextIndex; i < index; ++i)\n+         _references[i] = NULL;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc110d0e8fe05ae13d4feedfb6b77c216c59d41d"}, "originalPosition": 262}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA4MjA5Nw==", "bodyText": "I see that dereferenceObjectPointerReference is only used in the JITServer specific part of getPointer. If that's the case, maybe we should make this JITServer specific.", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r384082097", "createdAt": "2020-02-25T19:37:35Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/env/J9KnownObjectTable.cpp", "diffHunk": "@@ -56,28 +65,184 @@ J9::KnownObjectTable::isNull(Index index)\n TR::KnownObjectTable::Index\n J9::KnownObjectTable::getIndex(uintptrj_t objectPointer)\n    {\n-   TR_J9VMBase *fej9 = (TR_J9VMBase *)(self()->fe());\n-   TR_ASSERT(fej9->haveAccess(), \"Must haveAccess in J9::KnownObjectTable::getIndex\");\n    if (objectPointer == 0)\n       return 0; // Special Index value for NULL\n \n-   // Search for existing matching entry\n-   //\n    uint32_t nextIndex = self()->getEndIndex();\n-   for (uint32_t i = 1; i < nextIndex; i++)\n-      if (*_references.element(i) == objectPointer)\n-         return i;\n-\n-   // No luck -- allocate a new one\n-   //\n-   J9VMThread *thread = getJ9VMThreadFromTR_VM(self()->fe());\n-   TR_ASSERT(thread, \"assertion failure\");\n-   _references.setSize(nextIndex+1);\n-   _references[nextIndex] = (uintptrj_t*)thread->javaVM->internalVMFunctions->j9jni_createLocalRef((JNIEnv*)thread, (j9object_t)objectPointer);\n+#if defined(JITSERVER_SUPPORT)\n+   if (self()->comp()->isOutOfProcessCompilation())\n+      {\n+      auto stream = TR::CompilationInfo::getStream();\n+      stream->write(JITServer::MessageType::KnownObjectTable_getIndex, objectPointer);\n+      auto recv = stream->read<TR::KnownObjectTable::Index, uintptrj_t *>();\n+\n+      TR::KnownObjectTable::Index index = std::get<0>(recv);\n+      uintptrj_t *objectReferenceLocation = std::get<1>(recv);\n+      TR_ASSERT_FATAL(index <= nextIndex, \"The KOT index %d at the client is greater than the KOT index %d at the server\", index, nextIndex);\n+\n+      if (index < nextIndex)\n+         {\n+         return index;\n+         }\n+      else\n+         {\n+         updateKnownObjectTableAtServer(index, objectReferenceLocation);\n+         }\n+      }\n+   else\n+#endif /* defined(JITSERVER_SUPPORT) */\n+      {\n+      TR_J9VMBase *fej9 = (TR_J9VMBase *)(self()->fe());\n+      TR_ASSERT(fej9->haveAccess(), \"Must haveAccess in J9::KnownObjectTable::getIndex\");\n+\n+      // Search for existing matching entry\n+      //\n+      for (uint32_t i = 1; i < nextIndex; i++)\n+         if (*_references.element(i) == objectPointer)\n+            return i;\n+\n+      // No luck -- allocate a new one\n+      //\n+      J9VMThread *thread = getJ9VMThreadFromTR_VM(self()->fe());\n+      TR_ASSERT(thread, \"assertion failure\");\n+      _references.setSize(nextIndex+1);\n+      _references[nextIndex] = (uintptrj_t*)thread->javaVM->internalVMFunctions->j9jni_createLocalRef((JNIEnv*)thread, (j9object_t)objectPointer);\n+      }\n+\n    return nextIndex;\n    }\n \n \n+TR::KnownObjectTable::Index\n+J9::KnownObjectTable::getIndex(uintptrj_t objectPointer, bool isArrayWithConstantElements)\n+   {\n+   TR::KnownObjectTable::Index index = self()->getIndex(objectPointer);\n+   if (isArrayWithConstantElements)\n+      {\n+      self()->addArrayWithConstantElements(index);\n+      }\n+   return index;\n+   }\n+\n+\n+uintptrj_t\n+J9::KnownObjectTable::dereferenceObjectPointerReference(uintptrj_t *objectReferenceLocation)\n+   {\n+   uintptrj_t objectPointer = 0;\n+#if defined(JITSERVER_SUPPORT)\n+   if (self()->comp()->isOutOfProcessCompilation())\n+      {\n+      auto stream = TR::CompilationInfo::getStream();\n+      stream->write(JITServer::MessageType::KnownObjectTable_dereferenceObjectPointerReference, objectReferenceLocation);\n+      objectPointer = std::get<0>(stream->read<uintptrj_t>());\n+      }\n+   else\n+#endif /* defined(JITSERVER_SUPPORT) */\n+      {\n+      TR::VMAccessCriticalSection dereferenceObjectPointerReferenceCriticalSection(self()->comp());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc110d0e8fe05ae13d4feedfb6b77c216c59d41d"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA5MzcwNw==", "bodyText": "yes, it should break", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r384093707", "createdAt": "2020-02-25T19:58:53Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/env/J9KnownObjectTable.cpp", "diffHunk": "@@ -56,28 +65,184 @@ J9::KnownObjectTable::isNull(Index index)\n TR::KnownObjectTable::Index\n J9::KnownObjectTable::getIndex(uintptrj_t objectPointer)\n    {\n-   TR_J9VMBase *fej9 = (TR_J9VMBase *)(self()->fe());\n-   TR_ASSERT(fej9->haveAccess(), \"Must haveAccess in J9::KnownObjectTable::getIndex\");\n    if (objectPointer == 0)\n       return 0; // Special Index value for NULL\n \n-   // Search for existing matching entry\n-   //\n    uint32_t nextIndex = self()->getEndIndex();\n-   for (uint32_t i = 1; i < nextIndex; i++)\n-      if (*_references.element(i) == objectPointer)\n-         return i;\n-\n-   // No luck -- allocate a new one\n-   //\n-   J9VMThread *thread = getJ9VMThreadFromTR_VM(self()->fe());\n-   TR_ASSERT(thread, \"assertion failure\");\n-   _references.setSize(nextIndex+1);\n-   _references[nextIndex] = (uintptrj_t*)thread->javaVM->internalVMFunctions->j9jni_createLocalRef((JNIEnv*)thread, (j9object_t)objectPointer);\n+#if defined(JITSERVER_SUPPORT)\n+   if (self()->comp()->isOutOfProcessCompilation())\n+      {\n+      auto stream = TR::CompilationInfo::getStream();\n+      stream->write(JITServer::MessageType::KnownObjectTable_getIndex, objectPointer);\n+      auto recv = stream->read<TR::KnownObjectTable::Index, uintptrj_t *>();\n+\n+      TR::KnownObjectTable::Index index = std::get<0>(recv);\n+      uintptrj_t *objectReferenceLocation = std::get<1>(recv);\n+      TR_ASSERT_FATAL(index <= nextIndex, \"The KOT index %d at the client is greater than the KOT index %d at the server\", index, nextIndex);\n+\n+      if (index < nextIndex)\n+         {\n+         return index;\n+         }\n+      else\n+         {\n+         updateKnownObjectTableAtServer(index, objectReferenceLocation);\n+         }\n+      }\n+   else\n+#endif /* defined(JITSERVER_SUPPORT) */\n+      {\n+      TR_J9VMBase *fej9 = (TR_J9VMBase *)(self()->fe());\n+      TR_ASSERT(fej9->haveAccess(), \"Must haveAccess in J9::KnownObjectTable::getIndex\");\n+\n+      // Search for existing matching entry\n+      //\n+      for (uint32_t i = 1; i < nextIndex; i++)\n+         if (*_references.element(i) == objectPointer)\n+            return i;\n+\n+      // No luck -- allocate a new one\n+      //\n+      J9VMThread *thread = getJ9VMThreadFromTR_VM(self()->fe());\n+      TR_ASSERT(thread, \"assertion failure\");\n+      _references.setSize(nextIndex+1);\n+      _references[nextIndex] = (uintptrj_t*)thread->javaVM->internalVMFunctions->j9jni_createLocalRef((JNIEnv*)thread, (j9object_t)objectPointer);\n+      }\n+\n    return nextIndex;\n    }\n \n \n+TR::KnownObjectTable::Index\n+J9::KnownObjectTable::getIndex(uintptrj_t objectPointer, bool isArrayWithConstantElements)\n+   {\n+   TR::KnownObjectTable::Index index = self()->getIndex(objectPointer);\n+   if (isArrayWithConstantElements)\n+      {\n+      self()->addArrayWithConstantElements(index);\n+      }\n+   return index;\n+   }\n+\n+\n+uintptrj_t\n+J9::KnownObjectTable::dereferenceObjectPointerReference(uintptrj_t *objectReferenceLocation)\n+   {\n+   uintptrj_t objectPointer = 0;\n+#if defined(JITSERVER_SUPPORT)\n+   if (self()->comp()->isOutOfProcessCompilation())\n+      {\n+      auto stream = TR::CompilationInfo::getStream();\n+      stream->write(JITServer::MessageType::KnownObjectTable_dereferenceObjectPointerReference, objectReferenceLocation);\n+      objectPointer = std::get<0>(stream->read<uintptrj_t>());\n+      }\n+   else\n+#endif /* defined(JITSERVER_SUPPORT) */\n+      {\n+      TR::VMAccessCriticalSection dereferenceObjectPointerReferenceCriticalSection(self()->comp());\n+      objectPointer = *objectReferenceLocation;\n+      }\n+   return objectPointer;\n+   }\n+\n+\n+TR::KnownObjectTable::Index\n+J9::KnownObjectTable::getIndexAt(uintptrj_t *objectReferenceLocation)\n+   {\n+   TR::KnownObjectTable::Index result = UNKNOWN;\n+#if defined(JITSERVER_SUPPORT)\n+   if (self()->comp()->isOutOfProcessCompilation())\n+      {\n+      auto stream = TR::CompilationInfo::getStream();\n+      stream->write(JITServer::MessageType::KnownObjectTable_getIndexAt, objectReferenceLocation);\n+      auto recv = stream->read<TR::KnownObjectTable::Index>();\n+      result = std::get<0>(stream->read<TR::KnownObjectTable::Index>());\n+\n+      updateKnownObjectTableAtServer(result, objectReferenceLocation);\n+      }\n+   else\n+#endif /* defined(JITSERVER_SUPPORT) */\n+      {\n+      TR::VMAccessCriticalSection getIndexAtCriticalSection(self()->comp());\n+      uintptrj_t objectPointer = *objectReferenceLocation; // Note: object references held as uintptrj_t must never be compressed refs\n+      result = self()->getIndex(objectPointer);\n+      }\n+   return result;\n+   }\n+\n+TR::KnownObjectTable::Index\n+J9::KnownObjectTable::getIndexAt(uintptrj_t *objectReferenceLocation, bool isArrayWithConstantElements)\n+   {\n+   Index result = self()->getIndexAt(objectReferenceLocation);\n+   if (isArrayWithConstantElements)\n+      self()->addArrayWithConstantElements(result);\n+   return result;\n+   }\n+\n+\n+TR::KnownObjectTable::Index\n+J9::KnownObjectTable::getExistingIndexAt(uintptrj_t *objectReferenceLocation)\n+   {\n+   TR::KnownObjectTable::Index result = UNKNOWN;\n+#if defined(JITSERVER_SUPPORT)\n+   if (self()->comp()->isOutOfProcessCompilation())\n+      {\n+      auto stream = TR::CompilationInfo::getStream();\n+      stream->write(JITServer::MessageType::KnownObjectTable_getExistingIndexAt, objectReferenceLocation);\n+      result = std::get<0>(stream->read<TR::KnownObjectTable::Index>());\n+      }\n+   else\n+#endif /* defined(JITSERVER_SUPPORT) */\n+      {\n+      TR::VMAccessCriticalSection getExistingIndexAtCriticalSection(self()->comp());\n+\n+      uintptrj_t objectPointer = *objectReferenceLocation;\n+      for (Index i = 0; i < self()->getEndIndex() && (result == UNKNOWN); i++)\n+         {\n+         if (self()->getPointer(i) == objectPointer)\n+            result = i; //TODO: Shouldn't it break here?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc110d0e8fe05ae13d4feedfb6b77c216c59d41d"}, "originalPosition": 183}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA5NTYwOA==", "bodyText": "why does this need to be reimplemented? The OMR definition is exactly the same.", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r384095608", "createdAt": "2020-02-25T20:02:42Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/env/J9KnownObjectTable.cpp", "diffHunk": "@@ -56,28 +65,184 @@ J9::KnownObjectTable::isNull(Index index)\n TR::KnownObjectTable::Index\n J9::KnownObjectTable::getIndex(uintptrj_t objectPointer)\n    {\n-   TR_J9VMBase *fej9 = (TR_J9VMBase *)(self()->fe());\n-   TR_ASSERT(fej9->haveAccess(), \"Must haveAccess in J9::KnownObjectTable::getIndex\");\n    if (objectPointer == 0)\n       return 0; // Special Index value for NULL\n \n-   // Search for existing matching entry\n-   //\n    uint32_t nextIndex = self()->getEndIndex();\n-   for (uint32_t i = 1; i < nextIndex; i++)\n-      if (*_references.element(i) == objectPointer)\n-         return i;\n-\n-   // No luck -- allocate a new one\n-   //\n-   J9VMThread *thread = getJ9VMThreadFromTR_VM(self()->fe());\n-   TR_ASSERT(thread, \"assertion failure\");\n-   _references.setSize(nextIndex+1);\n-   _references[nextIndex] = (uintptrj_t*)thread->javaVM->internalVMFunctions->j9jni_createLocalRef((JNIEnv*)thread, (j9object_t)objectPointer);\n+#if defined(JITSERVER_SUPPORT)\n+   if (self()->comp()->isOutOfProcessCompilation())\n+      {\n+      auto stream = TR::CompilationInfo::getStream();\n+      stream->write(JITServer::MessageType::KnownObjectTable_getIndex, objectPointer);\n+      auto recv = stream->read<TR::KnownObjectTable::Index, uintptrj_t *>();\n+\n+      TR::KnownObjectTable::Index index = std::get<0>(recv);\n+      uintptrj_t *objectReferenceLocation = std::get<1>(recv);\n+      TR_ASSERT_FATAL(index <= nextIndex, \"The KOT index %d at the client is greater than the KOT index %d at the server\", index, nextIndex);\n+\n+      if (index < nextIndex)\n+         {\n+         return index;\n+         }\n+      else\n+         {\n+         updateKnownObjectTableAtServer(index, objectReferenceLocation);\n+         }\n+      }\n+   else\n+#endif /* defined(JITSERVER_SUPPORT) */\n+      {\n+      TR_J9VMBase *fej9 = (TR_J9VMBase *)(self()->fe());\n+      TR_ASSERT(fej9->haveAccess(), \"Must haveAccess in J9::KnownObjectTable::getIndex\");\n+\n+      // Search for existing matching entry\n+      //\n+      for (uint32_t i = 1; i < nextIndex; i++)\n+         if (*_references.element(i) == objectPointer)\n+            return i;\n+\n+      // No luck -- allocate a new one\n+      //\n+      J9VMThread *thread = getJ9VMThreadFromTR_VM(self()->fe());\n+      TR_ASSERT(thread, \"assertion failure\");\n+      _references.setSize(nextIndex+1);\n+      _references[nextIndex] = (uintptrj_t*)thread->javaVM->internalVMFunctions->j9jni_createLocalRef((JNIEnv*)thread, (j9object_t)objectPointer);\n+      }\n+\n    return nextIndex;\n    }\n \n \n+TR::KnownObjectTable::Index\n+J9::KnownObjectTable::getIndex(uintptrj_t objectPointer, bool isArrayWithConstantElements)\n+   {\n+   TR::KnownObjectTable::Index index = self()->getIndex(objectPointer);\n+   if (isArrayWithConstantElements)\n+      {\n+      self()->addArrayWithConstantElements(index);\n+      }\n+   return index;\n+   }\n+\n+\n+uintptrj_t\n+J9::KnownObjectTable::dereferenceObjectPointerReference(uintptrj_t *objectReferenceLocation)\n+   {\n+   uintptrj_t objectPointer = 0;\n+#if defined(JITSERVER_SUPPORT)\n+   if (self()->comp()->isOutOfProcessCompilation())\n+      {\n+      auto stream = TR::CompilationInfo::getStream();\n+      stream->write(JITServer::MessageType::KnownObjectTable_dereferenceObjectPointerReference, objectReferenceLocation);\n+      objectPointer = std::get<0>(stream->read<uintptrj_t>());\n+      }\n+   else\n+#endif /* defined(JITSERVER_SUPPORT) */\n+      {\n+      TR::VMAccessCriticalSection dereferenceObjectPointerReferenceCriticalSection(self()->comp());\n+      objectPointer = *objectReferenceLocation;\n+      }\n+   return objectPointer;\n+   }\n+\n+\n+TR::KnownObjectTable::Index\n+J9::KnownObjectTable::getIndexAt(uintptrj_t *objectReferenceLocation)\n+   {\n+   TR::KnownObjectTable::Index result = UNKNOWN;\n+#if defined(JITSERVER_SUPPORT)\n+   if (self()->comp()->isOutOfProcessCompilation())\n+      {\n+      auto stream = TR::CompilationInfo::getStream();\n+      stream->write(JITServer::MessageType::KnownObjectTable_getIndexAt, objectReferenceLocation);\n+      auto recv = stream->read<TR::KnownObjectTable::Index>();\n+      result = std::get<0>(stream->read<TR::KnownObjectTable::Index>());\n+\n+      updateKnownObjectTableAtServer(result, objectReferenceLocation);\n+      }\n+   else\n+#endif /* defined(JITSERVER_SUPPORT) */\n+      {\n+      TR::VMAccessCriticalSection getIndexAtCriticalSection(self()->comp());\n+      uintptrj_t objectPointer = *objectReferenceLocation; // Note: object references held as uintptrj_t must never be compressed refs\n+      result = self()->getIndex(objectPointer);\n+      }\n+   return result;\n+   }\n+\n+TR::KnownObjectTable::Index\n+J9::KnownObjectTable::getIndexAt(uintptrj_t *objectReferenceLocation, bool isArrayWithConstantElements)\n+   {\n+   Index result = self()->getIndexAt(objectReferenceLocation);\n+   if (isArrayWithConstantElements)\n+      self()->addArrayWithConstantElements(result);\n+   return result;\n+   }\n+\n+\n+TR::KnownObjectTable::Index\n+J9::KnownObjectTable::getExistingIndexAt(uintptrj_t *objectReferenceLocation)\n+   {\n+   TR::KnownObjectTable::Index result = UNKNOWN;\n+#if defined(JITSERVER_SUPPORT)\n+   if (self()->comp()->isOutOfProcessCompilation())\n+      {\n+      auto stream = TR::CompilationInfo::getStream();\n+      stream->write(JITServer::MessageType::KnownObjectTable_getExistingIndexAt, objectReferenceLocation);\n+      result = std::get<0>(stream->read<TR::KnownObjectTable::Index>());\n+      }\n+   else\n+#endif /* defined(JITSERVER_SUPPORT) */\n+      {\n+      TR::VMAccessCriticalSection getExistingIndexAtCriticalSection(self()->comp());\n+\n+      uintptrj_t objectPointer = *objectReferenceLocation;\n+      for (Index i = 0; i < self()->getEndIndex() && (result == UNKNOWN); i++)\n+         {\n+         if (self()->getPointer(i) == objectPointer)\n+            result = i; //TODO: Shouldn't it break here?\n+         }\n+      }\n+   return result;\n+   }\n+\n+\n+bool\n+J9::KnownObjectTable::isArrayWithConstantElements(Index index)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc110d0e8fe05ae13d4feedfb6b77c216c59d41d"}, "originalPosition": 191}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDExODc0Ng==", "bodyText": "filterIndexList[i] = knot->getIndex(filtersList[i]);", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r384118746", "createdAt": "2020-02-25T20:51:31Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/control/JITClientCompilationThread.cpp", "diffHunk": "@@ -2344,19 +2347,29 @@ handleServerMessage(JITServer::ClientStream *client, TR_J9VM *fe, JITServer::Mes\n          break;\n       case MessageType::runFEMacro_invokeFilterArgumentsHandle:\n          {\n-         auto recv = client->getRecvData<uintptrj_t*>();\n+         auto recv = client->getRecvData<uintptrj_t*, bool>();\n          TR::VMAccessCriticalSection invokeFilterArgumentsHandle(fe);\n          uintptrj_t methodHandle = *std::get<0>(recv);\n-         int32_t startPos = (int32_t)fe->getInt32Field(methodHandle, \"startPos\");\n+         bool knotEnabled = std::get<1>(recv);\n \n          uintptrj_t filters = fe->getReferenceField(methodHandle, \"filters\", \"[Ljava/lang/invoke/MethodHandle;\");\n          int32_t numFilters = fe->getArrayLengthInElements(filters);\n          std::vector<uintptrj_t> filtersList(numFilters);\n+         std::vector<TR::KnownObjectTable::Index> filterIndexList(numFilters);\n+         std::vector<uintptrj_t *> filterObjectReferenceLocationList(numFilters);\n+\n          for (int i = 0; i < numFilters; i++)\n             {\n             filtersList[i] = fe->getReferenceElement(filters, i);\n+\n+            if (knotEnabled)\n+               {\n+               filterIndexList[i] = knot->getIndex(fe->getReferenceElement(filters, i));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc110d0e8fe05ae13d4feedfb6b77c216c59d41d"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDEyMzYwNA==", "bodyText": "To avoid the usage of alloca we could create an empty string of methodDescriptorLength+1 chars and use its buffer as an input to fe->getStringUTF8\nstd::string nextSignatureString(methodDescriptorLength+1, 0);\nfe->getStringUTF8(methodDescriptorRef, nextSignatureString.data(), methodDescriptorLength+1);", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r384123604", "createdAt": "2020-02-25T21:01:37Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/control/JITClientCompilationThread.cpp", "diffHunk": "@@ -2366,7 +2379,7 @@ handleServerMessage(JITServer::ClientStream *client, TR_J9VM *fe, JITServer::Mes\n          char *nextSignature = (char*)alloca(methodDescriptorLength+1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc110d0e8fe05ae13d4feedfb6b77c216c59d41d"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDEyOTY5Mw==", "bodyText": "We don't need to send the filtersList. These are object pointers that have no meaning at server.\nHowever, if KOT is disabled we need a way of determining which entries have filters. Sending an array of bool will save space in this case. Thus it's better to send the array called haveFilter", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r384129693", "createdAt": "2020-02-25T21:14:19Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/control/JITClientCompilationThread.cpp", "diffHunk": "@@ -2366,7 +2379,7 @@ handleServerMessage(JITServer::ClientStream *client, TR_J9VM *fe, JITServer::Mes\n          char *nextSignature = (char*)alloca(methodDescriptorLength+1);\n          fe->getStringUTF8(methodDescriptorRef, nextSignature, methodDescriptorLength+1);\n          std::string nextSignatureString(nextSignature, methodDescriptorLength);\n-         client->write(response, startPos, nextSignatureString, filtersList);\n+         client->write(response, startPos, nextSignatureString, filtersList, filterIndexList, filterObjectReferenceLocationList);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc110d0e8fe05ae13d4feedfb6b77c216c59d41d"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDEzMDEwOQ==", "bodyText": "The vector of filters should be replaced by a vector of bools haveFilter", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r384130109", "createdAt": "2020-02-25T21:15:11Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/env/j9method.cpp", "diffHunk": "@@ -8922,15 +8934,18 @@ TR_J9ByteCodeIlGenerator::runFEMacro(TR::SymbolReference *symRef)\n          bool *haveFilter = NULL;\n          bool knotEnabled = !comp()->getOption(TR_DisableKnownObjectTable);\n          char *nextSignature;\n+         TR::KnownObjectTable *knot = knotEnabled ? comp()->getOrCreateKnownObjectTable() : NULL;\n #if defined(JITSERVER_SUPPORT)\n          if (comp()->isOutOfProcessCompilation())\n             {\n             auto stream = TR::CompilationInfo::getStream();\n-            stream->write(JITServer::MessageType::runFEMacro_invokeFilterArgumentsHandle, thunkDetails->getHandleRef());\n-            auto recv = stream->read<int32_t, std::string, std::vector<uintptrj_t>>();\n+            stream->write(JITServer::MessageType::runFEMacro_invokeFilterArgumentsHandle, thunkDetails->getHandleRef(), knotEnabled);\n+            auto recv = stream->read<int32_t, std::string, std::vector<uintptrj_t>, std::vector<TR::KnownObjectTable::Index>, std::vector<uintptrj_t *>>();\n             startPos = std::get<0>(recv);\n             std::string nextSigStr = std::get<1>(recv);\n             std::vector<uintptrj_t> &filters = std::get<2>(recv);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc110d0e8fe05ae13d4feedfb6b77c216c59d41d"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDEzNTA4MQ==", "bodyText": "Maybe other another test that recvfilterIndexList[i] is not NULL", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r384135081", "createdAt": "2020-02-25T21:25:18Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/env/j9method.cpp", "diffHunk": "@@ -8940,10 +8955,19 @@ TR_J9ByteCodeIlGenerator::runFEMacro(TR::SymbolReference *symRef)\n \n             // copy the filters\n             int32_t numFilters = filters.size();\n+            filterIndexList = knotEnabled ? (TR::KnownObjectTable::Index *) comp()->trMemory()->allocateMemory(sizeof(TR::KnownObjectTable::Index) * numFilters, stackAlloc) : NULL;\n             haveFilter = (bool *) comp()->trMemory()->allocateMemory(sizeof(bool) * numFilters, stackAlloc);\n             for (int i = 0; i <numFilters; i++)\n                {\n                haveFilter[i] = (filters[i] != 0) ? true: false;\n+\n+               if (knotEnabled)\n+                  {\n+                  filterIndexList[i] = recvfilterIndexList[i];\n+\n+                  if (recvfilterIndexList[i] != TR::KnownObjectTable::UNKNOWN)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc110d0e8fe05ae13d4feedfb6b77c216c59d41d"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY1ODY1MA==", "bodyText": "If knot is disabled we don't have to compute getVolatileReferenceField, so let's insert this function under if (knotEnabled && knot)", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r384658650", "createdAt": "2020-02-26T17:47:36Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/control/JITClientCompilationThread.cpp", "diffHunk": "@@ -2537,6 +2568,199 @@ handleServerMessage(JITServer::ClientStream *client, TR_J9VM *fe, JITServer::Mes\n                           std::string((char*) bodyInfo->getMethodInfo(), sizeof(TR_PersistentMethodInfo)));\n          }\n          break;\n+      case MessageType::KnownObjectTable_getIndex:\n+         {\n+         uintptrj_t objectPointer = std::get<0>(client->getRecvData<uintptrj_t>());\n+\n+         TR::VMAccessCriticalSection knownObjectTableGetIndex(fe);\n+         TR::KnownObjectTable::Index index = knot->getIndex(objectPointer);\n+         uintptrj_t *objectPointerReference = knot->getPointerLocation(index);\n+         client->write(response, index, objectPointerReference);\n+         }\n+         break;\n+      case MessageType::KnownObjectTable_getIndexAt:\n+         {\n+         uintptrj_t *objectPointerReference = std::get<0>(client->getRecvData<uintptrj_t*>());\n+         client->write(response, knot->getIndexAt(objectPointerReference));\n+         }\n+         break;\n+      case MessageType::KnownObjectTable_dereferenceObjectPointerReference:\n+         {\n+         uintptrj_t *objectPointerReference = std::get<0>(client->getRecvData<uintptrj_t*>());\n+         client->write(response, knot->dereferenceObjectPointerReference(objectPointerReference));\n+         }\n+         break;\n+      case MessageType::KnownObjectTable_getExistingIndexAt:\n+         {\n+         uintptrj_t *objectPointerReference = std::get<0>(client->getRecvData<uintptrj_t*>());\n+         client->write(response, knot->getExistingIndexAt(objectPointerReference));\n+         }\n+         break;\n+      case MessageType::KnownObjectTable_symbolReferenceTableCreateKnownObject:\n+         {\n+         auto recv = client->getRecvData<void *, TR_ResolvedMethod *, int32_t>();\n+         void *dataAddress = std::get<0>(recv);\n+         TR_ResolvedMethod *owningMethod = std::get<1>(recv);\n+         int32_t cpIndex = std::get<2>(recv);\n+\n+         bool createKnownObject = false;\n+         TR::KnownObjectTable::Index knotIndex = TR::KnownObjectTable::UNKNOWN;\n+         uintptrj_t *objectPointerReference = NULL;\n+\n+         TR::VMAccessCriticalSection getObjectReferenceLocation(fe);\n+         if (*((uintptrj_t*)dataAddress) != 0)\n+            {\n+            TR_OpaqueClassBlock *declaringClass = owningMethod->getDeclaringClassFromFieldOrStatic(comp, cpIndex);\n+            if (declaringClass && fe->isClassInitialized(declaringClass))\n+               {\n+               static const char *foldVarHandle = feGetEnv(\"TR_FoldVarHandleWithoutFear\");\n+               int32_t clazzNameLength = 0;\n+               char *clazzName = fe->getClassNameChars(declaringClass, clazzNameLength);\n+               bool createKnownObject = false;\n+\n+               if (J9::TransformUtil::foldFinalFieldsIn(declaringClass, clazzName, clazzNameLength, true, comp))\n+                  {\n+                  createKnownObject = true;\n+                  }\n+               else if (foldVarHandle\n+                        && (clazzNameLength != 16 || strncmp(clazzName, \"java/lang/System\", 16)))\n+                  {\n+                  TR_OpaqueClassBlock *varHandleClass =  fe->getSystemClassFromClassName(\"java/lang/invoke/VarHandle\", 26);\n+                  TR_OpaqueClassBlock *objectClass = TR::Compiler->cls.objectClass(comp, *((uintptrj_t*)dataAddress));\n+\n+                  if (varHandleClass != NULL\n+                      && objectClass != NULL\n+                      && fe->isInstanceOf(objectClass, varHandleClass, true, true))\n+                     {\n+                     createKnownObject = true;\n+                     }\n+                  }\n+\n+               if (createKnownObject)\n+                  {\n+                  knotIndex = knot->getIndexAt((uintptrj_t*)dataAddress);\n+                  objectPointerReference = knot->getPointerLocation(knotIndex);\n+                  }\n+               }\n+            }\n+         client->write(response, knotIndex, objectPointerReference);\n+         }\n+         break;\n+      case MessageType::KnownObjectTable_mutableCallSiteEpoch:\n+         {\n+         auto recv = client->getRecvData<uintptrj_t*, bool>();\n+         uintptrj_t* mcsReferenceLocation = std::get<0>(recv);\n+         bool knotEnabled = std::get<1>(recv);\n+\n+         uintptrj_t mcsObject = 0;\n+         TR::KnownObjectTable::Index knotIndex = TR::KnownObjectTable::UNKNOWN;\n+         uintptrj_t *objectPointerReference = NULL;\n+\n+         TR::VMAccessCriticalSection mutableCallSiteEpoch(fe);\n+         mcsObject = fe->getStaticReferenceFieldAtAddress((uintptrj_t)mcsReferenceLocation);\n+         if (mcsObject)\n+            {\n+            TR_J9VMBase *fej9 = (TR_J9VMBase *)(fe);\n+            uintptrj_t currentEpoch = fej9->getVolatileReferenceField(mcsObject, \"epoch\", \"Ljava/lang/invoke/MethodHandle;\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc110d0e8fe05ae13d4feedfb6b77c216c59d41d"}, "originalPosition": 180}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY4MzEzMA==", "bodyText": "If knot==NULL then this function does nothing. I would put the knot test first and only then execute\nTR_OpaqueClassBlock *mutableCallsiteClass = callee->classOfMethod();", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r384683130", "createdAt": "2020-02-26T18:32:47Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/optimizer/InterpreterEmulator.cpp", "diffHunk": "@@ -298,16 +336,36 @@ InterpreterEmulator::getReturnValueForInvokevirtual(TR_ResolvedMethod *callee)\n       TR::KnownObjectTable::Index resultIndex = TR::KnownObjectTable::UNKNOWN;\n       TR_OpaqueClassBlock *mutableCallsiteClass = callee->classOfMethod();\n       debugTrace(tracer(), \"java_lang_invoke_MutableCallSite_target receiver obj%d(*%p) mutableCallsiteClass %p\\n\", receiverIndex, knot->getPointerLocation(receiverIndex), mutableCallsiteClass);\n-      if (mutableCallsiteClass)\n+      if (mutableCallsiteClass && knot)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc110d0e8fe05ae13d4feedfb6b77c216c59d41d"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY4Mzc0Ng==", "bodyText": "Also, the critical section for VMAccess on line 334 is not needed.", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r384683746", "createdAt": "2020-02-26T18:33:46Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/optimizer/InterpreterEmulator.cpp", "diffHunk": "@@ -298,16 +336,36 @@ InterpreterEmulator::getReturnValueForInvokevirtual(TR_ResolvedMethod *callee)\n       TR::KnownObjectTable::Index resultIndex = TR::KnownObjectTable::UNKNOWN;\n       TR_OpaqueClassBlock *mutableCallsiteClass = callee->classOfMethod();\n       debugTrace(tracer(), \"java_lang_invoke_MutableCallSite_target receiver obj%d(*%p) mutableCallsiteClass %p\\n\", receiverIndex, knot->getPointerLocation(receiverIndex), mutableCallsiteClass);\n-      if (mutableCallsiteClass)\n+      if (mutableCallsiteClass && knot)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY4MzEzMA=="}, "originalCommit": {"oid": "bc110d0e8fe05ae13d4feedfb6b77c216c59d41d"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY5NTY3Mg==", "bodyText": "I would prefer the code in the non-jitserver block to be transformed in a similar way to the jitserver block. Otherwise people may have a hard time to understand why one is equivalent to the other.\n                  TR::KnownObjectTable::Index objectIndex = TR::KnownObjectTable::UNKNOWN\n                     {\n                     TR::VMAccessCriticalSection createSymRefWithKnownObject(comp->fej9());\n                     uintptrj_t jlClass = (uintptrj_t)J9VM_J9CLASS_TO_HEAPCLASS((J9Class*)baseObject->getSymbol()->castToStaticSymbol()->getStaticAddress());\n                     TR_ASSERT(jlClass, \"java/lang/Class reference from heap class must be non null\");\n                     objectIndex = knot->getIndexAt(&jlClass);\n                     }\n                  improvedSymRef = comp->getSymRefTab()->findOrCreateSymRefWithKnownObject(node->getSymbolReference(), objectIndex);", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r384695672", "createdAt": "2020-02-26T18:55:53Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/optimizer/J9TransformUtil.cpp", "diffHunk": "@@ -526,8 +526,30 @@ J9::TransformUtil::transformIndirectLoad(TR::Compilation *comp, TR::Node *node)\n                && baseObject->getOpCodeValue() == TR::loadaddr\n                && !baseObject->getSymbolReference()->isUnresolved())\n                {\n-               TR::SymbolReference *improvedSymRef;\n+               TR::SymbolReference *improvedSymRef = node->getSymbolReference();\n+#if defined(JITSERVER_SUPPORT)\n+               if (comp->isOutOfProcessCompilation())\n+                  {\n+                  TR::KnownObjectTable *knot = comp->getOrCreateKnownObjectTable();\n+                  if (knot)\n+                     {\n+                     auto stream = TR::CompilationInfo::getStream();\n+                     stream->write(JITServer::MessageType::KnownObjectTable_createSymRefWithKnownObject,\n+                           baseObject->getSymbol()->castToStaticSymbol()->getStaticAddress());\n+\n+                     auto recv = stream->read<TR::KnownObjectTable::Index, uintptrj_t*>();\n+                     TR::KnownObjectTable::Index knotIndex = std::get<0>(recv);\n+                     uintptrj_t *objectPointerReference = std::get<1>(recv);\n \n+                     if (knotIndex != TR::KnownObjectTable::UNKNOWN)\n+                        {\n+                        knot->updateKnownObjectTableAtServer(knotIndex, objectPointerReference);\n+                        }\n+                     improvedSymRef = comp->getSymRefTab()->findOrCreateSymRefWithKnownObject(node->getSymbolReference(), knotIndex);\n+                     }\n+                  }\n+               else\n+#endif /* defined(JITSERVER_SUPPORT) */\n                   {\n                   TR::VMAccessCriticalSection createSymRefWithKnownObject(comp->fej9());\n                   uintptrj_t jlClass = (uintptrj_t)J9VM_J9CLASS_TO_HEAPCLASS((J9Class*)baseObject->getSymbol()->castToStaticSymbol()->getStaticAddress());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc110d0e8fe05ae13d4feedfb6b77c216c59d41d"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDcwMzM1Mg==", "bodyText": "targetObjectReference is not needed", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r384703352", "createdAt": "2020-02-26T19:10:05Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/optimizer/J9TransformUtil.cpp", "diffHunk": "@@ -842,9 +864,34 @@ J9::TransformUtil::transformIndirectLoad(TR::Compilation *comp, TR::Node *node)\n                }\n             else if (symrefIsImprovable)\n                {\n-               uintptrj_t targetObjectReference;\n-               TR::SymbolReference *improvedSymRef;\n+               uintptrj_t targetObjectReference = 0;\n+               TR::SymbolReference *improvedSymRef = node->getSymbolReference();\n \n+#if defined(JITSERVER_SUPPORT)\n+               if (comp->isOutOfProcessCompilation())\n+                  {\n+                  TR::KnownObjectTable *knot = comp->getOrCreateKnownObjectTable();\n+                  bool knotEnabled = (knot != NULL);\n+                  auto stream = TR::CompilationInfo::getStream();\n+                  stream->write(JITServer::MessageType::KnownObjectTable_getReferenceField,\n+                        baseObject->getSymbol()->isStatic(), baseObjectRefLocation, fieldOffset, knotEnabled);\n+\n+                  auto recv = stream->read<TR::KnownObjectTable::Index, uintptrj_t*, uintptrj_t>();\n+                  TR::KnownObjectTable::Index knotIndex = std::get<0>(recv);\n+                  uintptrj_t *objectPointerReference = std::get<1>(recv);\n+                  targetObjectReference = std::get<2>(recv);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc110d0e8fe05ae13d4feedfb6b77c216c59d41d"}, "originalPosition": 53}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "bc110d0e8fe05ae13d4feedfb6b77c216c59d41d", "author": {"user": {"login": "a7ehuo", "name": "Annabelle Huo"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/bc110d0e8fe05ae13d4feedfb6b77c216c59d41d", "committedDate": "2020-02-25T16:02:29Z", "message": "Support Known Object Table at the server\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>"}, "afterCommit": {"oid": "ce013bce0da4bf1bcb24a394ae2b5c8c33f0de0e", "author": {"user": {"login": "a7ehuo", "name": "Annabelle Huo"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/ce013bce0da4bf1bcb24a394ae2b5c8c33f0de0e", "committedDate": "2020-02-27T20:21:46Z", "message": "Support Known Object Table at the server\n\nTwo main issues to consider when supporting KOT at the server:\n1) Prevent the object pointer from being dereferenced directly at the\n   server since it requires the VM access.\n2) The known object table is created at the client and the server. Some\n   operations might cause the KOT to be updated directly at the client\n   without going through the server first. Need to make sure the tables at\n   the client and the server in sync.\n\nMajor changes include:\n- Add KnownObjectTable::updateKnownObjectTableAtServer() which is used to\n  update KOT at the server.\n- Replace the direct dereference of getPointerLocation() with\n  getPointer(). When getPointer() is called at the server, it sends a\n  message to the client to dereference it with the proper VM access.\n- Send messages to the client to dereference the object pointer or\n  when retrieving the index if getIndex() is called.\n\nAlthough there are a few places the known object pointers are\ndereferenced directly, it wouldn\u2019t cause a problem if the critical\nsection is created with VMAccessCriticalSection::tryToAcquireVMAccess,\nbecause at the server the VM access will not be granted.\n\nTODOs:\n- Rename getIndex() with a name that reflects this method could\n  also create a new reference which ends up increasing the size of KOT.\n- Implement KnownObjectTable::dumpTo() and\n  KnownObjectTable::dumpObjectTo() at the server.\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ce013bce0da4bf1bcb24a394ae2b5c8c33f0de0e", "author": {"user": {"login": "a7ehuo", "name": "Annabelle Huo"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/ce013bce0da4bf1bcb24a394ae2b5c8c33f0de0e", "committedDate": "2020-02-27T20:21:46Z", "message": "Support Known Object Table at the server\n\nTwo main issues to consider when supporting KOT at the server:\n1) Prevent the object pointer from being dereferenced directly at the\n   server since it requires the VM access.\n2) The known object table is created at the client and the server. Some\n   operations might cause the KOT to be updated directly at the client\n   without going through the server first. Need to make sure the tables at\n   the client and the server in sync.\n\nMajor changes include:\n- Add KnownObjectTable::updateKnownObjectTableAtServer() which is used to\n  update KOT at the server.\n- Replace the direct dereference of getPointerLocation() with\n  getPointer(). When getPointer() is called at the server, it sends a\n  message to the client to dereference it with the proper VM access.\n- Send messages to the client to dereference the object pointer or\n  when retrieving the index if getIndex() is called.\n\nAlthough there are a few places the known object pointers are\ndereferenced directly, it wouldn\u2019t cause a problem if the critical\nsection is created with VMAccessCriticalSection::tryToAcquireVMAccess,\nbecause at the server the VM access will not be granted.\n\nTODOs:\n- Rename getIndex() with a name that reflects this method could\n  also create a new reference which ends up increasing the size of KOT.\n- Implement KnownObjectTable::dumpTo() and\n  KnownObjectTable::dumpObjectTo() at the server.\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>"}, "afterCommit": {"oid": "5d8add53116fe77ff1a1eb676e026c38eb0ce80f", "author": {"user": {"login": "a7ehuo", "name": "Annabelle Huo"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/5d8add53116fe77ff1a1eb676e026c38eb0ce80f", "committedDate": "2020-02-28T19:42:00Z", "message": "Support Known Object Table at the server\n\nTwo main issues to consider when supporting KOT at the server:\n1) Prevent the object pointer from being dereferenced directly at the\n   server since it requires the VM access.\n2) The known object table is created at the client and the server. Some\n   operations might cause the KOT to be updated directly at the client\n   without going through the server first. Need to make sure the tables at\n   the client and the server in sync.\n\nMajor changes include:\n- Add KnownObjectTable::updateKnownObjectTableAtServer() which is used to\n  update KOT at the server.\n- Replace the direct dereference of getPointerLocation() with\n  getPointer(). When getPointer() is called at the server, it sends a\n  message to the client to dereference it with the proper VM access.\n- Send messages to the client to dereference the object pointer or\n  when retrieving the index if getIndex() is called.\n\nAlthough there are a few places the known object pointers are\ndereferenced directly, it wouldn\u2019t cause a problem if the critical\nsection is created with VMAccessCriticalSection::tryToAcquireVMAccess,\nbecause at the server the VM access will not be granted.\n\nTODOs:\n- Rename getIndex() with a name that reflects this method could\n  also create a new reference which ends up increasing the size of KOT.\n- Implement KnownObjectTable::dumpTo() and\n  KnownObjectTable::dumpObjectTo() at the server.\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5d8add53116fe77ff1a1eb676e026c38eb0ce80f", "author": {"user": {"login": "a7ehuo", "name": "Annabelle Huo"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/5d8add53116fe77ff1a1eb676e026c38eb0ce80f", "committedDate": "2020-02-28T19:42:00Z", "message": "Support Known Object Table at the server\n\nTwo main issues to consider when supporting KOT at the server:\n1) Prevent the object pointer from being dereferenced directly at the\n   server since it requires the VM access.\n2) The known object table is created at the client and the server. Some\n   operations might cause the KOT to be updated directly at the client\n   without going through the server first. Need to make sure the tables at\n   the client and the server in sync.\n\nMajor changes include:\n- Add KnownObjectTable::updateKnownObjectTableAtServer() which is used to\n  update KOT at the server.\n- Replace the direct dereference of getPointerLocation() with\n  getPointer(). When getPointer() is called at the server, it sends a\n  message to the client to dereference it with the proper VM access.\n- Send messages to the client to dereference the object pointer or\n  when retrieving the index if getIndex() is called.\n\nAlthough there are a few places the known object pointers are\ndereferenced directly, it wouldn\u2019t cause a problem if the critical\nsection is created with VMAccessCriticalSection::tryToAcquireVMAccess,\nbecause at the server the VM access will not be granted.\n\nTODOs:\n- Rename getIndex() with a name that reflects this method could\n  also create a new reference which ends up increasing the size of KOT.\n- Implement KnownObjectTable::dumpTo() and\n  KnownObjectTable::dumpObjectTo() at the server.\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>"}, "afterCommit": {"oid": "5bf9611bd5370f1443864cb2099f13e68e687029", "author": {"user": {"login": "a7ehuo", "name": "Annabelle Huo"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/5bf9611bd5370f1443864cb2099f13e68e687029", "committedDate": "2020-03-03T15:22:25Z", "message": "Support Known Object Table at the server\n\nTwo main issues to consider when supporting KOT at the server:\n1) Prevent the object pointer from being dereferenced directly at the\n   server since it requires the VM access.\n2) The known object table is created at the client and the server. Some\n   operations might cause the KOT to be updated directly at the client\n   without going through the server first. Need to make sure the tables at\n   the client and the server in sync.\n\nMajor changes include:\n- Add KnownObjectTable::updateKnownObjectTableAtServer() which is used to\n  update KOT at the server.\n- Replace the direct dereference of getPointerLocation() with\n  getPointer(). When getPointer() is called at the server, it sends a\n  message to the client to dereference it with the proper VM access.\n- Send messages to the client to dereference the object pointer or\n  when retrieving the index if getIndex() is called.\n\nAlthough there are a few places the known object pointers are\ndereferenced directly, it wouldn\u2019t cause a problem if the critical\nsection is created with VMAccessCriticalSection::tryToAcquireVMAccess,\nbecause at the server the VM access will not be granted.\n\nTODOs:\n- Rename getIndex() with a name that reflects this method could\n  also create a new reference which ends up increasing the size of KOT.\n- Implement KnownObjectTable::dumpTo() and\n  KnownObjectTable::dumpObjectTo() at the server.\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5OTM3MDg2", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#pullrequestreview-369937086", "createdAt": "2020-03-05T21:44:09Z", "commit": {"oid": "5bf9611bd5370f1443864cb2099f13e68e687029"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMTo0NDowOVrOFylRAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMTo0NDowOVrOFylRAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU4MzY4Mw==", "bodyText": "I don't think it's safe for the server to ever execute this code because it deals with objects. Any object pointer may have received from the client could become stale because the client cannot hold VMaccess while sending a message to the server.\nIt may be the case that after all the transformations we actually don't call getIndex() from the server, but it's better to put a ASSERT_FATAL here.", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r388583683", "createdAt": "2020-03-05T21:44:09Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/env/J9KnownObjectTable.cpp", "diffHunk": "@@ -56,28 +65,176 @@ J9::KnownObjectTable::isNull(Index index)\n TR::KnownObjectTable::Index\n J9::KnownObjectTable::getIndex(uintptrj_t objectPointer)\n    {\n-   TR_J9VMBase *fej9 = (TR_J9VMBase *)(self()->fe());\n-   TR_ASSERT(fej9->haveAccess(), \"Must haveAccess in J9::KnownObjectTable::getIndex\");\n    if (objectPointer == 0)\n       return 0; // Special Index value for NULL\n \n-   // Search for existing matching entry\n-   //\n    uint32_t nextIndex = self()->getEndIndex();\n-   for (uint32_t i = 1; i < nextIndex; i++)\n-      if (*_references.element(i) == objectPointer)\n-         return i;\n-\n-   // No luck -- allocate a new one\n-   //\n-   J9VMThread *thread = getJ9VMThreadFromTR_VM(self()->fe());\n-   TR_ASSERT(thread, \"assertion failure\");\n-   _references.setSize(nextIndex+1);\n-   _references[nextIndex] = (uintptrj_t*)thread->javaVM->internalVMFunctions->j9jni_createLocalRef((JNIEnv*)thread, (j9object_t)objectPointer);\n+#if defined(J9VM_OPT_JITSERVER)\n+   if (self()->comp()->isOutOfProcessCompilation())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bf9611bd5370f1443864cb2099f13e68e687029"}, "originalPosition": 53}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5bf9611bd5370f1443864cb2099f13e68e687029", "author": {"user": {"login": "a7ehuo", "name": "Annabelle Huo"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/5bf9611bd5370f1443864cb2099f13e68e687029", "committedDate": "2020-03-03T15:22:25Z", "message": "Support Known Object Table at the server\n\nTwo main issues to consider when supporting KOT at the server:\n1) Prevent the object pointer from being dereferenced directly at the\n   server since it requires the VM access.\n2) The known object table is created at the client and the server. Some\n   operations might cause the KOT to be updated directly at the client\n   without going through the server first. Need to make sure the tables at\n   the client and the server in sync.\n\nMajor changes include:\n- Add KnownObjectTable::updateKnownObjectTableAtServer() which is used to\n  update KOT at the server.\n- Replace the direct dereference of getPointerLocation() with\n  getPointer(). When getPointer() is called at the server, it sends a\n  message to the client to dereference it with the proper VM access.\n- Send messages to the client to dereference the object pointer or\n  when retrieving the index if getIndex() is called.\n\nAlthough there are a few places the known object pointers are\ndereferenced directly, it wouldn\u2019t cause a problem if the critical\nsection is created with VMAccessCriticalSection::tryToAcquireVMAccess,\nbecause at the server the VM access will not be granted.\n\nTODOs:\n- Rename getIndex() with a name that reflects this method could\n  also create a new reference which ends up increasing the size of KOT.\n- Implement KnownObjectTable::dumpTo() and\n  KnownObjectTable::dumpObjectTo() at the server.\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>"}, "afterCommit": {"oid": "7e8397712a6f3cb8b1a6e905ab000c6ca2f3b979", "author": {"user": {"login": "a7ehuo", "name": "Annabelle Huo"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/7e8397712a6f3cb8b1a6e905ab000c6ca2f3b979", "committedDate": "2020-03-06T22:01:18Z", "message": "Support Known Object Table at the server\n\nTwo main issues to consider when supporting KOT at the server:\n1) Prevent the object pointer from being dereferenced directly at the\n   server since it requires the VM access.\n2) The known object table is created at the client and the server. Some\n   operations might cause the KOT to be updated directly at the client\n   without going through the server first. Need to make sure the tables at\n   the client and the server in sync.\n\nMajor changes include:\n- Add KnownObjectTable::updateKnownObjectTableAtServer() which is used to\n  update KOT at the server.\n- Replace the direct dereference of getPointerLocation() with\n  getPointer(). When getPointer() is called at the server, it sends a\n  message to the client to dereference it with the proper VM access.\n- Send messages to the client to dereference the object pointer or\n  when retrieving the index if getIndex() is called.\n\nAlthough there are a few places the known object pointers are\ndereferenced directly, it wouldn\u2019t cause a problem if the critical\nsection is created with VMAccessCriticalSection::tryToAcquireVMAccess,\nbecause at the server the VM access will not be granted.\n\nTODOs:\n- Rename getIndex() with a name that reflects this method could\n  also create a new reference which ends up increasing the size of KOT.\n- Implement KnownObjectTable::dumpTo() and\n  KnownObjectTable::dumpObjectTo() at the server.\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7e8397712a6f3cb8b1a6e905ab000c6ca2f3b979", "author": {"user": {"login": "a7ehuo", "name": "Annabelle Huo"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/7e8397712a6f3cb8b1a6e905ab000c6ca2f3b979", "committedDate": "2020-03-06T22:01:18Z", "message": "Support Known Object Table at the server\n\nTwo main issues to consider when supporting KOT at the server:\n1) Prevent the object pointer from being dereferenced directly at the\n   server since it requires the VM access.\n2) The known object table is created at the client and the server. Some\n   operations might cause the KOT to be updated directly at the client\n   without going through the server first. Need to make sure the tables at\n   the client and the server in sync.\n\nMajor changes include:\n- Add KnownObjectTable::updateKnownObjectTableAtServer() which is used to\n  update KOT at the server.\n- Replace the direct dereference of getPointerLocation() with\n  getPointer(). When getPointer() is called at the server, it sends a\n  message to the client to dereference it with the proper VM access.\n- Send messages to the client to dereference the object pointer or\n  when retrieving the index if getIndex() is called.\n\nAlthough there are a few places the known object pointers are\ndereferenced directly, it wouldn\u2019t cause a problem if the critical\nsection is created with VMAccessCriticalSection::tryToAcquireVMAccess,\nbecause at the server the VM access will not be granted.\n\nTODOs:\n- Rename getIndex() with a name that reflects this method could\n  also create a new reference which ends up increasing the size of KOT.\n- Implement KnownObjectTable::dumpTo() and\n  KnownObjectTable::dumpObjectTo() at the server.\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>"}, "afterCommit": {"oid": "afb5fdc2fa71976a34cfe04a9c32f169c898c67e", "author": {"user": {"login": "a7ehuo", "name": "Annabelle Huo"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/afb5fdc2fa71976a34cfe04a9c32f169c898c67e", "committedDate": "2020-03-08T20:02:28Z", "message": "Support Known Object Table at the server\n\nTwo main issues to consider when supporting KOT at the server:\n1) Prevent the object pointer from being dereferenced directly at the\n   server since it requires the VM access.\n2) The known object table is created at the client and the server. Some\n   operations might cause the KOT to be updated directly at the client\n   without going through the server first. Need to make sure the tables at\n   the client and the server in sync.\n\nMajor changes include:\n- Add KnownObjectTable::updateKnownObjectTableAtServer() which is used to\n  update KOT at the server.\n- Replace the direct dereference of getPointerLocation() with\n  getPointer(). When getPointer() is called at the server, it sends a\n  message to the client to dereference it with the proper VM access.\n- Send messages to the client to dereference the object pointer or\n  when retrieving the index if getIndex() is called.\n\nAlthough there are a few places the known object pointers are\ndereferenced directly, it wouldn\u2019t cause a problem if the critical\nsection is created with VMAccessCriticalSection::tryToAcquireVMAccess,\nbecause at the server the VM access will not be granted.\n\nTODOs:\n- Rename getIndex() with a name that reflects this method could\n  also create a new reference which ends up increasing the size of KOT.\n- Implement KnownObjectTable::dumpTo() and\n  KnownObjectTable::dumpObjectTo() at the server.\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcxMTg2ODE5", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#pullrequestreview-371186819", "createdAt": "2020-03-09T13:35:23Z", "commit": {"oid": "afb5fdc2fa71976a34cfe04a9c32f169c898c67e"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxMzozNToyM1rOFznpNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxMzozOTowMlrOFzn5fg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTY3MTIyMw==", "bodyText": "This is used in a single place in KnownObjectTable::getPointer(Index index). Thus, is should be marked private.", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r389671223", "createdAt": "2020-03-09T13:35:23Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/env/J9KnownObjectTable.cpp", "diffHunk": "@@ -56,28 +65,177 @@ J9::KnownObjectTable::isNull(Index index)\n TR::KnownObjectTable::Index\n J9::KnownObjectTable::getIndex(uintptrj_t objectPointer)\n    {\n-   TR_J9VMBase *fej9 = (TR_J9VMBase *)(self()->fe());\n-   TR_ASSERT(fej9->haveAccess(), \"Must haveAccess in J9::KnownObjectTable::getIndex\");\n    if (objectPointer == 0)\n       return 0; // Special Index value for NULL\n \n-   // Search for existing matching entry\n-   //\n    uint32_t nextIndex = self()->getEndIndex();\n-   for (uint32_t i = 1; i < nextIndex; i++)\n-      if (*_references.element(i) == objectPointer)\n-         return i;\n-\n-   // No luck -- allocate a new one\n-   //\n-   J9VMThread *thread = getJ9VMThreadFromTR_VM(self()->fe());\n-   TR_ASSERT(thread, \"assertion failure\");\n-   _references.setSize(nextIndex+1);\n-   _references[nextIndex] = (uintptrj_t*)thread->javaVM->internalVMFunctions->j9jni_createLocalRef((JNIEnv*)thread, (j9object_t)objectPointer);\n+#if defined(J9VM_OPT_JITSERVER)\n+   if (self()->comp()->isOutOfProcessCompilation())\n+      {\n+      TR_ASSERT(false, \"It is not safe to call getIndex() at the server. The object pointer could have become stale at the client.\");\n+      auto stream = TR::CompilationInfo::getStream();\n+      stream->write(JITServer::MessageType::KnownObjectTable_getIndex, objectPointer);\n+      auto recv = stream->read<TR::KnownObjectTable::Index, uintptrj_t *>();\n+\n+      TR::KnownObjectTable::Index index = std::get<0>(recv);\n+      uintptrj_t *objectReferenceLocation = std::get<1>(recv);\n+      TR_ASSERT_FATAL(index <= nextIndex, \"The KOT index %d at the client is greater than the KOT index %d at the server\", index, nextIndex);\n+\n+      if (index < nextIndex)\n+         {\n+         return index;\n+         }\n+      else\n+         {\n+         updateKnownObjectTableAtServer(index, objectReferenceLocation);\n+         }\n+      }\n+   else\n+#endif /* defined(J9VM_OPT_JITSERVER) */\n+      {\n+      TR_J9VMBase *fej9 = (TR_J9VMBase *)(self()->fe());\n+      TR_ASSERT(fej9->haveAccess(), \"Must haveAccess in J9::KnownObjectTable::getIndex\");\n+\n+      // Search for existing matching entry\n+      //\n+      for (uint32_t i = 1; i < nextIndex; i++)\n+         if (*_references.element(i) == objectPointer)\n+            return i;\n+\n+      // No luck -- allocate a new one\n+      //\n+      J9VMThread *thread = getJ9VMThreadFromTR_VM(self()->fe());\n+      TR_ASSERT(thread, \"assertion failure\");\n+      _references.setSize(nextIndex+1);\n+      _references[nextIndex] = (uintptrj_t*)thread->javaVM->internalVMFunctions->j9jni_createLocalRef((JNIEnv*)thread, (j9object_t)objectPointer);\n+      }\n+\n    return nextIndex;\n    }\n \n \n+TR::KnownObjectTable::Index\n+J9::KnownObjectTable::getIndex(uintptrj_t objectPointer, bool isArrayWithConstantElements)\n+   {\n+   TR::KnownObjectTable::Index index = self()->getIndex(objectPointer);\n+   if (isArrayWithConstantElements)\n+      {\n+      self()->addArrayWithConstantElements(index);\n+      }\n+   return index;\n+   }\n+\n+\n+#if defined(J9VM_OPT_JITSERVER)\n+uintptrj_t\n+J9::KnownObjectTable::dereferenceObjectPointerReference(uintptrj_t *objectReferenceLocation)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "afb5fdc2fa71976a34cfe04a9c32f169c898c67e"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTY3NTM5MA==", "bodyText": "I would like an assert here that this method is not called at the server. We obtain an object pointer from the client, but it's of no use to the server, because by the time we get to use it it may have become stale. Right now the assert holds from my scanning of the code.", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#discussion_r389675390", "createdAt": "2020-03-09T13:39:02Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/env/J9KnownObjectTable.cpp", "diffHunk": "@@ -56,28 +65,177 @@ J9::KnownObjectTable::isNull(Index index)\n TR::KnownObjectTable::Index\n J9::KnownObjectTable::getIndex(uintptrj_t objectPointer)\n    {\n-   TR_J9VMBase *fej9 = (TR_J9VMBase *)(self()->fe());\n-   TR_ASSERT(fej9->haveAccess(), \"Must haveAccess in J9::KnownObjectTable::getIndex\");\n    if (objectPointer == 0)\n       return 0; // Special Index value for NULL\n \n-   // Search for existing matching entry\n-   //\n    uint32_t nextIndex = self()->getEndIndex();\n-   for (uint32_t i = 1; i < nextIndex; i++)\n-      if (*_references.element(i) == objectPointer)\n-         return i;\n-\n-   // No luck -- allocate a new one\n-   //\n-   J9VMThread *thread = getJ9VMThreadFromTR_VM(self()->fe());\n-   TR_ASSERT(thread, \"assertion failure\");\n-   _references.setSize(nextIndex+1);\n-   _references[nextIndex] = (uintptrj_t*)thread->javaVM->internalVMFunctions->j9jni_createLocalRef((JNIEnv*)thread, (j9object_t)objectPointer);\n+#if defined(J9VM_OPT_JITSERVER)\n+   if (self()->comp()->isOutOfProcessCompilation())\n+      {\n+      TR_ASSERT(false, \"It is not safe to call getIndex() at the server. The object pointer could have become stale at the client.\");\n+      auto stream = TR::CompilationInfo::getStream();\n+      stream->write(JITServer::MessageType::KnownObjectTable_getIndex, objectPointer);\n+      auto recv = stream->read<TR::KnownObjectTable::Index, uintptrj_t *>();\n+\n+      TR::KnownObjectTable::Index index = std::get<0>(recv);\n+      uintptrj_t *objectReferenceLocation = std::get<1>(recv);\n+      TR_ASSERT_FATAL(index <= nextIndex, \"The KOT index %d at the client is greater than the KOT index %d at the server\", index, nextIndex);\n+\n+      if (index < nextIndex)\n+         {\n+         return index;\n+         }\n+      else\n+         {\n+         updateKnownObjectTableAtServer(index, objectReferenceLocation);\n+         }\n+      }\n+   else\n+#endif /* defined(J9VM_OPT_JITSERVER) */\n+      {\n+      TR_J9VMBase *fej9 = (TR_J9VMBase *)(self()->fe());\n+      TR_ASSERT(fej9->haveAccess(), \"Must haveAccess in J9::KnownObjectTable::getIndex\");\n+\n+      // Search for existing matching entry\n+      //\n+      for (uint32_t i = 1; i < nextIndex; i++)\n+         if (*_references.element(i) == objectPointer)\n+            return i;\n+\n+      // No luck -- allocate a new one\n+      //\n+      J9VMThread *thread = getJ9VMThreadFromTR_VM(self()->fe());\n+      TR_ASSERT(thread, \"assertion failure\");\n+      _references.setSize(nextIndex+1);\n+      _references[nextIndex] = (uintptrj_t*)thread->javaVM->internalVMFunctions->j9jni_createLocalRef((JNIEnv*)thread, (j9object_t)objectPointer);\n+      }\n+\n    return nextIndex;\n    }\n \n \n+TR::KnownObjectTable::Index\n+J9::KnownObjectTable::getIndex(uintptrj_t objectPointer, bool isArrayWithConstantElements)\n+   {\n+   TR::KnownObjectTable::Index index = self()->getIndex(objectPointer);\n+   if (isArrayWithConstantElements)\n+      {\n+      self()->addArrayWithConstantElements(index);\n+      }\n+   return index;\n+   }\n+\n+\n+#if defined(J9VM_OPT_JITSERVER)\n+uintptrj_t\n+J9::KnownObjectTable::dereferenceObjectPointerReference(uintptrj_t *objectReferenceLocation)\n+   {\n+   uintptrj_t objectPointer = 0;\n+   if (self()->comp()->isOutOfProcessCompilation())\n+      {\n+      auto stream = TR::CompilationInfo::getStream();\n+      stream->write(JITServer::MessageType::KnownObjectTable_dereferenceObjectPointerReference, objectReferenceLocation);\n+      objectPointer = std::get<0>(stream->read<uintptrj_t>());\n+      }\n+   else\n+      {\n+      TR::VMAccessCriticalSection dereferenceObjectPointerReferenceCriticalSection(self()->comp());\n+      objectPointer = *objectReferenceLocation;\n+      }\n+   return objectPointer;\n+   }\n+#endif /* defined(J9VM_OPT_JITSERVER) */\n+\n+\n+TR::KnownObjectTable::Index\n+J9::KnownObjectTable::getIndexAt(uintptrj_t *objectReferenceLocation)\n+   {\n+   TR::KnownObjectTable::Index result = UNKNOWN;\n+#if defined(J9VM_OPT_JITSERVER)\n+   if (self()->comp()->isOutOfProcessCompilation())\n+      {\n+      auto stream = TR::CompilationInfo::getStream();\n+      stream->write(JITServer::MessageType::KnownObjectTable_getIndexAt, objectReferenceLocation);\n+      auto recv = stream->read<TR::KnownObjectTable::Index>();\n+      result = std::get<0>(stream->read<TR::KnownObjectTable::Index>());\n+\n+      updateKnownObjectTableAtServer(result, objectReferenceLocation);\n+      }\n+   else\n+#endif /* defined(J9VM_OPT_JITSERVER) */\n+      {\n+      TR::VMAccessCriticalSection getIndexAtCriticalSection(self()->comp());\n+      uintptrj_t objectPointer = *objectReferenceLocation; // Note: object references held as uintptrj_t must never be compressed refs\n+      result = self()->getIndex(objectPointer);\n+      }\n+   return result;\n+   }\n+\n+TR::KnownObjectTable::Index\n+J9::KnownObjectTable::getIndexAt(uintptrj_t *objectReferenceLocation, bool isArrayWithConstantElements)\n+   {\n+   Index result = self()->getIndexAt(objectReferenceLocation);\n+   if (isArrayWithConstantElements)\n+      self()->addArrayWithConstantElements(result);\n+   return result;\n+   }\n+\n+\n+TR::KnownObjectTable::Index\n+J9::KnownObjectTable::getExistingIndexAt(uintptrj_t *objectReferenceLocation)\n+   {\n+   TR::KnownObjectTable::Index result = UNKNOWN;\n+#if defined(J9VM_OPT_JITSERVER)\n+   if (self()->comp()->isOutOfProcessCompilation())\n+      {\n+      auto stream = TR::CompilationInfo::getStream();\n+      stream->write(JITServer::MessageType::KnownObjectTable_getExistingIndexAt, objectReferenceLocation);\n+      result = std::get<0>(stream->read<TR::KnownObjectTable::Index>());\n+      }\n+   else\n+#endif /* defined(J9VM_OPT_JITSERVER) */\n+      {\n+      TR::VMAccessCriticalSection getExistingIndexAtCriticalSection(self()->comp());\n+\n+      uintptrj_t objectPointer = *objectReferenceLocation;\n+      for (Index i = 0; i < self()->getEndIndex() && (result == UNKNOWN); i++)\n+         {\n+         if (self()->getPointer(i) == objectPointer)\n+            {\n+            result = i;\n+            break;\n+            }\n+         }\n+      }\n+   return result;\n+   }\n+\n+\n+uintptrj_t\n+J9::KnownObjectTable::getPointer(Index index)\n+   {\n+   if (self()->isNull(index))\n+      {\n+      return 0; // Assumes host and target representations of null match each other\n+      }\n+   else\n+      {\n+#if defined(J9VM_OPT_JITSERVER)\n+      if (self()->comp()->isOutOfProcessCompilation())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "afb5fdc2fa71976a34cfe04a9c32f169c898c67e"}, "originalPosition": 204}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "afb5fdc2fa71976a34cfe04a9c32f169c898c67e", "author": {"user": {"login": "a7ehuo", "name": "Annabelle Huo"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/afb5fdc2fa71976a34cfe04a9c32f169c898c67e", "committedDate": "2020-03-08T20:02:28Z", "message": "Support Known Object Table at the server\n\nTwo main issues to consider when supporting KOT at the server:\n1) Prevent the object pointer from being dereferenced directly at the\n   server since it requires the VM access.\n2) The known object table is created at the client and the server. Some\n   operations might cause the KOT to be updated directly at the client\n   without going through the server first. Need to make sure the tables at\n   the client and the server in sync.\n\nMajor changes include:\n- Add KnownObjectTable::updateKnownObjectTableAtServer() which is used to\n  update KOT at the server.\n- Replace the direct dereference of getPointerLocation() with\n  getPointer(). When getPointer() is called at the server, it sends a\n  message to the client to dereference it with the proper VM access.\n- Send messages to the client to dereference the object pointer or\n  when retrieving the index if getIndex() is called.\n\nAlthough there are a few places the known object pointers are\ndereferenced directly, it wouldn\u2019t cause a problem if the critical\nsection is created with VMAccessCriticalSection::tryToAcquireVMAccess,\nbecause at the server the VM access will not be granted.\n\nTODOs:\n- Rename getIndex() with a name that reflects this method could\n  also create a new reference which ends up increasing the size of KOT.\n- Implement KnownObjectTable::dumpTo() and\n  KnownObjectTable::dumpObjectTo() at the server.\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>"}, "afterCommit": {"oid": "614ef58ead334a10d8ebfed3fc07e47551dbf538", "author": {"user": {"login": "a7ehuo", "name": "Annabelle Huo"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/614ef58ead334a10d8ebfed3fc07e47551dbf538", "committedDate": "2020-03-09T19:26:20Z", "message": "Support Known Object Table at the server\n\nTwo main issues to consider when supporting KOT at the server:\n1) Prevent the object pointer from being dereferenced directly at the\n   server since it requires the VM access.\n2) The known object table is created at the client and the server. Some\n   operations might cause the KOT to be updated directly at the client\n   without going through the server first. Need to make sure the tables at\n   the client and the server in sync.\n\nMajor changes include:\n- Add KnownObjectTable::updateKnownObjectTableAtServer() which is used to\n  update KOT at the server.\n- Replace the direct dereference of getPointerLocation() with\n  getPointer(). When getPointer() is called at the server, it sends a\n  message to the client to dereference it with the proper VM access.\n- Send messages to the client to dereference the object pointer or\n  when retrieving the index if getIndex() is called.\n\nAlthough there are a few places the known object pointers are\ndereferenced directly, it wouldn\u2019t cause a problem if the critical\nsection is created with VMAccessCriticalSection::tryToAcquireVMAccess,\nbecause at the server the VM access will not be granted.\n\nTODOs:\n- Rename getIndex() with a name that reflects this method could\n  also create a new reference which ends up increasing the size of KOT.\n- Implement KnownObjectTable::dumpTo() and\n  KnownObjectTable::dumpObjectTo() at the server.\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "355e705e05cb13624cb8373ff3510e43065ab99b", "author": {"user": {"login": "a7ehuo", "name": "Annabelle Huo"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/355e705e05cb13624cb8373ff3510e43065ab99b", "committedDate": "2020-03-10T14:25:43Z", "message": "Support Known Object Table at the server\n\nTwo main issues to consider when supporting KOT at the server:\n1) Prevent the object pointer from being dereferenced directly at the\n   server since it requires the VM access.\n2) The known object table is created at the client and the server. Some\n   operations might cause the KOT to be updated directly at the client\n   without going through the server first. Need to make sure the tables at\n   the client and the server in sync.\n\nMajor changes include:\n- Add KnownObjectTable::updateKnownObjectTableAtServer() which is used to\n  update KOT at the server.\n- Replace the direct dereference of getPointerLocation() with\n  getPointer(). When getPointer() is called at the server, it sends a\n  message to the client to dereference it with the proper VM access.\n- Send messages to the client to dereference the object pointer or\n  when retrieving the index if getIndex() is called.\n\nAlthough there are a few places the known object pointers are\ndereferenced directly, it wouldn\u2019t cause a problem if the critical\nsection is created with VMAccessCriticalSection::tryToAcquireVMAccess,\nbecause at the server the VM access will not be granted.\n\nTODOs:\n- Rename getIndex() with a name that reflects this method could\n  also create a new reference which ends up increasing the size of KOT.\n- Implement KnownObjectTable::dumpTo() and\n  KnownObjectTable::dumpObjectTo() at the server.\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "614ef58ead334a10d8ebfed3fc07e47551dbf538", "author": {"user": {"login": "a7ehuo", "name": "Annabelle Huo"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/614ef58ead334a10d8ebfed3fc07e47551dbf538", "committedDate": "2020-03-09T19:26:20Z", "message": "Support Known Object Table at the server\n\nTwo main issues to consider when supporting KOT at the server:\n1) Prevent the object pointer from being dereferenced directly at the\n   server since it requires the VM access.\n2) The known object table is created at the client and the server. Some\n   operations might cause the KOT to be updated directly at the client\n   without going through the server first. Need to make sure the tables at\n   the client and the server in sync.\n\nMajor changes include:\n- Add KnownObjectTable::updateKnownObjectTableAtServer() which is used to\n  update KOT at the server.\n- Replace the direct dereference of getPointerLocation() with\n  getPointer(). When getPointer() is called at the server, it sends a\n  message to the client to dereference it with the proper VM access.\n- Send messages to the client to dereference the object pointer or\n  when retrieving the index if getIndex() is called.\n\nAlthough there are a few places the known object pointers are\ndereferenced directly, it wouldn\u2019t cause a problem if the critical\nsection is created with VMAccessCriticalSection::tryToAcquireVMAccess,\nbecause at the server the VM access will not be granted.\n\nTODOs:\n- Rename getIndex() with a name that reflects this method could\n  also create a new reference which ends up increasing the size of KOT.\n- Implement KnownObjectTable::dumpTo() and\n  KnownObjectTable::dumpObjectTo() at the server.\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>"}, "afterCommit": {"oid": "355e705e05cb13624cb8373ff3510e43065ab99b", "author": {"user": {"login": "a7ehuo", "name": "Annabelle Huo"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/355e705e05cb13624cb8373ff3510e43065ab99b", "committedDate": "2020-03-10T14:25:43Z", "message": "Support Known Object Table at the server\n\nTwo main issues to consider when supporting KOT at the server:\n1) Prevent the object pointer from being dereferenced directly at the\n   server since it requires the VM access.\n2) The known object table is created at the client and the server. Some\n   operations might cause the KOT to be updated directly at the client\n   without going through the server first. Need to make sure the tables at\n   the client and the server in sync.\n\nMajor changes include:\n- Add KnownObjectTable::updateKnownObjectTableAtServer() which is used to\n  update KOT at the server.\n- Replace the direct dereference of getPointerLocation() with\n  getPointer(). When getPointer() is called at the server, it sends a\n  message to the client to dereference it with the proper VM access.\n- Send messages to the client to dereference the object pointer or\n  when retrieving the index if getIndex() is called.\n\nAlthough there are a few places the known object pointers are\ndereferenced directly, it wouldn\u2019t cause a problem if the critical\nsection is created with VMAccessCriticalSection::tryToAcquireVMAccess,\nbecause at the server the VM access will not be granted.\n\nTODOs:\n- Rename getIndex() with a name that reflects this method could\n  also create a new reference which ends up increasing the size of KOT.\n- Implement KnownObjectTable::dumpTo() and\n  KnownObjectTable::dumpObjectTo() at the server.\n\nSigned-off-by: Annabelle Huo <Annabelle.Huo@ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcyMjk1MDgx", "url": "https://github.com/eclipse-openj9/openj9/pull/8527#pullrequestreview-372295081", "createdAt": "2020-03-10T20:25:31Z", "commit": {"oid": "355e705e05cb13624cb8373ff3510e43065ab99b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 774, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}