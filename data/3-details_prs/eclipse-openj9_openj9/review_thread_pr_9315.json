{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA3MDQ4NDk2", "number": 9315, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxODozMDoyNVrOD054dg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQyMDowMDo0MVrOD08bkw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2ODAwODg2OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/runtime/JITClientSession.hpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxODozMDoyNVrOGKE-oA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwMzoyNjoyNFrOGKU5AQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzIyMDUxMg==", "bodyText": "Incomplete comment.", "url": "https://github.com/eclipse-openj9/openj9/pull/9315#discussion_r413220512", "createdAt": "2020-04-22T18:30:25Z", "author": {"login": "ymanton"}, "path": "runtime/compiler/runtime/JITClientSession.hpp", "diffHunk": "@@ -346,14 +347,17 @@ class ClientSessionData\n    PersistentUnorderedMap<ClassLoaderStringPair, TR_OpaqueClassBlock*> & getClassByNameMap() { return _classByNameMap; }\n    PersistentUnorderedMap<J9Class *, UDATA *> & getClassChainDataCache() { return _classChainDataMap; }\n    PersistentUnorderedMap<J9ConstantPool *, TR_OpaqueClassBlock*> & getConstantPoolToClassMap() { return _constantPoolToClassMap; }\n-   void processUnloadedClasses(JITServer::ServerStream *stream, const std::vector<TR_OpaqueClassBlock*> &classes);\n+   void initializeUnloadedClassAddrRanges(const std::vector<TR_AddressRange> &unloadedClassRanges, int32_t maxRanges);\n+   void processUnloadedClasses(const std::vector<TR_OpaqueClassBlock*> &classes, bool updateUnloadedClasses);\n    TR::Monitor *getROMMapMonitor() { return _romMapMonitor; }\n    TR::Monitor *getClassMapMonitor() { return _classMapMonitor; }\n    TR::Monitor *getClassChainDataMapMonitor() { return _classChainDataMapMonitor; }\n    TR_IPBytecodeHashTableEntry *getCachedIProfilerInfo(TR_OpaqueMethodBlock *method, uint32_t byteCodeIndex, bool *methodInfoPresent);\n    bool cacheIProfilerInfo(TR_OpaqueMethodBlock *method, uint32_t byteCodeIndex, TR_IPBytecodeHashTableEntry *entry, bool isCompiled);\n    VMInfo *getOrCacheVMInfo(JITServer::ServerStream *stream);\n-   void clearCaches(); // destroys _chTableClassMap, _romClassMap and _J9MethodMap\n+   void clearCaches(); // destroys _chTableClassMap, _romClassMap and _J9MethodMap and ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87df459cb235103b300c6c8b41df6a4c3abf96a1"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQ4MTIxNw==", "bodyText": "Fixed", "url": "https://github.com/eclipse-openj9/openj9/pull/9315#discussion_r413481217", "createdAt": "2020-04-23T03:26:24Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/runtime/JITClientSession.hpp", "diffHunk": "@@ -346,14 +347,17 @@ class ClientSessionData\n    PersistentUnorderedMap<ClassLoaderStringPair, TR_OpaqueClassBlock*> & getClassByNameMap() { return _classByNameMap; }\n    PersistentUnorderedMap<J9Class *, UDATA *> & getClassChainDataCache() { return _classChainDataMap; }\n    PersistentUnorderedMap<J9ConstantPool *, TR_OpaqueClassBlock*> & getConstantPoolToClassMap() { return _constantPoolToClassMap; }\n-   void processUnloadedClasses(JITServer::ServerStream *stream, const std::vector<TR_OpaqueClassBlock*> &classes);\n+   void initializeUnloadedClassAddrRanges(const std::vector<TR_AddressRange> &unloadedClassRanges, int32_t maxRanges);\n+   void processUnloadedClasses(const std::vector<TR_OpaqueClassBlock*> &classes, bool updateUnloadedClasses);\n    TR::Monitor *getROMMapMonitor() { return _romMapMonitor; }\n    TR::Monitor *getClassMapMonitor() { return _classMapMonitor; }\n    TR::Monitor *getClassChainDataMapMonitor() { return _classChainDataMapMonitor; }\n    TR_IPBytecodeHashTableEntry *getCachedIProfilerInfo(TR_OpaqueMethodBlock *method, uint32_t byteCodeIndex, bool *methodInfoPresent);\n    bool cacheIProfilerInfo(TR_OpaqueMethodBlock *method, uint32_t byteCodeIndex, TR_IPBytecodeHashTableEntry *entry, bool isCompiled);\n    VMInfo *getOrCacheVMInfo(JITServer::ServerStream *stream);\n-   void clearCaches(); // destroys _chTableClassMap, _romClassMap and _J9MethodMap\n+   void clearCaches(); // destroys _chTableClassMap, _romClassMap and _J9MethodMap and ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzIyMDUxMg=="}, "originalCommit": {"oid": "87df459cb235103b300c6c8b41df6a4c3abf96a1"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2ODQyMTAxOnYy", "diffSide": "RIGHT", "path": "runtime/compiler/control/JITServerCompilationThread.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxOTo1OTozM1rOGKI7mA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwMzoyNjozNVrOGKU5Lw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzI4NTI3Mg==", "bodyText": "Can we add a comment to explain the false? e.g.\n// This function updates multiple caches based on the newly unloaded classes list. Pass false here to indicate\n// that we want the unloaded class ranges table cache excluded since we just retrieved the entire table and it\n// should therefore already be up to date.", "url": "https://github.com/eclipse-openj9/openj9/pull/9315#discussion_r413285272", "createdAt": "2020-04-22T19:59:33Z", "author": {"login": "ymanton"}, "path": "runtime/compiler/control/JITServerCompilationThread.cpp", "diffHunk": "@@ -373,29 +375,56 @@ TR::CompilationInfoPerThreadRemote::processEntry(TR_MethodToBeCompiled &entry, J\n       clientSession->getSequencingMonitor()->exit();\n \n       // At this point I know that all preceeding requests have been processed\n-      // Free data for all classes that were unloaded for this sequence number\n-      // Redefined classes are marked as unloaded, since they need to be cleared\n-      // from the ROM class cache.\n-      clientSession->processUnloadedClasses(stream, unloadedClasses); // this locks getROMMapMonitor()\n-\n-      auto chTable = (JITServerPersistentCHTable*)compInfo->getPersistentInfo()->getPersistentCHTable();\n-      // TODO: is chTable always non-null?\n-      // TODO: we could send JVM info that is global and does not change together with CHTable\n-      // The following will acquire CHTable monitor and VMAccess, send a message and then release them\n-      bool initialized = chTable->initializeIfNeeded(_vm);\n-\n-      // A thread that initialized the CHTable does not have to apply the incremental update\n-      if (!initialized)\n+      // and only thread can ever be present in this section\n+      if (!clientSession->cachesAreCleared())\n          {\n+         // Free data for all classes that were unloaded for this sequence number\n+         // Redefined classes are marked as unloaded, since they need to be cleared\n+         // from the ROM class cache.\n+         if (unloadedClasses.empty())\n+            {\n+            if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+               TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"compThreadID=%d has no class to unload for clientUID %llu\", \n+                  getCompThreadId(), (unsigned long long)clientId);\n+            }\n+          else\n+            {\n+            clientSession->processUnloadedClasses(unloadedClasses, true); // this locks getROMMapMonitor()\n+            }\n+\n          // Process the CHTable updates in order\n-         stream->write(JITServer::MessageType::CHTable_getClassInfoUpdates, JITServer::Void());\n-         auto recv = stream->read<std::string, std::string>();\n-         const std::string &chtableUnloads = std::get<0>(recv);\n-         const std::string &chtableMods = std::get<1>(recv);\n          // Note that applying the updates will acquire the CHTable monitor and VMAccess\n+         auto chTable = (JITServerPersistentCHTable*)compInfo->getPersistentInfo()->getPersistentCHTable();\n+         TR_ASSERT_FATAL(chTable->isInitialized() || (chtableUnloads.empty() && chtableMods.empty()), \n+                         \"CHTable must have been initialized for clientUID=%llu\", (unsigned long long)clientId);\n          if (!chtableUnloads.empty() || !chtableMods.empty())\n             chTable->doUpdate(_vm, chtableUnloads, chtableMods);\n          }\n+      else // Internal caches are empty\n+         {\n+         if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+            TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"compThreadID=%d will ask for address ranges of unloaded classes and CHTable for clientUID %llu\", \n+               getCompThreadId(), (unsigned long long)clientId);\n+         stream->write(JITServer::MessageType::getUnloadedClassRanges, JITServer::Void());\n+         auto response = stream->read<std::vector<TR_AddressRange>, int32_t, std::string>();\n+         // TODO: we could send JVM info that is global and does not change together with CHTable\n+         auto &unloadedClassRanges = std::get<0>(response);\n+         auto maxRanges = std::get<1>(response);\n+         std::string &serializedCHTable = std::get<2>(response);\n+\n+         clientSession->initializeUnloadedClassAddrRanges(unloadedClassRanges, maxRanges);\n+         if (!unloadedClasses.empty())\n+            clientSession->processUnloadedClasses(unloadedClasses, false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87df459cb235103b300c6c8b41df6a4c3abf96a1"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQ4MTI2Mw==", "bodyText": "Added", "url": "https://github.com/eclipse-openj9/openj9/pull/9315#discussion_r413481263", "createdAt": "2020-04-23T03:26:35Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/control/JITServerCompilationThread.cpp", "diffHunk": "@@ -373,29 +375,56 @@ TR::CompilationInfoPerThreadRemote::processEntry(TR_MethodToBeCompiled &entry, J\n       clientSession->getSequencingMonitor()->exit();\n \n       // At this point I know that all preceeding requests have been processed\n-      // Free data for all classes that were unloaded for this sequence number\n-      // Redefined classes are marked as unloaded, since they need to be cleared\n-      // from the ROM class cache.\n-      clientSession->processUnloadedClasses(stream, unloadedClasses); // this locks getROMMapMonitor()\n-\n-      auto chTable = (JITServerPersistentCHTable*)compInfo->getPersistentInfo()->getPersistentCHTable();\n-      // TODO: is chTable always non-null?\n-      // TODO: we could send JVM info that is global and does not change together with CHTable\n-      // The following will acquire CHTable monitor and VMAccess, send a message and then release them\n-      bool initialized = chTable->initializeIfNeeded(_vm);\n-\n-      // A thread that initialized the CHTable does not have to apply the incremental update\n-      if (!initialized)\n+      // and only thread can ever be present in this section\n+      if (!clientSession->cachesAreCleared())\n          {\n+         // Free data for all classes that were unloaded for this sequence number\n+         // Redefined classes are marked as unloaded, since they need to be cleared\n+         // from the ROM class cache.\n+         if (unloadedClasses.empty())\n+            {\n+            if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+               TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"compThreadID=%d has no class to unload for clientUID %llu\", \n+                  getCompThreadId(), (unsigned long long)clientId);\n+            }\n+          else\n+            {\n+            clientSession->processUnloadedClasses(unloadedClasses, true); // this locks getROMMapMonitor()\n+            }\n+\n          // Process the CHTable updates in order\n-         stream->write(JITServer::MessageType::CHTable_getClassInfoUpdates, JITServer::Void());\n-         auto recv = stream->read<std::string, std::string>();\n-         const std::string &chtableUnloads = std::get<0>(recv);\n-         const std::string &chtableMods = std::get<1>(recv);\n          // Note that applying the updates will acquire the CHTable monitor and VMAccess\n+         auto chTable = (JITServerPersistentCHTable*)compInfo->getPersistentInfo()->getPersistentCHTable();\n+         TR_ASSERT_FATAL(chTable->isInitialized() || (chtableUnloads.empty() && chtableMods.empty()), \n+                         \"CHTable must have been initialized for clientUID=%llu\", (unsigned long long)clientId);\n          if (!chtableUnloads.empty() || !chtableMods.empty())\n             chTable->doUpdate(_vm, chtableUnloads, chtableMods);\n          }\n+      else // Internal caches are empty\n+         {\n+         if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+            TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"compThreadID=%d will ask for address ranges of unloaded classes and CHTable for clientUID %llu\", \n+               getCompThreadId(), (unsigned long long)clientId);\n+         stream->write(JITServer::MessageType::getUnloadedClassRanges, JITServer::Void());\n+         auto response = stream->read<std::vector<TR_AddressRange>, int32_t, std::string>();\n+         // TODO: we could send JVM info that is global and does not change together with CHTable\n+         auto &unloadedClassRanges = std::get<0>(response);\n+         auto maxRanges = std::get<1>(response);\n+         std::string &serializedCHTable = std::get<2>(response);\n+\n+         clientSession->initializeUnloadedClassAddrRanges(unloadedClassRanges, maxRanges);\n+         if (!unloadedClasses.empty())\n+            clientSession->processUnloadedClasses(unloadedClasses, false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzI4NTI3Mg=="}, "originalCommit": {"oid": "87df459cb235103b300c6c8b41df6a4c3abf96a1"}, "originalPosition": 101}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2ODQyNjQzOnYy", "diffSide": "RIGHT", "path": "runtime/compiler/control/JITClientCompilationThread.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQyMDowMDo0MVrOGKI_FQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwMzoyNjo0NlrOGKU5cw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzI4NjE2NQ==", "bodyText": "Can we change the message name to getUnloadedClassRangesAndCHTable or something like that? It would make the rest of the code a little clearer.", "url": "https://github.com/eclipse-openj9/openj9/pull/9315#discussion_r413286165", "createdAt": "2020-04-22T20:00:41Z", "author": {"login": "ymanton"}, "path": "runtime/compiler/control/JITClientCompilationThread.cpp", "diffHunk": "@@ -209,7 +209,11 @@ handleServerMessage(JITServer::ClientStream *client, TR_J9VM *fe, JITServer::Mes\n             OMR::CriticalSection getAddressSetRanges(assumptionTableMutex);\n             unloadedClasses->getRanges(ranges);\n             }\n-         client->write(response, ranges, unloadedClasses->getMaxRanges());\n+         // Add the entire CHTable as well\n+         auto table = (JITClientPersistentCHTable*)comp->getPersistentInfo()->getPersistentCHTable();\n+         std::string encoded = FlatPersistentClassInfo::serializeHierarchy(table);\n+\n+         client->write(response, ranges, unloadedClasses->getMaxRanges(), encoded);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87df459cb235103b300c6c8b41df6a4c3abf96a1"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQ4MTMzMQ==", "bodyText": "Done", "url": "https://github.com/eclipse-openj9/openj9/pull/9315#discussion_r413481331", "createdAt": "2020-04-23T03:26:46Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/control/JITClientCompilationThread.cpp", "diffHunk": "@@ -209,7 +209,11 @@ handleServerMessage(JITServer::ClientStream *client, TR_J9VM *fe, JITServer::Mes\n             OMR::CriticalSection getAddressSetRanges(assumptionTableMutex);\n             unloadedClasses->getRanges(ranges);\n             }\n-         client->write(response, ranges, unloadedClasses->getMaxRanges());\n+         // Add the entire CHTable as well\n+         auto table = (JITClientPersistentCHTable*)comp->getPersistentInfo()->getPersistentCHTable();\n+         std::string encoded = FlatPersistentClassInfo::serializeHierarchy(table);\n+\n+         client->write(response, ranges, unloadedClasses->getMaxRanges(), encoded);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzI4NjE2NQ=="}, "originalCommit": {"oid": "87df459cb235103b300c6c8b41df6a4c3abf96a1"}, "originalPosition": 9}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 225, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}