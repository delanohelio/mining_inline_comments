{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM5NDUyMzcx", "number": 10008, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxNzoxMTozNlrOEJwMyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxNzoxMzo1M1rOEJwPtA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4NjYyMzQ2OnYy", "diffSide": "RIGHT", "path": "runtime/jvmti/jvmtiClass.c", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxNzoxMTozNlrOGqaX2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxNzoxOTowN1rOGqaobw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzEyNTQ2NQ==", "bodyText": "Can you cache the vm->internalVMFunctions table in a local?  A minor thing but might be a small benefit for deep array chains...", "url": "https://github.com/eclipse-openj9/openj9/pull/10008#discussion_r447125465", "createdAt": "2020-06-29T17:11:36Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jvmti/jvmtiClass.c", "diffHunk": "@@ -1367,15 +1381,20 @@ copyInitiatedClass(J9Class * clazz, J9JVMTIClassStats * results)\n \n \t\tJ9JavaVM * vm = results->vm;\n \t\tJNIEnv * jniEnv = (JNIEnv *)results->currentThread;\n-\t\tjint slot = (jint)results->classCount - 1;\n-\n-\t\t/* Reverse fill */\n-\t\tif (slot >= 0) {\n-\t\t\tj9object_t classObject = J9VM_J9CLASS_TO_HEAPCLASS(clazz);\n-\t\t\t\n-\t\t\tresults->classRefs[slot] = (jclass)vm->internalVMFunctions->j9jni_createLocalRef(jniEnv, classObject);\n-\t\t\tresults->classCount = slot;\n-\t\t}\n+\n+\t\tdo {\n+\t\t\tjint slot = (jint)results->classCount - 1;\n+\n+\t\t\t/* Reverse fill */\n+\t\t\tif (slot >= 0) {\n+\t\t\t\tj9object_t classObject = J9VM_J9CLASS_TO_HEAPCLASS(clazz);\n+\t\t\t\t\n+\t\t\t\tresults->classRefs[slot] = (jclass)vm->internalVMFunctions->j9jni_createLocalRef(jniEnv, classObject);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b345ea88c3b430b1ece478f2c886ac0a1d678b93"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzEyOTcxMQ==", "bodyText": "Done.", "url": "https://github.com/eclipse-openj9/openj9/pull/10008#discussion_r447129711", "createdAt": "2020-06-29T17:19:07Z", "author": {"login": "gacholio"}, "path": "runtime/jvmti/jvmtiClass.c", "diffHunk": "@@ -1367,15 +1381,20 @@ copyInitiatedClass(J9Class * clazz, J9JVMTIClassStats * results)\n \n \t\tJ9JavaVM * vm = results->vm;\n \t\tJNIEnv * jniEnv = (JNIEnv *)results->currentThread;\n-\t\tjint slot = (jint)results->classCount - 1;\n-\n-\t\t/* Reverse fill */\n-\t\tif (slot >= 0) {\n-\t\t\tj9object_t classObject = J9VM_J9CLASS_TO_HEAPCLASS(clazz);\n-\t\t\t\n-\t\t\tresults->classRefs[slot] = (jclass)vm->internalVMFunctions->j9jni_createLocalRef(jniEnv, classObject);\n-\t\t\tresults->classCount = slot;\n-\t\t}\n+\n+\t\tdo {\n+\t\t\tjint slot = (jint)results->classCount - 1;\n+\n+\t\t\t/* Reverse fill */\n+\t\t\tif (slot >= 0) {\n+\t\t\t\tj9object_t classObject = J9VM_J9CLASS_TO_HEAPCLASS(clazz);\n+\t\t\t\t\n+\t\t\t\tresults->classRefs[slot] = (jclass)vm->internalVMFunctions->j9jni_createLocalRef(jniEnv, classObject);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzEyNTQ2NQ=="}, "originalCommit": {"oid": "b345ea88c3b430b1ece478f2c886ac0a1d678b93"}, "originalPosition": 123}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4NjYzMDkyOnYy", "diffSide": "RIGHT", "path": "runtime/jvmti/jvmtiClass.c", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxNzoxMzo1M1rOGqackQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxNzoxOToxNVrOGqaoww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzEyNjY3Mw==", "bodyText": "I think we've been leaning towards retiring the use of ++ for non-primitive indexes and preferring an explicit  += 1.", "url": "https://github.com/eclipse-openj9/openj9/pull/10008#discussion_r447126673", "createdAt": "2020-06-29T17:13:53Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jvmti/jvmtiClass.c", "diffHunk": "@@ -237,39 +239,48 @@ jvmtiGetClassLoaderClasses(jvmtiEnv* env,\n \n \t\tomrthread_monitor_enter(vm->classTableMutex);\n \n-\t\tmemset(&stats, 0, sizeof(J9JVMTIClassStats));\n-\n \t\tstats.vm = vm;\n \t\tstats.currentThread = currentThread;\n \n \t\t/* Search for classes who have this class loader as the initiating loader (wind up count) */\n-\t\tclazz = vm->internalVMFunctions->hashClassTableStartDo(loader, &walkState);\n+\t\tclazz = vmFuncs->hashClassTableStartDo(loader, &hashWalkState);\n \t\twhile (clazz != NULL) {\n \t\t\tcountInitiatedClass(clazz, &stats);\n-\t\t\tclazz = vm->internalVMFunctions->hashClassTableNextDo(&walkState);\n+\t\t\tclazz = vmFuncs->hashClassTableNextDo(&hashWalkState);\n \t\t}\n \n+\t\t/* The base type primitive array classes must also be added */\n+\t\tprimitiveArray = &vm->booleanArrayClass;\n+\t\tdo {\n+\t\t\tcountInitiatedClass(*primitiveArray++, &stats);\t\t\t\n+\t\t} while (primitiveArray <= &vm->longArrayClass);\n+\n \t\tstats.classRefs = j9mem_allocate_memory(stats.classCount * sizeof(jclass), J9MEM_CATEGORY_JVMTI_ALLOCATE);\n \t\tif (stats.classRefs == NULL) {\n \t\t\trc = JVMTI_ERROR_OUT_OF_MEMORY;\n \t\t} else {\n-\n \t\t\t/* Save count before it gets modified below... */\n \t\t\trv_class_count = (jint) stats.classCount;\n \t\t\trv_classes = stats.classRefs;\n \n \t\t\t/* Record classes who have this class loader as the initiating loader (wind down count) */\n-\t\t\tclazz = vm->internalVMFunctions->hashClassTableStartDo(loader, &walkState);\n+\t\t\tclazz = vmFuncs->hashClassTableStartDo(loader, &hashWalkState);\n \t\t\twhile (clazz != NULL) {\n \t\t\t\tcopyInitiatedClass(clazz, &stats);\n-\t\t\t\tclazz = vm->internalVMFunctions->hashClassTableNextDo(&walkState);\n+\t\t\t\tclazz = vmFuncs->hashClassTableNextDo(&hashWalkState);\n \t\t\t}\n+\n+\t\t\t/* The base type primitive array classes must also be added */\n+\t\t\tprimitiveArray = &vm->booleanArrayClass;\n+\t\t\tdo {\n+\t\t\t\tcopyInitiatedClass(*primitiveArray++, &stats);\t\t\t", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b345ea88c3b430b1ece478f2c886ac0a1d678b93"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzEyOTc5NQ==", "bodyText": "Done.", "url": "https://github.com/eclipse-openj9/openj9/pull/10008#discussion_r447129795", "createdAt": "2020-06-29T17:19:15Z", "author": {"login": "gacholio"}, "path": "runtime/jvmti/jvmtiClass.c", "diffHunk": "@@ -237,39 +239,48 @@ jvmtiGetClassLoaderClasses(jvmtiEnv* env,\n \n \t\tomrthread_monitor_enter(vm->classTableMutex);\n \n-\t\tmemset(&stats, 0, sizeof(J9JVMTIClassStats));\n-\n \t\tstats.vm = vm;\n \t\tstats.currentThread = currentThread;\n \n \t\t/* Search for classes who have this class loader as the initiating loader (wind up count) */\n-\t\tclazz = vm->internalVMFunctions->hashClassTableStartDo(loader, &walkState);\n+\t\tclazz = vmFuncs->hashClassTableStartDo(loader, &hashWalkState);\n \t\twhile (clazz != NULL) {\n \t\t\tcountInitiatedClass(clazz, &stats);\n-\t\t\tclazz = vm->internalVMFunctions->hashClassTableNextDo(&walkState);\n+\t\t\tclazz = vmFuncs->hashClassTableNextDo(&hashWalkState);\n \t\t}\n \n+\t\t/* The base type primitive array classes must also be added */\n+\t\tprimitiveArray = &vm->booleanArrayClass;\n+\t\tdo {\n+\t\t\tcountInitiatedClass(*primitiveArray++, &stats);\t\t\t\n+\t\t} while (primitiveArray <= &vm->longArrayClass);\n+\n \t\tstats.classRefs = j9mem_allocate_memory(stats.classCount * sizeof(jclass), J9MEM_CATEGORY_JVMTI_ALLOCATE);\n \t\tif (stats.classRefs == NULL) {\n \t\t\trc = JVMTI_ERROR_OUT_OF_MEMORY;\n \t\t} else {\n-\n \t\t\t/* Save count before it gets modified below... */\n \t\t\trv_class_count = (jint) stats.classCount;\n \t\t\trv_classes = stats.classRefs;\n \n \t\t\t/* Record classes who have this class loader as the initiating loader (wind down count) */\n-\t\t\tclazz = vm->internalVMFunctions->hashClassTableStartDo(loader, &walkState);\n+\t\t\tclazz = vmFuncs->hashClassTableStartDo(loader, &hashWalkState);\n \t\t\twhile (clazz != NULL) {\n \t\t\t\tcopyInitiatedClass(clazz, &stats);\n-\t\t\t\tclazz = vm->internalVMFunctions->hashClassTableNextDo(&walkState);\n+\t\t\t\tclazz = vmFuncs->hashClassTableNextDo(&hashWalkState);\n \t\t\t}\n+\n+\t\t\t/* The base type primitive array classes must also be added */\n+\t\t\tprimitiveArray = &vm->booleanArrayClass;\n+\t\t\tdo {\n+\t\t\t\tcopyInitiatedClass(*primitiveArray++, &stats);\t\t\t", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzEyNjY3Mw=="}, "originalCommit": {"oid": "b345ea88c3b430b1ece478f2c886ac0a1d678b93"}, "originalPosition": 78}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4865, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}