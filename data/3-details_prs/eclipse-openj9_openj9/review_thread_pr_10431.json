{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDcxMDkxNjYy", "number": 10431, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxNDo1NTo0MVrOEbm_-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQyMjo1MDozNFrOEcShew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3Mzg1OTc5OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/env/VMJ9Server.cpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxNDo1NTo0MVrOHFo1Ig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxNDo1NTo0MVrOHFo1Ig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTY3Mzg5MA==", "bodyText": "Why don't we add methodClassLoader in this case?", "url": "https://github.com/eclipse-openj9/openj9/pull/10431#discussion_r475673890", "createdAt": "2020-08-24T14:55:41Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/env/VMJ9Server.cpp", "diffHunk": "@@ -299,19 +299,64 @@ TR_J9ServerVM::getClassFromSignature(const char *sig, int32_t length, TR_Resolve\n    TR_OpaqueClassBlock * clazz = NULL;\n    J9ClassLoader * cl = ((TR_ResolvedJ9Method *)method)->getClassLoader();\n    ClassLoaderStringPair key = {cl, std::string(sig, length)};\n-   PersistentUnorderedMap<ClassLoaderStringPair, TR_OpaqueClassBlock*> & classBySignatureMap = _compInfoPT->getClientData()->getClassBySignatureMap();\n+   PersistentUnorderedMap<ClassLoaderStringPair, ClassFromSignatureData> &classBySignatureMap = _compInfoPT->getClientData()->getClassBySignatureMap();\n       {\n       OMR::CriticalSection classFromSigCS(_compInfoPT->getClientData()->getClassMapMonitor());\n       auto it = classBySignatureMap.find(key);\n       if (it != classBySignatureMap.end())\n-         return it->second;\n+         clazz = it->second._clazz;\n+\n+      if (!clazz)\n+         {\n+         key._classLoader = reinterpret_cast<J9ClassLoader *>(getSystemClassLoader());\n+         it = classBySignatureMap.find(key);\n+         if (it != classBySignatureMap.end())\n+            {\n+            // if this class loader previously referenced system class loader, we can return safely\n+            if (it->second.isClassLoaderVisible(cl))\n+               clazz = it->second._clazz;\n+            }\n+         }\n+      }\n+   if (clazz)\n+      {\n+#if defined(DEBUG)\n+      // make sure the cached class matches the client class\n+      TR_OpaqueClassBlock *clientClass = getClassFromSignature(sig, length, (TR_OpaqueMethodBlock *)method->getPersistentIdentifier(), isVettedForAOT);\n+      TR_ASSERT_FATAL(clientClass == clazz, \"Client and cached classes do not match: clientClass=%p cachedClass=%p\\n\", clientClass, clazz);\n+#endif\n+      return clazz;\n       }\n    // classname not found; ask the client and cache the answer\n    clazz = getClassFromSignature(sig, length, (TR_OpaqueMethodBlock *)method->getPersistentIdentifier(), isVettedForAOT);\n+   return clazz;\n+   }\n+\n+\n+TR_OpaqueClassBlock *\n+TR_J9ServerVM::getClassFromSignature(const char *sig, int32_t length, TR_OpaqueMethodBlock *method, bool isVettedForAOT)\n+   {\n+   JITServer::ServerStream *stream = _compInfoPT->getMethodBeingCompiled()->_stream;\n+   std::string str(sig, length);\n+   stream->write(JITServer::MessageType::VM_getClassFromSignature, str, method, isVettedForAOT);\n+   auto recv = stream->read<TR_OpaqueClassBlock *, J9ClassLoader *, J9ClassLoader *>();\n+   TR_OpaqueClassBlock *clazz = std::get<0>(recv);\n+   J9ClassLoader *cl = std::get<1>(recv);\n+   J9ClassLoader *methodClassLoader = std::get<2>(recv);\n    if (clazz)\n       {\n       OMR::CriticalSection classFromSigCS(_compInfoPT->getClientData()->getClassMapMonitor());\n-      classBySignatureMap[key] = clazz;\n+      PersistentUnorderedMap<ClassLoaderStringPair, ClassFromSignatureData> &classBySignatureMap = _compInfoPT->getClientData()->getClassBySignatureMap();\n+      ClassLoaderStringPair key = {cl, std::string(sig, length)};\n+      auto it = classBySignatureMap.find(key);\n+      if (it != classBySignatureMap.end())\n+         {\n+         // if we are here, that means the current class loader hasn't been encountered yet\n+         it->second.addClassLoader(methodClassLoader);\n+         TR_ASSERT_FATAL(clazz == it->second._clazz, \"Cached and client answers do not match: cached=%p client=%p\\n\", it->second._clazz, clazz);\n+         return it->second._clazz;\n+         }\n+      classBySignatureMap.insert({ key, ClassFromSignatureData(clazz) });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de5194d1d31c91b6f64e0ddab4784e36d4619267"}, "originalPosition": 89}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3MzkxOTIzOnYy", "diffSide": "RIGHT", "path": "runtime/compiler/env/VMJ9Server.cpp", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxNTowNDozNVrOHFpcIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxNjoxNTowMVrOHFsUow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTY4Mzg3Mw==", "bodyText": "Is it possible to have a NULL cached clazz? If not, then we don't need another test, but rather add an else statement to if (it != classBySignatureMap.end())", "url": "https://github.com/eclipse-openj9/openj9/pull/10431#discussion_r475683873", "createdAt": "2020-08-24T15:04:35Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/env/VMJ9Server.cpp", "diffHunk": "@@ -299,19 +299,64 @@ TR_J9ServerVM::getClassFromSignature(const char *sig, int32_t length, TR_Resolve\n    TR_OpaqueClassBlock * clazz = NULL;\n    J9ClassLoader * cl = ((TR_ResolvedJ9Method *)method)->getClassLoader();\n    ClassLoaderStringPair key = {cl, std::string(sig, length)};\n-   PersistentUnorderedMap<ClassLoaderStringPair, TR_OpaqueClassBlock*> & classBySignatureMap = _compInfoPT->getClientData()->getClassBySignatureMap();\n+   PersistentUnorderedMap<ClassLoaderStringPair, ClassFromSignatureData> &classBySignatureMap = _compInfoPT->getClientData()->getClassBySignatureMap();\n       {\n       OMR::CriticalSection classFromSigCS(_compInfoPT->getClientData()->getClassMapMonitor());\n       auto it = classBySignatureMap.find(key);\n       if (it != classBySignatureMap.end())\n-         return it->second;\n+         clazz = it->second._clazz;\n+\n+      if (!clazz)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de5194d1d31c91b6f64e0ddab4784e36d4619267"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTczMTEwNw==", "bodyText": "True, will fix.", "url": "https://github.com/eclipse-openj9/openj9/pull/10431#discussion_r475731107", "createdAt": "2020-08-24T16:15:01Z", "author": {"login": "dmitry-ten"}, "path": "runtime/compiler/env/VMJ9Server.cpp", "diffHunk": "@@ -299,19 +299,64 @@ TR_J9ServerVM::getClassFromSignature(const char *sig, int32_t length, TR_Resolve\n    TR_OpaqueClassBlock * clazz = NULL;\n    J9ClassLoader * cl = ((TR_ResolvedJ9Method *)method)->getClassLoader();\n    ClassLoaderStringPair key = {cl, std::string(sig, length)};\n-   PersistentUnorderedMap<ClassLoaderStringPair, TR_OpaqueClassBlock*> & classBySignatureMap = _compInfoPT->getClientData()->getClassBySignatureMap();\n+   PersistentUnorderedMap<ClassLoaderStringPair, ClassFromSignatureData> &classBySignatureMap = _compInfoPT->getClientData()->getClassBySignatureMap();\n       {\n       OMR::CriticalSection classFromSigCS(_compInfoPT->getClientData()->getClassMapMonitor());\n       auto it = classBySignatureMap.find(key);\n       if (it != classBySignatureMap.end())\n-         return it->second;\n+         clazz = it->second._clazz;\n+\n+      if (!clazz)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTY4Mzg3Mw=="}, "originalCommit": {"oid": "de5194d1d31c91b6f64e0ddab4784e36d4619267"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4MDk5MDY3OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/env/VMJ9Server.cpp", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQyMjo1MDozNFrOHGukUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxNDo1OTo1NVrOHHQUNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjgxNjQ2Nw==", "bodyText": "This is a typo: == needs to become !=", "url": "https://github.com/eclipse-openj9/openj9/pull/10431#discussion_r476816467", "createdAt": "2020-08-25T22:50:34Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/env/VMJ9Server.cpp", "diffHunk": "@@ -332,7 +332,26 @@ TR_J9ServerVM::getClassFromSignature(const char *sig, int32_t length, TR_OpaqueM\n    JITServer::ServerStream *stream = _compInfoPT->getMethodBeingCompiled()->_stream;\n    std::string str(sig, length);\n    stream->write(JITServer::MessageType::VM_getClassFromSignature, str, method, isVettedForAOT);\n-   return std::get<0>(stream->read<TR_OpaqueClassBlock *>());\n+   auto recv = stream->read<TR_OpaqueClassBlock *, J9ClassLoader *, J9ClassLoader *>();\n+   TR_OpaqueClassBlock *clazz = std::get<0>(recv);\n+   J9ClassLoader *cl = std::get<1>(recv);\n+   J9ClassLoader *methodClassLoader = std::get<2>(recv);\n+   if (clazz && cl != methodClassLoader)\n+      {\n+      // make sure that the class is cached\n+      J9ROMClass *romClass = TR::Compiler->cls.romClassOf(clazz);\n+      TR_ASSERT_FATAL(romClass, \"class %p could not be cached\", clazz);\n+      OMR::CriticalSection getRemoteROMClass(_compInfoPT->getClientData()->getROMMapMonitor());\n+      auto it = _compInfoPT->getClientData()->getROMClassMap().find(reinterpret_cast<J9Class *>(clazz));\n+      if (it == _compInfoPT->getClientData()->getROMClassMap().end())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fcd2ddbc1cfd52e185d2553c77974bad75bec8b5"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzM2OTM5Nw==", "bodyText": "Fixed.", "url": "https://github.com/eclipse-openj9/openj9/pull/10431#discussion_r477369397", "createdAt": "2020-08-26T14:59:55Z", "author": {"login": "dmitry-ten"}, "path": "runtime/compiler/env/VMJ9Server.cpp", "diffHunk": "@@ -332,7 +332,26 @@ TR_J9ServerVM::getClassFromSignature(const char *sig, int32_t length, TR_OpaqueM\n    JITServer::ServerStream *stream = _compInfoPT->getMethodBeingCompiled()->_stream;\n    std::string str(sig, length);\n    stream->write(JITServer::MessageType::VM_getClassFromSignature, str, method, isVettedForAOT);\n-   return std::get<0>(stream->read<TR_OpaqueClassBlock *>());\n+   auto recv = stream->read<TR_OpaqueClassBlock *, J9ClassLoader *, J9ClassLoader *>();\n+   TR_OpaqueClassBlock *clazz = std::get<0>(recv);\n+   J9ClassLoader *cl = std::get<1>(recv);\n+   J9ClassLoader *methodClassLoader = std::get<2>(recv);\n+   if (clazz && cl != methodClassLoader)\n+      {\n+      // make sure that the class is cached\n+      J9ROMClass *romClass = TR::Compiler->cls.romClassOf(clazz);\n+      TR_ASSERT_FATAL(romClass, \"class %p could not be cached\", clazz);\n+      OMR::CriticalSection getRemoteROMClass(_compInfoPT->getClientData()->getROMMapMonitor());\n+      auto it = _compInfoPT->getClientData()->getROMClassMap().find(reinterpret_cast<J9Class *>(clazz));\n+      if (it == _compInfoPT->getClientData()->getROMClassMap().end())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjgxNjQ2Nw=="}, "originalCommit": {"oid": "fcd2ddbc1cfd52e185d2553c77974bad75bec8b5"}, "originalPosition": 16}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4716, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}