{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE0NzkzMDMz", "number": 11088, "title": "Accelerate two-dimensional new array with second dimension being zero", "bodyText": "This commit adds support for 2-dimensional arrays where the second dimension has length=0 in the multianewarrayEvaluator.\nIssue: #2424\nSigned-off-by: Dhruv Chopra Dhruv.C.Chopra@ibm.com", "createdAt": "2020-11-03T14:59:29Z", "url": "https://github.com/eclipse-openj9/openj9/pull/11088", "merged": true, "mergeCommit": {"oid": "f6fcc177cc1679c3fa7214c2cb1ea834ba318a24"}, "closed": true, "closedAt": "2020-12-01T04:38:59Z", "author": {"login": "dchopra001"}, "timelineItems": {"totalCount": 23, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdZlxgNAFqTUyNDQ1ODI2MQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdhtFyRgFqTU0MTM0NjQyNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI0NDU4MjYx", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#pullrequestreview-524458261", "createdAt": "2020-11-05T16:46:17Z", "commit": {"oid": "7fd870a28386d90aa97661f88b14126e8af243c6"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxNjo0NjoxN1rOHuMVzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxNzoyNToyOFrOHuOAhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODE5ODczMw==", "bodyText": "This trace message needs to be updated to remove the \"DCDC\" (Dhruv Chopra? \ud83d\ude04 ). Also if we're adding it here we should also add it for x86 as well.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r518198733", "createdAt": "2020-11-05T16:46:17Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,339 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n+TR::Node *\n+createOutlinedCallNode(TR::CodeGenerator *cg, TR::Node *callNode, TR::ILOpCodes callOp)\n+   {\n+   int32_t   i;\n+   TR::Node  *child;\n+\n+   TR::Node *newCallNode = TR::Node::createWithSymRef(callNode, callOp, callNode->getNumChildren(), callNode->getSymbolReference());\n+\n+   newCallNode->setReferenceCount(1);\n+\n+   for (i=0; i<callNode->getNumChildren(); i++)\n+      {\n+      child = callNode->getChild(i);\n+\n+      if (child->getRegister() != NULL)\n+         {\n+         // Child has already been evaluated outside this tree.\n+         //\n+         newCallNode->setAndIncChild(i, child);\n+         }\n+      else if (child->getOpCode().isLoadConst())\n+         {\n+         // Copy unevaluated constant nodes.\n+         //\n+         child = TR::Node::copy(child);\n+         child->setReferenceCount(1);\n+         newCallNode->setChild(i, child);\n+         }\n+      else\n+         {\n+         if ((child->getOpCodeValue() == TR::loadaddr) &&\n+             (child->getSymbolReference()->getSymbol()) &&\n+             (child->getSymbolReference()->getSymbol()->getStaticSymbol()))\n+            {\n+            child = TR::Node::copy(child);\n+            child->setReferenceCount(1);\n+            newCallNode->setChild(i, child);\n+            }\n+         else\n+            {\n+            // Be very conservative at this point, even though it is possible to make it less so.  For example, this will catch\n+            // the case of an unevaluated argument not persisting outside of the outlined region even though one of its subtrees will.\n+            (void)cg->evaluate(child);\n+\n+            // Do not decrement the reference count here.  It will be decremented when the call node is evaluated\n+            // again in the helper instruction stream.\n+            newCallNode->setAndIncChild(i, child);\n+            }\n+         }\n+      }\n+   if(callNode->isPreparedForDirectJNI())\n+      {\n+         newCallNode->setPreparedForDirectJNI();\n+      }\n+\n+   return newCallNode;\n+   }\n+\n ///////////////////////////////////////////////////////////////////////////////////////\n // multianewArrayEvaluator:  multi-dimensional new array of objects\n ///////////////////////////////////////////////////////////////////////////////////////\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::acall);\n-   TR::Register * targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n-   }\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = (TR_J9VMBase *)(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt()!=2)\n+      {\n+      traceMsg(cg->comp(), \"DCDCDCDC - multianewArrayEvaluator. More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fd870a28386d90aa97661f88b14126e8af243c6"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODIxMjcxMA==", "bodyText": "I don't see a need for this function to exist. I see that x86 has the exact same copy as well. We shouldn't be duplicating code like this which seems it could be shared across codegens. However I don't think we should do that as this function serves no purpose to me. We should be able to just evaluate the call as we do before this change, without \"recreating\" the call node.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r518212710", "createdAt": "2020-11-05T17:05:57Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,339 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n+TR::Node *\n+createOutlinedCallNode(TR::CodeGenerator *cg, TR::Node *callNode, TR::ILOpCodes callOp)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fd870a28386d90aa97661f88b14126e8af243c6"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODIxMzIwNw==", "bodyText": "I don't think this should exist either unless we envision further uses of this function.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r518213207", "createdAt": "2020-11-05T17:06:37Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,339 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fd870a28386d90aa97661f88b14126e8af243c6"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODIxNjU2Mw==", "bodyText": "We've already evaluated the children in the mainline. Why can't we just do:\n   TR_S390OutOfLineCodeSection *outlinedSlowPath = new (cg->trHeapMemory()) TR_S390OutOfLineCodeSection(oolFailLabel, cFlowRegionEnd, cg);\n   cg->getS390OutOfLineCodeSectionList().push_front(outlinedSlowPath);\n   outlinedSlowPath->swapInstructionListsWithCompilation();\n\n   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, oolFailLabel);\n\n   TR::ILOpCodes opCode = node->getOpCodeValue();\n   TR::Node::recreate(node, TR::acall);\n   TR::Register* helperCallReturnReg = directCallEvaluator(node, cg);\n   TR::Node::recreate(node, opCode);\n\n   generateRRInstruction(cg, TR::InstOpCode::getLoadRegOpCode(), node, targetReg, helperCallReturnReg);\n   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);\n   \n   outlinedSlowPath->swapInstructionListsWithCompilation();\n\nAnd remove those two functions created above in this PR.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r518216563", "createdAt": "2020-11-05T17:11:17Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,339 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n+TR::Node *\n+createOutlinedCallNode(TR::CodeGenerator *cg, TR::Node *callNode, TR::ILOpCodes callOp)\n+   {\n+   int32_t   i;\n+   TR::Node  *child;\n+\n+   TR::Node *newCallNode = TR::Node::createWithSymRef(callNode, callOp, callNode->getNumChildren(), callNode->getSymbolReference());\n+\n+   newCallNode->setReferenceCount(1);\n+\n+   for (i=0; i<callNode->getNumChildren(); i++)\n+      {\n+      child = callNode->getChild(i);\n+\n+      if (child->getRegister() != NULL)\n+         {\n+         // Child has already been evaluated outside this tree.\n+         //\n+         newCallNode->setAndIncChild(i, child);\n+         }\n+      else if (child->getOpCode().isLoadConst())\n+         {\n+         // Copy unevaluated constant nodes.\n+         //\n+         child = TR::Node::copy(child);\n+         child->setReferenceCount(1);\n+         newCallNode->setChild(i, child);\n+         }\n+      else\n+         {\n+         if ((child->getOpCodeValue() == TR::loadaddr) &&\n+             (child->getSymbolReference()->getSymbol()) &&\n+             (child->getSymbolReference()->getSymbol()->getStaticSymbol()))\n+            {\n+            child = TR::Node::copy(child);\n+            child->setReferenceCount(1);\n+            newCallNode->setChild(i, child);\n+            }\n+         else\n+            {\n+            // Be very conservative at this point, even though it is possible to make it less so.  For example, this will catch\n+            // the case of an unevaluated argument not persisting outside of the outlined region even though one of its subtrees will.\n+            (void)cg->evaluate(child);\n+\n+            // Do not decrement the reference count here.  It will be decremented when the call node is evaluated\n+            // again in the helper instruction stream.\n+            newCallNode->setAndIncChild(i, child);\n+            }\n+         }\n+      }\n+   if(callNode->isPreparedForDirectJNI())\n+      {\n+         newCallNode->setPreparedForDirectJNI();\n+      }\n+\n+   return newCallNode;\n+   }\n+\n ///////////////////////////////////////////////////////////////////////////////////////\n // multianewArrayEvaluator:  multi-dimensional new array of objects\n ///////////////////////////////////////////////////////////////////////////////////////\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::acall);\n-   TR::Register * targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n-   }\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = (TR_J9VMBase *)(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt()!=2)\n+      {\n+      traceMsg(cg->comp(), \"DCDCDCDC - multianewArrayEvaluator. More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      return performHelperCall(node, NULL, TR::acall, false, cg);\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // First generate the OOL code. This path will be used to handle the scenarios that we don't want to handle in JITT'ed code.\n+   TR_S390OutOfLineCodeSection *outlinedSlowPath = new (cg->trHeapMemory()) TR_S390OutOfLineCodeSection(oolFailLabel, cFlowRegionEnd, cg);\n+   cg->getS390OutOfLineCodeSectionList().push_front(outlinedSlowPath);\n+   outlinedSlowPath->swapInstructionListsWithCompilation();\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, oolFailLabel);\n+\n+   TR::Node *_callNode = createOutlinedCallNode(cg, node, TR::acall);\n+   TR::Register *targetReg2 = NULL;\n+   targetReg2 = TR::TreeEvaluator::performCall(_callNode, false, cg);\n+   cg->decReferenceCount(_callNode);\n+   generateRRInstruction(cg, TR::InstOpCode::LR, node, targetReg, targetReg2);\n+\n+   // After returning from the helper, branch back to mainline code.\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);\n+   // End of OOL\n+   outlinedSlowPath->swapInstructionListsWithCompilation();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fd870a28386d90aa97661f88b14126e8af243c6"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODIxNzE3Ng==", "bodyText": "This looks incorrect. What about 64-bit non-compressedrefs? Surely this will fail every time right? Does any of the testing catch this? If it doesn't I'm a bit worried we don't have adequate testing in this area.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r518217176", "createdAt": "2020-11-05T17:12:12Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,339 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n+TR::Node *\n+createOutlinedCallNode(TR::CodeGenerator *cg, TR::Node *callNode, TR::ILOpCodes callOp)\n+   {\n+   int32_t   i;\n+   TR::Node  *child;\n+\n+   TR::Node *newCallNode = TR::Node::createWithSymRef(callNode, callOp, callNode->getNumChildren(), callNode->getSymbolReference());\n+\n+   newCallNode->setReferenceCount(1);\n+\n+   for (i=0; i<callNode->getNumChildren(); i++)\n+      {\n+      child = callNode->getChild(i);\n+\n+      if (child->getRegister() != NULL)\n+         {\n+         // Child has already been evaluated outside this tree.\n+         //\n+         newCallNode->setAndIncChild(i, child);\n+         }\n+      else if (child->getOpCode().isLoadConst())\n+         {\n+         // Copy unevaluated constant nodes.\n+         //\n+         child = TR::Node::copy(child);\n+         child->setReferenceCount(1);\n+         newCallNode->setChild(i, child);\n+         }\n+      else\n+         {\n+         if ((child->getOpCodeValue() == TR::loadaddr) &&\n+             (child->getSymbolReference()->getSymbol()) &&\n+             (child->getSymbolReference()->getSymbol()->getStaticSymbol()))\n+            {\n+            child = TR::Node::copy(child);\n+            child->setReferenceCount(1);\n+            newCallNode->setChild(i, child);\n+            }\n+         else\n+            {\n+            // Be very conservative at this point, even though it is possible to make it less so.  For example, this will catch\n+            // the case of an unevaluated argument not persisting outside of the outlined region even though one of its subtrees will.\n+            (void)cg->evaluate(child);\n+\n+            // Do not decrement the reference count here.  It will be decremented when the call node is evaluated\n+            // again in the helper instruction stream.\n+            newCallNode->setAndIncChild(i, child);\n+            }\n+         }\n+      }\n+   if(callNode->isPreparedForDirectJNI())\n+      {\n+         newCallNode->setPreparedForDirectJNI();\n+      }\n+\n+   return newCallNode;\n+   }\n+\n ///////////////////////////////////////////////////////////////////////////////////////\n // multianewArrayEvaluator:  multi-dimensional new array of objects\n ///////////////////////////////////////////////////////////////////////////////////////\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::acall);\n-   TR::Register * targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n-   }\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = (TR_J9VMBase *)(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt()!=2)\n+      {\n+      traceMsg(cg->comp(), \"DCDCDCDC - multianewArrayEvaluator. More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      return performHelperCall(node, NULL, TR::acall, false, cg);\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // First generate the OOL code. This path will be used to handle the scenarios that we don't want to handle in JITT'ed code.\n+   TR_S390OutOfLineCodeSection *outlinedSlowPath = new (cg->trHeapMemory()) TR_S390OutOfLineCodeSection(oolFailLabel, cFlowRegionEnd, cg);\n+   cg->getS390OutOfLineCodeSectionList().push_front(outlinedSlowPath);\n+   outlinedSlowPath->swapInstructionListsWithCompilation();\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, oolFailLabel);\n+\n+   TR::Node *_callNode = createOutlinedCallNode(cg, node, TR::acall);\n+   TR::Register *targetReg2 = NULL;\n+   targetReg2 = TR::TreeEvaluator::performCall(_callNode, false, cg);\n+   cg->decReferenceCount(_callNode);\n+   generateRRInstruction(cg, TR::InstOpCode::LR, node, targetReg, targetReg2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fd870a28386d90aa97661f88b14126e8af243c6"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODIxNzc2Ng==", "bodyText": "Extra new lines.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r518217766", "createdAt": "2020-11-05T17:13:00Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,339 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n+TR::Node *\n+createOutlinedCallNode(TR::CodeGenerator *cg, TR::Node *callNode, TR::ILOpCodes callOp)\n+   {\n+   int32_t   i;\n+   TR::Node  *child;\n+\n+   TR::Node *newCallNode = TR::Node::createWithSymRef(callNode, callOp, callNode->getNumChildren(), callNode->getSymbolReference());\n+\n+   newCallNode->setReferenceCount(1);\n+\n+   for (i=0; i<callNode->getNumChildren(); i++)\n+      {\n+      child = callNode->getChild(i);\n+\n+      if (child->getRegister() != NULL)\n+         {\n+         // Child has already been evaluated outside this tree.\n+         //\n+         newCallNode->setAndIncChild(i, child);\n+         }\n+      else if (child->getOpCode().isLoadConst())\n+         {\n+         // Copy unevaluated constant nodes.\n+         //\n+         child = TR::Node::copy(child);\n+         child->setReferenceCount(1);\n+         newCallNode->setChild(i, child);\n+         }\n+      else\n+         {\n+         if ((child->getOpCodeValue() == TR::loadaddr) &&\n+             (child->getSymbolReference()->getSymbol()) &&\n+             (child->getSymbolReference()->getSymbol()->getStaticSymbol()))\n+            {\n+            child = TR::Node::copy(child);\n+            child->setReferenceCount(1);\n+            newCallNode->setChild(i, child);\n+            }\n+         else\n+            {\n+            // Be very conservative at this point, even though it is possible to make it less so.  For example, this will catch\n+            // the case of an unevaluated argument not persisting outside of the outlined region even though one of its subtrees will.\n+            (void)cg->evaluate(child);\n+\n+            // Do not decrement the reference count here.  It will be decremented when the call node is evaluated\n+            // again in the helper instruction stream.\n+            newCallNode->setAndIncChild(i, child);\n+            }\n+         }\n+      }\n+   if(callNode->isPreparedForDirectJNI())\n+      {\n+         newCallNode->setPreparedForDirectJNI();\n+      }\n+\n+   return newCallNode;\n+   }\n+\n ///////////////////////////////////////////////////////////////////////////////////////\n // multianewArrayEvaluator:  multi-dimensional new array of objects\n ///////////////////////////////////////////////////////////////////////////////////////\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::acall);\n-   TR::Register * targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n-   }\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = (TR_J9VMBase *)(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt()!=2)\n+      {\n+      traceMsg(cg->comp(), \"DCDCDCDC - multianewArrayEvaluator. More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      return performHelperCall(node, NULL, TR::acall, false, cg);\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // First generate the OOL code. This path will be used to handle the scenarios that we don't want to handle in JITT'ed code.\n+   TR_S390OutOfLineCodeSection *outlinedSlowPath = new (cg->trHeapMemory()) TR_S390OutOfLineCodeSection(oolFailLabel, cFlowRegionEnd, cg);\n+   cg->getS390OutOfLineCodeSectionList().push_front(outlinedSlowPath);\n+   outlinedSlowPath->swapInstructionListsWithCompilation();\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, oolFailLabel);\n+\n+   TR::Node *_callNode = createOutlinedCallNode(cg, node, TR::acall);\n+   TR::Register *targetReg2 = NULL;\n+   targetReg2 = TR::TreeEvaluator::performCall(_callNode, false, cg);\n+   cg->decReferenceCount(_callNode);\n+   generateRRInstruction(cg, TR::InstOpCode::LR, node, targetReg, targetReg2);\n+\n+   // After returning from the helper, branch back to mainline code.\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);\n+   // End of OOL\n+   outlinedSlowPath->swapInstructionListsWithCompilation();\n \n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::LG, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));\n+\n+   TR::Register *secondDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::LG, node, secondDimLenReg, generateS390MemoryReference(dimsPtrReg, 0, cg));\n+\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fd870a28386d90aa97661f88b14126e8af243c6"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODIxOTU5Nw==", "bodyText": "I don't know enough about this opcode (multiANewArray), so I guess this is an opportunity for me to learn. What is the dimsPtrReg pointing to? It looks like a struct of two 64-bit values? Is this true even on 32-bit/compressedrefs? Could you describe what children of this evaluator represent?", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r518219597", "createdAt": "2020-11-05T17:15:47Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,339 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n+TR::Node *\n+createOutlinedCallNode(TR::CodeGenerator *cg, TR::Node *callNode, TR::ILOpCodes callOp)\n+   {\n+   int32_t   i;\n+   TR::Node  *child;\n+\n+   TR::Node *newCallNode = TR::Node::createWithSymRef(callNode, callOp, callNode->getNumChildren(), callNode->getSymbolReference());\n+\n+   newCallNode->setReferenceCount(1);\n+\n+   for (i=0; i<callNode->getNumChildren(); i++)\n+      {\n+      child = callNode->getChild(i);\n+\n+      if (child->getRegister() != NULL)\n+         {\n+         // Child has already been evaluated outside this tree.\n+         //\n+         newCallNode->setAndIncChild(i, child);\n+         }\n+      else if (child->getOpCode().isLoadConst())\n+         {\n+         // Copy unevaluated constant nodes.\n+         //\n+         child = TR::Node::copy(child);\n+         child->setReferenceCount(1);\n+         newCallNode->setChild(i, child);\n+         }\n+      else\n+         {\n+         if ((child->getOpCodeValue() == TR::loadaddr) &&\n+             (child->getSymbolReference()->getSymbol()) &&\n+             (child->getSymbolReference()->getSymbol()->getStaticSymbol()))\n+            {\n+            child = TR::Node::copy(child);\n+            child->setReferenceCount(1);\n+            newCallNode->setChild(i, child);\n+            }\n+         else\n+            {\n+            // Be very conservative at this point, even though it is possible to make it less so.  For example, this will catch\n+            // the case of an unevaluated argument not persisting outside of the outlined region even though one of its subtrees will.\n+            (void)cg->evaluate(child);\n+\n+            // Do not decrement the reference count here.  It will be decremented when the call node is evaluated\n+            // again in the helper instruction stream.\n+            newCallNode->setAndIncChild(i, child);\n+            }\n+         }\n+      }\n+   if(callNode->isPreparedForDirectJNI())\n+      {\n+         newCallNode->setPreparedForDirectJNI();\n+      }\n+\n+   return newCallNode;\n+   }\n+\n ///////////////////////////////////////////////////////////////////////////////////////\n // multianewArrayEvaluator:  multi-dimensional new array of objects\n ///////////////////////////////////////////////////////////////////////////////////////\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::acall);\n-   TR::Register * targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n-   }\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = (TR_J9VMBase *)(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt()!=2)\n+      {\n+      traceMsg(cg->comp(), \"DCDCDCDC - multianewArrayEvaluator. More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      return performHelperCall(node, NULL, TR::acall, false, cg);\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // First generate the OOL code. This path will be used to handle the scenarios that we don't want to handle in JITT'ed code.\n+   TR_S390OutOfLineCodeSection *outlinedSlowPath = new (cg->trHeapMemory()) TR_S390OutOfLineCodeSection(oolFailLabel, cFlowRegionEnd, cg);\n+   cg->getS390OutOfLineCodeSectionList().push_front(outlinedSlowPath);\n+   outlinedSlowPath->swapInstructionListsWithCompilation();\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, oolFailLabel);\n+\n+   TR::Node *_callNode = createOutlinedCallNode(cg, node, TR::acall);\n+   TR::Register *targetReg2 = NULL;\n+   targetReg2 = TR::TreeEvaluator::performCall(_callNode, false, cg);\n+   cg->decReferenceCount(_callNode);\n+   generateRRInstruction(cg, TR::InstOpCode::LR, node, targetReg, targetReg2);\n+\n+   // After returning from the helper, branch back to mainline code.\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);\n+   // End of OOL\n+   outlinedSlowPath->swapInstructionListsWithCompilation();\n \n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::LG, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fd870a28386d90aa97661f88b14126e8af243c6"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODIyMTMzMw==", "bodyText": "We don't typically generate this instructions by themselves. We should use generateS390CompareAndBranchInstruction to mimic all the other uses. Also let's remove the unnecessary casts and extra parenthesis while here.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r518221333", "createdAt": "2020-11-05T17:18:21Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,339 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n+TR::Node *\n+createOutlinedCallNode(TR::CodeGenerator *cg, TR::Node *callNode, TR::ILOpCodes callOp)\n+   {\n+   int32_t   i;\n+   TR::Node  *child;\n+\n+   TR::Node *newCallNode = TR::Node::createWithSymRef(callNode, callOp, callNode->getNumChildren(), callNode->getSymbolReference());\n+\n+   newCallNode->setReferenceCount(1);\n+\n+   for (i=0; i<callNode->getNumChildren(); i++)\n+      {\n+      child = callNode->getChild(i);\n+\n+      if (child->getRegister() != NULL)\n+         {\n+         // Child has already been evaluated outside this tree.\n+         //\n+         newCallNode->setAndIncChild(i, child);\n+         }\n+      else if (child->getOpCode().isLoadConst())\n+         {\n+         // Copy unevaluated constant nodes.\n+         //\n+         child = TR::Node::copy(child);\n+         child->setReferenceCount(1);\n+         newCallNode->setChild(i, child);\n+         }\n+      else\n+         {\n+         if ((child->getOpCodeValue() == TR::loadaddr) &&\n+             (child->getSymbolReference()->getSymbol()) &&\n+             (child->getSymbolReference()->getSymbol()->getStaticSymbol()))\n+            {\n+            child = TR::Node::copy(child);\n+            child->setReferenceCount(1);\n+            newCallNode->setChild(i, child);\n+            }\n+         else\n+            {\n+            // Be very conservative at this point, even though it is possible to make it less so.  For example, this will catch\n+            // the case of an unevaluated argument not persisting outside of the outlined region even though one of its subtrees will.\n+            (void)cg->evaluate(child);\n+\n+            // Do not decrement the reference count here.  It will be decremented when the call node is evaluated\n+            // again in the helper instruction stream.\n+            newCallNode->setAndIncChild(i, child);\n+            }\n+         }\n+      }\n+   if(callNode->isPreparedForDirectJNI())\n+      {\n+         newCallNode->setPreparedForDirectJNI();\n+      }\n+\n+   return newCallNode;\n+   }\n+\n ///////////////////////////////////////////////////////////////////////////////////////\n // multianewArrayEvaluator:  multi-dimensional new array of objects\n ///////////////////////////////////////////////////////////////////////////////////////\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::acall);\n-   TR::Register * targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n-   }\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = (TR_J9VMBase *)(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt()!=2)\n+      {\n+      traceMsg(cg->comp(), \"DCDCDCDC - multianewArrayEvaluator. More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      return performHelperCall(node, NULL, TR::acall, false, cg);\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // First generate the OOL code. This path will be used to handle the scenarios that we don't want to handle in JITT'ed code.\n+   TR_S390OutOfLineCodeSection *outlinedSlowPath = new (cg->trHeapMemory()) TR_S390OutOfLineCodeSection(oolFailLabel, cFlowRegionEnd, cg);\n+   cg->getS390OutOfLineCodeSectionList().push_front(outlinedSlowPath);\n+   outlinedSlowPath->swapInstructionListsWithCompilation();\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, oolFailLabel);\n+\n+   TR::Node *_callNode = createOutlinedCallNode(cg, node, TR::acall);\n+   TR::Register *targetReg2 = NULL;\n+   targetReg2 = TR::TreeEvaluator::performCall(_callNode, false, cg);\n+   cg->decReferenceCount(_callNode);\n+   generateRRInstruction(cg, TR::InstOpCode::LR, node, targetReg, targetReg2);\n+\n+   // After returning from the helper, branch back to mainline code.\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);\n+   // End of OOL\n+   outlinedSlowPath->swapInstructionListsWithCompilation();\n \n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::LG, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));\n+\n+   TR::Register *secondDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::LG, node, secondDimLenReg, generateS390MemoryReference(dimsPtrReg, 0, cg));\n+\n+\n+   // Check to see if second dimension is indeed 0. If yes, then proceed to handle the case here. Otherwise jump to OOL code to perform the call.\n+   generateRIEInstruction(cg, TR::InstOpCode::CLGIJ, node, secondDimLenReg, (int8_t)0, oolFailLabel, (TR::InstOpCode::COND_BNE));\n+\n+   // Now check to see if first dimension is also 0. If no, then jump to nonZeroFirstDimLabel to handle it. Otherwise continue below to handle the case when length for both dimensions is 0.\n+   generateRIEInstruction(cg, TR::InstOpCode::CLGIJ, node, firstDimLenReg, (int8_t)0, nonZeroFirstDimLabel, (TR::InstOpCode::COND_BNE));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fd870a28386d90aa97661f88b14126e8af243c6"}, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODIyMjAyNw==", "bodyText": "I think this clouds the evaluator. When generating a trace log if I see a label I'd expect there is an incoming branch somewhere. So this will definitely confuse readers. If you want to separate code and organize it, just use a comment.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r518222027", "createdAt": "2020-11-05T17:19:25Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,339 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n+TR::Node *\n+createOutlinedCallNode(TR::CodeGenerator *cg, TR::Node *callNode, TR::ILOpCodes callOp)\n+   {\n+   int32_t   i;\n+   TR::Node  *child;\n+\n+   TR::Node *newCallNode = TR::Node::createWithSymRef(callNode, callOp, callNode->getNumChildren(), callNode->getSymbolReference());\n+\n+   newCallNode->setReferenceCount(1);\n+\n+   for (i=0; i<callNode->getNumChildren(); i++)\n+      {\n+      child = callNode->getChild(i);\n+\n+      if (child->getRegister() != NULL)\n+         {\n+         // Child has already been evaluated outside this tree.\n+         //\n+         newCallNode->setAndIncChild(i, child);\n+         }\n+      else if (child->getOpCode().isLoadConst())\n+         {\n+         // Copy unevaluated constant nodes.\n+         //\n+         child = TR::Node::copy(child);\n+         child->setReferenceCount(1);\n+         newCallNode->setChild(i, child);\n+         }\n+      else\n+         {\n+         if ((child->getOpCodeValue() == TR::loadaddr) &&\n+             (child->getSymbolReference()->getSymbol()) &&\n+             (child->getSymbolReference()->getSymbol()->getStaticSymbol()))\n+            {\n+            child = TR::Node::copy(child);\n+            child->setReferenceCount(1);\n+            newCallNode->setChild(i, child);\n+            }\n+         else\n+            {\n+            // Be very conservative at this point, even though it is possible to make it less so.  For example, this will catch\n+            // the case of an unevaluated argument not persisting outside of the outlined region even though one of its subtrees will.\n+            (void)cg->evaluate(child);\n+\n+            // Do not decrement the reference count here.  It will be decremented when the call node is evaluated\n+            // again in the helper instruction stream.\n+            newCallNode->setAndIncChild(i, child);\n+            }\n+         }\n+      }\n+   if(callNode->isPreparedForDirectJNI())\n+      {\n+         newCallNode->setPreparedForDirectJNI();\n+      }\n+\n+   return newCallNode;\n+   }\n+\n ///////////////////////////////////////////////////////////////////////////////////////\n // multianewArrayEvaluator:  multi-dimensional new array of objects\n ///////////////////////////////////////////////////////////////////////////////////////\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::acall);\n-   TR::Register * targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n-   }\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = (TR_J9VMBase *)(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt()!=2)\n+      {\n+      traceMsg(cg->comp(), \"DCDCDCDC - multianewArrayEvaluator. More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      return performHelperCall(node, NULL, TR::acall, false, cg);\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // First generate the OOL code. This path will be used to handle the scenarios that we don't want to handle in JITT'ed code.\n+   TR_S390OutOfLineCodeSection *outlinedSlowPath = new (cg->trHeapMemory()) TR_S390OutOfLineCodeSection(oolFailLabel, cFlowRegionEnd, cg);\n+   cg->getS390OutOfLineCodeSectionList().push_front(outlinedSlowPath);\n+   outlinedSlowPath->swapInstructionListsWithCompilation();\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, oolFailLabel);\n+\n+   TR::Node *_callNode = createOutlinedCallNode(cg, node, TR::acall);\n+   TR::Register *targetReg2 = NULL;\n+   targetReg2 = TR::TreeEvaluator::performCall(_callNode, false, cg);\n+   cg->decReferenceCount(_callNode);\n+   generateRRInstruction(cg, TR::InstOpCode::LR, node, targetReg, targetReg2);\n+\n+   // After returning from the helper, branch back to mainline code.\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);\n+   // End of OOL\n+   outlinedSlowPath->swapInstructionListsWithCompilation();\n \n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::LG, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));\n+\n+   TR::Register *secondDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::LG, node, secondDimLenReg, generateS390MemoryReference(dimsPtrReg, 0, cg));\n+\n+\n+   // Check to see if second dimension is indeed 0. If yes, then proceed to handle the case here. Otherwise jump to OOL code to perform the call.\n+   generateRIEInstruction(cg, TR::InstOpCode::CLGIJ, node, secondDimLenReg, (int8_t)0, oolFailLabel, (TR::InstOpCode::COND_BNE));\n+\n+   // Now check to see if first dimension is also 0. If no, then jump to nonZeroFirstDimLabel to handle it. Otherwise continue below to handle the case when length for both dimensions is 0.\n+   generateRIEInstruction(cg, TR::InstOpCode::CLGIJ, node, firstDimLenReg, (int8_t)0, nonZeroFirstDimLabel, (TR::InstOpCode::COND_BNE));\n+\n+   // TODO: We don't need this label. But it's good for organizing the different paths for now.\n+   TR::LabelSymbol *firstDimZeroLabel = generateLabelSymbol(cg);\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, firstDimZeroLabel);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fd870a28386d90aa97661f88b14126e8af243c6"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODIyNTIzMQ==", "bodyText": "We don't need a register for this. We can use MVHI / MVGHI. Also does this even work under gencon? What would those two fej9->get* APIs return in gencon?", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r518225231", "createdAt": "2020-11-05T17:24:16Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,339 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n+TR::Node *\n+createOutlinedCallNode(TR::CodeGenerator *cg, TR::Node *callNode, TR::ILOpCodes callOp)\n+   {\n+   int32_t   i;\n+   TR::Node  *child;\n+\n+   TR::Node *newCallNode = TR::Node::createWithSymRef(callNode, callOp, callNode->getNumChildren(), callNode->getSymbolReference());\n+\n+   newCallNode->setReferenceCount(1);\n+\n+   for (i=0; i<callNode->getNumChildren(); i++)\n+      {\n+      child = callNode->getChild(i);\n+\n+      if (child->getRegister() != NULL)\n+         {\n+         // Child has already been evaluated outside this tree.\n+         //\n+         newCallNode->setAndIncChild(i, child);\n+         }\n+      else if (child->getOpCode().isLoadConst())\n+         {\n+         // Copy unevaluated constant nodes.\n+         //\n+         child = TR::Node::copy(child);\n+         child->setReferenceCount(1);\n+         newCallNode->setChild(i, child);\n+         }\n+      else\n+         {\n+         if ((child->getOpCodeValue() == TR::loadaddr) &&\n+             (child->getSymbolReference()->getSymbol()) &&\n+             (child->getSymbolReference()->getSymbol()->getStaticSymbol()))\n+            {\n+            child = TR::Node::copy(child);\n+            child->setReferenceCount(1);\n+            newCallNode->setChild(i, child);\n+            }\n+         else\n+            {\n+            // Be very conservative at this point, even though it is possible to make it less so.  For example, this will catch\n+            // the case of an unevaluated argument not persisting outside of the outlined region even though one of its subtrees will.\n+            (void)cg->evaluate(child);\n+\n+            // Do not decrement the reference count here.  It will be decremented when the call node is evaluated\n+            // again in the helper instruction stream.\n+            newCallNode->setAndIncChild(i, child);\n+            }\n+         }\n+      }\n+   if(callNode->isPreparedForDirectJNI())\n+      {\n+         newCallNode->setPreparedForDirectJNI();\n+      }\n+\n+   return newCallNode;\n+   }\n+\n ///////////////////////////////////////////////////////////////////////////////////////\n // multianewArrayEvaluator:  multi-dimensional new array of objects\n ///////////////////////////////////////////////////////////////////////////////////////\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::acall);\n-   TR::Register * targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n-   }\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = (TR_J9VMBase *)(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt()!=2)\n+      {\n+      traceMsg(cg->comp(), \"DCDCDCDC - multianewArrayEvaluator. More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      return performHelperCall(node, NULL, TR::acall, false, cg);\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // First generate the OOL code. This path will be used to handle the scenarios that we don't want to handle in JITT'ed code.\n+   TR_S390OutOfLineCodeSection *outlinedSlowPath = new (cg->trHeapMemory()) TR_S390OutOfLineCodeSection(oolFailLabel, cFlowRegionEnd, cg);\n+   cg->getS390OutOfLineCodeSectionList().push_front(outlinedSlowPath);\n+   outlinedSlowPath->swapInstructionListsWithCompilation();\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, oolFailLabel);\n+\n+   TR::Node *_callNode = createOutlinedCallNode(cg, node, TR::acall);\n+   TR::Register *targetReg2 = NULL;\n+   targetReg2 = TR::TreeEvaluator::performCall(_callNode, false, cg);\n+   cg->decReferenceCount(_callNode);\n+   generateRRInstruction(cg, TR::InstOpCode::LR, node, targetReg, targetReg2);\n+\n+   // After returning from the helper, branch back to mainline code.\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);\n+   // End of OOL\n+   outlinedSlowPath->swapInstructionListsWithCompilation();\n \n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::LG, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));\n+\n+   TR::Register *secondDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::LG, node, secondDimLenReg, generateS390MemoryReference(dimsPtrReg, 0, cg));\n+\n+\n+   // Check to see if second dimension is indeed 0. If yes, then proceed to handle the case here. Otherwise jump to OOL code to perform the call.\n+   generateRIEInstruction(cg, TR::InstOpCode::CLGIJ, node, secondDimLenReg, (int8_t)0, oolFailLabel, (TR::InstOpCode::COND_BNE));\n+\n+   // Now check to see if first dimension is also 0. If no, then jump to nonZeroFirstDimLabel to handle it. Otherwise continue below to handle the case when length for both dimensions is 0.\n+   generateRIEInstruction(cg, TR::InstOpCode::CLGIJ, node, firstDimLenReg, (int8_t)0, nonZeroFirstDimLabel, (TR::InstOpCode::COND_BNE));\n+\n+   // TODO: We don't need this label. But it's good for organizing the different paths for now.\n+   TR::LabelSymbol *firstDimZeroLabel = generateLabelSymbol(cg);\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, firstDimZeroLabel);\n+\n+   // First Dim zero, only allocate 1 zero-length object array\n+   int32_t zeroArraySize = TR::Compiler->om.discontiguousArrayHeaderSizeInBytes();\n+   TR::Register *vmThreadReg = cg->getMethodMetaDataRealRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, targetReg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+\n+   // Branch to OOL if there's not enough space for an array of size 0.\n+   TR::Register *temp1Reg = cg->allocateRegister();\n+   generateRIEInstruction(cg, TR::InstOpCode::getAddHalfWordImmDistinctOperandOpCode(), node, temp1Reg, targetReg, zeroArraySize);\n+   generateRXInstruction(cg, TR::InstOpCode::getCmpLogicalOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapTop), cg));\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BH, node, oolFailLabel);\n+\n+   // If there's enough space, then we can continue to allocate.\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+   \n+   // Init class\n+   bool use64BitClasses = comp->target().is64Bit() && !TR::Compiler->om.generateCompressedObjectHeaders();\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, classReg, generateS390MemoryReference(targetReg, TR::Compiler->om.offsetOfObjectVftField(), cg));\n+   \n+   // Init size and '0' fields to 0\n+   TR::Register *temp0Reg = cg->allocateRegister();\n+   generateRRInstruction(cg, TR::InstOpCode::getXORRegOpCode(), node, temp0Reg, temp0Reg);\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp0Reg, generateS390MemoryReference(targetReg, fej9->getOffsetOfContiguousArraySizeField(), cg));\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp0Reg, generateS390MemoryReference(targetReg, fej9->getOffsetOfDiscontiguousArraySizeField(), cg));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fd870a28386d90aa97661f88b14126e8af243c6"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODIyNTQ5NQ==", "bodyText": "I don't think these comments are too useful. They don't say anything more than the actual line of code.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r518225495", "createdAt": "2020-11-05T17:24:39Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,339 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n+TR::Node *\n+createOutlinedCallNode(TR::CodeGenerator *cg, TR::Node *callNode, TR::ILOpCodes callOp)\n+   {\n+   int32_t   i;\n+   TR::Node  *child;\n+\n+   TR::Node *newCallNode = TR::Node::createWithSymRef(callNode, callOp, callNode->getNumChildren(), callNode->getSymbolReference());\n+\n+   newCallNode->setReferenceCount(1);\n+\n+   for (i=0; i<callNode->getNumChildren(); i++)\n+      {\n+      child = callNode->getChild(i);\n+\n+      if (child->getRegister() != NULL)\n+         {\n+         // Child has already been evaluated outside this tree.\n+         //\n+         newCallNode->setAndIncChild(i, child);\n+         }\n+      else if (child->getOpCode().isLoadConst())\n+         {\n+         // Copy unevaluated constant nodes.\n+         //\n+         child = TR::Node::copy(child);\n+         child->setReferenceCount(1);\n+         newCallNode->setChild(i, child);\n+         }\n+      else\n+         {\n+         if ((child->getOpCodeValue() == TR::loadaddr) &&\n+             (child->getSymbolReference()->getSymbol()) &&\n+             (child->getSymbolReference()->getSymbol()->getStaticSymbol()))\n+            {\n+            child = TR::Node::copy(child);\n+            child->setReferenceCount(1);\n+            newCallNode->setChild(i, child);\n+            }\n+         else\n+            {\n+            // Be very conservative at this point, even though it is possible to make it less so.  For example, this will catch\n+            // the case of an unevaluated argument not persisting outside of the outlined region even though one of its subtrees will.\n+            (void)cg->evaluate(child);\n+\n+            // Do not decrement the reference count here.  It will be decremented when the call node is evaluated\n+            // again in the helper instruction stream.\n+            newCallNode->setAndIncChild(i, child);\n+            }\n+         }\n+      }\n+   if(callNode->isPreparedForDirectJNI())\n+      {\n+         newCallNode->setPreparedForDirectJNI();\n+      }\n+\n+   return newCallNode;\n+   }\n+\n ///////////////////////////////////////////////////////////////////////////////////////\n // multianewArrayEvaluator:  multi-dimensional new array of objects\n ///////////////////////////////////////////////////////////////////////////////////////\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::acall);\n-   TR::Register * targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n-   }\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = (TR_J9VMBase *)(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt()!=2)\n+      {\n+      traceMsg(cg->comp(), \"DCDCDCDC - multianewArrayEvaluator. More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      return performHelperCall(node, NULL, TR::acall, false, cg);\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // First generate the OOL code. This path will be used to handle the scenarios that we don't want to handle in JITT'ed code.\n+   TR_S390OutOfLineCodeSection *outlinedSlowPath = new (cg->trHeapMemory()) TR_S390OutOfLineCodeSection(oolFailLabel, cFlowRegionEnd, cg);\n+   cg->getS390OutOfLineCodeSectionList().push_front(outlinedSlowPath);\n+   outlinedSlowPath->swapInstructionListsWithCompilation();\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, oolFailLabel);\n+\n+   TR::Node *_callNode = createOutlinedCallNode(cg, node, TR::acall);\n+   TR::Register *targetReg2 = NULL;\n+   targetReg2 = TR::TreeEvaluator::performCall(_callNode, false, cg);\n+   cg->decReferenceCount(_callNode);\n+   generateRRInstruction(cg, TR::InstOpCode::LR, node, targetReg, targetReg2);\n+\n+   // After returning from the helper, branch back to mainline code.\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);\n+   // End of OOL\n+   outlinedSlowPath->swapInstructionListsWithCompilation();\n \n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::LG, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));\n+\n+   TR::Register *secondDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::LG, node, secondDimLenReg, generateS390MemoryReference(dimsPtrReg, 0, cg));\n+\n+\n+   // Check to see if second dimension is indeed 0. If yes, then proceed to handle the case here. Otherwise jump to OOL code to perform the call.\n+   generateRIEInstruction(cg, TR::InstOpCode::CLGIJ, node, secondDimLenReg, (int8_t)0, oolFailLabel, (TR::InstOpCode::COND_BNE));\n+\n+   // Now check to see if first dimension is also 0. If no, then jump to nonZeroFirstDimLabel to handle it. Otherwise continue below to handle the case when length for both dimensions is 0.\n+   generateRIEInstruction(cg, TR::InstOpCode::CLGIJ, node, firstDimLenReg, (int8_t)0, nonZeroFirstDimLabel, (TR::InstOpCode::COND_BNE));\n+\n+   // TODO: We don't need this label. But it's good for organizing the different paths for now.\n+   TR::LabelSymbol *firstDimZeroLabel = generateLabelSymbol(cg);\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, firstDimZeroLabel);\n+\n+   // First Dim zero, only allocate 1 zero-length object array\n+   int32_t zeroArraySize = TR::Compiler->om.discontiguousArrayHeaderSizeInBytes();\n+   TR::Register *vmThreadReg = cg->getMethodMetaDataRealRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, targetReg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+\n+   // Branch to OOL if there's not enough space for an array of size 0.\n+   TR::Register *temp1Reg = cg->allocateRegister();\n+   generateRIEInstruction(cg, TR::InstOpCode::getAddHalfWordImmDistinctOperandOpCode(), node, temp1Reg, targetReg, zeroArraySize);\n+   generateRXInstruction(cg, TR::InstOpCode::getCmpLogicalOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapTop), cg));\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BH, node, oolFailLabel);\n+\n+   // If there's enough space, then we can continue to allocate.\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+   \n+   // Init class\n+   bool use64BitClasses = comp->target().is64Bit() && !TR::Compiler->om.generateCompressedObjectHeaders();\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, classReg, generateS390MemoryReference(targetReg, TR::Compiler->om.offsetOfObjectVftField(), cg));\n+   \n+   // Init size and '0' fields to 0\n+   TR::Register *temp0Reg = cg->allocateRegister();\n+   generateRRInstruction(cg, TR::InstOpCode::getXORRegOpCode(), node, temp0Reg, temp0Reg);\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp0Reg, generateS390MemoryReference(targetReg, fej9->getOffsetOfContiguousArraySizeField(), cg));\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp0Reg, generateS390MemoryReference(targetReg, fej9->getOffsetOfDiscontiguousArraySizeField(), cg));\n+\n+   // Done with this scenario, so jump to end of ICF.\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fd870a28386d90aa97661f88b14126e8af243c6"}, "originalPosition": 177}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODIyNjA1NQ==", "bodyText": "\"DCDC\" needs to be removed. If there is something to be done, we should leave a TODO and open an issue for it.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r518226055", "createdAt": "2020-11-05T17:25:28Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,339 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n+TR::Node *\n+createOutlinedCallNode(TR::CodeGenerator *cg, TR::Node *callNode, TR::ILOpCodes callOp)\n+   {\n+   int32_t   i;\n+   TR::Node  *child;\n+\n+   TR::Node *newCallNode = TR::Node::createWithSymRef(callNode, callOp, callNode->getNumChildren(), callNode->getSymbolReference());\n+\n+   newCallNode->setReferenceCount(1);\n+\n+   for (i=0; i<callNode->getNumChildren(); i++)\n+      {\n+      child = callNode->getChild(i);\n+\n+      if (child->getRegister() != NULL)\n+         {\n+         // Child has already been evaluated outside this tree.\n+         //\n+         newCallNode->setAndIncChild(i, child);\n+         }\n+      else if (child->getOpCode().isLoadConst())\n+         {\n+         // Copy unevaluated constant nodes.\n+         //\n+         child = TR::Node::copy(child);\n+         child->setReferenceCount(1);\n+         newCallNode->setChild(i, child);\n+         }\n+      else\n+         {\n+         if ((child->getOpCodeValue() == TR::loadaddr) &&\n+             (child->getSymbolReference()->getSymbol()) &&\n+             (child->getSymbolReference()->getSymbol()->getStaticSymbol()))\n+            {\n+            child = TR::Node::copy(child);\n+            child->setReferenceCount(1);\n+            newCallNode->setChild(i, child);\n+            }\n+         else\n+            {\n+            // Be very conservative at this point, even though it is possible to make it less so.  For example, this will catch\n+            // the case of an unevaluated argument not persisting outside of the outlined region even though one of its subtrees will.\n+            (void)cg->evaluate(child);\n+\n+            // Do not decrement the reference count here.  It will be decremented when the call node is evaluated\n+            // again in the helper instruction stream.\n+            newCallNode->setAndIncChild(i, child);\n+            }\n+         }\n+      }\n+   if(callNode->isPreparedForDirectJNI())\n+      {\n+         newCallNode->setPreparedForDirectJNI();\n+      }\n+\n+   return newCallNode;\n+   }\n+\n ///////////////////////////////////////////////////////////////////////////////////////\n // multianewArrayEvaluator:  multi-dimensional new array of objects\n ///////////////////////////////////////////////////////////////////////////////////////\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::acall);\n-   TR::Register * targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n-   }\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = (TR_J9VMBase *)(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt()!=2)\n+      {\n+      traceMsg(cg->comp(), \"DCDCDCDC - multianewArrayEvaluator. More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      return performHelperCall(node, NULL, TR::acall, false, cg);\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // First generate the OOL code. This path will be used to handle the scenarios that we don't want to handle in JITT'ed code.\n+   TR_S390OutOfLineCodeSection *outlinedSlowPath = new (cg->trHeapMemory()) TR_S390OutOfLineCodeSection(oolFailLabel, cFlowRegionEnd, cg);\n+   cg->getS390OutOfLineCodeSectionList().push_front(outlinedSlowPath);\n+   outlinedSlowPath->swapInstructionListsWithCompilation();\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, oolFailLabel);\n+\n+   TR::Node *_callNode = createOutlinedCallNode(cg, node, TR::acall);\n+   TR::Register *targetReg2 = NULL;\n+   targetReg2 = TR::TreeEvaluator::performCall(_callNode, false, cg);\n+   cg->decReferenceCount(_callNode);\n+   generateRRInstruction(cg, TR::InstOpCode::LR, node, targetReg, targetReg2);\n+\n+   // After returning from the helper, branch back to mainline code.\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);\n+   // End of OOL\n+   outlinedSlowPath->swapInstructionListsWithCompilation();\n \n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::LG, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));\n+\n+   TR::Register *secondDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::LG, node, secondDimLenReg, generateS390MemoryReference(dimsPtrReg, 0, cg));\n+\n+\n+   // Check to see if second dimension is indeed 0. If yes, then proceed to handle the case here. Otherwise jump to OOL code to perform the call.\n+   generateRIEInstruction(cg, TR::InstOpCode::CLGIJ, node, secondDimLenReg, (int8_t)0, oolFailLabel, (TR::InstOpCode::COND_BNE));\n+\n+   // Now check to see if first dimension is also 0. If no, then jump to nonZeroFirstDimLabel to handle it. Otherwise continue below to handle the case when length for both dimensions is 0.\n+   generateRIEInstruction(cg, TR::InstOpCode::CLGIJ, node, firstDimLenReg, (int8_t)0, nonZeroFirstDimLabel, (TR::InstOpCode::COND_BNE));\n+\n+   // TODO: We don't need this label. But it's good for organizing the different paths for now.\n+   TR::LabelSymbol *firstDimZeroLabel = generateLabelSymbol(cg);\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, firstDimZeroLabel);\n+\n+   // First Dim zero, only allocate 1 zero-length object array\n+   int32_t zeroArraySize = TR::Compiler->om.discontiguousArrayHeaderSizeInBytes();\n+   TR::Register *vmThreadReg = cg->getMethodMetaDataRealRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, targetReg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+\n+   // Branch to OOL if there's not enough space for an array of size 0.\n+   TR::Register *temp1Reg = cg->allocateRegister();\n+   generateRIEInstruction(cg, TR::InstOpCode::getAddHalfWordImmDistinctOperandOpCode(), node, temp1Reg, targetReg, zeroArraySize);\n+   generateRXInstruction(cg, TR::InstOpCode::getCmpLogicalOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapTop), cg));\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BH, node, oolFailLabel);\n+\n+   // If there's enough space, then we can continue to allocate.\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+   \n+   // Init class\n+   bool use64BitClasses = comp->target().is64Bit() && !TR::Compiler->om.generateCompressedObjectHeaders();\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, classReg, generateS390MemoryReference(targetReg, TR::Compiler->om.offsetOfObjectVftField(), cg));\n+   \n+   // Init size and '0' fields to 0\n+   TR::Register *temp0Reg = cg->allocateRegister();\n+   generateRRInstruction(cg, TR::InstOpCode::getXORRegOpCode(), node, temp0Reg, temp0Reg);\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp0Reg, generateS390MemoryReference(targetReg, fej9->getOffsetOfContiguousArraySizeField(), cg));\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp0Reg, generateS390MemoryReference(targetReg, fej9->getOffsetOfDiscontiguousArraySizeField(), cg));\n+\n+   // Done with this scenario, so jump to end of ICF.\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);\n+\n+   // We end up in this block of the ICF if the first dimension is non-zero and the second dimension is zero.\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, nonZeroFirstDimLabel); // DCDCDCDC - > This is temporary. In the long run we want to have actual code and not just fall through into oolFailLabel.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fd870a28386d90aa97661f88b14126e8af243c6"}, "originalPosition": 180}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7fd870a28386d90aa97661f88b14126e8af243c6", "author": {"user": {"login": "dchopra001", "name": "Dhruv Chopra"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/7fd870a28386d90aa97661f88b14126e8af243c6", "committedDate": "2020-11-03T14:57:27Z", "message": "Rewrite multianewarray evaluator on Z\n\nThis commit adds support for 2-dimensional arrays\nwhere the second dimension has length=0 in the\nmultianewarrayEvaluator.\n\nSigned-off-by: Dhruv Chopra <Dhruv.C.Chopra@ibm.com>"}, "afterCommit": {"oid": "6240663d966ffed91823c9688591caeffb3a0c61", "author": {"user": {"login": "dchopra001", "name": "Dhruv Chopra"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/6240663d966ffed91823c9688591caeffb3a0c61", "committedDate": "2020-11-13T19:02:41Z", "message": "Use MVHI to store constants\n\nSigned-off-by: Dhruv Chopra <Dhruv.C.Chopra@ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM0ODUwNjUy", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#pullrequestreview-534850652", "createdAt": "2020-11-19T21:05:30Z", "commit": {"oid": "10d5904fe4cd34f70dcf0c92e294ba54ba930b38"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQyMTowNTozMFrOH2xmlw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQyMToyODowMlrOH2yWjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE5Nzg0Nw==", "bodyText": "We should use static_cast here.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r527197847", "createdAt": "2020-11-19T21:05:30Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,264 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n ///////////////////////////////////////////////////////////////////////////////////////\n // multianewArrayEvaluator:  multi-dimensional new array of objects\n ///////////////////////////////////////////////////////////////////////////////////////\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::acall);\n-   TR::Register * targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n-   }\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = (TR_J9VMBase *)(comp->fe());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10d5904fe4cd34f70dcf0c92e294ba54ba930b38"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIwMjM1NQ==", "bodyText": "Does this mean we only allow inline allocations if the signature is [x][0]? That doesn't really make sense to me.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r527202355", "createdAt": "2020-11-19T21:13:48Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,264 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n ///////////////////////////////////////////////////////////////////////////////////////\n // multianewArrayEvaluator:  multi-dimensional new array of objects\n ///////////////////////////////////////////////////////////////////////////////////////\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::acall);\n-   TR::Register * targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n-   }\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = (TR_J9VMBase *)(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt() != 2)\n+      {\n+      traceMsg(cg->comp(), \"multianewArrayEvaluator - More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      return performHelperCall(node, NULL, TR::acall, false, cg);\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   // oolJumpLabel is a common point that all branches will jump to. From this label, we branch to OOL code.\n+   // We do this instead of jumping directly to OOL code from mainline because the RA can only handle the case where there's\n+   // a single jump point to OOL code.\n+   TR::LabelSymbol *oolJumpLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));\n+\n+   TR::Register *secondDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, secondDimLenReg, generateS390MemoryReference(dimsPtrReg, 0, cg));\n+\n+   // Check to see if second dimension is indeed 0. If yes, then proceed to handle the case here. Otherwise jump to OOL code.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, secondDimLenReg, 0, TR::InstOpCode::COND_BNE, oolJumpLabel, false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10d5904fe4cd34f70dcf0c92e294ba54ba930b38"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIwNDg0Mw==", "bodyText": "Typo: ump", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r527204843", "createdAt": "2020-11-19T21:18:09Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,264 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n ///////////////////////////////////////////////////////////////////////////////////////\n // multianewArrayEvaluator:  multi-dimensional new array of objects\n ///////////////////////////////////////////////////////////////////////////////////////\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::acall);\n-   TR::Register * targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n-   }\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = (TR_J9VMBase *)(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt() != 2)\n+      {\n+      traceMsg(cg->comp(), \"multianewArrayEvaluator - More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      return performHelperCall(node, NULL, TR::acall, false, cg);\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   // oolJumpLabel is a common point that all branches will jump to. From this label, we branch to OOL code.\n+   // We do this instead of jumping directly to OOL code from mainline because the RA can only handle the case where there's\n+   // a single jump point to OOL code.\n+   TR::LabelSymbol *oolJumpLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));\n+\n+   TR::Register *secondDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, secondDimLenReg, generateS390MemoryReference(dimsPtrReg, 0, cg));\n+\n+   // Check to see if second dimension is indeed 0. If yes, then proceed to handle the case here. Otherwise jump to OOL code.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, secondDimLenReg, 0, TR::InstOpCode::COND_BNE, oolJumpLabel, false);\n+\n+   // Now check to see if first dimension is also 0. If yes, continue below to handle the case when length for both dimensions is 0. Otherwise jump to nonZeroFirstDimLabel.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, 0, TR::InstOpCode::COND_BNE, nonZeroFirstDimLabel, false);\n+\n+   // First dimension zero, so only allocate 1 zero-length object array\n+   int32_t zeroArraySize = TR::Compiler->om.discontiguousArrayHeaderSizeInBytes();\n+   TR::Register *vmThreadReg = cg->getMethodMetaDataRealRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, targetReg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+\n+   // Branch to OOL if there's not enough space for an array of size 0.\n+   TR::Register *temp1Reg = cg->allocateRegister();\n+   generateRIEInstruction(cg, TR::InstOpCode::getAddHalfWordImmDistinctOperandOpCode(), node, temp1Reg, targetReg, zeroArraySize);\n+   generateRXInstruction(cg, TR::InstOpCode::getCmpLogicalOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapTop), cg));\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BH, node, oolJumpLabel);\n+\n+   // If there's enough space, then we can continue to allocate.\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+   \n+   bool use64BitClasses = comp->target().is64Bit() && !TR::Compiler->om.generateCompressedObjectHeaders();\n+\n+   // Init class and fields, then jump to end of ICF\n+   generateRXInstruction(cg, use64BitClasses ? TR::InstOpCode::STG : TR::InstOpCode::ST, node, classReg, generateS390MemoryReference(targetReg, TR::Compiler->om.offsetOfObjectVftField(), cg));\n+   generateSILInstruction(cg, use64BitClasses ? TR::InstOpCode::MVGHI : TR::InstOpCode::MVHI, node, generateS390MemoryReference(targetReg, fej9->getOffsetOfContiguousArraySizeField(), cg), 0);\n+   generateSILInstruction(cg, use64BitClasses ? TR::InstOpCode::MVGHI : TR::InstOpCode::MVHI, node, generateS390MemoryReference(targetReg, fej9->getOffsetOfDiscontiguousArraySizeField(), cg), 0);\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);\n+\n+   // We end up in this region of the ICF if the first dimension is non-zero and the second dimension is zero.\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, nonZeroFirstDimLabel);\n+\n+   TR::Register *componentClassReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, componentClassReg, generateS390MemoryReference(classReg, offsetof(J9ArrayClass, componentType), cg));\n+\n+   // Calculate maximum allowable object size in elements and ump to OOL if it's higher than firstDimLenReg.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10d5904fe4cd34f70dcf0c92e294ba54ba930b38"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIwNTM1MA==", "bodyText": "Shouldn't this be a generateS390CompareAndBranchInstruction?", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r527205350", "createdAt": "2020-11-19T21:19:08Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,264 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n ///////////////////////////////////////////////////////////////////////////////////////\n // multianewArrayEvaluator:  multi-dimensional new array of objects\n ///////////////////////////////////////////////////////////////////////////////////////\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::acall);\n-   TR::Register * targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n-   }\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = (TR_J9VMBase *)(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt() != 2)\n+      {\n+      traceMsg(cg->comp(), \"multianewArrayEvaluator - More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      return performHelperCall(node, NULL, TR::acall, false, cg);\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   // oolJumpLabel is a common point that all branches will jump to. From this label, we branch to OOL code.\n+   // We do this instead of jumping directly to OOL code from mainline because the RA can only handle the case where there's\n+   // a single jump point to OOL code.\n+   TR::LabelSymbol *oolJumpLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));\n+\n+   TR::Register *secondDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, secondDimLenReg, generateS390MemoryReference(dimsPtrReg, 0, cg));\n+\n+   // Check to see if second dimension is indeed 0. If yes, then proceed to handle the case here. Otherwise jump to OOL code.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, secondDimLenReg, 0, TR::InstOpCode::COND_BNE, oolJumpLabel, false);\n+\n+   // Now check to see if first dimension is also 0. If yes, continue below to handle the case when length for both dimensions is 0. Otherwise jump to nonZeroFirstDimLabel.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, 0, TR::InstOpCode::COND_BNE, nonZeroFirstDimLabel, false);\n+\n+   // First dimension zero, so only allocate 1 zero-length object array\n+   int32_t zeroArraySize = TR::Compiler->om.discontiguousArrayHeaderSizeInBytes();\n+   TR::Register *vmThreadReg = cg->getMethodMetaDataRealRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, targetReg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+\n+   // Branch to OOL if there's not enough space for an array of size 0.\n+   TR::Register *temp1Reg = cg->allocateRegister();\n+   generateRIEInstruction(cg, TR::InstOpCode::getAddHalfWordImmDistinctOperandOpCode(), node, temp1Reg, targetReg, zeroArraySize);\n+   generateRXInstruction(cg, TR::InstOpCode::getCmpLogicalOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapTop), cg));\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BH, node, oolJumpLabel);\n+\n+   // If there's enough space, then we can continue to allocate.\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+   \n+   bool use64BitClasses = comp->target().is64Bit() && !TR::Compiler->om.generateCompressedObjectHeaders();\n+\n+   // Init class and fields, then jump to end of ICF\n+   generateRXInstruction(cg, use64BitClasses ? TR::InstOpCode::STG : TR::InstOpCode::ST, node, classReg, generateS390MemoryReference(targetReg, TR::Compiler->om.offsetOfObjectVftField(), cg));\n+   generateSILInstruction(cg, use64BitClasses ? TR::InstOpCode::MVGHI : TR::InstOpCode::MVHI, node, generateS390MemoryReference(targetReg, fej9->getOffsetOfContiguousArraySizeField(), cg), 0);\n+   generateSILInstruction(cg, use64BitClasses ? TR::InstOpCode::MVGHI : TR::InstOpCode::MVHI, node, generateS390MemoryReference(targetReg, fej9->getOffsetOfDiscontiguousArraySizeField(), cg), 0);\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);\n+\n+   // We end up in this region of the ICF if the first dimension is non-zero and the second dimension is zero.\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, nonZeroFirstDimLabel);\n+\n+   TR::Register *componentClassReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, componentClassReg, generateS390MemoryReference(classReg, offsetof(J9ArrayClass, componentType), cg));\n+\n+   // Calculate maximum allowable object size in elements and ump to OOL if it's higher than firstDimLenReg.\n+   int32_t elementSize = comp->useCompressedPointers() ? TR::Compiler->om.sizeofReferenceField() : static_cast<int32_t>(TR::Compiler->om.sizeofReferenceAddress());\n+   uintptr_t maxObjectSize = cg->getMaxObjectSizeGuaranteedNotToOverflow();\n+   uintptr_t maxObjectSizeInElements = maxObjectSize / elementSize;\n+\n+   if (comp->target().is64Bit() && !(maxObjectSizeInElements >= 0 && maxObjectSizeInElements <= (uintptr_t)INT_MAX))\n+      {\n+      uint32_t high32 = maxObjectSizeInElements >> 32;\n+      generateRILInstruction(cg, TR::InstOpCode::LLIHF, node, temp1Reg, high32);\n+      generateRILInstruction(cg, TR::InstOpCode::IILF, node, temp1Reg, static_cast<uint32_t>(maxObjectSizeInElements));\n+      generateRIEInstruction(cg, TR::InstOpCode::CLGRJ, node, firstDimLenReg, temp1Reg, oolJumpLabel, TR::InstOpCode::COND_BRH);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10d5904fe4cd34f70dcf0c92e294ba54ba930b38"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIwNjMyNg==", "bodyText": "This too can be a generateS390CompareAndBranchInstruction.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r527206326", "createdAt": "2020-11-19T21:20:52Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,264 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n ///////////////////////////////////////////////////////////////////////////////////////\n // multianewArrayEvaluator:  multi-dimensional new array of objects\n ///////////////////////////////////////////////////////////////////////////////////////\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::acall);\n-   TR::Register * targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n-   }\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = (TR_J9VMBase *)(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt() != 2)\n+      {\n+      traceMsg(cg->comp(), \"multianewArrayEvaluator - More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      return performHelperCall(node, NULL, TR::acall, false, cg);\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   // oolJumpLabel is a common point that all branches will jump to. From this label, we branch to OOL code.\n+   // We do this instead of jumping directly to OOL code from mainline because the RA can only handle the case where there's\n+   // a single jump point to OOL code.\n+   TR::LabelSymbol *oolJumpLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));\n+\n+   TR::Register *secondDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, secondDimLenReg, generateS390MemoryReference(dimsPtrReg, 0, cg));\n+\n+   // Check to see if second dimension is indeed 0. If yes, then proceed to handle the case here. Otherwise jump to OOL code.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, secondDimLenReg, 0, TR::InstOpCode::COND_BNE, oolJumpLabel, false);\n+\n+   // Now check to see if first dimension is also 0. If yes, continue below to handle the case when length for both dimensions is 0. Otherwise jump to nonZeroFirstDimLabel.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, 0, TR::InstOpCode::COND_BNE, nonZeroFirstDimLabel, false);\n+\n+   // First dimension zero, so only allocate 1 zero-length object array\n+   int32_t zeroArraySize = TR::Compiler->om.discontiguousArrayHeaderSizeInBytes();\n+   TR::Register *vmThreadReg = cg->getMethodMetaDataRealRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, targetReg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+\n+   // Branch to OOL if there's not enough space for an array of size 0.\n+   TR::Register *temp1Reg = cg->allocateRegister();\n+   generateRIEInstruction(cg, TR::InstOpCode::getAddHalfWordImmDistinctOperandOpCode(), node, temp1Reg, targetReg, zeroArraySize);\n+   generateRXInstruction(cg, TR::InstOpCode::getCmpLogicalOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapTop), cg));\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BH, node, oolJumpLabel);\n+\n+   // If there's enough space, then we can continue to allocate.\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+   \n+   bool use64BitClasses = comp->target().is64Bit() && !TR::Compiler->om.generateCompressedObjectHeaders();\n+\n+   // Init class and fields, then jump to end of ICF\n+   generateRXInstruction(cg, use64BitClasses ? TR::InstOpCode::STG : TR::InstOpCode::ST, node, classReg, generateS390MemoryReference(targetReg, TR::Compiler->om.offsetOfObjectVftField(), cg));\n+   generateSILInstruction(cg, use64BitClasses ? TR::InstOpCode::MVGHI : TR::InstOpCode::MVHI, node, generateS390MemoryReference(targetReg, fej9->getOffsetOfContiguousArraySizeField(), cg), 0);\n+   generateSILInstruction(cg, use64BitClasses ? TR::InstOpCode::MVGHI : TR::InstOpCode::MVHI, node, generateS390MemoryReference(targetReg, fej9->getOffsetOfDiscontiguousArraySizeField(), cg), 0);\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);\n+\n+   // We end up in this region of the ICF if the first dimension is non-zero and the second dimension is zero.\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, nonZeroFirstDimLabel);\n+\n+   TR::Register *componentClassReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, componentClassReg, generateS390MemoryReference(classReg, offsetof(J9ArrayClass, componentType), cg));\n+\n+   // Calculate maximum allowable object size in elements and ump to OOL if it's higher than firstDimLenReg.\n+   int32_t elementSize = comp->useCompressedPointers() ? TR::Compiler->om.sizeofReferenceField() : static_cast<int32_t>(TR::Compiler->om.sizeofReferenceAddress());\n+   uintptr_t maxObjectSize = cg->getMaxObjectSizeGuaranteedNotToOverflow();\n+   uintptr_t maxObjectSizeInElements = maxObjectSize / elementSize;\n+\n+   if (comp->target().is64Bit() && !(maxObjectSizeInElements >= 0 && maxObjectSizeInElements <= (uintptr_t)INT_MAX))\n+      {\n+      uint32_t high32 = maxObjectSizeInElements >> 32;\n+      generateRILInstruction(cg, TR::InstOpCode::LLIHF, node, temp1Reg, high32);\n+      generateRILInstruction(cg, TR::InstOpCode::IILF, node, temp1Reg, static_cast<uint32_t>(maxObjectSizeInElements));\n+      generateRIEInstruction(cg, TR::InstOpCode::CLGRJ, node, firstDimLenReg, temp1Reg, oolJumpLabel, TR::InstOpCode::COND_BRH);\n+      }\n+   else\n+      {\n+      generateRILInstruction(cg, TR::InstOpCode::CFI, node, firstDimLenReg, static_cast<uint32_t>(maxObjectSizeInElements));\n+      generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BHR, node, oolJumpLabel);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10d5904fe4cd34f70dcf0c92e294ba54ba930b38"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIwNzMxNw==", "bodyText": "Is this ever even true? I don't think field width is ever smaller than object alignment.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r527207317", "createdAt": "2020-11-19T21:22:44Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,264 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n ///////////////////////////////////////////////////////////////////////////////////////\n // multianewArrayEvaluator:  multi-dimensional new array of objects\n ///////////////////////////////////////////////////////////////////////////////////////\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::acall);\n-   TR::Register * targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n-   }\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = (TR_J9VMBase *)(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt() != 2)\n+      {\n+      traceMsg(cg->comp(), \"multianewArrayEvaluator - More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      return performHelperCall(node, NULL, TR::acall, false, cg);\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   // oolJumpLabel is a common point that all branches will jump to. From this label, we branch to OOL code.\n+   // We do this instead of jumping directly to OOL code from mainline because the RA can only handle the case where there's\n+   // a single jump point to OOL code.\n+   TR::LabelSymbol *oolJumpLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));\n+\n+   TR::Register *secondDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, secondDimLenReg, generateS390MemoryReference(dimsPtrReg, 0, cg));\n+\n+   // Check to see if second dimension is indeed 0. If yes, then proceed to handle the case here. Otherwise jump to OOL code.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, secondDimLenReg, 0, TR::InstOpCode::COND_BNE, oolJumpLabel, false);\n+\n+   // Now check to see if first dimension is also 0. If yes, continue below to handle the case when length for both dimensions is 0. Otherwise jump to nonZeroFirstDimLabel.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, 0, TR::InstOpCode::COND_BNE, nonZeroFirstDimLabel, false);\n+\n+   // First dimension zero, so only allocate 1 zero-length object array\n+   int32_t zeroArraySize = TR::Compiler->om.discontiguousArrayHeaderSizeInBytes();\n+   TR::Register *vmThreadReg = cg->getMethodMetaDataRealRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, targetReg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+\n+   // Branch to OOL if there's not enough space for an array of size 0.\n+   TR::Register *temp1Reg = cg->allocateRegister();\n+   generateRIEInstruction(cg, TR::InstOpCode::getAddHalfWordImmDistinctOperandOpCode(), node, temp1Reg, targetReg, zeroArraySize);\n+   generateRXInstruction(cg, TR::InstOpCode::getCmpLogicalOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapTop), cg));\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BH, node, oolJumpLabel);\n+\n+   // If there's enough space, then we can continue to allocate.\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+   \n+   bool use64BitClasses = comp->target().is64Bit() && !TR::Compiler->om.generateCompressedObjectHeaders();\n+\n+   // Init class and fields, then jump to end of ICF\n+   generateRXInstruction(cg, use64BitClasses ? TR::InstOpCode::STG : TR::InstOpCode::ST, node, classReg, generateS390MemoryReference(targetReg, TR::Compiler->om.offsetOfObjectVftField(), cg));\n+   generateSILInstruction(cg, use64BitClasses ? TR::InstOpCode::MVGHI : TR::InstOpCode::MVHI, node, generateS390MemoryReference(targetReg, fej9->getOffsetOfContiguousArraySizeField(), cg), 0);\n+   generateSILInstruction(cg, use64BitClasses ? TR::InstOpCode::MVGHI : TR::InstOpCode::MVHI, node, generateS390MemoryReference(targetReg, fej9->getOffsetOfDiscontiguousArraySizeField(), cg), 0);\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);\n+\n+   // We end up in this region of the ICF if the first dimension is non-zero and the second dimension is zero.\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, nonZeroFirstDimLabel);\n+\n+   TR::Register *componentClassReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, componentClassReg, generateS390MemoryReference(classReg, offsetof(J9ArrayClass, componentType), cg));\n+\n+   // Calculate maximum allowable object size in elements and ump to OOL if it's higher than firstDimLenReg.\n+   int32_t elementSize = comp->useCompressedPointers() ? TR::Compiler->om.sizeofReferenceField() : static_cast<int32_t>(TR::Compiler->om.sizeofReferenceAddress());\n+   uintptr_t maxObjectSize = cg->getMaxObjectSizeGuaranteedNotToOverflow();\n+   uintptr_t maxObjectSizeInElements = maxObjectSize / elementSize;\n+\n+   if (comp->target().is64Bit() && !(maxObjectSizeInElements >= 0 && maxObjectSizeInElements <= (uintptr_t)INT_MAX))\n+      {\n+      uint32_t high32 = maxObjectSizeInElements >> 32;\n+      generateRILInstruction(cg, TR::InstOpCode::LLIHF, node, temp1Reg, high32);\n+      generateRILInstruction(cg, TR::InstOpCode::IILF, node, temp1Reg, static_cast<uint32_t>(maxObjectSizeInElements));\n+      generateRIEInstruction(cg, TR::InstOpCode::CLGRJ, node, firstDimLenReg, temp1Reg, oolJumpLabel, TR::InstOpCode::COND_BRH);\n+      }\n+   else\n+      {\n+      generateRILInstruction(cg, TR::InstOpCode::CFI, node, firstDimLenReg, static_cast<uint32_t>(maxObjectSizeInElements));\n+      generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BHR, node, oolJumpLabel);\n+      }\n+\n+   // Now check to see if we have enough space to do the allocation. If not then jump to OOL code.\n+   generateRRInstruction(cg, TR::InstOpCode::LR, node, temp1Reg, firstDimLenReg);\n+\n+   int32_t round = (elementSize >= TR::Compiler->om.objectAlignmentInBytes()) ? 0 : TR::Compiler->om.objectAlignmentInBytes();\n+   int32_t disp32 = round ? (round - 1) : 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10d5904fe4cd34f70dcf0c92e294ba54ba930b38"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIwODMzOA==", "bodyText": "This should be static const. Also why the _ underscore?", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r527208338", "createdAt": "2020-11-19T21:24:37Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,264 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n ///////////////////////////////////////////////////////////////////////////////////////\n // multianewArrayEvaluator:  multi-dimensional new array of objects\n ///////////////////////////////////////////////////////////////////////////////////////\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::acall);\n-   TR::Register * targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n-   }\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = (TR_J9VMBase *)(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt() != 2)\n+      {\n+      traceMsg(cg->comp(), \"multianewArrayEvaluator - More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      return performHelperCall(node, NULL, TR::acall, false, cg);\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   // oolJumpLabel is a common point that all branches will jump to. From this label, we branch to OOL code.\n+   // We do this instead of jumping directly to OOL code from mainline because the RA can only handle the case where there's\n+   // a single jump point to OOL code.\n+   TR::LabelSymbol *oolJumpLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));\n+\n+   TR::Register *secondDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, secondDimLenReg, generateS390MemoryReference(dimsPtrReg, 0, cg));\n+\n+   // Check to see if second dimension is indeed 0. If yes, then proceed to handle the case here. Otherwise jump to OOL code.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, secondDimLenReg, 0, TR::InstOpCode::COND_BNE, oolJumpLabel, false);\n+\n+   // Now check to see if first dimension is also 0. If yes, continue below to handle the case when length for both dimensions is 0. Otherwise jump to nonZeroFirstDimLabel.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, 0, TR::InstOpCode::COND_BNE, nonZeroFirstDimLabel, false);\n+\n+   // First dimension zero, so only allocate 1 zero-length object array\n+   int32_t zeroArraySize = TR::Compiler->om.discontiguousArrayHeaderSizeInBytes();\n+   TR::Register *vmThreadReg = cg->getMethodMetaDataRealRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, targetReg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+\n+   // Branch to OOL if there's not enough space for an array of size 0.\n+   TR::Register *temp1Reg = cg->allocateRegister();\n+   generateRIEInstruction(cg, TR::InstOpCode::getAddHalfWordImmDistinctOperandOpCode(), node, temp1Reg, targetReg, zeroArraySize);\n+   generateRXInstruction(cg, TR::InstOpCode::getCmpLogicalOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapTop), cg));\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BH, node, oolJumpLabel);\n+\n+   // If there's enough space, then we can continue to allocate.\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+   \n+   bool use64BitClasses = comp->target().is64Bit() && !TR::Compiler->om.generateCompressedObjectHeaders();\n+\n+   // Init class and fields, then jump to end of ICF\n+   generateRXInstruction(cg, use64BitClasses ? TR::InstOpCode::STG : TR::InstOpCode::ST, node, classReg, generateS390MemoryReference(targetReg, TR::Compiler->om.offsetOfObjectVftField(), cg));\n+   generateSILInstruction(cg, use64BitClasses ? TR::InstOpCode::MVGHI : TR::InstOpCode::MVHI, node, generateS390MemoryReference(targetReg, fej9->getOffsetOfContiguousArraySizeField(), cg), 0);\n+   generateSILInstruction(cg, use64BitClasses ? TR::InstOpCode::MVGHI : TR::InstOpCode::MVHI, node, generateS390MemoryReference(targetReg, fej9->getOffsetOfDiscontiguousArraySizeField(), cg), 0);\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);\n+\n+   // We end up in this region of the ICF if the first dimension is non-zero and the second dimension is zero.\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, nonZeroFirstDimLabel);\n+\n+   TR::Register *componentClassReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, componentClassReg, generateS390MemoryReference(classReg, offsetof(J9ArrayClass, componentType), cg));\n+\n+   // Calculate maximum allowable object size in elements and ump to OOL if it's higher than firstDimLenReg.\n+   int32_t elementSize = comp->useCompressedPointers() ? TR::Compiler->om.sizeofReferenceField() : static_cast<int32_t>(TR::Compiler->om.sizeofReferenceAddress());\n+   uintptr_t maxObjectSize = cg->getMaxObjectSizeGuaranteedNotToOverflow();\n+   uintptr_t maxObjectSizeInElements = maxObjectSize / elementSize;\n+\n+   if (comp->target().is64Bit() && !(maxObjectSizeInElements >= 0 && maxObjectSizeInElements <= (uintptr_t)INT_MAX))\n+      {\n+      uint32_t high32 = maxObjectSizeInElements >> 32;\n+      generateRILInstruction(cg, TR::InstOpCode::LLIHF, node, temp1Reg, high32);\n+      generateRILInstruction(cg, TR::InstOpCode::IILF, node, temp1Reg, static_cast<uint32_t>(maxObjectSizeInElements));\n+      generateRIEInstruction(cg, TR::InstOpCode::CLGRJ, node, firstDimLenReg, temp1Reg, oolJumpLabel, TR::InstOpCode::COND_BRH);\n+      }\n+   else\n+      {\n+      generateRILInstruction(cg, TR::InstOpCode::CFI, node, firstDimLenReg, static_cast<uint32_t>(maxObjectSizeInElements));\n+      generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BHR, node, oolJumpLabel);\n+      }\n+\n+   // Now check to see if we have enough space to do the allocation. If not then jump to OOL code.\n+   generateRRInstruction(cg, TR::InstOpCode::LR, node, temp1Reg, firstDimLenReg);\n+\n+   int32_t round = (elementSize >= TR::Compiler->om.objectAlignmentInBytes()) ? 0 : TR::Compiler->om.objectAlignmentInBytes();\n+   int32_t disp32 = round ? (round - 1) : 0;\n+\n+   uint8_t _multiplierToStrideMap[] = {0, 0, 1, 0, 2, 0, 0, 0, 3};", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10d5904fe4cd34f70dcf0c92e294ba54ba930b38"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIwODkzNg==", "bodyText": "We should inline this variable as it is only used once.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r527208936", "createdAt": "2020-11-19T21:25:44Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,264 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n ///////////////////////////////////////////////////////////////////////////////////////\n // multianewArrayEvaluator:  multi-dimensional new array of objects\n ///////////////////////////////////////////////////////////////////////////////////////\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::acall);\n-   TR::Register * targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n-   }\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = (TR_J9VMBase *)(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt() != 2)\n+      {\n+      traceMsg(cg->comp(), \"multianewArrayEvaluator - More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      return performHelperCall(node, NULL, TR::acall, false, cg);\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   // oolJumpLabel is a common point that all branches will jump to. From this label, we branch to OOL code.\n+   // We do this instead of jumping directly to OOL code from mainline because the RA can only handle the case where there's\n+   // a single jump point to OOL code.\n+   TR::LabelSymbol *oolJumpLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));\n+\n+   TR::Register *secondDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, secondDimLenReg, generateS390MemoryReference(dimsPtrReg, 0, cg));\n+\n+   // Check to see if second dimension is indeed 0. If yes, then proceed to handle the case here. Otherwise jump to OOL code.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, secondDimLenReg, 0, TR::InstOpCode::COND_BNE, oolJumpLabel, false);\n+\n+   // Now check to see if first dimension is also 0. If yes, continue below to handle the case when length for both dimensions is 0. Otherwise jump to nonZeroFirstDimLabel.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, 0, TR::InstOpCode::COND_BNE, nonZeroFirstDimLabel, false);\n+\n+   // First dimension zero, so only allocate 1 zero-length object array\n+   int32_t zeroArraySize = TR::Compiler->om.discontiguousArrayHeaderSizeInBytes();\n+   TR::Register *vmThreadReg = cg->getMethodMetaDataRealRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, targetReg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+\n+   // Branch to OOL if there's not enough space for an array of size 0.\n+   TR::Register *temp1Reg = cg->allocateRegister();\n+   generateRIEInstruction(cg, TR::InstOpCode::getAddHalfWordImmDistinctOperandOpCode(), node, temp1Reg, targetReg, zeroArraySize);\n+   generateRXInstruction(cg, TR::InstOpCode::getCmpLogicalOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapTop), cg));\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BH, node, oolJumpLabel);\n+\n+   // If there's enough space, then we can continue to allocate.\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+   \n+   bool use64BitClasses = comp->target().is64Bit() && !TR::Compiler->om.generateCompressedObjectHeaders();\n+\n+   // Init class and fields, then jump to end of ICF\n+   generateRXInstruction(cg, use64BitClasses ? TR::InstOpCode::STG : TR::InstOpCode::ST, node, classReg, generateS390MemoryReference(targetReg, TR::Compiler->om.offsetOfObjectVftField(), cg));\n+   generateSILInstruction(cg, use64BitClasses ? TR::InstOpCode::MVGHI : TR::InstOpCode::MVHI, node, generateS390MemoryReference(targetReg, fej9->getOffsetOfContiguousArraySizeField(), cg), 0);\n+   generateSILInstruction(cg, use64BitClasses ? TR::InstOpCode::MVGHI : TR::InstOpCode::MVHI, node, generateS390MemoryReference(targetReg, fej9->getOffsetOfDiscontiguousArraySizeField(), cg), 0);\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);\n+\n+   // We end up in this region of the ICF if the first dimension is non-zero and the second dimension is zero.\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, nonZeroFirstDimLabel);\n+\n+   TR::Register *componentClassReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, componentClassReg, generateS390MemoryReference(classReg, offsetof(J9ArrayClass, componentType), cg));\n+\n+   // Calculate maximum allowable object size in elements and ump to OOL if it's higher than firstDimLenReg.\n+   int32_t elementSize = comp->useCompressedPointers() ? TR::Compiler->om.sizeofReferenceField() : static_cast<int32_t>(TR::Compiler->om.sizeofReferenceAddress());\n+   uintptr_t maxObjectSize = cg->getMaxObjectSizeGuaranteedNotToOverflow();\n+   uintptr_t maxObjectSizeInElements = maxObjectSize / elementSize;\n+\n+   if (comp->target().is64Bit() && !(maxObjectSizeInElements >= 0 && maxObjectSizeInElements <= (uintptr_t)INT_MAX))\n+      {\n+      uint32_t high32 = maxObjectSizeInElements >> 32;\n+      generateRILInstruction(cg, TR::InstOpCode::LLIHF, node, temp1Reg, high32);\n+      generateRILInstruction(cg, TR::InstOpCode::IILF, node, temp1Reg, static_cast<uint32_t>(maxObjectSizeInElements));\n+      generateRIEInstruction(cg, TR::InstOpCode::CLGRJ, node, firstDimLenReg, temp1Reg, oolJumpLabel, TR::InstOpCode::COND_BRH);\n+      }\n+   else\n+      {\n+      generateRILInstruction(cg, TR::InstOpCode::CFI, node, firstDimLenReg, static_cast<uint32_t>(maxObjectSizeInElements));\n+      generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BHR, node, oolJumpLabel);\n+      }\n+\n+   // Now check to see if we have enough space to do the allocation. If not then jump to OOL code.\n+   generateRRInstruction(cg, TR::InstOpCode::LR, node, temp1Reg, firstDimLenReg);\n+\n+   int32_t round = (elementSize >= TR::Compiler->om.objectAlignmentInBytes()) ? 0 : TR::Compiler->om.objectAlignmentInBytes();\n+   int32_t disp32 = round ? (round - 1) : 0;\n+\n+   uint8_t _multiplierToStrideMap[] = {0, 0, 1, 0, 2, 0, 0, 0, 3};\n+   uint8_t shiftVal = _multiplierToStrideMap[elementSize];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10d5904fe4cd34f70dcf0c92e294ba54ba930b38"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIxMDEyNg==", "bodyText": "You don't need the ternary here. sizeofReferenceField already checks for compressedrefs and returns the right thing.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r527210126", "createdAt": "2020-11-19T21:28:02Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,264 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n ///////////////////////////////////////////////////////////////////////////////////////\n // multianewArrayEvaluator:  multi-dimensional new array of objects\n ///////////////////////////////////////////////////////////////////////////////////////\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::acall);\n-   TR::Register * targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n-   }\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = (TR_J9VMBase *)(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt() != 2)\n+      {\n+      traceMsg(cg->comp(), \"multianewArrayEvaluator - More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      return performHelperCall(node, NULL, TR::acall, false, cg);\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   // oolJumpLabel is a common point that all branches will jump to. From this label, we branch to OOL code.\n+   // We do this instead of jumping directly to OOL code from mainline because the RA can only handle the case where there's\n+   // a single jump point to OOL code.\n+   TR::LabelSymbol *oolJumpLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));\n+\n+   TR::Register *secondDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, secondDimLenReg, generateS390MemoryReference(dimsPtrReg, 0, cg));\n+\n+   // Check to see if second dimension is indeed 0. If yes, then proceed to handle the case here. Otherwise jump to OOL code.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, secondDimLenReg, 0, TR::InstOpCode::COND_BNE, oolJumpLabel, false);\n+\n+   // Now check to see if first dimension is also 0. If yes, continue below to handle the case when length for both dimensions is 0. Otherwise jump to nonZeroFirstDimLabel.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, 0, TR::InstOpCode::COND_BNE, nonZeroFirstDimLabel, false);\n+\n+   // First dimension zero, so only allocate 1 zero-length object array\n+   int32_t zeroArraySize = TR::Compiler->om.discontiguousArrayHeaderSizeInBytes();\n+   TR::Register *vmThreadReg = cg->getMethodMetaDataRealRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, targetReg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+\n+   // Branch to OOL if there's not enough space for an array of size 0.\n+   TR::Register *temp1Reg = cg->allocateRegister();\n+   generateRIEInstruction(cg, TR::InstOpCode::getAddHalfWordImmDistinctOperandOpCode(), node, temp1Reg, targetReg, zeroArraySize);\n+   generateRXInstruction(cg, TR::InstOpCode::getCmpLogicalOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapTop), cg));\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BH, node, oolJumpLabel);\n+\n+   // If there's enough space, then we can continue to allocate.\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+   \n+   bool use64BitClasses = comp->target().is64Bit() && !TR::Compiler->om.generateCompressedObjectHeaders();\n+\n+   // Init class and fields, then jump to end of ICF\n+   generateRXInstruction(cg, use64BitClasses ? TR::InstOpCode::STG : TR::InstOpCode::ST, node, classReg, generateS390MemoryReference(targetReg, TR::Compiler->om.offsetOfObjectVftField(), cg));\n+   generateSILInstruction(cg, use64BitClasses ? TR::InstOpCode::MVGHI : TR::InstOpCode::MVHI, node, generateS390MemoryReference(targetReg, fej9->getOffsetOfContiguousArraySizeField(), cg), 0);\n+   generateSILInstruction(cg, use64BitClasses ? TR::InstOpCode::MVGHI : TR::InstOpCode::MVHI, node, generateS390MemoryReference(targetReg, fej9->getOffsetOfDiscontiguousArraySizeField(), cg), 0);\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);\n+\n+   // We end up in this region of the ICF if the first dimension is non-zero and the second dimension is zero.\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, nonZeroFirstDimLabel);\n+\n+   TR::Register *componentClassReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, componentClassReg, generateS390MemoryReference(classReg, offsetof(J9ArrayClass, componentType), cg));\n+\n+   // Calculate maximum allowable object size in elements and ump to OOL if it's higher than firstDimLenReg.\n+   int32_t elementSize = comp->useCompressedPointers() ? TR::Compiler->om.sizeofReferenceField() : static_cast<int32_t>(TR::Compiler->om.sizeofReferenceAddress());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10d5904fe4cd34f70dcf0c92e294ba54ba930b38"}, "originalPosition": 106}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM1NjYwNDY0", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#pullrequestreview-535660464", "createdAt": "2020-11-20T18:00:33Z", "commit": {"oid": "0d2a7a622a97110d921a531735d149005cfec0f1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxODowMDozNFrOH3bGTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxODowMDozNFrOH3bGTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzg3NzcxMQ==", "bodyText": "We don't need to zero out memory on Z since it is already bulk cleared. We should remove these two stores.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r527877711", "createdAt": "2020-11-20T18:00:34Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,259 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n ///////////////////////////////////////////////////////////////////////////////////////\n // multianewArrayEvaluator:  multi-dimensional new array of objects\n ///////////////////////////////////////////////////////////////////////////////////////\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::acall);\n-   TR::Register * targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n-   }\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = static_cast<TR_J9VMBase *>(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt() != 2)\n+      {\n+      traceMsg(cg->comp(), \"multianewArrayEvaluator - More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      return performHelperCall(node, NULL, TR::acall, false, cg);\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   // oolJumpLabel is a common point that all branches will jump to. From this label, we branch to OOL code.\n+   // We do this instead of jumping directly to OOL code from mainline because the RA can only handle the case where there's\n+   // a single jump point to OOL code.\n+   TR::LabelSymbol *oolJumpLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));\n+\n+   TR::Register *secondDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, secondDimLenReg, generateS390MemoryReference(dimsPtrReg, 0, cg));\n+\n+   // Check to see if second dimension is indeed 0. If yes, then proceed to handle the case here. Otherwise jump to OOL code.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, secondDimLenReg, 0, TR::InstOpCode::COND_BNE, oolJumpLabel, false);\n+\n+   // Now check to see if first dimension is also 0. If yes, continue below to handle the case when length for both dimensions is 0. Otherwise jump to nonZeroFirstDimLabel.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, 0, TR::InstOpCode::COND_BNE, nonZeroFirstDimLabel, false);\n+\n+   // First dimension zero, so only allocate 1 zero-length object array\n+   int32_t zeroArraySize = TR::Compiler->om.discontiguousArrayHeaderSizeInBytes();\n+   TR::Register *vmThreadReg = cg->getMethodMetaDataRealRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, targetReg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+\n+   // Branch to OOL if there's not enough space for an array of size 0.\n+   TR::Register *temp1Reg = cg->allocateRegister();\n+   generateRIEInstruction(cg, TR::InstOpCode::getAddHalfWordImmDistinctOperandOpCode(), node, temp1Reg, targetReg, zeroArraySize);\n+   generateRXInstruction(cg, TR::InstOpCode::getCmpLogicalOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapTop), cg));\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BH, node, oolJumpLabel);\n+\n+   // If there's enough space, then we can continue to allocate.\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+   \n+   bool use64BitClasses = comp->target().is64Bit() && !TR::Compiler->om.generateCompressedObjectHeaders();\n+\n+   // Init class and fields, then jump to end of ICF\n+   generateRXInstruction(cg, use64BitClasses ? TR::InstOpCode::STG : TR::InstOpCode::ST, node, classReg, generateS390MemoryReference(targetReg, TR::Compiler->om.offsetOfObjectVftField(), cg));\n+   generateSILInstruction(cg, use64BitClasses ? TR::InstOpCode::MVGHI : TR::InstOpCode::MVHI, node, generateS390MemoryReference(targetReg, fej9->getOffsetOfContiguousArraySizeField(), cg), 0);\n+   generateSILInstruction(cg, use64BitClasses ? TR::InstOpCode::MVGHI : TR::InstOpCode::MVHI, node, generateS390MemoryReference(targetReg, fej9->getOffsetOfDiscontiguousArraySizeField(), cg), 0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d2a7a622a97110d921a531735d149005cfec0f1"}, "originalPosition": 96}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM1NzAxMjc1", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#pullrequestreview-535701275", "createdAt": "2020-11-20T19:01:52Z", "commit": {"oid": "0d2a7a622a97110d921a531735d149005cfec0f1"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxOTowMTo1MlrOH3dMQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxOToyMzowOVrOH3d3Dg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzkxMjAwMw==", "bodyText": "This is incorrect. firstDimLenReg is a 32-bit value, so it would be functionally incorrect to test this value against a 64-bit constant. The upper 32-bits are dirty. IMO we should just have a check up front where we check !secondChild->getOpCode().isLoadConst() and just ensure the array is not greater than cg->getMaxObjectSizeGuaranteedNotToOverflow(), and if it is just bail out of the inline sequence.\nWe're only trying to accelerate the most common cases here. If someone is allocating a 2D array of size > 0x10000000 we should just let the helper handle it.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r527912003", "createdAt": "2020-11-20T19:01:52Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,259 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n ///////////////////////////////////////////////////////////////////////////////////////\n // multianewArrayEvaluator:  multi-dimensional new array of objects\n ///////////////////////////////////////////////////////////////////////////////////////\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::acall);\n-   TR::Register * targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n-   }\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = static_cast<TR_J9VMBase *>(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt() != 2)\n+      {\n+      traceMsg(cg->comp(), \"multianewArrayEvaluator - More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      return performHelperCall(node, NULL, TR::acall, false, cg);\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   // oolJumpLabel is a common point that all branches will jump to. From this label, we branch to OOL code.\n+   // We do this instead of jumping directly to OOL code from mainline because the RA can only handle the case where there's\n+   // a single jump point to OOL code.\n+   TR::LabelSymbol *oolJumpLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));\n+\n+   TR::Register *secondDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, secondDimLenReg, generateS390MemoryReference(dimsPtrReg, 0, cg));\n+\n+   // Check to see if second dimension is indeed 0. If yes, then proceed to handle the case here. Otherwise jump to OOL code.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, secondDimLenReg, 0, TR::InstOpCode::COND_BNE, oolJumpLabel, false);\n+\n+   // Now check to see if first dimension is also 0. If yes, continue below to handle the case when length for both dimensions is 0. Otherwise jump to nonZeroFirstDimLabel.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, 0, TR::InstOpCode::COND_BNE, nonZeroFirstDimLabel, false);\n+\n+   // First dimension zero, so only allocate 1 zero-length object array\n+   int32_t zeroArraySize = TR::Compiler->om.discontiguousArrayHeaderSizeInBytes();\n+   TR::Register *vmThreadReg = cg->getMethodMetaDataRealRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, targetReg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+\n+   // Branch to OOL if there's not enough space for an array of size 0.\n+   TR::Register *temp1Reg = cg->allocateRegister();\n+   generateRIEInstruction(cg, TR::InstOpCode::getAddHalfWordImmDistinctOperandOpCode(), node, temp1Reg, targetReg, zeroArraySize);\n+   generateRXInstruction(cg, TR::InstOpCode::getCmpLogicalOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapTop), cg));\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BH, node, oolJumpLabel);\n+\n+   // If there's enough space, then we can continue to allocate.\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+   \n+   bool use64BitClasses = comp->target().is64Bit() && !TR::Compiler->om.generateCompressedObjectHeaders();\n+\n+   // Init class and fields, then jump to end of ICF\n+   generateRXInstruction(cg, use64BitClasses ? TR::InstOpCode::STG : TR::InstOpCode::ST, node, classReg, generateS390MemoryReference(targetReg, TR::Compiler->om.offsetOfObjectVftField(), cg));\n+   generateSILInstruction(cg, use64BitClasses ? TR::InstOpCode::MVGHI : TR::InstOpCode::MVHI, node, generateS390MemoryReference(targetReg, fej9->getOffsetOfContiguousArraySizeField(), cg), 0);\n+   generateSILInstruction(cg, use64BitClasses ? TR::InstOpCode::MVGHI : TR::InstOpCode::MVHI, node, generateS390MemoryReference(targetReg, fej9->getOffsetOfDiscontiguousArraySizeField(), cg), 0);\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);\n+\n+   // We end up in this region of the ICF if the first dimension is non-zero and the second dimension is zero.\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, nonZeroFirstDimLabel);\n+\n+   TR::Register *componentClassReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, componentClassReg, generateS390MemoryReference(classReg, offsetof(J9ArrayClass, componentType), cg));\n+\n+   // Calculate maximum allowable object size in elements and jump to OOL if it's higher than firstDimLenReg.\n+   int32_t elementSize = TR::Compiler->om.sizeofReferenceField();\n+   uintptr_t maxObjectSize = cg->getMaxObjectSizeGuaranteedNotToOverflow();\n+   uintptr_t maxObjectSizeInElements = maxObjectSize / elementSize;\n+\n+   if (comp->target().is64Bit() && !(maxObjectSizeInElements >= 0 && maxObjectSizeInElements <= (uintptr_t)INT_MAX))\n+      {\n+      generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CLG, node, firstDimLenReg, static_cast<int64_t>(maxObjectSizeInElements), TR::InstOpCode::COND_BRH, oolJumpLabel, false);\n+      }\n+   else\n+      {\n+      generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, static_cast<int32_t>(maxObjectSizeInElements), TR::InstOpCode::COND_BHR, oolJumpLabel, false);\n+      }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d2a7a622a97110d921a531735d149005cfec0f1"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzkyMjExNg==", "bodyText": "Thought about this again. So elementSize is only 4 or 8 bytes realistically, so under 64-bit compressedrefs we can have the false case of the ternary here. We should use the OMR::align API here though.\nint32_t elementSizeAligned = OMR::align(elementSize, TR::Compiler->om.objectAlignmentInBytes());\nint32_t alignmentCompensation = (elementSize == elementSizeAligned) ? 0 : elementSizeAligned - 1;\n\n...\n\nif (alignmentCompensation != 0)\n   {\n   generateRILInstruction(cg, TR::InstOpCode::NILF, node, temp1Reg, -alignmentCompensation);\n   }", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r527922116", "createdAt": "2020-11-20T19:21:28Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,264 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n ///////////////////////////////////////////////////////////////////////////////////////\n // multianewArrayEvaluator:  multi-dimensional new array of objects\n ///////////////////////////////////////////////////////////////////////////////////////\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::acall);\n-   TR::Register * targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n-   }\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = (TR_J9VMBase *)(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt() != 2)\n+      {\n+      traceMsg(cg->comp(), \"multianewArrayEvaluator - More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      return performHelperCall(node, NULL, TR::acall, false, cg);\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   // oolJumpLabel is a common point that all branches will jump to. From this label, we branch to OOL code.\n+   // We do this instead of jumping directly to OOL code from mainline because the RA can only handle the case where there's\n+   // a single jump point to OOL code.\n+   TR::LabelSymbol *oolJumpLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));\n+\n+   TR::Register *secondDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, secondDimLenReg, generateS390MemoryReference(dimsPtrReg, 0, cg));\n+\n+   // Check to see if second dimension is indeed 0. If yes, then proceed to handle the case here. Otherwise jump to OOL code.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, secondDimLenReg, 0, TR::InstOpCode::COND_BNE, oolJumpLabel, false);\n+\n+   // Now check to see if first dimension is also 0. If yes, continue below to handle the case when length for both dimensions is 0. Otherwise jump to nonZeroFirstDimLabel.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, 0, TR::InstOpCode::COND_BNE, nonZeroFirstDimLabel, false);\n+\n+   // First dimension zero, so only allocate 1 zero-length object array\n+   int32_t zeroArraySize = TR::Compiler->om.discontiguousArrayHeaderSizeInBytes();\n+   TR::Register *vmThreadReg = cg->getMethodMetaDataRealRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, targetReg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+\n+   // Branch to OOL if there's not enough space for an array of size 0.\n+   TR::Register *temp1Reg = cg->allocateRegister();\n+   generateRIEInstruction(cg, TR::InstOpCode::getAddHalfWordImmDistinctOperandOpCode(), node, temp1Reg, targetReg, zeroArraySize);\n+   generateRXInstruction(cg, TR::InstOpCode::getCmpLogicalOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapTop), cg));\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BH, node, oolJumpLabel);\n+\n+   // If there's enough space, then we can continue to allocate.\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+   \n+   bool use64BitClasses = comp->target().is64Bit() && !TR::Compiler->om.generateCompressedObjectHeaders();\n+\n+   // Init class and fields, then jump to end of ICF\n+   generateRXInstruction(cg, use64BitClasses ? TR::InstOpCode::STG : TR::InstOpCode::ST, node, classReg, generateS390MemoryReference(targetReg, TR::Compiler->om.offsetOfObjectVftField(), cg));\n+   generateSILInstruction(cg, use64BitClasses ? TR::InstOpCode::MVGHI : TR::InstOpCode::MVHI, node, generateS390MemoryReference(targetReg, fej9->getOffsetOfContiguousArraySizeField(), cg), 0);\n+   generateSILInstruction(cg, use64BitClasses ? TR::InstOpCode::MVGHI : TR::InstOpCode::MVHI, node, generateS390MemoryReference(targetReg, fej9->getOffsetOfDiscontiguousArraySizeField(), cg), 0);\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);\n+\n+   // We end up in this region of the ICF if the first dimension is non-zero and the second dimension is zero.\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, nonZeroFirstDimLabel);\n+\n+   TR::Register *componentClassReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, componentClassReg, generateS390MemoryReference(classReg, offsetof(J9ArrayClass, componentType), cg));\n+\n+   // Calculate maximum allowable object size in elements and ump to OOL if it's higher than firstDimLenReg.\n+   int32_t elementSize = comp->useCompressedPointers() ? TR::Compiler->om.sizeofReferenceField() : static_cast<int32_t>(TR::Compiler->om.sizeofReferenceAddress());\n+   uintptr_t maxObjectSize = cg->getMaxObjectSizeGuaranteedNotToOverflow();\n+   uintptr_t maxObjectSizeInElements = maxObjectSize / elementSize;\n+\n+   if (comp->target().is64Bit() && !(maxObjectSizeInElements >= 0 && maxObjectSizeInElements <= (uintptr_t)INT_MAX))\n+      {\n+      uint32_t high32 = maxObjectSizeInElements >> 32;\n+      generateRILInstruction(cg, TR::InstOpCode::LLIHF, node, temp1Reg, high32);\n+      generateRILInstruction(cg, TR::InstOpCode::IILF, node, temp1Reg, static_cast<uint32_t>(maxObjectSizeInElements));\n+      generateRIEInstruction(cg, TR::InstOpCode::CLGRJ, node, firstDimLenReg, temp1Reg, oolJumpLabel, TR::InstOpCode::COND_BRH);\n+      }\n+   else\n+      {\n+      generateRILInstruction(cg, TR::InstOpCode::CFI, node, firstDimLenReg, static_cast<uint32_t>(maxObjectSizeInElements));\n+      generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BHR, node, oolJumpLabel);\n+      }\n+\n+   // Now check to see if we have enough space to do the allocation. If not then jump to OOL code.\n+   generateRRInstruction(cg, TR::InstOpCode::LR, node, temp1Reg, firstDimLenReg);\n+\n+   int32_t round = (elementSize >= TR::Compiler->om.objectAlignmentInBytes()) ? 0 : TR::Compiler->om.objectAlignmentInBytes();\n+   int32_t disp32 = round ? (round - 1) : 0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIwNzMxNw=="}, "originalCommit": {"oid": "10d5904fe4cd34f70dcf0c92e294ba54ba930b38"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzkyMjYyMA==", "bodyText": "We can get rid of this load by just using firstDimLenReg in the shift below.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r527922620", "createdAt": "2020-11-20T19:22:27Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,259 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n ///////////////////////////////////////////////////////////////////////////////////////\n // multianewArrayEvaluator:  multi-dimensional new array of objects\n ///////////////////////////////////////////////////////////////////////////////////////\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::acall);\n-   TR::Register * targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n-   }\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = static_cast<TR_J9VMBase *>(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt() != 2)\n+      {\n+      traceMsg(cg->comp(), \"multianewArrayEvaluator - More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      return performHelperCall(node, NULL, TR::acall, false, cg);\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   // oolJumpLabel is a common point that all branches will jump to. From this label, we branch to OOL code.\n+   // We do this instead of jumping directly to OOL code from mainline because the RA can only handle the case where there's\n+   // a single jump point to OOL code.\n+   TR::LabelSymbol *oolJumpLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));\n+\n+   TR::Register *secondDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, secondDimLenReg, generateS390MemoryReference(dimsPtrReg, 0, cg));\n+\n+   // Check to see if second dimension is indeed 0. If yes, then proceed to handle the case here. Otherwise jump to OOL code.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, secondDimLenReg, 0, TR::InstOpCode::COND_BNE, oolJumpLabel, false);\n+\n+   // Now check to see if first dimension is also 0. If yes, continue below to handle the case when length for both dimensions is 0. Otherwise jump to nonZeroFirstDimLabel.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, 0, TR::InstOpCode::COND_BNE, nonZeroFirstDimLabel, false);\n+\n+   // First dimension zero, so only allocate 1 zero-length object array\n+   int32_t zeroArraySize = TR::Compiler->om.discontiguousArrayHeaderSizeInBytes();\n+   TR::Register *vmThreadReg = cg->getMethodMetaDataRealRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, targetReg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+\n+   // Branch to OOL if there's not enough space for an array of size 0.\n+   TR::Register *temp1Reg = cg->allocateRegister();\n+   generateRIEInstruction(cg, TR::InstOpCode::getAddHalfWordImmDistinctOperandOpCode(), node, temp1Reg, targetReg, zeroArraySize);\n+   generateRXInstruction(cg, TR::InstOpCode::getCmpLogicalOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapTop), cg));\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BH, node, oolJumpLabel);\n+\n+   // If there's enough space, then we can continue to allocate.\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+   \n+   bool use64BitClasses = comp->target().is64Bit() && !TR::Compiler->om.generateCompressedObjectHeaders();\n+\n+   // Init class and fields, then jump to end of ICF\n+   generateRXInstruction(cg, use64BitClasses ? TR::InstOpCode::STG : TR::InstOpCode::ST, node, classReg, generateS390MemoryReference(targetReg, TR::Compiler->om.offsetOfObjectVftField(), cg));\n+   generateSILInstruction(cg, use64BitClasses ? TR::InstOpCode::MVGHI : TR::InstOpCode::MVHI, node, generateS390MemoryReference(targetReg, fej9->getOffsetOfContiguousArraySizeField(), cg), 0);\n+   generateSILInstruction(cg, use64BitClasses ? TR::InstOpCode::MVGHI : TR::InstOpCode::MVHI, node, generateS390MemoryReference(targetReg, fej9->getOffsetOfDiscontiguousArraySizeField(), cg), 0);\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);\n+\n+   // We end up in this region of the ICF if the first dimension is non-zero and the second dimension is zero.\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, nonZeroFirstDimLabel);\n+\n+   TR::Register *componentClassReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, componentClassReg, generateS390MemoryReference(classReg, offsetof(J9ArrayClass, componentType), cg));\n+\n+   // Calculate maximum allowable object size in elements and jump to OOL if it's higher than firstDimLenReg.\n+   int32_t elementSize = TR::Compiler->om.sizeofReferenceField();\n+   uintptr_t maxObjectSize = cg->getMaxObjectSizeGuaranteedNotToOverflow();\n+   uintptr_t maxObjectSizeInElements = maxObjectSize / elementSize;\n+\n+   if (comp->target().is64Bit() && !(maxObjectSizeInElements >= 0 && maxObjectSizeInElements <= (uintptr_t)INT_MAX))\n+      {\n+      generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CLG, node, firstDimLenReg, static_cast<int64_t>(maxObjectSizeInElements), TR::InstOpCode::COND_BRH, oolJumpLabel, false);\n+      }\n+   else\n+      {\n+      generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, static_cast<int32_t>(maxObjectSizeInElements), TR::InstOpCode::COND_BHR, oolJumpLabel, false);\n+      }\n+\n+   // Now check to see if we have enough space to do the allocation. If not then jump to OOL code.\n+   generateRRInstruction(cg, TR::InstOpCode::LR, node, temp1Reg, firstDimLenReg);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d2a7a622a97110d921a531735d149005cfec0f1"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzkyMjgwMA==", "bodyText": "I'd like to see a fatal assert here if elementSize > 8 otherwise this will access garbage data.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r527922800", "createdAt": "2020-11-20T19:22:51Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,259 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n ///////////////////////////////////////////////////////////////////////////////////////\n // multianewArrayEvaluator:  multi-dimensional new array of objects\n ///////////////////////////////////////////////////////////////////////////////////////\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::acall);\n-   TR::Register * targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n-   }\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = static_cast<TR_J9VMBase *>(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt() != 2)\n+      {\n+      traceMsg(cg->comp(), \"multianewArrayEvaluator - More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      return performHelperCall(node, NULL, TR::acall, false, cg);\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   // oolJumpLabel is a common point that all branches will jump to. From this label, we branch to OOL code.\n+   // We do this instead of jumping directly to OOL code from mainline because the RA can only handle the case where there's\n+   // a single jump point to OOL code.\n+   TR::LabelSymbol *oolJumpLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));\n+\n+   TR::Register *secondDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, secondDimLenReg, generateS390MemoryReference(dimsPtrReg, 0, cg));\n+\n+   // Check to see if second dimension is indeed 0. If yes, then proceed to handle the case here. Otherwise jump to OOL code.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, secondDimLenReg, 0, TR::InstOpCode::COND_BNE, oolJumpLabel, false);\n+\n+   // Now check to see if first dimension is also 0. If yes, continue below to handle the case when length for both dimensions is 0. Otherwise jump to nonZeroFirstDimLabel.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, 0, TR::InstOpCode::COND_BNE, nonZeroFirstDimLabel, false);\n+\n+   // First dimension zero, so only allocate 1 zero-length object array\n+   int32_t zeroArraySize = TR::Compiler->om.discontiguousArrayHeaderSizeInBytes();\n+   TR::Register *vmThreadReg = cg->getMethodMetaDataRealRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, targetReg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+\n+   // Branch to OOL if there's not enough space for an array of size 0.\n+   TR::Register *temp1Reg = cg->allocateRegister();\n+   generateRIEInstruction(cg, TR::InstOpCode::getAddHalfWordImmDistinctOperandOpCode(), node, temp1Reg, targetReg, zeroArraySize);\n+   generateRXInstruction(cg, TR::InstOpCode::getCmpLogicalOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapTop), cg));\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BH, node, oolJumpLabel);\n+\n+   // If there's enough space, then we can continue to allocate.\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+   \n+   bool use64BitClasses = comp->target().is64Bit() && !TR::Compiler->om.generateCompressedObjectHeaders();\n+\n+   // Init class and fields, then jump to end of ICF\n+   generateRXInstruction(cg, use64BitClasses ? TR::InstOpCode::STG : TR::InstOpCode::ST, node, classReg, generateS390MemoryReference(targetReg, TR::Compiler->om.offsetOfObjectVftField(), cg));\n+   generateSILInstruction(cg, use64BitClasses ? TR::InstOpCode::MVGHI : TR::InstOpCode::MVHI, node, generateS390MemoryReference(targetReg, fej9->getOffsetOfContiguousArraySizeField(), cg), 0);\n+   generateSILInstruction(cg, use64BitClasses ? TR::InstOpCode::MVGHI : TR::InstOpCode::MVHI, node, generateS390MemoryReference(targetReg, fej9->getOffsetOfDiscontiguousArraySizeField(), cg), 0);\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);\n+\n+   // We end up in this region of the ICF if the first dimension is non-zero and the second dimension is zero.\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, nonZeroFirstDimLabel);\n+\n+   TR::Register *componentClassReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, componentClassReg, generateS390MemoryReference(classReg, offsetof(J9ArrayClass, componentType), cg));\n+\n+   // Calculate maximum allowable object size in elements and jump to OOL if it's higher than firstDimLenReg.\n+   int32_t elementSize = TR::Compiler->om.sizeofReferenceField();\n+   uintptr_t maxObjectSize = cg->getMaxObjectSizeGuaranteedNotToOverflow();\n+   uintptr_t maxObjectSizeInElements = maxObjectSize / elementSize;\n+\n+   if (comp->target().is64Bit() && !(maxObjectSizeInElements >= 0 && maxObjectSizeInElements <= (uintptr_t)INT_MAX))\n+      {\n+      generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CLG, node, firstDimLenReg, static_cast<int64_t>(maxObjectSizeInElements), TR::InstOpCode::COND_BRH, oolJumpLabel, false);\n+      }\n+   else\n+      {\n+      generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, static_cast<int32_t>(maxObjectSizeInElements), TR::InstOpCode::COND_BHR, oolJumpLabel, false);\n+      }\n+\n+   // Now check to see if we have enough space to do the allocation. If not then jump to OOL code.\n+   generateRRInstruction(cg, TR::InstOpCode::LR, node, temp1Reg, firstDimLenReg);\n+\n+   int32_t round = (elementSize >= TR::Compiler->om.objectAlignmentInBytes()) ? 0 : TR::Compiler->om.objectAlignmentInBytes();\n+   int32_t disp32 = round ? (round - 1) : 0;\n+\n+   static const uint8_t multiplierToStrideMap[] = {0, 0, 1, 0, 2, 0, 0, 0, 3};\n+   generateRSInstruction(cg, TR::InstOpCode::getShiftLeftLogicalSingleOpCode(), node, temp1Reg, temp1Reg, multiplierToStrideMap[elementSize]);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d2a7a622a97110d921a531735d149005cfec0f1"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzkyMjk1OA==", "bodyText": "We can fold firstDimLenReg into the shift. Also let's not use a magic constant here. As Igor's recent work has shown the value of discontiguousArrayHeaderSizeInBytes can change in the future, so we don't want to hunt this bug down. Use the API.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r527922958", "createdAt": "2020-11-20T19:23:09Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2937,19 +2937,259 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n       return TR::TreeEvaluator::VMnewEvaluator(node, cg);\n    }\n \n+TR::Register *\n+performHelperCall(TR::Node *node, TR::SymbolReference *helperSymRef, TR::ILOpCodes helperCallOpCode, bool spillFPRegs, TR::CodeGenerator *cg)\n+   {\n+   TR::ILOpCodes opCode = node->getOpCodeValue();\n+   TR::Node::recreate(node, helperCallOpCode);\n+   if (helperSymRef)\n+      {\n+      node->setSymbolReference(helperSymRef);\n+      }\n+   TR::Register *targetReg = TR::TreeEvaluator::performCall(node, false /* isIndirect */, cg);\n+   TR::Node::recreate(node, opCode);\n+   return targetReg;\n+   }\n+\n ///////////////////////////////////////////////////////////////////////////////////////\n // multianewArrayEvaluator:  multi-dimensional new array of objects\n ///////////////////////////////////////////////////////////////////////////////////////\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n-   TR::ILOpCodes opCode = node->getOpCodeValue();\n-   TR::Node::recreate(node, TR::acall);\n-   TR::Register * targetRegister = directCallEvaluator(node, cg);\n-   TR::Node::recreate(node, opCode);\n-   return targetRegister;\n-   }\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = static_cast<TR_J9VMBase *>(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt() != 2)\n+      {\n+      traceMsg(cg->comp(), \"multianewArrayEvaluator - More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      return performHelperCall(node, NULL, TR::acall, false, cg);\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   // oolJumpLabel is a common point that all branches will jump to. From this label, we branch to OOL code.\n+   // We do this instead of jumping directly to OOL code from mainline because the RA can only handle the case where there's\n+   // a single jump point to OOL code.\n+   TR::LabelSymbol *oolJumpLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));\n+\n+   TR::Register *secondDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, secondDimLenReg, generateS390MemoryReference(dimsPtrReg, 0, cg));\n+\n+   // Check to see if second dimension is indeed 0. If yes, then proceed to handle the case here. Otherwise jump to OOL code.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, secondDimLenReg, 0, TR::InstOpCode::COND_BNE, oolJumpLabel, false);\n+\n+   // Now check to see if first dimension is also 0. If yes, continue below to handle the case when length for both dimensions is 0. Otherwise jump to nonZeroFirstDimLabel.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, 0, TR::InstOpCode::COND_BNE, nonZeroFirstDimLabel, false);\n+\n+   // First dimension zero, so only allocate 1 zero-length object array\n+   int32_t zeroArraySize = TR::Compiler->om.discontiguousArrayHeaderSizeInBytes();\n+   TR::Register *vmThreadReg = cg->getMethodMetaDataRealRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, targetReg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+\n+   // Branch to OOL if there's not enough space for an array of size 0.\n+   TR::Register *temp1Reg = cg->allocateRegister();\n+   generateRIEInstruction(cg, TR::InstOpCode::getAddHalfWordImmDistinctOperandOpCode(), node, temp1Reg, targetReg, zeroArraySize);\n+   generateRXInstruction(cg, TR::InstOpCode::getCmpLogicalOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapTop), cg));\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BH, node, oolJumpLabel);\n+\n+   // If there's enough space, then we can continue to allocate.\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+   \n+   bool use64BitClasses = comp->target().is64Bit() && !TR::Compiler->om.generateCompressedObjectHeaders();\n+\n+   // Init class and fields, then jump to end of ICF\n+   generateRXInstruction(cg, use64BitClasses ? TR::InstOpCode::STG : TR::InstOpCode::ST, node, classReg, generateS390MemoryReference(targetReg, TR::Compiler->om.offsetOfObjectVftField(), cg));\n+   generateSILInstruction(cg, use64BitClasses ? TR::InstOpCode::MVGHI : TR::InstOpCode::MVHI, node, generateS390MemoryReference(targetReg, fej9->getOffsetOfContiguousArraySizeField(), cg), 0);\n+   generateSILInstruction(cg, use64BitClasses ? TR::InstOpCode::MVGHI : TR::InstOpCode::MVHI, node, generateS390MemoryReference(targetReg, fej9->getOffsetOfDiscontiguousArraySizeField(), cg), 0);\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);\n+\n+   // We end up in this region of the ICF if the first dimension is non-zero and the second dimension is zero.\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, nonZeroFirstDimLabel);\n+\n+   TR::Register *componentClassReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, componentClassReg, generateS390MemoryReference(classReg, offsetof(J9ArrayClass, componentType), cg));\n+\n+   // Calculate maximum allowable object size in elements and jump to OOL if it's higher than firstDimLenReg.\n+   int32_t elementSize = TR::Compiler->om.sizeofReferenceField();\n+   uintptr_t maxObjectSize = cg->getMaxObjectSizeGuaranteedNotToOverflow();\n+   uintptr_t maxObjectSizeInElements = maxObjectSize / elementSize;\n+\n+   if (comp->target().is64Bit() && !(maxObjectSizeInElements >= 0 && maxObjectSizeInElements <= (uintptr_t)INT_MAX))\n+      {\n+      generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CLG, node, firstDimLenReg, static_cast<int64_t>(maxObjectSizeInElements), TR::InstOpCode::COND_BRH, oolJumpLabel, false);\n+      }\n+   else\n+      {\n+      generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, static_cast<int32_t>(maxObjectSizeInElements), TR::InstOpCode::COND_BHR, oolJumpLabel, false);\n+      }\n+\n+   // Now check to see if we have enough space to do the allocation. If not then jump to OOL code.\n+   generateRRInstruction(cg, TR::InstOpCode::LR, node, temp1Reg, firstDimLenReg);\n+\n+   int32_t round = (elementSize >= TR::Compiler->om.objectAlignmentInBytes()) ? 0 : TR::Compiler->om.objectAlignmentInBytes();\n+   int32_t disp32 = round ? (round - 1) : 0;\n+\n+   static const uint8_t multiplierToStrideMap[] = {0, 0, 1, 0, 2, 0, 0, 0, 3};\n+   generateRSInstruction(cg, TR::InstOpCode::getShiftLeftLogicalSingleOpCode(), node, temp1Reg, temp1Reg, multiplierToStrideMap[elementSize]);\n+   generateRILInstruction(cg, TR::InstOpCode::AGFI, node, temp1Reg, static_cast<int32_t>(TR::Compiler->om.contiguousArrayHeaderSizeInBytes()) + disp32);\n+\n+   if (round)\n+      {\n+      generateRILInstruction(cg, TR::InstOpCode::NILF, node, temp1Reg, -round);\n+      }\n \n+   // temp2Reg = firstDimLenReg * 16 (discontiguousArrayHeaderSizeInBytes)\n+   TR::Register *temp2Reg = cg->allocateRegister();\n+   generateRRInstruction(cg, TR::InstOpCode::LR, node, temp2Reg, firstDimLenReg);\n+   generateRSInstruction(cg, TR::InstOpCode::getShiftLeftLogicalSingleOpCode(), node, temp2Reg, temp2Reg, 4);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d2a7a622a97110d921a531735d149005cfec0f1"}, "originalPosition": 137}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "901d570b864c2d25b5bdbf9f1b547aabf7af1113", "author": {"user": {"login": "dchopra001", "name": "Dhruv Chopra"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/901d570b864c2d25b5bdbf9f1b547aabf7af1113", "committedDate": "2020-11-22T19:46:10Z", "message": "Remove unnecessary LR instruction.\n\nSigned-off-by: Dhruv Chopra <Dhruv.C.Chopra@ibm.com>"}, "afterCommit": {"oid": "fcb9ecf5318e844e2f5c852fe7ce4fee10dfff5e", "author": {"user": {"login": "dchopra001", "name": "Dhruv Chopra"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/fcb9ecf5318e844e2f5c852fe7ce4fee10dfff5e", "committedDate": "2020-11-23T04:42:51Z", "message": "-Remove unnecessary LR instructions.\n-Add assert to make sure elementSize <= 8\n-Add assert for discontiguousArrayHeaderSizeInBytes == 16\n-Use OMR::align API to do element alignment\n-Remove use of performHelperCall routine\n\nSigned-off-by: Dhruv Chopra <Dhruv.C.Chopra@ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "fcb9ecf5318e844e2f5c852fe7ce4fee10dfff5e", "author": {"user": {"login": "dchopra001", "name": "Dhruv Chopra"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/fcb9ecf5318e844e2f5c852fe7ce4fee10dfff5e", "committedDate": "2020-11-23T04:42:51Z", "message": "-Remove unnecessary LR instructions.\n-Add assert to make sure elementSize <= 8\n-Add assert for discontiguousArrayHeaderSizeInBytes == 16\n-Use OMR::align API to do element alignment\n-Remove use of performHelperCall routine\n\nSigned-off-by: Dhruv Chopra <Dhruv.C.Chopra@ibm.com>"}, "afterCommit": {"oid": "0c0a523fb2d8f29f7ebf068ecba2e3b4633d3c66", "author": {"user": {"login": "dchopra001", "name": "Dhruv Chopra"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/0c0a523fb2d8f29f7ebf068ecba2e3b4633d3c66", "committedDate": "2020-11-23T04:46:11Z", "message": "Address PR change requests\n\n-Remove unnecessary LR instructions.\n-Add assert to make sure elementSize <= 8\n-Add assert for discontiguousArrayHeaderSizeInBytes == 16\n-Use OMR::align API to do element alignment\n-Remove use of performHelperCall routine\n\nSigned-off-by: Dhruv Chopra <Dhruv.C.Chopra@ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2OTE4Mzk3", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#pullrequestreview-536918397", "createdAt": "2020-11-23T23:13:18Z", "commit": {"oid": "6678b5654755f3f8180759445dd464353128894f"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QyMzoxMzoxOVrOH4jEIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QyMzo0NjozNlrOH4j2HA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA1NjgwMQ==", "bodyText": "@bragaigor can you confirm in all of our GC policies that 0-length arrays will have the same layout, i.e. their size will be equal to sizeof(J9IndexableObjectDiscontiguousCompressed) or sizeof(J9IndexableObjectDiscontiguousFull) depending on compressedrefs mode. This is what the above om. API returns.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r529056801", "createdAt": "2020-11-23T23:13:19Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2943,13 +2944,230 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = static_cast<TR_J9VMBase *>(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt() != 2)\n+      {\n+      traceMsg(cg->comp(), \"multianewArrayEvaluator - More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      TR::ILOpCodes opCode = node->getOpCodeValue();\n+      TR::Node::recreate(node, TR::acall);\n+      TR::Register *helperTargetReg = TR::TreeEvaluator::performCall(node, false, cg);\n+      TR::Node::recreate(node, opCode);\n+      return helperTargetReg;\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   // oolJumpLabel is a common point that all branches will jump to. From this label, we branch to OOL code.\n+   // We do this instead of jumping directly to OOL code from mainline because the RA can only handle the case where there's\n+   // a single jump point to OOL code.\n+   TR::LabelSymbol *oolJumpLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));\n+\n+   TR::Register *secondDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, secondDimLenReg, generateS390MemoryReference(dimsPtrReg, 0, cg));\n+\n+   // Check to see if second dimension is indeed 0. If yes, then proceed to handle the case here. Otherwise jump to OOL code.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, secondDimLenReg, 0, TR::InstOpCode::COND_BNE, oolJumpLabel, false);\n+\n+   // Now check to see if first dimension is also 0. If yes, continue below to handle the case when length for both dimensions is 0. Otherwise jump to nonZeroFirstDimLabel.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, 0, TR::InstOpCode::COND_BNE, nonZeroFirstDimLabel, false);\n+\n+   // First dimension zero, so only allocate 1 zero-length object array\n+   int32_t zeroArraySize = TR::Compiler->om.discontiguousArrayHeaderSizeInBytes();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6678b5654755f3f8180759445dd464353128894f"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA1Njk4Mw==", "bodyText": "This should be a compare and branch.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r529056983", "createdAt": "2020-11-23T23:13:53Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2943,13 +2944,230 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = static_cast<TR_J9VMBase *>(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt() != 2)\n+      {\n+      traceMsg(cg->comp(), \"multianewArrayEvaluator - More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      TR::ILOpCodes opCode = node->getOpCodeValue();\n+      TR::Node::recreate(node, TR::acall);\n+      TR::Register *helperTargetReg = TR::TreeEvaluator::performCall(node, false, cg);\n+      TR::Node::recreate(node, opCode);\n+      return helperTargetReg;\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   // oolJumpLabel is a common point that all branches will jump to. From this label, we branch to OOL code.\n+   // We do this instead of jumping directly to OOL code from mainline because the RA can only handle the case where there's\n+   // a single jump point to OOL code.\n+   TR::LabelSymbol *oolJumpLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));\n+\n+   TR::Register *secondDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, secondDimLenReg, generateS390MemoryReference(dimsPtrReg, 0, cg));\n+\n+   // Check to see if second dimension is indeed 0. If yes, then proceed to handle the case here. Otherwise jump to OOL code.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, secondDimLenReg, 0, TR::InstOpCode::COND_BNE, oolJumpLabel, false);\n+\n+   // Now check to see if first dimension is also 0. If yes, continue below to handle the case when length for both dimensions is 0. Otherwise jump to nonZeroFirstDimLabel.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, 0, TR::InstOpCode::COND_BNE, nonZeroFirstDimLabel, false);\n+\n+   // First dimension zero, so only allocate 1 zero-length object array\n+   int32_t zeroArraySize = TR::Compiler->om.discontiguousArrayHeaderSizeInBytes();\n+   TR::Register *vmThreadReg = cg->getMethodMetaDataRealRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, targetReg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+\n+   // Branch to OOL if there's not enough space for an array of size 0.\n+   TR::Register *temp1Reg = cg->allocateRegister();\n+   generateRIEInstruction(cg, TR::InstOpCode::getAddHalfWordImmDistinctOperandOpCode(), node, temp1Reg, targetReg, zeroArraySize);\n+   generateRXInstruction(cg, TR::InstOpCode::getCmpLogicalOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapTop), cg));\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BH, node, oolJumpLabel);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6678b5654755f3f8180759445dd464353128894f"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA2MjMyOQ==", "bodyText": "This should be a compare and branch.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r529062329", "createdAt": "2020-11-23T23:27:15Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2943,13 +2944,230 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = static_cast<TR_J9VMBase *>(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt() != 2)\n+      {\n+      traceMsg(cg->comp(), \"multianewArrayEvaluator - More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      TR::ILOpCodes opCode = node->getOpCodeValue();\n+      TR::Node::recreate(node, TR::acall);\n+      TR::Register *helperTargetReg = TR::TreeEvaluator::performCall(node, false, cg);\n+      TR::Node::recreate(node, opCode);\n+      return helperTargetReg;\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   // oolJumpLabel is a common point that all branches will jump to. From this label, we branch to OOL code.\n+   // We do this instead of jumping directly to OOL code from mainline because the RA can only handle the case where there's\n+   // a single jump point to OOL code.\n+   TR::LabelSymbol *oolJumpLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));\n+\n+   TR::Register *secondDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, secondDimLenReg, generateS390MemoryReference(dimsPtrReg, 0, cg));\n+\n+   // Check to see if second dimension is indeed 0. If yes, then proceed to handle the case here. Otherwise jump to OOL code.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, secondDimLenReg, 0, TR::InstOpCode::COND_BNE, oolJumpLabel, false);\n+\n+   // Now check to see if first dimension is also 0. If yes, continue below to handle the case when length for both dimensions is 0. Otherwise jump to nonZeroFirstDimLabel.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, 0, TR::InstOpCode::COND_BNE, nonZeroFirstDimLabel, false);\n+\n+   // First dimension zero, so only allocate 1 zero-length object array\n+   int32_t zeroArraySize = TR::Compiler->om.discontiguousArrayHeaderSizeInBytes();\n+   TR::Register *vmThreadReg = cg->getMethodMetaDataRealRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, targetReg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+\n+   // Branch to OOL if there's not enough space for an array of size 0.\n+   TR::Register *temp1Reg = cg->allocateRegister();\n+   generateRIEInstruction(cg, TR::InstOpCode::getAddHalfWordImmDistinctOperandOpCode(), node, temp1Reg, targetReg, zeroArraySize);\n+   generateRXInstruction(cg, TR::InstOpCode::getCmpLogicalOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapTop), cg));\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BH, node, oolJumpLabel);\n+\n+   // If there's enough space, then we can continue to allocate.\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+   \n+   bool use64BitClasses = comp->target().is64Bit() && !TR::Compiler->om.generateCompressedObjectHeaders();\n+\n+   // Init class and fields, then jump to end of ICF\n+   generateRXInstruction(cg, use64BitClasses ? TR::InstOpCode::STG : TR::InstOpCode::ST, node, classReg, generateS390MemoryReference(targetReg, TR::Compiler->om.offsetOfObjectVftField(), cg));\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);\n+\n+   // We end up in this region of the ICF if the first dimension is non-zero and the second dimension is zero.\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, nonZeroFirstDimLabel);\n+\n+   TR::Register *componentClassReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, componentClassReg, generateS390MemoryReference(classReg, offsetof(J9ArrayClass, componentType), cg));\n+\n+   // Calculate maximum allowable object size in elements and jump to OOL if it's higher than firstDimLenReg.\n+   int32_t elementSize = TR::Compiler->om.sizeofReferenceField();\n+   uintptr_t maxObjectSize = cg->getMaxObjectSizeGuaranteedNotToOverflow();\n+   uintptr_t maxObjectSizeInElements = maxObjectSize / elementSize;\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, static_cast<int32_t>(maxObjectSizeInElements), TR::InstOpCode::COND_BHR, oolJumpLabel, false);\n+\n+   // Now check to see if we have enough space to do the allocation. If not then jump to OOL code.\n+   int32_t elementSizeAligned = OMR::align(elementSize, TR::Compiler->om.objectAlignmentInBytes());\n+   int32_t alignmentCompensation = (elementSize == elementSizeAligned) ? 0 : elementSizeAligned - 1;\n+   static const uint8_t multiplierToStrideMap[] = {0, 0, 1, 0, 2, 0, 0, 0, 3};\n+   TR_ASSERT_FATAL(elementSize <= 8, \"multianewArrayEvaluator - elementSize cannot be greater than 8!\");\n+   generateRSInstruction(cg, TR::InstOpCode::getShiftLeftLogicalSingleOpCode(), node, temp1Reg, firstDimLenReg, multiplierToStrideMap[elementSize]);\n+   generateRILInstruction(cg, TR::InstOpCode::AGFI, node, temp1Reg, static_cast<int32_t>(TR::Compiler->om.contiguousArrayHeaderSizeInBytes()) + alignmentCompensation);\n+\n+   if (alignmentCompensation != 0)\n+      {\n+      generateRILInstruction(cg, TR::InstOpCode::NILF, node, temp1Reg, -elementSizeAligned);\n+      }\n+\n+   TR::Register *temp2Reg = cg->allocateRegister();\n+   TR_ASSERT_FATAL(TR::Compiler->om.discontiguousArrayHeaderSizeInBytes() == 16, \"multianewArrayEvaluator - Expecting discontiguousArrayHeaderSizeInBytes to be 16.\");\n+   // temp2Reg = firstDimLenReg * 16 (discontiguousArrayHeaderSizeInBytes)\n+   generateRSInstruction(cg, TR::InstOpCode::getShiftLeftLogicalSingleOpCode(), node, temp2Reg, firstDimLenReg, 4);\n+\n+   generateRRInstruction(cg, TR::InstOpCode::getAddRegOpCode(), node, temp2Reg, temp1Reg);\n+\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, targetReg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+   generateRRInstruction(cg, TR::InstOpCode::getAddRegOpCode(), node, temp2Reg, targetReg);\n+   generateRXInstruction(cg, TR::InstOpCode::getCmpLogicalOpCode(), node, temp2Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapTop), cg));\n+\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BH, node, oolJumpLabel);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6678b5654755f3f8180759445dd464353128894f"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA2NTQxOA==", "bodyText": "@bragaigor can you also confirm that no matter what the GC policy, if an array of a certain length will fit into the TLH it will always have a contiguous layout?", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r529065418", "createdAt": "2020-11-23T23:35:26Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2943,13 +2944,230 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = static_cast<TR_J9VMBase *>(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt() != 2)\n+      {\n+      traceMsg(cg->comp(), \"multianewArrayEvaluator - More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      TR::ILOpCodes opCode = node->getOpCodeValue();\n+      TR::Node::recreate(node, TR::acall);\n+      TR::Register *helperTargetReg = TR::TreeEvaluator::performCall(node, false, cg);\n+      TR::Node::recreate(node, opCode);\n+      return helperTargetReg;\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   // oolJumpLabel is a common point that all branches will jump to. From this label, we branch to OOL code.\n+   // We do this instead of jumping directly to OOL code from mainline because the RA can only handle the case where there's\n+   // a single jump point to OOL code.\n+   TR::LabelSymbol *oolJumpLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));\n+\n+   TR::Register *secondDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, secondDimLenReg, generateS390MemoryReference(dimsPtrReg, 0, cg));\n+\n+   // Check to see if second dimension is indeed 0. If yes, then proceed to handle the case here. Otherwise jump to OOL code.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, secondDimLenReg, 0, TR::InstOpCode::COND_BNE, oolJumpLabel, false);\n+\n+   // Now check to see if first dimension is also 0. If yes, continue below to handle the case when length for both dimensions is 0. Otherwise jump to nonZeroFirstDimLabel.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, 0, TR::InstOpCode::COND_BNE, nonZeroFirstDimLabel, false);\n+\n+   // First dimension zero, so only allocate 1 zero-length object array\n+   int32_t zeroArraySize = TR::Compiler->om.discontiguousArrayHeaderSizeInBytes();\n+   TR::Register *vmThreadReg = cg->getMethodMetaDataRealRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, targetReg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+\n+   // Branch to OOL if there's not enough space for an array of size 0.\n+   TR::Register *temp1Reg = cg->allocateRegister();\n+   generateRIEInstruction(cg, TR::InstOpCode::getAddHalfWordImmDistinctOperandOpCode(), node, temp1Reg, targetReg, zeroArraySize);\n+   generateRXInstruction(cg, TR::InstOpCode::getCmpLogicalOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapTop), cg));\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BH, node, oolJumpLabel);\n+\n+   // If there's enough space, then we can continue to allocate.\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+   \n+   bool use64BitClasses = comp->target().is64Bit() && !TR::Compiler->om.generateCompressedObjectHeaders();\n+\n+   // Init class and fields, then jump to end of ICF\n+   generateRXInstruction(cg, use64BitClasses ? TR::InstOpCode::STG : TR::InstOpCode::ST, node, classReg, generateS390MemoryReference(targetReg, TR::Compiler->om.offsetOfObjectVftField(), cg));\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);\n+\n+   // We end up in this region of the ICF if the first dimension is non-zero and the second dimension is zero.\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, nonZeroFirstDimLabel);\n+\n+   TR::Register *componentClassReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, componentClassReg, generateS390MemoryReference(classReg, offsetof(J9ArrayClass, componentType), cg));\n+\n+   // Calculate maximum allowable object size in elements and jump to OOL if it's higher than firstDimLenReg.\n+   int32_t elementSize = TR::Compiler->om.sizeofReferenceField();\n+   uintptr_t maxObjectSize = cg->getMaxObjectSizeGuaranteedNotToOverflow();\n+   uintptr_t maxObjectSizeInElements = maxObjectSize / elementSize;\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, static_cast<int32_t>(maxObjectSizeInElements), TR::InstOpCode::COND_BHR, oolJumpLabel, false);\n+\n+   // Now check to see if we have enough space to do the allocation. If not then jump to OOL code.\n+   int32_t elementSizeAligned = OMR::align(elementSize, TR::Compiler->om.objectAlignmentInBytes());\n+   int32_t alignmentCompensation = (elementSize == elementSizeAligned) ? 0 : elementSizeAligned - 1;\n+   static const uint8_t multiplierToStrideMap[] = {0, 0, 1, 0, 2, 0, 0, 0, 3};\n+   TR_ASSERT_FATAL(elementSize <= 8, \"multianewArrayEvaluator - elementSize cannot be greater than 8!\");\n+   generateRSInstruction(cg, TR::InstOpCode::getShiftLeftLogicalSingleOpCode(), node, temp1Reg, firstDimLenReg, multiplierToStrideMap[elementSize]);\n+   generateRILInstruction(cg, TR::InstOpCode::AGFI, node, temp1Reg, static_cast<int32_t>(TR::Compiler->om.contiguousArrayHeaderSizeInBytes()) + alignmentCompensation);\n+\n+   if (alignmentCompensation != 0)\n+      {\n+      generateRILInstruction(cg, TR::InstOpCode::NILF, node, temp1Reg, -elementSizeAligned);\n+      }\n+\n+   TR::Register *temp2Reg = cg->allocateRegister();\n+   TR_ASSERT_FATAL(TR::Compiler->om.discontiguousArrayHeaderSizeInBytes() == 16, \"multianewArrayEvaluator - Expecting discontiguousArrayHeaderSizeInBytes to be 16.\");\n+   // temp2Reg = firstDimLenReg * 16 (discontiguousArrayHeaderSizeInBytes)\n+   generateRSInstruction(cg, TR::InstOpCode::getShiftLeftLogicalSingleOpCode(), node, temp2Reg, firstDimLenReg, 4);\n+\n+   generateRRInstruction(cg, TR::InstOpCode::getAddRegOpCode(), node, temp2Reg, temp1Reg);\n+\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, targetReg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+   generateRRInstruction(cg, TR::InstOpCode::getAddRegOpCode(), node, temp2Reg, targetReg);\n+   generateRXInstruction(cg, TR::InstOpCode::getCmpLogicalOpCode(), node, temp2Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapTop), cg));\n+\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BH, node, oolJumpLabel);\n+\n+   // We have enough space, so proceed with the allocation.\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp2Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+\n+   // Init 1st dim array class and size fields.\n+   generateRXInstruction(cg, use64BitClasses ? TR::InstOpCode::STG : TR::InstOpCode::ST, node, classReg, generateS390MemoryReference(targetReg, TR::Compiler->om.offsetOfObjectVftField(), cg));\n+   generateRXInstruction(cg, TR::InstOpCode::ST, node, firstDimLenReg, generateS390MemoryReference(targetReg, fej9->getOffsetOfContiguousArraySizeField(), cg));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6678b5654755f3f8180759445dd464353128894f"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA2NzI5MA==", "bodyText": "We don't need distinct operands here. An RI format instruction will suffice. Use getAddHalfWordImmOpCode() instead with generateRIInstruction.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r529067290", "createdAt": "2020-11-23T23:40:29Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2943,13 +2944,230 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = static_cast<TR_J9VMBase *>(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt() != 2)\n+      {\n+      traceMsg(cg->comp(), \"multianewArrayEvaluator - More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      TR::ILOpCodes opCode = node->getOpCodeValue();\n+      TR::Node::recreate(node, TR::acall);\n+      TR::Register *helperTargetReg = TR::TreeEvaluator::performCall(node, false, cg);\n+      TR::Node::recreate(node, opCode);\n+      return helperTargetReg;\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   // oolJumpLabel is a common point that all branches will jump to. From this label, we branch to OOL code.\n+   // We do this instead of jumping directly to OOL code from mainline because the RA can only handle the case where there's\n+   // a single jump point to OOL code.\n+   TR::LabelSymbol *oolJumpLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));\n+\n+   TR::Register *secondDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, secondDimLenReg, generateS390MemoryReference(dimsPtrReg, 0, cg));\n+\n+   // Check to see if second dimension is indeed 0. If yes, then proceed to handle the case here. Otherwise jump to OOL code.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, secondDimLenReg, 0, TR::InstOpCode::COND_BNE, oolJumpLabel, false);\n+\n+   // Now check to see if first dimension is also 0. If yes, continue below to handle the case when length for both dimensions is 0. Otherwise jump to nonZeroFirstDimLabel.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, 0, TR::InstOpCode::COND_BNE, nonZeroFirstDimLabel, false);\n+\n+   // First dimension zero, so only allocate 1 zero-length object array\n+   int32_t zeroArraySize = TR::Compiler->om.discontiguousArrayHeaderSizeInBytes();\n+   TR::Register *vmThreadReg = cg->getMethodMetaDataRealRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, targetReg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+\n+   // Branch to OOL if there's not enough space for an array of size 0.\n+   TR::Register *temp1Reg = cg->allocateRegister();\n+   generateRIEInstruction(cg, TR::InstOpCode::getAddHalfWordImmDistinctOperandOpCode(), node, temp1Reg, targetReg, zeroArraySize);\n+   generateRXInstruction(cg, TR::InstOpCode::getCmpLogicalOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapTop), cg));\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BH, node, oolJumpLabel);\n+\n+   // If there's enough space, then we can continue to allocate.\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+   \n+   bool use64BitClasses = comp->target().is64Bit() && !TR::Compiler->om.generateCompressedObjectHeaders();\n+\n+   // Init class and fields, then jump to end of ICF\n+   generateRXInstruction(cg, use64BitClasses ? TR::InstOpCode::STG : TR::InstOpCode::ST, node, classReg, generateS390MemoryReference(targetReg, TR::Compiler->om.offsetOfObjectVftField(), cg));\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);\n+\n+   // We end up in this region of the ICF if the first dimension is non-zero and the second dimension is zero.\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, nonZeroFirstDimLabel);\n+\n+   TR::Register *componentClassReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, componentClassReg, generateS390MemoryReference(classReg, offsetof(J9ArrayClass, componentType), cg));\n+\n+   // Calculate maximum allowable object size in elements and jump to OOL if it's higher than firstDimLenReg.\n+   int32_t elementSize = TR::Compiler->om.sizeofReferenceField();\n+   uintptr_t maxObjectSize = cg->getMaxObjectSizeGuaranteedNotToOverflow();\n+   uintptr_t maxObjectSizeInElements = maxObjectSize / elementSize;\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, static_cast<int32_t>(maxObjectSizeInElements), TR::InstOpCode::COND_BHR, oolJumpLabel, false);\n+\n+   // Now check to see if we have enough space to do the allocation. If not then jump to OOL code.\n+   int32_t elementSizeAligned = OMR::align(elementSize, TR::Compiler->om.objectAlignmentInBytes());\n+   int32_t alignmentCompensation = (elementSize == elementSizeAligned) ? 0 : elementSizeAligned - 1;\n+   static const uint8_t multiplierToStrideMap[] = {0, 0, 1, 0, 2, 0, 0, 0, 3};\n+   TR_ASSERT_FATAL(elementSize <= 8, \"multianewArrayEvaluator - elementSize cannot be greater than 8!\");\n+   generateRSInstruction(cg, TR::InstOpCode::getShiftLeftLogicalSingleOpCode(), node, temp1Reg, firstDimLenReg, multiplierToStrideMap[elementSize]);\n+   generateRILInstruction(cg, TR::InstOpCode::AGFI, node, temp1Reg, static_cast<int32_t>(TR::Compiler->om.contiguousArrayHeaderSizeInBytes()) + alignmentCompensation);\n+\n+   if (alignmentCompensation != 0)\n+      {\n+      generateRILInstruction(cg, TR::InstOpCode::NILF, node, temp1Reg, -elementSizeAligned);\n+      }\n+\n+   TR::Register *temp2Reg = cg->allocateRegister();\n+   TR_ASSERT_FATAL(TR::Compiler->om.discontiguousArrayHeaderSizeInBytes() == 16, \"multianewArrayEvaluator - Expecting discontiguousArrayHeaderSizeInBytes to be 16.\");\n+   // temp2Reg = firstDimLenReg * 16 (discontiguousArrayHeaderSizeInBytes)\n+   generateRSInstruction(cg, TR::InstOpCode::getShiftLeftLogicalSingleOpCode(), node, temp2Reg, firstDimLenReg, 4);\n+\n+   generateRRInstruction(cg, TR::InstOpCode::getAddRegOpCode(), node, temp2Reg, temp1Reg);\n+\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, targetReg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+   generateRRInstruction(cg, TR::InstOpCode::getAddRegOpCode(), node, temp2Reg, targetReg);\n+   generateRXInstruction(cg, TR::InstOpCode::getCmpLogicalOpCode(), node, temp2Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapTop), cg));\n+\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BH, node, oolJumpLabel);\n+\n+   // We have enough space, so proceed with the allocation.\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp2Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+\n+   // Init 1st dim array class and size fields.\n+   generateRXInstruction(cg, use64BitClasses ? TR::InstOpCode::STG : TR::InstOpCode::ST, node, classReg, generateS390MemoryReference(targetReg, TR::Compiler->om.offsetOfObjectVftField(), cg));\n+   generateRXInstruction(cg, TR::InstOpCode::ST, node, firstDimLenReg, generateS390MemoryReference(targetReg, fej9->getOffsetOfContiguousArraySizeField(), cg));\n+\n+   // temp2 point to end of 1st dim array i.e. start of 2nd dim\n+   generateRRInstruction(cg, TR::InstOpCode::getLoadRegOpCode(), node, temp2Reg, targetReg);\n+   generateRRInstruction(cg, TR::InstOpCode::getAddRegOpCode(), node, temp2Reg, temp1Reg);\n+   generateRIEInstruction(cg, TR::InstOpCode::getAddHalfWordImmDistinctOperandOpCode(), node, temp1Reg, targetReg, TR::Compiler->om.contiguousArrayHeaderSizeInBytes());\n+\n+   uintptr_t heapBase = TR::Compiler->vm.heapBaseAddress();\n+   bool useRegForHeapBase = comp->target().is64Bit() && comp->useCompressedPointers() &&\n+                           (heapBase != 0) && (!IS_32BIT_SIGNED(heapBase) || TR::Compiler->om.nativeAddressesCanChangeSize());\n+   if (useRegForHeapBase)\n+      {\n+      uint32_t high32 = heapBase >> 32;\n+      generateRILInstruction(cg, TR::InstOpCode::LLIHF, node, secondDimLenReg, high32);\n+      generateRILInstruction(cg, TR::InstOpCode::IILF, node, secondDimLenReg, static_cast<uint32_t>(heapBase));\n+      }\n+\n+   // Loop start\n+   TR::LabelSymbol *loopLabel = generateLabelSymbol(cg);\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, loopLabel);\n+\n+   // Init 2nd dim element's class\n+   generateRXInstruction(cg, use64BitClasses ? TR::InstOpCode::STG : TR::InstOpCode::ST, node, componentClassReg, generateS390MemoryReference(temp2Reg, TR::Compiler->om.offsetOfObjectVftField(), cg));\n+\n+   // Store 2nd dim element into 1st dim array slot, compress temp2 if needed\n+   TR::Register *temp3Reg = cg->allocateRegister();\n+   if (comp->target().is64Bit() && comp->useCompressedPointers())\n+      {\n+      int32_t shiftAmount = TR::Compiler->om.compressedReferenceShift();\n+      generateRRInstruction(cg, TR::InstOpCode::getLoadRegOpCode(), node, temp3Reg, temp2Reg);\n+\n+      if (heapBase != 0)\n+         {\n+         if (useRegForHeapBase)\n+            {\n+            generateRRInstruction(cg, TR::InstOpCode::getSubstractRegOpCode(), node, temp3Reg, secondDimLenReg);\n+            }\n+         else\n+            {\n+            generateRILInstruction(cg, TR::InstOpCode::getSubtractLogicalImmOpCode(), node, temp3Reg, static_cast<int32_t>(heapBase));\n+            }\n+         }\n+      if (shiftAmount != 0)\n+         {\n+         generateRSInstruction(cg, comp->target().is64Bit() ? TR::InstOpCode::SRAG : TR::InstOpCode::SRAK, node, temp3Reg, temp3Reg, shiftAmount);\n+         }\n+      generateRXInstruction(cg, TR::InstOpCode::ST, node, temp3Reg, generateS390MemoryReference(temp1Reg, 0, cg));\n+      }\n+   else\n+      {\n+      generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp2Reg, generateS390MemoryReference(temp1Reg, 0, cg));\n+      }\n+\n+   // Advance cursors temp1 and temp2. Then branch back or fall through if done.\n+   generateRIEInstruction(cg, TR::InstOpCode::getAddHalfWordImmDistinctOperandOpCode(), node, temp2Reg, temp2Reg, TR::Compiler->om.discontiguousArrayHeaderSizeInBytes());\n+   generateRIEInstruction(cg, TR::InstOpCode::getAddHalfWordImmDistinctOperandOpCode(), node, temp1Reg, temp1Reg, elementSize);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6678b5654755f3f8180759445dd464353128894f"}, "originalPosition": 181}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA2OTU5Ng==", "bodyText": "I believe this is always 0. I don't think we support non-zero heap base today, nor do we envision it in the future. @0xdaryl should we just fold code that references it? It needlessly complicates these evaluators and we have no way of testing these code paths anyway.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r529069596", "createdAt": "2020-11-23T23:46:36Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2943,13 +2944,230 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = static_cast<TR_J9VMBase *>(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt() != 2)\n+      {\n+      traceMsg(cg->comp(), \"multianewArrayEvaluator - More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      TR::ILOpCodes opCode = node->getOpCodeValue();\n+      TR::Node::recreate(node, TR::acall);\n+      TR::Register *helperTargetReg = TR::TreeEvaluator::performCall(node, false, cg);\n+      TR::Node::recreate(node, opCode);\n+      return helperTargetReg;\n+      }\n+\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg);\n+   TR::LabelSymbol *nonZeroFirstDimLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *cFlowRegionEnd = generateLabelSymbol(cg);\n+   TR::LabelSymbol *oolFailLabel = generateLabelSymbol(cg);\n+\n+   // oolJumpLabel is a common point that all branches will jump to. From this label, we branch to OOL code.\n+   // We do this instead of jumping directly to OOL code from mainline because the RA can only handle the case where there's\n+   // a single jump point to OOL code.\n+   TR::LabelSymbol *oolJumpLabel = generateLabelSymbol(cg);\n+\n+   cFlowRegionStart->setStartInternalControlFlow();\n+   cFlowRegionEnd->setEndInternalControlFlow();\n+\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, cFlowRegionStart);\n+\n+   TR::Register *dimsPtrReg = cg->evaluate(firstChild);\n+   TR::Register *dimReg = cg->evaluate(secondChild);\n+   TR::Register *classReg = cg->evaluate(thirdChild);\n+\n+   // In the mainline, first load the first and second dimensions' lengths into registers.\n+   TR::Register *firstDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, firstDimLenReg, generateS390MemoryReference(dimsPtrReg, 4, cg));\n+\n+   TR::Register *secondDimLenReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::L, node, secondDimLenReg, generateS390MemoryReference(dimsPtrReg, 0, cg));\n+\n+   // Check to see if second dimension is indeed 0. If yes, then proceed to handle the case here. Otherwise jump to OOL code.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, secondDimLenReg, 0, TR::InstOpCode::COND_BNE, oolJumpLabel, false);\n+\n+   // Now check to see if first dimension is also 0. If yes, continue below to handle the case when length for both dimensions is 0. Otherwise jump to nonZeroFirstDimLabel.\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, 0, TR::InstOpCode::COND_BNE, nonZeroFirstDimLabel, false);\n+\n+   // First dimension zero, so only allocate 1 zero-length object array\n+   int32_t zeroArraySize = TR::Compiler->om.discontiguousArrayHeaderSizeInBytes();\n+   TR::Register *vmThreadReg = cg->getMethodMetaDataRealRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, targetReg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+\n+   // Branch to OOL if there's not enough space for an array of size 0.\n+   TR::Register *temp1Reg = cg->allocateRegister();\n+   generateRIEInstruction(cg, TR::InstOpCode::getAddHalfWordImmDistinctOperandOpCode(), node, temp1Reg, targetReg, zeroArraySize);\n+   generateRXInstruction(cg, TR::InstOpCode::getCmpLogicalOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapTop), cg));\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BH, node, oolJumpLabel);\n+\n+   // If there's enough space, then we can continue to allocate.\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp1Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+   \n+   bool use64BitClasses = comp->target().is64Bit() && !TR::Compiler->om.generateCompressedObjectHeaders();\n+\n+   // Init class and fields, then jump to end of ICF\n+   generateRXInstruction(cg, use64BitClasses ? TR::InstOpCode::STG : TR::InstOpCode::ST, node, classReg, generateS390MemoryReference(targetReg, TR::Compiler->om.offsetOfObjectVftField(), cg));\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BRC, node, cFlowRegionEnd);\n+\n+   // We end up in this region of the ICF if the first dimension is non-zero and the second dimension is zero.\n+   generateS390LabelInstruction(cg, TR::InstOpCode::LABEL, node, nonZeroFirstDimLabel);\n+\n+   TR::Register *componentClassReg = cg->allocateRegister();\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, componentClassReg, generateS390MemoryReference(classReg, offsetof(J9ArrayClass, componentType), cg));\n+\n+   // Calculate maximum allowable object size in elements and jump to OOL if it's higher than firstDimLenReg.\n+   int32_t elementSize = TR::Compiler->om.sizeofReferenceField();\n+   uintptr_t maxObjectSize = cg->getMaxObjectSizeGuaranteedNotToOverflow();\n+   uintptr_t maxObjectSizeInElements = maxObjectSize / elementSize;\n+   generateS390CompareAndBranchInstruction(cg, TR::InstOpCode::CL, node, firstDimLenReg, static_cast<int32_t>(maxObjectSizeInElements), TR::InstOpCode::COND_BHR, oolJumpLabel, false);\n+\n+   // Now check to see if we have enough space to do the allocation. If not then jump to OOL code.\n+   int32_t elementSizeAligned = OMR::align(elementSize, TR::Compiler->om.objectAlignmentInBytes());\n+   int32_t alignmentCompensation = (elementSize == elementSizeAligned) ? 0 : elementSizeAligned - 1;\n+   static const uint8_t multiplierToStrideMap[] = {0, 0, 1, 0, 2, 0, 0, 0, 3};\n+   TR_ASSERT_FATAL(elementSize <= 8, \"multianewArrayEvaluator - elementSize cannot be greater than 8!\");\n+   generateRSInstruction(cg, TR::InstOpCode::getShiftLeftLogicalSingleOpCode(), node, temp1Reg, firstDimLenReg, multiplierToStrideMap[elementSize]);\n+   generateRILInstruction(cg, TR::InstOpCode::AGFI, node, temp1Reg, static_cast<int32_t>(TR::Compiler->om.contiguousArrayHeaderSizeInBytes()) + alignmentCompensation);\n+\n+   if (alignmentCompensation != 0)\n+      {\n+      generateRILInstruction(cg, TR::InstOpCode::NILF, node, temp1Reg, -elementSizeAligned);\n+      }\n+\n+   TR::Register *temp2Reg = cg->allocateRegister();\n+   TR_ASSERT_FATAL(TR::Compiler->om.discontiguousArrayHeaderSizeInBytes() == 16, \"multianewArrayEvaluator - Expecting discontiguousArrayHeaderSizeInBytes to be 16.\");\n+   // temp2Reg = firstDimLenReg * 16 (discontiguousArrayHeaderSizeInBytes)\n+   generateRSInstruction(cg, TR::InstOpCode::getShiftLeftLogicalSingleOpCode(), node, temp2Reg, firstDimLenReg, 4);\n+\n+   generateRRInstruction(cg, TR::InstOpCode::getAddRegOpCode(), node, temp2Reg, temp1Reg);\n+\n+   generateRXInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, targetReg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+   generateRRInstruction(cg, TR::InstOpCode::getAddRegOpCode(), node, temp2Reg, targetReg);\n+   generateRXInstruction(cg, TR::InstOpCode::getCmpLogicalOpCode(), node, temp2Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapTop), cg));\n+\n+   generateS390BranchInstruction(cg, TR::InstOpCode::BRC, TR::InstOpCode::COND_BH, node, oolJumpLabel);\n+\n+   // We have enough space, so proceed with the allocation.\n+   generateRXInstruction(cg, TR::InstOpCode::getStoreOpCode(), node, temp2Reg, generateS390MemoryReference(vmThreadReg, offsetof(J9VMThread, heapAlloc), cg));\n+\n+   // Init 1st dim array class and size fields.\n+   generateRXInstruction(cg, use64BitClasses ? TR::InstOpCode::STG : TR::InstOpCode::ST, node, classReg, generateS390MemoryReference(targetReg, TR::Compiler->om.offsetOfObjectVftField(), cg));\n+   generateRXInstruction(cg, TR::InstOpCode::ST, node, firstDimLenReg, generateS390MemoryReference(targetReg, fej9->getOffsetOfContiguousArraySizeField(), cg));\n+\n+   // temp2 point to end of 1st dim array i.e. start of 2nd dim\n+   generateRRInstruction(cg, TR::InstOpCode::getLoadRegOpCode(), node, temp2Reg, targetReg);\n+   generateRRInstruction(cg, TR::InstOpCode::getAddRegOpCode(), node, temp2Reg, temp1Reg);\n+   generateRIEInstruction(cg, TR::InstOpCode::getAddHalfWordImmDistinctOperandOpCode(), node, temp1Reg, targetReg, TR::Compiler->om.contiguousArrayHeaderSizeInBytes());\n+\n+   uintptr_t heapBase = TR::Compiler->vm.heapBaseAddress();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6678b5654755f3f8180759445dd464353128894f"}, "originalPosition": 133}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "54d6632c18ac873641e83f53e51c247f24db7052", "author": {"user": {"login": "dchopra001", "name": "Dhruv Chopra"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/54d6632c18ac873641e83f53e51c247f24db7052", "committedDate": "2020-11-24T15:12:34Z", "message": "Add tests\n\nSigned-off-by: Dhruv Chopra <Dhruv.C.Chopra@ibm.com>"}, "afterCommit": {"oid": "e5263da19db7f55f00d638cc6d8ca672dfe11c20", "author": {"user": {"login": "dchopra001", "name": "Dhruv Chopra"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/e5263da19db7f55f00d638cc6d8ca672dfe11c20", "committedDate": "2020-11-24T18:18:03Z", "message": "Add tests\n\nSigned-off-by: Dhruv Chopra <Dhruv.C.Chopra@ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM3NzY2OTQy", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#pullrequestreview-537766942", "createdAt": "2020-11-24T17:53:00Z", "commit": {"oid": "54d6632c18ac873641e83f53e51c247f24db7052"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNzo1MzowMFrOH5Of0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMToxNDo1N1rOH5VboA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTc2ODQwMA==", "bodyText": "Copyright should be 2020, 2020.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r529768400", "createdAt": "2020-11-24T17:53:00Z", "author": {"login": "fjeremic"}, "path": "test/functional/JIT_Test/src/jit/test/jitt/array/multianewarray.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*******************************************************************************\n+ * Copyright (c) 2001, 2020 IBM Corp. and others", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "54d6632c18ac873641e83f53e51c247f24db7052"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTc3MTI1MQ==", "bodyText": "Do we need this? Can't we just use AssertJUnit.assertEquals which is much more standard and pretty prints everything for us already.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r529771251", "createdAt": "2020-11-24T17:57:27Z", "author": {"login": "fjeremic"}, "path": "test/functional/JIT_Test/src/jit/test/jitt/array/multianewarray.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*******************************************************************************\n+ * Copyright (c) 2001, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+package jit.test.jitt.array;\n+\n+import org.testng.annotations.Test;\n+import org.testng.log4testng.Logger;\n+import org.testng.Assert;\n+\n+@Test(groups = { \"level.sanity\",\"component.jit\" })\n+\n+public class multianewarray extends jit.test.jitt.Test\n+   {\n+\n+   private static Logger logger = Logger.getLogger(multianewarray.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "54d6632c18ac873641e83f53e51c247f24db7052"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTc3MjMyNA==", "bodyText": "Do we need to extend this class? What functionality does it provide?", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r529772324", "createdAt": "2020-11-24T17:59:09Z", "author": {"login": "fjeremic"}, "path": "test/functional/JIT_Test/src/jit/test/jitt/array/multianewarray.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*******************************************************************************\n+ * Copyright (c) 2001, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+package jit.test.jitt.array;\n+\n+import org.testng.annotations.Test;\n+import org.testng.log4testng.Logger;\n+import org.testng.Assert;\n+\n+@Test(groups = { \"level.sanity\",\"component.jit\" })\n+\n+public class multianewarray extends jit.test.jitt.Test", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "54d6632c18ac873641e83f53e51c247f24db7052"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTc3NzI1Nw==", "bodyText": "Can we add an invocation count here to run the test twice:\n@Test(groups = {\"level.sanity\"}, invocationCount=2)\n\nAnd then modify playlist.xml for jit_jitt to add a variation which runs -Xjit:count=1,disalbeAsyncCompilation. This will ensure everything in here is properly resolved.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r529777257", "createdAt": "2020-11-24T18:06:12Z", "author": {"login": "fjeremic"}, "path": "test/functional/JIT_Test/src/jit/test/jitt/array/multianewarray.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*******************************************************************************\n+ * Copyright (c) 2001, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+package jit.test.jitt.array;\n+\n+import org.testng.annotations.Test;\n+import org.testng.log4testng.Logger;\n+import org.testng.Assert;\n+\n+@Test(groups = { \"level.sanity\",\"component.jit\" })", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "54d6632c18ac873641e83f53e51c247f24db7052"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTc3NzY3Ng==", "bodyText": "Brace styles should match that of VM Java code (tabs, braces in Java style, etc.). See:\nhttps://github.com/dchopra001/openj9/blob/arrayDim-Final/test/functional/JIT_Test/src/jit/test/recognizedMethod/TestRecognizedCallTransformer.java\nas an example.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r529777676", "createdAt": "2020-11-24T18:06:51Z", "author": {"login": "fjeremic"}, "path": "test/functional/JIT_Test/src/jit/test/jitt/array/multianewarray.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*******************************************************************************\n+ * Copyright (c) 2001, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+package jit.test.jitt.array;\n+\n+import org.testng.annotations.Test;\n+import org.testng.log4testng.Logger;\n+import org.testng.Assert;\n+\n+@Test(groups = { \"level.sanity\",\"component.jit\" })\n+\n+public class multianewarray extends jit.test.jitt.Test\n+   {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "54d6632c18ac873641e83f53e51c247f24db7052"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg0NTE3MA==", "bodyText": "Can we instead use a non-built in type of non-trivial length. For example can use use:\n\tpublic static class Vector {\n\t\tlong x;\n\t\tlong y;\n\t}\n\ninstead. This will have more coverage and ensure we handle classes with at least two fields. An instance of the above class will be greater than the object alignment, so that is covered as well.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r529845170", "createdAt": "2020-11-24T20:03:31Z", "author": {"login": "fjeremic"}, "path": "test/functional/JIT_Test/src/jit/test/jitt/array/multianewarray.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*******************************************************************************\n+ * Copyright (c) 2001, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+package jit.test.jitt.array;\n+\n+import org.testng.annotations.Test;\n+import org.testng.log4testng.Logger;\n+import org.testng.Assert;\n+\n+@Test(groups = { \"level.sanity\",\"component.jit\" })\n+\n+public class multianewarray extends jit.test.jitt.Test\n+   {\n+\n+   private static Logger logger = Logger.getLogger(multianewarray.class);\n+\n+   private Integer[][] createMultiArray(int firstDimLength, int secondDimLength)\n+      {\n+      Integer[][] multiarray = new Integer[firstDimLength][secondDimLength];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5263da19db7f55f00d638cc6d8ca672dfe11c20"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg0NjQ1NQ==", "bodyText": "We should just use AssertJUnit.assertTrue.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r529846455", "createdAt": "2020-11-24T20:05:58Z", "author": {"login": "fjeremic"}, "path": "test/functional/JIT_Test/src/jit/test/jitt/array/multianewarray.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*******************************************************************************\n+ * Copyright (c) 2001, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+package jit.test.jitt.array;\n+\n+import org.testng.annotations.Test;\n+import org.testng.log4testng.Logger;\n+import org.testng.Assert;\n+\n+@Test(groups = { \"level.sanity\",\"component.jit\" })\n+\n+public class multianewarray extends jit.test.jitt.Test\n+   {\n+\n+   private static Logger logger = Logger.getLogger(multianewarray.class);\n+\n+   private Integer[][] createMultiArray(int firstDimLength, int secondDimLength)\n+      {\n+      Integer[][] multiarray = new Integer[firstDimLength][secondDimLength];\n+      for (int i = 0; i < firstDimLength; i++)\n+         {\n+         for (int j = 0; j < secondDimLength; j++)\n+            {\n+            multiarray[i][j] = i * j;\n+            }\n+         }\n+      return multiarray;\n+      }\n+\n+   private boolean testMultiArray(Integer[][] inputArray)\n+      {\n+      for (int i = 0; i < inputArray.length; i++)\n+         {\n+         for (int j = 0; j < inputArray[0].length; j++)\n+            {\n+            if (inputArray[i][j] != i*j)\n+               {\n+               logger.error(\"testmultianewarray failed! Value at array[\" + i + \"][\" + j + \"] is \" + inputArray[i][j] + \" but expected to be \" + i*j);\n+               return false;\n+               }\n+            }\n+         }\n+      return true;\n+      }\n+\n+   @Test\n+   public void testmultianewarray()\n+      {\n+      Integer[][] inputArray;\n+\n+      for (int i = 0; i < 10000; i++)\n+         {\n+         inputArray = createMultiArray(0, 0);\n+         if (!testMultiArray(inputArray))\n+                 Assert.fail(\"input array not constructed correctly for array of length 0,0 at iteration\" + i);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5263da19db7f55f00d638cc6d8ca672dfe11c20"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg4MjAxNg==", "bodyText": "I'm fairly confident we don't need this code. This is already covered in the lowering phase:\nhttps://github.com/eclipse/openj9/blob/8c76311cdcccaa6def680d362df418eca6ae9325/runtime/compiler/env/VMJ9.cpp#L3394-L3449\nI don't think we can ever enter this if block. In fact it makes sense for this check to be performed in the lowering phase as such code doesn't need to be replicated across different codegens.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r529882016", "createdAt": "2020-11-24T21:14:57Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2943,13 +2944,230 @@ J9::Z::TreeEvaluator::anewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg\n TR::Register *\n J9::Z::TreeEvaluator::multianewArrayEvaluator(TR::Node * node, TR::CodeGenerator * cg)\n    {\n+   static char *useDirectHelperCall = feGetEnv(\"TR_MultiANewArrayEvaluatorUseDirectCall\");\n+   TR::Compilation *comp = cg->comp();\n+   TR_J9VMBase *fej9 = static_cast<TR_J9VMBase *>(comp->fe());\n+   TR::Register *targetReg = cg->allocateRegister();\n+\n+   TR::Node *firstChild = node->getFirstChild();\n+   TR::Node *secondChild = node->getSecondChild();\n+   TR::Node *thirdChild = node->getThirdChild();\n+\n+   if (useDirectHelperCall || !secondChild->getOpCode().isLoadConst() || secondChild->getInt() != 2)\n+      {\n+      traceMsg(cg->comp(), \"multianewArrayEvaluator - More than 2 dimensions, so we can't handle this scenario in JITT'ed code\\n\");\n+      TR::ILOpCodes opCode = node->getOpCodeValue();\n+      TR::Node::recreate(node, TR::acall);\n+      TR::Register *helperTargetReg = TR::TreeEvaluator::performCall(node, false, cg);\n+      TR::Node::recreate(node, opCode);\n+      return helperTargetReg;\n+      }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5263da19db7f55f00d638cc6d8ca672dfe11c20"}, "originalPosition": 29}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM3OTQxMjcx", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#pullrequestreview-537941271", "createdAt": "2020-11-24T21:17:11Z", "commit": {"oid": "e5263da19db7f55f00d638cc6d8ca672dfe11c20"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMToxNzoxMVrOH5VgqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMToxNzoxMVrOH5VgqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg4MzMwNA==", "bodyText": "We should also validate the lengths of the arrays are what we think they are, just in case the inline code doesn't allocate the arrays of correct sizes.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r529883304", "createdAt": "2020-11-24T21:17:11Z", "author": {"login": "fjeremic"}, "path": "test/functional/JIT_Test/src/jit/test/jitt/array/multianewarray.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*******************************************************************************\n+ * Copyright (c) 2001, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+package jit.test.jitt.array;\n+\n+import org.testng.annotations.Test;\n+import org.testng.log4testng.Logger;\n+import org.testng.Assert;\n+\n+@Test(groups = { \"level.sanity\",\"component.jit\" })\n+\n+public class multianewarray extends jit.test.jitt.Test\n+   {\n+\n+   private static Logger logger = Logger.getLogger(multianewarray.class);\n+\n+   private Integer[][] createMultiArray(int firstDimLength, int secondDimLength)\n+      {\n+      Integer[][] multiarray = new Integer[firstDimLength][secondDimLength];\n+      for (int i = 0; i < firstDimLength; i++)\n+         {\n+         for (int j = 0; j < secondDimLength; j++)\n+            {\n+            multiarray[i][j] = i * j;\n+            }\n+         }\n+      return multiarray;\n+      }\n+\n+   private boolean testMultiArray(Integer[][] inputArray)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5263da19db7f55f00d638cc6d8ca672dfe11c20"}, "originalPosition": 49}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "76d8f5dcc9120f101fd2623db027ab8a7befd442", "author": {"user": {"login": "dchopra001", "name": "Dhruv Chopra"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/76d8f5dcc9120f101fd2623db027ab8a7befd442", "committedDate": "2020-11-26T21:30:55Z", "message": "Newline\n\nSigned-off-by: Dhruv Chopra <Dhruv.C.Chopra@ibm.com>"}, "afterCommit": {"oid": "96a5c5234fa62e73ea3e4ceba64bd5c0d782421d", "author": {"user": {"login": "dchopra001", "name": "Dhruv Chopra"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/96a5c5234fa62e73ea3e4ceba64bd5c0d782421d", "committedDate": "2020-11-26T21:32:58Z", "message": "Newline and formatting changes\n\nSigned-off-by: Dhruv Chopra <Dhruv.C.Chopra@ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM5NTY0NDUw", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#pullrequestreview-539564450", "createdAt": "2020-11-26T22:14:28Z", "commit": {"oid": "96a5c5234fa62e73ea3e4ceba64bd5c0d782421d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQyMjoxNDoyOVrOH6oPrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQyMjoxNDoyOVrOH6oPrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTIzODgyOQ==", "bodyText": "btw, adding the class name under arrayTest  means any test target in playlist.xml uses -testnames arrayTest  will run this test. That is,\njit_jitt\njit_jitt_openj9_none_SCC\njit_jitt_none_SCC\njit_jitt_XCEEHDLR\nPlease ignore this comment if the change is intended. I just want to point it out so we do not run this test in the wrong test target or miss any cases.", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r531238829", "createdAt": "2020-11-26T22:14:29Z", "author": {"login": "llxia"}, "path": "test/functional/JIT_Test/testng.xml", "diffHunk": "@@ -46,6 +46,7 @@\n       <class name=\"jit.test.jitt.array.intArrayLoadStore\"/>\n       <class name=\"jit.test.jitt.array.intArrayLoadStoreConstIndices\"/>\n       <class name=\"jit.test.jitt.array.shortArrayLoadStore\"/>\n+      <class name=\"jit.test.jitt.array.multianewarray\"/>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "96a5c5234fa62e73ea3e4ceba64bd5c0d782421d"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQwMDU1MjAz", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#pullrequestreview-540055203", "createdAt": "2020-11-27T15:25:37Z", "commit": {"oid": "51ffa13092c2029ae450eb5641c0a97f99a65d6a"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "51ffa13092c2029ae450eb5641c0a97f99a65d6a", "author": {"user": {"login": "dchopra001", "name": "Dhruv Chopra"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/51ffa13092c2029ae450eb5641c0a97f99a65d6a", "committedDate": "2020-11-27T15:13:12Z", "message": "Remove class extension\n\nSigned-off-by: Dhruv Chopra <Dhruv.C.Chopra@ibm.com>"}, "afterCommit": {"oid": "226b06d9b0f332ac3613850b231c1a2525115a13", "author": {"user": {"login": "dchopra001", "name": "Dhruv Chopra"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/226b06d9b0f332ac3613850b231c1a2525115a13", "committedDate": "2020-11-27T18:41:47Z", "message": "Rewrite multianewarray evaluator on Z\n\nThis commit adds support for 2-dimensional arrays\nwhere the second dimension has length=0 in the\nmultianewarrayEvaluator. Additionally, some new tests\nare also added to test this functionality.\n\nSigned-off-by: Dhruv Chopra <Dhruv.C.Chopra@ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "226b06d9b0f332ac3613850b231c1a2525115a13", "author": {"user": {"login": "dchopra001", "name": "Dhruv Chopra"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/226b06d9b0f332ac3613850b231c1a2525115a13", "committedDate": "2020-11-27T18:41:47Z", "message": "Rewrite multianewarray evaluator on Z\n\nThis commit adds support for 2-dimensional arrays\nwhere the second dimension has length=0 in the\nmultianewarrayEvaluator. Additionally, some new tests\nare also added to test this functionality.\n\nSigned-off-by: Dhruv Chopra <Dhruv.C.Chopra@ibm.com>"}, "afterCommit": {"oid": "bd8761af7859a8690f90f86da594d5d63ba68f5b", "author": {"user": {"login": "dchopra001", "name": "Dhruv Chopra"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/bd8761af7859a8690f90f86da594d5d63ba68f5b", "committedDate": "2020-11-30T19:02:18Z", "message": "Rewrite multianewarray evaluator on Z\n\nThis commit adds support for 2-dimensional arrays\nwhere the second dimension has length=0 in the\nmultianewarrayEvaluator. Additionally, some new tests\nare also added to test this functionality.\n\nSigned-off-by: Dhruv Chopra <Dhruv.C.Chopra@ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "bd8761af7859a8690f90f86da594d5d63ba68f5b", "author": {"user": {"login": "dchopra001", "name": "Dhruv Chopra"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/bd8761af7859a8690f90f86da594d5d63ba68f5b", "committedDate": "2020-11-30T19:02:18Z", "message": "Rewrite multianewarray evaluator on Z\n\nThis commit adds support for 2-dimensional arrays\nwhere the second dimension has length=0 in the\nmultianewarrayEvaluator. Additionally, some new tests\nare also added to test this functionality.\n\nSigned-off-by: Dhruv Chopra <Dhruv.C.Chopra@ibm.com>"}, "afterCommit": {"oid": "885bb78e242d05f5865d3e4ddfe6d9c8b1beef0a", "author": {"user": {"login": "dchopra001", "name": "Dhruv Chopra"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/885bb78e242d05f5865d3e4ddfe6d9c8b1beef0a", "committedDate": "2020-11-30T19:07:03Z", "message": "Rewrite multianewarray evaluator on Z\n\nThis commit adds support for 2-dimensional arrays\nwhere the second dimension has length=0 in the\nmultianewarrayEvaluator. Additionally, some new tests\nare also added to test this functionality.\n\nSigned-off-by: Dhruv Chopra <Dhruv.C.Chopra@ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxMjIxMzQw", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#pullrequestreview-541221340", "createdAt": "2020-11-30T19:24:24Z", "commit": {"oid": "885bb78e242d05f5865d3e4ddfe6d9c8b1beef0a"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "885bb78e242d05f5865d3e4ddfe6d9c8b1beef0a", "author": {"user": {"login": "dchopra001", "name": "Dhruv Chopra"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/885bb78e242d05f5865d3e4ddfe6d9c8b1beef0a", "committedDate": "2020-11-30T19:07:03Z", "message": "Rewrite multianewarray evaluator on Z\n\nThis commit adds support for 2-dimensional arrays\nwhere the second dimension has length=0 in the\nmultianewarrayEvaluator. Additionally, some new tests\nare also added to test this functionality.\n\nSigned-off-by: Dhruv Chopra <Dhruv.C.Chopra@ibm.com>"}, "afterCommit": {"oid": "f85779ba406f57f872f3765b1546487d3f16dc4e", "author": {"user": {"login": "dchopra001", "name": "Dhruv Chopra"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/f85779ba406f57f872f3765b1546487d3f16dc4e", "committedDate": "2020-11-30T19:35:20Z", "message": "Rewrite multianewarray evaluator on Z\n\nThis commit adds support for 2-dimensional arrays\nwhere the second dimension has length=0 in the\nmultianewarrayEvaluator. Additionally, some new tests\nare also added to test this functionality.\n\nSigned-off-by: Dhruv Chopra <Dhruv.C.Chopra@ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxMzQyNDkx", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#pullrequestreview-541342491", "createdAt": "2020-11-30T22:21:35Z", "commit": {"oid": "f85779ba406f57f872f3765b1546487d3f16dc4e"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQyMjoyMTozNlrOH8QLdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQyMjoyMTozNlrOH8QLdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjk0MTY4NA==", "bodyText": "I think the 10000 here may be causing timeout issues on Power. For example see here:\nhttps://ci.eclipse.org/openj9/job/Test_openjdk8_j9_sanity.functional_ppc64_aix_Personal_testList_1/95/console\n16:28:11  variation: -Xrs -Xjit:noJitUntilMain,count=0,assumeStrictFP,optlevel=warm,gcOnResolve,rtResolve -verbose:stackwalk=0 -Xdump\n16:28:11  JVM_OPTIONS:  -Xrs -Xjit:noJitUntilMain,count=0,assumeStrictFP,optlevel=warm,gcOnResolve,rtResolve -verbose:stackwalk=0 -Xdump \n16:28:11  { itercnt=1; \\\n16:28:11  mkdir -p \"/home/jenkins/workspace/Test_openjdk8_j9_sanity.functional_ppc64_aix_Personal_testList_1/openjdk-tests/TKG/../TKG/test_output_16067716828123/jit_jitt_1\"; \\\n16:28:11  cd \"/home/jenkins/workspace/Test_openjdk8_j9_sanity.functional_ppc64_aix_Personal_testList_1/openjdk-tests/TKG/../TKG/test_output_16067716828123/jit_jitt_1\"; \\\n16:28:11  \"/home/jenkins/workspace/Test_openjdk8_j9_sanity.functional_ppc64_aix_Personal_testList_1/openjdkbinary/j2sdk-image/bin/java\"  -Xrs -Xjit:noJitUntilMain,count=0,assumeStrictFP,optlevel=warm,gcOnResolve,rtResolve -verbose:stackwalk=0 -Xdump  \\\n16:28:11  -cp \"/home/jenkins/workspace/Test_openjdk8_j9_sanity.functional_ppc64_aix_Personal_testList_1/openjdk-tests/TKG/../../jvmtest/TestConfig/resources:/home/jenkins/workspace/Test_openjdk8_j9_sanity.functional_ppc64_aix_Personal_testList_1/openjdk-tests/TKG/../TKG/lib/testng.jar:/home/jenkins/workspace/Test_openjdk8_j9_sanity.functional_ppc64_aix_Personal_testList_1/openjdk-tests/TKG/../TKG/lib/jcommander.jar:/home/jenkins/workspace/Test_openjdk8_j9_sanity.functional_ppc64_aix_Personal_testList_1/openjdk-tests/TKG/../../jvmtest/functional/JIT_Test/jitt.jar\" \\\n16:28:11  org.testng.TestNG -d \"/home/jenkins/workspace/Test_openjdk8_j9_sanity.functional_ppc64_aix_Personal_testList_1/openjdk-tests/TKG/../TKG/test_output_16067716828123/jit_jitt_1\" \"/home/jenkins/workspace/Test_openjdk8_j9_sanity.functional_ppc64_aix_Personal_testList_1/openjdk-tests/TKG/../../jvmtest/functional/JIT_Test/testng.xml\" \\\n16:28:11  -testnames \\\n16:28:11  arrayTest,\\\n16:28:11  assemblerTest,\\\n16:28:11  castingTest,\\\n16:28:11  cfgTest,\\\n16:28:11  crashesTest,\\\n16:28:11  ctresolvesTest,\\\n16:28:11  exceptionsTest,\\\n16:28:11  fieldsTest,\\\n16:28:11  floatsTest,\\\n16:28:11  gcTest,\\\n16:28:11  geCastingTest,\\\n16:28:11  immedOpTest,\\\n16:28:11  invokeTest,\\\n16:28:11  mathTest,\\\n16:28:11  math2Test,\\\n16:28:11  miscTest,\\\n16:28:11  os390LinkageTest,\\\n16:28:11  promotionTest,\\\n16:28:11  resolvesTest,\\\n16:28:11  sieveTest,\\\n16:28:11  transitionsTest \\\n16:28:11  -groups level.sanity \\\n16:28:11  -excludegroups d.*.aix_ppc-64_cmprssptrs,d.*.arch.ppc,d.*.os.aix,d.*.bits.64,d.*.generic-all; \\\n16:28:11  if [ $? -eq 0 ] ; then echo \"\"; echo \"jit_jitt_1\"\"_PASSED\"; echo \"\"; cd /home/jenkins/workspace/Test_openjdk8_j9_sanity.functional_ppc64_aix_Personal_testList_1/openjdk-tests/TKG/..;  else echo \"\"; echo \"jit_jitt_1\"\"_FAILED\"; echo \"\"; fi; } 2>&1 | tee -a \"/home/jenkins/workspace/Test_openjdk8_j9_sanity.functional_ppc64_aix_Personal_testList_1/openjdk-tests/TKG/../TKG/test_output_16067716828123/TestTargetResult\";\n16:28:17  [IncludeExcludeTestAnnotationTransformer] [INFO] exclude file is /home/jenkins/workspace/Test_openjdk8_j9_sanity.functional_ppc64_aix_Personal_testList_1/openjdk-tests/TKG/../TestConfig/resources/excludes/latest_exclude_8.txt\n16:28:17  ...\n16:28:17  ... TestNG 6.14.2 by C\u00e9dric Beust (cedric@beust.com)\n16:28:17  ...\n16:28:17  \nCalling Pipeline was cancelled\n16:34:50  Sending interrupt signal to process\n16:35:04  /bin/sh[4]: 20316372 Terminated\n16:35:04  \n16:35:04  jit_jitt_1_FAILED\n\nIt was spinning for 5 mins. then got cancelled. Can we tone this down to something more reasonable, perhaps 64 would be enough?", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#discussion_r532941684", "createdAt": "2020-11-30T22:21:36Z", "author": {"login": "fjeremic"}, "path": "test/functional/JIT_Test/src/jit/test/jitt/array/multianewarray.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+package jit.test.jitt.array;\n+\n+import org.testng.annotations.Test;\n+import org.testng.Assert;\t\n+import org.testng.AssertJUnit;\n+\n+@Test(groups = { \"level.sanity\",\"component.jit\" }, invocationCount=2)\n+public class multianewarray {\n+\tclass Vector {\n+\t\tlong x;\n+\t\tlong y;\n+\t}\n+\n+\tprivate Integer[][] createMultiArray(int firstDimLength, int secondDimLength) {\n+\t\tInteger[][] multiarray = new Integer[firstDimLength][secondDimLength];\n+\t\tfor (int i = 0; i < firstDimLength; i++) {\n+\t\t\tfor (int j = 0; j < secondDimLength; j++) {\n+\t\t\t\tmultiarray[i][j] = i * j;\n+\t\t\t}\n+\t\t}\n+\t\treturn multiarray;\n+\t}\n+\n+\tprivate Vector[][] createMultiVector(int firstDimLength, int secondDimLength) {\n+\t\tVector[][] multiVector = new Vector[firstDimLength][secondDimLength];\n+\t\tfor (int i = 0; i < firstDimLength; i++) {\n+\t\t\tfor (int j = 0; j < secondDimLength; j++) {\n+\t\t\t\tmultiVector[i][j] = new Vector();\n+\t\t\t\tmultiVector[i][j].x = i * j;\n+\t\t\t\tmultiVector[i][j].y = i * i + j * j;\n+\t\t\t}\n+\t\t}\n+\t\treturn multiVector;\n+\t}\n+\n+\tprivate void testMultiVector(Vector[][] inputVector, int dim1Length, int dim2Length) {\n+\t\tAssertJUnit.assertEquals(dim1Length, inputVector.length);\n+\t\tif (inputVector.length > 0)\n+\t\t\tAssertJUnit.assertEquals(dim2Length, inputVector[0].length);\n+\n+\t\tfor (int i = 0; i < inputVector.length; i++) {\n+\t\t\tfor (int j = 0; j < inputVector[0].length; j++) {\n+\t\t\t\tAssertJUnit.assertEquals(i*j, (inputVector[i][j]).x);\n+\t\t\t\tAssertJUnit.assertEquals(i*i + j*j, (inputVector[i][j]).y);\n+\t\t\t}\n+\t\t}\n+\t}\n+\tprivate void testMultiArray(Integer[][] inputArray, int dim1Length, int dim2Length) {\n+\t\tAssertJUnit.assertEquals(dim1Length, inputArray.length);\n+\t\tif (inputArray.length > 0)\n+\t\t\tAssertJUnit.assertEquals(dim2Length, inputArray[0].length);\n+\t\tfor (int i = 0; i < inputArray.length; i++) {\n+\t\t\tfor (int j = 0; j < inputArray[0].length; j++) {\n+\t\t\t\tAssertJUnit.assertEquals(i*j, (inputArray[i][j]).intValue());\n+\t\t\t}\n+\t\t}\n+\t}\n+\t@Test\n+\tpublic void testmultianewarray() {\n+\t\tInteger[][] inputArray;\n+\t\tVector[][] inputVector;\n+\t\tfor (int i = 0; i < 10000; i++) {\n+\t\t\tinputVector = createMultiVector(0, 0);\n+\t\t\ttestMultiVector(inputVector, 0, 0);\n+\t\t\tinputArray = createMultiArray(0, 0);\n+\t\t\ttestMultiArray(inputArray, 0, 0);\n+\t\t}\n+\t\tfor (int i = 0; i < 10000; i++) {\n+\t\t\tinputVector = createMultiVector(i, 0);\n+\t\t\ttestMultiVector(inputVector, i, 0);\n+\t\t\tinputArray = createMultiArray(i, 0);\n+\t\t\ttestMultiArray(inputArray, i, 0);\n+\t\t}\n+\t\tfor (int i = 0; i < 10000; i++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f85779ba406f57f872f3765b1546487d3f16dc4e"}, "originalPosition": 95}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cfd7aa6e7164f3ba2a7d30e51a5c78ae657b70a3", "author": {"user": {"login": "dchopra001", "name": "Dhruv Chopra"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/cfd7aa6e7164f3ba2a7d30e51a5c78ae657b70a3", "committedDate": "2020-11-30T22:26:03Z", "message": "Rewrite multianewarray evaluator on Z\n\nThis commit adds support for 2-dimensional arrays\nwhere the second dimension has length=0 in the\nmultianewarrayEvaluator. Additionally, some new tests\nare also added to test this functionality.\n\nSigned-off-by: Dhruv Chopra <Dhruv.C.Chopra@ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f85779ba406f57f872f3765b1546487d3f16dc4e", "author": {"user": {"login": "dchopra001", "name": "Dhruv Chopra"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/f85779ba406f57f872f3765b1546487d3f16dc4e", "committedDate": "2020-11-30T19:35:20Z", "message": "Rewrite multianewarray evaluator on Z\n\nThis commit adds support for 2-dimensional arrays\nwhere the second dimension has length=0 in the\nmultianewarrayEvaluator. Additionally, some new tests\nare also added to test this functionality.\n\nSigned-off-by: Dhruv Chopra <Dhruv.C.Chopra@ibm.com>"}, "afterCommit": {"oid": "cfd7aa6e7164f3ba2a7d30e51a5c78ae657b70a3", "author": {"user": {"login": "dchopra001", "name": "Dhruv Chopra"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/cfd7aa6e7164f3ba2a7d30e51a5c78ae657b70a3", "committedDate": "2020-11-30T22:26:03Z", "message": "Rewrite multianewarray evaluator on Z\n\nThis commit adds support for 2-dimensional arrays\nwhere the second dimension has length=0 in the\nmultianewarrayEvaluator. Additionally, some new tests\nare also added to test this functionality.\n\nSigned-off-by: Dhruv Chopra <Dhruv.C.Chopra@ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxMzQ2NDI3", "url": "https://github.com/eclipse-openj9/openj9/pull/11088#pullrequestreview-541346427", "createdAt": "2020-11-30T22:28:47Z", "commit": {"oid": "cfd7aa6e7164f3ba2a7d30e51a5c78ae657b70a3"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 89, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}