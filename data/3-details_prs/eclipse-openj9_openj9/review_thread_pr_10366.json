{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY2MDkxNDAw", "number": 10366, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMzowODoyOVrOEXM7aA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxODoxNDozNVrOEZmTaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNzY0NTIwOnYy", "diffSide": "LEFT", "path": "runtime/compiler/p/codegen/J9TreeEvaluator.cpp", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMzowODoyOVrOG-29fA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QyMToyNzo0NlrOHB7dtg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODU2NTM3Mg==", "bodyText": "I have a question to both @gita-omr  and @andrewcraik , I see that P and x86 codegen further forces the Unsafe.copyMemory calls to be inlined in case optimizer misses it. I do not see we do it on Z. Is it possible (Apart from running with noOpt) that optimizer would miss this call to transform?", "url": "https://github.com/eclipse-openj9/openj9/pull/10366#discussion_r468565372", "createdAt": "2020-08-11T13:08:29Z", "author": {"login": "r30shah"}, "path": "runtime/compiler/p/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -11993,8 +11993,11 @@ J9::Power::CodeGenerator::inlineDirectCall(TR::Node *node, TR::Register *&result\n             }\n          break;\n          }\n-", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "643d77094f17e6804dca021bf8e12c9a8a638090"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODU3ODU5MQ==", "bodyText": "the inlining in the inliner is always optional - the inliner may run out of budget before considering a call or may choose to spend budget elsewhere. While things like always inline bypass most of the heuristics related to budget - the current inliner is eager and so once it has consumed its budget it will stop considering callsites which can leave 'alwaysInline' methods not inlined.", "url": "https://github.com/eclipse-openj9/openj9/pull/10366#discussion_r468578591", "createdAt": "2020-08-11T13:28:27Z", "author": {"login": "andrewcraik"}, "path": "runtime/compiler/p/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -11993,8 +11993,11 @@ J9::Power::CodeGenerator::inlineDirectCall(TR::Node *node, TR::Register *&result\n             }\n          break;\n          }\n-", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODU2NTM3Mg=="}, "originalCommit": {"oid": "643d77094f17e6804dca021bf8e12c9a8a638090"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTc4NDg4Ng==", "bodyText": "IMO we should move that reduction out of the codegen evaluators and right into the J9RecognizedCallTransformer so all codegens can transparently take advantage. I'd try to avoid duplicating the already duplicated logic on Z.", "url": "https://github.com/eclipse-openj9/openj9/pull/10366#discussion_r471784886", "createdAt": "2020-08-17T21:27:46Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/p/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -11993,8 +11993,11 @@ J9::Power::CodeGenerator::inlineDirectCall(TR::Node *node, TR::Register *&result\n             }\n          break;\n          }\n-", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODU2NTM3Mg=="}, "originalCommit": {"oid": "643d77094f17e6804dca021bf8e12c9a8a638090"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNzczMzIwOnYy", "diffSide": "RIGHT", "path": "runtime/compiler/codegen/J9RecognizedMethodsEnum.hpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMzoyOToyNlrOG-3z0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMzoyOToyNlrOG-3z0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODU3OTI4Mw==", "bodyText": "I am not a fan of ifdef'd enum entries this makes corefile analysis and other things much harder than it needs to be - keep the numbering consistent. We do not generally use JDK version macros like this.", "url": "https://github.com/eclipse-openj9/openj9/pull/10366#discussion_r468579283", "createdAt": "2020-08-11T13:29:26Z", "author": {"login": "andrewcraik"}, "path": "runtime/compiler/codegen/J9RecognizedMethodsEnum.hpp", "diffHunk": "@@ -415,6 +415,10 @@\n \n    sun_misc_Unsafe_ensureClassInitialized,\n \n+#if JAVA_SPEC_VERSION >= 11", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "643d77094f17e6804dca021bf8e12c9a8a638090"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNzc0NDIyOnYy", "diffSide": "RIGHT", "path": "runtime/compiler/il/J9Node.cpp", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMzozMTo1NFrOG-36kg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwMDozODo0MlrOG_N1vg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODU4MTAxMA==", "bodyText": "I really don't think the method specific naming convention here makes sense. I think we should have an Unsafe_copyMemory_intrinsic which is what we match the sun/misc/Unsafe.copyMemory to under JDK8 and what we match the copyMemory0 to under JDK11. I think also that if there is a method to be inlined like jdk_internal_misc_Unsafe_copyMmeory0 that recognition can be matched unconditionally - it will only match when we are running JDK11 onward when the method moved. If there is a windows where the method moved but was native we can just check for the method being native before we recognize it and make all that matching code uncondition.\nUsing the Unsafe_copyMemory_intrinsic that is what OMR can reference and avoid Java specific issues to surface at that level of the architecture.", "url": "https://github.com/eclipse-openj9/openj9/pull/10366#discussion_r468581010", "createdAt": "2020-08-11T13:31:54Z", "author": {"login": "andrewcraik"}, "path": "runtime/compiler/il/J9Node.cpp", "diffHunk": "@@ -299,7 +299,12 @@ J9::Node::processJNICall(TR::TreeTop * callNodeTreeTop, TR::ResolvedMethodSymbol\n #endif\n \n    if (comp->canTransformUnsafeCopyToArrayCopy() &&\n-       (methodSymbol->getRecognizedMethod() == TR::sun_misc_Unsafe_copyMemory))\n+#if JAVA_SPEC_VERSION == 8", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "643d77094f17e6804dca021bf8e12c9a8a638090"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODk0MDIyMg==", "bodyText": "@andrewcraik  I have made changes that removes the #if macros that was checking the JAVA Version. I agree that we do not have to guard jdk_internal_misc_Unsafe_copyMmeory0 with JAVA SPEC version. Right now in JDK8 and JDK11, we have seen JNI methods sun/misc/Unsafe.copyMemory and jdk/internal/misc/Unsafe.copyMemory0 respectively and I have added an additional check to make sure it does the transformation only when it is JNI method in d1952e6", "url": "https://github.com/eclipse-openj9/openj9/pull/10366#discussion_r468940222", "createdAt": "2020-08-12T00:38:42Z", "author": {"login": "r30shah"}, "path": "runtime/compiler/il/J9Node.cpp", "diffHunk": "@@ -299,7 +299,12 @@ J9::Node::processJNICall(TR::TreeTop * callNodeTreeTop, TR::ResolvedMethodSymbol\n #endif\n \n    if (comp->canTransformUnsafeCopyToArrayCopy() &&\n-       (methodSymbol->getRecognizedMethod() == TR::sun_misc_Unsafe_copyMemory))\n+#if JAVA_SPEC_VERSION == 8", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODU4MTAxMA=="}, "originalCommit": {"oid": "643d77094f17e6804dca021bf8e12c9a8a638090"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMDAzMDcxOnYy", "diffSide": "RIGHT", "path": "runtime/compiler/il/J9Node.cpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwMDo0MDo0NFrOG_N38Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwMDo0MDo0NFrOG_N38Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODk0MDc4NQ==", "bodyText": "I found that having a query on the call node is the most convenient place as we can have all the information to check whether call node is JNI call and it is one of the recognized copyMemory method.", "url": "https://github.com/eclipse-openj9/openj9/pull/10366#discussion_r468940785", "createdAt": "2020-08-12T00:40:44Z", "author": {"login": "r30shah"}, "path": "runtime/compiler/il/J9Node.cpp", "diffHunk": "@@ -2212,6 +2212,23 @@ J9::Node::setDontInlinePutOrderedCall()\n    }\n \n bool\n+J9::Node::isUnsafeCopyMemoryIntrinsic()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cdb436ce300395af11b2c1e141c4aa783f6e71b2"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0ODQ3NTMxOnYy", "diffSide": "RIGHT", "path": "runtime/compiler/optimizer/J9ValuePropagation.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QxOToxMTowOFrOHB3fDQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QxOTo1NToxOFrOHB4w0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTcxOTY5Mw==", "bodyText": "These seem to only get used within the if block below. Can we move them there to limit the scope of the variables and make the code easier to reason about?", "url": "https://github.com/eclipse-openj9/openj9/pull/10366#discussion_r471719693", "createdAt": "2020-08-17T19:11:08Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/optimizer/J9ValuePropagation.cpp", "diffHunk": "@@ -483,6 +483,88 @@ bool J9::ValuePropagation::transformIndexOfKnownString(\n    return false;\n    }\n \n+bool J9::ValuePropagation::transformUnsafeCopyMemoryCall(TR::Node *arraycopyNode)\n+   {\n+   if (!canRunTransformToArrayCopy())\n+      return false;\n+\n+   TR::TreeTop *tt = _curTree;\n+   TR::Node *ttNode = tt->getNode();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cdb436ce300395af11b2c1e141c4aa783f6e71b2"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTc0MDYyNQ==", "bodyText": "Fixed in https://github.com/eclipse/openj9/compare/d8f5f521fc955e5cb1fbfeaa0d418cb475503a1a..ff0b1e1650935286a1a1c68ca3f5b8d8402e489a", "url": "https://github.com/eclipse-openj9/openj9/pull/10366#discussion_r471740625", "createdAt": "2020-08-17T19:55:18Z", "author": {"login": "r30shah"}, "path": "runtime/compiler/optimizer/J9ValuePropagation.cpp", "diffHunk": "@@ -483,6 +483,88 @@ bool J9::ValuePropagation::transformIndexOfKnownString(\n    return false;\n    }\n \n+bool J9::ValuePropagation::transformUnsafeCopyMemoryCall(TR::Node *arraycopyNode)\n+   {\n+   if (!canRunTransformToArrayCopy())\n+      return false;\n+\n+   TR::TreeTop *tt = _curTree;\n+   TR::Node *ttNode = tt->getNode();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTcxOTY5Mw=="}, "originalCommit": {"oid": "cdb436ce300395af11b2c1e141c4aa783f6e71b2"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0ODQ4MTY1OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/optimizer/J9ValuePropagation.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QxOToxMzowOFrOHB3i1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QxOTo1Mzo0MFrOHB4t3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTcyMDY2MQ==", "bodyText": "We can move these definitions down to where the variables get set, so:\n         int64_t srcOffLow   = srcOffsetConstraint ? srcOffsetConstraint->getLowInt() : TR::getMinSigned<TR::Int32>();\n         int64_t srcOffHigh  = srcOffsetConstraint ? srcOffsetConstraint->getHighInt() : TR::getMaxSigned<TR::Int32>();\n         int64_t dstOffLow   = dstOffsetConstraint ? dstOffsetConstraint->getLowInt() : TR::getMinSigned<TR::Int32>();\n         int64_t dstOffHigh  = dstOffsetConstraint ? dstOffsetConstraint->getHighInt() : TR::getMaxSigned<TR::Int32>();\n         int64_t copyLenLow  = copyLenConstraint   ? copyLenConstraint->getLowInt() : TR::getMinSigned<TR::Int32>();\n         int64_t copyLenHigh = copyLenConstraint   ? copyLenConstraint->getHighInt() : TR::getMaxSigned<TR::Int32>();", "url": "https://github.com/eclipse-openj9/openj9/pull/10366#discussion_r471720661", "createdAt": "2020-08-17T19:13:08Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/optimizer/J9ValuePropagation.cpp", "diffHunk": "@@ -483,6 +483,88 @@ bool J9::ValuePropagation::transformIndexOfKnownString(\n    return false;\n    }\n \n+bool J9::ValuePropagation::transformUnsafeCopyMemoryCall(TR::Node *arraycopyNode)\n+   {\n+   if (!canRunTransformToArrayCopy())\n+      return false;\n+\n+   TR::TreeTop *tt = _curTree;\n+   TR::Node *ttNode = tt->getNode();\n+\n+   if (comp()->canTransformUnsafeCopyToArrayCopy()\n+         && arraycopyNode->isUnsafeCopyMemoryIntrinsic())\n+      {\n+\n+      if ((ttNode->getOpCodeValue() == TR::treetop || ttNode->getOpCode().isResolveOrNullCheck())\n+            && performTransformation(comp(), \"%sChanging call Unsafe.copyMemory [%p] to arraycopy\\n\", OPT_DETAILS, arraycopyNode))\n+\n+         {\n+         TR::Node *unsafe     = arraycopyNode->getChild(0);\n+         TR::Node *src        = arraycopyNode->getChild(1);\n+         TR::Node *srcOffset  = arraycopyNode->getChild(2);\n+         TR::Node *dest       = arraycopyNode->getChild(3);\n+         TR::Node *destOffset = arraycopyNode->getChild(4);\n+         TR::Node *len        = arraycopyNode->getChild(5);\n+\n+         int64_t srcOffLow;\n+         int64_t srcOffHigh;\n+         int64_t dstOffLow;\n+         int64_t dstOffHigh;\n+         int64_t copyLenLow;\n+         int64_t copyLenHigh;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cdb436ce300395af11b2c1e141c4aa783f6e71b2"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTczOTg3MA==", "bodyText": "Fixed in https://github.com/eclipse/openj9/compare/cdb436ce300395af11b2c1e141c4aa783f6e71b2..d8f5f521fc955e5cb1fbfeaa0d418cb475503a1a", "url": "https://github.com/eclipse-openj9/openj9/pull/10366#discussion_r471739870", "createdAt": "2020-08-17T19:53:40Z", "author": {"login": "r30shah"}, "path": "runtime/compiler/optimizer/J9ValuePropagation.cpp", "diffHunk": "@@ -483,6 +483,88 @@ bool J9::ValuePropagation::transformIndexOfKnownString(\n    return false;\n    }\n \n+bool J9::ValuePropagation::transformUnsafeCopyMemoryCall(TR::Node *arraycopyNode)\n+   {\n+   if (!canRunTransformToArrayCopy())\n+      return false;\n+\n+   TR::TreeTop *tt = _curTree;\n+   TR::Node *ttNode = tt->getNode();\n+\n+   if (comp()->canTransformUnsafeCopyToArrayCopy()\n+         && arraycopyNode->isUnsafeCopyMemoryIntrinsic())\n+      {\n+\n+      if ((ttNode->getOpCodeValue() == TR::treetop || ttNode->getOpCode().isResolveOrNullCheck())\n+            && performTransformation(comp(), \"%sChanging call Unsafe.copyMemory [%p] to arraycopy\\n\", OPT_DETAILS, arraycopyNode))\n+\n+         {\n+         TR::Node *unsafe     = arraycopyNode->getChild(0);\n+         TR::Node *src        = arraycopyNode->getChild(1);\n+         TR::Node *srcOffset  = arraycopyNode->getChild(2);\n+         TR::Node *dest       = arraycopyNode->getChild(3);\n+         TR::Node *destOffset = arraycopyNode->getChild(4);\n+         TR::Node *len        = arraycopyNode->getChild(5);\n+\n+         int64_t srcOffLow;\n+         int64_t srcOffHigh;\n+         int64_t dstOffLow;\n+         int64_t dstOffHigh;\n+         int64_t copyLenLow;\n+         int64_t copyLenHigh;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTcyMDY2MQ=="}, "originalCommit": {"oid": "cdb436ce300395af11b2c1e141c4aa783f6e71b2"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0ODg3NzMxOnYy", "diffSide": "RIGHT", "path": "runtime/compiler/il/J9Node.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QyMToyMjoxOVrOHB7Tzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwMDo1Njo0M1rOHB_orw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTc4MjM1MQ==", "bodyText": "So many return points! Now sure if this would be cleaner:\n   if (self()->getOpCode().isCall() && self()->getSymbol()->isMethod())\n      {\n      TR::MethodSymbol *symbol = self()->getSymbol()->getMethodSymbol();\n      if (symbol != NULL && symbol->isNative())\n         {\n         switch (symbol->getRecognizedMethod())\n            {\n            case TR::sun_misc_Unsafe_copyMemory:\n            case TR::jdk_internal_misc_Unsafe_copyMemory0:\n                return true;\n            default:\n                break;\n            }\n         }\n      }\n   \n   return false;", "url": "https://github.com/eclipse-openj9/openj9/pull/10366#discussion_r471782351", "createdAt": "2020-08-17T21:22:19Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/il/J9Node.cpp", "diffHunk": "@@ -2212,6 +2212,23 @@ J9::Node::setDontInlinePutOrderedCall()\n    }\n \n bool\n+J9::Node::isUnsafeCopyMemoryIntrinsic()\n+   {\n+   if (!self()->getOpCode().isCall() || !self()->getSymbol()->isMethod())\n+      return false;\n+   TR::MethodSymbol *symbol = self()->getSymbol()->getMethodSymbol();\n+   if (!symbol || !symbol->isNative())\n+      return false;\n+   switch (symbol->getRecognizedMethod())\n+      {\n+      case TR::sun_misc_Unsafe_copyMemory:\n+      case TR::jdk_internal_misc_Unsafe_copyMemory0:\n+         return true;\n+      default:\n+         return false;\n+      }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b7e35a24c88400aebba54647550e37df536c44c"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg1MzIzMQ==", "bodyText": "Fixed in https://github.com/eclipse/openj9/compare/5b7e35a24c88400aebba54647550e37df536c44c..91cf3d3105d3cec00915a532186cdcbf5977262d", "url": "https://github.com/eclipse-openj9/openj9/pull/10366#discussion_r471853231", "createdAt": "2020-08-18T00:56:43Z", "author": {"login": "r30shah"}, "path": "runtime/compiler/il/J9Node.cpp", "diffHunk": "@@ -2212,6 +2212,23 @@ J9::Node::setDontInlinePutOrderedCall()\n    }\n \n bool\n+J9::Node::isUnsafeCopyMemoryIntrinsic()\n+   {\n+   if (!self()->getOpCode().isCall() || !self()->getSymbol()->isMethod())\n+      return false;\n+   TR::MethodSymbol *symbol = self()->getSymbol()->getMethodSymbol();\n+   if (!symbol || !symbol->isNative())\n+      return false;\n+   switch (symbol->getRecognizedMethod())\n+      {\n+      case TR::sun_misc_Unsafe_copyMemory:\n+      case TR::jdk_internal_misc_Unsafe_copyMemory0:\n+         return true;\n+      default:\n+         return false;\n+      }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTc4MjM1MQ=="}, "originalCommit": {"oid": "5b7e35a24c88400aebba54647550e37df536c44c"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0ODg3ODQxOnYy", "diffSide": "RIGHT", "path": "runtime/compiler/il/J9Node.hpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QyMToyMjo0NVrOHB7Ujg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwMDo1NjoxOVrOHB_oXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTc4MjU0Mg==", "bodyText": "This needs to be Doxygen documented as to why it exists and what is its purpose.", "url": "https://github.com/eclipse-openj9/openj9/pull/10366#discussion_r471782542", "createdAt": "2020-08-17T21:22:45Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/il/J9Node.hpp", "diffHunk": "@@ -284,6 +284,8 @@ class OMR_EXTENSIBLE Node : public OMR::NodeConnector\n    bool chkDontInlineUnsafePutOrderedCall();\n    const char * printIsDontInlineUnsafePutOrderedCall();\n \n+   bool isUnsafeCopyMemoryIntrinsic();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b7e35a24c88400aebba54647550e37df536c44c"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg1MzE0OQ==", "bodyText": "Added brief in https://github.com/eclipse/openj9/compare/5b7e35a24c88400aebba54647550e37df536c44c..91cf3d3105d3cec00915a532186cdcbf5977262d", "url": "https://github.com/eclipse-openj9/openj9/pull/10366#discussion_r471853149", "createdAt": "2020-08-18T00:56:19Z", "author": {"login": "r30shah"}, "path": "runtime/compiler/il/J9Node.hpp", "diffHunk": "@@ -284,6 +284,8 @@ class OMR_EXTENSIBLE Node : public OMR::NodeConnector\n    bool chkDontInlineUnsafePutOrderedCall();\n    const char * printIsDontInlineUnsafePutOrderedCall();\n \n+   bool isUnsafeCopyMemoryIntrinsic();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTc4MjU0Mg=="}, "originalCommit": {"oid": "5b7e35a24c88400aebba54647550e37df536c44c"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1Mjc3NDE5OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/il/J9Node.hpp", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxODoxNDozNVrOHCgZng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQxNDoyNDo0NFrOHDJ5Vg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM5MDA0Ng==", "bodyText": "This API seems very very specific for it to exist in the Node class. I worry this class will turn into a kitchen sink eventually. Does this really need to exist? It seems it gets used in two locations:\n\nIn processJNICall which we can just replace with:\n\n   if (comp->canTransformUnsafeCopyToArrayCopy() &&\n       (methodSymbol->getRecognizedMethod() == TR::sun_misc_Unsafe_copyMemory ||\n        methodSymbol->getRecognizedMethod() == TR::jdk_internal_misc_Unsafe_copyMemory0))\n\n\nIn transformUnsafeCopyMemoryCall which we can just inline a partial version of this API.\n\nAre we sure introducing this extra complexity into the Node class outweighs the benefits?", "url": "https://github.com/eclipse-openj9/openj9/pull/10366#discussion_r472390046", "createdAt": "2020-08-18T18:14:35Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/il/J9Node.hpp", "diffHunk": "@@ -284,6 +284,11 @@ class OMR_EXTENSIBLE Node : public OMR::NodeConnector\n    bool chkDontInlineUnsafePutOrderedCall();\n    const char * printIsDontInlineUnsafePutOrderedCall();\n \n+   /**\n+    * Checks  and return true if the callNode is JNI Call to Unsafe.copyMemory\n+    */\n+   bool isUnsafeCopyMemoryIntrinsic();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa538f2b7d215cb17ca22ff9c8893ea698034030"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA0NTcxOA==", "bodyText": "@fjeremic  Reason I chose to introduce this API in Node class is that it contains all the information that it needed to verify if the JNI call can be transformed. Idea behind using this intrinsic is that if in later version of JDK if there are changes in the call chain, we only need to make changes in one place.\nThere is another potential use of this API in recognized call transformer to identify and transform this call as you suggested in #10366 (comment) , which I think we should pursue and remove the complexity and duplicate code from the codegen.", "url": "https://github.com/eclipse-openj9/openj9/pull/10366#discussion_r473045718", "createdAt": "2020-08-19T13:52:00Z", "author": {"login": "r30shah"}, "path": "runtime/compiler/il/J9Node.hpp", "diffHunk": "@@ -284,6 +284,11 @@ class OMR_EXTENSIBLE Node : public OMR::NodeConnector\n    bool chkDontInlineUnsafePutOrderedCall();\n    const char * printIsDontInlineUnsafePutOrderedCall();\n \n+   /**\n+    * Checks  and return true if the callNode is JNI Call to Unsafe.copyMemory\n+    */\n+   bool isUnsafeCopyMemoryIntrinsic();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM5MDA0Ng=="}, "originalCommit": {"oid": "fa538f2b7d215cb17ca22ff9c8893ea698034030"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA2OTkxMA==", "bodyText": "That sounds reasonable. Thanks for explaining further uses.", "url": "https://github.com/eclipse-openj9/openj9/pull/10366#discussion_r473069910", "createdAt": "2020-08-19T14:24:44Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/il/J9Node.hpp", "diffHunk": "@@ -284,6 +284,11 @@ class OMR_EXTENSIBLE Node : public OMR::NodeConnector\n    bool chkDontInlineUnsafePutOrderedCall();\n    const char * printIsDontInlineUnsafePutOrderedCall();\n \n+   /**\n+    * Checks  and return true if the callNode is JNI Call to Unsafe.copyMemory\n+    */\n+   bool isUnsafeCopyMemoryIntrinsic();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM5MDA0Ng=="}, "originalCommit": {"oid": "fa538f2b7d215cb17ca22ff9c8893ea698034030"}, "originalPosition": 14}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4671, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}