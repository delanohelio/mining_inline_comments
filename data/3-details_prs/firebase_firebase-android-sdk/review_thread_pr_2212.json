{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI5Njg3MjY1", "number": 2212, "reviewThreads": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQwMTo1NzoxMFrOE_aqAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQwMjoxNDozMVrOE_a4sQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0OTMyNDgxOnYy", "diffSide": "RIGHT", "path": "firebase-ml-modeldownloader/firebase-ml-modeldownloader.gradle", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQwMTo1NzoxMFrOH9HRWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQxNDo0OTozN1rOH9ei2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzg0NDMxNQ==", "bodyText": "Any particular reason for this change? Several other SDKs use it as as is.\u00a0", "url": "https://github.com/firebase/firebase-android-sdk/pull/2212#discussion_r533844315", "createdAt": "2020-12-02T01:57:10Z", "author": {"login": "rlazo"}, "path": "firebase-ml-modeldownloader/firebase-ml-modeldownloader.gradle", "diffHunk": "@@ -25,7 +25,7 @@ android {\n     compileSdkVersion project.targetSdkVersion\n \n     defaultConfig {\n-        minSdkVersion project.minSdkVersion\n+        minSdkVersion 16", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b270c4efe700860814b5078d60f38b2966934500"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDIxMzU0NA==", "bodyText": "The existing sdk we are replacing was also min 16, so keeping this limit seemed appropriate. I believe the specific requirement in this PR is the addition of the android.util.LongSparseArray - which requires 16 instead of 14.", "url": "https://github.com/firebase/firebase-android-sdk/pull/2212#discussion_r534213544", "createdAt": "2020-12-02T14:34:39Z", "author": {"login": "annzimmer"}, "path": "firebase-ml-modeldownloader/firebase-ml-modeldownloader.gradle", "diffHunk": "@@ -25,7 +25,7 @@ android {\n     compileSdkVersion project.targetSdkVersion\n \n     defaultConfig {\n-        minSdkVersion project.minSdkVersion\n+        minSdkVersion 16", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzg0NDMxNQ=="}, "originalCommit": {"oid": "b270c4efe700860814b5078d60f38b2966934500"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDIyNTYyNg==", "bodyText": "Got it, thanks!", "url": "https://github.com/firebase/firebase-android-sdk/pull/2212#discussion_r534225626", "createdAt": "2020-12-02T14:49:37Z", "author": {"login": "rlazo"}, "path": "firebase-ml-modeldownloader/firebase-ml-modeldownloader.gradle", "diffHunk": "@@ -25,7 +25,7 @@ android {\n     compileSdkVersion project.targetSdkVersion\n \n     defaultConfig {\n-        minSdkVersion project.minSdkVersion\n+        minSdkVersion 16", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzg0NDMxNQ=="}, "originalCommit": {"oid": "b270c4efe700860814b5078d60f38b2966934500"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0OTMyOTQ4OnYy", "diffSide": "RIGHT", "path": "firebase-ml-modeldownloader/src/main/java/com/google/firebase/ml/modeldownloader/CustomModel.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQwMTo1OTozMVrOH9HT9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQwMTo1OTozMVrOH9HT9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzg0NDk4Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * @return the local file associated with the model, if the original file download is still in\n          \n          \n            \n               *     progress, returns null, if file update is in progress returns last fully uploaded model.\n          \n          \n            \n               * @return the local file associated with the model. If the original file download is still in\n          \n          \n            \n               *     progress, returns null. If file update is in progress, returns the last fully uploaded model.", "url": "https://github.com/firebase/firebase-android-sdk/pull/2212#discussion_r533844983", "createdAt": "2020-12-02T01:59:31Z", "author": {"login": "rlazo"}, "path": "firebase-ml-modeldownloader/src/main/java/com/google/firebase/ml/modeldownloader/CustomModel.java", "diffHunk": "@@ -127,11 +129,29 @@ public String getName() {\n    *     progress, returns null, if file update is in progress returns last fully uploaded model.\n    */\n   @Nullable\n-  public File getFile() {\n+  public File getFile() throws Exception {\n+    return getFile(ModelFileDownloadService.getInstance());\n+  }\n+\n+  /**\n+   * The local model file. If null is returned, use the download Id to check the download status.\n+   *\n+   * @return the local file associated with the model, if the original file download is still in\n+   *     progress, returns null, if file update is in progress returns last fully uploaded model.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b270c4efe700860814b5078d60f38b2966934500"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0OTMzNTgxOnYy", "diffSide": "RIGHT", "path": "firebase-ml-modeldownloader/src/main/java/com/google/firebase/ml/modeldownloader/FirebaseModelDownloader.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQwMjowMjozMVrOH9HXeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQwMjowMjozMVrOH9HXeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzg0NTg4MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * Triggers the move to permanent storage of successful model downloads and list all models\n          \n          \n            \n               * Triggers the move to permanent storage of successful model downloads and lists all models", "url": "https://github.com/firebase/firebase-android-sdk/pull/2212#discussion_r533845880", "createdAt": "2020-12-02T02:02:31Z", "author": {"login": "rlazo"}, "path": "firebase-ml-modeldownloader/src/main/java/com/google/firebase/ml/modeldownloader/FirebaseModelDownloader.java", "diffHunk": "@@ -95,21 +112,77 @@ public static FirebaseModelDownloader getInstance(@NonNull FirebaseApp app) {\n   public Task<CustomModel> getModel(\n       @NonNull String modelName,\n       @NonNull DownloadType downloadType,\n-      @Nullable CustomModelDownloadConditions conditions) {\n+      @Nullable CustomModelDownloadConditions conditions)\n+      throws Exception {\n+    CustomModel localModel = sharedPreferencesUtil.getCustomModelDetails(modelName);\n+    switch (downloadType) {\n+      case LOCAL_MODEL:\n+        if (localModel != null) {\n+          return Tasks.forResult(localModel);\n+        }\n+        Task<CustomModel> modelDetails =\n+            modelDownloadService.getCustomModelDetails(\n+                firebaseOptions.getProjectId(), modelName, null);\n+\n+        // no local model - start download.\n+        return modelDetails.continueWithTask(\n+            executor,\n+            modelDetailTask -> {\n+              if (modelDetailTask.isSuccessful()) {\n+                // start download\n+                return fileDownloadService\n+                    .download(modelDetailTask.getResult(), conditions)\n+                    .continueWithTask(\n+                        executor,\n+                        downloadTask -> {\n+                          if (downloadTask.isSuccessful()) {\n+                            // read the updated model\n+                            CustomModel downloadedModel =\n+                                sharedPreferencesUtil.getCustomModelDetails(modelName);\n+                            // TODO(annz) trigger file move here as well... right now it's temp\n+                            // call loadNewlyDownloadedModelFile\n+                            return Tasks.forResult(downloadedModel);\n+                          }\n+                          return Tasks.forException(new Exception(\"File download failed.\"));\n+                        });\n+              }\n+              return Tasks.forException(modelDetailTask.getException());\n+            });\n+      case LATEST_MODEL:\n+        // check for latest model and download newest\n+        break;\n+      case LOCAL_MODEL_UPDATE_IN_BACKGROUND:\n+        // start download in back ground return current model if not null.\n+        break;\n+    }\n     throw new UnsupportedOperationException(\"Not yet implemented.\");\n   }\n \n-  /** @return The set of all models that are downloaded to this device. */\n+  /**\n+   * Triggers the move to permanent storage of successful model downloads and list all models", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b270c4efe700860814b5078d60f38b2966934500"}, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0OTMzNjY2OnYy", "diffSide": "RIGHT", "path": "firebase-ml-modeldownloader/src/main/java/com/google/firebase/ml/modeldownloader/FirebaseModelDownloader.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQwMjowMjo1NFrOH9HX-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQxNDo0OTo1OFrOH9ekBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzg0NjAwOQ==", "bodyText": "Log maybe?", "url": "https://github.com/firebase/firebase-android-sdk/pull/2212#discussion_r533846009", "createdAt": "2020-12-02T02:02:54Z", "author": {"login": "rlazo"}, "path": "firebase-ml-modeldownloader/src/main/java/com/google/firebase/ml/modeldownloader/FirebaseModelDownloader.java", "diffHunk": "@@ -95,21 +112,77 @@ public static FirebaseModelDownloader getInstance(@NonNull FirebaseApp app) {\n   public Task<CustomModel> getModel(\n       @NonNull String modelName,\n       @NonNull DownloadType downloadType,\n-      @Nullable CustomModelDownloadConditions conditions) {\n+      @Nullable CustomModelDownloadConditions conditions)\n+      throws Exception {\n+    CustomModel localModel = sharedPreferencesUtil.getCustomModelDetails(modelName);\n+    switch (downloadType) {\n+      case LOCAL_MODEL:\n+        if (localModel != null) {\n+          return Tasks.forResult(localModel);\n+        }\n+        Task<CustomModel> modelDetails =\n+            modelDownloadService.getCustomModelDetails(\n+                firebaseOptions.getProjectId(), modelName, null);\n+\n+        // no local model - start download.\n+        return modelDetails.continueWithTask(\n+            executor,\n+            modelDetailTask -> {\n+              if (modelDetailTask.isSuccessful()) {\n+                // start download\n+                return fileDownloadService\n+                    .download(modelDetailTask.getResult(), conditions)\n+                    .continueWithTask(\n+                        executor,\n+                        downloadTask -> {\n+                          if (downloadTask.isSuccessful()) {\n+                            // read the updated model\n+                            CustomModel downloadedModel =\n+                                sharedPreferencesUtil.getCustomModelDetails(modelName);\n+                            // TODO(annz) trigger file move here as well... right now it's temp\n+                            // call loadNewlyDownloadedModelFile\n+                            return Tasks.forResult(downloadedModel);\n+                          }\n+                          return Tasks.forException(new Exception(\"File download failed.\"));\n+                        });\n+              }\n+              return Tasks.forException(modelDetailTask.getException());\n+            });\n+      case LATEST_MODEL:\n+        // check for latest model and download newest\n+        break;\n+      case LOCAL_MODEL_UPDATE_IN_BACKGROUND:\n+        // start download in back ground return current model if not null.\n+        break;\n+    }\n     throw new UnsupportedOperationException(\"Not yet implemented.\");\n   }\n \n-  /** @return The set of all models that are downloaded to this device. */\n+  /**\n+   * Triggers the move to permanent storage of successful model downloads and list all models\n+   * downloaded to device.\n+   *\n+   * @return The set of all models that are downloaded to this device, triggers completion of file\n+   *     moves for completed model downloads.\n+   */\n   @NonNull\n   public Task<Set<CustomModel>> listDownloadedModels() {\n+    // trigger completion of file moves for download files.\n+    try {\n+      fileDownloadService.maybeCheckDownloadingComplete();\n+    } catch (Exception ex) {\n+      System.out.println(\"Error checking for in progress downloads: \" + ex.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b270c4efe700860814b5078d60f38b2966934500"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDIxMzQ1NQ==", "bodyText": "Yes - changing all these to logs in the next major PR. Just started working on it this morning.", "url": "https://github.com/firebase/firebase-android-sdk/pull/2212#discussion_r534213455", "createdAt": "2020-12-02T14:34:33Z", "author": {"login": "annzimmer"}, "path": "firebase-ml-modeldownloader/src/main/java/com/google/firebase/ml/modeldownloader/FirebaseModelDownloader.java", "diffHunk": "@@ -95,21 +112,77 @@ public static FirebaseModelDownloader getInstance(@NonNull FirebaseApp app) {\n   public Task<CustomModel> getModel(\n       @NonNull String modelName,\n       @NonNull DownloadType downloadType,\n-      @Nullable CustomModelDownloadConditions conditions) {\n+      @Nullable CustomModelDownloadConditions conditions)\n+      throws Exception {\n+    CustomModel localModel = sharedPreferencesUtil.getCustomModelDetails(modelName);\n+    switch (downloadType) {\n+      case LOCAL_MODEL:\n+        if (localModel != null) {\n+          return Tasks.forResult(localModel);\n+        }\n+        Task<CustomModel> modelDetails =\n+            modelDownloadService.getCustomModelDetails(\n+                firebaseOptions.getProjectId(), modelName, null);\n+\n+        // no local model - start download.\n+        return modelDetails.continueWithTask(\n+            executor,\n+            modelDetailTask -> {\n+              if (modelDetailTask.isSuccessful()) {\n+                // start download\n+                return fileDownloadService\n+                    .download(modelDetailTask.getResult(), conditions)\n+                    .continueWithTask(\n+                        executor,\n+                        downloadTask -> {\n+                          if (downloadTask.isSuccessful()) {\n+                            // read the updated model\n+                            CustomModel downloadedModel =\n+                                sharedPreferencesUtil.getCustomModelDetails(modelName);\n+                            // TODO(annz) trigger file move here as well... right now it's temp\n+                            // call loadNewlyDownloadedModelFile\n+                            return Tasks.forResult(downloadedModel);\n+                          }\n+                          return Tasks.forException(new Exception(\"File download failed.\"));\n+                        });\n+              }\n+              return Tasks.forException(modelDetailTask.getException());\n+            });\n+      case LATEST_MODEL:\n+        // check for latest model and download newest\n+        break;\n+      case LOCAL_MODEL_UPDATE_IN_BACKGROUND:\n+        // start download in back ground return current model if not null.\n+        break;\n+    }\n     throw new UnsupportedOperationException(\"Not yet implemented.\");\n   }\n \n-  /** @return The set of all models that are downloaded to this device. */\n+  /**\n+   * Triggers the move to permanent storage of successful model downloads and list all models\n+   * downloaded to device.\n+   *\n+   * @return The set of all models that are downloaded to this device, triggers completion of file\n+   *     moves for completed model downloads.\n+   */\n   @NonNull\n   public Task<Set<CustomModel>> listDownloadedModels() {\n+    // trigger completion of file moves for download files.\n+    try {\n+      fileDownloadService.maybeCheckDownloadingComplete();\n+    } catch (Exception ex) {\n+      System.out.println(\"Error checking for in progress downloads: \" + ex.getMessage());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzg0NjAwOQ=="}, "originalCommit": {"oid": "b270c4efe700860814b5078d60f38b2966934500"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDIyMjY0Ng==", "bodyText": "Happy to change it earlier if you want - was just trying to keep this change as small as possible.", "url": "https://github.com/firebase/firebase-android-sdk/pull/2212#discussion_r534222646", "createdAt": "2020-12-02T14:45:50Z", "author": {"login": "annzimmer"}, "path": "firebase-ml-modeldownloader/src/main/java/com/google/firebase/ml/modeldownloader/FirebaseModelDownloader.java", "diffHunk": "@@ -95,21 +112,77 @@ public static FirebaseModelDownloader getInstance(@NonNull FirebaseApp app) {\n   public Task<CustomModel> getModel(\n       @NonNull String modelName,\n       @NonNull DownloadType downloadType,\n-      @Nullable CustomModelDownloadConditions conditions) {\n+      @Nullable CustomModelDownloadConditions conditions)\n+      throws Exception {\n+    CustomModel localModel = sharedPreferencesUtil.getCustomModelDetails(modelName);\n+    switch (downloadType) {\n+      case LOCAL_MODEL:\n+        if (localModel != null) {\n+          return Tasks.forResult(localModel);\n+        }\n+        Task<CustomModel> modelDetails =\n+            modelDownloadService.getCustomModelDetails(\n+                firebaseOptions.getProjectId(), modelName, null);\n+\n+        // no local model - start download.\n+        return modelDetails.continueWithTask(\n+            executor,\n+            modelDetailTask -> {\n+              if (modelDetailTask.isSuccessful()) {\n+                // start download\n+                return fileDownloadService\n+                    .download(modelDetailTask.getResult(), conditions)\n+                    .continueWithTask(\n+                        executor,\n+                        downloadTask -> {\n+                          if (downloadTask.isSuccessful()) {\n+                            // read the updated model\n+                            CustomModel downloadedModel =\n+                                sharedPreferencesUtil.getCustomModelDetails(modelName);\n+                            // TODO(annz) trigger file move here as well... right now it's temp\n+                            // call loadNewlyDownloadedModelFile\n+                            return Tasks.forResult(downloadedModel);\n+                          }\n+                          return Tasks.forException(new Exception(\"File download failed.\"));\n+                        });\n+              }\n+              return Tasks.forException(modelDetailTask.getException());\n+            });\n+      case LATEST_MODEL:\n+        // check for latest model and download newest\n+        break;\n+      case LOCAL_MODEL_UPDATE_IN_BACKGROUND:\n+        // start download in back ground return current model if not null.\n+        break;\n+    }\n     throw new UnsupportedOperationException(\"Not yet implemented.\");\n   }\n \n-  /** @return The set of all models that are downloaded to this device. */\n+  /**\n+   * Triggers the move to permanent storage of successful model downloads and list all models\n+   * downloaded to device.\n+   *\n+   * @return The set of all models that are downloaded to this device, triggers completion of file\n+   *     moves for completed model downloads.\n+   */\n   @NonNull\n   public Task<Set<CustomModel>> listDownloadedModels() {\n+    // trigger completion of file moves for download files.\n+    try {\n+      fileDownloadService.maybeCheckDownloadingComplete();\n+    } catch (Exception ex) {\n+      System.out.println(\"Error checking for in progress downloads: \" + ex.getMessage());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzg0NjAwOQ=="}, "originalCommit": {"oid": "b270c4efe700860814b5078d60f38b2966934500"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDIyNTkyNg==", "bodyText": "That's OK, you can do it later.", "url": "https://github.com/firebase/firebase-android-sdk/pull/2212#discussion_r534225926", "createdAt": "2020-12-02T14:49:58Z", "author": {"login": "rlazo"}, "path": "firebase-ml-modeldownloader/src/main/java/com/google/firebase/ml/modeldownloader/FirebaseModelDownloader.java", "diffHunk": "@@ -95,21 +112,77 @@ public static FirebaseModelDownloader getInstance(@NonNull FirebaseApp app) {\n   public Task<CustomModel> getModel(\n       @NonNull String modelName,\n       @NonNull DownloadType downloadType,\n-      @Nullable CustomModelDownloadConditions conditions) {\n+      @Nullable CustomModelDownloadConditions conditions)\n+      throws Exception {\n+    CustomModel localModel = sharedPreferencesUtil.getCustomModelDetails(modelName);\n+    switch (downloadType) {\n+      case LOCAL_MODEL:\n+        if (localModel != null) {\n+          return Tasks.forResult(localModel);\n+        }\n+        Task<CustomModel> modelDetails =\n+            modelDownloadService.getCustomModelDetails(\n+                firebaseOptions.getProjectId(), modelName, null);\n+\n+        // no local model - start download.\n+        return modelDetails.continueWithTask(\n+            executor,\n+            modelDetailTask -> {\n+              if (modelDetailTask.isSuccessful()) {\n+                // start download\n+                return fileDownloadService\n+                    .download(modelDetailTask.getResult(), conditions)\n+                    .continueWithTask(\n+                        executor,\n+                        downloadTask -> {\n+                          if (downloadTask.isSuccessful()) {\n+                            // read the updated model\n+                            CustomModel downloadedModel =\n+                                sharedPreferencesUtil.getCustomModelDetails(modelName);\n+                            // TODO(annz) trigger file move here as well... right now it's temp\n+                            // call loadNewlyDownloadedModelFile\n+                            return Tasks.forResult(downloadedModel);\n+                          }\n+                          return Tasks.forException(new Exception(\"File download failed.\"));\n+                        });\n+              }\n+              return Tasks.forException(modelDetailTask.getException());\n+            });\n+      case LATEST_MODEL:\n+        // check for latest model and download newest\n+        break;\n+      case LOCAL_MODEL_UPDATE_IN_BACKGROUND:\n+        // start download in back ground return current model if not null.\n+        break;\n+    }\n     throw new UnsupportedOperationException(\"Not yet implemented.\");\n   }\n \n-  /** @return The set of all models that are downloaded to this device. */\n+  /**\n+   * Triggers the move to permanent storage of successful model downloads and list all models\n+   * downloaded to device.\n+   *\n+   * @return The set of all models that are downloaded to this device, triggers completion of file\n+   *     moves for completed model downloads.\n+   */\n   @NonNull\n   public Task<Set<CustomModel>> listDownloadedModels() {\n+    // trigger completion of file moves for download files.\n+    try {\n+      fileDownloadService.maybeCheckDownloadingComplete();\n+    } catch (Exception ex) {\n+      System.out.println(\"Error checking for in progress downloads: \" + ex.getMessage());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzg0NjAwOQ=="}, "originalCommit": {"oid": "b270c4efe700860814b5078d60f38b2966934500"}, "originalPosition": 119}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0OTM0NTY0OnYy", "diffSide": "RIGHT", "path": "firebase-ml-modeldownloader/src/main/java/com/google/firebase/ml/modeldownloader/internal/ModelFileDownloadService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQwMjowNzoxNlrOH9HdKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQxNDozNDoyOFrOH9dzDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzg0NzMzOQ==", "bodyText": "Log maybe?", "url": "https://github.com/firebase/firebase-android-sdk/pull/2212#discussion_r533847339", "createdAt": "2020-12-02T02:07:16Z", "author": {"login": "rlazo"}, "path": "firebase-ml-modeldownloader/src/main/java/com/google/firebase/ml/modeldownloader/internal/ModelFileDownloadService.java", "diffHunk": "@@ -0,0 +1,371 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.ml.modeldownloader.internal;\n+\n+import android.app.DownloadManager;\n+import android.app.DownloadManager.Query;\n+import android.app.DownloadManager.Request;\n+import android.content.BroadcastReceiver;\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.IntentFilter;\n+import android.database.Cursor;\n+import android.net.Uri;\n+import android.os.Build.VERSION;\n+import android.os.Build.VERSION_CODES;\n+import android.os.ParcelFileDescriptor;\n+import android.util.LongSparseArray;\n+import androidx.annotation.GuardedBy;\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+import androidx.annotation.VisibleForTesting;\n+import androidx.annotation.WorkerThread;\n+import com.google.android.gms.tasks.Task;\n+import com.google.android.gms.tasks.TaskCompletionSource;\n+import com.google.android.gms.tasks.Tasks;\n+import com.google.firebase.FirebaseApp;\n+import com.google.firebase.ml.modeldownloader.CustomModel;\n+import com.google.firebase.ml.modeldownloader.CustomModelDownloadConditions;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Calls the Android Download service to copy the model file to device (temp location) and then\n+ * moves file to it's permanent location, updating the model details in shared preferences\n+ * throughout.\n+ *\n+ * @hide\n+ */\n+public class ModelFileDownloadService {\n+\n+  private final DownloadManager downloadManager;\n+  private final Context context;\n+  private final ModelFileManager fileManager;\n+  private final SharedPreferencesUtil sharedPreferencesUtil;\n+\n+  @GuardedBy(\"this\")\n+  // Mapping from download id to broadcast receiver. Because models can update, we cannot just keep\n+  // one instance of DownloadBroadcastReceiver per RemoteModelDownloadManager object.\n+  private final LongSparseArray<DownloadBroadcastReceiver> receiverMaps = new LongSparseArray<>();\n+\n+  @GuardedBy(\"this\")\n+  // Mapping from download id to TaskCompletionSource. Because models can update, we cannot just\n+  // keep one instance of TaskCompletionSource per RemoteModelDownloadManager object.\n+  private final LongSparseArray<TaskCompletionSource<Void>> taskCompletionSourceMaps =\n+      new LongSparseArray<>();\n+\n+  private CustomModelDownloadConditions downloadConditions =\n+      new CustomModelDownloadConditions.Builder().build();\n+\n+  public ModelFileDownloadService(@NonNull FirebaseApp firebaseApp) {\n+    this.context = firebaseApp.getApplicationContext();\n+    downloadManager = (DownloadManager) context.getSystemService(Context.DOWNLOAD_SERVICE);\n+    this.fileManager = ModelFileManager.getInstance();\n+    this.sharedPreferencesUtil = new SharedPreferencesUtil(firebaseApp);\n+  }\n+\n+  @VisibleForTesting\n+  ModelFileDownloadService(\n+      @NonNull FirebaseApp firebaseApp,\n+      DownloadManager downloadManager,\n+      ModelFileManager fileManager,\n+      SharedPreferencesUtil sharedPreferencesUtil) {\n+    this.context = firebaseApp.getApplicationContext();\n+    this.downloadManager = downloadManager;\n+    this.fileManager = fileManager;\n+    this.sharedPreferencesUtil = sharedPreferencesUtil;\n+  }\n+\n+  /**\n+   * Get ModelFileDownloadService instance using the firebase app returned by {@link\n+   * FirebaseApp#getInstance()}\n+   *\n+   * @return ModelFileDownloadService\n+   */\n+  @NonNull\n+  public static ModelFileDownloadService getInstance() {\n+    return FirebaseApp.getInstance().get(ModelFileDownloadService.class);\n+  }\n+\n+  public Task<Void> download(\n+      CustomModel customModel, CustomModelDownloadConditions downloadConditions) {\n+    this.downloadConditions = downloadConditions;\n+    // todo add url tests here\n+    return ensureModelDownloaded(customModel);\n+  }\n+\n+  @VisibleForTesting\n+  Task<Void> ensureModelDownloaded(CustomModel customModel) {\n+    // todo check model not already in progress of being downloaded\n+\n+    // todo remove any failed download attempts\n+\n+    // schedule new download of model file\n+    Long newDownloadId = scheduleModelDownload(customModel);\n+    if (newDownloadId == null) {\n+      return Tasks.forException(new Exception(\"Failed to schedule the download task\"));\n+    }\n+\n+    return registerReceiverForDownloadId(newDownloadId);\n+  }\n+\n+  private synchronized DownloadBroadcastReceiver getReceiverInstance(long downloadId) {\n+    DownloadBroadcastReceiver receiver = receiverMaps.get(downloadId);\n+    if (receiver == null) {\n+      receiver =\n+          new DownloadBroadcastReceiver(downloadId, getTaskCompletionSourceInstance(downloadId));\n+      receiverMaps.put(downloadId, receiver);\n+    }\n+    return receiver;\n+  }\n+\n+  private Task<Void> registerReceiverForDownloadId(long downloadId) {\n+    BroadcastReceiver broadcastReceiver = getReceiverInstance(downloadId);\n+    // It is okay to always register here. Since the broadcast receiver is the same via the lookup\n+    // for the same download id, the same broadcast receiver will be notified only once.\n+    context.registerReceiver(\n+        broadcastReceiver, new IntentFilter(DownloadManager.ACTION_DOWNLOAD_COMPLETE));\n+\n+    return getTaskCompletionSourceInstance(downloadId).getTask();\n+  }\n+\n+  @VisibleForTesting\n+  synchronized TaskCompletionSource<Void> getTaskCompletionSourceInstance(long downloadId) {\n+    TaskCompletionSource<Void> taskCompletionSource = taskCompletionSourceMaps.get(downloadId);\n+    if (taskCompletionSource == null) {\n+      taskCompletionSource = new TaskCompletionSource<>();\n+      taskCompletionSourceMaps.put(downloadId, taskCompletionSource);\n+    }\n+\n+    return taskCompletionSource;\n+  }\n+\n+  @VisibleForTesting\n+  synchronized Long scheduleModelDownload(@NonNull CustomModel customModel) {\n+    if (downloadManager == null) {\n+      return null;\n+    }\n+\n+    if (customModel.getDownloadUrl() == null || customModel.getDownloadUrl().isEmpty()) {\n+      return null;\n+    }\n+    // todo handle expired url here and figure out what to do about delayed downloads too..\n+\n+    // Schedule a new downloading\n+    Request downloadRequest = new Request(Uri.parse(customModel.getDownloadUrl()));\n+    // check Url is not expired - get new one if necessary...\n+\n+    // By setting the destination uri to null, the downloaded file will be stored in\n+    // DownloadManager's purgeable cache. As a result, WRITE_EXTERNAL_STORAGE permission is not\n+    // needed.\n+    downloadRequest.setDestinationUri(null);\n+    if (VERSION.SDK_INT >= VERSION_CODES.N) {\n+      downloadRequest.setRequiresCharging(downloadConditions.isChargingRequired());\n+      downloadRequest.setRequiresDeviceIdle(downloadConditions.isDeviceIdleRequired());\n+    }\n+\n+    if (downloadConditions.isWifiRequired()) {\n+      downloadRequest.setAllowedNetworkTypes(Request.NETWORK_WIFI);\n+    }\n+\n+    long id = downloadManager.enqueue(downloadRequest);\n+    // update the custom model to store the download id - do not lose current local file - in case\n+    // this is a background update.\n+    sharedPreferencesUtil.setDownloadingCustomModelDetails(\n+        new CustomModel(\n+            customModel.getName(),\n+            customModel.getModelHash(),\n+            customModel.getSize(),\n+            id,\n+            customModel.getLocalFilePath()));\n+    return id;\n+  }\n+\n+  @Nullable\n+  @VisibleForTesting\n+  synchronized Integer getDownloadingModelStatusCode(Long downloadingId) {\n+    if (downloadManager == null || downloadingId == null) {\n+      return null;\n+    }\n+\n+    Integer statusCode = null;\n+\n+    try (Cursor cursor = downloadManager.query(new Query().setFilterById(downloadingId))) {\n+\n+      if (cursor != null && cursor.moveToFirst()) {\n+        statusCode = cursor.getInt(cursor.getColumnIndex(DownloadManager.COLUMN_STATUS));\n+      }\n+\n+      if (statusCode == null) {\n+        return null;\n+      }\n+\n+      if (statusCode != DownloadManager.STATUS_RUNNING\n+          && statusCode != DownloadManager.STATUS_PAUSED\n+          && statusCode != DownloadManager.STATUS_PENDING\n+          && statusCode != DownloadManager.STATUS_SUCCESSFUL\n+          && statusCode != DownloadManager.STATUS_FAILED) {\n+        // Unknown status\n+        statusCode = null;\n+      }\n+      return statusCode;\n+    }\n+  }\n+\n+  @Nullable\n+  private synchronized ParcelFileDescriptor getDownloadedFile(Long downloadingId) {\n+    if (downloadManager == null || downloadingId == null) {\n+      return null;\n+    }\n+\n+    ParcelFileDescriptor fileDescriptor = null;\n+    try {\n+      fileDescriptor = downloadManager.openDownloadedFile(downloadingId);\n+    } catch (FileNotFoundException e) {\n+      System.out.println(\"Downloaded file is not found\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b270c4efe700860814b5078d60f38b2966934500"}, "originalPosition": 239}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDIxMzM5MA==", "bodyText": "Yes - changing all these to logs in the next major PR. Just started working on it this morning.", "url": "https://github.com/firebase/firebase-android-sdk/pull/2212#discussion_r534213390", "createdAt": "2020-12-02T14:34:28Z", "author": {"login": "annzimmer"}, "path": "firebase-ml-modeldownloader/src/main/java/com/google/firebase/ml/modeldownloader/internal/ModelFileDownloadService.java", "diffHunk": "@@ -0,0 +1,371 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.ml.modeldownloader.internal;\n+\n+import android.app.DownloadManager;\n+import android.app.DownloadManager.Query;\n+import android.app.DownloadManager.Request;\n+import android.content.BroadcastReceiver;\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.IntentFilter;\n+import android.database.Cursor;\n+import android.net.Uri;\n+import android.os.Build.VERSION;\n+import android.os.Build.VERSION_CODES;\n+import android.os.ParcelFileDescriptor;\n+import android.util.LongSparseArray;\n+import androidx.annotation.GuardedBy;\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+import androidx.annotation.VisibleForTesting;\n+import androidx.annotation.WorkerThread;\n+import com.google.android.gms.tasks.Task;\n+import com.google.android.gms.tasks.TaskCompletionSource;\n+import com.google.android.gms.tasks.Tasks;\n+import com.google.firebase.FirebaseApp;\n+import com.google.firebase.ml.modeldownloader.CustomModel;\n+import com.google.firebase.ml.modeldownloader.CustomModelDownloadConditions;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Calls the Android Download service to copy the model file to device (temp location) and then\n+ * moves file to it's permanent location, updating the model details in shared preferences\n+ * throughout.\n+ *\n+ * @hide\n+ */\n+public class ModelFileDownloadService {\n+\n+  private final DownloadManager downloadManager;\n+  private final Context context;\n+  private final ModelFileManager fileManager;\n+  private final SharedPreferencesUtil sharedPreferencesUtil;\n+\n+  @GuardedBy(\"this\")\n+  // Mapping from download id to broadcast receiver. Because models can update, we cannot just keep\n+  // one instance of DownloadBroadcastReceiver per RemoteModelDownloadManager object.\n+  private final LongSparseArray<DownloadBroadcastReceiver> receiverMaps = new LongSparseArray<>();\n+\n+  @GuardedBy(\"this\")\n+  // Mapping from download id to TaskCompletionSource. Because models can update, we cannot just\n+  // keep one instance of TaskCompletionSource per RemoteModelDownloadManager object.\n+  private final LongSparseArray<TaskCompletionSource<Void>> taskCompletionSourceMaps =\n+      new LongSparseArray<>();\n+\n+  private CustomModelDownloadConditions downloadConditions =\n+      new CustomModelDownloadConditions.Builder().build();\n+\n+  public ModelFileDownloadService(@NonNull FirebaseApp firebaseApp) {\n+    this.context = firebaseApp.getApplicationContext();\n+    downloadManager = (DownloadManager) context.getSystemService(Context.DOWNLOAD_SERVICE);\n+    this.fileManager = ModelFileManager.getInstance();\n+    this.sharedPreferencesUtil = new SharedPreferencesUtil(firebaseApp);\n+  }\n+\n+  @VisibleForTesting\n+  ModelFileDownloadService(\n+      @NonNull FirebaseApp firebaseApp,\n+      DownloadManager downloadManager,\n+      ModelFileManager fileManager,\n+      SharedPreferencesUtil sharedPreferencesUtil) {\n+    this.context = firebaseApp.getApplicationContext();\n+    this.downloadManager = downloadManager;\n+    this.fileManager = fileManager;\n+    this.sharedPreferencesUtil = sharedPreferencesUtil;\n+  }\n+\n+  /**\n+   * Get ModelFileDownloadService instance using the firebase app returned by {@link\n+   * FirebaseApp#getInstance()}\n+   *\n+   * @return ModelFileDownloadService\n+   */\n+  @NonNull\n+  public static ModelFileDownloadService getInstance() {\n+    return FirebaseApp.getInstance().get(ModelFileDownloadService.class);\n+  }\n+\n+  public Task<Void> download(\n+      CustomModel customModel, CustomModelDownloadConditions downloadConditions) {\n+    this.downloadConditions = downloadConditions;\n+    // todo add url tests here\n+    return ensureModelDownloaded(customModel);\n+  }\n+\n+  @VisibleForTesting\n+  Task<Void> ensureModelDownloaded(CustomModel customModel) {\n+    // todo check model not already in progress of being downloaded\n+\n+    // todo remove any failed download attempts\n+\n+    // schedule new download of model file\n+    Long newDownloadId = scheduleModelDownload(customModel);\n+    if (newDownloadId == null) {\n+      return Tasks.forException(new Exception(\"Failed to schedule the download task\"));\n+    }\n+\n+    return registerReceiverForDownloadId(newDownloadId);\n+  }\n+\n+  private synchronized DownloadBroadcastReceiver getReceiverInstance(long downloadId) {\n+    DownloadBroadcastReceiver receiver = receiverMaps.get(downloadId);\n+    if (receiver == null) {\n+      receiver =\n+          new DownloadBroadcastReceiver(downloadId, getTaskCompletionSourceInstance(downloadId));\n+      receiverMaps.put(downloadId, receiver);\n+    }\n+    return receiver;\n+  }\n+\n+  private Task<Void> registerReceiverForDownloadId(long downloadId) {\n+    BroadcastReceiver broadcastReceiver = getReceiverInstance(downloadId);\n+    // It is okay to always register here. Since the broadcast receiver is the same via the lookup\n+    // for the same download id, the same broadcast receiver will be notified only once.\n+    context.registerReceiver(\n+        broadcastReceiver, new IntentFilter(DownloadManager.ACTION_DOWNLOAD_COMPLETE));\n+\n+    return getTaskCompletionSourceInstance(downloadId).getTask();\n+  }\n+\n+  @VisibleForTesting\n+  synchronized TaskCompletionSource<Void> getTaskCompletionSourceInstance(long downloadId) {\n+    TaskCompletionSource<Void> taskCompletionSource = taskCompletionSourceMaps.get(downloadId);\n+    if (taskCompletionSource == null) {\n+      taskCompletionSource = new TaskCompletionSource<>();\n+      taskCompletionSourceMaps.put(downloadId, taskCompletionSource);\n+    }\n+\n+    return taskCompletionSource;\n+  }\n+\n+  @VisibleForTesting\n+  synchronized Long scheduleModelDownload(@NonNull CustomModel customModel) {\n+    if (downloadManager == null) {\n+      return null;\n+    }\n+\n+    if (customModel.getDownloadUrl() == null || customModel.getDownloadUrl().isEmpty()) {\n+      return null;\n+    }\n+    // todo handle expired url here and figure out what to do about delayed downloads too..\n+\n+    // Schedule a new downloading\n+    Request downloadRequest = new Request(Uri.parse(customModel.getDownloadUrl()));\n+    // check Url is not expired - get new one if necessary...\n+\n+    // By setting the destination uri to null, the downloaded file will be stored in\n+    // DownloadManager's purgeable cache. As a result, WRITE_EXTERNAL_STORAGE permission is not\n+    // needed.\n+    downloadRequest.setDestinationUri(null);\n+    if (VERSION.SDK_INT >= VERSION_CODES.N) {\n+      downloadRequest.setRequiresCharging(downloadConditions.isChargingRequired());\n+      downloadRequest.setRequiresDeviceIdle(downloadConditions.isDeviceIdleRequired());\n+    }\n+\n+    if (downloadConditions.isWifiRequired()) {\n+      downloadRequest.setAllowedNetworkTypes(Request.NETWORK_WIFI);\n+    }\n+\n+    long id = downloadManager.enqueue(downloadRequest);\n+    // update the custom model to store the download id - do not lose current local file - in case\n+    // this is a background update.\n+    sharedPreferencesUtil.setDownloadingCustomModelDetails(\n+        new CustomModel(\n+            customModel.getName(),\n+            customModel.getModelHash(),\n+            customModel.getSize(),\n+            id,\n+            customModel.getLocalFilePath()));\n+    return id;\n+  }\n+\n+  @Nullable\n+  @VisibleForTesting\n+  synchronized Integer getDownloadingModelStatusCode(Long downloadingId) {\n+    if (downloadManager == null || downloadingId == null) {\n+      return null;\n+    }\n+\n+    Integer statusCode = null;\n+\n+    try (Cursor cursor = downloadManager.query(new Query().setFilterById(downloadingId))) {\n+\n+      if (cursor != null && cursor.moveToFirst()) {\n+        statusCode = cursor.getInt(cursor.getColumnIndex(DownloadManager.COLUMN_STATUS));\n+      }\n+\n+      if (statusCode == null) {\n+        return null;\n+      }\n+\n+      if (statusCode != DownloadManager.STATUS_RUNNING\n+          && statusCode != DownloadManager.STATUS_PAUSED\n+          && statusCode != DownloadManager.STATUS_PENDING\n+          && statusCode != DownloadManager.STATUS_SUCCESSFUL\n+          && statusCode != DownloadManager.STATUS_FAILED) {\n+        // Unknown status\n+        statusCode = null;\n+      }\n+      return statusCode;\n+    }\n+  }\n+\n+  @Nullable\n+  private synchronized ParcelFileDescriptor getDownloadedFile(Long downloadingId) {\n+    if (downloadManager == null || downloadingId == null) {\n+      return null;\n+    }\n+\n+    ParcelFileDescriptor fileDescriptor = null;\n+    try {\n+      fileDescriptor = downloadManager.openDownloadedFile(downloadingId);\n+    } catch (FileNotFoundException e) {\n+      System.out.println(\"Downloaded file is not found\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzg0NzMzOQ=="}, "originalCommit": {"oid": "b270c4efe700860814b5078d60f38b2966934500"}, "originalPosition": 239}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0OTM1MzMyOnYy", "diffSide": "RIGHT", "path": "firebase-ml-modeldownloader/src/main/java/com/google/firebase/ml/modeldownloader/internal/ModelFileDownloadService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQwMjoxMDoyNVrOH9HhTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQxNDozNDoyNVrOH9dy4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzg0ODM5OQ==", "bodyText": "same", "url": "https://github.com/firebase/firebase-android-sdk/pull/2212#discussion_r533848399", "createdAt": "2020-12-02T02:10:25Z", "author": {"login": "rlazo"}, "path": "firebase-ml-modeldownloader/src/main/java/com/google/firebase/ml/modeldownloader/internal/ModelFileDownloadService.java", "diffHunk": "@@ -0,0 +1,371 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.ml.modeldownloader.internal;\n+\n+import android.app.DownloadManager;\n+import android.app.DownloadManager.Query;\n+import android.app.DownloadManager.Request;\n+import android.content.BroadcastReceiver;\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.IntentFilter;\n+import android.database.Cursor;\n+import android.net.Uri;\n+import android.os.Build.VERSION;\n+import android.os.Build.VERSION_CODES;\n+import android.os.ParcelFileDescriptor;\n+import android.util.LongSparseArray;\n+import androidx.annotation.GuardedBy;\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+import androidx.annotation.VisibleForTesting;\n+import androidx.annotation.WorkerThread;\n+import com.google.android.gms.tasks.Task;\n+import com.google.android.gms.tasks.TaskCompletionSource;\n+import com.google.android.gms.tasks.Tasks;\n+import com.google.firebase.FirebaseApp;\n+import com.google.firebase.ml.modeldownloader.CustomModel;\n+import com.google.firebase.ml.modeldownloader.CustomModelDownloadConditions;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Calls the Android Download service to copy the model file to device (temp location) and then\n+ * moves file to it's permanent location, updating the model details in shared preferences\n+ * throughout.\n+ *\n+ * @hide\n+ */\n+public class ModelFileDownloadService {\n+\n+  private final DownloadManager downloadManager;\n+  private final Context context;\n+  private final ModelFileManager fileManager;\n+  private final SharedPreferencesUtil sharedPreferencesUtil;\n+\n+  @GuardedBy(\"this\")\n+  // Mapping from download id to broadcast receiver. Because models can update, we cannot just keep\n+  // one instance of DownloadBroadcastReceiver per RemoteModelDownloadManager object.\n+  private final LongSparseArray<DownloadBroadcastReceiver> receiverMaps = new LongSparseArray<>();\n+\n+  @GuardedBy(\"this\")\n+  // Mapping from download id to TaskCompletionSource. Because models can update, we cannot just\n+  // keep one instance of TaskCompletionSource per RemoteModelDownloadManager object.\n+  private final LongSparseArray<TaskCompletionSource<Void>> taskCompletionSourceMaps =\n+      new LongSparseArray<>();\n+\n+  private CustomModelDownloadConditions downloadConditions =\n+      new CustomModelDownloadConditions.Builder().build();\n+\n+  public ModelFileDownloadService(@NonNull FirebaseApp firebaseApp) {\n+    this.context = firebaseApp.getApplicationContext();\n+    downloadManager = (DownloadManager) context.getSystemService(Context.DOWNLOAD_SERVICE);\n+    this.fileManager = ModelFileManager.getInstance();\n+    this.sharedPreferencesUtil = new SharedPreferencesUtil(firebaseApp);\n+  }\n+\n+  @VisibleForTesting\n+  ModelFileDownloadService(\n+      @NonNull FirebaseApp firebaseApp,\n+      DownloadManager downloadManager,\n+      ModelFileManager fileManager,\n+      SharedPreferencesUtil sharedPreferencesUtil) {\n+    this.context = firebaseApp.getApplicationContext();\n+    this.downloadManager = downloadManager;\n+    this.fileManager = fileManager;\n+    this.sharedPreferencesUtil = sharedPreferencesUtil;\n+  }\n+\n+  /**\n+   * Get ModelFileDownloadService instance using the firebase app returned by {@link\n+   * FirebaseApp#getInstance()}\n+   *\n+   * @return ModelFileDownloadService\n+   */\n+  @NonNull\n+  public static ModelFileDownloadService getInstance() {\n+    return FirebaseApp.getInstance().get(ModelFileDownloadService.class);\n+  }\n+\n+  public Task<Void> download(\n+      CustomModel customModel, CustomModelDownloadConditions downloadConditions) {\n+    this.downloadConditions = downloadConditions;\n+    // todo add url tests here\n+    return ensureModelDownloaded(customModel);\n+  }\n+\n+  @VisibleForTesting\n+  Task<Void> ensureModelDownloaded(CustomModel customModel) {\n+    // todo check model not already in progress of being downloaded\n+\n+    // todo remove any failed download attempts\n+\n+    // schedule new download of model file\n+    Long newDownloadId = scheduleModelDownload(customModel);\n+    if (newDownloadId == null) {\n+      return Tasks.forException(new Exception(\"Failed to schedule the download task\"));\n+    }\n+\n+    return registerReceiverForDownloadId(newDownloadId);\n+  }\n+\n+  private synchronized DownloadBroadcastReceiver getReceiverInstance(long downloadId) {\n+    DownloadBroadcastReceiver receiver = receiverMaps.get(downloadId);\n+    if (receiver == null) {\n+      receiver =\n+          new DownloadBroadcastReceiver(downloadId, getTaskCompletionSourceInstance(downloadId));\n+      receiverMaps.put(downloadId, receiver);\n+    }\n+    return receiver;\n+  }\n+\n+  private Task<Void> registerReceiverForDownloadId(long downloadId) {\n+    BroadcastReceiver broadcastReceiver = getReceiverInstance(downloadId);\n+    // It is okay to always register here. Since the broadcast receiver is the same via the lookup\n+    // for the same download id, the same broadcast receiver will be notified only once.\n+    context.registerReceiver(\n+        broadcastReceiver, new IntentFilter(DownloadManager.ACTION_DOWNLOAD_COMPLETE));\n+\n+    return getTaskCompletionSourceInstance(downloadId).getTask();\n+  }\n+\n+  @VisibleForTesting\n+  synchronized TaskCompletionSource<Void> getTaskCompletionSourceInstance(long downloadId) {\n+    TaskCompletionSource<Void> taskCompletionSource = taskCompletionSourceMaps.get(downloadId);\n+    if (taskCompletionSource == null) {\n+      taskCompletionSource = new TaskCompletionSource<>();\n+      taskCompletionSourceMaps.put(downloadId, taskCompletionSource);\n+    }\n+\n+    return taskCompletionSource;\n+  }\n+\n+  @VisibleForTesting\n+  synchronized Long scheduleModelDownload(@NonNull CustomModel customModel) {\n+    if (downloadManager == null) {\n+      return null;\n+    }\n+\n+    if (customModel.getDownloadUrl() == null || customModel.getDownloadUrl().isEmpty()) {\n+      return null;\n+    }\n+    // todo handle expired url here and figure out what to do about delayed downloads too..\n+\n+    // Schedule a new downloading\n+    Request downloadRequest = new Request(Uri.parse(customModel.getDownloadUrl()));\n+    // check Url is not expired - get new one if necessary...\n+\n+    // By setting the destination uri to null, the downloaded file will be stored in\n+    // DownloadManager's purgeable cache. As a result, WRITE_EXTERNAL_STORAGE permission is not\n+    // needed.\n+    downloadRequest.setDestinationUri(null);\n+    if (VERSION.SDK_INT >= VERSION_CODES.N) {\n+      downloadRequest.setRequiresCharging(downloadConditions.isChargingRequired());\n+      downloadRequest.setRequiresDeviceIdle(downloadConditions.isDeviceIdleRequired());\n+    }\n+\n+    if (downloadConditions.isWifiRequired()) {\n+      downloadRequest.setAllowedNetworkTypes(Request.NETWORK_WIFI);\n+    }\n+\n+    long id = downloadManager.enqueue(downloadRequest);\n+    // update the custom model to store the download id - do not lose current local file - in case\n+    // this is a background update.\n+    sharedPreferencesUtil.setDownloadingCustomModelDetails(\n+        new CustomModel(\n+            customModel.getName(),\n+            customModel.getModelHash(),\n+            customModel.getSize(),\n+            id,\n+            customModel.getLocalFilePath()));\n+    return id;\n+  }\n+\n+  @Nullable\n+  @VisibleForTesting\n+  synchronized Integer getDownloadingModelStatusCode(Long downloadingId) {\n+    if (downloadManager == null || downloadingId == null) {\n+      return null;\n+    }\n+\n+    Integer statusCode = null;\n+\n+    try (Cursor cursor = downloadManager.query(new Query().setFilterById(downloadingId))) {\n+\n+      if (cursor != null && cursor.moveToFirst()) {\n+        statusCode = cursor.getInt(cursor.getColumnIndex(DownloadManager.COLUMN_STATUS));\n+      }\n+\n+      if (statusCode == null) {\n+        return null;\n+      }\n+\n+      if (statusCode != DownloadManager.STATUS_RUNNING\n+          && statusCode != DownloadManager.STATUS_PAUSED\n+          && statusCode != DownloadManager.STATUS_PENDING\n+          && statusCode != DownloadManager.STATUS_SUCCESSFUL\n+          && statusCode != DownloadManager.STATUS_FAILED) {\n+        // Unknown status\n+        statusCode = null;\n+      }\n+      return statusCode;\n+    }\n+  }\n+\n+  @Nullable\n+  private synchronized ParcelFileDescriptor getDownloadedFile(Long downloadingId) {\n+    if (downloadManager == null || downloadingId == null) {\n+      return null;\n+    }\n+\n+    ParcelFileDescriptor fileDescriptor = null;\n+    try {\n+      fileDescriptor = downloadManager.openDownloadedFile(downloadingId);\n+    } catch (FileNotFoundException e) {\n+      System.out.println(\"Downloaded file is not found\");\n+    }\n+    return fileDescriptor;\n+  }\n+\n+  public void maybeCheckDownloadingComplete() throws Exception {\n+    for (String key : sharedPreferencesUtil.getSharedPreferenceKeySet()) {\n+      // if a local file path is present - get model details.\n+      Matcher matcher =\n+          Pattern.compile(SharedPreferencesUtil.DOWNLOADING_MODEL_ID_MATCHER).matcher(key);\n+      if (matcher.find()) {\n+        String modelName = matcher.group(matcher.groupCount());\n+        CustomModel downloadingModel = sharedPreferencesUtil.getCustomModelDetails(modelName);\n+        Integer statusCode = getDownloadingModelStatusCode(downloadingModel.getDownloadId());\n+        if (statusCode == DownloadManager.STATUS_SUCCESSFUL\n+            || statusCode == DownloadManager.STATUS_FAILED) {\n+          loadNewlyDownloadedModelFile(downloadingModel);\n+        }\n+      }\n+    }\n+  }\n+\n+  @Nullable\n+  @WorkerThread\n+  public File loadNewlyDownloadedModelFile(CustomModel model) throws Exception {\n+    Long downloadingId = model.getDownloadId();\n+    String downloadingModelHash = model.getModelHash();\n+\n+    if (downloadingId == null || downloadingModelHash == null) {\n+      // no downloading model file or incomplete info.\n+      return null;\n+    }\n+\n+    Integer statusCode = getDownloadingModelStatusCode(downloadingId);\n+    if (statusCode == null) {\n+      return null;\n+    }\n+\n+    if (statusCode == DownloadManager.STATUS_SUCCESSFUL) {\n+      // Get downloaded file.\n+      ParcelFileDescriptor fileDescriptor = getDownloadedFile(downloadingId);\n+      if (fileDescriptor == null) {\n+        // reset original model - removing download id.\n+        sharedPreferencesUtil.setFailedUploadedCustomModelDetails(model.getName());\n+        // todo call the download register?\n+        return null;\n+      }\n+\n+      // Try to move it to destination folder.\n+      File newModelFile = fileManager.moveModelToDestinationFolder(model, fileDescriptor);\n+\n+      if (newModelFile == null) {\n+        // reset original model - removing download id.\n+        // todo call the download register?\n+        sharedPreferencesUtil.setFailedUploadedCustomModelDetails(model.getName());\n+        return null;\n+      }\n+\n+      // Successfully moved,  update share preferences\n+      sharedPreferencesUtil.setUploadedCustomModelDetails(\n+          new CustomModel(\n+              model.getName(), model.getModelHash(), model.getSize(), 0, newModelFile.getPath()));\n+\n+      // Cleans up the old files if it is the initial creation.\n+      return newModelFile;\n+    } else if (statusCode == DownloadManager.STATUS_FAILED) {\n+      // reset original model - removing download id.\n+      sharedPreferencesUtil.setFailedUploadedCustomModelDetails(model.getName());\n+      // todo - determine if the temp files need to be clean up? Does one exist?\n+    }\n+    // Other cases, return as null and wait for download finish.\n+    return null;\n+  }\n+\n+  // This class runs totally on worker thread because we registered the receiver with a worker\n+  // thread handler.\n+  @WorkerThread\n+  private class DownloadBroadcastReceiver extends BroadcastReceiver {\n+\n+    // Download Id is captured inside this class in memory. So there is no concern of inconsistency\n+    // with the persisted download id in shared preferences.\n+    private final long downloadId;\n+    private final TaskCompletionSource<Void> taskCompletionSource;\n+\n+    private DownloadBroadcastReceiver(\n+        long downloadId, TaskCompletionSource<Void> taskCompletionSource) {\n+      this.downloadId = downloadId;\n+      this.taskCompletionSource = taskCompletionSource;\n+    }\n+\n+    @Override\n+    public void onReceive(Context context, Intent intent) {\n+      long id = intent.getLongExtra(DownloadManager.EXTRA_DOWNLOAD_ID, -1);\n+      if (id != downloadId) {\n+        return;\n+      }\n+\n+      Integer statusCode = getDownloadingModelStatusCode(downloadId);\n+      synchronized (ModelFileDownloadService.this) {\n+        try {\n+          context.getApplicationContext().unregisterReceiver(this);\n+        } catch (IllegalArgumentException e) {\n+          // If we try to unregister a receiver that was never registered or has been unregistered,\n+          // IllegalArgumentException will be thrown by the Android Framework.\n+          // Our current code does not have this problem. However, in order to be safer in the\n+          // future, we just ignore the exception here, because it is not a big deal. The code can\n+          // move on.\n+        }\n+\n+        receiverMaps.remove(downloadId);\n+        taskCompletionSourceMaps.remove(downloadId);\n+      }\n+\n+      if (statusCode != null) {\n+        if (statusCode == DownloadManager.STATUS_FAILED) {\n+          // todo add failure reason and logging\n+          System.out.println(\"Download Failed for id: \" + id);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b270c4efe700860814b5078d60f38b2966934500"}, "originalPosition": 355}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDIxMzM0NA==", "bodyText": "same", "url": "https://github.com/firebase/firebase-android-sdk/pull/2212#discussion_r534213344", "createdAt": "2020-12-02T14:34:25Z", "author": {"login": "annzimmer"}, "path": "firebase-ml-modeldownloader/src/main/java/com/google/firebase/ml/modeldownloader/internal/ModelFileDownloadService.java", "diffHunk": "@@ -0,0 +1,371 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.ml.modeldownloader.internal;\n+\n+import android.app.DownloadManager;\n+import android.app.DownloadManager.Query;\n+import android.app.DownloadManager.Request;\n+import android.content.BroadcastReceiver;\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.IntentFilter;\n+import android.database.Cursor;\n+import android.net.Uri;\n+import android.os.Build.VERSION;\n+import android.os.Build.VERSION_CODES;\n+import android.os.ParcelFileDescriptor;\n+import android.util.LongSparseArray;\n+import androidx.annotation.GuardedBy;\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+import androidx.annotation.VisibleForTesting;\n+import androidx.annotation.WorkerThread;\n+import com.google.android.gms.tasks.Task;\n+import com.google.android.gms.tasks.TaskCompletionSource;\n+import com.google.android.gms.tasks.Tasks;\n+import com.google.firebase.FirebaseApp;\n+import com.google.firebase.ml.modeldownloader.CustomModel;\n+import com.google.firebase.ml.modeldownloader.CustomModelDownloadConditions;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Calls the Android Download service to copy the model file to device (temp location) and then\n+ * moves file to it's permanent location, updating the model details in shared preferences\n+ * throughout.\n+ *\n+ * @hide\n+ */\n+public class ModelFileDownloadService {\n+\n+  private final DownloadManager downloadManager;\n+  private final Context context;\n+  private final ModelFileManager fileManager;\n+  private final SharedPreferencesUtil sharedPreferencesUtil;\n+\n+  @GuardedBy(\"this\")\n+  // Mapping from download id to broadcast receiver. Because models can update, we cannot just keep\n+  // one instance of DownloadBroadcastReceiver per RemoteModelDownloadManager object.\n+  private final LongSparseArray<DownloadBroadcastReceiver> receiverMaps = new LongSparseArray<>();\n+\n+  @GuardedBy(\"this\")\n+  // Mapping from download id to TaskCompletionSource. Because models can update, we cannot just\n+  // keep one instance of TaskCompletionSource per RemoteModelDownloadManager object.\n+  private final LongSparseArray<TaskCompletionSource<Void>> taskCompletionSourceMaps =\n+      new LongSparseArray<>();\n+\n+  private CustomModelDownloadConditions downloadConditions =\n+      new CustomModelDownloadConditions.Builder().build();\n+\n+  public ModelFileDownloadService(@NonNull FirebaseApp firebaseApp) {\n+    this.context = firebaseApp.getApplicationContext();\n+    downloadManager = (DownloadManager) context.getSystemService(Context.DOWNLOAD_SERVICE);\n+    this.fileManager = ModelFileManager.getInstance();\n+    this.sharedPreferencesUtil = new SharedPreferencesUtil(firebaseApp);\n+  }\n+\n+  @VisibleForTesting\n+  ModelFileDownloadService(\n+      @NonNull FirebaseApp firebaseApp,\n+      DownloadManager downloadManager,\n+      ModelFileManager fileManager,\n+      SharedPreferencesUtil sharedPreferencesUtil) {\n+    this.context = firebaseApp.getApplicationContext();\n+    this.downloadManager = downloadManager;\n+    this.fileManager = fileManager;\n+    this.sharedPreferencesUtil = sharedPreferencesUtil;\n+  }\n+\n+  /**\n+   * Get ModelFileDownloadService instance using the firebase app returned by {@link\n+   * FirebaseApp#getInstance()}\n+   *\n+   * @return ModelFileDownloadService\n+   */\n+  @NonNull\n+  public static ModelFileDownloadService getInstance() {\n+    return FirebaseApp.getInstance().get(ModelFileDownloadService.class);\n+  }\n+\n+  public Task<Void> download(\n+      CustomModel customModel, CustomModelDownloadConditions downloadConditions) {\n+    this.downloadConditions = downloadConditions;\n+    // todo add url tests here\n+    return ensureModelDownloaded(customModel);\n+  }\n+\n+  @VisibleForTesting\n+  Task<Void> ensureModelDownloaded(CustomModel customModel) {\n+    // todo check model not already in progress of being downloaded\n+\n+    // todo remove any failed download attempts\n+\n+    // schedule new download of model file\n+    Long newDownloadId = scheduleModelDownload(customModel);\n+    if (newDownloadId == null) {\n+      return Tasks.forException(new Exception(\"Failed to schedule the download task\"));\n+    }\n+\n+    return registerReceiverForDownloadId(newDownloadId);\n+  }\n+\n+  private synchronized DownloadBroadcastReceiver getReceiverInstance(long downloadId) {\n+    DownloadBroadcastReceiver receiver = receiverMaps.get(downloadId);\n+    if (receiver == null) {\n+      receiver =\n+          new DownloadBroadcastReceiver(downloadId, getTaskCompletionSourceInstance(downloadId));\n+      receiverMaps.put(downloadId, receiver);\n+    }\n+    return receiver;\n+  }\n+\n+  private Task<Void> registerReceiverForDownloadId(long downloadId) {\n+    BroadcastReceiver broadcastReceiver = getReceiverInstance(downloadId);\n+    // It is okay to always register here. Since the broadcast receiver is the same via the lookup\n+    // for the same download id, the same broadcast receiver will be notified only once.\n+    context.registerReceiver(\n+        broadcastReceiver, new IntentFilter(DownloadManager.ACTION_DOWNLOAD_COMPLETE));\n+\n+    return getTaskCompletionSourceInstance(downloadId).getTask();\n+  }\n+\n+  @VisibleForTesting\n+  synchronized TaskCompletionSource<Void> getTaskCompletionSourceInstance(long downloadId) {\n+    TaskCompletionSource<Void> taskCompletionSource = taskCompletionSourceMaps.get(downloadId);\n+    if (taskCompletionSource == null) {\n+      taskCompletionSource = new TaskCompletionSource<>();\n+      taskCompletionSourceMaps.put(downloadId, taskCompletionSource);\n+    }\n+\n+    return taskCompletionSource;\n+  }\n+\n+  @VisibleForTesting\n+  synchronized Long scheduleModelDownload(@NonNull CustomModel customModel) {\n+    if (downloadManager == null) {\n+      return null;\n+    }\n+\n+    if (customModel.getDownloadUrl() == null || customModel.getDownloadUrl().isEmpty()) {\n+      return null;\n+    }\n+    // todo handle expired url here and figure out what to do about delayed downloads too..\n+\n+    // Schedule a new downloading\n+    Request downloadRequest = new Request(Uri.parse(customModel.getDownloadUrl()));\n+    // check Url is not expired - get new one if necessary...\n+\n+    // By setting the destination uri to null, the downloaded file will be stored in\n+    // DownloadManager's purgeable cache. As a result, WRITE_EXTERNAL_STORAGE permission is not\n+    // needed.\n+    downloadRequest.setDestinationUri(null);\n+    if (VERSION.SDK_INT >= VERSION_CODES.N) {\n+      downloadRequest.setRequiresCharging(downloadConditions.isChargingRequired());\n+      downloadRequest.setRequiresDeviceIdle(downloadConditions.isDeviceIdleRequired());\n+    }\n+\n+    if (downloadConditions.isWifiRequired()) {\n+      downloadRequest.setAllowedNetworkTypes(Request.NETWORK_WIFI);\n+    }\n+\n+    long id = downloadManager.enqueue(downloadRequest);\n+    // update the custom model to store the download id - do not lose current local file - in case\n+    // this is a background update.\n+    sharedPreferencesUtil.setDownloadingCustomModelDetails(\n+        new CustomModel(\n+            customModel.getName(),\n+            customModel.getModelHash(),\n+            customModel.getSize(),\n+            id,\n+            customModel.getLocalFilePath()));\n+    return id;\n+  }\n+\n+  @Nullable\n+  @VisibleForTesting\n+  synchronized Integer getDownloadingModelStatusCode(Long downloadingId) {\n+    if (downloadManager == null || downloadingId == null) {\n+      return null;\n+    }\n+\n+    Integer statusCode = null;\n+\n+    try (Cursor cursor = downloadManager.query(new Query().setFilterById(downloadingId))) {\n+\n+      if (cursor != null && cursor.moveToFirst()) {\n+        statusCode = cursor.getInt(cursor.getColumnIndex(DownloadManager.COLUMN_STATUS));\n+      }\n+\n+      if (statusCode == null) {\n+        return null;\n+      }\n+\n+      if (statusCode != DownloadManager.STATUS_RUNNING\n+          && statusCode != DownloadManager.STATUS_PAUSED\n+          && statusCode != DownloadManager.STATUS_PENDING\n+          && statusCode != DownloadManager.STATUS_SUCCESSFUL\n+          && statusCode != DownloadManager.STATUS_FAILED) {\n+        // Unknown status\n+        statusCode = null;\n+      }\n+      return statusCode;\n+    }\n+  }\n+\n+  @Nullable\n+  private synchronized ParcelFileDescriptor getDownloadedFile(Long downloadingId) {\n+    if (downloadManager == null || downloadingId == null) {\n+      return null;\n+    }\n+\n+    ParcelFileDescriptor fileDescriptor = null;\n+    try {\n+      fileDescriptor = downloadManager.openDownloadedFile(downloadingId);\n+    } catch (FileNotFoundException e) {\n+      System.out.println(\"Downloaded file is not found\");\n+    }\n+    return fileDescriptor;\n+  }\n+\n+  public void maybeCheckDownloadingComplete() throws Exception {\n+    for (String key : sharedPreferencesUtil.getSharedPreferenceKeySet()) {\n+      // if a local file path is present - get model details.\n+      Matcher matcher =\n+          Pattern.compile(SharedPreferencesUtil.DOWNLOADING_MODEL_ID_MATCHER).matcher(key);\n+      if (matcher.find()) {\n+        String modelName = matcher.group(matcher.groupCount());\n+        CustomModel downloadingModel = sharedPreferencesUtil.getCustomModelDetails(modelName);\n+        Integer statusCode = getDownloadingModelStatusCode(downloadingModel.getDownloadId());\n+        if (statusCode == DownloadManager.STATUS_SUCCESSFUL\n+            || statusCode == DownloadManager.STATUS_FAILED) {\n+          loadNewlyDownloadedModelFile(downloadingModel);\n+        }\n+      }\n+    }\n+  }\n+\n+  @Nullable\n+  @WorkerThread\n+  public File loadNewlyDownloadedModelFile(CustomModel model) throws Exception {\n+    Long downloadingId = model.getDownloadId();\n+    String downloadingModelHash = model.getModelHash();\n+\n+    if (downloadingId == null || downloadingModelHash == null) {\n+      // no downloading model file or incomplete info.\n+      return null;\n+    }\n+\n+    Integer statusCode = getDownloadingModelStatusCode(downloadingId);\n+    if (statusCode == null) {\n+      return null;\n+    }\n+\n+    if (statusCode == DownloadManager.STATUS_SUCCESSFUL) {\n+      // Get downloaded file.\n+      ParcelFileDescriptor fileDescriptor = getDownloadedFile(downloadingId);\n+      if (fileDescriptor == null) {\n+        // reset original model - removing download id.\n+        sharedPreferencesUtil.setFailedUploadedCustomModelDetails(model.getName());\n+        // todo call the download register?\n+        return null;\n+      }\n+\n+      // Try to move it to destination folder.\n+      File newModelFile = fileManager.moveModelToDestinationFolder(model, fileDescriptor);\n+\n+      if (newModelFile == null) {\n+        // reset original model - removing download id.\n+        // todo call the download register?\n+        sharedPreferencesUtil.setFailedUploadedCustomModelDetails(model.getName());\n+        return null;\n+      }\n+\n+      // Successfully moved,  update share preferences\n+      sharedPreferencesUtil.setUploadedCustomModelDetails(\n+          new CustomModel(\n+              model.getName(), model.getModelHash(), model.getSize(), 0, newModelFile.getPath()));\n+\n+      // Cleans up the old files if it is the initial creation.\n+      return newModelFile;\n+    } else if (statusCode == DownloadManager.STATUS_FAILED) {\n+      // reset original model - removing download id.\n+      sharedPreferencesUtil.setFailedUploadedCustomModelDetails(model.getName());\n+      // todo - determine if the temp files need to be clean up? Does one exist?\n+    }\n+    // Other cases, return as null and wait for download finish.\n+    return null;\n+  }\n+\n+  // This class runs totally on worker thread because we registered the receiver with a worker\n+  // thread handler.\n+  @WorkerThread\n+  private class DownloadBroadcastReceiver extends BroadcastReceiver {\n+\n+    // Download Id is captured inside this class in memory. So there is no concern of inconsistency\n+    // with the persisted download id in shared preferences.\n+    private final long downloadId;\n+    private final TaskCompletionSource<Void> taskCompletionSource;\n+\n+    private DownloadBroadcastReceiver(\n+        long downloadId, TaskCompletionSource<Void> taskCompletionSource) {\n+      this.downloadId = downloadId;\n+      this.taskCompletionSource = taskCompletionSource;\n+    }\n+\n+    @Override\n+    public void onReceive(Context context, Intent intent) {\n+      long id = intent.getLongExtra(DownloadManager.EXTRA_DOWNLOAD_ID, -1);\n+      if (id != downloadId) {\n+        return;\n+      }\n+\n+      Integer statusCode = getDownloadingModelStatusCode(downloadId);\n+      synchronized (ModelFileDownloadService.this) {\n+        try {\n+          context.getApplicationContext().unregisterReceiver(this);\n+        } catch (IllegalArgumentException e) {\n+          // If we try to unregister a receiver that was never registered or has been unregistered,\n+          // IllegalArgumentException will be thrown by the Android Framework.\n+          // Our current code does not have this problem. However, in order to be safer in the\n+          // future, we just ignore the exception here, because it is not a big deal. The code can\n+          // move on.\n+        }\n+\n+        receiverMaps.remove(downloadId);\n+        taskCompletionSourceMaps.remove(downloadId);\n+      }\n+\n+      if (statusCode != null) {\n+        if (statusCode == DownloadManager.STATUS_FAILED) {\n+          // todo add failure reason and logging\n+          System.out.println(\"Download Failed for id: \" + id);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzg0ODM5OQ=="}, "originalCommit": {"oid": "b270c4efe700860814b5078d60f38b2966934500"}, "originalPosition": 355}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0OTM1NDg2OnYy", "diffSide": "RIGHT", "path": "firebase-ml-modeldownloader/src/main/java/com/google/firebase/ml/modeldownloader/internal/ModelFileDownloadService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQwMjoxMTowOFrOH9HiOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQxNDozNDoyMlrOH9dyvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzg0ODYzNA==", "bodyText": "same", "url": "https://github.com/firebase/firebase-android-sdk/pull/2212#discussion_r533848634", "createdAt": "2020-12-02T02:11:08Z", "author": {"login": "rlazo"}, "path": "firebase-ml-modeldownloader/src/main/java/com/google/firebase/ml/modeldownloader/internal/ModelFileDownloadService.java", "diffHunk": "@@ -0,0 +1,371 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.ml.modeldownloader.internal;\n+\n+import android.app.DownloadManager;\n+import android.app.DownloadManager.Query;\n+import android.app.DownloadManager.Request;\n+import android.content.BroadcastReceiver;\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.IntentFilter;\n+import android.database.Cursor;\n+import android.net.Uri;\n+import android.os.Build.VERSION;\n+import android.os.Build.VERSION_CODES;\n+import android.os.ParcelFileDescriptor;\n+import android.util.LongSparseArray;\n+import androidx.annotation.GuardedBy;\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+import androidx.annotation.VisibleForTesting;\n+import androidx.annotation.WorkerThread;\n+import com.google.android.gms.tasks.Task;\n+import com.google.android.gms.tasks.TaskCompletionSource;\n+import com.google.android.gms.tasks.Tasks;\n+import com.google.firebase.FirebaseApp;\n+import com.google.firebase.ml.modeldownloader.CustomModel;\n+import com.google.firebase.ml.modeldownloader.CustomModelDownloadConditions;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Calls the Android Download service to copy the model file to device (temp location) and then\n+ * moves file to it's permanent location, updating the model details in shared preferences\n+ * throughout.\n+ *\n+ * @hide\n+ */\n+public class ModelFileDownloadService {\n+\n+  private final DownloadManager downloadManager;\n+  private final Context context;\n+  private final ModelFileManager fileManager;\n+  private final SharedPreferencesUtil sharedPreferencesUtil;\n+\n+  @GuardedBy(\"this\")\n+  // Mapping from download id to broadcast receiver. Because models can update, we cannot just keep\n+  // one instance of DownloadBroadcastReceiver per RemoteModelDownloadManager object.\n+  private final LongSparseArray<DownloadBroadcastReceiver> receiverMaps = new LongSparseArray<>();\n+\n+  @GuardedBy(\"this\")\n+  // Mapping from download id to TaskCompletionSource. Because models can update, we cannot just\n+  // keep one instance of TaskCompletionSource per RemoteModelDownloadManager object.\n+  private final LongSparseArray<TaskCompletionSource<Void>> taskCompletionSourceMaps =\n+      new LongSparseArray<>();\n+\n+  private CustomModelDownloadConditions downloadConditions =\n+      new CustomModelDownloadConditions.Builder().build();\n+\n+  public ModelFileDownloadService(@NonNull FirebaseApp firebaseApp) {\n+    this.context = firebaseApp.getApplicationContext();\n+    downloadManager = (DownloadManager) context.getSystemService(Context.DOWNLOAD_SERVICE);\n+    this.fileManager = ModelFileManager.getInstance();\n+    this.sharedPreferencesUtil = new SharedPreferencesUtil(firebaseApp);\n+  }\n+\n+  @VisibleForTesting\n+  ModelFileDownloadService(\n+      @NonNull FirebaseApp firebaseApp,\n+      DownloadManager downloadManager,\n+      ModelFileManager fileManager,\n+      SharedPreferencesUtil sharedPreferencesUtil) {\n+    this.context = firebaseApp.getApplicationContext();\n+    this.downloadManager = downloadManager;\n+    this.fileManager = fileManager;\n+    this.sharedPreferencesUtil = sharedPreferencesUtil;\n+  }\n+\n+  /**\n+   * Get ModelFileDownloadService instance using the firebase app returned by {@link\n+   * FirebaseApp#getInstance()}\n+   *\n+   * @return ModelFileDownloadService\n+   */\n+  @NonNull\n+  public static ModelFileDownloadService getInstance() {\n+    return FirebaseApp.getInstance().get(ModelFileDownloadService.class);\n+  }\n+\n+  public Task<Void> download(\n+      CustomModel customModel, CustomModelDownloadConditions downloadConditions) {\n+    this.downloadConditions = downloadConditions;\n+    // todo add url tests here\n+    return ensureModelDownloaded(customModel);\n+  }\n+\n+  @VisibleForTesting\n+  Task<Void> ensureModelDownloaded(CustomModel customModel) {\n+    // todo check model not already in progress of being downloaded\n+\n+    // todo remove any failed download attempts\n+\n+    // schedule new download of model file\n+    Long newDownloadId = scheduleModelDownload(customModel);\n+    if (newDownloadId == null) {\n+      return Tasks.forException(new Exception(\"Failed to schedule the download task\"));\n+    }\n+\n+    return registerReceiverForDownloadId(newDownloadId);\n+  }\n+\n+  private synchronized DownloadBroadcastReceiver getReceiverInstance(long downloadId) {\n+    DownloadBroadcastReceiver receiver = receiverMaps.get(downloadId);\n+    if (receiver == null) {\n+      receiver =\n+          new DownloadBroadcastReceiver(downloadId, getTaskCompletionSourceInstance(downloadId));\n+      receiverMaps.put(downloadId, receiver);\n+    }\n+    return receiver;\n+  }\n+\n+  private Task<Void> registerReceiverForDownloadId(long downloadId) {\n+    BroadcastReceiver broadcastReceiver = getReceiverInstance(downloadId);\n+    // It is okay to always register here. Since the broadcast receiver is the same via the lookup\n+    // for the same download id, the same broadcast receiver will be notified only once.\n+    context.registerReceiver(\n+        broadcastReceiver, new IntentFilter(DownloadManager.ACTION_DOWNLOAD_COMPLETE));\n+\n+    return getTaskCompletionSourceInstance(downloadId).getTask();\n+  }\n+\n+  @VisibleForTesting\n+  synchronized TaskCompletionSource<Void> getTaskCompletionSourceInstance(long downloadId) {\n+    TaskCompletionSource<Void> taskCompletionSource = taskCompletionSourceMaps.get(downloadId);\n+    if (taskCompletionSource == null) {\n+      taskCompletionSource = new TaskCompletionSource<>();\n+      taskCompletionSourceMaps.put(downloadId, taskCompletionSource);\n+    }\n+\n+    return taskCompletionSource;\n+  }\n+\n+  @VisibleForTesting\n+  synchronized Long scheduleModelDownload(@NonNull CustomModel customModel) {\n+    if (downloadManager == null) {\n+      return null;\n+    }\n+\n+    if (customModel.getDownloadUrl() == null || customModel.getDownloadUrl().isEmpty()) {\n+      return null;\n+    }\n+    // todo handle expired url here and figure out what to do about delayed downloads too..\n+\n+    // Schedule a new downloading\n+    Request downloadRequest = new Request(Uri.parse(customModel.getDownloadUrl()));\n+    // check Url is not expired - get new one if necessary...\n+\n+    // By setting the destination uri to null, the downloaded file will be stored in\n+    // DownloadManager's purgeable cache. As a result, WRITE_EXTERNAL_STORAGE permission is not\n+    // needed.\n+    downloadRequest.setDestinationUri(null);\n+    if (VERSION.SDK_INT >= VERSION_CODES.N) {\n+      downloadRequest.setRequiresCharging(downloadConditions.isChargingRequired());\n+      downloadRequest.setRequiresDeviceIdle(downloadConditions.isDeviceIdleRequired());\n+    }\n+\n+    if (downloadConditions.isWifiRequired()) {\n+      downloadRequest.setAllowedNetworkTypes(Request.NETWORK_WIFI);\n+    }\n+\n+    long id = downloadManager.enqueue(downloadRequest);\n+    // update the custom model to store the download id - do not lose current local file - in case\n+    // this is a background update.\n+    sharedPreferencesUtil.setDownloadingCustomModelDetails(\n+        new CustomModel(\n+            customModel.getName(),\n+            customModel.getModelHash(),\n+            customModel.getSize(),\n+            id,\n+            customModel.getLocalFilePath()));\n+    return id;\n+  }\n+\n+  @Nullable\n+  @VisibleForTesting\n+  synchronized Integer getDownloadingModelStatusCode(Long downloadingId) {\n+    if (downloadManager == null || downloadingId == null) {\n+      return null;\n+    }\n+\n+    Integer statusCode = null;\n+\n+    try (Cursor cursor = downloadManager.query(new Query().setFilterById(downloadingId))) {\n+\n+      if (cursor != null && cursor.moveToFirst()) {\n+        statusCode = cursor.getInt(cursor.getColumnIndex(DownloadManager.COLUMN_STATUS));\n+      }\n+\n+      if (statusCode == null) {\n+        return null;\n+      }\n+\n+      if (statusCode != DownloadManager.STATUS_RUNNING\n+          && statusCode != DownloadManager.STATUS_PAUSED\n+          && statusCode != DownloadManager.STATUS_PENDING\n+          && statusCode != DownloadManager.STATUS_SUCCESSFUL\n+          && statusCode != DownloadManager.STATUS_FAILED) {\n+        // Unknown status\n+        statusCode = null;\n+      }\n+      return statusCode;\n+    }\n+  }\n+\n+  @Nullable\n+  private synchronized ParcelFileDescriptor getDownloadedFile(Long downloadingId) {\n+    if (downloadManager == null || downloadingId == null) {\n+      return null;\n+    }\n+\n+    ParcelFileDescriptor fileDescriptor = null;\n+    try {\n+      fileDescriptor = downloadManager.openDownloadedFile(downloadingId);\n+    } catch (FileNotFoundException e) {\n+      System.out.println(\"Downloaded file is not found\");\n+    }\n+    return fileDescriptor;\n+  }\n+\n+  public void maybeCheckDownloadingComplete() throws Exception {\n+    for (String key : sharedPreferencesUtil.getSharedPreferenceKeySet()) {\n+      // if a local file path is present - get model details.\n+      Matcher matcher =\n+          Pattern.compile(SharedPreferencesUtil.DOWNLOADING_MODEL_ID_MATCHER).matcher(key);\n+      if (matcher.find()) {\n+        String modelName = matcher.group(matcher.groupCount());\n+        CustomModel downloadingModel = sharedPreferencesUtil.getCustomModelDetails(modelName);\n+        Integer statusCode = getDownloadingModelStatusCode(downloadingModel.getDownloadId());\n+        if (statusCode == DownloadManager.STATUS_SUCCESSFUL\n+            || statusCode == DownloadManager.STATUS_FAILED) {\n+          loadNewlyDownloadedModelFile(downloadingModel);\n+        }\n+      }\n+    }\n+  }\n+\n+  @Nullable\n+  @WorkerThread\n+  public File loadNewlyDownloadedModelFile(CustomModel model) throws Exception {\n+    Long downloadingId = model.getDownloadId();\n+    String downloadingModelHash = model.getModelHash();\n+\n+    if (downloadingId == null || downloadingModelHash == null) {\n+      // no downloading model file or incomplete info.\n+      return null;\n+    }\n+\n+    Integer statusCode = getDownloadingModelStatusCode(downloadingId);\n+    if (statusCode == null) {\n+      return null;\n+    }\n+\n+    if (statusCode == DownloadManager.STATUS_SUCCESSFUL) {\n+      // Get downloaded file.\n+      ParcelFileDescriptor fileDescriptor = getDownloadedFile(downloadingId);\n+      if (fileDescriptor == null) {\n+        // reset original model - removing download id.\n+        sharedPreferencesUtil.setFailedUploadedCustomModelDetails(model.getName());\n+        // todo call the download register?\n+        return null;\n+      }\n+\n+      // Try to move it to destination folder.\n+      File newModelFile = fileManager.moveModelToDestinationFolder(model, fileDescriptor);\n+\n+      if (newModelFile == null) {\n+        // reset original model - removing download id.\n+        // todo call the download register?\n+        sharedPreferencesUtil.setFailedUploadedCustomModelDetails(model.getName());\n+        return null;\n+      }\n+\n+      // Successfully moved,  update share preferences\n+      sharedPreferencesUtil.setUploadedCustomModelDetails(\n+          new CustomModel(\n+              model.getName(), model.getModelHash(), model.getSize(), 0, newModelFile.getPath()));\n+\n+      // Cleans up the old files if it is the initial creation.\n+      return newModelFile;\n+    } else if (statusCode == DownloadManager.STATUS_FAILED) {\n+      // reset original model - removing download id.\n+      sharedPreferencesUtil.setFailedUploadedCustomModelDetails(model.getName());\n+      // todo - determine if the temp files need to be clean up? Does one exist?\n+    }\n+    // Other cases, return as null and wait for download finish.\n+    return null;\n+  }\n+\n+  // This class runs totally on worker thread because we registered the receiver with a worker\n+  // thread handler.\n+  @WorkerThread\n+  private class DownloadBroadcastReceiver extends BroadcastReceiver {\n+\n+    // Download Id is captured inside this class in memory. So there is no concern of inconsistency\n+    // with the persisted download id in shared preferences.\n+    private final long downloadId;\n+    private final TaskCompletionSource<Void> taskCompletionSource;\n+\n+    private DownloadBroadcastReceiver(\n+        long downloadId, TaskCompletionSource<Void> taskCompletionSource) {\n+      this.downloadId = downloadId;\n+      this.taskCompletionSource = taskCompletionSource;\n+    }\n+\n+    @Override\n+    public void onReceive(Context context, Intent intent) {\n+      long id = intent.getLongExtra(DownloadManager.EXTRA_DOWNLOAD_ID, -1);\n+      if (id != downloadId) {\n+        return;\n+      }\n+\n+      Integer statusCode = getDownloadingModelStatusCode(downloadId);\n+      synchronized (ModelFileDownloadService.this) {\n+        try {\n+          context.getApplicationContext().unregisterReceiver(this);\n+        } catch (IllegalArgumentException e) {\n+          // If we try to unregister a receiver that was never registered or has been unregistered,\n+          // IllegalArgumentException will be thrown by the Android Framework.\n+          // Our current code does not have this problem. However, in order to be safer in the\n+          // future, we just ignore the exception here, because it is not a big deal. The code can\n+          // move on.\n+        }\n+\n+        receiverMaps.remove(downloadId);\n+        taskCompletionSourceMaps.remove(downloadId);\n+      }\n+\n+      if (statusCode != null) {\n+        if (statusCode == DownloadManager.STATUS_FAILED) {\n+          // todo add failure reason and logging\n+          System.out.println(\"Download Failed for id: \" + id);\n+          taskCompletionSource.setException(new Exception(\"Failed\"));\n+          return;\n+        }\n+\n+        if (statusCode == DownloadManager.STATUS_SUCCESSFUL) {\n+          System.out.println(\"Download Succeeded for id: \" + id);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b270c4efe700860814b5078d60f38b2966934500"}, "originalPosition": 361}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDIxMzMxMQ==", "bodyText": "same", "url": "https://github.com/firebase/firebase-android-sdk/pull/2212#discussion_r534213311", "createdAt": "2020-12-02T14:34:22Z", "author": {"login": "annzimmer"}, "path": "firebase-ml-modeldownloader/src/main/java/com/google/firebase/ml/modeldownloader/internal/ModelFileDownloadService.java", "diffHunk": "@@ -0,0 +1,371 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.ml.modeldownloader.internal;\n+\n+import android.app.DownloadManager;\n+import android.app.DownloadManager.Query;\n+import android.app.DownloadManager.Request;\n+import android.content.BroadcastReceiver;\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.IntentFilter;\n+import android.database.Cursor;\n+import android.net.Uri;\n+import android.os.Build.VERSION;\n+import android.os.Build.VERSION_CODES;\n+import android.os.ParcelFileDescriptor;\n+import android.util.LongSparseArray;\n+import androidx.annotation.GuardedBy;\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+import androidx.annotation.VisibleForTesting;\n+import androidx.annotation.WorkerThread;\n+import com.google.android.gms.tasks.Task;\n+import com.google.android.gms.tasks.TaskCompletionSource;\n+import com.google.android.gms.tasks.Tasks;\n+import com.google.firebase.FirebaseApp;\n+import com.google.firebase.ml.modeldownloader.CustomModel;\n+import com.google.firebase.ml.modeldownloader.CustomModelDownloadConditions;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Calls the Android Download service to copy the model file to device (temp location) and then\n+ * moves file to it's permanent location, updating the model details in shared preferences\n+ * throughout.\n+ *\n+ * @hide\n+ */\n+public class ModelFileDownloadService {\n+\n+  private final DownloadManager downloadManager;\n+  private final Context context;\n+  private final ModelFileManager fileManager;\n+  private final SharedPreferencesUtil sharedPreferencesUtil;\n+\n+  @GuardedBy(\"this\")\n+  // Mapping from download id to broadcast receiver. Because models can update, we cannot just keep\n+  // one instance of DownloadBroadcastReceiver per RemoteModelDownloadManager object.\n+  private final LongSparseArray<DownloadBroadcastReceiver> receiverMaps = new LongSparseArray<>();\n+\n+  @GuardedBy(\"this\")\n+  // Mapping from download id to TaskCompletionSource. Because models can update, we cannot just\n+  // keep one instance of TaskCompletionSource per RemoteModelDownloadManager object.\n+  private final LongSparseArray<TaskCompletionSource<Void>> taskCompletionSourceMaps =\n+      new LongSparseArray<>();\n+\n+  private CustomModelDownloadConditions downloadConditions =\n+      new CustomModelDownloadConditions.Builder().build();\n+\n+  public ModelFileDownloadService(@NonNull FirebaseApp firebaseApp) {\n+    this.context = firebaseApp.getApplicationContext();\n+    downloadManager = (DownloadManager) context.getSystemService(Context.DOWNLOAD_SERVICE);\n+    this.fileManager = ModelFileManager.getInstance();\n+    this.sharedPreferencesUtil = new SharedPreferencesUtil(firebaseApp);\n+  }\n+\n+  @VisibleForTesting\n+  ModelFileDownloadService(\n+      @NonNull FirebaseApp firebaseApp,\n+      DownloadManager downloadManager,\n+      ModelFileManager fileManager,\n+      SharedPreferencesUtil sharedPreferencesUtil) {\n+    this.context = firebaseApp.getApplicationContext();\n+    this.downloadManager = downloadManager;\n+    this.fileManager = fileManager;\n+    this.sharedPreferencesUtil = sharedPreferencesUtil;\n+  }\n+\n+  /**\n+   * Get ModelFileDownloadService instance using the firebase app returned by {@link\n+   * FirebaseApp#getInstance()}\n+   *\n+   * @return ModelFileDownloadService\n+   */\n+  @NonNull\n+  public static ModelFileDownloadService getInstance() {\n+    return FirebaseApp.getInstance().get(ModelFileDownloadService.class);\n+  }\n+\n+  public Task<Void> download(\n+      CustomModel customModel, CustomModelDownloadConditions downloadConditions) {\n+    this.downloadConditions = downloadConditions;\n+    // todo add url tests here\n+    return ensureModelDownloaded(customModel);\n+  }\n+\n+  @VisibleForTesting\n+  Task<Void> ensureModelDownloaded(CustomModel customModel) {\n+    // todo check model not already in progress of being downloaded\n+\n+    // todo remove any failed download attempts\n+\n+    // schedule new download of model file\n+    Long newDownloadId = scheduleModelDownload(customModel);\n+    if (newDownloadId == null) {\n+      return Tasks.forException(new Exception(\"Failed to schedule the download task\"));\n+    }\n+\n+    return registerReceiverForDownloadId(newDownloadId);\n+  }\n+\n+  private synchronized DownloadBroadcastReceiver getReceiverInstance(long downloadId) {\n+    DownloadBroadcastReceiver receiver = receiverMaps.get(downloadId);\n+    if (receiver == null) {\n+      receiver =\n+          new DownloadBroadcastReceiver(downloadId, getTaskCompletionSourceInstance(downloadId));\n+      receiverMaps.put(downloadId, receiver);\n+    }\n+    return receiver;\n+  }\n+\n+  private Task<Void> registerReceiverForDownloadId(long downloadId) {\n+    BroadcastReceiver broadcastReceiver = getReceiverInstance(downloadId);\n+    // It is okay to always register here. Since the broadcast receiver is the same via the lookup\n+    // for the same download id, the same broadcast receiver will be notified only once.\n+    context.registerReceiver(\n+        broadcastReceiver, new IntentFilter(DownloadManager.ACTION_DOWNLOAD_COMPLETE));\n+\n+    return getTaskCompletionSourceInstance(downloadId).getTask();\n+  }\n+\n+  @VisibleForTesting\n+  synchronized TaskCompletionSource<Void> getTaskCompletionSourceInstance(long downloadId) {\n+    TaskCompletionSource<Void> taskCompletionSource = taskCompletionSourceMaps.get(downloadId);\n+    if (taskCompletionSource == null) {\n+      taskCompletionSource = new TaskCompletionSource<>();\n+      taskCompletionSourceMaps.put(downloadId, taskCompletionSource);\n+    }\n+\n+    return taskCompletionSource;\n+  }\n+\n+  @VisibleForTesting\n+  synchronized Long scheduleModelDownload(@NonNull CustomModel customModel) {\n+    if (downloadManager == null) {\n+      return null;\n+    }\n+\n+    if (customModel.getDownloadUrl() == null || customModel.getDownloadUrl().isEmpty()) {\n+      return null;\n+    }\n+    // todo handle expired url here and figure out what to do about delayed downloads too..\n+\n+    // Schedule a new downloading\n+    Request downloadRequest = new Request(Uri.parse(customModel.getDownloadUrl()));\n+    // check Url is not expired - get new one if necessary...\n+\n+    // By setting the destination uri to null, the downloaded file will be stored in\n+    // DownloadManager's purgeable cache. As a result, WRITE_EXTERNAL_STORAGE permission is not\n+    // needed.\n+    downloadRequest.setDestinationUri(null);\n+    if (VERSION.SDK_INT >= VERSION_CODES.N) {\n+      downloadRequest.setRequiresCharging(downloadConditions.isChargingRequired());\n+      downloadRequest.setRequiresDeviceIdle(downloadConditions.isDeviceIdleRequired());\n+    }\n+\n+    if (downloadConditions.isWifiRequired()) {\n+      downloadRequest.setAllowedNetworkTypes(Request.NETWORK_WIFI);\n+    }\n+\n+    long id = downloadManager.enqueue(downloadRequest);\n+    // update the custom model to store the download id - do not lose current local file - in case\n+    // this is a background update.\n+    sharedPreferencesUtil.setDownloadingCustomModelDetails(\n+        new CustomModel(\n+            customModel.getName(),\n+            customModel.getModelHash(),\n+            customModel.getSize(),\n+            id,\n+            customModel.getLocalFilePath()));\n+    return id;\n+  }\n+\n+  @Nullable\n+  @VisibleForTesting\n+  synchronized Integer getDownloadingModelStatusCode(Long downloadingId) {\n+    if (downloadManager == null || downloadingId == null) {\n+      return null;\n+    }\n+\n+    Integer statusCode = null;\n+\n+    try (Cursor cursor = downloadManager.query(new Query().setFilterById(downloadingId))) {\n+\n+      if (cursor != null && cursor.moveToFirst()) {\n+        statusCode = cursor.getInt(cursor.getColumnIndex(DownloadManager.COLUMN_STATUS));\n+      }\n+\n+      if (statusCode == null) {\n+        return null;\n+      }\n+\n+      if (statusCode != DownloadManager.STATUS_RUNNING\n+          && statusCode != DownloadManager.STATUS_PAUSED\n+          && statusCode != DownloadManager.STATUS_PENDING\n+          && statusCode != DownloadManager.STATUS_SUCCESSFUL\n+          && statusCode != DownloadManager.STATUS_FAILED) {\n+        // Unknown status\n+        statusCode = null;\n+      }\n+      return statusCode;\n+    }\n+  }\n+\n+  @Nullable\n+  private synchronized ParcelFileDescriptor getDownloadedFile(Long downloadingId) {\n+    if (downloadManager == null || downloadingId == null) {\n+      return null;\n+    }\n+\n+    ParcelFileDescriptor fileDescriptor = null;\n+    try {\n+      fileDescriptor = downloadManager.openDownloadedFile(downloadingId);\n+    } catch (FileNotFoundException e) {\n+      System.out.println(\"Downloaded file is not found\");\n+    }\n+    return fileDescriptor;\n+  }\n+\n+  public void maybeCheckDownloadingComplete() throws Exception {\n+    for (String key : sharedPreferencesUtil.getSharedPreferenceKeySet()) {\n+      // if a local file path is present - get model details.\n+      Matcher matcher =\n+          Pattern.compile(SharedPreferencesUtil.DOWNLOADING_MODEL_ID_MATCHER).matcher(key);\n+      if (matcher.find()) {\n+        String modelName = matcher.group(matcher.groupCount());\n+        CustomModel downloadingModel = sharedPreferencesUtil.getCustomModelDetails(modelName);\n+        Integer statusCode = getDownloadingModelStatusCode(downloadingModel.getDownloadId());\n+        if (statusCode == DownloadManager.STATUS_SUCCESSFUL\n+            || statusCode == DownloadManager.STATUS_FAILED) {\n+          loadNewlyDownloadedModelFile(downloadingModel);\n+        }\n+      }\n+    }\n+  }\n+\n+  @Nullable\n+  @WorkerThread\n+  public File loadNewlyDownloadedModelFile(CustomModel model) throws Exception {\n+    Long downloadingId = model.getDownloadId();\n+    String downloadingModelHash = model.getModelHash();\n+\n+    if (downloadingId == null || downloadingModelHash == null) {\n+      // no downloading model file or incomplete info.\n+      return null;\n+    }\n+\n+    Integer statusCode = getDownloadingModelStatusCode(downloadingId);\n+    if (statusCode == null) {\n+      return null;\n+    }\n+\n+    if (statusCode == DownloadManager.STATUS_SUCCESSFUL) {\n+      // Get downloaded file.\n+      ParcelFileDescriptor fileDescriptor = getDownloadedFile(downloadingId);\n+      if (fileDescriptor == null) {\n+        // reset original model - removing download id.\n+        sharedPreferencesUtil.setFailedUploadedCustomModelDetails(model.getName());\n+        // todo call the download register?\n+        return null;\n+      }\n+\n+      // Try to move it to destination folder.\n+      File newModelFile = fileManager.moveModelToDestinationFolder(model, fileDescriptor);\n+\n+      if (newModelFile == null) {\n+        // reset original model - removing download id.\n+        // todo call the download register?\n+        sharedPreferencesUtil.setFailedUploadedCustomModelDetails(model.getName());\n+        return null;\n+      }\n+\n+      // Successfully moved,  update share preferences\n+      sharedPreferencesUtil.setUploadedCustomModelDetails(\n+          new CustomModel(\n+              model.getName(), model.getModelHash(), model.getSize(), 0, newModelFile.getPath()));\n+\n+      // Cleans up the old files if it is the initial creation.\n+      return newModelFile;\n+    } else if (statusCode == DownloadManager.STATUS_FAILED) {\n+      // reset original model - removing download id.\n+      sharedPreferencesUtil.setFailedUploadedCustomModelDetails(model.getName());\n+      // todo - determine if the temp files need to be clean up? Does one exist?\n+    }\n+    // Other cases, return as null and wait for download finish.\n+    return null;\n+  }\n+\n+  // This class runs totally on worker thread because we registered the receiver with a worker\n+  // thread handler.\n+  @WorkerThread\n+  private class DownloadBroadcastReceiver extends BroadcastReceiver {\n+\n+    // Download Id is captured inside this class in memory. So there is no concern of inconsistency\n+    // with the persisted download id in shared preferences.\n+    private final long downloadId;\n+    private final TaskCompletionSource<Void> taskCompletionSource;\n+\n+    private DownloadBroadcastReceiver(\n+        long downloadId, TaskCompletionSource<Void> taskCompletionSource) {\n+      this.downloadId = downloadId;\n+      this.taskCompletionSource = taskCompletionSource;\n+    }\n+\n+    @Override\n+    public void onReceive(Context context, Intent intent) {\n+      long id = intent.getLongExtra(DownloadManager.EXTRA_DOWNLOAD_ID, -1);\n+      if (id != downloadId) {\n+        return;\n+      }\n+\n+      Integer statusCode = getDownloadingModelStatusCode(downloadId);\n+      synchronized (ModelFileDownloadService.this) {\n+        try {\n+          context.getApplicationContext().unregisterReceiver(this);\n+        } catch (IllegalArgumentException e) {\n+          // If we try to unregister a receiver that was never registered or has been unregistered,\n+          // IllegalArgumentException will be thrown by the Android Framework.\n+          // Our current code does not have this problem. However, in order to be safer in the\n+          // future, we just ignore the exception here, because it is not a big deal. The code can\n+          // move on.\n+        }\n+\n+        receiverMaps.remove(downloadId);\n+        taskCompletionSourceMaps.remove(downloadId);\n+      }\n+\n+      if (statusCode != null) {\n+        if (statusCode == DownloadManager.STATUS_FAILED) {\n+          // todo add failure reason and logging\n+          System.out.println(\"Download Failed for id: \" + id);\n+          taskCompletionSource.setException(new Exception(\"Failed\"));\n+          return;\n+        }\n+\n+        if (statusCode == DownloadManager.STATUS_SUCCESSFUL) {\n+          System.out.println(\"Download Succeeded for id: \" + id);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzg0ODYzNA=="}, "originalCommit": {"oid": "b270c4efe700860814b5078d60f38b2966934500"}, "originalPosition": 361}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0OTM1NzE0OnYy", "diffSide": "RIGHT", "path": "firebase-ml-modeldownloader/src/main/java/com/google/firebase/ml/modeldownloader/internal/ModelFileManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQwMjoxMjoxMlrOH9HjjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQwMjoxMjoxMlrOH9HjjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzg0ODk3Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private @Nullable File getModelDirUnsafe(@NonNull String modelName) {\n          \n          \n            \n              @Nullable private File getModelDirUnsafe(@NonNull String modelName) {", "url": "https://github.com/firebase/firebase-android-sdk/pull/2212#discussion_r533848973", "createdAt": "2020-12-02T02:12:12Z", "author": {"login": "rlazo"}, "path": "firebase-ml-modeldownloader/src/main/java/com/google/firebase/ml/modeldownloader/internal/ModelFileManager.java", "diffHunk": "@@ -0,0 +1,165 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+package com.google.firebase.ml.modeldownloader.internal;\n+\n+import android.content.Context;\n+import android.os.Build.VERSION;\n+import android.os.Build.VERSION_CODES;\n+import android.os.ParcelFileDescriptor;\n+import android.os.ParcelFileDescriptor.AutoCloseInputStream;\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+import androidx.annotation.VisibleForTesting;\n+import androidx.annotation.WorkerThread;\n+import com.google.firebase.FirebaseApp;\n+import com.google.firebase.ml.modeldownloader.CustomModel;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+\n+/** Model File Manager is used to move the downloaded file to the appropriate locations. */\n+public class ModelFileManager {\n+\n+  @VisibleForTesting\n+  static final String CUSTOM_MODEL_ROOT_PATH = \"com.google.firebase.ml.custom.models\";\n+\n+  private static final int INVALID_INDEX = -1;\n+  private final Context context;\n+  private final FirebaseApp firebaseApp;\n+\n+  public ModelFileManager(@NonNull FirebaseApp firebaseApp) {\n+    this.context = firebaseApp.getApplicationContext();\n+    this.firebaseApp = firebaseApp;\n+  }\n+\n+  /**\n+   * Get ModelFileDownloadService instance using the firebase app returned by {@link\n+   * FirebaseApp#getInstance()}\n+   *\n+   * @return ModelFileDownloadService\n+   */\n+  @NonNull\n+  public static ModelFileManager getInstance() {\n+    return FirebaseApp.getInstance().get(ModelFileManager.class);\n+  }\n+\n+  /**\n+   * Get the directory where the model is supposed to reside. This method does not ensure that the\n+   * directory specified does exist. If you need to ensure its existence, you should call\n+   * getDirImpl.\n+   */\n+  private @Nullable File getModelDirUnsafe(@NonNull String modelName) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b270c4efe700860814b5078d60f38b2966934500"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0OTM2MDI1OnYy", "diffSide": "RIGHT", "path": "firebase-ml-modeldownloader/src/main/java/com/google/firebase/ml/modeldownloader/internal/ModelFileManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQwMjoxMzoyNFrOH9HlKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQxNDozNDoyMFrOH9dykg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzg0OTM4NA==", "bodyText": "same", "url": "https://github.com/firebase/firebase-android-sdk/pull/2212#discussion_r533849384", "createdAt": "2020-12-02T02:13:24Z", "author": {"login": "rlazo"}, "path": "firebase-ml-modeldownloader/src/main/java/com/google/firebase/ml/modeldownloader/internal/ModelFileManager.java", "diffHunk": "@@ -0,0 +1,165 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+package com.google.firebase.ml.modeldownloader.internal;\n+\n+import android.content.Context;\n+import android.os.Build.VERSION;\n+import android.os.Build.VERSION_CODES;\n+import android.os.ParcelFileDescriptor;\n+import android.os.ParcelFileDescriptor.AutoCloseInputStream;\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+import androidx.annotation.VisibleForTesting;\n+import androidx.annotation.WorkerThread;\n+import com.google.firebase.FirebaseApp;\n+import com.google.firebase.ml.modeldownloader.CustomModel;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+\n+/** Model File Manager is used to move the downloaded file to the appropriate locations. */\n+public class ModelFileManager {\n+\n+  @VisibleForTesting\n+  static final String CUSTOM_MODEL_ROOT_PATH = \"com.google.firebase.ml.custom.models\";\n+\n+  private static final int INVALID_INDEX = -1;\n+  private final Context context;\n+  private final FirebaseApp firebaseApp;\n+\n+  public ModelFileManager(@NonNull FirebaseApp firebaseApp) {\n+    this.context = firebaseApp.getApplicationContext();\n+    this.firebaseApp = firebaseApp;\n+  }\n+\n+  /**\n+   * Get ModelFileDownloadService instance using the firebase app returned by {@link\n+   * FirebaseApp#getInstance()}\n+   *\n+   * @return ModelFileDownloadService\n+   */\n+  @NonNull\n+  public static ModelFileManager getInstance() {\n+    return FirebaseApp.getInstance().get(ModelFileManager.class);\n+  }\n+\n+  /**\n+   * Get the directory where the model is supposed to reside. This method does not ensure that the\n+   * directory specified does exist. If you need to ensure its existence, you should call\n+   * getDirImpl.\n+   */\n+  private @Nullable File getModelDirUnsafe(@NonNull String modelName) {\n+    String modelTypeSpecificRoot = CUSTOM_MODEL_ROOT_PATH;\n+    File root;\n+    if (VERSION.SDK_INT >= VERSION_CODES.LOLLIPOP) {\n+      root = new File(context.getNoBackupFilesDir(), modelTypeSpecificRoot);\n+    } else {\n+      root = context.getApplicationContext().getDir(modelTypeSpecificRoot, Context.MODE_PRIVATE);\n+    }\n+    File firebaseAppDir = new File(root, firebaseApp.getPersistenceKey());\n+    return new File(firebaseAppDir, modelName);\n+  }\n+\n+  /**\n+   * Gets the directory in the following schema:\n+   * app_root/model_type_specific_root/[temp]/firebase_app_persistence_key/model_name.\n+   */\n+  @VisibleForTesting\n+  @WorkerThread\n+  File getDirImpl(@NonNull String modelName) throws Exception {\n+    File modelDir = getModelDirUnsafe(modelName);\n+    if (!modelDir.exists()) {\n+      if (!modelDir.mkdirs()) {\n+        throw new Exception(\"Failed to create model folder: \" + modelDir);\n+      }\n+    } else if (!modelDir.isDirectory()) {\n+      throw new Exception(\n+          \"Can not create model folder, since an existing file has the same name: \" + modelDir);\n+    }\n+    return modelDir;\n+  }\n+\n+  /**\n+   * Since the model files under the model folder are named with numbers, and the later one is the\n+   * newer, the latest model is the file name with largest number.\n+   */\n+  @WorkerThread\n+  private int getLatestCachedModelVersion(@NonNull File modelDir) {\n+    File[] modelFiles = modelDir.listFiles();\n+    if (modelFiles == null || modelFiles.length == 0) {\n+      return INVALID_INDEX;\n+    }\n+\n+    int index = INVALID_INDEX;\n+    for (File modelFile : modelFiles) {\n+      try {\n+        index = Math.max(index, Integer.parseInt(modelFile.getName()));\n+      } catch (NumberFormatException e) {\n+        System.out.println(\"Contains non-integer file name \" + modelFile.getName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b270c4efe700860814b5078d60f38b2966934500"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDIxMzI2Ng==", "bodyText": "same", "url": "https://github.com/firebase/firebase-android-sdk/pull/2212#discussion_r534213266", "createdAt": "2020-12-02T14:34:20Z", "author": {"login": "annzimmer"}, "path": "firebase-ml-modeldownloader/src/main/java/com/google/firebase/ml/modeldownloader/internal/ModelFileManager.java", "diffHunk": "@@ -0,0 +1,165 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+package com.google.firebase.ml.modeldownloader.internal;\n+\n+import android.content.Context;\n+import android.os.Build.VERSION;\n+import android.os.Build.VERSION_CODES;\n+import android.os.ParcelFileDescriptor;\n+import android.os.ParcelFileDescriptor.AutoCloseInputStream;\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+import androidx.annotation.VisibleForTesting;\n+import androidx.annotation.WorkerThread;\n+import com.google.firebase.FirebaseApp;\n+import com.google.firebase.ml.modeldownloader.CustomModel;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+\n+/** Model File Manager is used to move the downloaded file to the appropriate locations. */\n+public class ModelFileManager {\n+\n+  @VisibleForTesting\n+  static final String CUSTOM_MODEL_ROOT_PATH = \"com.google.firebase.ml.custom.models\";\n+\n+  private static final int INVALID_INDEX = -1;\n+  private final Context context;\n+  private final FirebaseApp firebaseApp;\n+\n+  public ModelFileManager(@NonNull FirebaseApp firebaseApp) {\n+    this.context = firebaseApp.getApplicationContext();\n+    this.firebaseApp = firebaseApp;\n+  }\n+\n+  /**\n+   * Get ModelFileDownloadService instance using the firebase app returned by {@link\n+   * FirebaseApp#getInstance()}\n+   *\n+   * @return ModelFileDownloadService\n+   */\n+  @NonNull\n+  public static ModelFileManager getInstance() {\n+    return FirebaseApp.getInstance().get(ModelFileManager.class);\n+  }\n+\n+  /**\n+   * Get the directory where the model is supposed to reside. This method does not ensure that the\n+   * directory specified does exist. If you need to ensure its existence, you should call\n+   * getDirImpl.\n+   */\n+  private @Nullable File getModelDirUnsafe(@NonNull String modelName) {\n+    String modelTypeSpecificRoot = CUSTOM_MODEL_ROOT_PATH;\n+    File root;\n+    if (VERSION.SDK_INT >= VERSION_CODES.LOLLIPOP) {\n+      root = new File(context.getNoBackupFilesDir(), modelTypeSpecificRoot);\n+    } else {\n+      root = context.getApplicationContext().getDir(modelTypeSpecificRoot, Context.MODE_PRIVATE);\n+    }\n+    File firebaseAppDir = new File(root, firebaseApp.getPersistenceKey());\n+    return new File(firebaseAppDir, modelName);\n+  }\n+\n+  /**\n+   * Gets the directory in the following schema:\n+   * app_root/model_type_specific_root/[temp]/firebase_app_persistence_key/model_name.\n+   */\n+  @VisibleForTesting\n+  @WorkerThread\n+  File getDirImpl(@NonNull String modelName) throws Exception {\n+    File modelDir = getModelDirUnsafe(modelName);\n+    if (!modelDir.exists()) {\n+      if (!modelDir.mkdirs()) {\n+        throw new Exception(\"Failed to create model folder: \" + modelDir);\n+      }\n+    } else if (!modelDir.isDirectory()) {\n+      throw new Exception(\n+          \"Can not create model folder, since an existing file has the same name: \" + modelDir);\n+    }\n+    return modelDir;\n+  }\n+\n+  /**\n+   * Since the model files under the model folder are named with numbers, and the later one is the\n+   * newer, the latest model is the file name with largest number.\n+   */\n+  @WorkerThread\n+  private int getLatestCachedModelVersion(@NonNull File modelDir) {\n+    File[] modelFiles = modelDir.listFiles();\n+    if (modelFiles == null || modelFiles.length == 0) {\n+      return INVALID_INDEX;\n+    }\n+\n+    int index = INVALID_INDEX;\n+    for (File modelFile : modelFiles) {\n+      try {\n+        index = Math.max(index, Integer.parseInt(modelFile.getName()));\n+      } catch (NumberFormatException e) {\n+        System.out.println(\"Contains non-integer file name \" + modelFile.getName());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzg0OTM4NA=="}, "originalCommit": {"oid": "b270c4efe700860814b5078d60f38b2966934500"}, "originalPosition": 110}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0OTM2MjQxOnYy", "diffSide": "RIGHT", "path": "firebase-ml-modeldownloader/src/main/java/com/google/firebase/ml/modeldownloader/internal/ModelFileManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQwMjoxNDozMVrOH9Hmag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQxNDozNDoxOVrOH9dygg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzg0OTcwNg==", "bodyText": "same", "url": "https://github.com/firebase/firebase-android-sdk/pull/2212#discussion_r533849706", "createdAt": "2020-12-02T02:14:31Z", "author": {"login": "rlazo"}, "path": "firebase-ml-modeldownloader/src/main/java/com/google/firebase/ml/modeldownloader/internal/ModelFileManager.java", "diffHunk": "@@ -0,0 +1,165 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+package com.google.firebase.ml.modeldownloader.internal;\n+\n+import android.content.Context;\n+import android.os.Build.VERSION;\n+import android.os.Build.VERSION_CODES;\n+import android.os.ParcelFileDescriptor;\n+import android.os.ParcelFileDescriptor.AutoCloseInputStream;\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+import androidx.annotation.VisibleForTesting;\n+import androidx.annotation.WorkerThread;\n+import com.google.firebase.FirebaseApp;\n+import com.google.firebase.ml.modeldownloader.CustomModel;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+\n+/** Model File Manager is used to move the downloaded file to the appropriate locations. */\n+public class ModelFileManager {\n+\n+  @VisibleForTesting\n+  static final String CUSTOM_MODEL_ROOT_PATH = \"com.google.firebase.ml.custom.models\";\n+\n+  private static final int INVALID_INDEX = -1;\n+  private final Context context;\n+  private final FirebaseApp firebaseApp;\n+\n+  public ModelFileManager(@NonNull FirebaseApp firebaseApp) {\n+    this.context = firebaseApp.getApplicationContext();\n+    this.firebaseApp = firebaseApp;\n+  }\n+\n+  /**\n+   * Get ModelFileDownloadService instance using the firebase app returned by {@link\n+   * FirebaseApp#getInstance()}\n+   *\n+   * @return ModelFileDownloadService\n+   */\n+  @NonNull\n+  public static ModelFileManager getInstance() {\n+    return FirebaseApp.getInstance().get(ModelFileManager.class);\n+  }\n+\n+  /**\n+   * Get the directory where the model is supposed to reside. This method does not ensure that the\n+   * directory specified does exist. If you need to ensure its existence, you should call\n+   * getDirImpl.\n+   */\n+  private @Nullable File getModelDirUnsafe(@NonNull String modelName) {\n+    String modelTypeSpecificRoot = CUSTOM_MODEL_ROOT_PATH;\n+    File root;\n+    if (VERSION.SDK_INT >= VERSION_CODES.LOLLIPOP) {\n+      root = new File(context.getNoBackupFilesDir(), modelTypeSpecificRoot);\n+    } else {\n+      root = context.getApplicationContext().getDir(modelTypeSpecificRoot, Context.MODE_PRIVATE);\n+    }\n+    File firebaseAppDir = new File(root, firebaseApp.getPersistenceKey());\n+    return new File(firebaseAppDir, modelName);\n+  }\n+\n+  /**\n+   * Gets the directory in the following schema:\n+   * app_root/model_type_specific_root/[temp]/firebase_app_persistence_key/model_name.\n+   */\n+  @VisibleForTesting\n+  @WorkerThread\n+  File getDirImpl(@NonNull String modelName) throws Exception {\n+    File modelDir = getModelDirUnsafe(modelName);\n+    if (!modelDir.exists()) {\n+      if (!modelDir.mkdirs()) {\n+        throw new Exception(\"Failed to create model folder: \" + modelDir);\n+      }\n+    } else if (!modelDir.isDirectory()) {\n+      throw new Exception(\n+          \"Can not create model folder, since an existing file has the same name: \" + modelDir);\n+    }\n+    return modelDir;\n+  }\n+\n+  /**\n+   * Since the model files under the model folder are named with numbers, and the later one is the\n+   * newer, the latest model is the file name with largest number.\n+   */\n+  @WorkerThread\n+  private int getLatestCachedModelVersion(@NonNull File modelDir) {\n+    File[] modelFiles = modelDir.listFiles();\n+    if (modelFiles == null || modelFiles.length == 0) {\n+      return INVALID_INDEX;\n+    }\n+\n+    int index = INVALID_INDEX;\n+    for (File modelFile : modelFiles) {\n+      try {\n+        index = Math.max(index, Integer.parseInt(modelFile.getName()));\n+      } catch (NumberFormatException e) {\n+        System.out.println(\"Contains non-integer file name \" + modelFile.getName());\n+      }\n+    }\n+    return index;\n+  }\n+\n+  @VisibleForTesting\n+  @Nullable\n+  File getModelFileDestination(@NonNull CustomModel model) throws Exception {\n+    File destFolder = getDirImpl(model.getName());\n+    int index = getLatestCachedModelVersion(destFolder);\n+    return new File(destFolder, String.valueOf(index + 1));\n+  }\n+\n+  /**\n+   * Moves a downloaded file from external storage to private folder.\n+   *\n+   * <p>The private file path pattern is /%private_folder%/%firebaseapp_persistentkey%/%model_name%/\n+   *\n+   * <p>The model file under the model folder are named with numbers starting from 0. The larger one\n+   * is the newer model downloaded from cloud.\n+   *\n+   * <p>The caller is supposed to cleanup the previous downloaded files after this call, even when\n+   * this call throws exception.\n+   *\n+   * @return null if the movement failed. Otherwise, return the destination file.\n+   */\n+  @Nullable\n+  @WorkerThread\n+  public synchronized File moveModelToDestinationFolder(\n+      @NonNull CustomModel customModel, @NonNull ParcelFileDescriptor modelFileDescriptor)\n+      throws Exception {\n+    File modelFileDestination = getModelFileDestination(customModel);\n+\n+    // Moves to the final destination file in app private folder to avoid the downloaded file from\n+    // being changed by\n+    // other apps.\n+    try (FileInputStream fis = new AutoCloseInputStream(modelFileDescriptor);\n+        FileOutputStream fos = new FileOutputStream(modelFileDestination)) {\n+      byte[] buffer = new byte[4096];\n+      int read;\n+      while ((read = fis.read(buffer)) != -1) {\n+        fos.write(buffer, 0, read);\n+      }\n+      // Let's be extra sure it is all written before we return.\n+      fos.getFD().sync();\n+    } catch (IOException e) {\n+      // Failed to copy to destination - clean up.\n+      System.out.println(\"Failed to copy downloaded model file to destination folder: \" + e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b270c4efe700860814b5078d60f38b2966934500"}, "originalPosition": 158}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDIxMzI1MA==", "bodyText": "same", "url": "https://github.com/firebase/firebase-android-sdk/pull/2212#discussion_r534213250", "createdAt": "2020-12-02T14:34:19Z", "author": {"login": "annzimmer"}, "path": "firebase-ml-modeldownloader/src/main/java/com/google/firebase/ml/modeldownloader/internal/ModelFileManager.java", "diffHunk": "@@ -0,0 +1,165 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+package com.google.firebase.ml.modeldownloader.internal;\n+\n+import android.content.Context;\n+import android.os.Build.VERSION;\n+import android.os.Build.VERSION_CODES;\n+import android.os.ParcelFileDescriptor;\n+import android.os.ParcelFileDescriptor.AutoCloseInputStream;\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+import androidx.annotation.VisibleForTesting;\n+import androidx.annotation.WorkerThread;\n+import com.google.firebase.FirebaseApp;\n+import com.google.firebase.ml.modeldownloader.CustomModel;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+\n+/** Model File Manager is used to move the downloaded file to the appropriate locations. */\n+public class ModelFileManager {\n+\n+  @VisibleForTesting\n+  static final String CUSTOM_MODEL_ROOT_PATH = \"com.google.firebase.ml.custom.models\";\n+\n+  private static final int INVALID_INDEX = -1;\n+  private final Context context;\n+  private final FirebaseApp firebaseApp;\n+\n+  public ModelFileManager(@NonNull FirebaseApp firebaseApp) {\n+    this.context = firebaseApp.getApplicationContext();\n+    this.firebaseApp = firebaseApp;\n+  }\n+\n+  /**\n+   * Get ModelFileDownloadService instance using the firebase app returned by {@link\n+   * FirebaseApp#getInstance()}\n+   *\n+   * @return ModelFileDownloadService\n+   */\n+  @NonNull\n+  public static ModelFileManager getInstance() {\n+    return FirebaseApp.getInstance().get(ModelFileManager.class);\n+  }\n+\n+  /**\n+   * Get the directory where the model is supposed to reside. This method does not ensure that the\n+   * directory specified does exist. If you need to ensure its existence, you should call\n+   * getDirImpl.\n+   */\n+  private @Nullable File getModelDirUnsafe(@NonNull String modelName) {\n+    String modelTypeSpecificRoot = CUSTOM_MODEL_ROOT_PATH;\n+    File root;\n+    if (VERSION.SDK_INT >= VERSION_CODES.LOLLIPOP) {\n+      root = new File(context.getNoBackupFilesDir(), modelTypeSpecificRoot);\n+    } else {\n+      root = context.getApplicationContext().getDir(modelTypeSpecificRoot, Context.MODE_PRIVATE);\n+    }\n+    File firebaseAppDir = new File(root, firebaseApp.getPersistenceKey());\n+    return new File(firebaseAppDir, modelName);\n+  }\n+\n+  /**\n+   * Gets the directory in the following schema:\n+   * app_root/model_type_specific_root/[temp]/firebase_app_persistence_key/model_name.\n+   */\n+  @VisibleForTesting\n+  @WorkerThread\n+  File getDirImpl(@NonNull String modelName) throws Exception {\n+    File modelDir = getModelDirUnsafe(modelName);\n+    if (!modelDir.exists()) {\n+      if (!modelDir.mkdirs()) {\n+        throw new Exception(\"Failed to create model folder: \" + modelDir);\n+      }\n+    } else if (!modelDir.isDirectory()) {\n+      throw new Exception(\n+          \"Can not create model folder, since an existing file has the same name: \" + modelDir);\n+    }\n+    return modelDir;\n+  }\n+\n+  /**\n+   * Since the model files under the model folder are named with numbers, and the later one is the\n+   * newer, the latest model is the file name with largest number.\n+   */\n+  @WorkerThread\n+  private int getLatestCachedModelVersion(@NonNull File modelDir) {\n+    File[] modelFiles = modelDir.listFiles();\n+    if (modelFiles == null || modelFiles.length == 0) {\n+      return INVALID_INDEX;\n+    }\n+\n+    int index = INVALID_INDEX;\n+    for (File modelFile : modelFiles) {\n+      try {\n+        index = Math.max(index, Integer.parseInt(modelFile.getName()));\n+      } catch (NumberFormatException e) {\n+        System.out.println(\"Contains non-integer file name \" + modelFile.getName());\n+      }\n+    }\n+    return index;\n+  }\n+\n+  @VisibleForTesting\n+  @Nullable\n+  File getModelFileDestination(@NonNull CustomModel model) throws Exception {\n+    File destFolder = getDirImpl(model.getName());\n+    int index = getLatestCachedModelVersion(destFolder);\n+    return new File(destFolder, String.valueOf(index + 1));\n+  }\n+\n+  /**\n+   * Moves a downloaded file from external storage to private folder.\n+   *\n+   * <p>The private file path pattern is /%private_folder%/%firebaseapp_persistentkey%/%model_name%/\n+   *\n+   * <p>The model file under the model folder are named with numbers starting from 0. The larger one\n+   * is the newer model downloaded from cloud.\n+   *\n+   * <p>The caller is supposed to cleanup the previous downloaded files after this call, even when\n+   * this call throws exception.\n+   *\n+   * @return null if the movement failed. Otherwise, return the destination file.\n+   */\n+  @Nullable\n+  @WorkerThread\n+  public synchronized File moveModelToDestinationFolder(\n+      @NonNull CustomModel customModel, @NonNull ParcelFileDescriptor modelFileDescriptor)\n+      throws Exception {\n+    File modelFileDestination = getModelFileDestination(customModel);\n+\n+    // Moves to the final destination file in app private folder to avoid the downloaded file from\n+    // being changed by\n+    // other apps.\n+    try (FileInputStream fis = new AutoCloseInputStream(modelFileDescriptor);\n+        FileOutputStream fos = new FileOutputStream(modelFileDestination)) {\n+      byte[] buffer = new byte[4096];\n+      int read;\n+      while ((read = fis.read(buffer)) != -1) {\n+        fos.write(buffer, 0, read);\n+      }\n+      // Let's be extra sure it is all written before we return.\n+      fos.getFD().sync();\n+    } catch (IOException e) {\n+      // Failed to copy to destination - clean up.\n+      System.out.println(\"Failed to copy downloaded model file to destination folder: \" + e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzg0OTcwNg=="}, "originalCommit": {"oid": "b270c4efe700860814b5078d60f38b2966934500"}, "originalPosition": 158}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1014, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}