{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY5MjExNTQz", "number": 1182, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQxOTowNzoxN1rODcBu5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQxOToxNjoyMVrODcB5iQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwNzE1MTEwOnYy", "diffSide": "RIGHT", "path": "firebase-firestore/src/main/java/com/google/firebase/firestore/local/SQLiteSchema.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQxOTowNzoxN1rOFj2gnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQyMTo0Mjo1NlrOFj64FA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzEzNzU2NA==", "bodyText": "Dumb question: this file doesn't appear to employ a transaction anywhere. Doesn't db.execSQL auto-commit if you don't? It seems like it would be bad if this partially committed.", "url": "https://github.com/firebase/firebase-android-sdk/pull/1182#discussion_r373137564", "createdAt": "2020-01-30T19:07:17Z", "author": {"login": "wilhuff"}, "path": "firebase-firestore/src/main/java/com/google/firebase/firestore/local/SQLiteSchema.java", "diffHunk": "@@ -530,6 +537,26 @@ private boolean tableContainsColumn(String table, String column) {\n     return columns;\n   }\n \n+  private void rewriteCanonicalIds() {\n+    new SQLitePersistence.Query(db, \"SELECT target_id, target_proto FROM targets\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "062a6c1eccb63d1d779599f69c6027f6b30e7f4b"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzIwOTEwOA==", "bodyText": "The transaction is opened here: https://cs.corp.google.com/aosp-master/frameworks/base/core/java/android/database/sqlite/SQLiteOpenHelper.java?q=f:SQLiteopenhelper.java&dr&l=409\nIt will only get committed if line 421 executes.", "url": "https://github.com/firebase/firebase-android-sdk/pull/1182#discussion_r373209108", "createdAt": "2020-01-30T21:42:56Z", "author": {"login": "schmidt-sebastian"}, "path": "firebase-firestore/src/main/java/com/google/firebase/firestore/local/SQLiteSchema.java", "diffHunk": "@@ -530,6 +537,26 @@ private boolean tableContainsColumn(String table, String column) {\n     return columns;\n   }\n \n+  private void rewriteCanonicalIds() {\n+    new SQLitePersistence.Query(db, \"SELECT target_id, target_proto FROM targets\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzEzNzU2NA=="}, "originalCommit": {"oid": "062a6c1eccb63d1d779599f69c6027f6b30e7f4b"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwNzE3ODMzOnYy", "diffSide": "RIGHT", "path": "firebase-firestore/src/main/java/com/google/firebase/firestore/local/SQLiteSchema.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQxOToxNjoyMVrOFj2yJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQwMDo0MzozOVrOFj-gcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE0MjA1NQ==", "bodyText": "This migration can't be rolled back and has the potential to cause problems because target_id must be guaranteed unique (it's the primary key of the table).\nIf a user does roll back, will this actually cause a problem with duplicate target ids? I think probably not because the next target id is in target_globals and we're not changing that here, right?\nOne alternative that makes this slightly more rollback friendly would be to put the new target id in a new column and create an additional index on that column. I can't say I'm super excited about this prospect and likely would prefer to just document that this release includes a migration that can't be rolled-back from.", "url": "https://github.com/firebase/firebase-android-sdk/pull/1182#discussion_r373142055", "createdAt": "2020-01-30T19:16:21Z", "author": {"login": "wilhuff"}, "path": "firebase-firestore/src/main/java/com/google/firebase/firestore/local/SQLiteSchema.java", "diffHunk": "@@ -530,6 +537,26 @@ private boolean tableContainsColumn(String table, String column) {\n     return columns;\n   }\n \n+  private void rewriteCanonicalIds() {\n+    new SQLitePersistence.Query(db, \"SELECT target_id, target_proto FROM targets\")\n+        .forEach(\n+            cursor -> {\n+              int targetId = cursor.getInt(0);\n+              byte[] targetProtoBytes = cursor.getBlob(1);\n+\n+              try {\n+                Target targetProto = Target.parseFrom(targetProtoBytes);\n+                TargetData targetData = serializer.decodeTargetData(targetProto);\n+                String updatedCanonicalId = targetData.getTarget().getCanonicalId();\n+                db.execSQL(\n+                    \"UPDATE targets SET canonical_id  = ? WHERE target_id = ?\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "062a6c1eccb63d1d779599f69c6027f6b30e7f4b"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzIwOTkxNg==", "bodyText": "Good catch. The fix for this is actually pretty straightforward as we can always rewrite canonical IDs with the current format. The target IDs don't change and as as long the format in the schema matches the expected format at the current client version we should be safe. I modified the schema converter to support downgrades and updated the code to run this particular migration on both up- and downgrades.", "url": "https://github.com/firebase/firebase-android-sdk/pull/1182#discussion_r373209916", "createdAt": "2020-01-30T21:44:49Z", "author": {"login": "schmidt-sebastian"}, "path": "firebase-firestore/src/main/java/com/google/firebase/firestore/local/SQLiteSchema.java", "diffHunk": "@@ -530,6 +537,26 @@ private boolean tableContainsColumn(String table, String column) {\n     return columns;\n   }\n \n+  private void rewriteCanonicalIds() {\n+    new SQLitePersistence.Query(db, \"SELECT target_id, target_proto FROM targets\")\n+        .forEach(\n+            cursor -> {\n+              int targetId = cursor.getInt(0);\n+              byte[] targetProtoBytes = cursor.getBlob(1);\n+\n+              try {\n+                Target targetProto = Target.parseFrom(targetProtoBytes);\n+                TargetData targetData = serializer.decodeTargetData(targetProto);\n+                String updatedCanonicalId = targetData.getTarget().getCanonicalId();\n+                db.execSQL(\n+                    \"UPDATE targets SET canonical_id  = ? WHERE target_id = ?\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE0MjA1NQ=="}, "originalCommit": {"oid": "062a6c1eccb63d1d779599f69c6027f6b30e7f4b"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzIzNjAzMA==", "bodyText": "Hm. I just realized that the new version of the schema converter is pretty dumb. It assumes that my shiny new code is shipped to old SDKs. What do you think about submitting the PR in its original form and letting LRU GC delete stale QueryData if the user chooses to downgrade?", "url": "https://github.com/firebase/firebase-android-sdk/pull/1182#discussion_r373236030", "createdAt": "2020-01-30T22:49:11Z", "author": {"login": "schmidt-sebastian"}, "path": "firebase-firestore/src/main/java/com/google/firebase/firestore/local/SQLiteSchema.java", "diffHunk": "@@ -530,6 +537,26 @@ private boolean tableContainsColumn(String table, String column) {\n     return columns;\n   }\n \n+  private void rewriteCanonicalIds() {\n+    new SQLitePersistence.Query(db, \"SELECT target_id, target_proto FROM targets\")\n+        .forEach(\n+            cursor -> {\n+              int targetId = cursor.getInt(0);\n+              byte[] targetProtoBytes = cursor.getBlob(1);\n+\n+              try {\n+                Target targetProto = Target.parseFrom(targetProtoBytes);\n+                TargetData targetData = serializer.decodeTargetData(targetProto);\n+                String updatedCanonicalId = targetData.getTarget().getCanonicalId();\n+                db.execSQL(\n+                    \"UPDATE targets SET canonical_id  = ? WHERE target_id = ?\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE0MjA1NQ=="}, "originalCommit": {"oid": "062a6c1eccb63d1d779599f69c6027f6b30e7f4b"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI1ODYwNA==", "bodyText": "Letting LRU GC do its thing SGTM.", "url": "https://github.com/firebase/firebase-android-sdk/pull/1182#discussion_r373258604", "createdAt": "2020-01-31T00:04:00Z", "author": {"login": "wilhuff"}, "path": "firebase-firestore/src/main/java/com/google/firebase/firestore/local/SQLiteSchema.java", "diffHunk": "@@ -530,6 +537,26 @@ private boolean tableContainsColumn(String table, String column) {\n     return columns;\n   }\n \n+  private void rewriteCanonicalIds() {\n+    new SQLitePersistence.Query(db, \"SELECT target_id, target_proto FROM targets\")\n+        .forEach(\n+            cursor -> {\n+              int targetId = cursor.getInt(0);\n+              byte[] targetProtoBytes = cursor.getBlob(1);\n+\n+              try {\n+                Target targetProto = Target.parseFrom(targetProtoBytes);\n+                TargetData targetData = serializer.decodeTargetData(targetProto);\n+                String updatedCanonicalId = targetData.getTarget().getCanonicalId();\n+                db.execSQL(\n+                    \"UPDATE targets SET canonical_id  = ? WHERE target_id = ?\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE0MjA1NQ=="}, "originalCommit": {"oid": "062a6c1eccb63d1d779599f69c6027f6b30e7f4b"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI2ODU5Mw==", "bodyText": "I reverted the commit that pretended to add support for downgrades.", "url": "https://github.com/firebase/firebase-android-sdk/pull/1182#discussion_r373268593", "createdAt": "2020-01-31T00:43:39Z", "author": {"login": "schmidt-sebastian"}, "path": "firebase-firestore/src/main/java/com/google/firebase/firestore/local/SQLiteSchema.java", "diffHunk": "@@ -530,6 +537,26 @@ private boolean tableContainsColumn(String table, String column) {\n     return columns;\n   }\n \n+  private void rewriteCanonicalIds() {\n+    new SQLitePersistence.Query(db, \"SELECT target_id, target_proto FROM targets\")\n+        .forEach(\n+            cursor -> {\n+              int targetId = cursor.getInt(0);\n+              byte[] targetProtoBytes = cursor.getBlob(1);\n+\n+              try {\n+                Target targetProto = Target.parseFrom(targetProtoBytes);\n+                TargetData targetData = serializer.decodeTargetData(targetProto);\n+                String updatedCanonicalId = targetData.getTarget().getCanonicalId();\n+                db.execSQL(\n+                    \"UPDATE targets SET canonical_id  = ? WHERE target_id = ?\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE0MjA1NQ=="}, "originalCommit": {"oid": "062a6c1eccb63d1d779599f69c6027f6b30e7f4b"}, "originalPosition": 51}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 967, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}