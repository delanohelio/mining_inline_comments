{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQwMTA0NDEw", "number": 1717, "title": "Support Collections decoding", "bodyText": "", "createdAt": "2020-06-25T15:41:55Z", "url": "https://github.com/firebase/firebase-android-sdk/pull/1717", "merged": true, "mergeCommit": {"oid": "09bb8d372b542e86e1beef3afb2c915209ff6a9a"}, "closed": true, "closedAt": "2020-07-23T16:14:16Z", "author": {"login": "James201311"}, "timelineItems": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcuwjAugH2gAyNDQwMTA0NDEwOmJmMzE5ZTc5NjY2ZDk1NmU5Njc4N2JjODFlYmQ1ZTVlZWEyMjM0Mjg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc3w1iLAFqTQ1NDIyOTk5Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "bf319e79666d956e96787bc81ebd5e5eea223428", "author": {"user": null}, "url": "https://github.com/firebase/firebase-android-sdk/commit/bf319e79666d956e96787bc81ebd5e5eea223428", "committedDate": "2020-06-25T15:40:17Z", "message": "support map decoding"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM3NjI2MjU1", "url": "https://github.com/firebase/firebase-android-sdk/pull/1717#pullrequestreview-437626255", "createdAt": "2020-06-25T15:46:30Z", "commit": {"oid": "bf319e79666d956e96787bc81ebd5e5eea223428"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxNTo0NjozMFrOGpAyWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxNTo0NjozMFrOGpAyWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTY1NzY4OQ==", "bodyText": "Are there better ways to deal with Exceptions?\nor avoid using reflect?", "url": "https://github.com/firebase/firebase-android-sdk/pull/1717#discussion_r445657689", "createdAt": "2020-06-25T15:46:30Z", "author": {"login": "James201311"}, "path": "encoders/firebase-decoders-json/src/json/java/com/google/firebase/decoders/json/JsonDataDecoderBuilderContext.java", "diffHunk": "@@ -145,6 +148,83 @@\n     return null;\n   }\n \n+  private <T> boolean isPreDefinedObject(TypeToken.ClassToken<T> classToken) {\n+    Class<T> clazz = classToken.getRawType();\n+    return List.class.isAssignableFrom(clazz)\n+        || Map.class.isAssignableFrom(clazz)\n+        || Set.class.isAssignableFrom(clazz);\n+  }\n+\n+  private <T> T decodePreDefinedObject(TypeToken.ClassToken<T> classToken) throws IOException {\n+    Class<T> clazz = classToken.getRawType();\n+    if (Map.class.isAssignableFrom(clazz)) {\n+      @SuppressWarnings(\"unchecked\")\n+      T t = (T) decodeMap((TypeToken.ClassToken<Map>) classToken);\n+      return t;\n+    } else if (List.class.isAssignableFrom(clazz)) {\n+      // TODO: support List\n+    } else if (Set.class.isAssignableFrom(clazz)) {\n+      // TODO: support List\n+    }\n+    return null;\n+  }\n+\n+  private <K, V, T extends Map<K, V>> T decodeMap(TypeToken.ClassToken<T> classToken)\n+      throws IOException {\n+    TypeToken<K> keyTypeToken = classToken.getTypeArguments().at(0);\n+    TypeToken<V> valTypeToken = classToken.getTypeArguments().at(1);\n+    if (!isSingleValue(keyTypeToken))\n+      throw new IllegalArgumentException(keyTypeToken + \" cannot be used as Map key.\");\n+\n+    T map = null;\n+    try {\n+      map = classToken.getRawType().getDeclaredConstructor().newInstance();\n+    } catch (Exception e) {\n+      throw new IllegalArgumentException(\n+          classToken.getRawType()\n+              + \" cannot be initialized.\\n\"\n+              + \"Do not pass abstract class and an interface.\\n\"\n+              + e);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf319e79666d956e96787bc81ebd5e5eea223428"}, "originalPosition": 58}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9e970b341c89ba6096e2c9bb39e8114e59ba7fc1", "author": {"user": {"login": "James201311", "name": "James He"}}, "url": "https://github.com/firebase/firebase-android-sdk/commit/9e970b341c89ba6096e2c9bb39e8114e59ba7fc1", "committedDate": "2020-06-25T18:53:33Z", "message": "Merge branch 'firebase_encoders' into yizhaoh.map_decode"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "158c95f240e5ca933cfbbc0be986f75b370a5995", "author": {"user": null}, "url": "https://github.com/firebase/firebase-android-sdk/commit/158c95f240e5ca933cfbbc0be986f75b370a5995", "committedDate": "2020-06-25T19:05:15Z", "message": "put map decoding into a seperate test file"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e32b2bdef7e94f5de45982b765e7ccc84bf3d174", "author": {"user": null}, "url": "https://github.com/firebase/firebase-android-sdk/commit/e32b2bdef7e94f5de45982b765e7ccc84bf3d174", "committedDate": "2020-06-26T13:40:13Z", "message": "decode collection"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4MzA3Njkw", "url": "https://github.com/firebase/firebase-android-sdk/pull/1717#pullrequestreview-438307690", "createdAt": "2020-06-26T13:44:46Z", "commit": {"oid": "e32b2bdef7e94f5de45982b765e7ccc84bf3d174"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxMzo0NDo0NlrOGphdlg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxMzo0NDo0NlrOGphdlg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjE5MzA0Ng==", "bodyText": "same as above", "url": "https://github.com/firebase/firebase-android-sdk/pull/1717#discussion_r446193046", "createdAt": "2020-06-26T13:44:46Z", "author": {"login": "James201311"}, "path": "encoders/firebase-decoders-json/src/json/java/com/google/firebase/decoders/json/JsonDataDecoderBuilderContext.java", "diffHunk": "@@ -145,6 +148,101 @@\n     return null;\n   }\n \n+  private <T> boolean isPreDefinedObject(TypeToken.ClassToken<T> classToken) {\n+    Class<T> clazz = classToken.getRawType();\n+    return Collection.class.isAssignableFrom(clazz) || Map.class.isAssignableFrom(clazz);\n+  }\n+\n+  private <T> T decodePreDefinedObject(TypeToken.ClassToken<T> classToken) throws IOException {\n+    Class<T> clazz = classToken.getRawType();\n+    if (Map.class.isAssignableFrom(clazz)) {\n+      @SuppressWarnings(\"unchecked\")\n+      T t = (T) decodeMap((TypeToken.ClassToken<Map>) classToken);\n+      return t;\n+    } else {\n+      @SuppressWarnings(\"unchecked\")\n+      T t = (T) decodeCollection((TypeToken.ClassToken<Collection>) classToken);\n+      return t;\n+    }\n+  }\n+\n+  private <K, V, T extends Map<K, V>> T decodeMap(TypeToken.ClassToken<T> classToken)\n+      throws IOException {\n+    TypeToken<K> keyTypeToken = classToken.getTypeArguments().at(0);\n+    TypeToken<V> valTypeToken = classToken.getTypeArguments().at(1);\n+    if (!isSingleValue(keyTypeToken))\n+      throw new IllegalArgumentException(keyTypeToken + \" cannot be used as Map key.\");\n+\n+    T map = null;\n+    try {\n+      map = classToken.getRawType().getDeclaredConstructor().newInstance();\n+    } catch (Exception e) {\n+      throw new IllegalArgumentException(\n+          classToken.getRawType()\n+              + \" cannot be initialized.\\n\"\n+              + \"Do not pass abstract class and an interface.\\n\"\n+              + e);\n+    }\n+\n+    reader.beginObject();\n+    while (reader.hasNext()) {\n+      String keyLiteral = reader.nextName();\n+      K key = getActualKey(keyLiteral, keyTypeToken.getRawType());\n+      V val = decode(valTypeToken);\n+      V replaced = map.put(key, val);\n+      if (replaced != null) {\n+        throw new IllegalArgumentException(\"duplicate key: \" + key);\n+      }\n+    }\n+    reader.endObject();\n+\n+    return map;\n+  }\n+\n+  private <E, T extends Collection<E>> T decodeCollection(TypeToken.ClassToken<T> classToken)\n+      throws IOException {\n+    TypeToken<E> componentTypeToken = classToken.getTypeArguments().at(0);\n+    T collection = null;\n+    try {\n+      collection = classToken.getRawType().getDeclaredConstructor().newInstance();\n+    } catch (Exception e) {\n+      throw new IllegalArgumentException(\n+          classToken.getRawType()\n+              + \" cannot be initialized.\\n\"\n+              + \"Do not pass abstract class and an interface.\\n\"\n+              + e);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e32b2bdef7e94f5de45982b765e7ccc84bf3d174"}, "originalPosition": 84}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM5MjE2NjEz", "url": "https://github.com/firebase/firebase-android-sdk/pull/1717#pullrequestreview-439216613", "createdAt": "2020-06-29T14:44:00Z", "commit": {"oid": "e32b2bdef7e94f5de45982b765e7ccc84bf3d174"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a83522134cc3908e71c6564dbfa0e572f942da33", "author": {"user": null}, "url": "https://github.com/firebase/firebase-android-sdk/commit/a83522134cc3908e71c6564dbfa0e572f942da33", "committedDate": "2020-06-29T18:08:16Z", "message": "remove reflect, implement newInstance method to create supported type"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwMjIwNjEx", "url": "https://github.com/firebase/firebase-android-sdk/pull/1717#pullrequestreview-440220611", "createdAt": "2020-06-30T17:07:33Z", "commit": {"oid": "a83522134cc3908e71c6564dbfa0e572f942da33"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNzowNzozM1rOGrGRWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNzowOTo1OVrOGrGXWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg0NDY5Nw==", "bodyText": "Consider throwing EncodingException instead as this is the exception we advertise can be thrown.", "url": "https://github.com/firebase/firebase-android-sdk/pull/1717#discussion_r447844697", "createdAt": "2020-06-30T17:07:33Z", "author": {"login": "vkryachko"}, "path": "encoders/firebase-decoders-json/src/json/java/com/google/firebase/decoders/json/JsonDataDecoderBuilderContext.java", "diffHunk": "@@ -145,6 +160,109 @@\n     return null;\n   }\n \n+  private <T> boolean isPreDefinedObject(TypeToken.ClassToken<T> classToken) {\n+    Class<T> clazz = classToken.getRawType();\n+    return Collection.class.isAssignableFrom(clazz) || Map.class.isAssignableFrom(clazz);\n+  }\n+\n+  private <T> T decodePreDefinedObject(TypeToken.ClassToken<T> classToken) throws IOException {\n+    Class<T> clazz = classToken.getRawType();\n+    if (Map.class.isAssignableFrom(clazz)) {\n+      @SuppressWarnings(\"unchecked\")\n+      T t = (T) decodeMap((TypeToken.ClassToken<Map>) classToken);\n+      return t;\n+    } else {\n+      @SuppressWarnings(\"unchecked\")\n+      T t = (T) decodeCollection((TypeToken.ClassToken<Collection>) classToken);\n+      return t;\n+    }\n+  }\n+\n+  private <K, V, T extends Map<K, V>> T decodeMap(TypeToken.ClassToken<T> classToken)\n+      throws IOException {\n+    TypeToken<K> keyTypeToken = classToken.getTypeArguments().at(0);\n+    TypeToken<V> valTypeToken = classToken.getTypeArguments().at(1);\n+    if (!isSingleValue(keyTypeToken))\n+      throw new IllegalArgumentException(keyTypeToken + \" cannot be used as Map key.\");\n+\n+    T map = newInstance(classToken);\n+    reader.beginObject();\n+    while (reader.hasNext()) {\n+      String keyLiteral = reader.nextName();\n+      K key = getActualKey(keyLiteral, keyTypeToken.getRawType());\n+      V val = decode(valTypeToken);\n+      V replaced = map.put(key, val);\n+      if (replaced != null) {\n+        throw new IllegalArgumentException(\"duplicate key: \" + key);\n+      }\n+    }\n+    reader.endObject();\n+\n+    return map;\n+  }\n+\n+  private <E, T extends Collection<E>> T decodeCollection(TypeToken.ClassToken<T> classToken)\n+      throws IOException {\n+    TypeToken<E> componentTypeToken = classToken.getTypeArguments().at(0);\n+    T collection = newInstance(classToken);\n+    reader.beginArray();\n+    while (reader.hasNext()) {\n+      collection.add(decode(componentTypeToken));\n+    }\n+    reader.endArray();\n+    return collection;\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private <T> T newInstance(TypeToken.ClassToken<T> classToken) {\n+    Class<T> clazz = classToken.getRawType();\n+    if (clazz.equals(HashMap.class) || clazz.equals(Map.class)) {\n+      return (T) new HashMap<>();\n+    } else if (clazz.equals(LinkedHashMap.class)) {\n+      return (T) new LinkedHashMap<>();\n+    } else if (clazz.equals(TreeMap.class) || clazz.equals(SortedMap.class)) {\n+      return (T) new TreeMap<>();\n+    } else if (clazz.equals(ArrayList.class) || clazz.equals(List.class)) {\n+      return (T) new ArrayList<>();\n+    } else if (clazz.equals(ArrayDeque.class)\n+        || clazz.equals(Deque.class)\n+        || clazz.equals(Queue.class)) {\n+      return (T) new ArrayDeque<>();\n+    } else if (clazz.equals(PriorityQueue.class)) {\n+      return (T) new PriorityQueue<>();\n+    } else if (clazz.equals(HashSet.class) || clazz.equals(Set.class)) {\n+      return (T) new HashSet<>();\n+    } else if (clazz.equals(LinkedHashSet.class)) {\n+      return (T) new LinkedHashSet<>();\n+    } else if (clazz.equals(TreeSet.class) || clazz.equals(SortedSet.class)) {\n+      return (T) new TreeSet<>();\n+    }\n+    throw new IllegalArgumentException(classToken + \" not supported.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a83522134cc3908e71c6564dbfa0e572f942da33"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg0NjIzMw==", "bodyText": "Not sure how useful these are in the context of DTOs so we may want to remove them not to encourage folks to model queues with their json payloads, but I don't feel strongly.\nSame for priority queue below.", "url": "https://github.com/firebase/firebase-android-sdk/pull/1717#discussion_r447846233", "createdAt": "2020-06-30T17:09:59Z", "author": {"login": "vkryachko"}, "path": "encoders/firebase-decoders-json/src/json/java/com/google/firebase/decoders/json/JsonDataDecoderBuilderContext.java", "diffHunk": "@@ -145,6 +160,109 @@\n     return null;\n   }\n \n+  private <T> boolean isPreDefinedObject(TypeToken.ClassToken<T> classToken) {\n+    Class<T> clazz = classToken.getRawType();\n+    return Collection.class.isAssignableFrom(clazz) || Map.class.isAssignableFrom(clazz);\n+  }\n+\n+  private <T> T decodePreDefinedObject(TypeToken.ClassToken<T> classToken) throws IOException {\n+    Class<T> clazz = classToken.getRawType();\n+    if (Map.class.isAssignableFrom(clazz)) {\n+      @SuppressWarnings(\"unchecked\")\n+      T t = (T) decodeMap((TypeToken.ClassToken<Map>) classToken);\n+      return t;\n+    } else {\n+      @SuppressWarnings(\"unchecked\")\n+      T t = (T) decodeCollection((TypeToken.ClassToken<Collection>) classToken);\n+      return t;\n+    }\n+  }\n+\n+  private <K, V, T extends Map<K, V>> T decodeMap(TypeToken.ClassToken<T> classToken)\n+      throws IOException {\n+    TypeToken<K> keyTypeToken = classToken.getTypeArguments().at(0);\n+    TypeToken<V> valTypeToken = classToken.getTypeArguments().at(1);\n+    if (!isSingleValue(keyTypeToken))\n+      throw new IllegalArgumentException(keyTypeToken + \" cannot be used as Map key.\");\n+\n+    T map = newInstance(classToken);\n+    reader.beginObject();\n+    while (reader.hasNext()) {\n+      String keyLiteral = reader.nextName();\n+      K key = getActualKey(keyLiteral, keyTypeToken.getRawType());\n+      V val = decode(valTypeToken);\n+      V replaced = map.put(key, val);\n+      if (replaced != null) {\n+        throw new IllegalArgumentException(\"duplicate key: \" + key);\n+      }\n+    }\n+    reader.endObject();\n+\n+    return map;\n+  }\n+\n+  private <E, T extends Collection<E>> T decodeCollection(TypeToken.ClassToken<T> classToken)\n+      throws IOException {\n+    TypeToken<E> componentTypeToken = classToken.getTypeArguments().at(0);\n+    T collection = newInstance(classToken);\n+    reader.beginArray();\n+    while (reader.hasNext()) {\n+      collection.add(decode(componentTypeToken));\n+    }\n+    reader.endArray();\n+    return collection;\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private <T> T newInstance(TypeToken.ClassToken<T> classToken) {\n+    Class<T> clazz = classToken.getRawType();\n+    if (clazz.equals(HashMap.class) || clazz.equals(Map.class)) {\n+      return (T) new HashMap<>();\n+    } else if (clazz.equals(LinkedHashMap.class)) {\n+      return (T) new LinkedHashMap<>();\n+    } else if (clazz.equals(TreeMap.class) || clazz.equals(SortedMap.class)) {\n+      return (T) new TreeMap<>();\n+    } else if (clazz.equals(ArrayList.class) || clazz.equals(List.class)) {\n+      return (T) new ArrayList<>();\n+    } else if (clazz.equals(ArrayDeque.class)\n+        || clazz.equals(Deque.class)\n+        || clazz.equals(Queue.class)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a83522134cc3908e71c6564dbfa0e572f942da33"}, "originalPosition": 103}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQyNDY1MzQ3", "url": "https://github.com/firebase/firebase-android-sdk/pull/1717#pullrequestreview-442465347", "createdAt": "2020-07-03T15:00:08Z", "commit": {"oid": "a83522134cc3908e71c6564dbfa0e572f942da33"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxNTowMDowOFrOGsy25Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxNTowMjoxNlrOGsy6bw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTYyMzc4MQ==", "bodyText": "Looks like these 2 methods do more than one thing, consider splitting their functionality in to map and collection specific stuff, context: https://en.wikipedia.org/wiki/Single-responsibility_principle", "url": "https://github.com/firebase/firebase-android-sdk/pull/1717#discussion_r449623781", "createdAt": "2020-07-03T15:00:08Z", "author": {"login": "vkryachko"}, "path": "encoders/firebase-decoders-json/src/json/java/com/google/firebase/decoders/json/JsonDataDecoderBuilderContext.java", "diffHunk": "@@ -67,6 +80,8 @@\n       return decodePrimitive(classToken);\n     } else if (isSingleValue(classToken)) {\n       return decodeSingleValue(classToken);\n+    } else if (isPreDefinedObject(classToken)) {\n+      return decodePreDefinedObject(classToken);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a83522134cc3908e71c6564dbfa0e572f942da33"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTYyNDE1OQ==", "bodyText": "Same here, I would suggest you have 2 methods newMap, newCollection", "url": "https://github.com/firebase/firebase-android-sdk/pull/1717#discussion_r449624159", "createdAt": "2020-07-03T15:00:58Z", "author": {"login": "vkryachko"}, "path": "encoders/firebase-decoders-json/src/json/java/com/google/firebase/decoders/json/JsonDataDecoderBuilderContext.java", "diffHunk": "@@ -145,6 +160,109 @@\n     return null;\n   }\n \n+  private <T> boolean isPreDefinedObject(TypeToken.ClassToken<T> classToken) {\n+    Class<T> clazz = classToken.getRawType();\n+    return Collection.class.isAssignableFrom(clazz) || Map.class.isAssignableFrom(clazz);\n+  }\n+\n+  private <T> T decodePreDefinedObject(TypeToken.ClassToken<T> classToken) throws IOException {\n+    Class<T> clazz = classToken.getRawType();\n+    if (Map.class.isAssignableFrom(clazz)) {\n+      @SuppressWarnings(\"unchecked\")\n+      T t = (T) decodeMap((TypeToken.ClassToken<Map>) classToken);\n+      return t;\n+    } else {\n+      @SuppressWarnings(\"unchecked\")\n+      T t = (T) decodeCollection((TypeToken.ClassToken<Collection>) classToken);\n+      return t;\n+    }\n+  }\n+\n+  private <K, V, T extends Map<K, V>> T decodeMap(TypeToken.ClassToken<T> classToken)\n+      throws IOException {\n+    TypeToken<K> keyTypeToken = classToken.getTypeArguments().at(0);\n+    TypeToken<V> valTypeToken = classToken.getTypeArguments().at(1);\n+    if (!isSingleValue(keyTypeToken))\n+      throw new IllegalArgumentException(keyTypeToken + \" cannot be used as Map key.\");\n+\n+    T map = newInstance(classToken);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a83522134cc3908e71c6564dbfa0e572f942da33"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTYyNDQ5NQ==", "bodyText": "makes sense", "url": "https://github.com/firebase/firebase-android-sdk/pull/1717#discussion_r449624495", "createdAt": "2020-07-03T15:01:47Z", "author": {"login": "vkryachko"}, "path": "encoders/firebase-decoders-json/src/json/java/com/google/firebase/decoders/json/JsonDataDecoderBuilderContext.java", "diffHunk": "@@ -145,6 +160,109 @@\n     return null;\n   }\n \n+  private <T> boolean isPreDefinedObject(TypeToken.ClassToken<T> classToken) {\n+    Class<T> clazz = classToken.getRawType();\n+    return Collection.class.isAssignableFrom(clazz) || Map.class.isAssignableFrom(clazz);\n+  }\n+\n+  private <T> T decodePreDefinedObject(TypeToken.ClassToken<T> classToken) throws IOException {\n+    Class<T> clazz = classToken.getRawType();\n+    if (Map.class.isAssignableFrom(clazz)) {\n+      @SuppressWarnings(\"unchecked\")\n+      T t = (T) decodeMap((TypeToken.ClassToken<Map>) classToken);\n+      return t;\n+    } else {\n+      @SuppressWarnings(\"unchecked\")\n+      T t = (T) decodeCollection((TypeToken.ClassToken<Collection>) classToken);\n+      return t;\n+    }\n+  }\n+\n+  private <K, V, T extends Map<K, V>> T decodeMap(TypeToken.ClassToken<T> classToken)\n+      throws IOException {\n+    TypeToken<K> keyTypeToken = classToken.getTypeArguments().at(0);\n+    TypeToken<V> valTypeToken = classToken.getTypeArguments().at(1);\n+    if (!isSingleValue(keyTypeToken))\n+      throw new IllegalArgumentException(keyTypeToken + \" cannot be used as Map key.\");\n+\n+    T map = newInstance(classToken);\n+    reader.beginObject();\n+    while (reader.hasNext()) {\n+      String keyLiteral = reader.nextName();\n+      K key = getActualKey(keyLiteral, keyTypeToken.getRawType());\n+      V val = decode(valTypeToken);\n+      V replaced = map.put(key, val);\n+      if (replaced != null) {\n+        throw new IllegalArgumentException(\"duplicate key: \" + key);\n+      }\n+    }\n+    reader.endObject();\n+\n+    return map;\n+  }\n+\n+  private <E, T extends Collection<E>> T decodeCollection(TypeToken.ClassToken<T> classToken)\n+      throws IOException {\n+    TypeToken<E> componentTypeToken = classToken.getTypeArguments().at(0);\n+    T collection = newInstance(classToken);\n+    reader.beginArray();\n+    while (reader.hasNext()) {\n+      collection.add(decode(componentTypeToken));\n+    }\n+    reader.endArray();\n+    return collection;\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private <T> T newInstance(TypeToken.ClassToken<T> classToken) {\n+    Class<T> clazz = classToken.getRawType();\n+    if (clazz.equals(HashMap.class) || clazz.equals(Map.class)) {\n+      return (T) new HashMap<>();\n+    } else if (clazz.equals(LinkedHashMap.class)) {\n+      return (T) new LinkedHashMap<>();\n+    } else if (clazz.equals(TreeMap.class) || clazz.equals(SortedMap.class)) {\n+      return (T) new TreeMap<>();\n+    } else if (clazz.equals(ArrayList.class) || clazz.equals(List.class)) {\n+      return (T) new ArrayList<>();\n+    } else if (clazz.equals(ArrayDeque.class)\n+        || clazz.equals(Deque.class)\n+        || clazz.equals(Queue.class)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg0NjIzMw=="}, "originalCommit": {"oid": "a83522134cc3908e71c6564dbfa0e572f942da33"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTYyNDY4Nw==", "bodyText": "EncodingException", "url": "https://github.com/firebase/firebase-android-sdk/pull/1717#discussion_r449624687", "createdAt": "2020-07-03T15:02:16Z", "author": {"login": "vkryachko"}, "path": "encoders/firebase-decoders-json/src/json/java/com/google/firebase/decoders/json/JsonDataDecoderBuilderContext.java", "diffHunk": "@@ -145,6 +160,109 @@\n     return null;\n   }\n \n+  private <T> boolean isPreDefinedObject(TypeToken.ClassToken<T> classToken) {\n+    Class<T> clazz = classToken.getRawType();\n+    return Collection.class.isAssignableFrom(clazz) || Map.class.isAssignableFrom(clazz);\n+  }\n+\n+  private <T> T decodePreDefinedObject(TypeToken.ClassToken<T> classToken) throws IOException {\n+    Class<T> clazz = classToken.getRawType();\n+    if (Map.class.isAssignableFrom(clazz)) {\n+      @SuppressWarnings(\"unchecked\")\n+      T t = (T) decodeMap((TypeToken.ClassToken<Map>) classToken);\n+      return t;\n+    } else {\n+      @SuppressWarnings(\"unchecked\")\n+      T t = (T) decodeCollection((TypeToken.ClassToken<Collection>) classToken);\n+      return t;\n+    }\n+  }\n+\n+  private <K, V, T extends Map<K, V>> T decodeMap(TypeToken.ClassToken<T> classToken)\n+      throws IOException {\n+    TypeToken<K> keyTypeToken = classToken.getTypeArguments().at(0);\n+    TypeToken<V> valTypeToken = classToken.getTypeArguments().at(1);\n+    if (!isSingleValue(keyTypeToken))\n+      throw new IllegalArgumentException(keyTypeToken + \" cannot be used as Map key.\");\n+\n+    T map = newInstance(classToken);\n+    reader.beginObject();\n+    while (reader.hasNext()) {\n+      String keyLiteral = reader.nextName();\n+      K key = getActualKey(keyLiteral, keyTypeToken.getRawType());\n+      V val = decode(valTypeToken);\n+      V replaced = map.put(key, val);\n+      if (replaced != null) {\n+        throw new IllegalArgumentException(\"duplicate key: \" + key);\n+      }\n+    }\n+    reader.endObject();\n+\n+    return map;\n+  }\n+\n+  private <E, T extends Collection<E>> T decodeCollection(TypeToken.ClassToken<T> classToken)\n+      throws IOException {\n+    TypeToken<E> componentTypeToken = classToken.getTypeArguments().at(0);\n+    T collection = newInstance(classToken);\n+    reader.beginArray();\n+    while (reader.hasNext()) {\n+      collection.add(decode(componentTypeToken));\n+    }\n+    reader.endArray();\n+    return collection;\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private <T> T newInstance(TypeToken.ClassToken<T> classToken) {\n+    Class<T> clazz = classToken.getRawType();\n+    if (clazz.equals(HashMap.class) || clazz.equals(Map.class)) {\n+      return (T) new HashMap<>();\n+    } else if (clazz.equals(LinkedHashMap.class)) {\n+      return (T) new LinkedHashMap<>();\n+    } else if (clazz.equals(TreeMap.class) || clazz.equals(SortedMap.class)) {\n+      return (T) new TreeMap<>();\n+    } else if (clazz.equals(ArrayList.class) || clazz.equals(List.class)) {\n+      return (T) new ArrayList<>();\n+    } else if (clazz.equals(ArrayDeque.class)\n+        || clazz.equals(Deque.class)\n+        || clazz.equals(Queue.class)) {\n+      return (T) new ArrayDeque<>();\n+    } else if (clazz.equals(PriorityQueue.class)) {\n+      return (T) new PriorityQueue<>();\n+    } else if (clazz.equals(HashSet.class) || clazz.equals(Set.class)) {\n+      return (T) new HashSet<>();\n+    } else if (clazz.equals(LinkedHashSet.class)) {\n+      return (T) new LinkedHashSet<>();\n+    } else if (clazz.equals(TreeSet.class) || clazz.equals(SortedSet.class)) {\n+      return (T) new TreeSet<>();\n+    }\n+    throw new IllegalArgumentException(classToken + \" not supported.\");\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private <K> K getActualKey(String keyLiteral, Class<K> clazz) {\n+    if (clazz.equals(Integer.class)) {\n+      return (K) (Integer) Integer.parseInt(keyLiteral);\n+    } else if (clazz.equals(Double.class)) {\n+      return (K) (Double) Double.parseDouble(keyLiteral);\n+    } else if (clazz.equals(Float.class)) {\n+      return (K) (Float) Float.parseFloat(keyLiteral);\n+    } else if (clazz.equals(Short.class)) {\n+      return (K) (Short) Short.parseShort(keyLiteral);\n+    } else if (clazz.equals(Long.class)) {\n+      return (K) (Long) Long.parseLong(keyLiteral);\n+    } else if (clazz.equals(Character.class)) {\n+      return (K) (Character) keyLiteral.charAt(0);\n+    } else if (clazz.equals(Byte.class)) {\n+      return (K) (Byte) Byte.parseByte(keyLiteral);\n+    } else if (clazz.equals(String.class)) {\n+      return (K) keyLiteral;\n+    } else {\n+      throw new IllegalArgumentException(\"Excepted Single Value Type. \" + clazz + \" was found.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a83522134cc3908e71c6564dbfa0e572f942da33"}, "originalPosition": 136}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "951637cb03f284fd0726ef89b42ca03cbbe9fbe2", "author": {"user": null}, "url": "https://github.com/firebase/firebase-android-sdk/commit/951637cb03f284fd0726ef89b42ca03cbbe9fbe2", "committedDate": "2020-07-06T14:15:03Z", "message": "address comment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "91d72db9b35a68e12a9b54c71ce38b53d26edc7e", "author": {"user": null}, "url": "https://github.com/firebase/firebase-android-sdk/commit/91d72db9b35a68e12a9b54c71ce38b53d26edc7e", "committedDate": "2020-07-23T14:47:13Z", "message": "address comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0MjI5OTky", "url": "https://github.com/firebase/firebase-android-sdk/pull/1717#pullrequestreview-454229992", "createdAt": "2020-07-23T15:05:50Z", "commit": {"oid": "91d72db9b35a68e12a9b54c71ce38b53d26edc7e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2568, "cost": 1, "resetAt": "2021-11-01T14:20:25Z"}}}