{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgzMTUwMzUz", "number": 1310, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QyMTozNzowM1rODk0xgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwMDo1NTo1NlrODk3wAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5OTM5OTcwOnYy", "diffSide": "RIGHT", "path": "firebase-crashlytics/src/main/java/com/google/firebase/crashlytics/core/CrashlyticsController.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QyMTozNzowM1rOFxXaZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QyMTozNzowM1rOFxXaZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMwODEzNA==", "bodyText": "Can we make the 2000 a constant?", "url": "https://github.com/firebase/firebase-android-sdk/pull/1310#discussion_r387308134", "createdAt": "2020-03-03T21:37:03Z", "author": {"login": "mrwillis21"}, "path": "firebase-crashlytics/src/main/java/com/google/firebase/crashlytics/core/CrashlyticsController.java", "diffHunk": "@@ -1748,26 +1752,84 @@ private void sendSessionReports(AppSettingsData appSettings, boolean dataCollect\n     }\n   }\n \n-  private void recordFatalFirebaseEvent(long timestamp) {\n-    if (firebaseCrashExists()) {\n+  /**\n+   * Helper class that listens for Crashlytics origin events from FA and provides a method to block\n+   * while waiting for a Crash event to occur. The implementation assumes there can be at most ONE\n+   * app exception event being processed and waited upon at a time.\n+   */\n+  private static class BlockingCrashEventListener\n+      implements AnalyticsReceiver.CrashlyticsOriginEventListener {\n+\n+    private final CountDownLatch eventLatch = new CountDownLatch(1);\n+\n+    public void awaitEvent() throws InterruptedException {\n       Logger.getLogger()\n-          .d(Logger.TAG, \"Skipping logging Crashlytics event to Firebase, FirebaseCrash exists\");\n-      return;\n+          .d(Logger.TAG, \"Background thread awaiting crash event callback from FA...\");\n+\n+      if (eventLatch.await(2000, TimeUnit.MILLISECONDS)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a24cfa9e0398375bb2ccd6c8a0690c9138d2f700"}, "originalPosition": 124}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5OTQwMzI0OnYy", "diffSide": "RIGHT", "path": "firebase-crashlytics/src/main/java/com/google/firebase/crashlytics/core/CrashlyticsController.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QyMTozODowOFrOFxXclQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QyMjo0ODozOVrOFxZeHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMwODY5Mw==", "bodyText": "Should this be onClxOrigin?", "url": "https://github.com/firebase/firebase-android-sdk/pull/1310#discussion_r387308693", "createdAt": "2020-03-03T21:38:08Z", "author": {"login": "mrwillis21"}, "path": "firebase-crashlytics/src/main/java/com/google/firebase/crashlytics/core/CrashlyticsController.java", "diffHunk": "@@ -1748,26 +1752,84 @@ private void sendSessionReports(AppSettingsData appSettings, boolean dataCollect\n     }\n   }\n \n-  private void recordFatalFirebaseEvent(long timestamp) {\n-    if (firebaseCrashExists()) {\n+  /**\n+   * Helper class that listens for Crashlytics origin events from FA and provides a method to block\n+   * while waiting for a Crash event to occur. The implementation assumes there can be at most ONE\n+   * app exception event being processed and waited upon at a time.\n+   */\n+  private static class BlockingCrashEventListener\n+      implements AnalyticsReceiver.CrashlyticsOriginEventListener {\n+\n+    private final CountDownLatch eventLatch = new CountDownLatch(1);\n+\n+    public void awaitEvent() throws InterruptedException {\n       Logger.getLogger()\n-          .d(Logger.TAG, \"Skipping logging Crashlytics event to Firebase, FirebaseCrash exists\");\n-      return;\n+          .d(Logger.TAG, \"Background thread awaiting crash event callback from FA...\");\n+\n+      if (eventLatch.await(2000, TimeUnit.MILLISECONDS)) {\n+        Logger.getLogger().d(Logger.TAG, \"Crash event callback received from FA listener.\");\n+      } else {\n+        Logger.getLogger()\n+            .d(\n+                Logger.TAG,\n+                \"Timeout exceeded while awaiting crash event callback from FA listener.\");\n+      }\n     }\n \n-    if (analyticsConnector != null) {\n-      Logger.getLogger().d(Logger.TAG, \"Logging Crashlytics event to Firebase\");\n-      final Bundle params = new Bundle();\n-      params.putInt(FIREBASE_CRASH_TYPE, FIREBASE_CRASH_TYPE_FATAL);\n-      params.putLong(FIREBASE_TIMESTAMP, timestamp);\n-      analyticsConnector.logEvent(\n-          FIREBASE_ANALYTICS_ORIGIN_CRASHLYTICS, FIREBASE_APPLICATION_EXCEPTION, params);\n-    } else {\n-      Logger.getLogger()\n-          .d(Logger.TAG, \"Skipping logging Crashlytics event to Firebase, no Firebase Analytics\");\n+    @Override\n+    public void onCrashOriginEvent(int id, Bundle extras) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a24cfa9e0398375bb2ccd6c8a0690c9138d2f700"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMzNzY2NA==", "bodyText": "Probably onCrashlyticsOrigin. cls is an implementation detail. I'll update.", "url": "https://github.com/firebase/firebase-android-sdk/pull/1310#discussion_r387337664", "createdAt": "2020-03-03T22:38:54Z", "author": {"login": "mrichards"}, "path": "firebase-crashlytics/src/main/java/com/google/firebase/crashlytics/core/CrashlyticsController.java", "diffHunk": "@@ -1748,26 +1752,84 @@ private void sendSessionReports(AppSettingsData appSettings, boolean dataCollect\n     }\n   }\n \n-  private void recordFatalFirebaseEvent(long timestamp) {\n-    if (firebaseCrashExists()) {\n+  /**\n+   * Helper class that listens for Crashlytics origin events from FA and provides a method to block\n+   * while waiting for a Crash event to occur. The implementation assumes there can be at most ONE\n+   * app exception event being processed and waited upon at a time.\n+   */\n+  private static class BlockingCrashEventListener\n+      implements AnalyticsReceiver.CrashlyticsOriginEventListener {\n+\n+    private final CountDownLatch eventLatch = new CountDownLatch(1);\n+\n+    public void awaitEvent() throws InterruptedException {\n       Logger.getLogger()\n-          .d(Logger.TAG, \"Skipping logging Crashlytics event to Firebase, FirebaseCrash exists\");\n-      return;\n+          .d(Logger.TAG, \"Background thread awaiting crash event callback from FA...\");\n+\n+      if (eventLatch.await(2000, TimeUnit.MILLISECONDS)) {\n+        Logger.getLogger().d(Logger.TAG, \"Crash event callback received from FA listener.\");\n+      } else {\n+        Logger.getLogger()\n+            .d(\n+                Logger.TAG,\n+                \"Timeout exceeded while awaiting crash event callback from FA listener.\");\n+      }\n     }\n \n-    if (analyticsConnector != null) {\n-      Logger.getLogger().d(Logger.TAG, \"Logging Crashlytics event to Firebase\");\n-      final Bundle params = new Bundle();\n-      params.putInt(FIREBASE_CRASH_TYPE, FIREBASE_CRASH_TYPE_FATAL);\n-      params.putLong(FIREBASE_TIMESTAMP, timestamp);\n-      analyticsConnector.logEvent(\n-          FIREBASE_ANALYTICS_ORIGIN_CRASHLYTICS, FIREBASE_APPLICATION_EXCEPTION, params);\n-    } else {\n-      Logger.getLogger()\n-          .d(Logger.TAG, \"Skipping logging Crashlytics event to Firebase, no Firebase Analytics\");\n+    @Override\n+    public void onCrashOriginEvent(int id, Bundle extras) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMwODY5Mw=="}, "originalCommit": {"oid": "a24cfa9e0398375bb2ccd6c8a0690c9138d2f700"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzM0MTg1Mg==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/firebase/firebase-android-sdk/pull/1310#discussion_r387341852", "createdAt": "2020-03-03T22:48:39Z", "author": {"login": "mrwillis21"}, "path": "firebase-crashlytics/src/main/java/com/google/firebase/crashlytics/core/CrashlyticsController.java", "diffHunk": "@@ -1748,26 +1752,84 @@ private void sendSessionReports(AppSettingsData appSettings, boolean dataCollect\n     }\n   }\n \n-  private void recordFatalFirebaseEvent(long timestamp) {\n-    if (firebaseCrashExists()) {\n+  /**\n+   * Helper class that listens for Crashlytics origin events from FA and provides a method to block\n+   * while waiting for a Crash event to occur. The implementation assumes there can be at most ONE\n+   * app exception event being processed and waited upon at a time.\n+   */\n+  private static class BlockingCrashEventListener\n+      implements AnalyticsReceiver.CrashlyticsOriginEventListener {\n+\n+    private final CountDownLatch eventLatch = new CountDownLatch(1);\n+\n+    public void awaitEvent() throws InterruptedException {\n       Logger.getLogger()\n-          .d(Logger.TAG, \"Skipping logging Crashlytics event to Firebase, FirebaseCrash exists\");\n-      return;\n+          .d(Logger.TAG, \"Background thread awaiting crash event callback from FA...\");\n+\n+      if (eventLatch.await(2000, TimeUnit.MILLISECONDS)) {\n+        Logger.getLogger().d(Logger.TAG, \"Crash event callback received from FA listener.\");\n+      } else {\n+        Logger.getLogger()\n+            .d(\n+                Logger.TAG,\n+                \"Timeout exceeded while awaiting crash event callback from FA listener.\");\n+      }\n     }\n \n-    if (analyticsConnector != null) {\n-      Logger.getLogger().d(Logger.TAG, \"Logging Crashlytics event to Firebase\");\n-      final Bundle params = new Bundle();\n-      params.putInt(FIREBASE_CRASH_TYPE, FIREBASE_CRASH_TYPE_FATAL);\n-      params.putLong(FIREBASE_TIMESTAMP, timestamp);\n-      analyticsConnector.logEvent(\n-          FIREBASE_ANALYTICS_ORIGIN_CRASHLYTICS, FIREBASE_APPLICATION_EXCEPTION, params);\n-    } else {\n-      Logger.getLogger()\n-          .d(Logger.TAG, \"Skipping logging Crashlytics event to Firebase, no Firebase Analytics\");\n+    @Override\n+    public void onCrashOriginEvent(int id, Bundle extras) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMwODY5Mw=="}, "originalCommit": {"oid": "a24cfa9e0398375bb2ccd6c8a0690c9138d2f700"}, "originalPosition": 145}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5OTQwNjk1OnYy", "diffSide": "RIGHT", "path": "firebase-crashlytics/src/main/java/com/google/firebase/crashlytics/core/CrashlyticsController.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QyMTozOToyNVrOFxXfGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QyMTozOToyNVrOFxXfGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMwOTMzNg==", "bodyText": "Just to be technically correct \ud83e\udd13 might be worth calling this app_exception event callback", "url": "https://github.com/firebase/firebase-android-sdk/pull/1310#discussion_r387309336", "createdAt": "2020-03-03T21:39:25Z", "author": {"login": "mrwillis21"}, "path": "firebase-crashlytics/src/main/java/com/google/firebase/crashlytics/core/CrashlyticsController.java", "diffHunk": "@@ -1748,26 +1752,84 @@ private void sendSessionReports(AppSettingsData appSettings, boolean dataCollect\n     }\n   }\n \n-  private void recordFatalFirebaseEvent(long timestamp) {\n-    if (firebaseCrashExists()) {\n+  /**\n+   * Helper class that listens for Crashlytics origin events from FA and provides a method to block\n+   * while waiting for a Crash event to occur. The implementation assumes there can be at most ONE\n+   * app exception event being processed and waited upon at a time.\n+   */\n+  private static class BlockingCrashEventListener\n+      implements AnalyticsReceiver.CrashlyticsOriginEventListener {\n+\n+    private final CountDownLatch eventLatch = new CountDownLatch(1);\n+\n+    public void awaitEvent() throws InterruptedException {\n       Logger.getLogger()\n-          .d(Logger.TAG, \"Skipping logging Crashlytics event to Firebase, FirebaseCrash exists\");\n-      return;\n+          .d(Logger.TAG, \"Background thread awaiting crash event callback from FA...\");\n+\n+      if (eventLatch.await(2000, TimeUnit.MILLISECONDS)) {\n+        Logger.getLogger().d(Logger.TAG, \"Crash event callback received from FA listener.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a24cfa9e0398375bb2ccd6c8a0690c9138d2f700"}, "originalPosition": 125}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5OTQ1MDIyOnYy", "diffSide": "RIGHT", "path": "firebase-crashlytics/src/main/java/com/google/firebase/crashlytics/internal/analytics/AnalyticsConnectorReceiver.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QyMTo1Mjo1NFrOFxX57g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QyMTo1Mjo1NFrOFxX57g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMxNjIwNg==", "bodyText": "Definitely thought this was a 1 for a minute and got very confused.", "url": "https://github.com/firebase/firebase-android-sdk/pull/1310#discussion_r387316206", "createdAt": "2020-03-03T21:52:54Z", "author": {"login": "mrwillis21"}, "path": "firebase-crashlytics/src/main/java/com/google/firebase/crashlytics/internal/analytics/AnalyticsConnectorReceiver.java", "diffHunk": "@@ -75,14 +77,23 @@ public void unregister() {\n     }\n   }\n \n+  @Override\n+  public void setCrashlyticsOriginEventListener(@Nullable CrashlyticsOriginEventListener l) {\n+    this.crashOriginEventListener = l;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "31ee949598316e6d21d83349d4927c3965564ae6"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5OTQ2MTAwOnYy", "diffSide": "RIGHT", "path": "firebase-crashlytics/src/main/java/com/google/firebase/crashlytics/internal/analytics/AnalyticsConnectorReceiver.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QyMTo1NjoyMVrOFxYAsg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwMTozMDoxNlrOFxdEdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMxNzkzOA==", "bodyText": "Stylistic point: if you use the null object pattern here, and swap in a no-op implementation whenever null is passed in the setter above, you'll only have to null-check in the setter, rather than on every event.", "url": "https://github.com/firebase/firebase-android-sdk/pull/1310#discussion_r387317938", "createdAt": "2020-03-03T21:56:21Z", "author": {"login": "mrwillis21"}, "path": "firebase-crashlytics/src/main/java/com/google/firebase/crashlytics/internal/analytics/AnalyticsConnectorReceiver.java", "diffHunk": "@@ -91,11 +102,22 @@ public void onMessageTriggered(int id, @Nullable Bundle extras) {\n       params = new Bundle();\n     }\n \n-    try {\n-      final String serializedEvent = BREADCRUMB_PREFIX + serializeEvent(name, params);\n-      breadcrumbHandler.dropBreadcrumb(serializedEvent);\n-    } catch (JSONException e) {\n-      Logger.getLogger().w(Logger.TAG, \"Unable to serialize Firebase Analytics event.\");\n+    final String origin = params.getString(EVENT_ORIGIN_KEY);\n+    if (CRASH_ORIGIN.equals(origin)) {\n+      if (crashOriginEventListener != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "31ee949598316e6d21d83349d4927c3965564ae6"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzM3MTY1MA==", "bodyText": "Funny enough, this was another reason why I was considering Set of listeners instead of just the single one. The empty loop would no-op.\nI don't love the no object pattern as I find it confusing when it appears an event should be firing but there's no response anywhere. How  strongly do you feel about it in this particular place?", "url": "https://github.com/firebase/firebase-android-sdk/pull/1310#discussion_r387371650", "createdAt": "2020-03-04T00:15:59Z", "author": {"login": "mrichards"}, "path": "firebase-crashlytics/src/main/java/com/google/firebase/crashlytics/internal/analytics/AnalyticsConnectorReceiver.java", "diffHunk": "@@ -91,11 +102,22 @@ public void onMessageTriggered(int id, @Nullable Bundle extras) {\n       params = new Bundle();\n     }\n \n-    try {\n-      final String serializedEvent = BREADCRUMB_PREFIX + serializeEvent(name, params);\n-      breadcrumbHandler.dropBreadcrumb(serializedEvent);\n-    } catch (JSONException e) {\n-      Logger.getLogger().w(Logger.TAG, \"Unable to serialize Firebase Analytics event.\");\n+    final String origin = params.getString(EVENT_ORIGIN_KEY);\n+    if (CRASH_ORIGIN.equals(origin)) {\n+      if (crashOriginEventListener != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMxNzkzOA=="}, "originalCommit": {"oid": "31ee949598316e6d21d83349d4927c3965564ae6"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzM3MzA5Nw==", "bodyText": "Not strong enough to have you change it now. :) Just a pattern I happen to prefer that would reduce the number of times this conditional is triggered.", "url": "https://github.com/firebase/firebase-android-sdk/pull/1310#discussion_r387373097", "createdAt": "2020-03-04T00:20:54Z", "author": {"login": "mrwillis21"}, "path": "firebase-crashlytics/src/main/java/com/google/firebase/crashlytics/internal/analytics/AnalyticsConnectorReceiver.java", "diffHunk": "@@ -91,11 +102,22 @@ public void onMessageTriggered(int id, @Nullable Bundle extras) {\n       params = new Bundle();\n     }\n \n-    try {\n-      final String serializedEvent = BREADCRUMB_PREFIX + serializeEvent(name, params);\n-      breadcrumbHandler.dropBreadcrumb(serializedEvent);\n-    } catch (JSONException e) {\n-      Logger.getLogger().w(Logger.TAG, \"Unable to serialize Firebase Analytics event.\");\n+    final String origin = params.getString(EVENT_ORIGIN_KEY);\n+    if (CRASH_ORIGIN.equals(origin)) {\n+      if (crashOriginEventListener != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMxNzkzOA=="}, "originalCommit": {"oid": "31ee949598316e6d21d83349d4927c3965564ae6"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzM3MzI0Ng==", "bodyText": "In practice, though, this really should only happen once per session.", "url": "https://github.com/firebase/firebase-android-sdk/pull/1310#discussion_r387373246", "createdAt": "2020-03-04T00:21:24Z", "author": {"login": "mrwillis21"}, "path": "firebase-crashlytics/src/main/java/com/google/firebase/crashlytics/internal/analytics/AnalyticsConnectorReceiver.java", "diffHunk": "@@ -91,11 +102,22 @@ public void onMessageTriggered(int id, @Nullable Bundle extras) {\n       params = new Bundle();\n     }\n \n-    try {\n-      final String serializedEvent = BREADCRUMB_PREFIX + serializeEvent(name, params);\n-      breadcrumbHandler.dropBreadcrumb(serializedEvent);\n-    } catch (JSONException e) {\n-      Logger.getLogger().w(Logger.TAG, \"Unable to serialize Firebase Analytics event.\");\n+    final String origin = params.getString(EVENT_ORIGIN_KEY);\n+    if (CRASH_ORIGIN.equals(origin)) {\n+      if (crashOriginEventListener != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMxNzkzOA=="}, "originalCommit": {"oid": "31ee949598316e6d21d83349d4927c3965564ae6"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQwMDgyMQ==", "bodyText": "After a little synchronous chat: we settled on this being a relatively inconsequential matter of opinion and we're leaving it as-is.", "url": "https://github.com/firebase/firebase-android-sdk/pull/1310#discussion_r387400821", "createdAt": "2020-03-04T01:30:16Z", "author": {"login": "mrichards"}, "path": "firebase-crashlytics/src/main/java/com/google/firebase/crashlytics/internal/analytics/AnalyticsConnectorReceiver.java", "diffHunk": "@@ -91,11 +102,22 @@ public void onMessageTriggered(int id, @Nullable Bundle extras) {\n       params = new Bundle();\n     }\n \n-    try {\n-      final String serializedEvent = BREADCRUMB_PREFIX + serializeEvent(name, params);\n-      breadcrumbHandler.dropBreadcrumb(serializedEvent);\n-    } catch (JSONException e) {\n-      Logger.getLogger().w(Logger.TAG, \"Unable to serialize Firebase Analytics event.\");\n+    final String origin = params.getString(EVENT_ORIGIN_KEY);\n+    if (CRASH_ORIGIN.equals(origin)) {\n+      if (crashOriginEventListener != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMxNzkzOA=="}, "originalCommit": {"oid": "31ee949598316e6d21d83349d4927c3965564ae6"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5OTQ2MzMwOnYy", "diffSide": "RIGHT", "path": "firebase-crashlytics/src/main/java/com/google/firebase/crashlytics/internal/analytics/AnalyticsConnectorReceiver.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QyMTo1NzowOFrOFxYCLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QyMTo1NzowOFrOFxYCLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMxODMxOA==", "bodyText": "Would be great if we could pull these two paths out into named functions.", "url": "https://github.com/firebase/firebase-android-sdk/pull/1310#discussion_r387318318", "createdAt": "2020-03-03T21:57:08Z", "author": {"login": "mrwillis21"}, "path": "firebase-crashlytics/src/main/java/com/google/firebase/crashlytics/internal/analytics/AnalyticsConnectorReceiver.java", "diffHunk": "@@ -91,11 +102,22 @@ public void onMessageTriggered(int id, @Nullable Bundle extras) {\n       params = new Bundle();\n     }\n \n-    try {\n-      final String serializedEvent = BREADCRUMB_PREFIX + serializeEvent(name, params);\n-      breadcrumbHandler.dropBreadcrumb(serializedEvent);\n-    } catch (JSONException e) {\n-      Logger.getLogger().w(Logger.TAG, \"Unable to serialize Firebase Analytics event.\");\n+    final String origin = params.getString(EVENT_ORIGIN_KEY);\n+    if (CRASH_ORIGIN.equals(origin)) {\n+      if (crashOriginEventListener != null) {\n+        crashOriginEventListener.onCrashOriginEvent(id, extras);\n+      }\n+    } else { // Drop breadcrumbs for all named events which did not originate from Crashlytics\n+      final String name = extras.getString(EVENT_NAME_KEY);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "31ee949598316e6d21d83349d4927c3965564ae6"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5OTQ3NzMxOnYy", "diffSide": "RIGHT", "path": "firebase-crashlytics/src/main/java/com/google/firebase/crashlytics/core/CrashlyticsController.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QyMjowMTo0MVrOFxYLEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwMTozMTo0MVrOFxdGSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMyMDU5NA==", "bodyText": "As mentioned in chat, if you used a TaskCompletionSource instead of a countdown latch above, returned its Task from this method, and just resolved the task (via the completion source) in onCrashOriginEvent, you could simplify a lot of what's downstream.\n\nYou wouldn't need the extra Tasks.call with its own executor down below because this would just become part of the task chain already in the exception handler.\nYou wouldn't need the extra 2-second timeout here because the timeout would be handled by the exception handler task chain's timeout.", "url": "https://github.com/firebase/firebase-android-sdk/pull/1310#discussion_r387320594", "createdAt": "2020-03-03T22:01:41Z", "author": {"login": "mrwillis21"}, "path": "firebase-crashlytics/src/main/java/com/google/firebase/crashlytics/core/CrashlyticsController.java", "diffHunk": "@@ -1805,26 +1809,84 @@ private void sendSessionReports(AppSettingsData appSettings, boolean dataCollect\n     }\n   }\n \n-  private void recordFatalFirebaseEvent(long timestamp) {\n-    if (firebaseCrashExists()) {\n+  /**\n+   * Helper class that listens for Crashlytics origin events from FA and provides a method to block\n+   * while waiting for a Crash event to occur. The implementation assumes there can be at most ONE\n+   * app exception event being processed and waited upon at a time.\n+   */\n+  private static class BlockingCrashEventListener\n+      implements AnalyticsReceiver.CrashlyticsOriginEventListener {\n+\n+    private final CountDownLatch eventLatch = new CountDownLatch(1);\n+\n+    public void awaitEvent() throws InterruptedException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "31ee949598316e6d21d83349d4927c3965564ae6"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQwMTI4OA==", "bodyText": "(Going to do this on a future PR. See previous comment.)", "url": "https://github.com/firebase/firebase-android-sdk/pull/1310#discussion_r387401288", "createdAt": "2020-03-04T01:31:41Z", "author": {"login": "mrichards"}, "path": "firebase-crashlytics/src/main/java/com/google/firebase/crashlytics/core/CrashlyticsController.java", "diffHunk": "@@ -1805,26 +1809,84 @@ private void sendSessionReports(AppSettingsData appSettings, boolean dataCollect\n     }\n   }\n \n-  private void recordFatalFirebaseEvent(long timestamp) {\n-    if (firebaseCrashExists()) {\n+  /**\n+   * Helper class that listens for Crashlytics origin events from FA and provides a method to block\n+   * while waiting for a Crash event to occur. The implementation assumes there can be at most ONE\n+   * app exception event being processed and waited upon at a time.\n+   */\n+  private static class BlockingCrashEventListener\n+      implements AnalyticsReceiver.CrashlyticsOriginEventListener {\n+\n+    private final CountDownLatch eventLatch = new CountDownLatch(1);\n+\n+    public void awaitEvent() throws InterruptedException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMyMDU5NA=="}, "originalCommit": {"oid": "31ee949598316e6d21d83349d4927c3965564ae6"}, "originalPosition": 118}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5OTQ4ODM0OnYy", "diffSide": "RIGHT", "path": "firebase-crashlytics/src/main/java/com/google/firebase/crashlytics/core/CrashlyticsController.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QyMjowNTowOVrOFxYR-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwMTozMTowOVrOFxdFww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMyMjM2MQ==", "bodyText": "If this returned a task (as mentioned above), you could remove the extra Tasks.call above and turn this method (recordFatalFirebaseEvent) into a synchronous call (which still returns this task), then just chain the return value in the uncaught exception handler the same way.", "url": "https://github.com/firebase/firebase-android-sdk/pull/1310#discussion_r387322361", "createdAt": "2020-03-03T22:05:09Z", "author": {"login": "mrwillis21"}, "path": "firebase-crashlytics/src/main/java/com/google/firebase/crashlytics/core/CrashlyticsController.java", "diffHunk": "@@ -1805,26 +1809,84 @@ private void sendSessionReports(AppSettingsData appSettings, boolean dataCollect\n     }\n   }\n \n-  private void recordFatalFirebaseEvent(long timestamp) {\n-    if (firebaseCrashExists()) {\n+  /**\n+   * Helper class that listens for Crashlytics origin events from FA and provides a method to block\n+   * while waiting for a Crash event to occur. The implementation assumes there can be at most ONE\n+   * app exception event being processed and waited upon at a time.\n+   */\n+  private static class BlockingCrashEventListener\n+      implements AnalyticsReceiver.CrashlyticsOriginEventListener {\n+\n+    private final CountDownLatch eventLatch = new CountDownLatch(1);\n+\n+    public void awaitEvent() throws InterruptedException {\n       Logger.getLogger()\n-          .d(Logger.TAG, \"Skipping logging Crashlytics event to Firebase, FirebaseCrash exists\");\n-      return;\n+          .d(Logger.TAG, \"Background thread awaiting crash event callback from FA...\");\n+\n+      if (eventLatch.await(2000, TimeUnit.MILLISECONDS)) {\n+        Logger.getLogger().d(Logger.TAG, \"Crash event callback received from FA listener.\");\n+      } else {\n+        Logger.getLogger()\n+            .d(\n+                Logger.TAG,\n+                \"Timeout exceeded while awaiting crash event callback from FA listener.\");\n+      }\n     }\n \n-    if (analyticsConnector != null) {\n-      Logger.getLogger().d(Logger.TAG, \"Logging Crashlytics event to Firebase\");\n-      final Bundle params = new Bundle();\n-      params.putInt(FIREBASE_CRASH_TYPE, FIREBASE_CRASH_TYPE_FATAL);\n-      params.putLong(FIREBASE_TIMESTAMP, timestamp);\n-      analyticsConnector.logEvent(\n-          FIREBASE_ANALYTICS_ORIGIN_CRASHLYTICS, FIREBASE_APPLICATION_EXCEPTION, params);\n-    } else {\n-      Logger.getLogger()\n-          .d(Logger.TAG, \"Skipping logging Crashlytics event to Firebase, no Firebase Analytics\");\n+    @Override\n+    public void onCrashOriginEvent(int id, Bundle extras) {\n+      String eventName = extras.getString(AnalyticsConnectorReceiver.EVENT_NAME_KEY);\n+      if (AnalyticsConnectorReceiver.APP_EXCEPTION_EVENT_NAME.equals(eventName)) {\n+        eventLatch.countDown();\n+      }\n     }\n   }\n \n+  /**\n+   * Send an App Exception event to Firebase Analytics. FA records the event asynchronously, so this\n+   * method returns a Task in case the caller wants to verify that the event was recorded by FA and\n+   * will not be lost.\n+   */\n+  private Task<Void> recordFatalFirebaseEvent(long timestamp) {\n+    final ThreadPoolExecutor executor = new ScheduledThreadPoolExecutor(1);\n+    return Tasks.call(\n+        executor,\n+        new Callable<Void>() {\n+          @Override\n+          public Void call() throws Exception {\n+            if (firebaseCrashExists()) {\n+              Logger.getLogger()\n+                  .d(\n+                      Logger.TAG,\n+                      \"Skipping logging Crashlytics event to Firebase, FirebaseCrash exists\");\n+              return null;\n+            }\n+            if (analyticsConnector == null) {\n+              Logger.getLogger()\n+                  .d(\n+                      Logger.TAG,\n+                      \"Skipping logging Crashlytics event to Firebase, no Firebase Analytics\");\n+              return null;\n+            }\n+            final BlockingCrashEventListener blockingListener = new BlockingCrashEventListener();\n+            analyticsReceiver.setCrashlyticsOriginEventListener(blockingListener);\n+\n+            Logger.getLogger().d(Logger.TAG, \"Logging Crashlytics event to Firebase\");\n+            final Bundle params = new Bundle();\n+            params.putInt(FIREBASE_CRASH_TYPE, FIREBASE_CRASH_TYPE_FATAL);\n+            params.putLong(FIREBASE_TIMESTAMP, timestamp);\n+\n+            analyticsConnector.logEvent(\n+                FIREBASE_ANALYTICS_ORIGIN_CRASHLYTICS, FIREBASE_APPLICATION_EXCEPTION, params);\n+\n+            blockingListener.awaitEvent();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "31ee949598316e6d21d83349d4927c3965564ae6"}, "originalPosition": 190}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQwMTE1NQ==", "bodyText": "We both like this idea and will do this in a subsequent refactor, since it is going to require more extensive validation than we have time for before the next release. It mostly improves readability and not performance.", "url": "https://github.com/firebase/firebase-android-sdk/pull/1310#discussion_r387401155", "createdAt": "2020-03-04T01:31:09Z", "author": {"login": "mrichards"}, "path": "firebase-crashlytics/src/main/java/com/google/firebase/crashlytics/core/CrashlyticsController.java", "diffHunk": "@@ -1805,26 +1809,84 @@ private void sendSessionReports(AppSettingsData appSettings, boolean dataCollect\n     }\n   }\n \n-  private void recordFatalFirebaseEvent(long timestamp) {\n-    if (firebaseCrashExists()) {\n+  /**\n+   * Helper class that listens for Crashlytics origin events from FA and provides a method to block\n+   * while waiting for a Crash event to occur. The implementation assumes there can be at most ONE\n+   * app exception event being processed and waited upon at a time.\n+   */\n+  private static class BlockingCrashEventListener\n+      implements AnalyticsReceiver.CrashlyticsOriginEventListener {\n+\n+    private final CountDownLatch eventLatch = new CountDownLatch(1);\n+\n+    public void awaitEvent() throws InterruptedException {\n       Logger.getLogger()\n-          .d(Logger.TAG, \"Skipping logging Crashlytics event to Firebase, FirebaseCrash exists\");\n-      return;\n+          .d(Logger.TAG, \"Background thread awaiting crash event callback from FA...\");\n+\n+      if (eventLatch.await(2000, TimeUnit.MILLISECONDS)) {\n+        Logger.getLogger().d(Logger.TAG, \"Crash event callback received from FA listener.\");\n+      } else {\n+        Logger.getLogger()\n+            .d(\n+                Logger.TAG,\n+                \"Timeout exceeded while awaiting crash event callback from FA listener.\");\n+      }\n     }\n \n-    if (analyticsConnector != null) {\n-      Logger.getLogger().d(Logger.TAG, \"Logging Crashlytics event to Firebase\");\n-      final Bundle params = new Bundle();\n-      params.putInt(FIREBASE_CRASH_TYPE, FIREBASE_CRASH_TYPE_FATAL);\n-      params.putLong(FIREBASE_TIMESTAMP, timestamp);\n-      analyticsConnector.logEvent(\n-          FIREBASE_ANALYTICS_ORIGIN_CRASHLYTICS, FIREBASE_APPLICATION_EXCEPTION, params);\n-    } else {\n-      Logger.getLogger()\n-          .d(Logger.TAG, \"Skipping logging Crashlytics event to Firebase, no Firebase Analytics\");\n+    @Override\n+    public void onCrashOriginEvent(int id, Bundle extras) {\n+      String eventName = extras.getString(AnalyticsConnectorReceiver.EVENT_NAME_KEY);\n+      if (AnalyticsConnectorReceiver.APP_EXCEPTION_EVENT_NAME.equals(eventName)) {\n+        eventLatch.countDown();\n+      }\n     }\n   }\n \n+  /**\n+   * Send an App Exception event to Firebase Analytics. FA records the event asynchronously, so this\n+   * method returns a Task in case the caller wants to verify that the event was recorded by FA and\n+   * will not be lost.\n+   */\n+  private Task<Void> recordFatalFirebaseEvent(long timestamp) {\n+    final ThreadPoolExecutor executor = new ScheduledThreadPoolExecutor(1);\n+    return Tasks.call(\n+        executor,\n+        new Callable<Void>() {\n+          @Override\n+          public Void call() throws Exception {\n+            if (firebaseCrashExists()) {\n+              Logger.getLogger()\n+                  .d(\n+                      Logger.TAG,\n+                      \"Skipping logging Crashlytics event to Firebase, FirebaseCrash exists\");\n+              return null;\n+            }\n+            if (analyticsConnector == null) {\n+              Logger.getLogger()\n+                  .d(\n+                      Logger.TAG,\n+                      \"Skipping logging Crashlytics event to Firebase, no Firebase Analytics\");\n+              return null;\n+            }\n+            final BlockingCrashEventListener blockingListener = new BlockingCrashEventListener();\n+            analyticsReceiver.setCrashlyticsOriginEventListener(blockingListener);\n+\n+            Logger.getLogger().d(Logger.TAG, \"Logging Crashlytics event to Firebase\");\n+            final Bundle params = new Bundle();\n+            params.putInt(FIREBASE_CRASH_TYPE, FIREBASE_CRASH_TYPE_FATAL);\n+            params.putLong(FIREBASE_TIMESTAMP, timestamp);\n+\n+            analyticsConnector.logEvent(\n+                FIREBASE_ANALYTICS_ORIGIN_CRASHLYTICS, FIREBASE_APPLICATION_EXCEPTION, params);\n+\n+            blockingListener.awaitEvent();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMyMjM2MQ=="}, "originalCommit": {"oid": "31ee949598316e6d21d83349d4927c3965564ae6"}, "originalPosition": 190}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5OTg4NzM2OnYy", "diffSide": "RIGHT", "path": "firebase-crashlytics/src/main/java/com/google/firebase/crashlytics/internal/analytics/AnalyticsConnectorReceiver.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwMDo1NTo1NlrOFxcCnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwMToyOTowMlrOFxdDUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzM4Mzk2NA==", "bodyText": "nit: the \"fire\" prefix is... slightly overloaded in this codebase.", "url": "https://github.com/firebase/firebase-android-sdk/pull/1310#discussion_r387383964", "createdAt": "2020-03-04T00:55:56Z", "author": {"login": "mrwillis21"}, "path": "firebase-crashlytics/src/main/java/com/google/firebase/crashlytics/internal/analytics/AnalyticsConnectorReceiver.java", "diffHunk": "@@ -91,6 +102,25 @@ public void onMessageTriggered(int id, @Nullable Bundle extras) {\n       params = new Bundle();\n     }\n \n+    final String origin = params.getString(EVENT_ORIGIN_KEY);\n+    if (CRASHLYTICS_ORIGIN.equals(origin)) {\n+      fireCrashlyticsOriginEvent(id, extras);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8cf87cd937eb81dad28d2a7f9dadb186daf10d5a"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQwMDUyOQ==", "bodyText": "\ud83d\udd25\ud83d\udd25\ud83d\udd25 Whatever do you mean? \ud83d\udd25\ud83d\udd25\ud83d\udd25", "url": "https://github.com/firebase/firebase-android-sdk/pull/1310#discussion_r387400529", "createdAt": "2020-03-04T01:29:02Z", "author": {"login": "mrichards"}, "path": "firebase-crashlytics/src/main/java/com/google/firebase/crashlytics/internal/analytics/AnalyticsConnectorReceiver.java", "diffHunk": "@@ -91,6 +102,25 @@ public void onMessageTriggered(int id, @Nullable Bundle extras) {\n       params = new Bundle();\n     }\n \n+    final String origin = params.getString(EVENT_ORIGIN_KEY);\n+    if (CRASHLYTICS_ORIGIN.equals(origin)) {\n+      fireCrashlyticsOriginEvent(id, extras);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzM4Mzk2NA=="}, "originalCommit": {"oid": "8cf87cd937eb81dad28d2a7f9dadb186daf10d5a"}, "originalPosition": 86}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 837, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}