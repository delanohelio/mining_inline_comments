{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY4ODUyOTM0", "number": 1178, "title": "Add explicit FieldValue canonicalization", "bodyText": "Adds a new format for canonical IDs of field values that is meant to be verifiable and stable.", "createdAt": "2020-01-30T02:01:54Z", "url": "https://github.com/firebase/firebase-android-sdk/pull/1178", "merged": true, "mergeCommit": {"oid": "e4b4850fbe2c1ec86d984d406eb14e67282de0aa"}, "closed": true, "closedAt": "2020-02-01T01:22:41Z", "author": {"login": "schmidt-sebastian"}, "timelineItems": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb_QuE5AH2gAyMzY4ODUyOTM0OjlhZDU5ZGM4ZWU4YTFmMjJiZDFmYjYwMTMwODZhMmY0NTFkMzA3Njc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABb_5W97AH2gAyMzY4ODUyOTM0OjUxZDg2ODQxNTQ0YTNmNjU3Mzg2ZGE2MTEyMzhmMTU0NTg0NjE1NDI=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "9ad59dc8ee8a1f22bd1fb6013086a2f451d30767", "author": {"user": {"login": "schmidt-sebastian", "name": "Sebastian Schmidt"}}, "url": "https://github.com/firebase/firebase-android-sdk/commit/9ad59dc8ee8a1f22bd1fb6013086a2f451d30767", "committedDate": "2020-01-30T02:00:58Z", "message": "Add explicit FieldValue canonicalization"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUxMDYyMDA0", "url": "https://github.com/firebase/firebase-android-sdk/pull/1178#pullrequestreview-351062004", "createdAt": "2020-01-30T18:55:09Z", "commit": {"oid": "9ad59dc8ee8a1f22bd1fb6013086a2f451d30767"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQxODo1NTowOVrOFj2Hsw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQxOTowMDoxNlrOFj2RWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzEzMTE4Nw==", "bodyText": "buildTimestampCanonicalId reads weirdly and is the third form for names in this file:\n\nnumberEquals\ncompareNumber\nbuildNumberCanonicalId\n\nIt seems like these could all have the same shape.\nIdeas:\n\n\nmake these verbless, i.e. have\nprivate static void canonicalId(StringBuilder builder, Value value) ...\nand these helpers can then just drop the \"build\" prefix.\n\n\nuse a verb like \"canonify\" and then these become e.g. \"canonifyTimestamp\".", "url": "https://github.com/firebase/firebase-android-sdk/pull/1178#discussion_r373131187", "createdAt": "2020-01-30T18:55:09Z", "author": {"login": "wilhuff"}, "path": "firebase-firestore/src/main/java/com/google/firebase/firestore/model/value/ProtoValues.java", "diffHunk": "@@ -249,4 +249,87 @@ private static int compareMaps(MapValue left, MapValue right) {\n     // Only equal if both iterators are exhausted.\n     return Util.compareBooleans(iterator1.hasNext(), iterator2.hasNext());\n   }\n+\n+  /** Generate the canonical ID for the provided field value (as used in Target serialization). */\n+  public static String canonicalId(Value value) {\n+    StringBuilder builder = new StringBuilder();\n+    buildCanonicalId(builder, value);\n+    return builder.toString();\n+  }\n+\n+  // TODO(mrschmidt): Use in target serialization and migrate all existing TargetData\n+  private static void buildCanonicalId(StringBuilder builder, Value value) {\n+    switch (value.getValueTypeCase()) {\n+      case NULL_VALUE:\n+        builder.append(\"null\");\n+        break;\n+      case BOOLEAN_VALUE:\n+        builder.append(value.getBooleanValue());\n+        break;\n+      case INTEGER_VALUE:\n+        builder.append(value.getIntegerValue());\n+        break;\n+      case DOUBLE_VALUE:\n+        builder.append(value.getDoubleValue());\n+        break;\n+      case TIMESTAMP_VALUE:\n+        buildTimestampCanonicalId(builder, value.getTimestampValue());\n+        break;\n+      case STRING_VALUE:\n+        builder.append(value.getStringValue());\n+        break;\n+      case BYTES_VALUE:\n+        builder.append(Util.toDebugString(value.getBytesValue()));\n+        break;\n+      case REFERENCE_VALUE:\n+        // TODO(mrschmidt): Use document key only\n+        builder.append(value.getReferenceValue());\n+        break;\n+      case GEO_POINT_VALUE:\n+        buildGeoPointCanonicalId(builder, value.getGeoPointValue());\n+        break;\n+      case ARRAY_VALUE:\n+        buildArrayCanonicalId(builder, value.getArrayValue());\n+        break;\n+      case MAP_VALUE:\n+        buildObjectCanonicalId(builder, value.getMapValue());\n+        break;\n+      default:\n+        throw fail(\"Invalid value type: \" + value.getValueTypeCase());\n+    }\n+  }\n+\n+  private static void buildTimestampCanonicalId(StringBuilder builder, Timestamp timestamp) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ad59dc8ee8a1f22bd1fb6013086a2f451d30767"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzEzMzM1Mg==", "bodyText": "This is indistinguishable from a user-supplied object that happens to have these parameters. While JSON-like seems useful we could avoid collisions altogether if we made this look like an object constructor instead.\nSomething like geo(lat:%s,lng:%s) or even just geo(%s, %s).", "url": "https://github.com/firebase/firebase-android-sdk/pull/1178#discussion_r373133352", "createdAt": "2020-01-30T18:59:36Z", "author": {"login": "wilhuff"}, "path": "firebase-firestore/src/main/java/com/google/firebase/firestore/model/value/ProtoValues.java", "diffHunk": "@@ -249,4 +249,87 @@ private static int compareMaps(MapValue left, MapValue right) {\n     // Only equal if both iterators are exhausted.\n     return Util.compareBooleans(iterator1.hasNext(), iterator2.hasNext());\n   }\n+\n+  /** Generate the canonical ID for the provided field value (as used in Target serialization). */\n+  public static String canonicalId(Value value) {\n+    StringBuilder builder = new StringBuilder();\n+    buildCanonicalId(builder, value);\n+    return builder.toString();\n+  }\n+\n+  // TODO(mrschmidt): Use in target serialization and migrate all existing TargetData\n+  private static void buildCanonicalId(StringBuilder builder, Value value) {\n+    switch (value.getValueTypeCase()) {\n+      case NULL_VALUE:\n+        builder.append(\"null\");\n+        break;\n+      case BOOLEAN_VALUE:\n+        builder.append(value.getBooleanValue());\n+        break;\n+      case INTEGER_VALUE:\n+        builder.append(value.getIntegerValue());\n+        break;\n+      case DOUBLE_VALUE:\n+        builder.append(value.getDoubleValue());\n+        break;\n+      case TIMESTAMP_VALUE:\n+        buildTimestampCanonicalId(builder, value.getTimestampValue());\n+        break;\n+      case STRING_VALUE:\n+        builder.append(value.getStringValue());\n+        break;\n+      case BYTES_VALUE:\n+        builder.append(Util.toDebugString(value.getBytesValue()));\n+        break;\n+      case REFERENCE_VALUE:\n+        // TODO(mrschmidt): Use document key only\n+        builder.append(value.getReferenceValue());\n+        break;\n+      case GEO_POINT_VALUE:\n+        buildGeoPointCanonicalId(builder, value.getGeoPointValue());\n+        break;\n+      case ARRAY_VALUE:\n+        buildArrayCanonicalId(builder, value.getArrayValue());\n+        break;\n+      case MAP_VALUE:\n+        buildObjectCanonicalId(builder, value.getMapValue());\n+        break;\n+      default:\n+        throw fail(\"Invalid value type: \" + value.getValueTypeCase());\n+    }\n+  }\n+\n+  private static void buildTimestampCanonicalId(StringBuilder builder, Timestamp timestamp) {\n+    builder.append(String.format(\"{s:%s,n:%s}\", timestamp.getSeconds(), timestamp.getNanos()));\n+  }\n+\n+  private static void buildGeoPointCanonicalId(StringBuilder builder, LatLng latLng) {\n+    builder.append(String.format(\"{lat:%s,lng:%s}\", latLng.getLatitude(), latLng.getLongitude()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ad59dc8ee8a1f22bd1fb6013086a2f451d30767"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzEzMzY1Nw==", "bodyText": "Are you intending to make it an invariant that MapValues are always sorted by key? I don't recall seeing this in your other PR adding protovalue.ObjectValue.Builder.\nIf not, we probably need to sort the strings here :-(. I think maintaining the invariant is probably better though.\nNote that server-supplied MapValues already conform to this invariant.", "url": "https://github.com/firebase/firebase-android-sdk/pull/1178#discussion_r373133657", "createdAt": "2020-01-30T19:00:16Z", "author": {"login": "wilhuff"}, "path": "firebase-firestore/src/main/java/com/google/firebase/firestore/model/value/ProtoValues.java", "diffHunk": "@@ -249,4 +249,87 @@ private static int compareMaps(MapValue left, MapValue right) {\n     // Only equal if both iterators are exhausted.\n     return Util.compareBooleans(iterator1.hasNext(), iterator2.hasNext());\n   }\n+\n+  /** Generate the canonical ID for the provided field value (as used in Target serialization). */\n+  public static String canonicalId(Value value) {\n+    StringBuilder builder = new StringBuilder();\n+    buildCanonicalId(builder, value);\n+    return builder.toString();\n+  }\n+\n+  // TODO(mrschmidt): Use in target serialization and migrate all existing TargetData\n+  private static void buildCanonicalId(StringBuilder builder, Value value) {\n+    switch (value.getValueTypeCase()) {\n+      case NULL_VALUE:\n+        builder.append(\"null\");\n+        break;\n+      case BOOLEAN_VALUE:\n+        builder.append(value.getBooleanValue());\n+        break;\n+      case INTEGER_VALUE:\n+        builder.append(value.getIntegerValue());\n+        break;\n+      case DOUBLE_VALUE:\n+        builder.append(value.getDoubleValue());\n+        break;\n+      case TIMESTAMP_VALUE:\n+        buildTimestampCanonicalId(builder, value.getTimestampValue());\n+        break;\n+      case STRING_VALUE:\n+        builder.append(value.getStringValue());\n+        break;\n+      case BYTES_VALUE:\n+        builder.append(Util.toDebugString(value.getBytesValue()));\n+        break;\n+      case REFERENCE_VALUE:\n+        // TODO(mrschmidt): Use document key only\n+        builder.append(value.getReferenceValue());\n+        break;\n+      case GEO_POINT_VALUE:\n+        buildGeoPointCanonicalId(builder, value.getGeoPointValue());\n+        break;\n+      case ARRAY_VALUE:\n+        buildArrayCanonicalId(builder, value.getArrayValue());\n+        break;\n+      case MAP_VALUE:\n+        buildObjectCanonicalId(builder, value.getMapValue());\n+        break;\n+      default:\n+        throw fail(\"Invalid value type: \" + value.getValueTypeCase());\n+    }\n+  }\n+\n+  private static void buildTimestampCanonicalId(StringBuilder builder, Timestamp timestamp) {\n+    builder.append(String.format(\"{s:%s,n:%s}\", timestamp.getSeconds(), timestamp.getNanos()));\n+  }\n+\n+  private static void buildGeoPointCanonicalId(StringBuilder builder, LatLng latLng) {\n+    builder.append(String.format(\"{lat:%s,lng:%s}\", latLng.getLatitude(), latLng.getLongitude()));\n+  }\n+\n+  private static void buildObjectCanonicalId(StringBuilder builder, MapValue mapValue) {\n+    builder.append(\"{\");\n+    boolean first = true;\n+    for (Map.Entry<String, Value> entry : mapValue.getFieldsMap().entrySet()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ad59dc8ee8a1f22bd1fb6013086a2f451d30767"}, "originalPosition": 65}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a3f3b79b8d684b83edeb2167055582b6032a3d54", "author": {"user": {"login": "schmidt-sebastian", "name": "Sebastian Schmidt"}}, "url": "https://github.com/firebase/firebase-android-sdk/commit/a3f3b79b8d684b83edeb2167055582b6032a3d54", "committedDate": "2020-01-31T00:41:13Z", "message": "Feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cc3941934357f8f0d7e60b059d79f039cf801ccd", "author": {"user": {"login": "schmidt-sebastian", "name": "Sebastian Schmidt"}}, "url": "https://github.com/firebase/firebase-android-sdk/commit/cc3941934357f8f0d7e60b059d79f039cf801ccd", "committedDate": "2020-01-31T19:30:17Z", "message": "Update ProtoValues.java"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUxODIwNjQ3", "url": "https://github.com/firebase/firebase-android-sdk/pull/1178#pullrequestreview-351820647", "createdAt": "2020-01-31T22:46:33Z", "commit": {"oid": "cc3941934357f8f0d7e60b059d79f039cf801ccd"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQyMjo0NjozM1rOFkZ-bA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQyMjo0NjozM1rOFkZ-bA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzcxODYzNg==", "bodyText": "Building a binary tree to sort the entries is pretty wasteful in terms of memory allocation. It's also pessimistic because building the tree is always going to cost O(n lg(n)). An alternative would be to collect the keys into an ArrayList and sort that. That has the benefit of allocating less memory and also runs in O(n) if the list is already sorted.", "url": "https://github.com/firebase/firebase-android-sdk/pull/1178#discussion_r373718636", "createdAt": "2020-01-31T22:46:33Z", "author": {"login": "wilhuff"}, "path": "firebase-firestore/src/main/java/com/google/firebase/firestore/model/value/ProtoValues.java", "diffHunk": "@@ -249,4 +250,92 @@ private static int compareMaps(MapValue left, MapValue right) {\n     // Only equal if both iterators are exhausted.\n     return Util.compareBooleans(iterator1.hasNext(), iterator2.hasNext());\n   }\n+\n+  /** Generate the canonical ID for the provided field value (as used in Target serialization). */\n+  public static String canonicalId(Value value) {\n+    StringBuilder builder = new StringBuilder();\n+    stringifyValue(builder, value);\n+    return builder.toString();\n+  }\n+\n+  // TODO(mrschmidt): Use in target serialization and migrate all existing TargetData\n+  private static void stringifyValue(StringBuilder builder, Value value) {\n+    switch (value.getValueTypeCase()) {\n+      case NULL_VALUE:\n+        builder.append(\"null\");\n+        break;\n+      case BOOLEAN_VALUE:\n+        builder.append(value.getBooleanValue());\n+        break;\n+      case INTEGER_VALUE:\n+        builder.append(value.getIntegerValue());\n+        break;\n+      case DOUBLE_VALUE:\n+        builder.append(value.getDoubleValue());\n+        break;\n+      case TIMESTAMP_VALUE:\n+        stringifyTimestamp(builder, value.getTimestampValue());\n+        break;\n+      case STRING_VALUE:\n+        builder.append(value.getStringValue());\n+        break;\n+      case BYTES_VALUE:\n+        builder.append(Util.toDebugString(value.getBytesValue()));\n+        break;\n+      case REFERENCE_VALUE:\n+        // TODO(mrschmidt): Use document key only\n+        builder.append(value.getReferenceValue());\n+        break;\n+      case GEO_POINT_VALUE:\n+        stringifyGeoPoint(builder, value.getGeoPointValue());\n+        break;\n+      case ARRAY_VALUE:\n+        stringifyArray(builder, value.getArrayValue());\n+        break;\n+      case MAP_VALUE:\n+        stringifyObject(builder, value.getMapValue());\n+        break;\n+      default:\n+        throw fail(\"Invalid value type: \" + value.getValueTypeCase());\n+    }\n+  }\n+\n+  private static void stringifyTimestamp(StringBuilder builder, Timestamp timestamp) {\n+    builder.append(String.format(\"time(%s,%s)\", timestamp.getSeconds(), timestamp.getNanos()));\n+  }\n+\n+  private static void stringifyGeoPoint(StringBuilder builder, LatLng latLng) {\n+    builder.append(String.format(\"geo(%s,%s)\", latLng.getLatitude(), latLng.getLongitude()));\n+  }\n+\n+  private static void stringifyObject(StringBuilder builder, MapValue mapValue) {\n+    // Even though MapValue are likely sorted correctly based on their insertion order (e.g. when\n+    // received from the backend), local modifications can bring elements out of order. We need to\n+    // re-sort the elements to ensure that canonical IDs are independent of insertion order.\n+    SortedMap<String, Value> sortedMap = new TreeMap<>(mapValue.getFieldsMap());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cc3941934357f8f0d7e60b059d79f039cf801ccd"}, "originalPosition": 74}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2ef1826c2a922bd9fea0ff70ff888f8dcc751856", "author": {"user": {"login": "schmidt-sebastian", "name": "Sebastian Schmidt"}}, "url": "https://github.com/firebase/firebase-android-sdk/commit/2ef1826c2a922bd9fea0ff70ff888f8dcc751856", "committedDate": "2020-01-31T23:46:42Z", "message": "More Feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b3b6a77b5121c7d486288c40f80453886f79d70b", "author": {"user": {"login": "schmidt-sebastian", "name": "Sebastian Schmidt"}}, "url": "https://github.com/firebase/firebase-android-sdk/commit/b3b6a77b5121c7d486288c40f80453886f79d70b", "committedDate": "2020-01-31T23:47:23Z", "message": "Merge"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUxODQxMTk1", "url": "https://github.com/firebase/firebase-android-sdk/pull/1178#pullrequestreview-351841195", "createdAt": "2020-02-01T00:03:10Z", "commit": {"oid": "b3b6a77b5121c7d486288c40f80453886f79d70b"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wMVQwMDowMzoxMFrOFkbBKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wMVQwMDowMzoxMFrOFkbBKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzczNTcyMA==", "bodyText": "You can make this keys.sort() if you want.", "url": "https://github.com/firebase/firebase-android-sdk/pull/1178#discussion_r373735720", "createdAt": "2020-02-01T00:03:10Z", "author": {"login": "wilhuff"}, "path": "firebase-firestore/src/main/java/com/google/firebase/firestore/model/value/ProtoValues.java", "diffHunk": "@@ -249,4 +251,93 @@ private static int compareMaps(MapValue left, MapValue right) {\n     // Only equal if both iterators are exhausted.\n     return Util.compareBooleans(iterator1.hasNext(), iterator2.hasNext());\n   }\n+\n+  /** Generate the canonical ID for the provided field value (as used in Target serialization). */\n+  public static String canonicalId(Value value) {\n+    StringBuilder builder = new StringBuilder();\n+    canonifyValue(builder, value);\n+    return builder.toString();\n+  }\n+\n+  // TODO(mrschmidt): Use in target serialization and migrate all existing TargetData\n+  private static void canonifyValue(StringBuilder builder, Value value) {\n+    switch (value.getValueTypeCase()) {\n+      case NULL_VALUE:\n+        builder.append(\"null\");\n+        break;\n+      case BOOLEAN_VALUE:\n+        builder.append(value.getBooleanValue());\n+        break;\n+      case INTEGER_VALUE:\n+        builder.append(value.getIntegerValue());\n+        break;\n+      case DOUBLE_VALUE:\n+        builder.append(value.getDoubleValue());\n+        break;\n+      case TIMESTAMP_VALUE:\n+        canonifyTimestamp(builder, value.getTimestampValue());\n+        break;\n+      case STRING_VALUE:\n+        builder.append(value.getStringValue());\n+        break;\n+      case BYTES_VALUE:\n+        builder.append(Util.toDebugString(value.getBytesValue()));\n+        break;\n+      case REFERENCE_VALUE:\n+        // TODO(mrschmidt): Use document key only\n+        builder.append(value.getReferenceValue());\n+        break;\n+      case GEO_POINT_VALUE:\n+        canonifyGeoPoint(builder, value.getGeoPointValue());\n+        break;\n+      case ARRAY_VALUE:\n+        canonifyArray(builder, value.getArrayValue());\n+        break;\n+      case MAP_VALUE:\n+        canonifyObject(builder, value.getMapValue());\n+        break;\n+      default:\n+        throw fail(\"Invalid value type: \" + value.getValueTypeCase());\n+    }\n+  }\n+\n+  private static void canonifyTimestamp(StringBuilder builder, Timestamp timestamp) {\n+    builder.append(String.format(\"time(%s,%s)\", timestamp.getSeconds(), timestamp.getNanos()));\n+  }\n+\n+  private static void canonifyGeoPoint(StringBuilder builder, LatLng latLng) {\n+    builder.append(String.format(\"geo(%s,%s)\", latLng.getLatitude(), latLng.getLongitude()));\n+  }\n+\n+  private static void canonifyObject(StringBuilder builder, MapValue mapValue) {\n+    // Even though MapValue are likely sorted correctly based on their insertion order (e.g. when\n+    // received from the backend), local modifications can bring elements out of order. We need to\n+    // re-sort the elements to ensure that canonical IDs are independent of insertion order.\n+    List<String> keys = new ArrayList<>(mapValue.getFieldsMap().keySet());\n+    Collections.sort(keys);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3b6a77b5121c7d486288c40f80453886f79d70b"}, "originalPosition": 76}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5b1d303eb441d858b1672486b92ef39342cfda86", "author": {"user": {"login": "schmidt-sebastian", "name": "Sebastian Schmidt"}}, "url": "https://github.com/firebase/firebase-android-sdk/commit/5b1d303eb441d858b1672486b92ef39342cfda86", "committedDate": "2020-02-01T00:25:14Z", "message": "Update ProtoValues.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "51d86841544a3f657386da611238f15458461542", "author": {"user": {"login": "schmidt-sebastian", "name": "Sebastian Schmidt"}}, "url": "https://github.com/firebase/firebase-android-sdk/commit/51d86841544a3f657386da611238f15458461542", "committedDate": "2020-02-01T01:21:50Z", "message": "Revert Collections.sort()"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2285, "cost": 1, "resetAt": "2021-11-01T14:20:25Z"}}}