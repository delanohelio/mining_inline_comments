{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk1MTQ1OTY1", "number": 3102, "reviewThreads": {"totalCount": 21, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQwMDoyODo0M1rODs5uOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxNjo1MTo1NlrOD7Um_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4NDA5NjU3OnYy", "diffSide": "RIGHT", "path": "Essentials/src/com/earth2me/essentials/Teleport.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQwMDoyODo0M1rOF-BC6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQwMDo1MzowMlrOF-Bdig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU3MzE2MA==", "bodyText": "We never need an 'async' call inside any other 'async' callbacks because the chunk has already been loaded - this should make the code a lot nicer.", "url": "https://github.com/EssentialsX/Essentials/pull/3102#discussion_r400573160", "createdAt": "2020-03-31T00:28:43Z", "author": {"login": "Ichbinjoe"}, "path": "Essentials/src/com/earth2me/essentials/Teleport.java", "diffHunk": "@@ -121,28 +121,38 @@ public void now(Player entity, boolean cooldown, TeleportCause cause) throws Exc\n     protected void now(IUser teleportee, ITarget target, TeleportCause cause) throws Exception {\n         cancel(false);\n         teleportee.setLastLocation();\n-        Location loc = target.getLocation();\n \n-        if (LocationUtil.isBlockUnsafeForUser(teleportee, loc.getWorld(), loc.getBlockX(), loc.getBlockY(), loc.getBlockZ())) {\n-            if (ess.getSettings().isTeleportSafetyEnabled()) {\n-                if (ess.getSettings().isForceDisableTeleportSafety()) {\n-                    PaperLib.teleportAsync(teleportee.getBase(), loc, cause);\n+        PaperLib.getChunkAtAsync(target.getLocation()).thenAccept(chunk -> {\n+            Location loc = target.getLocation();\n+            if (LocationUtil.isBlockUnsafeForUser(teleportee, chunk, loc.getBlockX(), loc.getBlockY(), loc.getBlockZ())) {\n+                if (ess.getSettings().isTeleportSafetyEnabled()) {\n+                    if (ess.getSettings().isForceDisableTeleportSafety()) {\n+                        PaperLib.teleportAsync(teleportee.getBase(), loc, cause);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e1cb48d07bf2faacb41c6d6fd5276274ff97344"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU3OTk3OA==", "bodyText": "This would be a single line change but sure I guess", "url": "https://github.com/EssentialsX/Essentials/pull/3102#discussion_r400579978", "createdAt": "2020-03-31T00:53:02Z", "author": {"login": "JRoy"}, "path": "Essentials/src/com/earth2me/essentials/Teleport.java", "diffHunk": "@@ -121,28 +121,38 @@ public void now(Player entity, boolean cooldown, TeleportCause cause) throws Exc\n     protected void now(IUser teleportee, ITarget target, TeleportCause cause) throws Exception {\n         cancel(false);\n         teleportee.setLastLocation();\n-        Location loc = target.getLocation();\n \n-        if (LocationUtil.isBlockUnsafeForUser(teleportee, loc.getWorld(), loc.getBlockX(), loc.getBlockY(), loc.getBlockZ())) {\n-            if (ess.getSettings().isTeleportSafetyEnabled()) {\n-                if (ess.getSettings().isForceDisableTeleportSafety()) {\n-                    PaperLib.teleportAsync(teleportee.getBase(), loc, cause);\n+        PaperLib.getChunkAtAsync(target.getLocation()).thenAccept(chunk -> {\n+            Location loc = target.getLocation();\n+            if (LocationUtil.isBlockUnsafeForUser(teleportee, chunk, loc.getBlockX(), loc.getBlockY(), loc.getBlockZ())) {\n+                if (ess.getSettings().isTeleportSafetyEnabled()) {\n+                    if (ess.getSettings().isForceDisableTeleportSafety()) {\n+                        PaperLib.teleportAsync(teleportee.getBase(), loc, cause);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU3MzE2MA=="}, "originalCommit": {"oid": "0e1cb48d07bf2faacb41c6d6fd5276274ff97344"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4NDEwMTQzOnYy", "diffSide": "RIGHT", "path": "Essentials/src/com/earth2me/essentials/Teleport.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQwMDozMToyMFrOF-BFug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQwMTo1NjoyOFrOF-uMYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU3Mzg4Mg==", "bodyText": "I think you have hit the crux of why this hasn't happened previously :)\nWe can't throw the exception back upstream obviously because we are in a different stack frame. e.printStackTrace() isn't remotely acceptable, and even if it was, we lost the entire point of the exception - to notify the user that the destination of the teleport is unsafe. This is bad design in general (using exceptions as user feedback mechanisms), but unfortunately unless we are going to uproot the entire codebase its here to stay.\nA possible solution is to give now() a separate argument which accepts an exception as a callback, but that would bubble all the way up the stack as Node-esque hell. Not sure what the right solution here is.", "url": "https://github.com/EssentialsX/Essentials/pull/3102#discussion_r400573882", "createdAt": "2020-03-31T00:31:20Z", "author": {"login": "Ichbinjoe"}, "path": "Essentials/src/com/earth2me/essentials/Teleport.java", "diffHunk": "@@ -121,28 +121,38 @@ public void now(Player entity, boolean cooldown, TeleportCause cause) throws Exc\n     protected void now(IUser teleportee, ITarget target, TeleportCause cause) throws Exception {\n         cancel(false);\n         teleportee.setLastLocation();\n-        Location loc = target.getLocation();\n \n-        if (LocationUtil.isBlockUnsafeForUser(teleportee, loc.getWorld(), loc.getBlockX(), loc.getBlockY(), loc.getBlockZ())) {\n-            if (ess.getSettings().isTeleportSafetyEnabled()) {\n-                if (ess.getSettings().isForceDisableTeleportSafety()) {\n-                    PaperLib.teleportAsync(teleportee.getBase(), loc, cause);\n+        PaperLib.getChunkAtAsync(target.getLocation()).thenAccept(chunk -> {\n+            Location loc = target.getLocation();\n+            if (LocationUtil.isBlockUnsafeForUser(teleportee, chunk, loc.getBlockX(), loc.getBlockY(), loc.getBlockZ())) {\n+                if (ess.getSettings().isTeleportSafetyEnabled()) {\n+                    if (ess.getSettings().isForceDisableTeleportSafety()) {\n+                        PaperLib.teleportAsync(teleportee.getBase(), loc, cause);\n+                    } else {\n+                        try {\n+                            PaperLib.teleportAsync(teleportee.getBase(), LocationUtil.getSafeDestination(ess, teleportee, loc), cause);\n+                        } catch (Exception e) {\n+                            e.printStackTrace();\n+                        }\n+                    }\n                 } else {\n-                    PaperLib.teleportAsync(teleportee.getBase(), LocationUtil.getSafeDestination(ess, teleportee, loc), cause);\n+                    try {\n+                        throw new Exception(tl(\"unsafeTeleportDestination\", loc.getWorld().getName(), loc.getBlockX(), loc.getBlockY(), loc.getBlockZ()));\n+                    } catch (Exception e) {\n+                        e.printStackTrace();\n+                    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e1cb48d07bf2faacb41c6d6fd5276274ff97344"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDYxMjM1Ng==", "bodyText": "I looked into it, creating a callable is way too much of hassle to do here than just printing the stack trace. The point of these exceptions are to inform the user of their own mistake. As you pointed out, these are poor uses of exceptions and would require an uproot of the entire codebase to get rid of these poor uses. That being said, I feel like that is not in the scope of this PR and should be addressed separately than hacking in something that would only be used here and not anywhere else.", "url": "https://github.com/EssentialsX/Essentials/pull/3102#discussion_r400612356", "createdAt": "2020-03-31T02:54:04Z", "author": {"login": "JRoy"}, "path": "Essentials/src/com/earth2me/essentials/Teleport.java", "diffHunk": "@@ -121,28 +121,38 @@ public void now(Player entity, boolean cooldown, TeleportCause cause) throws Exc\n     protected void now(IUser teleportee, ITarget target, TeleportCause cause) throws Exception {\n         cancel(false);\n         teleportee.setLastLocation();\n-        Location loc = target.getLocation();\n \n-        if (LocationUtil.isBlockUnsafeForUser(teleportee, loc.getWorld(), loc.getBlockX(), loc.getBlockY(), loc.getBlockZ())) {\n-            if (ess.getSettings().isTeleportSafetyEnabled()) {\n-                if (ess.getSettings().isForceDisableTeleportSafety()) {\n-                    PaperLib.teleportAsync(teleportee.getBase(), loc, cause);\n+        PaperLib.getChunkAtAsync(target.getLocation()).thenAccept(chunk -> {\n+            Location loc = target.getLocation();\n+            if (LocationUtil.isBlockUnsafeForUser(teleportee, chunk, loc.getBlockX(), loc.getBlockY(), loc.getBlockZ())) {\n+                if (ess.getSettings().isTeleportSafetyEnabled()) {\n+                    if (ess.getSettings().isForceDisableTeleportSafety()) {\n+                        PaperLib.teleportAsync(teleportee.getBase(), loc, cause);\n+                    } else {\n+                        try {\n+                            PaperLib.teleportAsync(teleportee.getBase(), LocationUtil.getSafeDestination(ess, teleportee, loc), cause);\n+                        } catch (Exception e) {\n+                            e.printStackTrace();\n+                        }\n+                    }\n                 } else {\n-                    PaperLib.teleportAsync(teleportee.getBase(), LocationUtil.getSafeDestination(ess, teleportee, loc), cause);\n+                    try {\n+                        throw new Exception(tl(\"unsafeTeleportDestination\", loc.getWorld().getName(), loc.getBlockX(), loc.getBlockY(), loc.getBlockZ()));\n+                    } catch (Exception e) {\n+                        e.printStackTrace();\n+                    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU3Mzg4Mg=="}, "originalCommit": {"oid": "0e1cb48d07bf2faacb41c6d6fd5276274ff97344"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDYxMjgzMg==", "bodyText": "I would like the feedback of other team members on this as well!\nCC: @pop4959 @md678685", "url": "https://github.com/EssentialsX/Essentials/pull/3102#discussion_r400612832", "createdAt": "2020-03-31T02:55:23Z", "author": {"login": "JRoy"}, "path": "Essentials/src/com/earth2me/essentials/Teleport.java", "diffHunk": "@@ -121,28 +121,38 @@ public void now(Player entity, boolean cooldown, TeleportCause cause) throws Exc\n     protected void now(IUser teleportee, ITarget target, TeleportCause cause) throws Exception {\n         cancel(false);\n         teleportee.setLastLocation();\n-        Location loc = target.getLocation();\n \n-        if (LocationUtil.isBlockUnsafeForUser(teleportee, loc.getWorld(), loc.getBlockX(), loc.getBlockY(), loc.getBlockZ())) {\n-            if (ess.getSettings().isTeleportSafetyEnabled()) {\n-                if (ess.getSettings().isForceDisableTeleportSafety()) {\n-                    PaperLib.teleportAsync(teleportee.getBase(), loc, cause);\n+        PaperLib.getChunkAtAsync(target.getLocation()).thenAccept(chunk -> {\n+            Location loc = target.getLocation();\n+            if (LocationUtil.isBlockUnsafeForUser(teleportee, chunk, loc.getBlockX(), loc.getBlockY(), loc.getBlockZ())) {\n+                if (ess.getSettings().isTeleportSafetyEnabled()) {\n+                    if (ess.getSettings().isForceDisableTeleportSafety()) {\n+                        PaperLib.teleportAsync(teleportee.getBase(), loc, cause);\n+                    } else {\n+                        try {\n+                            PaperLib.teleportAsync(teleportee.getBase(), LocationUtil.getSafeDestination(ess, teleportee, loc), cause);\n+                        } catch (Exception e) {\n+                            e.printStackTrace();\n+                        }\n+                    }\n                 } else {\n-                    PaperLib.teleportAsync(teleportee.getBase(), LocationUtil.getSafeDestination(ess, teleportee, loc), cause);\n+                    try {\n+                        throw new Exception(tl(\"unsafeTeleportDestination\", loc.getWorld().getName(), loc.getBlockX(), loc.getBlockY(), loc.getBlockZ()));\n+                    } catch (Exception e) {\n+                        e.printStackTrace();\n+                    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU3Mzg4Mg=="}, "originalCommit": {"oid": "0e1cb48d07bf2faacb41c6d6fd5276274ff97344"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDY4NTYxNA==", "bodyText": "Unfortunately without somehow signalling up to the user how things broke, this is a regression of behavior. I would also agree that fixing that is not in the scope of this PR, but breaking user experience changes like this has been something that EssentialsX has always tried to avoid (to its own peril a lot of the time sure, but then again server owners are an interesting bunch).\nhttps://xkcd.com/1172/", "url": "https://github.com/EssentialsX/Essentials/pull/3102#discussion_r400685614", "createdAt": "2020-03-31T07:04:02Z", "author": {"login": "Ichbinjoe"}, "path": "Essentials/src/com/earth2me/essentials/Teleport.java", "diffHunk": "@@ -121,28 +121,38 @@ public void now(Player entity, boolean cooldown, TeleportCause cause) throws Exc\n     protected void now(IUser teleportee, ITarget target, TeleportCause cause) throws Exception {\n         cancel(false);\n         teleportee.setLastLocation();\n-        Location loc = target.getLocation();\n \n-        if (LocationUtil.isBlockUnsafeForUser(teleportee, loc.getWorld(), loc.getBlockX(), loc.getBlockY(), loc.getBlockZ())) {\n-            if (ess.getSettings().isTeleportSafetyEnabled()) {\n-                if (ess.getSettings().isForceDisableTeleportSafety()) {\n-                    PaperLib.teleportAsync(teleportee.getBase(), loc, cause);\n+        PaperLib.getChunkAtAsync(target.getLocation()).thenAccept(chunk -> {\n+            Location loc = target.getLocation();\n+            if (LocationUtil.isBlockUnsafeForUser(teleportee, chunk, loc.getBlockX(), loc.getBlockY(), loc.getBlockZ())) {\n+                if (ess.getSettings().isTeleportSafetyEnabled()) {\n+                    if (ess.getSettings().isForceDisableTeleportSafety()) {\n+                        PaperLib.teleportAsync(teleportee.getBase(), loc, cause);\n+                    } else {\n+                        try {\n+                            PaperLib.teleportAsync(teleportee.getBase(), LocationUtil.getSafeDestination(ess, teleportee, loc), cause);\n+                        } catch (Exception e) {\n+                            e.printStackTrace();\n+                        }\n+                    }\n                 } else {\n-                    PaperLib.teleportAsync(teleportee.getBase(), LocationUtil.getSafeDestination(ess, teleportee, loc), cause);\n+                    try {\n+                        throw new Exception(tl(\"unsafeTeleportDestination\", loc.getWorld().getName(), loc.getBlockX(), loc.getBlockY(), loc.getBlockZ()));\n+                    } catch (Exception e) {\n+                        e.printStackTrace();\n+                    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU3Mzg4Mg=="}, "originalCommit": {"oid": "0e1cb48d07bf2faacb41c6d6fd5276274ff97344"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTMxMjg2NQ==", "bodyText": "I haven't had the time to properly look into or test this PR yet, however I'll just say that existing behavior should be retained, including providing correct errors back to the user (and wherever else). If it's not possible to work around how Essentials' exception system works then it definitely blocks this PR and that will need to be taken care of first (perhaps by doing some refactoring so that the user errors can be accessed without needing to go through an exception). As Roy mentioned it is not in scope for this PR but it would certainly need to be addressed before pulling this.\nMD has been somewhat busy lately, so it may be a while for him to give some assessment on this, but I'll try to give this PR more love soon. We should definitely discuss this carefully and not rush to push out these changes before they are completely ready.", "url": "https://github.com/EssentialsX/Essentials/pull/3102#discussion_r401312865", "createdAt": "2020-04-01T01:56:28Z", "author": {"login": "pop4959"}, "path": "Essentials/src/com/earth2me/essentials/Teleport.java", "diffHunk": "@@ -121,28 +121,38 @@ public void now(Player entity, boolean cooldown, TeleportCause cause) throws Exc\n     protected void now(IUser teleportee, ITarget target, TeleportCause cause) throws Exception {\n         cancel(false);\n         teleportee.setLastLocation();\n-        Location loc = target.getLocation();\n \n-        if (LocationUtil.isBlockUnsafeForUser(teleportee, loc.getWorld(), loc.getBlockX(), loc.getBlockY(), loc.getBlockZ())) {\n-            if (ess.getSettings().isTeleportSafetyEnabled()) {\n-                if (ess.getSettings().isForceDisableTeleportSafety()) {\n-                    PaperLib.teleportAsync(teleportee.getBase(), loc, cause);\n+        PaperLib.getChunkAtAsync(target.getLocation()).thenAccept(chunk -> {\n+            Location loc = target.getLocation();\n+            if (LocationUtil.isBlockUnsafeForUser(teleportee, chunk, loc.getBlockX(), loc.getBlockY(), loc.getBlockZ())) {\n+                if (ess.getSettings().isTeleportSafetyEnabled()) {\n+                    if (ess.getSettings().isForceDisableTeleportSafety()) {\n+                        PaperLib.teleportAsync(teleportee.getBase(), loc, cause);\n+                    } else {\n+                        try {\n+                            PaperLib.teleportAsync(teleportee.getBase(), LocationUtil.getSafeDestination(ess, teleportee, loc), cause);\n+                        } catch (Exception e) {\n+                            e.printStackTrace();\n+                        }\n+                    }\n                 } else {\n-                    PaperLib.teleportAsync(teleportee.getBase(), LocationUtil.getSafeDestination(ess, teleportee, loc), cause);\n+                    try {\n+                        throw new Exception(tl(\"unsafeTeleportDestination\", loc.getWorld().getName(), loc.getBlockX(), loc.getBlockY(), loc.getBlockZ()));\n+                    } catch (Exception e) {\n+                        e.printStackTrace();\n+                    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU3Mzg4Mg=="}, "originalCommit": {"oid": "0e1cb48d07bf2faacb41c6d6fd5276274ff97344"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4NDEwNDg3OnYy", "diffSide": "RIGHT", "path": "Essentials/src/com/earth2me/essentials/utils/LocationUtil.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQwMDozMzoyN1rOF-BHyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQwMDozMzoyN1rOF-BHyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU3NDQxMA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    x = x & 0xF;\n          \n          \n            \n                    z = z & 0xF;\n          \n          \n            \n                    return y > chunk.getWorld().getMaxHeight() || HOLLOW_MATERIALS.contains(chunk.getBlock(x, y - 1, z).getType());\n          \n          \n            \n                    return y > chunk.getWorld().getMaxHeight() || HOLLOW_MATERIALS.contains(chunk.getBlock(x & 0xf, y - 1, z & 0xf).getType());\n          \n      \n    \n    \n  \n\nWhile Java doesn't do this, other languages this kind of assignment is scary, as you may be modifying the value out of scope. (You aren't here, you are fine, but it isn't a good pattern)", "url": "https://github.com/EssentialsX/Essentials/pull/3102#discussion_r400574410", "createdAt": "2020-03-31T00:33:27Z", "author": {"login": "Ichbinjoe"}, "path": "Essentials/src/com/earth2me/essentials/utils/LocationUtil.java", "diffHunk": "@@ -89,26 +86,42 @@ public static Location getTarget(final LivingEntity entity) throws Exception {\n     }\n \n     public static boolean isBlockAboveAir(final World world, final int x, final int y, final int z) {\n-        return y > world.getMaxHeight() || HOLLOW_MATERIALS.contains(world.getBlockAt(x, y - 1, z).getType());\n+        return isBlockAboveAir(world.getChunkAt(x, z), x, y, z);\n+    }\n+\n+    public static boolean isBlockAboveAir(final Chunk chunk, int x, final int y, int z) {\n+        x = x & 0xF;\n+        z = z & 0xF;\n+        return y > chunk.getWorld().getMaxHeight() || HOLLOW_MATERIALS.contains(chunk.getBlock(x, y - 1, z).getType());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e1cb48d07bf2faacb41c6d6fd5276274ff97344"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4NDEwNzE1OnYy", "diffSide": "RIGHT", "path": "Essentials/src/com/earth2me/essentials/utils/LocationUtil.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQwMDozNDozNlrOF-BJFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQwMDozNDozNlrOF-BJFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU3NDc0MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    x = x & 0xF;\n          \n          \n            \n                    z = z & 0xF;\n          \n          \n            \n                    final Block below = chunk.getBlock(x, y - 1, z);\n          \n          \n            \n                    final Block below = chunk.getBlock(x & 0xf, y - 1, z & 0xf);\n          \n      \n    \n    \n  \n\nsame as above", "url": "https://github.com/EssentialsX/Essentials/pull/3102#discussion_r400574740", "createdAt": "2020-03-31T00:34:36Z", "author": {"login": "Ichbinjoe"}, "path": "Essentials/src/com/earth2me/essentials/utils/LocationUtil.java", "diffHunk": "@@ -89,26 +86,42 @@ public static Location getTarget(final LivingEntity entity) throws Exception {\n     }\n \n     public static boolean isBlockAboveAir(final World world, final int x, final int y, final int z) {\n-        return y > world.getMaxHeight() || HOLLOW_MATERIALS.contains(world.getBlockAt(x, y - 1, z).getType());\n+        return isBlockAboveAir(world.getChunkAt(x, z), x, y, z);\n+    }\n+\n+    public static boolean isBlockAboveAir(final Chunk chunk, int x, final int y, int z) {\n+        x = x & 0xF;\n+        z = z & 0xF;\n+        return y > chunk.getWorld().getMaxHeight() || HOLLOW_MATERIALS.contains(chunk.getBlock(x, y - 1, z).getType());\n     }\n \n     public static boolean isBlockUnsafeForUser(final IUser user, final World world, final int x, final int y, final int z) {\n-        if (user.getBase().isOnline() && world.equals(user.getBase().getWorld()) && (user.getBase().getGameMode() == GameMode.CREATIVE || user.getBase().getGameMode() == GameMode.SPECTATOR || user.isGodModeEnabled()) && user.getBase().getAllowFlight()) {\n+        return isBlockUnsafeForUser(user, world.getChunkAt(x, z), x, y, z);\n+    }\n+\n+    public static boolean isBlockUnsafeForUser(final IUser user, final Chunk chunk, final int x, final int y, final int z) {\n+        if (user.getBase().isOnline() && chunk.getWorld().equals(user.getBase().getWorld()) && (user.getBase().getGameMode() == GameMode.CREATIVE || user.getBase().getGameMode() == GameMode.SPECTATOR || user.isGodModeEnabled()) && user.getBase().getAllowFlight()) {\n             return false;\n         }\n \n-        if (isBlockDamaging(world, x, y, z)) {\n+        if (isBlockDamaging(chunk, x, y, z)) {\n             return true;\n         }\n-        return isBlockAboveAir(world, x, y, z);\n+        return isBlockAboveAir(chunk, x, y, z);\n     }\n \n     public static boolean isBlockUnsafe(final World world, final int x, final int y, final int z) {\n         return isBlockDamaging(world, x, y, z) || isBlockAboveAir(world, x, y, z);\n     }\n \n     public static boolean isBlockDamaging(final World world, final int x, final int y, final int z) {\n-        final Block below = world.getBlockAt(x, y - 1, z);\n+        return isBlockDamaging(world.getChunkAt(x, z), x, y, z);\n+    }\n+\n+    public static boolean isBlockDamaging(final Chunk chunk, int x, final int y, int z) {\n+        x = x & 0xF;\n+        z = z & 0xF;\n+        final Block below = chunk.getBlock(x, y - 1, z);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e1cb48d07bf2faacb41c6d6fd5276274ff97344"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwNDQxNjI4OnYy", "diffSide": "RIGHT", "path": "Essentials/src/com/earth2me/essentials/Jails.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNVQwNTozNTo1NFrOGA89yQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxNDoxNTozM1rOGEn0cA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzY1MjA0MQ==", "bodyText": "I'm fairly certain that if a 3rd party plugin calls this it will deadlock the server. Should have been more clear when talking about 'deadlocking' in discord.\nI'm fairly certain this is the case - imagine the following:\n\nsendToJail is called\nthe server has a 'cache miss', resulting in a chunk load.\nbut wait! we are using paper, so its a cool async chunk load\nserver goes off and loads the chunk in a separate thread\nServer tries to continue to 126 - which is blocked on a lock. Main thread is now dependent on the async thread completing (which is what we want, because this is maintaining legacy behavior)\nServer is done 'loading' the chunk via IO, but now must load the chunk into the internal chunk map, which includes loading entities\nEntities have to be loaded in sync because they have to figure out bounding box stuff which calls into big block methods which look at worlds at a whole, not just the chunk\nI would assume Paper then waits for the next sync chunk to load the entities and declare the chunk 'loaded'\n\nAt this point, we have deadlocked because the sync thread is unable to progress in order to process the final chunk load, yet in order to progress the chunk must be loaded.", "url": "https://github.com/EssentialsX/Essentials/pull/3102#discussion_r403652041", "createdAt": "2020-04-05T05:35:54Z", "author": {"login": "Ichbinjoe"}, "path": "Essentials/src/com/earth2me/essentials/Jails.java", "diffHunk": "@@ -117,12 +118,31 @@ public void removeJail(final String jail) throws Exception {\n     }\n \n     @Override\n+    @Deprecated\n     public void sendToJail(final IUser user, final String jail) throws Exception {\n+        CompletableFuture<Exception> eFuture = new CompletableFuture<>();\n+        CompletableFuture<Boolean> future = new CompletableFuture<>();\n+        sendToJail(user, jail, eFuture, future);\n+        if (!future.get()) {\n+            throw eFuture.get();\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24cd053ce5b6390454fb9e7035a388dacf88e3d3"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzQ5OTg4OA==", "bodyText": "Should be mitigated as of now", "url": "https://github.com/EssentialsX/Essentials/pull/3102#discussion_r407499888", "createdAt": "2020-04-13T14:15:33Z", "author": {"login": "JRoy"}, "path": "Essentials/src/com/earth2me/essentials/Jails.java", "diffHunk": "@@ -117,12 +118,31 @@ public void removeJail(final String jail) throws Exception {\n     }\n \n     @Override\n+    @Deprecated\n     public void sendToJail(final IUser user, final String jail) throws Exception {\n+        CompletableFuture<Exception> eFuture = new CompletableFuture<>();\n+        CompletableFuture<Boolean> future = new CompletableFuture<>();\n+        sendToJail(user, jail, eFuture, future);\n+        if (!future.get()) {\n+            throw eFuture.get();\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzY1MjA0MQ=="}, "originalCommit": {"oid": "24cd053ce5b6390454fb9e7035a388dacf88e3d3"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyOTQyODk5OnYy", "diffSide": "RIGHT", "path": "Essentials/src/com/earth2me/essentials/commands/Commandjump.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxMjoyMDoxNFrOGEk5hw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxMjoyMDoxNFrOGEk5hw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzQ1MjAzOQ==", "bodyText": "As far as I can tell, the throw new NoChargeException() is to prevent players paying the command cost for both the /jump command and the teleport itself. Does this change alter this behaviour (or am I reading it wrong)?", "url": "https://github.com/EssentialsX/Essentials/pull/3102#discussion_r407452039", "createdAt": "2020-04-13T12:20:14Z", "author": {"login": "mdcfe"}, "path": "Essentials/src/com/earth2me/essentials/commands/Commandjump.java", "diffHunk": "@@ -46,8 +47,7 @@ public void run(final Server server, final User user, final String commandLabel,\n \n         final Trade charge = new Trade(this.getName(), ess);\n         charge.isAffordableFor(user);\n-        user.getTeleport().teleport(loc, charge, TeleportCause.COMMAND);\n-        throw new NoChargeException();\n+        user.getAsyncTeleport().teleport(loc, charge, TeleportCause.COMMAND, getNewExceptionFuture(user.getSource(), commandLabel), new CompletableFuture<>());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd0ce61530843bd862ccd8dd0e55137fa1a3035c"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyOTQ0MDExOnYy", "diffSide": "LEFT", "path": "Essentials/src/com/earth2me/essentials/commands/Commandtppos.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxMjoyNTowMVrOGEk_4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxMjoyNTowMVrOGEk_4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzQ1MzY2Ng==", "bodyText": "Same concern over NoChargeException as earlier", "url": "https://github.com/EssentialsX/Essentials/pull/3102#discussion_r407453666", "createdAt": "2020-04-13T12:25:01Z", "author": {"login": "mdcfe"}, "path": "Essentials/src/com/earth2me/essentials/commands/Commandtppos.java", "diffHunk": "@@ -55,8 +56,7 @@ public void run(final Server server, final User user, final String commandLabel,\n         final Trade charge = new Trade(this.getName(), ess);\n         charge.isAffordableFor(user);\n         user.sendMessage(tl(\"teleporting\", loc.getWorld().getName(), loc.getBlockX(), loc.getBlockY(), loc.getBlockZ()));\n-        user.getTeleport().teleport(loc, charge, TeleportCause.COMMAND);\n-        throw new NoChargeException();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd0ce61530843bd862ccd8dd0e55137fa1a3035c"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyOTQ0Njg4OnYy", "diffSide": "RIGHT", "path": "Essentials/src/com/earth2me/essentials/commands/Commandtpo.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxMjoyNzo1MFrOGElDvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxNDoxNDo0MFrOGEnyjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzQ1NDY1Mw==", "bodyText": "What's the functional difference between using these two lines and just calling getNewExceptionFuture()?", "url": "https://github.com/EssentialsX/Essentials/pull/3102#discussion_r407454653", "createdAt": "2020-04-13T12:27:50Z", "author": {"login": "mdcfe"}, "path": "Essentials/src/com/earth2me/essentials/commands/Commandtpo.java", "diffHunk": "@@ -17,6 +18,8 @@ public Commandtpo() {\n \n     @Override\n     public void run(final Server server, final User user, final String commandLabel, final String[] args) throws Exception {\n+        CompletableFuture<Exception> eFuture = new CompletableFuture<>();\n+        eFuture.thenAccept(e -> showError(user.getBase(), e, commandLabel));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd0ce61530843bd862ccd8dd0e55137fa1a3035c"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzQ5OTQwNg==", "bodyText": "Nothing, I probably wrote that before I made that method. Fixed!", "url": "https://github.com/EssentialsX/Essentials/pull/3102#discussion_r407499406", "createdAt": "2020-04-13T14:14:40Z", "author": {"login": "JRoy"}, "path": "Essentials/src/com/earth2me/essentials/commands/Commandtpo.java", "diffHunk": "@@ -17,6 +18,8 @@ public Commandtpo() {\n \n     @Override\n     public void run(final Server server, final User user, final String commandLabel, final String[] args) throws Exception {\n+        CompletableFuture<Exception> eFuture = new CompletableFuture<>();\n+        eFuture.thenAccept(e -> showError(user.getBase(), e, commandLabel));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzQ1NDY1Mw=="}, "originalCommit": {"oid": "fd0ce61530843bd862ccd8dd0e55137fa1a3035c"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyOTg3NDk2OnYy", "diffSide": "RIGHT", "path": "Essentials/src/com/earth2me/essentials/commands/Commandhome.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxNDo1Mzo0M1rOGEpCDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxNDo1Mzo0M1rOGEpCDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzUxOTc1OA==", "bodyText": "getNewExceptionFuture", "url": "https://github.com/EssentialsX/Essentials/pull/3102#discussion_r407519758", "createdAt": "2020-04-13T14:53:43Z", "author": {"login": "mdcfe"}, "path": "Essentials/src/com/earth2me/essentials/commands/Commandhome.java", "diffHunk": "@@ -38,30 +38,32 @@ public void run(final Server server, final User user, final String commandLabel,\n                 }\n             }\n         }\n+        CompletableFuture<Exception> eFuture = new CompletableFuture<>();\n+        eFuture.thenAccept(e -> showError(user.getBase(), e, commandLabel));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "332545e675dc506fcb54c193a248756194b53c0c"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyOTg3NzY4OnYy", "diffSide": "RIGHT", "path": "Essentials/src/com/earth2me/essentials/commands/Commandtp.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxNDo1NDoyOVrOGEpDqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxNDo1NDoyOVrOGEpDqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzUyMDE3MQ==", "bodyText": "Another getNewExceptionFuture", "url": "https://github.com/EssentialsX/Essentials/pull/3102#discussion_r407520171", "createdAt": "2020-04-13T14:54:29Z", "author": {"login": "mdcfe"}, "path": "Essentials/src/com/earth2me/essentials/commands/Commandtp.java", "diffHunk": "@@ -23,6 +22,9 @@ public Commandtp() {\n \n     @Override\n     public void run(final Server server, final User user, final String commandLabel, final String[] args) throws Exception {\n+        CompletableFuture<Exception> eFuture = new CompletableFuture<>();\n+        CompletableFuture<Boolean> future = new CompletableFuture<>();\n+        eFuture.thenAccept(e -> showError(user.getBase(), e, commandLabel));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "332545e675dc506fcb54c193a248756194b53c0c"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyOTg3OTYxOnYy", "diffSide": "RIGHT", "path": "Essentials/src/com/earth2me/essentials/commands/Commandtpaccept.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxNDo1NTowMVrOGEpE5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxNDo1NTowMVrOGEpE5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzUyMDQ4NQ==", "bodyText": "getNewExceptionFuture", "url": "https://github.com/EssentialsX/Essentials/pull/3102#discussion_r407520485", "createdAt": "2020-04-13T14:55:01Z", "author": {"login": "mdcfe"}, "path": "Essentials/src/com/earth2me/essentials/commands/Commandtpaccept.java", "diffHunk": "@@ -49,24 +51,32 @@ public void run(final Server server, final User user, final String commandLabel,\n         user.sendMessage(tl(\"requestAccepted\"));\n         requester.sendMessage(tl(\"requestAcceptedFrom\", user.getDisplayName()));\n \n-        try {\n-            if (user.isTpRequestHere()) {\n-                final Location loc = user.getTpRequestLocation();\n-                Teleport teleport = requester.getTeleport();\n-                teleport.setTpType(Teleport.TeleportType.TPA);\n-                teleport.teleportPlayer(user, user.getTpRequestLocation(), charge, TeleportCause.COMMAND);\n-                requester.sendMessage(tl(\"teleporting\", loc.getWorld().getName(), loc.getBlockX(), loc.getBlockY(), loc.getBlockZ()));\n-            } else {\n-                Teleport teleport = requester.getTeleport();\n-                teleport.setTpType(Teleport.TeleportType.TPA);\n-                teleport.teleport(user.getBase(), charge, TeleportCause.COMMAND);\n-            }\n-        } catch (Exception ex) {\n+        CompletableFuture<Exception> eFuture = new CompletableFuture<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "332545e675dc506fcb54c193a248756194b53c0c"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyOTg4MDYxOnYy", "diffSide": "RIGHT", "path": "Essentials/src/com/earth2me/essentials/commands/Commandtpall.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxNDo1NToxOFrOGEpFcw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxNDo1NToxOFrOGEpFcw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzUyMDYyNw==", "bodyText": "getNewExceptionFuture", "url": "https://github.com/EssentialsX/Essentials/pull/3102#discussion_r407520627", "createdAt": "2020-04-13T14:55:18Z", "author": {"login": "mdcfe"}, "path": "Essentials/src/com/earth2me/essentials/commands/Commandtpall.java", "diffHunk": "@@ -41,11 +42,9 @@ private void teleportAllPlayers(Server server, CommandSource sender, User target\n             if (sender.equals(target.getBase()) && target.getWorld() != player.getWorld() && ess.getSettings().isWorldTeleportPermissions() && !target.isAuthorized(\"essentials.worlds.\" + target.getWorld().getName())) {\n                 continue;\n             }\n-            try {\n-                player.getTeleport().now(loc, false, TeleportCause.COMMAND);\n-            } catch (Exception ex) {\n-                ess.showError(sender, ex, getName());\n-            }\n+            CompletableFuture<Exception> eFuture = new CompletableFuture<>();\n+            eFuture.thenAccept(e -> showError(sender.getSender(), e, label));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "332545e675dc506fcb54c193a248756194b53c0c"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyOTg4MTU2OnYy", "diffSide": "RIGHT", "path": "Essentials/src/com/earth2me/essentials/commands/Commandtpoffline.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxNDo1NTozNVrOGEpGGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxNDo1NTozNVrOGEpGGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzUyMDc5Mg==", "bodyText": "getNewExceptionFuture", "url": "https://github.com/EssentialsX/Essentials/pull/3102#discussion_r407520792", "createdAt": "2020-04-13T14:55:35Z", "author": {"login": "mdcfe"}, "path": "Essentials/src/com/earth2me/essentials/commands/Commandtpoffline.java", "diffHunk": "@@ -28,7 +30,9 @@ public void run(final Server server, final User user, final String label, final\n                 }\n \n                 user.sendMessage(tl(\"teleporting\", logout.getWorld().getName(), logout.getBlockX(), logout.getBlockY(), logout.getBlockZ()));\n-                user.getTeleport().now(logout, false, PlayerTeleportEvent.TeleportCause.COMMAND);\n+                CompletableFuture<Exception> eFuture = new CompletableFuture<>();\n+                eFuture.thenAccept(e -> showError(user.getBase(), e, label));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "332545e675dc506fcb54c193a248756194b53c0c"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyOTg4MjMyOnYy", "diffSide": "RIGHT", "path": "Essentials/src/com/earth2me/essentials/commands/Commandtpohere.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxNDo1NTo0OVrOGEpGjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxNDo1NTo0OVrOGEpGjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzUyMDkwOA==", "bodyText": "getNewExceptionFuture", "url": "https://github.com/EssentialsX/Essentials/pull/3102#discussion_r407520908", "createdAt": "2020-04-13T14:55:49Z", "author": {"login": "mdcfe"}, "path": "Essentials/src/com/earth2me/essentials/commands/Commandtpohere.java", "diffHunk": "@@ -28,8 +29,9 @@ public void run(final Server server, final User user, final String commandLabel,\n             throw new Exception(tl(\"noPerm\", \"essentials.worlds.\" + user.getWorld().getName()));\n         }\n \n-        // Verify permission\n-        player.getTeleport().now(user.getBase(), false, TeleportCause.COMMAND);\n+        CompletableFuture<Exception> eFuture = new CompletableFuture<>();\n+        eFuture.thenAccept(e -> showError(user.getBase(), e, commandLabel));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "332545e675dc506fcb54c193a248756194b53c0c"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzMDgzMDE4OnYy", "diffSide": "RIGHT", "path": "Essentials/src/com/earth2me/essentials/commands/Commandtp.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxOTozMTo0N1rOGEyTHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxOTozMTo0N1rOGEyTHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY3MTU4Mw==", "bodyText": "Seems like I missed this one the first time around.", "url": "https://github.com/EssentialsX/Essentials/pull/3102#discussion_r407671583", "createdAt": "2020-04-13T19:31:47Z", "author": {"login": "mdcfe"}, "path": "Essentials/src/com/earth2me/essentials/commands/Commandtp.java", "diffHunk": "@@ -113,7 +121,9 @@ public void run(final Server server, final CommandSource sender, final String co\n         if (args.length == 2) {\n             final User toPlayer = getPlayer(server, args, 1, true, false);\n             target.sendMessage(tl(\"teleportAtoB\", Console.NAME, toPlayer.getDisplayName()));\n-            target.getTeleport().now(toPlayer.getBase(), false, TeleportCause.COMMAND);\n+            CompletableFuture<Exception> eFuture = new CompletableFuture<>();\n+            target.getAsyncTeleport().now(toPlayer.getBase(), false, TeleportCause.COMMAND, eFuture, new CompletableFuture<>());\n+            eFuture.thenAccept(e -> showError(sender.getSender(), e, commandLabel));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4df801271f808abb4160a242a8625e849f03465"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzMDgzMzk5OnYy", "diffSide": "RIGHT", "path": "Essentials/src/com/earth2me/essentials/commands/Commandtp.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxOTozMjo1N1rOGEyViA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxOTozMjo1N1rOGEyViA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY3MjIwMA==", "bodyText": "Also this one.", "url": "https://github.com/EssentialsX/Essentials/pull/3102#discussion_r407672200", "createdAt": "2020-04-13T19:32:57Z", "author": {"login": "mdcfe"}, "path": "Essentials/src/com/earth2me/essentials/commands/Commandtp.java", "diffHunk": "@@ -123,8 +133,15 @@ public void run(final Server server, final CommandSource sender, final String co\n             }\n             final Location loc = new Location(target.getWorld(), x, y, z, target.getLocation().getYaw(), target.getLocation().getPitch());\n             sender.sendMessage(tl(\"teleporting\", loc.getWorld().getName(), loc.getBlockX(), loc.getBlockY(), loc.getBlockZ()));\n-            target.getTeleport().now(loc, false, TeleportCause.COMMAND);\n-            target.sendMessage(tl(\"teleporting\", loc.getWorld().getName(), loc.getBlockX(), loc.getBlockY(), loc.getBlockZ()));\n+            CompletableFuture<Exception> eFuture = new CompletableFuture<>();\n+            CompletableFuture<Boolean> future = new CompletableFuture<>();\n+            target.getAsyncTeleport().now(loc, false, TeleportCause.COMMAND, eFuture, future);\n+            future.thenAccept(success -> {\n+                if (success) {\n+                    target.sendMessage(tl(\"teleporting\", loc.getWorld().getName(), loc.getBlockX(), loc.getBlockY(), loc.getBlockZ()));\n+                }\n+            });\n+            eFuture.thenAccept(e -> showError(sender.getSender(), e, commandLabel));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4df801271f808abb4160a242a8625e849f03465"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNTY5NDA5OnYy", "diffSide": "RIGHT", "path": "Essentials/src/com/earth2me/essentials/api/ITeleport.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMTowNzoxOVrOGFg8UA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMTowNzoxOVrOGFg8UA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQzNTc5Mg==", "bodyText": "ok", "url": "https://github.com/EssentialsX/Essentials/pull/3102#discussion_r408435792", "createdAt": "2020-04-14T21:07:19Z", "author": {"login": "pop4959"}, "path": "Essentials/src/com/earth2me/essentials/api/ITeleport.java", "diffHunk": "@@ -117,17 +129,19 @@\n      *\n      * @param teleporter - The user performing the /back command.\n      *                   This value may be {@code null} to indicate console.\n-     * @param chargeFor - What the {@code teleporter} will be charged if teleportPlayer is successful\n+     * @param chargeFor  - What the {@code teleporter} will be charged if teleportPlayer is successful", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "944f112d557b181f4b4755ae63fbaef22b0805e2"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNTc1NjMyOnYy", "diffSide": "RIGHT", "path": "Essentials/src/com/earth2me/essentials/commands/EssentialsCommand.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMToyNTo0N1rOGFhhuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMToyNTo0N1rOGFhhuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ0NTM3MQ==", "bodyText": "Logger::info would also work here", "url": "https://github.com/EssentialsX/Essentials/pull/3102#discussion_r408445371", "createdAt": "2020-04-14T21:25:47Z", "author": {"login": "pop4959"}, "path": "Essentials/src/com/earth2me/essentials/commands/EssentialsCommand.java", "diffHunk": "@@ -344,6 +347,21 @@ private static boolean canInteractWith(User interactor, User interactee) {\n         return command.tabComplete(sender.getSender(), label, effectiveArgs);\n     }\n \n+    @Override\n+    public void showError(CommandSender sender, Throwable throwable, String commandLabel) {\n+        sender.sendMessage(tl(\"errorWithMessage\", throwable.getMessage()));\n+        if (ess.getSettings().isDebug()) {\n+            ess.getLogger().log(Level.INFO, tl(\"errorCallingCommand\", commandLabel), throwable);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "944f112d557b181f4b4755ae63fbaef22b0805e2"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwNTU3MzEwOnYy", "diffSide": "RIGHT", "path": "Essentials/src/com/earth2me/essentials/AsyncTeleport.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQyMToxNTo1OFrOGPV8cw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQyMTo0MzoyMVrOGPWhaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc0MTM2Mw==", "bodyText": "This logic is called on main, thus this will deadlock; need to check the current thread before doing this", "url": "https://github.com/EssentialsX/Essentials/pull/3102#discussion_r418741363", "createdAt": "2020-05-01T21:15:58Z", "author": {"login": "electronicboy"}, "path": "Essentials/src/com/earth2me/essentials/AsyncTeleport.java", "diffHunk": "@@ -0,0 +1,419 @@\n+package com.earth2me.essentials;\n+\n+import com.earth2me.essentials.api.IAsyncTeleport;\n+import com.earth2me.essentials.commands.WarpNotFoundException;\n+import com.earth2me.essentials.utils.DateUtil;\n+import com.earth2me.essentials.utils.LocationUtil;\n+import io.papermc.lib.PaperLib;\n+import net.ess3.api.IEssentials;\n+import net.ess3.api.IUser;\n+import net.ess3.api.InvalidWorldException;\n+import net.ess3.api.events.UserTeleportEvent;\n+import net.ess3.api.events.UserWarpEvent;\n+import org.bukkit.Bukkit;\n+import org.bukkit.Location;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.player.PlayerRespawnEvent;\n+import org.bukkit.event.player.PlayerTeleportEvent.TeleportCause;\n+\n+import java.math.BigDecimal;\n+import java.util.Calendar;\n+import java.util.GregorianCalendar;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+\n+import static com.earth2me.essentials.I18n.tl;\n+\n+\n+public class AsyncTeleport implements IAsyncTeleport {\n+    private final IUser teleportOwner;\n+    private final IEssentials ess;\n+    private AsyncTimedTeleport timedTeleport;\n+\n+    private TeleportType tpType;\n+\n+    public AsyncTeleport(IUser user, IEssentials ess) {\n+        this.teleportOwner = user;\n+        this.ess = ess;\n+        tpType = TeleportType.NORMAL;\n+    }\n+\n+    public enum TeleportType {\n+        TPA,\n+        BACK,\n+        NORMAL\n+    }\n+\n+    public void cooldown(boolean check) throws Throwable {\n+        CompletableFuture<Boolean> exceptionFuture = new CompletableFuture<>();\n+        if (cooldown(check, exceptionFuture)) {\n+            try {\n+                exceptionFuture.get();\n+            } catch (ExecutionException e) {\n+                throw e.getCause();\n+            }\n+        }\n+    }\n+\n+    public boolean cooldown(boolean check, CompletableFuture<Boolean> future) {\n+        final Calendar time = new GregorianCalendar();\n+        if (teleportOwner.getLastTeleportTimestamp() > 0) {\n+            // Take the current time, and remove the delay from it.\n+            final double cooldown = ess.getSettings().getTeleportCooldown();\n+            final Calendar earliestTime = new GregorianCalendar();\n+            earliestTime.add(Calendar.SECOND, -(int) cooldown);\n+            earliestTime.add(Calendar.MILLISECOND, -(int) ((cooldown * 1000.0) % 1000.0));\n+            // This value contains the most recent time a teleportPlayer could have been used that would allow another use.\n+            final long earliestLong = earliestTime.getTimeInMillis();\n+\n+            // When was the last teleportPlayer used?\n+            final long lastTime = teleportOwner.getLastTeleportTimestamp();\n+\n+            if (lastTime > time.getTimeInMillis()) {\n+                // This is to make sure time didn't get messed up on last teleportPlayer use.\n+                // If this happens, let's give the user the benifit of the doubt.\n+                teleportOwner.setLastTeleportTimestamp(time.getTimeInMillis());\n+                return false;\n+            } else if (lastTime > earliestLong\n+                && cooldownApplies()) {\n+                time.setTimeInMillis(lastTime);\n+                time.add(Calendar.SECOND, (int) cooldown);\n+                time.add(Calendar.MILLISECOND, (int) ((cooldown * 1000.0) % 1000.0));\n+                future.completeExceptionally(new Exception(tl(\"timeBeforeTeleport\", DateUtil.formatDateDiff(time.getTimeInMillis()))));\n+                return true;\n+            }\n+        }\n+        // if justCheck is set, don't update lastTeleport; we're just checking\n+        if (!check) {\n+            teleportOwner.setLastTeleportTimestamp(time.getTimeInMillis());\n+        }\n+        return false;\n+    }\n+\n+    private boolean cooldownApplies() {\n+        boolean applies = true;\n+        String globalBypassPerm = \"essentials.teleport.cooldown.bypass\";\n+        switch (tpType) {\n+            case NORMAL:\n+                applies = !teleportOwner.isAuthorized(globalBypassPerm);\n+                break;\n+            case BACK:\n+                applies = !(teleportOwner.isAuthorized(globalBypassPerm) &&\n+                    teleportOwner.isAuthorized(\"essentials.teleport.cooldown.bypass.back\"));\n+                break;\n+            case TPA:\n+                applies = !(teleportOwner.isAuthorized(globalBypassPerm) &&\n+                    teleportOwner.isAuthorized(\"essentials.teleport.cooldown.bypass.tpa\"));\n+                break;\n+        }\n+        return applies;\n+    }\n+\n+    private void warnUser(final IUser user, final double delay) {\n+        Calendar c = new GregorianCalendar();\n+        c.add(Calendar.SECOND, (int) delay);\n+        c.add(Calendar.MILLISECOND, (int) ((delay * 1000.0) % 1000.0));\n+        user.sendMessage(tl(\"dontMoveMessage\", DateUtil.formatDateDiff(c.getTimeInMillis())));\n+    }\n+\n+\n+    @Override\n+    public void now(Location loc, boolean cooldown, TeleportCause cause, CompletableFuture<Boolean> future) {\n+        if (cooldown && cooldown(false, future)) {\n+            return;\n+        }\n+        final ITarget target = new LocationTarget(loc);\n+        nowAsync(teleportOwner, target, cause, future);\n+    }\n+\n+    @Override\n+    public void now(Player entity, boolean cooldown, TeleportCause cause, CompletableFuture<Boolean> future) {\n+        if (cooldown && cooldown(false, future)) {\n+            future.complete(false);\n+            return;\n+        }\n+        final ITarget target = new PlayerTarget(entity);\n+        nowAsync(teleportOwner, target, cause, future);\n+        future.thenAccept(success -> {\n+            if (success) {\n+                teleportOwner.sendMessage(tl(\"teleporting\", target.getLocation().getWorld().getName(), target.getLocation().getBlockX(), target.getLocation().getBlockY(), target.getLocation().getBlockZ()));\n+            }\n+        });\n+    }\n+\n+    protected void nowAsync(IUser teleportee, ITarget target, TeleportCause cause, CompletableFuture<Boolean> future) {\n+        cancel(false);\n+\n+        UserTeleportEvent event = new UserTeleportEvent(teleportee, cause, target.getLocation());\n+        Bukkit.getServer().getPluginManager().callEvent(event);\n+        if (event.isCancelled()) {\n+            return;\n+        }\n+        teleportee.setLastLocation();\n+\n+        if (!teleportee.getBase().isEmpty()) {\n+            if (!ess.getSettings().isTeleportPassengerDismount()) {\n+                future.completeExceptionally(new Exception(tl(\"passengerTeleportFail\")));\n+                return;\n+            }\n+            CompletableFuture<Object> dismountFuture = new CompletableFuture<>();\n+            Bukkit.getScheduler().runTask(ess, () -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "613665a7f6bbe4f485def052812b4e82448b5e9e"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc1MDgyNQ==", "bodyText": "Something like this?\n            if (Bukkit.isPrimaryThread()) {\n                teleportee.getBase().eject();\n            } else {\n                CompletableFuture<Object> dismountFuture = new CompletableFuture<>();\n                Bukkit.getScheduler().runTask(ess, () -> {\n                    teleportee.getBase().eject();\n                    dismountFuture.complete(new Object());\n                });\n                try {\n                    dismountFuture.get(); //EntityDismountEvent requires sync context we also want to wait for it to finish\n                } catch (InterruptedException | ExecutionException e) {\n                    future.completeExceptionally(e);\n                    return;\n                }\n            }", "url": "https://github.com/EssentialsX/Essentials/pull/3102#discussion_r418750825", "createdAt": "2020-05-01T21:43:21Z", "author": {"login": "JRoy"}, "path": "Essentials/src/com/earth2me/essentials/AsyncTeleport.java", "diffHunk": "@@ -0,0 +1,419 @@\n+package com.earth2me.essentials;\n+\n+import com.earth2me.essentials.api.IAsyncTeleport;\n+import com.earth2me.essentials.commands.WarpNotFoundException;\n+import com.earth2me.essentials.utils.DateUtil;\n+import com.earth2me.essentials.utils.LocationUtil;\n+import io.papermc.lib.PaperLib;\n+import net.ess3.api.IEssentials;\n+import net.ess3.api.IUser;\n+import net.ess3.api.InvalidWorldException;\n+import net.ess3.api.events.UserTeleportEvent;\n+import net.ess3.api.events.UserWarpEvent;\n+import org.bukkit.Bukkit;\n+import org.bukkit.Location;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.player.PlayerRespawnEvent;\n+import org.bukkit.event.player.PlayerTeleportEvent.TeleportCause;\n+\n+import java.math.BigDecimal;\n+import java.util.Calendar;\n+import java.util.GregorianCalendar;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+\n+import static com.earth2me.essentials.I18n.tl;\n+\n+\n+public class AsyncTeleport implements IAsyncTeleport {\n+    private final IUser teleportOwner;\n+    private final IEssentials ess;\n+    private AsyncTimedTeleport timedTeleport;\n+\n+    private TeleportType tpType;\n+\n+    public AsyncTeleport(IUser user, IEssentials ess) {\n+        this.teleportOwner = user;\n+        this.ess = ess;\n+        tpType = TeleportType.NORMAL;\n+    }\n+\n+    public enum TeleportType {\n+        TPA,\n+        BACK,\n+        NORMAL\n+    }\n+\n+    public void cooldown(boolean check) throws Throwable {\n+        CompletableFuture<Boolean> exceptionFuture = new CompletableFuture<>();\n+        if (cooldown(check, exceptionFuture)) {\n+            try {\n+                exceptionFuture.get();\n+            } catch (ExecutionException e) {\n+                throw e.getCause();\n+            }\n+        }\n+    }\n+\n+    public boolean cooldown(boolean check, CompletableFuture<Boolean> future) {\n+        final Calendar time = new GregorianCalendar();\n+        if (teleportOwner.getLastTeleportTimestamp() > 0) {\n+            // Take the current time, and remove the delay from it.\n+            final double cooldown = ess.getSettings().getTeleportCooldown();\n+            final Calendar earliestTime = new GregorianCalendar();\n+            earliestTime.add(Calendar.SECOND, -(int) cooldown);\n+            earliestTime.add(Calendar.MILLISECOND, -(int) ((cooldown * 1000.0) % 1000.0));\n+            // This value contains the most recent time a teleportPlayer could have been used that would allow another use.\n+            final long earliestLong = earliestTime.getTimeInMillis();\n+\n+            // When was the last teleportPlayer used?\n+            final long lastTime = teleportOwner.getLastTeleportTimestamp();\n+\n+            if (lastTime > time.getTimeInMillis()) {\n+                // This is to make sure time didn't get messed up on last teleportPlayer use.\n+                // If this happens, let's give the user the benifit of the doubt.\n+                teleportOwner.setLastTeleportTimestamp(time.getTimeInMillis());\n+                return false;\n+            } else if (lastTime > earliestLong\n+                && cooldownApplies()) {\n+                time.setTimeInMillis(lastTime);\n+                time.add(Calendar.SECOND, (int) cooldown);\n+                time.add(Calendar.MILLISECOND, (int) ((cooldown * 1000.0) % 1000.0));\n+                future.completeExceptionally(new Exception(tl(\"timeBeforeTeleport\", DateUtil.formatDateDiff(time.getTimeInMillis()))));\n+                return true;\n+            }\n+        }\n+        // if justCheck is set, don't update lastTeleport; we're just checking\n+        if (!check) {\n+            teleportOwner.setLastTeleportTimestamp(time.getTimeInMillis());\n+        }\n+        return false;\n+    }\n+\n+    private boolean cooldownApplies() {\n+        boolean applies = true;\n+        String globalBypassPerm = \"essentials.teleport.cooldown.bypass\";\n+        switch (tpType) {\n+            case NORMAL:\n+                applies = !teleportOwner.isAuthorized(globalBypassPerm);\n+                break;\n+            case BACK:\n+                applies = !(teleportOwner.isAuthorized(globalBypassPerm) &&\n+                    teleportOwner.isAuthorized(\"essentials.teleport.cooldown.bypass.back\"));\n+                break;\n+            case TPA:\n+                applies = !(teleportOwner.isAuthorized(globalBypassPerm) &&\n+                    teleportOwner.isAuthorized(\"essentials.teleport.cooldown.bypass.tpa\"));\n+                break;\n+        }\n+        return applies;\n+    }\n+\n+    private void warnUser(final IUser user, final double delay) {\n+        Calendar c = new GregorianCalendar();\n+        c.add(Calendar.SECOND, (int) delay);\n+        c.add(Calendar.MILLISECOND, (int) ((delay * 1000.0) % 1000.0));\n+        user.sendMessage(tl(\"dontMoveMessage\", DateUtil.formatDateDiff(c.getTimeInMillis())));\n+    }\n+\n+\n+    @Override\n+    public void now(Location loc, boolean cooldown, TeleportCause cause, CompletableFuture<Boolean> future) {\n+        if (cooldown && cooldown(false, future)) {\n+            return;\n+        }\n+        final ITarget target = new LocationTarget(loc);\n+        nowAsync(teleportOwner, target, cause, future);\n+    }\n+\n+    @Override\n+    public void now(Player entity, boolean cooldown, TeleportCause cause, CompletableFuture<Boolean> future) {\n+        if (cooldown && cooldown(false, future)) {\n+            future.complete(false);\n+            return;\n+        }\n+        final ITarget target = new PlayerTarget(entity);\n+        nowAsync(teleportOwner, target, cause, future);\n+        future.thenAccept(success -> {\n+            if (success) {\n+                teleportOwner.sendMessage(tl(\"teleporting\", target.getLocation().getWorld().getName(), target.getLocation().getBlockX(), target.getLocation().getBlockY(), target.getLocation().getBlockZ()));\n+            }\n+        });\n+    }\n+\n+    protected void nowAsync(IUser teleportee, ITarget target, TeleportCause cause, CompletableFuture<Boolean> future) {\n+        cancel(false);\n+\n+        UserTeleportEvent event = new UserTeleportEvent(teleportee, cause, target.getLocation());\n+        Bukkit.getServer().getPluginManager().callEvent(event);\n+        if (event.isCancelled()) {\n+            return;\n+        }\n+        teleportee.setLastLocation();\n+\n+        if (!teleportee.getBase().isEmpty()) {\n+            if (!ess.getSettings().isTeleportPassengerDismount()) {\n+                future.completeExceptionally(new Exception(tl(\"passengerTeleportFail\")));\n+                return;\n+            }\n+            CompletableFuture<Object> dismountFuture = new CompletableFuture<>();\n+            Bukkit.getScheduler().runTask(ess, () -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc0MTM2Mw=="}, "originalCommit": {"oid": "613665a7f6bbe4f485def052812b4e82448b5e9e"}, "originalPosition": 160}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzMDYzODY3OnYy", "diffSide": "RIGHT", "path": "Essentials/src/com/earth2me/essentials/IUser.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQxNjowNDoxNVrOGS8L2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQxNjowNDoxNVrOGS8L2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjUxMzYyNA==", "bodyText": "Could you undo the indentation changes here to clean up the diff?", "url": "https://github.com/EssentialsX/Essentials/pull/3102#discussion_r422513624", "createdAt": "2020-05-09T16:04:15Z", "author": {"login": "mdcfe"}, "path": "Essentials/src/com/earth2me/essentials/IUser.java", "diffHunk": "@@ -154,13 +161,13 @@\n     Map<String, Object> getConfigMap();\n \n     Map<String, Object> getConfigMap(String node);\n-    \n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b92ea836086062040c300e2d1057fc57b3794449"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzNTMwMjM4OnYy", "diffSide": "RIGHT", "path": "Essentials/src/com/earth2me/essentials/IUser.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxNjo1MTo1NlrOGTkyyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxNjo1MTo1NlrOGTkyyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE3ODk1NQ==", "bodyText": "Even if it seems redundant, changing this import from net.ess3.api.ITeleport might cause ABI breakage with plugins that built against the class when it had the old import.", "url": "https://github.com/EssentialsX/Essentials/pull/3102#discussion_r423178955", "createdAt": "2020-05-11T16:51:56Z", "author": {"login": "mdcfe"}, "path": "Essentials/src/com/earth2me/essentials/IUser.java", "diffHunk": "@@ -1,7 +1,8 @@\n package com.earth2me.essentials;\n \n+import com.earth2me.essentials.api.IAsyncTeleport;\n+import com.earth2me.essentials.api.ITeleport;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e72746e628a38df4c77c08ff4b6611a0166005c0"}, "originalPosition": 4}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4778, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}