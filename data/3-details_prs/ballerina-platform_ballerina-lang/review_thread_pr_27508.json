{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQwNDc1NjY4", "number": 27508, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwODo0NDowNlrOFGErDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwODo1NjoyM1rOFGFAoQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxOTEyMzMyOnYy", "diffSide": "RIGHT", "path": "misc/debug-adapter/modules/debug-adapter-core/src/main/java/org/ballerinalang/debugadapter/evaluation/engine/FunctionInvocationExpressionEvaluator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwODo0NDowNlrOIG6BEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxMToyMjoyN1rOIHAf_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDExMjkxNQ==", "bodyText": "If the goal is to find the function from within the constructs in the module itself, you can use the moduleLevelSymbols() API. It basically retrieves the symbols of all the module-level constructs, including non-public ones.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/27508#discussion_r544112915", "createdAt": "2020-12-16T08:44:06Z", "author": {"login": "pubudu91"}, "path": "misc/debug-adapter/modules/debug-adapter-core/src/main/java/org/ballerinalang/debugadapter/evaluation/engine/FunctionInvocationExpressionEvaluator.java", "diffHunk": "@@ -83,69 +87,39 @@ public BExpressionValue evaluate() throws EvaluationException {\n         }\n     }\n \n-    /**\n-     * Searches for a matching jvm method for a given ballerina function using its syntax node and the debug context\n-     * information.\n-     *\n-     * @return the matching JVM method, if available\n-     */\n-    private Optional<GeneratedStaticMethod> findFunctionFromLoadedClasses() {\n-        List<ReferenceType> allClasses = context.getAttachedVm().allClasses();\n-        DebugSourceType sourceType = context.getSourceType();\n-        for (ReferenceType cls : allClasses) {\n-            try {\n-                // Expected class name should end with the file name of the ballerina source, only for single\n-                // ballerina sources. (We cannot be sure about the module context, as we can invoke any method\n-                // defined within the module.)\n-                if (sourceType == DebugSourceType.SINGLE_FILE && !cls.name().endsWith(context.getFileName().get())) {\n-                    continue;\n-                }\n-                // If the sources reside inside a ballerina module/project, generated class name should start with the\n-                // organization name of the ballerina module/project source.\n-                if (sourceType == DebugSourceType.PACKAGE && !cls.name().startsWith(context.getPackageOrg().get())) {\n-                    continue;\n-                }\n-                List<Method> methods = cls.methodsByName(functionName);\n-                for (Method method : methods) {\n-                    // Note - All the ballerina functions are represented as java static methods and all the generated\n-                    // jvm methods contain strand as its first argument.\n-                    if (method.isStatic()) {\n-                        return Optional.of(new GeneratedStaticMethod(context, cls, method));\n-                    }\n-                }\n-            } catch (ClassNotPreparedException ignored) {\n-                // Unprepared classes should be skipped.\n-            }\n+    private Optional<FunctionSymbol> findFunctionWithinModule() {\n+        SemanticModel semanticContext = context.getDebugCompiler().getSemanticInfo();\n+        LinePosition position = LinePosition.from(context.getLineNumber(), 0);\n+        List<Symbol> functionMatches = semanticContext.visibleSymbols(context.getFileNameWithExt().get(), position)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dcab4970c32b9b40e187cd3d49be30a55862e847"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDIxOTEzMg==", "bodyText": "+1. Changed in e1c2ab6", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/27508#discussion_r544219132", "createdAt": "2020-12-16T11:22:27Z", "author": {"login": "NipunaRanasinghe"}, "path": "misc/debug-adapter/modules/debug-adapter-core/src/main/java/org/ballerinalang/debugadapter/evaluation/engine/FunctionInvocationExpressionEvaluator.java", "diffHunk": "@@ -83,69 +87,39 @@ public BExpressionValue evaluate() throws EvaluationException {\n         }\n     }\n \n-    /**\n-     * Searches for a matching jvm method for a given ballerina function using its syntax node and the debug context\n-     * information.\n-     *\n-     * @return the matching JVM method, if available\n-     */\n-    private Optional<GeneratedStaticMethod> findFunctionFromLoadedClasses() {\n-        List<ReferenceType> allClasses = context.getAttachedVm().allClasses();\n-        DebugSourceType sourceType = context.getSourceType();\n-        for (ReferenceType cls : allClasses) {\n-            try {\n-                // Expected class name should end with the file name of the ballerina source, only for single\n-                // ballerina sources. (We cannot be sure about the module context, as we can invoke any method\n-                // defined within the module.)\n-                if (sourceType == DebugSourceType.SINGLE_FILE && !cls.name().endsWith(context.getFileName().get())) {\n-                    continue;\n-                }\n-                // If the sources reside inside a ballerina module/project, generated class name should start with the\n-                // organization name of the ballerina module/project source.\n-                if (sourceType == DebugSourceType.PACKAGE && !cls.name().startsWith(context.getPackageOrg().get())) {\n-                    continue;\n-                }\n-                List<Method> methods = cls.methodsByName(functionName);\n-                for (Method method : methods) {\n-                    // Note - All the ballerina functions are represented as java static methods and all the generated\n-                    // jvm methods contain strand as its first argument.\n-                    if (method.isStatic()) {\n-                        return Optional.of(new GeneratedStaticMethod(context, cls, method));\n-                    }\n-                }\n-            } catch (ClassNotPreparedException ignored) {\n-                // Unprepared classes should be skipped.\n-            }\n+    private Optional<FunctionSymbol> findFunctionWithinModule() {\n+        SemanticModel semanticContext = context.getDebugCompiler().getSemanticInfo();\n+        LinePosition position = LinePosition.from(context.getLineNumber(), 0);\n+        List<Symbol> functionMatches = semanticContext.visibleSymbols(context.getFileNameWithExt().get(), position)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDExMjkxNQ=="}, "originalCommit": {"oid": "dcab4970c32b9b40e187cd3d49be30a55862e847"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxOTE3ODU3OnYy", "diffSide": "RIGHT", "path": "misc/debug-adapter/modules/debug-adapter-core/src/main/java/org/ballerinalang/debugadapter/evaluation/engine/MethodCallExpressionEvaluator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwODo1NjoyM1rOIG6hNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxMToyMjozNlrOIHAgPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDEyMTE0Mw==", "bodyText": "Same comment as above here.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/27508#discussion_r544121143", "createdAt": "2020-12-16T08:56:23Z", "author": {"login": "pubudu91"}, "path": "misc/debug-adapter/modules/debug-adapter-core/src/main/java/org/ballerinalang/debugadapter/evaluation/engine/MethodCallExpressionEvaluator.java", "diffHunk": "@@ -91,6 +113,99 @@ public BExpressionValue evaluate() throws EvaluationException {\n         }\n     }\n \n+    private Value invokeObjectMethod(BVariable resultVar) throws EvaluationException {\n+        boolean isFoundObjectMethod = false;\n+        try {\n+            String className = resultVar.getDapVariable().getValue();\n+            Optional<ClassSymbol> classDef = findClassDefWithinModule(className);\n+            if (classDef.isEmpty()) {\n+                throw new EvaluationException(String.format(EvaluationExceptionKind.CLASS_NOT_FOUND.getString(),\n+                        className));\n+            }\n+\n+            Optional<MethodSymbol> objectMethodDef = findObjectMethodInClass(classDef.get(), methodName);\n+            if (objectMethodDef.isEmpty()) {\n+                throw new EvaluationException(\n+                        String.format(EvaluationExceptionKind.OBJECT_METHOD_NOT_FOUND.getString(),\n+                                syntaxNode.methodName().toString().trim(), className));\n+            }\n+\n+            isFoundObjectMethod = true;\n+            GeneratedInstanceMethod objectMethod = getObjectMethodByName(resultVar, methodName);\n+            objectMethod.setNamedArgValues(generateNamedArgs(context, methodName, objectMethodDef.get().\n+                    typeDescriptor(), argEvaluators));\n+            return objectMethod.invoke();\n+        } catch (EvaluationException e) {\n+            // If the object method is not found, we have to ignore the Evaluation Exception and try find any\n+            // matching lang library functions.\n+            if (isFoundObjectMethod) {\n+                throw e;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private Value invokeLangLibMethod(BExpressionValue resultVar) throws EvaluationException {\n+\n+        FunctionSymbol langLibFunctionDef = null;\n+        GeneratedStaticMethod langLibMethod = null;\n+\n+        // Tries to use the dedicated lang library functions.\n+        String langLibName = getAssociatedLangLibName(resultVar.getType());\n+        Optional<ModuleSymbol> langLibDef = getLangLibDefinition(context, langLibName);\n+        if (langLibDef.isPresent()) {\n+            Optional<FunctionSymbol> functionDef = getLangLibFunctionDefinition(context, langLibDef.get(), methodName);\n+            if (functionDef.isPresent()) {\n+                String langLibCls = getQualifiedLangLibClassName(langLibDef.get(), langLibName);\n+                langLibFunctionDef = functionDef.get();\n+                langLibMethod = loadLangLibMethod(context, resultVar, langLibCls, methodName);\n+            }\n+        }\n+\n+        // Tries to use \"value\" lang library functions.\n+        if (langLibMethod == null) {\n+            Optional<ModuleSymbol> valueLibDef = getLangLibDefinition(context, LANG_LIB_VALUE);\n+            if (valueLibDef.isEmpty()) {\n+                throw new EvaluationException(String.format(EvaluationExceptionKind.LANG_LIB_NOT_FOUND.getString(),\n+                        LANG_LIB_PACKAGE_PREFIX + langLibName + \", \" + LANG_LIB_PACKAGE_PREFIX + LANG_LIB_VALUE));\n+            }\n+\n+            Optional<FunctionSymbol> functionDef = getLangLibFunctionDefinition(context, valueLibDef.get(), methodName);\n+            if (functionDef.isEmpty()) {\n+                throw new EvaluationException(String.format(EvaluationExceptionKind.LANG_LIB_METHOD_NOT_FOUND.\n+                        getString(), methodName, langLibName));\n+            }\n+\n+            String langLibCls = getQualifiedLangLibClassName(valueLibDef.get(), LANG_LIB_VALUE);\n+            langLibFunctionDef = functionDef.get();\n+            langLibMethod = loadLangLibMethod(context, resultVar, langLibCls, methodName);\n+        }\n+\n+        argEvaluators.add(0, new AbstractMap.SimpleEntry<>(\"\", objectExpressionEvaluator));\n+        FunctionTypeSymbol functionTypeDesc = langLibFunctionDef.typeDescriptor();\n+        Map<String, Value> argValueMap = generateNamedArgs(context, methodName, functionTypeDesc, argEvaluators);\n+        langLibMethod.setNamedArgValues(argValueMap);\n+        return langLibMethod.invoke();\n+    }\n+\n+    private Optional<ClassSymbol> findClassDefWithinModule(String className) {\n+        SemanticModel semanticContext = context.getDebugCompiler().getSemanticInfo();\n+        LinePosition position = LinePosition.from(context.getLineNumber(), 0);\n+\n+        return semanticContext.visibleSymbols(context.getFileNameWithExt().get(), position)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dcab4970c32b9b40e187cd3d49be30a55862e847"}, "originalPosition": 169}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDIxOTE5OA==", "bodyText": "+1. Changed in e1c2ab6", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/27508#discussion_r544219198", "createdAt": "2020-12-16T11:22:36Z", "author": {"login": "NipunaRanasinghe"}, "path": "misc/debug-adapter/modules/debug-adapter-core/src/main/java/org/ballerinalang/debugadapter/evaluation/engine/MethodCallExpressionEvaluator.java", "diffHunk": "@@ -91,6 +113,99 @@ public BExpressionValue evaluate() throws EvaluationException {\n         }\n     }\n \n+    private Value invokeObjectMethod(BVariable resultVar) throws EvaluationException {\n+        boolean isFoundObjectMethod = false;\n+        try {\n+            String className = resultVar.getDapVariable().getValue();\n+            Optional<ClassSymbol> classDef = findClassDefWithinModule(className);\n+            if (classDef.isEmpty()) {\n+                throw new EvaluationException(String.format(EvaluationExceptionKind.CLASS_NOT_FOUND.getString(),\n+                        className));\n+            }\n+\n+            Optional<MethodSymbol> objectMethodDef = findObjectMethodInClass(classDef.get(), methodName);\n+            if (objectMethodDef.isEmpty()) {\n+                throw new EvaluationException(\n+                        String.format(EvaluationExceptionKind.OBJECT_METHOD_NOT_FOUND.getString(),\n+                                syntaxNode.methodName().toString().trim(), className));\n+            }\n+\n+            isFoundObjectMethod = true;\n+            GeneratedInstanceMethod objectMethod = getObjectMethodByName(resultVar, methodName);\n+            objectMethod.setNamedArgValues(generateNamedArgs(context, methodName, objectMethodDef.get().\n+                    typeDescriptor(), argEvaluators));\n+            return objectMethod.invoke();\n+        } catch (EvaluationException e) {\n+            // If the object method is not found, we have to ignore the Evaluation Exception and try find any\n+            // matching lang library functions.\n+            if (isFoundObjectMethod) {\n+                throw e;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private Value invokeLangLibMethod(BExpressionValue resultVar) throws EvaluationException {\n+\n+        FunctionSymbol langLibFunctionDef = null;\n+        GeneratedStaticMethod langLibMethod = null;\n+\n+        // Tries to use the dedicated lang library functions.\n+        String langLibName = getAssociatedLangLibName(resultVar.getType());\n+        Optional<ModuleSymbol> langLibDef = getLangLibDefinition(context, langLibName);\n+        if (langLibDef.isPresent()) {\n+            Optional<FunctionSymbol> functionDef = getLangLibFunctionDefinition(context, langLibDef.get(), methodName);\n+            if (functionDef.isPresent()) {\n+                String langLibCls = getQualifiedLangLibClassName(langLibDef.get(), langLibName);\n+                langLibFunctionDef = functionDef.get();\n+                langLibMethod = loadLangLibMethod(context, resultVar, langLibCls, methodName);\n+            }\n+        }\n+\n+        // Tries to use \"value\" lang library functions.\n+        if (langLibMethod == null) {\n+            Optional<ModuleSymbol> valueLibDef = getLangLibDefinition(context, LANG_LIB_VALUE);\n+            if (valueLibDef.isEmpty()) {\n+                throw new EvaluationException(String.format(EvaluationExceptionKind.LANG_LIB_NOT_FOUND.getString(),\n+                        LANG_LIB_PACKAGE_PREFIX + langLibName + \", \" + LANG_LIB_PACKAGE_PREFIX + LANG_LIB_VALUE));\n+            }\n+\n+            Optional<FunctionSymbol> functionDef = getLangLibFunctionDefinition(context, valueLibDef.get(), methodName);\n+            if (functionDef.isEmpty()) {\n+                throw new EvaluationException(String.format(EvaluationExceptionKind.LANG_LIB_METHOD_NOT_FOUND.\n+                        getString(), methodName, langLibName));\n+            }\n+\n+            String langLibCls = getQualifiedLangLibClassName(valueLibDef.get(), LANG_LIB_VALUE);\n+            langLibFunctionDef = functionDef.get();\n+            langLibMethod = loadLangLibMethod(context, resultVar, langLibCls, methodName);\n+        }\n+\n+        argEvaluators.add(0, new AbstractMap.SimpleEntry<>(\"\", objectExpressionEvaluator));\n+        FunctionTypeSymbol functionTypeDesc = langLibFunctionDef.typeDescriptor();\n+        Map<String, Value> argValueMap = generateNamedArgs(context, methodName, functionTypeDesc, argEvaluators);\n+        langLibMethod.setNamedArgValues(argValueMap);\n+        return langLibMethod.invoke();\n+    }\n+\n+    private Optional<ClassSymbol> findClassDefWithinModule(String className) {\n+        SemanticModel semanticContext = context.getDebugCompiler().getSemanticInfo();\n+        LinePosition position = LinePosition.from(context.getLineNumber(), 0);\n+\n+        return semanticContext.visibleSymbols(context.getFileNameWithExt().get(), position)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDEyMTE0Mw=="}, "originalCommit": {"oid": "dcab4970c32b9b40e187cd3d49be30a55862e847"}, "originalPosition": 169}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2757, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}