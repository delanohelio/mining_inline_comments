{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTEzNTk2NDU5", "number": 26693, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwMzowMTowM1rOE0N6DQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwMzowNDowMVrOE0N7Zg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMTg5MjYxOnYy", "diffSide": "RIGHT", "path": "language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/LangExtensionDelegator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwMzowMTowM1rOHr0-Fw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwMzowMTowM1rOHr0-Fw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTcxODY3OQ==", "bodyText": "Specific reason to limit to one? We can merge the results from multiple filtered extensions. eg. there can be two completion extensions with the same uri pattern.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26693#discussion_r515718679", "createdAt": "2020-11-02T03:01:03Z", "author": {"login": "rasika"}, "path": "language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/LangExtensionDelegator.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langserver;\n+\n+import org.ballerinalang.langserver.commons.CompletionExtension;\n+import org.ballerinalang.langserver.commons.DiagnosticsExtension;\n+import org.ballerinalang.langserver.commons.FormattingExtension;\n+import org.ballerinalang.langserver.commons.LSContext;\n+import org.ballerinalang.langserver.commons.LanguageExtension;\n+import org.eclipse.lsp4j.CompletionItem;\n+import org.eclipse.lsp4j.CompletionList;\n+import org.eclipse.lsp4j.CompletionParams;\n+import org.eclipse.lsp4j.DocumentFormattingParams;\n+import org.eclipse.lsp4j.PublishDiagnosticsParams;\n+import org.eclipse.lsp4j.TextEdit;\n+import org.eclipse.lsp4j.jsonrpc.messages.Either;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.ServiceLoader;\n+\n+/**\n+ * Delegate the operation to the valid extension.\n+ *\n+ * @since 2.0.0\n+ */\n+public class LangExtensionDelegator {\n+\n+    private static final LangExtensionDelegator INSTANCE = new LangExtensionDelegator();\n+\n+    private final List<CompletionExtension> completionExtensions = new ArrayList<>();\n+    private final List<FormattingExtension> formatExtensions = new ArrayList<>();\n+    private final List<DiagnosticsExtension> diagExtensions = new ArrayList<>();\n+\n+    private LangExtensionDelegator() {\n+        ServiceLoader.load(LanguageExtension.class).forEach(languageExtension -> {\n+            switch (languageExtension.kind()) {\n+                case COMPLETION:\n+                    completionExtensions.add((CompletionExtension) languageExtension);\n+                    break;\n+                case FORMAT:\n+                    formatExtensions.add((FormattingExtension) languageExtension);\n+                    break;\n+                case DIAGNOSTIC:\n+                    diagExtensions.add((DiagnosticsExtension) languageExtension);\n+                    break;\n+                default:\n+                    break;\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Get the completions.\n+     *\n+     * @param params completion parameters\n+     * @return {@link Either} completion results\n+     */\n+    public Either<List<CompletionItem>, CompletionList> completion(CompletionParams params, LSContext context) {\n+        return completionExtensions.stream().filter(ext -> ext.validate(params))\n+                .map(ext -> ext.execute(params, context))\n+                .findFirst()\n+                .orElse(Either.forRight(new CompletionList()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2b326a82c9406d17d3e6d75bef63e62e0d1c6e4f"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMTg5MzE1OnYy", "diffSide": "RIGHT", "path": "language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/LangExtensionDelegator.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwMzowMToyNVrOHr0-Yg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwNToyMToyNlrOHr2law==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTcxODc1NA==", "bodyText": "Specific reason to limit to one? We can merge the results from multiple filtered extensions. eg. there can be two completion extensions with the same uri pattern.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26693#discussion_r515718754", "createdAt": "2020-11-02T03:01:25Z", "author": {"login": "rasika"}, "path": "language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/LangExtensionDelegator.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langserver;\n+\n+import org.ballerinalang.langserver.commons.CompletionExtension;\n+import org.ballerinalang.langserver.commons.DiagnosticsExtension;\n+import org.ballerinalang.langserver.commons.FormattingExtension;\n+import org.ballerinalang.langserver.commons.LSContext;\n+import org.ballerinalang.langserver.commons.LanguageExtension;\n+import org.eclipse.lsp4j.CompletionItem;\n+import org.eclipse.lsp4j.CompletionList;\n+import org.eclipse.lsp4j.CompletionParams;\n+import org.eclipse.lsp4j.DocumentFormattingParams;\n+import org.eclipse.lsp4j.PublishDiagnosticsParams;\n+import org.eclipse.lsp4j.TextEdit;\n+import org.eclipse.lsp4j.jsonrpc.messages.Either;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.ServiceLoader;\n+\n+/**\n+ * Delegate the operation to the valid extension.\n+ *\n+ * @since 2.0.0\n+ */\n+public class LangExtensionDelegator {\n+\n+    private static final LangExtensionDelegator INSTANCE = new LangExtensionDelegator();\n+\n+    private final List<CompletionExtension> completionExtensions = new ArrayList<>();\n+    private final List<FormattingExtension> formatExtensions = new ArrayList<>();\n+    private final List<DiagnosticsExtension> diagExtensions = new ArrayList<>();\n+\n+    private LangExtensionDelegator() {\n+        ServiceLoader.load(LanguageExtension.class).forEach(languageExtension -> {\n+            switch (languageExtension.kind()) {\n+                case COMPLETION:\n+                    completionExtensions.add((CompletionExtension) languageExtension);\n+                    break;\n+                case FORMAT:\n+                    formatExtensions.add((FormattingExtension) languageExtension);\n+                    break;\n+                case DIAGNOSTIC:\n+                    diagExtensions.add((DiagnosticsExtension) languageExtension);\n+                    break;\n+                default:\n+                    break;\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Get the completions.\n+     *\n+     * @param params completion parameters\n+     * @return {@link Either} completion results\n+     */\n+    public Either<List<CompletionItem>, CompletionList> completion(CompletionParams params, LSContext context) {\n+        return completionExtensions.stream().filter(ext -> ext.validate(params))\n+                .map(ext -> ext.execute(params, context))\n+                .findFirst()\n+                .orElse(Either.forRight(new CompletionList()));\n+    }\n+\n+    /**\n+     * Get the formatting.\n+     *\n+     * @param params formatting parameters\n+     * @return {@link List} of text edits\n+     */\n+    public List<? extends TextEdit> formatting(DocumentFormattingParams params, LSContext context) {\n+        return formatExtensions.stream().filter(ext -> ext.validate(params))\n+                .map(ext -> ext.execute(params, context))\n+                .findFirst()\n+                .orElse(new ArrayList<>());\n+    }\n+\n+    /**\n+     * Get the Diagnostics.\n+     *\n+     * @param uri document URI\n+     * @return {@link PublishDiagnosticsParams} diagnostic params calculated\n+     */\n+    public PublishDiagnosticsParams diagnostics(String uri, LSContext context) {\n+        return diagExtensions.stream().filter(ext -> ext.validate(uri))\n+                .map(ext -> ext.execute(uri, context))\n+                .findFirst()\n+                .orElse(new PublishDiagnosticsParams());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2b326a82c9406d17d3e6d75bef63e62e0d1c6e4f"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTcyMTg1Ng==", "bodyText": "Yes, I added this one to force only one at this time because we need to decide whether we collect from all the extensions and if we do so, do we need a specific enable disable mechanism (Because as an example, for completions and signatures, ordering of the items matters). We need to decide that.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26693#discussion_r515721856", "createdAt": "2020-11-02T03:18:06Z", "author": {"login": "nadeeshaan"}, "path": "language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/LangExtensionDelegator.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langserver;\n+\n+import org.ballerinalang.langserver.commons.CompletionExtension;\n+import org.ballerinalang.langserver.commons.DiagnosticsExtension;\n+import org.ballerinalang.langserver.commons.FormattingExtension;\n+import org.ballerinalang.langserver.commons.LSContext;\n+import org.ballerinalang.langserver.commons.LanguageExtension;\n+import org.eclipse.lsp4j.CompletionItem;\n+import org.eclipse.lsp4j.CompletionList;\n+import org.eclipse.lsp4j.CompletionParams;\n+import org.eclipse.lsp4j.DocumentFormattingParams;\n+import org.eclipse.lsp4j.PublishDiagnosticsParams;\n+import org.eclipse.lsp4j.TextEdit;\n+import org.eclipse.lsp4j.jsonrpc.messages.Either;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.ServiceLoader;\n+\n+/**\n+ * Delegate the operation to the valid extension.\n+ *\n+ * @since 2.0.0\n+ */\n+public class LangExtensionDelegator {\n+\n+    private static final LangExtensionDelegator INSTANCE = new LangExtensionDelegator();\n+\n+    private final List<CompletionExtension> completionExtensions = new ArrayList<>();\n+    private final List<FormattingExtension> formatExtensions = new ArrayList<>();\n+    private final List<DiagnosticsExtension> diagExtensions = new ArrayList<>();\n+\n+    private LangExtensionDelegator() {\n+        ServiceLoader.load(LanguageExtension.class).forEach(languageExtension -> {\n+            switch (languageExtension.kind()) {\n+                case COMPLETION:\n+                    completionExtensions.add((CompletionExtension) languageExtension);\n+                    break;\n+                case FORMAT:\n+                    formatExtensions.add((FormattingExtension) languageExtension);\n+                    break;\n+                case DIAGNOSTIC:\n+                    diagExtensions.add((DiagnosticsExtension) languageExtension);\n+                    break;\n+                default:\n+                    break;\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Get the completions.\n+     *\n+     * @param params completion parameters\n+     * @return {@link Either} completion results\n+     */\n+    public Either<List<CompletionItem>, CompletionList> completion(CompletionParams params, LSContext context) {\n+        return completionExtensions.stream().filter(ext -> ext.validate(params))\n+                .map(ext -> ext.execute(params, context))\n+                .findFirst()\n+                .orElse(Either.forRight(new CompletionList()));\n+    }\n+\n+    /**\n+     * Get the formatting.\n+     *\n+     * @param params formatting parameters\n+     * @return {@link List} of text edits\n+     */\n+    public List<? extends TextEdit> formatting(DocumentFormattingParams params, LSContext context) {\n+        return formatExtensions.stream().filter(ext -> ext.validate(params))\n+                .map(ext -> ext.execute(params, context))\n+                .findFirst()\n+                .orElse(new ArrayList<>());\n+    }\n+\n+    /**\n+     * Get the Diagnostics.\n+     *\n+     * @param uri document URI\n+     * @return {@link PublishDiagnosticsParams} diagnostic params calculated\n+     */\n+    public PublishDiagnosticsParams diagnostics(String uri, LSContext context) {\n+        return diagExtensions.stream().filter(ext -> ext.validate(uri))\n+                .map(ext -> ext.execute(uri, context))\n+                .findFirst()\n+                .orElse(new PublishDiagnosticsParams());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTcxODc1NA=="}, "originalCommit": {"oid": "2b326a82c9406d17d3e6d75bef63e62e0d1c6e4f"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc0NTEzMQ==", "bodyText": "Added the aggregated result support", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26693#discussion_r515745131", "createdAt": "2020-11-02T05:21:26Z", "author": {"login": "nadeeshaan"}, "path": "language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/LangExtensionDelegator.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langserver;\n+\n+import org.ballerinalang.langserver.commons.CompletionExtension;\n+import org.ballerinalang.langserver.commons.DiagnosticsExtension;\n+import org.ballerinalang.langserver.commons.FormattingExtension;\n+import org.ballerinalang.langserver.commons.LSContext;\n+import org.ballerinalang.langserver.commons.LanguageExtension;\n+import org.eclipse.lsp4j.CompletionItem;\n+import org.eclipse.lsp4j.CompletionList;\n+import org.eclipse.lsp4j.CompletionParams;\n+import org.eclipse.lsp4j.DocumentFormattingParams;\n+import org.eclipse.lsp4j.PublishDiagnosticsParams;\n+import org.eclipse.lsp4j.TextEdit;\n+import org.eclipse.lsp4j.jsonrpc.messages.Either;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.ServiceLoader;\n+\n+/**\n+ * Delegate the operation to the valid extension.\n+ *\n+ * @since 2.0.0\n+ */\n+public class LangExtensionDelegator {\n+\n+    private static final LangExtensionDelegator INSTANCE = new LangExtensionDelegator();\n+\n+    private final List<CompletionExtension> completionExtensions = new ArrayList<>();\n+    private final List<FormattingExtension> formatExtensions = new ArrayList<>();\n+    private final List<DiagnosticsExtension> diagExtensions = new ArrayList<>();\n+\n+    private LangExtensionDelegator() {\n+        ServiceLoader.load(LanguageExtension.class).forEach(languageExtension -> {\n+            switch (languageExtension.kind()) {\n+                case COMPLETION:\n+                    completionExtensions.add((CompletionExtension) languageExtension);\n+                    break;\n+                case FORMAT:\n+                    formatExtensions.add((FormattingExtension) languageExtension);\n+                    break;\n+                case DIAGNOSTIC:\n+                    diagExtensions.add((DiagnosticsExtension) languageExtension);\n+                    break;\n+                default:\n+                    break;\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Get the completions.\n+     *\n+     * @param params completion parameters\n+     * @return {@link Either} completion results\n+     */\n+    public Either<List<CompletionItem>, CompletionList> completion(CompletionParams params, LSContext context) {\n+        return completionExtensions.stream().filter(ext -> ext.validate(params))\n+                .map(ext -> ext.execute(params, context))\n+                .findFirst()\n+                .orElse(Either.forRight(new CompletionList()));\n+    }\n+\n+    /**\n+     * Get the formatting.\n+     *\n+     * @param params formatting parameters\n+     * @return {@link List} of text edits\n+     */\n+    public List<? extends TextEdit> formatting(DocumentFormattingParams params, LSContext context) {\n+        return formatExtensions.stream().filter(ext -> ext.validate(params))\n+                .map(ext -> ext.execute(params, context))\n+                .findFirst()\n+                .orElse(new ArrayList<>());\n+    }\n+\n+    /**\n+     * Get the Diagnostics.\n+     *\n+     * @param uri document URI\n+     * @return {@link PublishDiagnosticsParams} diagnostic params calculated\n+     */\n+    public PublishDiagnosticsParams diagnostics(String uri, LSContext context) {\n+        return diagExtensions.stream().filter(ext -> ext.validate(uri))\n+                .map(ext -> ext.execute(uri, context))\n+                .findFirst()\n+                .orElse(new PublishDiagnosticsParams());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTcxODc1NA=="}, "originalCommit": {"oid": "2b326a82c9406d17d3e6d75bef63e62e0d1c6e4f"}, "originalPosition": 104}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMTg5MzQwOnYy", "diffSide": "RIGHT", "path": "language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/LangExtensionDelegator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwMzowMTozOFrOHr0-gQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwNToyMTozMVrOHr2lfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTcxODc4NQ==", "bodyText": "Specific reason to limit to one? We can merge the results from multiple filtered extensions. eg. there can be two completion extensions with the same uri pattern.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26693#discussion_r515718785", "createdAt": "2020-11-02T03:01:38Z", "author": {"login": "rasika"}, "path": "language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/LangExtensionDelegator.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langserver;\n+\n+import org.ballerinalang.langserver.commons.CompletionExtension;\n+import org.ballerinalang.langserver.commons.DiagnosticsExtension;\n+import org.ballerinalang.langserver.commons.FormattingExtension;\n+import org.ballerinalang.langserver.commons.LSContext;\n+import org.ballerinalang.langserver.commons.LanguageExtension;\n+import org.eclipse.lsp4j.CompletionItem;\n+import org.eclipse.lsp4j.CompletionList;\n+import org.eclipse.lsp4j.CompletionParams;\n+import org.eclipse.lsp4j.DocumentFormattingParams;\n+import org.eclipse.lsp4j.PublishDiagnosticsParams;\n+import org.eclipse.lsp4j.TextEdit;\n+import org.eclipse.lsp4j.jsonrpc.messages.Either;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.ServiceLoader;\n+\n+/**\n+ * Delegate the operation to the valid extension.\n+ *\n+ * @since 2.0.0\n+ */\n+public class LangExtensionDelegator {\n+\n+    private static final LangExtensionDelegator INSTANCE = new LangExtensionDelegator();\n+\n+    private final List<CompletionExtension> completionExtensions = new ArrayList<>();\n+    private final List<FormattingExtension> formatExtensions = new ArrayList<>();\n+    private final List<DiagnosticsExtension> diagExtensions = new ArrayList<>();\n+\n+    private LangExtensionDelegator() {\n+        ServiceLoader.load(LanguageExtension.class).forEach(languageExtension -> {\n+            switch (languageExtension.kind()) {\n+                case COMPLETION:\n+                    completionExtensions.add((CompletionExtension) languageExtension);\n+                    break;\n+                case FORMAT:\n+                    formatExtensions.add((FormattingExtension) languageExtension);\n+                    break;\n+                case DIAGNOSTIC:\n+                    diagExtensions.add((DiagnosticsExtension) languageExtension);\n+                    break;\n+                default:\n+                    break;\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Get the completions.\n+     *\n+     * @param params completion parameters\n+     * @return {@link Either} completion results\n+     */\n+    public Either<List<CompletionItem>, CompletionList> completion(CompletionParams params, LSContext context) {\n+        return completionExtensions.stream().filter(ext -> ext.validate(params))\n+                .map(ext -> ext.execute(params, context))\n+                .findFirst()\n+                .orElse(Either.forRight(new CompletionList()));\n+    }\n+\n+    /**\n+     * Get the formatting.\n+     *\n+     * @param params formatting parameters\n+     * @return {@link List} of text edits\n+     */\n+    public List<? extends TextEdit> formatting(DocumentFormattingParams params, LSContext context) {\n+        return formatExtensions.stream().filter(ext -> ext.validate(params))\n+                .map(ext -> ext.execute(params, context))\n+                .findFirst()\n+                .orElse(new ArrayList<>());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2b326a82c9406d17d3e6d75bef63e62e0d1c6e4f"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc0NTE1MA==", "bodyText": "fixed", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26693#discussion_r515745150", "createdAt": "2020-11-02T05:21:31Z", "author": {"login": "nadeeshaan"}, "path": "language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/LangExtensionDelegator.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langserver;\n+\n+import org.ballerinalang.langserver.commons.CompletionExtension;\n+import org.ballerinalang.langserver.commons.DiagnosticsExtension;\n+import org.ballerinalang.langserver.commons.FormattingExtension;\n+import org.ballerinalang.langserver.commons.LSContext;\n+import org.ballerinalang.langserver.commons.LanguageExtension;\n+import org.eclipse.lsp4j.CompletionItem;\n+import org.eclipse.lsp4j.CompletionList;\n+import org.eclipse.lsp4j.CompletionParams;\n+import org.eclipse.lsp4j.DocumentFormattingParams;\n+import org.eclipse.lsp4j.PublishDiagnosticsParams;\n+import org.eclipse.lsp4j.TextEdit;\n+import org.eclipse.lsp4j.jsonrpc.messages.Either;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.ServiceLoader;\n+\n+/**\n+ * Delegate the operation to the valid extension.\n+ *\n+ * @since 2.0.0\n+ */\n+public class LangExtensionDelegator {\n+\n+    private static final LangExtensionDelegator INSTANCE = new LangExtensionDelegator();\n+\n+    private final List<CompletionExtension> completionExtensions = new ArrayList<>();\n+    private final List<FormattingExtension> formatExtensions = new ArrayList<>();\n+    private final List<DiagnosticsExtension> diagExtensions = new ArrayList<>();\n+\n+    private LangExtensionDelegator() {\n+        ServiceLoader.load(LanguageExtension.class).forEach(languageExtension -> {\n+            switch (languageExtension.kind()) {\n+                case COMPLETION:\n+                    completionExtensions.add((CompletionExtension) languageExtension);\n+                    break;\n+                case FORMAT:\n+                    formatExtensions.add((FormattingExtension) languageExtension);\n+                    break;\n+                case DIAGNOSTIC:\n+                    diagExtensions.add((DiagnosticsExtension) languageExtension);\n+                    break;\n+                default:\n+                    break;\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Get the completions.\n+     *\n+     * @param params completion parameters\n+     * @return {@link Either} completion results\n+     */\n+    public Either<List<CompletionItem>, CompletionList> completion(CompletionParams params, LSContext context) {\n+        return completionExtensions.stream().filter(ext -> ext.validate(params))\n+                .map(ext -> ext.execute(params, context))\n+                .findFirst()\n+                .orElse(Either.forRight(new CompletionList()));\n+    }\n+\n+    /**\n+     * Get the formatting.\n+     *\n+     * @param params formatting parameters\n+     * @return {@link List} of text edits\n+     */\n+    public List<? extends TextEdit> formatting(DocumentFormattingParams params, LSContext context) {\n+        return formatExtensions.stream().filter(ext -> ext.validate(params))\n+                .map(ext -> ext.execute(params, context))\n+                .findFirst()\n+                .orElse(new ArrayList<>());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTcxODc4NQ=="}, "originalCommit": {"oid": "2b326a82c9406d17d3e6d75bef63e62e0d1c6e4f"}, "originalPosition": 91}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMTg5NjA2OnYy", "diffSide": "RIGHT", "path": "language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/BallerinaTextDocumentService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwMzowNDowMVrOHr1ADQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwMzoxODoxOVrOHr1KlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTcxOTE4MQ==", "bodyText": "Instead of returning new ArrayList<>() for erroneous cases we can return an unmodifiable pre-declared empty list with Collections.emptyList(). This will limit ad-hoc new list objects creations. Check for other places in the PR that returns new arraylist as well.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26693#discussion_r515719181", "createdAt": "2020-11-02T03:04:01Z", "author": {"login": "rasika"}, "path": "language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/BallerinaTextDocumentService.java", "diffHunk": "@@ -156,14 +155,13 @@ void setClientCapabilities(LSClientCapabilities clientCapabilities) {\n \n     @Override\n     public CompletableFuture<Either<List<CompletionItem>, CompletionList>> completion(CompletionParams position) {\n-        final List<CompletionItem> completions = new ArrayList<>();\n         return CompletableFuture.supplyAsync(() -> {\n             String fileUri = position.getTextDocument().getUri();\n             Optional<Path> completionPath = CommonUtil.getPathFromURI(fileUri);\n \n             // Note: If the source is a cached stdlib source or path does not exist, then return early and ignore\n             if (completionPath.isEmpty() || CommonUtil.isCachedExternalSource(fileUri)) {\n-                return Either.forLeft(completions);\n+                return Either.forLeft(new ArrayList<>());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2b326a82c9406d17d3e6d75bef63e62e0d1c6e4f"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTcyMTg3Nw==", "bodyText": "+1", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26693#discussion_r515721877", "createdAt": "2020-11-02T03:18:19Z", "author": {"login": "nadeeshaan"}, "path": "language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/BallerinaTextDocumentService.java", "diffHunk": "@@ -156,14 +155,13 @@ void setClientCapabilities(LSClientCapabilities clientCapabilities) {\n \n     @Override\n     public CompletableFuture<Either<List<CompletionItem>, CompletionList>> completion(CompletionParams position) {\n-        final List<CompletionItem> completions = new ArrayList<>();\n         return CompletableFuture.supplyAsync(() -> {\n             String fileUri = position.getTextDocument().getUri();\n             Optional<Path> completionPath = CommonUtil.getPathFromURI(fileUri);\n \n             // Note: If the source is a cached stdlib source or path does not exist, then return early and ignore\n             if (completionPath.isEmpty() || CommonUtil.isCachedExternalSource(fileUri)) {\n-                return Either.forLeft(completions);\n+                return Either.forLeft(new ArrayList<>());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTcxOTE4MQ=="}, "originalCommit": {"oid": "2b326a82c9406d17d3e6d75bef63e62e0d1c6e4f"}, "originalPosition": 20}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4705, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}