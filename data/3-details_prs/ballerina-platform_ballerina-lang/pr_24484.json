{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQxMjIyMzEw", "number": 24484, "title": "Add support for `readonly` fields in a mapping constructor expression and allow using `readonly` as the CET for mapping/list constructor expressions", "bodyText": "Purpose\nThis PR\n\nAdds support for readonly fields in a mapping-constructor expression. Fixes #23663\n\nSuch a mapping constructor will create a value of a type that belongs to the applicable contextually expected type, but additionally, the fields with which readonly were used will be readonly fields.\nThe constraints this enforce on the value are the same as with readonly fields in the type-descriptor. i.e.,\n\nthe values specified for such fields have to be immutable\nthe field cannot be updated once the value is created\nif the constructor creates a closed record and all the fields are now readonly the resultant type will also be an readonly type\n\n\nAllows using readonly as the CET for mapping/list constructor expressions. Fixes #24472\n\nThe type for such a value is inferred as done with var, but in addition the value created will have its read-only bit set.\n\nAllows constructing values with their read-only bit on with a type-cast-expr <readonly> Fixes #22954\n\nThis PR also\nfixes #24466 - Issue in error messages with readonly fields in anonymous record/objects\nfixes #24474 - Bad, sad error at runtime when an anonymous record has a rest field which again is of an anonymous type\nfixes #24437 - Improves type-checking checks with intersection types by using the effective type when visiting an expression\nSamples\ntype Employee record {|\n    Details details;\n    string department;\n|};\n\ntype Details record {|\n    string name;\n    int id;\n|};\n\npublic function main() {\n    Employee emp = {\n        readonly details: {\n            name: \"May\",\n            id: 112233\n        },\n        department: \"IT\"\n    };\n}\nSince readonly is specified with details when creating emp, the particular Details value is created as an immutable value.\nio:println(emp.isReadOnly()); // false\nio:println(emp.details.isReadOnly()); // true\nThe effective type of emp is now a subtype of Employee that mandates the details field to be readonly.\nio:println(emp is record {|readonly Details details; string department;|}); // true\nSince the field itself will also be marked as a readonly field, attempting to change the details field itself will panic.\nemp.details = { // {ballerina/lang.map}InherentTypeViolation message=cannot update 'readonly' field 'details' in record of type '$anonType$0'\n    name: \"Jo\",\n    id: 4324\n};\nCheck List\n\n Read the Contributing Guide\n Updated Change Log\n Checked Tooling Support (#)\n Added necessary tests\n\n Unit Tests\n Spec Conformance Tests\n Integration Tests\n Ballerina By Example Tests\n\n\n Increased Test Coverage\n Added necessary documentation\n\n API documentation\n Module documentation in Module.md files\n Ballerina By Examples", "createdAt": "2020-06-29T06:18:10Z", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24484", "merged": true, "mergeCommit": {"oid": "72a65b5f823182d18ca77b13036f643cb48ad650"}, "closed": true, "closedAt": "2020-07-16T03:54:29Z", "author": {"login": "MaryamZi"}, "timelineItems": {"totalCount": 37, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcuT-PtgH2gAyNDQxMjIyMzEwOjQ4Y2VlOGVjY2U5NDg5MDczMTRkYTEyMTk4YzZjNTdhZTNmZGUwYmM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc1XB0IAFqTQ0OTQ4OTE3OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "48cee8ecce948907314da12198c6c57ae3fde0bc", "author": {"user": {"login": "MaryamZi", "name": "Maryam Ziyad"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/48cee8ecce948907314da12198c6c57ae3fde0bc", "committedDate": "2020-06-24T06:22:47Z", "message": "Fix setting field readonly flag"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dad358769b870c33c37082d9a06780c74b4e5dbc", "author": {"user": {"login": "MaryamZi", "name": "Maryam Ziyad"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/dad358769b870c33c37082d9a06780c74b4e5dbc", "committedDate": "2020-06-24T17:55:22Z", "message": "Infer a type for mapping-constrs with readonly fields"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "77730ccd2afd3c7e3187f6967365dd1f660cb09a", "author": {"user": {"login": "MaryamZi", "name": "Maryam Ziyad"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/77730ccd2afd3c7e3187f6967365dd1f660cb09a", "committedDate": "2020-06-24T18:46:58Z", "message": "Fix error on readonly field with invalid type"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "68257ea62dad097ad7effd55c5e6d088c3f4f8bb", "author": {"user": {"login": "MaryamZi", "name": "Maryam Ziyad"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/68257ea62dad097ad7effd55c5e6d088c3f4f8bb", "committedDate": "2020-06-25T13:51:22Z", "message": "Make the inferred exclusive record type readonly if all constructor and CET fields are readonly"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fa6fc74f98f340aeb7cfca44c43fda066458e0b9", "author": {"user": {"login": "MaryamZi", "name": "Maryam Ziyad"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/fa6fc74f98f340aeb7cfca44c43fda066458e0b9", "committedDate": "2020-06-25T18:03:21Z", "message": "Add tests for readonly fields in the mapping-constructor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "871ac410420b9a9b50b1b5bdfd23d86204d55809", "author": {"user": {"login": "MaryamZi", "name": "Maryam Ziyad"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/871ac410420b9a9b50b1b5bdfd23d86204d55809", "committedDate": "2020-06-26T14:25:27Z", "message": "Add readonly modifier in record/object readonly field string representation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a635d3ba5837cae49d511cd1133fe0f1e5dcef00", "author": {"user": {"login": "MaryamZi", "name": "Maryam Ziyad"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a635d3ba5837cae49d511cd1133fe0f1e5dcef00", "committedDate": "2020-06-28T07:34:15Z", "message": "Allow using readonly as the CET for map/list constructor exprs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cc72c493e613c8cb89a93fbe6eb30e62e10dba58", "author": {"user": {"login": "MaryamZi", "name": "Maryam Ziyad"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/cc72c493e613c8cb89a93fbe6eb30e62e10dba58", "committedDate": "2020-06-28T07:45:28Z", "message": "Fix anon record rest field not getting rewritten at desugar"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e5ba2799c8ee6b439cf47bb14d564db2e029cb28", "author": {"user": {"login": "MaryamZi", "name": "Maryam Ziyad"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e5ba2799c8ee6b439cf47bb14d564db2e029cb28", "committedDate": "2020-06-28T10:49:55Z", "message": "Fix constr type-checking against readonly in union and add tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f34a4da4bdaf3e136c59e1936ba63f688862867c", "author": {"user": {"login": "MaryamZi", "name": "Maryam Ziyad"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f34a4da4bdaf3e136c59e1936ba63f688862867c", "committedDate": "2020-06-28T12:02:16Z", "message": "Add tests for union CET with readonly"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7f8304c89fa0cf39750fb00c14e763f8040e1d37", "author": {"user": {"login": "MaryamZi", "name": "Maryam Ziyad"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7f8304c89fa0cf39750fb00c14e763f8040e1d37", "committedDate": "2020-06-28T12:02:42Z", "message": "Merge branch 'master' of https://github.com/ballerina-lang/ballerina into readonly-support"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b0624bb903dc06b54205c97b611c5463a97d0583", "author": {"user": {"login": "MaryamZi", "name": "Maryam Ziyad"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b0624bb903dc06b54205c97b611c5463a97d0583", "committedDate": "2020-06-28T20:48:24Z", "message": "Use intersection effective type for type-checking"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "98462d7940d5582d7606cf0984488e7df0950409", "author": {"user": {"login": "MaryamZi", "name": "Maryam Ziyad"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/98462d7940d5582d7606cf0984488e7df0950409", "committedDate": "2020-06-28T20:53:33Z", "message": "Add tests for readonly with mapping constr with diff. field kinds"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "562ef0f7e36ee2e9e06d45d8ac01f46331068dfd", "author": {"user": {"login": "MaryamZi", "name": "Maryam Ziyad"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/562ef0f7e36ee2e9e06d45d8ac01f46331068dfd", "committedDate": "2020-06-30T07:21:58Z", "message": "Merge branch 'master' of https://github.com/ballerina-lang/ballerina into readonly-support"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6398a7b7a98df7144045aba0e528596680d8af9f", "author": {"user": {"login": "MaryamZi", "name": "Maryam Ziyad"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6398a7b7a98df7144045aba0e528596680d8af9f", "committedDate": "2020-06-30T16:40:06Z", "message": "Avoid rest field literal key check for gen.ed record types and narrow type for readonly fields"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7679816a9718b649c4a1f0e2a43f9d8abfc755af", "author": {"user": {"login": "MaryamZi", "name": "Maryam Ziyad"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7679816a9718b649c4a1f0e2a43f9d8abfc755af", "committedDate": "2020-07-01T07:56:08Z", "message": "Refactor expected type setting logic for mapping-constructors"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b4da316a9935e882730f3910cd71d89089862c50", "author": {"user": {"login": "MaryamZi", "name": "Maryam Ziyad"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b4da316a9935e882730f3910cd71d89089862c50", "committedDate": "2020-07-03T11:01:21Z", "message": "Construct values as read-only when used with a cast to readonly"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQyNTg3MjQw", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24484#pullrequestreview-442587240", "createdAt": "2020-07-04T04:46:44Z", "commit": {"oid": "b4da316a9935e882730f3910cd71d89089862c50"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNFQwNDo0Njo0NFrOGs54yg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNFQwNDo0Njo0NFrOGs54yg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTczODk1NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // A record type is inferred for a record literal even if the CET is a map, if the mapping\n          \n          \n            \n                    // constructor expression has `readonly` fields.\n          \n          \n            \n                    // A record type is inferred for a record literal even if the CET (contextually expected type) is a map, if \n          \n          \n            \n                    // the mapping constructor expression has `readonly` fields.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24484#discussion_r449738954", "createdAt": "2020-07-04T04:46:44Z", "author": {"login": "KRVPerera"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/CodeAnalyzer.java", "diffHunk": "@@ -1998,7 +1998,14 @@ public void visit(BLangRecordLiteral recordLiteral) {\n \n         Set<Object> names = new HashSet<>();\n         BType type = recordLiteral.type;\n-        boolean isOpenRecord = type != null && type.tag == TypeTags.RECORD && !((BRecordType) type).sealed;\n+        boolean isRecord = type != null && type.tag == TypeTags.RECORD;\n+        boolean isOpenRecord = isRecord && !((BRecordType) type).sealed;\n+\n+        // A record type is inferred for a record literal even if the CET is a map, if the mapping\n+        // constructor expression has `readonly` fields.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4da316a9935e882730f3910cd71d89089862c50"}, "originalPosition": 9}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQyNTg3Njc5", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24484#pullrequestreview-442587679", "createdAt": "2020-07-04T04:58:49Z", "commit": {"oid": "b4da316a9935e882730f3910cd71d89089862c50"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNFQwNDo1ODo1MFrOGs57rA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNFQwNDo1ODo1MFrOGs57rA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTczOTY5Mg==", "bodyText": "origExpType type is not used.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24484#discussion_r449739692", "createdAt": "2020-07-04T04:58:50Z", "author": {"login": "KRVPerera"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -360,16 +348,35 @@ public BType checkExpr(BLangExpression expr, SymbolEnv env, BType expType, Diagn\n \n         expr.accept(this);\n \n-        expr.type = resultType.tag != TypeTags.INTERSECTION ? resultType :\n-                ((BIntersectionType) resultType).effectiveType;\n+        if (resultType.tag == TypeTags.INTERSECTION) {\n+            resultType = ((BIntersectionType) resultType).effectiveType;\n+        }\n+\n+        expr.type = resultType;\n         expr.typeChecked = isTypeChecked;\n         this.env = prevEnv;\n         this.expType = preExpType;\n         this.diagCode = preDiagCode;\n-        if (resultType.tag != TypeTags.SEMANTIC_ERROR) {\n+\n+        validateAndSetExprExpectedType(expr, expType);\n+\n+        return resultType;\n+    }\n+\n+    private void validateAndSetExprExpectedType(BLangExpression expr, BType origExpType) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4da316a9935e882730f3910cd71d89089862c50"}, "originalPosition": 70}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "db6dd878879ed81545688e40046afbd5d14b3af1", "author": {"user": {"login": "MaryamZi", "name": "Maryam Ziyad"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/db6dd878879ed81545688e40046afbd5d14b3af1", "committedDate": "2020-07-06T06:17:29Z", "message": "Merge branch 'master' of https://github.com/ballerina-lang/ballerina into readonly-support"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "290649cd679228bbe66d06897c69a3401caa8498", "author": {"user": {"login": "MaryamZi", "name": "Maryam Ziyad"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/290649cd679228bbe66d06897c69a3401caa8498", "committedDate": "2020-07-06T07:16:37Z", "message": "Address review suggestions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "95533b19950d9d6557473bafa304a16a65ed2a02", "author": {"user": {"login": "MaryamZi", "name": "Maryam Ziyad"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/95533b19950d9d6557473bafa304a16a65ed2a02", "committedDate": "2020-07-06T12:24:31Z", "message": "Merge branch 'master' of https://github.com/ballerina-lang/ballerina into readonly-support"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4f67df544ffe98957721d6037f08ec6faa125752", "author": {"user": {"login": "MaryamZi", "name": "Maryam Ziyad"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/4f67df544ffe98957721d6037f08ec6faa125752", "committedDate": "2020-07-15T06:41:13Z", "message": "Merge branch 'master' of https://github.com/ballerina-lang/ballerina into readonly-support"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ed729d2aa3f90d27522bb8d1f867a4ee61da6cd8", "author": {"user": {"login": "MaryamZi", "name": "Maryam Ziyad"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/ed729d2aa3f90d27522bb8d1f867a4ee61da6cd8", "committedDate": "2020-07-15T10:15:40Z", "message": "Fix tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ5MDA5MDI5", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24484#pullrequestreview-449009029", "createdAt": "2020-07-15T14:26:43Z", "commit": {"oid": "ed729d2aa3f90d27522bb8d1f867a4ee61da6cd8"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ5MjE4ODEy", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24484#pullrequestreview-449218812", "createdAt": "2020-07-15T18:21:57Z", "commit": {"oid": "ed729d2aa3f90d27522bb8d1f867a4ee61da6cd8"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ5MjY5NzYy", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24484#pullrequestreview-449269762", "createdAt": "2020-07-15T19:34:44Z", "commit": {"oid": "ed729d2aa3f90d27522bb8d1f867a4ee61da6cd8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxOTozNDo0NVrOGyM7wA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxOTozNDo0NVrOGyM7wA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI5Mzg4OA==", "bodyText": "Not related to this PR, but there shouldn't be a case where the type of a record literal is null in code analyzer right?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24484#discussion_r455293888", "createdAt": "2020-07-15T19:34:45Z", "author": {"login": "pubudu91"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/CodeAnalyzer.java", "diffHunk": "@@ -2020,7 +2020,14 @@ public void visit(BLangRecordLiteral recordLiteral) {\n \n         Set<Object> names = new HashSet<>();\n         BType type = recordLiteral.type;\n-        boolean isOpenRecord = type != null && type.tag == TypeTags.RECORD && !((BRecordType) type).sealed;\n+        boolean isRecord = type != null && type.tag == TypeTags.RECORD;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed729d2aa3f90d27522bb8d1f867a4ee61da6cd8"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ5Mjc3NDk5", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24484#pullrequestreview-449277499", "createdAt": "2020-07-15T19:46:30Z", "commit": {"oid": "ed729d2aa3f90d27522bb8d1f867a4ee61da6cd8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxOTo0NjozMFrOGyNT2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxOTo0NjozMFrOGyNT2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMwMDA1Nw==", "bodyText": "Why is the expected type changed here?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24484#discussion_r455300057", "createdAt": "2020-07-15T19:46:30Z", "author": {"login": "pubudu91"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/CodeAnalyzer.java", "diffHunk": "@@ -2084,6 +2091,10 @@ public void visit(BLangRecordLiteral recordLiteral) {\n                 }\n             }\n         }\n+\n+        if (isInferredRecordForMapCET) {\n+            recordLiteral.expectedType = type;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed729d2aa3f90d27522bb8d1f867a4ee61da6cd8"}, "originalPosition": 31}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ5MjkwMjk0", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24484#pullrequestreview-449290294", "createdAt": "2020-07-15T20:05:37Z", "commit": {"oid": "ed729d2aa3f90d27522bb8d1f867a4ee61da6cd8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQyMDowNTozN1rOGyN73w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQyMDowNTozN1rOGyN73w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMxMDMwMw==", "bodyText": "Shall we move this above line 371? When placed here, it looks like a dangling comment", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24484#discussion_r455310303", "createdAt": "2020-07-15T20:05:37Z", "author": {"login": "pubudu91"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -360,16 +348,35 @@ public BType checkExpr(BLangExpression expr, SymbolEnv env, BType expType, Diagn\n \n         expr.accept(this);\n \n-        expr.type = resultType.tag != TypeTags.INTERSECTION ? resultType :\n-                ((BIntersectionType) resultType).effectiveType;\n+        if (resultType.tag == TypeTags.INTERSECTION) {\n+            resultType = ((BIntersectionType) resultType).effectiveType;\n+        }\n+\n+        expr.type = resultType;\n         expr.typeChecked = isTypeChecked;\n         this.env = prevEnv;\n         this.expType = preExpType;\n         this.diagCode = preDiagCode;\n-        if (resultType.tag != TypeTags.SEMANTIC_ERROR) {\n+\n+        validateAndSetExprExpectedType(expr);\n+\n+        return resultType;\n+    }\n+\n+    private void validateAndSetExprExpectedType(BLangExpression expr) {\n+        if (resultType.tag == TypeTags.SEMANTIC_ERROR) {\n+            return;\n+        }\n+\n+        if (expr.getKind() != NodeKind.RECORD_LITERAL_EXPR ||\n+                expr.expectedType == null ||\n+                expr.expectedType.tag != TypeTags.MAP ||\n+                expr.type.tag != TypeTags.RECORD) {\n             expr.expectedType = resultType;\n         }\n-        return resultType;\n+\n+        // If the expected type is a map, but a record type is inferred due to the presence of `readonly` fields in\n+        // the mapping constructor expression, we don't override the expected type.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed729d2aa3f90d27522bb8d1f867a4ee61da6cd8"}, "originalPosition": 84}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ5MjkwNzU0", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24484#pullrequestreview-449290754", "createdAt": "2020-07-15T20:06:19Z", "commit": {"oid": "ed729d2aa3f90d27522bb8d1f867a4ee61da6cd8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQyMDowNjoyMFrOGyN9Sw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQyMDowNjoyMFrOGyN9Sw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMxMDY2Nw==", "bodyText": "Wouldn't the inverse of this check read better?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24484#discussion_r455310667", "createdAt": "2020-07-15T20:06:20Z", "author": {"login": "pubudu91"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -360,16 +348,35 @@ public BType checkExpr(BLangExpression expr, SymbolEnv env, BType expType, Diagn\n \n         expr.accept(this);\n \n-        expr.type = resultType.tag != TypeTags.INTERSECTION ? resultType :\n-                ((BIntersectionType) resultType).effectiveType;\n+        if (resultType.tag == TypeTags.INTERSECTION) {\n+            resultType = ((BIntersectionType) resultType).effectiveType;\n+        }\n+\n+        expr.type = resultType;\n         expr.typeChecked = isTypeChecked;\n         this.env = prevEnv;\n         this.expType = preExpType;\n         this.diagCode = preDiagCode;\n-        if (resultType.tag != TypeTags.SEMANTIC_ERROR) {\n+\n+        validateAndSetExprExpectedType(expr);\n+\n+        return resultType;\n+    }\n+\n+    private void validateAndSetExprExpectedType(BLangExpression expr) {\n+        if (resultType.tag == TypeTags.SEMANTIC_ERROR) {\n+            return;\n+        }\n+\n+        if (expr.getKind() != NodeKind.RECORD_LITERAL_EXPR ||\n+                expr.expectedType == null ||\n+                expr.expectedType.tag != TypeTags.MAP ||\n+                expr.type.tag != TypeTags.RECORD) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed729d2aa3f90d27522bb8d1f867a4ee61da6cd8"}, "originalPosition": 78}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ5MzA4OTcz", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24484#pullrequestreview-449308973", "createdAt": "2020-07-15T20:33:36Z", "commit": {"oid": "ed729d2aa3f90d27522bb8d1f867a4ee61da6cd8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQyMDozMzozNlrOGyO1Pg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQyMDozMzozNlrOGyO1Pg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMyNDk5MA==", "bodyText": "I think we should consider providing common info such as the name, type of a field through an API. Would simplify code like this. Again, I mean as a future improvement.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24484#discussion_r455324990", "createdAt": "2020-07-15T20:33:36Z", "author": {"login": "pubudu91"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -1481,51 +1497,193 @@ private boolean exprIncompatible(BType eType, BLangExpression expr) {\n         return checkExpr(exprToCheck, this.env, eType) == symTable.semanticError;\n     }\n \n-    private BType[] getExprListUniqueTypes(List<BLangExpression> exprs, SymbolEnv env) {\n-        LinkedHashSet<BType> typesSet = new LinkedHashSet<>(checkExprList(exprs, env));\n-        return typesSet.toArray(new BType[0]);\n+    private List<BType> checkExprList(List<BLangExpression> exprs, SymbolEnv env) {\n+        return checkExprList(exprs, env, symTable.noType);\n     }\n \n-    private List<BType> checkExprList(List<BLangExpression> exprs, SymbolEnv env) {\n+    private List<BType> checkExprList(List<BLangExpression> exprs, SymbolEnv env, BType expType) {\n         List<BType> types = new ArrayList<>();\n         SymbolEnv prevEnv = this.env;\n         BType preExpType = this.expType;\n         this.env = env;\n-        this.expType = symTable.noType;\n+        this.expType = expType;\n         for (BLangExpression e : exprs) {\n-            checkExpr(e, this.env);\n+            checkExpr(e, this.env, expType);\n             types.add(resultType);\n         }\n         this.env = prevEnv;\n         this.expType = preExpType;\n         return types;\n     }\n \n-    private BType getInferredTupleType(BLangListConstructorExpr listConstructor) {\n-        List<BType> memTypes = checkExprList(listConstructor.exprs, env);\n+    private BType getInferredTupleType(BLangListConstructorExpr listConstructor, BType expType) {\n+        List<BType> memTypes = checkExprList(listConstructor.exprs, env, expType);\n \n         for (BType memType : memTypes) {\n             if (memType == symTable.semanticError) {\n                 return symTable.semanticError;\n             }\n         }\n \n-        return new BTupleType(memTypes);\n+        BTupleType tupleType = new BTupleType(memTypes);\n+\n+        if (expType.tag != TypeTags.READONLY) {\n+            return tupleType;\n+        }\n+\n+        tupleType.flags |= Flags.READONLY;\n+        return tupleType;\n     }\n \n     public void visit(BLangRecordLiteral recordLiteral) {\n         int expTypeTag = expType.tag;\n \n-        if (expTypeTag == TypeTags.NONE) {\n-            expType = defineInferredRecordType(recordLiteral);\n+        if (expTypeTag == TypeTags.NONE || expTypeTag == TypeTags.READONLY) {\n+            expType = defineInferredRecordType(recordLiteral, expType);\n         } else if (expTypeTag == TypeTags.OBJECT) {\n-            dlog.error(recordLiteral.pos,\n-                       DiagnosticCode.INVALID_RECORD_LITERAL, expType);\n+            dlog.error(recordLiteral.pos, DiagnosticCode.INVALID_RECORD_LITERAL, expType);\n             resultType = symTable.semanticError;\n             return;\n         }\n \n-        resultType = checkMappingConstructorCompatibility(expType, recordLiteral);\n+        resultType = getEffectiveMappingType(recordLiteral,\n+                                             checkMappingConstructorCompatibility(expType, recordLiteral));\n+    }\n+\n+    private BType getEffectiveMappingType(BLangRecordLiteral recordLiteral, BType applicableMappingType) {\n+        if (applicableMappingType == symTable.semanticError ||\n+                (applicableMappingType.tag == TypeTags.RECORD && Symbols.isFlagOn(applicableMappingType.flags,\n+                                                                                  Flags.READONLY))) {\n+            return applicableMappingType;\n+        }\n+\n+        Map<String, RecordLiteralNode.RecordField> readOnlyFields = new LinkedHashMap<>();\n+        LinkedHashMap<String, BField> applicableTypeFields =\n+                applicableMappingType.tag == TypeTags.RECORD ? ((BRecordType) applicableMappingType).fields :\n+                        new LinkedHashMap<>();\n+\n+        for (RecordLiteralNode.RecordField field : recordLiteral.fields) {\n+            if (field.getKind() == NodeKind.RECORD_LITERAL_SPREAD_OP) {\n+                continue;\n+            }\n+\n+            String name;\n+            if (field.isKeyValueField()) {\n+                BLangRecordKeyValueField keyValueField = (BLangRecordKeyValueField) field;\n+\n+                if (!keyValueField.readonly) {\n+                    continue;\n+                }\n+\n+                BLangExpression keyExpr = keyValueField.key.expr;\n+                if (keyExpr.getKind() == NodeKind.SIMPLE_VARIABLE_REF) {\n+                    name = ((BLangSimpleVarRef) keyExpr).variableName.value;\n+                } else {\n+                    name = (String) ((BLangLiteral) keyExpr).value;\n+                }\n+            } else {\n+                BLangRecordVarNameField varNameField = (BLangRecordVarNameField) field;\n+\n+                if (!varNameField.readonly) {\n+                    continue;\n+                }\n+                name = varNameField.variableName.value;\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed729d2aa3f90d27522bb8d1f867a4ee61da6cd8"}, "originalPosition": 297}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ5MzA5NDgy", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24484#pullrequestreview-449309482", "createdAt": "2020-07-15T20:34:24Z", "commit": {"oid": "ed729d2aa3f90d27522bb8d1f867a4ee61da6cd8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQyMDozNDoyNFrOGyO21g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQyMDozNDoyNFrOGyO21g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMyNTM5OA==", "bodyText": "Another example of what I mentioned above.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24484#discussion_r455325398", "createdAt": "2020-07-15T20:34:24Z", "author": {"login": "pubudu91"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -1481,51 +1497,193 @@ private boolean exprIncompatible(BType eType, BLangExpression expr) {\n         return checkExpr(exprToCheck, this.env, eType) == symTable.semanticError;\n     }\n \n-    private BType[] getExprListUniqueTypes(List<BLangExpression> exprs, SymbolEnv env) {\n-        LinkedHashSet<BType> typesSet = new LinkedHashSet<>(checkExprList(exprs, env));\n-        return typesSet.toArray(new BType[0]);\n+    private List<BType> checkExprList(List<BLangExpression> exprs, SymbolEnv env) {\n+        return checkExprList(exprs, env, symTable.noType);\n     }\n \n-    private List<BType> checkExprList(List<BLangExpression> exprs, SymbolEnv env) {\n+    private List<BType> checkExprList(List<BLangExpression> exprs, SymbolEnv env, BType expType) {\n         List<BType> types = new ArrayList<>();\n         SymbolEnv prevEnv = this.env;\n         BType preExpType = this.expType;\n         this.env = env;\n-        this.expType = symTable.noType;\n+        this.expType = expType;\n         for (BLangExpression e : exprs) {\n-            checkExpr(e, this.env);\n+            checkExpr(e, this.env, expType);\n             types.add(resultType);\n         }\n         this.env = prevEnv;\n         this.expType = preExpType;\n         return types;\n     }\n \n-    private BType getInferredTupleType(BLangListConstructorExpr listConstructor) {\n-        List<BType> memTypes = checkExprList(listConstructor.exprs, env);\n+    private BType getInferredTupleType(BLangListConstructorExpr listConstructor, BType expType) {\n+        List<BType> memTypes = checkExprList(listConstructor.exprs, env, expType);\n \n         for (BType memType : memTypes) {\n             if (memType == symTable.semanticError) {\n                 return symTable.semanticError;\n             }\n         }\n \n-        return new BTupleType(memTypes);\n+        BTupleType tupleType = new BTupleType(memTypes);\n+\n+        if (expType.tag != TypeTags.READONLY) {\n+            return tupleType;\n+        }\n+\n+        tupleType.flags |= Flags.READONLY;\n+        return tupleType;\n     }\n \n     public void visit(BLangRecordLiteral recordLiteral) {\n         int expTypeTag = expType.tag;\n \n-        if (expTypeTag == TypeTags.NONE) {\n-            expType = defineInferredRecordType(recordLiteral);\n+        if (expTypeTag == TypeTags.NONE || expTypeTag == TypeTags.READONLY) {\n+            expType = defineInferredRecordType(recordLiteral, expType);\n         } else if (expTypeTag == TypeTags.OBJECT) {\n-            dlog.error(recordLiteral.pos,\n-                       DiagnosticCode.INVALID_RECORD_LITERAL, expType);\n+            dlog.error(recordLiteral.pos, DiagnosticCode.INVALID_RECORD_LITERAL, expType);\n             resultType = symTable.semanticError;\n             return;\n         }\n \n-        resultType = checkMappingConstructorCompatibility(expType, recordLiteral);\n+        resultType = getEffectiveMappingType(recordLiteral,\n+                                             checkMappingConstructorCompatibility(expType, recordLiteral));\n+    }\n+\n+    private BType getEffectiveMappingType(BLangRecordLiteral recordLiteral, BType applicableMappingType) {\n+        if (applicableMappingType == symTable.semanticError ||\n+                (applicableMappingType.tag == TypeTags.RECORD && Symbols.isFlagOn(applicableMappingType.flags,\n+                                                                                  Flags.READONLY))) {\n+            return applicableMappingType;\n+        }\n+\n+        Map<String, RecordLiteralNode.RecordField> readOnlyFields = new LinkedHashMap<>();\n+        LinkedHashMap<String, BField> applicableTypeFields =\n+                applicableMappingType.tag == TypeTags.RECORD ? ((BRecordType) applicableMappingType).fields :\n+                        new LinkedHashMap<>();\n+\n+        for (RecordLiteralNode.RecordField field : recordLiteral.fields) {\n+            if (field.getKind() == NodeKind.RECORD_LITERAL_SPREAD_OP) {\n+                continue;\n+            }\n+\n+            String name;\n+            if (field.isKeyValueField()) {\n+                BLangRecordKeyValueField keyValueField = (BLangRecordKeyValueField) field;\n+\n+                if (!keyValueField.readonly) {\n+                    continue;\n+                }\n+\n+                BLangExpression keyExpr = keyValueField.key.expr;\n+                if (keyExpr.getKind() == NodeKind.SIMPLE_VARIABLE_REF) {\n+                    name = ((BLangSimpleVarRef) keyExpr).variableName.value;\n+                } else {\n+                    name = (String) ((BLangLiteral) keyExpr).value;\n+                }\n+            } else {\n+                BLangRecordVarNameField varNameField = (BLangRecordVarNameField) field;\n+\n+                if (!varNameField.readonly) {\n+                    continue;\n+                }\n+                name = varNameField.variableName.value;\n+            }\n+\n+            if (applicableTypeFields.containsKey(name) &&\n+                    Symbols.isFlagOn(applicableTypeFields.get(name).symbol.flags, Flags.READONLY)) {\n+                continue;\n+            }\n+\n+            readOnlyFields.put(name, field);\n+        }\n+\n+        if (readOnlyFields.isEmpty()) {\n+            return applicableMappingType;\n+        }\n+\n+        PackageID pkgID = env.enclPkg.symbol.pkgID;\n+        BRecordTypeSymbol recordSymbol = createRecordTypeSymbol(pkgID);\n+\n+        LinkedHashMap<String, BField> newFields = new LinkedHashMap<>();\n+\n+        for (Map.Entry<String, RecordLiteralNode.RecordField> readOnlyEntry : readOnlyFields.entrySet()) {\n+            RecordLiteralNode.RecordField field = readOnlyEntry.getValue();\n+\n+            String key = readOnlyEntry.getKey();\n+            Name fieldName = names.fromString(key);\n+\n+            BType readOnlyFieldType;\n+            if (field.isKeyValueField()) {\n+                readOnlyFieldType = ((BLangRecordKeyValueField) field).valueExpr.type;\n+            } else {\n+                // Has to be a varname field.\n+                readOnlyFieldType = ((BLangRecordVarNameField) field).type;\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed729d2aa3f90d27522bb8d1f867a4ee61da6cd8"}, "originalPosition": 328}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8f1e3d6896a9d118ea91c15175257d0bac1daa46", "author": {"user": {"login": "MaryamZi", "name": "Maryam Ziyad"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/8f1e3d6896a9d118ea91c15175257d0bac1daa46", "committedDate": "2020-07-15T21:11:23Z", "message": "Address review suggestions"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ5MzM2MDM1", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24484#pullrequestreview-449336035", "createdAt": "2020-07-15T21:13:03Z", "commit": {"oid": "8f1e3d6896a9d118ea91c15175257d0bac1daa46"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2cf9cdf5e3924c0e4728eb04f505eea61e75350f", "author": {"user": {"login": "MaryamZi", "name": "Maryam Ziyad"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2cf9cdf5e3924c0e4728eb04f505eea61e75350f", "committedDate": "2020-07-15T21:49:00Z", "message": "Merge branch 'master' of https://github.com/ballerina-lang/ballerina into readonly-support"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ac3b92785bf915d106596a351d375766bbfbb304", "author": {"user": {"login": "MaryamZi", "name": "Maryam Ziyad"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/ac3b92785bf915d106596a351d375766bbfbb304", "committedDate": "2020-07-15T22:02:36Z", "message": "Fix RawTemplateLiteralTest"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ5NDg5MTc5", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24484#pullrequestreview-449489179", "createdAt": "2020-07-16T03:53:52Z", "commit": {"oid": "ac3b92785bf915d106596a351d375766bbfbb304"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4234, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}