{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcyODU4NzQ0", "number": 20937, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwNDozMjo1MFrODfC6Fg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwNToxODo1NFrODfDPVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzODgwMDg2OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/util/TypeDefBuilderHelper.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwNDozMjo1MFrOFohgWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwNDozMjo1MFrOFohgWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODAzNjMxNA==", "bodyText": "Maybe a function name like addTypeDefinition is more suitable here?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20937#discussion_r378036314", "createdAt": "2020-02-12T04:32:50Z", "author": {"login": "KRVPerera"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/util/TypeDefBuilderHelper.java", "diffHunk": "@@ -0,0 +1,158 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.wso2.ballerinalang.compiler.util;\n+\n+import org.ballerinalang.model.TreeBuilder;\n+import org.ballerinalang.model.elements.Flag;\n+import org.ballerinalang.model.elements.PackageID;\n+import org.wso2.ballerinalang.compiler.desugar.ASTBuilderUtil;\n+import org.wso2.ballerinalang.compiler.semantics.analyzer.TaintAnalyzer;\n+import org.wso2.ballerinalang.compiler.semantics.model.Scope;\n+import org.wso2.ballerinalang.compiler.semantics.model.SymbolEnv;\n+import org.wso2.ballerinalang.compiler.semantics.model.SymbolTable;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BAttachedFunction;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BInvokableTypeSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BRecordTypeSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BTypeSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BVarSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.SymTag;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.Symbols;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.TaintRecord;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BField;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BInvokableType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BRecordType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BType;\n+import org.wso2.ballerinalang.compiler.tree.BLangFunction;\n+import org.wso2.ballerinalang.compiler.tree.BLangSimpleVariable;\n+import org.wso2.ballerinalang.compiler.tree.BLangTypeDefinition;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangRecordTypeNode;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangStructureTypeNode;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangType;\n+import org.wso2.ballerinalang.compiler.util.diagnotic.DiagnosticPos;\n+import org.wso2.ballerinalang.util.Flags;\n+\n+import java.util.ArrayList;\n+import java.util.EnumSet;\n+import java.util.HashMap;\n+import java.util.List;\n+\n+/**\n+ * Helper class with util methods to create type definitions.\n+ *\n+ * @since 1.2.0\n+ */\n+public class TypeDefBuilderHelper {\n+\n+    public static BLangRecordTypeNode createRecordTypeNode(BRecordType recordType, PackageID packageID,\n+                                                           SymbolTable symTable, DiagnosticPos pos) {\n+        List<BLangSimpleVariable> fieldList = new ArrayList<>();\n+        for (BField field : recordType.fields) {\n+            BVarSymbol symbol = field.symbol;\n+            if (symbol == null) {\n+                symbol = new BVarSymbol(Flags.PUBLIC, field.name, packageID, symTable.pureType, null);\n+            }\n+\n+            BLangSimpleVariable fieldVar = ASTBuilderUtil.createVariable(field.pos, symbol.name.value, field.type,\n+                                                                         null, symbol);\n+            fieldList.add(fieldVar);\n+        }\n+        return createRecordTypeNode(fieldList, recordType, pos);\n+    }\n+\n+    public static BLangRecordTypeNode createRecordTypeNode(List<BLangSimpleVariable> typeDefFields,\n+                                                           BRecordType recordType, DiagnosticPos pos) {\n+        BLangRecordTypeNode recordTypeNode = (BLangRecordTypeNode) TreeBuilder.createRecordTypeNode();\n+        recordTypeNode.type = recordType;\n+        recordTypeNode.fields = typeDefFields;\n+        recordTypeNode.symbol = recordType.tsymbol;\n+        recordTypeNode.pos = pos;\n+\n+        return recordTypeNode;\n+    }\n+\n+    public static BLangFunction createInitFunctionForRecordType(BLangRecordTypeNode recordTypeNode, SymbolEnv env,\n+                                                                Names names, SymbolTable symTable) {\n+        BLangFunction initFunction = createInitFunctionForStructureType(recordTypeNode, env,\n+                                                                        Names.INIT_FUNCTION_SUFFIX, names, symTable);\n+        BRecordTypeSymbol recordSymbol = ((BRecordTypeSymbol) recordTypeNode.type.tsymbol);\n+        recordSymbol.initializerFunc = new BAttachedFunction(initFunction.symbol.name, initFunction.symbol,\n+                                                             (BInvokableType) initFunction.type);\n+        recordTypeNode.initFunction = initFunction;\n+        recordSymbol.scope.define(recordSymbol.initializerFunc.symbol.name, recordSymbol.initializerFunc.symbol);\n+        return initFunction;\n+    }\n+\n+    public static BLangFunction createInitFunctionForStructureType(BLangStructureTypeNode structureTypeNode,\n+                                                                   SymbolEnv env, Name suffix, Names names,\n+                                                                   SymbolTable symTable) {\n+        String structTypeName = structureTypeNode.type.tsymbol.name.value;\n+        BLangFunction initFunction = ASTBuilderUtil\n+                .createInitFunctionWithNilReturn(structureTypeNode.pos, structTypeName, suffix);\n+\n+        // Create the receiver and add receiver details to the node\n+        initFunction.receiver = ASTBuilderUtil.createReceiver(structureTypeNode.pos, structureTypeNode.type);\n+        BVarSymbol receiverSymbol = new BVarSymbol(Flags.asMask(EnumSet.noneOf(Flag.class)),\n+                                                   names.fromIdNode(initFunction.receiver.name),\n+                                                   env.enclPkg.symbol.pkgID, structureTypeNode.type, null);\n+        initFunction.receiver.symbol = receiverSymbol;\n+        initFunction.attachedFunction = true;\n+        initFunction.flagSet.add(Flag.ATTACHED);\n+\n+        // Create the function type\n+        initFunction.type = new BInvokableType(new ArrayList<>(), symTable.nilType, null);\n+\n+        // Create the function symbol\n+        Name funcSymbolName = names.fromString(Symbols.getAttachedFuncSymbolName(structTypeName, suffix.value));\n+        initFunction.symbol = Symbols\n+                .createFunctionSymbol(Flags.asMask(initFunction.flagSet), funcSymbolName, env.enclPkg.symbol.pkgID,\n+                                      initFunction.type, structureTypeNode.symbol, initFunction.body != null);\n+        initFunction.symbol.scope = new Scope(initFunction.symbol);\n+        initFunction.symbol.scope.define(receiverSymbol.name, receiverSymbol);\n+        initFunction.symbol.receiverSymbol = receiverSymbol;\n+        initFunction.name = ASTBuilderUtil.createIdentifier(structureTypeNode.pos, funcSymbolName.value);\n+\n+        // Create the function type symbol\n+        BInvokableTypeSymbol tsymbol = Symbols.createInvokableTypeSymbol(SymTag.FUNCTION_TYPE,\n+                                                                         initFunction.symbol.flags,\n+                                                                         env.enclPkg.packageID, initFunction.type,\n+                                                                         initFunction.symbol);\n+        tsymbol.params = initFunction.symbol.params;\n+        tsymbol.restParam = initFunction.symbol.restParam;\n+        tsymbol.returnType = initFunction.symbol.retType;\n+        initFunction.type.tsymbol = tsymbol;\n+\n+        receiverSymbol.owner = initFunction.symbol;\n+\n+        // Add return type as nil to the symbol\n+        initFunction.symbol.retType = symTable.nilType;\n+\n+        // Set the taint information to the constructed init function\n+        initFunction.symbol.taintTable = new HashMap<>();\n+        TaintRecord taintRecord = new TaintRecord(TaintRecord.TaintedStatus.UNTAINTED, new ArrayList<>());\n+        initFunction.symbol.taintTable.put(TaintAnalyzer.ALL_UNTAINTED_TABLE_ENTRY_INDEX, taintRecord);\n+\n+        return initFunction;\n+    }\n+\n+    public static void createTypeDefinition(BType type, BTypeSymbol symbol, BLangType typeNode, SymbolEnv env) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad653c8a288a83240f30156e1f6d4b9f2c53a9a6"}, "originalPosition": 151}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzODgzMzA4OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwNTowMDowNFrOFoh0Nw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwNjo0Mzo1NFrOFojN0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA0MTM5OQ==", "bodyText": "Looking at the algorithm I think instead of an array list this could be HashSet. Feel like we are iterating over possibleTypes several times for searching. For loop and contains.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20937#discussion_r378041399", "createdAt": "2020-02-12T05:00:04Z", "author": {"login": "KRVPerera"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -1004,31 +1000,66 @@ private void reportMissingRecordFieldDiagnostics(List<RecordLiteralNode.RecordFi\n         if (bType.tag == TypeTags.UNION) {\n             Set<BType> expTypes = ((BUnionType) bType).getMemberTypes();\n \n-            List<BType> possibleTypes =\n-                    expTypes.stream()\n-                            .filter(type -> type.tag == TypeTags.MAP ||\n-                                    (type.tag == TypeTags.RECORD &&\n-                                            (!((BRecordType) type).sealed ||\n-                                                    isCompatibleClosedRecordLiteral((BRecordType) type,\n-                                                            recordLiteral))))\n-                            .collect(Collectors.toList());\n+            List<BType> possibleTypes = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad653c8a288a83240f30156e1f6d4b9f2c53a9a6"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA2NDMzNw==", "bodyText": "IMO, possible types will often have only around 2-3 types. Given that, I'm wondering if there'll be a significant gain switching to a set?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20937#discussion_r378064337", "createdAt": "2020-02-12T06:43:54Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -1004,31 +1000,66 @@ private void reportMissingRecordFieldDiagnostics(List<RecordLiteralNode.RecordFi\n         if (bType.tag == TypeTags.UNION) {\n             Set<BType> expTypes = ((BUnionType) bType).getMemberTypes();\n \n-            List<BType> possibleTypes =\n-                    expTypes.stream()\n-                            .filter(type -> type.tag == TypeTags.MAP ||\n-                                    (type.tag == TypeTags.RECORD &&\n-                                            (!((BRecordType) type).sealed ||\n-                                                    isCompatibleClosedRecordLiteral((BRecordType) type,\n-                                                            recordLiteral))))\n-                            .collect(Collectors.toList());\n+            List<BType> possibleTypes = new ArrayList<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA0MTM5OQ=="}, "originalCommit": {"oid": "ad653c8a288a83240f30156e1f6d4b9f2c53a9a6"}, "originalPosition": 140}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzODg0NDY0OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwNTowOTo1OVrOFoh7Yw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QwNDo1NDoyNlrOFpHAIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA0MzIzNQ==", "bodyText": "Should the second loop start from the t1+1 item to reduce duplicate isAssignable calls?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20937#discussion_r378043235", "createdAt": "2020-02-12T05:09:59Z", "author": {"login": "KRVPerera"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -4766,4 +4807,141 @@ private boolean isConst(BLangExpression expression) {\n     private Name getCurrentCompUnit(BLangNode node) {\n         return names.fromString(node.pos.getSource().getCompilationUnitName());\n     }\n+\n+    private BType getRepresentativeBroadType(List<BLangExpression> exprs) {\n+        LinkedHashSet<BType> narrowTypes = new LinkedHashSet<>();\n+        LinkedHashSet<BType> broadTypesSet = new LinkedHashSet<>();\n+        BType[] inferredTypes = checkExprList(exprs, env);\n+        for (BType type : inferredTypes) {\n+            if (type.tag == TypeTags.SEMANTIC_ERROR) {\n+                return type;\n+            }\n+\n+            if (narrowTypes.stream().noneMatch(nType -> types.isSameType(type, nType))) {\n+                narrowTypes.add(type);\n+            }\n+        }\n+        BType broadType;\n+        for (BType t1 : narrowTypes) {\n+            broadType = t1;\n+            for (BType t2 : narrowTypes) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad653c8a288a83240f30156e1f6d4b9f2c53a9a6"}, "originalPosition": 319}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODY1MDY1OQ==", "bodyText": "I've updated the getRepresentativeBroadType() logic a bit with ddbbe63. Those changes should address these concerns.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20937#discussion_r378650659", "createdAt": "2020-02-13T04:54:26Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -4766,4 +4807,141 @@ private boolean isConst(BLangExpression expression) {\n     private Name getCurrentCompUnit(BLangNode node) {\n         return names.fromString(node.pos.getSource().getCompilationUnitName());\n     }\n+\n+    private BType getRepresentativeBroadType(List<BLangExpression> exprs) {\n+        LinkedHashSet<BType> narrowTypes = new LinkedHashSet<>();\n+        LinkedHashSet<BType> broadTypesSet = new LinkedHashSet<>();\n+        BType[] inferredTypes = checkExprList(exprs, env);\n+        for (BType type : inferredTypes) {\n+            if (type.tag == TypeTags.SEMANTIC_ERROR) {\n+                return type;\n+            }\n+\n+            if (narrowTypes.stream().noneMatch(nType -> types.isSameType(type, nType))) {\n+                narrowTypes.add(type);\n+            }\n+        }\n+        BType broadType;\n+        for (BType t1 : narrowTypes) {\n+            broadType = t1;\n+            for (BType t2 : narrowTypes) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA0MzIzNQ=="}, "originalCommit": {"oid": "ad653c8a288a83240f30156e1f6d4b9f2c53a9a6"}, "originalPosition": 319}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzODg1NTI1OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwNToxODo1NVrOFoiBwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwNToxODo1NVrOFoiBwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA0NDg2Ng==", "bodyText": "Can we combine this for loop with below double for loops? Something like\ntypes.isSameType(t1, t2) --> continue:;\nt1.tag == TypeTags.SEMANTIC_ERROR) --> continue;\nt2.tag == TypeTags.SEMANTIC_ERROR --> continue;", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20937#discussion_r378044866", "createdAt": "2020-02-12T05:18:55Z", "author": {"login": "KRVPerera"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -4766,4 +4807,141 @@ private boolean isConst(BLangExpression expression) {\n     private Name getCurrentCompUnit(BLangNode node) {\n         return names.fromString(node.pos.getSource().getCompilationUnitName());\n     }\n+\n+    private BType getRepresentativeBroadType(List<BLangExpression> exprs) {\n+        LinkedHashSet<BType> narrowTypes = new LinkedHashSet<>();\n+        LinkedHashSet<BType> broadTypesSet = new LinkedHashSet<>();\n+        BType[] inferredTypes = checkExprList(exprs, env);\n+        for (BType type : inferredTypes) {\n+            if (type.tag == TypeTags.SEMANTIC_ERROR) {\n+                return type;\n+            }\n+\n+            if (narrowTypes.stream().noneMatch(nType -> types.isSameType(type, nType))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad653c8a288a83240f30156e1f6d4b9f2c53a9a6"}, "originalPosition": 312}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1178, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}