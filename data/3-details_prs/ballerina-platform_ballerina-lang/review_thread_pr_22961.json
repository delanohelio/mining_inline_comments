{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEwNjExMzk1", "number": 22961, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxMzo0NDowNlrOD3oiAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxNDoyMDozM1rOD4EKKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NjYyMzM2OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxMzo0NDowNlrOGN_gEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQwNDoyODowNFrOGOZN3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzMyNTA3Mw==", "bodyText": "I think we should remove from L#2851-L#2867. This should be handled inside the parseStatementStartsWithIdentifier() method. Similar cases are handled in that method.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22961#discussion_r417325073", "createdAt": "2020-04-29T13:44:06Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -2842,6 +2856,15 @@ private STNode parseStatement(SyntaxKind tokenKind, STNode annots) {\n                     finalKeyword = STNodeFactory.createEmptyNode();\n                     return parseVariableDecl(getAnnotations(annots), finalKeyword, false);\n                 }\n+                //If the nex token is pipe token then it can be unary type or compound assignment statement.\n+                if (nextToken.kind == SyntaxKind.PIPE_TOKEN) {\n+                    STToken nextNextToken = peek(3);\n+                    // if the nextNextToken is not an equal token then it is a unary type with user defined type\n+                    if (nextNextToken.kind != SyntaxKind.EQUAL_TOKEN) {\n+                        finalKeyword = STNodeFactory.createEmptyNode();\n+                        return parseVariableDecl(getAnnotations(annots), finalKeyword, false);\n+                    }\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc16760353f3bd8612cbfaf26dc2862a1ca86143"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQzNjgyNw==", "bodyText": "will look at it", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22961#discussion_r417436827", "createdAt": "2020-04-29T16:10:42Z", "author": {"login": "rdulmina"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -2842,6 +2856,15 @@ private STNode parseStatement(SyntaxKind tokenKind, STNode annots) {\n                     finalKeyword = STNodeFactory.createEmptyNode();\n                     return parseVariableDecl(getAnnotations(annots), finalKeyword, false);\n                 }\n+                //If the nex token is pipe token then it can be unary type or compound assignment statement.\n+                if (nextToken.kind == SyntaxKind.PIPE_TOKEN) {\n+                    STToken nextNextToken = peek(3);\n+                    // if the nextNextToken is not an equal token then it is a unary type with user defined type\n+                    if (nextNextToken.kind != SyntaxKind.EQUAL_TOKEN) {\n+                        finalKeyword = STNodeFactory.createEmptyNode();\n+                        return parseVariableDecl(getAnnotations(annots), finalKeyword, false);\n+                    }\n+                }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzMyNTA3Mw=="}, "originalCommit": {"oid": "fc16760353f3bd8612cbfaf26dc2862a1ca86143"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc0NjM5Nw==", "bodyText": "Changed. Please check that change is enough.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22961#discussion_r417746397", "createdAt": "2020-04-30T04:28:04Z", "author": {"login": "rdulmina"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -2842,6 +2856,15 @@ private STNode parseStatement(SyntaxKind tokenKind, STNode annots) {\n                     finalKeyword = STNodeFactory.createEmptyNode();\n                     return parseVariableDecl(getAnnotations(annots), finalKeyword, false);\n                 }\n+                //If the nex token is pipe token then it can be unary type or compound assignment statement.\n+                if (nextToken.kind == SyntaxKind.PIPE_TOKEN) {\n+                    STToken nextNextToken = peek(3);\n+                    // if the nextNextToken is not an equal token then it is a unary type with user defined type\n+                    if (nextNextToken.kind != SyntaxKind.EQUAL_TOKEN) {\n+                        finalKeyword = STNodeFactory.createEmptyNode();\n+                        return parseVariableDecl(getAnnotations(annots), finalKeyword, false);\n+                    }\n+                }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzMyNTA3Mw=="}, "originalCommit": {"oid": "fc16760353f3bd8612cbfaf26dc2862a1ca86143"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NjY0MDA3OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxMzo0Nzo0OVrOGN_qpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQwNDoyNzowNVrOGOZM8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzMyNzc4MQ==", "bodyText": "I feel ParserRuleContext.UNION_TYPE_DESCRIPTOR is not needed at all. Looks like it is not being used for any decision making within the error recovery. Only pushed and popped from the stack.\nCan we use ParserRuleContext.PIPE here?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22961#discussion_r417327781", "createdAt": "2020-04-29T13:47:49Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -259,7 +259,8 @@\n             { ParserRuleContext.BASIC_LITERAL, ParserRuleContext.VARIABLE_REF };\n \n     private static final ParserRuleContext[] TYPEDESC_RHS = {ParserRuleContext.NON_RECURSIVE_TYPE,\n-            ParserRuleContext.ARRAY_TYPE_DESCRIPTOR, ParserRuleContext.OPTIONAL_TYPE_DESCRIPTOR };\n+            ParserRuleContext.ARRAY_TYPE_DESCRIPTOR, ParserRuleContext.OPTIONAL_TYPE_DESCRIPTOR,\n+            ParserRuleContext.UNION_TYPE_DESCRIPTOR };", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc16760353f3bd8612cbfaf26dc2862a1ca86143"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQzNjM4Nw==", "bodyText": "Yeh seems like we can do that. But It will affect readability.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22961#discussion_r417436387", "createdAt": "2020-04-29T16:10:05Z", "author": {"login": "rdulmina"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -259,7 +259,8 @@\n             { ParserRuleContext.BASIC_LITERAL, ParserRuleContext.VARIABLE_REF };\n \n     private static final ParserRuleContext[] TYPEDESC_RHS = {ParserRuleContext.NON_RECURSIVE_TYPE,\n-            ParserRuleContext.ARRAY_TYPE_DESCRIPTOR, ParserRuleContext.OPTIONAL_TYPE_DESCRIPTOR };\n+            ParserRuleContext.ARRAY_TYPE_DESCRIPTOR, ParserRuleContext.OPTIONAL_TYPE_DESCRIPTOR,\n+            ParserRuleContext.UNION_TYPE_DESCRIPTOR };", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzMyNzc4MQ=="}, "originalCommit": {"oid": "fc16760353f3bd8612cbfaf26dc2862a1ca86143"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc0NjE2Mg==", "bodyText": "Used ParserRuleContext.PIPE and removed ParserRuleContext.UNION_TYPE_DESCRIPTOR", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22961#discussion_r417746162", "createdAt": "2020-04-30T04:27:05Z", "author": {"login": "rdulmina"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -259,7 +259,8 @@\n             { ParserRuleContext.BASIC_LITERAL, ParserRuleContext.VARIABLE_REF };\n \n     private static final ParserRuleContext[] TYPEDESC_RHS = {ParserRuleContext.NON_RECURSIVE_TYPE,\n-            ParserRuleContext.ARRAY_TYPE_DESCRIPTOR, ParserRuleContext.OPTIONAL_TYPE_DESCRIPTOR };\n+            ParserRuleContext.ARRAY_TYPE_DESCRIPTOR, ParserRuleContext.OPTIONAL_TYPE_DESCRIPTOR,\n+            ParserRuleContext.UNION_TYPE_DESCRIPTOR };", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzMyNzc4MQ=="}, "originalCommit": {"oid": "fc16760353f3bd8612cbfaf26dc2862a1ca86143"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwMTExMjM0OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxNDoxMjowNVrOGOrLOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxNjoxMDowMFrOGOwUlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODA0MDYzMg==", "bodyText": "Can't we use parseComplexTypeDescriptor() method?\nyou'll need to extract the content out in that method to a new method like: parseComplexTypeDescriptor(SyntaxKind kind)", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22961#discussion_r418040632", "createdAt": "2020-04-30T14:12:05Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -5587,12 +5593,32 @@ private STNode parseStatementStartsWithIdentifier(SyntaxKind nextTokenKind, STNo\n             case SEMICOLON_TOKEN:\n                 // Here we directly start parsing as a statement that starts with an expression.\n                 return parseStamentStartWithExpr(nextTokenKind, identifier);\n+            case QUESTION_MARK_TOKEN:\n+                // if the next token is question-mark then it is an optional type descriptor with user defined type\n+                switchContext(ParserRuleContext.VAR_DECL_STMT);\n+                STNode questionMarkToken = parseQuestionMark();\n+                STNode optionalTypeDesc = STNodeFactory.createOptionalTypeDescriptorNode(identifier, questionMarkToken);\n+                //check whether if there is more type descriptor elements\n+                STNode typeDesc = parseComplexTypeDescriptor(optionalTypeDesc);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7c0c897e123a7ba21ce474c49571e29f20b7c983"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODEyNDk0OQ==", "bodyText": "done", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22961#discussion_r418124949", "createdAt": "2020-04-30T16:10:00Z", "author": {"login": "rdulmina"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -5587,12 +5593,32 @@ private STNode parseStatementStartsWithIdentifier(SyntaxKind nextTokenKind, STNo\n             case SEMICOLON_TOKEN:\n                 // Here we directly start parsing as a statement that starts with an expression.\n                 return parseStamentStartWithExpr(nextTokenKind, identifier);\n+            case QUESTION_MARK_TOKEN:\n+                // if the next token is question-mark then it is an optional type descriptor with user defined type\n+                switchContext(ParserRuleContext.VAR_DECL_STMT);\n+                STNode questionMarkToken = parseQuestionMark();\n+                STNode optionalTypeDesc = STNodeFactory.createOptionalTypeDescriptorNode(identifier, questionMarkToken);\n+                //check whether if there is more type descriptor elements\n+                STNode typeDesc = parseComplexTypeDescriptor(optionalTypeDesc);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODA0MDYzMg=="}, "originalCommit": {"oid": "7c0c897e123a7ba21ce474c49571e29f20b7c983"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwMTEyMTc0OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxNDoxNDoyMFrOGOrRTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxNjoxMTowMFrOGOwXWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODA0MjE4OA==", "bodyText": "Similarly, can we call parseUnionTypeDescriptor() here?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22961#discussion_r418042188", "createdAt": "2020-04-30T14:14:20Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -5587,12 +5593,32 @@ private STNode parseStatementStartsWithIdentifier(SyntaxKind nextTokenKind, STNo\n             case SEMICOLON_TOKEN:\n                 // Here we directly start parsing as a statement that starts with an expression.\n                 return parseStamentStartWithExpr(nextTokenKind, identifier);\n+            case QUESTION_MARK_TOKEN:\n+                // if the next token is question-mark then it is an optional type descriptor with user defined type\n+                switchContext(ParserRuleContext.VAR_DECL_STMT);\n+                STNode questionMarkToken = parseQuestionMark();\n+                STNode optionalTypeDesc = STNodeFactory.createOptionalTypeDescriptorNode(identifier, questionMarkToken);\n+                //check whether if there is more type descriptor elements\n+                STNode typeDesc = parseComplexTypeDescriptor(optionalTypeDesc);\n+                varName = parseVariableName();\n+                finalKeyword = STNodeFactory.createEmptyNode();\n+                return parseVarDeclRhs(annots, finalKeyword, typeDesc, varName, false);\n             default:\n                 // If its a binary operator then this can be a compound assignment statement\n                 if (isCompoundBinaryOperator(nextTokenKind)) {\n                     return parseCompoundAssignmentStmtRhs(identifier);\n                 }\n-\n+                // If its not a compound assignment statement then it can be union type desc.\n+                if (nextTokenKind == SyntaxKind.PIPE_TOKEN) {\n+                    switchContext(ParserRuleContext.VAR_DECL_STMT);\n+                    STNode pipeToken = parsePipeToken();\n+                    STNode rightTypeDesc = parseTypeDescriptor();\n+                    STNode unionTypeDesc = STNodeFactory.createUnionTypeDescriptorNode(identifier, pipeToken,\n+                            rightTypeDesc);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7c0c897e123a7ba21ce474c49571e29f20b7c983"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODEyNTY1Ng==", "bodyText": "@SupunS found a better way. Please check.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22961#discussion_r418125656", "createdAt": "2020-04-30T16:11:00Z", "author": {"login": "rdulmina"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -5587,12 +5593,32 @@ private STNode parseStatementStartsWithIdentifier(SyntaxKind nextTokenKind, STNo\n             case SEMICOLON_TOKEN:\n                 // Here we directly start parsing as a statement that starts with an expression.\n                 return parseStamentStartWithExpr(nextTokenKind, identifier);\n+            case QUESTION_MARK_TOKEN:\n+                // if the next token is question-mark then it is an optional type descriptor with user defined type\n+                switchContext(ParserRuleContext.VAR_DECL_STMT);\n+                STNode questionMarkToken = parseQuestionMark();\n+                STNode optionalTypeDesc = STNodeFactory.createOptionalTypeDescriptorNode(identifier, questionMarkToken);\n+                //check whether if there is more type descriptor elements\n+                STNode typeDesc = parseComplexTypeDescriptor(optionalTypeDesc);\n+                varName = parseVariableName();\n+                finalKeyword = STNodeFactory.createEmptyNode();\n+                return parseVarDeclRhs(annots, finalKeyword, typeDesc, varName, false);\n             default:\n                 // If its a binary operator then this can be a compound assignment statement\n                 if (isCompoundBinaryOperator(nextTokenKind)) {\n                     return parseCompoundAssignmentStmtRhs(identifier);\n                 }\n-\n+                // If its not a compound assignment statement then it can be union type desc.\n+                if (nextTokenKind == SyntaxKind.PIPE_TOKEN) {\n+                    switchContext(ParserRuleContext.VAR_DECL_STMT);\n+                    STNode pipeToken = parsePipeToken();\n+                    STNode rightTypeDesc = parseTypeDescriptor();\n+                    STNode unionTypeDesc = STNodeFactory.createUnionTypeDescriptorNode(identifier, pipeToken,\n+                            rightTypeDesc);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODA0MjE4OA=="}, "originalCommit": {"oid": "7c0c897e123a7ba21ce474c49571e29f20b7c983"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwMTEzMTgzOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxNDoxNjozOFrOGOrXvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxNjoxMTowOFrOGOwXtg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODA0MzgzOQ==", "bodyText": "These three lines seems to be repeating in three places inside this method. Better to take it out as a method and re-use it.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22961#discussion_r418043839", "createdAt": "2020-04-30T14:16:38Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -5587,12 +5593,32 @@ private STNode parseStatementStartsWithIdentifier(SyntaxKind nextTokenKind, STNo\n             case SEMICOLON_TOKEN:\n                 // Here we directly start parsing as a statement that starts with an expression.\n                 return parseStamentStartWithExpr(nextTokenKind, identifier);\n+            case QUESTION_MARK_TOKEN:\n+                // if the next token is question-mark then it is an optional type descriptor with user defined type\n+                switchContext(ParserRuleContext.VAR_DECL_STMT);\n+                STNode questionMarkToken = parseQuestionMark();\n+                STNode optionalTypeDesc = STNodeFactory.createOptionalTypeDescriptorNode(identifier, questionMarkToken);\n+                //check whether if there is more type descriptor elements\n+                STNode typeDesc = parseComplexTypeDescriptor(optionalTypeDesc);\n+                varName = parseVariableName();\n+                finalKeyword = STNodeFactory.createEmptyNode();\n+                return parseVarDeclRhs(annots, finalKeyword, typeDesc, varName, false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7c0c897e123a7ba21ce474c49571e29f20b7c983"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODEyNTc1MA==", "bodyText": "done", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22961#discussion_r418125750", "createdAt": "2020-04-30T16:11:08Z", "author": {"login": "rdulmina"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -5587,12 +5593,32 @@ private STNode parseStatementStartsWithIdentifier(SyntaxKind nextTokenKind, STNo\n             case SEMICOLON_TOKEN:\n                 // Here we directly start parsing as a statement that starts with an expression.\n                 return parseStamentStartWithExpr(nextTokenKind, identifier);\n+            case QUESTION_MARK_TOKEN:\n+                // if the next token is question-mark then it is an optional type descriptor with user defined type\n+                switchContext(ParserRuleContext.VAR_DECL_STMT);\n+                STNode questionMarkToken = parseQuestionMark();\n+                STNode optionalTypeDesc = STNodeFactory.createOptionalTypeDescriptorNode(identifier, questionMarkToken);\n+                //check whether if there is more type descriptor elements\n+                STNode typeDesc = parseComplexTypeDescriptor(optionalTypeDesc);\n+                varName = parseVariableName();\n+                finalKeyword = STNodeFactory.createEmptyNode();\n+                return parseVarDeclRhs(annots, finalKeyword, typeDesc, varName, false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODA0MzgzOQ=="}, "originalCommit": {"oid": "7c0c897e123a7ba21ce474c49571e29f20b7c983"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwMTE0OTg0OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxNDoyMDozM1rOGOri9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxNjoxMToxOFrOGOwYHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODA0NjcxMA==", "bodyText": "Shall we move this as another case in the switch-case? If the token after pipe is a = then we can fall through.\nReason is, use of  union-types is a more prominent use-case compared to compound operators. So moving this to switch case lets us exit-early.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22961#discussion_r418046710", "createdAt": "2020-04-30T14:20:33Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -5587,12 +5593,32 @@ private STNode parseStatementStartsWithIdentifier(SyntaxKind nextTokenKind, STNo\n             case SEMICOLON_TOKEN:\n                 // Here we directly start parsing as a statement that starts with an expression.\n                 return parseStamentStartWithExpr(nextTokenKind, identifier);\n+            case QUESTION_MARK_TOKEN:\n+                // if the next token is question-mark then it is an optional type descriptor with user defined type\n+                switchContext(ParserRuleContext.VAR_DECL_STMT);\n+                STNode questionMarkToken = parseQuestionMark();\n+                STNode optionalTypeDesc = STNodeFactory.createOptionalTypeDescriptorNode(identifier, questionMarkToken);\n+                //check whether if there is more type descriptor elements\n+                STNode typeDesc = parseComplexTypeDescriptor(optionalTypeDesc);\n+                varName = parseVariableName();\n+                finalKeyword = STNodeFactory.createEmptyNode();\n+                return parseVarDeclRhs(annots, finalKeyword, typeDesc, varName, false);\n             default:\n                 // If its a binary operator then this can be a compound assignment statement\n                 if (isCompoundBinaryOperator(nextTokenKind)) {\n                     return parseCompoundAssignmentStmtRhs(identifier);\n                 }\n-\n+                // If its not a compound assignment statement then it can be union type desc.\n+                if (nextTokenKind == SyntaxKind.PIPE_TOKEN) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7c0c897e123a7ba21ce474c49571e29f20b7c983"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODEyNTg1Mw==", "bodyText": "done", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22961#discussion_r418125853", "createdAt": "2020-04-30T16:11:18Z", "author": {"login": "rdulmina"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -5587,12 +5593,32 @@ private STNode parseStatementStartsWithIdentifier(SyntaxKind nextTokenKind, STNo\n             case SEMICOLON_TOKEN:\n                 // Here we directly start parsing as a statement that starts with an expression.\n                 return parseStamentStartWithExpr(nextTokenKind, identifier);\n+            case QUESTION_MARK_TOKEN:\n+                // if the next token is question-mark then it is an optional type descriptor with user defined type\n+                switchContext(ParserRuleContext.VAR_DECL_STMT);\n+                STNode questionMarkToken = parseQuestionMark();\n+                STNode optionalTypeDesc = STNodeFactory.createOptionalTypeDescriptorNode(identifier, questionMarkToken);\n+                //check whether if there is more type descriptor elements\n+                STNode typeDesc = parseComplexTypeDescriptor(optionalTypeDesc);\n+                varName = parseVariableName();\n+                finalKeyword = STNodeFactory.createEmptyNode();\n+                return parseVarDeclRhs(annots, finalKeyword, typeDesc, varName, false);\n             default:\n                 // If its a binary operator then this can be a compound assignment statement\n                 if (isCompoundBinaryOperator(nextTokenKind)) {\n                     return parseCompoundAssignmentStmtRhs(identifier);\n                 }\n-\n+                // If its not a compound assignment statement then it can be union type desc.\n+                if (nextTokenKind == SyntaxKind.PIPE_TOKEN) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODA0NjcxMA=="}, "originalCommit": {"oid": "7c0c897e123a7ba21ce474c49571e29f20b7c983"}, "originalPosition": 69}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3835, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}