{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ2MzM3NzUw", "number": 24658, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQwMzowOTowM1rOEMuarA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQwMzoxMzoyNFrOEMudVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxNzc4ODYwOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQwMzowOTowM1rOGvAI9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxODowODowMFrOGvcP6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTkzODU1MQ==", "bodyText": "I think we can simplify this method and parseOtherArgMatchPatterns method, if we follow the same approach as parseArgList method.\nA further simplified/cleanup version can be found in parseArgListBindingPatterns (still WIP). I would suggest let's do similar to this one.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24658#discussion_r451938551", "createdAt": "2020-07-09T03:09:03Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -12744,6 +12754,251 @@ private STNode parseFieldMatchPatternRhs(SyntaxKind nextTokenKind) {\n         }\n     }\n \n+    private STNode parseFunctionalMatchPatternOrConsPattern(STNode typeRefOrConstExpr) {\n+        return parseFunctionalMatchPatternOrConsPattern(peek().kind, typeRefOrConstExpr);\n+    }\n+\n+    private STNode parseFunctionalMatchPatternOrConsPattern(SyntaxKind nextToken, STNode typeRefOrConstExpr) {\n+        switch (nextToken) {\n+            case OPEN_PAREN_TOKEN:\n+                return parseFunctionalMatchPattern(typeRefOrConstExpr);\n+            default:\n+                if (isMatchPatternRhs(peek().kind)) {\n+                    return typeRefOrConstExpr;\n+                }\n+                Solution solution = recover(peek(), ParserRuleContext.FUNC_MATCH_PATTERN_OR_CONST_PATTERN,\n+                        typeRefOrConstExpr);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseFunctionalMatchPatternOrConsPattern(solution.tokenKind, typeRefOrConstExpr);\n+        }\n+    }\n+\n+    private boolean isMatchPatternRhs(SyntaxKind tokenKind) {\n+        switch (tokenKind) {\n+            case RIGHT_DOUBLE_ARROW_TOKEN:\n+            case COMMA_TOKEN:\n+            case CLOSE_BRACE_TOKEN:\n+            case CLOSE_BRACKET_TOKEN:\n+            case CLOSE_PAREN_TOKEN:\n+            case PIPE_TOKEN:\n+            case IF_KEYWORD:\n+            case EOF_TOKEN:\n+                return true;\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    /**\n+     * Parse functional match pattern.\n+     *<p>\n+     *     functional-match-pattern := functionally-constructible-type-reference ( arg-list-match-pattern )\n+     *     <br/>\n+     *     functionally-constructible-type-reference := error | type-reference\n+     *     <br/>\n+     *     type-reference := identifier | qualified-identifier\n+     *     <br/>\n+     *     arg-list-match-pattern := positional-arg-match-patterns [, other-arg-match-patterns]\n+     *    | other-arg-match-patterns\n+     *</p>\n+     *\n+     * @return Parsed functional match pattern node.\n+     */\n+    private STNode parseFunctionalMatchPattern(STNode typeRef) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27b36fdc98bea11d278680a23ab8dc0bcd9ddd87"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTk4ODI5Mg==", "bodyText": "sure will look into that :-)", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24658#discussion_r451988292", "createdAt": "2020-07-09T06:20:04Z", "author": {"login": "rdulmina"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -12744,6 +12754,251 @@ private STNode parseFieldMatchPatternRhs(SyntaxKind nextTokenKind) {\n         }\n     }\n \n+    private STNode parseFunctionalMatchPatternOrConsPattern(STNode typeRefOrConstExpr) {\n+        return parseFunctionalMatchPatternOrConsPattern(peek().kind, typeRefOrConstExpr);\n+    }\n+\n+    private STNode parseFunctionalMatchPatternOrConsPattern(SyntaxKind nextToken, STNode typeRefOrConstExpr) {\n+        switch (nextToken) {\n+            case OPEN_PAREN_TOKEN:\n+                return parseFunctionalMatchPattern(typeRefOrConstExpr);\n+            default:\n+                if (isMatchPatternRhs(peek().kind)) {\n+                    return typeRefOrConstExpr;\n+                }\n+                Solution solution = recover(peek(), ParserRuleContext.FUNC_MATCH_PATTERN_OR_CONST_PATTERN,\n+                        typeRefOrConstExpr);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseFunctionalMatchPatternOrConsPattern(solution.tokenKind, typeRefOrConstExpr);\n+        }\n+    }\n+\n+    private boolean isMatchPatternRhs(SyntaxKind tokenKind) {\n+        switch (tokenKind) {\n+            case RIGHT_DOUBLE_ARROW_TOKEN:\n+            case COMMA_TOKEN:\n+            case CLOSE_BRACE_TOKEN:\n+            case CLOSE_BRACKET_TOKEN:\n+            case CLOSE_PAREN_TOKEN:\n+            case PIPE_TOKEN:\n+            case IF_KEYWORD:\n+            case EOF_TOKEN:\n+                return true;\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    /**\n+     * Parse functional match pattern.\n+     *<p>\n+     *     functional-match-pattern := functionally-constructible-type-reference ( arg-list-match-pattern )\n+     *     <br/>\n+     *     functionally-constructible-type-reference := error | type-reference\n+     *     <br/>\n+     *     type-reference := identifier | qualified-identifier\n+     *     <br/>\n+     *     arg-list-match-pattern := positional-arg-match-patterns [, other-arg-match-patterns]\n+     *    | other-arg-match-patterns\n+     *</p>\n+     *\n+     * @return Parsed functional match pattern node.\n+     */\n+    private STNode parseFunctionalMatchPattern(STNode typeRef) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTkzODU1MQ=="}, "originalCommit": {"oid": "27b36fdc98bea11d278680a23ab8dc0bcd9ddd87"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM5OTA4Mg==", "bodyText": "Improved", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24658#discussion_r452399082", "createdAt": "2020-07-09T18:08:00Z", "author": {"login": "rdulmina"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -12744,6 +12754,251 @@ private STNode parseFieldMatchPatternRhs(SyntaxKind nextTokenKind) {\n         }\n     }\n \n+    private STNode parseFunctionalMatchPatternOrConsPattern(STNode typeRefOrConstExpr) {\n+        return parseFunctionalMatchPatternOrConsPattern(peek().kind, typeRefOrConstExpr);\n+    }\n+\n+    private STNode parseFunctionalMatchPatternOrConsPattern(SyntaxKind nextToken, STNode typeRefOrConstExpr) {\n+        switch (nextToken) {\n+            case OPEN_PAREN_TOKEN:\n+                return parseFunctionalMatchPattern(typeRefOrConstExpr);\n+            default:\n+                if (isMatchPatternRhs(peek().kind)) {\n+                    return typeRefOrConstExpr;\n+                }\n+                Solution solution = recover(peek(), ParserRuleContext.FUNC_MATCH_PATTERN_OR_CONST_PATTERN,\n+                        typeRefOrConstExpr);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseFunctionalMatchPatternOrConsPattern(solution.tokenKind, typeRefOrConstExpr);\n+        }\n+    }\n+\n+    private boolean isMatchPatternRhs(SyntaxKind tokenKind) {\n+        switch (tokenKind) {\n+            case RIGHT_DOUBLE_ARROW_TOKEN:\n+            case COMMA_TOKEN:\n+            case CLOSE_BRACE_TOKEN:\n+            case CLOSE_BRACKET_TOKEN:\n+            case CLOSE_PAREN_TOKEN:\n+            case PIPE_TOKEN:\n+            case IF_KEYWORD:\n+            case EOF_TOKEN:\n+                return true;\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    /**\n+     * Parse functional match pattern.\n+     *<p>\n+     *     functional-match-pattern := functionally-constructible-type-reference ( arg-list-match-pattern )\n+     *     <br/>\n+     *     functionally-constructible-type-reference := error | type-reference\n+     *     <br/>\n+     *     type-reference := identifier | qualified-identifier\n+     *     <br/>\n+     *     arg-list-match-pattern := positional-arg-match-patterns [, other-arg-match-patterns]\n+     *    | other-arg-match-patterns\n+     *</p>\n+     *\n+     * @return Parsed functional match pattern node.\n+     */\n+    private STNode parseFunctionalMatchPattern(STNode typeRef) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTkzODU1MQ=="}, "originalCommit": {"oid": "27b36fdc98bea11d278680a23ab8dc0bcd9ddd87"}, "originalPosition": 105}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxNzc5NTQyOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-treegen/src/main/resources/syntax_tree_descriptor.json", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQwMzoxMzoyNFrOGvANHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxODowODoxMFrOGvcQMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTkzOTYxMw==", "bodyText": "The comma in between the two lists are not captured?\nWould it be better to merge these two lists in to one (similar to arguments list in a function call)?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24658#discussion_r451939613", "createdAt": "2020-07-09T03:13:24Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-treegen/src/main/resources/syntax_tree_descriptor.json", "diffHunk": "@@ -3938,6 +3938,70 @@\n                 }\n             ]\n         },\n+        {\n+            \"name\": \"FunctionalMatchPatternNode\",\n+            \"base\": \"Node\",\n+            \"kind\": \"FUNCTIONAL_MATCH_PATTERN\",\n+            \"attributes\": [\n+                {\n+                    \"name\": \"typeRef\",\n+                    \"type\": \"Node\"\n+                },\n+                {\n+                    \"name\": \"openParenthesisToken\",\n+                    \"type\": \"Token\"\n+                },\n+                {\n+                    \"name\": \"positionalArgMatchPatternsNode\",\n+                    \"type\": \"Node\",\n+                    \"occurrences\": \"MULTIPLE_SEPARATED\"\n+                },\n+                {\n+                    \"name\": \"otherArgMatchPatternsNode\",\n+                    \"type\": \"OtherArgMatchPatternsNode\"\n+                },", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27b36fdc98bea11d278680a23ab8dc0bcd9ddd87"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTk4ODA1OA==", "bodyText": "That comma is captured to the end of positionalArgMatchPatterns list.\nWill look into that", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24658#discussion_r451988058", "createdAt": "2020-07-09T06:19:27Z", "author": {"login": "rdulmina"}, "path": "compiler/ballerina-treegen/src/main/resources/syntax_tree_descriptor.json", "diffHunk": "@@ -3938,6 +3938,70 @@\n                 }\n             ]\n         },\n+        {\n+            \"name\": \"FunctionalMatchPatternNode\",\n+            \"base\": \"Node\",\n+            \"kind\": \"FUNCTIONAL_MATCH_PATTERN\",\n+            \"attributes\": [\n+                {\n+                    \"name\": \"typeRef\",\n+                    \"type\": \"Node\"\n+                },\n+                {\n+                    \"name\": \"openParenthesisToken\",\n+                    \"type\": \"Token\"\n+                },\n+                {\n+                    \"name\": \"positionalArgMatchPatternsNode\",\n+                    \"type\": \"Node\",\n+                    \"occurrences\": \"MULTIPLE_SEPARATED\"\n+                },\n+                {\n+                    \"name\": \"otherArgMatchPatternsNode\",\n+                    \"type\": \"OtherArgMatchPatternsNode\"\n+                },", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTkzOTYxMw=="}, "originalCommit": {"oid": "27b36fdc98bea11d278680a23ab8dc0bcd9ddd87"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM5OTE1NQ==", "bodyText": "Changed", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24658#discussion_r452399155", "createdAt": "2020-07-09T18:08:10Z", "author": {"login": "rdulmina"}, "path": "compiler/ballerina-treegen/src/main/resources/syntax_tree_descriptor.json", "diffHunk": "@@ -3938,6 +3938,70 @@\n                 }\n             ]\n         },\n+        {\n+            \"name\": \"FunctionalMatchPatternNode\",\n+            \"base\": \"Node\",\n+            \"kind\": \"FUNCTIONAL_MATCH_PATTERN\",\n+            \"attributes\": [\n+                {\n+                    \"name\": \"typeRef\",\n+                    \"type\": \"Node\"\n+                },\n+                {\n+                    \"name\": \"openParenthesisToken\",\n+                    \"type\": \"Token\"\n+                },\n+                {\n+                    \"name\": \"positionalArgMatchPatternsNode\",\n+                    \"type\": \"Node\",\n+                    \"occurrences\": \"MULTIPLE_SEPARATED\"\n+                },\n+                {\n+                    \"name\": \"otherArgMatchPatternsNode\",\n+                    \"type\": \"OtherArgMatchPatternsNode\"\n+                },", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTkzOTYxMw=="}, "originalCommit": {"oid": "27b36fdc98bea11d278680a23ab8dc0bcd9ddd87"}, "originalPosition": 25}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3239, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}