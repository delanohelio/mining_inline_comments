{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIyMDczODUy", "number": 23450, "title": "Add enum declaration support to new parser", "bodyText": "Purpose\nAdd enum declaration support to new parser with recovery logic and test cases.\nFixes #23414\nCheck List\n\n Read the Contributing Guide\n Updated Change Log\n Checked Tooling Support (#)\n Added necessary tests\n\n Unit Tests\n Spec Conformance Tests\n Integration Tests\n Ballerina By Example Tests\n\n\n Increased Test Coverage\n Added necessary documentation\n\n API documentation\n Module documentation in Module.md files\n Ballerina By Examples", "createdAt": "2020-05-22T18:07:21Z", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23450", "merged": true, "mergeCommit": {"oid": "73752385e3a3efcf93d63da1dcfef6dbd963a430"}, "closed": true, "closedAt": "2020-05-23T14:16:37Z", "author": {"login": "rdulmina"}, "timelineItems": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcjtcnegH2gAyNDIyMDczODUyOjI4NGVlOGFiMzUwZmJmYWRjODE1Y2M1NzhhOGY4ZDJmNDdjZjgxNDA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABckF88hgFqTQxNzI3NDE1Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "284ee8ab350fbfadc815cc578a8f8d2f47cf8140", "author": {"user": {"login": "rdulmina", "name": "Dulmina Renuke"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/284ee8ab350fbfadc815cc578a8f8d2f47cf8140", "committedDate": "2020-05-22T07:50:25Z", "message": "Module enum declaration support."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1529ada0cc6a8d5dfd92008004354e5861cf9dfe", "author": {"user": {"login": "rdulmina", "name": "Dulmina Renuke"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1529ada0cc6a8d5dfd92008004354e5861cf9dfe", "committedDate": "2020-05-22T17:43:19Z", "message": "Recovery logic and test cases for module enum declaration."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dfcd1ac831930ec13ff0c709e9a40d0b9b8df1d9", "author": {"user": {"login": "rdulmina", "name": "Dulmina Renuke"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/dfcd1ac831930ec13ff0c709e9a40d0b9b8df1d9", "committedDate": "2020-05-22T18:03:14Z", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into tuple-type"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f064353a3b19c89f7ccd71c0f8083a0e11dc4560", "author": {"user": {"login": "rdulmina", "name": "Dulmina Renuke"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f064353a3b19c89f7ccd71c0f8083a0e11dc4560", "committedDate": "2020-05-22T18:12:19Z", "message": "Removed extra new lines."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "126f69cb7996d944324fa820a43b45288ae77074", "author": {"user": {"login": "rdulmina", "name": "Dulmina Renuke"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/126f69cb7996d944324fa820a43b45288ae77074", "committedDate": "2020-05-22T18:14:47Z", "message": "Added new line to EOF."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE3Mjc0MTUy", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23450#pullrequestreview-417274152", "createdAt": "2020-05-23T12:12:59Z", "commit": {"oid": "126f69cb7996d944324fa820a43b45288ae77074"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QxMjoxMjo1OVrOGZpFKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QxMjoxNDowN1rOGZpFYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU0MDY1MQ==", "bodyText": "Can say parseEnumMemberEnd", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23450#discussion_r429540651", "createdAt": "2020-05-23T12:12:59Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -10857,4 +10866,164 @@ private STNode parseConditionalExpression(STNode lhsExpr) {\n         STNode endExpr = parseExpression(OperatorPrecedence.ELVIS_CONDITIONAL, true, false);\n         return STNodeFactory.createConditionalExpressionNode(lhsExpr, questionMark, middleExpr, colon, endExpr);\n     }\n+\n+    /**\n+     * Parse enum declaration.\n+     * <p>\n+     * module-enum-decl :=\n+     *  metadata\n+     *  [public] enum identifier { enum-member (, enum-member)* }\n+     * enum-member := metadata identifier [= const-expr]\n+     * </p>\n+     * @param metadata\n+     * @param qualifier\n+     *\n+     * @return Parsed enum node.\n+     */\n+    private STNode parseEnumDeclaration(STNode metadata, STNode qualifier) {\n+        startContext(ParserRuleContext.MODULE_ENUM_DECLARATION);\n+        STNode enumKeywordToken = parseEnumKeyword();\n+        STNode identifier = parseIdentifier(ParserRuleContext.MODULE_ENUM_NAME);\n+        STNode openBraceToken = parseOpenBrace();\n+        STNode enumMemberList = parseEnumMemberList();\n+        STNode closeBraceToken = parseCloseBrace();\n+\n+        endContext();\n+        return STNodeFactory.createEnumDeclarationNode(metadata, qualifier, enumKeywordToken, identifier,\n+                openBraceToken, enumMemberList, closeBraceToken);\n+    }\n+\n+    /**\n+     * Parse enum member list.\n+     * <p>enum-member := metadata identifier [= const-expr]</p>\n+     *\n+     * @return enum member list node.\n+     */\n+    private STNode parseEnumMemberList() {\n+        startContext(ParserRuleContext.ENUM_MEMBER_LIST);\n+        List<STNode> enumMemberList = new ArrayList<>();\n+        STToken nextToken = peek();\n+\n+        // Report an empty enum member list\n+        if (nextToken.kind == SyntaxKind.CLOSE_BRACE_TOKEN) {\n+            this.errorHandler.reportMissingTokenError(\"enum member list cannot be empty\");\n+            return STNodeFactory.createNodeList(new ArrayList<>());\n+        }\n+\n+        // Parse first enum member, that has no leading comma\n+        STNode enumMember = parseEnumMember();\n+\n+        // Parse the remaining enum members\n+        nextToken = peek();\n+        STNode enumMemberRhs;\n+        while (nextToken.kind != SyntaxKind.CLOSE_BRACE_TOKEN) {\n+            enumMemberRhs = parseEnumMemberRhs(nextToken.kind);\n+            if (enumMemberRhs == null) {\n+                break;\n+            }\n+            enumMemberList.add(enumMember);\n+            enumMemberList.add(enumMemberRhs);\n+            enumMember = parseEnumMember();\n+            nextToken = peek();\n+        }\n+\n+        enumMemberList.add(enumMember);\n+\n+        endContext();\n+        return STNodeFactory.createNodeList(enumMemberList);\n+    }\n+\n+    /**\n+     * Parse enum member.\n+     * <p>enum-member := metadata identifier [= const-expr]</p>\n+     *\n+     * @return Parsed enum member node.\n+     */\n+    private STNode parseEnumMember() {\n+        STToken nextToken = peek();\n+        STNode metadata;\n+        switch (nextToken.kind) {\n+            case DOCUMENTATION_LINE:\n+            case AT_TOKEN:\n+                metadata = parseMetaData(nextToken.kind);\n+                break;\n+            default:\n+                metadata = STNodeFactory.createEmptyNode();\n+        }\n+\n+        STNode identifierNode = parseIdentifier(ParserRuleContext.ENUM_MEMBER_NAME);\n+        return parseEnumMemberInternalRhs(metadata, identifierNode);\n+    }\n+\n+    private STNode parseEnumMemberInternalRhs(STNode metadata, STNode identifierNode) {\n+        return parseEnumMemberInternalRhs(metadata, identifierNode, peek().kind);\n+    }\n+\n+    private STNode parseEnumMemberInternalRhs(STNode metadata, STNode identifierNode, SyntaxKind nextToken) {\n+        STNode equalToken, constExprNode;\n+        switch (nextToken) {\n+            case EQUAL_TOKEN:\n+                equalToken = parseAssignOp();\n+                constExprNode = parseExpression();\n+                break;\n+            case COMMA_TOKEN:\n+            case CLOSE_BRACE_TOKEN:\n+                equalToken = STNodeFactory.createEmptyNode();\n+                constExprNode = STNodeFactory.createEmptyNode();\n+                break;\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.ENUM_MEMBER_INTERNAL_RHS, metadata,\n+                        identifierNode);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseEnumMemberInternalRhs(metadata, identifierNode, solution.tokenKind);\n+        }\n+\n+        return STNodeFactory.createEnumMemberNode(metadata, identifierNode, equalToken, constExprNode);\n+    }\n+\n+    private STNode parseEnumMemberRhs() {\n+        return parseEnumMemberRhs(peek().kind);\n+    }\n+\n+    private STNode parseEnumMemberRhs(SyntaxKind nextTokenKind) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "126f69cb7996d944324fa820a43b45288ae77074"}, "originalPosition": 170}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU0MDY3Mw==", "bodyText": "can say parseEnumMemberRhs", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23450#discussion_r429540673", "createdAt": "2020-05-23T12:13:14Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -10857,4 +10866,164 @@ private STNode parseConditionalExpression(STNode lhsExpr) {\n         STNode endExpr = parseExpression(OperatorPrecedence.ELVIS_CONDITIONAL, true, false);\n         return STNodeFactory.createConditionalExpressionNode(lhsExpr, questionMark, middleExpr, colon, endExpr);\n     }\n+\n+    /**\n+     * Parse enum declaration.\n+     * <p>\n+     * module-enum-decl :=\n+     *  metadata\n+     *  [public] enum identifier { enum-member (, enum-member)* }\n+     * enum-member := metadata identifier [= const-expr]\n+     * </p>\n+     * @param metadata\n+     * @param qualifier\n+     *\n+     * @return Parsed enum node.\n+     */\n+    private STNode parseEnumDeclaration(STNode metadata, STNode qualifier) {\n+        startContext(ParserRuleContext.MODULE_ENUM_DECLARATION);\n+        STNode enumKeywordToken = parseEnumKeyword();\n+        STNode identifier = parseIdentifier(ParserRuleContext.MODULE_ENUM_NAME);\n+        STNode openBraceToken = parseOpenBrace();\n+        STNode enumMemberList = parseEnumMemberList();\n+        STNode closeBraceToken = parseCloseBrace();\n+\n+        endContext();\n+        return STNodeFactory.createEnumDeclarationNode(metadata, qualifier, enumKeywordToken, identifier,\n+                openBraceToken, enumMemberList, closeBraceToken);\n+    }\n+\n+    /**\n+     * Parse enum member list.\n+     * <p>enum-member := metadata identifier [= const-expr]</p>\n+     *\n+     * @return enum member list node.\n+     */\n+    private STNode parseEnumMemberList() {\n+        startContext(ParserRuleContext.ENUM_MEMBER_LIST);\n+        List<STNode> enumMemberList = new ArrayList<>();\n+        STToken nextToken = peek();\n+\n+        // Report an empty enum member list\n+        if (nextToken.kind == SyntaxKind.CLOSE_BRACE_TOKEN) {\n+            this.errorHandler.reportMissingTokenError(\"enum member list cannot be empty\");\n+            return STNodeFactory.createNodeList(new ArrayList<>());\n+        }\n+\n+        // Parse first enum member, that has no leading comma\n+        STNode enumMember = parseEnumMember();\n+\n+        // Parse the remaining enum members\n+        nextToken = peek();\n+        STNode enumMemberRhs;\n+        while (nextToken.kind != SyntaxKind.CLOSE_BRACE_TOKEN) {\n+            enumMemberRhs = parseEnumMemberRhs(nextToken.kind);\n+            if (enumMemberRhs == null) {\n+                break;\n+            }\n+            enumMemberList.add(enumMember);\n+            enumMemberList.add(enumMemberRhs);\n+            enumMember = parseEnumMember();\n+            nextToken = peek();\n+        }\n+\n+        enumMemberList.add(enumMember);\n+\n+        endContext();\n+        return STNodeFactory.createNodeList(enumMemberList);\n+    }\n+\n+    /**\n+     * Parse enum member.\n+     * <p>enum-member := metadata identifier [= const-expr]</p>\n+     *\n+     * @return Parsed enum member node.\n+     */\n+    private STNode parseEnumMember() {\n+        STToken nextToken = peek();\n+        STNode metadata;\n+        switch (nextToken.kind) {\n+            case DOCUMENTATION_LINE:\n+            case AT_TOKEN:\n+                metadata = parseMetaData(nextToken.kind);\n+                break;\n+            default:\n+                metadata = STNodeFactory.createEmptyNode();\n+        }\n+\n+        STNode identifierNode = parseIdentifier(ParserRuleContext.ENUM_MEMBER_NAME);\n+        return parseEnumMemberInternalRhs(metadata, identifierNode);\n+    }\n+\n+    private STNode parseEnumMemberInternalRhs(STNode metadata, STNode identifierNode) {\n+        return parseEnumMemberInternalRhs(metadata, identifierNode, peek().kind);\n+    }\n+\n+    private STNode parseEnumMemberInternalRhs(STNode metadata, STNode identifierNode, SyntaxKind nextToken) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "126f69cb7996d944324fa820a43b45288ae77074"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU0MDcwNA==", "bodyText": "Let's have the SyntaxKind nextToken as the first param. Thats the pattern we have followed elsewhere...", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23450#discussion_r429540704", "createdAt": "2020-05-23T12:14:07Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -10857,4 +10866,164 @@ private STNode parseConditionalExpression(STNode lhsExpr) {\n         STNode endExpr = parseExpression(OperatorPrecedence.ELVIS_CONDITIONAL, true, false);\n         return STNodeFactory.createConditionalExpressionNode(lhsExpr, questionMark, middleExpr, colon, endExpr);\n     }\n+\n+    /**\n+     * Parse enum declaration.\n+     * <p>\n+     * module-enum-decl :=\n+     *  metadata\n+     *  [public] enum identifier { enum-member (, enum-member)* }\n+     * enum-member := metadata identifier [= const-expr]\n+     * </p>\n+     * @param metadata\n+     * @param qualifier\n+     *\n+     * @return Parsed enum node.\n+     */\n+    private STNode parseEnumDeclaration(STNode metadata, STNode qualifier) {\n+        startContext(ParserRuleContext.MODULE_ENUM_DECLARATION);\n+        STNode enumKeywordToken = parseEnumKeyword();\n+        STNode identifier = parseIdentifier(ParserRuleContext.MODULE_ENUM_NAME);\n+        STNode openBraceToken = parseOpenBrace();\n+        STNode enumMemberList = parseEnumMemberList();\n+        STNode closeBraceToken = parseCloseBrace();\n+\n+        endContext();\n+        return STNodeFactory.createEnumDeclarationNode(metadata, qualifier, enumKeywordToken, identifier,\n+                openBraceToken, enumMemberList, closeBraceToken);\n+    }\n+\n+    /**\n+     * Parse enum member list.\n+     * <p>enum-member := metadata identifier [= const-expr]</p>\n+     *\n+     * @return enum member list node.\n+     */\n+    private STNode parseEnumMemberList() {\n+        startContext(ParserRuleContext.ENUM_MEMBER_LIST);\n+        List<STNode> enumMemberList = new ArrayList<>();\n+        STToken nextToken = peek();\n+\n+        // Report an empty enum member list\n+        if (nextToken.kind == SyntaxKind.CLOSE_BRACE_TOKEN) {\n+            this.errorHandler.reportMissingTokenError(\"enum member list cannot be empty\");\n+            return STNodeFactory.createNodeList(new ArrayList<>());\n+        }\n+\n+        // Parse first enum member, that has no leading comma\n+        STNode enumMember = parseEnumMember();\n+\n+        // Parse the remaining enum members\n+        nextToken = peek();\n+        STNode enumMemberRhs;\n+        while (nextToken.kind != SyntaxKind.CLOSE_BRACE_TOKEN) {\n+            enumMemberRhs = parseEnumMemberRhs(nextToken.kind);\n+            if (enumMemberRhs == null) {\n+                break;\n+            }\n+            enumMemberList.add(enumMember);\n+            enumMemberList.add(enumMemberRhs);\n+            enumMember = parseEnumMember();\n+            nextToken = peek();\n+        }\n+\n+        enumMemberList.add(enumMember);\n+\n+        endContext();\n+        return STNodeFactory.createNodeList(enumMemberList);\n+    }\n+\n+    /**\n+     * Parse enum member.\n+     * <p>enum-member := metadata identifier [= const-expr]</p>\n+     *\n+     * @return Parsed enum member node.\n+     */\n+    private STNode parseEnumMember() {\n+        STToken nextToken = peek();\n+        STNode metadata;\n+        switch (nextToken.kind) {\n+            case DOCUMENTATION_LINE:\n+            case AT_TOKEN:\n+                metadata = parseMetaData(nextToken.kind);\n+                break;\n+            default:\n+                metadata = STNodeFactory.createEmptyNode();\n+        }\n+\n+        STNode identifierNode = parseIdentifier(ParserRuleContext.ENUM_MEMBER_NAME);\n+        return parseEnumMemberInternalRhs(metadata, identifierNode);\n+    }\n+\n+    private STNode parseEnumMemberInternalRhs(STNode metadata, STNode identifierNode) {\n+        return parseEnumMemberInternalRhs(metadata, identifierNode, peek().kind);\n+    }\n+\n+    private STNode parseEnumMemberInternalRhs(STNode metadata, STNode identifierNode, SyntaxKind nextToken) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU0MDY3Mw=="}, "originalCommit": {"oid": "126f69cb7996d944324fa820a43b45288ae77074"}, "originalPosition": 137}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4531, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}