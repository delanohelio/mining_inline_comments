{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEzMDQ5Nzk2", "number": 23087, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwNzo1NjozMlrOD5tTpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwNzo1ODozMFrOD5tV9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxODM3NzMyOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/codegen/JvmValueGen.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwNzo1NjozMlrOGRH3Dw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwNzo1NjozMlrOGRH3Dw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDYwNzc1OQ==", "bodyText": "remove this new line", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23087#discussion_r420607759", "createdAt": "2020-05-06T07:56:32Z", "author": {"login": "Kishanthan"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/codegen/JvmValueGen.java", "diffHunk": "@@ -568,17 +573,80 @@ private void createInstantiateMethod(ClassWriter cw, BRecordType recordType) {\n         loadType(mv, recordType);\n         mv.visitMethodInsn(INVOKESPECIAL, className, \"<init>\", String.format(\"(L%s;)V\", BTYPE), false);\n \n+\n+        BAttachedFunction initializer = ((BRecordTypeSymbol) recordType.tsymbol).initializerFunc;\n+        StringBuilder closureParamSignature = calcClosureMapSignature(initializer.type.paramTypes.size());\n+\n         // Invoke the init-function of this type.\n         mv.visitVarInsn(ALOAD, 1);\n         mv.visitInsn(SWAP);\n-        mv.visitMethodInsn(INVOKESTATIC, className, \"$init\",\n-                String.format(\"(L%s;L%s;)V\", STRAND, MAP_VALUE), false);\n \n+\n+        // Invoke the init-functions of referenced types. This is done to initialize the\n+        // defualt values of the fields coming from the referenced types.\n+        for (BType typeRef : typeDef.referencedTypes) {\n+            if (typeRef.tag == TypeTags.RECORD) {\n+                String refTypeClassName = getTypeValueClassName(typeRef.tsymbol.pkgID, toNameString(typeRef));\n+                mv.visitInsn(DUP2);\n+                mv.visitMethodInsn(INVOKESTATIC, refTypeClassName, \"$init\",\n+                                   String.format(\"(L%s;L%s;)V\", STRAND, MAP_VALUE), false);\n+            }\n+        }\n+\n+\n+        mv.visitVarInsn(ALOAD, 0);\n+        mv.visitFieldInsn(GETFIELD, TYPEDESC_VALUE_IMPL, TYPEDESC_VALUE_IMPL_CLOSURES,\n+                          String.format(\"[L%s;\", MAP_VALUE));\n+\n+        for (int i = 0; i < initializer.type.paramTypes.size(); i++) {\n+            mv.visitInsn(DUP);\n+            mv.visitIntInsn(BIPUSH, i);\n+            mv.visitInsn(AALOAD);\n+            mv.visitInsn(SWAP);\n+\n+            mv.visitInsn(ICONST_1);\n+            mv.visitInsn(SWAP);\n+        }\n+        mv.visitInsn(POP);\n+\n+\n+        // Invoke the init-function of this type.\n+        String initFuncName;\n+        String valueClassName;\n+        List<BIRFunction> attachedFuncs = typeDef.attachedFuncs;\n+\n+        // Attached functions are empty for type-labeling. In such cases, call the __init() of\n+        // the original type value;\n+        if (attachedFuncs.size() != 0) {\n+            initFuncName = attachedFuncs.get(0).name.value;\n+            valueClassName = className;\n+        } else {\n+            // record type is the original record-type of this type-label\n+            valueClassName = getTypeValueClassName(recordType.tsymbol.pkgID, toNameString(recordType));\n+            initFuncName = cleanupFunctionName(recordType.name + \"__init_\");\n+        }\n+\n+        mv.visitMethodInsn(INVOKESTATIC, valueClassName, initFuncName,\n+                           String.format(\"(L%s;L%s;%s)L%s;\", STRAND, MAP_VALUE, closureParamSignature, OBJECT),\n+                           false);\n+\n+        mv.visitInsn(POP);\n         mv.visitInsn(ARETURN);\n         mv.visitMaxs(0, 0);\n         mv.visitEnd();\n     }\n \n+    private StringBuilder calcClosureMapSignature(int size) {\n+        StringBuilder closureParamSignature = new StringBuilder();\n+        for (int i = 0; i < size; i++) {\n+            closureParamSignature.append('L');\n+            closureParamSignature.append(MAP_VALUE);\n+            closureParamSignature.append(\";Z\");\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56248cd7fe8bdb2369d6352ffe5bd03f7c2183cf"}, "originalPosition": 120}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxODM4MzI3OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/ClosureDesugar.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwNzo1ODozMFrOGRH62g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwODowNTozNFrOGRIIjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDYwODczMA==", "bodyText": "commented out sections? do we need them?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23087#discussion_r420608730", "createdAt": "2020-05-06T07:58:30Z", "author": {"login": "Kishanthan"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/ClosureDesugar.java", "diffHunk": "@@ -1245,6 +1249,13 @@ public void visit(BLangRecordLiteral.BLangMapLiteral mapLiteral) {\n \n     @Override\n     public void visit(BLangRecordLiteral.BLangStructLiteral structLiteral) {\n+        SymbolEnv symbolEnv = env.createClone();\n+//        bLangLambdaFunction.capturedClosureEnv = symbolEnv;\n+        BLangFunction enclInvokable = (BLangFunction) symbolEnv.enclInvokable;\n+        // Save param closure map of the encl invokable.\n+//        bLangLambdaFunction.paramMapSymbolsOfEnclInvokable = enclInvokable.paramClosureMap;\n+//        boolean isWorker = bLangLambdaFunction.function.flagSet.contains(Flag.WORKER);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56248cd7fe8bdb2369d6352ffe5bd03f7c2183cf"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDYxMjIzNw==", "bodyText": "no, my bad, I though I removed before committing. will remove.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23087#discussion_r420612237", "createdAt": "2020-05-06T08:05:34Z", "author": {"login": "manuranga"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/ClosureDesugar.java", "diffHunk": "@@ -1245,6 +1249,13 @@ public void visit(BLangRecordLiteral.BLangMapLiteral mapLiteral) {\n \n     @Override\n     public void visit(BLangRecordLiteral.BLangStructLiteral structLiteral) {\n+        SymbolEnv symbolEnv = env.createClone();\n+//        bLangLambdaFunction.capturedClosureEnv = symbolEnv;\n+        BLangFunction enclInvokable = (BLangFunction) symbolEnv.enclInvokable;\n+        // Save param closure map of the encl invokable.\n+//        bLangLambdaFunction.paramMapSymbolsOfEnclInvokable = enclInvokable.paramClosureMap;\n+//        boolean isWorker = bLangLambdaFunction.function.flagSet.contains(Flag.WORKER);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDYwODczMA=="}, "originalCommit": {"oid": "56248cd7fe8bdb2369d6352ffe5bd03f7c2183cf"}, "originalPosition": 67}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3702, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}