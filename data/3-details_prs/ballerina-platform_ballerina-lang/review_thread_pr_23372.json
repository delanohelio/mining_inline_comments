{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIwMTA5OTcx", "number": 23372, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxMDoxMzoxMVrOD-Jk0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxMDoxMzoxMVrOD-Jk0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NDk1MTg2OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxMDoxMzoxMVrOGYEv1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQwNjo1Mjo1N1rOGYoNYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzg5Njc4OQ==", "bodyText": "Assuming qualified-identifier gets the higher precedence a ? b:c : d passes as anticipated.\nBut, If we consider simple a ? b : c, it cannot be parsed as b:c is parsed as a qualified-identifier.\nThat's problem I'm facing now", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23372#discussion_r427896789", "createdAt": "2020-05-20T10:13:11Z", "author": {"login": "lochana-chathura"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -9077,4 +9097,45 @@ private STNode parseIntersectionTypeDescriptor(STNode leftTypeDesc, ParserRuleCo\n         STNode rightTypeDesc = parseTypeDescriptor(context);\n         return STNodeFactory.createIntersectionTypeDescriptorNode(leftTypeDesc, bitwiseAndToken, rightTypeDesc);\n     }\n+\n+    /**\n+     * Parse optional field access expression .\n+     *\n+     * @param lhsExpr Preceding expression of the optional field access\n+     * @return <code>optional-field-access-expr</code>.\n+     */\n+    private STNode parseOptionalFieldAccessExpression(STNode lhsExpr) {\n+        STNode optionalFieldAccessToken = parseOptionalFieldAccessToken();\n+        STNode fieldName = parseIdentifier(ParserRuleContext.FIELD_OR_FUNC_NAME);\n+        return STNodeFactory.createOptionalFieldAccessExpressionNode(lhsExpr, optionalFieldAccessToken, fieldName);\n+    }\n+\n+    /**\n+     * Parse optional-field-access-token.\n+     *\n+     * @return parsed node\n+     */\n+    private STNode parseOptionalFieldAccessToken() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.OPTIONAL_CHAINING_TOKEN) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(token, ParserRuleContext.OPTIONAL_CHAINING_TOKEN);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse conditional expression.\n+     *\n+     * @param lhsExpr Preceding expression of the question mark\n+     * @return <code>conditional-expr</code>.\n+     */\n+    private STNode parseConditionalExpression(STNode lhsExpr) {\n+        STNode questionMark = parseQuestionMark();\n+        STNode middleExpr = parseExpression(OperatorPrecedence.ELVIS_CONDITIONAL, true, false);\n+        STNode colon = parseColon();\n+        STNode endExpr = parseExpression(OperatorPrecedence.ELVIS_CONDITIONAL, true, false);\n+        return STNodeFactory.createConditionalExpressionNode(lhsExpr, questionMark, middleExpr, colon, endExpr);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1bd31d47993d09d69796a2e83840f780007c16b7"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzkwODIzNw==", "bodyText": "I see. May be we would have to special case that. i.e: in expr1 ? expr2 : expr3 if colon is missing, we check whether expr2 is a qualified identifier or not. If yes, we can split it back and treat it as the expr2:expr3. Not the cleanest way, but that would work i think.\nWDYT?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23372#discussion_r427908237", "createdAt": "2020-05-20T10:34:21Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -9077,4 +9097,45 @@ private STNode parseIntersectionTypeDescriptor(STNode leftTypeDesc, ParserRuleCo\n         STNode rightTypeDesc = parseTypeDescriptor(context);\n         return STNodeFactory.createIntersectionTypeDescriptorNode(leftTypeDesc, bitwiseAndToken, rightTypeDesc);\n     }\n+\n+    /**\n+     * Parse optional field access expression .\n+     *\n+     * @param lhsExpr Preceding expression of the optional field access\n+     * @return <code>optional-field-access-expr</code>.\n+     */\n+    private STNode parseOptionalFieldAccessExpression(STNode lhsExpr) {\n+        STNode optionalFieldAccessToken = parseOptionalFieldAccessToken();\n+        STNode fieldName = parseIdentifier(ParserRuleContext.FIELD_OR_FUNC_NAME);\n+        return STNodeFactory.createOptionalFieldAccessExpressionNode(lhsExpr, optionalFieldAccessToken, fieldName);\n+    }\n+\n+    /**\n+     * Parse optional-field-access-token.\n+     *\n+     * @return parsed node\n+     */\n+    private STNode parseOptionalFieldAccessToken() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.OPTIONAL_CHAINING_TOKEN) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(token, ParserRuleContext.OPTIONAL_CHAINING_TOKEN);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse conditional expression.\n+     *\n+     * @param lhsExpr Preceding expression of the question mark\n+     * @return <code>conditional-expr</code>.\n+     */\n+    private STNode parseConditionalExpression(STNode lhsExpr) {\n+        STNode questionMark = parseQuestionMark();\n+        STNode middleExpr = parseExpression(OperatorPrecedence.ELVIS_CONDITIONAL, true, false);\n+        STNode colon = parseColon();\n+        STNode endExpr = parseExpression(OperatorPrecedence.ELVIS_CONDITIONAL, true, false);\n+        return STNodeFactory.createConditionalExpressionNode(lhsExpr, questionMark, middleExpr, colon, endExpr);\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzg5Njc4OQ=="}, "originalCommit": {"oid": "1bd31d47993d09d69796a2e83840f780007c16b7"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI1MDc4Nw==", "bodyText": "Well, expr2 is not always a qualified identifier, when we have this problem.\nFor example in a ? b : c+d, we have a binary expression.\nSo depend on the situation we will have to check their children or children of children or .... for a qualified identifier.\nSometimes there cloud be more than one qualified identifier. Splitting and re-parsing is not possible in such complex cases.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23372#discussion_r428250787", "createdAt": "2020-05-20T19:15:59Z", "author": {"login": "lochana-chathura"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -9077,4 +9097,45 @@ private STNode parseIntersectionTypeDescriptor(STNode leftTypeDesc, ParserRuleCo\n         STNode rightTypeDesc = parseTypeDescriptor(context);\n         return STNodeFactory.createIntersectionTypeDescriptorNode(leftTypeDesc, bitwiseAndToken, rightTypeDesc);\n     }\n+\n+    /**\n+     * Parse optional field access expression .\n+     *\n+     * @param lhsExpr Preceding expression of the optional field access\n+     * @return <code>optional-field-access-expr</code>.\n+     */\n+    private STNode parseOptionalFieldAccessExpression(STNode lhsExpr) {\n+        STNode optionalFieldAccessToken = parseOptionalFieldAccessToken();\n+        STNode fieldName = parseIdentifier(ParserRuleContext.FIELD_OR_FUNC_NAME);\n+        return STNodeFactory.createOptionalFieldAccessExpressionNode(lhsExpr, optionalFieldAccessToken, fieldName);\n+    }\n+\n+    /**\n+     * Parse optional-field-access-token.\n+     *\n+     * @return parsed node\n+     */\n+    private STNode parseOptionalFieldAccessToken() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.OPTIONAL_CHAINING_TOKEN) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(token, ParserRuleContext.OPTIONAL_CHAINING_TOKEN);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse conditional expression.\n+     *\n+     * @param lhsExpr Preceding expression of the question mark\n+     * @return <code>conditional-expr</code>.\n+     */\n+    private STNode parseConditionalExpression(STNode lhsExpr) {\n+        STNode questionMark = parseQuestionMark();\n+        STNode middleExpr = parseExpression(OperatorPrecedence.ELVIS_CONDITIONAL, true, false);\n+        STNode colon = parseColon();\n+        STNode endExpr = parseExpression(OperatorPrecedence.ELVIS_CONDITIONAL, true, false);\n+        return STNodeFactory.createConditionalExpressionNode(lhsExpr, questionMark, middleExpr, colon, endExpr);\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzg5Njc4OQ=="}, "originalCommit": {"oid": "1bd31d47993d09d69796a2e83840f780007c16b7"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI1MjQxNw==", "bodyText": "Since we have an LL(k) parser I was thinking something like this.\nWhen parsing a qualified identifier, we can check whether there's a spare colon ahead until lower precedence operator or end of expression token is reached. If there's no spare colon ahead, we will not parse the qualified identifier, instead only capture the identifier.\nWe will have to use a flag to identify whether we are in a conditional-expr when doing the above thing.\nAnother problem in this approach is we could have mapping-constructors when checking over the tokens ahead. So we have to make sure that we are looking for a spare colon which is not surrounded by {  }  tokens.\nWDYT?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23372#discussion_r428252417", "createdAt": "2020-05-20T19:19:02Z", "author": {"login": "lochana-chathura"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -9077,4 +9097,45 @@ private STNode parseIntersectionTypeDescriptor(STNode leftTypeDesc, ParserRuleCo\n         STNode rightTypeDesc = parseTypeDescriptor(context);\n         return STNodeFactory.createIntersectionTypeDescriptorNode(leftTypeDesc, bitwiseAndToken, rightTypeDesc);\n     }\n+\n+    /**\n+     * Parse optional field access expression .\n+     *\n+     * @param lhsExpr Preceding expression of the optional field access\n+     * @return <code>optional-field-access-expr</code>.\n+     */\n+    private STNode parseOptionalFieldAccessExpression(STNode lhsExpr) {\n+        STNode optionalFieldAccessToken = parseOptionalFieldAccessToken();\n+        STNode fieldName = parseIdentifier(ParserRuleContext.FIELD_OR_FUNC_NAME);\n+        return STNodeFactory.createOptionalFieldAccessExpressionNode(lhsExpr, optionalFieldAccessToken, fieldName);\n+    }\n+\n+    /**\n+     * Parse optional-field-access-token.\n+     *\n+     * @return parsed node\n+     */\n+    private STNode parseOptionalFieldAccessToken() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.OPTIONAL_CHAINING_TOKEN) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(token, ParserRuleContext.OPTIONAL_CHAINING_TOKEN);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse conditional expression.\n+     *\n+     * @param lhsExpr Preceding expression of the question mark\n+     * @return <code>conditional-expr</code>.\n+     */\n+    private STNode parseConditionalExpression(STNode lhsExpr) {\n+        STNode questionMark = parseQuestionMark();\n+        STNode middleExpr = parseExpression(OperatorPrecedence.ELVIS_CONDITIONAL, true, false);\n+        STNode colon = parseColon();\n+        STNode endExpr = parseExpression(OperatorPrecedence.ELVIS_CONDITIONAL, true, false);\n+        return STNodeFactory.createConditionalExpressionNode(lhsExpr, questionMark, middleExpr, colon, endExpr);\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzg5Njc4OQ=="}, "originalCommit": {"oid": "1bd31d47993d09d69796a2e83840f780007c16b7"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ3NjExNA==", "bodyText": "Ok.\nI think we have to treat a ? b : c as an invalid code. Because according to ballerina-platform/ballerina-spec#523, b:c is a var ref.\nIf someone want to make it working, they have to use parenthesis like:  a ? (b) : c.\nThat will simplify many things.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23372#discussion_r428476114", "createdAt": "2020-05-21T06:48:04Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -9077,4 +9097,45 @@ private STNode parseIntersectionTypeDescriptor(STNode leftTypeDesc, ParserRuleCo\n         STNode rightTypeDesc = parseTypeDescriptor(context);\n         return STNodeFactory.createIntersectionTypeDescriptorNode(leftTypeDesc, bitwiseAndToken, rightTypeDesc);\n     }\n+\n+    /**\n+     * Parse optional field access expression .\n+     *\n+     * @param lhsExpr Preceding expression of the optional field access\n+     * @return <code>optional-field-access-expr</code>.\n+     */\n+    private STNode parseOptionalFieldAccessExpression(STNode lhsExpr) {\n+        STNode optionalFieldAccessToken = parseOptionalFieldAccessToken();\n+        STNode fieldName = parseIdentifier(ParserRuleContext.FIELD_OR_FUNC_NAME);\n+        return STNodeFactory.createOptionalFieldAccessExpressionNode(lhsExpr, optionalFieldAccessToken, fieldName);\n+    }\n+\n+    /**\n+     * Parse optional-field-access-token.\n+     *\n+     * @return parsed node\n+     */\n+    private STNode parseOptionalFieldAccessToken() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.OPTIONAL_CHAINING_TOKEN) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(token, ParserRuleContext.OPTIONAL_CHAINING_TOKEN);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse conditional expression.\n+     *\n+     * @param lhsExpr Preceding expression of the question mark\n+     * @return <code>conditional-expr</code>.\n+     */\n+    private STNode parseConditionalExpression(STNode lhsExpr) {\n+        STNode questionMark = parseQuestionMark();\n+        STNode middleExpr = parseExpression(OperatorPrecedence.ELVIS_CONDITIONAL, true, false);\n+        STNode colon = parseColon();\n+        STNode endExpr = parseExpression(OperatorPrecedence.ELVIS_CONDITIONAL, true, false);\n+        return STNodeFactory.createConditionalExpressionNode(lhsExpr, questionMark, middleExpr, colon, endExpr);\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzg5Njc4OQ=="}, "originalCommit": {"oid": "1bd31d47993d09d69796a2e83840f780007c16b7"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ3Nzc5Mg==", "bodyText": "Ok great. Then no trouble at all.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23372#discussion_r428477792", "createdAt": "2020-05-21T06:52:57Z", "author": {"login": "lochana-chathura"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -9077,4 +9097,45 @@ private STNode parseIntersectionTypeDescriptor(STNode leftTypeDesc, ParserRuleCo\n         STNode rightTypeDesc = parseTypeDescriptor(context);\n         return STNodeFactory.createIntersectionTypeDescriptorNode(leftTypeDesc, bitwiseAndToken, rightTypeDesc);\n     }\n+\n+    /**\n+     * Parse optional field access expression .\n+     *\n+     * @param lhsExpr Preceding expression of the optional field access\n+     * @return <code>optional-field-access-expr</code>.\n+     */\n+    private STNode parseOptionalFieldAccessExpression(STNode lhsExpr) {\n+        STNode optionalFieldAccessToken = parseOptionalFieldAccessToken();\n+        STNode fieldName = parseIdentifier(ParserRuleContext.FIELD_OR_FUNC_NAME);\n+        return STNodeFactory.createOptionalFieldAccessExpressionNode(lhsExpr, optionalFieldAccessToken, fieldName);\n+    }\n+\n+    /**\n+     * Parse optional-field-access-token.\n+     *\n+     * @return parsed node\n+     */\n+    private STNode parseOptionalFieldAccessToken() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.OPTIONAL_CHAINING_TOKEN) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(token, ParserRuleContext.OPTIONAL_CHAINING_TOKEN);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse conditional expression.\n+     *\n+     * @param lhsExpr Preceding expression of the question mark\n+     * @return <code>conditional-expr</code>.\n+     */\n+    private STNode parseConditionalExpression(STNode lhsExpr) {\n+        STNode questionMark = parseQuestionMark();\n+        STNode middleExpr = parseExpression(OperatorPrecedence.ELVIS_CONDITIONAL, true, false);\n+        STNode colon = parseColon();\n+        STNode endExpr = parseExpression(OperatorPrecedence.ELVIS_CONDITIONAL, true, false);\n+        return STNodeFactory.createConditionalExpressionNode(lhsExpr, questionMark, middleExpr, colon, endExpr);\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzg5Njc4OQ=="}, "originalCommit": {"oid": "1bd31d47993d09d69796a2e83840f780007c16b7"}, "originalPosition": 113}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3676, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}