{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc3Nzg4MjUx", "number": 25564, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwOToxNjoyNVrOEgTw_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QxMDo1MTo0MlrOEg42sw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMzEzNzI0OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwOToxNjoyNVrOHNGOeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwOToyODozM1rOHNGnbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ5NTU0Ng==", "bodyText": "do we need the similar validation for object members too (i.e: if isObjectMember is true) ?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25564#discussion_r483495546", "createdAt": "2020-09-04T09:16:25Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -992,11 +980,44 @@ private STNode parseReturnTypeDescRhs(STNode metadata, STNode functionKeyword, S\n         funcSignature = validateAndGetFuncParams((STFunctionSignatureNode) funcSignature);\n \n         STNode funcDef =\n-                createFuncDefOrMethodDecl(metadata, functionKeyword, isObjectMethod, name, funcSignature, qualifiers);\n+                createFuncDefOrMethodDecl(metadata, functionKeyword, isObjectMember, name, funcSignature, qualifiers);\n         endContext();\n         return funcDef;\n     }\n \n+    private STNode parseVarDeclWithFunctionType(STNode typeDesc, boolean isObjectMember, STNode qualifiers,\n+                                                STNode metadata) {\n+        STNodeList qualifierList = (STNodeList) qualifiers;\n+        if (isObjectMember) {\n+            // public qualifier allowed in object field.\n+            STNode readonlyQualifier = STNodeFactory.createEmptyNode();\n+            STNode fieldName = parseVariableName();\n+            if (qualifierList.isEmpty()) {\n+                return parseObjectFieldRhs(metadata, STNodeFactory.createEmptyNode(), readonlyQualifier,\n+                        typeDesc, fieldName);\n+            } else {\n+                return parseObjectFieldRhs(metadata, qualifiers.childInBucket(0), readonlyQualifier, typeDesc,\n+                        fieldName);\n+            }\n+        }\n+\n+        STNode finalKeyword = STNodeFactory.createEmptyNode();\n+        // Only the final keyword is allowed as a qualifier\n+        for (int position = 0; position < qualifierList.size(); position++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e95695a4731a49fac4cc1354442192f06b8eae2"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzUwMTkzMg==", "bodyText": "+1 will update.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25564#discussion_r483501932", "createdAt": "2020-09-04T09:28:33Z", "author": {"login": "rdulmina"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -992,11 +980,44 @@ private STNode parseReturnTypeDescRhs(STNode metadata, STNode functionKeyword, S\n         funcSignature = validateAndGetFuncParams((STFunctionSignatureNode) funcSignature);\n \n         STNode funcDef =\n-                createFuncDefOrMethodDecl(metadata, functionKeyword, isObjectMethod, name, funcSignature, qualifiers);\n+                createFuncDefOrMethodDecl(metadata, functionKeyword, isObjectMember, name, funcSignature, qualifiers);\n         endContext();\n         return funcDef;\n     }\n \n+    private STNode parseVarDeclWithFunctionType(STNode typeDesc, boolean isObjectMember, STNode qualifiers,\n+                                                STNode metadata) {\n+        STNodeList qualifierList = (STNodeList) qualifiers;\n+        if (isObjectMember) {\n+            // public qualifier allowed in object field.\n+            STNode readonlyQualifier = STNodeFactory.createEmptyNode();\n+            STNode fieldName = parseVariableName();\n+            if (qualifierList.isEmpty()) {\n+                return parseObjectFieldRhs(metadata, STNodeFactory.createEmptyNode(), readonlyQualifier,\n+                        typeDesc, fieldName);\n+            } else {\n+                return parseObjectFieldRhs(metadata, qualifiers.childInBucket(0), readonlyQualifier, typeDesc,\n+                        fieldName);\n+            }\n+        }\n+\n+        STNode finalKeyword = STNodeFactory.createEmptyNode();\n+        // Only the final keyword is allowed as a qualifier\n+        for (int position = 0; position < qualifierList.size(); position++) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ5NTU0Ng=="}, "originalCommit": {"oid": "8e95695a4731a49fac4cc1354442192f06b8eae2"}, "originalPosition": 147}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyOTE3NjE5OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/resources/syntax_diagnostic_message.properties", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QxMDo0MToxNFrOHN6WdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QxMDo0MToxNFrOHN6WdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDM0OTU1Nw==", "bodyText": "I think error msg like this:  ''{0}'' qualifier not allowed here would be better.\nIn the class-change branch it is already using that way for error.qualifier.not.allowed", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25564#discussion_r484349557", "createdAt": "2020-09-07T10:41:14Z", "author": {"login": "lochana-chathura"}, "path": "compiler/ballerina-parser/src/main/resources/syntax_diagnostic_message.properties", "diffHunk": "@@ -202,6 +215,8 @@ error.import.declaration.after.other.declarations=import declaration after other\n error.annotations.attached.to.expression=annotations attached to expression\n error.invalid.expression.in.start.action=invalid expression in start action\n error.same.object.type.qualifier=same object type qualifier\n+error.duplicate.qualifier=duplicate qualifier\n+error.qualifier.not.allowed=qualifier not allowed", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f504a777e112145668800b1146739f3bfe3a2569"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyOTE3OTAwOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/resources/syntax_diagnostic_message.properties", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QxMDo0MjowNlrOHN6YGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QxMTowNDowOVrOHN7D9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDM0OTk3Nw==", "bodyText": "duplicate ''{0}'' qualifier would be better", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25564#discussion_r484349977", "createdAt": "2020-09-07T10:42:06Z", "author": {"login": "lochana-chathura"}, "path": "compiler/ballerina-parser/src/main/resources/syntax_diagnostic_message.properties", "diffHunk": "@@ -202,6 +215,8 @@ error.import.declaration.after.other.declarations=import declaration after other\n error.annotations.attached.to.expression=annotations attached to expression\n error.invalid.expression.in.start.action=invalid expression in start action\n error.same.object.type.qualifier=same object type qualifier\n+error.duplicate.qualifier=duplicate qualifier", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f504a777e112145668800b1146739f3bfe3a2569"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDM2MTIwNQ==", "bodyText": "thanx will change", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25564#discussion_r484361205", "createdAt": "2020-09-07T11:04:09Z", "author": {"login": "rdulmina"}, "path": "compiler/ballerina-parser/src/main/resources/syntax_diagnostic_message.properties", "diffHunk": "@@ -202,6 +215,8 @@ error.import.declaration.after.other.declarations=import declaration after other\n error.annotations.attached.to.expression=annotations attached to expression\n error.invalid.expression.in.start.action=invalid expression in start action\n error.same.object.type.qualifier=same object type qualifier\n+error.duplicate.qualifier=duplicate qualifier", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDM0OTk3Nw=="}, "originalCommit": {"oid": "f504a777e112145668800b1146739f3bfe3a2569"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyOTE4NjMxOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QxMDo0NDoxMFrOHN6cew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QxMDo0NDoxMFrOHN6cew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDM1MTA5OQ==", "bodyText": "Related above comment.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                typeDesc = SyntaxErrors.cloneWithLeadingInvalidNodeMinutiae(typeDesc, qualifier,\n          \n          \n            \n                                        DiagnosticErrorCode.ERROR_QUALIFIER_NOT_ALLOWED);\n          \n          \n            \n                                typeDesc = SyntaxErrors.cloneWithLeadingInvalidNodeMinutiae(typeDesc, qualifier,\n          \n          \n            \n                                        DiagnosticErrorCode.ERROR_QUALIFIER_NOT_ALLOWED, ((STToken) qualifier).text()));", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25564#discussion_r484351099", "createdAt": "2020-09-07T10:44:10Z", "author": {"login": "lochana-chathura"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -992,11 +980,42 @@ private STNode parseReturnTypeDescRhs(STNode metadata, STNode functionKeyword, S\n         funcSignature = validateAndGetFuncParams((STFunctionSignatureNode) funcSignature);\n \n         STNode funcDef =\n-                createFuncDefOrMethodDecl(metadata, functionKeyword, isObjectMethod, name, funcSignature, qualifiers);\n+                createFuncDefOrMethodDecl(metadata, functionKeyword, isObjectMember, name, funcSignature, qualifiers);\n         endContext();\n         return funcDef;\n     }\n \n+    private STNode parseVarDeclWithFunctionType(STNode typeDesc, boolean isObjectMember, STNode qualifiers,\n+                                                STNode metadata) {\n+        STNodeList qualifierList = (STNodeList) qualifiers;\n+        STNode visibilityQualifier = STNodeFactory.createEmptyNode();\n+        // qualifiers are not allowed except for object filed\n+        for (int position = 0; position < qualifierList.size(); position++) {\n+            STNode qualifier = qualifierList.get(position);\n+            if (isObjectMember) {\n+                // public or private qualifier allowed in object field.\n+                if (qualifier.kind == SyntaxKind.PUBLIC_KEYWORD || qualifier.kind == SyntaxKind.PRIVATE_KEYWORD) {\n+                    visibilityQualifier = qualifier;\n+                } else {\n+                    // if remote or transactional qualifier present\n+                    typeDesc = SyntaxErrors.cloneWithLeadingInvalidNodeMinutiae(typeDesc, qualifier,\n+                            DiagnosticErrorCode.ERROR_QUALIFIER_NOT_ALLOWED);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f504a777e112145668800b1146739f3bfe3a2569"}, "originalPosition": 143}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyOTIxMDczOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QxMDo1MDo0MVrOHN6qsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QxMToxMTo1MFrOHN7SGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDM1NDczNg==", "bodyText": "I think we can merge this checks and avoid nested if clause.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25564#discussion_r484354736", "createdAt": "2020-09-07T10:50:41Z", "author": {"login": "lochana-chathura"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -992,11 +980,42 @@ private STNode parseReturnTypeDescRhs(STNode metadata, STNode functionKeyword, S\n         funcSignature = validateAndGetFuncParams((STFunctionSignatureNode) funcSignature);\n \n         STNode funcDef =\n-                createFuncDefOrMethodDecl(metadata, functionKeyword, isObjectMethod, name, funcSignature, qualifiers);\n+                createFuncDefOrMethodDecl(metadata, functionKeyword, isObjectMember, name, funcSignature, qualifiers);\n         endContext();\n         return funcDef;\n     }\n \n+    private STNode parseVarDeclWithFunctionType(STNode typeDesc, boolean isObjectMember, STNode qualifiers,\n+                                                STNode metadata) {\n+        STNodeList qualifierList = (STNodeList) qualifiers;\n+        STNode visibilityQualifier = STNodeFactory.createEmptyNode();\n+        // qualifiers are not allowed except for object filed\n+        for (int position = 0; position < qualifierList.size(); position++) {\n+            STNode qualifier = qualifierList.get(position);\n+            if (isObjectMember) {\n+                // public or private qualifier allowed in object field.\n+                if (qualifier.kind == SyntaxKind.PUBLIC_KEYWORD || qualifier.kind == SyntaxKind.PRIVATE_KEYWORD) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f504a777e112145668800b1146739f3bfe3a2569"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDM2NDgyNg==", "bodyText": "changed", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25564#discussion_r484364826", "createdAt": "2020-09-07T11:11:50Z", "author": {"login": "rdulmina"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -992,11 +980,42 @@ private STNode parseReturnTypeDescRhs(STNode metadata, STNode functionKeyword, S\n         funcSignature = validateAndGetFuncParams((STFunctionSignatureNode) funcSignature);\n \n         STNode funcDef =\n-                createFuncDefOrMethodDecl(metadata, functionKeyword, isObjectMethod, name, funcSignature, qualifiers);\n+                createFuncDefOrMethodDecl(metadata, functionKeyword, isObjectMember, name, funcSignature, qualifiers);\n         endContext();\n         return funcDef;\n     }\n \n+    private STNode parseVarDeclWithFunctionType(STNode typeDesc, boolean isObjectMember, STNode qualifiers,\n+                                                STNode metadata) {\n+        STNodeList qualifierList = (STNodeList) qualifiers;\n+        STNode visibilityQualifier = STNodeFactory.createEmptyNode();\n+        // qualifiers are not allowed except for object filed\n+        for (int position = 0; position < qualifierList.size(); position++) {\n+            STNode qualifier = qualifierList.get(position);\n+            if (isObjectMember) {\n+                // public or private qualifier allowed in object field.\n+                if (qualifier.kind == SyntaxKind.PUBLIC_KEYWORD || qualifier.kind == SyntaxKind.PRIVATE_KEYWORD) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDM1NDczNg=="}, "originalCommit": {"oid": "f504a777e112145668800b1146739f3bfe3a2569"}, "originalPosition": 138}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyOTIxMzk1OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QxMDo1MTo0MlrOHN6ssQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QxMDo1MTo0MlrOHN6ssQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDM1NTI0OQ==", "bodyText": "new lines at top and bottom would be cleaner", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25564#discussion_r484355249", "createdAt": "2020-09-07T10:51:42Z", "author": {"login": "lochana-chathura"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -992,11 +980,42 @@ private STNode parseReturnTypeDescRhs(STNode metadata, STNode functionKeyword, S\n         funcSignature = validateAndGetFuncParams((STFunctionSignatureNode) funcSignature);\n \n         STNode funcDef =\n-                createFuncDefOrMethodDecl(metadata, functionKeyword, isObjectMethod, name, funcSignature, qualifiers);\n+                createFuncDefOrMethodDecl(metadata, functionKeyword, isObjectMember, name, funcSignature, qualifiers);\n         endContext();\n         return funcDef;\n     }\n \n+    private STNode parseVarDeclWithFunctionType(STNode typeDesc, boolean isObjectMember, STNode qualifiers,\n+                                                STNode metadata) {\n+        STNodeList qualifierList = (STNodeList) qualifiers;\n+        STNode visibilityQualifier = STNodeFactory.createEmptyNode();\n+        // qualifiers are not allowed except for object filed\n+        for (int position = 0; position < qualifierList.size(); position++) {\n+            STNode qualifier = qualifierList.get(position);\n+            if (isObjectMember) {\n+                // public or private qualifier allowed in object field.\n+                if (qualifier.kind == SyntaxKind.PUBLIC_KEYWORD || qualifier.kind == SyntaxKind.PRIVATE_KEYWORD) {\n+                    visibilityQualifier = qualifier;\n+                } else {\n+                    // if remote or transactional qualifier present\n+                    typeDesc = SyntaxErrors.cloneWithLeadingInvalidNodeMinutiae(typeDesc, qualifier,\n+                            DiagnosticErrorCode.ERROR_QUALIFIER_NOT_ALLOWED);\n+                }\n+            } else {\n+                typeDesc = SyntaxErrors.cloneWithLeadingInvalidNodeMinutiae(typeDesc, qualifier,\n+                        DiagnosticErrorCode.ERROR_QUALIFIER_NOT_ALLOWED);\n+            }\n+        }\n+        if (isObjectMember) {\n+            STNode readonlyQualifier = STNodeFactory.createEmptyNode();\n+            STNode fieldName = parseVariableName();\n+            return parseObjectFieldRhs(metadata, visibilityQualifier, readonlyQualifier, typeDesc, fieldName);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f504a777e112145668800b1146739f3bfe3a2569"}, "originalPosition": 154}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 166, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}