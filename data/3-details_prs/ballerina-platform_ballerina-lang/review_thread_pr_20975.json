{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzczNTExNDc0", "number": 20975, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QwODoxMDo0N1rODfc1wg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QwODoxNzoyMFrODfc8Ew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0MzA0OTYyOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/QueryDesugar.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QwODoxMDo0OFrOFpKRyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxMjowMToyOFrOFpRPew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODcwNDMyOA==", "bodyText": "Shall we replace this with a simple array:push function?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20975#discussion_r378704328", "createdAt": "2020-02-13T08:10:48Z", "author": {"login": "gimantha"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/QueryDesugar.java", "diffHunk": "@@ -0,0 +1,250 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.wso2.ballerinalang.compiler.desugar;\n+\n+import org.ballerinalang.model.TreeBuilder;\n+import org.wso2.ballerinalang.compiler.parser.BLangAnonymousModelHelper;\n+import org.wso2.ballerinalang.compiler.semantics.analyzer.SymbolEnter;\n+import org.wso2.ballerinalang.compiler.semantics.analyzer.SymbolResolver;\n+import org.wso2.ballerinalang.compiler.semantics.analyzer.Types;\n+import org.wso2.ballerinalang.compiler.semantics.model.SymbolEnv;\n+import org.wso2.ballerinalang.compiler.semantics.model.SymbolTable;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BInvokableSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BVarSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BArrayType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BType;\n+import org.wso2.ballerinalang.compiler.tree.BLangNodeVisitor;\n+import org.wso2.ballerinalang.compiler.tree.BLangSimpleVariable;\n+import org.wso2.ballerinalang.compiler.tree.clauses.BLangDoClause;\n+import org.wso2.ballerinalang.compiler.tree.clauses.BLangFromClause;\n+import org.wso2.ballerinalang.compiler.tree.clauses.BLangSelectClause;\n+import org.wso2.ballerinalang.compiler.tree.clauses.BLangWhereClause;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangIndexBasedAccess;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangInvocation;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangListConstructorExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangQueryExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangSimpleVarRef;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangStatementExpression;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangAssignment;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangBlockStmt;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangForeach;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangIf;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangQueryAction;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangSimpleVariableDef;\n+import org.wso2.ballerinalang.compiler.util.CompilerContext;\n+import org.wso2.ballerinalang.compiler.util.Name;\n+import org.wso2.ballerinalang.compiler.util.Names;\n+import org.wso2.ballerinalang.compiler.util.diagnotic.BLangDiagnosticLog;\n+import org.wso2.ballerinalang.compiler.util.diagnotic.DiagnosticPos;\n+import org.wso2.ballerinalang.util.Lists;\n+\n+import java.util.List;\n+\n+/**\n+ * Class responsible for desugar query pipeline into actual Ballerina code.\n+ *\n+ * @since 1.2.0\n+ */\n+public class QueryDesugar extends BLangNodeVisitor {\n+\n+    private static final CompilerContext.Key<QueryDesugar> QUERY_DESUGAR_KEY =\n+            new CompilerContext.Key<>();\n+    private final SymbolEnter symbolEnter;\n+    private final Desugar desugar;\n+    private final SymbolTable symTable;\n+    private final BLangAnonymousModelHelper anonymousModelHelper;\n+    private BLangDiagnosticLog dlog;\n+    private final SymbolResolver symResolver;\n+    private final Names names;\n+    private final Types types;\n+    private BLangForeach parentForeach = null;\n+\n+    private QueryDesugar(CompilerContext context) {\n+        context.put(QUERY_DESUGAR_KEY, this);\n+        this.symTable = SymbolTable.getInstance(context);\n+        this.symResolver = SymbolResolver.getInstance(context);\n+        this.symbolEnter = SymbolEnter.getInstance(context);\n+        this.names = Names.getInstance(context);\n+        this.types = Types.getInstance(context);\n+        this.dlog = BLangDiagnosticLog.getInstance(context);\n+        this.desugar = Desugar.getInstance(context);\n+        this.anonymousModelHelper = BLangAnonymousModelHelper.getInstance(context);\n+    }\n+\n+    public static QueryDesugar getInstance(CompilerContext context) {\n+        QueryDesugar desugar = context.get(QUERY_DESUGAR_KEY);\n+        if (desugar == null) {\n+            desugar = new QueryDesugar(context);\n+        }\n+\n+        return desugar;\n+    }\n+\n+    BLangStatementExpression desugarQueryExpr(BLangQueryExpr queryExpr, SymbolEnv env) {\n+        List<BLangFromClause> fromClauseList = queryExpr.fromClauseList;\n+        BLangFromClause fromClause = fromClauseList.get(0);\n+        BLangSelectClause selectClause = queryExpr.selectClause;\n+        List<BLangWhereClause> whereClauseList = queryExpr.whereClauseList;\n+        DiagnosticPos pos = fromClause.pos;\n+\n+        // Create Foreach statement\n+        //\n+        // Below query expression :\n+        //      from var person in personList\n+        //\n+        // changes as,\n+        //      foreach var person in personList {\n+        //          ....\n+        //      }\n+        BLangForeach leafForeach = buildFromClauseBlock(fromClauseList);\n+        BLangBlockStmt foreachBody = ASTBuilderUtil.createBlockStmt(pos);\n+\n+        BType outputArrayType;\n+        if (selectClause.expression != null && selectClause.expression.type != null) {\n+            outputArrayType = new BArrayType(selectClause.expression.type);\n+        } else {\n+            outputArrayType = fromClause.varType;\n+        }\n+\n+        BLangListConstructorExpr emptyArrayExpr = ASTBuilderUtil.createEmptyArrayLiteral(pos,\n+                (BArrayType) outputArrayType);\n+        BVarSymbol emptyArrayVarSymbol = new BVarSymbol(0, new Name(\"$outputDataArray$\"),\n+                env.scope.owner.pkgID, outputArrayType, env.scope.owner);\n+        BLangSimpleVariable outputArrayVariable =\n+                ASTBuilderUtil.createVariable(pos, \"$outputDataArray$\", outputArrayType,\n+                        emptyArrayExpr, emptyArrayVarSymbol);\n+\n+        // Create temp array variable\n+        //      Person[] x = [];\n+\n+        BLangSimpleVariableDef outputVariableDef =\n+                ASTBuilderUtil.createVariableDef(pos, outputArrayVariable);\n+        BLangSimpleVarRef outputVarRef = ASTBuilderUtil.createVariableRef(pos, outputArrayVariable.symbol);\n+\n+        // Create indexed based access expression statement\n+        //      x[x.length()] = {\n+        //         firstName: person.firstName,\n+        //         lastName: person.lastName\n+        //      };\n+\n+        if (selectClause.expression.type == null) {\n+            selectClause.expression.type = fromClause.varType;\n+        }\n+\n+        BLangInvocation lengthInvocation = createLengthInvocation(selectClause.pos, outputArrayVariable.symbol);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "203067b0b64f5a971e0f3bb4210ecb75c38aa637"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODgxODQyNw==", "bodyText": "Facing an issue for primitive arrays @ runtime when using push method. Will attend this separately.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20975#discussion_r378818427", "createdAt": "2020-02-13T12:01:28Z", "author": {"login": "mohanvive"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/QueryDesugar.java", "diffHunk": "@@ -0,0 +1,250 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.wso2.ballerinalang.compiler.desugar;\n+\n+import org.ballerinalang.model.TreeBuilder;\n+import org.wso2.ballerinalang.compiler.parser.BLangAnonymousModelHelper;\n+import org.wso2.ballerinalang.compiler.semantics.analyzer.SymbolEnter;\n+import org.wso2.ballerinalang.compiler.semantics.analyzer.SymbolResolver;\n+import org.wso2.ballerinalang.compiler.semantics.analyzer.Types;\n+import org.wso2.ballerinalang.compiler.semantics.model.SymbolEnv;\n+import org.wso2.ballerinalang.compiler.semantics.model.SymbolTable;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BInvokableSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BVarSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BArrayType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BType;\n+import org.wso2.ballerinalang.compiler.tree.BLangNodeVisitor;\n+import org.wso2.ballerinalang.compiler.tree.BLangSimpleVariable;\n+import org.wso2.ballerinalang.compiler.tree.clauses.BLangDoClause;\n+import org.wso2.ballerinalang.compiler.tree.clauses.BLangFromClause;\n+import org.wso2.ballerinalang.compiler.tree.clauses.BLangSelectClause;\n+import org.wso2.ballerinalang.compiler.tree.clauses.BLangWhereClause;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangIndexBasedAccess;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangInvocation;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangListConstructorExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangQueryExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangSimpleVarRef;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangStatementExpression;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangAssignment;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangBlockStmt;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangForeach;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangIf;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangQueryAction;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangSimpleVariableDef;\n+import org.wso2.ballerinalang.compiler.util.CompilerContext;\n+import org.wso2.ballerinalang.compiler.util.Name;\n+import org.wso2.ballerinalang.compiler.util.Names;\n+import org.wso2.ballerinalang.compiler.util.diagnotic.BLangDiagnosticLog;\n+import org.wso2.ballerinalang.compiler.util.diagnotic.DiagnosticPos;\n+import org.wso2.ballerinalang.util.Lists;\n+\n+import java.util.List;\n+\n+/**\n+ * Class responsible for desugar query pipeline into actual Ballerina code.\n+ *\n+ * @since 1.2.0\n+ */\n+public class QueryDesugar extends BLangNodeVisitor {\n+\n+    private static final CompilerContext.Key<QueryDesugar> QUERY_DESUGAR_KEY =\n+            new CompilerContext.Key<>();\n+    private final SymbolEnter symbolEnter;\n+    private final Desugar desugar;\n+    private final SymbolTable symTable;\n+    private final BLangAnonymousModelHelper anonymousModelHelper;\n+    private BLangDiagnosticLog dlog;\n+    private final SymbolResolver symResolver;\n+    private final Names names;\n+    private final Types types;\n+    private BLangForeach parentForeach = null;\n+\n+    private QueryDesugar(CompilerContext context) {\n+        context.put(QUERY_DESUGAR_KEY, this);\n+        this.symTable = SymbolTable.getInstance(context);\n+        this.symResolver = SymbolResolver.getInstance(context);\n+        this.symbolEnter = SymbolEnter.getInstance(context);\n+        this.names = Names.getInstance(context);\n+        this.types = Types.getInstance(context);\n+        this.dlog = BLangDiagnosticLog.getInstance(context);\n+        this.desugar = Desugar.getInstance(context);\n+        this.anonymousModelHelper = BLangAnonymousModelHelper.getInstance(context);\n+    }\n+\n+    public static QueryDesugar getInstance(CompilerContext context) {\n+        QueryDesugar desugar = context.get(QUERY_DESUGAR_KEY);\n+        if (desugar == null) {\n+            desugar = new QueryDesugar(context);\n+        }\n+\n+        return desugar;\n+    }\n+\n+    BLangStatementExpression desugarQueryExpr(BLangQueryExpr queryExpr, SymbolEnv env) {\n+        List<BLangFromClause> fromClauseList = queryExpr.fromClauseList;\n+        BLangFromClause fromClause = fromClauseList.get(0);\n+        BLangSelectClause selectClause = queryExpr.selectClause;\n+        List<BLangWhereClause> whereClauseList = queryExpr.whereClauseList;\n+        DiagnosticPos pos = fromClause.pos;\n+\n+        // Create Foreach statement\n+        //\n+        // Below query expression :\n+        //      from var person in personList\n+        //\n+        // changes as,\n+        //      foreach var person in personList {\n+        //          ....\n+        //      }\n+        BLangForeach leafForeach = buildFromClauseBlock(fromClauseList);\n+        BLangBlockStmt foreachBody = ASTBuilderUtil.createBlockStmt(pos);\n+\n+        BType outputArrayType;\n+        if (selectClause.expression != null && selectClause.expression.type != null) {\n+            outputArrayType = new BArrayType(selectClause.expression.type);\n+        } else {\n+            outputArrayType = fromClause.varType;\n+        }\n+\n+        BLangListConstructorExpr emptyArrayExpr = ASTBuilderUtil.createEmptyArrayLiteral(pos,\n+                (BArrayType) outputArrayType);\n+        BVarSymbol emptyArrayVarSymbol = new BVarSymbol(0, new Name(\"$outputDataArray$\"),\n+                env.scope.owner.pkgID, outputArrayType, env.scope.owner);\n+        BLangSimpleVariable outputArrayVariable =\n+                ASTBuilderUtil.createVariable(pos, \"$outputDataArray$\", outputArrayType,\n+                        emptyArrayExpr, emptyArrayVarSymbol);\n+\n+        // Create temp array variable\n+        //      Person[] x = [];\n+\n+        BLangSimpleVariableDef outputVariableDef =\n+                ASTBuilderUtil.createVariableDef(pos, outputArrayVariable);\n+        BLangSimpleVarRef outputVarRef = ASTBuilderUtil.createVariableRef(pos, outputArrayVariable.symbol);\n+\n+        // Create indexed based access expression statement\n+        //      x[x.length()] = {\n+        //         firstName: person.firstName,\n+        //         lastName: person.lastName\n+        //      };\n+\n+        if (selectClause.expression.type == null) {\n+            selectClause.expression.type = fromClause.varType;\n+        }\n+\n+        BLangInvocation lengthInvocation = createLengthInvocation(selectClause.pos, outputArrayVariable.symbol);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODcwNDMyOA=="}, "originalCommit": {"oid": "203067b0b64f5a971e0f3bb4210ecb75c38aa637"}, "originalPosition": 148}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0MzA2MzE2OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/CodeAnalyzer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QwODoxNjoxNlrOFpKZ7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QwODoxNjoxNlrOFpKZ7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODcwNjQxMw==", "bodyText": "without directly calling accept() shall we call analyzeExpr()? Applies to other places as well", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20975#discussion_r378706413", "createdAt": "2020-02-13T08:16:16Z", "author": {"login": "gimantha"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/CodeAnalyzer.java", "diffHunk": "@@ -1160,6 +1167,27 @@ public void visit(BLangForeach foreach) {\n         analyzeExpr(foreach.collection);\n     }\n \n+    @Override\n+    public void visit(BLangQueryAction queryAction) {\n+        this.loopWithintransactionCheckStack.push(true);\n+        boolean statementReturns = this.statementReturns;\n+        this.checkStatementExecutionValidity(queryAction);\n+        this.loopCount++;\n+        queryAction.doClause.accept(this);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "203067b0b64f5a971e0f3bb4210ecb75c38aa637"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0MzA2NTc5OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/DataflowAnalyzer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QwODoxNzoyMFrOFpKbhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QwODoxNzoyMFrOFpKbhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODcwNjgyMg==", "bodyText": "Use analyzeNode instead", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20975#discussion_r378706822", "createdAt": "2020-02-13T08:17:20Z", "author": {"login": "gimantha"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/DataflowAnalyzer.java", "diffHunk": "@@ -449,6 +456,19 @@ public void visit(BLangForeach foreach) {\n         analyzeNode(foreach.body, env);\n     }\n \n+    @Override\n+    public void visit(BLangQueryAction queryAction) {\n+        for (FromClauseNode fromClauseNode : queryAction.fromClauseList) {\n+            ((BLangFromClause) fromClauseNode).accept(this);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "203067b0b64f5a971e0f3bb4210ecb75c38aa637"}, "originalPosition": 35}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1203, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}