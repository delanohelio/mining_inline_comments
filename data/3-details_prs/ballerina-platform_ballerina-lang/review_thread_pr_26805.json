{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE2ODg1MTI5", "number": 26805, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQwMjo1MzozOVrOE2lnZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQwMzoxNjo1OVrOE2l1VA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1Njc0ODU0OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/io/ballerina/compiler/api/impl/LangLibrary.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQwMjo1MzozOVrOHvdZ8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQwODo1NjozMlrOHvkk9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTUyNjg5Ng==", "bodyText": "Lang libs are looped twice, here and at L#80. Can we do it in a single loop?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26805#discussion_r519526896", "createdAt": "2020-11-09T02:53:39Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-lang/src/main/java/io/ballerina/compiler/api/impl/LangLibrary.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.ballerina.compiler.api.impl;\n+\n+import io.ballerina.compiler.api.symbols.FunctionSymbol;\n+import io.ballerina.compiler.api.symbols.TypeDescKind;\n+import org.ballerinalang.model.elements.PackageID;\n+import org.ballerinalang.model.symbols.SymbolKind;\n+import org.wso2.ballerinalang.compiler.semantics.model.Scope;\n+import org.wso2.ballerinalang.compiler.semantics.model.SymbolEnv;\n+import org.wso2.ballerinalang.compiler.semantics.model.SymbolTable;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BInvokableSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BPackageSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.Symbols;\n+import org.wso2.ballerinalang.compiler.util.CompilerContext;\n+import org.wso2.ballerinalang.compiler.util.Name;\n+import org.wso2.ballerinalang.compiler.util.Names;\n+import org.wso2.ballerinalang.util.Flags;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.ARRAY;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.BOOLEAN;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.DECIMAL;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.ERROR;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.FLOAT;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.FUTURE;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.INT;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.MAP;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.OBJECT;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.STREAM;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.STRING;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.TABLE;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.TYPEDESC;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.XML;\n+\n+\n+/**\n+ * A class to hold the lang library function info required for types.\n+ *\n+ * @since 2.0.0\n+ */\n+public class LangLibrary {\n+\n+    private static final CompilerContext.Key<LangLibrary> LANG_LIB_KEY = new CompilerContext.Key<>();\n+    private static final String LANG_VALUE = \"value\";\n+\n+    private final Map<String, Map<String, BInvokableSymbol>> langLibMethods;\n+    private final Map<String, List<FunctionSymbol>> wrappedLangLibMethods;\n+    private final SymbolFactory symbolFactory;\n+\n+    private LangLibrary(CompilerContext context) {\n+        context.put(LANG_LIB_KEY, this);\n+\n+        symbolFactory = SymbolFactory.getInstance(context);\n+        SymbolTable symbolTable = SymbolTable.getInstance(context);\n+        Map<String, BPackageSymbol> langLibs = new HashMap<>();\n+        wrappedLangLibMethods = new HashMap<>();\n+\n+        for (Map.Entry<BPackageSymbol, SymbolEnv> entry : symbolTable.pkgEnvMap.entrySet()) {\n+            BPackageSymbol module = entry.getKey();\n+            PackageID moduleID = module.pkgID;\n+\n+            if (Names.BALLERINA_ORG.equals(moduleID.orgName) &&\n+                    (moduleID.nameComps.size() == 2 && Names.LANG.equals(moduleID.nameComps.get(0)))) {\n+                langLibs.put(moduleID.nameComps.get(1).value, module);\n+            }\n+        }\n+\n+        langLibMethods = getLangLibMethods(langLibs);\n+    }\n+\n+    public static LangLibrary getInstance(CompilerContext context) {\n+        LangLibrary langLib = context.get(LANG_LIB_KEY);\n+        if (langLib == null) {\n+            langLib = new LangLibrary(context);\n+        }\n+\n+        return langLib;\n+    }\n+\n+    /**\n+     * Given a type descriptor kind, return the list of lang library functions that can be called using a method call\n+     * expr, on an expression of that type.\n+     *\n+     * @param typeDescKind A type descriptor kind\n+     * @return The associated list of lang library functions\n+     */\n+    public List<FunctionSymbol> getMethods(TypeDescKind typeDescKind) {\n+        String langLibName = getAssociatedLangLibName(typeDescKind);\n+\n+        if (wrappedLangLibMethods.containsKey(langLibName)) {\n+            return wrappedLangLibMethods.get(langLibName);\n+        }\n+\n+        Map<String, BInvokableSymbol> methods = langLibMethods.get(langLibName);\n+\n+        List<FunctionSymbol> wrappedMethods = new ArrayList<>();\n+        wrappedLangLibMethods.put(langLibName, wrappedMethods);\n+        populateMethodList(wrappedMethods, methods);\n+\n+        // Add the common functions in lang.value to types which have an associated lang library.\n+        if (!LANG_VALUE.equals(langLibName)) {\n+            populateMethodList(wrappedMethods, langLibMethods.get(LANG_VALUE));\n+        }\n+\n+        return wrappedMethods;\n+    }\n+\n+    // Private Methods\n+\n+    private void populateMethodList(List<FunctionSymbol> list, Map<String, BInvokableSymbol> langLib) {\n+        for (Map.Entry<String, BInvokableSymbol> entry : langLib.entrySet()) {\n+            FunctionSymbol method = symbolFactory.createFunctionSymbol(entry.getValue(), entry.getKey());\n+            list.add(method);\n+        }\n+    }\n+\n+    private String getAssociatedLangLibName(TypeDescKind typeDescKind) {\n+        switch (typeDescKind) {\n+            case INT:\n+            case BYTE:\n+                return INT.getName();\n+            case FLOAT:\n+                return FLOAT.getName();\n+            case DECIMAL:\n+                return DECIMAL.getName();\n+            case STRING:\n+                return STRING.getName();\n+            case BOOLEAN:\n+                return BOOLEAN.getName();\n+            case ARRAY:\n+            case TUPLE:\n+                return ARRAY.getName();\n+            case STREAM:\n+                return STREAM.getName();\n+            case OBJECT:\n+                return OBJECT.getName();\n+            case RECORD:\n+            case MAP:\n+                return MAP.getName();\n+            case ERROR:\n+                return ERROR.getName();\n+            case FUTURE:\n+                return FUTURE.getName();\n+            case TYPEDESC:\n+                return TYPEDESC.getName();\n+            case XML:\n+                return XML.getName();\n+            case TABLE:\n+                return TABLE.getName();\n+            default:\n+                return \"value\";\n+        }\n+    }\n+\n+    private static Map<String, Map<String, BInvokableSymbol>> getLangLibMethods(Map<String, BPackageSymbol> langLibs) {\n+        Map<String, Map<String, BInvokableSymbol>> langLibMethods = new HashMap<>();\n+\n+        for (Map.Entry<String, BPackageSymbol> entry : langLibs.entrySet()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b27c6b6f05c2d99e8331ed10c57b1f057932edad"}, "originalPosition": 180}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTY0NDQwNw==", "bodyText": "Ack. I think we can, by populating the lang lib map on-demand, instead of populating the function list at the lang lib initialization.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26805#discussion_r519644407", "createdAt": "2020-11-09T08:56:32Z", "author": {"login": "pubudu91"}, "path": "compiler/ballerina-lang/src/main/java/io/ballerina/compiler/api/impl/LangLibrary.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.ballerina.compiler.api.impl;\n+\n+import io.ballerina.compiler.api.symbols.FunctionSymbol;\n+import io.ballerina.compiler.api.symbols.TypeDescKind;\n+import org.ballerinalang.model.elements.PackageID;\n+import org.ballerinalang.model.symbols.SymbolKind;\n+import org.wso2.ballerinalang.compiler.semantics.model.Scope;\n+import org.wso2.ballerinalang.compiler.semantics.model.SymbolEnv;\n+import org.wso2.ballerinalang.compiler.semantics.model.SymbolTable;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BInvokableSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BPackageSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.Symbols;\n+import org.wso2.ballerinalang.compiler.util.CompilerContext;\n+import org.wso2.ballerinalang.compiler.util.Name;\n+import org.wso2.ballerinalang.compiler.util.Names;\n+import org.wso2.ballerinalang.util.Flags;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.ARRAY;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.BOOLEAN;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.DECIMAL;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.ERROR;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.FLOAT;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.FUTURE;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.INT;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.MAP;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.OBJECT;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.STREAM;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.STRING;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.TABLE;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.TYPEDESC;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.XML;\n+\n+\n+/**\n+ * A class to hold the lang library function info required for types.\n+ *\n+ * @since 2.0.0\n+ */\n+public class LangLibrary {\n+\n+    private static final CompilerContext.Key<LangLibrary> LANG_LIB_KEY = new CompilerContext.Key<>();\n+    private static final String LANG_VALUE = \"value\";\n+\n+    private final Map<String, Map<String, BInvokableSymbol>> langLibMethods;\n+    private final Map<String, List<FunctionSymbol>> wrappedLangLibMethods;\n+    private final SymbolFactory symbolFactory;\n+\n+    private LangLibrary(CompilerContext context) {\n+        context.put(LANG_LIB_KEY, this);\n+\n+        symbolFactory = SymbolFactory.getInstance(context);\n+        SymbolTable symbolTable = SymbolTable.getInstance(context);\n+        Map<String, BPackageSymbol> langLibs = new HashMap<>();\n+        wrappedLangLibMethods = new HashMap<>();\n+\n+        for (Map.Entry<BPackageSymbol, SymbolEnv> entry : symbolTable.pkgEnvMap.entrySet()) {\n+            BPackageSymbol module = entry.getKey();\n+            PackageID moduleID = module.pkgID;\n+\n+            if (Names.BALLERINA_ORG.equals(moduleID.orgName) &&\n+                    (moduleID.nameComps.size() == 2 && Names.LANG.equals(moduleID.nameComps.get(0)))) {\n+                langLibs.put(moduleID.nameComps.get(1).value, module);\n+            }\n+        }\n+\n+        langLibMethods = getLangLibMethods(langLibs);\n+    }\n+\n+    public static LangLibrary getInstance(CompilerContext context) {\n+        LangLibrary langLib = context.get(LANG_LIB_KEY);\n+        if (langLib == null) {\n+            langLib = new LangLibrary(context);\n+        }\n+\n+        return langLib;\n+    }\n+\n+    /**\n+     * Given a type descriptor kind, return the list of lang library functions that can be called using a method call\n+     * expr, on an expression of that type.\n+     *\n+     * @param typeDescKind A type descriptor kind\n+     * @return The associated list of lang library functions\n+     */\n+    public List<FunctionSymbol> getMethods(TypeDescKind typeDescKind) {\n+        String langLibName = getAssociatedLangLibName(typeDescKind);\n+\n+        if (wrappedLangLibMethods.containsKey(langLibName)) {\n+            return wrappedLangLibMethods.get(langLibName);\n+        }\n+\n+        Map<String, BInvokableSymbol> methods = langLibMethods.get(langLibName);\n+\n+        List<FunctionSymbol> wrappedMethods = new ArrayList<>();\n+        wrappedLangLibMethods.put(langLibName, wrappedMethods);\n+        populateMethodList(wrappedMethods, methods);\n+\n+        // Add the common functions in lang.value to types which have an associated lang library.\n+        if (!LANG_VALUE.equals(langLibName)) {\n+            populateMethodList(wrappedMethods, langLibMethods.get(LANG_VALUE));\n+        }\n+\n+        return wrappedMethods;\n+    }\n+\n+    // Private Methods\n+\n+    private void populateMethodList(List<FunctionSymbol> list, Map<String, BInvokableSymbol> langLib) {\n+        for (Map.Entry<String, BInvokableSymbol> entry : langLib.entrySet()) {\n+            FunctionSymbol method = symbolFactory.createFunctionSymbol(entry.getValue(), entry.getKey());\n+            list.add(method);\n+        }\n+    }\n+\n+    private String getAssociatedLangLibName(TypeDescKind typeDescKind) {\n+        switch (typeDescKind) {\n+            case INT:\n+            case BYTE:\n+                return INT.getName();\n+            case FLOAT:\n+                return FLOAT.getName();\n+            case DECIMAL:\n+                return DECIMAL.getName();\n+            case STRING:\n+                return STRING.getName();\n+            case BOOLEAN:\n+                return BOOLEAN.getName();\n+            case ARRAY:\n+            case TUPLE:\n+                return ARRAY.getName();\n+            case STREAM:\n+                return STREAM.getName();\n+            case OBJECT:\n+                return OBJECT.getName();\n+            case RECORD:\n+            case MAP:\n+                return MAP.getName();\n+            case ERROR:\n+                return ERROR.getName();\n+            case FUTURE:\n+                return FUTURE.getName();\n+            case TYPEDESC:\n+                return TYPEDESC.getName();\n+            case XML:\n+                return XML.getName();\n+            case TABLE:\n+                return TABLE.getName();\n+            default:\n+                return \"value\";\n+        }\n+    }\n+\n+    private static Map<String, Map<String, BInvokableSymbol>> getLangLibMethods(Map<String, BPackageSymbol> langLibs) {\n+        Map<String, Map<String, BInvokableSymbol>> langLibMethods = new HashMap<>();\n+\n+        for (Map.Entry<String, BPackageSymbol> entry : langLibs.entrySet()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTUyNjg5Ng=="}, "originalCommit": {"oid": "b27c6b6f05c2d99e8331ed10c57b1f057932edad"}, "originalPosition": 180}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1Njc1MjUxOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/io/ballerina/compiler/api/impl/LangLibrary.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQwMjo1NTo1M1rOHvdcKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxMDowNjoyNVrOHvnTfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTUyNzQ2NA==", "bodyText": "Can there be symbols in the lang.value module without the LANG_LIB flag?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26805#discussion_r519527464", "createdAt": "2020-11-09T02:55:53Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-lang/src/main/java/io/ballerina/compiler/api/impl/LangLibrary.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.ballerina.compiler.api.impl;\n+\n+import io.ballerina.compiler.api.symbols.FunctionSymbol;\n+import io.ballerina.compiler.api.symbols.TypeDescKind;\n+import org.ballerinalang.model.elements.PackageID;\n+import org.ballerinalang.model.symbols.SymbolKind;\n+import org.wso2.ballerinalang.compiler.semantics.model.Scope;\n+import org.wso2.ballerinalang.compiler.semantics.model.SymbolEnv;\n+import org.wso2.ballerinalang.compiler.semantics.model.SymbolTable;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BInvokableSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BPackageSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.Symbols;\n+import org.wso2.ballerinalang.compiler.util.CompilerContext;\n+import org.wso2.ballerinalang.compiler.util.Name;\n+import org.wso2.ballerinalang.compiler.util.Names;\n+import org.wso2.ballerinalang.util.Flags;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.ARRAY;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.BOOLEAN;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.DECIMAL;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.ERROR;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.FLOAT;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.FUTURE;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.INT;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.MAP;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.OBJECT;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.STREAM;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.STRING;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.TABLE;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.TYPEDESC;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.XML;\n+\n+\n+/**\n+ * A class to hold the lang library function info required for types.\n+ *\n+ * @since 2.0.0\n+ */\n+public class LangLibrary {\n+\n+    private static final CompilerContext.Key<LangLibrary> LANG_LIB_KEY = new CompilerContext.Key<>();\n+    private static final String LANG_VALUE = \"value\";\n+\n+    private final Map<String, Map<String, BInvokableSymbol>> langLibMethods;\n+    private final Map<String, List<FunctionSymbol>> wrappedLangLibMethods;\n+    private final SymbolFactory symbolFactory;\n+\n+    private LangLibrary(CompilerContext context) {\n+        context.put(LANG_LIB_KEY, this);\n+\n+        symbolFactory = SymbolFactory.getInstance(context);\n+        SymbolTable symbolTable = SymbolTable.getInstance(context);\n+        Map<String, BPackageSymbol> langLibs = new HashMap<>();\n+        wrappedLangLibMethods = new HashMap<>();\n+\n+        for (Map.Entry<BPackageSymbol, SymbolEnv> entry : symbolTable.pkgEnvMap.entrySet()) {\n+            BPackageSymbol module = entry.getKey();\n+            PackageID moduleID = module.pkgID;\n+\n+            if (Names.BALLERINA_ORG.equals(moduleID.orgName) &&\n+                    (moduleID.nameComps.size() == 2 && Names.LANG.equals(moduleID.nameComps.get(0)))) {\n+                langLibs.put(moduleID.nameComps.get(1).value, module);\n+            }\n+        }\n+\n+        langLibMethods = getLangLibMethods(langLibs);\n+    }\n+\n+    public static LangLibrary getInstance(CompilerContext context) {\n+        LangLibrary langLib = context.get(LANG_LIB_KEY);\n+        if (langLib == null) {\n+            langLib = new LangLibrary(context);\n+        }\n+\n+        return langLib;\n+    }\n+\n+    /**\n+     * Given a type descriptor kind, return the list of lang library functions that can be called using a method call\n+     * expr, on an expression of that type.\n+     *\n+     * @param typeDescKind A type descriptor kind\n+     * @return The associated list of lang library functions\n+     */\n+    public List<FunctionSymbol> getMethods(TypeDescKind typeDescKind) {\n+        String langLibName = getAssociatedLangLibName(typeDescKind);\n+\n+        if (wrappedLangLibMethods.containsKey(langLibName)) {\n+            return wrappedLangLibMethods.get(langLibName);\n+        }\n+\n+        Map<String, BInvokableSymbol> methods = langLibMethods.get(langLibName);\n+\n+        List<FunctionSymbol> wrappedMethods = new ArrayList<>();\n+        wrappedLangLibMethods.put(langLibName, wrappedMethods);\n+        populateMethodList(wrappedMethods, methods);\n+\n+        // Add the common functions in lang.value to types which have an associated lang library.\n+        if (!LANG_VALUE.equals(langLibName)) {\n+            populateMethodList(wrappedMethods, langLibMethods.get(LANG_VALUE));\n+        }\n+\n+        return wrappedMethods;\n+    }\n+\n+    // Private Methods\n+\n+    private void populateMethodList(List<FunctionSymbol> list, Map<String, BInvokableSymbol> langLib) {\n+        for (Map.Entry<String, BInvokableSymbol> entry : langLib.entrySet()) {\n+            FunctionSymbol method = symbolFactory.createFunctionSymbol(entry.getValue(), entry.getKey());\n+            list.add(method);\n+        }\n+    }\n+\n+    private String getAssociatedLangLibName(TypeDescKind typeDescKind) {\n+        switch (typeDescKind) {\n+            case INT:\n+            case BYTE:\n+                return INT.getName();\n+            case FLOAT:\n+                return FLOAT.getName();\n+            case DECIMAL:\n+                return DECIMAL.getName();\n+            case STRING:\n+                return STRING.getName();\n+            case BOOLEAN:\n+                return BOOLEAN.getName();\n+            case ARRAY:\n+            case TUPLE:\n+                return ARRAY.getName();\n+            case STREAM:\n+                return STREAM.getName();\n+            case OBJECT:\n+                return OBJECT.getName();\n+            case RECORD:\n+            case MAP:\n+                return MAP.getName();\n+            case ERROR:\n+                return ERROR.getName();\n+            case FUTURE:\n+                return FUTURE.getName();\n+            case TYPEDESC:\n+                return TYPEDESC.getName();\n+            case XML:\n+                return XML.getName();\n+            case TABLE:\n+                return TABLE.getName();\n+            default:\n+                return \"value\";\n+        }\n+    }\n+\n+    private static Map<String, Map<String, BInvokableSymbol>> getLangLibMethods(Map<String, BPackageSymbol> langLibs) {\n+        Map<String, Map<String, BInvokableSymbol>> langLibMethods = new HashMap<>();\n+\n+        for (Map.Entry<String, BPackageSymbol> entry : langLibs.entrySet()) {\n+            String key = entry.getKey();\n+            BPackageSymbol value = entry.getValue();\n+\n+            Map<String, BInvokableSymbol> methods = new HashMap<>();\n+\n+            for (Map.Entry<Name, Scope.ScopeEntry> nameScopeEntry : value.scope.entries.entrySet()) {\n+                BSymbol symbol = nameScopeEntry.getValue().symbol;\n+\n+                if (symbol.kind != SymbolKind.FUNCTION) {\n+                    continue;\n+                }\n+\n+                BInvokableSymbol invSymbol = (BInvokableSymbol) symbol;\n+\n+                if (Symbols.isFlagOn(invSymbol.flags, Flags.PUBLIC) && !invSymbol.params.isEmpty() &&\n+                        key.compareToIgnoreCase(invSymbol.params.get(0).type.getKind().name()) == 0) {\n+                    methods.put(invSymbol.name.value, invSymbol);\n+                }\n+            }\n+\n+            langLibMethods.put(key, methods);\n+        }\n+\n+        populateLangValueLibrary(langLibs, langLibMethods);\n+        return langLibMethods;\n+    }\n+\n+    private static void populateLangValueLibrary(Map<String, BPackageSymbol> langLibs,\n+                                                 Map<String, Map<String, BInvokableSymbol>> langLibMethods) {\n+        BPackageSymbol langValue = langLibs.get(LANG_VALUE);\n+        Map<String, BInvokableSymbol> methods = new HashMap<>();\n+\n+        for (Map.Entry<Name, Scope.ScopeEntry> nameScopeEntry : langValue.scope.entries.entrySet()) {\n+            BSymbol symbol = nameScopeEntry.getValue().symbol;\n+\n+            if (symbol.kind != SymbolKind.FUNCTION || !Symbols.isFlagOn(symbol.flags, Flags.LANG_LIB)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b27c6b6f05c2d99e8331ed10c57b1f057932edad"}, "originalPosition": 216}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTY0NzE3Nw==", "bodyText": "There can be I guess. Currently we have added the LANG_LIB flag to lang lib functions. I guess we can get rid of the flag check", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26805#discussion_r519647177", "createdAt": "2020-11-09T09:01:07Z", "author": {"login": "pubudu91"}, "path": "compiler/ballerina-lang/src/main/java/io/ballerina/compiler/api/impl/LangLibrary.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.ballerina.compiler.api.impl;\n+\n+import io.ballerina.compiler.api.symbols.FunctionSymbol;\n+import io.ballerina.compiler.api.symbols.TypeDescKind;\n+import org.ballerinalang.model.elements.PackageID;\n+import org.ballerinalang.model.symbols.SymbolKind;\n+import org.wso2.ballerinalang.compiler.semantics.model.Scope;\n+import org.wso2.ballerinalang.compiler.semantics.model.SymbolEnv;\n+import org.wso2.ballerinalang.compiler.semantics.model.SymbolTable;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BInvokableSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BPackageSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.Symbols;\n+import org.wso2.ballerinalang.compiler.util.CompilerContext;\n+import org.wso2.ballerinalang.compiler.util.Name;\n+import org.wso2.ballerinalang.compiler.util.Names;\n+import org.wso2.ballerinalang.util.Flags;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.ARRAY;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.BOOLEAN;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.DECIMAL;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.ERROR;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.FLOAT;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.FUTURE;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.INT;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.MAP;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.OBJECT;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.STREAM;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.STRING;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.TABLE;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.TYPEDESC;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.XML;\n+\n+\n+/**\n+ * A class to hold the lang library function info required for types.\n+ *\n+ * @since 2.0.0\n+ */\n+public class LangLibrary {\n+\n+    private static final CompilerContext.Key<LangLibrary> LANG_LIB_KEY = new CompilerContext.Key<>();\n+    private static final String LANG_VALUE = \"value\";\n+\n+    private final Map<String, Map<String, BInvokableSymbol>> langLibMethods;\n+    private final Map<String, List<FunctionSymbol>> wrappedLangLibMethods;\n+    private final SymbolFactory symbolFactory;\n+\n+    private LangLibrary(CompilerContext context) {\n+        context.put(LANG_LIB_KEY, this);\n+\n+        symbolFactory = SymbolFactory.getInstance(context);\n+        SymbolTable symbolTable = SymbolTable.getInstance(context);\n+        Map<String, BPackageSymbol> langLibs = new HashMap<>();\n+        wrappedLangLibMethods = new HashMap<>();\n+\n+        for (Map.Entry<BPackageSymbol, SymbolEnv> entry : symbolTable.pkgEnvMap.entrySet()) {\n+            BPackageSymbol module = entry.getKey();\n+            PackageID moduleID = module.pkgID;\n+\n+            if (Names.BALLERINA_ORG.equals(moduleID.orgName) &&\n+                    (moduleID.nameComps.size() == 2 && Names.LANG.equals(moduleID.nameComps.get(0)))) {\n+                langLibs.put(moduleID.nameComps.get(1).value, module);\n+            }\n+        }\n+\n+        langLibMethods = getLangLibMethods(langLibs);\n+    }\n+\n+    public static LangLibrary getInstance(CompilerContext context) {\n+        LangLibrary langLib = context.get(LANG_LIB_KEY);\n+        if (langLib == null) {\n+            langLib = new LangLibrary(context);\n+        }\n+\n+        return langLib;\n+    }\n+\n+    /**\n+     * Given a type descriptor kind, return the list of lang library functions that can be called using a method call\n+     * expr, on an expression of that type.\n+     *\n+     * @param typeDescKind A type descriptor kind\n+     * @return The associated list of lang library functions\n+     */\n+    public List<FunctionSymbol> getMethods(TypeDescKind typeDescKind) {\n+        String langLibName = getAssociatedLangLibName(typeDescKind);\n+\n+        if (wrappedLangLibMethods.containsKey(langLibName)) {\n+            return wrappedLangLibMethods.get(langLibName);\n+        }\n+\n+        Map<String, BInvokableSymbol> methods = langLibMethods.get(langLibName);\n+\n+        List<FunctionSymbol> wrappedMethods = new ArrayList<>();\n+        wrappedLangLibMethods.put(langLibName, wrappedMethods);\n+        populateMethodList(wrappedMethods, methods);\n+\n+        // Add the common functions in lang.value to types which have an associated lang library.\n+        if (!LANG_VALUE.equals(langLibName)) {\n+            populateMethodList(wrappedMethods, langLibMethods.get(LANG_VALUE));\n+        }\n+\n+        return wrappedMethods;\n+    }\n+\n+    // Private Methods\n+\n+    private void populateMethodList(List<FunctionSymbol> list, Map<String, BInvokableSymbol> langLib) {\n+        for (Map.Entry<String, BInvokableSymbol> entry : langLib.entrySet()) {\n+            FunctionSymbol method = symbolFactory.createFunctionSymbol(entry.getValue(), entry.getKey());\n+            list.add(method);\n+        }\n+    }\n+\n+    private String getAssociatedLangLibName(TypeDescKind typeDescKind) {\n+        switch (typeDescKind) {\n+            case INT:\n+            case BYTE:\n+                return INT.getName();\n+            case FLOAT:\n+                return FLOAT.getName();\n+            case DECIMAL:\n+                return DECIMAL.getName();\n+            case STRING:\n+                return STRING.getName();\n+            case BOOLEAN:\n+                return BOOLEAN.getName();\n+            case ARRAY:\n+            case TUPLE:\n+                return ARRAY.getName();\n+            case STREAM:\n+                return STREAM.getName();\n+            case OBJECT:\n+                return OBJECT.getName();\n+            case RECORD:\n+            case MAP:\n+                return MAP.getName();\n+            case ERROR:\n+                return ERROR.getName();\n+            case FUTURE:\n+                return FUTURE.getName();\n+            case TYPEDESC:\n+                return TYPEDESC.getName();\n+            case XML:\n+                return XML.getName();\n+            case TABLE:\n+                return TABLE.getName();\n+            default:\n+                return \"value\";\n+        }\n+    }\n+\n+    private static Map<String, Map<String, BInvokableSymbol>> getLangLibMethods(Map<String, BPackageSymbol> langLibs) {\n+        Map<String, Map<String, BInvokableSymbol>> langLibMethods = new HashMap<>();\n+\n+        for (Map.Entry<String, BPackageSymbol> entry : langLibs.entrySet()) {\n+            String key = entry.getKey();\n+            BPackageSymbol value = entry.getValue();\n+\n+            Map<String, BInvokableSymbol> methods = new HashMap<>();\n+\n+            for (Map.Entry<Name, Scope.ScopeEntry> nameScopeEntry : value.scope.entries.entrySet()) {\n+                BSymbol symbol = nameScopeEntry.getValue().symbol;\n+\n+                if (symbol.kind != SymbolKind.FUNCTION) {\n+                    continue;\n+                }\n+\n+                BInvokableSymbol invSymbol = (BInvokableSymbol) symbol;\n+\n+                if (Symbols.isFlagOn(invSymbol.flags, Flags.PUBLIC) && !invSymbol.params.isEmpty() &&\n+                        key.compareToIgnoreCase(invSymbol.params.get(0).type.getKind().name()) == 0) {\n+                    methods.put(invSymbol.name.value, invSymbol);\n+                }\n+            }\n+\n+            langLibMethods.put(key, methods);\n+        }\n+\n+        populateLangValueLibrary(langLibs, langLibMethods);\n+        return langLibMethods;\n+    }\n+\n+    private static void populateLangValueLibrary(Map<String, BPackageSymbol> langLibs,\n+                                                 Map<String, Map<String, BInvokableSymbol>> langLibMethods) {\n+        BPackageSymbol langValue = langLibs.get(LANG_VALUE);\n+        Map<String, BInvokableSymbol> methods = new HashMap<>();\n+\n+        for (Map.Entry<Name, Scope.ScopeEntry> nameScopeEntry : langValue.scope.entries.entrySet()) {\n+            BSymbol symbol = nameScopeEntry.getValue().symbol;\n+\n+            if (symbol.kind != SymbolKind.FUNCTION || !Symbols.isFlagOn(symbol.flags, Flags.LANG_LIB)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTUyNzQ2NA=="}, "originalCommit": {"oid": "b27c6b6f05c2d99e8331ed10c57b1f057932edad"}, "originalPosition": 216}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTY4OTA4Nw==", "bodyText": "Checked this. Forgot that I explicitly checked the lang lib flag to filter out the module init, start, stop functions.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26805#discussion_r519689087", "createdAt": "2020-11-09T10:06:25Z", "author": {"login": "pubudu91"}, "path": "compiler/ballerina-lang/src/main/java/io/ballerina/compiler/api/impl/LangLibrary.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.ballerina.compiler.api.impl;\n+\n+import io.ballerina.compiler.api.symbols.FunctionSymbol;\n+import io.ballerina.compiler.api.symbols.TypeDescKind;\n+import org.ballerinalang.model.elements.PackageID;\n+import org.ballerinalang.model.symbols.SymbolKind;\n+import org.wso2.ballerinalang.compiler.semantics.model.Scope;\n+import org.wso2.ballerinalang.compiler.semantics.model.SymbolEnv;\n+import org.wso2.ballerinalang.compiler.semantics.model.SymbolTable;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BInvokableSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BPackageSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.Symbols;\n+import org.wso2.ballerinalang.compiler.util.CompilerContext;\n+import org.wso2.ballerinalang.compiler.util.Name;\n+import org.wso2.ballerinalang.compiler.util.Names;\n+import org.wso2.ballerinalang.util.Flags;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.ARRAY;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.BOOLEAN;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.DECIMAL;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.ERROR;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.FLOAT;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.FUTURE;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.INT;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.MAP;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.OBJECT;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.STREAM;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.STRING;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.TABLE;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.TYPEDESC;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.XML;\n+\n+\n+/**\n+ * A class to hold the lang library function info required for types.\n+ *\n+ * @since 2.0.0\n+ */\n+public class LangLibrary {\n+\n+    private static final CompilerContext.Key<LangLibrary> LANG_LIB_KEY = new CompilerContext.Key<>();\n+    private static final String LANG_VALUE = \"value\";\n+\n+    private final Map<String, Map<String, BInvokableSymbol>> langLibMethods;\n+    private final Map<String, List<FunctionSymbol>> wrappedLangLibMethods;\n+    private final SymbolFactory symbolFactory;\n+\n+    private LangLibrary(CompilerContext context) {\n+        context.put(LANG_LIB_KEY, this);\n+\n+        symbolFactory = SymbolFactory.getInstance(context);\n+        SymbolTable symbolTable = SymbolTable.getInstance(context);\n+        Map<String, BPackageSymbol> langLibs = new HashMap<>();\n+        wrappedLangLibMethods = new HashMap<>();\n+\n+        for (Map.Entry<BPackageSymbol, SymbolEnv> entry : symbolTable.pkgEnvMap.entrySet()) {\n+            BPackageSymbol module = entry.getKey();\n+            PackageID moduleID = module.pkgID;\n+\n+            if (Names.BALLERINA_ORG.equals(moduleID.orgName) &&\n+                    (moduleID.nameComps.size() == 2 && Names.LANG.equals(moduleID.nameComps.get(0)))) {\n+                langLibs.put(moduleID.nameComps.get(1).value, module);\n+            }\n+        }\n+\n+        langLibMethods = getLangLibMethods(langLibs);\n+    }\n+\n+    public static LangLibrary getInstance(CompilerContext context) {\n+        LangLibrary langLib = context.get(LANG_LIB_KEY);\n+        if (langLib == null) {\n+            langLib = new LangLibrary(context);\n+        }\n+\n+        return langLib;\n+    }\n+\n+    /**\n+     * Given a type descriptor kind, return the list of lang library functions that can be called using a method call\n+     * expr, on an expression of that type.\n+     *\n+     * @param typeDescKind A type descriptor kind\n+     * @return The associated list of lang library functions\n+     */\n+    public List<FunctionSymbol> getMethods(TypeDescKind typeDescKind) {\n+        String langLibName = getAssociatedLangLibName(typeDescKind);\n+\n+        if (wrappedLangLibMethods.containsKey(langLibName)) {\n+            return wrappedLangLibMethods.get(langLibName);\n+        }\n+\n+        Map<String, BInvokableSymbol> methods = langLibMethods.get(langLibName);\n+\n+        List<FunctionSymbol> wrappedMethods = new ArrayList<>();\n+        wrappedLangLibMethods.put(langLibName, wrappedMethods);\n+        populateMethodList(wrappedMethods, methods);\n+\n+        // Add the common functions in lang.value to types which have an associated lang library.\n+        if (!LANG_VALUE.equals(langLibName)) {\n+            populateMethodList(wrappedMethods, langLibMethods.get(LANG_VALUE));\n+        }\n+\n+        return wrappedMethods;\n+    }\n+\n+    // Private Methods\n+\n+    private void populateMethodList(List<FunctionSymbol> list, Map<String, BInvokableSymbol> langLib) {\n+        for (Map.Entry<String, BInvokableSymbol> entry : langLib.entrySet()) {\n+            FunctionSymbol method = symbolFactory.createFunctionSymbol(entry.getValue(), entry.getKey());\n+            list.add(method);\n+        }\n+    }\n+\n+    private String getAssociatedLangLibName(TypeDescKind typeDescKind) {\n+        switch (typeDescKind) {\n+            case INT:\n+            case BYTE:\n+                return INT.getName();\n+            case FLOAT:\n+                return FLOAT.getName();\n+            case DECIMAL:\n+                return DECIMAL.getName();\n+            case STRING:\n+                return STRING.getName();\n+            case BOOLEAN:\n+                return BOOLEAN.getName();\n+            case ARRAY:\n+            case TUPLE:\n+                return ARRAY.getName();\n+            case STREAM:\n+                return STREAM.getName();\n+            case OBJECT:\n+                return OBJECT.getName();\n+            case RECORD:\n+            case MAP:\n+                return MAP.getName();\n+            case ERROR:\n+                return ERROR.getName();\n+            case FUTURE:\n+                return FUTURE.getName();\n+            case TYPEDESC:\n+                return TYPEDESC.getName();\n+            case XML:\n+                return XML.getName();\n+            case TABLE:\n+                return TABLE.getName();\n+            default:\n+                return \"value\";\n+        }\n+    }\n+\n+    private static Map<String, Map<String, BInvokableSymbol>> getLangLibMethods(Map<String, BPackageSymbol> langLibs) {\n+        Map<String, Map<String, BInvokableSymbol>> langLibMethods = new HashMap<>();\n+\n+        for (Map.Entry<String, BPackageSymbol> entry : langLibs.entrySet()) {\n+            String key = entry.getKey();\n+            BPackageSymbol value = entry.getValue();\n+\n+            Map<String, BInvokableSymbol> methods = new HashMap<>();\n+\n+            for (Map.Entry<Name, Scope.ScopeEntry> nameScopeEntry : value.scope.entries.entrySet()) {\n+                BSymbol symbol = nameScopeEntry.getValue().symbol;\n+\n+                if (symbol.kind != SymbolKind.FUNCTION) {\n+                    continue;\n+                }\n+\n+                BInvokableSymbol invSymbol = (BInvokableSymbol) symbol;\n+\n+                if (Symbols.isFlagOn(invSymbol.flags, Flags.PUBLIC) && !invSymbol.params.isEmpty() &&\n+                        key.compareToIgnoreCase(invSymbol.params.get(0).type.getKind().name()) == 0) {\n+                    methods.put(invSymbol.name.value, invSymbol);\n+                }\n+            }\n+\n+            langLibMethods.put(key, methods);\n+        }\n+\n+        populateLangValueLibrary(langLibs, langLibMethods);\n+        return langLibMethods;\n+    }\n+\n+    private static void populateLangValueLibrary(Map<String, BPackageSymbol> langLibs,\n+                                                 Map<String, Map<String, BInvokableSymbol>> langLibMethods) {\n+        BPackageSymbol langValue = langLibs.get(LANG_VALUE);\n+        Map<String, BInvokableSymbol> methods = new HashMap<>();\n+\n+        for (Map.Entry<Name, Scope.ScopeEntry> nameScopeEntry : langValue.scope.entries.entrySet()) {\n+            BSymbol symbol = nameScopeEntry.getValue().symbol;\n+\n+            if (symbol.kind != SymbolKind.FUNCTION || !Symbols.isFlagOn(symbol.flags, Flags.LANG_LIB)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTUyNzQ2NA=="}, "originalCommit": {"oid": "b27c6b6f05c2d99e8331ed10c57b1f057932edad"}, "originalPosition": 216}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1Njc1NTkxOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/io/ballerina/compiler/api/impl/LangLibrary.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQwMjo1ODoyMlrOHvdeQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQwMjo1ODoyMlrOHvdeQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTUyODAwMw==", "bodyText": "Can rename:\nkey -> pkgName\nvalue to pkgSymbol", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26805#discussion_r519528003", "createdAt": "2020-11-09T02:58:22Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-lang/src/main/java/io/ballerina/compiler/api/impl/LangLibrary.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.ballerina.compiler.api.impl;\n+\n+import io.ballerina.compiler.api.symbols.FunctionSymbol;\n+import io.ballerina.compiler.api.symbols.TypeDescKind;\n+import org.ballerinalang.model.elements.PackageID;\n+import org.ballerinalang.model.symbols.SymbolKind;\n+import org.wso2.ballerinalang.compiler.semantics.model.Scope;\n+import org.wso2.ballerinalang.compiler.semantics.model.SymbolEnv;\n+import org.wso2.ballerinalang.compiler.semantics.model.SymbolTable;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BInvokableSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BPackageSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.Symbols;\n+import org.wso2.ballerinalang.compiler.util.CompilerContext;\n+import org.wso2.ballerinalang.compiler.util.Name;\n+import org.wso2.ballerinalang.compiler.util.Names;\n+import org.wso2.ballerinalang.util.Flags;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.ARRAY;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.BOOLEAN;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.DECIMAL;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.ERROR;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.FLOAT;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.FUTURE;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.INT;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.MAP;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.OBJECT;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.STREAM;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.STRING;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.TABLE;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.TYPEDESC;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.XML;\n+\n+\n+/**\n+ * A class to hold the lang library function info required for types.\n+ *\n+ * @since 2.0.0\n+ */\n+public class LangLibrary {\n+\n+    private static final CompilerContext.Key<LangLibrary> LANG_LIB_KEY = new CompilerContext.Key<>();\n+    private static final String LANG_VALUE = \"value\";\n+\n+    private final Map<String, Map<String, BInvokableSymbol>> langLibMethods;\n+    private final Map<String, List<FunctionSymbol>> wrappedLangLibMethods;\n+    private final SymbolFactory symbolFactory;\n+\n+    private LangLibrary(CompilerContext context) {\n+        context.put(LANG_LIB_KEY, this);\n+\n+        symbolFactory = SymbolFactory.getInstance(context);\n+        SymbolTable symbolTable = SymbolTable.getInstance(context);\n+        Map<String, BPackageSymbol> langLibs = new HashMap<>();\n+        wrappedLangLibMethods = new HashMap<>();\n+\n+        for (Map.Entry<BPackageSymbol, SymbolEnv> entry : symbolTable.pkgEnvMap.entrySet()) {\n+            BPackageSymbol module = entry.getKey();\n+            PackageID moduleID = module.pkgID;\n+\n+            if (Names.BALLERINA_ORG.equals(moduleID.orgName) &&\n+                    (moduleID.nameComps.size() == 2 && Names.LANG.equals(moduleID.nameComps.get(0)))) {\n+                langLibs.put(moduleID.nameComps.get(1).value, module);\n+            }\n+        }\n+\n+        langLibMethods = getLangLibMethods(langLibs);\n+    }\n+\n+    public static LangLibrary getInstance(CompilerContext context) {\n+        LangLibrary langLib = context.get(LANG_LIB_KEY);\n+        if (langLib == null) {\n+            langLib = new LangLibrary(context);\n+        }\n+\n+        return langLib;\n+    }\n+\n+    /**\n+     * Given a type descriptor kind, return the list of lang library functions that can be called using a method call\n+     * expr, on an expression of that type.\n+     *\n+     * @param typeDescKind A type descriptor kind\n+     * @return The associated list of lang library functions\n+     */\n+    public List<FunctionSymbol> getMethods(TypeDescKind typeDescKind) {\n+        String langLibName = getAssociatedLangLibName(typeDescKind);\n+\n+        if (wrappedLangLibMethods.containsKey(langLibName)) {\n+            return wrappedLangLibMethods.get(langLibName);\n+        }\n+\n+        Map<String, BInvokableSymbol> methods = langLibMethods.get(langLibName);\n+\n+        List<FunctionSymbol> wrappedMethods = new ArrayList<>();\n+        wrappedLangLibMethods.put(langLibName, wrappedMethods);\n+        populateMethodList(wrappedMethods, methods);\n+\n+        // Add the common functions in lang.value to types which have an associated lang library.\n+        if (!LANG_VALUE.equals(langLibName)) {\n+            populateMethodList(wrappedMethods, langLibMethods.get(LANG_VALUE));\n+        }\n+\n+        return wrappedMethods;\n+    }\n+\n+    // Private Methods\n+\n+    private void populateMethodList(List<FunctionSymbol> list, Map<String, BInvokableSymbol> langLib) {\n+        for (Map.Entry<String, BInvokableSymbol> entry : langLib.entrySet()) {\n+            FunctionSymbol method = symbolFactory.createFunctionSymbol(entry.getValue(), entry.getKey());\n+            list.add(method);\n+        }\n+    }\n+\n+    private String getAssociatedLangLibName(TypeDescKind typeDescKind) {\n+        switch (typeDescKind) {\n+            case INT:\n+            case BYTE:\n+                return INT.getName();\n+            case FLOAT:\n+                return FLOAT.getName();\n+            case DECIMAL:\n+                return DECIMAL.getName();\n+            case STRING:\n+                return STRING.getName();\n+            case BOOLEAN:\n+                return BOOLEAN.getName();\n+            case ARRAY:\n+            case TUPLE:\n+                return ARRAY.getName();\n+            case STREAM:\n+                return STREAM.getName();\n+            case OBJECT:\n+                return OBJECT.getName();\n+            case RECORD:\n+            case MAP:\n+                return MAP.getName();\n+            case ERROR:\n+                return ERROR.getName();\n+            case FUTURE:\n+                return FUTURE.getName();\n+            case TYPEDESC:\n+                return TYPEDESC.getName();\n+            case XML:\n+                return XML.getName();\n+            case TABLE:\n+                return TABLE.getName();\n+            default:\n+                return \"value\";\n+        }\n+    }\n+\n+    private static Map<String, Map<String, BInvokableSymbol>> getLangLibMethods(Map<String, BPackageSymbol> langLibs) {\n+        Map<String, Map<String, BInvokableSymbol>> langLibMethods = new HashMap<>();\n+\n+        for (Map.Entry<String, BPackageSymbol> entry : langLibs.entrySet()) {\n+            String key = entry.getKey();\n+            BPackageSymbol value = entry.getValue();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b27c6b6f05c2d99e8331ed10c57b1f057932edad"}, "originalPosition": 182}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1Njc2OTA5OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/io/ballerina/compiler/api/impl/LangLibrary.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQwMzowNzozMVrOHvdmIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQwOTowMzozOVrOHvk13A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTUzMDAxNw==", "bodyText": "will the number of name components be 2 in future as well? What if we check for startsWith(\"lang.\")?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26805#discussion_r519530017", "createdAt": "2020-11-09T03:07:31Z", "author": {"login": "nadeeshaan"}, "path": "compiler/ballerina-lang/src/main/java/io/ballerina/compiler/api/impl/LangLibrary.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.ballerina.compiler.api.impl;\n+\n+import io.ballerina.compiler.api.symbols.FunctionSymbol;\n+import io.ballerina.compiler.api.symbols.TypeDescKind;\n+import org.ballerinalang.model.elements.PackageID;\n+import org.ballerinalang.model.symbols.SymbolKind;\n+import org.wso2.ballerinalang.compiler.semantics.model.Scope;\n+import org.wso2.ballerinalang.compiler.semantics.model.SymbolEnv;\n+import org.wso2.ballerinalang.compiler.semantics.model.SymbolTable;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BInvokableSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BPackageSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.Symbols;\n+import org.wso2.ballerinalang.compiler.util.CompilerContext;\n+import org.wso2.ballerinalang.compiler.util.Name;\n+import org.wso2.ballerinalang.compiler.util.Names;\n+import org.wso2.ballerinalang.util.Flags;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.ARRAY;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.BOOLEAN;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.DECIMAL;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.ERROR;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.FLOAT;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.FUTURE;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.INT;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.MAP;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.OBJECT;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.STREAM;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.STRING;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.TABLE;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.TYPEDESC;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.XML;\n+\n+\n+/**\n+ * A class to hold the lang library function info required for types.\n+ *\n+ * @since 2.0.0\n+ */\n+public class LangLibrary {\n+\n+    private static final CompilerContext.Key<LangLibrary> LANG_LIB_KEY = new CompilerContext.Key<>();\n+    private static final String LANG_VALUE = \"value\";\n+\n+    private final Map<String, Map<String, BInvokableSymbol>> langLibMethods;\n+    private final Map<String, List<FunctionSymbol>> wrappedLangLibMethods;\n+    private final SymbolFactory symbolFactory;\n+\n+    private LangLibrary(CompilerContext context) {\n+        context.put(LANG_LIB_KEY, this);\n+\n+        symbolFactory = SymbolFactory.getInstance(context);\n+        SymbolTable symbolTable = SymbolTable.getInstance(context);\n+        Map<String, BPackageSymbol> langLibs = new HashMap<>();\n+        wrappedLangLibMethods = new HashMap<>();\n+\n+        for (Map.Entry<BPackageSymbol, SymbolEnv> entry : symbolTable.pkgEnvMap.entrySet()) {\n+            BPackageSymbol module = entry.getKey();\n+            PackageID moduleID = module.pkgID;\n+\n+            if (Names.BALLERINA_ORG.equals(moduleID.orgName) &&\n+                    (moduleID.nameComps.size() == 2 && Names.LANG.equals(moduleID.nameComps.get(0)))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b27c6b6f05c2d99e8331ed10c57b1f057932edad"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTY0ODczMg==", "bodyText": "Good point. Don't think there's a restriction on that. But it's also unlikely that there'd be multiple components because a lang library usually corresponds to a basic type (which is typically a single word).", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26805#discussion_r519648732", "createdAt": "2020-11-09T09:03:39Z", "author": {"login": "pubudu91"}, "path": "compiler/ballerina-lang/src/main/java/io/ballerina/compiler/api/impl/LangLibrary.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.ballerina.compiler.api.impl;\n+\n+import io.ballerina.compiler.api.symbols.FunctionSymbol;\n+import io.ballerina.compiler.api.symbols.TypeDescKind;\n+import org.ballerinalang.model.elements.PackageID;\n+import org.ballerinalang.model.symbols.SymbolKind;\n+import org.wso2.ballerinalang.compiler.semantics.model.Scope;\n+import org.wso2.ballerinalang.compiler.semantics.model.SymbolEnv;\n+import org.wso2.ballerinalang.compiler.semantics.model.SymbolTable;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BInvokableSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BPackageSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.Symbols;\n+import org.wso2.ballerinalang.compiler.util.CompilerContext;\n+import org.wso2.ballerinalang.compiler.util.Name;\n+import org.wso2.ballerinalang.compiler.util.Names;\n+import org.wso2.ballerinalang.util.Flags;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.ARRAY;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.BOOLEAN;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.DECIMAL;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.ERROR;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.FLOAT;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.FUTURE;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.INT;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.MAP;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.OBJECT;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.STREAM;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.STRING;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.TABLE;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.TYPEDESC;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.XML;\n+\n+\n+/**\n+ * A class to hold the lang library function info required for types.\n+ *\n+ * @since 2.0.0\n+ */\n+public class LangLibrary {\n+\n+    private static final CompilerContext.Key<LangLibrary> LANG_LIB_KEY = new CompilerContext.Key<>();\n+    private static final String LANG_VALUE = \"value\";\n+\n+    private final Map<String, Map<String, BInvokableSymbol>> langLibMethods;\n+    private final Map<String, List<FunctionSymbol>> wrappedLangLibMethods;\n+    private final SymbolFactory symbolFactory;\n+\n+    private LangLibrary(CompilerContext context) {\n+        context.put(LANG_LIB_KEY, this);\n+\n+        symbolFactory = SymbolFactory.getInstance(context);\n+        SymbolTable symbolTable = SymbolTable.getInstance(context);\n+        Map<String, BPackageSymbol> langLibs = new HashMap<>();\n+        wrappedLangLibMethods = new HashMap<>();\n+\n+        for (Map.Entry<BPackageSymbol, SymbolEnv> entry : symbolTable.pkgEnvMap.entrySet()) {\n+            BPackageSymbol module = entry.getKey();\n+            PackageID moduleID = module.pkgID;\n+\n+            if (Names.BALLERINA_ORG.equals(moduleID.orgName) &&\n+                    (moduleID.nameComps.size() == 2 && Names.LANG.equals(moduleID.nameComps.get(0)))) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTUzMDAxNw=="}, "originalCommit": {"oid": "b27c6b6f05c2d99e8331ed10c57b1f057932edad"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1Njc4NDIwOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/io/ballerina/compiler/api/impl/LangLibrary.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQwMzoxNjo1OVrOHvduYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQwMzoxNjo1OVrOHvduYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTUzMjEyOA==", "bodyText": "We can simplify the cases and the returns here. What if get the common cases to the bottom where we can directly call getName() over the typeDescKind", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26805#discussion_r519532128", "createdAt": "2020-11-09T03:16:59Z", "author": {"login": "nadeeshaan"}, "path": "compiler/ballerina-lang/src/main/java/io/ballerina/compiler/api/impl/LangLibrary.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.ballerina.compiler.api.impl;\n+\n+import io.ballerina.compiler.api.symbols.FunctionSymbol;\n+import io.ballerina.compiler.api.symbols.TypeDescKind;\n+import org.ballerinalang.model.elements.PackageID;\n+import org.ballerinalang.model.symbols.SymbolKind;\n+import org.wso2.ballerinalang.compiler.semantics.model.Scope;\n+import org.wso2.ballerinalang.compiler.semantics.model.SymbolEnv;\n+import org.wso2.ballerinalang.compiler.semantics.model.SymbolTable;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BInvokableSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BPackageSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.Symbols;\n+import org.wso2.ballerinalang.compiler.util.CompilerContext;\n+import org.wso2.ballerinalang.compiler.util.Name;\n+import org.wso2.ballerinalang.compiler.util.Names;\n+import org.wso2.ballerinalang.util.Flags;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.ARRAY;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.BOOLEAN;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.DECIMAL;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.ERROR;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.FLOAT;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.FUTURE;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.INT;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.MAP;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.OBJECT;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.STREAM;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.STRING;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.TABLE;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.TYPEDESC;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.XML;\n+\n+\n+/**\n+ * A class to hold the lang library function info required for types.\n+ *\n+ * @since 2.0.0\n+ */\n+public class LangLibrary {\n+\n+    private static final CompilerContext.Key<LangLibrary> LANG_LIB_KEY = new CompilerContext.Key<>();\n+    private static final String LANG_VALUE = \"value\";\n+\n+    private final Map<String, Map<String, BInvokableSymbol>> langLibMethods;\n+    private final Map<String, List<FunctionSymbol>> wrappedLangLibMethods;\n+    private final SymbolFactory symbolFactory;\n+\n+    private LangLibrary(CompilerContext context) {\n+        context.put(LANG_LIB_KEY, this);\n+\n+        symbolFactory = SymbolFactory.getInstance(context);\n+        SymbolTable symbolTable = SymbolTable.getInstance(context);\n+        Map<String, BPackageSymbol> langLibs = new HashMap<>();\n+        wrappedLangLibMethods = new HashMap<>();\n+\n+        for (Map.Entry<BPackageSymbol, SymbolEnv> entry : symbolTable.pkgEnvMap.entrySet()) {\n+            BPackageSymbol module = entry.getKey();\n+            PackageID moduleID = module.pkgID;\n+\n+            if (Names.BALLERINA_ORG.equals(moduleID.orgName) &&\n+                    (moduleID.nameComps.size() == 2 && Names.LANG.equals(moduleID.nameComps.get(0)))) {\n+                langLibs.put(moduleID.nameComps.get(1).value, module);\n+            }\n+        }\n+\n+        langLibMethods = getLangLibMethods(langLibs);\n+    }\n+\n+    public static LangLibrary getInstance(CompilerContext context) {\n+        LangLibrary langLib = context.get(LANG_LIB_KEY);\n+        if (langLib == null) {\n+            langLib = new LangLibrary(context);\n+        }\n+\n+        return langLib;\n+    }\n+\n+    /**\n+     * Given a type descriptor kind, return the list of lang library functions that can be called using a method call\n+     * expr, on an expression of that type.\n+     *\n+     * @param typeDescKind A type descriptor kind\n+     * @return The associated list of lang library functions\n+     */\n+    public List<FunctionSymbol> getMethods(TypeDescKind typeDescKind) {\n+        String langLibName = getAssociatedLangLibName(typeDescKind);\n+\n+        if (wrappedLangLibMethods.containsKey(langLibName)) {\n+            return wrappedLangLibMethods.get(langLibName);\n+        }\n+\n+        Map<String, BInvokableSymbol> methods = langLibMethods.get(langLibName);\n+\n+        List<FunctionSymbol> wrappedMethods = new ArrayList<>();\n+        wrappedLangLibMethods.put(langLibName, wrappedMethods);\n+        populateMethodList(wrappedMethods, methods);\n+\n+        // Add the common functions in lang.value to types which have an associated lang library.\n+        if (!LANG_VALUE.equals(langLibName)) {\n+            populateMethodList(wrappedMethods, langLibMethods.get(LANG_VALUE));\n+        }\n+\n+        return wrappedMethods;\n+    }\n+\n+    // Private Methods\n+\n+    private void populateMethodList(List<FunctionSymbol> list, Map<String, BInvokableSymbol> langLib) {\n+        for (Map.Entry<String, BInvokableSymbol> entry : langLib.entrySet()) {\n+            FunctionSymbol method = symbolFactory.createFunctionSymbol(entry.getValue(), entry.getKey());\n+            list.add(method);\n+        }\n+    }\n+\n+    private String getAssociatedLangLibName(TypeDescKind typeDescKind) {\n+        switch (typeDescKind) {\n+            case INT:\n+            case BYTE:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b27c6b6f05c2d99e8331ed10c57b1f057932edad"}, "originalPosition": 142}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3101, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}