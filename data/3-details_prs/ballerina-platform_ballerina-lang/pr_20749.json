{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY3Mzg1MDE5", "number": 20749, "title": "Fill-in missing values by list constructor", "bodyText": "Purpose\nFixes #20721\nApproach\nChanged explicit array size and list constructor size mismatch check by loosening it to only to error out scenarios where the list constructor is trying to create an array larger than given explicit array length.\nAdded fill value check to test if the array is created using a type which has a valid fill value\nSamples\nCode Snippet\n    int[4] arr = [3, 1];\n    io:println(\"arr : \", arr);\n    arr[3] = 30;\n    io:println(\"arr : \", arr)\nOutput:\n    arr : 3 1 0 0\n    arr : 3 1 0 30\n\nRemarks\nToDo\n\n boolean / int / float / decimal / string/ byte arrays\n any\n anydata\n unions\n tuples\n records\n Singleton array\n Object array  - Issue #20983\n json array\n xml arrays\n\nCheck List\n\n Read the Contributing Guide\n Updated Change Log\n Checked Tooling Support (#)\n Added necessary tests\n\n Unit Tests\n Spec Conformance Tests\n Integration Tests\n Ballerina By Example Tests\n\n\n Increased Test Coverage\n Added necessary documentation\n\n API documentation\n Module documentation in Module.md files\n Ballerina By Examples", "createdAt": "2020-01-27T09:16:11Z", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749", "merged": true, "mergeCommit": {"oid": "99c5c0ab8ff5ec7ef6799621267e76eff3b784a5"}, "closed": true, "closedAt": "2020-02-26T06:21:08Z", "author": {"login": "KRVPerera"}, "timelineItems": {"totalCount": 71, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb-hRKlgBqjI5ODI5NTU2NzE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcIAnJTAFqTM2NDYyNDQwMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2352207a62e522dc2e601febbe3aad398bf8a62f", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2352207a62e522dc2e601febbe3aad398bf8a62f", "committedDate": "2020-01-27T12:17:01Z", "message": "Add more test cases to test auto fill in list ctor"}, "afterCommit": {"oid": "89204061f107109dd671044ca4b098913d14df03", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/89204061f107109dd671044ca4b098913d14df03", "committedDate": "2020-01-27T18:43:26Z", "message": "WIP: Fill-in missing values by list constructor\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ad17b8e2fb05dbe958f86698ccc739d89e260c21", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/ad17b8e2fb05dbe958f86698ccc739d89e260c21", "committedDate": "2020-01-28T04:25:12Z", "message": "Add XML array test with list ctor"}, "afterCommit": {"oid": "c9d74b4a73ccd6cfad0d7783f6a02b9ecede6535", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c9d74b4a73ccd6cfad0d7783f6a02b9ecede6535", "committedDate": "2020-01-28T06:09:52Z", "message": "Add XML array test with list ctor"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d7a3a038ed441ab944e5117b05195a1dd4786789", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/d7a3a038ed441ab944e5117b05195a1dd4786789", "committedDate": "2020-01-28T10:26:06Z", "message": "Fix infinite loop in new test case\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>"}, "afterCommit": {"oid": "ca163139d84d3f88a0c677f8533a7f92b938e8f6", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/ca163139d84d3f88a0c677f8533a7f92b938e8f6", "committedDate": "2020-01-28T10:27:58Z", "message": "Fill-in missing values by list constructor\n\nRemoved explicit check in list constructor length to same length as the\narray definition. This strict check is loosened now to only check if\nlist constructor is creating a larger array than array definition. Test\ncases are added to test array creation in various data types.\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "bf7bcfdfc2cde0f80d23067b2bce1aed3799b02a", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/bf7bcfdfc2cde0f80d23067b2bce1aed3799b02a", "committedDate": "2020-01-28T11:00:20Z", "message": "Fix syntax error in unit-test case\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>"}, "afterCommit": {"oid": "bfea2e6ed3c01bef9d1ac8b0c18f1f469b872050", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/bfea2e6ed3c01bef9d1ac8b0c18f1f469b872050", "committedDate": "2020-01-28T11:03:32Z", "message": "Fill-in missing values by list constructor\n\nRemoved explicit check in list constructor length to same length as the\narray definition. This strict check is loosened now to only check if\nlist constructor is creating a larger array than array definition. Test\ncases are added to test array creation in various data types.\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ5NDg4MTI4", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#pullrequestreview-349488128", "createdAt": "2020-01-28T15:53:23Z", "commit": {"oid": "bfea2e6ed3c01bef9d1ac8b0c18f1f469b872050"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQxNTo1MzoyM1rOFiqWXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQxNjowNjo1MlrOFiq5BA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTg4OTc1OQ==", "bodyText": "Shall we improve formatting?\n                    dlog.error(listConstructor.pos, DiagnosticCode.MISMATCHING_ARRAY_LITERAL_VALUES, \n                               arrayType.size, listConstructor.exprs.size());", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r371889759", "createdAt": "2020-01-28T15:53:23Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -609,10 +609,14 @@ public void visit(BLangListConstructorExpr listConstructor) {\n             if (arrayType.state == BArrayState.OPEN_SEALED) {\n                 arrayType.size = listConstructor.exprs.size();\n                 arrayType.state = BArrayState.CLOSED_SEALED;\n-            } else if (arrayType.state != BArrayState.UNSEALED && arrayType.size != listConstructor.exprs.size()) {\n-                dlog.error(listConstructor.pos,\n-                        DiagnosticCode.MISMATCHING_ARRAY_LITERAL_VALUES, arrayType.size, listConstructor.exprs.size());\n-                return;\n+            } else if ((arrayType.state != BArrayState.UNSEALED) && (arrayType.size != listConstructor.exprs.size())) {\n+                if (arrayType.size < listConstructor.exprs.size()) {\n+                    dlog.error(listConstructor.pos,\n+                            DiagnosticCode.MISMATCHING_ARRAY_LITERAL_VALUES, arrayType.size, listConstructor.exprs.size\n+                            ());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bfea2e6ed3c01bef9d1ac8b0c18f1f469b872050"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTg5Mjg0Mw==", "bodyText": "Shall we write this test to panic on failure instead? e.g., https://github.com/ballerina-platform/ballerina-lang/pull/20679/files#diff-8ef02e76dc938bb93e61ae0143f646cdR1060\nThat way we could remove the Java side assertions.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r371892843", "createdAt": "2020-01-28T15:57:54Z", "author": {"login": "MaryamZi"}, "path": "tests/jballerina-unit-test/src/test/java/org/ballerinalang/test/expressions/listconstructor/ListConstructorExprTest.java", "diffHunk": "@@ -59,4 +59,11 @@ public void diagnosticsTest() {\n                 23, 34);\n         Assert.assertEquals(resultNegative.getErrorCount(), i);\n     }\n+\n+    @Test\n+    public void testListConstructorAutoFillExpr() {\n+        BValue[] returns = BRunUtil.invoke(result, \"testListConstructorAutoFillExpr\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bfea2e6ed3c01bef9d1ac8b0c18f1f469b872050"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTg5MzMxMA==", "bodyText": "We can write these tests also in Ballerina right?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r371893310", "createdAt": "2020-01-28T15:58:38Z", "author": {"login": "MaryamZi"}, "path": "tests/jballerina-unit-test/src/test/java/org/ballerinalang/test/statements/arrays/SealedArrayTest.java", "diffHunk": "@@ -53,6 +53,11 @@ public void testCreateIntegerSealedArray() {\n                 returnValues == null || returnValues.length == 0 || returnValues[0] == null, \"Invalid Return Values.\");\n         Assert.assertEquals(((BInteger) returnValues[0]).intValue(), 5, \"Length didn't match\");\n \n+        returnValues = BRunUtil.invoke(compileResult, \"createIntAutoFilledSealedArray\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bfea2e6ed3c01bef9d1ac8b0c18f1f469b872050"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTg5ODA1NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            }\n          \n          \n            \n            }", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r371898055", "createdAt": "2020-01-28T16:06:00Z", "author": {"login": "MaryamZi"}, "path": "tests/jballerina-unit-test/src/test/resources/test-src/statements/arrays/sealed-array.bal", "diffHunk": "@@ -257,3 +327,13 @@ function testSealedArrayConstrainedMapInvalidIndex (int[3] x1, int index) {\n     x[\"v1\"] = x1;\n     x[\"v1\"][index] = 4;\n }\n+\n+// xml arrays\n+\n+function createXMLAutoFilledSealedArray() returns int {\n+    xml a = xml `<name>Ballerina</name>`;\n+    xml[5] sealedArray = [a, a];\n+    sealedArray[3] = a;\n+    xml test = sealedArray[4];\n+    return sealedArray.length();\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bfea2e6ed3c01bef9d1ac8b0c18f1f469b872050"}, "originalPosition": 167}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTg5ODYyOA==", "bodyText": "Why are we commenting these out instead of removing them?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r371898628", "createdAt": "2020-01-28T16:06:52Z", "author": {"login": "MaryamZi"}, "path": "tests/jballerina-unit-test/src/test/resources/test-src/statements/arrays/sealed-array-semantics-negative.bal", "diffHunk": "@@ -27,7 +27,7 @@ function accessInvalidIndexOfSealedArrayUsingKeyword() returns string {\n }\n \n function initializeInvalidSizedSealedArray() {\n-    boolean[4] sealedArray1 = [true, true, false];\n+    //boolean[4] sealedArray1 = [true, true, false]; // this is valid now", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bfea2e6ed3c01bef9d1ac8b0c18f1f469b872050"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUwMDQ3MDk5", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#pullrequestreview-350047099", "createdAt": "2020-01-29T11:48:05Z", "commit": {"oid": "065350ed95e2194c657525c7bb4c17048337c6ef"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxMTo0ODowNVrOFjFpxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxMTo0ODowNVrOFjFpxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjMzNzA5Mg==", "bodyText": "Add new line at EOF.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r372337092", "createdAt": "2020-01-29T11:48:05Z", "author": {"login": "kalaiyarasiganeshalingam"}, "path": "tests/jballerina-unit-test/src/test/resources/test-src/statements/arrays/sealed-array.bal", "diffHunk": "@@ -257,3 +334,36 @@ function testSealedArrayConstrainedMapInvalidIndex (int[3] x1, int index) {\n     x[\"v1\"] = x1;\n     x[\"v1\"][index] = 4;\n }\n+\n+// xml arrays\n+\n+function createXMLAutoFilledSealedArray() returns int {\n+    xml a = xml `<name>Ballerina</name>`;\n+    xml[5] sealedArray = [a, a];\n+    sealedArray[3] = a;\n+    xml test = sealedArray[4];\n+    return sealedArray.length();\n+}\n+\n+// helper methods\n+\n+function assertArrayLengthPanic(int expected, any[] arr, string message = \"Array length did not match\") {\n+    int actual = arr.length();\n+    if (expected != actual) {\n+        panic error(message + \" Expected : \" + expected.toString() + \" Actual : \" + actual.toString());\n+    }\n+}\n+\n+function assertArrayValuePanic(anydata expected, anydata[] arr, int index,  string message = \"Array value mismatch\") {\n+    anydata actual = arr[index];\n+    if (expected != actual) {\n+        panic error(message + \" Expected : \" + expected.toString() + \" Actual : \" + actual.toString());\n+    }\n+}\n+\n+function isEqualPanic(string expected, any[] arr, string message = \"Not equal\") {\n+    string actual = arr.toString().trim();\n+    if (expected != actual) {\n+        panic error(message + \" Expected : \" + expected + \" Actual : \" + actual);\n+    }\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "065350ed95e2194c657525c7bb4c17048337c6ef"}, "originalPosition": 313}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6f919c74abc8004a285bcb678e4a37a9f2f109cb", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6f919c74abc8004a285bcb678e4a37a9f2f109cb", "committedDate": "2020-01-30T02:45:26Z", "message": "Add EOF line to sealed-array.bal"}, "afterCommit": {"oid": "5fc28b9a058502c6955722be7fdd5144c48f5bf3", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/5fc28b9a058502c6955722be7fdd5144c48f5bf3", "committedDate": "2020-01-30T02:47:38Z", "message": "Fill-in missing values by list constructor\n\nRemoved explicit check in list constructor length to same length as the\narray definition. This strict check is loosened now to only check if\nlist constructor is creating a larger array than array definition. Test\ncases are added to test array creation in various data types.\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3f66346dba8bc8caad3bdcdcd8467f27f42c2132", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3f66346dba8bc8caad3bdcdcd8467f27f42c2132", "committedDate": "2020-02-02T10:19:58Z", "message": "Fix more than 120 char line length"}, "afterCommit": {"oid": "972f0eab1c92d3d4556b71e9cc3e9914297c5483", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/972f0eab1c92d3d4556b71e9cc3e9914297c5483", "committedDate": "2020-02-02T10:20:56Z", "message": "Fix abstract object list construction without error\n\nAbstract object creation through list constructor does not throw error\nand this was fixed and now before we initilize the list we check if the\nunderneath object type is an abstact object type\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c5511b29c0b4e404b49d78ba54544f77ad65f19b", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c5511b29c0b4e404b49d78ba54544f77ad65f19b", "committedDate": "2020-02-03T09:51:12Z", "message": "Add doc comment for FillerUtils.java"}, "afterCommit": {"oid": "b61a710cde422553991fa45d129723eea51f8d7b", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b61a710cde422553991fa45d129723eea51f8d7b", "committedDate": "2020-02-03T09:53:10Z", "message": "Refactor fill value check in compile TypeChecker"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b61a710cde422553991fa45d129723eea51f8d7b", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b61a710cde422553991fa45d129723eea51f8d7b", "committedDate": "2020-02-03T09:53:10Z", "message": "Refactor fill value check in compile TypeChecker"}, "afterCommit": {"oid": "c20cc4b202e4b0ed29bb5ddbcb368a69c02cf573", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c20cc4b202e4b0ed29bb5ddbcb368a69c02cf573", "committedDate": "2020-02-05T07:24:34Z", "message": "Refactor fill value check in compile TypeChecker"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c20cc4b202e4b0ed29bb5ddbcb368a69c02cf573", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c20cc4b202e4b0ed29bb5ddbcb368a69c02cf573", "committedDate": "2020-02-05T07:24:34Z", "message": "Refactor fill value check in compile TypeChecker"}, "afterCommit": {"oid": "26b29b9c62e479a206d8407c2b6e458bf64c111a", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/26b29b9c62e479a206d8407c2b6e458bf64c111a", "committedDate": "2020-02-05T09:54:59Z", "message": "Add union auto fill test cases"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d3774783d05cd9823fca005b410bc2f8d2c10ba8", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/d3774783d05cd9823fca005b410bc2f8d2c10ba8", "committedDate": "2020-02-05T12:18:10Z", "message": "Handle array type for fill value"}, "afterCommit": {"oid": "e78f9a4ee679d83110031e2cba7adf2610ae5918", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e78f9a4ee679d83110031e2cba7adf2610ae5918", "committedDate": "2020-02-06T04:16:19Z", "message": "Handle array type for fill value"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3f65fa153e00035bc2c7ecce6bb09d1ab5d878f7", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3f65fa153e00035bc2c7ecce6bb09d1ab5d878f7", "committedDate": "2020-02-06T11:56:55Z", "message": "Refactor and add utils to Types.java"}, "afterCommit": {"oid": "c6188a57538ce75774c88b14bc47f73fcc3d9aa3", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c6188a57538ce75774c88b14bc47f73fcc3d9aa3", "committedDate": "2020-02-06T15:47:33Z", "message": "Refactor and add utils to Types.java"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ba15e81610c2c42a113270bbca8b50970b9a685c", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/ba15e81610c2c42a113270bbca8b50970b9a685c", "committedDate": "2020-02-07T05:24:13Z", "message": "Add todo note for sealed-array.bal"}, "afterCommit": {"oid": "10d9703486a07ea9bde5047466f1579f195136c5", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/10d9703486a07ea9bde5047466f1579f195136c5", "committedDate": "2020-02-07T05:25:26Z", "message": "Add todo note for sealed-array.bal"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7abf37e27e04dbab6e2023a2e14238f9d4d0caf2", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7abf37e27e04dbab6e2023a2e14238f9d4d0caf2", "committedDate": "2020-02-07T07:57:21Z", "message": "Fix sealed singleton array initialization"}, "afterCommit": {"oid": "0253730d5baffb1fc794d77a4b8ebd88ee0ac176", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/0253730d5baffb1fc794d77a4b8ebd88ee0ac176", "committedDate": "2020-02-07T08:42:45Z", "message": "Test object fillinh"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "dd53167454c687742c4ff66470cdaf445943a5d7", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/dd53167454c687742c4ff66470cdaf445943a5d7", "committedDate": "2020-02-07T10:00:33Z", "message": "Fix build after conclict resolution"}, "afterCommit": {"oid": "bfd7d62ffded201fde0b3a6bad84de44c70a99c7", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/bfd7d62ffded201fde0b3a6bad84de44c70a99c7", "committedDate": "2020-02-08T04:43:57Z", "message": "Fix build after conclict resolution"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "bfd7d62ffded201fde0b3a6bad84de44c70a99c7", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/bfd7d62ffded201fde0b3a6bad84de44c70a99c7", "committedDate": "2020-02-08T04:43:57Z", "message": "Fix build after conclict resolution"}, "afterCommit": {"oid": "319dc5d9cbd357f840f2562ac95bdeb4263a721b", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/319dc5d9cbd357f840f2562ac95bdeb4263a721b", "committedDate": "2020-02-08T04:49:35Z", "message": "Fix sealed singleton array initialization"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d7f7d9895b50fac6f1ea8777c9dc2bc107b6e802", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/d7f7d9895b50fac6f1ea8777c9dc2bc107b6e802", "committedDate": "2020-02-08T07:02:46Z", "message": "Fix incorrect caching of fillvalue check"}, "afterCommit": {"oid": "19b5d638226b05c465049b3027cbe950c49679e3", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/19b5d638226b05c465049b3027cbe950c49679e3", "committedDate": "2020-02-08T07:25:52Z", "message": "Fix incorrect caching of fillvalue check"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2b73ff589091926f46a5b9ca82c3eedb0cefd1b7", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2b73ff589091926f46a5b9ca82c3eedb0cefd1b7", "committedDate": "2020-02-08T08:10:08Z", "message": "Fix compiler error"}, "afterCommit": {"oid": "af33fdd90b72da50f6196405e906ac0359fdbdb8", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/af33fdd90b72da50f6196405e906ac0359fdbdb8", "committedDate": "2020-02-08T16:03:17Z", "message": "Fix sealed singleton array initialization"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "14ed660461442578df396c6c3bb26b9062f823b1", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/14ed660461442578df396c6c3bb26b9062f823b1", "committedDate": "2020-02-09T18:47:13Z", "message": "Fix anydata array fill list-ctor related issues"}, "afterCommit": {"oid": "b14ad7424dd2446f6e2726093d844c71f9ab1024", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b14ad7424dd2446f6e2726093d844c71f9ab1024", "committedDate": "2020-02-10T04:25:38Z", "message": "Fix anydata array fill list-ctor related issues"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "99031665fe92b3d4dfca360fbea50211faf6717f", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/99031665fe92b3d4dfca360fbea50211faf6717f", "committedDate": "2020-02-10T09:34:28Z", "message": "Check fill value before array initilization"}, "afterCommit": {"oid": "5519773712e3c4a1f32511620b19da8d52e96bec", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/5519773712e3c4a1f32511620b19da8d52e96bec", "committedDate": "2020-02-10T16:13:40Z", "message": "Check fill value before array initilization"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5519773712e3c4a1f32511620b19da8d52e96bec", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/5519773712e3c4a1f32511620b19da8d52e96bec", "committedDate": "2020-02-10T16:13:40Z", "message": "Check fill value before array initilization"}, "afterCommit": {"oid": "c003414045f8ef10724fd7f140cf1b3454e7bfeb", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c003414045f8ef10724fd7f140cf1b3454e7bfeb", "committedDate": "2020-02-11T06:19:35Z", "message": "Add BRecord type fill value check"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2NDQ3ODIy", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#pullrequestreview-356447822", "createdAt": "2020-02-11T07:14:20Z", "commit": {"oid": "c003414045f8ef10724fd7f140cf1b3454e7bfeb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQwNzoxNDoyMFrOFn_Bpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQwNzoxNDoyMFrOFn_Bpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ3MTM5OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Copyright (c) 2019, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n          \n          \n            \n             * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r377471398", "createdAt": "2020-02-11T07:14:20Z", "author": {"login": "kalaiyarasiganeshalingam"}, "path": "tests/jballerina-unit-test/src/test/java/org/ballerinalang/test/statements/arrays/ArrayFillTestRuntime.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Copyright (c) 2019, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c003414045f8ef10724fd7f140cf1b3454e7bfeb"}, "originalPosition": 2}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2NDQ4MDIz", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#pullrequestreview-356448023", "createdAt": "2020-02-11T07:15:04Z", "commit": {"oid": "c003414045f8ef10724fd7f140cf1b3454e7bfeb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQwNzoxNTowNVrOFn_CPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQwNzoxNTowNVrOFn_CPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ3MTU0OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * This will handle two types\n          \n          \n            \n                 * This will handle two types.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r377471549", "createdAt": "2020-02-11T07:15:05Z", "author": {"login": "kalaiyarasiganeshalingam"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2537,4 +2563,196 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type == null) {\n+            return true;\n+        }\n+        if (type.tag < TypeTags.RECORD) {\n+            return true;\n+        }\n+        switch (type.tag) {\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+                return false;\n+            }\n+        } else {\n+            if (initFunction.symbol.getReturnType().getKind() == TypeKind.ERROR) {\n+                return false;\n+            }\n+            if (!hasFillerValue(initFunction.symbol.getReturnType())) {\n+                return false;\n+            }\n+            if (!initFunction.symbol.getParameters().stream()\n+                    .allMatch(bVarSymbol -> bVarSymbol.defaultableParam == true)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * This will handle two types", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c003414045f8ef10724fd7f140cf1b3454e7bfeb"}, "originalPosition": 96}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2NDQ4MTky", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#pullrequestreview-356448192", "createdAt": "2020-02-11T07:15:43Z", "commit": {"oid": "c003414045f8ef10724fd7f140cf1b3454e7bfeb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQwNzoxNTo0M1rOFn_CvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQwNzoxNTo0M1rOFn_CvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ3MTY3Nw==", "bodyText": "Remove extra lines", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r377471677", "createdAt": "2020-02-11T07:15:43Z", "author": {"login": "kalaiyarasiganeshalingam"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -4766,4 +4775,6 @@ private boolean isConst(BLangExpression expression) {\n     private Name getCurrentCompUnit(BLangNode node) {\n         return names.fromString(node.pos.getSource().getCompilationUnitName());\n     }\n+\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c003414045f8ef10724fd7f140cf1b3454e7bfeb"}, "originalPosition": 52}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c003414045f8ef10724fd7f140cf1b3454e7bfeb", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c003414045f8ef10724fd7f140cf1b3454e7bfeb", "committedDate": "2020-02-11T06:19:35Z", "message": "Add BRecord type fill value check"}, "afterCommit": {"oid": "4e72db66fcea5682a5011c9f48e9ac2c96076de1", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/4e72db66fcea5682a5011c9f48e9ac2c96076de1", "committedDate": "2020-02-11T07:18:25Z", "message": "Fill only the needed elements in the array"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4e72db66fcea5682a5011c9f48e9ac2c96076de1", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/4e72db66fcea5682a5011c9f48e9ac2c96076de1", "committedDate": "2020-02-11T07:18:25Z", "message": "Fill only the needed elements in the array"}, "afterCommit": {"oid": "1fbd4be112257964d55d15afde5dd462dca84696", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1fbd4be112257964d55d15afde5dd462dca84696", "committedDate": "2020-02-11T07:51:26Z", "message": "Fill only the needed elements in the array"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1fbd4be112257964d55d15afde5dd462dca84696", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1fbd4be112257964d55d15afde5dd462dca84696", "committedDate": "2020-02-11T07:51:26Z", "message": "Fill only the needed elements in the array"}, "afterCommit": {"oid": "f58c8c21da6ba8cb86457d3e7c52e863a15a3b68", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f58c8c21da6ba8cb86457d3e7c52e863a15a3b68", "committedDate": "2020-02-11T08:39:27Z", "message": "Add list-expr filler value check at compile time\n\nWhen we create a array of size x with list-expr if the user does not\nprovide x number of elements but some y (<x) in list-expr compiler\nneeds to auto fill x-y number of elements in the array\n\nPrevious check to prevent this when there is a size mismatch in\nlist-expr and array size (x != y) is removed and additional fill value\ncheck is added\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2NDg3ODIz", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#pullrequestreview-356487823", "createdAt": "2020-02-11T08:53:15Z", "commit": {"oid": "f58c8c21da6ba8cb86457d3e7c52e863a15a3b68"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQwODo1MzoxNVrOFoA-Cg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQwODo1MzoxNVrOFoA-Cg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzUwMzI0Mg==", "bodyText": "If we move this logic to a function, we can improve the readability of the code. WDYT?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r377503242", "createdAt": "2020-02-11T08:53:15Z", "author": {"login": "dulvinw"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -619,10 +619,18 @@ public void visit(BLangListConstructorExpr listConstructor) {\n             if (arrayType.state == BArrayState.OPEN_SEALED) {\n                 arrayType.size = listConstructor.exprs.size();\n                 arrayType.state = BArrayState.CLOSED_SEALED;\n-            } else if (arrayType.state != BArrayState.UNSEALED && arrayType.size != listConstructor.exprs.size()) {\n-                dlog.error(listConstructor.pos,\n-                        DiagnosticCode.MISMATCHING_ARRAY_LITERAL_VALUES, arrayType.size, listConstructor.exprs.size());\n-                return;\n+            } else if ((arrayType.state != BArrayState.UNSEALED) && (arrayType.size != listConstructor.exprs.size())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f58c8c21da6ba8cb86457d3e7c52e863a15a3b68"}, "originalPosition": 24}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "36815d9eb481e296884a261f2c9e520e5fee180d", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/36815d9eb481e296884a261f2c9e520e5fee180d", "committedDate": "2020-02-11T09:07:34Z", "message": "Change license header to 2020\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>"}, "afterCommit": {"oid": "9f4bd3783fb1baa13f66660a4e9a7448e5ffab45", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/9f4bd3783fb1baa13f66660a4e9a7448e5ffab45", "committedDate": "2020-02-11T10:12:53Z", "message": "Fix style"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9f4bd3783fb1baa13f66660a4e9a7448e5ffab45", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/9f4bd3783fb1baa13f66660a4e9a7448e5ffab45", "committedDate": "2020-02-11T10:12:53Z", "message": "Fix style"}, "afterCommit": {"oid": "d7ffca3f2535a897d0e44911a0f4d7bff9869799", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/d7ffca3f2535a897d0e44911a0f4d7bff9869799", "committedDate": "2020-02-11T10:36:13Z", "message": "Change license header to 2020\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d7ffca3f2535a897d0e44911a0f4d7bff9869799", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/d7ffca3f2535a897d0e44911a0f4d7bff9869799", "committedDate": "2020-02-11T10:36:13Z", "message": "Change license header to 2020\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>"}, "afterCommit": {"oid": "8c1d8da35d38db84786c9c1f2d6c088fc1779caa", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/8c1d8da35d38db84786c9c1f2d6c088fc1779caa", "committedDate": "2020-02-11T19:56:08Z", "message": "Change license header to 2020\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU1NjI1NDA3", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#pullrequestreview-355625407", "createdAt": "2020-02-09T18:49:50Z", "commit": {"oid": "14ed660461442578df396c6c3bb26b9062f823b1"}, "state": "COMMENTED", "comments": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wOVQxODo0OTo1MFrOFnWaUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwNToxODoyNlrOFoiBcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjgwNTk2OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Optional<Boolean> hasFillerValue = Optional.empty();;\n          \n          \n            \n                private Optional<Boolean> hasFillerValue = Optional.empty();", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r376805968", "createdAt": "2020-02-09T18:49:50Z", "author": {"login": "MaryamZi"}, "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/values/ArrayValueImpl.java", "diffHunk": "@@ -71,6 +72,8 @@\n     private String[] stringValues;\n     private BString[] bStringValues;\n \n+    private Optional<Boolean> hasFillerValue = Optional.empty();;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14ed660461442578df396c6c3bb26b9062f823b1"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjkzNTk1NQ==", "bodyText": "Not due to this changes but IIUC, if this method gets called we've been initializing the array to the default size even if the array is a closed, fixed-length one? Shouldn't we only use the default if there is no explicit size?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r376935955", "createdAt": "2020-02-10T09:07:49Z", "author": {"login": "MaryamZi"}, "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/values/ArrayValueImpl.java", "diffHunk": "@@ -130,56 +133,60 @@ public ArrayValueImpl(BArrayType type) {\n         this.arrayType = type;\n         BArrayType arrayType = (BArrayType) type;\n         this.elementType = arrayType.getElementType();\n+        initArrayValues(elementType, false);\n         if (arrayType.getState() == ArrayState.CLOSED_SEALED) {\n             this.size = maxSize = arrayType.getSize();\n         }\n-        initArrayValues(this.elementType, false);\n     }\n \n     private void initArrayValues(BType elementType, boolean useBString) {\n+        int initialArraySize = Math.max(DEFAULT_ARRAY_SIZE, arrayType.getSize());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6a1ded361a9c36677290e97cd4a3ad1610dc21f1"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjkzOTA2Nw==", "bodyText": "Not sure if this is the correct error? This just says \"invalid usage of list constructor with type 'T'\" right? IMO, we should say something that implies there's no filler value and there's a size mismatch.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r376939067", "createdAt": "2020-02-10T09:14:37Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -619,16 +620,25 @@ public void visit(BLangListConstructorExpr listConstructor) {\n             if (arrayType.state == BArrayState.OPEN_SEALED) {\n                 arrayType.size = listConstructor.exprs.size();\n                 arrayType.state = BArrayState.CLOSED_SEALED;\n-            } else if (arrayType.state != BArrayState.UNSEALED && arrayType.size != listConstructor.exprs.size()) {\n-                dlog.error(listConstructor.pos,\n-                        DiagnosticCode.MISMATCHING_ARRAY_LITERAL_VALUES, arrayType.size, listConstructor.exprs.size());\n-                return;\n+            } else if ((arrayType.state != BArrayState.UNSEALED) && (arrayType.size != listConstructor.exprs.size())) {\n+                if (arrayType.size < listConstructor.exprs.size()) {\n+                    dlog.error(listConstructor.pos,\n+                               DiagnosticCode.MISMATCHING_ARRAY_LITERAL_VALUES, arrayType.size,\n+                               listConstructor.exprs.size());\n+                    return;\n+                }\n+                //TODO: check fillable values\n+                if (!types.hasFillerValue(arrayType.eType)) {\n+                    dlog.error(listConstructor.pos, DiagnosticCode.INVALID_LIST_CONSTRUCTOR, expType);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6a1ded361a9c36677290e97cd4a3ad1610dc21f1"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk0MDQ1MA==", "bodyText": "Shall we add the version?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r376940450", "createdAt": "2020-02-10T09:17:17Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -109,6 +110,31 @@\n     private Names names;\n     private int finiteTypeCount = 0;\n \n+    /**\n+     * Keep default values for basic types in String format.\n+     *", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6a1ded361a9c36677290e97cd4a3ad1610dc21f1"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk0MDgxNw==", "bodyText": "And shall we say filler instead of default?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r376940817", "createdAt": "2020-02-10T09:17:56Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -109,6 +110,31 @@\n     private Names names;\n     private int finiteTypeCount = 0;\n \n+    /**\n+     * Keep default values for basic types in String format.\n+     *", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk0MDQ1MA=="}, "originalCommit": {"oid": "6a1ded361a9c36677290e97cd4a3ad1610dc21f1"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk0MTA2Mw==", "bodyText": "Is type ever null?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r376941063", "createdAt": "2020-02-10T09:18:25Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2537,4 +2563,154 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6a1ded361a9c36677290e97cd4a3ad1610dc21f1"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgzNDQ3OA==", "bodyText": "We only need to check if the return type is not nil right?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r377834478", "createdAt": "2020-02-11T18:59:55Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2537,4 +2563,196 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type == null) {\n+            return true;\n+        }\n+        if (type.tag < TypeTags.RECORD) {\n+            return true;\n+        }\n+        switch (type.tag) {\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+                return false;\n+            }\n+        } else {\n+            if (initFunction.symbol.getReturnType().getKind() == TypeKind.ERROR) {\n+                return false;\n+            }\n+            if (!hasFillerValue(initFunction.symbol.getReturnType())) {\n+                return false;\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d7ffca3f2535a897d0e44911a0f4d7bff9869799"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgzNjQ2Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                .allMatch(bVarSymbol -> bVarSymbol.defaultableParam == true)) {\n          \n          \n            \n                                .allMatch(bVarSymbol -> bVarSymbol.defaultableParam)) {", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r377836466", "createdAt": "2020-02-11T19:03:29Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2537,4 +2563,196 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type == null) {\n+            return true;\n+        }\n+        if (type.tag < TypeTags.RECORD) {\n+            return true;\n+        }\n+        switch (type.tag) {\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+                return false;\n+            }\n+        } else {\n+            if (initFunction.symbol.getReturnType().getKind() == TypeKind.ERROR) {\n+                return false;\n+            }\n+            if (!hasFillerValue(initFunction.symbol.getReturnType())) {\n+                return false;\n+            }\n+            if (!initFunction.symbol.getParameters().stream()\n+                    .allMatch(bVarSymbol -> bVarSymbol.defaultableParam == true)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d7ffca3f2535a897d0e44911a0f4d7bff9869799"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgzNzExOQ==", "bodyText": "Shall we avoid using streams btw?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r377837119", "createdAt": "2020-02-11T19:04:42Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2537,4 +2563,196 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type == null) {\n+            return true;\n+        }\n+        if (type.tag < TypeTags.RECORD) {\n+            return true;\n+        }\n+        switch (type.tag) {\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+                return false;\n+            }\n+        } else {\n+            if (initFunction.symbol.getReturnType().getKind() == TypeKind.ERROR) {\n+                return false;\n+            }\n+            if (!hasFillerValue(initFunction.symbol.getReturnType())) {\n+                return false;\n+            }\n+            if (!initFunction.symbol.getParameters().stream()\n+                    .allMatch(bVarSymbol -> bVarSymbol.defaultableParam == true)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgzNjQ2Ng=="}, "originalCommit": {"oid": "d7ffca3f2535a897d0e44911a0f4d7bff9869799"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg0NTQ5NQ==", "bodyText": "Do we need the null check for value space members? Can the value be null?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r377845495", "createdAt": "2020-02-11T19:19:58Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2537,4 +2563,196 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type == null) {\n+            return true;\n+        }\n+        if (type.tag < TypeTags.RECORD) {\n+            return true;\n+        }\n+        switch (type.tag) {\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+                return false;\n+            }\n+        } else {\n+            if (initFunction.symbol.getReturnType().getKind() == TypeKind.ERROR) {\n+                return false;\n+            }\n+            if (!hasFillerValue(initFunction.symbol.getReturnType())) {\n+                return false;\n+            }\n+            if (!initFunction.symbol.getParameters().stream()\n+                    .allMatch(bVarSymbol -> bVarSymbol.defaultableParam == true)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * This will handle two types.\n+     *  Singleton : As singleton can have one value that value should it self be a valid fill value\n+     *  Union :\n+     *          1. if nil is a member it is the fill values\n+     *          2. else all the values should belong to same type and the default value for that type\n+     *              should be a member of the union\n+     * @param type BFiniteType union or finite\n+     * @return\n+     */\n+    private boolean checkFillerValue(BFiniteType type) {\n+        // For singleton types, that value is the implicit initial value\n+        if (type.valueSpace.size() == 1) {\n+            return true;\n+        }\n+\n+        // is first value null\n+        Iterator iterator = type.valueSpace.iterator();\n+        BLangExpression firstElement = (BLangExpression) iterator.next();\n+        if ((firstElement == null) || (firstElement.type.getKind() == TypeKind.NIL)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d7ffca3f2535a897d0e44911a0f4d7bff9869799"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg0ODY2NA==", "bodyText": "return getDefaultFillValue(expr.type);", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r377848664", "createdAt": "2020-02-11T19:25:42Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2537,4 +2563,196 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type == null) {\n+            return true;\n+        }\n+        if (type.tag < TypeTags.RECORD) {\n+            return true;\n+        }\n+        switch (type.tag) {\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+                return false;\n+            }\n+        } else {\n+            if (initFunction.symbol.getReturnType().getKind() == TypeKind.ERROR) {\n+                return false;\n+            }\n+            if (!hasFillerValue(initFunction.symbol.getReturnType())) {\n+                return false;\n+            }\n+            if (!initFunction.symbol.getParameters().stream()\n+                    .allMatch(bVarSymbol -> bVarSymbol.defaultableParam == true)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * This will handle two types.\n+     *  Singleton : As singleton can have one value that value should it self be a valid fill value\n+     *  Union :\n+     *          1. if nil is a member it is the fill values\n+     *          2. else all the values should belong to same type and the default value for that type\n+     *              should be a member of the union\n+     * @param type BFiniteType union or finite\n+     * @return\n+     */\n+    private boolean checkFillerValue(BFiniteType type) {\n+        // For singleton types, that value is the implicit initial value\n+        if (type.valueSpace.size() == 1) {\n+            return true;\n+        }\n+\n+        // is first value null\n+        Iterator iterator = type.valueSpace.iterator();\n+        BLangExpression firstElement = (BLangExpression) iterator.next();\n+        if ((firstElement == null) || (firstElement.type.getKind() == TypeKind.NIL)) {\n+            return true;\n+        }\n+\n+        boolean allMembersHaveSameType = true;\n+        boolean defaultFillValuePresent = false;\n+\n+        // is first value is a valid fill value\n+        String defaultFillValue = getDefaultFillValue(firstElement);\n+        if (firstElement.toString().equals(defaultFillValue)) {\n+            defaultFillValuePresent = true;\n+        }\n+\n+        while (iterator.hasNext()) {\n+            Object value =  iterator.next();\n+            if (value == null) {\n+                return true;\n+            }\n+\n+            BType valueType = ((BLangExpression) value).type;\n+            if (valueType.getKind() == TypeKind.NIL) {\n+                return true;\n+            }\n+\n+            if (allMembersHaveSameType && !isSameType(valueType, firstElement.type)) {\n+                allMembersHaveSameType = false;\n+            }\n+\n+            if (!defaultFillValuePresent && value.toString().equals(defaultFillValue)) {\n+                defaultFillValuePresent = true;\n+            }\n+        }\n+\n+        if (!allMembersHaveSameType) {\n+            return false;\n+        }\n+\n+        return defaultFillValuePresent;\n+    }\n+\n+    private boolean checkFillerValue(BUnionType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+\n+        Iterator<BType> iterator = type.getMemberTypes().iterator();\n+        BType firstMember = iterator.next();\n+        // is first value is a valid fill value\n+        if (firstMember.getKind() == TypeKind.NIL) {\n+            return true;\n+        }\n+\n+        boolean allMembersHaveSameType = true;\n+        boolean defaultFillValuePresent = false;\n+\n+        // is first value is a valid fill value\n+        String defaultFillValue = getDefaultFillValue(firstMember);\n+        if (firstMember.toString().equals(defaultFillValue)) {\n+            defaultFillValuePresent = true;\n+        }\n+\n+        while (iterator.hasNext()) {\n+\n+            Object value =  iterator.next();\n+            if (value == null) {\n+                return true;\n+            }\n+\n+            if (allMembersHaveSameType && !isSameType(firstMember, iterator.next())) {\n+                allMembersHaveSameType = false;\n+            }\n+\n+            if (!defaultFillValuePresent && value.toString().equals(defaultFillValue)) {\n+                defaultFillValuePresent = true;\n+            }\n+        }\n+\n+        if (!allMembersHaveSameType) {\n+            return false;\n+        }\n+        return defaultFillValuePresent;\n+    }\n+\n+    private boolean checkFillerValue(BRecordType type) {\n+        for (BField field : type.fields) {\n+            if (field.symbol.defaultableParam) {\n+                continue;\n+            }\n+            if (!hasFillerValue(field.type)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private boolean checkFillerValue(BArrayType type) {\n+        return hasFillerValue(type.eType);\n+    }\n+\n+    private String getDefaultFillValue(BLangExpression expr) {\n+        BType type = expr.type;\n+        return getDefaultFillValue(type);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d7ffca3f2535a897d0e44911a0f4d7bff9869799"}, "originalPosition": 215}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODAzOTUwMg==", "bodyText": "Also, instead of this can't our first check be isNullable like for union types before iterating through the value space?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r378039502", "createdAt": "2020-02-12T04:50:18Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2537,4 +2563,196 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type == null) {\n+            return true;\n+        }\n+        if (type.tag < TypeTags.RECORD) {\n+            return true;\n+        }\n+        switch (type.tag) {\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+                return false;\n+            }\n+        } else {\n+            if (initFunction.symbol.getReturnType().getKind() == TypeKind.ERROR) {\n+                return false;\n+            }\n+            if (!hasFillerValue(initFunction.symbol.getReturnType())) {\n+                return false;\n+            }\n+            if (!initFunction.symbol.getParameters().stream()\n+                    .allMatch(bVarSymbol -> bVarSymbol.defaultableParam == true)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * This will handle two types.\n+     *  Singleton : As singleton can have one value that value should it self be a valid fill value\n+     *  Union :\n+     *          1. if nil is a member it is the fill values\n+     *          2. else all the values should belong to same type and the default value for that type\n+     *              should be a member of the union\n+     * @param type BFiniteType union or finite\n+     * @return\n+     */\n+    private boolean checkFillerValue(BFiniteType type) {\n+        // For singleton types, that value is the implicit initial value\n+        if (type.valueSpace.size() == 1) {\n+            return true;\n+        }\n+\n+        // is first value null\n+        Iterator iterator = type.valueSpace.iterator();\n+        BLangExpression firstElement = (BLangExpression) iterator.next();\n+        if ((firstElement == null) || (firstElement.type.getKind() == TypeKind.NIL)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg0NTQ5NQ=="}, "originalCommit": {"oid": "d7ffca3f2535a897d0e44911a0f4d7bff9869799"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA0MTE5MQ==", "bodyText": "Can't we just check !isSameType(valueType, firstElement.type) and return false here?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r378041191", "createdAt": "2020-02-12T04:59:04Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2537,4 +2563,196 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type == null) {\n+            return true;\n+        }\n+        if (type.tag < TypeTags.RECORD) {\n+            return true;\n+        }\n+        switch (type.tag) {\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+                return false;\n+            }\n+        } else {\n+            if (initFunction.symbol.getReturnType().getKind() == TypeKind.ERROR) {\n+                return false;\n+            }\n+            if (!hasFillerValue(initFunction.symbol.getReturnType())) {\n+                return false;\n+            }\n+            if (!initFunction.symbol.getParameters().stream()\n+                    .allMatch(bVarSymbol -> bVarSymbol.defaultableParam == true)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * This will handle two types.\n+     *  Singleton : As singleton can have one value that value should it self be a valid fill value\n+     *  Union :\n+     *          1. if nil is a member it is the fill values\n+     *          2. else all the values should belong to same type and the default value for that type\n+     *              should be a member of the union\n+     * @param type BFiniteType union or finite\n+     * @return\n+     */\n+    private boolean checkFillerValue(BFiniteType type) {\n+        // For singleton types, that value is the implicit initial value\n+        if (type.valueSpace.size() == 1) {\n+            return true;\n+        }\n+\n+        // is first value null\n+        Iterator iterator = type.valueSpace.iterator();\n+        BLangExpression firstElement = (BLangExpression) iterator.next();\n+        if ((firstElement == null) || (firstElement.type.getKind() == TypeKind.NIL)) {\n+            return true;\n+        }\n+\n+        boolean allMembersHaveSameType = true;\n+        boolean defaultFillValuePresent = false;\n+\n+        // is first value is a valid fill value\n+        String defaultFillValue = getDefaultFillValue(firstElement);\n+        if (firstElement.toString().equals(defaultFillValue)) {\n+            defaultFillValuePresent = true;\n+        }\n+\n+        while (iterator.hasNext()) {\n+            Object value =  iterator.next();\n+            if (value == null) {\n+                return true;\n+            }\n+\n+            BType valueType = ((BLangExpression) value).type;\n+            if (valueType.getKind() == TypeKind.NIL) {\n+                return true;\n+            }\n+\n+            if (allMembersHaveSameType && !isSameType(valueType, firstElement.type)) {\n+                allMembersHaveSameType = false;\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c1d8da35d38db84786c9c1f2d6c088fc1779caa"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA0Mjg5MQ==", "bodyText": "If this was true we would have already returned at https://github.com/ballerina-platform/ballerina-lang/pull/20749/files#diff-782094a79e6831ac57a34ad157af49c1R2678 right?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r378042891", "createdAt": "2020-02-12T05:08:10Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2537,4 +2563,196 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type == null) {\n+            return true;\n+        }\n+        if (type.tag < TypeTags.RECORD) {\n+            return true;\n+        }\n+        switch (type.tag) {\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+                return false;\n+            }\n+        } else {\n+            if (initFunction.symbol.getReturnType().getKind() == TypeKind.ERROR) {\n+                return false;\n+            }\n+            if (!hasFillerValue(initFunction.symbol.getReturnType())) {\n+                return false;\n+            }\n+            if (!initFunction.symbol.getParameters().stream()\n+                    .allMatch(bVarSymbol -> bVarSymbol.defaultableParam == true)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * This will handle two types.\n+     *  Singleton : As singleton can have one value that value should it self be a valid fill value\n+     *  Union :\n+     *          1. if nil is a member it is the fill values\n+     *          2. else all the values should belong to same type and the default value for that type\n+     *              should be a member of the union\n+     * @param type BFiniteType union or finite\n+     * @return\n+     */\n+    private boolean checkFillerValue(BFiniteType type) {\n+        // For singleton types, that value is the implicit initial value\n+        if (type.valueSpace.size() == 1) {\n+            return true;\n+        }\n+\n+        // is first value null\n+        Iterator iterator = type.valueSpace.iterator();\n+        BLangExpression firstElement = (BLangExpression) iterator.next();\n+        if ((firstElement == null) || (firstElement.type.getKind() == TypeKind.NIL)) {\n+            return true;\n+        }\n+\n+        boolean allMembersHaveSameType = true;\n+        boolean defaultFillValuePresent = false;\n+\n+        // is first value is a valid fill value\n+        String defaultFillValue = getDefaultFillValue(firstElement);\n+        if (firstElement.toString().equals(defaultFillValue)) {\n+            defaultFillValuePresent = true;\n+        }\n+\n+        while (iterator.hasNext()) {\n+            Object value =  iterator.next();\n+            if (value == null) {\n+                return true;\n+            }\n+\n+            BType valueType = ((BLangExpression) value).type;\n+            if (valueType.getKind() == TypeKind.NIL) {\n+                return true;\n+            }\n+\n+            if (allMembersHaveSameType && !isSameType(valueType, firstElement.type)) {\n+                allMembersHaveSameType = false;\n+            }\n+\n+            if (!defaultFillValuePresent && value.toString().equals(defaultFillValue)) {\n+                defaultFillValuePresent = true;\n+            }\n+        }\n+\n+        if (!allMembersHaveSameType) {\n+            return false;\n+        }\n+\n+        return defaultFillValuePresent;\n+    }\n+\n+    private boolean checkFillerValue(BUnionType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+\n+        Iterator<BType> iterator = type.getMemberTypes().iterator();\n+        BType firstMember = iterator.next();\n+        // is first value is a valid fill value\n+        if (firstMember.getKind() == TypeKind.NIL) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c1d8da35d38db84786c9c1f2d6c088fc1779caa"}, "originalPosition": 162}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA0Mjk2Ng==", "bodyText": "Again, can these be null?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r378042966", "createdAt": "2020-02-12T05:08:38Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2537,4 +2563,196 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type == null) {\n+            return true;\n+        }\n+        if (type.tag < TypeTags.RECORD) {\n+            return true;\n+        }\n+        switch (type.tag) {\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+                return false;\n+            }\n+        } else {\n+            if (initFunction.symbol.getReturnType().getKind() == TypeKind.ERROR) {\n+                return false;\n+            }\n+            if (!hasFillerValue(initFunction.symbol.getReturnType())) {\n+                return false;\n+            }\n+            if (!initFunction.symbol.getParameters().stream()\n+                    .allMatch(bVarSymbol -> bVarSymbol.defaultableParam == true)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * This will handle two types.\n+     *  Singleton : As singleton can have one value that value should it self be a valid fill value\n+     *  Union :\n+     *          1. if nil is a member it is the fill values\n+     *          2. else all the values should belong to same type and the default value for that type\n+     *              should be a member of the union\n+     * @param type BFiniteType union or finite\n+     * @return\n+     */\n+    private boolean checkFillerValue(BFiniteType type) {\n+        // For singleton types, that value is the implicit initial value\n+        if (type.valueSpace.size() == 1) {\n+            return true;\n+        }\n+\n+        // is first value null\n+        Iterator iterator = type.valueSpace.iterator();\n+        BLangExpression firstElement = (BLangExpression) iterator.next();\n+        if ((firstElement == null) || (firstElement.type.getKind() == TypeKind.NIL)) {\n+            return true;\n+        }\n+\n+        boolean allMembersHaveSameType = true;\n+        boolean defaultFillValuePresent = false;\n+\n+        // is first value is a valid fill value\n+        String defaultFillValue = getDefaultFillValue(firstElement);\n+        if (firstElement.toString().equals(defaultFillValue)) {\n+            defaultFillValuePresent = true;\n+        }\n+\n+        while (iterator.hasNext()) {\n+            Object value =  iterator.next();\n+            if (value == null) {\n+                return true;\n+            }\n+\n+            BType valueType = ((BLangExpression) value).type;\n+            if (valueType.getKind() == TypeKind.NIL) {\n+                return true;\n+            }\n+\n+            if (allMembersHaveSameType && !isSameType(valueType, firstElement.type)) {\n+                allMembersHaveSameType = false;\n+            }\n+\n+            if (!defaultFillValuePresent && value.toString().equals(defaultFillValue)) {\n+                defaultFillValuePresent = true;\n+            }\n+        }\n+\n+        if (!allMembersHaveSameType) {\n+            return false;\n+        }\n+\n+        return defaultFillValuePresent;\n+    }\n+\n+    private boolean checkFillerValue(BUnionType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+\n+        Iterator<BType> iterator = type.getMemberTypes().iterator();\n+        BType firstMember = iterator.next();\n+        // is first value is a valid fill value\n+        if (firstMember.getKind() == TypeKind.NIL) {\n+            return true;\n+        }\n+\n+        boolean allMembersHaveSameType = true;\n+        boolean defaultFillValuePresent = false;\n+\n+        // is first value is a valid fill value\n+        String defaultFillValue = getDefaultFillValue(firstMember);\n+        if (firstMember.toString().equals(defaultFillValue)) {\n+            defaultFillValuePresent = true;\n+        }\n+\n+        while (iterator.hasNext()) {\n+\n+            Object value =  iterator.next();\n+            if (value == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c1d8da35d38db84786c9c1f2d6c088fc1779caa"}, "originalPosition": 178}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA0NDM2MQ==", "bodyText": "Is this set for record fields too? IINM, we usually check only a flag.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r378044361", "createdAt": "2020-02-12T05:16:15Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2537,4 +2563,196 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type == null) {\n+            return true;\n+        }\n+        if (type.tag < TypeTags.RECORD) {\n+            return true;\n+        }\n+        switch (type.tag) {\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+                return false;\n+            }\n+        } else {\n+            if (initFunction.symbol.getReturnType().getKind() == TypeKind.ERROR) {\n+                return false;\n+            }\n+            if (!hasFillerValue(initFunction.symbol.getReturnType())) {\n+                return false;\n+            }\n+            if (!initFunction.symbol.getParameters().stream()\n+                    .allMatch(bVarSymbol -> bVarSymbol.defaultableParam == true)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * This will handle two types.\n+     *  Singleton : As singleton can have one value that value should it self be a valid fill value\n+     *  Union :\n+     *          1. if nil is a member it is the fill values\n+     *          2. else all the values should belong to same type and the default value for that type\n+     *              should be a member of the union\n+     * @param type BFiniteType union or finite\n+     * @return\n+     */\n+    private boolean checkFillerValue(BFiniteType type) {\n+        // For singleton types, that value is the implicit initial value\n+        if (type.valueSpace.size() == 1) {\n+            return true;\n+        }\n+\n+        // is first value null\n+        Iterator iterator = type.valueSpace.iterator();\n+        BLangExpression firstElement = (BLangExpression) iterator.next();\n+        if ((firstElement == null) || (firstElement.type.getKind() == TypeKind.NIL)) {\n+            return true;\n+        }\n+\n+        boolean allMembersHaveSameType = true;\n+        boolean defaultFillValuePresent = false;\n+\n+        // is first value is a valid fill value\n+        String defaultFillValue = getDefaultFillValue(firstElement);\n+        if (firstElement.toString().equals(defaultFillValue)) {\n+            defaultFillValuePresent = true;\n+        }\n+\n+        while (iterator.hasNext()) {\n+            Object value =  iterator.next();\n+            if (value == null) {\n+                return true;\n+            }\n+\n+            BType valueType = ((BLangExpression) value).type;\n+            if (valueType.getKind() == TypeKind.NIL) {\n+                return true;\n+            }\n+\n+            if (allMembersHaveSameType && !isSameType(valueType, firstElement.type)) {\n+                allMembersHaveSameType = false;\n+            }\n+\n+            if (!defaultFillValuePresent && value.toString().equals(defaultFillValue)) {\n+                defaultFillValuePresent = true;\n+            }\n+        }\n+\n+        if (!allMembersHaveSameType) {\n+            return false;\n+        }\n+\n+        return defaultFillValuePresent;\n+    }\n+\n+    private boolean checkFillerValue(BUnionType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+\n+        Iterator<BType> iterator = type.getMemberTypes().iterator();\n+        BType firstMember = iterator.next();\n+        // is first value is a valid fill value\n+        if (firstMember.getKind() == TypeKind.NIL) {\n+            return true;\n+        }\n+\n+        boolean allMembersHaveSameType = true;\n+        boolean defaultFillValuePresent = false;\n+\n+        // is first value is a valid fill value\n+        String defaultFillValue = getDefaultFillValue(firstMember);\n+        if (firstMember.toString().equals(defaultFillValue)) {\n+            defaultFillValuePresent = true;\n+        }\n+\n+        while (iterator.hasNext()) {\n+\n+            Object value =  iterator.next();\n+            if (value == null) {\n+                return true;\n+            }\n+\n+            if (allMembersHaveSameType && !isSameType(firstMember, iterator.next())) {\n+                allMembersHaveSameType = false;\n+            }\n+\n+            if (!defaultFillValuePresent && value.toString().equals(defaultFillValue)) {\n+                defaultFillValuePresent = true;\n+            }\n+        }\n+\n+        if (!allMembersHaveSameType) {\n+            return false;\n+        }\n+        return defaultFillValuePresent;\n+    }\n+\n+    private boolean checkFillerValue(BRecordType type) {\n+        for (BField field : type.fields) {\n+            if (field.symbol.defaultableParam) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c1d8da35d38db84786c9c1f2d6c088fc1779caa"}, "originalPosition": 199}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA0NDc4NA==", "bodyText": "IINM, this is not correct. According to the spec, fill member should be done only for lists.\ntype Foo record {\n   string s;\n};\n\nFoo[2] arr = [];\nThis should still fail IMO.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r378044784", "createdAt": "2020-02-12T05:18:26Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2537,4 +2563,196 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type == null) {\n+            return true;\n+        }\n+        if (type.tag < TypeTags.RECORD) {\n+            return true;\n+        }\n+        switch (type.tag) {\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+                return false;\n+            }\n+        } else {\n+            if (initFunction.symbol.getReturnType().getKind() == TypeKind.ERROR) {\n+                return false;\n+            }\n+            if (!hasFillerValue(initFunction.symbol.getReturnType())) {\n+                return false;\n+            }\n+            if (!initFunction.symbol.getParameters().stream()\n+                    .allMatch(bVarSymbol -> bVarSymbol.defaultableParam == true)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * This will handle two types.\n+     *  Singleton : As singleton can have one value that value should it self be a valid fill value\n+     *  Union :\n+     *          1. if nil is a member it is the fill values\n+     *          2. else all the values should belong to same type and the default value for that type\n+     *              should be a member of the union\n+     * @param type BFiniteType union or finite\n+     * @return\n+     */\n+    private boolean checkFillerValue(BFiniteType type) {\n+        // For singleton types, that value is the implicit initial value\n+        if (type.valueSpace.size() == 1) {\n+            return true;\n+        }\n+\n+        // is first value null\n+        Iterator iterator = type.valueSpace.iterator();\n+        BLangExpression firstElement = (BLangExpression) iterator.next();\n+        if ((firstElement == null) || (firstElement.type.getKind() == TypeKind.NIL)) {\n+            return true;\n+        }\n+\n+        boolean allMembersHaveSameType = true;\n+        boolean defaultFillValuePresent = false;\n+\n+        // is first value is a valid fill value\n+        String defaultFillValue = getDefaultFillValue(firstElement);\n+        if (firstElement.toString().equals(defaultFillValue)) {\n+            defaultFillValuePresent = true;\n+        }\n+\n+        while (iterator.hasNext()) {\n+            Object value =  iterator.next();\n+            if (value == null) {\n+                return true;\n+            }\n+\n+            BType valueType = ((BLangExpression) value).type;\n+            if (valueType.getKind() == TypeKind.NIL) {\n+                return true;\n+            }\n+\n+            if (allMembersHaveSameType && !isSameType(valueType, firstElement.type)) {\n+                allMembersHaveSameType = false;\n+            }\n+\n+            if (!defaultFillValuePresent && value.toString().equals(defaultFillValue)) {\n+                defaultFillValuePresent = true;\n+            }\n+        }\n+\n+        if (!allMembersHaveSameType) {\n+            return false;\n+        }\n+\n+        return defaultFillValuePresent;\n+    }\n+\n+    private boolean checkFillerValue(BUnionType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+\n+        Iterator<BType> iterator = type.getMemberTypes().iterator();\n+        BType firstMember = iterator.next();\n+        // is first value is a valid fill value\n+        if (firstMember.getKind() == TypeKind.NIL) {\n+            return true;\n+        }\n+\n+        boolean allMembersHaveSameType = true;\n+        boolean defaultFillValuePresent = false;\n+\n+        // is first value is a valid fill value\n+        String defaultFillValue = getDefaultFillValue(firstMember);\n+        if (firstMember.toString().equals(defaultFillValue)) {\n+            defaultFillValuePresent = true;\n+        }\n+\n+        while (iterator.hasNext()) {\n+\n+            Object value =  iterator.next();\n+            if (value == null) {\n+                return true;\n+            }\n+\n+            if (allMembersHaveSameType && !isSameType(firstMember, iterator.next())) {\n+                allMembersHaveSameType = false;\n+            }\n+\n+            if (!defaultFillValuePresent && value.toString().equals(defaultFillValue)) {\n+                defaultFillValuePresent = true;\n+            }\n+        }\n+\n+        if (!allMembersHaveSameType) {\n+            return false;\n+        }\n+        return defaultFillValuePresent;\n+    }\n+\n+    private boolean checkFillerValue(BRecordType type) {\n+        for (BField field : type.fields) {\n+            if (field.symbol.defaultableParam) {\n+                continue;\n+            }\n+            if (!hasFillerValue(field.type)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c1d8da35d38db84786c9c1f2d6c088fc1779caa"}, "originalPosition": 202}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8c1d8da35d38db84786c9c1f2d6c088fc1779caa", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/8c1d8da35d38db84786c9c1f2d6c088fc1779caa", "committedDate": "2020-02-11T19:56:08Z", "message": "Change license header to 2020\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>"}, "afterCommit": {"oid": "7e45bf2f4e93f2b9cd1ad9615ddb89a52cc12cba", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7e45bf2f4e93f2b9cd1ad9615ddb89a52cc12cba", "committedDate": "2020-02-13T05:45:25Z", "message": "Fix invalid logic"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7e45bf2f4e93f2b9cd1ad9615ddb89a52cc12cba", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7e45bf2f4e93f2b9cd1ad9615ddb89a52cc12cba", "committedDate": "2020-02-13T05:45:25Z", "message": "Fix invalid logic"}, "afterCommit": {"oid": "7b99ac91ded41ae1f8f9b3fdf55cf585c9370b51", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7b99ac91ded41ae1f8f9b3fdf55cf585c9370b51", "committedDate": "2020-02-13T15:29:22Z", "message": "Refactor fill value check for Union type\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "281133b4229e0f9060e438274110f03251e416bb", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/281133b4229e0f9060e438274110f03251e416bb", "committedDate": "2020-02-13T20:30:25Z", "message": "Change error for list-expr usage without filler\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>"}, "afterCommit": {"oid": "5dda7566d1f2b9bf2c0ccfd721319c6a99b40acb", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/5dda7566d1f2b9bf2c0ccfd721319c6a99b40acb", "committedDate": "2020-02-14T04:43:26Z", "message": "Change error for list-expr usage without filler\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0b33c79d503d6e0fff81d409a51000c82411afbb", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/0b33c79d503d6e0fff81d409a51000c82411afbb", "committedDate": "2020-02-14T09:37:15Z", "message": "Fix filler value check logic for Records\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>"}, "afterCommit": {"oid": "f21bca4d1e537732576a0558486343c55dd1def9", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f21bca4d1e537732576a0558486343c55dd1def9", "committedDate": "2020-02-14T09:37:59Z", "message": "Fix filler value check logic for Records\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "041c2d40aa84058bbbb64596ed17f780c1eb7082", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/041c2d40aa84058bbbb64596ed17f780c1eb7082", "committedDate": "2020-02-14T10:38:46Z", "message": "Fix coding style"}, "afterCommit": {"oid": "c3c97829d04a244c24dec385c28f71566407be08", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c3c97829d04a244c24dec385c28f71566407be08", "committedDate": "2020-02-14T10:41:04Z", "message": "Incorporate code quality feedback on code review"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c3c97829d04a244c24dec385c28f71566407be08", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c3c97829d04a244c24dec385c28f71566407be08", "committedDate": "2020-02-14T10:41:04Z", "message": "Incorporate code quality feedback on code review"}, "afterCommit": {"oid": "3d15f2572961cd44fb9146eabfa3b3131e70de7e", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3d15f2572961cd44fb9146eabfa3b3131e70de7e", "committedDate": "2020-02-14T10:43:00Z", "message": "Incorporate feedback on code review\n\nRemove extra null checks. Refacor the logic related to record type\nfilling.  Change the error message for type usage in list-expr without\nvalid filler values. Add a \"nullable\" cache to finitie type."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU5Njc4NTUz", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#pullrequestreview-359678553", "createdAt": "2020-02-17T11:49:35Z", "commit": {"oid": "3d15f2572961cd44fb9146eabfa3b3131e70de7e"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QxMTo0OTozNVrOFqhu9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QxMjozMjozOVrOFqi3uw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDEzNzIwNQ==", "bodyText": "Comments are invalid now?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r380137205", "createdAt": "2020-02-17T11:49:35Z", "author": {"login": "MaryamZi"}, "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/values/ArrayValueImpl.java", "diffHunk": "@@ -842,13 +850,15 @@ protected void rangeCheck(long index, int size) {\n     protected void fillerValueCheck(int index, int size) {\n         // if there has been values added beyond the current index, that means filler values\n         // has already been checked. Therefore no need to check again.\n-        if (this.size >= index) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d15f2572961cd44fb9146eabfa3b3131e70de7e"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE0MzQzMA==", "bodyText": "Shouldn't the getter return an unmodifiable set too?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r380143430", "createdAt": "2020-02-17T12:04:15Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/model/types/BFiniteType.java", "diffHunk": "@@ -37,9 +37,11 @@\n  */\n public class BFiniteType extends BType implements FiniteType {\n \n-    public Set<BLangExpression> valueSpace;\n+    private Set<BLangExpression> valueSpace;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d15f2572961cd44fb9146eabfa3b3131e70de7e"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE0NDg5Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @since 1.1.2\n          \n          \n            \n                 * @since 1.2.0", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r380144896", "createdAt": "2020-02-17T12:07:38Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -109,6 +110,32 @@\n     private Names names;\n     private int finiteTypeCount = 0;\n \n+    /**\n+     * Keep filler value for basic types in String format.\n+     *\n+     * @since 1.1.2", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d15f2572961cd44fb9146eabfa3b3131e70de7e"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE0NzA1NQ==", "bodyText": "This can be\n    return (type.tsymbol.flags & Flags.ABSTRACT) != Flags.ABSTRACT;\nright?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r380147055", "createdAt": "2020-02-17T12:12:46Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2537,4 +2564,166 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type.tag < TypeTags.RECORD) {\n+            return true;\n+        }\n+        switch (type.tag) {\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+                return false;\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d15f2572961cd44fb9146eabfa3b3131e70de7e"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE0NzM1Mg==", "bodyText": "We can then remove this else and move out this block?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r380147352", "createdAt": "2020-02-17T12:13:27Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2537,4 +2564,166 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type.tag < TypeTags.RECORD) {\n+            return true;\n+        }\n+        switch (type.tag) {\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+                return false;\n+            }\n+        } else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d15f2572961cd44fb9146eabfa3b3131e70de7e"}, "originalPosition": 156}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE0Nzk3NQ==", "bodyText": "IINM, this can never be just error. It's either nil or a union with error. Just checking initFunction.symbol.getReturnType().getKind() != TypeKind.NIL should be enough?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r380147975", "createdAt": "2020-02-17T12:14:46Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2537,4 +2564,166 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type.tag < TypeTags.RECORD) {\n+            return true;\n+        }\n+        switch (type.tag) {\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+                return false;\n+            }\n+        } else {\n+            if (initFunction.symbol.getReturnType().getKind() == TypeKind.ERROR) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d15f2572961cd44fb9146eabfa3b3131e70de7e"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE1NDIzNA==", "bodyText": "IMO, we can remove this.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r380154234", "createdAt": "2020-02-17T12:28:54Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2537,4 +2564,166 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type.tag < TypeTags.RECORD) {\n+            return true;\n+        }\n+        switch (type.tag) {\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+                return false;\n+            }\n+        } else {\n+            if (initFunction.symbol.getReturnType().getKind() == TypeKind.ERROR) {\n+                return false;\n+            }\n+            if (initFunction.symbol.getReturnType().getKind() != TypeKind.NIL) {\n+                return false;\n+            }\n+            for (BVarSymbol bVarSymbol : initFunction.symbol.getParameters()) {\n+                if (!bVarSymbol.defaultableParam) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * This will handle two types. Singleton : As singleton can have one value that value should it self be a valid fill\n+     * value Union : 1. if nil is a member it is the fill values 2. else all the values should belong to same type and\n+     * the default value for that type should be a member of the union precondition : value space should have at least\n+     * one element\n+     *\n+     * @param type BFiniteType union or finite\n+     * @return boolean whether type has a valid filler value or not\n+     */\n+    private boolean checkFillerValue(BFiniteType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+\n+        // For singleton types, that value is the implicit initial value\n+        if (type.getValueSpace().size() == 1) {\n+            return true;\n+        }\n+\n+        Iterator iterator = type.getValueSpace().iterator();\n+        if (!iterator.hasNext()) { // sanity check this cannot be\n+            return false;\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d15f2572961cd44fb9146eabfa3b3131e70de7e"}, "originalPosition": 194}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE1NTgzNQ==", "bodyText": "Can we extract out firstElement.type to a variable?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r380155835", "createdAt": "2020-02-17T12:32:39Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2537,4 +2564,166 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type.tag < TypeTags.RECORD) {\n+            return true;\n+        }\n+        switch (type.tag) {\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+                return false;\n+            }\n+        } else {\n+            if (initFunction.symbol.getReturnType().getKind() == TypeKind.ERROR) {\n+                return false;\n+            }\n+            if (initFunction.symbol.getReturnType().getKind() != TypeKind.NIL) {\n+                return false;\n+            }\n+            for (BVarSymbol bVarSymbol : initFunction.symbol.getParameters()) {\n+                if (!bVarSymbol.defaultableParam) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * This will handle two types. Singleton : As singleton can have one value that value should it self be a valid fill\n+     * value Union : 1. if nil is a member it is the fill values 2. else all the values should belong to same type and\n+     * the default value for that type should be a member of the union precondition : value space should have at least\n+     * one element\n+     *\n+     * @param type BFiniteType union or finite\n+     * @return boolean whether type has a valid filler value or not\n+     */\n+    private boolean checkFillerValue(BFiniteType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+\n+        // For singleton types, that value is the implicit initial value\n+        if (type.getValueSpace().size() == 1) {\n+            return true;\n+        }\n+\n+        Iterator iterator = type.getValueSpace().iterator();\n+        if (!iterator.hasNext()) { // sanity check this cannot be\n+            return false;\n+        }\n+        boolean defaultFillValuePresent = false;\n+\n+        BLangExpression firstElement = (BLangExpression) iterator.next();\n+        String defaultFillValue = getDefaultFillValue(firstElement);\n+        if (firstElement.toString().equals(defaultFillValue)) {\n+            defaultFillValuePresent = true;\n+        }\n+\n+        while (iterator.hasNext()) {\n+            Object value =  iterator.next();\n+            BType valueType = ((BLangExpression) value).type;\n+            if (!isSameType(valueType, firstElement.type)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d15f2572961cd44fb9146eabfa3b3131e70de7e"}, "originalPosition": 206}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3d15f2572961cd44fb9146eabfa3b3131e70de7e", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3d15f2572961cd44fb9146eabfa3b3131e70de7e", "committedDate": "2020-02-14T10:43:00Z", "message": "Incorporate feedback on code review\n\nRemove extra null checks. Refacor the logic related to record type\nfilling.  Change the error message for type usage in list-expr without\nvalid filler values. Add a \"nullable\" cache to finitie type."}, "afterCommit": {"oid": "ff0acc05501340c2064c3bb1b3211752955782ad", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/ff0acc05501340c2064c3bb1b3211752955782ad", "committedDate": "2020-02-17T20:56:21Z", "message": "Incorporate code review feedback"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYxNjM3MTAz", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#pullrequestreview-361637103", "createdAt": "2020-02-20T05:12:57Z", "commit": {"oid": "ff0acc05501340c2064c3bb1b3211752955782ad"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwNToxMjo1N1rOFsE4fg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwNToxMjo1N1rOFsE4fg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc2MTY2Mg==", "bodyText": "Can we validate if this works for constants?\nconst ZERO = 0;\n\ntype Foo ZERO|1|2;", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r381761662", "createdAt": "2020-02-20T05:12:57Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2537,4 +2564,160 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type.tag < TypeTags.RECORD) {\n+            return true;\n+        }\n+        switch (type.tag) {\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+            return false;\n+        }\n+\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            return true;\n+        }\n+        if (initFunction.symbol.getReturnType().getKind() != TypeKind.NIL) {\n+            return false;\n+        }\n+\n+        for (BVarSymbol bVarSymbol : initFunction.symbol.getParameters()) {\n+            if (!bVarSymbol.defaultableParam) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * This will handle two types. Singleton : As singleton can have one value that value should it self be a valid fill\n+     * value Union : 1. if nil is a member it is the fill values 2. else all the values should belong to same type and\n+     * the default value for that type should be a member of the union precondition : value space should have at least\n+     * one element\n+     *\n+     * @param type BFiniteType union or finite\n+     * @return boolean whether type has a valid filler value or not\n+     */\n+    private boolean checkFillerValue(BFiniteType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+\n+        // For singleton types, that value is the implicit initial value\n+        if (type.getValueSpace().size() == 1) {\n+            return true;\n+        }\n+\n+        boolean defaultFillValuePresent = false;\n+\n+        Iterator iterator = type.getValueSpace().iterator();\n+        BLangExpression firstElement = (BLangExpression) iterator.next();\n+        BType firstElementType = firstElement.type;\n+        String defaultFillValue = getDefaultFillValue(firstElement);\n+        if (firstElement.toString().equals(defaultFillValue)) {\n+            defaultFillValuePresent = true;\n+        }\n+\n+        while (iterator.hasNext()) {\n+            Object value =  iterator.next();\n+            BType valueType = ((BLangExpression) value).type;\n+            if (!isSameType(valueType, firstElementType)) {\n+                return false;\n+            }\n+            if (!defaultFillValuePresent && value.toString().equals(defaultFillValue)) {\n+                defaultFillValuePresent = true;\n+            }\n+        }\n+        return defaultFillValuePresent;\n+    }\n+\n+    private boolean checkFillerValue(BUnionType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+        Iterator<BType> iterator = type.getMemberTypes().iterator();\n+        BType firstMember = iterator.next();\n+        boolean defaultFillValuePresent = false;\n+\n+        // is first value is a valid fill value\n+        String defaultFillValue = getDefaultFillValue(firstMember);\n+        if (firstMember.toString().equals(defaultFillValue)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff0acc05501340c2064c3bb1b3211752955782ad"}, "originalPosition": 223}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYxNjM3NTQy", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#pullrequestreview-361637542", "createdAt": "2020-02-20T05:14:41Z", "commit": {"oid": "ff0acc05501340c2064c3bb1b3211752955782ad"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwNToxNDo0MVrOFsE7yg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwNToxNDo0MVrOFsE7yg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc2MjUwNg==", "bodyText": "This fillerValueCheck() method is called for each and every add operation. So could this be an overhead?\nSince hasFillerValue needs to be calculated only once for a given type, can we move this flag to the array-type, and have it calculated only once during the initialisation of the type?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r381762506", "createdAt": "2020-02-20T05:14:41Z", "author": {"login": "SupunS"}, "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/values/ArrayValueImpl.java", "diffHunk": "@@ -840,15 +848,15 @@ protected void rangeCheck(long index, int size) {\n \n     @Override\n     protected void fillerValueCheck(int index, int size) {\n-        // if there has been values added beyond the current index, that means filler values\n-        // has already been checked. Therefore no need to check again.\n-        if (this.size >= index) {\n-            return;\n+        if (!hasFillerValue.isPresent()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff0acc05501340c2064c3bb1b3211752955782ad"}, "originalPosition": 97}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYxNjQyODcy", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#pullrequestreview-361642872", "createdAt": "2020-02-20T05:35:35Z", "commit": {"oid": "ff0acc05501340c2064c3bb1b3211752955782ad"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwNTozNTozNVrOFsFjWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwNTo1MDoxMVrOFsF_RQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc3MjYzNQ==", "bodyText": "Wondering if keeping this in the String format is the best approach? Can't we use the value itself and compare, based on the assumption that they will only be used for comparison with either literals or constant refs?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r381772635", "createdAt": "2020-02-20T05:35:35Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2537,4 +2564,160 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type.tag < TypeTags.RECORD) {\n+            return true;\n+        }\n+        switch (type.tag) {\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+            return false;\n+        }\n+\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            return true;\n+        }\n+        if (initFunction.symbol.getReturnType().getKind() != TypeKind.NIL) {\n+            return false;\n+        }\n+\n+        for (BVarSymbol bVarSymbol : initFunction.symbol.getParameters()) {\n+            if (!bVarSymbol.defaultableParam) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * This will handle two types. Singleton : As singleton can have one value that value should it self be a valid fill\n+     * value Union : 1. if nil is a member it is the fill values 2. else all the values should belong to same type and\n+     * the default value for that type should be a member of the union precondition : value space should have at least\n+     * one element\n+     *\n+     * @param type BFiniteType union or finite\n+     * @return boolean whether type has a valid filler value or not\n+     */\n+    private boolean checkFillerValue(BFiniteType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+\n+        // For singleton types, that value is the implicit initial value\n+        if (type.getValueSpace().size() == 1) {\n+            return true;\n+        }\n+\n+        boolean defaultFillValuePresent = false;\n+\n+        Iterator iterator = type.getValueSpace().iterator();\n+        BLangExpression firstElement = (BLangExpression) iterator.next();\n+        BType firstElementType = firstElement.type;\n+        String defaultFillValue = getDefaultFillValue(firstElement);\n+        if (firstElement.toString().equals(defaultFillValue)) {\n+            defaultFillValuePresent = true;\n+        }\n+\n+        while (iterator.hasNext()) {\n+            Object value =  iterator.next();\n+            BType valueType = ((BLangExpression) value).type;\n+            if (!isSameType(valueType, firstElementType)) {\n+                return false;\n+            }\n+            if (!defaultFillValuePresent && value.toString().equals(defaultFillValue)) {\n+                defaultFillValuePresent = true;\n+            }\n+        }\n+        return defaultFillValuePresent;\n+    }\n+\n+    private boolean checkFillerValue(BUnionType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+        Iterator<BType> iterator = type.getMemberTypes().iterator();\n+        BType firstMember = iterator.next();\n+        boolean defaultFillValuePresent = false;\n+\n+        // is first value is a valid fill value\n+        String defaultFillValue = getDefaultFillValue(firstMember);\n+        if (firstMember.toString().equals(defaultFillValue)) {\n+            defaultFillValuePresent = true;\n+        }\n+\n+        while (iterator.hasNext()) {\n+            Object value = iterator.next();\n+\n+            if (!isSameType(firstMember, iterator.next())) {\n+                return false;\n+            }\n+\n+            if (!defaultFillValuePresent && value.toString().equals(defaultFillValue)) {\n+                defaultFillValuePresent = true;\n+            }\n+        }\n+        return defaultFillValuePresent;\n+    }\n+\n+    private boolean checkFillerValue(BRecordType type) {\n+        for (BField field : type.fields) {\n+            if (Symbols.isFlagOn(field.symbol.flags, Flags.OPTIONAL)) {\n+                continue;\n+            }\n+            if (Symbols.isFlagOn(field.symbol.flags, Flags.REQUIRED)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private boolean checkFillerValue(BArrayType type) {\n+        return hasFillerValue(type.eType);\n+    }\n+\n+    private String getDefaultFillValue(BLangExpression expr) {\n+        return getDefaultFillValue(expr.type);\n+    }\n+\n+    private String getDefaultFillValue(BType type) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff0acc05501340c2064c3bb1b3211752955782ad"}, "originalPosition": 261}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc3NTQ3MA==", "bodyText": "Shall we remove the extra lines?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r381775470", "createdAt": "2020-02-20T05:41:18Z", "author": {"login": "MaryamZi"}, "path": "tests/jballerina-unit-test/src/test/java/org/ballerinalang/test/statements/arrays/SealedArrayTest.java", "diffHunk": "@@ -36,177 +36,117 @@\n  */\n public class SealedArrayTest {\n \n-    private CompileResult compileResult, resultNegative, semanticsNegative;\n+    private CompileResult compileResult, resultNegative, semanticsNegative, listExprNegative;\n \n     @BeforeClass\n     public void setup() {\n         compileResult = BCompileUtil.compile(\"test-src/statements/arrays/sealed-array.bal\");\n         resultNegative = BCompileUtil.compile(\"test-src/statements/arrays/sealed-array-negative.bal\");\n+        listExprNegative = BCompileUtil.compile(\"test-src/statements/arrays/sealed_array_listexpr_negative.bal\");\n         semanticsNegative = BCompileUtil.compile(\"test-src/statements/arrays/sealed-array-semantics-negative\" +\n                 \".bal\");\n     }\n \n     @Test\n     public void testCreateIntegerSealedArray() {\n-        BValue[] returnValues = BRunUtil.invoke(compileResult, \"createIntSealedArray\");\n-        Assert.assertFalse(\n-                returnValues == null || returnValues.length == 0 || returnValues[0] == null, \"Invalid Return Values.\");\n-        Assert.assertEquals(((BInteger) returnValues[0]).intValue(), 5, \"Length didn't match\");\n+        BRunUtil.invoke(compileResult, \"createIntSealedArray\");\n \n-        returnValues = BRunUtil.invoke(compileResult, \"createIntSealedArrayWithLabel\");\n-        Assert.assertFalse(\n-                returnValues == null || returnValues.length == 0 || returnValues[0] == null, \"Invalid Return Values.\");\n-        Assert.assertEquals(((BInteger) returnValues[0]).intValue(), 5, \"Length didn't match\");\n+        BRunUtil.invoke(compileResult, \"createIntAutoFilledSealedArray\");\n \n-        returnValues = BRunUtil.invoke(compileResult, \"createIntDefaultSealedArray\");\n-        Assert.assertFalse(\n-                returnValues == null || returnValues.length == 0 || returnValues[0] == null, \"Invalid Return Values.\");\n-        Assert.assertEquals(returnValues[0].stringValue(), \"[0, 0, 0, 0, 0]\", \"Length didn't match\");\n-        Assert.assertEquals(((BInteger) returnValues[1]).intValue(), 5, \"Length didn't match\");\n+        BRunUtil.invoke(compileResult, \"createIntSealedArrayWithLabel\");\n+\n+        BRunUtil.invoke(compileResult, \"createIntDefaultSealedArray\");\n     }\n \n     @Test\n     public void testCreateBooleanSealedArray() {\n-        BValue[] returnValues = BRunUtil.invoke(compileResult, \"createBoolSealedArray\");\n-        Assert.assertFalse(\n-                returnValues == null || returnValues.length == 0 || returnValues[0] == null, \"Invalid Return Values.\");\n-        Assert.assertEquals(((BInteger) returnValues[0]).intValue(), 5, \"Length didn't match\");\n+        BRunUtil.invoke(compileResult, \"createBoolSealedArray\");\n \n-        returnValues = BRunUtil.invoke(compileResult, \"createBoolSealedArrayWithLabel\");\n-        Assert.assertFalse(\n-                returnValues == null || returnValues.length == 0 || returnValues[0] == null, \"Invalid Return Values.\");\n-        Assert.assertEquals(((BInteger) returnValues[0]).intValue(), 5, \"Length didn't match\");\n+        BRunUtil.invoke(compileResult, \"createBoolAutoFilledSealedArray\");\n \n-        returnValues = BRunUtil.invoke(compileResult, \"createBoolDefaultSealedArray\");\n-        Assert.assertFalse(\n-                returnValues == null || returnValues.length == 0 || returnValues[0] == null, \"Invalid Return Values.\");\n-        Assert.assertEquals(returnValues[0].stringValue(),\n-                \"[false, false, false, false, false]\", \"Length didn't match\");\n-        Assert.assertEquals(((BInteger) returnValues[1]).intValue(), 5, \"Length didn't match\");\n+        BRunUtil.invoke(compileResult, \"createBoolSealedArrayWithLabel\");\n+\n+        BRunUtil.invoke(compileResult, \"createBoolDefaultSealedArray\");\n     }\n \n     @Test\n     public void testCreateFloatSealedArray() {\n-        BValue[] returnValues = BRunUtil.invoke(compileResult, \"createFloatSealedArray\");\n-        Assert.assertFalse(\n-                returnValues == null || returnValues.length == 0 || returnValues[0] == null, \"Invalid Return Values.\");\n-        Assert.assertEquals(((BInteger) returnValues[0]).intValue(), 5, \"Length didn't match\");\n+        BRunUtil.invoke(compileResult, \"createFloatSealedArray\");\n \n-        returnValues = BRunUtil.invoke(compileResult, \"createFloatSealedArrayWithLabel\");\n-        Assert.assertFalse(\n-                returnValues == null || returnValues.length == 0 || returnValues[0] == null, \"Invalid Return Values.\");\n-        Assert.assertEquals(((BInteger) returnValues[0]).intValue(), 5, \"Length didn't match\");\n+        BRunUtil.invoke(compileResult, \"createFloatAutoFilledSealedArray\");\n \n-        returnValues = BRunUtil.invoke(compileResult, \"createFloatDefaultSealedArray\");\n-        Assert.assertFalse(\n-                returnValues == null || returnValues.length == 0 || returnValues[0] == null, \"Invalid Return Values.\");\n-        Assert.assertEquals(returnValues[0].stringValue(), \"[0.0, 0.0, 0.0, 0.0, 0.0]\", \"Length didn't match\");\n-        Assert.assertEquals(((BInteger) returnValues[1]).intValue(), 5, \"Length didn't match\");\n+        BRunUtil.invoke(compileResult, \"createFloatSealedArrayWithLabel\");\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff0acc05501340c2064c3bb1b3211752955782ad"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc3NTU5Mw==", "bodyText": "Invalid comment?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r381775593", "createdAt": "2020-02-20T05:41:34Z", "author": {"login": "MaryamZi"}, "path": "tests/jballerina-unit-test/src/test/java/org/ballerinalang/test/statements/arrays/SealedArrayTest.java", "diffHunk": "@@ -282,51 +222,99 @@ public void testNegativeSealedArrays() {\n         BAssertUtil.validateError(resultNegative, 0, \"variable 'sealedArray1' is not initialized\", 19, 5);\n     }\n \n+    // TODO : uncomment", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff0acc05501340c2064c3bb1b3211752955782ad"}, "originalPosition": 231}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc3NTg1NA==", "bodyText": "Can we have these in a single line?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r381775854", "createdAt": "2020-02-20T05:42:08Z", "author": {"login": "MaryamZi"}, "path": "tests/jballerina-unit-test/src/test/java/org/ballerinalang/test/statements/arrays/SealedArrayTest.java", "diffHunk": "@@ -282,51 +222,99 @@ public void testNegativeSealedArrays() {\n         BAssertUtil.validateError(resultNegative, 0, \"variable 'sealedArray1' is not initialized\", 19, 5);\n     }\n \n+    // TODO : uncomment\n+    @Test()\n+    public void testNegativeAutoFillSealedArray() {\n+        Assert.assertEquals(listExprNegative.getErrorCount(), 11);\n+        BAssertUtil.validateError(listExprNegative, 0,\n+                                  \"invalid usage of list constructor: type 'Person[5]' does not have a filler value\",\n+                                  24,\n+                                  19);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff0acc05501340c2064c3bb1b3211752955782ad"}, "originalPosition": 238}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc3OTc4MQ==", "bodyText": "Incorrect version?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r381779781", "createdAt": "2020-02-20T05:50:11Z", "author": {"login": "MaryamZi"}, "path": "tests/jballerina-unit-test/src/test/java/org/ballerinalang/test/statements/arrays/ArrayFillTestRuntime.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.ballerinalang.test.statements.arrays;\n+\n+import org.ballerinalang.test.util.BCompileUtil;\n+import org.ballerinalang.test.util.CompileResult;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+/**\n+ * Test cases for filling the elements of the array with its type's implicit initial value.\n+ *\n+ * @since 1.1.1", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff0acc05501340c2064c3bb1b3211752955782ad"}, "originalPosition": 29}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYxNjQ3NzIw", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#pullrequestreview-361647720", "createdAt": "2020-02-20T05:53:32Z", "commit": {"oid": "ff0acc05501340c2064c3bb1b3211752955782ad"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwNTo1MzozMlrOFsGGMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwNjoyOTozOFrOFsHOJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc4MTU1NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                int [8] arrOfEightInts = [1, 2, 3];\n          \n          \n            \n                int[8] arrOfEightInts = [1, 2, 3];", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r381781555", "createdAt": "2020-02-20T05:53:32Z", "author": {"login": "MaryamZi"}, "path": "tests/jballerina-unit-test/src/test/resources/test-src/expressions/listconstructor/list_constructor.bal", "diffHunk": "@@ -35,3 +35,18 @@ function testListConstructorExpr() returns boolean {\n         && fooArr[0] == \"DDD\"\n         && fooArr[1] == 444;\n }\n+\n+function testListConstructorAutoFillExpr() {\n+    int [8] arrOfEightInts = [1, 2, 3];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff0acc05501340c2064c3bb1b3211752955782ad"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc4MjAyNQ==", "bodyText": "Can't we write these tests in Ballerina itself?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r381782025", "createdAt": "2020-02-20T05:54:23Z", "author": {"login": "MaryamZi"}, "path": "tests/jballerina-unit-test/src/test/resources/test-src/statements/arrays/array-fill-test.bal", "diffHunk": "@@ -70,6 +70,13 @@ function testTupleArrayFill(int index) returns [string, int][] {\n     return ar;\n }\n \n+function testTupleSealedArrayFill(int index) returns [string, int][] {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff0acc05501340c2064c3bb1b3211752955782ad"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc4NTMyOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Person p = {name:\"John\", age:25};\n          \n          \n            \n                Person p = {name: \"John\", age: 25};", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r381785329", "createdAt": "2020-02-20T06:00:57Z", "author": {"login": "MaryamZi"}, "path": "tests/jballerina-unit-test/src/test/resources/test-src/statements/arrays/array-fill-test.bal", "diffHunk": "@@ -150,6 +157,14 @@ function testAnyArrayFill(int index) returns any[] {\n     return ar;\n }\n \n+function testAnySealedArrayFill(int index) returns any[] {\n+    Person p = {name:\"John\", age:25};", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff0acc05501340c2064c3bb1b3211752955782ad"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc4NjI1MQ==", "bodyText": "This is not used?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r381786251", "createdAt": "2020-02-20T06:02:55Z", "author": {"login": "MaryamZi"}, "path": "tests/jballerina-unit-test/src/test/resources/test-src/statements/arrays/array-test.bal", "diffHunk": "@@ -153,3 +153,23 @@ function testGetFromFrozenArray() returns int {\n \n     return -1;\n }\n+\n+type Age object {\n+    public int age;\n+    public function __init(int age) {\n+    \t self.age = age;\n+    }\n+};\n+\n+function testObjectDynamicArrayFilling() {\n+    Age[] y = [];\n+    y[0] = new(5);\n+    y[1] = new(5);\n+}\n+\n+function assertArrayLengthPanic(int expected, any[] arr, string message = \"Array length did not match\") {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff0acc05501340c2064c3bb1b3211752955782ad"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc4NjQ0NA==", "bodyText": "Is this test complete/called?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r381786444", "createdAt": "2020-02-20T06:03:16Z", "author": {"login": "MaryamZi"}, "path": "tests/jballerina-unit-test/src/test/resources/test-src/statements/arrays/array-test.bal", "diffHunk": "@@ -153,3 +153,23 @@ function testGetFromFrozenArray() returns int {\n \n     return -1;\n }\n+\n+type Age object {\n+    public int age;\n+    public function __init(int age) {\n+    \t self.age = age;\n+    }\n+};\n+\n+function testObjectDynamicArrayFilling() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff0acc05501340c2064c3bb1b3211752955782ad"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc5MDk2Mw==", "bodyText": "The names are not quite clear IMO. :)", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r381790963", "createdAt": "2020-02-20T06:12:12Z", "author": {"login": "MaryamZi"}, "path": "tests/jballerina-unit-test/src/test/resources/test-src/statements/arrays/sealed_array_listexpr_negative.bal", "diffHunk": "@@ -0,0 +1,113 @@\n+// Copyright (c) 2020 WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+//\n+// WSO2 Inc. licenses this file to you under the Apache License,\n+// Version 2.0 (the \"License\"); you may not use this file except\n+// in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+type Person abstract object {\n+    public int age;\n+    function getFullName() returns string;\n+};\n+\n+// [0] cannot initialize abstract objects\n+function createAbstractObjectArray() {\n+    Person[5] x = [];\n+    Person p1 = x[2];\n+    p1.age = 20;\n+}\n+\n+// [1] cannot create multi dimensional arrays of abstract objects\n+function createAbstractObjectEmptyArray() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff0acc05501340c2064c3bb1b3211752955782ad"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc5OTk3Mg==", "bodyText": "This shouldn't fail right?\nPerson[5][] means 5 arrays of open Person arrays (Person[])? So for the members, [] is a valid constructor?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r381799972", "createdAt": "2020-02-20T06:29:38Z", "author": {"login": "MaryamZi"}, "path": "tests/jballerina-unit-test/src/test/resources/test-src/statements/arrays/sealed_array_listexpr_negative.bal", "diffHunk": "@@ -0,0 +1,113 @@\n+// Copyright (c) 2020 WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+//\n+// WSO2 Inc. licenses this file to you under the Apache License,\n+// Version 2.0 (the \"License\"); you may not use this file except\n+// in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+type Person abstract object {\n+    public int age;\n+    function getFullName() returns string;\n+};\n+\n+// [0] cannot initialize abstract objects\n+function createAbstractObjectArray() {\n+    Person[5] x = [];\n+    Person p1 = x[2];\n+    p1.age = 20;\n+}\n+\n+// [1] cannot create multi dimensional arrays of abstract objects\n+function createAbstractObjectEmptyArray() {\n+    Person[5][] y = [];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff0acc05501340c2064c3bb1b3211752955782ad"}, "originalPosition": 31}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ff0acc05501340c2064c3bb1b3211752955782ad", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/ff0acc05501340c2064c3bb1b3211752955782ad", "committedDate": "2020-02-17T20:56:21Z", "message": "Incorporate code review feedback"}, "afterCommit": {"oid": "af14271c90a2a56d7fda35b055a4840553985ad9", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/af14271c90a2a56d7fda35b055a4840553985ad9", "committedDate": "2020-02-20T15:43:49Z", "message": "Refactor test cases for list-ctor-expression\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d995d5d7f983dfb2f8d3552cb8c61fe130f699b2", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/d995d5d7f983dfb2f8d3552cb8c61fe130f699b2", "committedDate": "2020-02-20T17:13:11Z", "message": "Enable unused test 'testObjectDynamicArrayFilling'\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>"}, "afterCommit": {"oid": "17f429daf9d5785fbeee7d411c55b2c892bda422", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/17f429daf9d5785fbeee7d411c55b2c892bda422", "committedDate": "2020-02-20T17:15:44Z", "message": "Fix CheckStyle Audit import separation\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyMzk5MTU0", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#pullrequestreview-362399154", "createdAt": "2020-02-21T04:55:12Z", "commit": {"oid": "17f429daf9d5785fbeee7d411c55b2c892bda422"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwNDo1NToxMlrOFsrq_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwNDo1NToxMlrOFsrq_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM5NzE4MQ==", "bodyText": "Do we need to check this here?\nIsn't fillValues always called after fillerValueCheck?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r382397181", "createdAt": "2020-02-21T04:55:12Z", "author": {"login": "MaryamZi"}, "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/values/ArrayValueImpl.java", "diffHunk": "@@ -808,8 +813,9 @@ protected void fillValues(int index) {\n             case TypeTags.BOOLEAN_TAG:\n                 return;\n             default:\n-                Arrays.fill(refValues, size, index, elementType.getZeroValue());\n-\n+                if (arrayType.hasFillerValue()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17f429daf9d5785fbeee7d411c55b2c892bda422"}, "originalPosition": 78}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyNDEwOTIz", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#pullrequestreview-362410923", "createdAt": "2020-02-21T05:46:37Z", "commit": {"oid": "17f429daf9d5785fbeee7d411c55b2c892bda422"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwNTo0NjozN1rOFssSzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwNTo0Njo1OVrOFssTHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQwNzM3Mw==", "bodyText": "We seem to have methods with different namescheckFillerValue, hasFillerValue, etc. across the class for similar checks. Shall we revisit these and group them together?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r382407373", "createdAt": "2020-02-21T05:46:37Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -109,6 +110,35 @@\n     private Names names;\n     private int finiteTypeCount = 0;\n \n+    private boolean checkFillerValue(BUnionType type) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17f429daf9d5785fbeee7d411c55b2c892bda422"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQwNzQ1NA==", "bodyText": "What about when the value space has more than one value but are all of the same type?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r382407454", "createdAt": "2020-02-21T05:46:59Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2553,4 +2583,182 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type.tag < TypeTags.RECORD) {\n+            return true;\n+        }\n+        switch (type.tag) {\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+            return false;\n+        }\n+\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            return true;\n+        }\n+        if (initFunction.symbol.getReturnType().getKind() != TypeKind.NIL) {\n+            return false;\n+        }\n+\n+        for (BVarSymbol bVarSymbol : initFunction.symbol.getParameters()) {\n+            if (!bVarSymbol.defaultableParam) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * This will handle two types. Singleton : As singleton can have one value that value should it self be a valid fill\n+     * value Union : 1. if nil is a member it is the fill values 2. else all the values should belong to same type and\n+     * the default value for that type should be a member of the union precondition : value space should have at least\n+     * one element\n+     *\n+     * @param type BFiniteType union or finite\n+     * @return boolean whether type has a valid filler value or not\n+     */\n+    private boolean checkFillerValue(BFiniteType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+\n+        // For singleton types, that value is the implicit initial value\n+        if (type.getValueSpace().size() == 1) {\n+            return true;\n+        }\n+\n+        boolean defaultFillValuePresent = false;\n+\n+        Iterator iterator = type.getValueSpace().iterator();\n+        BLangExpression firstElement = (BLangExpression) iterator.next();\n+        BType firstElementType = firstElement.type;\n+        String defaultFillValue = getDefaultFillValue(firstElement);\n+        if (defaultFillValue.equals(DefaultValues.UNKNOWN.getValue())) {\n+            return false;\n+        }\n+        if (firstElement.toString().equals(defaultFillValue)) {\n+            defaultFillValuePresent = true;\n+        }\n+\n+        while (iterator.hasNext()) {\n+            Object value = iterator.next();\n+            BType valueType = ((BLangExpression) value).type;\n+            if (!isSameType(valueType, firstElementType)) {\n+                return false;\n+            }\n+            if (!defaultFillValuePresent && value.toString().equals(defaultFillValue)) {\n+                defaultFillValuePresent = true;\n+            }\n+        }\n+        return defaultFillValuePresent;\n+    }\n+\n+    private String getDefaultFillValue(BType type) {\n+        switch(type.getKind()) {\n+            case INT:\n+            case BYTE:\n+                return DefaultValues.INTEGER.getValue();\n+            case STRING:\n+                return DefaultValues.STRING.getValue();\n+            case DECIMAL:\n+            case FLOAT:\n+                return DefaultValues.FLOAT.getValue();\n+            case BOOLEAN:\n+                return DefaultValues.BOOLEAN.getValue();\n+            case NIL:\n+                return DefaultValues.NIL.getValue();\n+            case ERROR:\n+            case TYPEDESC:\n+                return DefaultValues.UNKNOWN.getValue();\n+            default:\n+                if (type instanceof BFiniteType) {\n+                    return getDefaultFillValue((BFiniteType) type);\n+                }\n+                return DefaultValues.UNKNOWN.getValue();\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BRecordType type) {\n+        for (BField field : type.fields) {\n+            if (Symbols.isFlagOn(field.symbol.flags, Flags.OPTIONAL)) {\n+                continue;\n+            }\n+            if (Symbols.isFlagOn(field.symbol.flags, Flags.REQUIRED)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private boolean checkFillerValue(BArrayType type) {\n+        if (type.size == -1) {\n+            return true;\n+        }\n+        return hasFillerValue(type.eType);\n+    }\n+\n+    private String getDefaultFillValue(BLangExpression expr) {\n+        return getDefaultFillValue(expr.type);\n+    }\n+\n+    private String getDefaultFillValue(BFiniteType finiteType) {\n+        if (finiteType.getValueSpace().size() == 1) {\n+            for (BLangExpression valueLiteral : finiteType.getValueSpace()) {\n+                if (!(valueLiteral instanceof BLangLiteral)) {\n+                    return DefaultValues.UNKNOWN.getValue();\n+                }\n+                return valueLiteral.toString();\n+            }\n+        }\n+        return DefaultValues.UNKNOWN.getValue();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17f429daf9d5785fbeee7d411c55b2c892bda422"}, "originalPosition": 276}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzMjQzNDY5", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#pullrequestreview-363243469", "createdAt": "2020-02-24T09:13:25Z", "commit": {"oid": "17f429daf9d5785fbeee7d411c55b2c892bda422"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQwOToxMzoyNlrOFtZbQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQwOToxMzoyNlrOFtZbQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE0NjgxNg==", "bodyText": "isNullable call", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r383146816", "createdAt": "2020-02-24T09:13:26Z", "author": {"login": "KRVPerera"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/model/types/BFiniteType.java", "diffHunk": "@@ -111,4 +114,11 @@ public boolean isAnydata() {\n         this.isAnyData = Optional.of(true);\n         return true;\n     }\n+\n+    public void addValue(BLangExpression value) {\n+        this.valueSpace.add(value);\n+        if (!nullable && (value.type.tag == TypeTags.NIL)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17f429daf9d5785fbeee7d411c55b2c892bda422"}, "originalPosition": 46}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "44c71470244d611e03adcc4f5fec68eccf5669bb", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/44c71470244d611e03adcc4f5fec68eccf5669bb", "committedDate": "2020-02-25T09:50:31Z", "message": "Add list-expr filler value check at compile time\n\nWhen we create a array of size x with list-expr if the user does not\nprovide x number of elements but some y (<x) in list-expr compiler\nneeds to auto fill x-y number of elements in the array\n\nPrevious check to prevent this when there is a size mismatch in\nlist-expr and array size (x != y) is removed and additional fill value\ncheck is added\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5463e66362a78d6e556e803b56f81121f729d195", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/5463e66362a78d6e556e803b56f81121f729d195", "committedDate": "2020-02-25T09:50:31Z", "message": "Add run time support for list-expr auto filling\n\nAfter compile time fill value check is done run time needs to actually\nfill the values. Since previously we were not handling situation at\ncompile time object filling is enforced now at compile time\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "304b6202f2fde0ebc346d1788fd44d51e65d5093", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/304b6202f2fde0ebc346d1788fd44d51e65d5093", "committedDate": "2020-02-25T09:50:32Z", "message": "Fix negative test cases to accept list-expr filling\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "910f7fbd9babe3a83236bdcd0595f7aca1f94de1", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/910f7fbd9babe3a83236bdcd0595f7aca1f94de1", "committedDate": "2020-02-25T09:50:32Z", "message": "Add list-expr auto fill test cases\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6b5a6a9955abd5ec41010933ba5eb3ebaec897e8", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6b5a6a9955abd5ec41010933ba5eb3ebaec897e8", "committedDate": "2020-02-25T09:50:32Z", "message": "Update compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\r\n\r\nCode review suggestion to improve doc comment\n\nCo-Authored-By: kalaiyarasiganeshalingam <ashakalai31@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "159db5d3607b5960f1698dab1ed480b7c0363c72", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/159db5d3607b5960f1698dab1ed480b7c0363c72", "committedDate": "2020-02-25T09:50:32Z", "message": "Change license header to 2020\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5cf86031eacffe34b57eed9c33f94d27a7c6ff14", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/5cf86031eacffe34b57eed9c33f94d27a7c6ff14", "committedDate": "2020-02-25T09:50:32Z", "message": "Incorporate feedback on code review\n\nRemove extra null checks. Refacor the logic related to record type\nfilling.  Change the error message for type usage in list-expr without\nvalid filler values. Add a \"nullable\" cache to finitie type."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cacda240e52e7d7387d6681d50ef74df3e39cd3b", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/cacda240e52e7d7387d6681d50ef74df3e39cd3b", "committedDate": "2020-02-25T09:50:33Z", "message": "Incorporate code review feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a20ba46ac1072a72ea0ff2a761d2595dff440f5d", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a20ba46ac1072a72ea0ff2a761d2595dff440f5d", "committedDate": "2020-02-25T09:50:33Z", "message": "Cache runtime filler value check in BArrayType\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f238554650314bf495aca1e84c4297d07c2eae98", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f238554650314bf495aca1e84c4297d07c2eae98", "committedDate": "2020-02-25T09:50:33Z", "message": "Fix filler value check for unions with constants\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8c19d9e17da81716ef0cb8a4124481f9990367d0", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/8c19d9e17da81716ef0cb8a4124481f9990367d0", "committedDate": "2020-02-25T09:50:33Z", "message": "Remove multi-dim dynamic array filler-value check\n\nThis will not give syntax errors for multidimensional arrays with\ndynamic arrays which does not need filler values. This allow user to\ncreate fixed size (sealed) arrays with abstract objects but with inner\nmost dimension is dynamic array. Run time check will still run to make\nsure dynamic automatic array fill by compiler is not allowed. User must\ngive valid objects at runtime to these arrays.\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "21889df2928eaeab2b33dd7a4548bc69e0eb77c4", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/21889df2928eaeab2b33dd7a4548bc69e0eb77c4", "committedDate": "2020-02-25T09:50:34Z", "message": "Improve filler-value check for BFiniteType\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a6821534b9d61b6259bceca2ca9fc8248d6eb71f", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a6821534b9d61b6259bceca2ca9fc8248d6eb71f", "committedDate": "2020-02-25T09:50:34Z", "message": "Refactor test cases for list-ctor-expression\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1a5426f3a7cd14ef99f007fc7854f43774c836ef", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1a5426f3a7cd14ef99f007fc7854f43774c836ef", "committedDate": "2020-02-25T09:50:34Z", "message": "Fix CheckStyle Audit import separation\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6b960fb1338317fa6be9ad9a37a174568dae87ce", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6b960fb1338317fa6be9ad9a37a174568dae87ce", "committedDate": "2020-02-25T09:47:35Z", "message": "Improve union type filler value check logic\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>"}, "afterCommit": {"oid": "90ccc20df850f617d1f355c1e786ef7ea9d0d9fd", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/90ccc20df850f617d1f355c1e786ef7ea9d0d9fd", "committedDate": "2020-02-25T09:50:34Z", "message": "Improve union type filler value check logic\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "90ccc20df850f617d1f355c1e786ef7ea9d0d9fd", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/90ccc20df850f617d1f355c1e786ef7ea9d0d9fd", "committedDate": "2020-02-25T09:50:34Z", "message": "Improve union type filler value check logic\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>"}, "afterCommit": {"oid": "2d67c3899c76d1080418067c6b3570f40011eb05", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2d67c3899c76d1080418067c6b3570f40011eb05", "committedDate": "2020-02-25T10:18:26Z", "message": "Improve union type filler value check logic\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e493306b2169e6eb276e902de8689b1c2cce1b37", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e493306b2169e6eb276e902de8689b1c2cce1b37", "committedDate": "2020-02-25T10:37:38Z", "message": "Improve union type filler value check logic\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2d67c3899c76d1080418067c6b3570f40011eb05", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2d67c3899c76d1080418067c6b3570f40011eb05", "committedDate": "2020-02-25T10:18:26Z", "message": "Improve union type filler value check logic\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>"}, "afterCommit": {"oid": "e493306b2169e6eb276e902de8689b1c2cce1b37", "author": {"user": {"login": "KRVPerera", "name": "Rukshan Perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e493306b2169e6eb276e902de8689b1c2cce1b37", "committedDate": "2020-02-25T10:37:38Z", "message": "Improve union type filler value check logic\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0NjAyOTE3", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#pullrequestreview-364602917", "createdAt": "2020-02-26T03:30:05Z", "commit": {"oid": "e493306b2169e6eb276e902de8689b1c2cce1b37"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0NjE5OTQ3", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#pullrequestreview-364619947", "createdAt": "2020-02-26T04:43:18Z", "commit": {"oid": "e493306b2169e6eb276e902de8689b1c2cce1b37"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwNDo0MzoxOFrOFueGxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwNDo0MzoxOFrOFueGxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI3MjA3MQ==", "bodyText": "The following should work right?\nconst FOO = \"foo\";\nconst BAR = \"bar\";\n\ntype FooBar FOO|BAR;\n\npublic function main() {\n    (map<FooBar>|map<string>)[2] x = [];\n}\nI guess it won't work with the isValueType check?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r384272071", "createdAt": "2020-02-26T04:43:18Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2553,4 +2565,150 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        switch (type.tag) {\n+            case TypeTags.INT:\n+            case TypeTags.BYTE:\n+            case TypeTags.FLOAT:\n+            case TypeTags.DECIMAL:\n+            case TypeTags.STRING:\n+            case TypeTags.BOOLEAN:\n+            case TypeTags.JSON:\n+            case TypeTags.XML:\n+            case TypeTags.TABLE:\n+            case TypeTags.NIL:\n+            case TypeTags.ANYDATA:\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+            return false;\n+        }\n+\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            return true;\n+        }\n+        if (initFunction.symbol.getReturnType().getKind() != TypeKind.NIL) {\n+            return false;\n+        }\n+\n+        for (BVarSymbol bVarSymbol : initFunction.symbol.getParameters()) {\n+            if (!bVarSymbol.defaultableParam) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * This will handle two types. Singleton : As singleton can have one value that value should it self be a valid fill\n+     * value Union : 1. if nil is a member it is the fill values 2. else all the values should belong to same type and\n+     * the default value for that type should be a member of the union precondition : value space should have at least\n+     * one element\n+     *\n+     * @param type BFiniteType union or finite\n+     * @return boolean whether type has a valid filler value or not\n+     */\n+    private boolean checkFillerValue(BFiniteType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+        if (type.getValueSpace().size() == 1) { // For singleton types, that value is the implicit initial value\n+            return true;\n+        }\n+        Iterator iterator = type.getValueSpace().iterator();\n+        BLangExpression firstElement = (BLangExpression) iterator.next();\n+        boolean defaultFillValuePresent = isImplicitDefaultValue(firstElement);\n+\n+        while (iterator.hasNext()) {\n+            BLangExpression value = (BLangExpression) iterator.next();\n+            if (!isSameType(value.type, firstElement.type)) {\n+                return false;\n+            }\n+            if (!defaultFillValuePresent && isImplicitDefaultValue(value)) {\n+                defaultFillValuePresent = true;\n+            }\n+        }\n+\n+        return defaultFillValuePresent;\n+    }\n+\n+    private boolean checkFillerValue(BUnionType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+        Iterator<BType> iterator = type.getMemberTypes().iterator();\n+        BType firstMember = iterator.next();\n+        while (iterator.hasNext()) {\n+            if (!isSameType(firstMember, iterator.next())) {\n+                return false;\n+            }\n+        }\n+        return isValueType(firstMember) && hasFillerValue(firstMember);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e493306b2169e6eb276e902de8689b1c2cce1b37"}, "originalPosition": 217}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0NjI0NDAz", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#pullrequestreview-364624403", "createdAt": "2020-02-26T05:02:09Z", "commit": {"oid": "e493306b2169e6eb276e902de8689b1c2cce1b37"}, "state": "APPROVED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwNTowMjoxMFrOFueVnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwNToyMTo0M1rOFuelYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI3NTg3MQ==", "bodyText": "How about constant refs?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r384275871", "createdAt": "2020-02-26T05:02:10Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2553,4 +2565,150 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        switch (type.tag) {\n+            case TypeTags.INT:\n+            case TypeTags.BYTE:\n+            case TypeTags.FLOAT:\n+            case TypeTags.DECIMAL:\n+            case TypeTags.STRING:\n+            case TypeTags.BOOLEAN:\n+            case TypeTags.JSON:\n+            case TypeTags.XML:\n+            case TypeTags.TABLE:\n+            case TypeTags.NIL:\n+            case TypeTags.ANYDATA:\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+            return false;\n+        }\n+\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            return true;\n+        }\n+        if (initFunction.symbol.getReturnType().getKind() != TypeKind.NIL) {\n+            return false;\n+        }\n+\n+        for (BVarSymbol bVarSymbol : initFunction.symbol.getParameters()) {\n+            if (!bVarSymbol.defaultableParam) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * This will handle two types. Singleton : As singleton can have one value that value should it self be a valid fill\n+     * value Union : 1. if nil is a member it is the fill values 2. else all the values should belong to same type and\n+     * the default value for that type should be a member of the union precondition : value space should have at least\n+     * one element\n+     *\n+     * @param type BFiniteType union or finite\n+     * @return boolean whether type has a valid filler value or not\n+     */\n+    private boolean checkFillerValue(BFiniteType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+        if (type.getValueSpace().size() == 1) { // For singleton types, that value is the implicit initial value\n+            return true;\n+        }\n+        Iterator iterator = type.getValueSpace().iterator();\n+        BLangExpression firstElement = (BLangExpression) iterator.next();\n+        boolean defaultFillValuePresent = isImplicitDefaultValue(firstElement);\n+\n+        while (iterator.hasNext()) {\n+            BLangExpression value = (BLangExpression) iterator.next();\n+            if (!isSameType(value.type, firstElement.type)) {\n+                return false;\n+            }\n+            if (!defaultFillValuePresent && isImplicitDefaultValue(value)) {\n+                defaultFillValuePresent = true;\n+            }\n+        }\n+\n+        return defaultFillValuePresent;\n+    }\n+\n+    private boolean checkFillerValue(BUnionType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+        Iterator<BType> iterator = type.getMemberTypes().iterator();\n+        BType firstMember = iterator.next();\n+        while (iterator.hasNext()) {\n+            if (!isSameType(firstMember, iterator.next())) {\n+                return false;\n+            }\n+        }\n+        return isValueType(firstMember) && hasFillerValue(firstMember);\n+    }\n+\n+    private boolean isImplicitDefaultValue(BLangExpression expression) {\n+        if ((expression.getKind() == NodeKind.LITERAL) || (expression.getKind() == NodeKind.NUMERIC_LITERAL)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e493306b2169e6eb276e902de8689b1c2cce1b37"}, "originalPosition": 221}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI3NjAxOA==", "bodyText": "Do we need this null check?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r384276018", "createdAt": "2020-02-26T05:03:02Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2553,4 +2565,150 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        switch (type.tag) {\n+            case TypeTags.INT:\n+            case TypeTags.BYTE:\n+            case TypeTags.FLOAT:\n+            case TypeTags.DECIMAL:\n+            case TypeTags.STRING:\n+            case TypeTags.BOOLEAN:\n+            case TypeTags.JSON:\n+            case TypeTags.XML:\n+            case TypeTags.TABLE:\n+            case TypeTags.NIL:\n+            case TypeTags.ANYDATA:\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+            return false;\n+        }\n+\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            return true;\n+        }\n+        if (initFunction.symbol.getReturnType().getKind() != TypeKind.NIL) {\n+            return false;\n+        }\n+\n+        for (BVarSymbol bVarSymbol : initFunction.symbol.getParameters()) {\n+            if (!bVarSymbol.defaultableParam) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * This will handle two types. Singleton : As singleton can have one value that value should it self be a valid fill\n+     * value Union : 1. if nil is a member it is the fill values 2. else all the values should belong to same type and\n+     * the default value for that type should be a member of the union precondition : value space should have at least\n+     * one element\n+     *\n+     * @param type BFiniteType union or finite\n+     * @return boolean whether type has a valid filler value or not\n+     */\n+    private boolean checkFillerValue(BFiniteType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+        if (type.getValueSpace().size() == 1) { // For singleton types, that value is the implicit initial value\n+            return true;\n+        }\n+        Iterator iterator = type.getValueSpace().iterator();\n+        BLangExpression firstElement = (BLangExpression) iterator.next();\n+        boolean defaultFillValuePresent = isImplicitDefaultValue(firstElement);\n+\n+        while (iterator.hasNext()) {\n+            BLangExpression value = (BLangExpression) iterator.next();\n+            if (!isSameType(value.type, firstElement.type)) {\n+                return false;\n+            }\n+            if (!defaultFillValuePresent && isImplicitDefaultValue(value)) {\n+                defaultFillValuePresent = true;\n+            }\n+        }\n+\n+        return defaultFillValuePresent;\n+    }\n+\n+    private boolean checkFillerValue(BUnionType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+        Iterator<BType> iterator = type.getMemberTypes().iterator();\n+        BType firstMember = iterator.next();\n+        while (iterator.hasNext()) {\n+            if (!isSameType(firstMember, iterator.next())) {\n+                return false;\n+            }\n+        }\n+        return isValueType(firstMember) && hasFillerValue(firstMember);\n+    }\n+\n+    private boolean isImplicitDefaultValue(BLangExpression expression) {\n+        if ((expression.getKind() == NodeKind.LITERAL) || (expression.getKind() == NodeKind.NUMERIC_LITERAL)) {\n+            BLangLiteral literalExpression = (BLangLiteral) expression;\n+            BType literalExprType = literalExpression.type;\n+            Object value = literalExpression.getValue();\n+            switch (literalExprType.getKind()) {\n+                case INT:\n+                case BYTE:\n+                    return value.equals(Long.valueOf(0));\n+                case STRING:\n+                    return value == null || value.equals(\"\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e493306b2169e6eb276e902de8689b1c2cce1b37"}, "originalPosition": 230}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI3NjEzOA==", "bodyText": "Shouldn't we check if value is null?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r384276138", "createdAt": "2020-02-26T05:03:31Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2553,4 +2565,150 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        switch (type.tag) {\n+            case TypeTags.INT:\n+            case TypeTags.BYTE:\n+            case TypeTags.FLOAT:\n+            case TypeTags.DECIMAL:\n+            case TypeTags.STRING:\n+            case TypeTags.BOOLEAN:\n+            case TypeTags.JSON:\n+            case TypeTags.XML:\n+            case TypeTags.TABLE:\n+            case TypeTags.NIL:\n+            case TypeTags.ANYDATA:\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+            return false;\n+        }\n+\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            return true;\n+        }\n+        if (initFunction.symbol.getReturnType().getKind() != TypeKind.NIL) {\n+            return false;\n+        }\n+\n+        for (BVarSymbol bVarSymbol : initFunction.symbol.getParameters()) {\n+            if (!bVarSymbol.defaultableParam) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * This will handle two types. Singleton : As singleton can have one value that value should it self be a valid fill\n+     * value Union : 1. if nil is a member it is the fill values 2. else all the values should belong to same type and\n+     * the default value for that type should be a member of the union precondition : value space should have at least\n+     * one element\n+     *\n+     * @param type BFiniteType union or finite\n+     * @return boolean whether type has a valid filler value or not\n+     */\n+    private boolean checkFillerValue(BFiniteType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+        if (type.getValueSpace().size() == 1) { // For singleton types, that value is the implicit initial value\n+            return true;\n+        }\n+        Iterator iterator = type.getValueSpace().iterator();\n+        BLangExpression firstElement = (BLangExpression) iterator.next();\n+        boolean defaultFillValuePresent = isImplicitDefaultValue(firstElement);\n+\n+        while (iterator.hasNext()) {\n+            BLangExpression value = (BLangExpression) iterator.next();\n+            if (!isSameType(value.type, firstElement.type)) {\n+                return false;\n+            }\n+            if (!defaultFillValuePresent && isImplicitDefaultValue(value)) {\n+                defaultFillValuePresent = true;\n+            }\n+        }\n+\n+        return defaultFillValuePresent;\n+    }\n+\n+    private boolean checkFillerValue(BUnionType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+        Iterator<BType> iterator = type.getMemberTypes().iterator();\n+        BType firstMember = iterator.next();\n+        while (iterator.hasNext()) {\n+            if (!isSameType(firstMember, iterator.next())) {\n+                return false;\n+            }\n+        }\n+        return isValueType(firstMember) && hasFillerValue(firstMember);\n+    }\n+\n+    private boolean isImplicitDefaultValue(BLangExpression expression) {\n+        if ((expression.getKind() == NodeKind.LITERAL) || (expression.getKind() == NodeKind.NUMERIC_LITERAL)) {\n+            BLangLiteral literalExpression = (BLangLiteral) expression;\n+            BType literalExprType = literalExpression.type;\n+            Object value = literalExpression.getValue();\n+            switch (literalExprType.getKind()) {\n+                case INT:\n+                case BYTE:\n+                    return value.equals(Long.valueOf(0));\n+                case STRING:\n+                    return value == null || value.equals(\"\");\n+                case DECIMAL:\n+                case FLOAT:\n+                    return value.equals(String.valueOf(0.0));\n+                case BOOLEAN:\n+                    return value.equals(Boolean.valueOf(false));\n+                case NIL:\n+                    return true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e493306b2169e6eb276e902de8689b1c2cce1b37"}, "originalPosition": 237}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI3ODA0OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                assertArrayValuePanic(0, sealedArray, 2);\n          \n          \n            \n                assertArrayValuePanic(0, sealedArray, 3);\n          \n      \n    \n    \n  \n\n?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r384278048", "createdAt": "2020-02-26T05:12:45Z", "author": {"login": "MaryamZi"}, "path": "tests/jballerina-unit-test/src/test/resources/test-src/statements/arrays/sealed-array.bal", "diffHunk": "@@ -16,82 +16,123 @@\n \n // Int Arrays\n \n-function createIntSealedArray() returns int {\n+function createIntSealedArray() {\n     int[5] sealedArray = [2, 15, 200, 1500, 5000];\n-    return sealedArray.length();\n+    assertArrayLengthPanic(5, sealedArray);\n }\n \n-function createIntSealedArrayWithLabel() returns int {\n+function createIntAutoFilledSealedArray() {\n+    int[5] sealedArray = [2];\n+    sealedArray[4] = 2;\n+    assertArrayValuePanic(2, sealedArray, 4);\n+    assertArrayValuePanic(2, sealedArray, 0);\n+    assertArrayValuePanic(0, sealedArray, 1);\n+    assertArrayValuePanic(0, sealedArray, 2);\n+    assertArrayValuePanic(0, sealedArray, 2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e493306b2169e6eb276e902de8689b1c2cce1b37"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI3OTExOA==", "bodyText": "IMO, we should avoid using string representations for equality as much as possible.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r384279118", "createdAt": "2020-02-26T05:17:57Z", "author": {"login": "MaryamZi"}, "path": "tests/jballerina-unit-test/src/test/resources/test-src/statements/arrays/sealed-array.bal", "diffHunk": "@@ -16,82 +16,123 @@\n \n // Int Arrays\n \n-function createIntSealedArray() returns int {\n+function createIntSealedArray() {\n     int[5] sealedArray = [2, 15, 200, 1500, 5000];\n-    return sealedArray.length();\n+    assertArrayLengthPanic(5, sealedArray);\n }\n \n-function createIntSealedArrayWithLabel() returns int {\n+function createIntAutoFilledSealedArray() {\n+    int[5] sealedArray = [2];\n+    sealedArray[4] = 2;\n+    assertArrayValuePanic(2, sealedArray, 4);\n+    assertArrayValuePanic(2, sealedArray, 0);\n+    assertArrayValuePanic(0, sealedArray, 1);\n+    assertArrayValuePanic(0, sealedArray, 2);\n+    assertArrayValuePanic(0, sealedArray, 2);\n+    assertArrayLengthPanic(5, sealedArray);\n+}\n+\n+function createIntSealedArrayWithLabel() {\n     int[*] sealedArray = [2, 15, 200, 1500, 5000];\n-    return sealedArray.length();\n+    assertArrayLengthPanic(5, sealedArray);\n }\n \n-function createIntDefaultSealedArray() returns [int[], int] {\n+function createIntDefaultSealedArray() {\n     int[5] sealedArray = [0, 0, 0, 0, 0];\n-    return [sealedArray, sealedArray.length()];\n+    assertArrayLengthPanic(5, sealedArray);\n+    isEqualPanic(\"0 0 0 0 0\", sealedArray);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e493306b2169e6eb276e902de8689b1c2cce1b37"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI3OTkwNQ==", "bodyText": "Can we also assert the filled values?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r384279905", "createdAt": "2020-02-26T05:21:43Z", "author": {"login": "MaryamZi"}, "path": "tests/jballerina-unit-test/src/test/resources/test-src/statements/arrays/sealed-array.bal", "diffHunk": "@@ -16,82 +16,123 @@\n \n // Int Arrays\n \n-function createIntSealedArray() returns int {\n+function createIntSealedArray() {\n     int[5] sealedArray = [2, 15, 200, 1500, 5000];\n-    return sealedArray.length();\n+    assertArrayLengthPanic(5, sealedArray);\n }\n \n-function createIntSealedArrayWithLabel() returns int {\n+function createIntAutoFilledSealedArray() {\n+    int[5] sealedArray = [2];\n+    sealedArray[4] = 2;\n+    assertArrayValuePanic(2, sealedArray, 4);\n+    assertArrayValuePanic(2, sealedArray, 0);\n+    assertArrayValuePanic(0, sealedArray, 1);\n+    assertArrayValuePanic(0, sealedArray, 2);\n+    assertArrayValuePanic(0, sealedArray, 2);\n+    assertArrayLengthPanic(5, sealedArray);\n+}\n+\n+function createIntSealedArrayWithLabel() {\n     int[*] sealedArray = [2, 15, 200, 1500, 5000];\n-    return sealedArray.length();\n+    assertArrayLengthPanic(5, sealedArray);\n }\n \n-function createIntDefaultSealedArray() returns [int[], int] {\n+function createIntDefaultSealedArray() {\n     int[5] sealedArray = [0, 0, 0, 0, 0];\n-    return [sealedArray, sealedArray.length()];\n+    assertArrayLengthPanic(5, sealedArray);\n+    isEqualPanic(\"0 0 0 0 0\", sealedArray);\n }\n \n // Boolean Arrays\n \n-function createBoolSealedArray() returns int {\n+function createBoolSealedArray() {\n     boolean[5] sealedArray = [true, false, false, true, false];\n-    return sealedArray.length();\n+    assertArrayLengthPanic(5, sealedArray);\n+}\n+\n+function createBoolAutoFilledSealedArray() {\n+    boolean[5] sealedArray = [true, false];\n+    sealedArray[4] = false;\n+    assertArrayValuePanic(false, sealedArray, 4);\n+    assertArrayLengthPanic(5, sealedArray);\n }\n \n-function createBoolSealedArrayWithLabel() returns int {\n+function createBoolSealedArrayWithLabel() {\n     boolean[*] sealedArray = [true, false, false, true, false];\n-    return sealedArray.length();\n+    assertArrayLengthPanic(5, sealedArray);\n }\n \n-function createBoolDefaultSealedArray() returns [boolean[], int] {\n+function createBoolDefaultSealedArray() {\n     boolean[5] sealedArray = [false, false, false, false, false];\n-    return [sealedArray, sealedArray.length()];\n+    assertArrayLengthPanic(5, sealedArray);\n+    isEqualPanic(\"false false false false false\", sealedArray);\n }\n \n // Float Arrays\n \n-function createFloatSealedArray() returns int {\n+function createFloatSealedArray() {\n     float[5] sealedArray = [0.0, 15.2, 1100.0, -25.8, -10.0];\n-    return sealedArray.length();\n+    assertArrayLengthPanic(5, sealedArray);\n }\n \n-function createFloatSealedArrayWithLabel() returns int {\n+function createFloatAutoFilledSealedArray() {\n+    float[5] sealedArray = [0.0, 15.2];\n+    sealedArray[4] = 2.5;\n+    assertArrayValuePanic(2.5, sealedArray, 4);\n+    assertArrayLengthPanic(5, sealedArray);\n+}\n+\n+function createFloatSealedArrayWithLabel() {\n     float[*] sealedArray = [0.0, 15.2, 1100.0, -25.8, -10.0];\n-    return sealedArray.length();\n+    assertArrayLengthPanic(5, sealedArray);\n }\n \n-function createFloatDefaultSealedArray() returns [float[], int] {\n+function createFloatDefaultSealedArray() {\n     float[5] sealedArray = [0.0, 0.0, 0.0, 0.0, 0.0];\n-    return [sealedArray, sealedArray.length()];\n+    assertArrayLengthPanic(5, sealedArray);\n+    isEqualPanic(\"0.0 0.0 0.0 0.0 0.0\", sealedArray);\n }\n \n // String Arrays\n \n-function createStringSealedArray() returns int {\n+function createStringSealedArray() {\n     string[5] sealedArray = [\"a\", \"abc\", \"12\", \"-12\", \".\"];\n-    return sealedArray.length();\n+    assertArrayLengthPanic(5, sealedArray);\n+}\n+\n+function createStringAutoFilledSealedArray() {\n+    string[5] sealedArray = [\"a\"];\n+    assertArrayLengthPanic(5, sealedArray);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e493306b2169e6eb276e902de8689b1c2cce1b37"}, "originalPosition": 110}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4393, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}