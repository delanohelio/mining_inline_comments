{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg2NjE2Mjc5", "number": 25778, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwNzoyMTozOFrOEj7AIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwMzozMjowNFrOEn6V6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2MTAyMzA2OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/parser/BLangNodeTransformer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwNzoyMTozOFrOHSjfiA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwNzoyNjoyMVrOHSjqRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIxNzkyOA==", "bodyText": "Lets remove this, if its no longer needed.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25778#discussion_r489217928", "createdAt": "2020-09-16T07:21:38Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/parser/BLangNodeTransformer.java", "diffHunk": "@@ -1022,7 +1022,8 @@ public BLangNode transform(ObjectFieldNode objFieldNode) {\n         Optional<Node> doc = getDocumentationString(objFieldNode.metadata());\n         simpleVar.markdownDocumentationAttachment = createMarkdownDocumentationAttachment(doc);\n \n-        addRedonlyQualifier(objFieldNode.readonlyKeyword(), objFieldNode.typeName(), simpleVar);\n+        // TODO: add changes for `final`\n+//        addRedonlyQualifier(objFieldNode.readonlyKeyword(), objFieldNode.typeName(), simpleVar);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "946e71758a33c93b1b9f24a5dfc2829b6a847c1b"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyMDY3Ng==", "bodyText": "@SupunS PR is not yet ready to be reviewed. Waiting for PR #25784 to be merged to clean up old commits from that PR. Also have to do small refactoring. Will let you knw once ready. :)", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25778#discussion_r489220676", "createdAt": "2020-09-16T07:26:21Z", "author": {"login": "lochana-chathura"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/parser/BLangNodeTransformer.java", "diffHunk": "@@ -1022,7 +1022,8 @@ public BLangNode transform(ObjectFieldNode objFieldNode) {\n         Optional<Node> doc = getDocumentationString(objFieldNode.metadata());\n         simpleVar.markdownDocumentationAttachment = createMarkdownDocumentationAttachment(doc);\n \n-        addRedonlyQualifier(objFieldNode.readonlyKeyword(), objFieldNode.typeName(), simpleVar);\n+        // TODO: add changes for `final`\n+//        addRedonlyQualifier(objFieldNode.readonlyKeyword(), objFieldNode.typeName(), simpleVar);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIxNzkyOA=="}, "originalCommit": {"oid": "946e71758a33c93b1b9f24a5dfc2829b6a847c1b"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NjYwNzI0OnYy", "diffSide": "RIGHT", "path": "language-server/modules/langserver-core/src/test/java/org/ballerinalang/langserver/completion/latest/ClassDefContextTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwNDoxMTozM1rOHWVqkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwNDoyNzoyMlrOHWV6Lw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE4NTY4Mg==", "bodyText": "Can we create an issue to track this test disabling?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25778#discussion_r493185682", "createdAt": "2020-09-23T04:11:33Z", "author": {"login": "nadeeshaan"}, "path": "language-server/modules/langserver-core/src/test/java/org/ballerinalang/langserver/completion/latest/ClassDefContextTest.java", "diffHunk": "@@ -41,6 +41,6 @@ public String getTestResourceDir() {\n \n     @Override\n     public List<String> skipList() {\n-        return Arrays.asList(\"config3.json\", \"config8.json\");\n+        return Arrays.asList(\"config3.json\", \"config8.json\", \"config12.json\", \"config13.json\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ebb4f58b6ce5899f9fb7fbeb72b3e7d21014ea3a"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE4OTY3OQ==", "bodyText": "Issue created #26017", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25778#discussion_r493189679", "createdAt": "2020-09-23T04:27:22Z", "author": {"login": "lochana-chathura"}, "path": "language-server/modules/langserver-core/src/test/java/org/ballerinalang/langserver/completion/latest/ClassDefContextTest.java", "diffHunk": "@@ -41,6 +41,6 @@ public String getTestResourceDir() {\n \n     @Override\n     public List<String> skipList() {\n-        return Arrays.asList(\"config3.json\", \"config8.json\");\n+        return Arrays.asList(\"config3.json\", \"config8.json\", \"config12.json\", \"config13.json\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE4NTY4Mg=="}, "originalCommit": {"oid": "ebb4f58b6ce5899f9fb7fbeb72b3e7d21014ea3a"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwMjg1NzkxOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwMzozMTo1OVrOHYtbqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwMzozMTo1OVrOHYtbqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY3MjIzNQ==", "bodyText": "Similar to the prev one, I think we don't need the parseObjectTypeQualifiers() method", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25778#discussion_r495672235", "createdAt": "2020-09-28T03:31:59Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -4625,56 +4662,150 @@ private STNode parseObjectConstructorExpression(STNode annots) {\n \n     /**\n      * <p>\n-     * Parse object type qualifiers.\n+     * Parse object constructor qualifiers.\n      * </p>\n-     * <code>object-type-qualifiers := [client]</code>\n+     * <code>object-constructor-qualifier := [client]</code>\n      *\n      * @return Parsed node\n      */\n-    private STNode parseObjectTypeQualifiers() {\n+    private STNode parseObjectConstructorQualifiers() {\n+        STToken nextToken = peek();\n+        STToken firstQualifier;\n+        switch (nextToken.kind) {\n+            case CLIENT_KEYWORD:\n+                firstQualifier = consume();\n+                break;\n+            case READONLY_KEYWORD:\n+            case ABSTRACT_KEYWORD:\n+            case ISOLATED_KEYWORD:\n+                // Here we allow parsing of old object type qualifiers (`abstract` and `readonly`)\n+                // and then log an error\n+                firstQualifier = consume();\n+                addInvalidNodeToNextToken(firstQualifier, DiagnosticErrorCode.ERROR_QUALIFIER_NOT_ALLOWED,\n+                        firstQualifier.text());\n+                return parseObjectConstructorQualifiers();\n+            case OBJECT_KEYWORD:\n+                return STNodeFactory.createEmptyNodeList();\n+            default:\n+                recover(nextToken, ParserRuleContext.OBJECT_CONSTRUCTOR_QUALIFIER);\n+                return parseObjectConstructorQualifiers();\n+        }\n+\n+        return parseObjectConstructorNextQualifiers(firstQualifier);\n+    }\n+\n+    private STNode parseObjectConstructorNextQualifiers(STNode firstQualifier) {\n         List<STNode> qualifiers = new ArrayList<>();\n-        STNode qualifier;\n-        DiagnosticErrorCode errorCode = null;\n-        boolean hasClient = false;\n+        qualifiers.add(firstQualifier);\n \n-        // Here we allow parsing of old object type qualifiers (`abstract` and `readonly`) and then log an error\n-        for (int i = 0; i < 3; i++) {\n+        // Parse remaining qualifiers\n+        for (int i = 0; i < 2; i++) {\n             STToken nextToken = peek();\n+            if (isNodeWithSyntaxKindInList(qualifiers, nextToken.kind)) {\n+                // Consume the nextToken\n+                nextToken = consume();\n+                updateLastNodeInListWithInvalidNode(qualifiers, nextToken,\n+                        DiagnosticErrorCode.ERROR_DUPLICATE_QUALIFIER, nextToken.text());\n+                continue;\n+            }\n+\n+            STToken nextQualifier;\n             switch (nextToken.kind) {\n                 case CLIENT_KEYWORD:\n-                    qualifier = consume();\n-                    if (hasClient) {\n-                        errorCode = DiagnosticErrorCode.ERROR_DUPLICATE_OBJECT_TYPE_QUALIFIER;\n-                    } else {\n-                        qualifiers.add(qualifier);\n-                        hasClient = true;\n-                    }\n-                    break;\n-                case ABSTRACT_KEYWORD:\n-                    qualifier = consume();\n-                    errorCode = DiagnosticErrorCode.ERROR_ABSTRACT_QUALIFIER_NOT_ALLOWED_IN_OBJECT;\n+                    nextQualifier = consume();\n                     break;\n                 case READONLY_KEYWORD:\n-                    qualifier = consume();\n-                    errorCode = DiagnosticErrorCode.ERROR_READONLY_QUALIFIER_NOT_ALLOWED_IN_OBJECT;\n-                    break;\n+                case ABSTRACT_KEYWORD:\n+                case ISOLATED_KEYWORD:\n+                    // Here we allow parsing of old object type qualifiers (`abstract` and `readonly`)\n+                    // and then log an error\n+                    nextQualifier = consume();\n+                    updateLastNodeInListWithInvalidNode(qualifiers, nextQualifier,\n+                            DiagnosticErrorCode.ERROR_QUALIFIER_NOT_ALLOWED, nextQualifier.text());\n+                    continue;\n                 case OBJECT_KEYWORD:\n                 default:\n                     return STNodeFactory.createNodeList(qualifiers);\n             }\n+            qualifiers.add(nextQualifier);\n+        }\n \n-            if (errorCode != null) {\n-                if (qualifiers.size() > 0) {\n-                    updateLastNodeInListWithInvalidNode(qualifiers, qualifier, errorCode);\n-                } else {\n-                    addInvalidNodeToNextToken(qualifier, errorCode);\n-                }\n-                errorCode = null;\n+        return STNodeFactory.createNodeList(qualifiers);\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse object type descriptor qualifiers.\n+     * </p>\n+     * <code>object-type-descriptor-qualifiers := (client | isolated)*</code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseObjectTypeQualifiers() {\n+        STToken nextToken = peek();\n+        STToken firstQualifier;\n+        switch (nextToken.kind) {\n+            case CLIENT_KEYWORD:\n+            case ISOLATED_KEYWORD:\n+                firstQualifier = consume();\n+                break;\n+            case READONLY_KEYWORD:\n+            case ABSTRACT_KEYWORD:\n+                // Here we allow parsing of old object type qualifiers (`abstract` and `readonly`)\n+                // and then log an error\n+                firstQualifier = consume();\n+                addInvalidNodeToNextToken(firstQualifier, DiagnosticErrorCode.ERROR_QUALIFIER_NOT_ALLOWED,\n+                        firstQualifier.text());\n+                return parseObjectTypeQualifiers();\n+            case OBJECT_KEYWORD:\n+                return STNodeFactory.createEmptyNodeList();\n+            default:\n+                recover(nextToken, ParserRuleContext.OBJECT_TYPE_QUALIFIER);\n+                return parseObjectTypeQualifiers();\n+        }\n+\n+        return parseObjectTypeNextQualifiers(firstQualifier);\n+    }\n+\n+    private STNode parseObjectTypeNextQualifiers(STNode firstQualifier) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83ba2ff80e90b45c9c3517358d4b88186c30ee98"}, "originalPosition": 322}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwMjg1ODAwOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwMzozMjowNFrOHYtbtg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwMzozMjowNFrOHYtbtg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY3MjI0Ng==", "bodyText": "Do we need two methods?\nI think the one with the loop would be sufficient to handle all cases.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25778#discussion_r495672246", "createdAt": "2020-09-28T03:32:04Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -4625,56 +4662,150 @@ private STNode parseObjectConstructorExpression(STNode annots) {\n \n     /**\n      * <p>\n-     * Parse object type qualifiers.\n+     * Parse object constructor qualifiers.\n      * </p>\n-     * <code>object-type-qualifiers := [client]</code>\n+     * <code>object-constructor-qualifier := [client]</code>\n      *\n      * @return Parsed node\n      */\n-    private STNode parseObjectTypeQualifiers() {\n+    private STNode parseObjectConstructorQualifiers() {\n+        STToken nextToken = peek();\n+        STToken firstQualifier;\n+        switch (nextToken.kind) {\n+            case CLIENT_KEYWORD:\n+                firstQualifier = consume();\n+                break;\n+            case READONLY_KEYWORD:\n+            case ABSTRACT_KEYWORD:\n+            case ISOLATED_KEYWORD:\n+                // Here we allow parsing of old object type qualifiers (`abstract` and `readonly`)\n+                // and then log an error\n+                firstQualifier = consume();\n+                addInvalidNodeToNextToken(firstQualifier, DiagnosticErrorCode.ERROR_QUALIFIER_NOT_ALLOWED,\n+                        firstQualifier.text());\n+                return parseObjectConstructorQualifiers();\n+            case OBJECT_KEYWORD:\n+                return STNodeFactory.createEmptyNodeList();\n+            default:\n+                recover(nextToken, ParserRuleContext.OBJECT_CONSTRUCTOR_QUALIFIER);\n+                return parseObjectConstructorQualifiers();\n+        }\n+\n+        return parseObjectConstructorNextQualifiers(firstQualifier);\n+    }\n+\n+    private STNode parseObjectConstructorNextQualifiers(STNode firstQualifier) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83ba2ff80e90b45c9c3517358d4b88186c30ee98"}, "originalPosition": 223}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 103, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}