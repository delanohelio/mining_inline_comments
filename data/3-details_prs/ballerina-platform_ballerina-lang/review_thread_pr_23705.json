{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI3NDE3MzUw", "number": 23705, "reviewThreads": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwMTowNjowN1rOECXv2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQxODoxNTo1MlrOEFJlGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwOTIxNjkwOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/ballerinalang/model/tree/expressions/TemplateLiteralNode.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwMTowNjowN1rOGeyaZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwMTowNjowN1rOGeyaZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDkzNjQyMw==", "bodyText": "Let's not use Preview1", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23705#discussion_r434936423", "createdAt": "2020-06-04T01:06:07Z", "author": {"login": "hasithaa"}, "path": "compiler/ballerina-lang/src/main/java/org/ballerinalang/model/tree/expressions/TemplateLiteralNode.java", "diffHunk": "@@ -0,0 +1,36 @@\n+/*\n+*  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+*\n+*  WSO2 Inc. licenses this file to you under the Apache License,\n+*  Version 2.0 (the \"License\"); you may not use this file except\n+*  in compliance with the License.\n+*  You may obtain a copy of the License at\n+*\n+*    http://www.apache.org/licenses/LICENSE-2.0\n+*\n+*  Unless required by applicable law or agreed to in writing,\n+*  software distributed under the License is distributed on an\n+*  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+*  KIND, either express or implied.  See the License for the\n+*  specific language governing permissions and limitations\n+*  under the License.\n+*/\n+package org.ballerinalang.model.tree.expressions;\n+\n+import java.util.List;\n+\n+/**\n+ * Represents a backtick string template literal node.\n+ *\n+ * @since 2.0.0-Preview1", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5126d4c60a558ea9413a498955cf6399ca92c258"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwOTIyMzk0OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwMToxMToyMFrOGeye9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QyMDo0MjowMlrOGgLvUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDkzNzU4OA==", "bodyText": "Shall we add a comment explaining the final desugar outcome?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23705#discussion_r434937588", "createdAt": "2020-06-04T01:11:20Z", "author": {"login": "hasithaa"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java", "diffHunk": "@@ -4368,6 +4369,55 @@ public void visit(BLangStringTemplateLiteral stringTemplateLiteral) {\n         result = rewriteExpr(constructStringTemplateConcatExpression(stringTemplateLiteral.exprs));\n     }\n \n+    @Override\n+    public void visit(BLangRawTemplateLiteral rawTemplateLiteral) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5126d4c60a558ea9413a498955cf6399ca92c258"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM5OTk1NQ==", "bodyText": "Added with c860ced", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23705#discussion_r436399955", "createdAt": "2020-06-07T20:42:02Z", "author": {"login": "pubudu91"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java", "diffHunk": "@@ -4368,6 +4369,55 @@ public void visit(BLangStringTemplateLiteral stringTemplateLiteral) {\n         result = rewriteExpr(constructStringTemplateConcatExpression(stringTemplateLiteral.exprs));\n     }\n \n+    @Override\n+    public void visit(BLangRawTemplateLiteral rawTemplateLiteral) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDkzNzU4OA=="}, "originalCommit": {"oid": "5126d4c60a558ea9413a498955cf6399ca92c258"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMjA4ODg3OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQwNjowNTozNFrOGiPo7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQwNzowNDowOFrOGiQ-fg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODU2MTAwNw==", "bodyText": "Shouldn't this be readonly & string[]", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23705#discussion_r438561007", "createdAt": "2020-06-11T06:05:34Z", "author": {"login": "KRVPerera"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java", "diffHunk": "@@ -4263,6 +4281,160 @@ public void visit(BLangStringTemplateLiteral stringTemplateLiteral) {\n         result = rewriteExpr(constructStringTemplateConcatExpression(stringTemplateLiteral.exprs));\n     }\n \n+    /**\n+     * The raw template literal gets desugared to a type init expression. For each literal, a new object class type\n+     * def is generated from the object type. The type init expression creates an instance of this generated object\n+     * type. For example, consider the following statements:\n+     *      string name = \"Pubudu\";\n+     *      'object:RawTemplate rt = `Hello ${name}!`;\n+     *\n+     * The raw template literal above is desugared to:\n+     *      type RawTemplate$Impl$0 object {\n+     *          public string[] strings = [\"Hello \", \"!\"];\n+     *          public (any|error)[] insertions;\n+     *\n+     *          function init((any|error)[] insertions) {\n+     *              self.insertions = insertions;\n+     *          }\n+     *      };\n+     *\n+     *      // somewhere in code\n+     *      'object:RawTemplate rt = new RawTemplate$Impl$0([name]);\n+     *\n+     * @param rawTemplateLiteral The raw template literal to be desugared.\n+     */\n+    @Override\n+    public void visit(BLangRawTemplateLiteral rawTemplateLiteral) {\n+        DiagnosticPos pos = rawTemplateLiteral.pos;\n+        BObjectType objType = (BObjectType) rawTemplateLiteral.type;\n+        BLangTypeDefinition objClassDef = desugarTemplateLiteralObjectTypedef(rawTemplateLiteral.strings, objType, pos);\n+        BObjectType classObjType = (BObjectType) objClassDef.type;\n+\n+        BVarSymbol insertionsSym = classObjType.fields.get(\"insertions\").symbol;\n+        BLangListConstructorExpr insertionsList = ASTBuilderUtil.createEmptyArrayLiteral(pos, insertionsSym.type);\n+        insertionsList.exprs.addAll(rawTemplateLiteral.insertions);\n+        insertionsList.expectedType = insertionsSym.type;\n+\n+        // Create an instance of the generated object class\n+        BLangTypeInit typeNewExpr = ASTBuilderUtil.createEmptyTypeInit(pos, classObjType);\n+        typeNewExpr.argsExpr.add(insertionsList);\n+        typeNewExpr.initInvocation.argExprs.add(insertionsList);\n+        typeNewExpr.initInvocation.requiredArgs.add(insertionsList);\n+\n+        result = rewriteExpr(typeNewExpr);\n+    }\n+\n+    /**\n+     * This method desugars a raw template literal object class for the provided raw template object type as follows:\n+     * A literal defined as 'object:RawTemplate rt = `Hello ${name}!`;\n+     * is desugared to,\n+     *      type $anonType$0 object {\n+     *          public string[] strings = [\"Hello \", \"!\"];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ae4b7db94637e24df2fb309bf349c2cd3f8bc00"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODU2MTkzNA==", "bodyText": "Also can't we have this as an actual object defined in lang.object\nballerina-platform/ballerina-spec#442 (comment)", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23705#discussion_r438561934", "createdAt": "2020-06-11T06:08:21Z", "author": {"login": "KRVPerera"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java", "diffHunk": "@@ -4263,6 +4281,160 @@ public void visit(BLangStringTemplateLiteral stringTemplateLiteral) {\n         result = rewriteExpr(constructStringTemplateConcatExpression(stringTemplateLiteral.exprs));\n     }\n \n+    /**\n+     * The raw template literal gets desugared to a type init expression. For each literal, a new object class type\n+     * def is generated from the object type. The type init expression creates an instance of this generated object\n+     * type. For example, consider the following statements:\n+     *      string name = \"Pubudu\";\n+     *      'object:RawTemplate rt = `Hello ${name}!`;\n+     *\n+     * The raw template literal above is desugared to:\n+     *      type RawTemplate$Impl$0 object {\n+     *          public string[] strings = [\"Hello \", \"!\"];\n+     *          public (any|error)[] insertions;\n+     *\n+     *          function init((any|error)[] insertions) {\n+     *              self.insertions = insertions;\n+     *          }\n+     *      };\n+     *\n+     *      // somewhere in code\n+     *      'object:RawTemplate rt = new RawTemplate$Impl$0([name]);\n+     *\n+     * @param rawTemplateLiteral The raw template literal to be desugared.\n+     */\n+    @Override\n+    public void visit(BLangRawTemplateLiteral rawTemplateLiteral) {\n+        DiagnosticPos pos = rawTemplateLiteral.pos;\n+        BObjectType objType = (BObjectType) rawTemplateLiteral.type;\n+        BLangTypeDefinition objClassDef = desugarTemplateLiteralObjectTypedef(rawTemplateLiteral.strings, objType, pos);\n+        BObjectType classObjType = (BObjectType) objClassDef.type;\n+\n+        BVarSymbol insertionsSym = classObjType.fields.get(\"insertions\").symbol;\n+        BLangListConstructorExpr insertionsList = ASTBuilderUtil.createEmptyArrayLiteral(pos, insertionsSym.type);\n+        insertionsList.exprs.addAll(rawTemplateLiteral.insertions);\n+        insertionsList.expectedType = insertionsSym.type;\n+\n+        // Create an instance of the generated object class\n+        BLangTypeInit typeNewExpr = ASTBuilderUtil.createEmptyTypeInit(pos, classObjType);\n+        typeNewExpr.argsExpr.add(insertionsList);\n+        typeNewExpr.initInvocation.argExprs.add(insertionsList);\n+        typeNewExpr.initInvocation.requiredArgs.add(insertionsList);\n+\n+        result = rewriteExpr(typeNewExpr);\n+    }\n+\n+    /**\n+     * This method desugars a raw template literal object class for the provided raw template object type as follows:\n+     * A literal defined as 'object:RawTemplate rt = `Hello ${name}!`;\n+     * is desugared to,\n+     *      type $anonType$0 object {\n+     *          public string[] strings = [\"Hello \", \"!\"];", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODU2MTAwNw=="}, "originalCommit": {"oid": "8ae4b7db94637e24df2fb309bf349c2cd3f8bc00"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODU4MTg5OQ==", "bodyText": "Yes, need to change it to readonly & string[].", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23705#discussion_r438581899", "createdAt": "2020-06-11T07:01:36Z", "author": {"login": "pubudu91"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java", "diffHunk": "@@ -4263,6 +4281,160 @@ public void visit(BLangStringTemplateLiteral stringTemplateLiteral) {\n         result = rewriteExpr(constructStringTemplateConcatExpression(stringTemplateLiteral.exprs));\n     }\n \n+    /**\n+     * The raw template literal gets desugared to a type init expression. For each literal, a new object class type\n+     * def is generated from the object type. The type init expression creates an instance of this generated object\n+     * type. For example, consider the following statements:\n+     *      string name = \"Pubudu\";\n+     *      'object:RawTemplate rt = `Hello ${name}!`;\n+     *\n+     * The raw template literal above is desugared to:\n+     *      type RawTemplate$Impl$0 object {\n+     *          public string[] strings = [\"Hello \", \"!\"];\n+     *          public (any|error)[] insertions;\n+     *\n+     *          function init((any|error)[] insertions) {\n+     *              self.insertions = insertions;\n+     *          }\n+     *      };\n+     *\n+     *      // somewhere in code\n+     *      'object:RawTemplate rt = new RawTemplate$Impl$0([name]);\n+     *\n+     * @param rawTemplateLiteral The raw template literal to be desugared.\n+     */\n+    @Override\n+    public void visit(BLangRawTemplateLiteral rawTemplateLiteral) {\n+        DiagnosticPos pos = rawTemplateLiteral.pos;\n+        BObjectType objType = (BObjectType) rawTemplateLiteral.type;\n+        BLangTypeDefinition objClassDef = desugarTemplateLiteralObjectTypedef(rawTemplateLiteral.strings, objType, pos);\n+        BObjectType classObjType = (BObjectType) objClassDef.type;\n+\n+        BVarSymbol insertionsSym = classObjType.fields.get(\"insertions\").symbol;\n+        BLangListConstructorExpr insertionsList = ASTBuilderUtil.createEmptyArrayLiteral(pos, insertionsSym.type);\n+        insertionsList.exprs.addAll(rawTemplateLiteral.insertions);\n+        insertionsList.expectedType = insertionsSym.type;\n+\n+        // Create an instance of the generated object class\n+        BLangTypeInit typeNewExpr = ASTBuilderUtil.createEmptyTypeInit(pos, classObjType);\n+        typeNewExpr.argsExpr.add(insertionsList);\n+        typeNewExpr.initInvocation.argExprs.add(insertionsList);\n+        typeNewExpr.initInvocation.requiredArgs.add(insertionsList);\n+\n+        result = rewriteExpr(typeNewExpr);\n+    }\n+\n+    /**\n+     * This method desugars a raw template literal object class for the provided raw template object type as follows:\n+     * A literal defined as 'object:RawTemplate rt = `Hello ${name}!`;\n+     * is desugared to,\n+     *      type $anonType$0 object {\n+     *          public string[] strings = [\"Hello \", \"!\"];", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODU2MTAwNw=="}, "originalCommit": {"oid": "8ae4b7db94637e24df2fb309bf349c2cd3f8bc00"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODU4MjkxMA==", "bodyText": "Also can't we have this as an actual object defined in lang.object\nballerina-platform/ballerina-spec#442 (comment)\n\nThis is what I initially did. But as James clarified in the above issue, raw template literals are meant to work with abstract objects. If we try to use them with concrete objects, we run in to the issue I explained in ballerina-platform/ballerina-spec#442 (comment).", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23705#discussion_r438582910", "createdAt": "2020-06-11T07:04:08Z", "author": {"login": "pubudu91"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java", "diffHunk": "@@ -4263,6 +4281,160 @@ public void visit(BLangStringTemplateLiteral stringTemplateLiteral) {\n         result = rewriteExpr(constructStringTemplateConcatExpression(stringTemplateLiteral.exprs));\n     }\n \n+    /**\n+     * The raw template literal gets desugared to a type init expression. For each literal, a new object class type\n+     * def is generated from the object type. The type init expression creates an instance of this generated object\n+     * type. For example, consider the following statements:\n+     *      string name = \"Pubudu\";\n+     *      'object:RawTemplate rt = `Hello ${name}!`;\n+     *\n+     * The raw template literal above is desugared to:\n+     *      type RawTemplate$Impl$0 object {\n+     *          public string[] strings = [\"Hello \", \"!\"];\n+     *          public (any|error)[] insertions;\n+     *\n+     *          function init((any|error)[] insertions) {\n+     *              self.insertions = insertions;\n+     *          }\n+     *      };\n+     *\n+     *      // somewhere in code\n+     *      'object:RawTemplate rt = new RawTemplate$Impl$0([name]);\n+     *\n+     * @param rawTemplateLiteral The raw template literal to be desugared.\n+     */\n+    @Override\n+    public void visit(BLangRawTemplateLiteral rawTemplateLiteral) {\n+        DiagnosticPos pos = rawTemplateLiteral.pos;\n+        BObjectType objType = (BObjectType) rawTemplateLiteral.type;\n+        BLangTypeDefinition objClassDef = desugarTemplateLiteralObjectTypedef(rawTemplateLiteral.strings, objType, pos);\n+        BObjectType classObjType = (BObjectType) objClassDef.type;\n+\n+        BVarSymbol insertionsSym = classObjType.fields.get(\"insertions\").symbol;\n+        BLangListConstructorExpr insertionsList = ASTBuilderUtil.createEmptyArrayLiteral(pos, insertionsSym.type);\n+        insertionsList.exprs.addAll(rawTemplateLiteral.insertions);\n+        insertionsList.expectedType = insertionsSym.type;\n+\n+        // Create an instance of the generated object class\n+        BLangTypeInit typeNewExpr = ASTBuilderUtil.createEmptyTypeInit(pos, classObjType);\n+        typeNewExpr.argsExpr.add(insertionsList);\n+        typeNewExpr.initInvocation.argExprs.add(insertionsList);\n+        typeNewExpr.initInvocation.requiredArgs.add(insertionsList);\n+\n+        result = rewriteExpr(typeNewExpr);\n+    }\n+\n+    /**\n+     * This method desugars a raw template literal object class for the provided raw template object type as follows:\n+     * A literal defined as 'object:RawTemplate rt = `Hello ${name}!`;\n+     * is desugared to,\n+     *      type $anonType$0 object {\n+     *          public string[] strings = [\"Hello \", \"!\"];", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODU2MTAwNw=="}, "originalCommit": {"oid": "8ae4b7db94637e24df2fb309bf349c2cd3f8bc00"}, "originalPosition": 147}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMjEwODMzOnYy", "diffSide": "RIGHT", "path": "tests/jballerina-unit-test/src/test/resources/test-src/expressions/rawtemplate/raw_template_literal_test.bal", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQwNjoxNDo0N1rOGiP0tw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxMzoyNzoxOFrOGic94A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODU2NDAyMw==", "bodyText": "This is currently failing right.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23705#discussion_r438564023", "createdAt": "2020-06-11T06:14:47Z", "author": {"login": "KRVPerera"}, "path": "tests/jballerina-unit-test/src/test/resources/test-src/expressions/rawtemplate/raw_template_literal_test.bal", "diffHunk": "@@ -0,0 +1,230 @@\n+// Copyright (c) 2020 WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+//\n+// WSO2 Inc. licenses this file to you under the Apache License,\n+// Version 2.0 (the \"License\"); you may not use this file except\n+// in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+import ballerina/lang.'object as ob;\n+\n+function testBasicUsage() {\n+    string name = \"Pubudu\";\n+    ob:RawTemplate rt = `Hello ${name}!`;\n+\n+    assert(<string[]>[\"Hello \", \"!\"], rt.strings);\n+    assert(\"Pubudu\", <string>rt.insertions[0]);\n+}\n+\n+function testEmptyLiteral() {\n+    ob:RawTemplate rt = ``;\n+\n+    assert(<string[]>[], rt.strings);\n+    assert(0, rt.insertions.length());\n+}\n+\n+function testLiteralWithNoInterpolations() {\n+    ob:RawTemplate rt = `Hello World!`;\n+\n+    assert(<string[]>[\"Hello World!\"], rt.strings);\n+    assert(0, rt.insertions.length());\n+}\n+\n+function testLiteralWithNoStrings() {\n+    string hello = \"Hello\";\n+    int n = 10;\n+    string world = \"World\";\n+\n+    ob:RawTemplate rt = `${hello}${n}${world}`;\n+\n+    assert(<string[]>[], rt.strings);\n+    assert(\"Hello\", <string>rt.insertions[0]);\n+    assert(10, <int>rt.insertions[1]);\n+    assert(\"World\", <string>rt.insertions[2]);\n+}\n+\n+type Person object {\n+    string name;\n+    int age;\n+\n+    function __init(string name, int age) {\n+        self.name = name;\n+        self.age = age;\n+    }\n+\n+    function toString() returns string {\n+        return string `name: ${self.name}, age: ${self.age}`;\n+    }\n+};\n+\n+function testComplexExpressions() {\n+    int x = 10;\n+    int y = 20;\n+\n+    ob:RawTemplate rt1 = `x + y = ${x + y}`;\n+    assert(<string[]>[\"x + y = \"], rt1.strings);\n+    assert(30, <int>rt1.insertions[0]);\n+\n+    var fn = function () returns string { return \"Pubudu\"; };\n+\n+    ob:RawTemplate rt2 = `Hello ${fn()}!`;\n+    assert(<string[]>[\"Hello \", \"!\"], rt2.strings);\n+    assert(\"Pubudu\", <string>rt2.insertions[0]);\n+\n+    Person p = new(\"John Doe\", 20);\n+\n+    ob:RawTemplate rt3 = `${p} is a person`;\n+    assert(<string[]>[\" is a person\"], rt3.strings);\n+    assert(\"name: John Doe, age: 20\", rt3.insertions[0].toString());\n+}\n+\n+type Template1 object {\n+    public string[] strings = [];\n+    public int[] insertions = [];\n+\n+    function toString() returns string {\n+        return string `${self.insertions[0]}${self.strings[0]}${self.insertions[1]}${self.strings[1]}${self.insertions[2]}`;\n+    }\n+};\n+\n+function testSubtyping1() {\n+    int x = 10;\n+    int y = 20;\n+\n+    Template1 t = `${x} + ${y} = ${x + y}`;\n+    assert(\"10 + 20 = 30\", t.toString());\n+}\n+\n+type Template2 object {\n+    public string[] strings = [];\n+    public [int, string, float] insertions = [];\n+};\n+\n+function testSubtyping2() {\n+    int x = 25;\n+    string s = \"foo\";\n+    float f = 12.34;\n+\n+    Template2 t = `Using tuples: ${x}, ${s}, ${f}`;\n+    assert(\"Using tuples:  ,  , \", t.strings.toString());\n+    assert(x, t.insertions[0]);\n+    assert(s, t.insertions[1]);\n+    assert(f, t.insertions[2]);\n+\n+    object {\n+        public string[] strings = [];\n+        public [int, string, anydata...] insertions;\n+        string name = \"\";\n+\n+        function __init() {\n+            self.insertions = [];\n+        }\n+    } temp2 = `Using tuples 2: ${x}, ${s}, ${f}`;\n+\n+    assert(\"Using tuples 2:  ,  , \", temp2.strings.toString());\n+    assert(x, temp2.insertions[0]);\n+    assert(s, temp2.insertions[1]);\n+    assert(f, temp2.insertions[2]);\n+\n+    object {\n+        public string[] strings = [];\n+        public [anydata...] insertions = [];\n+        string name = \"\";\n+    } temp3 = `Using tuples 3: ${x}, ${s}, ${f}`;\n+\n+    assert(\"Using tuples 3:  ,  , \", temp3.strings.toString());\n+    assert(x, temp2.insertions[0]);\n+    assert(s, temp3.insertions[1]);\n+    assert(f, temp3.insertions[2]);\n+}\n+\n+const FOO = \"Foo\";\n+const BAR = \"Bar\";\n+\n+type FooBar FOO|BAR;\n+\n+function testSubtyping3() {\n+    int x = 10;\n+\n+    object {\n+        public FooBar[] strings = [];\n+        public int[] insertions = [];\n+    } temp1 = `Foo${x}Bar`;\n+\n+    assert(<string[]>[\"Foo\", \"Bar\"], temp1.strings);\n+    assert(10, temp1.insertions[0]);\n+}\n+\n+function testUsageWithQueryExpressions() {\n+    int[] arr = [100, 200, 300, 400, 500];\n+\n+    ob:RawTemplate[] queries = from var x in arr\n+        select `INSERT INTO product ('id', 'name', 'price') VALUES (${x}, ${x + 10}, ${x + 20})`;\n+\n+    foreach var x in queries {\n+        assert(\"INSERT INTO product ('id', 'name', 'price') VALUES ( ,  ,  )\", x.strings.toString());\n+    }\n+\n+    int i = 0;\n+    foreach var x in queries {\n+        assert(string `${arr[i]} ${arr[i] + 10} ${arr[i] + 20}`, x.insertions.toString());\n+        i += 1;\n+    }\n+}\n+\n+public type Value ()|int|float|decimal|string|xml;\n+\n+public type ParameterizedQuery object {\n+    public string[] strings = [];\n+    public Value[] insertions = [];\n+};\n+\n+function testUsageWithQueryExpressions2() {\n+    var data = [\n+        {name: \"Alice1\"},\n+        {name: \"Alice2\"},\n+        {name: \"Alice3\"}\n+    ];\n+\n+    ParameterizedQuery[] queries = from var rec in data select `INSERT INTO People (name) values (${rec.name});`;\n+\n+    foreach var x in queries {\n+        assert(\"INSERT INTO People (name) values ( );\", x.strings.toString());\n+    }\n+\n+    int i = 0;\n+    foreach var x in queries {\n+        assert(data[i][\"name\"], x.insertions.toString());\n+        i += 1;\n+    }\n+}\n+\n+function testUseWithVar() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ae4b7db94637e24df2fb309bf349c2cd3f8bc00"}, "originalPosition": 210}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODU4MDc2Ng==", "bodyText": "Yes, I haven't pushed the updated tests yet. Will push them once the negative tests are also updated", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23705#discussion_r438580766", "createdAt": "2020-06-11T06:59:10Z", "author": {"login": "pubudu91"}, "path": "tests/jballerina-unit-test/src/test/resources/test-src/expressions/rawtemplate/raw_template_literal_test.bal", "diffHunk": "@@ -0,0 +1,230 @@\n+// Copyright (c) 2020 WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+//\n+// WSO2 Inc. licenses this file to you under the Apache License,\n+// Version 2.0 (the \"License\"); you may not use this file except\n+// in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+import ballerina/lang.'object as ob;\n+\n+function testBasicUsage() {\n+    string name = \"Pubudu\";\n+    ob:RawTemplate rt = `Hello ${name}!`;\n+\n+    assert(<string[]>[\"Hello \", \"!\"], rt.strings);\n+    assert(\"Pubudu\", <string>rt.insertions[0]);\n+}\n+\n+function testEmptyLiteral() {\n+    ob:RawTemplate rt = ``;\n+\n+    assert(<string[]>[], rt.strings);\n+    assert(0, rt.insertions.length());\n+}\n+\n+function testLiteralWithNoInterpolations() {\n+    ob:RawTemplate rt = `Hello World!`;\n+\n+    assert(<string[]>[\"Hello World!\"], rt.strings);\n+    assert(0, rt.insertions.length());\n+}\n+\n+function testLiteralWithNoStrings() {\n+    string hello = \"Hello\";\n+    int n = 10;\n+    string world = \"World\";\n+\n+    ob:RawTemplate rt = `${hello}${n}${world}`;\n+\n+    assert(<string[]>[], rt.strings);\n+    assert(\"Hello\", <string>rt.insertions[0]);\n+    assert(10, <int>rt.insertions[1]);\n+    assert(\"World\", <string>rt.insertions[2]);\n+}\n+\n+type Person object {\n+    string name;\n+    int age;\n+\n+    function __init(string name, int age) {\n+        self.name = name;\n+        self.age = age;\n+    }\n+\n+    function toString() returns string {\n+        return string `name: ${self.name}, age: ${self.age}`;\n+    }\n+};\n+\n+function testComplexExpressions() {\n+    int x = 10;\n+    int y = 20;\n+\n+    ob:RawTemplate rt1 = `x + y = ${x + y}`;\n+    assert(<string[]>[\"x + y = \"], rt1.strings);\n+    assert(30, <int>rt1.insertions[0]);\n+\n+    var fn = function () returns string { return \"Pubudu\"; };\n+\n+    ob:RawTemplate rt2 = `Hello ${fn()}!`;\n+    assert(<string[]>[\"Hello \", \"!\"], rt2.strings);\n+    assert(\"Pubudu\", <string>rt2.insertions[0]);\n+\n+    Person p = new(\"John Doe\", 20);\n+\n+    ob:RawTemplate rt3 = `${p} is a person`;\n+    assert(<string[]>[\" is a person\"], rt3.strings);\n+    assert(\"name: John Doe, age: 20\", rt3.insertions[0].toString());\n+}\n+\n+type Template1 object {\n+    public string[] strings = [];\n+    public int[] insertions = [];\n+\n+    function toString() returns string {\n+        return string `${self.insertions[0]}${self.strings[0]}${self.insertions[1]}${self.strings[1]}${self.insertions[2]}`;\n+    }\n+};\n+\n+function testSubtyping1() {\n+    int x = 10;\n+    int y = 20;\n+\n+    Template1 t = `${x} + ${y} = ${x + y}`;\n+    assert(\"10 + 20 = 30\", t.toString());\n+}\n+\n+type Template2 object {\n+    public string[] strings = [];\n+    public [int, string, float] insertions = [];\n+};\n+\n+function testSubtyping2() {\n+    int x = 25;\n+    string s = \"foo\";\n+    float f = 12.34;\n+\n+    Template2 t = `Using tuples: ${x}, ${s}, ${f}`;\n+    assert(\"Using tuples:  ,  , \", t.strings.toString());\n+    assert(x, t.insertions[0]);\n+    assert(s, t.insertions[1]);\n+    assert(f, t.insertions[2]);\n+\n+    object {\n+        public string[] strings = [];\n+        public [int, string, anydata...] insertions;\n+        string name = \"\";\n+\n+        function __init() {\n+            self.insertions = [];\n+        }\n+    } temp2 = `Using tuples 2: ${x}, ${s}, ${f}`;\n+\n+    assert(\"Using tuples 2:  ,  , \", temp2.strings.toString());\n+    assert(x, temp2.insertions[0]);\n+    assert(s, temp2.insertions[1]);\n+    assert(f, temp2.insertions[2]);\n+\n+    object {\n+        public string[] strings = [];\n+        public [anydata...] insertions = [];\n+        string name = \"\";\n+    } temp3 = `Using tuples 3: ${x}, ${s}, ${f}`;\n+\n+    assert(\"Using tuples 3:  ,  , \", temp3.strings.toString());\n+    assert(x, temp2.insertions[0]);\n+    assert(s, temp3.insertions[1]);\n+    assert(f, temp3.insertions[2]);\n+}\n+\n+const FOO = \"Foo\";\n+const BAR = \"Bar\";\n+\n+type FooBar FOO|BAR;\n+\n+function testSubtyping3() {\n+    int x = 10;\n+\n+    object {\n+        public FooBar[] strings = [];\n+        public int[] insertions = [];\n+    } temp1 = `Foo${x}Bar`;\n+\n+    assert(<string[]>[\"Foo\", \"Bar\"], temp1.strings);\n+    assert(10, temp1.insertions[0]);\n+}\n+\n+function testUsageWithQueryExpressions() {\n+    int[] arr = [100, 200, 300, 400, 500];\n+\n+    ob:RawTemplate[] queries = from var x in arr\n+        select `INSERT INTO product ('id', 'name', 'price') VALUES (${x}, ${x + 10}, ${x + 20})`;\n+\n+    foreach var x in queries {\n+        assert(\"INSERT INTO product ('id', 'name', 'price') VALUES ( ,  ,  )\", x.strings.toString());\n+    }\n+\n+    int i = 0;\n+    foreach var x in queries {\n+        assert(string `${arr[i]} ${arr[i] + 10} ${arr[i] + 20}`, x.insertions.toString());\n+        i += 1;\n+    }\n+}\n+\n+public type Value ()|int|float|decimal|string|xml;\n+\n+public type ParameterizedQuery object {\n+    public string[] strings = [];\n+    public Value[] insertions = [];\n+};\n+\n+function testUsageWithQueryExpressions2() {\n+    var data = [\n+        {name: \"Alice1\"},\n+        {name: \"Alice2\"},\n+        {name: \"Alice3\"}\n+    ];\n+\n+    ParameterizedQuery[] queries = from var rec in data select `INSERT INTO People (name) values (${rec.name});`;\n+\n+    foreach var x in queries {\n+        assert(\"INSERT INTO People (name) values ( );\", x.strings.toString());\n+    }\n+\n+    int i = 0;\n+    foreach var x in queries {\n+        assert(data[i][\"name\"], x.insertions.toString());\n+        i += 1;\n+    }\n+}\n+\n+function testUseWithVar() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODU2NDAyMw=="}, "originalCommit": {"oid": "8ae4b7db94637e24df2fb309bf349c2cd3f8bc00"}, "originalPosition": 210}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc3OTM2MA==", "bodyText": "Pushed the updated tests", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23705#discussion_r438779360", "createdAt": "2020-06-11T13:27:18Z", "author": {"login": "pubudu91"}, "path": "tests/jballerina-unit-test/src/test/resources/test-src/expressions/rawtemplate/raw_template_literal_test.bal", "diffHunk": "@@ -0,0 +1,230 @@\n+// Copyright (c) 2020 WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+//\n+// WSO2 Inc. licenses this file to you under the Apache License,\n+// Version 2.0 (the \"License\"); you may not use this file except\n+// in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+import ballerina/lang.'object as ob;\n+\n+function testBasicUsage() {\n+    string name = \"Pubudu\";\n+    ob:RawTemplate rt = `Hello ${name}!`;\n+\n+    assert(<string[]>[\"Hello \", \"!\"], rt.strings);\n+    assert(\"Pubudu\", <string>rt.insertions[0]);\n+}\n+\n+function testEmptyLiteral() {\n+    ob:RawTemplate rt = ``;\n+\n+    assert(<string[]>[], rt.strings);\n+    assert(0, rt.insertions.length());\n+}\n+\n+function testLiteralWithNoInterpolations() {\n+    ob:RawTemplate rt = `Hello World!`;\n+\n+    assert(<string[]>[\"Hello World!\"], rt.strings);\n+    assert(0, rt.insertions.length());\n+}\n+\n+function testLiteralWithNoStrings() {\n+    string hello = \"Hello\";\n+    int n = 10;\n+    string world = \"World\";\n+\n+    ob:RawTemplate rt = `${hello}${n}${world}`;\n+\n+    assert(<string[]>[], rt.strings);\n+    assert(\"Hello\", <string>rt.insertions[0]);\n+    assert(10, <int>rt.insertions[1]);\n+    assert(\"World\", <string>rt.insertions[2]);\n+}\n+\n+type Person object {\n+    string name;\n+    int age;\n+\n+    function __init(string name, int age) {\n+        self.name = name;\n+        self.age = age;\n+    }\n+\n+    function toString() returns string {\n+        return string `name: ${self.name}, age: ${self.age}`;\n+    }\n+};\n+\n+function testComplexExpressions() {\n+    int x = 10;\n+    int y = 20;\n+\n+    ob:RawTemplate rt1 = `x + y = ${x + y}`;\n+    assert(<string[]>[\"x + y = \"], rt1.strings);\n+    assert(30, <int>rt1.insertions[0]);\n+\n+    var fn = function () returns string { return \"Pubudu\"; };\n+\n+    ob:RawTemplate rt2 = `Hello ${fn()}!`;\n+    assert(<string[]>[\"Hello \", \"!\"], rt2.strings);\n+    assert(\"Pubudu\", <string>rt2.insertions[0]);\n+\n+    Person p = new(\"John Doe\", 20);\n+\n+    ob:RawTemplate rt3 = `${p} is a person`;\n+    assert(<string[]>[\" is a person\"], rt3.strings);\n+    assert(\"name: John Doe, age: 20\", rt3.insertions[0].toString());\n+}\n+\n+type Template1 object {\n+    public string[] strings = [];\n+    public int[] insertions = [];\n+\n+    function toString() returns string {\n+        return string `${self.insertions[0]}${self.strings[0]}${self.insertions[1]}${self.strings[1]}${self.insertions[2]}`;\n+    }\n+};\n+\n+function testSubtyping1() {\n+    int x = 10;\n+    int y = 20;\n+\n+    Template1 t = `${x} + ${y} = ${x + y}`;\n+    assert(\"10 + 20 = 30\", t.toString());\n+}\n+\n+type Template2 object {\n+    public string[] strings = [];\n+    public [int, string, float] insertions = [];\n+};\n+\n+function testSubtyping2() {\n+    int x = 25;\n+    string s = \"foo\";\n+    float f = 12.34;\n+\n+    Template2 t = `Using tuples: ${x}, ${s}, ${f}`;\n+    assert(\"Using tuples:  ,  , \", t.strings.toString());\n+    assert(x, t.insertions[0]);\n+    assert(s, t.insertions[1]);\n+    assert(f, t.insertions[2]);\n+\n+    object {\n+        public string[] strings = [];\n+        public [int, string, anydata...] insertions;\n+        string name = \"\";\n+\n+        function __init() {\n+            self.insertions = [];\n+        }\n+    } temp2 = `Using tuples 2: ${x}, ${s}, ${f}`;\n+\n+    assert(\"Using tuples 2:  ,  , \", temp2.strings.toString());\n+    assert(x, temp2.insertions[0]);\n+    assert(s, temp2.insertions[1]);\n+    assert(f, temp2.insertions[2]);\n+\n+    object {\n+        public string[] strings = [];\n+        public [anydata...] insertions = [];\n+        string name = \"\";\n+    } temp3 = `Using tuples 3: ${x}, ${s}, ${f}`;\n+\n+    assert(\"Using tuples 3:  ,  , \", temp3.strings.toString());\n+    assert(x, temp2.insertions[0]);\n+    assert(s, temp3.insertions[1]);\n+    assert(f, temp3.insertions[2]);\n+}\n+\n+const FOO = \"Foo\";\n+const BAR = \"Bar\";\n+\n+type FooBar FOO|BAR;\n+\n+function testSubtyping3() {\n+    int x = 10;\n+\n+    object {\n+        public FooBar[] strings = [];\n+        public int[] insertions = [];\n+    } temp1 = `Foo${x}Bar`;\n+\n+    assert(<string[]>[\"Foo\", \"Bar\"], temp1.strings);\n+    assert(10, temp1.insertions[0]);\n+}\n+\n+function testUsageWithQueryExpressions() {\n+    int[] arr = [100, 200, 300, 400, 500];\n+\n+    ob:RawTemplate[] queries = from var x in arr\n+        select `INSERT INTO product ('id', 'name', 'price') VALUES (${x}, ${x + 10}, ${x + 20})`;\n+\n+    foreach var x in queries {\n+        assert(\"INSERT INTO product ('id', 'name', 'price') VALUES ( ,  ,  )\", x.strings.toString());\n+    }\n+\n+    int i = 0;\n+    foreach var x in queries {\n+        assert(string `${arr[i]} ${arr[i] + 10} ${arr[i] + 20}`, x.insertions.toString());\n+        i += 1;\n+    }\n+}\n+\n+public type Value ()|int|float|decimal|string|xml;\n+\n+public type ParameterizedQuery object {\n+    public string[] strings = [];\n+    public Value[] insertions = [];\n+};\n+\n+function testUsageWithQueryExpressions2() {\n+    var data = [\n+        {name: \"Alice1\"},\n+        {name: \"Alice2\"},\n+        {name: \"Alice3\"}\n+    ];\n+\n+    ParameterizedQuery[] queries = from var rec in data select `INSERT INTO People (name) values (${rec.name});`;\n+\n+    foreach var x in queries {\n+        assert(\"INSERT INTO People (name) values ( );\", x.strings.toString());\n+    }\n+\n+    int i = 0;\n+    foreach var x in queries {\n+        assert(data[i][\"name\"], x.insertions.toString());\n+        i += 1;\n+    }\n+}\n+\n+function testUseWithVar() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODU2NDAyMw=="}, "originalCommit": {"oid": "8ae4b7db94637e24df2fb309bf349c2cd3f8bc00"}, "originalPosition": 210}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMjE0NjI0OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/ASTBuilderUtil.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQwNjozMTozOVrOGiQMIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQxODozNToyM1rOGjN_ow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODU3MDAxNw==", "bodyText": "Shouldn't we keep this as is and use BLangListConstructorExpr.BLangTupleLiteral for tuples?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23705#discussion_r438570017", "createdAt": "2020-06-11T06:31:39Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/ASTBuilderUtil.java", "diffHunk": "@@ -626,7 +625,11 @@ static BLangRecordLiteral createEmptyRecordLiteral(DiagnosticPos pos, BType type\n         return recordKeyValue;\n     }\n \n-    static BLangListConstructorExpr.BLangArrayLiteral createEmptyArrayLiteral(DiagnosticPos pos, BArrayType type) {\n+    static BLangListConstructorExpr.BLangArrayLiteral createEmptyArrayLiteral(DiagnosticPos pos, BType type) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ae4b7db94637e24df2fb309bf349c2cd3f8bc00"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU4MjE2MQ==", "bodyText": "Ah I wasn't aware of this node. Just used this since it was the only API for creating an array.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23705#discussion_r439582161", "createdAt": "2020-06-12T18:34:20Z", "author": {"login": "pubudu91"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/ASTBuilderUtil.java", "diffHunk": "@@ -626,7 +625,11 @@ static BLangRecordLiteral createEmptyRecordLiteral(DiagnosticPos pos, BType type\n         return recordKeyValue;\n     }\n \n-    static BLangListConstructorExpr.BLangArrayLiteral createEmptyArrayLiteral(DiagnosticPos pos, BArrayType type) {\n+    static BLangListConstructorExpr.BLangArrayLiteral createEmptyArrayLiteral(DiagnosticPos pos, BType type) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODU3MDAxNw=="}, "originalCommit": {"oid": "8ae4b7db94637e24df2fb309bf349c2cd3f8bc00"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU4MjYyNw==", "bodyText": "Come to think of it, I probably should be creating a BLangListConstructorExpr and let the desugar handle separating it out to array and tuple literals right?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23705#discussion_r439582627", "createdAt": "2020-06-12T18:35:23Z", "author": {"login": "pubudu91"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/ASTBuilderUtil.java", "diffHunk": "@@ -626,7 +625,11 @@ static BLangRecordLiteral createEmptyRecordLiteral(DiagnosticPos pos, BType type\n         return recordKeyValue;\n     }\n \n-    static BLangListConstructorExpr.BLangArrayLiteral createEmptyArrayLiteral(DiagnosticPos pos, BArrayType type) {\n+    static BLangListConstructorExpr.BLangArrayLiteral createEmptyArrayLiteral(DiagnosticPos pos, BType type) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODU3MDAxNw=="}, "originalCommit": {"oid": "8ae4b7db94637e24df2fb309bf349c2cd3f8bc00"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMzc1Nzc5OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/util/Flags.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNDozNDoyN1rOGigN0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNDo0NzozOVrOGigyBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODgzMjU5NQ==", "bodyText": "not used ?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23705#discussion_r438832595", "createdAt": "2020-06-11T14:34:27Z", "author": {"login": "KRVPerera"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/util/Flags.java", "diffHunk": "@@ -225,6 +225,10 @@ public static int asMask(Set<Flag> flagSet) {\n         return flagSet;\n     }\n \n+    public static int unset(int mask, int flag) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66641535b5ebb4c17aab78b0c7d6426a285b721c"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg0MTg2MA==", "bodyText": "This is used in desugarTemplateLiteralObjectTypedef() method in Desugar", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23705#discussion_r438841860", "createdAt": "2020-06-11T14:47:39Z", "author": {"login": "pubudu91"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/util/Flags.java", "diffHunk": "@@ -225,6 +225,10 @@ public static int asMask(Set<Flag> flagSet) {\n         return flagSet;\n     }\n \n+    public static int unset(int mask, int flag) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODgzMjU5NQ=="}, "originalCommit": {"oid": "66641535b5ebb4c17aab78b0c7d6426a285b721c"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczNDQzMDg2OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNzoxNTo1OVrOGinAgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQxODozNzowNlrOGjOCdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk0Mzg3NA==", "bodyText": "Is this comment still valid?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23705#discussion_r438943874", "createdAt": "2020-06-11T17:15:59Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java", "diffHunk": "@@ -4263,6 +4281,160 @@ public void visit(BLangStringTemplateLiteral stringTemplateLiteral) {\n         result = rewriteExpr(constructStringTemplateConcatExpression(stringTemplateLiteral.exprs));\n     }\n \n+    /**\n+     * The raw template literal gets desugared to a type init expression. For each literal, a new object class type\n+     * def is generated from the object type. The type init expression creates an instance of this generated object\n+     * type. For example, consider the following statements:\n+     *      string name = \"Pubudu\";\n+     *      'object:RawTemplate rt = `Hello ${name}!`;\n+     *\n+     * The raw template literal above is desugared to:\n+     *      type RawTemplate$Impl$0 object {\n+     *          public string[] strings = [\"Hello \", \"!\"];\n+     *          public (any|error)[] insertions;\n+     *\n+     *          function init((any|error)[] insertions) {\n+     *              self.insertions = insertions;\n+     *          }\n+     *      };\n+     *\n+     *      // somewhere in code\n+     *      'object:RawTemplate rt = new RawTemplate$Impl$0([name]);\n+     *\n+     * @param rawTemplateLiteral The raw template literal to be desugared.\n+     */\n+    @Override\n+    public void visit(BLangRawTemplateLiteral rawTemplateLiteral) {\n+        DiagnosticPos pos = rawTemplateLiteral.pos;\n+        BObjectType objType = (BObjectType) rawTemplateLiteral.type;\n+        BLangTypeDefinition objClassDef = desugarTemplateLiteralObjectTypedef(rawTemplateLiteral.strings, objType, pos);\n+        BObjectType classObjType = (BObjectType) objClassDef.type;\n+\n+        BVarSymbol insertionsSym = classObjType.fields.get(\"insertions\").symbol;\n+        BLangListConstructorExpr insertionsList = ASTBuilderUtil.createEmptyArrayLiteral(pos, insertionsSym.type);\n+        insertionsList.exprs.addAll(rawTemplateLiteral.insertions);\n+        insertionsList.expectedType = insertionsSym.type;\n+\n+        // Create an instance of the generated object class\n+        BLangTypeInit typeNewExpr = ASTBuilderUtil.createEmptyTypeInit(pos, classObjType);\n+        typeNewExpr.argsExpr.add(insertionsList);\n+        typeNewExpr.initInvocation.argExprs.add(insertionsList);\n+        typeNewExpr.initInvocation.requiredArgs.add(insertionsList);\n+\n+        result = rewriteExpr(typeNewExpr);\n+    }\n+\n+    /**\n+     * This method desugars a raw template literal object class for the provided raw template object type as follows.\n+     * A literal defined as 'object:RawTemplate rt = `Hello ${name}!`;\n+     * is desugared to,\n+     *      type $anonType$0 object {\n+     *          public string[] strings = [\"Hello \", \"!\"];\n+     *          public (any|error)[] insertions;\n+     *\n+     *          function init((any|error)[] insertions) {\n+     *              self.insertions = insertions;\n+     *          }\n+     *      };\n+     * @param strings    The string portions of the literal\n+     * @param objectType The abstract object type for which an object class needs to be generated\n+     * @param pos        The diagnostic position info for the type node\n+     * @return Returns the generated concrete object class def\n+     */\n+    private BLangTypeDefinition desugarTemplateLiteralObjectTypedef(List<BLangLiteral> strings, BObjectType objectType,\n+                                                                    DiagnosticPos pos) {\n+        // TODO: Use the anon model helper to generate the object name?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "891490b3a6b6b735e7100ecee4a9aea422113bcc"}, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU4MzM1MA==", "bodyText": "I think it would be better. Have to add an API to the anon model helper for it. So was planning to push it as a further improvement in preview2.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23705#discussion_r439583350", "createdAt": "2020-06-12T18:37:06Z", "author": {"login": "pubudu91"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java", "diffHunk": "@@ -4263,6 +4281,160 @@ public void visit(BLangStringTemplateLiteral stringTemplateLiteral) {\n         result = rewriteExpr(constructStringTemplateConcatExpression(stringTemplateLiteral.exprs));\n     }\n \n+    /**\n+     * The raw template literal gets desugared to a type init expression. For each literal, a new object class type\n+     * def is generated from the object type. The type init expression creates an instance of this generated object\n+     * type. For example, consider the following statements:\n+     *      string name = \"Pubudu\";\n+     *      'object:RawTemplate rt = `Hello ${name}!`;\n+     *\n+     * The raw template literal above is desugared to:\n+     *      type RawTemplate$Impl$0 object {\n+     *          public string[] strings = [\"Hello \", \"!\"];\n+     *          public (any|error)[] insertions;\n+     *\n+     *          function init((any|error)[] insertions) {\n+     *              self.insertions = insertions;\n+     *          }\n+     *      };\n+     *\n+     *      // somewhere in code\n+     *      'object:RawTemplate rt = new RawTemplate$Impl$0([name]);\n+     *\n+     * @param rawTemplateLiteral The raw template literal to be desugared.\n+     */\n+    @Override\n+    public void visit(BLangRawTemplateLiteral rawTemplateLiteral) {\n+        DiagnosticPos pos = rawTemplateLiteral.pos;\n+        BObjectType objType = (BObjectType) rawTemplateLiteral.type;\n+        BLangTypeDefinition objClassDef = desugarTemplateLiteralObjectTypedef(rawTemplateLiteral.strings, objType, pos);\n+        BObjectType classObjType = (BObjectType) objClassDef.type;\n+\n+        BVarSymbol insertionsSym = classObjType.fields.get(\"insertions\").symbol;\n+        BLangListConstructorExpr insertionsList = ASTBuilderUtil.createEmptyArrayLiteral(pos, insertionsSym.type);\n+        insertionsList.exprs.addAll(rawTemplateLiteral.insertions);\n+        insertionsList.expectedType = insertionsSym.type;\n+\n+        // Create an instance of the generated object class\n+        BLangTypeInit typeNewExpr = ASTBuilderUtil.createEmptyTypeInit(pos, classObjType);\n+        typeNewExpr.argsExpr.add(insertionsList);\n+        typeNewExpr.initInvocation.argExprs.add(insertionsList);\n+        typeNewExpr.initInvocation.requiredArgs.add(insertionsList);\n+\n+        result = rewriteExpr(typeNewExpr);\n+    }\n+\n+    /**\n+     * This method desugars a raw template literal object class for the provided raw template object type as follows.\n+     * A literal defined as 'object:RawTemplate rt = `Hello ${name}!`;\n+     * is desugared to,\n+     *      type $anonType$0 object {\n+     *          public string[] strings = [\"Hello \", \"!\"];\n+     *          public (any|error)[] insertions;\n+     *\n+     *          function init((any|error)[] insertions) {\n+     *              self.insertions = insertions;\n+     *          }\n+     *      };\n+     * @param strings    The string portions of the literal\n+     * @param objectType The abstract object type for which an object class needs to be generated\n+     * @param pos        The diagnostic position info for the type node\n+     * @return Returns the generated concrete object class def\n+     */\n+    private BLangTypeDefinition desugarTemplateLiteralObjectTypedef(List<BLangLiteral> strings, BObjectType objectType,\n+                                                                    DiagnosticPos pos) {\n+        // TODO: Use the anon model helper to generate the object name?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk0Mzg3NA=="}, "originalCommit": {"oid": "891490b3a6b6b735e7100ecee4a9aea422113bcc"}, "originalPosition": 161}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczNzMzNjgyOnYy", "diffSide": "RIGHT", "path": "langlib/lang.object/src/main/ballerina/src/lang.object/raw_template.bal", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQxMzowOTozN1rOGjDWiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQxODozNzoyNVrOGjODCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQwODI2NQ==", "bodyText": "Should we add at least a one-line description for the time-being?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23705#discussion_r439408265", "createdAt": "2020-06-12T13:09:37Z", "author": {"login": "MaryamZi"}, "path": "langlib/lang.object/src/main/ballerina/src/lang.object/raw_template.bal", "diffHunk": "@@ -0,0 +1,21 @@\n+// Copyright (c) 2020 WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+//\n+// WSO2 Inc. licenses this file to you under the Apache License,\n+// Version 2.0 (the \"License\"); you may not use this file except\n+// in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+// TODO: Add docs", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1ed2ff235a7b21c5fea3c740f46ba2533779e8ce"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU4MzQ5Ng==", "bodyText": "Ack. Will do", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23705#discussion_r439583496", "createdAt": "2020-06-12T18:37:25Z", "author": {"login": "pubudu91"}, "path": "langlib/lang.object/src/main/ballerina/src/lang.object/raw_template.bal", "diffHunk": "@@ -0,0 +1,21 @@\n+// Copyright (c) 2020 WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+//\n+// WSO2 Inc. licenses this file to you under the Apache License,\n+// Version 2.0 (the \"License\"); you may not use this file except\n+// in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+// TODO: Add docs", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQwODI2NQ=="}, "originalCommit": {"oid": "1ed2ff235a7b21c5fea3c740f46ba2533779e8ce"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczNzkwMzM5OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQxNTo1MDowMFrOGjI9-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QwNzoyMjowOVrOGjWNyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUwMDI4Mw==", "bodyText": "When we use an invalid type now, the error is for the rawTemplateLiteral itself.\npublic type Template abstract object {\n    public string[] strings;\n};\n\npublic function main() {\n    string name = \"World\";\n\n    Template greeting = `Hello ${name}`; // error: .::xyz.bal:8:25: incompatible types: expected 'ballerina/lang.object:1.0.0:RawTemplate', found 'Template'\n}\nShouldn't the error be for the expected type, to say something like these template literals are only allowed with sub-types of 'lang.object:RawTemplate'?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23705#discussion_r439500283", "createdAt": "2020-06-12T15:50:00Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -3619,6 +3622,111 @@ public void visit(BLangStringTemplateLiteral stringTemplateLiteral) {\n         resultType = types.checkType(stringTemplateLiteral, symTable.stringType, expType);\n     }\n \n+    @Override\n+    public void visit(BLangRawTemplateLiteral rawTemplateLiteral) {\n+        // First, ensure that the contextually expected type is compatible with the RawTemplate type.\n+        // The RawTemplate type should have just two fields: strings and insertions. There shouldn't be any methods.\n+        BType type = determineRawTemplateLiteralType(rawTemplateLiteral, expType);\n+\n+        if (type == symTable.semanticError) {\n+            resultType = type;\n+            return;\n+        }\n+\n+        // Once we ensure the types are compatible, need to ensure that the types of the strings and insertions are\n+        // compatible with the types of the strings and insertions fields.\n+        BObjectType literalType = (BObjectType) type;\n+        BType stringsType = literalType.fields.get(\"strings\").type;\n+\n+        if (evaluateRawTemplateExprs(rawTemplateLiteral.strings, stringsType, INVALID_NUM_STRINGS,\n+                                     rawTemplateLiteral.pos)) {\n+            type = symTable.semanticError;\n+        }\n+\n+        BType insertionsType = literalType.fields.get(\"insertions\").type;\n+\n+        if (evaluateRawTemplateExprs(rawTemplateLiteral.insertions, insertionsType, INVALID_NUM_INSERTIONS,\n+                                     rawTemplateLiteral.pos)) {\n+            type = symTable.semanticError;\n+        }\n+\n+        resultType = type;\n+    }\n+\n+    private BType determineRawTemplateLiteralType(BLangRawTemplateLiteral rawTemplateLiteral, BType expType) {\n+        // Contextually expected type is NoType when `var` is used.\n+        // Therefore consider the literal as of type RawTemplate\n+        if (expType == symTable.noType) {\n+            return symTable.rawTemplateType;\n+        }\n+\n+        BType type = types.checkType(rawTemplateLiteral, expType, symTable.rawTemplateType);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd82f348921449885db5de62db2be7576acdb103"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU4NDYwMQ==", "bodyText": "Hmm yes, that does look wrong. I guess the correct way to do this would be to do what you suggested in #23705 (comment) and not switch the order. Will change.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23705#discussion_r439584601", "createdAt": "2020-06-12T18:40:07Z", "author": {"login": "pubudu91"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -3619,6 +3622,111 @@ public void visit(BLangStringTemplateLiteral stringTemplateLiteral) {\n         resultType = types.checkType(stringTemplateLiteral, symTable.stringType, expType);\n     }\n \n+    @Override\n+    public void visit(BLangRawTemplateLiteral rawTemplateLiteral) {\n+        // First, ensure that the contextually expected type is compatible with the RawTemplate type.\n+        // The RawTemplate type should have just two fields: strings and insertions. There shouldn't be any methods.\n+        BType type = determineRawTemplateLiteralType(rawTemplateLiteral, expType);\n+\n+        if (type == symTable.semanticError) {\n+            resultType = type;\n+            return;\n+        }\n+\n+        // Once we ensure the types are compatible, need to ensure that the types of the strings and insertions are\n+        // compatible with the types of the strings and insertions fields.\n+        BObjectType literalType = (BObjectType) type;\n+        BType stringsType = literalType.fields.get(\"strings\").type;\n+\n+        if (evaluateRawTemplateExprs(rawTemplateLiteral.strings, stringsType, INVALID_NUM_STRINGS,\n+                                     rawTemplateLiteral.pos)) {\n+            type = symTable.semanticError;\n+        }\n+\n+        BType insertionsType = literalType.fields.get(\"insertions\").type;\n+\n+        if (evaluateRawTemplateExprs(rawTemplateLiteral.insertions, insertionsType, INVALID_NUM_INSERTIONS,\n+                                     rawTemplateLiteral.pos)) {\n+            type = symTable.semanticError;\n+        }\n+\n+        resultType = type;\n+    }\n+\n+    private BType determineRawTemplateLiteralType(BLangRawTemplateLiteral rawTemplateLiteral, BType expType) {\n+        // Contextually expected type is NoType when `var` is used.\n+        // Therefore consider the literal as of type RawTemplate\n+        if (expType == symTable.noType) {\n+            return symTable.rawTemplateType;\n+        }\n+\n+        BType type = types.checkType(rawTemplateLiteral, expType, symTable.rawTemplateType);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUwMDI4Mw=="}, "originalCommit": {"oid": "fd82f348921449885db5de62db2be7576acdb103"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTYxNjE4MQ==", "bodyText": "Had a look at this. Instead of type checking against an inferred type, how about giving a different error here, instead of the standard incompatible types error? The reason is, to infer a type, we'll have to first individually type check the strings and insertions. But since now we are not type checking those two fields against a type, we'll be losing more accurate error messages we can give like in the following scenario.\ntype Temp abstract object {\n    public [string, string, string] strings;\n    public [int, float] insertions;\n};\n\nfunction testTypeChecking() {\n    Temp rt = `Foo${8}Bar${\"asdf\"}`;\n}\nThe error:\nerror: .::test.bal:7:29: incompatible types: expected 'float', found 'string'\n\nIf we infer a type and type check what we'd get is the standard incompatible message like:\nerror: .::test.bal:7:16: incompatible types: expected 'Temp', found 'abstract object {....}'", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23705#discussion_r439616181", "createdAt": "2020-06-12T19:57:21Z", "author": {"login": "pubudu91"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -3619,6 +3622,111 @@ public void visit(BLangStringTemplateLiteral stringTemplateLiteral) {\n         resultType = types.checkType(stringTemplateLiteral, symTable.stringType, expType);\n     }\n \n+    @Override\n+    public void visit(BLangRawTemplateLiteral rawTemplateLiteral) {\n+        // First, ensure that the contextually expected type is compatible with the RawTemplate type.\n+        // The RawTemplate type should have just two fields: strings and insertions. There shouldn't be any methods.\n+        BType type = determineRawTemplateLiteralType(rawTemplateLiteral, expType);\n+\n+        if (type == symTable.semanticError) {\n+            resultType = type;\n+            return;\n+        }\n+\n+        // Once we ensure the types are compatible, need to ensure that the types of the strings and insertions are\n+        // compatible with the types of the strings and insertions fields.\n+        BObjectType literalType = (BObjectType) type;\n+        BType stringsType = literalType.fields.get(\"strings\").type;\n+\n+        if (evaluateRawTemplateExprs(rawTemplateLiteral.strings, stringsType, INVALID_NUM_STRINGS,\n+                                     rawTemplateLiteral.pos)) {\n+            type = symTable.semanticError;\n+        }\n+\n+        BType insertionsType = literalType.fields.get(\"insertions\").type;\n+\n+        if (evaluateRawTemplateExprs(rawTemplateLiteral.insertions, insertionsType, INVALID_NUM_INSERTIONS,\n+                                     rawTemplateLiteral.pos)) {\n+            type = symTable.semanticError;\n+        }\n+\n+        resultType = type;\n+    }\n+\n+    private BType determineRawTemplateLiteralType(BLangRawTemplateLiteral rawTemplateLiteral, BType expType) {\n+        // Contextually expected type is NoType when `var` is used.\n+        // Therefore consider the literal as of type RawTemplate\n+        if (expType == symTable.noType) {\n+            return symTable.rawTemplateType;\n+        }\n+\n+        BType type = types.checkType(rawTemplateLiteral, expType, symTable.rawTemplateType);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUwMDI4Mw=="}, "originalCommit": {"oid": "fd82f348921449885db5de62db2be7576acdb103"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwNjEzMg==", "bodyText": "Yeah. I also think a different error would be more explanatory here. It's a bit different from our usual errors, but I guess that's OK given that this is kinda different syntax to create a value of a specific type of object?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23705#discussion_r439706132", "createdAt": "2020-06-13T03:52:55Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -3619,6 +3622,111 @@ public void visit(BLangStringTemplateLiteral stringTemplateLiteral) {\n         resultType = types.checkType(stringTemplateLiteral, symTable.stringType, expType);\n     }\n \n+    @Override\n+    public void visit(BLangRawTemplateLiteral rawTemplateLiteral) {\n+        // First, ensure that the contextually expected type is compatible with the RawTemplate type.\n+        // The RawTemplate type should have just two fields: strings and insertions. There shouldn't be any methods.\n+        BType type = determineRawTemplateLiteralType(rawTemplateLiteral, expType);\n+\n+        if (type == symTable.semanticError) {\n+            resultType = type;\n+            return;\n+        }\n+\n+        // Once we ensure the types are compatible, need to ensure that the types of the strings and insertions are\n+        // compatible with the types of the strings and insertions fields.\n+        BObjectType literalType = (BObjectType) type;\n+        BType stringsType = literalType.fields.get(\"strings\").type;\n+\n+        if (evaluateRawTemplateExprs(rawTemplateLiteral.strings, stringsType, INVALID_NUM_STRINGS,\n+                                     rawTemplateLiteral.pos)) {\n+            type = symTable.semanticError;\n+        }\n+\n+        BType insertionsType = literalType.fields.get(\"insertions\").type;\n+\n+        if (evaluateRawTemplateExprs(rawTemplateLiteral.insertions, insertionsType, INVALID_NUM_INSERTIONS,\n+                                     rawTemplateLiteral.pos)) {\n+            type = symTable.semanticError;\n+        }\n+\n+        resultType = type;\n+    }\n+\n+    private BType determineRawTemplateLiteralType(BLangRawTemplateLiteral rawTemplateLiteral, BType expType) {\n+        // Contextually expected type is NoType when `var` is used.\n+        // Therefore consider the literal as of type RawTemplate\n+        if (expType == symTable.noType) {\n+            return symTable.rawTemplateType;\n+        }\n+\n+        BType type = types.checkType(rawTemplateLiteral, expType, symTable.rawTemplateType);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUwMDI4Mw=="}, "originalCommit": {"oid": "fd82f348921449885db5de62db2be7576acdb103"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcxMzY1MA==", "bodyText": "Yeah, was thinking the same. Will type check with a different error message", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23705#discussion_r439713650", "createdAt": "2020-06-13T06:17:22Z", "author": {"login": "pubudu91"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -3619,6 +3622,111 @@ public void visit(BLangStringTemplateLiteral stringTemplateLiteral) {\n         resultType = types.checkType(stringTemplateLiteral, symTable.stringType, expType);\n     }\n \n+    @Override\n+    public void visit(BLangRawTemplateLiteral rawTemplateLiteral) {\n+        // First, ensure that the contextually expected type is compatible with the RawTemplate type.\n+        // The RawTemplate type should have just two fields: strings and insertions. There shouldn't be any methods.\n+        BType type = determineRawTemplateLiteralType(rawTemplateLiteral, expType);\n+\n+        if (type == symTable.semanticError) {\n+            resultType = type;\n+            return;\n+        }\n+\n+        // Once we ensure the types are compatible, need to ensure that the types of the strings and insertions are\n+        // compatible with the types of the strings and insertions fields.\n+        BObjectType literalType = (BObjectType) type;\n+        BType stringsType = literalType.fields.get(\"strings\").type;\n+\n+        if (evaluateRawTemplateExprs(rawTemplateLiteral.strings, stringsType, INVALID_NUM_STRINGS,\n+                                     rawTemplateLiteral.pos)) {\n+            type = symTable.semanticError;\n+        }\n+\n+        BType insertionsType = literalType.fields.get(\"insertions\").type;\n+\n+        if (evaluateRawTemplateExprs(rawTemplateLiteral.insertions, insertionsType, INVALID_NUM_INSERTIONS,\n+                                     rawTemplateLiteral.pos)) {\n+            type = symTable.semanticError;\n+        }\n+\n+        resultType = type;\n+    }\n+\n+    private BType determineRawTemplateLiteralType(BLangRawTemplateLiteral rawTemplateLiteral, BType expType) {\n+        // Contextually expected type is NoType when `var` is used.\n+        // Therefore consider the literal as of type RawTemplate\n+        if (expType == symTable.noType) {\n+            return symTable.rawTemplateType;\n+        }\n+\n+        BType type = types.checkType(rawTemplateLiteral, expType, symTable.rawTemplateType);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUwMDI4Mw=="}, "originalCommit": {"oid": "fd82f348921449885db5de62db2be7576acdb103"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcxNzMyMQ==", "bodyText": "Changed to the following in 7f3b0c2\ninvalid literal for type 'string': raw templates can only be assigned to abstract subtypes of 'ballerina/lang.object:1.0.0:RawTemplate'", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23705#discussion_r439717321", "createdAt": "2020-06-13T07:22:09Z", "author": {"login": "pubudu91"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -3619,6 +3622,111 @@ public void visit(BLangStringTemplateLiteral stringTemplateLiteral) {\n         resultType = types.checkType(stringTemplateLiteral, symTable.stringType, expType);\n     }\n \n+    @Override\n+    public void visit(BLangRawTemplateLiteral rawTemplateLiteral) {\n+        // First, ensure that the contextually expected type is compatible with the RawTemplate type.\n+        // The RawTemplate type should have just two fields: strings and insertions. There shouldn't be any methods.\n+        BType type = determineRawTemplateLiteralType(rawTemplateLiteral, expType);\n+\n+        if (type == symTable.semanticError) {\n+            resultType = type;\n+            return;\n+        }\n+\n+        // Once we ensure the types are compatible, need to ensure that the types of the strings and insertions are\n+        // compatible with the types of the strings and insertions fields.\n+        BObjectType literalType = (BObjectType) type;\n+        BType stringsType = literalType.fields.get(\"strings\").type;\n+\n+        if (evaluateRawTemplateExprs(rawTemplateLiteral.strings, stringsType, INVALID_NUM_STRINGS,\n+                                     rawTemplateLiteral.pos)) {\n+            type = symTable.semanticError;\n+        }\n+\n+        BType insertionsType = literalType.fields.get(\"insertions\").type;\n+\n+        if (evaluateRawTemplateExprs(rawTemplateLiteral.insertions, insertionsType, INVALID_NUM_INSERTIONS,\n+                                     rawTemplateLiteral.pos)) {\n+            type = symTable.semanticError;\n+        }\n+\n+        resultType = type;\n+    }\n+\n+    private BType determineRawTemplateLiteralType(BLangRawTemplateLiteral rawTemplateLiteral, BType expType) {\n+        // Contextually expected type is NoType when `var` is used.\n+        // Therefore consider the literal as of type RawTemplate\n+        if (expType == symTable.noType) {\n+            return symTable.rawTemplateType;\n+        }\n+\n+        BType type = types.checkType(rawTemplateLiteral, expType, symTable.rawTemplateType);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUwMDI4Mw=="}, "originalCommit": {"oid": "fd82f348921449885db5de62db2be7576acdb103"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczNzk1ODk2OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/tree/expressions/BLangRawTemplateLiteral.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQxNjowNzoxOFrOGjJhow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QwNDowNzo0MVrOGjVlIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUwOTQxMQ==", "bodyText": "Could this ever get printed? Shouldn't the string representation differentiate between the insertions and the strings?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23705#discussion_r439509411", "createdAt": "2020-06-12T16:07:18Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/tree/expressions/BLangRawTemplateLiteral.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.wso2.ballerinalang.compiler.tree.expressions;\n+\n+import org.ballerinalang.model.tree.NodeKind;\n+import org.ballerinalang.model.tree.expressions.ExpressionNode;\n+import org.ballerinalang.model.tree.expressions.RawTemplateLiteralNode;\n+import org.wso2.ballerinalang.compiler.tree.BLangNodeVisitor;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Represents a raw template literal of the form: `Hello ${name}!`. This gets desugared to an object:RawTemplate object\n+ * or a subtype of this.\n+ *\n+ * @since 2.0.0\n+ */\n+public class BLangRawTemplateLiteral extends BLangExpression implements RawTemplateLiteralNode {\n+\n+    public List<BLangExpression> insertions;\n+    public List<BLangLiteral> strings;\n+\n+    public BLangRawTemplateLiteral() {\n+        insertions = new ArrayList<>();\n+        strings = new ArrayList<>();\n+    }\n+\n+    @Override\n+    public void accept(BLangNodeVisitor visitor) {\n+        visitor.visit(this);\n+    }\n+\n+    @Override\n+    public NodeKind getKind() {\n+        return NodeKind.RAW_TEMPLATE_LITERAL;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"BLangRawTemplateLiteral: \" + insertions + \" \" + strings;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd82f348921449885db5de62db2be7576acdb103"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU4NTkwOA==", "bodyText": "No, don't think so, since this is the node itself. This just shows up in the debugger as the string representation of the node AFAIK. The string looks something like the following:\nBLangRawTemplateLiteral: [name]  [Hello, how are you?]", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23705#discussion_r439585908", "createdAt": "2020-06-12T18:43:04Z", "author": {"login": "pubudu91"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/tree/expressions/BLangRawTemplateLiteral.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.wso2.ballerinalang.compiler.tree.expressions;\n+\n+import org.ballerinalang.model.tree.NodeKind;\n+import org.ballerinalang.model.tree.expressions.ExpressionNode;\n+import org.ballerinalang.model.tree.expressions.RawTemplateLiteralNode;\n+import org.wso2.ballerinalang.compiler.tree.BLangNodeVisitor;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Represents a raw template literal of the form: `Hello ${name}!`. This gets desugared to an object:RawTemplate object\n+ * or a subtype of this.\n+ *\n+ * @since 2.0.0\n+ */\n+public class BLangRawTemplateLiteral extends BLangExpression implements RawTemplateLiteralNode {\n+\n+    public List<BLangExpression> insertions;\n+    public List<BLangLiteral> strings;\n+\n+    public BLangRawTemplateLiteral() {\n+        insertions = new ArrayList<>();\n+        strings = new ArrayList<>();\n+    }\n+\n+    @Override\n+    public void accept(BLangNodeVisitor visitor) {\n+        visitor.visit(this);\n+    }\n+\n+    @Override\n+    public NodeKind getKind() {\n+        return NodeKind.RAW_TEMPLATE_LITERAL;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"BLangRawTemplateLiteral: \" + insertions + \" \" + strings;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUwOTQxMQ=="}, "originalCommit": {"oid": "fd82f348921449885db5de62db2be7576acdb103"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwNjkxNQ==", "bodyText": "Was just wondering if we should change this to something like\nBLangRawTemplateLiteral: insertions [name] strings [Hello, how are you?]", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23705#discussion_r439706915", "createdAt": "2020-06-13T04:07:41Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/tree/expressions/BLangRawTemplateLiteral.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.wso2.ballerinalang.compiler.tree.expressions;\n+\n+import org.ballerinalang.model.tree.NodeKind;\n+import org.ballerinalang.model.tree.expressions.ExpressionNode;\n+import org.ballerinalang.model.tree.expressions.RawTemplateLiteralNode;\n+import org.wso2.ballerinalang.compiler.tree.BLangNodeVisitor;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Represents a raw template literal of the form: `Hello ${name}!`. This gets desugared to an object:RawTemplate object\n+ * or a subtype of this.\n+ *\n+ * @since 2.0.0\n+ */\n+public class BLangRawTemplateLiteral extends BLangExpression implements RawTemplateLiteralNode {\n+\n+    public List<BLangExpression> insertions;\n+    public List<BLangLiteral> strings;\n+\n+    public BLangRawTemplateLiteral() {\n+        insertions = new ArrayList<>();\n+        strings = new ArrayList<>();\n+    }\n+\n+    @Override\n+    public void accept(BLangNodeVisitor visitor) {\n+        visitor.visit(this);\n+    }\n+\n+    @Override\n+    public NodeKind getKind() {\n+        return NodeKind.RAW_TEMPLATE_LITERAL;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"BLangRawTemplateLiteral: \" + insertions + \" \" + strings;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUwOTQxMQ=="}, "originalCommit": {"oid": "fd82f348921449885db5de62db2be7576acdb103"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczNzk3NjAzOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/resources/compiler.properties", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQxNjoxMTozOFrOGjJsOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQxODo0Mzo1N1rOGjOOFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUxMjEyMg==", "bodyText": "Should we say\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              invalid raw template assignment: ''{0}'' expected to be abstract\n          \n          \n            \n              invalid raw template assignment: ''{0}'' should be an abstract object", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23705#discussion_r439512122", "createdAt": "2020-06-12T16:11:38Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/resources/compiler.properties", "diffHunk": "@@ -1363,3 +1363,18 @@ error.invalid.param.type.for.return.type=\\\n \n error.invalid.typedesc.param=\\\n   default value for a ''typedesc'' parameter used in the return type should be a reference to a type\n+\n+error.invalid.num.of.strings=\\\n+  invalid raw template: expected {0} string(s), but found {1} string(s)\n+\n+error.invalid.num.of.insertions=\\\n+  invalid raw template: expected {0} insertion(s), but found {1} insertion(s)\n+\n+error.invalid.raw.template.assignment=\\\n+  invalid raw template assignment: ''{0}'' expected to be abstract", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd82f348921449885db5de62db2be7576acdb103"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU2NTEwOA==", "bodyText": "If we are changing this we'll have to change the next 2 too.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23705#discussion_r439565108", "createdAt": "2020-06-12T17:56:38Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/resources/compiler.properties", "diffHunk": "@@ -1363,3 +1363,18 @@ error.invalid.param.type.for.return.type=\\\n \n error.invalid.typedesc.param=\\\n   default value for a ''typedesc'' parameter used in the return type should be a reference to a type\n+\n+error.invalid.num.of.strings=\\\n+  invalid raw template: expected {0} string(s), but found {1} string(s)\n+\n+error.invalid.num.of.insertions=\\\n+  invalid raw template: expected {0} insertion(s), but found {1} insertion(s)\n+\n+error.invalid.raw.template.assignment=\\\n+  invalid raw template assignment: ''{0}'' expected to be abstract", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUxMjEyMg=="}, "originalCommit": {"oid": "fd82f348921449885db5de62db2be7576acdb103"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU4NjMyNw==", "bodyText": "Will see. Might have to reword the error messages if going with inferring a type for the literal first", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23705#discussion_r439586327", "createdAt": "2020-06-12T18:43:57Z", "author": {"login": "pubudu91"}, "path": "compiler/ballerina-lang/src/main/resources/compiler.properties", "diffHunk": "@@ -1363,3 +1363,18 @@ error.invalid.param.type.for.return.type=\\\n \n error.invalid.typedesc.param=\\\n   default value for a ''typedesc'' parameter used in the return type should be a reference to a type\n+\n+error.invalid.num.of.strings=\\\n+  invalid raw template: expected {0} string(s), but found {1} string(s)\n+\n+error.invalid.num.of.insertions=\\\n+  invalid raw template: expected {0} insertion(s), but found {1} insertion(s)\n+\n+error.invalid.raw.template.assignment=\\\n+  invalid raw template assignment: ''{0}'' expected to be abstract", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUxMjEyMg=="}, "originalCommit": {"oid": "fd82f348921449885db5de62db2be7576acdb103"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczODM0MjQ4OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQxODoxMjowN1rOGjNWSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQxODo0NzozOVrOGjOUwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU3MjA0MQ==", "bodyText": "Can/should we infer a narrower type instead, at least in the future??\nFor example, for\npublic function main() {\n    string item = \"Book\";\n    int count = 2;\n\n    var temp = `${item} count: ${count}`;\n}\ncan we infer something like\nabstract object {\n    public [string, string, string] strings;\n    public [string, int] insertions;\n}", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23705#discussion_r439572041", "createdAt": "2020-06-12T18:12:07Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -3619,6 +3622,111 @@ public void visit(BLangStringTemplateLiteral stringTemplateLiteral) {\n         resultType = types.checkType(stringTemplateLiteral, symTable.stringType, expType);\n     }\n \n+    @Override\n+    public void visit(BLangRawTemplateLiteral rawTemplateLiteral) {\n+        // First, ensure that the contextually expected type is compatible with the RawTemplate type.\n+        // The RawTemplate type should have just two fields: strings and insertions. There shouldn't be any methods.\n+        BType type = determineRawTemplateLiteralType(rawTemplateLiteral, expType);\n+\n+        if (type == symTable.semanticError) {\n+            resultType = type;\n+            return;\n+        }\n+\n+        // Once we ensure the types are compatible, need to ensure that the types of the strings and insertions are\n+        // compatible with the types of the strings and insertions fields.\n+        BObjectType literalType = (BObjectType) type;\n+        BType stringsType = literalType.fields.get(\"strings\").type;\n+\n+        if (evaluateRawTemplateExprs(rawTemplateLiteral.strings, stringsType, INVALID_NUM_STRINGS,\n+                                     rawTemplateLiteral.pos)) {\n+            type = symTable.semanticError;\n+        }\n+\n+        BType insertionsType = literalType.fields.get(\"insertions\").type;\n+\n+        if (evaluateRawTemplateExprs(rawTemplateLiteral.insertions, insertionsType, INVALID_NUM_INSERTIONS,\n+                                     rawTemplateLiteral.pos)) {\n+            type = symTable.semanticError;\n+        }\n+\n+        resultType = type;\n+    }\n+\n+    private BType determineRawTemplateLiteralType(BLangRawTemplateLiteral rawTemplateLiteral, BType expType) {\n+        // Contextually expected type is NoType when `var` is used.\n+        // Therefore consider the literal as of type RawTemplate\n+        if (expType == symTable.noType) {\n+            return symTable.rawTemplateType;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd82f348921449885db5de62db2be7576acdb103"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU4ODAzMw==", "bodyText": "Yes, should be inferring a narrower type. Will see check and see.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23705#discussion_r439588033", "createdAt": "2020-06-12T18:47:39Z", "author": {"login": "pubudu91"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -3619,6 +3622,111 @@ public void visit(BLangStringTemplateLiteral stringTemplateLiteral) {\n         resultType = types.checkType(stringTemplateLiteral, symTable.stringType, expType);\n     }\n \n+    @Override\n+    public void visit(BLangRawTemplateLiteral rawTemplateLiteral) {\n+        // First, ensure that the contextually expected type is compatible with the RawTemplate type.\n+        // The RawTemplate type should have just two fields: strings and insertions. There shouldn't be any methods.\n+        BType type = determineRawTemplateLiteralType(rawTemplateLiteral, expType);\n+\n+        if (type == symTable.semanticError) {\n+            resultType = type;\n+            return;\n+        }\n+\n+        // Once we ensure the types are compatible, need to ensure that the types of the strings and insertions are\n+        // compatible with the types of the strings and insertions fields.\n+        BObjectType literalType = (BObjectType) type;\n+        BType stringsType = literalType.fields.get(\"strings\").type;\n+\n+        if (evaluateRawTemplateExprs(rawTemplateLiteral.strings, stringsType, INVALID_NUM_STRINGS,\n+                                     rawTemplateLiteral.pos)) {\n+            type = symTable.semanticError;\n+        }\n+\n+        BType insertionsType = literalType.fields.get(\"insertions\").type;\n+\n+        if (evaluateRawTemplateExprs(rawTemplateLiteral.insertions, insertionsType, INVALID_NUM_INSERTIONS,\n+                                     rawTemplateLiteral.pos)) {\n+            type = symTable.semanticError;\n+        }\n+\n+        resultType = type;\n+    }\n+\n+    private BType determineRawTemplateLiteralType(BLangRawTemplateLiteral rawTemplateLiteral, BType expType) {\n+        // Contextually expected type is NoType when `var` is used.\n+        // Therefore consider the literal as of type RawTemplate\n+        if (expType == symTable.noType) {\n+            return symTable.rawTemplateType;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU3MjA0MQ=="}, "originalCommit": {"oid": "fd82f348921449885db5de62db2be7576acdb103"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczODM1MjkwOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQxODoxNTo1MlrOGjNdHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QxNToxNjoxNVrOGjX_ow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU3Mzc4OA==", "bodyText": "Will we be updating the logic for fixed-length arrays in this PR?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23705#discussion_r439573788", "createdAt": "2020-06-12T18:15:52Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -3619,6 +3622,111 @@ public void visit(BLangStringTemplateLiteral stringTemplateLiteral) {\n         resultType = types.checkType(stringTemplateLiteral, symTable.stringType, expType);\n     }\n \n+    @Override\n+    public void visit(BLangRawTemplateLiteral rawTemplateLiteral) {\n+        // First, ensure that the contextually expected type is compatible with the RawTemplate type.\n+        // The RawTemplate type should have just two fields: strings and insertions. There shouldn't be any methods.\n+        BType type = determineRawTemplateLiteralType(rawTemplateLiteral, expType);\n+\n+        if (type == symTable.semanticError) {\n+            resultType = type;\n+            return;\n+        }\n+\n+        // Once we ensure the types are compatible, need to ensure that the types of the strings and insertions are\n+        // compatible with the types of the strings and insertions fields.\n+        BObjectType literalType = (BObjectType) type;\n+        BType stringsType = literalType.fields.get(\"strings\").type;\n+\n+        if (evaluateRawTemplateExprs(rawTemplateLiteral.strings, stringsType, INVALID_NUM_STRINGS,\n+                                     rawTemplateLiteral.pos)) {\n+            type = symTable.semanticError;\n+        }\n+\n+        BType insertionsType = literalType.fields.get(\"insertions\").type;\n+\n+        if (evaluateRawTemplateExprs(rawTemplateLiteral.insertions, insertionsType, INVALID_NUM_INSERTIONS,\n+                                     rawTemplateLiteral.pos)) {\n+            type = symTable.semanticError;\n+        }\n+\n+        resultType = type;\n+    }\n+\n+    private BType determineRawTemplateLiteralType(BLangRawTemplateLiteral rawTemplateLiteral, BType expType) {\n+        // Contextually expected type is NoType when `var` is used.\n+        // Therefore consider the literal as of type RawTemplate\n+        if (expType == symTable.noType) {\n+            return symTable.rawTemplateType;\n+        }\n+\n+        BType type = types.checkType(rawTemplateLiteral, expType, symTable.rawTemplateType);\n+\n+        if (type == symTable.semanticError) {\n+            return type;\n+        }\n+\n+        // Raw template literals can be directly assigned only to abstract object types\n+        if (!Symbols.isFlagOn(type.tsymbol.flags, Flags.ABSTRACT)) {\n+            dlog.error(rawTemplateLiteral.pos, DiagnosticCode.INVALID_RAW_TEMPLATE_ASSIGNMENT, type);\n+            return symTable.semanticError;\n+        }\n+\n+        // Ensure that only the two fields, strings and insertions, are there\n+        BObjectType litObjType = (BObjectType) type;\n+        BObjectTypeSymbol objTSymbol = (BObjectTypeSymbol) litObjType.tsymbol;\n+\n+        if (litObjType.fields.size() > 2) {\n+            dlog.error(rawTemplateLiteral.pos, DiagnosticCode.INVALID_NUM_FIELDS, litObjType);\n+            type = symTable.semanticError;\n+        }\n+\n+        if (!objTSymbol.attachedFuncs.isEmpty()) {\n+            dlog.error(rawTemplateLiteral.pos, DiagnosticCode.METHODS_NOT_ALLOWED, litObjType);\n+            type = symTable.semanticError;\n+        }\n+\n+        return type;\n+    }\n+\n+    private boolean evaluateRawTemplateExprs(List<? extends BLangExpression> exprs, BType listType, DiagnosticCode code,\n+                                             DiagnosticPos pos) {\n+        boolean errored = false;\n+\n+        if (listType.tag == TypeTags.ARRAY) {\n+            BArrayType arrayType = (BArrayType) listType;\n+            for (BLangExpression expr : exprs) {\n+                errored = (checkExpr(expr, env, arrayType.eType) == symTable.semanticError) || errored;\n+            }\n+            // TODO: Consider fixed-length arrays", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd82f348921449885db5de62db2be7576acdb103"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU4ODU4MA==", "bodyText": "Was thinking of deferring that to preview2", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23705#discussion_r439588580", "createdAt": "2020-06-12T18:48:54Z", "author": {"login": "pubudu91"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -3619,6 +3622,111 @@ public void visit(BLangStringTemplateLiteral stringTemplateLiteral) {\n         resultType = types.checkType(stringTemplateLiteral, symTable.stringType, expType);\n     }\n \n+    @Override\n+    public void visit(BLangRawTemplateLiteral rawTemplateLiteral) {\n+        // First, ensure that the contextually expected type is compatible with the RawTemplate type.\n+        // The RawTemplate type should have just two fields: strings and insertions. There shouldn't be any methods.\n+        BType type = determineRawTemplateLiteralType(rawTemplateLiteral, expType);\n+\n+        if (type == symTable.semanticError) {\n+            resultType = type;\n+            return;\n+        }\n+\n+        // Once we ensure the types are compatible, need to ensure that the types of the strings and insertions are\n+        // compatible with the types of the strings and insertions fields.\n+        BObjectType literalType = (BObjectType) type;\n+        BType stringsType = literalType.fields.get(\"strings\").type;\n+\n+        if (evaluateRawTemplateExprs(rawTemplateLiteral.strings, stringsType, INVALID_NUM_STRINGS,\n+                                     rawTemplateLiteral.pos)) {\n+            type = symTable.semanticError;\n+        }\n+\n+        BType insertionsType = literalType.fields.get(\"insertions\").type;\n+\n+        if (evaluateRawTemplateExprs(rawTemplateLiteral.insertions, insertionsType, INVALID_NUM_INSERTIONS,\n+                                     rawTemplateLiteral.pos)) {\n+            type = symTable.semanticError;\n+        }\n+\n+        resultType = type;\n+    }\n+\n+    private BType determineRawTemplateLiteralType(BLangRawTemplateLiteral rawTemplateLiteral, BType expType) {\n+        // Contextually expected type is NoType when `var` is used.\n+        // Therefore consider the literal as of type RawTemplate\n+        if (expType == symTable.noType) {\n+            return symTable.rawTemplateType;\n+        }\n+\n+        BType type = types.checkType(rawTemplateLiteral, expType, symTable.rawTemplateType);\n+\n+        if (type == symTable.semanticError) {\n+            return type;\n+        }\n+\n+        // Raw template literals can be directly assigned only to abstract object types\n+        if (!Symbols.isFlagOn(type.tsymbol.flags, Flags.ABSTRACT)) {\n+            dlog.error(rawTemplateLiteral.pos, DiagnosticCode.INVALID_RAW_TEMPLATE_ASSIGNMENT, type);\n+            return symTable.semanticError;\n+        }\n+\n+        // Ensure that only the two fields, strings and insertions, are there\n+        BObjectType litObjType = (BObjectType) type;\n+        BObjectTypeSymbol objTSymbol = (BObjectTypeSymbol) litObjType.tsymbol;\n+\n+        if (litObjType.fields.size() > 2) {\n+            dlog.error(rawTemplateLiteral.pos, DiagnosticCode.INVALID_NUM_FIELDS, litObjType);\n+            type = symTable.semanticError;\n+        }\n+\n+        if (!objTSymbol.attachedFuncs.isEmpty()) {\n+            dlog.error(rawTemplateLiteral.pos, DiagnosticCode.METHODS_NOT_ALLOWED, litObjType);\n+            type = symTable.semanticError;\n+        }\n+\n+        return type;\n+    }\n+\n+    private boolean evaluateRawTemplateExprs(List<? extends BLangExpression> exprs, BType listType, DiagnosticCode code,\n+                                             DiagnosticPos pos) {\n+        boolean errored = false;\n+\n+        if (listType.tag == TypeTags.ARRAY) {\n+            BArrayType arrayType = (BArrayType) listType;\n+            for (BLangExpression expr : exprs) {\n+                errored = (checkExpr(expr, env, arrayType.eType) == symTable.semanticError) || errored;\n+            }\n+            // TODO: Consider fixed-length arrays", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU3Mzc4OA=="}, "originalCommit": {"oid": "fd82f348921449885db5de62db2be7576acdb103"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwNzE3Ng==", "bodyText": "But this could lead to issues right, since we aren't validating too many/not enough expressions?\nIMO, it would be better if we can introduce this feature with this validation.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23705#discussion_r439707176", "createdAt": "2020-06-13T04:13:11Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -3619,6 +3622,111 @@ public void visit(BLangStringTemplateLiteral stringTemplateLiteral) {\n         resultType = types.checkType(stringTemplateLiteral, symTable.stringType, expType);\n     }\n \n+    @Override\n+    public void visit(BLangRawTemplateLiteral rawTemplateLiteral) {\n+        // First, ensure that the contextually expected type is compatible with the RawTemplate type.\n+        // The RawTemplate type should have just two fields: strings and insertions. There shouldn't be any methods.\n+        BType type = determineRawTemplateLiteralType(rawTemplateLiteral, expType);\n+\n+        if (type == symTable.semanticError) {\n+            resultType = type;\n+            return;\n+        }\n+\n+        // Once we ensure the types are compatible, need to ensure that the types of the strings and insertions are\n+        // compatible with the types of the strings and insertions fields.\n+        BObjectType literalType = (BObjectType) type;\n+        BType stringsType = literalType.fields.get(\"strings\").type;\n+\n+        if (evaluateRawTemplateExprs(rawTemplateLiteral.strings, stringsType, INVALID_NUM_STRINGS,\n+                                     rawTemplateLiteral.pos)) {\n+            type = symTable.semanticError;\n+        }\n+\n+        BType insertionsType = literalType.fields.get(\"insertions\").type;\n+\n+        if (evaluateRawTemplateExprs(rawTemplateLiteral.insertions, insertionsType, INVALID_NUM_INSERTIONS,\n+                                     rawTemplateLiteral.pos)) {\n+            type = symTable.semanticError;\n+        }\n+\n+        resultType = type;\n+    }\n+\n+    private BType determineRawTemplateLiteralType(BLangRawTemplateLiteral rawTemplateLiteral, BType expType) {\n+        // Contextually expected type is NoType when `var` is used.\n+        // Therefore consider the literal as of type RawTemplate\n+        if (expType == symTable.noType) {\n+            return symTable.rawTemplateType;\n+        }\n+\n+        BType type = types.checkType(rawTemplateLiteral, expType, symTable.rawTemplateType);\n+\n+        if (type == symTable.semanticError) {\n+            return type;\n+        }\n+\n+        // Raw template literals can be directly assigned only to abstract object types\n+        if (!Symbols.isFlagOn(type.tsymbol.flags, Flags.ABSTRACT)) {\n+            dlog.error(rawTemplateLiteral.pos, DiagnosticCode.INVALID_RAW_TEMPLATE_ASSIGNMENT, type);\n+            return symTable.semanticError;\n+        }\n+\n+        // Ensure that only the two fields, strings and insertions, are there\n+        BObjectType litObjType = (BObjectType) type;\n+        BObjectTypeSymbol objTSymbol = (BObjectTypeSymbol) litObjType.tsymbol;\n+\n+        if (litObjType.fields.size() > 2) {\n+            dlog.error(rawTemplateLiteral.pos, DiagnosticCode.INVALID_NUM_FIELDS, litObjType);\n+            type = symTable.semanticError;\n+        }\n+\n+        if (!objTSymbol.attachedFuncs.isEmpty()) {\n+            dlog.error(rawTemplateLiteral.pos, DiagnosticCode.METHODS_NOT_ALLOWED, litObjType);\n+            type = symTable.semanticError;\n+        }\n+\n+        return type;\n+    }\n+\n+    private boolean evaluateRawTemplateExprs(List<? extends BLangExpression> exprs, BType listType, DiagnosticCode code,\n+                                             DiagnosticPos pos) {\n+        boolean errored = false;\n+\n+        if (listType.tag == TypeTags.ARRAY) {\n+            BArrayType arrayType = (BArrayType) listType;\n+            for (BLangExpression expr : exprs) {\n+                errored = (checkExpr(expr, env, arrayType.eType) == symTable.semanticError) || errored;\n+            }\n+            // TODO: Consider fixed-length arrays", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU3Mzc4OA=="}, "originalCommit": {"oid": "fd82f348921449885db5de62db2be7576acdb103"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcxNDcxMw==", "bodyText": "Didn't get that.What do you mean by \"validating too many/not enough expressions\"?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23705#discussion_r439714713", "createdAt": "2020-06-13T06:36:48Z", "author": {"login": "pubudu91"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -3619,6 +3622,111 @@ public void visit(BLangStringTemplateLiteral stringTemplateLiteral) {\n         resultType = types.checkType(stringTemplateLiteral, symTable.stringType, expType);\n     }\n \n+    @Override\n+    public void visit(BLangRawTemplateLiteral rawTemplateLiteral) {\n+        // First, ensure that the contextually expected type is compatible with the RawTemplate type.\n+        // The RawTemplate type should have just two fields: strings and insertions. There shouldn't be any methods.\n+        BType type = determineRawTemplateLiteralType(rawTemplateLiteral, expType);\n+\n+        if (type == symTable.semanticError) {\n+            resultType = type;\n+            return;\n+        }\n+\n+        // Once we ensure the types are compatible, need to ensure that the types of the strings and insertions are\n+        // compatible with the types of the strings and insertions fields.\n+        BObjectType literalType = (BObjectType) type;\n+        BType stringsType = literalType.fields.get(\"strings\").type;\n+\n+        if (evaluateRawTemplateExprs(rawTemplateLiteral.strings, stringsType, INVALID_NUM_STRINGS,\n+                                     rawTemplateLiteral.pos)) {\n+            type = symTable.semanticError;\n+        }\n+\n+        BType insertionsType = literalType.fields.get(\"insertions\").type;\n+\n+        if (evaluateRawTemplateExprs(rawTemplateLiteral.insertions, insertionsType, INVALID_NUM_INSERTIONS,\n+                                     rawTemplateLiteral.pos)) {\n+            type = symTable.semanticError;\n+        }\n+\n+        resultType = type;\n+    }\n+\n+    private BType determineRawTemplateLiteralType(BLangRawTemplateLiteral rawTemplateLiteral, BType expType) {\n+        // Contextually expected type is NoType when `var` is used.\n+        // Therefore consider the literal as of type RawTemplate\n+        if (expType == symTable.noType) {\n+            return symTable.rawTemplateType;\n+        }\n+\n+        BType type = types.checkType(rawTemplateLiteral, expType, symTable.rawTemplateType);\n+\n+        if (type == symTable.semanticError) {\n+            return type;\n+        }\n+\n+        // Raw template literals can be directly assigned only to abstract object types\n+        if (!Symbols.isFlagOn(type.tsymbol.flags, Flags.ABSTRACT)) {\n+            dlog.error(rawTemplateLiteral.pos, DiagnosticCode.INVALID_RAW_TEMPLATE_ASSIGNMENT, type);\n+            return symTable.semanticError;\n+        }\n+\n+        // Ensure that only the two fields, strings and insertions, are there\n+        BObjectType litObjType = (BObjectType) type;\n+        BObjectTypeSymbol objTSymbol = (BObjectTypeSymbol) litObjType.tsymbol;\n+\n+        if (litObjType.fields.size() > 2) {\n+            dlog.error(rawTemplateLiteral.pos, DiagnosticCode.INVALID_NUM_FIELDS, litObjType);\n+            type = symTable.semanticError;\n+        }\n+\n+        if (!objTSymbol.attachedFuncs.isEmpty()) {\n+            dlog.error(rawTemplateLiteral.pos, DiagnosticCode.METHODS_NOT_ALLOWED, litObjType);\n+            type = symTable.semanticError;\n+        }\n+\n+        return type;\n+    }\n+\n+    private boolean evaluateRawTemplateExprs(List<? extends BLangExpression> exprs, BType listType, DiagnosticCode code,\n+                                             DiagnosticPos pos) {\n+        boolean errored = false;\n+\n+        if (listType.tag == TypeTags.ARRAY) {\n+            BArrayType arrayType = (BArrayType) listType;\n+            for (BLangExpression expr : exprs) {\n+                errored = (checkExpr(expr, env, arrayType.eType) == symTable.semanticError) || errored;\n+            }\n+            // TODO: Consider fixed-length arrays", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU3Mzc4OA=="}, "originalCommit": {"oid": "fd82f348921449885db5de62db2be7576acdb103"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcxOTI0Mg==", "bodyText": "I meant something like\npublic type Template abstract object {\n    public string[10] strings;\n    public int[1] insertions;\n};\n\npublic function main() {    \n    Template t = `Count:${1}${2}`;\n}\nThis currently fails at runtime\n$ ballerina run --new-parser xyz.bal \nCompiling source\n        xyz.bal\nRunning executables\n\nerror: {ballerina/lang.array}IndexOutOfRange message=array index out of range: index: 1, size: 1\n        at xyz:main(xyz.bal:7)", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23705#discussion_r439719242", "createdAt": "2020-06-13T07:56:14Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -3619,6 +3622,111 @@ public void visit(BLangStringTemplateLiteral stringTemplateLiteral) {\n         resultType = types.checkType(stringTemplateLiteral, symTable.stringType, expType);\n     }\n \n+    @Override\n+    public void visit(BLangRawTemplateLiteral rawTemplateLiteral) {\n+        // First, ensure that the contextually expected type is compatible with the RawTemplate type.\n+        // The RawTemplate type should have just two fields: strings and insertions. There shouldn't be any methods.\n+        BType type = determineRawTemplateLiteralType(rawTemplateLiteral, expType);\n+\n+        if (type == symTable.semanticError) {\n+            resultType = type;\n+            return;\n+        }\n+\n+        // Once we ensure the types are compatible, need to ensure that the types of the strings and insertions are\n+        // compatible with the types of the strings and insertions fields.\n+        BObjectType literalType = (BObjectType) type;\n+        BType stringsType = literalType.fields.get(\"strings\").type;\n+\n+        if (evaluateRawTemplateExprs(rawTemplateLiteral.strings, stringsType, INVALID_NUM_STRINGS,\n+                                     rawTemplateLiteral.pos)) {\n+            type = symTable.semanticError;\n+        }\n+\n+        BType insertionsType = literalType.fields.get(\"insertions\").type;\n+\n+        if (evaluateRawTemplateExprs(rawTemplateLiteral.insertions, insertionsType, INVALID_NUM_INSERTIONS,\n+                                     rawTemplateLiteral.pos)) {\n+            type = symTable.semanticError;\n+        }\n+\n+        resultType = type;\n+    }\n+\n+    private BType determineRawTemplateLiteralType(BLangRawTemplateLiteral rawTemplateLiteral, BType expType) {\n+        // Contextually expected type is NoType when `var` is used.\n+        // Therefore consider the literal as of type RawTemplate\n+        if (expType == symTable.noType) {\n+            return symTable.rawTemplateType;\n+        }\n+\n+        BType type = types.checkType(rawTemplateLiteral, expType, symTable.rawTemplateType);\n+\n+        if (type == symTable.semanticError) {\n+            return type;\n+        }\n+\n+        // Raw template literals can be directly assigned only to abstract object types\n+        if (!Symbols.isFlagOn(type.tsymbol.flags, Flags.ABSTRACT)) {\n+            dlog.error(rawTemplateLiteral.pos, DiagnosticCode.INVALID_RAW_TEMPLATE_ASSIGNMENT, type);\n+            return symTable.semanticError;\n+        }\n+\n+        // Ensure that only the two fields, strings and insertions, are there\n+        BObjectType litObjType = (BObjectType) type;\n+        BObjectTypeSymbol objTSymbol = (BObjectTypeSymbol) litObjType.tsymbol;\n+\n+        if (litObjType.fields.size() > 2) {\n+            dlog.error(rawTemplateLiteral.pos, DiagnosticCode.INVALID_NUM_FIELDS, litObjType);\n+            type = symTable.semanticError;\n+        }\n+\n+        if (!objTSymbol.attachedFuncs.isEmpty()) {\n+            dlog.error(rawTemplateLiteral.pos, DiagnosticCode.METHODS_NOT_ALLOWED, litObjType);\n+            type = symTable.semanticError;\n+        }\n+\n+        return type;\n+    }\n+\n+    private boolean evaluateRawTemplateExprs(List<? extends BLangExpression> exprs, BType listType, DiagnosticCode code,\n+                                             DiagnosticPos pos) {\n+        boolean errored = false;\n+\n+        if (listType.tag == TypeTags.ARRAY) {\n+            BArrayType arrayType = (BArrayType) listType;\n+            for (BLangExpression expr : exprs) {\n+                errored = (checkExpr(expr, env, arrayType.eType) == symTable.semanticError) || errored;\n+            }\n+            // TODO: Consider fixed-length arrays", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU3Mzc4OA=="}, "originalCommit": {"oid": "fd82f348921449885db5de62db2be7576acdb103"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc0NjQ2Nw==", "bodyText": "Added with f494648", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23705#discussion_r439746467", "createdAt": "2020-06-13T15:16:15Z", "author": {"login": "pubudu91"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -3619,6 +3622,111 @@ public void visit(BLangStringTemplateLiteral stringTemplateLiteral) {\n         resultType = types.checkType(stringTemplateLiteral, symTable.stringType, expType);\n     }\n \n+    @Override\n+    public void visit(BLangRawTemplateLiteral rawTemplateLiteral) {\n+        // First, ensure that the contextually expected type is compatible with the RawTemplate type.\n+        // The RawTemplate type should have just two fields: strings and insertions. There shouldn't be any methods.\n+        BType type = determineRawTemplateLiteralType(rawTemplateLiteral, expType);\n+\n+        if (type == symTable.semanticError) {\n+            resultType = type;\n+            return;\n+        }\n+\n+        // Once we ensure the types are compatible, need to ensure that the types of the strings and insertions are\n+        // compatible with the types of the strings and insertions fields.\n+        BObjectType literalType = (BObjectType) type;\n+        BType stringsType = literalType.fields.get(\"strings\").type;\n+\n+        if (evaluateRawTemplateExprs(rawTemplateLiteral.strings, stringsType, INVALID_NUM_STRINGS,\n+                                     rawTemplateLiteral.pos)) {\n+            type = symTable.semanticError;\n+        }\n+\n+        BType insertionsType = literalType.fields.get(\"insertions\").type;\n+\n+        if (evaluateRawTemplateExprs(rawTemplateLiteral.insertions, insertionsType, INVALID_NUM_INSERTIONS,\n+                                     rawTemplateLiteral.pos)) {\n+            type = symTable.semanticError;\n+        }\n+\n+        resultType = type;\n+    }\n+\n+    private BType determineRawTemplateLiteralType(BLangRawTemplateLiteral rawTemplateLiteral, BType expType) {\n+        // Contextually expected type is NoType when `var` is used.\n+        // Therefore consider the literal as of type RawTemplate\n+        if (expType == symTable.noType) {\n+            return symTable.rawTemplateType;\n+        }\n+\n+        BType type = types.checkType(rawTemplateLiteral, expType, symTable.rawTemplateType);\n+\n+        if (type == symTable.semanticError) {\n+            return type;\n+        }\n+\n+        // Raw template literals can be directly assigned only to abstract object types\n+        if (!Symbols.isFlagOn(type.tsymbol.flags, Flags.ABSTRACT)) {\n+            dlog.error(rawTemplateLiteral.pos, DiagnosticCode.INVALID_RAW_TEMPLATE_ASSIGNMENT, type);\n+            return symTable.semanticError;\n+        }\n+\n+        // Ensure that only the two fields, strings and insertions, are there\n+        BObjectType litObjType = (BObjectType) type;\n+        BObjectTypeSymbol objTSymbol = (BObjectTypeSymbol) litObjType.tsymbol;\n+\n+        if (litObjType.fields.size() > 2) {\n+            dlog.error(rawTemplateLiteral.pos, DiagnosticCode.INVALID_NUM_FIELDS, litObjType);\n+            type = symTable.semanticError;\n+        }\n+\n+        if (!objTSymbol.attachedFuncs.isEmpty()) {\n+            dlog.error(rawTemplateLiteral.pos, DiagnosticCode.METHODS_NOT_ALLOWED, litObjType);\n+            type = symTable.semanticError;\n+        }\n+\n+        return type;\n+    }\n+\n+    private boolean evaluateRawTemplateExprs(List<? extends BLangExpression> exprs, BType listType, DiagnosticCode code,\n+                                             DiagnosticPos pos) {\n+        boolean errored = false;\n+\n+        if (listType.tag == TypeTags.ARRAY) {\n+            BArrayType arrayType = (BArrayType) listType;\n+            for (BLangExpression expr : exprs) {\n+                errored = (checkExpr(expr, env, arrayType.eType) == symTable.semanticError) || errored;\n+            }\n+            // TODO: Consider fixed-length arrays", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU3Mzc4OA=="}, "originalCommit": {"oid": "fd82f348921449885db5de62db2be7576acdb103"}, "originalPosition": 106}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3431, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}