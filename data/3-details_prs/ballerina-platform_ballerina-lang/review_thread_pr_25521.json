{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc1MzgyNjI2", "number": 25521, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QwMzoyNTozMVrOEfzoAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwOTo1MTozMVrOEgUepw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNzg3MTM4OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QwMzoyNTozMVrOHMUeOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QwMzoyNTozMVrOHMUeOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjY4MDM3Ng==", "bodyText": "lets use the expanded name for BP:  parseAsErrorBindingPattern", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25521#discussion_r482680376", "createdAt": "2020-09-03T03:25:31Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -12975,165 +12987,277 @@ private boolean isEndOfMappingBindingPattern(SyntaxKind nextTokenKind) {\n         return nextTokenKind == SyntaxKind.CLOSE_BRACE_TOKEN;\n     }\n \n+    private STNode parseErrorTypeDescOrErrorBP(STNode annots) {\n+        STToken nextNextToken = peek(2);\n+        switch (nextNextToken.kind) {\n+            case OPEN_PAREN_TOKEN:// Error binding pattern\n+                return parseAsErrorBP();\n+            case LT_TOKEN:\n+                return parseAsErrorTypeDesc(annots);\n+            case IDENTIFIER_TOKEN:\n+                // If the next token is identifier it can be either error a; or error a (errorMessage);\n+                SyntaxKind nextNextNextTokenKind = peek(3).kind;\n+                if (nextNextNextTokenKind == SyntaxKind.COLON_TOKEN ||\n+                        nextNextNextTokenKind == SyntaxKind.OPEN_PAREN_TOKEN) {\n+                    return parseAsErrorBP();\n+                }\n+                // Fall through.\n+            default:\n+                return parseAsErrorTypeDesc(annots);\n+        }\n+    }\n+\n+    private STNode parseAsErrorBP() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f838a70ba26890edd7c319b862e7bed6a8321e2f"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNzg3MzMxOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QwMzoyNjo0MFrOHMUfWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QwMzoyNjo0MFrOHMUfWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjY4MDY2Nw==", "bodyText": "Need a newline after }", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25521#discussion_r482680667", "createdAt": "2020-09-03T03:26:40Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -12975,165 +12987,277 @@ private boolean isEndOfMappingBindingPattern(SyntaxKind nextTokenKind) {\n         return nextTokenKind == SyntaxKind.CLOSE_BRACE_TOKEN;\n     }\n \n+    private STNode parseErrorTypeDescOrErrorBP(STNode annots) {\n+        STToken nextNextToken = peek(2);\n+        switch (nextNextToken.kind) {\n+            case OPEN_PAREN_TOKEN:// Error binding pattern\n+                return parseAsErrorBP();\n+            case LT_TOKEN:\n+                return parseAsErrorTypeDesc(annots);\n+            case IDENTIFIER_TOKEN:\n+                // If the next token is identifier it can be either error a; or error a (errorMessage);\n+                SyntaxKind nextNextNextTokenKind = peek(3).kind;\n+                if (nextNextNextTokenKind == SyntaxKind.COLON_TOKEN ||\n+                        nextNextNextTokenKind == SyntaxKind.OPEN_PAREN_TOKEN) {\n+                    return parseAsErrorBP();\n+                }\n+                // Fall through.\n+            default:\n+                return parseAsErrorTypeDesc(annots);\n+        }\n+    }\n+\n+    private STNode parseAsErrorBP() {\n+        startContext(ParserRuleContext.ASSIGNMENT_STMT);\n+        return parseAssignmentStmtRhs(parseErrorBindingPattern());\n+    }\n+\n+    private STNode parseAsErrorTypeDesc(STNode annots) {\n+        STNode finalKeyword = STNodeFactory.createEmptyNode();\n+        return parseVariableDecl(getAnnotations(annots), finalKeyword, false);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f838a70ba26890edd7c319b862e7bed6a8321e2f"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNzg5MzgzOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QwMzozODo0MVrOHMUrfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QwMzozODo0MVrOHMUrfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjY4Mzc3Mg==", "bodyText": "Should we loop on a condition like isErrorArgsListEnd()?\nThen we can exit early for cases like eof-token, ) token, etc..", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25521#discussion_r482683772", "createdAt": "2020-09-03T03:38:41Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -12975,165 +12987,277 @@ private boolean isEndOfMappingBindingPattern(SyntaxKind nextTokenKind) {\n         return nextTokenKind == SyntaxKind.CLOSE_BRACE_TOKEN;\n     }\n \n+    private STNode parseErrorTypeDescOrErrorBP(STNode annots) {\n+        STToken nextNextToken = peek(2);\n+        switch (nextNextToken.kind) {\n+            case OPEN_PAREN_TOKEN:// Error binding pattern\n+                return parseAsErrorBP();\n+            case LT_TOKEN:\n+                return parseAsErrorTypeDesc(annots);\n+            case IDENTIFIER_TOKEN:\n+                // If the next token is identifier it can be either error a; or error a (errorMessage);\n+                SyntaxKind nextNextNextTokenKind = peek(3).kind;\n+                if (nextNextNextTokenKind == SyntaxKind.COLON_TOKEN ||\n+                        nextNextNextTokenKind == SyntaxKind.OPEN_PAREN_TOKEN) {\n+                    return parseAsErrorBP();\n+                }\n+                // Fall through.\n+            default:\n+                return parseAsErrorTypeDesc(annots);\n+        }\n+    }\n+\n+    private STNode parseAsErrorBP() {\n+        startContext(ParserRuleContext.ASSIGNMENT_STMT);\n+        return parseAssignmentStmtRhs(parseErrorBindingPattern());\n+    }\n+\n+    private STNode parseAsErrorTypeDesc(STNode annots) {\n+        STNode finalKeyword = STNodeFactory.createEmptyNode();\n+        return parseVariableDecl(getAnnotations(annots), finalKeyword, false);\n+    }\n     /**\n      * Parse error binding pattern node.\n      * <p>\n-     * <code>functional-binding-pattern := error ( arg-list-binding-pattern )</code>\n+     * <code>error-binding-pattern := error [error-type-reference] ( error-arg-list-binding-pattern )</code>\n+     * <br/><br/>\n+     * error-arg-list-binding-pattern :=\n+     *    error-message-binding-pattern [, error-cause-binding-pattern] [, error-field-binding-patterns]\n+     *    | [error-field-binding-patterns]\n+     * <br/><br/>\n+     * error-message-binding-pattern := simple-binding-pattern\n+     * <br/><br/>\n+     * error-cause-binding-pattern := simple-binding-pattern | error-binding-pattern\n+     * <br/><br/>\n+     * simple-binding-pattern := capture-binding-pattern | wildcard-binding-pattern\n+     * <br/><br/>\n+     * error-field-binding-patterns :=\n+     *    named-arg-binding-pattern (, named-arg-binding-pattern)* [, rest-binding-pattern]\n+     *    | rest-binding-pattern\n+     * <br/><br/>\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n      * \n      * @return Error binding pattern node.\n      */\n     private STNode parseErrorBindingPattern() {\n-        startContext(ParserRuleContext.FUNCTIONAL_BINDING_PATTERN);\n-        STNode typeDesc = parseErrorKeyword();\n-        return parseFunctionalBindingPattern(typeDesc);\n+        startContext(ParserRuleContext.ERROR_BINDING_PATTERN);\n+        STNode errorKeyword = parseErrorKeyword();\n+        return parseErrorBindingPattern(errorKeyword);\n+    }\n+\n+    private STNode parseErrorBindingPattern(STNode errorKeyword) {\n+        STToken nextToken = peek();\n+        STNode typeRef;\n+        switch (nextToken.kind) {\n+            case IDENTIFIER_TOKEN:\n+                typeRef = parseTypeReference();\n+                break;\n+            case OPEN_PAREN_TOKEN:\n+                typeRef = STNodeFactory.createEmptyNode();\n+                break;\n+            default:\n+                recover(peek(), ParserRuleContext.ERROR_BINDING_PATTERN_ERROR_KEYWORD_RHS);\n+                return parseErrorBindingPattern(errorKeyword);\n+        }\n+        return parseErrorBindingPattern(errorKeyword, typeRef);\n+    }\n+\n+    private STNode parseErrorBindingPattern(STNode errorKeyword, STNode typeRef) {\n+        STNode openParenthesis = parseOpenParenthesis(ParserRuleContext.OPEN_PARENTHESIS);\n+        STNode argListBindingPatterns = parseErrorArgListBindingPatterns();\n+        STNode closeParenthesis = parseCloseParenthesis();\n+        endContext();\n+        return STNodeFactory.createErrorBindingPatternNode(errorKeyword, typeRef, openParenthesis,\n+                argListBindingPatterns, closeParenthesis);\n     }\n \n     /**\n-     * Parse functional binding pattern.\n+     * Parse error arg list binding pattern.\n      * <p>\n      * <code>\n-     * functional-binding-pattern := functionally-constructible-type-reference ( arg-list-binding-pattern )\n+     * error-arg-list-binding-pattern :=\n+     * error-message-binding-pattern [, error-cause-binding-pattern] [, error-field-binding-patterns]\n+     * | [error-field-binding-patterns]\n      * <br/><br/>\n-     * functionally-constructible-type-reference := error | type-reference\n+     *\n+     * error-message-binding-pattern := simple-binding-pattern\n+     * <br/><br/>\n+     *\n+     * error-cause-binding-pattern := simple-binding-pattern | error-binding-pattern\n+     * <br/><br/>\n+     *\n+     * simple-binding-pattern := capture-binding-pattern | wildcard-binding-pattern\n+     * <br/><br/>\n+     *\n+     * error-field-binding-patterns :=\n+     * named-arg-binding-pattern (, named-arg-binding-pattern)* [, rest-binding-pattern]\n+     * | rest-binding-pattern\n+     * <br/><br/>\n+     *\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n      * </code>\n-     * \n-     * @param typeDesc Functionally constructible type reference\n-     * @return Functional binding pattern node.\n+     *\n+     * @return Error arg list binding patterns.\n      */\n-    private STNode parseFunctionalBindingPattern(STNode typeDesc) {\n-        STNode openParenthesis = parseOpenParenthesis(ParserRuleContext.ARG_LIST_START);\n-        STNode argListBindingPatterns = parseArgListBindingPatterns();\n-        STNode closeParenthesis = parseCloseParenthesis();\n-        endContext();\n-        return STNodeFactory.createFunctionalBindingPatternNode(typeDesc, openParenthesis, argListBindingPatterns,\n-                closeParenthesis);\n-    }\n-\n-    private STNode parseArgListBindingPatterns() {\n+    private STNode parseErrorArgListBindingPatterns() {\n         List<STNode> argListBindingPatterns = new ArrayList<>();\n         SyntaxKind lastValidArgKind = SyntaxKind.CAPTURE_BINDING_PATTERN;\n         STToken nextToken = peek();\n \n         if (isEndOfParametersList(nextToken.kind)) {\n             return STNodeFactory.createNodeList(argListBindingPatterns);\n         }\n-        argListBindingPatterns.add(parseArgBindingPattern());\n \n-        nextToken = peek();\n-        while (!isEndOfParametersList(nextToken.kind)) {\n-            STNode argEnd = parseArgsBindingPatternEnd();\n-            if (argEnd == null) {\n-                // null marks the end of args\n-                break;\n-            }\n+        int argCount = 1;\n+        boolean isArgEnd = false;\n+        while (!isArgEnd) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f838a70ba26890edd7c319b862e7bed6a8321e2f"}, "originalPosition": 219}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNzg5Njk1OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QwMzo0MDoyNlrOHMUtQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QwMzo0MDoyNlrOHMUtQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjY4NDIyNw==", "bodyText": "Taking this snippet out (immediately after the parseErrorArgsBindingPatternEnd) will simplify the logic", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25521#discussion_r482684227", "createdAt": "2020-09-03T03:40:26Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -12975,165 +12987,277 @@ private boolean isEndOfMappingBindingPattern(SyntaxKind nextTokenKind) {\n         return nextTokenKind == SyntaxKind.CLOSE_BRACE_TOKEN;\n     }\n \n+    private STNode parseErrorTypeDescOrErrorBP(STNode annots) {\n+        STToken nextNextToken = peek(2);\n+        switch (nextNextToken.kind) {\n+            case OPEN_PAREN_TOKEN:// Error binding pattern\n+                return parseAsErrorBP();\n+            case LT_TOKEN:\n+                return parseAsErrorTypeDesc(annots);\n+            case IDENTIFIER_TOKEN:\n+                // If the next token is identifier it can be either error a; or error a (errorMessage);\n+                SyntaxKind nextNextNextTokenKind = peek(3).kind;\n+                if (nextNextNextTokenKind == SyntaxKind.COLON_TOKEN ||\n+                        nextNextNextTokenKind == SyntaxKind.OPEN_PAREN_TOKEN) {\n+                    return parseAsErrorBP();\n+                }\n+                // Fall through.\n+            default:\n+                return parseAsErrorTypeDesc(annots);\n+        }\n+    }\n+\n+    private STNode parseAsErrorBP() {\n+        startContext(ParserRuleContext.ASSIGNMENT_STMT);\n+        return parseAssignmentStmtRhs(parseErrorBindingPattern());\n+    }\n+\n+    private STNode parseAsErrorTypeDesc(STNode annots) {\n+        STNode finalKeyword = STNodeFactory.createEmptyNode();\n+        return parseVariableDecl(getAnnotations(annots), finalKeyword, false);\n+    }\n     /**\n      * Parse error binding pattern node.\n      * <p>\n-     * <code>functional-binding-pattern := error ( arg-list-binding-pattern )</code>\n+     * <code>error-binding-pattern := error [error-type-reference] ( error-arg-list-binding-pattern )</code>\n+     * <br/><br/>\n+     * error-arg-list-binding-pattern :=\n+     *    error-message-binding-pattern [, error-cause-binding-pattern] [, error-field-binding-patterns]\n+     *    | [error-field-binding-patterns]\n+     * <br/><br/>\n+     * error-message-binding-pattern := simple-binding-pattern\n+     * <br/><br/>\n+     * error-cause-binding-pattern := simple-binding-pattern | error-binding-pattern\n+     * <br/><br/>\n+     * simple-binding-pattern := capture-binding-pattern | wildcard-binding-pattern\n+     * <br/><br/>\n+     * error-field-binding-patterns :=\n+     *    named-arg-binding-pattern (, named-arg-binding-pattern)* [, rest-binding-pattern]\n+     *    | rest-binding-pattern\n+     * <br/><br/>\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n      * \n      * @return Error binding pattern node.\n      */\n     private STNode parseErrorBindingPattern() {\n-        startContext(ParserRuleContext.FUNCTIONAL_BINDING_PATTERN);\n-        STNode typeDesc = parseErrorKeyword();\n-        return parseFunctionalBindingPattern(typeDesc);\n+        startContext(ParserRuleContext.ERROR_BINDING_PATTERN);\n+        STNode errorKeyword = parseErrorKeyword();\n+        return parseErrorBindingPattern(errorKeyword);\n+    }\n+\n+    private STNode parseErrorBindingPattern(STNode errorKeyword) {\n+        STToken nextToken = peek();\n+        STNode typeRef;\n+        switch (nextToken.kind) {\n+            case IDENTIFIER_TOKEN:\n+                typeRef = parseTypeReference();\n+                break;\n+            case OPEN_PAREN_TOKEN:\n+                typeRef = STNodeFactory.createEmptyNode();\n+                break;\n+            default:\n+                recover(peek(), ParserRuleContext.ERROR_BINDING_PATTERN_ERROR_KEYWORD_RHS);\n+                return parseErrorBindingPattern(errorKeyword);\n+        }\n+        return parseErrorBindingPattern(errorKeyword, typeRef);\n+    }\n+\n+    private STNode parseErrorBindingPattern(STNode errorKeyword, STNode typeRef) {\n+        STNode openParenthesis = parseOpenParenthesis(ParserRuleContext.OPEN_PARENTHESIS);\n+        STNode argListBindingPatterns = parseErrorArgListBindingPatterns();\n+        STNode closeParenthesis = parseCloseParenthesis();\n+        endContext();\n+        return STNodeFactory.createErrorBindingPatternNode(errorKeyword, typeRef, openParenthesis,\n+                argListBindingPatterns, closeParenthesis);\n     }\n \n     /**\n-     * Parse functional binding pattern.\n+     * Parse error arg list binding pattern.\n      * <p>\n      * <code>\n-     * functional-binding-pattern := functionally-constructible-type-reference ( arg-list-binding-pattern )\n+     * error-arg-list-binding-pattern :=\n+     * error-message-binding-pattern [, error-cause-binding-pattern] [, error-field-binding-patterns]\n+     * | [error-field-binding-patterns]\n      * <br/><br/>\n-     * functionally-constructible-type-reference := error | type-reference\n+     *\n+     * error-message-binding-pattern := simple-binding-pattern\n+     * <br/><br/>\n+     *\n+     * error-cause-binding-pattern := simple-binding-pattern | error-binding-pattern\n+     * <br/><br/>\n+     *\n+     * simple-binding-pattern := capture-binding-pattern | wildcard-binding-pattern\n+     * <br/><br/>\n+     *\n+     * error-field-binding-patterns :=\n+     * named-arg-binding-pattern (, named-arg-binding-pattern)* [, rest-binding-pattern]\n+     * | rest-binding-pattern\n+     * <br/><br/>\n+     *\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n      * </code>\n-     * \n-     * @param typeDesc Functionally constructible type reference\n-     * @return Functional binding pattern node.\n+     *\n+     * @return Error arg list binding patterns.\n      */\n-    private STNode parseFunctionalBindingPattern(STNode typeDesc) {\n-        STNode openParenthesis = parseOpenParenthesis(ParserRuleContext.ARG_LIST_START);\n-        STNode argListBindingPatterns = parseArgListBindingPatterns();\n-        STNode closeParenthesis = parseCloseParenthesis();\n-        endContext();\n-        return STNodeFactory.createFunctionalBindingPatternNode(typeDesc, openParenthesis, argListBindingPatterns,\n-                closeParenthesis);\n-    }\n-\n-    private STNode parseArgListBindingPatterns() {\n+    private STNode parseErrorArgListBindingPatterns() {\n         List<STNode> argListBindingPatterns = new ArrayList<>();\n         SyntaxKind lastValidArgKind = SyntaxKind.CAPTURE_BINDING_PATTERN;\n         STToken nextToken = peek();\n \n         if (isEndOfParametersList(nextToken.kind)) {\n             return STNodeFactory.createNodeList(argListBindingPatterns);\n         }\n-        argListBindingPatterns.add(parseArgBindingPattern());\n \n-        nextToken = peek();\n-        while (!isEndOfParametersList(nextToken.kind)) {\n-            STNode argEnd = parseArgsBindingPatternEnd();\n-            if (argEnd == null) {\n-                // null marks the end of args\n-                break;\n-            }\n+        int argCount = 1;\n+        boolean isArgEnd = false;\n+        while (!isArgEnd) {\n \n-            nextToken = peek();\n-            STNode currentArg = parseArgBindingPattern();\n-            DiagnosticErrorCode errorCode = validateArgBindingPatternOrder(lastValidArgKind, currentArg.kind);\n+            STNode currentArg = parseErrorArgListBindingPattern(argCount);\n+            DiagnosticErrorCode errorCode = validateArgBindingPatternOrder(lastValidArgKind, currentArg.kind,\n+                    argCount);\n+            STNode argEnd = parseErrorArgsBindingPatternEnd(argCount);\n             if (errorCode == null) {\n-                argListBindingPatterns.add(argEnd);\n                 argListBindingPatterns.add(currentArg);\n+                if (argEnd == null) {\n+                    // null marks the end of args\n+                    break;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f838a70ba26890edd7c319b862e7bed6a8321e2f"}, "originalPosition": 233}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNzkxNTc3OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QwMzo1MToyOVrOHMU4NA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QwMzo1MToyOVrOHMU4NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjY4NzAyOA==", "bodyText": "toString() method will include minutiae including comments, invalid tokens, etc..", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25521#discussion_r482687028", "createdAt": "2020-09-03T03:51:29Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -12975,165 +12987,277 @@ private boolean isEndOfMappingBindingPattern(SyntaxKind nextTokenKind) {\n         return nextTokenKind == SyntaxKind.CLOSE_BRACE_TOKEN;\n     }\n \n+    private STNode parseErrorTypeDescOrErrorBP(STNode annots) {\n+        STToken nextNextToken = peek(2);\n+        switch (nextNextToken.kind) {\n+            case OPEN_PAREN_TOKEN:// Error binding pattern\n+                return parseAsErrorBP();\n+            case LT_TOKEN:\n+                return parseAsErrorTypeDesc(annots);\n+            case IDENTIFIER_TOKEN:\n+                // If the next token is identifier it can be either error a; or error a (errorMessage);\n+                SyntaxKind nextNextNextTokenKind = peek(3).kind;\n+                if (nextNextNextTokenKind == SyntaxKind.COLON_TOKEN ||\n+                        nextNextNextTokenKind == SyntaxKind.OPEN_PAREN_TOKEN) {\n+                    return parseAsErrorBP();\n+                }\n+                // Fall through.\n+            default:\n+                return parseAsErrorTypeDesc(annots);\n+        }\n+    }\n+\n+    private STNode parseAsErrorBP() {\n+        startContext(ParserRuleContext.ASSIGNMENT_STMT);\n+        return parseAssignmentStmtRhs(parseErrorBindingPattern());\n+    }\n+\n+    private STNode parseAsErrorTypeDesc(STNode annots) {\n+        STNode finalKeyword = STNodeFactory.createEmptyNode();\n+        return parseVariableDecl(getAnnotations(annots), finalKeyword, false);\n+    }\n     /**\n      * Parse error binding pattern node.\n      * <p>\n-     * <code>functional-binding-pattern := error ( arg-list-binding-pattern )</code>\n+     * <code>error-binding-pattern := error [error-type-reference] ( error-arg-list-binding-pattern )</code>\n+     * <br/><br/>\n+     * error-arg-list-binding-pattern :=\n+     *    error-message-binding-pattern [, error-cause-binding-pattern] [, error-field-binding-patterns]\n+     *    | [error-field-binding-patterns]\n+     * <br/><br/>\n+     * error-message-binding-pattern := simple-binding-pattern\n+     * <br/><br/>\n+     * error-cause-binding-pattern := simple-binding-pattern | error-binding-pattern\n+     * <br/><br/>\n+     * simple-binding-pattern := capture-binding-pattern | wildcard-binding-pattern\n+     * <br/><br/>\n+     * error-field-binding-patterns :=\n+     *    named-arg-binding-pattern (, named-arg-binding-pattern)* [, rest-binding-pattern]\n+     *    | rest-binding-pattern\n+     * <br/><br/>\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n      * \n      * @return Error binding pattern node.\n      */\n     private STNode parseErrorBindingPattern() {\n-        startContext(ParserRuleContext.FUNCTIONAL_BINDING_PATTERN);\n-        STNode typeDesc = parseErrorKeyword();\n-        return parseFunctionalBindingPattern(typeDesc);\n+        startContext(ParserRuleContext.ERROR_BINDING_PATTERN);\n+        STNode errorKeyword = parseErrorKeyword();\n+        return parseErrorBindingPattern(errorKeyword);\n+    }\n+\n+    private STNode parseErrorBindingPattern(STNode errorKeyword) {\n+        STToken nextToken = peek();\n+        STNode typeRef;\n+        switch (nextToken.kind) {\n+            case IDENTIFIER_TOKEN:\n+                typeRef = parseTypeReference();\n+                break;\n+            case OPEN_PAREN_TOKEN:\n+                typeRef = STNodeFactory.createEmptyNode();\n+                break;\n+            default:\n+                recover(peek(), ParserRuleContext.ERROR_BINDING_PATTERN_ERROR_KEYWORD_RHS);\n+                return parseErrorBindingPattern(errorKeyword);\n+        }\n+        return parseErrorBindingPattern(errorKeyword, typeRef);\n+    }\n+\n+    private STNode parseErrorBindingPattern(STNode errorKeyword, STNode typeRef) {\n+        STNode openParenthesis = parseOpenParenthesis(ParserRuleContext.OPEN_PARENTHESIS);\n+        STNode argListBindingPatterns = parseErrorArgListBindingPatterns();\n+        STNode closeParenthesis = parseCloseParenthesis();\n+        endContext();\n+        return STNodeFactory.createErrorBindingPatternNode(errorKeyword, typeRef, openParenthesis,\n+                argListBindingPatterns, closeParenthesis);\n     }\n \n     /**\n-     * Parse functional binding pattern.\n+     * Parse error arg list binding pattern.\n      * <p>\n      * <code>\n-     * functional-binding-pattern := functionally-constructible-type-reference ( arg-list-binding-pattern )\n+     * error-arg-list-binding-pattern :=\n+     * error-message-binding-pattern [, error-cause-binding-pattern] [, error-field-binding-patterns]\n+     * | [error-field-binding-patterns]\n      * <br/><br/>\n-     * functionally-constructible-type-reference := error | type-reference\n+     *\n+     * error-message-binding-pattern := simple-binding-pattern\n+     * <br/><br/>\n+     *\n+     * error-cause-binding-pattern := simple-binding-pattern | error-binding-pattern\n+     * <br/><br/>\n+     *\n+     * simple-binding-pattern := capture-binding-pattern | wildcard-binding-pattern\n+     * <br/><br/>\n+     *\n+     * error-field-binding-patterns :=\n+     * named-arg-binding-pattern (, named-arg-binding-pattern)* [, rest-binding-pattern]\n+     * | rest-binding-pattern\n+     * <br/><br/>\n+     *\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n      * </code>\n-     * \n-     * @param typeDesc Functionally constructible type reference\n-     * @return Functional binding pattern node.\n+     *\n+     * @return Error arg list binding patterns.\n      */\n-    private STNode parseFunctionalBindingPattern(STNode typeDesc) {\n-        STNode openParenthesis = parseOpenParenthesis(ParserRuleContext.ARG_LIST_START);\n-        STNode argListBindingPatterns = parseArgListBindingPatterns();\n-        STNode closeParenthesis = parseCloseParenthesis();\n-        endContext();\n-        return STNodeFactory.createFunctionalBindingPatternNode(typeDesc, openParenthesis, argListBindingPatterns,\n-                closeParenthesis);\n-    }\n-\n-    private STNode parseArgListBindingPatterns() {\n+    private STNode parseErrorArgListBindingPatterns() {\n         List<STNode> argListBindingPatterns = new ArrayList<>();\n         SyntaxKind lastValidArgKind = SyntaxKind.CAPTURE_BINDING_PATTERN;\n         STToken nextToken = peek();\n \n         if (isEndOfParametersList(nextToken.kind)) {\n             return STNodeFactory.createNodeList(argListBindingPatterns);\n         }\n-        argListBindingPatterns.add(parseArgBindingPattern());\n \n-        nextToken = peek();\n-        while (!isEndOfParametersList(nextToken.kind)) {\n-            STNode argEnd = parseArgsBindingPatternEnd();\n-            if (argEnd == null) {\n-                // null marks the end of args\n-                break;\n-            }\n+        int argCount = 1;\n+        boolean isArgEnd = false;\n+        while (!isArgEnd) {\n \n-            nextToken = peek();\n-            STNode currentArg = parseArgBindingPattern();\n-            DiagnosticErrorCode errorCode = validateArgBindingPatternOrder(lastValidArgKind, currentArg.kind);\n+            STNode currentArg = parseErrorArgListBindingPattern(argCount);\n+            DiagnosticErrorCode errorCode = validateArgBindingPatternOrder(lastValidArgKind, currentArg.kind,\n+                    argCount);\n+            STNode argEnd = parseErrorArgsBindingPatternEnd(argCount);\n             if (errorCode == null) {\n-                argListBindingPatterns.add(argEnd);\n                 argListBindingPatterns.add(currentArg);\n+                if (argEnd == null) {\n+                    // null marks the end of args\n+                    break;\n+                }\n+                argListBindingPatterns.add(argEnd);\n                 lastValidArgKind = currentArg.kind;\n+                argCount++;\n             } else {\n-                updateLastNodeInListWithInvalidNode(argListBindingPatterns, argEnd, null);\n-                updateLastNodeInListWithInvalidNode(argListBindingPatterns, currentArg, errorCode);\n+                if (argListBindingPatterns.size() != 0) {\n+                    updateLastNodeInListWithInvalidNode(argListBindingPatterns, currentArg, errorCode);\n+                    if (argEnd != null) {\n+                        updateLastNodeInListWithInvalidNode(argListBindingPatterns, argEnd, null);\n+                    }\n+                } else {\n+                    addInvalidNodeToNextToken(currentArg, errorCode, currentArg.toString().trim());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f838a70ba26890edd7c319b862e7bed6a8321e2f"}, "originalPosition": 247}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNzkzMTg2OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QwNDowMDo0MVrOHMVBhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QwNDowMDo0MVrOHMVBhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjY4OTQxMw==", "bodyText": "Can we only rely on the lastValidArgKind?\nI feel we can do all the validation only using the lastValidArgKind..", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25521#discussion_r482689413", "createdAt": "2020-09-03T04:00:41Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -12975,165 +12987,277 @@ private boolean isEndOfMappingBindingPattern(SyntaxKind nextTokenKind) {\n         return nextTokenKind == SyntaxKind.CLOSE_BRACE_TOKEN;\n     }\n \n+    private STNode parseErrorTypeDescOrErrorBP(STNode annots) {\n+        STToken nextNextToken = peek(2);\n+        switch (nextNextToken.kind) {\n+            case OPEN_PAREN_TOKEN:// Error binding pattern\n+                return parseAsErrorBP();\n+            case LT_TOKEN:\n+                return parseAsErrorTypeDesc(annots);\n+            case IDENTIFIER_TOKEN:\n+                // If the next token is identifier it can be either error a; or error a (errorMessage);\n+                SyntaxKind nextNextNextTokenKind = peek(3).kind;\n+                if (nextNextNextTokenKind == SyntaxKind.COLON_TOKEN ||\n+                        nextNextNextTokenKind == SyntaxKind.OPEN_PAREN_TOKEN) {\n+                    return parseAsErrorBP();\n+                }\n+                // Fall through.\n+            default:\n+                return parseAsErrorTypeDesc(annots);\n+        }\n+    }\n+\n+    private STNode parseAsErrorBP() {\n+        startContext(ParserRuleContext.ASSIGNMENT_STMT);\n+        return parseAssignmentStmtRhs(parseErrorBindingPattern());\n+    }\n+\n+    private STNode parseAsErrorTypeDesc(STNode annots) {\n+        STNode finalKeyword = STNodeFactory.createEmptyNode();\n+        return parseVariableDecl(getAnnotations(annots), finalKeyword, false);\n+    }\n     /**\n      * Parse error binding pattern node.\n      * <p>\n-     * <code>functional-binding-pattern := error ( arg-list-binding-pattern )</code>\n+     * <code>error-binding-pattern := error [error-type-reference] ( error-arg-list-binding-pattern )</code>\n+     * <br/><br/>\n+     * error-arg-list-binding-pattern :=\n+     *    error-message-binding-pattern [, error-cause-binding-pattern] [, error-field-binding-patterns]\n+     *    | [error-field-binding-patterns]\n+     * <br/><br/>\n+     * error-message-binding-pattern := simple-binding-pattern\n+     * <br/><br/>\n+     * error-cause-binding-pattern := simple-binding-pattern | error-binding-pattern\n+     * <br/><br/>\n+     * simple-binding-pattern := capture-binding-pattern | wildcard-binding-pattern\n+     * <br/><br/>\n+     * error-field-binding-patterns :=\n+     *    named-arg-binding-pattern (, named-arg-binding-pattern)* [, rest-binding-pattern]\n+     *    | rest-binding-pattern\n+     * <br/><br/>\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n      * \n      * @return Error binding pattern node.\n      */\n     private STNode parseErrorBindingPattern() {\n-        startContext(ParserRuleContext.FUNCTIONAL_BINDING_PATTERN);\n-        STNode typeDesc = parseErrorKeyword();\n-        return parseFunctionalBindingPattern(typeDesc);\n+        startContext(ParserRuleContext.ERROR_BINDING_PATTERN);\n+        STNode errorKeyword = parseErrorKeyword();\n+        return parseErrorBindingPattern(errorKeyword);\n+    }\n+\n+    private STNode parseErrorBindingPattern(STNode errorKeyword) {\n+        STToken nextToken = peek();\n+        STNode typeRef;\n+        switch (nextToken.kind) {\n+            case IDENTIFIER_TOKEN:\n+                typeRef = parseTypeReference();\n+                break;\n+            case OPEN_PAREN_TOKEN:\n+                typeRef = STNodeFactory.createEmptyNode();\n+                break;\n+            default:\n+                recover(peek(), ParserRuleContext.ERROR_BINDING_PATTERN_ERROR_KEYWORD_RHS);\n+                return parseErrorBindingPattern(errorKeyword);\n+        }\n+        return parseErrorBindingPattern(errorKeyword, typeRef);\n+    }\n+\n+    private STNode parseErrorBindingPattern(STNode errorKeyword, STNode typeRef) {\n+        STNode openParenthesis = parseOpenParenthesis(ParserRuleContext.OPEN_PARENTHESIS);\n+        STNode argListBindingPatterns = parseErrorArgListBindingPatterns();\n+        STNode closeParenthesis = parseCloseParenthesis();\n+        endContext();\n+        return STNodeFactory.createErrorBindingPatternNode(errorKeyword, typeRef, openParenthesis,\n+                argListBindingPatterns, closeParenthesis);\n     }\n \n     /**\n-     * Parse functional binding pattern.\n+     * Parse error arg list binding pattern.\n      * <p>\n      * <code>\n-     * functional-binding-pattern := functionally-constructible-type-reference ( arg-list-binding-pattern )\n+     * error-arg-list-binding-pattern :=\n+     * error-message-binding-pattern [, error-cause-binding-pattern] [, error-field-binding-patterns]\n+     * | [error-field-binding-patterns]\n      * <br/><br/>\n-     * functionally-constructible-type-reference := error | type-reference\n+     *\n+     * error-message-binding-pattern := simple-binding-pattern\n+     * <br/><br/>\n+     *\n+     * error-cause-binding-pattern := simple-binding-pattern | error-binding-pattern\n+     * <br/><br/>\n+     *\n+     * simple-binding-pattern := capture-binding-pattern | wildcard-binding-pattern\n+     * <br/><br/>\n+     *\n+     * error-field-binding-patterns :=\n+     * named-arg-binding-pattern (, named-arg-binding-pattern)* [, rest-binding-pattern]\n+     * | rest-binding-pattern\n+     * <br/><br/>\n+     *\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n      * </code>\n-     * \n-     * @param typeDesc Functionally constructible type reference\n-     * @return Functional binding pattern node.\n+     *\n+     * @return Error arg list binding patterns.\n      */\n-    private STNode parseFunctionalBindingPattern(STNode typeDesc) {\n-        STNode openParenthesis = parseOpenParenthesis(ParserRuleContext.ARG_LIST_START);\n-        STNode argListBindingPatterns = parseArgListBindingPatterns();\n-        STNode closeParenthesis = parseCloseParenthesis();\n-        endContext();\n-        return STNodeFactory.createFunctionalBindingPatternNode(typeDesc, openParenthesis, argListBindingPatterns,\n-                closeParenthesis);\n-    }\n-\n-    private STNode parseArgListBindingPatterns() {\n+    private STNode parseErrorArgListBindingPatterns() {\n         List<STNode> argListBindingPatterns = new ArrayList<>();\n         SyntaxKind lastValidArgKind = SyntaxKind.CAPTURE_BINDING_PATTERN;\n         STToken nextToken = peek();\n \n         if (isEndOfParametersList(nextToken.kind)) {\n             return STNodeFactory.createNodeList(argListBindingPatterns);\n         }\n-        argListBindingPatterns.add(parseArgBindingPattern());\n \n-        nextToken = peek();\n-        while (!isEndOfParametersList(nextToken.kind)) {\n-            STNode argEnd = parseArgsBindingPatternEnd();\n-            if (argEnd == null) {\n-                // null marks the end of args\n-                break;\n-            }\n+        int argCount = 1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f838a70ba26890edd7c319b862e7bed6a8321e2f"}, "originalPosition": 217}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMzI1NDE1OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwOTo1MTozMVrOHNHWKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwOTo1MTozMVrOHNHWKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzUxMzg5Ng==", "bodyText": "can merge the else and the if", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25521#discussion_r483513896", "createdAt": "2020-09-04T09:51:31Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -12975,165 +12987,265 @@ private boolean isEndOfMappingBindingPattern(SyntaxKind nextTokenKind) {\n         return nextTokenKind == SyntaxKind.CLOSE_BRACE_TOKEN;\n     }\n \n+    private STNode parseErrorTypeDescOrErrorBP(STNode annots) {\n+        STToken nextNextToken = peek(2);\n+        switch (nextNextToken.kind) {\n+            case OPEN_PAREN_TOKEN:// Error binding pattern\n+                return parseAsErrorBindingPattern();\n+            case LT_TOKEN:\n+                return parseAsErrorTypeDesc(annots);\n+            case IDENTIFIER_TOKEN:\n+                // If the next token is identifier it can be either error a; or error a (errorMessage);\n+                SyntaxKind nextNextNextTokenKind = peek(3).kind;\n+                if (nextNextNextTokenKind == SyntaxKind.COLON_TOKEN ||\n+                        nextNextNextTokenKind == SyntaxKind.OPEN_PAREN_TOKEN) {\n+                    return parseAsErrorBindingPattern();\n+                }\n+                // Fall through.\n+            default:\n+                return parseAsErrorTypeDesc(annots);\n+        }\n+    }\n+\n+    private STNode parseAsErrorBindingPattern() {\n+        startContext(ParserRuleContext.ASSIGNMENT_STMT);\n+        return parseAssignmentStmtRhs(parseErrorBindingPattern());\n+    }\n+\n+    private STNode parseAsErrorTypeDesc(STNode annots) {\n+        STNode finalKeyword = STNodeFactory.createEmptyNode();\n+        return parseVariableDecl(getAnnotations(annots), finalKeyword, false);\n+    }\n+\n     /**\n      * Parse error binding pattern node.\n      * <p>\n-     * <code>functional-binding-pattern := error ( arg-list-binding-pattern )</code>\n+     * <code>error-binding-pattern := error [error-type-reference] ( error-arg-list-binding-pattern )</code>\n+     * <br/><br/>\n+     * error-arg-list-binding-pattern :=\n+     *    error-message-binding-pattern [, error-cause-binding-pattern] [, error-field-binding-patterns]\n+     *    | [error-field-binding-patterns]\n+     * <br/><br/>\n+     * error-message-binding-pattern := simple-binding-pattern\n+     * <br/><br/>\n+     * error-cause-binding-pattern := simple-binding-pattern | error-binding-pattern\n+     * <br/><br/>\n+     * simple-binding-pattern := capture-binding-pattern | wildcard-binding-pattern\n+     * <br/><br/>\n+     * error-field-binding-patterns :=\n+     *    named-arg-binding-pattern (, named-arg-binding-pattern)* [, rest-binding-pattern]\n+     *    | rest-binding-pattern\n+     * <br/><br/>\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n      * \n      * @return Error binding pattern node.\n      */\n     private STNode parseErrorBindingPattern() {\n-        startContext(ParserRuleContext.FUNCTIONAL_BINDING_PATTERN);\n-        STNode typeDesc = parseErrorKeyword();\n-        return parseFunctionalBindingPattern(typeDesc);\n+        startContext(ParserRuleContext.ERROR_BINDING_PATTERN);\n+        STNode errorKeyword = parseErrorKeyword();\n+        return parseErrorBindingPattern(errorKeyword);\n+    }\n+\n+    private STNode parseErrorBindingPattern(STNode errorKeyword) {\n+        STToken nextToken = peek();\n+        STNode typeRef;\n+        switch (nextToken.kind) {\n+            case IDENTIFIER_TOKEN:\n+                typeRef = parseTypeReference();\n+                break;\n+            case OPEN_PAREN_TOKEN:\n+                typeRef = STNodeFactory.createEmptyNode();\n+                break;\n+            default:\n+                recover(peek(), ParserRuleContext.ERROR_BINDING_PATTERN_ERROR_KEYWORD_RHS);\n+                return parseErrorBindingPattern(errorKeyword);\n+        }\n+        return parseErrorBindingPattern(errorKeyword, typeRef);\n+    }\n+\n+    private STNode parseErrorBindingPattern(STNode errorKeyword, STNode typeRef) {\n+        STNode openParenthesis = parseOpenParenthesis(ParserRuleContext.OPEN_PARENTHESIS);\n+        STNode argListBindingPatterns = parseErrorArgListBindingPatterns();\n+        STNode closeParenthesis = parseCloseParenthesis();\n+        endContext();\n+        return STNodeFactory.createErrorBindingPatternNode(errorKeyword, typeRef, openParenthesis,\n+                argListBindingPatterns, closeParenthesis);\n     }\n \n     /**\n-     * Parse functional binding pattern.\n+     * Parse error arg list binding pattern.\n      * <p>\n      * <code>\n-     * functional-binding-pattern := functionally-constructible-type-reference ( arg-list-binding-pattern )\n+     * error-arg-list-binding-pattern :=\n+     * error-message-binding-pattern [, error-cause-binding-pattern] [, error-field-binding-patterns]\n+     * | [error-field-binding-patterns]\n      * <br/><br/>\n-     * functionally-constructible-type-reference := error | type-reference\n+     *\n+     * error-message-binding-pattern := simple-binding-pattern\n+     * <br/><br/>\n+     *\n+     * error-cause-binding-pattern := simple-binding-pattern | error-binding-pattern\n+     * <br/><br/>\n+     *\n+     * simple-binding-pattern := capture-binding-pattern | wildcard-binding-pattern\n+     * <br/><br/>\n+     *\n+     * error-field-binding-patterns :=\n+     * named-arg-binding-pattern (, named-arg-binding-pattern)* [, rest-binding-pattern]\n+     * | rest-binding-pattern\n+     * <br/><br/>\n+     *\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n      * </code>\n-     * \n-     * @param typeDesc Functionally constructible type reference\n-     * @return Functional binding pattern node.\n+     *\n+     * @return Error arg list binding patterns.\n      */\n-    private STNode parseFunctionalBindingPattern(STNode typeDesc) {\n-        STNode openParenthesis = parseOpenParenthesis(ParserRuleContext.ARG_LIST_START);\n-        STNode argListBindingPatterns = parseArgListBindingPatterns();\n-        STNode closeParenthesis = parseCloseParenthesis();\n-        endContext();\n-        return STNodeFactory.createFunctionalBindingPatternNode(typeDesc, openParenthesis, argListBindingPatterns,\n-                closeParenthesis);\n-    }\n-\n-    private STNode parseArgListBindingPatterns() {\n+    private STNode parseErrorArgListBindingPatterns() {\n         List<STNode> argListBindingPatterns = new ArrayList<>();\n-        SyntaxKind lastValidArgKind = SyntaxKind.CAPTURE_BINDING_PATTERN;\n-        STToken nextToken = peek();\n-\n-        if (isEndOfParametersList(nextToken.kind)) {\n+        if (isEndOfErrorFieldBindingPatterns()) {\n             return STNodeFactory.createNodeList(argListBindingPatterns);\n         }\n-        argListBindingPatterns.add(parseArgBindingPattern());\n+        STNode firstArg = parseErrorArgListBindingPattern(ParserRuleContext.ERROR_ARG_LIST_BINDING_PATTERN_START);\n+        if (firstArg.kind == SyntaxKind.CAPTURE_BINDING_PATTERN ||\n+                firstArg.kind == SyntaxKind.WILDCARD_BINDING_PATTERN) {\n \n-        nextToken = peek();\n-        while (!isEndOfParametersList(nextToken.kind)) {\n-            STNode argEnd = parseArgsBindingPatternEnd();\n+            argListBindingPatterns.add(firstArg);\n+            STNode argEnd = parseErrorArgsBindingPatternEnd(ParserRuleContext.ERROR_MESSAGE_BINDING_PATTERN_END);\n+            if (argEnd != null) {\n+                // null marks the end of args\n+                STNode secondArg = parseErrorArgListBindingPattern(ParserRuleContext.ERROR_MESSAGE_BINDING_PATTERN_RHS);\n+                if (isValidSecondArgBindingPattern(secondArg.kind)) {\n+                    argListBindingPatterns.add(argEnd);\n+                    argListBindingPatterns.add(secondArg);\n+                } else {\n+                    updateLastNodeInListWithInvalidNode(argListBindingPatterns, argEnd, null);\n+                    updateLastNodeInListWithInvalidNode(argListBindingPatterns, secondArg,\n+                            DiagnosticErrorCode.ERROR_BINDING_PATTERN_NOT_ALLOWED);\n+                }\n+            }\n+        } else {\n+            if (firstArg.kind != SyntaxKind.NAMED_ARG_BINDING_PATTERN &&", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e5d00d599006b3f4394f18f682a051cd40b2a2e"}, "originalPosition": 233}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 141, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}