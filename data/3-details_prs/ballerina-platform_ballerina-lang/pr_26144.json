{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk0MTcyMjY5", "number": 26144, "title": "Implement mapping-match-pattern", "bodyText": "Purpose\n$subject\nFixes #25434\nCheck List\n\n Read the Contributing Guide\n Updated Change Log\n Checked Tooling Support (#)\n Added necessary tests\n\n Unit Tests\n Spec Conformance Tests\n Integration Tests\n Ballerina By Example Tests\n\n\n Increased Test Coverage\n Added necessary documentation\n\n API documentation\n Module documentation in Module.md files\n Ballerina By Examples", "createdAt": "2020-09-28T14:12:07Z", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144", "merged": true, "mergeCommit": {"oid": "1da23649df8d2e9880496b1670dbf991a422fe60"}, "closed": true, "closedAt": "2021-01-14T15:45:38Z", "author": {"login": "KavinduZoysa"}, "timelineItems": {"totalCount": 50, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdPhYbfgBqjM4Mzk3NDkwNDA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdwGSeygFqTU2ODM2MjY5Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "279910624a3db380835666909b6da77482f9fa32", "author": {"user": {"login": "KavinduZoysa", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/279910624a3db380835666909b6da77482f9fa32", "committedDate": "2020-09-28T14:07:46Z", "message": "Add the tests"}, "afterCommit": {"oid": "350b2303816107f65442f9b83cb853e1158ec3b4", "author": {"user": {"login": "KavinduZoysa", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/350b2303816107f65442f9b83cb853e1158ec3b4", "committedDate": "2020-10-05T10:38:50Z", "message": "Enable tests"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "350b2303816107f65442f9b83cb853e1158ec3b4", "author": {"user": {"login": "KavinduZoysa", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/350b2303816107f65442f9b83cb853e1158ec3b4", "committedDate": "2020-10-05T10:38:50Z", "message": "Enable tests"}, "afterCommit": {"oid": "53c49cecef51da58516076e79d9e3a72aabaaae0", "author": {"user": {"login": "KavinduZoysa", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/53c49cecef51da58516076e79d9e3a72aabaaae0", "committedDate": "2020-10-06T05:49:28Z", "message": "Enable tests"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "53c49cecef51da58516076e79d9e3a72aabaaae0", "author": {"user": {"login": "KavinduZoysa", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/53c49cecef51da58516076e79d9e3a72aabaaae0", "committedDate": "2020-10-06T05:49:28Z", "message": "Enable tests"}, "afterCommit": {"oid": "f6adfbcf4f81049289f9ef550ece11e3be7a8b7e", "author": {"user": {"login": "KavinduZoysa", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f6adfbcf4f81049289f9ef550ece11e3be7a8b7e", "committedDate": "2020-10-19T09:00:30Z", "message": "Rebase with master"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f6adfbcf4f81049289f9ef550ece11e3be7a8b7e", "author": {"user": {"login": "KavinduZoysa", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f6adfbcf4f81049289f9ef550ece11e3be7a8b7e", "committedDate": "2020-10-19T09:00:30Z", "message": "Rebase with master"}, "afterCommit": {"oid": "1ba840594a125c0163957673f62aaba61bb56f5c", "author": {"user": {"login": "KavinduZoysa", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1ba840594a125c0163957673f62aaba61bb56f5c", "committedDate": "2020-10-23T04:46:39Z", "message": "Add tests"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1ba840594a125c0163957673f62aaba61bb56f5c", "author": {"user": {"login": "KavinduZoysa", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1ba840594a125c0163957673f62aaba61bb56f5c", "committedDate": "2020-10-23T04:46:39Z", "message": "Add tests"}, "afterCommit": {"oid": "c8e24ab9baa7970f4d12358d6b4a62310cb16c82", "author": {"user": {"login": "KavinduZoysa", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c8e24ab9baa7970f4d12358d6b4a62310cb16c82", "committedDate": "2020-10-23T04:59:48Z", "message": "Add tests"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c8e24ab9baa7970f4d12358d6b4a62310cb16c82", "author": {"user": {"login": "KavinduZoysa", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c8e24ab9baa7970f4d12358d6b4a62310cb16c82", "committedDate": "2020-10-23T04:59:48Z", "message": "Add tests"}, "afterCommit": {"oid": "092cfbe5bebb9b77f71bfa6732b3e57c30d02e62", "author": {"user": {"login": "KavinduZoysa", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/092cfbe5bebb9b77f71bfa6732b3e57c30d02e62", "committedDate": "2020-10-23T05:18:30Z", "message": "Add tests"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2cc519be185676756710c6bc51d500515be92f08", "author": {"user": {"login": "KavinduZoysa", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2cc519be185676756710c6bc51d500515be92f08", "committedDate": "2020-10-23T14:34:50Z", "message": "Disable a language server test"}, "afterCommit": {"oid": "85716441863b970c3dbba302c08cb4ed3e55fa06", "author": {"user": {"login": "KavinduZoysa", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/85716441863b970c3dbba302c08cb4ed3e55fa06", "committedDate": "2020-11-02T19:17:46Z", "message": "Disable a formatter test"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "85716441863b970c3dbba302c08cb4ed3e55fa06", "author": {"user": {"login": "KavinduZoysa", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/85716441863b970c3dbba302c08cb4ed3e55fa06", "committedDate": "2020-11-02T19:17:46Z", "message": "Disable a formatter test"}, "afterCommit": {"oid": "b00e917509b394720d660bdc253245fcc333d346", "author": {"user": {"login": "KavinduZoysa", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b00e917509b394720d660bdc253245fcc333d346", "committedDate": "2020-11-03T11:37:23Z", "message": "Disable a formatter test"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "79f48cb894337b35878569d781f011a459f8c24a", "author": {"user": {"login": "KavinduZoysa", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/79f48cb894337b35878569d781f011a459f8c24a", "committedDate": "2020-11-04T14:45:35Z", "message": "Add more tests"}, "afterCommit": {"oid": "6bb24bce0a62d65e933f2d8f3bff8b5d4381b5b6", "author": {"user": {"login": "KavinduZoysa", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6bb24bce0a62d65e933f2d8f3bff8b5d4381b5b6", "committedDate": "2020-11-04T14:56:26Z", "message": "Add more tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI2ODQzNTIx", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#pullrequestreview-526843521", "createdAt": "2020-11-10T04:26:13Z", "commit": {"oid": "6bb24bce0a62d65e933f2d8f3bff8b5d4381b5b6"}, "state": "COMMENTED", "comments": {"totalCount": 20, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwNDoyNjoxM1rOHwLRMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwNTo1Mzo0MlrOHwM0rg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI3ODMyMw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * @since Swan Lake\n          \n          \n            \n             * @since 2.0.0\n          \n      \n    \n    \n  \n\nPlease fix in other new classes too.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r520278323", "createdAt": "2020-11-10T04:26:13Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/ballerinalang/model/tree/matchpatterns/FieldMatchPatternNode.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.model.tree.matchpatterns;\n+\n+import org.ballerinalang.model.tree.IdentifierNode;\n+import org.ballerinalang.model.tree.Node;\n+\n+/**\n+ * The interface with the APIs to implement the field-match-pattern.\n+ *\n+ * @since Swan Lake", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6bb24bce0a62d65e933f2d8f3bff8b5d4381b5b6"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI3ODg0NA==", "bodyText": "Why have we added two commented out test classes for ones that are already running?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r520278844", "createdAt": "2020-11-10T04:28:23Z", "author": {"login": "MaryamZi"}, "path": "tests/jballerina-unit-test/src/test/resources/testng.xml", "diffHunk": "@@ -201,8 +201,11 @@\n             <class name=\"org.ballerinalang.test.statements.matchstmt.MatchStatementSyntaxErrorsTest\"></class>\n             <class name=\"org.ballerinalang.test.statements.matchstmt.varbindingpatternmatchpattern.CaptureBindingPatternTest\"></class>\n             <class name=\"org.ballerinalang.test.statements.matchstmt.MatchStmtListMatchPatternTest\"></class>\n+            <class name=\"org.ballerinalang.test.statements.matchstmt.MatchStmtMappingMatchPatternTest\"></class>\n             <class name=\"org.ballerinalang.test.statements.matchstmt.MatchStatementOnFailTest\"></class>\n             <class name=\"org.ballerinalang.test.lock.LocksWithOnFailTest\"></class>\n+<!--            <class name=\"org.ballerinalang.test.statements.matchstmt.MatchStatementOnFailTest\"></class>-->\n+<!--            <class name=\"org.ballerinalang.test.lock.LocksWithOnFailTest\"></class>-->", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6bb24bce0a62d65e933f2d8f3bff8b5d4381b5b6"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI3OTQwNQ==", "bodyText": "IMO, the formatting has to be consistent with other usage of curly braces + key/value pairs.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    { a : \"str\"} => {\n          \n          \n            \n                    {a: \"str\"} => {", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r520279405", "createdAt": "2020-11-10T04:30:31Z", "author": {"login": "MaryamZi"}, "path": "tests/jballerina-unit-test/src/test/resources/test-src/statements/matchstmt/mapping-match-pattern.bal", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020 WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+//\n+// WSO2 Inc. licenses this file to you under the Apache License,\n+// Version 2.0 (the \"License\"); you may not use this file except\n+// in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+function mappingMatchPattern1(any v) returns string {\n+    match v {\n+        { a : \"str\"} => {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6bb24bce0a62d65e933f2d8f3bff8b5d4381b5b6"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI4MDA2Mw==", "bodyText": "Shall we move this to the end and assert against i? That way we will assert all the errors in the future too.\nAssert.assertEquals(resultNegative.getErrorCount(), i);\nWill have to change i's initial value and switch to i++.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r520280063", "createdAt": "2020-11-10T04:33:05Z", "author": {"login": "MaryamZi"}, "path": "tests/jballerina-unit-test/src/test/java/org/ballerinalang/test/statements/matchstmt/MatchStmtMappingMatchPatternTest.java", "diffHunk": "@@ -0,0 +1,198 @@\n+// Copyright (c) 2020 WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+//\n+// WSO2 Inc. licenses this file to you under the Apache License,\n+// Version 2.0 (the \"License\"); you may not use this file except\n+// in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+package org.ballerinalang.test.statements.matchstmt;\n+\n+import org.ballerinalang.test.util.BAssertUtil;\n+import org.ballerinalang.test.util.BCompileUtil;\n+import org.ballerinalang.test.util.BRunUtil;\n+import org.ballerinalang.test.util.CompileResult;\n+import org.testng.Assert;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+/**\n+ * Test cases to verify the behaviour of the mapping-match-pattern.\n+ *\n+ * @since Swan Lake\n+ */\n+@Test(groups = { \"disableOnOldParser\" })\n+public class MatchStmtMappingMatchPatternTest {\n+\n+    private CompileResult result, resultNegative, resultRestPattern;\n+    private String patternNotMatched = \"pattern will not be matched\";\n+    private String unreachablePattern = \"unreachable pattern\";\n+\n+    @BeforeClass\n+    public void setup() {\n+        result = BCompileUtil.compile(\"test-src/statements/matchstmt/mapping-match-pattern.bal\");\n+        resultRestPattern = BCompileUtil.compile(\"test-src/statements/matchstmt/mapping-match-pattern-with-rest-match\" +\n+                \"-pattern.bal\");\n+        resultNegative = BCompileUtil.compile(\"test-src/statements/matchstmt/mapping-mach-pattern-negative.bal\");\n+    }\n+\n+    @Test\n+    public void testMappingMatchPattern1() {\n+        BRunUtil.invoke(result, \"testMappingMatchPattern1\");\n+    }\n+\n+    @Test\n+    public void testMappingMatchPattern2() {\n+        BRunUtil.invoke(result, \"testMappingMatchPattern2\");\n+    }\n+\n+    @Test\n+    public void testMappingMatchPattern3() {\n+        BRunUtil.invoke(result, \"testMappingMatchPattern3\");\n+    }\n+\n+    @Test\n+    public void testMappingMatchPattern4() {\n+        BRunUtil.invoke(result, \"testMappingMatchPattern4\");\n+    }\n+\n+    @Test\n+    public void testMappingMatchPattern5() {\n+        BRunUtil.invoke(result, \"testMappingMatchPattern5\");\n+    }\n+\n+    @Test\n+    public void testMappingMatchPattern6() {\n+        BRunUtil.invoke(result, \"testMappingMatchPattern6\");\n+    }\n+\n+    @Test\n+    public void testMappingMatchPattern7() {\n+        BRunUtil.invoke(result, \"testMappingMatchPattern7\");\n+    }\n+\n+    @Test\n+    public void testMappingMatchPattern8() {\n+        BRunUtil.invoke(result, \"testMappingMatchPattern8\");\n+    }\n+\n+    @Test\n+    public void testMappingMatchPattern9() {\n+        BRunUtil.invoke(result, \"testMappingMatchPattern9\");\n+    }\n+\n+    @Test\n+    public void testMappingMatchPattern10() {\n+        BRunUtil.invoke(result, \"testMappingMatchPattern10\");\n+    }\n+\n+    @Test\n+    public void testMappingMatchPattern11() {\n+        BRunUtil.invoke(result, \"testMappingMatchPattern11\");\n+    }\n+\n+    @Test\n+    public void testMappingMatchPattern12() {\n+        BRunUtil.invoke(result, \"testMappingMatchPattern12\");\n+    }\n+\n+    @Test\n+    public void testMappingMatchPattern13() {\n+        BRunUtil.invoke(result, \"testMappingMatchPattern13\");\n+    }\n+\n+    @Test\n+    public void testMappingMatchPattern14() {\n+        BRunUtil.invoke(result, \"testMappingMatchPattern14\");\n+    }\n+\n+    @Test\n+    public void testMappingMatchPattern15() {\n+        BRunUtil.invoke(result, \"testMappingMatchPattern15\");\n+    }\n+\n+    @Test\n+    public void testMappingMatchPattern16() {\n+        BRunUtil.invoke(result, \"testMappingMatchPattern16\");\n+    }\n+\n+    @Test\n+    public void testMappingMatchPattern17() {\n+        BRunUtil.invoke(result, \"testMappingMatchPattern17\");\n+    }\n+\n+    @Test\n+    public void testMappingMatchPattern18() {\n+        BRunUtil.invoke(result, \"testMappingMatchPattern18\");\n+    }\n+\n+    @Test\n+    public void testMappingMatchPattern19() {\n+        BRunUtil.invoke(result, \"testMappingMatchPattern19\");\n+    }\n+\n+    @Test\n+    public void testMappingMatchPattern20() {\n+        BRunUtil.invoke(result, \"testMappingMatchPattern20\");\n+    }\n+\n+    @Test\n+    public void testMappingMatchPattern21() {\n+        BRunUtil.invoke(result, \"testMappingMatchPattern21\");\n+    }\n+\n+    @Test\n+    public void testMappingMatchPattern22() {\n+        BRunUtil.invoke(result, \"testMappingMatchPattern22\");\n+    }\n+\n+    @Test\n+    public void testMappingMatchPattern23() {\n+        BRunUtil.invoke(result, \"testMappingMatchPattern23\");\n+    }\n+\n+    @Test\n+    public void testMappingMatchPatternWithRestPattern1() {\n+        BRunUtil.invoke(resultRestPattern, \"testMappingMatchPattern1\");\n+    }\n+\n+    @Test\n+    public void testMappingMatchPatternWithRestPattern2() {\n+        BRunUtil.invoke(resultRestPattern, \"testMappingMatchPattern2\");\n+    }\n+\n+    @Test\n+    public void testMappingMatchPatternWithRestPattern3() {\n+        BRunUtil.invoke(resultRestPattern, \"testMappingMatchPattern3\");\n+    }\n+\n+    @Test\n+    public void testMappingMatchPatternNegative() {\n+        Assert.assertEquals(resultNegative.getErrorCount(), 16);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6bb24bce0a62d65e933f2d8f3bff8b5d4381b5b6"}, "originalPosition": 178}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI4MTY5NQ==", "bodyText": "Shall we make these constants?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r520281695", "createdAt": "2020-11-10T04:39:32Z", "author": {"login": "MaryamZi"}, "path": "tests/jballerina-unit-test/src/test/java/org/ballerinalang/test/statements/matchstmt/MatchStmtMappingMatchPatternTest.java", "diffHunk": "@@ -0,0 +1,198 @@\n+// Copyright (c) 2020 WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+//\n+// WSO2 Inc. licenses this file to you under the Apache License,\n+// Version 2.0 (the \"License\"); you may not use this file except\n+// in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+package org.ballerinalang.test.statements.matchstmt;\n+\n+import org.ballerinalang.test.util.BAssertUtil;\n+import org.ballerinalang.test.util.BCompileUtil;\n+import org.ballerinalang.test.util.BRunUtil;\n+import org.ballerinalang.test.util.CompileResult;\n+import org.testng.Assert;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+/**\n+ * Test cases to verify the behaviour of the mapping-match-pattern.\n+ *\n+ * @since Swan Lake\n+ */\n+@Test(groups = { \"disableOnOldParser\" })\n+public class MatchStmtMappingMatchPatternTest {\n+\n+    private CompileResult result, resultNegative, resultRestPattern;\n+    private String patternNotMatched = \"pattern will not be matched\";\n+    private String unreachablePattern = \"unreachable pattern\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6bb24bce0a62d65e933f2d8f3bff8b5d4381b5b6"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI4Mjc2OA==", "bodyText": "Formatting needs to be fixed for these too.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                map<int> v2 = { a : 2 };\n          \n          \n            \n                map<int> v2 = {a: 2};", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r520282768", "createdAt": "2020-11-10T04:43:56Z", "author": {"login": "MaryamZi"}, "path": "tests/jballerina-unit-test/src/test/resources/test-src/statements/matchstmt/mapping-mach-pattern-negative.bal", "diffHunk": "@@ -0,0 +1,84 @@\n+const string CONST1 = \"str\";\n+\n+function testMappingMatchPatternNegative() returns string {\n+\n+    boolean v1 = true;\n+    match v1 {\n+        { a : true } => { // pattern will not be matched\n+            return \"Match\";\n+        }\n+    }\n+\n+    map<int> v2 = { a : 2 };", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6bb24bce0a62d65e933f2d8f3bff8b5d4381b5b6"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI4Mjg0MQ==", "bodyText": "Missing the licence header.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r520282841", "createdAt": "2020-11-10T04:44:11Z", "author": {"login": "MaryamZi"}, "path": "tests/jballerina-unit-test/src/test/resources/test-src/statements/matchstmt/mapping-mach-pattern-negative.bal", "diffHunk": "@@ -0,0 +1,84 @@\n+const string CONST1 = \"str\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6bb24bce0a62d65e933f2d8f3bff8b5d4381b5b6"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI4MzEzMQ==", "bodyText": "Shall we add at least a brief description? Please check other classes too.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r520283131", "createdAt": "2020-11-10T04:45:10Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/tree/matchpatterns/BLangMappingMatchPattern.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.wso2.ballerinalang.compiler.tree.matchpatterns;\n+\n+import org.ballerinalang.model.tree.NodeKind;\n+import org.ballerinalang.model.tree.matchpatterns.FieldMatchPatternNode;\n+import org.ballerinalang.model.tree.matchpatterns.MappingMatchPatternNode;\n+import org.ballerinalang.model.tree.matchpatterns.RestMatchPatternNode;\n+import org.wso2.ballerinalang.compiler.tree.BLangNodeVisitor;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * @since Swan Lake", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6bb24bce0a62d65e933f2d8f3bff8b5d4381b5b6"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI4MzE4NA==", "bodyText": "Is this still relevant?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r520283184", "createdAt": "2020-11-10T04:45:22Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/tree/matchpatterns/BLangMappingMatchPattern.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.wso2.ballerinalang.compiler.tree.matchpatterns;\n+\n+import org.ballerinalang.model.tree.NodeKind;\n+import org.ballerinalang.model.tree.matchpatterns.FieldMatchPatternNode;\n+import org.ballerinalang.model.tree.matchpatterns.MappingMatchPatternNode;\n+import org.ballerinalang.model.tree.matchpatterns.RestMatchPatternNode;\n+import org.wso2.ballerinalang.compiler.tree.BLangNodeVisitor;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * @since Swan Lake\n+ */\n+public class BLangMappingMatchPattern extends BLangMatchPattern implements MappingMatchPatternNode {\n+\n+    public List<BLangFieldMatchPattern> fieldMatchPatterns = new ArrayList<>();\n+    public BLangRestMatchPattern restMatchPattern;\n+    // TODO : add rest-match-pattern", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6bb24bce0a62d65e933f2d8f3bff8b5d4381b5b6"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI4MzIzNA==", "bodyText": "Extra new line inconsistent with the rest of the class?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r520283234", "createdAt": "2020-11-10T04:45:39Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/tree/matchpatterns/BLangMappingMatchPattern.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.wso2.ballerinalang.compiler.tree.matchpatterns;\n+\n+import org.ballerinalang.model.tree.NodeKind;\n+import org.ballerinalang.model.tree.matchpatterns.FieldMatchPatternNode;\n+import org.ballerinalang.model.tree.matchpatterns.MappingMatchPatternNode;\n+import org.ballerinalang.model.tree.matchpatterns.RestMatchPatternNode;\n+import org.wso2.ballerinalang.compiler.tree.BLangNodeVisitor;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * @since Swan Lake\n+ */\n+public class BLangMappingMatchPattern extends BLangMatchPattern implements MappingMatchPatternNode {\n+\n+    public List<BLangFieldMatchPattern> fieldMatchPatterns = new ArrayList<>();\n+    public BLangRestMatchPattern restMatchPattern;\n+    // TODO : add rest-match-pattern\n+\n+    @Override\n+    public void accept(BLangNodeVisitor visitor) {\n+        visitor.visit(this);\n+    }\n+\n+    @Override\n+    public NodeKind getKind() {\n+        return NodeKind.MAPPING_MATCH_PATTERN;\n+    }\n+\n+    @Override\n+    public List<? extends FieldMatchPatternNode> getFieldMatchPatterns() {\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6bb24bce0a62d65e933f2d8f3bff8b5d4381b5b6"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI4Mzk4Ng==", "bodyText": "@pubudu91, along with your recent changes, we need to set the ANONYMOUS flag here, right?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r520283986", "createdAt": "2020-11-10T04:48:40Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/SemanticAnalyzer.java", "diffHunk": "@@ -2345,6 +2348,136 @@ public void visit(BLangMatchGuard matchGuard) {\n         matchGuard.expr.accept(this);\n     }\n \n+    @Override\n+    public void visit(BLangMappingMatchPattern mappingMatchPattern) {\n+        BRecordTypeSymbol recordSymbol =\n+                Symbols.createRecordSymbol(0, names.fromString(\"$anonRecordType$\" + recordCount++),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6bb24bce0a62d65e933f2d8f3bff8b5d4381b5b6"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI4NDUyMw==", "bodyText": "Can't/shouldn't we call analyzeNode instead of directly calling accept?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r520284523", "createdAt": "2020-11-10T04:50:20Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/SemanticAnalyzer.java", "diffHunk": "@@ -2345,6 +2348,136 @@ public void visit(BLangMatchGuard matchGuard) {\n         matchGuard.expr.accept(this);\n     }\n \n+    @Override\n+    public void visit(BLangMappingMatchPattern mappingMatchPattern) {\n+        BRecordTypeSymbol recordSymbol =\n+                Symbols.createRecordSymbol(0, names.fromString(\"$anonRecordType$\" + recordCount++),\n+                        env.enclPkg.symbol.pkgID, null, env.scope.owner, mappingMatchPattern.pos, VIRTUAL);\n+        LinkedHashMap<String, BField> fields = new LinkedHashMap<>();\n+\n+        for (BLangFieldMatchPattern fieldMatchPattern : mappingMatchPattern.fieldMatchPatterns) {\n+            fieldMatchPattern.accept(this);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6bb24bce0a62d65e933f2d8f3bff8b5d4381b5b6"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI5MDU3Ng==", "bodyText": "Don't we have to reset this?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r520290576", "createdAt": "2020-11-10T05:13:03Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -367,6 +373,19 @@ public BType resolvePatternTypeFromMatchExpr(BLangExpression matchExpr, BLangExp\n         return symTable.noType;\n     }\n \n+    public BType resolvePatternTypeFromMatchExpr(BLangMappingMatchPattern mappingMatchPattern, BType patternType,\n+                                                 SymbolEnv env) {\n+        if (mappingMatchPattern.matchExpr == null) {\n+            return patternType;\n+        }\n+        this.env = env;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6bb24bce0a62d65e933f2d8f3bff8b5d4381b5b6"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI5NDUxMw==", "bodyText": "The rest match pattern needs to allow for all unmatched fields which can include non-rest fields in the case of a record.\nThe following doesn't fail atm.\npublic function main() {\n    record {|\n        int a;\n        int b;\n        string...;\n    |} x = {a : 2, b: 3};\n\n    match x {\n        {a: 2, ...var rst} => {\n            map<string> mp = rst; // no compilation error, even though the type of `rst`\n                                  // is `record {|int b; string...;|}`  \n        }\n    }\n}", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r520294513", "createdAt": "2020-11-10T05:27:00Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/SemanticAnalyzer.java", "diffHunk": "@@ -2345,6 +2348,136 @@ public void visit(BLangMatchGuard matchGuard) {\n         matchGuard.expr.accept(this);\n     }\n \n+    @Override\n+    public void visit(BLangMappingMatchPattern mappingMatchPattern) {\n+        BRecordTypeSymbol recordSymbol =\n+                Symbols.createRecordSymbol(0, names.fromString(\"$anonRecordType$\" + recordCount++),\n+                        env.enclPkg.symbol.pkgID, null, env.scope.owner, mappingMatchPattern.pos, VIRTUAL);\n+        LinkedHashMap<String, BField> fields = new LinkedHashMap<>();\n+\n+        for (BLangFieldMatchPattern fieldMatchPattern : mappingMatchPattern.fieldMatchPatterns) {\n+            fieldMatchPattern.accept(this);\n+            String fieldName = fieldMatchPattern.fieldName.value;\n+            BVarSymbol fieldSymbol = new BVarSymbol(0, names.fromString(fieldName), env.enclPkg.symbol.pkgID,\n+                    fieldMatchPattern.matchPattern.type, recordSymbol, fieldMatchPattern.pos, COMPILED_SOURCE);\n+            BField field = new BField(names.fromString(fieldName), fieldMatchPattern.pos, fieldSymbol);\n+            fields.put(fieldName, field);\n+            mappingMatchPattern.declaredVars.putAll(fieldMatchPattern.declaredVars);\n+        }\n+        BRecordType recordVarType = new BRecordType(recordSymbol);\n+        recordVarType.fields = fields;\n+        recordVarType.restFieldType = symTable.anydataType;\n+        if (mappingMatchPattern.restMatchPattern != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6bb24bce0a62d65e933f2d8f3bff8b5d4381b5b6"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI5NTgyMQ==", "bodyText": "Types is like a stateless util class, so IMO, we shouldn't do this. Can't we pass the env from wherever the methods are called?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r520295821", "createdAt": "2020-11-10T05:29:07Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -128,6 +132,8 @@\n     private Names names;\n     private int finiteTypeCount = 0;\n     private BUnionType expandedXMLBuiltinSubtypes;\n+    private int recordCount = 0;\n+    private SymbolEnv env;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6bb24bce0a62d65e933f2d8f3bff8b5d4381b5b6"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI5NzI4NA==", "bodyText": "Neither any nor anydata contain error. So shouldn't we check what the other type is here?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r520297284", "createdAt": "2020-11-10T05:31:17Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -380,10 +399,32 @@ private boolean containsAnyType(BType type) {\n         return false;\n     }\n \n+    private boolean containsAnyDataType(BType type) {\n+        if (type.tag != TypeTags.UNION) {\n+            return type.tag == TypeTags.ANYDATA;\n+        }\n+\n+        for (BType memberTypes : ((BUnionType) type).getMemberTypes()) {\n+            if (memberTypes.tag == TypeTags.ANYDATA) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n     public BType mergeTypes(BType typeFirst, BType typeSecond) {\n         if (containsAnyType(typeFirst)) {\n             return typeSecond;\n         }\n+        if (containsAnyType(typeSecond)) {\n+            return typeFirst;\n+        }\n+        if (containsAnyDataType(typeFirst)) {\n+            return typeSecond;\n+        }\n+        if (containsAnyDataType(typeSecond)) {\n+            return typeFirst;\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6bb24bce0a62d65e933f2d8f3bff8b5d4381b5b6"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI5NzY2MQ==", "bodyText": "Shouldn't we create a new BMapType here instead of updating the parameter?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r520297661", "createdAt": "2020-11-10T05:32:52Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2756,6 +2788,61 @@ BType getTypeForUnionTypeMembersAssignableToType(BUnionType unionType, BType tar\n         }\n     }\n \n+    BType getTypeForMapTypeMembersAssignableToType(BMapType mapType, BType targetType) {\n+        if (targetType.tag != TypeTags.MAP && targetType.tag != TypeTags.RECORD) {\n+            return symTable.semanticError;\n+        }\n+        if (targetType.tag == TypeTags.MAP) {\n+            BType intersectionConstraintType = getTypeIntersection(mapType.constraint,\n+                    ((BMapType) targetType).constraint);\n+            if (intersectionConstraintType != symTable.semanticError) {\n+                return symTable.semanticError;\n+            }\n+            mapType.constraint = intersectionConstraintType;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6bb24bce0a62d65e933f2d8f3bff8b5d4381b5b6"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDMwMjU1Nw==", "bodyText": "Are these names accurate? Just gets the intersection, right?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r520302557", "createdAt": "2020-11-10T05:49:44Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2756,6 +2788,61 @@ BType getTypeForUnionTypeMembersAssignableToType(BUnionType unionType, BType tar\n         }\n     }\n \n+    BType getTypeForMapTypeMembersAssignableToType(BMapType mapType, BType targetType) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6bb24bce0a62d65e933f2d8f3bff8b5d4381b5b6"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDMwMzE1NQ==", "bodyText": "Aren't we implementing record-record intersection here? If so shouldn't we change the check in L2808 to just\ntargetType.tag != TypeTags.MAP\n@dulvinw is probably implementing record-record intersection though.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r520303155", "createdAt": "2020-11-10T05:51:37Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2756,6 +2788,61 @@ BType getTypeForUnionTypeMembersAssignableToType(BUnionType unionType, BType tar\n         }\n     }\n \n+    BType getTypeForMapTypeMembersAssignableToType(BMapType mapType, BType targetType) {\n+        if (targetType.tag != TypeTags.MAP && targetType.tag != TypeTags.RECORD) {\n+            return symTable.semanticError;\n+        }\n+        if (targetType.tag == TypeTags.MAP) {\n+            BType intersectionConstraintType = getTypeIntersection(mapType.constraint,\n+                    ((BMapType) targetType).constraint);\n+            if (intersectionConstraintType != symTable.semanticError) {\n+                return symTable.semanticError;\n+            }\n+            mapType.constraint = intersectionConstraintType;\n+            return mapType;\n+        }\n+        return getTypeForRecordTypeMembersAssignableToType((BRecordType) targetType, mapType);\n+    }\n+\n+    BType getTypeForRecordTypeMembersAssignableToType(BRecordType recordType, BType targetType) {\n+        if (targetType.tag != TypeTags.MAP && targetType.tag != TypeTags.RECORD) {\n+            return symTable.semanticError;\n+        }\n+        if (targetType.tag == TypeTags.MAP) {\n+            BRecordTypeSymbol recordSymbol =\n+                    Symbols.createRecordSymbol(0, names.fromString(\"$anonRecordIntersectionType$\" + recordCount++),\n+                            env.enclPkg.symbol.pkgID, null, env.scope.owner, recordType.tsymbol.pos, VIRTUAL);\n+            LinkedHashMap<String, BField> fields = new LinkedHashMap<>();\n+            for (String key : recordType.fields.keySet()) {\n+                BType intersectionKeyType = getTypeIntersection(recordType.fields.get(key).type,\n+                        ((BMapType) targetType).constraint);\n+                if (intersectionKeyType == symTable.semanticError) {\n+                    return symTable.semanticError;\n+                }\n+                BVarSymbol fieldSymbol = new BVarSymbol(0, names.fromString(key), env.enclPkg.symbol.pkgID,\n+                        intersectionKeyType, recordSymbol, recordType.fields.get(key).pos, COMPILED_SOURCE);\n+                BField field = new BField(names.fromString(key), recordType.fields.get(key).pos, fieldSymbol);\n+                fields.put(key, field);\n+            }\n+            BRecordType intersectionRecordType = new BRecordType(recordSymbol);\n+            recordSymbol.type = intersectionRecordType;\n+            intersectionRecordType.fields = fields;\n+\n+            if (recordType.restFieldType != null) {\n+                BType intersectionRestType = getTypeIntersection(recordType.restFieldType,\n+                        ((BMapType) targetType).constraint);\n+                if (intersectionRestType == symTable.semanticError) {\n+                    intersectionRecordType.sealed = true;\n+                }\n+                intersectionRecordType.restFieldType = intersectionRestType;\n+            } else {\n+                intersectionRecordType.sealed = recordType.sealed;\n+            }\n+            return intersectionRecordType;\n+        }\n+        return symTable.semanticError;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6bb24bce0a62d65e933f2d8f3bff8b5d4381b5b6"}, "originalPosition": 169}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDMwMzc5MA==", "bodyText": "Is this still relevant?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r520303790", "createdAt": "2020-11-10T05:53:42Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/tree/matchpatterns/BLangMappingMatchPattern.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.wso2.ballerinalang.compiler.tree.matchpatterns;\n+\n+import org.ballerinalang.model.tree.NodeKind;\n+import org.ballerinalang.model.tree.matchpatterns.FieldMatchPatternNode;\n+import org.ballerinalang.model.tree.matchpatterns.MappingMatchPatternNode;\n+import org.ballerinalang.model.tree.matchpatterns.RestMatchPatternNode;\n+import org.wso2.ballerinalang.compiler.tree.BLangNodeVisitor;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * @since Swan Lake\n+ */\n+public class BLangMappingMatchPattern extends BLangMatchPattern implements MappingMatchPatternNode {\n+\n+    public List<BLangFieldMatchPattern> fieldMatchPatterns = new ArrayList<>();\n+    public BLangRestMatchPattern restMatchPattern;\n+    // TODO : add rest-match-pattern", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6bb24bce0a62d65e933f2d8f3bff8b5d4381b5b6"}, "originalPosition": 36}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3fc4678f2d6e2dfceda9bfdf83a398c838958f03", "author": {"user": {"login": "KavinduZoysa", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3fc4678f2d6e2dfceda9bfdf83a398c838958f03", "committedDate": "2020-11-12T03:59:48Z", "message": "Fix review suggestions"}, "afterCommit": {"oid": "1f6b301ac68a9deeb1d4176dc36f1d668366101a", "author": {"user": {"login": "KavinduZoysa", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1f6b301ac68a9deeb1d4176dc36f1d668366101a", "committedDate": "2020-11-12T04:09:59Z", "message": "Fix review suggestions"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1f6b301ac68a9deeb1d4176dc36f1d668366101a", "author": {"user": {"login": "KavinduZoysa", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1f6b301ac68a9deeb1d4176dc36f1d668366101a", "committedDate": "2020-11-12T04:09:59Z", "message": "Fix review suggestions"}, "afterCommit": {"oid": "eb08826815f53e2db2b5bc5da000cda33122c47c", "author": {"user": {"login": "KavinduZoysa", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/eb08826815f53e2db2b5bc5da000cda33122c47c", "committedDate": "2020-11-12T08:43:26Z", "message": "Fix review suggestions"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "eb08826815f53e2db2b5bc5da000cda33122c47c", "author": {"user": {"login": "KavinduZoysa", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/eb08826815f53e2db2b5bc5da000cda33122c47c", "committedDate": "2020-11-12T08:43:26Z", "message": "Fix review suggestions"}, "afterCommit": {"oid": "366c9a4bacd059aa1c6d6e33fc04bd34c07e7d61", "author": {"user": {"login": "KavinduZoysa", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/366c9a4bacd059aa1c6d6e33fc04bd34c07e7d61", "committedDate": "2020-11-17T04:44:34Z", "message": "Add record intersection"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM1MDc3MzY5", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#pullrequestreview-535077369", "createdAt": "2020-11-20T04:50:51Z", "commit": {"oid": "60633c4b0cba351b0952428c39168a63cc34d2df"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQwNDo1MDo1MlrOH29skA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQwNToyODo0MFrOH2-kkw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzM5NTk4NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * @since Swan Lake\n          \n          \n            \n             * @since 2.0.0", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r527395984", "createdAt": "2020-11-20T04:50:52Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/ballerinalang/model/tree/matchpatterns/MappingMatchPatternNode.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.model.tree.matchpatterns;\n+\n+import org.ballerinalang.model.tree.Node;\n+\n+import java.util.List;\n+\n+/**\n+ * The interface with the APIs to implement the mapping-match-pattern.\n+ *\n+ * @since Swan Lake", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60633c4b0cba351b0952428c39168a63cc34d2df"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzM5NzAyMw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * @since Swan Lake\n          \n          \n            \n             * @since 2.0.0", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r527397023", "createdAt": "2020-11-20T04:54:50Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/ballerinalang/model/tree/matchpatterns/RestMatchPatternNode.java", "diffHunk": "@@ -18,13 +18,14 @@\n package org.ballerinalang.model.tree.matchpatterns;\n \n import org.ballerinalang.model.tree.IdentifierNode;\n+import org.ballerinalang.model.tree.Node;\n \n /**\n  * The interface with the APIs to implement the rest-match-pattern.\n  *\n- * @since 2.0.0\n+ * @since Swan Lake", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60633c4b0cba351b0952428c39168a63cc34d2df"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzQwMDkzOA==", "bodyText": "Do we have an issue to track cleaning these up?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r527400938", "createdAt": "2020-11-20T05:09:58Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/parser/BLangNodeTransformer.java", "diffHunk": "@@ -3916,23 +3927,53 @@ private BLangMatchPattern transformMatchPattern(Node matchPattern, Location matc\n             if (listMatchPatternNode.restMatchPattern().isPresent()) {\n                 RestMatchPatternNode restMatchPatternNode = listMatchPatternNode.restMatchPattern().get();\n                 bLangListMatchPattern.setRestMatchPattern(\n-                        (BLangRestMatchPattern) transformMatchPattern(restMatchPatternNode,\n-                                getPosition(restMatchPatternNode)));\n+                        (BLangRestMatchPattern) transformMatchPattern(restMatchPatternNode));\n             }\n             return bLangListMatchPattern;\n-        } else if (matchPattern.kind() == SyntaxKind.REST_MATCH_PATTERN) {\n+        }\n+\n+        if (kind == SyntaxKind.REST_MATCH_PATTERN) {\n             RestMatchPatternNode restMatchPatternNode = (RestMatchPatternNode) matchPattern;\n             BLangRestMatchPattern bLangRestMatchPattern = (BLangRestMatchPattern) TreeBuilder.createRestMatchPattern();\n             bLangRestMatchPattern.pos = matchPatternPos;\n \n             SimpleNameReferenceNode variableName = restMatchPatternNode.variableName();\n             bLangRestMatchPattern.setIdentifier(createIdentifier(getPosition(variableName), variableName.name()));\n             return bLangRestMatchPattern;\n-        } else {\n-            // TODO : Remove this after all binding patterns are implemented\n-            dlog.error(matchPatternPos, DiagnosticCode.MATCH_PATTERN_NOT_SUPPORTED);\n-            return null;\n         }\n+\n+        if (kind == SyntaxKind.MAPPING_MATCH_PATTERN) {\n+            MappingMatchPatternNode mappingMatchPatternNode = (MappingMatchPatternNode) matchPattern;\n+            BLangMappingMatchPattern bLangMappingMatchPattern =\n+                    (BLangMappingMatchPattern) TreeBuilder.createMappingMatchPattern();\n+            bLangMappingMatchPattern.pos = matchPatternPos;\n+\n+            for (FieldMatchPatternNode fieldMatchPatternNode : mappingMatchPatternNode.fieldMatchPatterns()) {\n+                bLangMappingMatchPattern.fieldMatchPatterns.add((BLangFieldMatchPattern)\n+                        transformMatchPattern(fieldMatchPatternNode));\n+            }\n+            if (mappingMatchPatternNode.restMatchPattern().isPresent()) {\n+                bLangMappingMatchPattern.restMatchPattern =\n+                        (BLangRestMatchPattern) transformMatchPattern(mappingMatchPatternNode.restMatchPattern().get());\n+            }\n+\n+            return bLangMappingMatchPattern;\n+        }\n+\n+        if (kind == SyntaxKind.FIELD_MATCH_PATTERN) {\n+            FieldMatchPatternNode fieldMatchPatternNode = (FieldMatchPatternNode) matchPattern;\n+            BLangFieldMatchPattern bLangFieldMatchPattern =\n+                    (BLangFieldMatchPattern) TreeBuilder.createFieldMatchPattern();\n+\n+            bLangFieldMatchPattern.fieldName =\n+                    createIdentifier(fieldMatchPatternNode.fieldNameNode());\n+            bLangFieldMatchPattern.matchPattern = transformMatchPattern(fieldMatchPatternNode.matchPattern());\n+            return bLangFieldMatchPattern;\n+        }\n+\n+        // TODO : Remove this after all binding patterns are implemented", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60633c4b0cba351b0952428c39168a63cc34d2df"}, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzQwMTE3NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void visit(BLangFieldMatchPattern fieldMatchPattern) {}\n          \n          \n            \n                public void visit(BLangFieldMatchPattern fieldMatchPattern) {\n          \n          \n            \n                }", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r527401175", "createdAt": "2020-11-20T05:10:33Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/CodeAnalyzer.java", "diffHunk": "@@ -898,6 +900,13 @@ public void visit(BLangMatchClause matchClause) {\n         resetStatementReturns();\n     }\n \n+    @Override\n+    public void visit(BLangMappingMatchPattern mappingMatchPattern) {\n+    }\n+\n+    @Override\n+    public void visit(BLangFieldMatchPattern fieldMatchPattern) {}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60633c4b0cba351b0952428c39168a63cc34d2df"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzQxMDMyMw==", "bodyText": "Is it correct to pass the pkgEnv here? Shouldn't it be the current env?\nFor example, if this env is eventually used to create a record for an intersection, and that intersection is within a function, the owner has to be the function and not the module?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r527410323", "createdAt": "2020-11-20T05:28:40Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeNarrower.java", "diffHunk": "@@ -257,15 +258,16 @@ private NarrowedTypes getNarrowedTypesForBinaryOp(Map<BVarSymbol, NarrowedTypes>\n             rhsTrueType = rhsFalseType = symbol.type;\n         }\n \n+        SymbolEnv pkgEnv = symTable.pkgEnvMap.get(this.env.enclPkg.symbol);\n         BType trueType, falseType;\n         if (operator == OperatorKind.AND) {\n-            trueType = types.getTypeIntersection(lhsTrueType, rhsTrueType);\n-            BType tmpType = types.getTypeIntersection(lhsTrueType, rhsFalseType);\n+            trueType = types.getTypeIntersection(lhsTrueType, rhsTrueType, pkgEnv);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60633c4b0cba351b0952428c39168a63cc34d2df"}, "originalPosition": 19}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "60633c4b0cba351b0952428c39168a63cc34d2df", "author": {"user": {"login": "KavinduZoysa", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/60633c4b0cba351b0952428c39168a63cc34d2df", "committedDate": "2020-11-18T04:48:25Z", "message": "Handle zero patterns"}, "afterCommit": {"oid": "f4c1e7fa41fac422ee832a102c029316dc408594", "author": {"user": {"login": "KavinduZoysa", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f4c1e7fa41fac422ee832a102c029316dc408594", "committedDate": "2020-11-20T08:49:09Z", "message": "Rebase with master"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f4c1e7fa41fac422ee832a102c029316dc408594", "author": {"user": {"login": "KavinduZoysa", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f4c1e7fa41fac422ee832a102c029316dc408594", "committedDate": "2020-11-20T08:49:09Z", "message": "Rebase with master"}, "afterCommit": {"oid": "b8de7c9cbdc760ababb5c117b942185a816939d3", "author": {"user": {"login": "KavinduZoysa", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b8de7c9cbdc760ababb5c117b942185a816939d3", "committedDate": "2020-11-23T03:17:06Z", "message": "Rebase with master"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b8de7c9cbdc760ababb5c117b942185a816939d3", "author": {"user": {"login": "KavinduZoysa", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b8de7c9cbdc760ababb5c117b942185a816939d3", "committedDate": "2020-11-23T03:17:06Z", "message": "Rebase with master"}, "afterCommit": {"oid": "1055ec1c66a9e91c8786d22d559dffc403d1011c", "author": {"user": {"login": "KavinduZoysa", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1055ec1c66a9e91c8786d22d559dffc403d1011c", "committedDate": "2020-11-23T06:32:48Z", "message": "Rebase with master"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUwNjkyMTgx", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#pullrequestreview-550692181", "createdAt": "2020-12-12T05:22:41Z", "commit": {"oid": "1055ec1c66a9e91c8786d22d559dffc403d1011c"}, "state": "COMMENTED", "comments": {"totalCount": 19, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMlQwNToyMjo0MlrOIEa46A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMlQwNzo1NTowM1rOIEcMqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTUwNTc2OA==", "bodyText": "Is this used? If this is needed how come we don not need set methods for the field match patterns?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r541505768", "createdAt": "2020-12-12T05:22:42Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/ballerinalang/model/tree/matchpatterns/MappingMatchPatternNode.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.model.tree.matchpatterns;\n+\n+import org.ballerinalang.model.tree.Node;\n+\n+import java.util.List;\n+\n+/**\n+ * The interface with the APIs to implement the mapping-match-pattern.\n+ *\n+ * @since 2.0.0\n+ */\n+public interface MappingMatchPatternNode extends Node {\n+    List<? extends FieldMatchPatternNode> getFieldMatchPatterns();\n+\n+    RestMatchPatternNode getRestMatchPattern();\n+\n+    void setRestMatchPattern(RestMatchPatternNode restMatchPattern);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1055ec1c66a9e91c8786d22d559dffc403d1011c"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTUwNjU4Ng==", "bodyText": "Do we need to set the symbol also here? We don't usually do that in the node cloner, right?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r541506586", "createdAt": "2020-12-12T05:28:57Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/parser/NodeCloner.java", "diffHunk": "@@ -746,6 +748,23 @@ public void visit(BLangListMatchPattern source) {\n         clone.declaredVars = source.declaredVars;\n     }\n \n+    @Override\n+    public void visit(BLangCaptureBindingPattern source) {\n+        BLangCaptureBindingPattern clone = new BLangCaptureBindingPattern();\n+        source.cloneRef = clone;\n+        clone.setIdentifier(source.getIdentifier());\n+        clone.symbol = (BVarSymbol) source.getSymbol();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1055ec1c66a9e91c8786d22d559dffc403d1011c"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTUxMjg4NA==", "bodyText": "The following should work, right? x in the block scope should override the one in module scope?\nmap<int> x = {};\n\npublic function main() {\n    map<int> m = {a: 1, b: 2, c: 3};\n\n    // var x = m; // OK\n\n    match m {\n        {a: 1, ...var x} => {\n\n        }\n    }\n}\nFails with a \"redeclared symbol 'x'\" error for the module-level variable.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r541512884", "createdAt": "2020-12-12T06:13:14Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/SemanticAnalyzer.java", "diffHunk": "@@ -2349,7 +2356,20 @@ public void visit(BLangMatchClause matchClause) {\n         SymbolEnv blockEnv = SymbolEnv.createBlockEnv(matchClause.blockStmt, env);\n \n         for (BLangMatchPattern matchPattern : matchClause.matchPatterns) {\n-            analyzeNode(matchPattern, blockEnv);\n+            SymbolEnv patternEnv = SymbolEnv.createPatternEnv(matchPattern, env);\n+            analyzeNode(matchPattern, patternEnv);\n+            Map<String, BVarSymbol> clauseVariables = matchClause.declaredVars;\n+            Map<String, BVarSymbol> patternVariables = matchPattern.declaredVars;\n+            for (String patternVariableName : patternVariables.keySet()) {\n+                BVarSymbol patternVariableSymbol = patternVariables.get(patternVariableName);\n+                if (!clauseVariables.containsKey(patternVariableName)) {\n+                    symbolEnter.defineSymbol(patternVariableSymbol.pos, patternVariableSymbol, blockEnv);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1055ec1c66a9e91c8786d22d559dffc403d1011c"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTUxNDY0OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    {a:\"str\"} => {\n          \n          \n            \n                    {a: \"str\"} => {", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r541514649", "createdAt": "2020-12-12T06:24:59Z", "author": {"login": "MaryamZi"}, "path": "tests/jballerina-unit-test/src/test/resources/test-src/statements/matchstmt/mapping-match-pattern.bal", "diffHunk": "@@ -0,0 +1,516 @@\n+// Copyright (c) 2020 WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+//\n+// WSO2 Inc. licenses this file to you under the Apache License,\n+// Version 2.0 (the \"License\"); you may not use this file except\n+// in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+function mappingMatchPattern1(any v) returns string {\n+    match v {\n+        {a:\"str\"} => {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1055ec1c66a9e91c8786d22d559dffc403d1011c"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTUxNTM0Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    { x : var a, y : 3 } => {\n          \n          \n            \n                    {x: var a, y: 3} => {\n          \n      \n    \n    \n  \n\nPlease fix formatting in all of the tests introduced here.\n\nno space after { and before }\nk1: v1, k2: v2 - no space before the colon, have a space after a comma and a colon", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r541515342", "createdAt": "2020-12-12T06:30:10Z", "author": {"login": "MaryamZi"}, "path": "tests/jballerina-unit-test/src/test/resources/test-src/statements/matchstmt/mapping-mach-pattern-negative.bal", "diffHunk": "@@ -0,0 +1,100 @@\n+// Copyright (c) 2020 WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+//\n+// WSO2 Inc. licenses this file to you under the Apache License,\n+// Version 2.0 (the \"License\"); you may not use this file except\n+// in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+const string CONST1 = \"str\";\n+\n+function testMappingMatchPatternNegative() returns string {\n+\n+    boolean v1 = true;\n+    match v1 {\n+        { a : true } => { // pattern will not be matched\n+            return \"Match\";\n+        }\n+    }\n+\n+    map<int> v2 = { a : 2 };\n+    match v2 {\n+        { a : \"2\" } => { // pattern will not be matched\n+            return \"Match\";\n+        }\n+        { x : 2, y : \"2\" } | { x : 3, y : \"3\"} => { // pattern will not be matched\n+            return \"Match\";\n+        }\n+        { c1 : CONST1, c2 : 2 } => { // pattern will not be matched\n+            return \"Match\";\n+        }\n+    }\n+\n+    map<int|string> v3 = { a : 2, b : \"2\" };\n+    match v3 {\n+        { a : 2 , b : true } => { // pattern will not be matched\n+            return \"Match\";\n+        }\n+        { a : CONST1 , b : true } => { // pattern will not be matched\n+            return \"Match\";\n+        }\n+    }\n+\n+    return \"No match\";\n+\n+}\n+\n+const X = 2;\n+const Y = 4;\n+function testSameMatchPatternsNegative1() {\n+    map<int> v = { x : 1, y : 2 };\n+    match v {\n+        { x : var a, y : 2 } | { x : var a, y : 2 } => { // unreachable pattern\n+        }\n+        { x : var a, y : 3 } => {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1055ec1c66a9e91c8786d22d559dffc403d1011c"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTUxNzQyNQ==", "bodyText": "Still seems to be using pkgEnv?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r541517425", "createdAt": "2020-12-12T06:44:45Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeNarrower.java", "diffHunk": "@@ -257,15 +258,16 @@ private NarrowedTypes getNarrowedTypesForBinaryOp(Map<BVarSymbol, NarrowedTypes>\n             rhsTrueType = rhsFalseType = symbol.type;\n         }\n \n+        SymbolEnv pkgEnv = symTable.pkgEnvMap.get(this.env.enclPkg.symbol);\n         BType trueType, falseType;\n         if (operator == OperatorKind.AND) {\n-            trueType = types.getTypeIntersection(lhsTrueType, rhsTrueType);\n-            BType tmpType = types.getTypeIntersection(lhsTrueType, rhsFalseType);\n+            trueType = types.getTypeIntersection(lhsTrueType, rhsTrueType, pkgEnv);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzQxMDMyMw=="}, "originalCommit": {"oid": "60633c4b0cba351b0952428c39168a63cc34d2df"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTUxOTI4NA==", "bodyText": "Wouldn't the isAssignable check handle this and more cases here?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r541519284", "createdAt": "2020-12-12T06:58:26Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -381,10 +404,32 @@ private boolean containsAnyType(BType type) {\n         return false;\n     }\n \n+    private boolean containsAnyDataType(BType type) {\n+        if (type.tag != TypeTags.UNION) {\n+            return type.tag == TypeTags.ANYDATA;\n+        }\n+\n+        for (BType memberTypes : ((BUnionType) type).getMemberTypes()) {\n+            if (memberTypes.tag == TypeTags.ANYDATA) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n     public BType mergeTypes(BType typeFirst, BType typeSecond) {\n-        if (containsAnyType(typeFirst)) {\n+        if (containsAnyType(typeFirst) && !containsErrorType(typeSecond)) {\n             return typeSecond;\n         }\n+        if (containsAnyType(typeSecond) && !containsErrorType(typeFirst)) {\n+            return typeFirst;\n+        }\n+        if (containsAnyDataType(typeFirst) && !containsErrorType(typeSecond)) {\n+            return typeSecond;\n+        }\n+        if (containsAnyDataType(typeSecond) && !containsErrorType(typeFirst)) {\n+            return typeFirst;\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1055ec1c66a9e91c8786d22d559dffc403d1011c"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTUxOTYzMg==", "bodyText": "This can be a package-private method.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r541519632", "createdAt": "2020-12-12T07:00:49Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -381,10 +404,32 @@ private boolean containsAnyType(BType type) {\n         return false;\n     }\n \n+    private boolean containsAnyDataType(BType type) {\n+        if (type.tag != TypeTags.UNION) {\n+            return type.tag == TypeTags.ANYDATA;\n+        }\n+\n+        for (BType memberTypes : ((BUnionType) type).getMemberTypes()) {\n+            if (memberTypes.tag == TypeTags.ANYDATA) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n     public BType mergeTypes(BType typeFirst, BType typeSecond) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1055ec1c66a9e91c8786d22d559dffc403d1011c"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTUyMjM4Mg==", "bodyText": "The following results in a bad, sad error here.\npublic function main() {\n    map<int>|map<json> m = {a: \"foo\", b: 2, c: 3};\n\n    match m {\n        {a: 1, ...var x}|{a: \"foo\", ...var x} => {\n\n        }\n    }\n}", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r541522382", "createdAt": "2020-12-12T07:20:42Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java", "diffHunk": "@@ -3203,89 +3227,256 @@ private BLangExpression createConditionForListMemberPattern(int index, BLangMatc\n         return createVarCheckCondition(listMemberMatchPattern, tempVarRef);\n     }\n \n-    private BLangExpression createVarCheckCondition(BLangMatchPattern matchPattern,\n-                                                    BLangSimpleVarRef varRef) {\n+    private BLangExpression createConditionForMappingMatchPattern(BLangMappingMatchPattern mappingMatchPattern,\n+                                                                  BLangSimpleVarRef matchExprVarRef) {\n+        BType matchPatternType = mappingMatchPattern.type;\n+        Location pos = mappingMatchPattern.pos;\n \n-        NodeKind patternKind = matchPattern.getKind();\n-        switch (patternKind) {\n-            case WILDCARD_MATCH_PATTERN:\n-                return createConditionForWildCardMatchPattern((BLangWildCardMatchPattern) matchPattern);\n-            case CONST_MATCH_PATTERN:\n-                return createConditionForConstMatchPattern((BLangConstPattern) matchPattern, varRef);\n-            case VAR_BINDING_PATTERN_MATCH_PATTERN:\n-                return createConditionForVarBindingPatternMatchPattern(\n-                        (BLangVarBindingPatternMatchPattern) matchPattern, varRef);\n-            case LIST_MATCH_PATTERN:\n-                BLangListMatchPattern listMatchPattern = (BLangListMatchPattern) matchPattern;\n-                Location pos = listMatchPattern.pos;\n-                BLangBlockStmt blockStmt = ASTBuilderUtil.createBlockStmt(pos);\n-\n-                BLangSimpleVariableDef resultVarDef = createVarDef(\"$listPatternVarResult$\", symTable.booleanType, null,\n-                        pos);\n-                BLangSimpleVarRef resultVarRef = ASTBuilderUtil.createVariableRef(pos, resultVarDef.var.symbol);\n-                blockStmt.addStatement(resultVarDef);\n-\n-                BLangAssignment failureResult =\n-                        ASTBuilderUtil.createAssignmentStmt(pos, resultVarRef, getBooleanLiteral(false));\n-                BLangAssignment successResult =\n-                        ASTBuilderUtil.createAssignmentStmt(pos, resultVarRef, getBooleanLiteral(true));\n-                blockStmt.addStatement(failureResult);\n-\n-                List<BType> memberTupleTypes = ((BTupleType) varRef.type).getTupleTypes();\n-                List<BLangMatchPattern> matchPatterns = listMatchPattern.matchPatterns;\n-\n-                BLangSimpleVariableDef tempCastVarDef = createVarDef(\"$castTemp$\", varRef.type, varRef, pos);\n-                blockStmt.addStatement(tempCastVarDef);\n-                BLangExpression condition = createConditionForListMemberPattern(0, matchPatterns.get(0),\n-                        tempCastVarDef, blockStmt, memberTupleTypes.get(0), pos);\n-\n-                for (int i = 1; i < matchPatterns.size(); i++) {\n-                    BLangExpression memberPatternCondition = createConditionForListMemberPattern(i,\n-                            matchPatterns.get(i), tempCastVarDef, blockStmt, memberTupleTypes.get(i), pos);\n-\n-                    condition = ASTBuilderUtil.createBinaryExpr(pos, condition, memberPatternCondition,\n-                            symTable.booleanType, OperatorKind.AND, (BOperatorSymbol) symResolver\n-                                    .resolveBinaryOperator(OperatorKind.AND, symTable.booleanType,\n-                                            symTable.booleanType));\n-                }\n+        BLangSimpleVariableDef resultVarDef = createVarDef(\"$mappingPatternResult$\", symTable.booleanType, null, pos);\n+        BLangSimpleVarRef resultVarRef = ASTBuilderUtil.createVariableRef(pos, resultVarDef.var.symbol);\n+        BLangBlockStmt mainBlockStmt = ASTBuilderUtil.createBlockStmt(pos);\n+        mainBlockStmt.addStatement(resultVarDef);\n+\n+        BLangAssignment failureResult =\n+                ASTBuilderUtil.createAssignmentStmt(pos, resultVarRef, getBooleanLiteral(false));\n+        BLangAssignment successResult =\n+                ASTBuilderUtil.createAssignmentStmt(pos, resultVarRef, getBooleanLiteral(true));\n+        mainBlockStmt.addStatement(failureResult);\n \n-                BLangBlockStmt tempBlockStmt = ASTBuilderUtil.createBlockStmt(pos);\n-                tempBlockStmt.addStatement(successResult);\n-                BLangIf ifStmtForMatchPatterns = ASTBuilderUtil.createIfElseStmt(pos, condition, tempBlockStmt, null);\n-                blockStmt.addStatement(ifStmtForMatchPatterns);\n+        BLangExpression typeCheckCondition = createIsLikeExpression(mappingMatchPattern.pos, matchExprVarRef,\n+                matchPatternType);\n+        BLangExpression typeConvertedExpr = addConversionExprIfRequired(matchExprVarRef, matchPatternType);\n+        BLangSimpleVariableDef tempCastVarDef = createVarDef(\"$castTemp$\", matchPatternType, typeConvertedExpr, pos);\n+        BLangSimpleVarRef tempCastVarRef = ASTBuilderUtil.createVariableRef(pos, tempCastVarDef.var.symbol);\n \n-                BLangStatementExpression statementExpression = ASTBuilderUtil.createStatementExpression(blockStmt,\n-                        resultVarRef);\n-                statementExpression.type = symTable.booleanType;\n-                return statementExpression;\n-            default:\n-                // If some patterns are not implemented, those should be detected before this phase\n-                // TODO : Remove this after all patterns are implemented\n-                return null;\n+        BLangBlockStmt ifBlock = ASTBuilderUtil.createBlockStmt(pos);\n+        ifBlock.addStatement(tempCastVarDef);\n+        BLangIf ifStmt = ASTBuilderUtil.createIfElseStmt(pos, typeCheckCondition, ifBlock, null);\n+        mainBlockStmt.addStatement(ifStmt);\n+\n+        BLangExpression condition = createConditionForFieldMatchPatterns(mappingMatchPattern.fieldMatchPatterns,\n+                tempCastVarDef, ifBlock, pos);\n+\n+        BLangBlockStmt tempBlockStmt = ASTBuilderUtil.createBlockStmt(pos);\n+        tempBlockStmt.addStatement(successResult);\n+        if (mappingMatchPattern.restMatchPattern != null) {\n+            BLangRestMatchPattern restMatchPattern = mappingMatchPattern.restMatchPattern;\n+            Location restPatternPos = restMatchPattern.pos;\n+            List<String> keysToRemove = getKeysToRemove(mappingMatchPattern);\n+            BMapType entriesType = new BMapType(TypeTags.MAP, new BTupleType(Arrays.asList(symTable.stringType,\n+                    ((BRecordType) matchPatternType).restFieldType)), null);\n+            BLangInvocation entriesInvocation = generateMapEntriesInvocation(tempCastVarRef, entriesType);\n+            BLangSimpleVariableDef entriesVarDef = createVarDef(\"$entries$\", entriesType, entriesInvocation,\n+                    restPatternPos);\n+            tempBlockStmt.addStatement(entriesVarDef);\n+            BLangLambdaFunction filteringFunction = createFuncToFilterOutRestParam(keysToRemove, restPatternPos);\n+            BLangInvocation filterInvocation = generateMapFilterInvocation(pos, entriesVarDef.var, filteringFunction);\n+            BLangSimpleVariableDef filtersVarDef = createVarDef(\"$filteredVarDef$\", entriesType, filterInvocation,\n+                    restPatternPos);\n+            tempBlockStmt.addStatement(filtersVarDef);\n+            BLangLambdaFunction backToMapLambda = generateEntriesToMapLambda(restPatternPos);\n+            BLangInvocation mapInvocation = generateMapMapInvocation(restPatternPos, filtersVarDef.var,\n+                    backToMapLambda);\n+            BLangSimpleVariable restVar =\n+                    ASTBuilderUtil.createVariable(restPatternPos, restMatchPattern.getIdentifier().getValue(),\n+                            restMatchPattern.symbol.type, mapInvocation, restMatchPattern.symbol);\n+            BLangSimpleVariableDef restVarDef = ASTBuilderUtil.createVariableDef(restPatternPos, restVar);\n+            tempBlockStmt.addStatement(restVarDef);\n+        }\n+        BLangIf ifStmtForMatchPatterns = ASTBuilderUtil.createIfElseStmt(pos, condition, tempBlockStmt, null);\n+        ifBlock.addStatement(ifStmtForMatchPatterns);\n+\n+        BLangStatementExpression statementExpression = ASTBuilderUtil.createStatementExpression(mainBlockStmt,\n+                resultVarRef);\n+        statementExpression.type = symTable.booleanType;\n+\n+        addAsRecordTypeDefinition(matchPatternType, pos);\n+        return statementExpression;\n+    }\n+\n+    private List<String> getKeysToRemove(BLangMappingMatchPattern mappingMatchPattern) {\n+        List<String> allKeys = new ArrayList<>(((BRecordType) mappingMatchPattern.type).fields.keySet());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1055ec1c66a9e91c8786d22d559dffc403d1011c"}, "originalPosition": 176}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTUyMjk2OQ==", "bodyText": "Please recheck the access modifiers for these methods. Seems like they don't have to be public.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r541522969", "createdAt": "2020-12-12T07:24:46Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -368,6 +379,18 @@ public BType resolvePatternTypeFromMatchExpr(BLangExpression matchExpr, BLangExp\n         return symTable.noType;\n     }\n \n+    public BType resolvePatternTypeFromMatchExpr(BLangMappingMatchPattern mappingMatchPattern, BType patternType,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1055ec1c66a9e91c8786d22d559dffc403d1011c"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTUyMzI2MA==", "bodyText": "The comment is no longer relevant?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r541523260", "createdAt": "2020-12-12T07:26:52Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2736,25 +2781,16 @@ BType getTypeForFiniteTypeValuesAssignableToType(BFiniteType finiteType, BType t\n      * @return           a single type or a new union type if at least one member type of the union type is\n      *                      assignable to targetType, else semanticError\n      */\n-    BType getTypeForUnionTypeMembersAssignableToType(BUnionType unionType, BType targetType) {\n+    BType getTypeForUnionTypeMembersAssignableToType(BUnionType unionType, BType targetType, SymbolEnv env) {\n         List<BType> intersection = new LinkedList<>();\n \n         // type FooOne \"foo\"|1;\n         // type FooBar \"foo\"|\"bar\";\n         // unionType - boolean|FooOne, targetType - boolean|FooBar", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1055ec1c66a9e91c8786d22d559dffc403d1011c"}, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTUyMzY3Mg==", "bodyText": "Can you check if we can replace this entire method with a direct call to getTypeIntersection instead?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r541523672", "createdAt": "2020-12-12T07:29:48Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2736,25 +2781,16 @@ BType getTypeForFiniteTypeValuesAssignableToType(BFiniteType finiteType, BType t\n      * @return           a single type or a new union type if at least one member type of the union type is\n      *                      assignable to targetType, else semanticError\n      */\n-    BType getTypeForUnionTypeMembersAssignableToType(BUnionType unionType, BType targetType) {\n+    BType getTypeForUnionTypeMembersAssignableToType(BUnionType unionType, BType targetType, SymbolEnv env) {\n         List<BType> intersection = new LinkedList<>();\n \n         // type FooOne \"foo\"|1;\n         // type FooBar \"foo\"|\"bar\";\n         // unionType - boolean|FooOne, targetType - boolean|FooBar\n         unionType.getMemberTypes().forEach(memType -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1055ec1c66a9e91c8786d22d559dffc403d1011c"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTUyNDM5NQ==", "bodyText": "Given that it's just two case can't we do\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (targetType.tag != TypeTags.MAP && targetType.tag != TypeTags.RECORD) {\n          \n          \n            \n                        return symTable.semanticError;\n          \n          \n            \n                    }\n          \n          \n            \n                    if (targetType.tag == TypeTags.MAP) {\n          \n          \n            \n                        BType intersectionConstraintType = getTypeIntersection(mapType.constraint,\n          \n          \n            \n                                ((BMapType) targetType).constraint, env);\n          \n          \n            \n                        if (intersectionConstraintType == symTable.semanticError) {\n          \n          \n            \n                            return symTable.semanticError;\n          \n          \n            \n                        }\n          \n          \n            \n                        return new BMapType(TypeTags.MAP, intersectionConstraintType, null);\n          \n          \n            \n                    }\n          \n          \n            \n                    return getTypeIntersectedWithRecordType((BRecordType) targetType, mapType, env);\n          \n          \n            \n                    int targetTypeTag = targetType.tag;\n          \n          \n            \n                    \n          \n          \n            \n                    if (targetTypeTag == TypeTags.MAP) {\n          \n          \n            \n                        BType intersectionConstraintType = getTypeIntersection(mapType.constraint,\n          \n          \n            \n                                ((BMapType) targetType).constraint, env);\n          \n          \n            \n                        if (intersectionConstraintType == symTable.semanticError) {\n          \n          \n            \n                            return symTable.semanticError;\n          \n          \n            \n                        }\n          \n          \n            \n                        return new BMapType(TypeTags.MAP, intersectionConstraintType, null);\n          \n          \n            \n                    }\n          \n          \n            \n                    \n          \n          \n            \n                    if (targetTypeTag == TypeTags.RECORD) {\n          \n          \n            \n                        return getTypeIntersectedWithRecordType((BRecordType) targetType, mapType, env);\n          \n          \n            \n                    }\n          \n          \n            \n                    \n          \n          \n            \n                    return symTable.semanticError;", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r541524395", "createdAt": "2020-12-12T07:35:08Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2769,6 +2805,146 @@ BType getTypeForUnionTypeMembersAssignableToType(BUnionType unionType, BType tar\n         }\n     }\n \n+    BType getTypeIntersectedWithMapType(BMapType mapType, BType targetType, SymbolEnv env) {\n+        if (targetType.tag != TypeTags.MAP && targetType.tag != TypeTags.RECORD) {\n+            return symTable.semanticError;\n+        }\n+        if (targetType.tag == TypeTags.MAP) {\n+            BType intersectionConstraintType = getTypeIntersection(mapType.constraint,\n+                    ((BMapType) targetType).constraint, env);\n+            if (intersectionConstraintType == symTable.semanticError) {\n+                return symTable.semanticError;\n+            }\n+            return new BMapType(TypeTags.MAP, intersectionConstraintType, null);\n+        }\n+        return getTypeIntersectedWithRecordType((BRecordType) targetType, mapType, env);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1055ec1c66a9e91c8786d22d559dffc403d1011c"}, "originalPosition": 182}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTUyNDc1Ng==", "bodyText": "Aren't we repeating some checks by doing this? Wouldn't it be better to extract out the map-record intersection logic to a separate method and directly call that here and in getTypeIntersectedWithRecordType?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r541524756", "createdAt": "2020-12-12T07:37:33Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2769,6 +2805,146 @@ BType getTypeForUnionTypeMembersAssignableToType(BUnionType unionType, BType tar\n         }\n     }\n \n+    BType getTypeIntersectedWithMapType(BMapType mapType, BType targetType, SymbolEnv env) {\n+        if (targetType.tag != TypeTags.MAP && targetType.tag != TypeTags.RECORD) {\n+            return symTable.semanticError;\n+        }\n+        if (targetType.tag == TypeTags.MAP) {\n+            BType intersectionConstraintType = getTypeIntersection(mapType.constraint,\n+                    ((BMapType) targetType).constraint, env);\n+            if (intersectionConstraintType == symTable.semanticError) {\n+                return symTable.semanticError;\n+            }\n+            return new BMapType(TypeTags.MAP, intersectionConstraintType, null);\n+        }\n+        return getTypeIntersectedWithRecordType((BRecordType) targetType, mapType, env);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1055ec1c66a9e91c8786d22d559dffc403d1011c"}, "originalPosition": 182}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTUyNTE2Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    } else if (isAssignable(origField.type, overlappingField.type)) {\n          \n          \n            \n                        return origField.type;\n          \n          \n            \n                    } else {\n          \n          \n            \n                        return symTable.semanticError;\n          \n          \n            \n                    }\n          \n          \n            \n                    } \n          \n          \n            \n                    \n          \n          \n            \n                    if (isAssignable(origField.type, overlappingField.type)) {\n          \n          \n            \n                        return origField.type;\n          \n          \n            \n                    }\n          \n          \n            \n                    return symTable.semanticError;", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r541525167", "createdAt": "2020-12-12T07:40:38Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2769,6 +2805,146 @@ BType getTypeForUnionTypeMembersAssignableToType(BUnionType unionType, BType tar\n         }\n     }\n \n+    BType getTypeIntersectedWithMapType(BMapType mapType, BType targetType, SymbolEnv env) {\n+        if (targetType.tag != TypeTags.MAP && targetType.tag != TypeTags.RECORD) {\n+            return symTable.semanticError;\n+        }\n+        if (targetType.tag == TypeTags.MAP) {\n+            BType intersectionConstraintType = getTypeIntersection(mapType.constraint,\n+                    ((BMapType) targetType).constraint, env);\n+            if (intersectionConstraintType == symTable.semanticError) {\n+                return symTable.semanticError;\n+            }\n+            return new BMapType(TypeTags.MAP, intersectionConstraintType, null);\n+        }\n+        return getTypeIntersectedWithRecordType((BRecordType) targetType, mapType, env);\n+    }\n+\n+    BType getTypeIntersectedWithRecordType(BRecordType recordType, BType targetType, SymbolEnv env) {\n+        if (targetType.tag != TypeTags.MAP && targetType.tag != TypeTags.RECORD) {\n+            return symTable.semanticError;\n+        }\n+        if (targetType.tag == TypeTags.MAP) {\n+            BRecordType intersectionRecordType = createAnonymousRecord(env);\n+            LinkedHashMap<String, BField> fields = new LinkedHashMap<>();\n+            for (String key : recordType.fields.keySet()) {\n+                BType intersectionKeyType = getTypeIntersection(recordType.fields.get(key).type,\n+                        ((BMapType) targetType).constraint, env);\n+                if (intersectionKeyType == symTable.semanticError) {\n+                    return symTable.semanticError;\n+                }\n+                BVarSymbol fieldSymbol = new BVarSymbol(0, names.fromString(key), env.enclPkg.symbol.pkgID,\n+                        intersectionKeyType, intersectionRecordType.tsymbol, recordType.fields.get(key).pos,\n+                        COMPILED_SOURCE);\n+                BField field = new BField(names.fromString(key), recordType.fields.get(key).pos, fieldSymbol);\n+                fields.put(key, field);\n+            }\n+            intersectionRecordType.fields = fields;\n+\n+            if (recordType.restFieldType != null) {\n+                BType intersectionRestType = getTypeIntersection(recordType.restFieldType,\n+                        ((BMapType) targetType).constraint, env);\n+                if (intersectionRestType == symTable.semanticError) {\n+                    intersectionRecordType.sealed = true;\n+                }\n+                intersectionRecordType.restFieldType = intersectionRestType;\n+            } else {\n+                intersectionRecordType.sealed = recordType.sealed;\n+            }\n+            return intersectionRecordType;\n+        }\n+        return createRecordIntersection(recordType, targetType, env);\n+    }\n+\n+    private BType createRecordIntersection(BType recordTypeOne, BType recordTypeTwo, SymbolEnv env) {\n+        BRecordType recordType = createAnonymousRecord(env);\n+\n+        if (!populateRecordFields(recordType, recordTypeOne, env) ||\n+                !populateRecordFields(recordType, recordTypeTwo, env)) {\n+            return symTable.semanticError;\n+        }\n+\n+        recordType.restFieldType = getTypeIntersection(((BRecordType) recordTypeOne).restFieldType,\n+                ((BRecordType) recordTypeTwo).restFieldType, env);\n+\n+        if (recordType.restFieldType == symTable.semanticError) {\n+            return symTable.semanticError;\n+        }\n+        return recordType;\n+    }\n+\n+    private boolean populateRecordFields(BRecordType recordType, BType originalType, SymbolEnv env) {\n+        BTypeSymbol intersectionRecordSymbol = recordType.tsymbol;\n+        // If the detail type is BMapType simply ignore since the resulting detail type has `anydata` as rest type.\n+        if (originalType.getKind() != TypeKind.RECORD) {\n+            return true;\n+        }\n+        BRecordType originalRecordType = (BRecordType) originalType;\n+        LinkedHashMap<String, BField> fields = new LinkedHashMap<>();\n+        for (BField origField : originalRecordType.fields.values()) {\n+            org.wso2.ballerinalang.compiler.util.Name origFieldName = origField.name;\n+            String nameString = origFieldName.value;\n+\n+            BType recordFieldType = validateOverlappingFields(recordType, origField);\n+            if (recordFieldType == symTable.semanticError) {\n+                return false;\n+            }\n+\n+            BVarSymbol recordFieldSymbol = new BVarSymbol(origField.symbol.flags, origFieldName,\n+                    env.enclPkg.packageID, recordFieldType,\n+                    intersectionRecordSymbol, origField.pos, SOURCE);\n+            if (recordFieldType.tag == TypeTags.INVOKABLE && recordFieldType.tsymbol != null) {\n+                BInvokableTypeSymbol tsymbol = (BInvokableTypeSymbol) recordFieldType.tsymbol;\n+                BInvokableSymbol invokableSymbol = (BInvokableSymbol) recordFieldSymbol;\n+                invokableSymbol.params = tsymbol.params;\n+                invokableSymbol.restParam = tsymbol.restParam;\n+                invokableSymbol.retType = tsymbol.returnType;\n+                invokableSymbol.flags = tsymbol.flags;\n+            }\n+            fields.put(nameString, new BField(origFieldName, null, recordFieldSymbol));\n+        }\n+        recordType.fields.putAll(fields);\n+        return true;\n+    }\n+\n+    private BType validateOverlappingFields(BRecordType recordType, BField origField) {\n+        BField overlappingField = recordType.fields.get(origField.name.value);\n+        if (overlappingField == null) {\n+            return origField.type;\n+        }\n+\n+        if (isAssignable(overlappingField.type, origField.type)) {\n+            return overlappingField.type;\n+        } else if (isAssignable(origField.type, overlappingField.type)) {\n+            return origField.type;\n+        } else {\n+            return symTable.semanticError;\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1055ec1c66a9e91c8786d22d559dffc403d1011c"}, "originalPosition": 284}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTUyNTUyNA==", "bodyText": "Is setting intersectionRestType correct even if intersectionRestType is symTable.semanticError? Shouln't it be symTable.noType if it is an exclusive record?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r541525524", "createdAt": "2020-12-12T07:43:03Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2769,6 +2805,146 @@ BType getTypeForUnionTypeMembersAssignableToType(BUnionType unionType, BType tar\n         }\n     }\n \n+    BType getTypeIntersectedWithMapType(BMapType mapType, BType targetType, SymbolEnv env) {\n+        if (targetType.tag != TypeTags.MAP && targetType.tag != TypeTags.RECORD) {\n+            return symTable.semanticError;\n+        }\n+        if (targetType.tag == TypeTags.MAP) {\n+            BType intersectionConstraintType = getTypeIntersection(mapType.constraint,\n+                    ((BMapType) targetType).constraint, env);\n+            if (intersectionConstraintType == symTable.semanticError) {\n+                return symTable.semanticError;\n+            }\n+            return new BMapType(TypeTags.MAP, intersectionConstraintType, null);\n+        }\n+        return getTypeIntersectedWithRecordType((BRecordType) targetType, mapType, env);\n+    }\n+\n+    BType getTypeIntersectedWithRecordType(BRecordType recordType, BType targetType, SymbolEnv env) {\n+        if (targetType.tag != TypeTags.MAP && targetType.tag != TypeTags.RECORD) {\n+            return symTable.semanticError;\n+        }\n+        if (targetType.tag == TypeTags.MAP) {\n+            BRecordType intersectionRecordType = createAnonymousRecord(env);\n+            LinkedHashMap<String, BField> fields = new LinkedHashMap<>();\n+            for (String key : recordType.fields.keySet()) {\n+                BType intersectionKeyType = getTypeIntersection(recordType.fields.get(key).type,\n+                        ((BMapType) targetType).constraint, env);\n+                if (intersectionKeyType == symTable.semanticError) {\n+                    return symTable.semanticError;\n+                }\n+                BVarSymbol fieldSymbol = new BVarSymbol(0, names.fromString(key), env.enclPkg.symbol.pkgID,\n+                        intersectionKeyType, intersectionRecordType.tsymbol, recordType.fields.get(key).pos,\n+                        COMPILED_SOURCE);\n+                BField field = new BField(names.fromString(key), recordType.fields.get(key).pos, fieldSymbol);\n+                fields.put(key, field);\n+            }\n+            intersectionRecordType.fields = fields;\n+\n+            if (recordType.restFieldType != null) {\n+                BType intersectionRestType = getTypeIntersection(recordType.restFieldType,\n+                        ((BMapType) targetType).constraint, env);\n+                if (intersectionRestType == symTable.semanticError) {\n+                    intersectionRecordType.sealed = true;\n+                }\n+                intersectionRecordType.restFieldType = intersectionRestType;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1055ec1c66a9e91c8786d22d559dffc403d1011c"}, "originalPosition": 212}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTUyNTg1Mg==", "bodyText": "Seems like getTypeIntersectedWithRecordType is only called from this method. If so we can change the targetType param of getTypeIntersectedWithRecordType to be of a BMapType and remove the tag checks.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r541525852", "createdAt": "2020-12-12T07:45:28Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2769,6 +2805,146 @@ BType getTypeForUnionTypeMembersAssignableToType(BUnionType unionType, BType tar\n         }\n     }\n \n+    BType getTypeIntersectedWithMapType(BMapType mapType, BType targetType, SymbolEnv env) {\n+        if (targetType.tag != TypeTags.MAP && targetType.tag != TypeTags.RECORD) {\n+            return symTable.semanticError;\n+        }\n+        if (targetType.tag == TypeTags.MAP) {\n+            BType intersectionConstraintType = getTypeIntersection(mapType.constraint,\n+                    ((BMapType) targetType).constraint, env);\n+            if (intersectionConstraintType == symTable.semanticError) {\n+                return symTable.semanticError;\n+            }\n+            return new BMapType(TypeTags.MAP, intersectionConstraintType, null);\n+        }\n+        return getTypeIntersectedWithRecordType((BRecordType) targetType, mapType, env);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTUyNDc1Ng=="}, "originalCommit": {"oid": "1055ec1c66a9e91c8786d22d559dffc403d1011c"}, "originalPosition": 182}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTUyNjg1MA==", "bodyText": "AFAIK restFieldType is never null in a BRecordType. If it is an exclusive record, the restType will be symTable.noType. We may have to change this check.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r541526850", "createdAt": "2020-12-12T07:52:25Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2769,6 +2805,146 @@ BType getTypeForUnionTypeMembersAssignableToType(BUnionType unionType, BType tar\n         }\n     }\n \n+    BType getTypeIntersectedWithMapType(BMapType mapType, BType targetType, SymbolEnv env) {\n+        if (targetType.tag != TypeTags.MAP && targetType.tag != TypeTags.RECORD) {\n+            return symTable.semanticError;\n+        }\n+        if (targetType.tag == TypeTags.MAP) {\n+            BType intersectionConstraintType = getTypeIntersection(mapType.constraint,\n+                    ((BMapType) targetType).constraint, env);\n+            if (intersectionConstraintType == symTable.semanticError) {\n+                return symTable.semanticError;\n+            }\n+            return new BMapType(TypeTags.MAP, intersectionConstraintType, null);\n+        }\n+        return getTypeIntersectedWithRecordType((BRecordType) targetType, mapType, env);\n+    }\n+\n+    BType getTypeIntersectedWithRecordType(BRecordType recordType, BType targetType, SymbolEnv env) {\n+        if (targetType.tag != TypeTags.MAP && targetType.tag != TypeTags.RECORD) {\n+            return symTable.semanticError;\n+        }\n+        if (targetType.tag == TypeTags.MAP) {\n+            BRecordType intersectionRecordType = createAnonymousRecord(env);\n+            LinkedHashMap<String, BField> fields = new LinkedHashMap<>();\n+            for (String key : recordType.fields.keySet()) {\n+                BType intersectionKeyType = getTypeIntersection(recordType.fields.get(key).type,\n+                        ((BMapType) targetType).constraint, env);\n+                if (intersectionKeyType == symTable.semanticError) {\n+                    return symTable.semanticError;\n+                }\n+                BVarSymbol fieldSymbol = new BVarSymbol(0, names.fromString(key), env.enclPkg.symbol.pkgID,\n+                        intersectionKeyType, intersectionRecordType.tsymbol, recordType.fields.get(key).pos,\n+                        COMPILED_SOURCE);\n+                BField field = new BField(names.fromString(key), recordType.fields.get(key).pos, fieldSymbol);\n+                fields.put(key, field);\n+            }\n+            intersectionRecordType.fields = fields;\n+\n+            if (recordType.restFieldType != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1055ec1c66a9e91c8786d22d559dffc403d1011c"}, "originalPosition": 206}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTUyNzIwOQ==", "bodyText": "Shouldn't we check if the field is optional here?\nFor example, map<json> and record {|int i; stream<int> j?;|} has an intersection, right?\nrecord {|int i;|}", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r541527209", "createdAt": "2020-12-12T07:55:03Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2769,6 +2805,146 @@ BType getTypeForUnionTypeMembersAssignableToType(BUnionType unionType, BType tar\n         }\n     }\n \n+    BType getTypeIntersectedWithMapType(BMapType mapType, BType targetType, SymbolEnv env) {\n+        if (targetType.tag != TypeTags.MAP && targetType.tag != TypeTags.RECORD) {\n+            return symTable.semanticError;\n+        }\n+        if (targetType.tag == TypeTags.MAP) {\n+            BType intersectionConstraintType = getTypeIntersection(mapType.constraint,\n+                    ((BMapType) targetType).constraint, env);\n+            if (intersectionConstraintType == symTable.semanticError) {\n+                return symTable.semanticError;\n+            }\n+            return new BMapType(TypeTags.MAP, intersectionConstraintType, null);\n+        }\n+        return getTypeIntersectedWithRecordType((BRecordType) targetType, mapType, env);\n+    }\n+\n+    BType getTypeIntersectedWithRecordType(BRecordType recordType, BType targetType, SymbolEnv env) {\n+        if (targetType.tag != TypeTags.MAP && targetType.tag != TypeTags.RECORD) {\n+            return symTable.semanticError;\n+        }\n+        if (targetType.tag == TypeTags.MAP) {\n+            BRecordType intersectionRecordType = createAnonymousRecord(env);\n+            LinkedHashMap<String, BField> fields = new LinkedHashMap<>();\n+            for (String key : recordType.fields.keySet()) {\n+                BType intersectionKeyType = getTypeIntersection(recordType.fields.get(key).type,\n+                        ((BMapType) targetType).constraint, env);\n+                if (intersectionKeyType == symTable.semanticError) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1055ec1c66a9e91c8786d22d559dffc403d1011c"}, "originalPosition": 195}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1055ec1c66a9e91c8786d22d559dffc403d1011c", "author": {"user": {"login": "KavinduZoysa", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1055ec1c66a9e91c8786d22d559dffc403d1011c", "committedDate": "2020-11-23T06:32:48Z", "message": "Rebase with master"}, "afterCommit": {"oid": "575ec7b55a3c6d28c8dbb0c5c378989a08a8c3cc", "author": {"user": {"login": "KavinduZoysa", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/575ec7b55a3c6d28c8dbb0c5c378989a08a8c3cc", "committedDate": "2020-12-17T10:12:18Z", "message": "Fix sugestions"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "575ec7b55a3c6d28c8dbb0c5c378989a08a8c3cc", "author": {"user": {"login": "KavinduZoysa", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/575ec7b55a3c6d28c8dbb0c5c378989a08a8c3cc", "committedDate": "2020-12-17T10:12:18Z", "message": "Fix sugestions"}, "afterCommit": {"oid": "f6b3cd10f2ec69868abea4b2daee20526352400c", "author": {"user": {"login": "KavinduZoysa", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f6b3cd10f2ec69868abea4b2daee20526352400c", "committedDate": "2020-12-17T17:21:48Z", "message": "Fix sugestions"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f6b3cd10f2ec69868abea4b2daee20526352400c", "author": {"user": {"login": "KavinduZoysa", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f6b3cd10f2ec69868abea4b2daee20526352400c", "committedDate": "2020-12-17T17:21:48Z", "message": "Fix sugestions"}, "afterCommit": {"oid": "827faf60c52de396ec39662b767279e3460ded62", "author": {"user": {"login": "KavinduZoysa", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/827faf60c52de396ec39662b767279e3460ded62", "committedDate": "2021-01-04T04:34:11Z", "message": "Fix sugestions"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "827faf60c52de396ec39662b767279e3460ded62", "author": {"user": {"login": "KavinduZoysa", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/827faf60c52de396ec39662b767279e3460ded62", "committedDate": "2021-01-04T04:34:11Z", "message": "Fix sugestions"}, "afterCommit": {"oid": "b3f60111f23c01a3f321cace2b0311cce9c4de46", "author": {"user": {"login": "KavinduZoysa", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b3f60111f23c01a3f321cace2b0311cce9c4de46", "committedDate": "2021-01-12T07:43:03Z", "message": "Sync with master"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b3f60111f23c01a3f321cace2b0311cce9c4de46", "author": {"user": {"login": "KavinduZoysa", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b3f60111f23c01a3f321cace2b0311cce9c4de46", "committedDate": "2021-01-12T07:43:03Z", "message": "Sync with master"}, "afterCommit": {"oid": "a795ecd1ecb76c24c1d87a0e00b7ecd1849f0ef4", "author": {"user": {"login": "KavinduZoysa", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a795ecd1ecb76c24c1d87a0e00b7ecd1849f0ef4", "committedDate": "2021-01-12T10:57:59Z", "message": "Sync with master"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY2ODg2NDEy", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#pullrequestreview-566886412", "createdAt": "2021-01-13T04:33:22Z", "commit": {"oid": "a795ecd1ecb76c24c1d87a0e00b7ecd1849f0ef4"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QwNDozMzoyMlrOISfMKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QwNTowMjoxOFrOISfpbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjI1NjI5OA==", "bodyText": "There's quite a bit of repeated code between this and createVarCheckConditionForListMatchPattern, right? Shall we check if we can refactor these methods to avoid repetition?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r556256298", "createdAt": "2021-01-13T04:33:22Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java", "diffHunk": "@@ -3463,89 +3487,252 @@ private BLangExpression createConditionForListMemberPattern(int index, BLangMatc\n         return createVarCheckCondition(listMemberMatchPattern, tempVarRef);\n     }\n \n-    private BLangExpression createVarCheckCondition(BLangMatchPattern matchPattern,\n-                                                    BLangSimpleVarRef varRef) {\n+    private BLangExpression createConditionForMappingMatchPattern(BLangMappingMatchPattern mappingMatchPattern,\n+                                                                  BLangSimpleVarRef matchExprVarRef) {\n+        BType matchPatternType = mappingMatchPattern.type;\n+        Location pos = mappingMatchPattern.pos;\n \n-        NodeKind patternKind = matchPattern.getKind();\n-        switch (patternKind) {\n-            case WILDCARD_MATCH_PATTERN:\n-                return createConditionForWildCardMatchPattern((BLangWildCardMatchPattern) matchPattern);\n-            case CONST_MATCH_PATTERN:\n-                return createConditionForConstMatchPattern((BLangConstPattern) matchPattern, varRef);\n-            case VAR_BINDING_PATTERN_MATCH_PATTERN:\n-                return createConditionForVarBindingPatternMatchPattern(\n-                        (BLangVarBindingPatternMatchPattern) matchPattern, varRef);\n-            case LIST_MATCH_PATTERN:\n-                BLangListMatchPattern listMatchPattern = (BLangListMatchPattern) matchPattern;\n-                Location pos = listMatchPattern.pos;\n-                BLangBlockStmt blockStmt = ASTBuilderUtil.createBlockStmt(pos);\n-\n-                BLangSimpleVariableDef resultVarDef = createVarDef(\"$listPatternVarResult$\", symTable.booleanType, null,\n-                        pos);\n-                BLangSimpleVarRef resultVarRef = ASTBuilderUtil.createVariableRef(pos, resultVarDef.var.symbol);\n-                blockStmt.addStatement(resultVarDef);\n-\n-                BLangAssignment failureResult =\n-                        ASTBuilderUtil.createAssignmentStmt(pos, resultVarRef, getBooleanLiteral(false));\n-                BLangAssignment successResult =\n-                        ASTBuilderUtil.createAssignmentStmt(pos, resultVarRef, getBooleanLiteral(true));\n-                blockStmt.addStatement(failureResult);\n-\n-                List<BType> memberTupleTypes = ((BTupleType) varRef.type).getTupleTypes();\n-                List<BLangMatchPattern> matchPatterns = listMatchPattern.matchPatterns;\n-\n-                BLangSimpleVariableDef tempCastVarDef = createVarDef(\"$castTemp$\", varRef.type, varRef, pos);\n-                blockStmt.addStatement(tempCastVarDef);\n-                BLangExpression condition = createConditionForListMemberPattern(0, matchPatterns.get(0),\n-                        tempCastVarDef, blockStmt, memberTupleTypes.get(0), pos);\n-\n-                for (int i = 1; i < matchPatterns.size(); i++) {\n-                    BLangExpression memberPatternCondition = createConditionForListMemberPattern(i,\n-                            matchPatterns.get(i), tempCastVarDef, blockStmt, memberTupleTypes.get(i), pos);\n-\n-                    condition = ASTBuilderUtil.createBinaryExpr(pos, condition, memberPatternCondition,\n-                            symTable.booleanType, OperatorKind.AND, (BOperatorSymbol) symResolver\n-                                    .resolveBinaryOperator(OperatorKind.AND, symTable.booleanType,\n-                                            symTable.booleanType));\n-                }\n+        BLangSimpleVariableDef resultVarDef = createVarDef(\"$mappingPatternResult$\", symTable.booleanType, null, pos);\n+        BLangSimpleVarRef resultVarRef = ASTBuilderUtil.createVariableRef(pos, resultVarDef.var.symbol);\n+        BLangBlockStmt mainBlockStmt = ASTBuilderUtil.createBlockStmt(pos);\n+        mainBlockStmt.addStatement(resultVarDef);\n+\n+        BLangAssignment failureResult =\n+                ASTBuilderUtil.createAssignmentStmt(pos, resultVarRef, getBooleanLiteral(false));\n+        BLangAssignment successResult =\n+                ASTBuilderUtil.createAssignmentStmt(pos, resultVarRef, getBooleanLiteral(true));\n+        mainBlockStmt.addStatement(failureResult);\n \n-                BLangBlockStmt tempBlockStmt = ASTBuilderUtil.createBlockStmt(pos);\n-                tempBlockStmt.addStatement(successResult);\n-                BLangIf ifStmtForMatchPatterns = ASTBuilderUtil.createIfElseStmt(pos, condition, tempBlockStmt, null);\n-                blockStmt.addStatement(ifStmtForMatchPatterns);\n+        BLangExpression typeCheckCondition = createIsLikeExpression(mappingMatchPattern.pos, matchExprVarRef,\n+                matchPatternType);\n+        BLangExpression typeConvertedExpr = addConversionExprIfRequired(matchExprVarRef, matchPatternType);\n+        BLangSimpleVariableDef tempCastVarDef = createVarDef(\"$castTemp$\", matchPatternType, typeConvertedExpr, pos);\n+        BLangSimpleVarRef tempCastVarRef = ASTBuilderUtil.createVariableRef(pos, tempCastVarDef.var.symbol);\n \n-                BLangStatementExpression statementExpression = ASTBuilderUtil.createStatementExpression(blockStmt,\n-                        resultVarRef);\n-                statementExpression.type = symTable.booleanType;\n-                return statementExpression;\n-            default:\n-                // If some patterns are not implemented, those should be detected before this phase\n-                // TODO : Remove this after all patterns are implemented\n-                return null;\n+        BLangBlockStmt ifBlock = ASTBuilderUtil.createBlockStmt(pos);\n+        ifBlock.addStatement(tempCastVarDef);\n+        BLangIf ifStmt = ASTBuilderUtil.createIfElseStmt(pos, typeCheckCondition, ifBlock, null);\n+        mainBlockStmt.addStatement(ifStmt);\n+\n+        BLangExpression condition = createConditionForFieldMatchPatterns(mappingMatchPattern.fieldMatchPatterns,\n+                tempCastVarDef, ifBlock, pos);\n+\n+        BLangBlockStmt tempBlockStmt = ASTBuilderUtil.createBlockStmt(pos);\n+        tempBlockStmt.addStatement(successResult);\n+        if (mappingMatchPattern.restMatchPattern != null) {\n+            BLangRestMatchPattern restMatchPattern = mappingMatchPattern.restMatchPattern;\n+            Location restPatternPos = restMatchPattern.pos;\n+            List<String> keysToRemove = getKeysToRemove(mappingMatchPattern);\n+            BMapType entriesType = new BMapType(TypeTags.MAP, new BTupleType(Arrays.asList(symTable.stringType,\n+                    ((BMapType) mappingMatchPattern.restMatchPattern.type).constraint)), null);\n+            BLangInvocation entriesInvocation = generateMapEntriesInvocation(tempCastVarRef, entriesType);\n+            BLangSimpleVariableDef entriesVarDef = createVarDef(\"$entries$\", entriesType, entriesInvocation,\n+                    restPatternPos);\n+            tempBlockStmt.addStatement(entriesVarDef);\n+            BLangLambdaFunction filteringFunction = createFuncToFilterOutRestParam(keysToRemove, restPatternPos);\n+            BLangInvocation filterInvocation = generateMapFilterInvocation(pos, entriesVarDef.var, filteringFunction);\n+            BLangSimpleVariableDef filtersVarDef = createVarDef(\"$filteredVarDef$\", entriesType, filterInvocation,\n+                    restPatternPos);\n+            tempBlockStmt.addStatement(filtersVarDef);\n+            BLangLambdaFunction backToMapLambda = generateEntriesToMapLambda(restPatternPos);\n+            BLangInvocation mapInvocation = generateMapMapInvocation(restPatternPos, filtersVarDef.var,\n+                    backToMapLambda);\n+            BLangSimpleVarRef restMatchPatternVarRef = declaredVarDef.get(restMatchPattern.getIdentifier().getValue());\n+            tempBlockStmt.addStatement(ASTBuilderUtil.createAssignmentStmt(pos, restMatchPatternVarRef, mapInvocation));\n+        }\n+        BLangIf ifStmtForMatchPatterns = ASTBuilderUtil.createIfElseStmt(pos, condition, tempBlockStmt, null);\n+        ifBlock.addStatement(ifStmtForMatchPatterns);\n+\n+        BLangStatementExpression statementExpression = ASTBuilderUtil.createStatementExpression(mainBlockStmt,\n+                resultVarRef);\n+        statementExpression.type = symTable.booleanType;\n+\n+        addAsRecordTypeDefinition(matchPatternType, pos);\n+        return statementExpression;\n+    }\n+\n+    private List<String> getKeysToRemove(BLangMappingMatchPattern mappingMatchPattern) {\n+        List<String> keysToRemove = new ArrayList<>();\n+        for (BLangFieldMatchPattern fieldMatchPattern : mappingMatchPattern.fieldMatchPatterns) {\n+            keysToRemove.add(fieldMatchPattern.fieldName.value);\n         }\n+        return keysToRemove;\n     }\n \n-    private BLangExpression createConditionForMatchPattern(BLangMatchPattern matchPattern,\n-                                                           BLangSimpleVarRef matchExprVarRef) {\n+    private BLangExpression createConditionForFieldMatchPatterns(List<BLangFieldMatchPattern> fieldMatchPatterns,\n+                                                                 BLangSimpleVariableDef varDef,\n+                                                                 BLangBlockStmt blockStmt,\n+                                                                 Location pos) {\n+        BLangExpression condition = ASTBuilderUtil.createLiteral(pos, symTable.booleanType, true);\n+        for (int i = 0; i < fieldMatchPatterns.size(); i++) {\n+            BLangExpression fieldMatchPatternCondition =\n+                    createConditionForFieldMatchPattern(i, fieldMatchPatterns.get(i), varDef, blockStmt);\n+            condition = ASTBuilderUtil.createBinaryExpr(pos, condition, fieldMatchPatternCondition,\n+                    symTable.booleanType, OperatorKind.AND, (BOperatorSymbol) symResolver\n+                            .resolveBinaryOperator(OperatorKind.AND, symTable.booleanType, symTable.booleanType));\n+        }\n+        return condition;\n+    }\n+\n+    private BLangExpression createConditionForFieldMatchPattern(int index, BLangFieldMatchPattern fieldMatchPattern,\n+                                                                BLangSimpleVariableDef tempCastVarDef,\n+                                                                BLangBlockStmt blockStmt) {\n+        String fieldName = fieldMatchPattern.fieldName.value;\n+        BLangMatchPattern matchPattern = fieldMatchPattern.matchPattern;\n+        BLangFieldBasedAccess fieldBasedAccessExpr = getFieldAccessExpression(fieldMatchPattern.pos, fieldName,\n+                matchPattern.type, tempCastVarDef.var.symbol);\n+        BLangSimpleVariableDef tempVarDef = createVarDef(\"$memberVarTemp$\" + index + \"_$\", matchPattern.type,\n+                fieldBasedAccessExpr, matchPattern.pos);\n+        BLangSimpleVarRef tempVarRef = ASTBuilderUtil.createVariableRef(matchPattern.pos, tempVarDef.var.symbol);\n+        blockStmt.addStatement(tempVarDef);\n+        return createVarCheckCondition(matchPattern, tempVarRef);\n+    }\n+\n+    private BLangExpression createVarCheckCondition(BLangMatchPattern matchPattern, BLangSimpleVarRef varRef) {\n \n         NodeKind patternKind = matchPattern.getKind();\n         switch (patternKind) {\n             case WILDCARD_MATCH_PATTERN:\n                 return createConditionForWildCardMatchPattern((BLangWildCardMatchPattern) matchPattern);\n             case CONST_MATCH_PATTERN:\n-                return createConditionForConstMatchPattern((BLangConstPattern) matchPattern, matchExprVarRef);\n+                return createConditionForConstMatchPattern((BLangConstPattern) matchPattern, varRef);\n             case VAR_BINDING_PATTERN_MATCH_PATTERN:\n                 return createConditionForVarBindingPatternMatchPattern(\n-                        (BLangVarBindingPatternMatchPattern) matchPattern, matchExprVarRef);\n+                        (BLangVarBindingPatternMatchPattern) matchPattern, varRef);\n             case LIST_MATCH_PATTERN:\n-                return createConditionForListMatchPattern((BLangListMatchPattern) matchPattern, matchExprVarRef);\n+                return createVarCheckConditionForListMatchPattern((BLangListMatchPattern) matchPattern, varRef);\n+            case MAPPING_MATCH_PATTERN:\n+                return createVarCheckConditionForMappingMatchPattern((BLangMappingMatchPattern) matchPattern, varRef);\n             default:\n                 // If some patterns are not implemented, those should be detected before this phase\n                 // TODO : Remove this after all patterns are implemented\n                 return null;\n         }\n     }\n \n+    private BLangExpression createVarCheckConditionForListMatchPattern(BLangListMatchPattern listMatchPattern,\n+                                                                       BLangSimpleVarRef varRef) {\n+        Location pos = listMatchPattern.pos;\n+        BLangBlockStmt blockStmt = ASTBuilderUtil.createBlockStmt(pos);\n+\n+        BLangSimpleVariableDef resultVarDef = createVarDef(\"$listPatternVarResult$\", symTable.booleanType, null,\n+                pos);\n+        BLangSimpleVarRef resultVarRef = ASTBuilderUtil.createVariableRef(pos, resultVarDef.var.symbol);\n+        blockStmt.addStatement(resultVarDef);\n+\n+        BLangAssignment failureResult =\n+                ASTBuilderUtil.createAssignmentStmt(pos, resultVarRef, getBooleanLiteral(false));\n+        BLangAssignment successResult =\n+                ASTBuilderUtil.createAssignmentStmt(pos, resultVarRef, getBooleanLiteral(true));\n+        blockStmt.addStatement(failureResult);\n+\n+        List<BType> memberTupleTypes = ((BTupleType) varRef.type).getTupleTypes();\n+        List<BLangMatchPattern> matchPatterns = listMatchPattern.matchPatterns;\n+\n+        BLangSimpleVariableDef tempCastVarDef = createVarDef(\"$castTemp$\", varRef.type, varRef, pos);\n+        blockStmt.addStatement(tempCastVarDef);\n+        BLangExpression condition = createConditionForListMemberPattern(0, matchPatterns.get(0),\n+                tempCastVarDef, blockStmt, memberTupleTypes.get(0), pos);\n+\n+        for (int i = 1; i < matchPatterns.size(); i++) {\n+            BLangExpression memberPatternCondition = createConditionForListMemberPattern(i,\n+                    matchPatterns.get(i), tempCastVarDef, blockStmt, memberTupleTypes.get(i), pos);\n+\n+            condition = ASTBuilderUtil.createBinaryExpr(pos, condition, memberPatternCondition,\n+                    symTable.booleanType, OperatorKind.AND, (BOperatorSymbol) symResolver\n+                            .resolveBinaryOperator(OperatorKind.AND, symTable.booleanType,\n+                                    symTable.booleanType));\n+        }\n+\n+        BLangBlockStmt tempBlockStmt = ASTBuilderUtil.createBlockStmt(pos);\n+        tempBlockStmt.addStatement(successResult);\n+        BLangIf ifStmtForMatchPatterns = ASTBuilderUtil.createIfElseStmt(pos, condition, tempBlockStmt, null);\n+        blockStmt.addStatement(ifStmtForMatchPatterns);\n+\n+        BLangStatementExpression statementExpression = ASTBuilderUtil.createStatementExpression(blockStmt,\n+                resultVarRef);\n+        statementExpression.type = symTable.booleanType;\n+        return statementExpression;\n+    }\n+\n+    private BLangExpression createVarCheckConditionForMappingMatchPattern(BLangMappingMatchPattern mappingMatchPattern,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a795ecd1ecb76c24c1d87a0e00b7ecd1849f0ef4"}, "originalPosition": 281}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjI1NjgyOA==", "bodyText": "Can't we return here? Or we have to unnecessarily check the tag in L3701 and return?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r556256828", "createdAt": "2021-01-13T04:35:31Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java", "diffHunk": "@@ -3463,89 +3487,252 @@ private BLangExpression createConditionForListMemberPattern(int index, BLangMatc\n         return createVarCheckCondition(listMemberMatchPattern, tempVarRef);\n     }\n \n-    private BLangExpression createVarCheckCondition(BLangMatchPattern matchPattern,\n-                                                    BLangSimpleVarRef varRef) {\n+    private BLangExpression createConditionForMappingMatchPattern(BLangMappingMatchPattern mappingMatchPattern,\n+                                                                  BLangSimpleVarRef matchExprVarRef) {\n+        BType matchPatternType = mappingMatchPattern.type;\n+        Location pos = mappingMatchPattern.pos;\n \n-        NodeKind patternKind = matchPattern.getKind();\n-        switch (patternKind) {\n-            case WILDCARD_MATCH_PATTERN:\n-                return createConditionForWildCardMatchPattern((BLangWildCardMatchPattern) matchPattern);\n-            case CONST_MATCH_PATTERN:\n-                return createConditionForConstMatchPattern((BLangConstPattern) matchPattern, varRef);\n-            case VAR_BINDING_PATTERN_MATCH_PATTERN:\n-                return createConditionForVarBindingPatternMatchPattern(\n-                        (BLangVarBindingPatternMatchPattern) matchPattern, varRef);\n-            case LIST_MATCH_PATTERN:\n-                BLangListMatchPattern listMatchPattern = (BLangListMatchPattern) matchPattern;\n-                Location pos = listMatchPattern.pos;\n-                BLangBlockStmt blockStmt = ASTBuilderUtil.createBlockStmt(pos);\n-\n-                BLangSimpleVariableDef resultVarDef = createVarDef(\"$listPatternVarResult$\", symTable.booleanType, null,\n-                        pos);\n-                BLangSimpleVarRef resultVarRef = ASTBuilderUtil.createVariableRef(pos, resultVarDef.var.symbol);\n-                blockStmt.addStatement(resultVarDef);\n-\n-                BLangAssignment failureResult =\n-                        ASTBuilderUtil.createAssignmentStmt(pos, resultVarRef, getBooleanLiteral(false));\n-                BLangAssignment successResult =\n-                        ASTBuilderUtil.createAssignmentStmt(pos, resultVarRef, getBooleanLiteral(true));\n-                blockStmt.addStatement(failureResult);\n-\n-                List<BType> memberTupleTypes = ((BTupleType) varRef.type).getTupleTypes();\n-                List<BLangMatchPattern> matchPatterns = listMatchPattern.matchPatterns;\n-\n-                BLangSimpleVariableDef tempCastVarDef = createVarDef(\"$castTemp$\", varRef.type, varRef, pos);\n-                blockStmt.addStatement(tempCastVarDef);\n-                BLangExpression condition = createConditionForListMemberPattern(0, matchPatterns.get(0),\n-                        tempCastVarDef, blockStmt, memberTupleTypes.get(0), pos);\n-\n-                for (int i = 1; i < matchPatterns.size(); i++) {\n-                    BLangExpression memberPatternCondition = createConditionForListMemberPattern(i,\n-                            matchPatterns.get(i), tempCastVarDef, blockStmt, memberTupleTypes.get(i), pos);\n-\n-                    condition = ASTBuilderUtil.createBinaryExpr(pos, condition, memberPatternCondition,\n-                            symTable.booleanType, OperatorKind.AND, (BOperatorSymbol) symResolver\n-                                    .resolveBinaryOperator(OperatorKind.AND, symTable.booleanType,\n-                                            symTable.booleanType));\n-                }\n+        BLangSimpleVariableDef resultVarDef = createVarDef(\"$mappingPatternResult$\", symTable.booleanType, null, pos);\n+        BLangSimpleVarRef resultVarRef = ASTBuilderUtil.createVariableRef(pos, resultVarDef.var.symbol);\n+        BLangBlockStmt mainBlockStmt = ASTBuilderUtil.createBlockStmt(pos);\n+        mainBlockStmt.addStatement(resultVarDef);\n+\n+        BLangAssignment failureResult =\n+                ASTBuilderUtil.createAssignmentStmt(pos, resultVarRef, getBooleanLiteral(false));\n+        BLangAssignment successResult =\n+                ASTBuilderUtil.createAssignmentStmt(pos, resultVarRef, getBooleanLiteral(true));\n+        mainBlockStmt.addStatement(failureResult);\n \n-                BLangBlockStmt tempBlockStmt = ASTBuilderUtil.createBlockStmt(pos);\n-                tempBlockStmt.addStatement(successResult);\n-                BLangIf ifStmtForMatchPatterns = ASTBuilderUtil.createIfElseStmt(pos, condition, tempBlockStmt, null);\n-                blockStmt.addStatement(ifStmtForMatchPatterns);\n+        BLangExpression typeCheckCondition = createIsLikeExpression(mappingMatchPattern.pos, matchExprVarRef,\n+                matchPatternType);\n+        BLangExpression typeConvertedExpr = addConversionExprIfRequired(matchExprVarRef, matchPatternType);\n+        BLangSimpleVariableDef tempCastVarDef = createVarDef(\"$castTemp$\", matchPatternType, typeConvertedExpr, pos);\n+        BLangSimpleVarRef tempCastVarRef = ASTBuilderUtil.createVariableRef(pos, tempCastVarDef.var.symbol);\n \n-                BLangStatementExpression statementExpression = ASTBuilderUtil.createStatementExpression(blockStmt,\n-                        resultVarRef);\n-                statementExpression.type = symTable.booleanType;\n-                return statementExpression;\n-            default:\n-                // If some patterns are not implemented, those should be detected before this phase\n-                // TODO : Remove this after all patterns are implemented\n-                return null;\n+        BLangBlockStmt ifBlock = ASTBuilderUtil.createBlockStmt(pos);\n+        ifBlock.addStatement(tempCastVarDef);\n+        BLangIf ifStmt = ASTBuilderUtil.createIfElseStmt(pos, typeCheckCondition, ifBlock, null);\n+        mainBlockStmt.addStatement(ifStmt);\n+\n+        BLangExpression condition = createConditionForFieldMatchPatterns(mappingMatchPattern.fieldMatchPatterns,\n+                tempCastVarDef, ifBlock, pos);\n+\n+        BLangBlockStmt tempBlockStmt = ASTBuilderUtil.createBlockStmt(pos);\n+        tempBlockStmt.addStatement(successResult);\n+        if (mappingMatchPattern.restMatchPattern != null) {\n+            BLangRestMatchPattern restMatchPattern = mappingMatchPattern.restMatchPattern;\n+            Location restPatternPos = restMatchPattern.pos;\n+            List<String> keysToRemove = getKeysToRemove(mappingMatchPattern);\n+            BMapType entriesType = new BMapType(TypeTags.MAP, new BTupleType(Arrays.asList(symTable.stringType,\n+                    ((BMapType) mappingMatchPattern.restMatchPattern.type).constraint)), null);\n+            BLangInvocation entriesInvocation = generateMapEntriesInvocation(tempCastVarRef, entriesType);\n+            BLangSimpleVariableDef entriesVarDef = createVarDef(\"$entries$\", entriesType, entriesInvocation,\n+                    restPatternPos);\n+            tempBlockStmt.addStatement(entriesVarDef);\n+            BLangLambdaFunction filteringFunction = createFuncToFilterOutRestParam(keysToRemove, restPatternPos);\n+            BLangInvocation filterInvocation = generateMapFilterInvocation(pos, entriesVarDef.var, filteringFunction);\n+            BLangSimpleVariableDef filtersVarDef = createVarDef(\"$filteredVarDef$\", entriesType, filterInvocation,\n+                    restPatternPos);\n+            tempBlockStmt.addStatement(filtersVarDef);\n+            BLangLambdaFunction backToMapLambda = generateEntriesToMapLambda(restPatternPos);\n+            BLangInvocation mapInvocation = generateMapMapInvocation(restPatternPos, filtersVarDef.var,\n+                    backToMapLambda);\n+            BLangSimpleVarRef restMatchPatternVarRef = declaredVarDef.get(restMatchPattern.getIdentifier().getValue());\n+            tempBlockStmt.addStatement(ASTBuilderUtil.createAssignmentStmt(pos, restMatchPatternVarRef, mapInvocation));\n+        }\n+        BLangIf ifStmtForMatchPatterns = ASTBuilderUtil.createIfElseStmt(pos, condition, tempBlockStmt, null);\n+        ifBlock.addStatement(ifStmtForMatchPatterns);\n+\n+        BLangStatementExpression statementExpression = ASTBuilderUtil.createStatementExpression(mainBlockStmt,\n+                resultVarRef);\n+        statementExpression.type = symTable.booleanType;\n+\n+        addAsRecordTypeDefinition(matchPatternType, pos);\n+        return statementExpression;\n+    }\n+\n+    private List<String> getKeysToRemove(BLangMappingMatchPattern mappingMatchPattern) {\n+        List<String> keysToRemove = new ArrayList<>();\n+        for (BLangFieldMatchPattern fieldMatchPattern : mappingMatchPattern.fieldMatchPatterns) {\n+            keysToRemove.add(fieldMatchPattern.fieldName.value);\n         }\n+        return keysToRemove;\n     }\n \n-    private BLangExpression createConditionForMatchPattern(BLangMatchPattern matchPattern,\n-                                                           BLangSimpleVarRef matchExprVarRef) {\n+    private BLangExpression createConditionForFieldMatchPatterns(List<BLangFieldMatchPattern> fieldMatchPatterns,\n+                                                                 BLangSimpleVariableDef varDef,\n+                                                                 BLangBlockStmt blockStmt,\n+                                                                 Location pos) {\n+        BLangExpression condition = ASTBuilderUtil.createLiteral(pos, symTable.booleanType, true);\n+        for (int i = 0; i < fieldMatchPatterns.size(); i++) {\n+            BLangExpression fieldMatchPatternCondition =\n+                    createConditionForFieldMatchPattern(i, fieldMatchPatterns.get(i), varDef, blockStmt);\n+            condition = ASTBuilderUtil.createBinaryExpr(pos, condition, fieldMatchPatternCondition,\n+                    symTable.booleanType, OperatorKind.AND, (BOperatorSymbol) symResolver\n+                            .resolveBinaryOperator(OperatorKind.AND, symTable.booleanType, symTable.booleanType));\n+        }\n+        return condition;\n+    }\n+\n+    private BLangExpression createConditionForFieldMatchPattern(int index, BLangFieldMatchPattern fieldMatchPattern,\n+                                                                BLangSimpleVariableDef tempCastVarDef,\n+                                                                BLangBlockStmt blockStmt) {\n+        String fieldName = fieldMatchPattern.fieldName.value;\n+        BLangMatchPattern matchPattern = fieldMatchPattern.matchPattern;\n+        BLangFieldBasedAccess fieldBasedAccessExpr = getFieldAccessExpression(fieldMatchPattern.pos, fieldName,\n+                matchPattern.type, tempCastVarDef.var.symbol);\n+        BLangSimpleVariableDef tempVarDef = createVarDef(\"$memberVarTemp$\" + index + \"_$\", matchPattern.type,\n+                fieldBasedAccessExpr, matchPattern.pos);\n+        BLangSimpleVarRef tempVarRef = ASTBuilderUtil.createVariableRef(matchPattern.pos, tempVarDef.var.symbol);\n+        blockStmt.addStatement(tempVarDef);\n+        return createVarCheckCondition(matchPattern, tempVarRef);\n+    }\n+\n+    private BLangExpression createVarCheckCondition(BLangMatchPattern matchPattern, BLangSimpleVarRef varRef) {\n \n         NodeKind patternKind = matchPattern.getKind();\n         switch (patternKind) {\n             case WILDCARD_MATCH_PATTERN:\n                 return createConditionForWildCardMatchPattern((BLangWildCardMatchPattern) matchPattern);\n             case CONST_MATCH_PATTERN:\n-                return createConditionForConstMatchPattern((BLangConstPattern) matchPattern, matchExprVarRef);\n+                return createConditionForConstMatchPattern((BLangConstPattern) matchPattern, varRef);\n             case VAR_BINDING_PATTERN_MATCH_PATTERN:\n                 return createConditionForVarBindingPatternMatchPattern(\n-                        (BLangVarBindingPatternMatchPattern) matchPattern, matchExprVarRef);\n+                        (BLangVarBindingPatternMatchPattern) matchPattern, varRef);\n             case LIST_MATCH_PATTERN:\n-                return createConditionForListMatchPattern((BLangListMatchPattern) matchPattern, matchExprVarRef);\n+                return createVarCheckConditionForListMatchPattern((BLangListMatchPattern) matchPattern, varRef);\n+            case MAPPING_MATCH_PATTERN:\n+                return createVarCheckConditionForMappingMatchPattern((BLangMappingMatchPattern) matchPattern, varRef);\n             default:\n                 // If some patterns are not implemented, those should be detected before this phase\n                 // TODO : Remove this after all patterns are implemented\n                 return null;\n         }\n     }\n \n+    private BLangExpression createVarCheckConditionForListMatchPattern(BLangListMatchPattern listMatchPattern,\n+                                                                       BLangSimpleVarRef varRef) {\n+        Location pos = listMatchPattern.pos;\n+        BLangBlockStmt blockStmt = ASTBuilderUtil.createBlockStmt(pos);\n+\n+        BLangSimpleVariableDef resultVarDef = createVarDef(\"$listPatternVarResult$\", symTable.booleanType, null,\n+                pos);\n+        BLangSimpleVarRef resultVarRef = ASTBuilderUtil.createVariableRef(pos, resultVarDef.var.symbol);\n+        blockStmt.addStatement(resultVarDef);\n+\n+        BLangAssignment failureResult =\n+                ASTBuilderUtil.createAssignmentStmt(pos, resultVarRef, getBooleanLiteral(false));\n+        BLangAssignment successResult =\n+                ASTBuilderUtil.createAssignmentStmt(pos, resultVarRef, getBooleanLiteral(true));\n+        blockStmt.addStatement(failureResult);\n+\n+        List<BType> memberTupleTypes = ((BTupleType) varRef.type).getTupleTypes();\n+        List<BLangMatchPattern> matchPatterns = listMatchPattern.matchPatterns;\n+\n+        BLangSimpleVariableDef tempCastVarDef = createVarDef(\"$castTemp$\", varRef.type, varRef, pos);\n+        blockStmt.addStatement(tempCastVarDef);\n+        BLangExpression condition = createConditionForListMemberPattern(0, matchPatterns.get(0),\n+                tempCastVarDef, blockStmt, memberTupleTypes.get(0), pos);\n+\n+        for (int i = 1; i < matchPatterns.size(); i++) {\n+            BLangExpression memberPatternCondition = createConditionForListMemberPattern(i,\n+                    matchPatterns.get(i), tempCastVarDef, blockStmt, memberTupleTypes.get(i), pos);\n+\n+            condition = ASTBuilderUtil.createBinaryExpr(pos, condition, memberPatternCondition,\n+                    symTable.booleanType, OperatorKind.AND, (BOperatorSymbol) symResolver\n+                            .resolveBinaryOperator(OperatorKind.AND, symTable.booleanType,\n+                                    symTable.booleanType));\n+        }\n+\n+        BLangBlockStmt tempBlockStmt = ASTBuilderUtil.createBlockStmt(pos);\n+        tempBlockStmt.addStatement(successResult);\n+        BLangIf ifStmtForMatchPatterns = ASTBuilderUtil.createIfElseStmt(pos, condition, tempBlockStmt, null);\n+        blockStmt.addStatement(ifStmtForMatchPatterns);\n+\n+        BLangStatementExpression statementExpression = ASTBuilderUtil.createStatementExpression(blockStmt,\n+                resultVarRef);\n+        statementExpression.type = symTable.booleanType;\n+        return statementExpression;\n+    }\n+\n+    private BLangExpression createVarCheckConditionForMappingMatchPattern(BLangMappingMatchPattern mappingMatchPattern,\n+                                                                          BLangSimpleVarRef varRef) {\n+        BRecordType recordType = (BRecordType) mappingMatchPattern.type;\n+        Location pos = mappingMatchPattern.pos;\n+        BLangBlockStmt blockStmt = ASTBuilderUtil.createBlockStmt(pos);\n+\n+        BLangSimpleVariableDef resultVarDef = createVarDef(\"$mappingPatternVarResult$\", symTable.booleanType,\n+                null, pos);\n+        BLangSimpleVarRef resultVarRef = ASTBuilderUtil.createVariableRef(pos, resultVarDef.var.symbol);\n+        blockStmt.addStatement(resultVarDef);\n+\n+        BLangAssignment failureResult =\n+                ASTBuilderUtil.createAssignmentStmt(pos, resultVarRef, getBooleanLiteral(false));\n+        BLangAssignment successResult =\n+                ASTBuilderUtil.createAssignmentStmt(pos, resultVarRef, getBooleanLiteral(true));\n+        blockStmt.addStatement(failureResult);\n+\n+        BLangSimpleVariableDef tempCastVarDef = createVarDef(\"$castTemp$\", mappingMatchPattern.type, varRef,\n+                pos);\n+        blockStmt.addStatement(tempCastVarDef);\n+\n+        BLangExpression condition =\n+                createConditionForFieldMatchPatterns(mappingMatchPattern.fieldMatchPatterns, tempCastVarDef,\n+                        blockStmt, pos);\n+\n+        BLangBlockStmt tempBlockStmt = ASTBuilderUtil.createBlockStmt(pos);\n+        tempBlockStmt.addStatement(successResult);\n+        BLangIf ifStmtForMatchPatterns = ASTBuilderUtil.createIfElseStmt(pos, condition, tempBlockStmt, null);\n+        blockStmt.addStatement(ifStmtForMatchPatterns);\n+\n+        BLangStatementExpression statementExpression = ASTBuilderUtil.createStatementExpression(blockStmt,\n+                resultVarRef);\n+        statementExpression.type = symTable.booleanType;\n+        addAsRecordTypeDefinition(recordType, pos);\n+        return statementExpression;\n+    }\n+\n+    private void addAsRecordTypeDefinition(BType type, Location pos) {\n+        if (type.tag == TypeTags.UNION) {\n+            for (BType memberType : ((BUnionType) type).getMemberTypes()) {\n+                addAsRecordTypeDefinition(memberType, pos);\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a795ecd1ecb76c24c1d87a0e00b7ecd1849f0ef4"}, "originalPosition": 322}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjI1ODAyNQ==", "bodyText": "Can't we use org.wso2.ballerinalang.compiler.util.TypeDefBuilderHelper#createRecordTypeNode(org.wso2.ballerinalang.compiler.semantics.model.types.BRecordType, org.ballerinalang.model.elements.PackageID, org.wso2.ballerinalang.compiler.semantics.model.SymbolTable, io.ballerina.tools.diagnostics.Location) here?\nIf there's something missing I think it should go in TypeDefBuilderHelper rather than adding it here.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r556258025", "createdAt": "2021-01-13T04:39:41Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java", "diffHunk": "@@ -3463,89 +3487,252 @@ private BLangExpression createConditionForListMemberPattern(int index, BLangMatc\n         return createVarCheckCondition(listMemberMatchPattern, tempVarRef);\n     }\n \n-    private BLangExpression createVarCheckCondition(BLangMatchPattern matchPattern,\n-                                                    BLangSimpleVarRef varRef) {\n+    private BLangExpression createConditionForMappingMatchPattern(BLangMappingMatchPattern mappingMatchPattern,\n+                                                                  BLangSimpleVarRef matchExprVarRef) {\n+        BType matchPatternType = mappingMatchPattern.type;\n+        Location pos = mappingMatchPattern.pos;\n \n-        NodeKind patternKind = matchPattern.getKind();\n-        switch (patternKind) {\n-            case WILDCARD_MATCH_PATTERN:\n-                return createConditionForWildCardMatchPattern((BLangWildCardMatchPattern) matchPattern);\n-            case CONST_MATCH_PATTERN:\n-                return createConditionForConstMatchPattern((BLangConstPattern) matchPattern, varRef);\n-            case VAR_BINDING_PATTERN_MATCH_PATTERN:\n-                return createConditionForVarBindingPatternMatchPattern(\n-                        (BLangVarBindingPatternMatchPattern) matchPattern, varRef);\n-            case LIST_MATCH_PATTERN:\n-                BLangListMatchPattern listMatchPattern = (BLangListMatchPattern) matchPattern;\n-                Location pos = listMatchPattern.pos;\n-                BLangBlockStmt blockStmt = ASTBuilderUtil.createBlockStmt(pos);\n-\n-                BLangSimpleVariableDef resultVarDef = createVarDef(\"$listPatternVarResult$\", symTable.booleanType, null,\n-                        pos);\n-                BLangSimpleVarRef resultVarRef = ASTBuilderUtil.createVariableRef(pos, resultVarDef.var.symbol);\n-                blockStmt.addStatement(resultVarDef);\n-\n-                BLangAssignment failureResult =\n-                        ASTBuilderUtil.createAssignmentStmt(pos, resultVarRef, getBooleanLiteral(false));\n-                BLangAssignment successResult =\n-                        ASTBuilderUtil.createAssignmentStmt(pos, resultVarRef, getBooleanLiteral(true));\n-                blockStmt.addStatement(failureResult);\n-\n-                List<BType> memberTupleTypes = ((BTupleType) varRef.type).getTupleTypes();\n-                List<BLangMatchPattern> matchPatterns = listMatchPattern.matchPatterns;\n-\n-                BLangSimpleVariableDef tempCastVarDef = createVarDef(\"$castTemp$\", varRef.type, varRef, pos);\n-                blockStmt.addStatement(tempCastVarDef);\n-                BLangExpression condition = createConditionForListMemberPattern(0, matchPatterns.get(0),\n-                        tempCastVarDef, blockStmt, memberTupleTypes.get(0), pos);\n-\n-                for (int i = 1; i < matchPatterns.size(); i++) {\n-                    BLangExpression memberPatternCondition = createConditionForListMemberPattern(i,\n-                            matchPatterns.get(i), tempCastVarDef, blockStmt, memberTupleTypes.get(i), pos);\n-\n-                    condition = ASTBuilderUtil.createBinaryExpr(pos, condition, memberPatternCondition,\n-                            symTable.booleanType, OperatorKind.AND, (BOperatorSymbol) symResolver\n-                                    .resolveBinaryOperator(OperatorKind.AND, symTable.booleanType,\n-                                            symTable.booleanType));\n-                }\n+        BLangSimpleVariableDef resultVarDef = createVarDef(\"$mappingPatternResult$\", symTable.booleanType, null, pos);\n+        BLangSimpleVarRef resultVarRef = ASTBuilderUtil.createVariableRef(pos, resultVarDef.var.symbol);\n+        BLangBlockStmt mainBlockStmt = ASTBuilderUtil.createBlockStmt(pos);\n+        mainBlockStmt.addStatement(resultVarDef);\n+\n+        BLangAssignment failureResult =\n+                ASTBuilderUtil.createAssignmentStmt(pos, resultVarRef, getBooleanLiteral(false));\n+        BLangAssignment successResult =\n+                ASTBuilderUtil.createAssignmentStmt(pos, resultVarRef, getBooleanLiteral(true));\n+        mainBlockStmt.addStatement(failureResult);\n \n-                BLangBlockStmt tempBlockStmt = ASTBuilderUtil.createBlockStmt(pos);\n-                tempBlockStmt.addStatement(successResult);\n-                BLangIf ifStmtForMatchPatterns = ASTBuilderUtil.createIfElseStmt(pos, condition, tempBlockStmt, null);\n-                blockStmt.addStatement(ifStmtForMatchPatterns);\n+        BLangExpression typeCheckCondition = createIsLikeExpression(mappingMatchPattern.pos, matchExprVarRef,\n+                matchPatternType);\n+        BLangExpression typeConvertedExpr = addConversionExprIfRequired(matchExprVarRef, matchPatternType);\n+        BLangSimpleVariableDef tempCastVarDef = createVarDef(\"$castTemp$\", matchPatternType, typeConvertedExpr, pos);\n+        BLangSimpleVarRef tempCastVarRef = ASTBuilderUtil.createVariableRef(pos, tempCastVarDef.var.symbol);\n \n-                BLangStatementExpression statementExpression = ASTBuilderUtil.createStatementExpression(blockStmt,\n-                        resultVarRef);\n-                statementExpression.type = symTable.booleanType;\n-                return statementExpression;\n-            default:\n-                // If some patterns are not implemented, those should be detected before this phase\n-                // TODO : Remove this after all patterns are implemented\n-                return null;\n+        BLangBlockStmt ifBlock = ASTBuilderUtil.createBlockStmt(pos);\n+        ifBlock.addStatement(tempCastVarDef);\n+        BLangIf ifStmt = ASTBuilderUtil.createIfElseStmt(pos, typeCheckCondition, ifBlock, null);\n+        mainBlockStmt.addStatement(ifStmt);\n+\n+        BLangExpression condition = createConditionForFieldMatchPatterns(mappingMatchPattern.fieldMatchPatterns,\n+                tempCastVarDef, ifBlock, pos);\n+\n+        BLangBlockStmt tempBlockStmt = ASTBuilderUtil.createBlockStmt(pos);\n+        tempBlockStmt.addStatement(successResult);\n+        if (mappingMatchPattern.restMatchPattern != null) {\n+            BLangRestMatchPattern restMatchPattern = mappingMatchPattern.restMatchPattern;\n+            Location restPatternPos = restMatchPattern.pos;\n+            List<String> keysToRemove = getKeysToRemove(mappingMatchPattern);\n+            BMapType entriesType = new BMapType(TypeTags.MAP, new BTupleType(Arrays.asList(symTable.stringType,\n+                    ((BMapType) mappingMatchPattern.restMatchPattern.type).constraint)), null);\n+            BLangInvocation entriesInvocation = generateMapEntriesInvocation(tempCastVarRef, entriesType);\n+            BLangSimpleVariableDef entriesVarDef = createVarDef(\"$entries$\", entriesType, entriesInvocation,\n+                    restPatternPos);\n+            tempBlockStmt.addStatement(entriesVarDef);\n+            BLangLambdaFunction filteringFunction = createFuncToFilterOutRestParam(keysToRemove, restPatternPos);\n+            BLangInvocation filterInvocation = generateMapFilterInvocation(pos, entriesVarDef.var, filteringFunction);\n+            BLangSimpleVariableDef filtersVarDef = createVarDef(\"$filteredVarDef$\", entriesType, filterInvocation,\n+                    restPatternPos);\n+            tempBlockStmt.addStatement(filtersVarDef);\n+            BLangLambdaFunction backToMapLambda = generateEntriesToMapLambda(restPatternPos);\n+            BLangInvocation mapInvocation = generateMapMapInvocation(restPatternPos, filtersVarDef.var,\n+                    backToMapLambda);\n+            BLangSimpleVarRef restMatchPatternVarRef = declaredVarDef.get(restMatchPattern.getIdentifier().getValue());\n+            tempBlockStmt.addStatement(ASTBuilderUtil.createAssignmentStmt(pos, restMatchPatternVarRef, mapInvocation));\n+        }\n+        BLangIf ifStmtForMatchPatterns = ASTBuilderUtil.createIfElseStmt(pos, condition, tempBlockStmt, null);\n+        ifBlock.addStatement(ifStmtForMatchPatterns);\n+\n+        BLangStatementExpression statementExpression = ASTBuilderUtil.createStatementExpression(mainBlockStmt,\n+                resultVarRef);\n+        statementExpression.type = symTable.booleanType;\n+\n+        addAsRecordTypeDefinition(matchPatternType, pos);\n+        return statementExpression;\n+    }\n+\n+    private List<String> getKeysToRemove(BLangMappingMatchPattern mappingMatchPattern) {\n+        List<String> keysToRemove = new ArrayList<>();\n+        for (BLangFieldMatchPattern fieldMatchPattern : mappingMatchPattern.fieldMatchPatterns) {\n+            keysToRemove.add(fieldMatchPattern.fieldName.value);\n         }\n+        return keysToRemove;\n     }\n \n-    private BLangExpression createConditionForMatchPattern(BLangMatchPattern matchPattern,\n-                                                           BLangSimpleVarRef matchExprVarRef) {\n+    private BLangExpression createConditionForFieldMatchPatterns(List<BLangFieldMatchPattern> fieldMatchPatterns,\n+                                                                 BLangSimpleVariableDef varDef,\n+                                                                 BLangBlockStmt blockStmt,\n+                                                                 Location pos) {\n+        BLangExpression condition = ASTBuilderUtil.createLiteral(pos, symTable.booleanType, true);\n+        for (int i = 0; i < fieldMatchPatterns.size(); i++) {\n+            BLangExpression fieldMatchPatternCondition =\n+                    createConditionForFieldMatchPattern(i, fieldMatchPatterns.get(i), varDef, blockStmt);\n+            condition = ASTBuilderUtil.createBinaryExpr(pos, condition, fieldMatchPatternCondition,\n+                    symTable.booleanType, OperatorKind.AND, (BOperatorSymbol) symResolver\n+                            .resolveBinaryOperator(OperatorKind.AND, symTable.booleanType, symTable.booleanType));\n+        }\n+        return condition;\n+    }\n+\n+    private BLangExpression createConditionForFieldMatchPattern(int index, BLangFieldMatchPattern fieldMatchPattern,\n+                                                                BLangSimpleVariableDef tempCastVarDef,\n+                                                                BLangBlockStmt blockStmt) {\n+        String fieldName = fieldMatchPattern.fieldName.value;\n+        BLangMatchPattern matchPattern = fieldMatchPattern.matchPattern;\n+        BLangFieldBasedAccess fieldBasedAccessExpr = getFieldAccessExpression(fieldMatchPattern.pos, fieldName,\n+                matchPattern.type, tempCastVarDef.var.symbol);\n+        BLangSimpleVariableDef tempVarDef = createVarDef(\"$memberVarTemp$\" + index + \"_$\", matchPattern.type,\n+                fieldBasedAccessExpr, matchPattern.pos);\n+        BLangSimpleVarRef tempVarRef = ASTBuilderUtil.createVariableRef(matchPattern.pos, tempVarDef.var.symbol);\n+        blockStmt.addStatement(tempVarDef);\n+        return createVarCheckCondition(matchPattern, tempVarRef);\n+    }\n+\n+    private BLangExpression createVarCheckCondition(BLangMatchPattern matchPattern, BLangSimpleVarRef varRef) {\n \n         NodeKind patternKind = matchPattern.getKind();\n         switch (patternKind) {\n             case WILDCARD_MATCH_PATTERN:\n                 return createConditionForWildCardMatchPattern((BLangWildCardMatchPattern) matchPattern);\n             case CONST_MATCH_PATTERN:\n-                return createConditionForConstMatchPattern((BLangConstPattern) matchPattern, matchExprVarRef);\n+                return createConditionForConstMatchPattern((BLangConstPattern) matchPattern, varRef);\n             case VAR_BINDING_PATTERN_MATCH_PATTERN:\n                 return createConditionForVarBindingPatternMatchPattern(\n-                        (BLangVarBindingPatternMatchPattern) matchPattern, matchExprVarRef);\n+                        (BLangVarBindingPatternMatchPattern) matchPattern, varRef);\n             case LIST_MATCH_PATTERN:\n-                return createConditionForListMatchPattern((BLangListMatchPattern) matchPattern, matchExprVarRef);\n+                return createVarCheckConditionForListMatchPattern((BLangListMatchPattern) matchPattern, varRef);\n+            case MAPPING_MATCH_PATTERN:\n+                return createVarCheckConditionForMappingMatchPattern((BLangMappingMatchPattern) matchPattern, varRef);\n             default:\n                 // If some patterns are not implemented, those should be detected before this phase\n                 // TODO : Remove this after all patterns are implemented\n                 return null;\n         }\n     }\n \n+    private BLangExpression createVarCheckConditionForListMatchPattern(BLangListMatchPattern listMatchPattern,\n+                                                                       BLangSimpleVarRef varRef) {\n+        Location pos = listMatchPattern.pos;\n+        BLangBlockStmt blockStmt = ASTBuilderUtil.createBlockStmt(pos);\n+\n+        BLangSimpleVariableDef resultVarDef = createVarDef(\"$listPatternVarResult$\", symTable.booleanType, null,\n+                pos);\n+        BLangSimpleVarRef resultVarRef = ASTBuilderUtil.createVariableRef(pos, resultVarDef.var.symbol);\n+        blockStmt.addStatement(resultVarDef);\n+\n+        BLangAssignment failureResult =\n+                ASTBuilderUtil.createAssignmentStmt(pos, resultVarRef, getBooleanLiteral(false));\n+        BLangAssignment successResult =\n+                ASTBuilderUtil.createAssignmentStmt(pos, resultVarRef, getBooleanLiteral(true));\n+        blockStmt.addStatement(failureResult);\n+\n+        List<BType> memberTupleTypes = ((BTupleType) varRef.type).getTupleTypes();\n+        List<BLangMatchPattern> matchPatterns = listMatchPattern.matchPatterns;\n+\n+        BLangSimpleVariableDef tempCastVarDef = createVarDef(\"$castTemp$\", varRef.type, varRef, pos);\n+        blockStmt.addStatement(tempCastVarDef);\n+        BLangExpression condition = createConditionForListMemberPattern(0, matchPatterns.get(0),\n+                tempCastVarDef, blockStmt, memberTupleTypes.get(0), pos);\n+\n+        for (int i = 1; i < matchPatterns.size(); i++) {\n+            BLangExpression memberPatternCondition = createConditionForListMemberPattern(i,\n+                    matchPatterns.get(i), tempCastVarDef, blockStmt, memberTupleTypes.get(i), pos);\n+\n+            condition = ASTBuilderUtil.createBinaryExpr(pos, condition, memberPatternCondition,\n+                    symTable.booleanType, OperatorKind.AND, (BOperatorSymbol) symResolver\n+                            .resolveBinaryOperator(OperatorKind.AND, symTable.booleanType,\n+                                    symTable.booleanType));\n+        }\n+\n+        BLangBlockStmt tempBlockStmt = ASTBuilderUtil.createBlockStmt(pos);\n+        tempBlockStmt.addStatement(successResult);\n+        BLangIf ifStmtForMatchPatterns = ASTBuilderUtil.createIfElseStmt(pos, condition, tempBlockStmt, null);\n+        blockStmt.addStatement(ifStmtForMatchPatterns);\n+\n+        BLangStatementExpression statementExpression = ASTBuilderUtil.createStatementExpression(blockStmt,\n+                resultVarRef);\n+        statementExpression.type = symTable.booleanType;\n+        return statementExpression;\n+    }\n+\n+    private BLangExpression createVarCheckConditionForMappingMatchPattern(BLangMappingMatchPattern mappingMatchPattern,\n+                                                                          BLangSimpleVarRef varRef) {\n+        BRecordType recordType = (BRecordType) mappingMatchPattern.type;\n+        Location pos = mappingMatchPattern.pos;\n+        BLangBlockStmt blockStmt = ASTBuilderUtil.createBlockStmt(pos);\n+\n+        BLangSimpleVariableDef resultVarDef = createVarDef(\"$mappingPatternVarResult$\", symTable.booleanType,\n+                null, pos);\n+        BLangSimpleVarRef resultVarRef = ASTBuilderUtil.createVariableRef(pos, resultVarDef.var.symbol);\n+        blockStmt.addStatement(resultVarDef);\n+\n+        BLangAssignment failureResult =\n+                ASTBuilderUtil.createAssignmentStmt(pos, resultVarRef, getBooleanLiteral(false));\n+        BLangAssignment successResult =\n+                ASTBuilderUtil.createAssignmentStmt(pos, resultVarRef, getBooleanLiteral(true));\n+        blockStmt.addStatement(failureResult);\n+\n+        BLangSimpleVariableDef tempCastVarDef = createVarDef(\"$castTemp$\", mappingMatchPattern.type, varRef,\n+                pos);\n+        blockStmt.addStatement(tempCastVarDef);\n+\n+        BLangExpression condition =\n+                createConditionForFieldMatchPatterns(mappingMatchPattern.fieldMatchPatterns, tempCastVarDef,\n+                        blockStmt, pos);\n+\n+        BLangBlockStmt tempBlockStmt = ASTBuilderUtil.createBlockStmt(pos);\n+        tempBlockStmt.addStatement(successResult);\n+        BLangIf ifStmtForMatchPatterns = ASTBuilderUtil.createIfElseStmt(pos, condition, tempBlockStmt, null);\n+        blockStmt.addStatement(ifStmtForMatchPatterns);\n+\n+        BLangStatementExpression statementExpression = ASTBuilderUtil.createStatementExpression(blockStmt,\n+                resultVarRef);\n+        statementExpression.type = symTable.booleanType;\n+        addAsRecordTypeDefinition(recordType, pos);\n+        return statementExpression;\n+    }\n+\n+    private void addAsRecordTypeDefinition(BType type, Location pos) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a795ecd1ecb76c24c1d87a0e00b7ecd1849f0ef4"}, "originalPosition": 318}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjI1ODIzMA==", "bodyText": "What's the scenario where this becomes true?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r556258230", "createdAt": "2021-01-13T04:40:29Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java", "diffHunk": "@@ -3463,89 +3487,252 @@ private BLangExpression createConditionForListMemberPattern(int index, BLangMatc\n         return createVarCheckCondition(listMemberMatchPattern, tempVarRef);\n     }\n \n-    private BLangExpression createVarCheckCondition(BLangMatchPattern matchPattern,\n-                                                    BLangSimpleVarRef varRef) {\n+    private BLangExpression createConditionForMappingMatchPattern(BLangMappingMatchPattern mappingMatchPattern,\n+                                                                  BLangSimpleVarRef matchExprVarRef) {\n+        BType matchPatternType = mappingMatchPattern.type;\n+        Location pos = mappingMatchPattern.pos;\n \n-        NodeKind patternKind = matchPattern.getKind();\n-        switch (patternKind) {\n-            case WILDCARD_MATCH_PATTERN:\n-                return createConditionForWildCardMatchPattern((BLangWildCardMatchPattern) matchPattern);\n-            case CONST_MATCH_PATTERN:\n-                return createConditionForConstMatchPattern((BLangConstPattern) matchPattern, varRef);\n-            case VAR_BINDING_PATTERN_MATCH_PATTERN:\n-                return createConditionForVarBindingPatternMatchPattern(\n-                        (BLangVarBindingPatternMatchPattern) matchPattern, varRef);\n-            case LIST_MATCH_PATTERN:\n-                BLangListMatchPattern listMatchPattern = (BLangListMatchPattern) matchPattern;\n-                Location pos = listMatchPattern.pos;\n-                BLangBlockStmt blockStmt = ASTBuilderUtil.createBlockStmt(pos);\n-\n-                BLangSimpleVariableDef resultVarDef = createVarDef(\"$listPatternVarResult$\", symTable.booleanType, null,\n-                        pos);\n-                BLangSimpleVarRef resultVarRef = ASTBuilderUtil.createVariableRef(pos, resultVarDef.var.symbol);\n-                blockStmt.addStatement(resultVarDef);\n-\n-                BLangAssignment failureResult =\n-                        ASTBuilderUtil.createAssignmentStmt(pos, resultVarRef, getBooleanLiteral(false));\n-                BLangAssignment successResult =\n-                        ASTBuilderUtil.createAssignmentStmt(pos, resultVarRef, getBooleanLiteral(true));\n-                blockStmt.addStatement(failureResult);\n-\n-                List<BType> memberTupleTypes = ((BTupleType) varRef.type).getTupleTypes();\n-                List<BLangMatchPattern> matchPatterns = listMatchPattern.matchPatterns;\n-\n-                BLangSimpleVariableDef tempCastVarDef = createVarDef(\"$castTemp$\", varRef.type, varRef, pos);\n-                blockStmt.addStatement(tempCastVarDef);\n-                BLangExpression condition = createConditionForListMemberPattern(0, matchPatterns.get(0),\n-                        tempCastVarDef, blockStmt, memberTupleTypes.get(0), pos);\n-\n-                for (int i = 1; i < matchPatterns.size(); i++) {\n-                    BLangExpression memberPatternCondition = createConditionForListMemberPattern(i,\n-                            matchPatterns.get(i), tempCastVarDef, blockStmt, memberTupleTypes.get(i), pos);\n-\n-                    condition = ASTBuilderUtil.createBinaryExpr(pos, condition, memberPatternCondition,\n-                            symTable.booleanType, OperatorKind.AND, (BOperatorSymbol) symResolver\n-                                    .resolveBinaryOperator(OperatorKind.AND, symTable.booleanType,\n-                                            symTable.booleanType));\n-                }\n+        BLangSimpleVariableDef resultVarDef = createVarDef(\"$mappingPatternResult$\", symTable.booleanType, null, pos);\n+        BLangSimpleVarRef resultVarRef = ASTBuilderUtil.createVariableRef(pos, resultVarDef.var.symbol);\n+        BLangBlockStmt mainBlockStmt = ASTBuilderUtil.createBlockStmt(pos);\n+        mainBlockStmt.addStatement(resultVarDef);\n+\n+        BLangAssignment failureResult =\n+                ASTBuilderUtil.createAssignmentStmt(pos, resultVarRef, getBooleanLiteral(false));\n+        BLangAssignment successResult =\n+                ASTBuilderUtil.createAssignmentStmt(pos, resultVarRef, getBooleanLiteral(true));\n+        mainBlockStmt.addStatement(failureResult);\n \n-                BLangBlockStmt tempBlockStmt = ASTBuilderUtil.createBlockStmt(pos);\n-                tempBlockStmt.addStatement(successResult);\n-                BLangIf ifStmtForMatchPatterns = ASTBuilderUtil.createIfElseStmt(pos, condition, tempBlockStmt, null);\n-                blockStmt.addStatement(ifStmtForMatchPatterns);\n+        BLangExpression typeCheckCondition = createIsLikeExpression(mappingMatchPattern.pos, matchExprVarRef,\n+                matchPatternType);\n+        BLangExpression typeConvertedExpr = addConversionExprIfRequired(matchExprVarRef, matchPatternType);\n+        BLangSimpleVariableDef tempCastVarDef = createVarDef(\"$castTemp$\", matchPatternType, typeConvertedExpr, pos);\n+        BLangSimpleVarRef tempCastVarRef = ASTBuilderUtil.createVariableRef(pos, tempCastVarDef.var.symbol);\n \n-                BLangStatementExpression statementExpression = ASTBuilderUtil.createStatementExpression(blockStmt,\n-                        resultVarRef);\n-                statementExpression.type = symTable.booleanType;\n-                return statementExpression;\n-            default:\n-                // If some patterns are not implemented, those should be detected before this phase\n-                // TODO : Remove this after all patterns are implemented\n-                return null;\n+        BLangBlockStmt ifBlock = ASTBuilderUtil.createBlockStmt(pos);\n+        ifBlock.addStatement(tempCastVarDef);\n+        BLangIf ifStmt = ASTBuilderUtil.createIfElseStmt(pos, typeCheckCondition, ifBlock, null);\n+        mainBlockStmt.addStatement(ifStmt);\n+\n+        BLangExpression condition = createConditionForFieldMatchPatterns(mappingMatchPattern.fieldMatchPatterns,\n+                tempCastVarDef, ifBlock, pos);\n+\n+        BLangBlockStmt tempBlockStmt = ASTBuilderUtil.createBlockStmt(pos);\n+        tempBlockStmt.addStatement(successResult);\n+        if (mappingMatchPattern.restMatchPattern != null) {\n+            BLangRestMatchPattern restMatchPattern = mappingMatchPattern.restMatchPattern;\n+            Location restPatternPos = restMatchPattern.pos;\n+            List<String> keysToRemove = getKeysToRemove(mappingMatchPattern);\n+            BMapType entriesType = new BMapType(TypeTags.MAP, new BTupleType(Arrays.asList(symTable.stringType,\n+                    ((BMapType) mappingMatchPattern.restMatchPattern.type).constraint)), null);\n+            BLangInvocation entriesInvocation = generateMapEntriesInvocation(tempCastVarRef, entriesType);\n+            BLangSimpleVariableDef entriesVarDef = createVarDef(\"$entries$\", entriesType, entriesInvocation,\n+                    restPatternPos);\n+            tempBlockStmt.addStatement(entriesVarDef);\n+            BLangLambdaFunction filteringFunction = createFuncToFilterOutRestParam(keysToRemove, restPatternPos);\n+            BLangInvocation filterInvocation = generateMapFilterInvocation(pos, entriesVarDef.var, filteringFunction);\n+            BLangSimpleVariableDef filtersVarDef = createVarDef(\"$filteredVarDef$\", entriesType, filterInvocation,\n+                    restPatternPos);\n+            tempBlockStmt.addStatement(filtersVarDef);\n+            BLangLambdaFunction backToMapLambda = generateEntriesToMapLambda(restPatternPos);\n+            BLangInvocation mapInvocation = generateMapMapInvocation(restPatternPos, filtersVarDef.var,\n+                    backToMapLambda);\n+            BLangSimpleVarRef restMatchPatternVarRef = declaredVarDef.get(restMatchPattern.getIdentifier().getValue());\n+            tempBlockStmt.addStatement(ASTBuilderUtil.createAssignmentStmt(pos, restMatchPatternVarRef, mapInvocation));\n+        }\n+        BLangIf ifStmtForMatchPatterns = ASTBuilderUtil.createIfElseStmt(pos, condition, tempBlockStmt, null);\n+        ifBlock.addStatement(ifStmtForMatchPatterns);\n+\n+        BLangStatementExpression statementExpression = ASTBuilderUtil.createStatementExpression(mainBlockStmt,\n+                resultVarRef);\n+        statementExpression.type = symTable.booleanType;\n+\n+        addAsRecordTypeDefinition(matchPatternType, pos);\n+        return statementExpression;\n+    }\n+\n+    private List<String> getKeysToRemove(BLangMappingMatchPattern mappingMatchPattern) {\n+        List<String> keysToRemove = new ArrayList<>();\n+        for (BLangFieldMatchPattern fieldMatchPattern : mappingMatchPattern.fieldMatchPatterns) {\n+            keysToRemove.add(fieldMatchPattern.fieldName.value);\n         }\n+        return keysToRemove;\n     }\n \n-    private BLangExpression createConditionForMatchPattern(BLangMatchPattern matchPattern,\n-                                                           BLangSimpleVarRef matchExprVarRef) {\n+    private BLangExpression createConditionForFieldMatchPatterns(List<BLangFieldMatchPattern> fieldMatchPatterns,\n+                                                                 BLangSimpleVariableDef varDef,\n+                                                                 BLangBlockStmt blockStmt,\n+                                                                 Location pos) {\n+        BLangExpression condition = ASTBuilderUtil.createLiteral(pos, symTable.booleanType, true);\n+        for (int i = 0; i < fieldMatchPatterns.size(); i++) {\n+            BLangExpression fieldMatchPatternCondition =\n+                    createConditionForFieldMatchPattern(i, fieldMatchPatterns.get(i), varDef, blockStmt);\n+            condition = ASTBuilderUtil.createBinaryExpr(pos, condition, fieldMatchPatternCondition,\n+                    symTable.booleanType, OperatorKind.AND, (BOperatorSymbol) symResolver\n+                            .resolveBinaryOperator(OperatorKind.AND, symTable.booleanType, symTable.booleanType));\n+        }\n+        return condition;\n+    }\n+\n+    private BLangExpression createConditionForFieldMatchPattern(int index, BLangFieldMatchPattern fieldMatchPattern,\n+                                                                BLangSimpleVariableDef tempCastVarDef,\n+                                                                BLangBlockStmt blockStmt) {\n+        String fieldName = fieldMatchPattern.fieldName.value;\n+        BLangMatchPattern matchPattern = fieldMatchPattern.matchPattern;\n+        BLangFieldBasedAccess fieldBasedAccessExpr = getFieldAccessExpression(fieldMatchPattern.pos, fieldName,\n+                matchPattern.type, tempCastVarDef.var.symbol);\n+        BLangSimpleVariableDef tempVarDef = createVarDef(\"$memberVarTemp$\" + index + \"_$\", matchPattern.type,\n+                fieldBasedAccessExpr, matchPattern.pos);\n+        BLangSimpleVarRef tempVarRef = ASTBuilderUtil.createVariableRef(matchPattern.pos, tempVarDef.var.symbol);\n+        blockStmt.addStatement(tempVarDef);\n+        return createVarCheckCondition(matchPattern, tempVarRef);\n+    }\n+\n+    private BLangExpression createVarCheckCondition(BLangMatchPattern matchPattern, BLangSimpleVarRef varRef) {\n \n         NodeKind patternKind = matchPattern.getKind();\n         switch (patternKind) {\n             case WILDCARD_MATCH_PATTERN:\n                 return createConditionForWildCardMatchPattern((BLangWildCardMatchPattern) matchPattern);\n             case CONST_MATCH_PATTERN:\n-                return createConditionForConstMatchPattern((BLangConstPattern) matchPattern, matchExprVarRef);\n+                return createConditionForConstMatchPattern((BLangConstPattern) matchPattern, varRef);\n             case VAR_BINDING_PATTERN_MATCH_PATTERN:\n                 return createConditionForVarBindingPatternMatchPattern(\n-                        (BLangVarBindingPatternMatchPattern) matchPattern, matchExprVarRef);\n+                        (BLangVarBindingPatternMatchPattern) matchPattern, varRef);\n             case LIST_MATCH_PATTERN:\n-                return createConditionForListMatchPattern((BLangListMatchPattern) matchPattern, matchExprVarRef);\n+                return createVarCheckConditionForListMatchPattern((BLangListMatchPattern) matchPattern, varRef);\n+            case MAPPING_MATCH_PATTERN:\n+                return createVarCheckConditionForMappingMatchPattern((BLangMappingMatchPattern) matchPattern, varRef);\n             default:\n                 // If some patterns are not implemented, those should be detected before this phase\n                 // TODO : Remove this after all patterns are implemented\n                 return null;\n         }\n     }\n \n+    private BLangExpression createVarCheckConditionForListMatchPattern(BLangListMatchPattern listMatchPattern,\n+                                                                       BLangSimpleVarRef varRef) {\n+        Location pos = listMatchPattern.pos;\n+        BLangBlockStmt blockStmt = ASTBuilderUtil.createBlockStmt(pos);\n+\n+        BLangSimpleVariableDef resultVarDef = createVarDef(\"$listPatternVarResult$\", symTable.booleanType, null,\n+                pos);\n+        BLangSimpleVarRef resultVarRef = ASTBuilderUtil.createVariableRef(pos, resultVarDef.var.symbol);\n+        blockStmt.addStatement(resultVarDef);\n+\n+        BLangAssignment failureResult =\n+                ASTBuilderUtil.createAssignmentStmt(pos, resultVarRef, getBooleanLiteral(false));\n+        BLangAssignment successResult =\n+                ASTBuilderUtil.createAssignmentStmt(pos, resultVarRef, getBooleanLiteral(true));\n+        blockStmt.addStatement(failureResult);\n+\n+        List<BType> memberTupleTypes = ((BTupleType) varRef.type).getTupleTypes();\n+        List<BLangMatchPattern> matchPatterns = listMatchPattern.matchPatterns;\n+\n+        BLangSimpleVariableDef tempCastVarDef = createVarDef(\"$castTemp$\", varRef.type, varRef, pos);\n+        blockStmt.addStatement(tempCastVarDef);\n+        BLangExpression condition = createConditionForListMemberPattern(0, matchPatterns.get(0),\n+                tempCastVarDef, blockStmt, memberTupleTypes.get(0), pos);\n+\n+        for (int i = 1; i < matchPatterns.size(); i++) {\n+            BLangExpression memberPatternCondition = createConditionForListMemberPattern(i,\n+                    matchPatterns.get(i), tempCastVarDef, blockStmt, memberTupleTypes.get(i), pos);\n+\n+            condition = ASTBuilderUtil.createBinaryExpr(pos, condition, memberPatternCondition,\n+                    symTable.booleanType, OperatorKind.AND, (BOperatorSymbol) symResolver\n+                            .resolveBinaryOperator(OperatorKind.AND, symTable.booleanType,\n+                                    symTable.booleanType));\n+        }\n+\n+        BLangBlockStmt tempBlockStmt = ASTBuilderUtil.createBlockStmt(pos);\n+        tempBlockStmt.addStatement(successResult);\n+        BLangIf ifStmtForMatchPatterns = ASTBuilderUtil.createIfElseStmt(pos, condition, tempBlockStmt, null);\n+        blockStmt.addStatement(ifStmtForMatchPatterns);\n+\n+        BLangStatementExpression statementExpression = ASTBuilderUtil.createStatementExpression(blockStmt,\n+                resultVarRef);\n+        statementExpression.type = symTable.booleanType;\n+        return statementExpression;\n+    }\n+\n+    private BLangExpression createVarCheckConditionForMappingMatchPattern(BLangMappingMatchPattern mappingMatchPattern,\n+                                                                          BLangSimpleVarRef varRef) {\n+        BRecordType recordType = (BRecordType) mappingMatchPattern.type;\n+        Location pos = mappingMatchPattern.pos;\n+        BLangBlockStmt blockStmt = ASTBuilderUtil.createBlockStmt(pos);\n+\n+        BLangSimpleVariableDef resultVarDef = createVarDef(\"$mappingPatternVarResult$\", symTable.booleanType,\n+                null, pos);\n+        BLangSimpleVarRef resultVarRef = ASTBuilderUtil.createVariableRef(pos, resultVarDef.var.symbol);\n+        blockStmt.addStatement(resultVarDef);\n+\n+        BLangAssignment failureResult =\n+                ASTBuilderUtil.createAssignmentStmt(pos, resultVarRef, getBooleanLiteral(false));\n+        BLangAssignment successResult =\n+                ASTBuilderUtil.createAssignmentStmt(pos, resultVarRef, getBooleanLiteral(true));\n+        blockStmt.addStatement(failureResult);\n+\n+        BLangSimpleVariableDef tempCastVarDef = createVarDef(\"$castTemp$\", mappingMatchPattern.type, varRef,\n+                pos);\n+        blockStmt.addStatement(tempCastVarDef);\n+\n+        BLangExpression condition =\n+                createConditionForFieldMatchPatterns(mappingMatchPattern.fieldMatchPatterns, tempCastVarDef,\n+                        blockStmt, pos);\n+\n+        BLangBlockStmt tempBlockStmt = ASTBuilderUtil.createBlockStmt(pos);\n+        tempBlockStmt.addStatement(successResult);\n+        BLangIf ifStmtForMatchPatterns = ASTBuilderUtil.createIfElseStmt(pos, condition, tempBlockStmt, null);\n+        blockStmt.addStatement(ifStmtForMatchPatterns);\n+\n+        BLangStatementExpression statementExpression = ASTBuilderUtil.createStatementExpression(blockStmt,\n+                resultVarRef);\n+        statementExpression.type = symTable.booleanType;\n+        addAsRecordTypeDefinition(recordType, pos);\n+        return statementExpression;\n+    }\n+\n+    private void addAsRecordTypeDefinition(BType type, Location pos) {\n+        if (type.tag == TypeTags.UNION) {\n+            for (BType memberType : ((BUnionType) type).getMemberTypes()) {\n+                addAsRecordTypeDefinition(memberType, pos);\n+            }\n+        }\n+        if (type.tag != TypeTags.RECORD) {\n+            return;\n+        }\n+        BRecordType recordType = (BRecordType) type;\n+        if (isRecordTypeDefExist(recordType.tsymbol, env)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a795ecd1ecb76c24c1d87a0e00b7ecd1849f0ef4"}, "originalPosition": 328}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjI2MDMzNA==", "bodyText": "Unused variables.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r556260334", "createdAt": "2021-01-13T04:48:44Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -136,6 +137,8 @@\n     private Names names;\n     private int finiteTypeCount = 0;\n     private BUnionType expandedXMLBuiltinSubtypes;\n+    private int recordCount = 0;\n+    private SymbolEnv env;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a795ecd1ecb76c24c1d87a0e00b7ecd1849f0ef4"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjI2Mjc0OQ==", "bodyText": "Ping on this.\nAlso I don't think the subsequent check with isSameBasicType works either.\nFor example, if you passed int as the first type and 'int:Signed16 as the second type we would return int here.\nBut if we pass 'int:Signed16 as the first type as int as the second type we would return 'int:Signed16. Is this correct?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r556262749", "createdAt": "2021-01-13T04:58:17Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -381,10 +404,32 @@ private boolean containsAnyType(BType type) {\n         return false;\n     }\n \n+    private boolean containsAnyDataType(BType type) {\n+        if (type.tag != TypeTags.UNION) {\n+            return type.tag == TypeTags.ANYDATA;\n+        }\n+\n+        for (BType memberTypes : ((BUnionType) type).getMemberTypes()) {\n+            if (memberTypes.tag == TypeTags.ANYDATA) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n     public BType mergeTypes(BType typeFirst, BType typeSecond) {\n-        if (containsAnyType(typeFirst)) {\n+        if (containsAnyType(typeFirst) && !containsErrorType(typeSecond)) {\n             return typeSecond;\n         }\n+        if (containsAnyType(typeSecond) && !containsErrorType(typeFirst)) {\n+            return typeFirst;\n+        }\n+        if (containsAnyDataType(typeFirst) && !containsErrorType(typeSecond)) {\n+            return typeSecond;\n+        }\n+        if (containsAnyDataType(typeSecond) && !containsErrorType(typeFirst)) {\n+            return typeFirst;\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTUxOTI4NA=="}, "originalCommit": {"oid": "1055ec1c66a9e91c8786d22d559dffc403d1011c"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjI2MzY2NA==", "bodyText": "I missed that this was getting called from getTypeIntersection. This is OK.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r556263664", "createdAt": "2021-01-13T05:01:50Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2736,25 +2781,16 @@ BType getTypeForFiniteTypeValuesAssignableToType(BFiniteType finiteType, BType t\n      * @return           a single type or a new union type if at least one member type of the union type is\n      *                      assignable to targetType, else semanticError\n      */\n-    BType getTypeForUnionTypeMembersAssignableToType(BUnionType unionType, BType targetType) {\n+    BType getTypeForUnionTypeMembersAssignableToType(BUnionType unionType, BType targetType, SymbolEnv env) {\n         List<BType> intersection = new LinkedList<>();\n \n         // type FooOne \"foo\"|1;\n         // type FooBar \"foo\"|\"bar\";\n         // unionType - boolean|FooOne, targetType - boolean|FooBar\n         unionType.getMemberTypes().forEach(memType -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTUyMzY3Mg=="}, "originalCommit": {"oid": "1055ec1c66a9e91c8786d22d559dffc403d1011c"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjI2Mzc5MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * @since Swan Lake\n          \n          \n            \n             * @since 2.0.0", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r556263790", "createdAt": "2021-01-13T05:02:18Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/tree/matchpatterns/BLangMappingMatchPattern.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.wso2.ballerinalang.compiler.tree.matchpatterns;\n+\n+import org.ballerinalang.model.tree.NodeKind;\n+import org.ballerinalang.model.tree.matchpatterns.FieldMatchPatternNode;\n+import org.ballerinalang.model.tree.matchpatterns.MappingMatchPatternNode;\n+import org.ballerinalang.model.tree.matchpatterns.RestMatchPatternNode;\n+import org.wso2.ballerinalang.compiler.tree.BLangNodeVisitor;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Represent mapping-match-pattern.\n+ *\n+ * @since Swan Lake", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a795ecd1ecb76c24c1d87a0e00b7ecd1849f0ef4"}, "originalPosition": 32}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a795ecd1ecb76c24c1d87a0e00b7ecd1849f0ef4", "author": {"user": {"login": "KavinduZoysa", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a795ecd1ecb76c24c1d87a0e00b7ecd1849f0ef4", "committedDate": "2021-01-12T10:57:59Z", "message": "Sync with master"}, "afterCommit": {"oid": "72d63ef3b4ded54361a1f82dddc788d97dbf7f6d", "author": {"user": {"login": "KavinduZoysa", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/72d63ef3b4ded54361a1f82dddc788d97dbf7f6d", "committedDate": "2021-01-13T09:14:22Z", "message": "Fix review suggestions"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "72d63ef3b4ded54361a1f82dddc788d97dbf7f6d", "author": {"user": {"login": "KavinduZoysa", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/72d63ef3b4ded54361a1f82dddc788d97dbf7f6d", "committedDate": "2021-01-13T09:14:22Z", "message": "Fix review suggestions"}, "afterCommit": {"oid": "545a8bb9b1f8b158053c3b811f61a2a5a2824366", "author": {"user": {"login": "KavinduZoysa", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/545a8bb9b1f8b158053c3b811f61a2a5a2824366", "committedDate": "2021-01-13T19:30:19Z", "message": "Fix review suggestions"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "545a8bb9b1f8b158053c3b811f61a2a5a2824366", "author": {"user": {"login": "KavinduZoysa", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/545a8bb9b1f8b158053c3b811f61a2a5a2824366", "committedDate": "2021-01-13T19:30:19Z", "message": "Fix review suggestions"}, "afterCommit": {"oid": "802a27539a3c7e3150df324046fa8bbf07efb9f7", "author": {"user": {"login": "KavinduZoysa", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/802a27539a3c7e3150df324046fa8bbf07efb9f7", "committedDate": "2021-01-14T03:51:57Z", "message": "Fix review suggestions"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY3ODY4MzE1", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#pullrequestreview-567868315", "createdAt": "2021-01-14T05:54:17Z", "commit": {"oid": "802a27539a3c7e3150df324046fa8bbf07efb9f7"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dd2c008b0eead60dafd35099504dc2ddb14e9299", "author": {"user": {"login": "KavinduZoysa", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/dd2c008b0eead60dafd35099504dc2ddb14e9299", "committedDate": "2021-01-14T07:32:17Z", "message": "Changed the parser"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "05d18205bfc27cc2711e4a553cd928f6b879477f", "author": {"user": {"login": "KavinduZoysa", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/05d18205bfc27cc2711e4a553cd928f6b879477f", "committedDate": "2021-01-14T07:32:17Z", "message": "Change the transformer"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4e6b081c1fc6f8a0a2774b9dfb4a6eff8a365369", "author": {"user": {"login": "KavinduZoysa", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/4e6b081c1fc6f8a0a2774b9dfb4a6eff8a365369", "committedDate": "2021-01-14T07:32:17Z", "message": "Add nodes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c768c6790c200168d47c9f7831bc85055a092929", "author": {"user": {"login": "KavinduZoysa", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c768c6790c200168d47c9f7831bc85055a092929", "committedDate": "2021-01-14T07:32:17Z", "message": "Implement the logic"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ce467510a5a0a130e7a94796fed3b0593a2a24be", "author": {"user": {"login": "KavinduZoysa", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/ce467510a5a0a130e7a94796fed3b0593a2a24be", "committedDate": "2021-01-14T07:32:17Z", "message": "Add the tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "63b4849b15c72b9342688792e46c6f56743e58be", "author": {"user": {"login": "KavinduZoysa", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/63b4849b15c72b9342688792e46c6f56743e58be", "committedDate": "2021-01-14T07:32:17Z", "message": "Remove unused imports"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "32f38ac77d0e92e13183ce4f63b401b4a2791e68", "author": {"user": {"login": "KavinduZoysa", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/32f38ac77d0e92e13183ce4f63b401b4a2791e68", "committedDate": "2021-01-14T07:32:17Z", "message": "Enable tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b20a5d1a94c42580cf58aa14dc6751c2abe7cba9", "author": {"user": {"login": "KavinduZoysa", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b20a5d1a94c42580cf58aa14dc6751c2abe7cba9", "committedDate": "2021-01-14T07:32:17Z", "message": "Support for rest-match-pattern"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0027e3a889c771376df1602f53d8d31e54d3c63c", "author": {"user": {"login": "KavinduZoysa", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/0027e3a889c771376df1602f53d8d31e54d3c63c", "committedDate": "2021-01-14T07:32:17Z", "message": "Add tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c23bd2c93e3f7a4d0e053f83d68cc1d8732db34f", "author": {"user": {"login": "KavinduZoysa", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c23bd2c93e3f7a4d0e053f83d68cc1d8732db34f", "committedDate": "2021-01-14T07:32:17Z", "message": "Disable a formatter test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "710195563428498eddb454fc757e6f86a4ec088a", "author": {"user": {"login": "KavinduZoysa", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/710195563428498eddb454fc757e6f86a4ec088a", "committedDate": "2021-01-14T07:32:17Z", "message": "Add more tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "829a0f7cee5549dc304f3b93f6301d1c59dbf480", "author": {"user": {"login": "KavinduZoysa", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/829a0f7cee5549dc304f3b93f6301d1c59dbf480", "committedDate": "2021-01-14T07:32:17Z", "message": "Add new env"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c47f94d03f1fe418e1bb4a25a837d39ed9a9911a", "author": {"user": {"login": "KavinduZoysa", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c47f94d03f1fe418e1bb4a25a837d39ed9a9911a", "committedDate": "2021-01-14T07:32:17Z", "message": "Fix review suggestions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f7b6f87e0ed27f0ca81b4b80a5fb9a5a4d569dc3", "author": {"user": {"login": "KavinduZoysa", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f7b6f87e0ed27f0ca81b4b80a5fb9a5a4d569dc3", "committedDate": "2021-01-14T07:32:17Z", "message": "Add record intersection"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cacb48491f5363850b2c6cd28aa26fc18b562107", "author": {"user": {"login": "KavinduZoysa", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/cacb48491f5363850b2c6cd28aa26fc18b562107", "committedDate": "2021-01-14T07:32:17Z", "message": "Handle zero patterns and fix suggestions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a67288db480bc700e90d8c9a6ba92968fc657b47", "author": {"user": {"login": "KavinduZoysa", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a67288db480bc700e90d8c9a6ba92968fc657b47", "committedDate": "2021-01-14T07:32:17Z", "message": "Rebase with master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2c4afc627e79a1098feaeb77dc0d7d0ae3496ebe", "author": {"user": {"login": "KavinduZoysa", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2c4afc627e79a1098feaeb77dc0d7d0ae3496ebe", "committedDate": "2021-01-14T07:32:17Z", "message": "Fix sugestions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "620d6c203a8ca74d79d00bb0a7aab9980d34f7dd", "author": {"user": {"login": "KavinduZoysa", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/620d6c203a8ca74d79d00bb0a7aab9980d34f7dd", "committedDate": "2021-01-14T07:32:17Z", "message": "Sync with master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3912c8b24c867847fec11d4e2c6a7fd17f57b3e6", "author": {"user": {"login": "KavinduZoysa", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3912c8b24c867847fec11d4e2c6a7fd17f57b3e6", "committedDate": "2021-01-14T07:32:17Z", "message": "Fix review suggestions"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "802a27539a3c7e3150df324046fa8bbf07efb9f7", "author": {"user": {"login": "KavinduZoysa", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/802a27539a3c7e3150df324046fa8bbf07efb9f7", "committedDate": "2021-01-14T03:51:57Z", "message": "Fix review suggestions"}, "afterCommit": {"oid": "3912c8b24c867847fec11d4e2c6a7fd17f57b3e6", "author": {"user": {"login": "KavinduZoysa", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3912c8b24c867847fec11d4e2c6a7fd17f57b3e6", "committedDate": "2021-01-14T07:32:17Z", "message": "Fix review suggestions"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY4MDA5ODE2", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#pullrequestreview-568009816", "createdAt": "2021-01-14T08:33:08Z", "commit": {"oid": "3912c8b24c867847fec11d4e2c6a7fd17f57b3e6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNFQwODozMzowOFrOITYi_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNFQwODozMzowOFrOITYi_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzE5NjAyOQ==", "bodyText": "The third pattern has an extra variable, right? Shouldn't this fail because \"All the match-patterns in a given match-pattern-list must bind the same set of variables.\"?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r557196029", "createdAt": "2021-01-14T08:33:08Z", "author": {"login": "MaryamZi"}, "path": "tests/jballerina-unit-test/src/test/resources/test-src/statements/matchstmt/mapping-match-pattern.bal", "diffHunk": "@@ -0,0 +1,516 @@\n+// Copyright (c) 2020 WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+//\n+// WSO2 Inc. licenses this file to you under the Apache License,\n+// Version 2.0 (the \"License\"); you may not use this file except\n+// in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+function mappingMatchPattern1(any v) returns string {\n+    match v {\n+        {a: \"str\"} => {\n+            return \"match1\";\n+        }\n+        {a: 1} => {\n+            return \"match2\";\n+        }\n+        {a: true} => {\n+            return \"match3\";\n+        }\n+    }\n+    return \"No match\";\n+}\n+\n+function testMappingMatchPattern1() {\n+    assertEquals(\"match1\", mappingMatchPattern1({a: \"str\"}));\n+    assertEquals(\"match1\", mappingMatchPattern1({a: \"str\", b: \"D\"}));\n+    assertEquals(\"match2\", mappingMatchPattern1({a: 1}));\n+    assertEquals(\"match3\", mappingMatchPattern1({a: true}));\n+    assertEquals(\"No match\", mappingMatchPattern1({b: true}));\n+}\n+\n+function mappingMatchPattern2(any v) returns string {\n+    match v {\n+        {a: \"str1\", b: \"str2\"} => {\n+            return \"match1\";\n+        }\n+        {a: 1, b: 2} => {\n+            return \"match2\";\n+        }\n+        {a: true, b: false, c: 3} => {\n+            return \"match3\";\n+        }\n+    }\n+\n+    return \"No match\";\n+}\n+\n+function testMappingMatchPattern2() {\n+    assertEquals(\"match1\", mappingMatchPattern2({a: \"str1\", b: \"str2\"}));\n+    assertEquals(\"match2\", mappingMatchPattern2({a: 1, b: 2}));\n+    assertEquals(\"match3\", mappingMatchPattern2({a: true, b: false, c: 3}));\n+    assertEquals(\"match2\", mappingMatchPattern2({a: 1, b: 2, c: 4}));\n+    assertEquals(\"No match\", mappingMatchPattern2({b: true}));\n+}\n+\n+function mappingMatchPattern3(any v) returns string {\n+    match v {\n+        {a: \"str1\", b: \"str2\"} | {a: \"str3\", b: \"str4\"} | {a: \"str5\", b: \"str6\", c: \"str7\"}  => {\n+            return \"match1\";\n+        }\n+        {a: 1, b: 2} | {a: 3, b: 4} | {a: 5, b: 6, c: 7} => {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3912c8b24c867847fec11d4e2c6a7fd17f57b3e6"}, "originalPosition": 69}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY4MzYyNjky", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#pullrequestreview-568362692", "createdAt": "2021-01-14T15:45:13Z", "commit": {"oid": "3912c8b24c867847fec11d4e2c6a7fd17f57b3e6"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4481, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}