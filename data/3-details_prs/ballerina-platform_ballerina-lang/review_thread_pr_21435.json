{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgyODY4ODI3", "number": 21435, "reviewThreads": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxMzozMzo1MFrODkpriQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwNTo0MzozOVrODk6wCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5NzU4MjE3OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/BackendDriver.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxMzozMzo1MVrOFxF3GA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxMzozMzo1MVrOFxF3GA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzAyMDU2OA==", "bodyText": "Shall we add a new line in all places?\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            package org.wso2.ballerinalang.compiler.bir;\n          \n          \n            \n            \n          \n          \n            \n            package org.wso2.ballerinalang.compiler.bir;", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21435#discussion_r387020568", "createdAt": "2020-03-03T13:33:51Z", "author": {"login": "riyafa"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/BackendDriver.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.wso2.ballerinalang.compiler.bir;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82df207efdc85acd9646a1aae1461f7d1f7bbc5f"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMDIzNDA2OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/codegen/JvmCastGen.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwMzo1MTo0N1rOFxfOOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwMzo1MTo0N1rOFxfOOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQzNjA4OQ==", "bodyText": "Why don't  we use a switch statement here?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21435#discussion_r387436089", "createdAt": "2020-03-04T03:51:47Z", "author": {"login": "riyafa"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/codegen/JvmCastGen.java", "diffHunk": "@@ -0,0 +1,1096 @@\n+/*\n+ *  Copyright (c) 2018, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.wso2.ballerinalang.compiler.bir.codegen;\n+\n+import org.ballerinalang.compiler.BLangCompilerException;\n+import org.objectweb.asm.Label;\n+import org.objectweb.asm.MethodVisitor;\n+import org.wso2.ballerinalang.compiler.bir.codegen.JvmMethodGen.BalToJVMIndexMap;\n+import org.wso2.ballerinalang.compiler.bir.codegen.interop.JType;\n+import org.wso2.ballerinalang.compiler.bir.codegen.interop.JTypeTags;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRVariableDcl;\n+import org.wso2.ballerinalang.compiler.bir.model.VarKind;\n+import org.wso2.ballerinalang.compiler.bir.model.VarScope;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BFiniteType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BMapType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BUnionType;\n+import org.wso2.ballerinalang.compiler.util.Name;\n+import org.wso2.ballerinalang.compiler.util.TypeTags;\n+\n+import static org.objectweb.asm.Opcodes.ALOAD;\n+import static org.objectweb.asm.Opcodes.ASTORE;\n+import static org.objectweb.asm.Opcodes.CHECKCAST;\n+import static org.objectweb.asm.Opcodes.D2F;\n+import static org.objectweb.asm.Opcodes.D2I;\n+import static org.objectweb.asm.Opcodes.D2L;\n+import static org.objectweb.asm.Opcodes.DUP;\n+import static org.objectweb.asm.Opcodes.F2D;\n+import static org.objectweb.asm.Opcodes.I2B;\n+import static org.objectweb.asm.Opcodes.I2C;\n+import static org.objectweb.asm.Opcodes.I2D;\n+import static org.objectweb.asm.Opcodes.I2F;\n+import static org.objectweb.asm.Opcodes.I2L;\n+import static org.objectweb.asm.Opcodes.I2S;\n+import static org.objectweb.asm.Opcodes.IFNE;\n+import static org.objectweb.asm.Opcodes.IFNULL;\n+import static org.objectweb.asm.Opcodes.INSTANCEOF;\n+import static org.objectweb.asm.Opcodes.INVOKEINTERFACE;\n+import static org.objectweb.asm.Opcodes.INVOKESPECIAL;\n+import static org.objectweb.asm.Opcodes.INVOKESTATIC;\n+import static org.objectweb.asm.Opcodes.INVOKEVIRTUAL;\n+import static org.objectweb.asm.Opcodes.L2D;\n+import static org.objectweb.asm.Opcodes.L2F;\n+import static org.objectweb.asm.Opcodes.L2I;\n+import static org.objectweb.asm.Opcodes.NEW;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.ARRAY_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BHANDLE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BOOLEAN_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BTYPE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.DECIMAL_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.DOUBLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.ERROR_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.FUNCTION_POINTER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.FUTURE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.HANDLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.INT_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.LONG_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.MAP_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.NUMBER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.OBJECT;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.OBJECT_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.REF_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.SIMPLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STREAM_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STRING_UTILS;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STRING_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TABLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TYPEDESC_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TYPE_CHECKER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TYPE_CONVERTER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.XML_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmInstructionGen.B_STRING_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmInstructionGen.I_STRING_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmInstructionGen.addBoxInsn;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmLabelGen.LabelGenerator;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmPackageGen.symbolTable;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmTypeGen.loadType;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.interop.InteropMethodGen.getSignatureForJType;\n+\n+/**\n+ * Check cast methods generation for JVM bytecode generation.\n+ *\n+ * @since 1.2.0\n+ */\n+public class JvmCastGen {\n+\n+    static void generatePlatformCheckCast(MethodVisitor mv, BalToJVMIndexMap indexMap, BType sourceType,\n+                                          BType targetType) {\n+\n+        if (sourceType.tag == JTypeTags.JTYPE) {\n+            // If a target type is bir type, then we can guarantee source type is a jvm type, hence the cast\n+            generateJToBCheckCast(mv, indexMap, (JType) sourceType, targetType);\n+        } else {\n+            // else target type is jvm and source type is bir\n+            generateBToJCheckCast(mv, sourceType, (JType) targetType);\n+        }\n+    }\n+\n+    public static void generateBToJCheckCast(MethodVisitor mv, BType sourceType, JType targetType) {\n+\n+        if (targetType.jTag == JTypeTags.JBYTE) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82df207efdc85acd9646a1aae1461f7d1f7bbc5f"}, "originalPosition": 116}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMDIzODM1OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/codegen/JvmCastGen.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwMzo1NDo1NlrOFxfQxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwMzo1NDo1NlrOFxfQxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQzNjc0MA==", "bodyText": "Shall we use switch statement?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21435#discussion_r387436740", "createdAt": "2020-03-04T03:54:56Z", "author": {"login": "riyafa"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/codegen/JvmCastGen.java", "diffHunk": "@@ -0,0 +1,1096 @@\n+/*\n+ *  Copyright (c) 2018, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.wso2.ballerinalang.compiler.bir.codegen;\n+\n+import org.ballerinalang.compiler.BLangCompilerException;\n+import org.objectweb.asm.Label;\n+import org.objectweb.asm.MethodVisitor;\n+import org.wso2.ballerinalang.compiler.bir.codegen.JvmMethodGen.BalToJVMIndexMap;\n+import org.wso2.ballerinalang.compiler.bir.codegen.interop.JType;\n+import org.wso2.ballerinalang.compiler.bir.codegen.interop.JTypeTags;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRVariableDcl;\n+import org.wso2.ballerinalang.compiler.bir.model.VarKind;\n+import org.wso2.ballerinalang.compiler.bir.model.VarScope;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BFiniteType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BMapType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BUnionType;\n+import org.wso2.ballerinalang.compiler.util.Name;\n+import org.wso2.ballerinalang.compiler.util.TypeTags;\n+\n+import static org.objectweb.asm.Opcodes.ALOAD;\n+import static org.objectweb.asm.Opcodes.ASTORE;\n+import static org.objectweb.asm.Opcodes.CHECKCAST;\n+import static org.objectweb.asm.Opcodes.D2F;\n+import static org.objectweb.asm.Opcodes.D2I;\n+import static org.objectweb.asm.Opcodes.D2L;\n+import static org.objectweb.asm.Opcodes.DUP;\n+import static org.objectweb.asm.Opcodes.F2D;\n+import static org.objectweb.asm.Opcodes.I2B;\n+import static org.objectweb.asm.Opcodes.I2C;\n+import static org.objectweb.asm.Opcodes.I2D;\n+import static org.objectweb.asm.Opcodes.I2F;\n+import static org.objectweb.asm.Opcodes.I2L;\n+import static org.objectweb.asm.Opcodes.I2S;\n+import static org.objectweb.asm.Opcodes.IFNE;\n+import static org.objectweb.asm.Opcodes.IFNULL;\n+import static org.objectweb.asm.Opcodes.INSTANCEOF;\n+import static org.objectweb.asm.Opcodes.INVOKEINTERFACE;\n+import static org.objectweb.asm.Opcodes.INVOKESPECIAL;\n+import static org.objectweb.asm.Opcodes.INVOKESTATIC;\n+import static org.objectweb.asm.Opcodes.INVOKEVIRTUAL;\n+import static org.objectweb.asm.Opcodes.L2D;\n+import static org.objectweb.asm.Opcodes.L2F;\n+import static org.objectweb.asm.Opcodes.L2I;\n+import static org.objectweb.asm.Opcodes.NEW;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.ARRAY_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BHANDLE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BOOLEAN_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BTYPE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.DECIMAL_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.DOUBLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.ERROR_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.FUNCTION_POINTER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.FUTURE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.HANDLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.INT_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.LONG_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.MAP_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.NUMBER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.OBJECT;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.OBJECT_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.REF_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.SIMPLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STREAM_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STRING_UTILS;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STRING_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TABLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TYPEDESC_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TYPE_CHECKER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TYPE_CONVERTER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.XML_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmInstructionGen.B_STRING_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmInstructionGen.I_STRING_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmInstructionGen.addBoxInsn;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmLabelGen.LabelGenerator;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmPackageGen.symbolTable;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmTypeGen.loadType;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.interop.InteropMethodGen.getSignatureForJType;\n+\n+/**\n+ * Check cast methods generation for JVM bytecode generation.\n+ *\n+ * @since 1.2.0\n+ */\n+public class JvmCastGen {\n+\n+    static void generatePlatformCheckCast(MethodVisitor mv, BalToJVMIndexMap indexMap, BType sourceType,\n+                                          BType targetType) {\n+\n+        if (sourceType.tag == JTypeTags.JTYPE) {\n+            // If a target type is bir type, then we can guarantee source type is a jvm type, hence the cast\n+            generateJToBCheckCast(mv, indexMap, (JType) sourceType, targetType);\n+        } else {\n+            // else target type is jvm and source type is bir\n+            generateBToJCheckCast(mv, sourceType, (JType) targetType);\n+        }\n+    }\n+\n+    public static void generateBToJCheckCast(MethodVisitor mv, BType sourceType, JType targetType) {\n+\n+        if (targetType.jTag == JTypeTags.JBYTE) {\n+            generateCheckCastBToJByte(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JCHAR) {\n+            generateCheckCastBToJChar(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JSHORT) {\n+            generateCheckCastBToJShort(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JINT) {\n+            generateCheckCastBToJInt(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JLONG) {\n+            generateCheckCastBToJLong(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JFLOAT) {\n+            generateCheckCastBToJFloat(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JDOUBLE) {\n+            generateCheckCastBToJDouble(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JREF) {\n+            if (((JType.JRefType) targetType).typeValue.equals(B_STRING_VALUE)) {\n+                generateCheckCastBToJString(mv, sourceType);\n+            } else {\n+                generateCheckCastBToJRef(mv, sourceType, targetType);\n+            }\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JARRAY) {\n+            generateCheckCastBToJRef(mv, sourceType, targetType);\n+            return;\n+        } else {\n+            throw new BLangCompilerException(String.format(\"Casting is not supported from '%s' to 'java %s'\",\n+                    sourceType, targetType));\n+        }\n+    }\n+\n+    private static void generateCheckCastBToJString(MethodVisitor mv, BType sourceType) {\n+\n+        if (sourceType.tag == TypeTags.STRING) {\n+            mv.visitMethodInsn(INVOKESTATIC, STRING_UTILS, \"fromString\",\n+                    String.format(\"(L%s;)L%s;\", STRING_VALUE, B_STRING_VALUE), false);\n+        } else {\n+            throw new BLangCompilerException(String.format(\"Casting is not supported from '%s' to 'java byte'\",\n+                    sourceType));\n+        }\n+    }\n+\n+    private static void generateCheckCastBToJByte(MethodVisitor mv, BType sourceType) {\n+\n+        if (sourceType.tag == TypeTags.BYTE) {\n+            // do nothing\n+        } else if (sourceType.tag == TypeTags.INT) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82df207efdc85acd9646a1aae1461f7d1f7bbc5f"}, "originalPosition": 168}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMDIzOTIxOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/codegen/JvmCastGen.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwMzo1NTozMlrOFxfRTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwMzo1NTozMlrOFxfRTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQzNjg3OQ==", "bodyText": "Shall we use a constant for hardcoded method name?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21435#discussion_r387436879", "createdAt": "2020-03-04T03:55:32Z", "author": {"login": "riyafa"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/codegen/JvmCastGen.java", "diffHunk": "@@ -0,0 +1,1096 @@\n+/*\n+ *  Copyright (c) 2018, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.wso2.ballerinalang.compiler.bir.codegen;\n+\n+import org.ballerinalang.compiler.BLangCompilerException;\n+import org.objectweb.asm.Label;\n+import org.objectweb.asm.MethodVisitor;\n+import org.wso2.ballerinalang.compiler.bir.codegen.JvmMethodGen.BalToJVMIndexMap;\n+import org.wso2.ballerinalang.compiler.bir.codegen.interop.JType;\n+import org.wso2.ballerinalang.compiler.bir.codegen.interop.JTypeTags;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRVariableDcl;\n+import org.wso2.ballerinalang.compiler.bir.model.VarKind;\n+import org.wso2.ballerinalang.compiler.bir.model.VarScope;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BFiniteType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BMapType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BUnionType;\n+import org.wso2.ballerinalang.compiler.util.Name;\n+import org.wso2.ballerinalang.compiler.util.TypeTags;\n+\n+import static org.objectweb.asm.Opcodes.ALOAD;\n+import static org.objectweb.asm.Opcodes.ASTORE;\n+import static org.objectweb.asm.Opcodes.CHECKCAST;\n+import static org.objectweb.asm.Opcodes.D2F;\n+import static org.objectweb.asm.Opcodes.D2I;\n+import static org.objectweb.asm.Opcodes.D2L;\n+import static org.objectweb.asm.Opcodes.DUP;\n+import static org.objectweb.asm.Opcodes.F2D;\n+import static org.objectweb.asm.Opcodes.I2B;\n+import static org.objectweb.asm.Opcodes.I2C;\n+import static org.objectweb.asm.Opcodes.I2D;\n+import static org.objectweb.asm.Opcodes.I2F;\n+import static org.objectweb.asm.Opcodes.I2L;\n+import static org.objectweb.asm.Opcodes.I2S;\n+import static org.objectweb.asm.Opcodes.IFNE;\n+import static org.objectweb.asm.Opcodes.IFNULL;\n+import static org.objectweb.asm.Opcodes.INSTANCEOF;\n+import static org.objectweb.asm.Opcodes.INVOKEINTERFACE;\n+import static org.objectweb.asm.Opcodes.INVOKESPECIAL;\n+import static org.objectweb.asm.Opcodes.INVOKESTATIC;\n+import static org.objectweb.asm.Opcodes.INVOKEVIRTUAL;\n+import static org.objectweb.asm.Opcodes.L2D;\n+import static org.objectweb.asm.Opcodes.L2F;\n+import static org.objectweb.asm.Opcodes.L2I;\n+import static org.objectweb.asm.Opcodes.NEW;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.ARRAY_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BHANDLE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BOOLEAN_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BTYPE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.DECIMAL_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.DOUBLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.ERROR_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.FUNCTION_POINTER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.FUTURE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.HANDLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.INT_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.LONG_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.MAP_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.NUMBER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.OBJECT;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.OBJECT_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.REF_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.SIMPLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STREAM_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STRING_UTILS;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STRING_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TABLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TYPEDESC_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TYPE_CHECKER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TYPE_CONVERTER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.XML_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmInstructionGen.B_STRING_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmInstructionGen.I_STRING_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmInstructionGen.addBoxInsn;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmLabelGen.LabelGenerator;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmPackageGen.symbolTable;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmTypeGen.loadType;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.interop.InteropMethodGen.getSignatureForJType;\n+\n+/**\n+ * Check cast methods generation for JVM bytecode generation.\n+ *\n+ * @since 1.2.0\n+ */\n+public class JvmCastGen {\n+\n+    static void generatePlatformCheckCast(MethodVisitor mv, BalToJVMIndexMap indexMap, BType sourceType,\n+                                          BType targetType) {\n+\n+        if (sourceType.tag == JTypeTags.JTYPE) {\n+            // If a target type is bir type, then we can guarantee source type is a jvm type, hence the cast\n+            generateJToBCheckCast(mv, indexMap, (JType) sourceType, targetType);\n+        } else {\n+            // else target type is jvm and source type is bir\n+            generateBToJCheckCast(mv, sourceType, (JType) targetType);\n+        }\n+    }\n+\n+    public static void generateBToJCheckCast(MethodVisitor mv, BType sourceType, JType targetType) {\n+\n+        if (targetType.jTag == JTypeTags.JBYTE) {\n+            generateCheckCastBToJByte(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JCHAR) {\n+            generateCheckCastBToJChar(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JSHORT) {\n+            generateCheckCastBToJShort(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JINT) {\n+            generateCheckCastBToJInt(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JLONG) {\n+            generateCheckCastBToJLong(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JFLOAT) {\n+            generateCheckCastBToJFloat(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JDOUBLE) {\n+            generateCheckCastBToJDouble(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JREF) {\n+            if (((JType.JRefType) targetType).typeValue.equals(B_STRING_VALUE)) {\n+                generateCheckCastBToJString(mv, sourceType);\n+            } else {\n+                generateCheckCastBToJRef(mv, sourceType, targetType);\n+            }\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JARRAY) {\n+            generateCheckCastBToJRef(mv, sourceType, targetType);\n+            return;\n+        } else {\n+            throw new BLangCompilerException(String.format(\"Casting is not supported from '%s' to 'java %s'\",\n+                    sourceType, targetType));\n+        }\n+    }\n+\n+    private static void generateCheckCastBToJString(MethodVisitor mv, BType sourceType) {\n+\n+        if (sourceType.tag == TypeTags.STRING) {\n+            mv.visitMethodInsn(INVOKESTATIC, STRING_UTILS, \"fromString\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82df207efdc85acd9646a1aae1461f7d1f7bbc5f"}, "originalPosition": 156}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMDI0MDE0OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/codegen/JvmCastGen.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwMzo1NjoxMVrOFxfR1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwMzo1NjoxMVrOFxfR1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQzNzAxNA==", "bodyText": "Shall we use switch statements in all places instead of if-else-if statements?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21435#discussion_r387437014", "createdAt": "2020-03-04T03:56:11Z", "author": {"login": "riyafa"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/codegen/JvmCastGen.java", "diffHunk": "@@ -0,0 +1,1096 @@\n+/*\n+ *  Copyright (c) 2018, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.wso2.ballerinalang.compiler.bir.codegen;\n+\n+import org.ballerinalang.compiler.BLangCompilerException;\n+import org.objectweb.asm.Label;\n+import org.objectweb.asm.MethodVisitor;\n+import org.wso2.ballerinalang.compiler.bir.codegen.JvmMethodGen.BalToJVMIndexMap;\n+import org.wso2.ballerinalang.compiler.bir.codegen.interop.JType;\n+import org.wso2.ballerinalang.compiler.bir.codegen.interop.JTypeTags;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRVariableDcl;\n+import org.wso2.ballerinalang.compiler.bir.model.VarKind;\n+import org.wso2.ballerinalang.compiler.bir.model.VarScope;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BFiniteType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BMapType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BUnionType;\n+import org.wso2.ballerinalang.compiler.util.Name;\n+import org.wso2.ballerinalang.compiler.util.TypeTags;\n+\n+import static org.objectweb.asm.Opcodes.ALOAD;\n+import static org.objectweb.asm.Opcodes.ASTORE;\n+import static org.objectweb.asm.Opcodes.CHECKCAST;\n+import static org.objectweb.asm.Opcodes.D2F;\n+import static org.objectweb.asm.Opcodes.D2I;\n+import static org.objectweb.asm.Opcodes.D2L;\n+import static org.objectweb.asm.Opcodes.DUP;\n+import static org.objectweb.asm.Opcodes.F2D;\n+import static org.objectweb.asm.Opcodes.I2B;\n+import static org.objectweb.asm.Opcodes.I2C;\n+import static org.objectweb.asm.Opcodes.I2D;\n+import static org.objectweb.asm.Opcodes.I2F;\n+import static org.objectweb.asm.Opcodes.I2L;\n+import static org.objectweb.asm.Opcodes.I2S;\n+import static org.objectweb.asm.Opcodes.IFNE;\n+import static org.objectweb.asm.Opcodes.IFNULL;\n+import static org.objectweb.asm.Opcodes.INSTANCEOF;\n+import static org.objectweb.asm.Opcodes.INVOKEINTERFACE;\n+import static org.objectweb.asm.Opcodes.INVOKESPECIAL;\n+import static org.objectweb.asm.Opcodes.INVOKESTATIC;\n+import static org.objectweb.asm.Opcodes.INVOKEVIRTUAL;\n+import static org.objectweb.asm.Opcodes.L2D;\n+import static org.objectweb.asm.Opcodes.L2F;\n+import static org.objectweb.asm.Opcodes.L2I;\n+import static org.objectweb.asm.Opcodes.NEW;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.ARRAY_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BHANDLE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BOOLEAN_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BTYPE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.DECIMAL_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.DOUBLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.ERROR_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.FUNCTION_POINTER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.FUTURE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.HANDLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.INT_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.LONG_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.MAP_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.NUMBER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.OBJECT;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.OBJECT_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.REF_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.SIMPLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STREAM_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STRING_UTILS;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STRING_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TABLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TYPEDESC_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TYPE_CHECKER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TYPE_CONVERTER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.XML_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmInstructionGen.B_STRING_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmInstructionGen.I_STRING_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmInstructionGen.addBoxInsn;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmLabelGen.LabelGenerator;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmPackageGen.symbolTable;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmTypeGen.loadType;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.interop.InteropMethodGen.getSignatureForJType;\n+\n+/**\n+ * Check cast methods generation for JVM bytecode generation.\n+ *\n+ * @since 1.2.0\n+ */\n+public class JvmCastGen {\n+\n+    static void generatePlatformCheckCast(MethodVisitor mv, BalToJVMIndexMap indexMap, BType sourceType,\n+                                          BType targetType) {\n+\n+        if (sourceType.tag == JTypeTags.JTYPE) {\n+            // If a target type is bir type, then we can guarantee source type is a jvm type, hence the cast\n+            generateJToBCheckCast(mv, indexMap, (JType) sourceType, targetType);\n+        } else {\n+            // else target type is jvm and source type is bir\n+            generateBToJCheckCast(mv, sourceType, (JType) targetType);\n+        }\n+    }\n+\n+    public static void generateBToJCheckCast(MethodVisitor mv, BType sourceType, JType targetType) {\n+\n+        if (targetType.jTag == JTypeTags.JBYTE) {\n+            generateCheckCastBToJByte(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JCHAR) {\n+            generateCheckCastBToJChar(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JSHORT) {\n+            generateCheckCastBToJShort(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JINT) {\n+            generateCheckCastBToJInt(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JLONG) {\n+            generateCheckCastBToJLong(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JFLOAT) {\n+            generateCheckCastBToJFloat(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JDOUBLE) {\n+            generateCheckCastBToJDouble(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JREF) {\n+            if (((JType.JRefType) targetType).typeValue.equals(B_STRING_VALUE)) {\n+                generateCheckCastBToJString(mv, sourceType);\n+            } else {\n+                generateCheckCastBToJRef(mv, sourceType, targetType);\n+            }\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JARRAY) {\n+            generateCheckCastBToJRef(mv, sourceType, targetType);\n+            return;\n+        } else {\n+            throw new BLangCompilerException(String.format(\"Casting is not supported from '%s' to 'java %s'\",\n+                    sourceType, targetType));\n+        }\n+    }\n+\n+    private static void generateCheckCastBToJString(MethodVisitor mv, BType sourceType) {\n+\n+        if (sourceType.tag == TypeTags.STRING) {\n+            mv.visitMethodInsn(INVOKESTATIC, STRING_UTILS, \"fromString\",\n+                    String.format(\"(L%s;)L%s;\", STRING_VALUE, B_STRING_VALUE), false);\n+        } else {\n+            throw new BLangCompilerException(String.format(\"Casting is not supported from '%s' to 'java byte'\",\n+                    sourceType));\n+        }\n+    }\n+\n+    private static void generateCheckCastBToJByte(MethodVisitor mv, BType sourceType) {\n+\n+        if (sourceType.tag == TypeTags.BYTE) {\n+            // do nothing\n+        } else if (sourceType.tag == TypeTags.INT) {\n+            mv.visitInsn(L2I);\n+            mv.visitInsn(I2B);\n+        } else if (sourceType.tag == TypeTags.FLOAT) {\n+            mv.visitInsn(D2I);\n+            mv.visitInsn(I2B);\n+        } else if (sourceType.tag == TypeTags.HANDLE) {\n+            mv.visitMethodInsn(INVOKEVIRTUAL, HANDLE_VALUE, \"getValue\", \"()Ljava/lang/Object;\", false);\n+        } else if (sourceType.tag == TypeTags.FINITE) {\n+            mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, \"anyToByte\", String.format(\"(L%s;)I\", OBJECT), false);\n+            mv.visitInsn(I2B);\n+        } else {\n+            throw new BLangCompilerException(String.format(\"Casting is not supported from '%s' to 'java byte'\",\n+                    sourceType));\n+        }\n+    }\n+\n+    private static void generateCheckCastBToJChar(MethodVisitor mv, BType sourceType) {\n+\n+        if (sourceType.tag == TypeTags.BYTE) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82df207efdc85acd9646a1aae1461f7d1f7bbc5f"}, "originalPosition": 187}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMDI0MTA0OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/codegen/JvmCastGen.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwMzo1Njo1NVrOFxfSWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwODoyNjo1M1rOFxjy9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQzNzE0Nw==", "bodyText": "Shall we use constants for the hardcoded values in all places?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21435#discussion_r387437147", "createdAt": "2020-03-04T03:56:55Z", "author": {"login": "riyafa"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/codegen/JvmCastGen.java", "diffHunk": "@@ -0,0 +1,1096 @@\n+/*\n+ *  Copyright (c) 2018, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.wso2.ballerinalang.compiler.bir.codegen;\n+\n+import org.ballerinalang.compiler.BLangCompilerException;\n+import org.objectweb.asm.Label;\n+import org.objectweb.asm.MethodVisitor;\n+import org.wso2.ballerinalang.compiler.bir.codegen.JvmMethodGen.BalToJVMIndexMap;\n+import org.wso2.ballerinalang.compiler.bir.codegen.interop.JType;\n+import org.wso2.ballerinalang.compiler.bir.codegen.interop.JTypeTags;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRVariableDcl;\n+import org.wso2.ballerinalang.compiler.bir.model.VarKind;\n+import org.wso2.ballerinalang.compiler.bir.model.VarScope;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BFiniteType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BMapType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BUnionType;\n+import org.wso2.ballerinalang.compiler.util.Name;\n+import org.wso2.ballerinalang.compiler.util.TypeTags;\n+\n+import static org.objectweb.asm.Opcodes.ALOAD;\n+import static org.objectweb.asm.Opcodes.ASTORE;\n+import static org.objectweb.asm.Opcodes.CHECKCAST;\n+import static org.objectweb.asm.Opcodes.D2F;\n+import static org.objectweb.asm.Opcodes.D2I;\n+import static org.objectweb.asm.Opcodes.D2L;\n+import static org.objectweb.asm.Opcodes.DUP;\n+import static org.objectweb.asm.Opcodes.F2D;\n+import static org.objectweb.asm.Opcodes.I2B;\n+import static org.objectweb.asm.Opcodes.I2C;\n+import static org.objectweb.asm.Opcodes.I2D;\n+import static org.objectweb.asm.Opcodes.I2F;\n+import static org.objectweb.asm.Opcodes.I2L;\n+import static org.objectweb.asm.Opcodes.I2S;\n+import static org.objectweb.asm.Opcodes.IFNE;\n+import static org.objectweb.asm.Opcodes.IFNULL;\n+import static org.objectweb.asm.Opcodes.INSTANCEOF;\n+import static org.objectweb.asm.Opcodes.INVOKEINTERFACE;\n+import static org.objectweb.asm.Opcodes.INVOKESPECIAL;\n+import static org.objectweb.asm.Opcodes.INVOKESTATIC;\n+import static org.objectweb.asm.Opcodes.INVOKEVIRTUAL;\n+import static org.objectweb.asm.Opcodes.L2D;\n+import static org.objectweb.asm.Opcodes.L2F;\n+import static org.objectweb.asm.Opcodes.L2I;\n+import static org.objectweb.asm.Opcodes.NEW;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.ARRAY_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BHANDLE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BOOLEAN_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BTYPE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.DECIMAL_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.DOUBLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.ERROR_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.FUNCTION_POINTER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.FUTURE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.HANDLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.INT_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.LONG_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.MAP_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.NUMBER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.OBJECT;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.OBJECT_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.REF_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.SIMPLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STREAM_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STRING_UTILS;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STRING_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TABLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TYPEDESC_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TYPE_CHECKER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TYPE_CONVERTER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.XML_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmInstructionGen.B_STRING_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmInstructionGen.I_STRING_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmInstructionGen.addBoxInsn;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmLabelGen.LabelGenerator;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmPackageGen.symbolTable;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmTypeGen.loadType;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.interop.InteropMethodGen.getSignatureForJType;\n+\n+/**\n+ * Check cast methods generation for JVM bytecode generation.\n+ *\n+ * @since 1.2.0\n+ */\n+public class JvmCastGen {\n+\n+    static void generatePlatformCheckCast(MethodVisitor mv, BalToJVMIndexMap indexMap, BType sourceType,\n+                                          BType targetType) {\n+\n+        if (sourceType.tag == JTypeTags.JTYPE) {\n+            // If a target type is bir type, then we can guarantee source type is a jvm type, hence the cast\n+            generateJToBCheckCast(mv, indexMap, (JType) sourceType, targetType);\n+        } else {\n+            // else target type is jvm and source type is bir\n+            generateBToJCheckCast(mv, sourceType, (JType) targetType);\n+        }\n+    }\n+\n+    public static void generateBToJCheckCast(MethodVisitor mv, BType sourceType, JType targetType) {\n+\n+        if (targetType.jTag == JTypeTags.JBYTE) {\n+            generateCheckCastBToJByte(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JCHAR) {\n+            generateCheckCastBToJChar(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JSHORT) {\n+            generateCheckCastBToJShort(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JINT) {\n+            generateCheckCastBToJInt(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JLONG) {\n+            generateCheckCastBToJLong(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JFLOAT) {\n+            generateCheckCastBToJFloat(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JDOUBLE) {\n+            generateCheckCastBToJDouble(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JREF) {\n+            if (((JType.JRefType) targetType).typeValue.equals(B_STRING_VALUE)) {\n+                generateCheckCastBToJString(mv, sourceType);\n+            } else {\n+                generateCheckCastBToJRef(mv, sourceType, targetType);\n+            }\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JARRAY) {\n+            generateCheckCastBToJRef(mv, sourceType, targetType);\n+            return;\n+        } else {\n+            throw new BLangCompilerException(String.format(\"Casting is not supported from '%s' to 'java %s'\",\n+                    sourceType, targetType));\n+        }\n+    }\n+\n+    private static void generateCheckCastBToJString(MethodVisitor mv, BType sourceType) {\n+\n+        if (sourceType.tag == TypeTags.STRING) {\n+            mv.visitMethodInsn(INVOKESTATIC, STRING_UTILS, \"fromString\",\n+                    String.format(\"(L%s;)L%s;\", STRING_VALUE, B_STRING_VALUE), false);\n+        } else {\n+            throw new BLangCompilerException(String.format(\"Casting is not supported from '%s' to 'java byte'\",\n+                    sourceType));\n+        }\n+    }\n+\n+    private static void generateCheckCastBToJByte(MethodVisitor mv, BType sourceType) {\n+\n+        if (sourceType.tag == TypeTags.BYTE) {\n+            // do nothing\n+        } else if (sourceType.tag == TypeTags.INT) {\n+            mv.visitInsn(L2I);\n+            mv.visitInsn(I2B);\n+        } else if (sourceType.tag == TypeTags.FLOAT) {\n+            mv.visitInsn(D2I);\n+            mv.visitInsn(I2B);\n+        } else if (sourceType.tag == TypeTags.HANDLE) {\n+            mv.visitMethodInsn(INVOKEVIRTUAL, HANDLE_VALUE, \"getValue\", \"()Ljava/lang/Object;\", false);\n+        } else if (sourceType.tag == TypeTags.FINITE) {\n+            mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, \"anyToByte\", String.format(\"(L%s;)I\", OBJECT), false);\n+            mv.visitInsn(I2B);\n+        } else {\n+            throw new BLangCompilerException(String.format(\"Casting is not supported from '%s' to 'java byte'\",\n+                    sourceType));\n+        }\n+    }\n+\n+    private static void generateCheckCastBToJChar(MethodVisitor mv, BType sourceType) {\n+\n+        if (sourceType.tag == TypeTags.BYTE) {\n+            mv.visitInsn(I2C);\n+        } else if (sourceType.tag == TypeTags.INT) {\n+            mv.visitInsn(L2I);\n+            mv.visitInsn(I2C);\n+        } else if (sourceType.tag == TypeTags.FLOAT) {\n+            mv.visitInsn(D2I);\n+            mv.visitInsn(I2C);\n+        } else if (sourceType.tag == TypeTags.HANDLE) {\n+            mv.visitMethodInsn(INVOKEVIRTUAL, HANDLE_VALUE, \"getValue\", \"()Ljava/lang/Object;\", false);\n+        } else if (sourceType.tag == TypeTags.FINITE) {\n+            mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, \"anyToInt\", String.format(\"(L%s;)J\", OBJECT), false);\n+            mv.visitInsn(L2I);\n+            mv.visitInsn(I2C);\n+        } else {\n+            throw new BLangCompilerException(String.format(\"Casting is not supported from '%s' to 'java char'\",\n+                    sourceType));\n+        }\n+    }\n+\n+    private static void generateCheckCastBToJShort(MethodVisitor mv, BType sourceType) {\n+\n+        if (sourceType.tag == TypeTags.BYTE) {\n+            mv.visitInsn(I2S);\n+        } else if (sourceType.tag == TypeTags.INT) {\n+            mv.visitInsn(L2I);\n+            mv.visitInsn(I2S);\n+        } else if (sourceType.tag == TypeTags.FLOAT) {\n+            mv.visitInsn(D2I);\n+            mv.visitInsn(I2S);\n+        } else if (sourceType.tag == TypeTags.HANDLE) {\n+            mv.visitMethodInsn(INVOKEVIRTUAL, HANDLE_VALUE, \"getValue\", \"()Ljava/lang/Object;\", false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82df207efdc85acd9646a1aae1461f7d1f7bbc5f"}, "originalPosition": 218}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ0NTQ1Ng==", "bodyText": "why?, I personally find it easier to read when I can see the value.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21435#discussion_r387445456", "createdAt": "2020-03-04T04:39:26Z", "author": {"login": "manuranga"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/codegen/JvmCastGen.java", "diffHunk": "@@ -0,0 +1,1096 @@\n+/*\n+ *  Copyright (c) 2018, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.wso2.ballerinalang.compiler.bir.codegen;\n+\n+import org.ballerinalang.compiler.BLangCompilerException;\n+import org.objectweb.asm.Label;\n+import org.objectweb.asm.MethodVisitor;\n+import org.wso2.ballerinalang.compiler.bir.codegen.JvmMethodGen.BalToJVMIndexMap;\n+import org.wso2.ballerinalang.compiler.bir.codegen.interop.JType;\n+import org.wso2.ballerinalang.compiler.bir.codegen.interop.JTypeTags;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRVariableDcl;\n+import org.wso2.ballerinalang.compiler.bir.model.VarKind;\n+import org.wso2.ballerinalang.compiler.bir.model.VarScope;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BFiniteType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BMapType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BUnionType;\n+import org.wso2.ballerinalang.compiler.util.Name;\n+import org.wso2.ballerinalang.compiler.util.TypeTags;\n+\n+import static org.objectweb.asm.Opcodes.ALOAD;\n+import static org.objectweb.asm.Opcodes.ASTORE;\n+import static org.objectweb.asm.Opcodes.CHECKCAST;\n+import static org.objectweb.asm.Opcodes.D2F;\n+import static org.objectweb.asm.Opcodes.D2I;\n+import static org.objectweb.asm.Opcodes.D2L;\n+import static org.objectweb.asm.Opcodes.DUP;\n+import static org.objectweb.asm.Opcodes.F2D;\n+import static org.objectweb.asm.Opcodes.I2B;\n+import static org.objectweb.asm.Opcodes.I2C;\n+import static org.objectweb.asm.Opcodes.I2D;\n+import static org.objectweb.asm.Opcodes.I2F;\n+import static org.objectweb.asm.Opcodes.I2L;\n+import static org.objectweb.asm.Opcodes.I2S;\n+import static org.objectweb.asm.Opcodes.IFNE;\n+import static org.objectweb.asm.Opcodes.IFNULL;\n+import static org.objectweb.asm.Opcodes.INSTANCEOF;\n+import static org.objectweb.asm.Opcodes.INVOKEINTERFACE;\n+import static org.objectweb.asm.Opcodes.INVOKESPECIAL;\n+import static org.objectweb.asm.Opcodes.INVOKESTATIC;\n+import static org.objectweb.asm.Opcodes.INVOKEVIRTUAL;\n+import static org.objectweb.asm.Opcodes.L2D;\n+import static org.objectweb.asm.Opcodes.L2F;\n+import static org.objectweb.asm.Opcodes.L2I;\n+import static org.objectweb.asm.Opcodes.NEW;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.ARRAY_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BHANDLE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BOOLEAN_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BTYPE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.DECIMAL_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.DOUBLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.ERROR_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.FUNCTION_POINTER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.FUTURE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.HANDLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.INT_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.LONG_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.MAP_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.NUMBER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.OBJECT;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.OBJECT_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.REF_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.SIMPLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STREAM_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STRING_UTILS;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STRING_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TABLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TYPEDESC_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TYPE_CHECKER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TYPE_CONVERTER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.XML_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmInstructionGen.B_STRING_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmInstructionGen.I_STRING_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmInstructionGen.addBoxInsn;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmLabelGen.LabelGenerator;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmPackageGen.symbolTable;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmTypeGen.loadType;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.interop.InteropMethodGen.getSignatureForJType;\n+\n+/**\n+ * Check cast methods generation for JVM bytecode generation.\n+ *\n+ * @since 1.2.0\n+ */\n+public class JvmCastGen {\n+\n+    static void generatePlatformCheckCast(MethodVisitor mv, BalToJVMIndexMap indexMap, BType sourceType,\n+                                          BType targetType) {\n+\n+        if (sourceType.tag == JTypeTags.JTYPE) {\n+            // If a target type is bir type, then we can guarantee source type is a jvm type, hence the cast\n+            generateJToBCheckCast(mv, indexMap, (JType) sourceType, targetType);\n+        } else {\n+            // else target type is jvm and source type is bir\n+            generateBToJCheckCast(mv, sourceType, (JType) targetType);\n+        }\n+    }\n+\n+    public static void generateBToJCheckCast(MethodVisitor mv, BType sourceType, JType targetType) {\n+\n+        if (targetType.jTag == JTypeTags.JBYTE) {\n+            generateCheckCastBToJByte(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JCHAR) {\n+            generateCheckCastBToJChar(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JSHORT) {\n+            generateCheckCastBToJShort(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JINT) {\n+            generateCheckCastBToJInt(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JLONG) {\n+            generateCheckCastBToJLong(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JFLOAT) {\n+            generateCheckCastBToJFloat(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JDOUBLE) {\n+            generateCheckCastBToJDouble(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JREF) {\n+            if (((JType.JRefType) targetType).typeValue.equals(B_STRING_VALUE)) {\n+                generateCheckCastBToJString(mv, sourceType);\n+            } else {\n+                generateCheckCastBToJRef(mv, sourceType, targetType);\n+            }\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JARRAY) {\n+            generateCheckCastBToJRef(mv, sourceType, targetType);\n+            return;\n+        } else {\n+            throw new BLangCompilerException(String.format(\"Casting is not supported from '%s' to 'java %s'\",\n+                    sourceType, targetType));\n+        }\n+    }\n+\n+    private static void generateCheckCastBToJString(MethodVisitor mv, BType sourceType) {\n+\n+        if (sourceType.tag == TypeTags.STRING) {\n+            mv.visitMethodInsn(INVOKESTATIC, STRING_UTILS, \"fromString\",\n+                    String.format(\"(L%s;)L%s;\", STRING_VALUE, B_STRING_VALUE), false);\n+        } else {\n+            throw new BLangCompilerException(String.format(\"Casting is not supported from '%s' to 'java byte'\",\n+                    sourceType));\n+        }\n+    }\n+\n+    private static void generateCheckCastBToJByte(MethodVisitor mv, BType sourceType) {\n+\n+        if (sourceType.tag == TypeTags.BYTE) {\n+            // do nothing\n+        } else if (sourceType.tag == TypeTags.INT) {\n+            mv.visitInsn(L2I);\n+            mv.visitInsn(I2B);\n+        } else if (sourceType.tag == TypeTags.FLOAT) {\n+            mv.visitInsn(D2I);\n+            mv.visitInsn(I2B);\n+        } else if (sourceType.tag == TypeTags.HANDLE) {\n+            mv.visitMethodInsn(INVOKEVIRTUAL, HANDLE_VALUE, \"getValue\", \"()Ljava/lang/Object;\", false);\n+        } else if (sourceType.tag == TypeTags.FINITE) {\n+            mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, \"anyToByte\", String.format(\"(L%s;)I\", OBJECT), false);\n+            mv.visitInsn(I2B);\n+        } else {\n+            throw new BLangCompilerException(String.format(\"Casting is not supported from '%s' to 'java byte'\",\n+                    sourceType));\n+        }\n+    }\n+\n+    private static void generateCheckCastBToJChar(MethodVisitor mv, BType sourceType) {\n+\n+        if (sourceType.tag == TypeTags.BYTE) {\n+            mv.visitInsn(I2C);\n+        } else if (sourceType.tag == TypeTags.INT) {\n+            mv.visitInsn(L2I);\n+            mv.visitInsn(I2C);\n+        } else if (sourceType.tag == TypeTags.FLOAT) {\n+            mv.visitInsn(D2I);\n+            mv.visitInsn(I2C);\n+        } else if (sourceType.tag == TypeTags.HANDLE) {\n+            mv.visitMethodInsn(INVOKEVIRTUAL, HANDLE_VALUE, \"getValue\", \"()Ljava/lang/Object;\", false);\n+        } else if (sourceType.tag == TypeTags.FINITE) {\n+            mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, \"anyToInt\", String.format(\"(L%s;)J\", OBJECT), false);\n+            mv.visitInsn(L2I);\n+            mv.visitInsn(I2C);\n+        } else {\n+            throw new BLangCompilerException(String.format(\"Casting is not supported from '%s' to 'java char'\",\n+                    sourceType));\n+        }\n+    }\n+\n+    private static void generateCheckCastBToJShort(MethodVisitor mv, BType sourceType) {\n+\n+        if (sourceType.tag == TypeTags.BYTE) {\n+            mv.visitInsn(I2S);\n+        } else if (sourceType.tag == TypeTags.INT) {\n+            mv.visitInsn(L2I);\n+            mv.visitInsn(I2S);\n+        } else if (sourceType.tag == TypeTags.FLOAT) {\n+            mv.visitInsn(D2I);\n+            mv.visitInsn(I2S);\n+        } else if (sourceType.tag == TypeTags.HANDLE) {\n+            mv.visitMethodInsn(INVOKEVIRTUAL, HANDLE_VALUE, \"getValue\", \"()Ljava/lang/Object;\", false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQzNzE0Nw=="}, "originalCommit": {"oid": "82df207efdc85acd9646a1aae1461f7d1f7bbc5f"}, "originalPosition": 218}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ0NTg2Ng==", "bodyText": "If we change the name of the method in the future we would need to change only a constant instead of grepping to change all files which can create mistakes. It is a best practice to define method names as constants", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21435#discussion_r387445866", "createdAt": "2020-03-04T04:41:34Z", "author": {"login": "riyafa"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/codegen/JvmCastGen.java", "diffHunk": "@@ -0,0 +1,1096 @@\n+/*\n+ *  Copyright (c) 2018, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.wso2.ballerinalang.compiler.bir.codegen;\n+\n+import org.ballerinalang.compiler.BLangCompilerException;\n+import org.objectweb.asm.Label;\n+import org.objectweb.asm.MethodVisitor;\n+import org.wso2.ballerinalang.compiler.bir.codegen.JvmMethodGen.BalToJVMIndexMap;\n+import org.wso2.ballerinalang.compiler.bir.codegen.interop.JType;\n+import org.wso2.ballerinalang.compiler.bir.codegen.interop.JTypeTags;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRVariableDcl;\n+import org.wso2.ballerinalang.compiler.bir.model.VarKind;\n+import org.wso2.ballerinalang.compiler.bir.model.VarScope;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BFiniteType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BMapType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BUnionType;\n+import org.wso2.ballerinalang.compiler.util.Name;\n+import org.wso2.ballerinalang.compiler.util.TypeTags;\n+\n+import static org.objectweb.asm.Opcodes.ALOAD;\n+import static org.objectweb.asm.Opcodes.ASTORE;\n+import static org.objectweb.asm.Opcodes.CHECKCAST;\n+import static org.objectweb.asm.Opcodes.D2F;\n+import static org.objectweb.asm.Opcodes.D2I;\n+import static org.objectweb.asm.Opcodes.D2L;\n+import static org.objectweb.asm.Opcodes.DUP;\n+import static org.objectweb.asm.Opcodes.F2D;\n+import static org.objectweb.asm.Opcodes.I2B;\n+import static org.objectweb.asm.Opcodes.I2C;\n+import static org.objectweb.asm.Opcodes.I2D;\n+import static org.objectweb.asm.Opcodes.I2F;\n+import static org.objectweb.asm.Opcodes.I2L;\n+import static org.objectweb.asm.Opcodes.I2S;\n+import static org.objectweb.asm.Opcodes.IFNE;\n+import static org.objectweb.asm.Opcodes.IFNULL;\n+import static org.objectweb.asm.Opcodes.INSTANCEOF;\n+import static org.objectweb.asm.Opcodes.INVOKEINTERFACE;\n+import static org.objectweb.asm.Opcodes.INVOKESPECIAL;\n+import static org.objectweb.asm.Opcodes.INVOKESTATIC;\n+import static org.objectweb.asm.Opcodes.INVOKEVIRTUAL;\n+import static org.objectweb.asm.Opcodes.L2D;\n+import static org.objectweb.asm.Opcodes.L2F;\n+import static org.objectweb.asm.Opcodes.L2I;\n+import static org.objectweb.asm.Opcodes.NEW;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.ARRAY_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BHANDLE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BOOLEAN_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BTYPE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.DECIMAL_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.DOUBLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.ERROR_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.FUNCTION_POINTER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.FUTURE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.HANDLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.INT_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.LONG_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.MAP_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.NUMBER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.OBJECT;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.OBJECT_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.REF_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.SIMPLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STREAM_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STRING_UTILS;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STRING_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TABLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TYPEDESC_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TYPE_CHECKER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TYPE_CONVERTER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.XML_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmInstructionGen.B_STRING_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmInstructionGen.I_STRING_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmInstructionGen.addBoxInsn;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmLabelGen.LabelGenerator;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmPackageGen.symbolTable;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmTypeGen.loadType;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.interop.InteropMethodGen.getSignatureForJType;\n+\n+/**\n+ * Check cast methods generation for JVM bytecode generation.\n+ *\n+ * @since 1.2.0\n+ */\n+public class JvmCastGen {\n+\n+    static void generatePlatformCheckCast(MethodVisitor mv, BalToJVMIndexMap indexMap, BType sourceType,\n+                                          BType targetType) {\n+\n+        if (sourceType.tag == JTypeTags.JTYPE) {\n+            // If a target type is bir type, then we can guarantee source type is a jvm type, hence the cast\n+            generateJToBCheckCast(mv, indexMap, (JType) sourceType, targetType);\n+        } else {\n+            // else target type is jvm and source type is bir\n+            generateBToJCheckCast(mv, sourceType, (JType) targetType);\n+        }\n+    }\n+\n+    public static void generateBToJCheckCast(MethodVisitor mv, BType sourceType, JType targetType) {\n+\n+        if (targetType.jTag == JTypeTags.JBYTE) {\n+            generateCheckCastBToJByte(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JCHAR) {\n+            generateCheckCastBToJChar(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JSHORT) {\n+            generateCheckCastBToJShort(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JINT) {\n+            generateCheckCastBToJInt(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JLONG) {\n+            generateCheckCastBToJLong(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JFLOAT) {\n+            generateCheckCastBToJFloat(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JDOUBLE) {\n+            generateCheckCastBToJDouble(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JREF) {\n+            if (((JType.JRefType) targetType).typeValue.equals(B_STRING_VALUE)) {\n+                generateCheckCastBToJString(mv, sourceType);\n+            } else {\n+                generateCheckCastBToJRef(mv, sourceType, targetType);\n+            }\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JARRAY) {\n+            generateCheckCastBToJRef(mv, sourceType, targetType);\n+            return;\n+        } else {\n+            throw new BLangCompilerException(String.format(\"Casting is not supported from '%s' to 'java %s'\",\n+                    sourceType, targetType));\n+        }\n+    }\n+\n+    private static void generateCheckCastBToJString(MethodVisitor mv, BType sourceType) {\n+\n+        if (sourceType.tag == TypeTags.STRING) {\n+            mv.visitMethodInsn(INVOKESTATIC, STRING_UTILS, \"fromString\",\n+                    String.format(\"(L%s;)L%s;\", STRING_VALUE, B_STRING_VALUE), false);\n+        } else {\n+            throw new BLangCompilerException(String.format(\"Casting is not supported from '%s' to 'java byte'\",\n+                    sourceType));\n+        }\n+    }\n+\n+    private static void generateCheckCastBToJByte(MethodVisitor mv, BType sourceType) {\n+\n+        if (sourceType.tag == TypeTags.BYTE) {\n+            // do nothing\n+        } else if (sourceType.tag == TypeTags.INT) {\n+            mv.visitInsn(L2I);\n+            mv.visitInsn(I2B);\n+        } else if (sourceType.tag == TypeTags.FLOAT) {\n+            mv.visitInsn(D2I);\n+            mv.visitInsn(I2B);\n+        } else if (sourceType.tag == TypeTags.HANDLE) {\n+            mv.visitMethodInsn(INVOKEVIRTUAL, HANDLE_VALUE, \"getValue\", \"()Ljava/lang/Object;\", false);\n+        } else if (sourceType.tag == TypeTags.FINITE) {\n+            mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, \"anyToByte\", String.format(\"(L%s;)I\", OBJECT), false);\n+            mv.visitInsn(I2B);\n+        } else {\n+            throw new BLangCompilerException(String.format(\"Casting is not supported from '%s' to 'java byte'\",\n+                    sourceType));\n+        }\n+    }\n+\n+    private static void generateCheckCastBToJChar(MethodVisitor mv, BType sourceType) {\n+\n+        if (sourceType.tag == TypeTags.BYTE) {\n+            mv.visitInsn(I2C);\n+        } else if (sourceType.tag == TypeTags.INT) {\n+            mv.visitInsn(L2I);\n+            mv.visitInsn(I2C);\n+        } else if (sourceType.tag == TypeTags.FLOAT) {\n+            mv.visitInsn(D2I);\n+            mv.visitInsn(I2C);\n+        } else if (sourceType.tag == TypeTags.HANDLE) {\n+            mv.visitMethodInsn(INVOKEVIRTUAL, HANDLE_VALUE, \"getValue\", \"()Ljava/lang/Object;\", false);\n+        } else if (sourceType.tag == TypeTags.FINITE) {\n+            mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, \"anyToInt\", String.format(\"(L%s;)J\", OBJECT), false);\n+            mv.visitInsn(L2I);\n+            mv.visitInsn(I2C);\n+        } else {\n+            throw new BLangCompilerException(String.format(\"Casting is not supported from '%s' to 'java char'\",\n+                    sourceType));\n+        }\n+    }\n+\n+    private static void generateCheckCastBToJShort(MethodVisitor mv, BType sourceType) {\n+\n+        if (sourceType.tag == TypeTags.BYTE) {\n+            mv.visitInsn(I2S);\n+        } else if (sourceType.tag == TypeTags.INT) {\n+            mv.visitInsn(L2I);\n+            mv.visitInsn(I2S);\n+        } else if (sourceType.tag == TypeTags.FLOAT) {\n+            mv.visitInsn(D2I);\n+            mv.visitInsn(I2S);\n+        } else if (sourceType.tag == TypeTags.HANDLE) {\n+            mv.visitMethodInsn(INVOKEVIRTUAL, HANDLE_VALUE, \"getValue\", \"()Ljava/lang/Object;\", false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQzNzE0Nw=="}, "originalCommit": {"oid": "82df207efdc85acd9646a1aae1461f7d1f7bbc5f"}, "originalPosition": 218}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzUxMTAzMQ==", "bodyText": "Code is read more often than changed, so it better if its easier to read, not easier to modify. In my opinion you need to question the this kind of best practices than blindly trust them.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21435#discussion_r387511031", "createdAt": "2020-03-04T08:26:53Z", "author": {"login": "manuranga"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/codegen/JvmCastGen.java", "diffHunk": "@@ -0,0 +1,1096 @@\n+/*\n+ *  Copyright (c) 2018, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.wso2.ballerinalang.compiler.bir.codegen;\n+\n+import org.ballerinalang.compiler.BLangCompilerException;\n+import org.objectweb.asm.Label;\n+import org.objectweb.asm.MethodVisitor;\n+import org.wso2.ballerinalang.compiler.bir.codegen.JvmMethodGen.BalToJVMIndexMap;\n+import org.wso2.ballerinalang.compiler.bir.codegen.interop.JType;\n+import org.wso2.ballerinalang.compiler.bir.codegen.interop.JTypeTags;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRVariableDcl;\n+import org.wso2.ballerinalang.compiler.bir.model.VarKind;\n+import org.wso2.ballerinalang.compiler.bir.model.VarScope;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BFiniteType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BMapType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BUnionType;\n+import org.wso2.ballerinalang.compiler.util.Name;\n+import org.wso2.ballerinalang.compiler.util.TypeTags;\n+\n+import static org.objectweb.asm.Opcodes.ALOAD;\n+import static org.objectweb.asm.Opcodes.ASTORE;\n+import static org.objectweb.asm.Opcodes.CHECKCAST;\n+import static org.objectweb.asm.Opcodes.D2F;\n+import static org.objectweb.asm.Opcodes.D2I;\n+import static org.objectweb.asm.Opcodes.D2L;\n+import static org.objectweb.asm.Opcodes.DUP;\n+import static org.objectweb.asm.Opcodes.F2D;\n+import static org.objectweb.asm.Opcodes.I2B;\n+import static org.objectweb.asm.Opcodes.I2C;\n+import static org.objectweb.asm.Opcodes.I2D;\n+import static org.objectweb.asm.Opcodes.I2F;\n+import static org.objectweb.asm.Opcodes.I2L;\n+import static org.objectweb.asm.Opcodes.I2S;\n+import static org.objectweb.asm.Opcodes.IFNE;\n+import static org.objectweb.asm.Opcodes.IFNULL;\n+import static org.objectweb.asm.Opcodes.INSTANCEOF;\n+import static org.objectweb.asm.Opcodes.INVOKEINTERFACE;\n+import static org.objectweb.asm.Opcodes.INVOKESPECIAL;\n+import static org.objectweb.asm.Opcodes.INVOKESTATIC;\n+import static org.objectweb.asm.Opcodes.INVOKEVIRTUAL;\n+import static org.objectweb.asm.Opcodes.L2D;\n+import static org.objectweb.asm.Opcodes.L2F;\n+import static org.objectweb.asm.Opcodes.L2I;\n+import static org.objectweb.asm.Opcodes.NEW;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.ARRAY_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BHANDLE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BOOLEAN_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BTYPE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.DECIMAL_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.DOUBLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.ERROR_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.FUNCTION_POINTER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.FUTURE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.HANDLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.INT_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.LONG_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.MAP_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.NUMBER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.OBJECT;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.OBJECT_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.REF_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.SIMPLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STREAM_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STRING_UTILS;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STRING_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TABLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TYPEDESC_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TYPE_CHECKER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TYPE_CONVERTER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.XML_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmInstructionGen.B_STRING_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmInstructionGen.I_STRING_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmInstructionGen.addBoxInsn;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmLabelGen.LabelGenerator;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmPackageGen.symbolTable;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmTypeGen.loadType;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.interop.InteropMethodGen.getSignatureForJType;\n+\n+/**\n+ * Check cast methods generation for JVM bytecode generation.\n+ *\n+ * @since 1.2.0\n+ */\n+public class JvmCastGen {\n+\n+    static void generatePlatformCheckCast(MethodVisitor mv, BalToJVMIndexMap indexMap, BType sourceType,\n+                                          BType targetType) {\n+\n+        if (sourceType.tag == JTypeTags.JTYPE) {\n+            // If a target type is bir type, then we can guarantee source type is a jvm type, hence the cast\n+            generateJToBCheckCast(mv, indexMap, (JType) sourceType, targetType);\n+        } else {\n+            // else target type is jvm and source type is bir\n+            generateBToJCheckCast(mv, sourceType, (JType) targetType);\n+        }\n+    }\n+\n+    public static void generateBToJCheckCast(MethodVisitor mv, BType sourceType, JType targetType) {\n+\n+        if (targetType.jTag == JTypeTags.JBYTE) {\n+            generateCheckCastBToJByte(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JCHAR) {\n+            generateCheckCastBToJChar(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JSHORT) {\n+            generateCheckCastBToJShort(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JINT) {\n+            generateCheckCastBToJInt(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JLONG) {\n+            generateCheckCastBToJLong(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JFLOAT) {\n+            generateCheckCastBToJFloat(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JDOUBLE) {\n+            generateCheckCastBToJDouble(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JREF) {\n+            if (((JType.JRefType) targetType).typeValue.equals(B_STRING_VALUE)) {\n+                generateCheckCastBToJString(mv, sourceType);\n+            } else {\n+                generateCheckCastBToJRef(mv, sourceType, targetType);\n+            }\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JARRAY) {\n+            generateCheckCastBToJRef(mv, sourceType, targetType);\n+            return;\n+        } else {\n+            throw new BLangCompilerException(String.format(\"Casting is not supported from '%s' to 'java %s'\",\n+                    sourceType, targetType));\n+        }\n+    }\n+\n+    private static void generateCheckCastBToJString(MethodVisitor mv, BType sourceType) {\n+\n+        if (sourceType.tag == TypeTags.STRING) {\n+            mv.visitMethodInsn(INVOKESTATIC, STRING_UTILS, \"fromString\",\n+                    String.format(\"(L%s;)L%s;\", STRING_VALUE, B_STRING_VALUE), false);\n+        } else {\n+            throw new BLangCompilerException(String.format(\"Casting is not supported from '%s' to 'java byte'\",\n+                    sourceType));\n+        }\n+    }\n+\n+    private static void generateCheckCastBToJByte(MethodVisitor mv, BType sourceType) {\n+\n+        if (sourceType.tag == TypeTags.BYTE) {\n+            // do nothing\n+        } else if (sourceType.tag == TypeTags.INT) {\n+            mv.visitInsn(L2I);\n+            mv.visitInsn(I2B);\n+        } else if (sourceType.tag == TypeTags.FLOAT) {\n+            mv.visitInsn(D2I);\n+            mv.visitInsn(I2B);\n+        } else if (sourceType.tag == TypeTags.HANDLE) {\n+            mv.visitMethodInsn(INVOKEVIRTUAL, HANDLE_VALUE, \"getValue\", \"()Ljava/lang/Object;\", false);\n+        } else if (sourceType.tag == TypeTags.FINITE) {\n+            mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, \"anyToByte\", String.format(\"(L%s;)I\", OBJECT), false);\n+            mv.visitInsn(I2B);\n+        } else {\n+            throw new BLangCompilerException(String.format(\"Casting is not supported from '%s' to 'java byte'\",\n+                    sourceType));\n+        }\n+    }\n+\n+    private static void generateCheckCastBToJChar(MethodVisitor mv, BType sourceType) {\n+\n+        if (sourceType.tag == TypeTags.BYTE) {\n+            mv.visitInsn(I2C);\n+        } else if (sourceType.tag == TypeTags.INT) {\n+            mv.visitInsn(L2I);\n+            mv.visitInsn(I2C);\n+        } else if (sourceType.tag == TypeTags.FLOAT) {\n+            mv.visitInsn(D2I);\n+            mv.visitInsn(I2C);\n+        } else if (sourceType.tag == TypeTags.HANDLE) {\n+            mv.visitMethodInsn(INVOKEVIRTUAL, HANDLE_VALUE, \"getValue\", \"()Ljava/lang/Object;\", false);\n+        } else if (sourceType.tag == TypeTags.FINITE) {\n+            mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, \"anyToInt\", String.format(\"(L%s;)J\", OBJECT), false);\n+            mv.visitInsn(L2I);\n+            mv.visitInsn(I2C);\n+        } else {\n+            throw new BLangCompilerException(String.format(\"Casting is not supported from '%s' to 'java char'\",\n+                    sourceType));\n+        }\n+    }\n+\n+    private static void generateCheckCastBToJShort(MethodVisitor mv, BType sourceType) {\n+\n+        if (sourceType.tag == TypeTags.BYTE) {\n+            mv.visitInsn(I2S);\n+        } else if (sourceType.tag == TypeTags.INT) {\n+            mv.visitInsn(L2I);\n+            mv.visitInsn(I2S);\n+        } else if (sourceType.tag == TypeTags.FLOAT) {\n+            mv.visitInsn(D2I);\n+            mv.visitInsn(I2S);\n+        } else if (sourceType.tag == TypeTags.HANDLE) {\n+            mv.visitMethodInsn(INVOKEVIRTUAL, HANDLE_VALUE, \"getValue\", \"()Ljava/lang/Object;\", false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQzNzE0Nw=="}, "originalCommit": {"oid": "82df207efdc85acd9646a1aae1461f7d1f7bbc5f"}, "originalPosition": 218}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMDMzOTU1OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/BIRGen.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwNToxNTo0OFrOFxgPSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwNToxNTo0OFrOFxgPSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ1Mjc0NQ==", "bodyText": "This add(0, is used in multiple places. A new reader might not know what 0 signifies. If we define a constant for 0 it would add clarity.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21435#discussion_r387452745", "createdAt": "2020-03-04T05:15:48Z", "author": {"login": "riyafa"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/BIRGen.java", "diffHunk": "@@ -460,6 +461,7 @@ public void visit(BLangFunction astFunc) {\n         // Special %0 location for storing return values\n         birFunc.returnVariable = new BIRVariableDcl(astFunc.pos, astFunc.symbol.type.getReturnType(),\n                 this.env.nextLocalVarId(names), VarScope.FUNCTION, VarKind.RETURN, null);\n+        birFunc.localVars.add(0, birFunc.returnVariable);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82df207efdc85acd9646a1aae1461f7d1f7bbc5f"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMDM1NTM1OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/codegen/JvmCastGen.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwNToyNzoyNFrOFxgZFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwNToyNzoyNFrOFxgZFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ1NTI1Mw==", "bodyText": "Shall we remove commented out code in all places before merging?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21435#discussion_r387455253", "createdAt": "2020-03-04T05:27:24Z", "author": {"login": "riyafa"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/codegen/JvmCastGen.java", "diffHunk": "@@ -0,0 +1,1096 @@\n+/*\n+ *  Copyright (c) 2018, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.wso2.ballerinalang.compiler.bir.codegen;\n+\n+import org.ballerinalang.compiler.BLangCompilerException;\n+import org.objectweb.asm.Label;\n+import org.objectweb.asm.MethodVisitor;\n+import org.wso2.ballerinalang.compiler.bir.codegen.JvmMethodGen.BalToJVMIndexMap;\n+import org.wso2.ballerinalang.compiler.bir.codegen.interop.JType;\n+import org.wso2.ballerinalang.compiler.bir.codegen.interop.JTypeTags;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRVariableDcl;\n+import org.wso2.ballerinalang.compiler.bir.model.VarKind;\n+import org.wso2.ballerinalang.compiler.bir.model.VarScope;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BFiniteType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BMapType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BUnionType;\n+import org.wso2.ballerinalang.compiler.util.Name;\n+import org.wso2.ballerinalang.compiler.util.TypeTags;\n+\n+import static org.objectweb.asm.Opcodes.ALOAD;\n+import static org.objectweb.asm.Opcodes.ASTORE;\n+import static org.objectweb.asm.Opcodes.CHECKCAST;\n+import static org.objectweb.asm.Opcodes.D2F;\n+import static org.objectweb.asm.Opcodes.D2I;\n+import static org.objectweb.asm.Opcodes.D2L;\n+import static org.objectweb.asm.Opcodes.DUP;\n+import static org.objectweb.asm.Opcodes.F2D;\n+import static org.objectweb.asm.Opcodes.I2B;\n+import static org.objectweb.asm.Opcodes.I2C;\n+import static org.objectweb.asm.Opcodes.I2D;\n+import static org.objectweb.asm.Opcodes.I2F;\n+import static org.objectweb.asm.Opcodes.I2L;\n+import static org.objectweb.asm.Opcodes.I2S;\n+import static org.objectweb.asm.Opcodes.IFNE;\n+import static org.objectweb.asm.Opcodes.IFNULL;\n+import static org.objectweb.asm.Opcodes.INSTANCEOF;\n+import static org.objectweb.asm.Opcodes.INVOKEINTERFACE;\n+import static org.objectweb.asm.Opcodes.INVOKESPECIAL;\n+import static org.objectweb.asm.Opcodes.INVOKESTATIC;\n+import static org.objectweb.asm.Opcodes.INVOKEVIRTUAL;\n+import static org.objectweb.asm.Opcodes.L2D;\n+import static org.objectweb.asm.Opcodes.L2F;\n+import static org.objectweb.asm.Opcodes.L2I;\n+import static org.objectweb.asm.Opcodes.NEW;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.ARRAY_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BHANDLE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BOOLEAN_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BTYPE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.DECIMAL_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.DOUBLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.ERROR_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.FUNCTION_POINTER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.FUTURE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.HANDLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.INT_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.LONG_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.MAP_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.NUMBER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.OBJECT;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.OBJECT_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.REF_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.SIMPLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STREAM_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STRING_UTILS;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STRING_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TABLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TYPEDESC_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TYPE_CHECKER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TYPE_CONVERTER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.XML_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmInstructionGen.B_STRING_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmInstructionGen.I_STRING_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmInstructionGen.addBoxInsn;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmLabelGen.LabelGenerator;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmPackageGen.symbolTable;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmTypeGen.loadType;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.interop.InteropMethodGen.getSignatureForJType;\n+\n+/**\n+ * Check cast methods generation for JVM bytecode generation.\n+ *\n+ * @since 1.2.0\n+ */\n+public class JvmCastGen {\n+\n+    static void generatePlatformCheckCast(MethodVisitor mv, BalToJVMIndexMap indexMap, BType sourceType,\n+                                          BType targetType) {\n+\n+        if (sourceType.tag == JTypeTags.JTYPE) {\n+            // If a target type is bir type, then we can guarantee source type is a jvm type, hence the cast\n+            generateJToBCheckCast(mv, indexMap, (JType) sourceType, targetType);\n+        } else {\n+            // else target type is jvm and source type is bir\n+            generateBToJCheckCast(mv, sourceType, (JType) targetType);\n+        }\n+    }\n+\n+    public static void generateBToJCheckCast(MethodVisitor mv, BType sourceType, JType targetType) {\n+\n+        if (targetType.jTag == JTypeTags.JBYTE) {\n+            generateCheckCastBToJByte(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JCHAR) {\n+            generateCheckCastBToJChar(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JSHORT) {\n+            generateCheckCastBToJShort(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JINT) {\n+            generateCheckCastBToJInt(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JLONG) {\n+            generateCheckCastBToJLong(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JFLOAT) {\n+            generateCheckCastBToJFloat(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JDOUBLE) {\n+            generateCheckCastBToJDouble(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JREF) {\n+            if (((JType.JRefType) targetType).typeValue.equals(B_STRING_VALUE)) {\n+                generateCheckCastBToJString(mv, sourceType);\n+            } else {\n+                generateCheckCastBToJRef(mv, sourceType, targetType);\n+            }\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JARRAY) {\n+            generateCheckCastBToJRef(mv, sourceType, targetType);\n+            return;\n+        } else {\n+            throw new BLangCompilerException(String.format(\"Casting is not supported from '%s' to 'java %s'\",\n+                    sourceType, targetType));\n+        }\n+    }\n+\n+    private static void generateCheckCastBToJString(MethodVisitor mv, BType sourceType) {\n+\n+        if (sourceType.tag == TypeTags.STRING) {\n+            mv.visitMethodInsn(INVOKESTATIC, STRING_UTILS, \"fromString\",\n+                    String.format(\"(L%s;)L%s;\", STRING_VALUE, B_STRING_VALUE), false);\n+        } else {\n+            throw new BLangCompilerException(String.format(\"Casting is not supported from '%s' to 'java byte'\",\n+                    sourceType));\n+        }\n+    }\n+\n+    private static void generateCheckCastBToJByte(MethodVisitor mv, BType sourceType) {\n+\n+        if (sourceType.tag == TypeTags.BYTE) {\n+            // do nothing\n+        } else if (sourceType.tag == TypeTags.INT) {\n+            mv.visitInsn(L2I);\n+            mv.visitInsn(I2B);\n+        } else if (sourceType.tag == TypeTags.FLOAT) {\n+            mv.visitInsn(D2I);\n+            mv.visitInsn(I2B);\n+        } else if (sourceType.tag == TypeTags.HANDLE) {\n+            mv.visitMethodInsn(INVOKEVIRTUAL, HANDLE_VALUE, \"getValue\", \"()Ljava/lang/Object;\", false);\n+        } else if (sourceType.tag == TypeTags.FINITE) {\n+            mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, \"anyToByte\", String.format(\"(L%s;)I\", OBJECT), false);\n+            mv.visitInsn(I2B);\n+        } else {\n+            throw new BLangCompilerException(String.format(\"Casting is not supported from '%s' to 'java byte'\",\n+                    sourceType));\n+        }\n+    }\n+\n+    private static void generateCheckCastBToJChar(MethodVisitor mv, BType sourceType) {\n+\n+        if (sourceType.tag == TypeTags.BYTE) {\n+            mv.visitInsn(I2C);\n+        } else if (sourceType.tag == TypeTags.INT) {\n+            mv.visitInsn(L2I);\n+            mv.visitInsn(I2C);\n+        } else if (sourceType.tag == TypeTags.FLOAT) {\n+            mv.visitInsn(D2I);\n+            mv.visitInsn(I2C);\n+        } else if (sourceType.tag == TypeTags.HANDLE) {\n+            mv.visitMethodInsn(INVOKEVIRTUAL, HANDLE_VALUE, \"getValue\", \"()Ljava/lang/Object;\", false);\n+        } else if (sourceType.tag == TypeTags.FINITE) {\n+            mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, \"anyToInt\", String.format(\"(L%s;)J\", OBJECT), false);\n+            mv.visitInsn(L2I);\n+            mv.visitInsn(I2C);\n+        } else {\n+            throw new BLangCompilerException(String.format(\"Casting is not supported from '%s' to 'java char'\",\n+                    sourceType));\n+        }\n+    }\n+\n+    private static void generateCheckCastBToJShort(MethodVisitor mv, BType sourceType) {\n+\n+        if (sourceType.tag == TypeTags.BYTE) {\n+            mv.visitInsn(I2S);\n+        } else if (sourceType.tag == TypeTags.INT) {\n+            mv.visitInsn(L2I);\n+            mv.visitInsn(I2S);\n+        } else if (sourceType.tag == TypeTags.FLOAT) {\n+            mv.visitInsn(D2I);\n+            mv.visitInsn(I2S);\n+        } else if (sourceType.tag == TypeTags.HANDLE) {\n+            mv.visitMethodInsn(INVOKEVIRTUAL, HANDLE_VALUE, \"getValue\", \"()Ljava/lang/Object;\", false);\n+        } else if (sourceType.tag == TypeTags.FINITE) {\n+            mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, \"anyToInt\", String.format(\"(L%s;)J\", OBJECT), false);\n+            mv.visitInsn(L2I);\n+            mv.visitInsn(I2S);\n+        } else {\n+            throw new BLangCompilerException(String.format(\"Casting is not supported from '%s' to 'java short'\",\n+                    sourceType));\n+        }\n+    }\n+\n+    private static void generateCheckCastBToJInt(MethodVisitor mv, BType sourceType) {\n+\n+        if (sourceType.tag == TypeTags.BYTE) {\n+            // do nothing\n+        } else if (sourceType.tag == TypeTags.INT) {\n+            mv.visitInsn(L2I);\n+        } else if (sourceType.tag == TypeTags.FLOAT) {\n+            mv.visitInsn(D2I);\n+        } else if (sourceType.tag == TypeTags.HANDLE) {\n+            mv.visitMethodInsn(INVOKEVIRTUAL, HANDLE_VALUE, \"getValue\", \"()Ljava/lang/Object;\", false);\n+        } else if (sourceType.tag == TypeTags.FINITE) {\n+            mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, \"anyToInt\", String.format(\"(L%s;)J\", OBJECT), false);\n+            mv.visitInsn(L2I);\n+        } else {\n+            throw new BLangCompilerException(String.format(\"Casting is not supported from '%s' to 'java int'\",\n+                    sourceType));\n+        }\n+    }\n+\n+    private static void generateCheckCastBToJLong(MethodVisitor mv, BType sourceType) {\n+\n+        if (sourceType.tag == TypeTags.BYTE) {\n+            mv.visitInsn(I2L);\n+        } else if (sourceType.tag == TypeTags.INT) {\n+            // do nothing\n+        } else if (sourceType.tag == TypeTags.FLOAT) {\n+            mv.visitInsn(D2L);\n+        } else if (sourceType.tag == TypeTags.HANDLE) {\n+            mv.visitMethodInsn(INVOKEVIRTUAL, HANDLE_VALUE, \"getValue\", \"()Ljava/lang/Object;\", false);\n+        } else if (sourceType.tag == TypeTags.FINITE) {\n+            mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, \"anyToInt\", String.format(\"(L%s;)J\", OBJECT), false);\n+        } else {\n+            throw new BLangCompilerException(String.format(\"Casting is not supported from '%s' to 'java long'\",\n+                    sourceType));\n+        }\n+    }\n+\n+    private static void generateCheckCastBToJFloat(MethodVisitor mv, BType sourceType) {\n+\n+        if (sourceType.tag == TypeTags.BYTE) {\n+            mv.visitInsn(I2F);\n+        } else if (sourceType.tag == TypeTags.INT) {\n+            mv.visitInsn(L2F);\n+        } else if (sourceType.tag == TypeTags.FLOAT) {\n+            mv.visitInsn(D2F);\n+        } else if (sourceType.tag == TypeTags.HANDLE) {\n+            mv.visitMethodInsn(INVOKEVIRTUAL, HANDLE_VALUE, \"getValue\", \"()Ljava/lang/Object;\", false);\n+        } else if (sourceType.tag == TypeTags.FINITE) {\n+            mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, \"anyToFloat\", String.format(\"(L%s;)D\", OBJECT), false);\n+            mv.visitInsn(D2F);\n+        } else {\n+            throw new BLangCompilerException(String.format(\"Casting is not supported from '%s' to 'java float'\",\n+                    sourceType));\n+        }\n+    }\n+\n+    private static void generateCheckCastBToJDouble(MethodVisitor mv, BType sourceType) {\n+\n+        if (sourceType.tag == TypeTags.BYTE) {\n+            mv.visitInsn(I2D);\n+        } else if (sourceType.tag == TypeTags.INT) {\n+            mv.visitInsn(L2D);\n+        } else if (sourceType.tag == TypeTags.FLOAT) {\n+            // do nothing\n+        } else if (sourceType.tag == TypeTags.HANDLE) {\n+            mv.visitMethodInsn(INVOKEVIRTUAL, HANDLE_VALUE, \"getValue\", \"()Ljava/lang/Object;\", false);\n+        } else if (sourceType.tag == TypeTags.FINITE) {\n+            mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, \"anyToFloat\", String.format(\"(L%s;)D\", OBJECT), false);\n+        } else {\n+            throw new BLangCompilerException(String.format(\"Casting is not supported from '%s' to 'java double'\",\n+                    sourceType));\n+        }\n+    }\n+\n+    private static void generateCheckCastBToJRef(MethodVisitor mv, BType sourceType, JType targetType) {\n+\n+        if (sourceType.tag == TypeTags.HANDLE) {\n+            if (targetType.jTag == JTypeTags.JREF) {\n+                JType.JRefType jRefType = (JType.JRefType) targetType;\n+                if (jRefType.typeValue.equals(HANDLE_VALUE) || jRefType.typeValue.equals(BHANDLE)) {\n+                    // do nothing\n+                    return;\n+                }\n+            }\n+            mv.visitMethodInsn(INVOKEVIRTUAL, HANDLE_VALUE, \"getValue\", \"()Ljava/lang/Object;\", false);\n+            String sig = getSignatureForJType(targetType);\n+            mv.visitTypeInsn(CHECKCAST, sig);\n+        } else if (sourceType.tag == TypeTags.DECIMAL) {\n+            // do nothing\n+            return;\n+        } else {\n+            if (targetType.jTag == JTypeTags.JREF) {\n+                addBoxInsn(mv, sourceType);\n+                mv.visitTypeInsn(CHECKCAST, ((JType.JRefType) targetType).typeValue);\n+            } else {\n+                throw new BLangCompilerException(String.format(\"Casting is not supported from '%s' to '%s'\",\n+                        sourceType, targetType));\n+            }\n+        }\n+    }\n+\n+    private static void generateJToBCheckCast(MethodVisitor mv, BalToJVMIndexMap indexMap, JType sourceType,\n+                                              BType targetType) {\n+\n+        if (targetType.tag == TypeTags.INT) {\n+            generateCheckCastJToBInt(mv, sourceType);\n+            return;\n+        } else if (targetType.tag == TypeTags.FLOAT) {\n+            generateCheckCastJToBFloat(mv, sourceType);\n+            return;\n+        } else if (targetType.tag == TypeTags.STRING) {\n+            generateCheckCastJToBString(mv, sourceType);\n+            return;\n+        } else if (targetType.tag == TypeTags.DECIMAL) {\n+            generateCheckCastJToBDecimal(mv, sourceType);\n+            return;\n+        } else if (targetType.tag == TypeTags.BOOLEAN) {\n+            generateCheckCastJToBBoolean(mv, sourceType);\n+            return;\n+        } else if (targetType.tag == TypeTags.BYTE) {\n+            generateCheckCastJToBByte(mv, sourceType);\n+            return;\n+        } else if (targetType.tag == TypeTags.NIL) {\n+            // Do nothing\n+            return;\n+        } else {\n+            if (targetType.tag == TypeTags.UNION) {\n+                generateCheckCastJToBUnionType(mv, indexMap, sourceType, (BUnionType) targetType);\n+            } else if (targetType.tag == TypeTags.ANYDATA) {\n+                generateCheckCastJToBAnyData(mv, indexMap, sourceType);\n+            } else if (targetType.tag == TypeTags.HANDLE) {\n+                generateJCastToBHandle(mv, sourceType);\n+            } else if (targetType.tag == TypeTags.ANY) {\n+                generateJCastToBAny(mv, indexMap, sourceType, targetType);\n+            } else if (targetType.tag == TypeTags.JSON) {\n+                generateCheckCastJToBJSON(mv, indexMap, sourceType);\n+            } else if (targetType.tag == TypeTags.FINITE) {\n+                generateCheckCastJToBFiniteType(mv, indexMap, sourceType, targetType);\n+                // TODO fix below properly - rajith\n+                //} else if (sourceType is bir:BXMLType && targetType is bir:BMapType) {\n+                //    generateXMLToAttributesMap(mv, sourceType);\n+                //    return;\n+                //} else if (targetType is bir:BFiniteType) {\n+                //    generateCheckCastToFiniteType(mv, sourceType, targetType);\n+                //    return;\n+                //} else if (sourceType is bir:BRecordType && (targetType is bir:BMapType && targetType.constraint\n+                // is bir:BTypeAny)) {\n+                //    // do nothing", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82df207efdc85acd9646a1aae1461f7d1f7bbc5f"}, "originalPosition": 376}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMDM3NDQ2OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/codegen/JvmInstructionGen.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwNTo0MDozN1rOFxgk2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwNTo0MDozN1rOFxgk2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ1ODI2NA==", "bodyText": "Shall we fix these strange comments?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21435#discussion_r387458264", "createdAt": "2020-03-04T05:40:37Z", "author": {"login": "riyafa"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/codegen/JvmInstructionGen.java", "diffHunk": "@@ -0,0 +1,1698 @@\n+/*\n+ *  Copyright (c) 2018, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.wso2.ballerinalang.compiler.bir.codegen;\n+\n+import org.ballerinalang.compiler.BLangCompilerException;\n+import org.ballerinalang.model.elements.PackageID;\n+import org.objectweb.asm.Handle;\n+import org.objectweb.asm.Label;\n+import org.objectweb.asm.MethodVisitor;\n+import org.objectweb.asm.Opcodes;\n+import org.objectweb.asm.Type;\n+import org.wso2.ballerinalang.compiler.bir.codegen.interop.JInsKind;\n+import org.wso2.ballerinalang.compiler.bir.codegen.interop.JType;\n+import org.wso2.ballerinalang.compiler.bir.codegen.interop.JTypeTags;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRGlobalVariableDcl;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRPackage;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRVariableDcl;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLProcIns;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.UnaryOP;\n+import org.wso2.ballerinalang.compiler.bir.model.BIROperand;\n+import org.wso2.ballerinalang.compiler.bir.model.InstructionKind;\n+import org.wso2.ballerinalang.compiler.bir.model.VarKind;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BArrayType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BJSONType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BObjectType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BServiceType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BType;\n+import org.wso2.ballerinalang.compiler.util.TypeTags;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.objectweb.asm.Opcodes.ACONST_NULL;\n+import static org.objectweb.asm.Opcodes.ALOAD;\n+import static org.objectweb.asm.Opcodes.ASTORE;\n+import static org.objectweb.asm.Opcodes.BIPUSH;\n+import static org.objectweb.asm.Opcodes.CHECKCAST;\n+import static org.objectweb.asm.Opcodes.DADD;\n+import static org.objectweb.asm.Opcodes.DCMPL;\n+import static org.objectweb.asm.Opcodes.DDIV;\n+import static org.objectweb.asm.Opcodes.DLOAD;\n+import static org.objectweb.asm.Opcodes.DMUL;\n+import static org.objectweb.asm.Opcodes.DNEG;\n+import static org.objectweb.asm.Opcodes.DREM;\n+import static org.objectweb.asm.Opcodes.DSTORE;\n+import static org.objectweb.asm.Opcodes.DSUB;\n+import static org.objectweb.asm.Opcodes.DUP;\n+import static org.objectweb.asm.Opcodes.FLOAD;\n+import static org.objectweb.asm.Opcodes.FSTORE;\n+import static org.objectweb.asm.Opcodes.GETSTATIC;\n+import static org.objectweb.asm.Opcodes.GOTO;\n+import static org.objectweb.asm.Opcodes.I2B;\n+import static org.objectweb.asm.Opcodes.I2L;\n+import static org.objectweb.asm.Opcodes.IADD;\n+import static org.objectweb.asm.Opcodes.IAND;\n+import static org.objectweb.asm.Opcodes.IASTORE;\n+import static org.objectweb.asm.Opcodes.ICONST_0;\n+import static org.objectweb.asm.Opcodes.ICONST_1;\n+import static org.objectweb.asm.Opcodes.IFEQ;\n+import static org.objectweb.asm.Opcodes.IFGE;\n+import static org.objectweb.asm.Opcodes.IFGT;\n+import static org.objectweb.asm.Opcodes.IFLE;\n+import static org.objectweb.asm.Opcodes.IFLT;\n+import static org.objectweb.asm.Opcodes.IFNE;\n+import static org.objectweb.asm.Opcodes.IF_ICMPEQ;\n+import static org.objectweb.asm.Opcodes.IF_ICMPGE;\n+import static org.objectweb.asm.Opcodes.IF_ICMPGT;\n+import static org.objectweb.asm.Opcodes.IF_ICMPLE;\n+import static org.objectweb.asm.Opcodes.IF_ICMPLT;\n+import static org.objectweb.asm.Opcodes.IF_ICMPNE;\n+import static org.objectweb.asm.Opcodes.ILOAD;\n+import static org.objectweb.asm.Opcodes.INEG;\n+import static org.objectweb.asm.Opcodes.INVOKEINTERFACE;\n+import static org.objectweb.asm.Opcodes.INVOKESPECIAL;\n+import static org.objectweb.asm.Opcodes.INVOKESTATIC;\n+import static org.objectweb.asm.Opcodes.INVOKEVIRTUAL;\n+import static org.objectweb.asm.Opcodes.IOR;\n+import static org.objectweb.asm.Opcodes.ISHL;\n+import static org.objectweb.asm.Opcodes.ISHR;\n+import static org.objectweb.asm.Opcodes.ISTORE;\n+import static org.objectweb.asm.Opcodes.IUSHR;\n+import static org.objectweb.asm.Opcodes.IXOR;\n+import static org.objectweb.asm.Opcodes.L2I;\n+import static org.objectweb.asm.Opcodes.LADD;\n+import static org.objectweb.asm.Opcodes.LAND;\n+import static org.objectweb.asm.Opcodes.LCMP;\n+import static org.objectweb.asm.Opcodes.LLOAD;\n+import static org.objectweb.asm.Opcodes.LMUL;\n+import static org.objectweb.asm.Opcodes.LNEG;\n+import static org.objectweb.asm.Opcodes.LOR;\n+import static org.objectweb.asm.Opcodes.LSHL;\n+import static org.objectweb.asm.Opcodes.LSHR;\n+import static org.objectweb.asm.Opcodes.LSTORE;\n+import static org.objectweb.asm.Opcodes.LSUB;\n+import static org.objectweb.asm.Opcodes.LUSHR;\n+import static org.objectweb.asm.Opcodes.LXOR;\n+import static org.objectweb.asm.Opcodes.NEW;\n+import static org.objectweb.asm.Opcodes.NEWARRAY;\n+import static org.objectweb.asm.Opcodes.PUTSTATIC;\n+import static org.objectweb.asm.Opcodes.SWAP;\n+import static org.objectweb.asm.Opcodes.T_INT;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmCastGen.generateCast;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmCastGen.generateCheckCast;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmCastGen.generateCheckCastToByte;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmCastGen.generatePlatformCheckCast;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmCastGen.getTargetClass;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.ANNOTATION_MAP_NAME;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.ANNOTATION_UTILS;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.ARRAY_TYPE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.ARRAY_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.ARRAY_VALUE_IMPL;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BTYPE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BXML_QNAME;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.DECIMAL_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.ERROR_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.FUNCTION;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.FUNCTION_POINTER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.JSON_UTILS;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.LONG_STREAM;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.MAP_UTILS;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.MAP_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.MAP_VALUE_IMPL;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.MATH_UTILS;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.MODULE_INIT_CLASS_NAME;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.OBJECT;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.OBJECT_TYPE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.OBJECT_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STRAND;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STRING_UTILS;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STRING_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TABLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TUPLE_TYPE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TUPLE_VALUE_IMPL;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TYPEDESC_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TYPE_CHECKER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.XML_FACTORY;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.XML_QNAME;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.XML_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmMethodGen.BalToJVMIndexMap;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmPackageGen.currentClass;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmPackageGen.getPackageName;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmPackageGen.lambdaIndex;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmPackageGen.lambdas;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmPackageGen.lookupGlobalVarClassName;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmPackageGen.lookupTypeDef;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmPackageGen.symbolTable;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmTerminatorGen.TerminatorGenerator.toNameString;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmTypeGen.duplicateServiceTypeWithAnnots;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmTypeGen.getTypeDesc;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmTypeGen.loadExternalType;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmTypeGen.loadType;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmValueGen.getTypeValueClassName;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.interop.InteropMethodGen.JCast;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.interop.InteropMethodGen.JInstruction;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.BinaryOp;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.ConstantLoad;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.FPLoad;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.FieldAccess;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.IsLike;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.Move;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewArray;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewError;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewInstance;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewStringXMLQName;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewStructure;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewTable;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewTypeDesc;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLComment;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLElement;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLQName;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLText;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.TypeCast;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.TypeTest;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.XMLAccess;\n+\n+/**\n+ * BIR instructions to JVM byte code generation related methods.\n+ *\n+ * @since 1.2.0\n+ */\n+public class JvmInstructionGen {\n+\n+    public static final String I_STRING_VALUE = \"org/ballerinalang/jvm/values/StringValue\";\n+    public static final String B_STRING_VALUE = \"org/ballerinalang/jvm/values/api/BString\";\n+    public static final String BMP_STRING_VALUE = \"org/ballerinalang/jvm/values/BmpStringValue\";\n+    public static final String NON_BMP_STRING_VALUE = \"org/ballerinalang/jvm/values/NonBmpStringValue\";\n+    public static final boolean IS_BSTRING = (System.getProperty(\"ballerina.bstring\") != null &&\n+            !\"\".equals(System.getProperty(\"ballerina.bstring\")));\n+    public static final String BSTRING_VALUE = IS_BSTRING ? I_STRING_VALUE : STRING_VALUE;\n+\n+    static void addBoxInsn(MethodVisitor mv, @Nilable BType bType) {\n+\n+        if (bType == null) {\n+            return;\n+        } else {\n+            generateCast(mv, bType, symbolTable.anyType, false);\n+        }\n+    }\n+\n+    public static void addUnboxInsn(MethodVisitor mv, @Nilable BType bType, boolean useBString /* = false */) {\n+\n+        if (bType == null) {\n+            return;\n+        } else {\n+            generateCast(mv, symbolTable.anyType, bType, useBString);\n+        }\n+    }\n+\n+    static void addJUnboxInsn(MethodVisitor mv, @Nilable JType jType) {\n+\n+        if (jType == null) {\n+            return;\n+        } else if (jType.jTag == JTypeTags.JBYTE) {\n+            mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, \"anyToJByte\", String.format(\"(L%s;)B\", OBJECT), false);\n+        } else if (jType.jTag == JTypeTags.JCHAR) {\n+            mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, \"anyToJChar\", String.format(\"(L%s;)C\", OBJECT), false);\n+        } else if (jType.jTag == JTypeTags.JSHORT) {\n+            mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, \"anyToJShort\", String.format(\"(L%s;)S\", OBJECT), false);\n+        } else if (jType.jTag == JTypeTags.JINT) {\n+            mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, \"anyToJInt\", String.format(\"(L%s;)I\", OBJECT), false);\n+        } else if (jType.jTag == JTypeTags.JLONG) {\n+            mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, \"anyToJLong\", String.format(\"(L%s;)J\", OBJECT), false);\n+        } else if (jType.jTag == JTypeTags.JFLOAT) {\n+            mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, \"anyToJFloat\", String.format(\"(L%s;)F\", OBJECT), false);\n+        } else if (jType.jTag == JTypeTags.JDOUBLE) {\n+            mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, \"anyToJDouble\", String.format(\"(L%s;)D\", OBJECT), false);\n+        } else if (jType.jTag == JTypeTags.JBOOLEAN) {\n+            mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, \"anyToJBoolean\", String.format(\"(L%s;)Z\", OBJECT), false);\n+        } else if (jType.jTag == JTypeTags.JREF) {\n+            mv.visitTypeInsn(CHECKCAST, ((JType.JRefType) jType).typeValue);\n+            //} else {\n+            //    error err = error(io:sprintf(\"Unboxing is not supported for '%s'\", bType));\n+            //    panic err;\n+        }\n+    }\n+\n+    public static void generateVarLoad(MethodVisitor mv, BIRVariableDcl varDcl, String currentPackageName,\n+                                       int valueIndex) {\n+\n+        BType bType = varDcl.type;\n+\n+        if (varDcl.kind == VarKind.GLOBAL) {\n+            BIRGlobalVariableDcl globalVar = (BIRGlobalVariableDcl) varDcl;\n+            PackageID modId = globalVar.pkgId;\n+            String moduleName = getPackageName(modId.orgName, modId.name);\n+\n+            String varName = varDcl.name.value;\n+            String className = lookupGlobalVarClassName(moduleName, varName);\n+\n+            String typeSig = getTypeDesc(bType, false);\n+            mv.visitFieldInsn(GETSTATIC, className, varName, typeSig);\n+            return;\n+        } else if (varDcl.kind == VarKind.SELF) {\n+            mv.visitVarInsn(ALOAD, 0);\n+            return;\n+        } else if (varDcl.kind == VarKind.CONSTANT) {\n+            String varName = varDcl.name.value;\n+            PackageID moduleId = ((BIRGlobalVariableDcl) varDcl).pkgId;\n+            String pkgName = getPackageName(moduleId.orgName, moduleId.name);\n+            String className = lookupGlobalVarClassName(pkgName, varName);\n+            String typeSig = getTypeDesc(bType, false);\n+            mv.visitFieldInsn(GETSTATIC, className, varName, typeSig);\n+            return;\n+        }\n+\n+        if (bType.tag == TypeTags.INT) {\n+            mv.visitVarInsn(LLOAD, valueIndex);\n+        } else if (bType.tag == TypeTags.BYTE) {\n+            mv.visitVarInsn(ILOAD, valueIndex);\n+            mv.visitInsn(I2B);\n+            mv.visitMethodInsn(INVOKESTATIC, \"java/lang/Byte\", \"toUnsignedInt\", \"(B)I\", false);\n+        } else if (bType.tag == TypeTags.FLOAT) {\n+            mv.visitVarInsn(DLOAD, valueIndex);\n+        } else if (bType.tag == TypeTags.BOOLEAN) {\n+            mv.visitVarInsn(ILOAD, valueIndex);\n+        } else if (bType.tag == TypeTags.ARRAY ||\n+                bType.tag == TypeTags.STRING ||\n+                bType.tag == TypeTags.MAP ||\n+                bType.tag == TypeTags.TABLE ||\n+                bType.tag == TypeTags.STREAM ||\n+                bType.tag == TypeTags.ANY ||\n+                bType.tag == TypeTags.ANYDATA ||\n+                bType.tag == TypeTags.NIL ||\n+                bType.tag == TypeTags.UNION ||\n+                bType.tag == TypeTags.TUPLE ||\n+                bType.tag == TypeTags.RECORD ||\n+                bType.tag == TypeTags.ERROR ||\n+                bType.tag == TypeTags.JSON ||\n+                bType.tag == TypeTags.FUTURE ||\n+                bType.tag == TypeTags.OBJECT ||\n+                bType.tag == TypeTags.SERVICE ||\n+                bType.tag == TypeTags.DECIMAL ||\n+                bType.tag == TypeTags.XML ||\n+                bType.tag == TypeTags.INVOKABLE ||\n+                bType.tag == TypeTags.FINITE ||\n+                bType.tag == TypeTags.HANDLE ||\n+                bType.tag == TypeTags.TYPEDESC) {\n+            mv.visitVarInsn(ALOAD, valueIndex);\n+        } else if (bType.tag == JTypeTags.JTYPE) {\n+            generateJVarLoad(mv, (JType) bType, currentPackageName, valueIndex);\n+        } else {\n+            throw new BLangCompilerException(\"JVM generation is not supported for type \" + String.format(\"%s\", bType));\n+        }\n+    }\n+\n+    private static void generateJVarLoad(MethodVisitor mv, JType jType, String currentPackageName, int valueIndex) {\n+\n+        if (jType.jTag == JTypeTags.JBYTE) {\n+            mv.visitVarInsn(ILOAD, valueIndex);\n+        } else if (jType.jTag == JTypeTags.JCHAR) {\n+            mv.visitVarInsn(ILOAD, valueIndex);\n+        } else if (jType.jTag == JTypeTags.JSHORT) {\n+            mv.visitVarInsn(ILOAD, valueIndex);\n+        } else if (jType.jTag == JTypeTags.JINT) {\n+            mv.visitVarInsn(ILOAD, valueIndex);\n+        } else if (jType.jTag == JTypeTags.JLONG) {\n+            mv.visitVarInsn(LLOAD, valueIndex);\n+        } else if (jType.jTag == JTypeTags.JFLOAT) {\n+            mv.visitVarInsn(FLOAD, valueIndex);\n+        } else if (jType.jTag == JTypeTags.JDOUBLE) {\n+            mv.visitVarInsn(DLOAD, valueIndex);\n+        } else if (jType.jTag == JTypeTags.JBOOLEAN) {\n+            mv.visitVarInsn(ILOAD, valueIndex);\n+        } else if (jType.jTag == JTypeTags.JARRAY ||\n+                jType.jTag == JTypeTags.JREF) {\n+            mv.visitVarInsn(ALOAD, valueIndex);\n+        } else {\n+            throw new BLangCompilerException(\"JVM generation is not supported for type \" + String.format(\"%s\", jType));\n+        }\n+    }\n+\n+    public static void generateVarStore(MethodVisitor mv, BIRVariableDcl varDcl, String currentPackageName,\n+                                        int valueIndex) {\n+\n+        BType bType = varDcl.type;\n+\n+        if (varDcl.kind == VarKind.GLOBAL) {\n+            String varName = varDcl.name.value;\n+            String className = lookupGlobalVarClassName(currentPackageName, varName);\n+            String typeSig = getTypeDesc(bType, false);\n+            mv.visitFieldInsn(PUTSTATIC, className, varName, typeSig);\n+            return;\n+        } else if (varDcl.kind == VarKind.CONSTANT) {\n+            String varName = varDcl.name.value;\n+            PackageID moduleId = ((BIRGlobalVariableDcl) varDcl).pkgId;\n+            String pkgName = getPackageName(moduleId.orgName, moduleId.name);\n+            String className = lookupGlobalVarClassName(pkgName, varName);\n+            String typeSig = getTypeDesc(bType, false);\n+            mv.visitFieldInsn(PUTSTATIC, className, varName, typeSig);\n+            return;\n+        }\n+\n+        if (bType.tag == TypeTags.INT) {\n+            mv.visitVarInsn(LSTORE, valueIndex);\n+        } else if (bType.tag == TypeTags.BYTE) {\n+            mv.visitVarInsn(ISTORE, valueIndex);\n+        } else if (bType.tag == TypeTags.FLOAT) {\n+            mv.visitVarInsn(DSTORE, valueIndex);\n+        } else if (bType.tag == TypeTags.BOOLEAN) {\n+            mv.visitVarInsn(ISTORE, valueIndex);\n+        } else if (bType.tag == TypeTags.ARRAY ||\n+                bType.tag == TypeTags.STRING ||\n+                bType.tag == TypeTags.MAP ||\n+                bType.tag == TypeTags.TABLE ||\n+                bType.tag == TypeTags.STREAM ||\n+                bType.tag == TypeTags.ANY ||\n+                bType.tag == TypeTags.ANYDATA ||\n+                bType.tag == TypeTags.NIL ||\n+                bType.tag == TypeTags.UNION ||\n+                bType.tag == TypeTags.TUPLE ||\n+                bType.tag == TypeTags.DECIMAL ||\n+                bType.tag == TypeTags.RECORD ||\n+                bType.tag == TypeTags.ERROR ||\n+                bType.tag == TypeTags.JSON ||\n+                bType.tag == TypeTags.FUTURE ||\n+                bType.tag == TypeTags.OBJECT ||\n+                bType.tag == TypeTags.SERVICE ||\n+                bType.tag == TypeTags.XML ||\n+                bType.tag == TypeTags.INVOKABLE ||\n+                bType.tag == TypeTags.FINITE ||\n+                bType.tag == TypeTags.HANDLE ||\n+                bType.tag == TypeTags.TYPEDESC) {\n+            mv.visitVarInsn(ASTORE, valueIndex);\n+        } else if (bType.tag == JTypeTags.JTYPE) {\n+            generateJVarStore(mv, (JType) bType, currentPackageName, valueIndex);\n+        } else {\n+            throw new BLangCompilerException(\"JVM generation is not supported for type \" + String.format(\"%s\", bType));\n+        }\n+    }\n+\n+    private static void generateJVarStore(MethodVisitor mv, JType jType, String currentPackageName, int valueIndex) {\n+\n+        if (jType.jTag == JTypeTags.JBYTE) {\n+            mv.visitVarInsn(ISTORE, valueIndex);\n+        } else if (jType.jTag == JTypeTags.JCHAR) {\n+            mv.visitVarInsn(ISTORE, valueIndex);\n+        } else if (jType.jTag == JTypeTags.JSHORT) {\n+            mv.visitVarInsn(ISTORE, valueIndex);\n+        } else if (jType.jTag == JTypeTags.JINT) {\n+            mv.visitVarInsn(ISTORE, valueIndex);\n+        } else if (jType.jTag == JTypeTags.JLONG) {\n+            mv.visitVarInsn(LSTORE, valueIndex);\n+        } else if (jType.jTag == JTypeTags.JFLOAT) {\n+            mv.visitVarInsn(FSTORE, valueIndex);\n+        } else if (jType.jTag == JTypeTags.JDOUBLE) {\n+            mv.visitVarInsn(DSTORE, valueIndex);\n+        } else if (jType.jTag == JTypeTags.JBOOLEAN) {\n+            mv.visitVarInsn(ISTORE, valueIndex);\n+        } else if (jType.jTag == JTypeTags.JARRAY ||\n+                jType.jTag == JTypeTags.JREF) {\n+            mv.visitVarInsn(ASTORE, valueIndex);\n+        } else {\n+            throw new BLangCompilerException(\"JVM generation is not supported for type \" + String.format(\"%s\", jType));\n+        }\n+    }\n+\n+    /**\n+     * Instruction generator helper class to hold its enclosing pkg and index map.\n+     *\n+     * @since 1.2.0\n+     */\n+    public static class InstructionGenerator {\n+\n+        MethodVisitor mv;\n+        BalToJVMIndexMap indexMap;\n+        String currentPackageName;\n+        BIRPackage currentPackage;\n+\n+        public InstructionGenerator(MethodVisitor mv, BalToJVMIndexMap indexMap, BIRPackage currentPackage) {\n+\n+            this.mv = mv;\n+            this.indexMap = indexMap;\n+            this.currentPackage = currentPackage;\n+            this.currentPackageName = getPackageName(currentPackage.org.value, currentPackage.name.value);\n+        }\n+\n+        void generatePlatformIns(JInstruction ins) {\n+\n+            if (ins.jKind == JInsKind.JCAST) {\n+                JCast castIns = (JCast) ins;\n+                BType targetType = castIns.targetType;\n+                this.loadVar(castIns.rhsOp.variableDcl);\n+                generatePlatformCheckCast(this.mv, this.indexMap, castIns.rhsOp.variableDcl.type, targetType);\n+                this.storeToVar(castIns.lhsOp.variableDcl);\n+            }\n+        }\n+\n+        void generateMoveIns(Move moveIns) {\n+\n+            this.loadVar(moveIns.rhsOp.variableDcl);\n+            this.storeToVar(moveIns.lhsOp.variableDcl);\n+        }\n+\n+        void generateBinaryOpIns(BinaryOp binaryIns) {\n+\n+            InstructionKind insKind = binaryIns.kind;\n+            switch (insKind) {\n+                case ADD:\n+                    this.generateAddIns(binaryIns);\n+                    break;\n+                case SUB:\n+                    this.generateSubIns(binaryIns);\n+                    break;\n+                case MUL:\n+                    this.generateMulIns(binaryIns);\n+                    break;\n+                case DIV:\n+                    this.generateDivIns(binaryIns);\n+                    break;\n+                case MOD:\n+                    this.generateRemIns(binaryIns);\n+                    break;\n+                case EQUAL:\n+                    this.generateEqualIns(binaryIns);\n+                    break;\n+                case NOT_EQUAL:\n+                    this.generateNotEqualIns(binaryIns);\n+                    break;\n+                case GREATER_THAN:\n+                    this.generateGreaterThanIns(binaryIns);\n+                    break;\n+                case GREATER_EQUAL:\n+                    this.generateGreaterEqualIns(binaryIns);\n+                    break;\n+                case LESS_THAN:\n+                    this.generateLessThanIns(binaryIns);\n+                    break;\n+                case LESS_EQUAL:\n+                    this.generateLessEqualIns(binaryIns);\n+                    break;\n+                case REF_EQUAL:\n+                    this.generateRefEqualIns(binaryIns);\n+                    break;\n+                case REF_NOT_EQUAL:\n+                    this.generateRefNotEqualIns(binaryIns);\n+                    break;\n+                case CLOSED_RANGE:\n+                    this.generateClosedRangeIns(binaryIns);\n+                    break;\n+                case HALF_OPEN_RANGE:\n+                    this.generateClosedRangeIns(binaryIns);\n+                    break;\n+                case ANNOT_ACCESS:\n+                    this.generateAnnotAccessIns(binaryIns);\n+                    break;\n+                case BITWISE_AND:\n+                    this.generateBitwiseAndIns(binaryIns);\n+                    break;\n+                case BITWISE_OR:\n+                    this.generateBitwiseOrIns(binaryIns);\n+                    break;\n+                case BITWISE_XOR:\n+                    this.generateBitwiseXorIns(binaryIns);\n+                    break;\n+                case BITWISE_LEFT_SHIFT:\n+                    this.generateBitwiseLeftShiftIns(binaryIns);\n+                    break;\n+                case BITWISE_RIGHT_SHIFT:\n+                    this.generateBitwiseRightShiftIns(binaryIns);\n+                    break;\n+                case BITWISE_UNSIGNED_RIGHT_SHIFT:\n+                    this.generateBitwiseUnsignedRightShiftIns(binaryIns);\n+                    break;\n+                default:\n+                    throw new BLangCompilerException(\"JVM generation is not supported for instruction kind : \" +\n+                            String.format(\"%s\", insKind));\n+            }\n+        }\n+\n+        void generateBinaryRhsAndLhsLoad(BinaryOp binaryIns) {\n+\n+            this.loadVar(binaryIns.rhsOp1.variableDcl);\n+            this.loadVar(binaryIns.rhsOp2.variableDcl);\n+        }\n+\n+        private void generateLessThanIns(BinaryOp binaryIns) {\n+\n+            this.generateBinaryCompareIns(binaryIns, IFLT);\n+        }\n+\n+        private void generateGreaterThanIns(BinaryOp binaryIns) {\n+\n+            this.generateBinaryCompareIns(binaryIns, IFGT);\n+        }\n+\n+        private void generateLessEqualIns(BinaryOp binaryIns) {\n+\n+            this.generateBinaryCompareIns(binaryIns, IFLE);\n+\n+        }\n+\n+        private void generateGreaterEqualIns(BinaryOp binaryIns) {\n+\n+            this.generateBinaryCompareIns(binaryIns, IFGE);\n+        }\n+\n+        private void generateBinaryCompareIns(BinaryOp binaryIns, int opcode) {\n+\n+            if (opcode != IFLT && opcode != IFGT && opcode != IFLE && opcode != IFGE) {\n+                throw new BLangCompilerException(String.format(\"Unsupported opcode '%s' for binary operator.\", opcode));\n+            }\n+\n+            this.generateBinaryRhsAndLhsLoad(binaryIns);\n+            Label label1 = new Label();\n+            Label label2 = new Label();\n+\n+            BType lhsOpType = binaryIns.rhsOp1.variableDcl.type;\n+            BType rhsOpType = binaryIns.rhsOp2.variableDcl.type;\n+\n+            if (lhsOpType.tag == TypeTags.INT && rhsOpType.tag == TypeTags.INT) {\n+                this.mv.visitInsn(LCMP);\n+                this.mv.visitJumpInsn(opcode, label1);\n+            } else if (lhsOpType.tag == TypeTags.BYTE && rhsOpType.tag == TypeTags.BYTE) {\n+                if (opcode == IFLT) {\n+                    this.mv.visitJumpInsn(IF_ICMPLT, label1);\n+                } else if (opcode != IFGT) {\n+                    this.mv.visitJumpInsn(IF_ICMPGT, label1);\n+                } else if (opcode != IFLE) {\n+                    this.mv.visitJumpInsn(IF_ICMPLE, label1);\n+                } else if (opcode == IFGE) {\n+                    this.mv.visitJumpInsn(IF_ICMPGE, label1);\n+                }\n+            } else if (lhsOpType.tag == TypeTags.FLOAT && rhsOpType.tag == TypeTags.FLOAT) {\n+                this.mv.visitInsn(DCMPL);\n+                this.mv.visitJumpInsn(opcode, label1);\n+            } else if (lhsOpType.tag == TypeTags.DECIMAL && rhsOpType.tag == TypeTags.DECIMAL) {\n+                String compareFuncName = this.getDecimalCompareFuncName(opcode);\n+                this.mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, compareFuncName,\n+                        String.format(\"(L%s;L%s;)Z\", DECIMAL_VALUE, DECIMAL_VALUE), false);\n+                this.storeToVar(binaryIns.lhsOp.variableDcl);\n+                return;\n+            }\n+\n+            this.mv.visitInsn(ICONST_0);\n+            this.mv.visitJumpInsn(GOTO, label2);\n+\n+            this.mv.visitLabel(label1);\n+            this.mv.visitInsn(ICONST_1);\n+\n+            this.mv.visitLabel(label2);\n+            this.storeToVar(binaryIns.lhsOp.variableDcl);\n+        }\n+\n+        private String getDecimalCompareFuncName(int opcode) {\n+\n+            if (opcode == IFGT) {\n+                return \"checkDecimalGreaterThan\";\n+            } else if (opcode == IFGE) {\n+                return \"checkDecimalGreaterThanOrEqual\";\n+            } else if (opcode == IFLT) {\n+                return \"checkDecimalLessThan\";\n+            } else if (opcode == IFLE) {\n+                return \"checkDecimalLessThanOrEqual\";\n+            } else {\n+                throw new BLangCompilerException(String.format(\"Opcode: '%s' is not a comparison opcode.\", opcode));\n+            }\n+        }\n+\n+        void generateEqualIns(BinaryOp binaryIns) {\n+\n+            this.generateBinaryRhsAndLhsLoad(binaryIns);\n+\n+            Label label1 = new Label();\n+            Label label2 = new Label();\n+\n+            BType lhsOpType = binaryIns.rhsOp1.variableDcl.type;\n+            BType rhsOpType = binaryIns.rhsOp2.variableDcl.type;\n+\n+            if (lhsOpType.tag == TypeTags.INT && rhsOpType.tag == TypeTags.INT) {\n+                this.mv.visitInsn(LCMP);\n+                this.mv.visitJumpInsn(IFNE, label1);\n+            } else if (lhsOpType.tag == TypeTags.BYTE && rhsOpType.tag == TypeTags.BYTE) {\n+                this.mv.visitJumpInsn(IF_ICMPNE, label1);\n+            } else if (lhsOpType.tag == TypeTags.FLOAT && rhsOpType.tag == TypeTags.FLOAT) {\n+                this.mv.visitInsn(DCMPL);\n+                this.mv.visitJumpInsn(IFNE, label1);\n+            } else if (lhsOpType.tag == TypeTags.BOOLEAN && rhsOpType.tag == TypeTags.BOOLEAN) {\n+                this.mv.visitJumpInsn(IF_ICMPNE, label1);\n+            } else if (lhsOpType.tag == TypeTags.DECIMAL && rhsOpType.tag == TypeTags.DECIMAL) {\n+                this.mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, \"checkDecimalEqual\",\n+                        String.format(\"(L%s;L%s;)Z\", DECIMAL_VALUE, DECIMAL_VALUE), false);\n+                this.storeToVar(binaryIns.lhsOp.variableDcl);\n+                return;\n+            } else {\n+                this.mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, \"isEqual\",\n+                        String.format(\"(L%s;L%s;)Z\", OBJECT, OBJECT), false);\n+                this.storeToVar(binaryIns.lhsOp.variableDcl);\n+                return;\n+            }\n+\n+            this.mv.visitInsn(ICONST_1);\n+            this.mv.visitJumpInsn(GOTO, label2);\n+\n+            this.mv.visitLabel(label1);\n+            this.mv.visitInsn(ICONST_0);\n+\n+            this.mv.visitLabel(label2);\n+            this.storeToVar(binaryIns.lhsOp.variableDcl);\n+        }\n+\n+        void generateNotEqualIns(BinaryOp binaryIns) {\n+\n+            this.generateBinaryRhsAndLhsLoad(binaryIns);\n+\n+            Label label1 = new Label();\n+            Label label2 = new Label();\n+\n+            // It is assumed that both operands are of same type\n+            BType lhsOpType = binaryIns.rhsOp1.variableDcl.type;\n+            BType rhsOpType = binaryIns.rhsOp2.variableDcl.type;\n+            if (lhsOpType.tag == TypeTags.INT && rhsOpType.tag == TypeTags.INT) {\n+                this.mv.visitInsn(LCMP);\n+                this.mv.visitJumpInsn(IFEQ, label1);\n+            } else if (lhsOpType.tag == TypeTags.BYTE && rhsOpType.tag == TypeTags.BYTE) {\n+                this.mv.visitJumpInsn(IF_ICMPEQ, label1);\n+            } else if (lhsOpType.tag == TypeTags.FLOAT && rhsOpType.tag == TypeTags.FLOAT) {\n+                this.mv.visitInsn(DCMPL);\n+                this.mv.visitJumpInsn(IFEQ, label1);\n+            } else if (lhsOpType.tag == TypeTags.BOOLEAN && rhsOpType.tag == TypeTags.BOOLEAN) {\n+                this.mv.visitJumpInsn(IF_ICMPEQ, label1);\n+            } else if (lhsOpType.tag == TypeTags.DECIMAL && rhsOpType.tag == TypeTags.DECIMAL) {\n+                this.mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, \"checkDecimalEqual\",\n+                        String.format(\"(L%s;L%s;)Z\", DECIMAL_VALUE, DECIMAL_VALUE), false);\n+                this.mv.visitJumpInsn(IFNE, label1);\n+            } else {\n+                this.mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, \"isEqual\",\n+                        String.format(\"(L%s;L%s;)Z\", OBJECT, OBJECT), false);\n+                this.mv.visitJumpInsn(IFNE, label1);\n+            }\n+\n+            this.mv.visitInsn(ICONST_1);\n+            this.mv.visitJumpInsn(GOTO, label2);\n+\n+            this.mv.visitLabel(label1);\n+            this.mv.visitInsn(ICONST_0);\n+\n+            this.mv.visitLabel(label2);\n+            this.storeToVar(binaryIns.lhsOp.variableDcl);\n+        }\n+\n+        void generateRefEqualIns(BinaryOp binaryIns) {\n+\n+            this.generateBinaryRhsAndLhsLoad(binaryIns);\n+\n+            Label label1 = new Label();\n+            Label label2 = new Label();\n+\n+            BType lhsOpType = binaryIns.rhsOp1.variableDcl.type;\n+            BType rhsOpType = binaryIns.rhsOp2.variableDcl.type;\n+            if (lhsOpType.tag == TypeTags.INT && rhsOpType.tag == TypeTags.INT) {\n+                this.mv.visitInsn(LCMP);\n+                this.mv.visitJumpInsn(IFNE, label1);\n+            } else if (lhsOpType.tag == TypeTags.BYTE && rhsOpType.tag == TypeTags.BYTE) {\n+                this.mv.visitJumpInsn(IF_ICMPNE, label1);\n+            } else if (lhsOpType.tag == TypeTags.FLOAT && rhsOpType.tag == TypeTags.FLOAT) {\n+                this.mv.visitInsn(DCMPL);\n+                this.mv.visitJumpInsn(IFNE, label1);\n+            } else if (lhsOpType.tag == TypeTags.BOOLEAN && rhsOpType.tag == TypeTags.BOOLEAN) {\n+                this.mv.visitJumpInsn(IF_ICMPNE, label1);\n+            } else {\n+                this.mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, \"isReferenceEqual\",\n+                        String.format(\"(L%s;L%s;)Z\", OBJECT, OBJECT), false);\n+                this.storeToVar(binaryIns.lhsOp.variableDcl);\n+                return;\n+            }\n+\n+            this.mv.visitInsn(ICONST_1);\n+            this.mv.visitJumpInsn(GOTO, label2);\n+\n+            this.mv.visitLabel(label1);\n+            this.mv.visitInsn(ICONST_0);\n+\n+            this.mv.visitLabel(label2);\n+            this.storeToVar(binaryIns.lhsOp.variableDcl);\n+        }\n+\n+        void generateRefNotEqualIns(BinaryOp binaryIns) {\n+\n+            this.generateBinaryRhsAndLhsLoad(binaryIns);\n+\n+            Label label1 = new Label();\n+            Label label2 = new Label();\n+\n+            // It is assumed that both operands are of same type\n+            BType lhsOpType = binaryIns.rhsOp1.variableDcl.type;\n+            BType rhsOpType = binaryIns.rhsOp2.variableDcl.type;\n+            if (lhsOpType.tag == TypeTags.INT && rhsOpType.tag == TypeTags.INT) {\n+                this.mv.visitInsn(LCMP);\n+                this.mv.visitJumpInsn(IFEQ, label1);\n+            } else if (lhsOpType.tag == TypeTags.BYTE && rhsOpType.tag == TypeTags.BYTE) {\n+                this.mv.visitJumpInsn(IF_ICMPEQ, label1);\n+            } else if (lhsOpType.tag == TypeTags.FLOAT && rhsOpType.tag == TypeTags.FLOAT) {\n+                this.mv.visitInsn(DCMPL);\n+                this.mv.visitJumpInsn(IFEQ, label1);\n+            } else if (lhsOpType.tag == TypeTags.BOOLEAN && rhsOpType.tag == TypeTags.BOOLEAN) {\n+                this.mv.visitJumpInsn(IF_ICMPEQ, label1);\n+            } else {\n+                this.mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, \"isReferenceEqual\",\n+                        String.format(\"(L%s;L%s;)Z\", OBJECT, OBJECT), false);\n+                this.mv.visitJumpInsn(IFNE, label1);\n+            }\n+\n+            this.mv.visitInsn(ICONST_1);\n+            this.mv.visitJumpInsn(GOTO, label2);\n+\n+            this.mv.visitLabel(label1);\n+            this.mv.visitInsn(ICONST_0);\n+\n+            this.mv.visitLabel(label2);\n+            this.storeToVar(binaryIns.lhsOp.variableDcl);\n+        }\n+\n+        void generateClosedRangeIns(BinaryOp binaryIns) {\n+\n+            this.mv.visitTypeInsn(NEW, ARRAY_VALUE_IMPL);\n+            this.mv.visitInsn(DUP);\n+            this.generateBinaryRhsAndLhsLoad(binaryIns);\n+            this.mv.visitMethodInsn(INVOKESTATIC, LONG_STREAM, \"rangeClosed\", String.format(\"(JJ)L%s;\", LONG_STREAM),\n+                    true);\n+            this.mv.visitMethodInsn(INVOKEINTERFACE, LONG_STREAM, \"toArray\", \"()[J\", true);\n+            this.mv.visitMethodInsn(INVOKESPECIAL, ARRAY_VALUE_IMPL, \"<init>\", \"([J)V\", false);\n+            this.storeToVar(binaryIns.lhsOp.variableDcl);\n+        }\n+\n+        void generateAnnotAccessIns(BinaryOp binaryIns) {\n+\n+            this.loadVar(binaryIns.rhsOp1.variableDcl);\n+            this.loadVar(binaryIns.rhsOp2.variableDcl);\n+            this.mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, \"getAnnotValue\",\n+                    String.format(\"(L%s;L%s;)L%s;\", TYPEDESC_VALUE, STRING_VALUE, OBJECT), false);\n+\n+            BType targetType = binaryIns.lhsOp.variableDcl.type;\n+            addUnboxInsn(this.mv, targetType, false);\n+            this.storeToVar(binaryIns.lhsOp.variableDcl);\n+        }\n+\n+        void generateAddIns(BinaryOp binaryIns) {\n+\n+            BType bType = binaryIns.lhsOp.variableDcl.type;\n+            this.generateBinaryRhsAndLhsLoad(binaryIns);\n+            if (bType.tag == TypeTags.INT) {\n+                this.mv.visitInsn(LADD);\n+            } else if (bType.tag == TypeTags.BYTE) {\n+                this.mv.visitInsn(IADD);\n+            } else if (bType.tag == TypeTags.STRING) {\n+                if (IS_BSTRING) {\n+                    this.mv.visitMethodInsn(INVOKEINTERFACE, BSTRING_VALUE, \"concat\",\n+                            String.format(\"(L%s;)L%s;\", BSTRING_VALUE, BSTRING_VALUE), true);\n+                } else {\n+                    this.mv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/String\", \"concat\",\n+                            String.format(\"(L%s;)L%s;\", STRING_VALUE, STRING_VALUE), false);\n+                }\n+            } else if (bType.tag == TypeTags.DECIMAL) {\n+                this.mv.visitMethodInsn(INVOKEVIRTUAL, DECIMAL_VALUE, \"add\",\n+                        String.format(\"(L%s;)L%s;\", DECIMAL_VALUE, DECIMAL_VALUE), false);\n+            } else if (bType.tag == TypeTags.FLOAT) {\n+                this.mv.visitInsn(DADD);\n+            } else if (bType.tag == TypeTags.XML) {\n+                this.mv.visitMethodInsn(INVOKESTATIC, XML_FACTORY, \"concatenate\",\n+                        String.format(\"(L%s;L%s;)L%s;\", XML_VALUE, XML_VALUE, XML_VALUE), false);\n+            } else {\n+                throw new BLangCompilerException(\"JVM generation is not supported for type \" +\n+                        String.format(\"%s\", binaryIns.lhsOp.variableDcl.type));\n+            }\n+\n+            this.storeToVar(binaryIns.lhsOp.variableDcl);\n+        }\n+\n+        void generateSubIns(BinaryOp binaryIns) {\n+\n+            BType bType = binaryIns.lhsOp.variableDcl.type;\n+            this.generateBinaryRhsAndLhsLoad(binaryIns);\n+            if (bType.tag == TypeTags.INT) {\n+                this.mv.visitInsn(LSUB);\n+            } else if (bType.tag == TypeTags.FLOAT) {\n+                this.mv.visitInsn(DSUB);\n+            } else if (bType.tag == TypeTags.DECIMAL) {\n+                this.mv.visitMethodInsn(INVOKEVIRTUAL, DECIMAL_VALUE, \"subtract\",\n+                        String.format(\"(L%s;)L%s;\", DECIMAL_VALUE, DECIMAL_VALUE), false);\n+            } else {\n+                throw new BLangCompilerException(\"JVM generation is not supported for type \" +\n+                        String.format(\"%s\", binaryIns.lhsOp.variableDcl.type));\n+            }\n+            this.storeToVar(binaryIns.lhsOp.variableDcl);\n+        }\n+\n+        void generateDivIns(BinaryOp binaryIns) {\n+\n+            BType bType = binaryIns.lhsOp.variableDcl.type;\n+            this.generateBinaryRhsAndLhsLoad(binaryIns);\n+            if (bType.tag == TypeTags.INT) {\n+                this.mv.visitMethodInsn(INVOKESTATIC, MATH_UTILS, \"divide\", \"(JJ)J\", false);\n+            } else if (bType.tag == TypeTags.FLOAT) {\n+                this.mv.visitInsn(DDIV);\n+            } else if (bType.tag == TypeTags.DECIMAL) {\n+                this.mv.visitMethodInsn(INVOKEVIRTUAL, DECIMAL_VALUE, \"divide\",\n+                        String.format(\"(L%s;)L%s;\", DECIMAL_VALUE, DECIMAL_VALUE), false);\n+            } else {\n+                throw new BLangCompilerException(\"JVM generation is not supported for type \" +\n+                        String.format(\"%s\", binaryIns.lhsOp.variableDcl.type));\n+            }\n+            this.storeToVar(binaryIns.lhsOp.variableDcl);\n+        }\n+\n+        void generateMulIns(BinaryOp binaryIns) {\n+\n+            BType bType = binaryIns.lhsOp.variableDcl.type;\n+            this.generateBinaryRhsAndLhsLoad(binaryIns);\n+            if (bType.tag == TypeTags.INT) {\n+                this.mv.visitInsn(LMUL);\n+            } else if (bType.tag == TypeTags.FLOAT) {\n+                this.mv.visitInsn(DMUL);\n+            } else if (bType.tag == TypeTags.DECIMAL) {\n+                this.mv.visitMethodInsn(INVOKEVIRTUAL, DECIMAL_VALUE, \"multiply\",\n+                        String.format(\"(L%s;)L%s;\", DECIMAL_VALUE, DECIMAL_VALUE), false);\n+            } else {\n+                throw new BLangCompilerException(\"JVM generation is not supported for type \" +\n+                        String.format(\"%s\", binaryIns.lhsOp.variableDcl.type));\n+            }\n+            this.storeToVar(binaryIns.lhsOp.variableDcl);\n+        }\n+\n+        void generateRemIns(BinaryOp binaryIns) {\n+\n+            BType bType = binaryIns.lhsOp.variableDcl.type;\n+            this.generateBinaryRhsAndLhsLoad(binaryIns);\n+            if (bType.tag == TypeTags.INT) {\n+                this.mv.visitMethodInsn(INVOKESTATIC, MATH_UTILS, \"remainder\", \"(JJ)J\", false);\n+            } else if (bType.tag == TypeTags.FLOAT) {\n+                this.mv.visitInsn(DREM);\n+            } else if (bType.tag == TypeTags.DECIMAL) {\n+                this.mv.visitMethodInsn(INVOKEVIRTUAL, DECIMAL_VALUE, \"remainder\",\n+                        String.format(\"(L%s;)L%s;\", DECIMAL_VALUE, DECIMAL_VALUE), false);\n+            } else {\n+                throw new BLangCompilerException(\"JVM generation is not supported for type \" +\n+                        String.format(\"%s\", binaryIns.lhsOp.variableDcl.type));\n+            }\n+            this.storeToVar(binaryIns.lhsOp.variableDcl);\n+        }\n+\n+        void generateBitwiseAndIns(BinaryOp binaryIns) {\n+\n+            BType opType1 = binaryIns.rhsOp1.variableDcl.type;\n+            BType opType2 = binaryIns.rhsOp2.variableDcl.type;\n+\n+            if (opType1.tag == TypeTags.INT && opType2.tag == TypeTags.INT) {\n+                this.loadVar(binaryIns.rhsOp1.variableDcl);\n+                this.loadVar(binaryIns.rhsOp2.variableDcl);\n+                this.mv.visitInsn(LAND);\n+            } else {\n+                this.loadVar(binaryIns.rhsOp1.variableDcl);\n+                generateCheckCastToByte(this.mv, opType1);\n+\n+                this.loadVar(binaryIns.rhsOp2.variableDcl);\n+                generateCheckCastToByte(this.mv, opType2);\n+\n+                this.mv.visitInsn(IAND);\n+            }\n+            this.storeToVar(binaryIns.lhsOp.variableDcl);\n+        }\n+\n+        void generateBitwiseOrIns(BinaryOp binaryIns) {\n+\n+            this.loadVar(binaryIns.rhsOp1.variableDcl);\n+            this.loadVar(binaryIns.rhsOp2.variableDcl);\n+\n+            BType opType = binaryIns.rhsOp1.variableDcl.type;\n+            if (opType.tag == TypeTags.INT) {\n+                this.mv.visitInsn(LOR);\n+            } else {\n+                this.mv.visitInsn(IOR);\n+            }\n+            this.storeToVar(binaryIns.lhsOp.variableDcl);\n+        }\n+\n+        void generateBitwiseXorIns(BinaryOp binaryIns) {\n+\n+            this.loadVar(binaryIns.rhsOp1.variableDcl);\n+            this.loadVar(binaryIns.rhsOp2.variableDcl);\n+\n+            BType opType = binaryIns.rhsOp1.variableDcl.type;\n+            if (opType.tag == TypeTags.INT) {\n+                this.mv.visitInsn(LXOR);\n+            } else {\n+                this.mv.visitInsn(IXOR);\n+            }\n+            this.storeToVar(binaryIns.lhsOp.variableDcl);\n+        }\n+\n+        void generateBitwiseLeftShiftIns(BinaryOp binaryIns) {\n+\n+            this.loadVar(binaryIns.rhsOp1.variableDcl);\n+            this.loadVar(binaryIns.rhsOp2.variableDcl);\n+\n+            BType secondOpType = binaryIns.rhsOp2.variableDcl.type;\n+            if (secondOpType.tag == TypeTags.INT) {\n+                this.mv.visitInsn(L2I);\n+            }\n+\n+            BType firstOpType = binaryIns.rhsOp1.variableDcl.type;\n+            if (firstOpType.tag == TypeTags.INT) {\n+                this.mv.visitInsn(LSHL);\n+            } else {\n+                this.mv.visitInsn(ISHL);\n+                this.mv.visitInsn(I2L);\n+            }\n+\n+            this.storeToVar(binaryIns.lhsOp.variableDcl);\n+        }\n+\n+        void generateBitwiseRightShiftIns(BinaryOp binaryIns) {\n+\n+            this.loadVar(binaryIns.rhsOp1.variableDcl);\n+            this.loadVar(binaryIns.rhsOp2.variableDcl);\n+\n+            BType secondOpType = binaryIns.rhsOp2.variableDcl.type;\n+            if (secondOpType.tag == TypeTags.INT) {\n+                this.mv.visitInsn(L2I);\n+            }\n+\n+            BType firstOpType = binaryIns.rhsOp1.variableDcl.type;\n+            if (firstOpType.tag == TypeTags.INT) {\n+                this.mv.visitInsn(LSHR);\n+            } else {\n+                this.mv.visitInsn(ISHR);\n+            }\n+\n+            this.storeToVar(binaryIns.lhsOp.variableDcl);\n+        }\n+\n+        void generateBitwiseUnsignedRightShiftIns(BinaryOp binaryIns) {\n+\n+            this.loadVar(binaryIns.rhsOp1.variableDcl);\n+            this.loadVar(binaryIns.rhsOp2.variableDcl);\n+\n+            BType secondOpType = binaryIns.rhsOp2.variableDcl.type;\n+            if (secondOpType.tag == TypeTags.INT) {\n+                this.mv.visitInsn(L2I);\n+            }\n+\n+            BType firstOpType = binaryIns.rhsOp1.variableDcl.type;\n+            if (firstOpType.tag == TypeTags.INT) {\n+                this.mv.visitInsn(LUSHR);\n+            } else {\n+                this.mv.visitInsn(IUSHR);\n+            }\n+\n+            this.storeToVar(binaryIns.lhsOp.variableDcl);\n+        }\n+\n+        int getJVMIndexOfVarRef(BIRVariableDcl varDcl) {\n+\n+            return this.indexMap.getIndex(varDcl);\n+        }\n+\n+        void generateMapNewIns(NewStructure mapNewIns, int localVarOffset) {\n+\n+            BType typeOfMapNewIns = mapNewIns.type;\n+            String className = MAP_VALUE_IMPL;\n+\n+            if (typeOfMapNewIns.tag == TypeTags.RECORD) {\n+                if (mapNewIns.isExternalDef) {\n+                    className = getTypeValueClassName(mapNewIns.externalPackageId, toNameString(typeOfMapNewIns));\n+                } else {\n+                    className = getTypeValueClassName(this.currentPackage, toNameString(typeOfMapNewIns));\n+                }\n+\n+                this.mv.visitTypeInsn(NEW, className);\n+                this.mv.visitInsn(DUP);\n+                this.mv.visitInsn(DUP);\n+                if (mapNewIns.isExternalDef) {\n+                    loadExternalType(this.mv, mapNewIns.externalPackageId, mapNewIns.recordName);\n+                } else {\n+                    loadType(this.mv, mapNewIns.type);\n+                }\n+                this.mv.visitMethodInsn(INVOKESPECIAL, className, \"<init>\", String.format(\"(L%s;)V\", BTYPE), false);\n+\n+                // Invoke the init-function of this type.\n+                this.mv.visitVarInsn(ALOAD, localVarOffset);\n+                this.mv.visitInsn(SWAP);\n+                this.mv.visitMethodInsn(INVOKESTATIC, className, \"$init\",\n+                        String.format(\"(L%s;L%s;)V\", STRAND, MAP_VALUE), false);\n+            } else {\n+                this.mv.visitTypeInsn(NEW, className);\n+                this.mv.visitInsn(DUP);\n+                loadType(this.mv, mapNewIns.type);\n+                this.mv.visitMethodInsn(INVOKESPECIAL, className, \"<init>\", String.format(\"(L%s;)V\", BTYPE), false);\n+            }\n+            this.storeToVar(mapNewIns.lhsOp.variableDcl);\n+        }\n+\n+        void generateTableNewIns(NewTable tableNewIns) {\n+\n+            this.mv.visitTypeInsn(NEW, TABLE_VALUE);\n+            this.mv.visitInsn(DUP);\n+            loadType(this.mv, tableNewIns.type);\n+            this.loadVar(tableNewIns.keyColOp.variableDcl);\n+            this.loadVar(tableNewIns.dataOp.variableDcl);\n+            this.mv.visitMethodInsn(INVOKESPECIAL, TABLE_VALUE, \"<init>\", String.format(\"(L%s;L%s;L%s;)V\", BTYPE,\n+                    ARRAY_VALUE, ARRAY_VALUE), false);\n+            this.storeToVar(tableNewIns.lhsOp.variableDcl);\n+        }\n+\n+        void generateMapStoreIns(FieldAccess mapStoreIns) {\n+            // visit map_ref\n+            this.loadVar(mapStoreIns.lhsOp.variableDcl);\n+            BType varRefType = mapStoreIns.lhsOp.variableDcl.type;\n+\n+            // visit key_expr\n+            this.loadVar(mapStoreIns.keyOp.variableDcl);\n+\n+            // visit value_expr\n+            BType valueType = mapStoreIns.rhsOp.variableDcl.type;\n+            this.loadVar(mapStoreIns.rhsOp.variableDcl);\n+            addBoxInsn(this.mv, valueType);\n+\n+            if (varRefType.tag == TypeTags.JSON) {\n+                this.mv.visitMethodInsn(INVOKESTATIC, JSON_UTILS, \"setElement\",\n+                        String.format(\"(L%s;L%s;L%s;)V\", OBJECT, STRING_VALUE, OBJECT), false);\n+            } else {\n+                this.mv.visitMethodInsn(INVOKESTATIC, MAP_UTILS, \"handleMapStore\",\n+                        String.format(\"(L%s;L%s;L%s;)V\", MAP_VALUE, STRING_VALUE, OBJECT),\n+                        false);\n+            }\n+        }\n+\n+        void generateMapLoadIns(FieldAccess mapLoadIns) {\n+            // visit map_ref\n+            this.loadVar(mapLoadIns.rhsOp.variableDcl);\n+            BType varRefType = mapLoadIns.rhsOp.variableDcl.type;\n+            addUnboxInsn(this.mv, varRefType, false);\n+\n+            // visit key_expr\n+            this.loadVar(mapLoadIns.keyOp.variableDcl);\n+\n+            if (varRefType.tag == TypeTags.JSON) {\n+                if (mapLoadIns.optionalFieldAccess) {\n+                    this.mv.visitTypeInsn(CHECKCAST, STRING_VALUE);\n+                    this.mv.visitMethodInsn(INVOKESTATIC, JSON_UTILS, \"getElementOrNil\",\n+                            String.format(\"(L%s;L%s;)L%s;\", OBJECT, STRING_VALUE, OBJECT), false);\n+                } else {\n+                    this.mv.visitTypeInsn(CHECKCAST, STRING_VALUE);\n+                    this.mv.visitMethodInsn(INVOKESTATIC, JSON_UTILS, \"getElement\",\n+                            String.format(\"(L%s;L%s;)L%s;\", OBJECT, STRING_VALUE, OBJECT), false);\n+                }\n+            } else {\n+                if (mapLoadIns.fillingRead) {\n+                    this.mv.visitMethodInsn(INVOKEINTERFACE, MAP_VALUE, \"fillAndGet\",\n+                            String.format(\"(L%s;)L%s;\", OBJECT, OBJECT), true);\n+                } else {\n+                    this.mv.visitMethodInsn(INVOKEINTERFACE, MAP_VALUE, \"get\",\n+                            String.format(\"(L%s;)L%s;\", OBJECT, OBJECT), true);\n+                }\n+            }\n+\n+            // store in the target reg\n+            BType targetType = mapLoadIns.lhsOp.variableDcl.type;\n+            addUnboxInsn(this.mv, targetType, false);\n+            this.storeToVar(mapLoadIns.lhsOp.variableDcl);\n+        }\n+\n+        void generateObjectLoadIns(FieldAccess objectLoadIns) {\n+            // visit object_ref\n+            this.loadVar(objectLoadIns.rhsOp.variableDcl);\n+            BType varRefType = objectLoadIns.rhsOp.variableDcl.type;\n+\n+            // visit key_expr\n+            this.loadVar(objectLoadIns.keyOp.variableDcl);\n+\n+            // invoke get() method, and unbox if needed\n+            this.mv.visitMethodInsn(INVOKEINTERFACE, OBJECT_VALUE, \"get\",\n+                    String.format(\"(L%s;)L%s;\", STRING_VALUE, OBJECT), true);\n+            BType targetType = objectLoadIns.lhsOp.variableDcl.type;\n+            addUnboxInsn(this.mv, targetType, false);\n+\n+            // store in the target reg\n+            this.storeToVar(objectLoadIns.lhsOp.variableDcl);\n+        }\n+\n+        void generateObjectStoreIns(FieldAccess objectStoreIns, boolean useBString) {\n+            // visit object_ref\n+            this.loadVar(objectStoreIns.lhsOp.variableDcl);\n+            BType varRefType = objectStoreIns.lhsOp.variableDcl.type;\n+\n+            // visit key_expr\n+            this.loadVar(objectStoreIns.keyOp.variableDcl);\n+\n+            // visit value_expr\n+            BType valueType = objectStoreIns.rhsOp.variableDcl.type;\n+            this.loadVar(objectStoreIns.rhsOp.variableDcl);\n+            addBoxInsn(this.mv, valueType);\n+\n+            // invoke set() method\n+            this.mv.visitMethodInsn(INVOKEINTERFACE, OBJECT_VALUE, \"set\",\n+                    String.format(\"(L%s;L%s;)V\", useBString ? I_STRING_VALUE : STRING_VALUE, OBJECT), true);\n+        }\n+\n+        void generateStringLoadIns(FieldAccess stringLoadIns) {\n+            // visit the string\n+            this.loadVar(stringLoadIns.rhsOp.variableDcl);\n+\n+            // visit the key expr\n+            this.loadVar(stringLoadIns.keyOp.variableDcl);\n+\n+            // invoke the `getStringAt()` method\n+            this.mv.visitMethodInsn(INVOKESTATIC, STRING_UTILS, \"getStringAt\",\n+                    String.format(\"(L%s;J)L%s;\", STRING_VALUE, STRING_VALUE), false);\n+\n+            // store in the target reg\n+            this.storeToVar(stringLoadIns.lhsOp.variableDcl);\n+        }\n+\n+        //    # Generate a new instance of an array value\n+//    #\n+//    # + inst - the new array instruction\n+        void generateArrayNewIns(NewArray inst) {\n+\n+            if (inst.type.tag == TypeTags.ARRAY) {\n+                this.mv.visitTypeInsn(NEW, ARRAY_VALUE_IMPL);\n+                this.mv.visitInsn(DUP);\n+                loadType(this.mv, inst.type);\n+                this.loadVar(inst.sizeOp.variableDcl);\n+                this.mv.visitMethodInsn(INVOKESPECIAL, ARRAY_VALUE_IMPL, \"<init>\",\n+                        String.format(\"(L%s;J)V\", ARRAY_TYPE), false);\n+                this.storeToVar(inst.lhsOp.variableDcl);\n+            } else {\n+                this.mv.visitTypeInsn(NEW, TUPLE_VALUE_IMPL);\n+                this.mv.visitInsn(DUP);\n+                loadType(this.mv, inst.type);\n+                this.loadVar(inst.sizeOp.variableDcl);\n+                this.mv.visitMethodInsn(INVOKESPECIAL, TUPLE_VALUE_IMPL, \"<init>\",\n+                        String.format(\"(L%s;J)V\", TUPLE_TYPE), false);\n+                this.storeToVar(inst.lhsOp.variableDcl);\n+            }\n+        }\n+\n+        //    # Generate adding a new value to an array\n+//    #\n+//    # + inst - array store instruction", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82df207efdc85acd9646a1aae1461f7d1f7bbc5f"}, "originalPosition": 1214}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMDM3ODk4OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/codegen/JvmMethodGen.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwNTo0Mzo0MFrOFxgnjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwNTo0Mzo0MFrOFxgnjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ1ODk1Nw==", "bodyText": "We really need switch statements.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21435#discussion_r387458957", "createdAt": "2020-03-04T05:43:40Z", "author": {"login": "riyafa"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/codegen/JvmMethodGen.java", "diffHunk": "@@ -0,0 +1,2928 @@\n+/*\n+ *  Copyright (c) 2018, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.wso2.ballerinalang.compiler.bir.codegen;\n+\n+import org.ballerinalang.compiler.BLangCompilerException;\n+import org.ballerinalang.model.elements.PackageID;\n+import org.objectweb.asm.ClassWriter;\n+import org.objectweb.asm.FieldVisitor;\n+import org.objectweb.asm.Label;\n+import org.objectweb.asm.MethodVisitor;\n+import org.wso2.ballerinalang.compiler.bir.codegen.JvmErrorGen.ErrorHandlerGenerator;\n+import org.wso2.ballerinalang.compiler.bir.codegen.JvmInstructionGen.InstructionGenerator;\n+import org.wso2.ballerinalang.compiler.bir.codegen.JvmLabelGen.LabelGenerator;\n+import org.wso2.ballerinalang.compiler.bir.codegen.JvmTerminatorGen.TerminatorGenerator;\n+import org.wso2.ballerinalang.compiler.bir.codegen.interop.JType;\n+import org.wso2.ballerinalang.compiler.bir.codegen.interop.JTypeTags;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRInstruction;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRAnnotationArrayValue;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRAnnotationAttachment;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRAnnotationLiteralValue;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRAnnotationRecordValue;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRAnnotationValue;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRBasicBlock;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRFunction;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRFunctionParameter;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRPackage;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRTypeDefinition;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRVariableDcl;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.BinaryOp;\n+import org.wso2.ballerinalang.compiler.bir.model.BIROperand;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRTerminator;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRTerminator.AsyncCall;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRTerminator.GOTO;\n+import org.wso2.ballerinalang.compiler.bir.model.InstructionKind;\n+import org.wso2.ballerinalang.compiler.bir.model.VarKind;\n+import org.wso2.ballerinalang.compiler.bir.model.VarScope;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BInvokableSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BPackageSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BField;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BFutureType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BInvokableType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BNilType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BObjectType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BServiceType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BUnionType;\n+import org.wso2.ballerinalang.compiler.util.Name;\n+import org.wso2.ballerinalang.compiler.util.TypeTags;\n+import org.wso2.ballerinalang.compiler.util.diagnotic.DiagnosticPos;\n+import org.wso2.ballerinalang.util.Flags;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.objectweb.asm.ClassWriter.COMPUTE_FRAMES;\n+import static org.objectweb.asm.Opcodes.AALOAD;\n+import static org.objectweb.asm.Opcodes.AASTORE;\n+import static org.objectweb.asm.Opcodes.ACC_PUBLIC;\n+import static org.objectweb.asm.Opcodes.ACC_STATIC;\n+import static org.objectweb.asm.Opcodes.ACC_SUPER;\n+import static org.objectweb.asm.Opcodes.ACONST_NULL;\n+import static org.objectweb.asm.Opcodes.ALOAD;\n+import static org.objectweb.asm.Opcodes.ANEWARRAY;\n+import static org.objectweb.asm.Opcodes.ARETURN;\n+import static org.objectweb.asm.Opcodes.ASTORE;\n+import static org.objectweb.asm.Opcodes.ATHROW;\n+import static org.objectweb.asm.Opcodes.BIPUSH;\n+import static org.objectweb.asm.Opcodes.CHECKCAST;\n+import static org.objectweb.asm.Opcodes.DCONST_0;\n+import static org.objectweb.asm.Opcodes.DLOAD;\n+import static org.objectweb.asm.Opcodes.DSTORE;\n+import static org.objectweb.asm.Opcodes.DUP;\n+import static org.objectweb.asm.Opcodes.DUP_X1;\n+import static org.objectweb.asm.Opcodes.FCONST_0;\n+import static org.objectweb.asm.Opcodes.FLOAD;\n+import static org.objectweb.asm.Opcodes.FSTORE;\n+import static org.objectweb.asm.Opcodes.GETFIELD;\n+import static org.objectweb.asm.Opcodes.GETSTATIC;\n+import static org.objectweb.asm.Opcodes.GOTO;\n+import static org.objectweb.asm.Opcodes.IADD;\n+import static org.objectweb.asm.Opcodes.ICONST_0;\n+import static org.objectweb.asm.Opcodes.ICONST_1;\n+import static org.objectweb.asm.Opcodes.IFEQ;\n+import static org.objectweb.asm.Opcodes.IFGT;\n+import static org.objectweb.asm.Opcodes.IFNE;\n+import static org.objectweb.asm.Opcodes.IFNULL;\n+import static org.objectweb.asm.Opcodes.ILOAD;\n+import static org.objectweb.asm.Opcodes.INVOKEINTERFACE;\n+import static org.objectweb.asm.Opcodes.INVOKESPECIAL;\n+import static org.objectweb.asm.Opcodes.INVOKESTATIC;\n+import static org.objectweb.asm.Opcodes.INVOKEVIRTUAL;\n+import static org.objectweb.asm.Opcodes.ISTORE;\n+import static org.objectweb.asm.Opcodes.ISUB;\n+import static org.objectweb.asm.Opcodes.L2I;\n+import static org.objectweb.asm.Opcodes.LCONST_0;\n+import static org.objectweb.asm.Opcodes.LLOAD;\n+import static org.objectweb.asm.Opcodes.LSTORE;\n+import static org.objectweb.asm.Opcodes.NEW;\n+import static org.objectweb.asm.Opcodes.POP;\n+import static org.objectweb.asm.Opcodes.PUTFIELD;\n+import static org.objectweb.asm.Opcodes.RETURN;\n+import static org.objectweb.asm.Opcodes.SIPUSH;\n+import static org.objectweb.asm.Opcodes.V1_8;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.ANNOTATION_MAP_NAME;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.ANNOTATION_UTILS;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.ARGUMENT_PARSER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.ARRAY_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BALLERINA;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BAL_ERRORS;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BAL_EXTENSION;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BOOLEAN_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BTYPE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BUILT_IN_PACKAGE_NAME;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.CHANNEL_DETAILS;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.COMPATIBILITY_CHECKER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.CURRENT_MODULE_INIT;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.DECIMAL_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.DEFAULTABLE_ARGS_ANOT_FIELD;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.DEFAULTABLE_ARGS_ANOT_NAME;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.DOUBLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.ERROR_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.FUNCTION;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.FUNCTION_POINTER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.FUTURE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.HANDLE_RETURNED_ERROR_METHOD;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.HANDLE_STOP_PANIC_METHOD;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.HANDLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.INT_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.JAVA_PACKAGE_SEPERATOR;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.JAVA_RUNTIME;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.JAVA_THREAD;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.LAUNCH_UTILS;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.LONG_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.MAP_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.MODULE_INIT;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.MODULE_INIT_CLASS_NAME;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.MODULE_START;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.MODULE_STOP;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.OBJECT;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.OBJECT_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.PANIC_FIELD;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.RUNTIME_UTILS;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.SCHEDULER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.SCHEDULER_START_METHOD;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.SCHEDULE_FUNCTION_METHOD;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STRAND;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STREAM_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STRING_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TABLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.THROWABLE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TYPEDESC_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.VALUE_CREATOR;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.WINDOWS_PATH_SEPERATOR;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.XML_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmInstructionGen.BSTRING_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmInstructionGen.IS_BSTRING;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmInstructionGen.I_STRING_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmInstructionGen.InstructionGenerator.visitInvokeDyn;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmInstructionGen.addBoxInsn;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmInstructionGen.addUnboxInsn;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmObservabilityGen.emitReportErrorInvocation;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmObservabilityGen.emitStartObservationInvocation;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmObservabilityGen.emitStopObservationInvocation;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmObservabilityGen.getFullQualifiedRemoteFunctionName;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmPackageGen.JavaClass;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmPackageGen.birFunctionMap;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmPackageGen.currentClass;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmPackageGen.getFunctionWrapper;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmPackageGen.getModuleLevelClassName;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmPackageGen.getPackageName;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmPackageGen.lookupGlobalVarClassName;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmPackageGen.packageToModuleId;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmPackageGen.symbolTable;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmTerminatorGen.TerminatorGenerator.toNameString;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmTerminatorGen.cleanupObjectTypeName;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmTerminatorGen.isExternStaticFunctionCall;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmTerminatorGen.loadChannelDetails;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmTypeGen.loadExternalOrLocalType;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmTypeGen.loadType;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmTypeGen.typeOwnerClass;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.interop.ExternalMethodGen.genJMethodForBExternalFunc;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.interop.ExternalMethodGen.isBallerinaBuiltinModule;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.interop.InteropMethodGen.JInstruction;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.interop.InteropMethodGen.getJTypeSignature;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.interop.InteropMethodGen.getSignatureForJType;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.ConstantLoad;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.FPLoad;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.FieldAccess;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.IsLike;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.Move;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewArray;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewError;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewInstance;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewStringXMLQName;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewStructure;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewTable;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewTypeDesc;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLComment;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLElement;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLProcIns;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLQName;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLText;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.TypeCast;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.TypeTest;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.UnaryOP;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.XMLAccess;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRTerminator.Branch;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRTerminator.Call;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRTerminator.Return;\n+\n+/**\n+ * BIR function to JVM byte code generation class.\n+ *\n+ * @since 1.2.0\n+ */\n+public class JvmMethodGen {\n+\n+    private static List<String> generatedInitFuncs = new ArrayList<>();\n+    public static int nextId = -1;\n+    public static int nextVarId = -1;\n+\n+    private static final FunctionParamComparator FUNCTION_PARAM_COMPARATOR = new FunctionParamComparator();\n+    static BUnionType errorOrNilType;\n+\n+    static void generateMethod(BIRFunction birFunc,\n+                               ClassWriter cw,\n+                               BIRPackage birModule,\n+                               @Nilable BType attachedType /* = () */,\n+                               boolean isService /* = false */,\n+                               String serviceName /* = \"\" */) {\n+\n+        if (isExternFunc(birFunc)) {\n+            genJMethodForBExternalFunc(birFunc, cw, birModule, attachedType);\n+        } else {\n+            genJMethodForBFunc(birFunc, cw, birModule, isService, serviceName, attachedType);\n+        }\n+    }\n+\n+    public static void genJMethodForBFunc(BIRFunction func,\n+                                          ClassWriter cw,\n+                                          BIRPackage module,\n+                                          boolean isService,\n+                                          String serviceName,\n+                                          @Nilable BType attachedType /* = () */) {\n+\n+        String currentPackageName = getPackageName(module.org.value, module.name.value);\n+        BalToJVMIndexMap indexMap = new BalToJVMIndexMap();\n+        String funcName = cleanupFunctionName(func.name.value);\n+        boolean useBString = IS_BSTRING;\n+        int returnVarRefIndex = -1;\n+\n+        BIRVariableDcl strandVar = new BIRVariableDcl(symbolTable.stringType, new Name(\"strand\"),\n+                VarScope.FUNCTION, VarKind.ARG);\n+        int ignoreStrandVarIndex = indexMap.getIndex(strandVar);\n+\n+        // generate method desc\n+        String desc = getMethodDesc(func.type.paramTypes, func.type.retType, null, false, useBString);\n+        int access = ACC_PUBLIC;\n+        int localVarOffset;\n+        if (attachedType != null) {\n+            localVarOffset = 1;\n+\n+            // add the self as the first local var\n+            // TODO: find a better way\n+            BIRVariableDcl selfVar = new BIRVariableDcl(symbolTable.anyType, new Name(\"self\"),\n+                    VarScope.FUNCTION, VarKind.ARG);\n+            int ignoreSelfVarIndex = indexMap.getIndex(selfVar);\n+        } else {\n+            localVarOffset = 0;\n+            access += ACC_STATIC;\n+        }\n+\n+        MethodVisitor mv = cw.visitMethod(access, funcName, desc, null, null);\n+        InstructionGenerator instGen = new InstructionGenerator(mv, indexMap, module);\n+        ErrorHandlerGenerator errorGen = new ErrorHandlerGenerator(mv, indexMap, currentPackageName);\n+        LabelGenerator labelGen = new LabelGenerator();\n+\n+        mv.visitCode();\n+\n+        @Nilable Label tryStart = null;\n+        boolean isObserved = false;\n+        boolean isWorker = (func.flags & Flags.WORKER) == Flags.WORKER;\n+        boolean isRemote = (func.flags & Flags.REMOTE) == Flags.REMOTE;\n+        if ((isService || isRemote || isWorker) && !\"__init\".equals(funcName) && !\"$__init$\".equals(funcName)) {\n+            // create try catch block to start and stop observability.\n+            isObserved = true;\n+            tryStart = labelGen.getLabel(\"try-start\");\n+            mv.visitLabel(tryStart);\n+        }\n+\n+        Label methodStartLabel = new Label();\n+        mv.visitLabel(methodStartLabel);\n+\n+        // generate method body\n+        int k = 1;\n+\n+        // set channel details to strand.\n+        // these channel info is required to notify datachannels, when there is a panic\n+        // we cannot set this during strand creation, because function call do not have this info.\n+        if (func.workerChannels.length > 0) {\n+            mv.visitVarInsn(ALOAD, localVarOffset);\n+            loadChannelDetails(mv, Arrays.asList(func.workerChannels));\n+            mv.visitMethodInsn(INVOKEVIRTUAL, STRAND, \"updateChannelDetails\",\n+                    String.format(\"([L%s;)V\", CHANNEL_DETAILS), false);\n+        }\n+\n+        // panic if this strand is cancelled\n+        checkStrandCancelled(mv, localVarOffset);\n+\n+        func.localVars.sort(FUNCTION_PARAM_COMPARATOR);\n+\n+        @Nilable List<BIRVariableDcl> localVars = func.localVars;\n+        while (k < localVars.size()) {\n+            BIRVariableDcl localVar = getVariableDcl(localVars.get(k));\n+            int index = indexMap.getIndex(localVar);\n+            if (localVar.kind != VarKind.ARG) {\n+                BType bType = localVar.type;\n+                genDefaultValue(mv, bType, index);\n+            }\n+            k += 1;\n+        }\n+\n+        BIRVariableDcl varDcl = getVariableDcl(localVars.get(0));\n+        returnVarRefIndex = indexMap.getIndex(varDcl);\n+        BType returnType = func.type.retType;\n+        genDefaultValue(mv, returnType, returnVarRefIndex);\n+\n+        BIRVariableDcl stateVar = new BIRVariableDcl(symbolTable.stringType, //should  be javaInt\n+                new Name(\"state\"), null, VarKind.TEMP);\n+        int stateVarIndex = indexMap.getIndex(stateVar);\n+        mv.visitInsn(ICONST_0);\n+        mv.visitVarInsn(ISTORE, stateVarIndex);\n+\n+        mv.visitVarInsn(ALOAD, localVarOffset);\n+        mv.visitFieldInsn(GETFIELD, \"org/ballerinalang/jvm/scheduling/Strand\", \"resumeIndex\", \"I\");\n+        Label resumeLable = labelGen.getLabel(funcName + \"resume\");\n+        mv.visitJumpInsn(IFGT, resumeLable);\n+\n+        Label varinitLable = labelGen.getLabel(funcName + \"varinit\");\n+        mv.visitLabel(varinitLable);\n+\n+        // uncomment to test yield\n+        // mv.visitFieldInsn(GETSTATIC, className, \"i\", \"I\");\n+        // mv.visitInsn(ICONST_1);\n+        // mv.visitInsn(IADD);\n+        // mv.visitFieldInsn(PUTSTATIC, className, \"i\", \"I\");\n+\n+        // process basic blocks\n+        @Nilable List<BIRBasicBlock> basicBlocks = func.basicBlocks;\n+\n+        List<Label> lables = new ArrayList<>();\n+        List<Integer> states = new ArrayList<>();\n+\n+        int i = 0;\n+        int caseIndex = 0;\n+        while (i < basicBlocks.size()) {\n+            BIRBasicBlock bb = getBasicBlock(basicBlocks.get(i));\n+            if (i == 0) {\n+                lables.add(caseIndex, labelGen.getLabel(funcName + bb.id.value));\n+                states.add(caseIndex, caseIndex);\n+                caseIndex += 1;\n+            }\n+            lables.add(caseIndex, labelGen.getLabel(funcName + bb.id.value + \"beforeTerm\"));\n+            states.add(caseIndex, caseIndex);\n+            caseIndex += 1;\n+            i = i + 1;\n+        }\n+\n+        TerminatorGenerator termGen = new TerminatorGenerator(mv, indexMap, labelGen, errorGen, module);\n+\n+        // uncomment to test yield\n+        // mv.visitFieldInsn(GETSTATIC, className, \"i\", \"I\");\n+        // mv.visitIntInsn(BIPUSH, 100);\n+        // jvm:Label l0 = labelGen.getLabel(funcName + \"l0\");\n+        // mv.visitJumpInsn(IF_ICMPNE, l0);\n+        // mv.visitVarInsn(ALOAD, 0);\n+        // mv.visitInsn(ICONST_1);\n+        // mv.visitFieldInsn(PUTFIELD, \"org/ballerinalang/jvm/scheduling/Strand\", \"yield\", \"Z\");\n+        // termGen.genReturnTerm({kind:\"RETURN\"}, returnVarRefIndex, func);\n+        // mv.visitLabel(l0);\n+\n+        mv.visitVarInsn(ILOAD, stateVarIndex);\n+        Label yieldLable = labelGen.getLabel(funcName + \"yield\");\n+        mv.visitLookupSwitchInsn(yieldLable, toIntArray(states), lables.toArray(new Label[0]));\n+\n+        generateBasicBlocks(mv, basicBlocks, labelGen, errorGen, instGen, termGen, func, returnVarRefIndex,\n+                stateVarIndex, localVarOffset, false, module, currentPackageName, attachedType, isObserved, isService,\n+                serviceName, useBString);\n+\n+        String frameName = getFrameClassName(currentPackageName, funcName, attachedType);\n+        mv.visitLabel(resumeLable);\n+        mv.visitVarInsn(ALOAD, localVarOffset);\n+        mv.visitFieldInsn(GETFIELD, \"org/ballerinalang/jvm/scheduling/Strand\", \"frames\", \"[Ljava/lang/Object;\");\n+        mv.visitVarInsn(ALOAD, localVarOffset);\n+        mv.visitInsn(DUP);\n+        mv.visitFieldInsn(GETFIELD, \"org/ballerinalang/jvm/scheduling/Strand\", \"resumeIndex\", \"I\");\n+        mv.visitInsn(ICONST_1);\n+        mv.visitInsn(ISUB);\n+        mv.visitInsn(DUP_X1);\n+        mv.visitFieldInsn(PUTFIELD, \"org/ballerinalang/jvm/scheduling/Strand\", \"resumeIndex\", \"I\");\n+        mv.visitInsn(AALOAD);\n+        mv.visitTypeInsn(CHECKCAST, frameName);\n+\n+        generateFrameClassFieldLoad(localVars, mv, indexMap, frameName, useBString);\n+        mv.visitFieldInsn(GETFIELD, frameName, \"state\", \"I\");\n+        mv.visitVarInsn(ISTORE, stateVarIndex);\n+        mv.visitJumpInsn(GOTO, varinitLable);\n+\n+        mv.visitLabel(yieldLable);\n+        mv.visitTypeInsn(NEW, frameName);\n+        mv.visitInsn(DUP);\n+        mv.visitMethodInsn(INVOKESPECIAL, frameName, \"<init>\", \"()V\", false);\n+\n+        generateFrameClassFieldUpdate(localVars, mv, indexMap, frameName, useBString);\n+\n+        mv.visitInsn(DUP);\n+        mv.visitVarInsn(ILOAD, stateVarIndex);\n+        mv.visitFieldInsn(PUTFIELD, frameName, \"state\", \"I\");\n+\n+        BIRVariableDcl frameVar = new BIRVariableDcl(symbolTable.stringType, new Name(\"frame\"), null, VarKind.TEMP);\n+        int frameVarIndex = indexMap.getIndex(frameVar);\n+        mv.visitVarInsn(ASTORE, frameVarIndex);\n+\n+        mv.visitVarInsn(ALOAD, localVarOffset);\n+        mv.visitFieldInsn(GETFIELD, \"org/ballerinalang/jvm/scheduling/Strand\", \"frames\", \"[Ljava/lang/Object;\");\n+        mv.visitVarInsn(ALOAD, localVarOffset);\n+        mv.visitInsn(DUP);\n+        mv.visitFieldInsn(GETFIELD, \"org/ballerinalang/jvm/scheduling/Strand\", \"resumeIndex\", \"I\");\n+        mv.visitInsn(DUP_X1);\n+        mv.visitInsn(ICONST_1);\n+        mv.visitInsn(IADD);\n+        mv.visitFieldInsn(PUTFIELD, \"org/ballerinalang/jvm/scheduling/Strand\", \"resumeIndex\", \"I\");\n+        mv.visitVarInsn(ALOAD, frameVarIndex);\n+        mv.visitInsn(AASTORE);\n+\n+        Label methodEndLabel = new Label();\n+        // generate the try catch finally to stop observing if an error occurs.\n+        if (isObserved) {\n+            Label tryEnd = labelGen.getLabel(\"try-end\");\n+            Label tryCatch = labelGen.getLabel(\"try-handler\");\n+            // visitTryCatchBlock visited at the end since order of the error table matters.\n+            mv.visitTryCatchBlock((Label) tryStart, tryEnd, tryCatch, ERROR_VALUE);\n+            Label tryFinally = labelGen.getLabel(\"try-finally\");\n+            mv.visitTryCatchBlock((Label) tryStart, tryEnd, tryFinally, null);\n+            Label tryCatchFinally = labelGen.getLabel(\"try-catch-finally\");\n+            mv.visitTryCatchBlock(tryCatch, tryCatchFinally, tryFinally, null);\n+\n+            BIRVariableDcl catchVarDcl = new BIRVariableDcl(symbolTable.anyType, new Name(\"$_catch_$\"),\n+                    VarScope.FUNCTION, VarKind.ARG);\n+            int catchVarIndex = indexMap.getIndex(catchVarDcl);\n+            BIRVariableDcl throwableVarDcl = new BIRVariableDcl(symbolTable.anyType, new Name(\"$_throwable_$\"),\n+                    VarScope.FUNCTION, VarKind.ARG);\n+            int throwableVarIndex = indexMap.getIndex(throwableVarDcl);\n+\n+            // Try-To-Finally\n+            mv.visitLabel(tryEnd);\n+            // emitStopObservationInvocation(mv, localVarOffset);\n+            Label tryBlock1 = labelGen.getLabel(\"try-block-1\");\n+            mv.visitLabel(tryBlock1);\n+            mv.visitJumpInsn(GOTO, methodEndLabel);\n+\n+            // Catch Block\n+            mv.visitLabel(tryCatch);\n+            mv.visitVarInsn(ASTORE, catchVarIndex);\n+            Label tryBlock2 = labelGen.getLabel(\"try-block-2\");\n+            mv.visitLabel(tryBlock2);\n+            emitReportErrorInvocation(mv, localVarOffset, catchVarIndex);\n+            mv.visitLabel(tryCatchFinally);\n+            emitStopObservationInvocation(mv, localVarOffset);\n+            Label tryBlock3 = labelGen.getLabel(\"try-block-3\");\n+            mv.visitLabel(tryBlock3);\n+            // re-throw caught error value\n+            mv.visitVarInsn(ALOAD, catchVarIndex);\n+            mv.visitInsn(ATHROW);\n+\n+            // Finally Block\n+            mv.visitLabel(tryFinally);\n+            mv.visitVarInsn(ASTORE, throwableVarIndex);\n+            emitStopObservationInvocation(mv, localVarOffset);\n+            Label tryBlock4 = labelGen.getLabel(\"try-block-4\");\n+            mv.visitLabel(tryBlock4);\n+            mv.visitVarInsn(ALOAD, throwableVarIndex);\n+            mv.visitInsn(ATHROW);\n+        }\n+        mv.visitLabel(methodEndLabel);\n+        termGen.genReturnTerm(new Return(null), returnVarRefIndex, func, false, -1);\n+\n+        // Create Local Variable Table\n+        k = localVarOffset;\n+        // Add strand variable to LVT\n+        mv.visitLocalVariable(\"__strand\", String.format(\"L%s;\", STRAND), null, methodStartLabel, methodEndLabel,\n+                localVarOffset);\n+        while (k < localVars.size()) {\n+            BIRVariableDcl localVar = getVariableDcl(localVars.get(k));\n+            Label startLabel = methodStartLabel;\n+            Label endLabel = methodEndLabel;\n+            boolean tmpBoolParam = localVar.type.tag == TypeTags.BOOLEAN && localVar.name.value.startsWith(\"%syn\");\n+            if (!tmpBoolParam && (localVar.kind == VarKind.LOCAL || localVar.kind == VarKind.ARG)) {\n+                // local vars have visible range information\n+                if (localVar.kind == VarKind.LOCAL) {\n+//                    String startBBID = localVar.startBB.id.value;\n+//                    String endBBID = localVar.endBB.id.value;\n+                    int insOffset = localVar.insOffset;\n+                    if (localVar.startBB != null) {\n+                        startLabel = labelGen.getLabel(funcName + localVar.startBB.id.value + \"ins\" + insOffset);\n+                    }\n+                    if (localVar.endBB != null) {\n+                        endLabel = labelGen.getLabel(funcName + localVar.endBB.id.value + \"beforeTerm\");\n+                    }\n+                }\n+                String metaVarName = localVar.name.value;\n+                if (!\"\".equals(metaVarName) &&\n+                        // filter out compiler added vars\n+                        !((metaVarName.startsWith(\"$\") && metaVarName.endsWith(\"$\"))\n+                                || (metaVarName.startsWith(\"$$\") && metaVarName.endsWith(\"$$\"))\n+                                || metaVarName.startsWith(\"_$$_\"))) {\n+                    mv.visitLocalVariable(metaVarName, getJVMTypeSign(localVar.type), null,\n+                            startLabel, endLabel, indexMap.getIndex(localVar));\n+                }\n+            }\n+            k = k + 1;\n+        }\n+\n+        mv.visitMaxs(0, 0);\n+        mv.visitEnd();\n+    }\n+\n+    private static int[] toIntArray(List<Integer> states) {\n+\n+        int[] ints = new int[states.size()];\n+        for (int i = 0; i < states.size(); i++) {\n+            ints[i] = states.get(i);\n+        }\n+        return ints;\n+    }\n+\n+    private static void generateFrameClassFieldLoad(List<BIRVariableDcl> localVars, MethodVisitor mv,\n+                                                    BalToJVMIndexMap indexMap, String frameName, boolean useBString) {\n+\n+        int k = 0;\n+        while (k < localVars.size()) {\n+            BIRVariableDcl localVar = getVariableDcl(localVars.get(k));\n+            int index = indexMap.getIndex(localVar);\n+            BType bType = localVar.type;\n+            mv.visitInsn(DUP);\n+\n+            if (bType.tag == TypeTags.INT) {\n+                mv.visitFieldInsn(GETFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"), \"J\");\n+                mv.visitVarInsn(LSTORE, index);\n+            } else if (bType.tag == TypeTags.BYTE) {\n+                mv.visitFieldInsn(GETFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"), \"I\");\n+                mv.visitVarInsn(ISTORE, index);\n+            } else if (bType.tag == TypeTags.FLOAT) {\n+                mv.visitFieldInsn(GETFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"), \"D\");\n+                mv.visitVarInsn(DSTORE, index);\n+            } else if (bType.tag == TypeTags.STRING) {\n+                mv.visitFieldInsn(GETFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"),\n+                        String.format(\"L%s;\", useBString ? I_STRING_VALUE : STRING_VALUE));\n+                mv.visitVarInsn(ASTORE, index);\n+            } else if (bType.tag == TypeTags.DECIMAL) {\n+                mv.visitFieldInsn(GETFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"),\n+                        String.format(\"L%s;\", DECIMAL_VALUE));\n+                mv.visitVarInsn(ASTORE, index);\n+            } else if (bType.tag == TypeTags.BOOLEAN) {\n+                mv.visitFieldInsn(GETFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"), \"Z\");\n+                mv.visitVarInsn(ISTORE, index);\n+            } else if (bType.tag == TypeTags.MAP || bType.tag == TypeTags.RECORD) {\n+                mv.visitFieldInsn(GETFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"),\n+                        String.format(\"L%s;\", MAP_VALUE));\n+                mv.visitVarInsn(ASTORE, index);\n+            } else if (bType.tag == TypeTags.TABLE) {\n+                mv.visitFieldInsn(GETFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"),\n+                        String.format(\"L%s;\", TABLE_VALUE));\n+                mv.visitVarInsn(ASTORE, index);\n+            } else if (bType.tag == TypeTags.STREAM) {\n+                mv.visitFieldInsn(GETFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"),\n+                        String.format(\"L%s;\", STREAM_VALUE));\n+                mv.visitVarInsn(ASTORE, index);\n+            } else if (bType.tag == TypeTags.ARRAY ||\n+                    bType.tag == TypeTags.TUPLE) {\n+                mv.visitFieldInsn(GETFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"),\n+                        String.format(\"L%s;\", ARRAY_VALUE));\n+                mv.visitVarInsn(ASTORE, index);\n+            } else if (bType.tag == TypeTags.OBJECT || bType.tag == TypeTags.SERVICE) {\n+                mv.visitFieldInsn(GETFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"),\n+                        String.format(\"L%s;\", OBJECT_VALUE));\n+                mv.visitVarInsn(ASTORE, index);\n+            } else if (bType.tag == TypeTags.ERROR) {\n+                mv.visitFieldInsn(GETFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"),\n+                        String.format(\"L%s;\", ERROR_VALUE));\n+                mv.visitVarInsn(ASTORE, index);\n+            } else if (bType.tag == TypeTags.FUTURE) {\n+                mv.visitFieldInsn(GETFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"),\n+                        String.format(\"L%s;\", FUTURE_VALUE));\n+                mv.visitVarInsn(ASTORE, index);\n+            } else if (bType.tag == TypeTags.INVOKABLE) {\n+                mv.visitFieldInsn(GETFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"),\n+                        String.format(\"L%s;\", FUNCTION_POINTER));\n+                mv.visitVarInsn(ASTORE, index);\n+            } else if (bType.tag == TypeTags.TYPEDESC) {\n+                mv.visitFieldInsn(GETFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"),\n+                        String.format(\"L%s;\", TYPEDESC_VALUE));\n+                mv.visitVarInsn(ASTORE, index);\n+            } else if (bType.tag == TypeTags.NIL ||\n+                    bType.tag == TypeTags.ANY ||\n+                    bType.tag == TypeTags.ANYDATA ||\n+                    bType.tag == TypeTags.UNION ||\n+                    bType.tag == TypeTags.JSON ||\n+                    bType.tag == TypeTags.FINITE) {\n+                mv.visitFieldInsn(GETFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"),\n+                        String.format(\"L%s;\", OBJECT));\n+                mv.visitVarInsn(ASTORE, index);\n+            } else if (bType.tag == TypeTags.XML) {\n+                mv.visitFieldInsn(GETFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"),\n+                        String.format(\"L%s;\", XML_VALUE));\n+                mv.visitVarInsn(ASTORE, index);\n+            } else if (bType.tag == TypeTags.HANDLE) {\n+                mv.visitFieldInsn(GETFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"),\n+                        String.format(\"L%s;\", HANDLE_VALUE));\n+                mv.visitVarInsn(ASTORE, index);\n+            } else if (bType.tag == JTypeTags.JTYPE) {\n+                generateFrameClassJFieldLoad(localVar, mv, index, frameName);\n+            } else {\n+                throw new BLangCompilerException(\"JVM generation is not supported for type \" +\n+                        String.format(\"%s\", bType));\n+            }\n+            k = k + 1;\n+        }\n+\n+    }\n+\n+    private static void generateFrameClassJFieldLoad(BIRVariableDcl localVar, MethodVisitor mv,\n+                                                     int index, String frameName) {\n+\n+        JType jType = (JType) localVar.type;\n+\n+        if (jType.jTag == JTypeTags.JBYTE) {\n+            mv.visitFieldInsn(GETFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"), \"I\");\n+            mv.visitVarInsn(ISTORE, index);\n+        } else if (jType.jTag == JTypeTags.JCHAR) {\n+            mv.visitFieldInsn(GETFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"), \"I\");\n+            mv.visitVarInsn(ISTORE, index);\n+        } else if (jType.jTag == JTypeTags.JSHORT) {\n+            mv.visitFieldInsn(GETFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"), \"I\");\n+            mv.visitVarInsn(ISTORE, index);\n+        } else if (jType.jTag == JTypeTags.JINT) {\n+            mv.visitFieldInsn(GETFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"), \"I\");\n+            mv.visitVarInsn(ISTORE, index);\n+        } else if (jType.jTag == JTypeTags.JLONG) {\n+            mv.visitFieldInsn(GETFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"), \"J\");\n+            mv.visitVarInsn(LSTORE, index);\n+        } else if (jType.jTag == JTypeTags.JFLOAT) {\n+            mv.visitFieldInsn(GETFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"), \"F\");\n+            mv.visitVarInsn(FSTORE, index);\n+        } else if (jType.jTag == JTypeTags.JDOUBLE) {\n+            mv.visitFieldInsn(GETFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"), \"D\");\n+            mv.visitVarInsn(DSTORE, index);\n+        } else if (jType.jTag == JTypeTags.JBOOLEAN) {\n+            mv.visitFieldInsn(GETFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"), \"Z\");\n+            mv.visitVarInsn(ISTORE, index);\n+        } else if (jType.jTag == JTypeTags.JARRAY ||\n+                jType.jTag == JTypeTags.JREF) {\n+            mv.visitFieldInsn(GETFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"), getJTypeSignature(jType));\n+            mv.visitVarInsn(ASTORE, index);\n+        } else {\n+            throw new BLangCompilerException(\"JVM generation is not supported for type \" + String.format(\"%s\", jType));\n+        }\n+\n+    }\n+\n+    private static void generateFrameClassFieldUpdate(@Nilable List<BIRVariableDcl> localVars, MethodVisitor mv,\n+                                                      BalToJVMIndexMap indexMap, String frameName, boolean useBString) {\n+\n+        int k = 0;\n+        while (k < localVars.size()) {\n+            BIRVariableDcl localVar = getVariableDcl(localVars.get(k));\n+            int index = indexMap.getIndex(localVar);\n+            mv.visitInsn(DUP);\n+\n+            BType bType = localVar.type;\n+            if (bType.tag == TypeTags.INT) {\n+                mv.visitVarInsn(LLOAD, index);\n+                mv.visitFieldInsn(PUTFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"), \"J\");\n+            } else if (bType.tag == TypeTags.BYTE) {\n+                mv.visitVarInsn(ILOAD, index);\n+                mv.visitFieldInsn(PUTFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"), \"I\");\n+            } else if (bType.tag == TypeTags.FLOAT) {\n+                mv.visitVarInsn(DLOAD, index);\n+                mv.visitFieldInsn(PUTFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"), \"D\");\n+            } else if (bType.tag == TypeTags.STRING) {\n+                mv.visitVarInsn(ALOAD, index);\n+                mv.visitFieldInsn(PUTFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"),\n+                        String.format(\"L%s;\", useBString ? I_STRING_VALUE : STRING_VALUE));\n+            } else if (bType.tag == TypeTags.DECIMAL) {\n+                mv.visitVarInsn(ALOAD, index);\n+                mv.visitFieldInsn(PUTFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"),\n+                        String.format(\"L%s;\", DECIMAL_VALUE));\n+            } else if (bType.tag == TypeTags.BOOLEAN) {\n+                mv.visitVarInsn(ILOAD, index);\n+                mv.visitFieldInsn(PUTFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"), \"Z\");\n+            } else if (bType.tag == TypeTags.MAP ||\n+                    bType.tag == TypeTags.RECORD) {\n+                mv.visitVarInsn(ALOAD, index);\n+                mv.visitFieldInsn(PUTFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"),\n+                        String.format(\"L%s;\", MAP_VALUE));\n+            } else if (bType.tag == TypeTags.TABLE) {\n+                mv.visitVarInsn(ALOAD, index);\n+                mv.visitFieldInsn(PUTFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"),\n+                        String.format(\"L%s;\", TABLE_VALUE));\n+            } else if (bType.tag == TypeTags.STREAM) {\n+                mv.visitVarInsn(ALOAD, index);\n+                mv.visitFieldInsn(PUTFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"),\n+                        String.format(\"L%s;\", STREAM_VALUE));\n+            } else if (bType.tag == TypeTags.ARRAY ||\n+                    bType.tag == TypeTags.TUPLE) {\n+                mv.visitVarInsn(ALOAD, index);\n+                mv.visitFieldInsn(PUTFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"),\n+                        String.format(\"L%s;\", ARRAY_VALUE));\n+            } else if (bType.tag == TypeTags.ERROR) {\n+                mv.visitVarInsn(ALOAD, index);\n+                mv.visitFieldInsn(PUTFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"),\n+                        String.format(\"L%s;\", ERROR_VALUE));\n+            } else if (bType.tag == TypeTags.FUTURE) {\n+                mv.visitVarInsn(ALOAD, index);\n+                mv.visitFieldInsn(PUTFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"),\n+                        String.format(\"L%s;\", FUTURE_VALUE));\n+            } else if (bType.tag == TypeTags.TYPEDESC) {\n+                mv.visitVarInsn(ALOAD, index);\n+                mv.visitTypeInsn(CHECKCAST, TYPEDESC_VALUE);\n+                mv.visitFieldInsn(PUTFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"),\n+                        String.format(\"L%s;\", TYPEDESC_VALUE));\n+            } else if (bType.tag == TypeTags.OBJECT || bType.tag == TypeTags.SERVICE) {\n+                mv.visitVarInsn(ALOAD, index);\n+                mv.visitFieldInsn(PUTFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"),\n+                        String.format(\"L%s;\", OBJECT_VALUE));\n+            } else if (bType.tag == TypeTags.INVOKABLE) {\n+                mv.visitVarInsn(ALOAD, index);\n+                mv.visitFieldInsn(PUTFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"),\n+                        String.format(\"L%s;\", FUNCTION_POINTER));\n+            } else if (bType.tag == TypeTags.NIL ||\n+                    bType.tag == TypeTags.ANY ||\n+                    bType.tag == TypeTags.ANYDATA ||\n+                    bType.tag == TypeTags.UNION ||\n+                    bType.tag == TypeTags.JSON ||\n+                    bType.tag == TypeTags.FINITE) {\n+                mv.visitVarInsn(ALOAD, index);\n+                mv.visitFieldInsn(PUTFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"),\n+                        String.format(\"L%s;\", OBJECT));\n+            } else if (bType.tag == TypeTags.XML) {\n+                mv.visitVarInsn(ALOAD, index);\n+                mv.visitFieldInsn(PUTFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"),\n+                        String.format(\"L%s;\", XML_VALUE));\n+            } else if (bType.tag == TypeTags.HANDLE) {\n+                mv.visitVarInsn(ALOAD, index);\n+                mv.visitFieldInsn(PUTFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"),\n+                        String.format(\"L%s;\", HANDLE_VALUE));\n+            } else if (bType.tag == JTypeTags.JTYPE) {\n+                generateFrameClassJFieldUpdate(localVar, mv, index, frameName);\n+            } else {\n+                throw new BLangCompilerException(\"JVM generation is not supported for type \" +\n+                        String.format(\"%s\", bType));\n+            }\n+            k = k + 1;\n+        }\n+    }\n+\n+    private static void generateFrameClassJFieldUpdate(BIRVariableDcl localVar, MethodVisitor mv,\n+                                                       int index, String frameName) {\n+\n+        JType jType = (JType) localVar.type;\n+        if (jType.jTag == JTypeTags.JBYTE) {\n+            mv.visitVarInsn(ILOAD, index);\n+            mv.visitFieldInsn(PUTFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"), \"B\");\n+        } else if (jType.jTag == JTypeTags.JCHAR) {\n+            mv.visitVarInsn(ILOAD, index);\n+            mv.visitFieldInsn(PUTFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"), \"C\");\n+        } else if (jType.jTag == JTypeTags.JSHORT) {\n+            mv.visitVarInsn(ILOAD, index);\n+            mv.visitFieldInsn(PUTFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"), \"S\");\n+        } else if (jType.jTag == JTypeTags.JINT) {\n+            mv.visitVarInsn(ILOAD, index);\n+            mv.visitFieldInsn(PUTFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"), \"I\");\n+        } else if (jType.jTag == JTypeTags.JLONG) {\n+            mv.visitVarInsn(LLOAD, index);\n+            mv.visitFieldInsn(PUTFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"), \"J\");\n+        } else if (jType.jTag == JTypeTags.JFLOAT) {\n+            mv.visitVarInsn(FLOAD, index);\n+            mv.visitFieldInsn(PUTFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"), \"F\");\n+        } else if (jType.jTag == JTypeTags.JDOUBLE) {\n+            mv.visitVarInsn(DLOAD, index);\n+            mv.visitFieldInsn(PUTFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"), \"D\");\n+        } else if (jType.jTag == JTypeTags.JBOOLEAN) {\n+            mv.visitVarInsn(ILOAD, index);\n+            mv.visitFieldInsn(PUTFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"), \"Z\");\n+        } else if (jType.jTag == JTypeTags.JARRAY || jType.jTag == JTypeTags.JREF) {\n+            String classSig = getJTypeSignature(jType);\n+            String className = getSignatureForJType(jType);\n+            mv.visitVarInsn(ALOAD, index);\n+            mv.visitTypeInsn(CHECKCAST, className);\n+            mv.visitFieldInsn(PUTFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"), classSig);\n+        } else {\n+            throw new BLangCompilerException(\"JVM generation is not supported for type \" + String.format(\"%s\", jType));\n+        }\n+    }\n+\n+    private static String getJVMTypeSign(BType bType) {\n+\n+        String jvmType = \"\";\n+        if (bType.tag == TypeTags.INT) {\n+            jvmType = \"J\";\n+        } else if (bType.tag == TypeTags.BYTE) {\n+            jvmType = \"I\";\n+        } else if (bType.tag == TypeTags.FLOAT) {\n+            jvmType = \"D\";\n+        } else if (bType.tag == TypeTags.BOOLEAN) {\n+            jvmType = \"Z\";\n+        } else if (bType.tag == TypeTags.STRING) {\n+            jvmType = String.format(\"L%s;\", STRING_VALUE);\n+        } else if (bType.tag == TypeTags.DECIMAL) {\n+            jvmType = String.format(\"L%s;\", DECIMAL_VALUE);\n+        } else if (bType.tag == TypeTags.MAP || bType.tag == TypeTags.RECORD) {\n+            jvmType = String.format(\"L%s;\", MAP_VALUE);\n+        } else if (bType.tag == TypeTags.TABLE) {\n+            jvmType = String.format(\"L%s;\", TABLE_VALUE);\n+        } else if (bType.tag == TypeTags.STREAM) {\n+            jvmType = String.format(\"L%s;\", STREAM_VALUE);\n+        } else if (bType.tag == TypeTags.ARRAY ||\n+                bType.tag == TypeTags.TUPLE) {\n+            jvmType = String.format(\"L%s;\", ARRAY_VALUE);\n+        } else if (bType.tag == TypeTags.OBJECT || bType.tag == TypeTags.SERVICE) {\n+            jvmType = String.format(\"L%s;\", OBJECT_VALUE);\n+        } else if (bType.tag == TypeTags.ERROR) {\n+            jvmType = String.format(\"L%s;\", ERROR_VALUE);\n+        } else if (bType.tag == TypeTags.FUTURE) {\n+            jvmType = String.format(\"L%s;\", FUTURE_VALUE);\n+        } else if (bType.tag == TypeTags.INVOKABLE) {\n+            jvmType = String.format(\"L%s;\", FUNCTION_POINTER);\n+        } else if (bType.tag == TypeTags.HANDLE) {\n+            jvmType = String.format(\"L%s;\", HANDLE_VALUE);\n+        } else if (bType.tag == TypeTags.TYPEDESC) {\n+            jvmType = String.format(\"L%s;\", TYPEDESC_VALUE);\n+        } else if (bType.tag == TypeTags.NIL\n+                || bType.tag == TypeTags.ANY\n+                || bType.tag == TypeTags.ANYDATA\n+                || bType.tag == TypeTags.UNION\n+                || bType.tag == TypeTags.JSON\n+                || bType.tag == TypeTags.FINITE) {\n+            jvmType = String.format(\"L%s;\", OBJECT);\n+        } else if (bType.tag == JTypeTags.JTYPE) {\n+            jvmType = getJTypeSignature((JType) bType);\n+        } else if (bType.tag == TypeTags.XML) {\n+            jvmType = String.format(\"L%s;\", XML_VALUE);\n+        } else {\n+            throw new BLangCompilerException(\"JVM code generation is not supported for type \" +\n+                    String.format(\"%s\", bType));\n+        }\n+        return jvmType;\n+    }\n+\n+    public static void generateBasicBlocks(MethodVisitor mv, @Nilable List<BIRBasicBlock> basicBlocks,\n+                                           LabelGenerator labelGen, ErrorHandlerGenerator errorGen,\n+                                           InstructionGenerator instGen, TerminatorGenerator termGen,\n+                                           BIRFunction func, int returnVarRefIndex, int stateVarIndex,\n+                                           int localVarOffset, boolean isArg, BIRPackage module,\n+                                           String currentPackageName, @Nilable BType attachedType,\n+                                           boolean isObserved /* = false */,\n+                                           boolean isService /* = false */, String serviceName /* = \"\" */,\n+                                           boolean useBString /* = false */) {\n+\n+        int j = 0;\n+        String funcName = cleanupFunctionName(func.name.value);\n+\n+        int caseIndex = 0;\n+\n+        while (j < basicBlocks.size()) {\n+            BIRBasicBlock bb = getBasicBlock(basicBlocks.get(j));\n+            String currentBBName = String.format(\"%s\", bb.id.value);\n+\n+            // create jvm label\n+            Label bbLabel = labelGen.getLabel(funcName + bb.id.value);\n+            mv.visitLabel(bbLabel);\n+            if (j == 0 && !isArg) {\n+                // SIPUSH range is (-32768 to 32767) so if the state index goes beyond that, need to use visitLdcInsn\n+                mv.visitIntInsn(SIPUSH, caseIndex);\n+                mv.visitVarInsn(ISTORE, stateVarIndex);\n+                caseIndex += 1;\n+            }\n+\n+            String serviceOrConnectorName = serviceName;\n+            if (isObserved && j == 0) {\n+                String observationStartMethod = isService ? \"startResourceObservation\" : \"startCallableObservation\";\n+                if (!isService && attachedType != null && attachedType.tag == TypeTags.OBJECT) {\n+                    // add module org and module name to remote spans.\n+                    BObjectType attachedTypeObj = (BObjectType) attachedType;\n+                    serviceOrConnectorName = getFullQualifiedRemoteFunctionName(\n+                            attachedTypeObj.tsymbol.pkgID.orgName.value,\n+                            attachedTypeObj.tsymbol.pkgID.name.value, serviceName);\n+                }\n+                emitStartObservationInvocation(mv, localVarOffset, serviceOrConnectorName, funcName,\n+                        observationStartMethod);\n+            }\n+\n+            // generate instructions\n+            int m = 0;\n+            int insCount = bb.instructions.size();\n+\n+            InstructionKind insKind;\n+            while (m < insCount) {\n+                Label insLabel = labelGen.getLabel(funcName + bb.id.value + \"ins\" + m);\n+                mv.visitLabel(insLabel);\n+                @Nilable BIRInstruction inst = bb.instructions.get(m);\n+                if (inst == null) {\n+                    continue;\n+                } else {\n+                    insKind = inst.getKind();\n+                    generateDiagnosticPos(((BIRNode) inst).pos, mv);\n+                }\n+\n+                if (inst instanceof BinaryOp) {\n+                    instGen.generateBinaryOpIns((BinaryOp) inst);\n+                } else {\n+                    switch (insKind) {\n+                        case MOVE:\n+                            instGen.generateMoveIns((Move) inst);\n+                            break;\n+                        case CONST_LOAD:\n+                            instGen.generateConstantLoadIns((ConstantLoad) inst, useBString);\n+                            break;\n+                        case NEW_STRUCTURE:\n+                            instGen.generateMapNewIns((NewStructure) inst, localVarOffset);\n+                            break;\n+                        case NEW_INSTANCE:\n+                            instGen.generateObjectNewIns((NewInstance) inst, localVarOffset);\n+                            break;\n+                        case MAP_STORE:\n+                            instGen.generateMapStoreIns((FieldAccess) inst);\n+                            break;\n+                        case NEW_ARRAY:\n+                            instGen.generateArrayNewIns((NewArray) inst);\n+                            break;\n+                        case ARRAY_STORE:\n+                            instGen.generateArrayStoreIns((FieldAccess) inst);\n+                            break;\n+                        case MAP_LOAD:\n+                            instGen.generateMapLoadIns((FieldAccess) inst);\n+                            break;\n+                        case ARRAY_LOAD:\n+                            instGen.generateArrayValueLoad((FieldAccess) inst);\n+                            break;\n+                        case NEW_ERROR:\n+                            instGen.generateNewErrorIns((NewError) inst);\n+                            break;\n+                        case TYPE_CAST:\n+                            instGen.generateCastIns((TypeCast) inst);\n+                            break;\n+                        case IS_LIKE:\n+                            instGen.generateIsLikeIns((IsLike) inst);\n+                            break;\n+                        case TYPE_TEST:\n+                            instGen.generateTypeTestIns((TypeTest) inst);\n+                            break;\n+                        case OBJECT_STORE:\n+                            instGen.generateObjectStoreIns((FieldAccess) inst, useBString);\n+                            break;\n+                        case OBJECT_LOAD:\n+                            instGen.generateObjectLoadIns((FieldAccess) inst);\n+                            break;\n+                        case NEW_XML_ELEMENT:\n+                            instGen.generateNewXMLElementIns((NewXMLElement) inst);\n+                            break;\n+                        case NEW_XML_TEXT:\n+                            instGen.generateNewXMLTextIns((NewXMLText) inst);\n+                            break;\n+                        case NEW_XML_COMMENT:\n+                            instGen.generateNewXMLCommentIns((NewXMLComment) inst);\n+                            break;\n+                        case NEW_XML_PI:\n+                            instGen.generateNewXMLProcIns((NewXMLProcIns) inst);\n+                            break;\n+                        case NEW_XML_QNAME:\n+                            instGen.generateNewXMLQNameIns((NewXMLQName) inst);\n+                            break;\n+                        case NEW_STRING_XML_QNAME:\n+                            instGen.generateNewStringXMLQNameIns((NewStringXMLQName) inst);\n+                            break;\n+                        case XML_SEQ_STORE:\n+                            instGen.generateXMLStoreIns((XMLAccess) inst);\n+                            break;\n+                        case XML_SEQ_LOAD:\n+                            instGen.generateXMLLoadIns((FieldAccess) inst);\n+                            break;\n+                        case XML_LOAD:\n+                            instGen.generateXMLLoadIns((FieldAccess) inst);\n+                            break;\n+                        case XML_LOAD_ALL:\n+                            instGen.generateXMLLoadAllIns((XMLAccess) inst);\n+                            break;\n+                        case XML_ATTRIBUTE_STORE:\n+                            instGen.generateXMLAttrStoreIns((FieldAccess) inst);\n+                            break;\n+                        case XML_ATTRIBUTE_LOAD:\n+                            instGen.generateXMLAttrLoadIns((FieldAccess) inst);\n+                            break;\n+                        case FP_LOAD:\n+                            instGen.generateFPLoadIns((FPLoad) inst);\n+                            break;\n+                        case STRING_LOAD:\n+                            instGen.generateStringLoadIns((FieldAccess) inst);\n+                            break;\n+                        case NEW_TABLE:\n+                            instGen.generateTableNewIns((NewTable) inst);\n+                            break;\n+                        case TYPEOF:\n+                            instGen.generateTypeofIns((UnaryOP) inst);\n+                            break;\n+                        case NOT:\n+                            instGen.generateNotIns((UnaryOP) inst);\n+                            break;\n+                        case NEW_TYPEDESC:\n+                            instGen.generateNewTypedescIns((NewTypeDesc) inst);\n+                            break;\n+                        case NEGATE:\n+                            instGen.generateNegateIns((UnaryOP) inst);\n+                            break;\n+                        case PLATFORM:\n+                            instGen.generatePlatformIns((JInstruction) inst);\n+                            break;\n+                        default:\n+                            throw new BLangCompilerException(\"JVM generation is not supported for operation \" +\n+                                    String.format(\"%s\", inst));\n+                    }\n+                }\n+                m += 1;\n+            }\n+\n+            Label bbEndLable = labelGen.getLabel(funcName + bb.id.value + \"beforeTerm\");\n+            mv.visitLabel(bbEndLable);\n+\n+            BIRTerminator terminator = bb.terminator;\n+            if (!isArg) {\n+                // SIPUSH range is (-32768 to 32767) so if the state index goes beyond that, need to use visitLdcInsn\n+                mv.visitIntInsn(SIPUSH, caseIndex);\n+                mv.visitVarInsn(ISTORE, stateVarIndex);\n+                caseIndex += 1;\n+            }\n+\n+            // process terminator\n+            boolean isTerminatorTrapped = false;\n+            if (!isArg || (isArg && !(terminator instanceof Return))) {\n+                generateDiagnosticPos(terminator.pos, mv);\n+                if (isModuleInitFunction(module, func) && terminator instanceof Return) {\n+                    generateAnnotLoad(mv, module.typeDefs, getPackageName(module.org.value, module.name.value));\n+                }\n+                termGen.genTerminator(terminator, func, funcName, localVarOffset, returnVarRefIndex, attachedType,\n+                        isObserved);\n+            }\n+\n+            errorGen.generateTryCatch(func, funcName, bb, instGen, termGen, labelGen);\n+\n+            BIRBasicBlock thenBB = terminator.thenBB;\n+            if (thenBB instanceof BIRBasicBlock) {\n+                genYieldCheck(mv, termGen.labelGen, thenBB, funcName, localVarOffset);\n+            }\n+            j += 1;\n+        }\n+    }\n+\n+    private static void genYieldCheck(MethodVisitor mv, LabelGenerator labelGen, BIRBasicBlock thenBB, String funcName,\n+                                      int localVarOffset) {\n+\n+        mv.visitVarInsn(ALOAD, localVarOffset);\n+        mv.visitMethodInsn(INVOKEVIRTUAL, STRAND, \"isYielded\", \"()Z\", false);\n+        Label yieldLabel = labelGen.getLabel(funcName + \"yield\");\n+        mv.visitJumpInsn(IFNE, yieldLabel);\n+\n+        // goto thenBB\n+        Label gotoLabel = labelGen.getLabel(funcName + thenBB.id.value);\n+        mv.visitJumpInsn(GOTO, gotoLabel);\n+    }\n+\n+    static void generateLambdaMethod(BIRInstruction ins, ClassWriter cw, String lambdaName) {\n+\n+        @Nilable BType lhsType;\n+        String orgName;\n+        String moduleName;\n+        String funcName;\n+        int paramIndex = 1;\n+        boolean isVirtual = false;\n+        InstructionKind kind = ins.getKind();\n+        if (kind == InstructionKind.ASYNC_CALL) {\n+            AsyncCall asyncIns = (AsyncCall) ins;\n+            isVirtual = asyncIns.isVirtual;\n+            lhsType = asyncIns.lhsOp != null ? asyncIns.lhsOp.variableDcl.type : null;\n+            orgName = asyncIns.calleePkg.orgName.value;\n+            moduleName = asyncIns.calleePkg.name.value;\n+            funcName = asyncIns.name.getValue();\n+        } else if (kind == InstructionKind.FP_LOAD) {\n+            FPLoad fpIns = (FPLoad) ins;\n+            lhsType = fpIns.lhsOp.variableDcl.type;\n+            orgName = fpIns.pkgId.orgName.value;\n+            moduleName = fpIns.pkgId.name.value;\n+            funcName = fpIns.funcName.getValue();\n+        } else {\n+            throw new BLangCompilerException(\"JVM lambda method generation is not supported for instruction \" +\n+                    String.format(\"%s\", ins));\n+        }\n+\n+        boolean isExternFunction = isExternStaticFunctionCall(ins);\n+        boolean isBuiltinModule = isBallerinaBuiltinModule(orgName, moduleName);\n+\n+        BType returnType = new BNilType();\n+        if (lhsType.tag == TypeTags.FUTURE) {\n+            returnType = ((BFutureType) lhsType).constraint;\n+        } else if (ins instanceof FPLoad) {\n+            returnType = ((FPLoad) ins).retType;\n+            if (returnType.tag == TypeTags.INVOKABLE) {\n+                returnType = ((BInvokableType) returnType).retType;\n+            }\n+        } else {\n+            throw new BLangCompilerException(\"JVM generation is not supported for async return type \" +\n+                    String.format(\"%s\", lhsType));\n+        }\n+\n+        int closureMapsCount = 0;\n+        if (kind == InstructionKind.FP_LOAD) {\n+            closureMapsCount = ((FPLoad) ins).closureMaps.size();\n+        }\n+        String closureMapsDesc = getMapValueDesc(closureMapsCount);\n+\n+        MethodVisitor mv;\n+        mv = cw.visitMethod(ACC_PUBLIC + ACC_STATIC, cleanupFunctionName(lambdaName),\n+                String.format(\"(%s[L%s;)L%s;\", closureMapsDesc, OBJECT, OBJECT), null, null);\n+\n+        mv.visitCode();\n+        // load strand as first arg\n+        // strand and other args are in a object[] param. This param comes after closure maps.\n+        // hence the closureMapsCount is equal to the array's param index.\n+        mv.visitVarInsn(ALOAD, closureMapsCount);\n+        mv.visitInsn(ICONST_0);\n+        mv.visitInsn(AALOAD);\n+        mv.visitTypeInsn(CHECKCAST, STRAND);\n+\n+        if (isExternFunction) {\n+            Label blockedOnExternLabel = new Label();\n+\n+            mv.visitInsn(DUP);\n+\n+            mv.visitMethodInsn(INVOKEVIRTUAL, STRAND, \"isBlockedOnExtern\", \"()Z\", false);\n+            mv.visitJumpInsn(IFEQ, blockedOnExternLabel);\n+\n+            mv.visitInsn(DUP);\n+            mv.visitInsn(ICONST_0);\n+            mv.visitFieldInsn(PUTFIELD, STRAND, \"blockedOnExtern\", \"Z\");\n+\n+            mv.visitInsn(DUP);\n+            mv.visitFieldInsn(GETFIELD, STRAND, \"returnValue\", \"Ljava/lang/Object;\");\n+            mv.visitInsn(ARETURN);\n+\n+            mv.visitLabel(blockedOnExternLabel);\n+        }\n+        @Nilable List<BType> paramBTypes = new ArrayList<>();\n+\n+        if (kind == InstructionKind.ASYNC_CALL) {\n+            AsyncCall asyncIns = (AsyncCall) ins;\n+            @Nilable List<BIROperand> paramTypes = asyncIns.args;\n+            if (isVirtual) {\n+                genLoadDataForObjectAttachedLambdas(asyncIns, mv, closureMapsCount, paramTypes, isBuiltinModule);\n+                int paramTypeIndex = 1;\n+                paramIndex = 2;\n+                while (paramTypeIndex < paramTypes.size()) {\n+                    generateObjectArgs(mv, paramIndex);\n+                    paramTypeIndex += 1;\n+                    paramIndex += 1;\n+                    if (!isBuiltinModule) {\n+                        generateObjectArgs(mv, paramIndex);\n+                        paramIndex += 1;\n+               ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82df207efdc85acd9646a1aae1461f7d1f7bbc5f"}, "originalPosition": 1451}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1088, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}