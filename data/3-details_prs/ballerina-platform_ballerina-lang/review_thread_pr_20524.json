{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzU5MzkzMDU3", "number": 20524, "reviewThreads": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wN1QwNDozMzoxOVrODWJkxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wN1QwNDo1NTowNFrODWJs3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0NTUyMTM0OnYy", "diffSide": "RIGHT", "path": "language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/completions/sourceprune/CompletionsTokenTraverserFactory.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wN1QwNDozMzoxOVrOFavpgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOFQwNjoxOTo0MlrOFbNkXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU4Nzk3MA==", "bodyText": "Shall we add a doc comment for the public method?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20524#discussion_r363587970", "createdAt": "2020-01-07T04:33:19Z", "author": {"login": "nadeeshaan"}, "path": "language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/completions/sourceprune/CompletionsTokenTraverserFactory.java", "diffHunk": "@@ -0,0 +1,117 @@\n+/*\n+  Copyright (c) 2019, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+\n+  Licensed under the Apache License, Version 2.0 (the \"License\");\n+  you may not use this file except in compliance with the License.\n+  You may obtain a copy of the License at\n+\n+  http://www.apache.org/licenses/LICENSE-2.0\n+\n+  Unless required by applicable law or agreed to in writing, software\n+  distributed under the License is distributed on an \"AS IS\" BASIS,\n+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+  See the License for the specific language governing permissions and\n+  limitations under the License.\n+ */\n+package org.ballerinalang.langserver.completions.sourceprune;\n+\n+import org.antlr.v4.runtime.TokenStream;\n+import org.ballerinalang.langserver.common.utils.CommonUtil;\n+import org.ballerinalang.langserver.compiler.workspace.WorkspaceDocumentException;\n+import org.ballerinalang.langserver.compiler.workspace.WorkspaceDocumentManager;\n+import org.ballerinalang.langserver.sourceprune.SourcePruneContext;\n+import org.ballerinalang.langserver.sourceprune.TokenTraverser;\n+import org.ballerinalang.langserver.sourceprune.TokenTraverserFactory;\n+import org.wso2.ballerinalang.compiler.parser.antlr4.BallerinaParser;\n+\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * Factory class for providing token traversers and related artifacts for 'completions' service operation.\n+ */\n+public class CompletionsTokenTraverserFactory implements TokenTraverserFactory {\n+    private final SourcePruneContext sourcePruneCtx;\n+    private final boolean pruneTokens;\n+    private final TokenStream tokenStream;\n+\n+    private static final List<Integer> BLOCK_REMOVE_KW_TERMINALS;\n+    private static final List<Integer> LHS_TRAVERSE_TERMINALS;\n+    private static final List<Integer> RHS_TRAVERSE_TERMINALS;\n+\n+    static {\n+        BLOCK_REMOVE_KW_TERMINALS = Arrays.asList(\n+                BallerinaParser.SERVICE, BallerinaParser.FUNCTION, BallerinaParser.TYPE, BallerinaParser.MATCH,\n+                BallerinaParser.FOREACH, BallerinaParser.WORKER\n+        );\n+        LHS_TRAVERSE_TERMINALS = Arrays.asList(\n+                BallerinaParser.LEFT_BRACE, BallerinaParser.RIGHT_BRACE, BallerinaParser.SEMICOLON,\n+                BallerinaParser.COMMA, BallerinaParser.LEFT_PARENTHESIS, BallerinaParser.RIGHT_PARENTHESIS,\n+                BallerinaParser.LT, BallerinaParser.RETURNS, BallerinaParser.TRANSACTION,\n+                BallerinaParser.LEFT_CLOSED_RECORD_DELIMITER, BallerinaParser.LEFT_BRACKET\n+        );\n+        RHS_TRAVERSE_TERMINALS = Arrays.asList(\n+                BallerinaParser.SEMICOLON, BallerinaParser.DocumentationLineStart,\n+                BallerinaParser.AT, BallerinaParser.LEFT_BRACE, BallerinaParser.RIGHT_BRACE,\n+                BallerinaParser.RIGHT_PARENTHESIS, BallerinaParser.IMPORT, BallerinaParser.GT,\n+                BallerinaParser.XMLNS, BallerinaParser.SERVICE, BallerinaParser.PUBLIC, BallerinaParser.PRIVATE,\n+                BallerinaParser.REMOTE, BallerinaParser.FUNCTION, BallerinaParser.TYPE, BallerinaParser.ANNOTATION,\n+                BallerinaParser.CONST, BallerinaParser.RIGHT_BRACKET, BallerinaParser.RIGHT_CLOSED_RECORD_DELIMITER,\n+                BallerinaParser.RESOURCE, BallerinaParser.LISTENER, BallerinaParser.MATCH, BallerinaParser.IF,\n+                BallerinaParser.WHILE, BallerinaParser.FOREACH, BallerinaParser.BREAK, BallerinaParser.BREAK,\n+                BallerinaParser.FORK, BallerinaParser.THROW, BallerinaParser.TRANSACTION, BallerinaParser.WORKER\n+        );\n+    }\n+\n+    public CompletionsTokenTraverserFactory(Path filePath, WorkspaceDocumentManager documentManager,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89a10b44bdbeb4e9bc902a4e2c2be5307df59e9f"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDA3ODE3NA==", "bodyText": "Added missing doc comments in other places. This is a constructor which we usually don't add doc comments since class level doc comment is already there. For the sake of consistency let's keep this as it is. WDYT?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20524#discussion_r364078174", "createdAt": "2020-01-08T06:19:42Z", "author": {"login": "rasika"}, "path": "language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/completions/sourceprune/CompletionsTokenTraverserFactory.java", "diffHunk": "@@ -0,0 +1,117 @@\n+/*\n+  Copyright (c) 2019, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+\n+  Licensed under the Apache License, Version 2.0 (the \"License\");\n+  you may not use this file except in compliance with the License.\n+  You may obtain a copy of the License at\n+\n+  http://www.apache.org/licenses/LICENSE-2.0\n+\n+  Unless required by applicable law or agreed to in writing, software\n+  distributed under the License is distributed on an \"AS IS\" BASIS,\n+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+  See the License for the specific language governing permissions and\n+  limitations under the License.\n+ */\n+package org.ballerinalang.langserver.completions.sourceprune;\n+\n+import org.antlr.v4.runtime.TokenStream;\n+import org.ballerinalang.langserver.common.utils.CommonUtil;\n+import org.ballerinalang.langserver.compiler.workspace.WorkspaceDocumentException;\n+import org.ballerinalang.langserver.compiler.workspace.WorkspaceDocumentManager;\n+import org.ballerinalang.langserver.sourceprune.SourcePruneContext;\n+import org.ballerinalang.langserver.sourceprune.TokenTraverser;\n+import org.ballerinalang.langserver.sourceprune.TokenTraverserFactory;\n+import org.wso2.ballerinalang.compiler.parser.antlr4.BallerinaParser;\n+\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * Factory class for providing token traversers and related artifacts for 'completions' service operation.\n+ */\n+public class CompletionsTokenTraverserFactory implements TokenTraverserFactory {\n+    private final SourcePruneContext sourcePruneCtx;\n+    private final boolean pruneTokens;\n+    private final TokenStream tokenStream;\n+\n+    private static final List<Integer> BLOCK_REMOVE_KW_TERMINALS;\n+    private static final List<Integer> LHS_TRAVERSE_TERMINALS;\n+    private static final List<Integer> RHS_TRAVERSE_TERMINALS;\n+\n+    static {\n+        BLOCK_REMOVE_KW_TERMINALS = Arrays.asList(\n+                BallerinaParser.SERVICE, BallerinaParser.FUNCTION, BallerinaParser.TYPE, BallerinaParser.MATCH,\n+                BallerinaParser.FOREACH, BallerinaParser.WORKER\n+        );\n+        LHS_TRAVERSE_TERMINALS = Arrays.asList(\n+                BallerinaParser.LEFT_BRACE, BallerinaParser.RIGHT_BRACE, BallerinaParser.SEMICOLON,\n+                BallerinaParser.COMMA, BallerinaParser.LEFT_PARENTHESIS, BallerinaParser.RIGHT_PARENTHESIS,\n+                BallerinaParser.LT, BallerinaParser.RETURNS, BallerinaParser.TRANSACTION,\n+                BallerinaParser.LEFT_CLOSED_RECORD_DELIMITER, BallerinaParser.LEFT_BRACKET\n+        );\n+        RHS_TRAVERSE_TERMINALS = Arrays.asList(\n+                BallerinaParser.SEMICOLON, BallerinaParser.DocumentationLineStart,\n+                BallerinaParser.AT, BallerinaParser.LEFT_BRACE, BallerinaParser.RIGHT_BRACE,\n+                BallerinaParser.RIGHT_PARENTHESIS, BallerinaParser.IMPORT, BallerinaParser.GT,\n+                BallerinaParser.XMLNS, BallerinaParser.SERVICE, BallerinaParser.PUBLIC, BallerinaParser.PRIVATE,\n+                BallerinaParser.REMOTE, BallerinaParser.FUNCTION, BallerinaParser.TYPE, BallerinaParser.ANNOTATION,\n+                BallerinaParser.CONST, BallerinaParser.RIGHT_BRACKET, BallerinaParser.RIGHT_CLOSED_RECORD_DELIMITER,\n+                BallerinaParser.RESOURCE, BallerinaParser.LISTENER, BallerinaParser.MATCH, BallerinaParser.IF,\n+                BallerinaParser.WHILE, BallerinaParser.FOREACH, BallerinaParser.BREAK, BallerinaParser.BREAK,\n+                BallerinaParser.FORK, BallerinaParser.THROW, BallerinaParser.TRANSACTION, BallerinaParser.WORKER\n+        );\n+    }\n+\n+    public CompletionsTokenTraverserFactory(Path filePath, WorkspaceDocumentManager documentManager,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU4Nzk3MA=="}, "originalCommit": {"oid": "89a10b44bdbeb4e9bc902a4e2c2be5307df59e9f"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0NTUyMjIwOnYy", "diffSide": "RIGHT", "path": "language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/completions/sourceprune/LHSCompletionsTokenTraverser.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wN1QwNDozNDoyOFrOFavp_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wN1QwNDozNDoyOFrOFavp_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU4ODA5NQ==", "bodyText": "Is it possible to make the class package-private if we do not expose this as a public API?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20524#discussion_r363588095", "createdAt": "2020-01-07T04:34:28Z", "author": {"login": "nadeeshaan"}, "path": "language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/completions/sourceprune/LHSCompletionsTokenTraverser.java", "diffHunk": "@@ -32,7 +35,7 @@\n  * \n  * @since 0.995.0\n  */\n-class LHSTokenTraverser extends AbstractTokenTraverser {\n+public class LHSCompletionsTokenTraverser extends AbstractTokenTraverser {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89a10b44bdbeb4e9bc902a4e2c2be5307df59e9f"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0NTUyMjg3OnYy", "diffSide": "RIGHT", "path": "language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/completions/sourceprune/RHSCompletionsTokenTraverser.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wN1QwNDozNToyNFrOFavqbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wN1QwNDozNToyNFrOFavqbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU4ODIwNg==", "bodyText": "Is it possible to make the class package-private since we do not expose this as a public API?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20524#discussion_r363588206", "createdAt": "2020-01-07T04:35:24Z", "author": {"login": "nadeeshaan"}, "path": "language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/completions/sourceprune/RHSCompletionsTokenTraverser.java", "diffHunk": "@@ -29,7 +32,7 @@\n  * \n  * @since 0.995.0\n  */\n-class RHSTokenTraverser extends AbstractTokenTraverser {\n+public class RHSCompletionsTokenTraverser extends AbstractTokenTraverser {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89a10b44bdbeb4e9bc902a4e2c2be5307df59e9f"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0NTUyMzYyOnYy", "diffSide": "RIGHT", "path": "language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/completions/util/CompletionUtil.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wN1QwNDozNjowN1rOFavq2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wN1QwNDozNjowN1rOFavq2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU4ODMxNQ==", "bodyText": "Missing doc comment for the public method", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20524#discussion_r363588315", "createdAt": "2020-01-07T04:36:07Z", "author": {"login": "nadeeshaan"}, "path": "language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/completions/util/CompletionUtil.java", "diffHunk": "@@ -126,4 +135,20 @@ private static void setInvocationOrInteractionOrFieldAccessToken(LSContext conte\n         }\n         context.put(CompletionKeys.INVOCATION_TOKEN_TYPE_KEY, resultToken);\n     }\n+\n+    public static void pruneSource(LSContext lsContext) throws SourcePruneException, WorkspaceDocumentException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89a10b44bdbeb4e9bc902a4e2c2be5307df59e9f"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0NTUyNTQ0OnYy", "diffSide": "RIGHT", "path": "language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/signature/SignatureHelpUtil.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wN1QwNDozNzo1OVrOFavr3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wN1QwNDozNzo1OVrOFavr3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU4ODU3Mg==", "bodyText": "Shall we remove the Commented code snippet?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20524#discussion_r363588572", "createdAt": "2020-01-07T04:37:59Z", "author": {"login": "nadeeshaan"}, "path": "language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/signature/SignatureHelpUtil.java", "diffHunk": "@@ -210,31 +133,66 @@ private SignatureHelpUtil() {\n         return new ImmutablePair<>(parseAndGetFunctionInvocationPath(subRule, serviceContext), paramIndex);\n     }\n \n-    private static List<String> getSourcePrunedFunctionInvocation(LSServiceOperationContext serviceContext) {\n+    private static Pair<String, Integer> extractSourcePrunedInvocationDetails(\n+            LSServiceOperationContext serviceContext) {\n+        int parameterOffset = 0;\n         // Collect source-pruned tokens\n-        List<String> tokenText = new ArrayList<>();\n+        List<String> tokenTexts = new ArrayList<>();\n \n         final int[] pendingRParenthesisCount = new int[]{0};\n         Consumer<Integer> tokenAcceptor = type -> {\n-            if (type == BallerinaParser.RIGHT_PARENTHESIS) {\n-                pendingRParenthesisCount[0]++;\n-            } else if (type == BallerinaParser.LEFT_PARENTHESIS) {\n+            if (type == BallerinaParser.LEFT_PARENTHESIS) {\n                 pendingRParenthesisCount[0]--;\n+            } else if (type == BallerinaParser.RIGHT_PARENTHESIS) {\n+                pendingRParenthesisCount[0]++;\n             }\n         };\n \n-        // Visit Left-Hand side tokens\n+        // Visit Left-Hand side tokens before cursor\n         List<CommonToken> lhsTokens = serviceContext.get(CompletionKeys.LHS_TOKENS_KEY);\n         if (lhsTokens != null) {\n-            for (Token commonToken : lhsTokens) {\n-                tokenAcceptor.accept(commonToken.getType());\n-                tokenText.add(commonToken.getText());\n+            while (lhsTokens.get(0).getType() == BallerinaParser.COMMA) {\n+                lhsTokens.remove(0);\n+            }\n+            boolean isLastLeftParenthesisProcessed = false;\n+            for (int i = lhsTokens.size() - 1; i >= 0; i--) {\n+                Token commonToken = lhsTokens.get(i);\n+                int tokenType = commonToken.getType();\n+                if (tokenType == BallerinaParser.LEFT_PARENTHESIS) {\n+                    // Since we are traversing reverse order, we'll get the last LParenthesis first\n+                    isLastLeftParenthesisProcessed = true;\n+                }\n+                if (tokenType == BallerinaParser.COMMA) {\n+                    if (i - 1 >= 0 && lhsTokens.get(i - 1).getType() == BallerinaParser.RIGHT_PARENTHESIS) {\n+                        // eg. func1(func2(10, 10, 5),[cursor]);\n+//                        pendingRParenthesisCount[0]++;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89a10b44bdbeb4e9bc902a4e2c2be5307df59e9f"}, "originalPosition": 226}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0NTUyODEwOnYy", "diffSide": "RIGHT", "path": "language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/signature/SignatureHelpUtil.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wN1QwNDo0MDozNVrOFavtcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wN1QxMTo1NTo0MFrOFa3aPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU4ODk3Ng==", "bodyText": "Can there be semantically inconsistent issues if we do this?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20524#discussion_r363588976", "createdAt": "2020-01-07T04:40:35Z", "author": {"login": "nadeeshaan"}, "path": "language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/signature/SignatureHelpUtil.java", "diffHunk": "@@ -243,20 +201,34 @@ private SignatureHelpUtil() {\n                     break;\n                 }\n                 tokenAcceptor.accept(commonToken.getType());\n-                tokenText.add(commonToken.getText());\n+                tokenTexts.add(commonToken.getText());\n             }\n         }\n \n+        // Remove if any comma[,] when pendingRParenthesis is less than zero\n+        int lastIndex = tokenTexts.size() - 1;\n+        if (COMMA.equals(tokenTexts.get(lastIndex)) && pendingRParenthesisCount[0] <= 0) {\n+            tokenTexts.remove(lastIndex);\n+        }\n+\n+        //  Remove if any semi-colon[;]\n+        lastIndex = tokenTexts.size() - 1;\n+        if (SEMI_COLON.equals(tokenTexts.get(lastIndex))) {\n+            tokenTexts.remove(lastIndex);\n+        }\n+\n         // Add Missing Parenthesis\n         while (pendingRParenthesisCount[0] < 0) {\n-            tokenText.add(\")\");\n+            tokenTexts.add(\")\");\n             pendingRParenthesisCount[0]++;\n         }\n-        return tokenText;\n+        return Pair.of(String.join(\"\", tokenTexts), parameterOffset);\n     }\n \n     private static Optional<String> parseAndGetFunctionInvocationPath(String subRule, LSServiceOperationContext context)\n             throws CompilationFailedException {\n+        // Replace 'optional field access' with 'field access' to avoid empty top-level nodes\n+        subRule = subRule.replaceAll(\"\\\\?.\", \".\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89a10b44bdbeb4e9bc902a4e2c2be5307df59e9f"}, "originalPosition": 293}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzcxNTEzMw==", "bodyText": "This won't be an issue. Idea is to generate a path string seperated by dots[.] to resolve BInvokableSymbol out of an function invocation text. Here we treat Optional field access as legitimate field access to find the correct function BInvokableSymbol to generate the signature help text.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20524#discussion_r363715133", "createdAt": "2020-01-07T11:55:40Z", "author": {"login": "rasika"}, "path": "language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/signature/SignatureHelpUtil.java", "diffHunk": "@@ -243,20 +201,34 @@ private SignatureHelpUtil() {\n                     break;\n                 }\n                 tokenAcceptor.accept(commonToken.getType());\n-                tokenText.add(commonToken.getText());\n+                tokenTexts.add(commonToken.getText());\n             }\n         }\n \n+        // Remove if any comma[,] when pendingRParenthesis is less than zero\n+        int lastIndex = tokenTexts.size() - 1;\n+        if (COMMA.equals(tokenTexts.get(lastIndex)) && pendingRParenthesisCount[0] <= 0) {\n+            tokenTexts.remove(lastIndex);\n+        }\n+\n+        //  Remove if any semi-colon[;]\n+        lastIndex = tokenTexts.size() - 1;\n+        if (SEMI_COLON.equals(tokenTexts.get(lastIndex))) {\n+            tokenTexts.remove(lastIndex);\n+        }\n+\n         // Add Missing Parenthesis\n         while (pendingRParenthesisCount[0] < 0) {\n-            tokenText.add(\")\");\n+            tokenTexts.add(\")\");\n             pendingRParenthesisCount[0]++;\n         }\n-        return tokenText;\n+        return Pair.of(String.join(\"\", tokenTexts), parameterOffset);\n     }\n \n     private static Optional<String> parseAndGetFunctionInvocationPath(String subRule, LSServiceOperationContext context)\n             throws CompilationFailedException {\n+        // Replace 'optional field access' with 'field access' to avoid empty top-level nodes\n+        subRule = subRule.replaceAll(\"\\\\?.\", \".\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU4ODk3Ng=="}, "originalCommit": {"oid": "89a10b44bdbeb4e9bc902a4e2c2be5307df59e9f"}, "originalPosition": 293}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0NTUzMzM0OnYy", "diffSide": "RIGHT", "path": "language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/signature/sourceprune/LHSSignatureTokenTraverser.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wN1QwNDo0NTo1M1rOFavwhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wN1QwNDo0NTo1M1rOFavwhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU4OTc2NQ==", "bodyText": "Invalid version", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20524#discussion_r363589765", "createdAt": "2020-01-07T04:45:53Z", "author": {"login": "nadeeshaan"}, "path": "language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/signature/sourceprune/LHSSignatureTokenTraverser.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+  Copyright (c) 2019, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ \n+  Licensed under the Apache License, Version 2.0 (the \"License\");\n+  you may not use this file except in compliance with the License.\n+  You may obtain a copy of the License at\n+ \n+  http://www.apache.org/licenses/LICENSE-2.0\n+ \n+  Unless required by applicable law or agreed to in writing, software\n+  distributed under the License is distributed on an \"AS IS\" BASIS,\n+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+  See the License for the specific language governing permissions and\n+  limitations under the License.\n+ */\n+package org.ballerinalang.langserver.signature.sourceprune;\n+\n+import org.antlr.v4.runtime.CommonToken;\n+import org.antlr.v4.runtime.Token;\n+import org.antlr.v4.runtime.TokenStream;\n+import org.ballerinalang.langserver.common.utils.CommonUtil;\n+import org.ballerinalang.langserver.sourceprune.AbstractTokenTraverser;\n+import org.ballerinalang.langserver.sourceprune.SourcePruneContext;\n+import org.ballerinalang.langserver.sourceprune.SourcePruneKeys;\n+import org.wso2.ballerinalang.compiler.parser.antlr4.BallerinaParser;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+\n+/**\n+ * LHS token traverser.\n+ *\n+ * @since 1.0.4", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89a10b44bdbeb4e9bc902a4e2c2be5307df59e9f"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0NTUzNjgxOnYy", "diffSide": "RIGHT", "path": "language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/signature/sourceprune/LHSSignatureTokenTraverser.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wN1QwNDo0OToyMlrOFavypw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wN1QxMjoyMTo1MVrOFa356g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU5MDMxMQ==", "bodyText": "Shall we refactor this one to use switch case instead of the if-else ladder?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20524#discussion_r363590311", "createdAt": "2020-01-07T04:49:22Z", "author": {"login": "nadeeshaan"}, "path": "language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/signature/sourceprune/LHSSignatureTokenTraverser.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+  Copyright (c) 2019, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ \n+  Licensed under the Apache License, Version 2.0 (the \"License\");\n+  you may not use this file except in compliance with the License.\n+  You may obtain a copy of the License at\n+ \n+  http://www.apache.org/licenses/LICENSE-2.0\n+ \n+  Unless required by applicable law or agreed to in writing, software\n+  distributed under the License is distributed on an \"AS IS\" BASIS,\n+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+  See the License for the specific language governing permissions and\n+  limitations under the License.\n+ */\n+package org.ballerinalang.langserver.signature.sourceprune;\n+\n+import org.antlr.v4.runtime.CommonToken;\n+import org.antlr.v4.runtime.Token;\n+import org.antlr.v4.runtime.TokenStream;\n+import org.ballerinalang.langserver.common.utils.CommonUtil;\n+import org.ballerinalang.langserver.sourceprune.AbstractTokenTraverser;\n+import org.ballerinalang.langserver.sourceprune.SourcePruneContext;\n+import org.ballerinalang.langserver.sourceprune.SourcePruneKeys;\n+import org.wso2.ballerinalang.compiler.parser.antlr4.BallerinaParser;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+\n+/**\n+ * LHS token traverser.\n+ *\n+ * @since 1.0.4\n+ */\n+public class LHSSignatureTokenTraverser extends AbstractTokenTraverser {\n+    private List<Integer> lhsTraverseTerminals;\n+    private SourcePruneContext sourcePruneContext;\n+    private boolean forcedProcessedToken = false;\n+    private boolean capturedFirstLeftParenthesis = false;\n+    private boolean capturedFirstColon = false;\n+    private int pendingRightParenthesis = 1;\n+    private int pendingLeftParenthesis = 1;\n+    private int pendingLeftBrace = 0;\n+    private int pendingLeftBracket = 0;\n+    private boolean isCommaTerminal = true;\n+\n+    private boolean isCapturingEnabled = true;\n+    private boolean captureStatement = false;\n+    private boolean addSemiColon = false;\n+\n+    LHSSignatureTokenTraverser(SourcePruneContext sourcePruneContext, boolean pruneTokens) {\n+        super(pruneTokens);\n+        this.sourcePruneContext = sourcePruneContext;\n+        this.lhsTraverseTerminals = sourcePruneContext.get(SourcePruneKeys.LHS_TRAVERSE_TERMINALS_KEY);\n+        this.processedTokens = new ArrayList<>();\n+    }\n+\n+    @Override\n+    public List<CommonToken> traverse(TokenStream tokenStream, int tokenIndex) {\n+        Optional<Token> token = Optional.of(tokenStream.get(tokenIndex));\n+        if (token.isPresent()) {\n+            int type = token.get().getType();\n+            if (type == BallerinaParser.COMMA) {\n+                this.isCommaTerminal = false;\n+            }\n+        }\n+        while (token.isPresent()) {\n+            int type = token.get().getType();\n+            if (token.get().getChannel() != 0 && this.capturedFirstLeftParenthesis) {\n+                // if the first left parenthesis '(' is already captured, when we are getting non default channel token\n+                // we disable capturing tokens but continue pruning\n+                Optional<Token> prevToken = CommonUtil.getPreviousDefaultToken(tokenStream, tokenIndex);\n+\n+                // Exception is made for capturing explicit object initializations, eg. new Object()\n+                boolean explicitInit = prevToken.isPresent() && prevToken.get().getType() == BallerinaParser.NEW;\n+\n+                // Exception is made for capturing implicit object initializations, eg. Object obj = new()\n+                if (!this.captureStatement && this.processedTokens.size() >= 2) {\n+                    CommonToken nToken = this.processedTokens.get(this.processedTokens.size() - 1);\n+                    CommonToken nnToken = this.processedTokens.get(this.processedTokens.size() - 2);\n+                    this.captureStatement = nToken.getType() == BallerinaParser.NEW &&\n+                            nnToken.getType() == BallerinaParser.LEFT_PARENTHESIS;\n+                }\n+                if (!explicitInit && !this.captureStatement && this.pendingLeftParenthesis == 0) {\n+                    this.isCapturingEnabled = false;\n+                }\n+            }\n+            if (this.lhsTraverseTerminals.contains(type)) {\n+                boolean terminate = terminateLHSTraverse(token.get(), tokenStream);\n+                if (terminate) {\n+                    break;\n+                }\n+            }\n+            // If match statement, avoid adding semi-colon\n+            this.addSemiColon = this.addSemiColon || token.get().getType() == BallerinaParser.MATCH;\n+            if (!this.forcedProcessedToken) {\n+                processToken(token.get());\n+            }\n+            this.forcedProcessedToken = false;\n+            tokenIndex = token.get().getTokenIndex() - 1;\n+            token = tokenIndex < 0 ? Optional.empty() : Optional.of(tokenStream.get(tokenIndex));\n+        }\n+        sourcePruneContext.put(SourcePruneKeys.LEFT_PARAN_COUNT_KEY, this.pendingLeftParenthesis);\n+        sourcePruneContext.put(SourcePruneKeys.RIGHT_PARAN_COUNT_KEY, this.pendingRightParenthesis);\n+        sourcePruneContext.put(SourcePruneKeys.LEFT_BRACE_COUNT_KEY, this.pendingLeftBrace);\n+        sourcePruneContext.put(SourcePruneKeys.ADD_SEMICOLON_COUNT_KEY, this.addSemiColon);\n+        Collections.reverse(this.processedTokens);\n+\n+        removeProceedingNonDefaultTokens(this.processedTokens);\n+        return this.processedTokens;\n+    }\n+\n+    private void removeProceedingNonDefaultTokens(List<CommonToken> processedTokens) {\n+        int len = processedTokens.size();\n+        for (int i = 0; i < len; i++) {\n+            CommonToken token = processedTokens.get(i);\n+            if (token.getChannel() != 0) {\n+                processedTokens.remove(token);\n+                i--;\n+                len--;\n+            } else {\n+                break;\n+            }\n+        }\n+    }\n+\n+    private boolean terminateLHSTraverse(Token token, TokenStream tokenStream) {\n+        int type = token.getType();\n+        String text = token.getText();\n+        if (type == BallerinaParser.RIGHT_PARENTHESIS) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89a10b44bdbeb4e9bc902a4e2c2be5307df59e9f"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzcyMzI0Mg==", "bodyText": "I already tried it but couldn't due to this case. Even making ${\".equals(text) check an inner-if, didn't work due to false checkstyle error Fall through from previous branch of the switch statement.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20524#discussion_r363723242", "createdAt": "2020-01-07T12:21:51Z", "author": {"login": "rasika"}, "path": "language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/signature/sourceprune/LHSSignatureTokenTraverser.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+  Copyright (c) 2019, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ \n+  Licensed under the Apache License, Version 2.0 (the \"License\");\n+  you may not use this file except in compliance with the License.\n+  You may obtain a copy of the License at\n+ \n+  http://www.apache.org/licenses/LICENSE-2.0\n+ \n+  Unless required by applicable law or agreed to in writing, software\n+  distributed under the License is distributed on an \"AS IS\" BASIS,\n+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+  See the License for the specific language governing permissions and\n+  limitations under the License.\n+ */\n+package org.ballerinalang.langserver.signature.sourceprune;\n+\n+import org.antlr.v4.runtime.CommonToken;\n+import org.antlr.v4.runtime.Token;\n+import org.antlr.v4.runtime.TokenStream;\n+import org.ballerinalang.langserver.common.utils.CommonUtil;\n+import org.ballerinalang.langserver.sourceprune.AbstractTokenTraverser;\n+import org.ballerinalang.langserver.sourceprune.SourcePruneContext;\n+import org.ballerinalang.langserver.sourceprune.SourcePruneKeys;\n+import org.wso2.ballerinalang.compiler.parser.antlr4.BallerinaParser;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+\n+/**\n+ * LHS token traverser.\n+ *\n+ * @since 1.0.4\n+ */\n+public class LHSSignatureTokenTraverser extends AbstractTokenTraverser {\n+    private List<Integer> lhsTraverseTerminals;\n+    private SourcePruneContext sourcePruneContext;\n+    private boolean forcedProcessedToken = false;\n+    private boolean capturedFirstLeftParenthesis = false;\n+    private boolean capturedFirstColon = false;\n+    private int pendingRightParenthesis = 1;\n+    private int pendingLeftParenthesis = 1;\n+    private int pendingLeftBrace = 0;\n+    private int pendingLeftBracket = 0;\n+    private boolean isCommaTerminal = true;\n+\n+    private boolean isCapturingEnabled = true;\n+    private boolean captureStatement = false;\n+    private boolean addSemiColon = false;\n+\n+    LHSSignatureTokenTraverser(SourcePruneContext sourcePruneContext, boolean pruneTokens) {\n+        super(pruneTokens);\n+        this.sourcePruneContext = sourcePruneContext;\n+        this.lhsTraverseTerminals = sourcePruneContext.get(SourcePruneKeys.LHS_TRAVERSE_TERMINALS_KEY);\n+        this.processedTokens = new ArrayList<>();\n+    }\n+\n+    @Override\n+    public List<CommonToken> traverse(TokenStream tokenStream, int tokenIndex) {\n+        Optional<Token> token = Optional.of(tokenStream.get(tokenIndex));\n+        if (token.isPresent()) {\n+            int type = token.get().getType();\n+            if (type == BallerinaParser.COMMA) {\n+                this.isCommaTerminal = false;\n+            }\n+        }\n+        while (token.isPresent()) {\n+            int type = token.get().getType();\n+            if (token.get().getChannel() != 0 && this.capturedFirstLeftParenthesis) {\n+                // if the first left parenthesis '(' is already captured, when we are getting non default channel token\n+                // we disable capturing tokens but continue pruning\n+                Optional<Token> prevToken = CommonUtil.getPreviousDefaultToken(tokenStream, tokenIndex);\n+\n+                // Exception is made for capturing explicit object initializations, eg. new Object()\n+                boolean explicitInit = prevToken.isPresent() && prevToken.get().getType() == BallerinaParser.NEW;\n+\n+                // Exception is made for capturing implicit object initializations, eg. Object obj = new()\n+                if (!this.captureStatement && this.processedTokens.size() >= 2) {\n+                    CommonToken nToken = this.processedTokens.get(this.processedTokens.size() - 1);\n+                    CommonToken nnToken = this.processedTokens.get(this.processedTokens.size() - 2);\n+                    this.captureStatement = nToken.getType() == BallerinaParser.NEW &&\n+                            nnToken.getType() == BallerinaParser.LEFT_PARENTHESIS;\n+                }\n+                if (!explicitInit && !this.captureStatement && this.pendingLeftParenthesis == 0) {\n+                    this.isCapturingEnabled = false;\n+                }\n+            }\n+            if (this.lhsTraverseTerminals.contains(type)) {\n+                boolean terminate = terminateLHSTraverse(token.get(), tokenStream);\n+                if (terminate) {\n+                    break;\n+                }\n+            }\n+            // If match statement, avoid adding semi-colon\n+            this.addSemiColon = this.addSemiColon || token.get().getType() == BallerinaParser.MATCH;\n+            if (!this.forcedProcessedToken) {\n+                processToken(token.get());\n+            }\n+            this.forcedProcessedToken = false;\n+            tokenIndex = token.get().getTokenIndex() - 1;\n+            token = tokenIndex < 0 ? Optional.empty() : Optional.of(tokenStream.get(tokenIndex));\n+        }\n+        sourcePruneContext.put(SourcePruneKeys.LEFT_PARAN_COUNT_KEY, this.pendingLeftParenthesis);\n+        sourcePruneContext.put(SourcePruneKeys.RIGHT_PARAN_COUNT_KEY, this.pendingRightParenthesis);\n+        sourcePruneContext.put(SourcePruneKeys.LEFT_BRACE_COUNT_KEY, this.pendingLeftBrace);\n+        sourcePruneContext.put(SourcePruneKeys.ADD_SEMICOLON_COUNT_KEY, this.addSemiColon);\n+        Collections.reverse(this.processedTokens);\n+\n+        removeProceedingNonDefaultTokens(this.processedTokens);\n+        return this.processedTokens;\n+    }\n+\n+    private void removeProceedingNonDefaultTokens(List<CommonToken> processedTokens) {\n+        int len = processedTokens.size();\n+        for (int i = 0; i < len; i++) {\n+            CommonToken token = processedTokens.get(i);\n+            if (token.getChannel() != 0) {\n+                processedTokens.remove(token);\n+                i--;\n+                len--;\n+            } else {\n+                break;\n+            }\n+        }\n+    }\n+\n+    private boolean terminateLHSTraverse(Token token, TokenStream tokenStream) {\n+        int type = token.getType();\n+        String text = token.getText();\n+        if (type == BallerinaParser.RIGHT_PARENTHESIS) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU5MDMxMQ=="}, "originalCommit": {"oid": "89a10b44bdbeb4e9bc902a4e2c2be5307df59e9f"}, "originalPosition": 132}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0NTUzODMxOnYy", "diffSide": "RIGHT", "path": "language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/signature/sourceprune/RHSSignatureTokenTraverser.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wN1QwNDo1MDo0OVrOFavzlg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wN1QwNDo1MDo0OVrOFavzlg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU5MDU1MA==", "bodyText": "Invalid version", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20524#discussion_r363590550", "createdAt": "2020-01-07T04:50:49Z", "author": {"login": "nadeeshaan"}, "path": "language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/signature/sourceprune/RHSSignatureTokenTraverser.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+  Copyright (c) 2019, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ \n+  Licensed under the Apache License, Version 2.0 (the \"License\");\n+  you may not use this file except in compliance with the License.\n+  You may obtain a copy of the License at\n+ \n+  http://www.apache.org/licenses/LICENSE-2.0\n+ \n+  Unless required by applicable law or agreed to in writing, software\n+  distributed under the License is distributed on an \"AS IS\" BASIS,\n+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+  See the License for the specific language governing permissions and\n+  limitations under the License.\n+ */\n+package org.ballerinalang.langserver.signature.sourceprune;\n+\n+import org.antlr.v4.runtime.CommonToken;\n+import org.antlr.v4.runtime.Token;\n+import org.antlr.v4.runtime.TokenStream;\n+import org.ballerinalang.langserver.sourceprune.AbstractTokenTraverser;\n+import org.ballerinalang.langserver.sourceprune.SourcePruneContext;\n+import org.ballerinalang.langserver.sourceprune.SourcePruneKeys;\n+import org.wso2.ballerinalang.compiler.parser.antlr4.BallerinaParser;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+\n+/**\n+ * RHS Token Traverser.\n+ *\n+ * @since 1.0.4", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89a10b44bdbeb4e9bc902a4e2c2be5307df59e9f"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0NTU0MjA3OnYy", "diffSide": "RIGHT", "path": "language-server/modules/langserver-core/src/test/java/org/ballerinalang/langserver/sourceprune/SignatureSourcePruneTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wN1QwNDo1NTowNFrOFav12g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wN1QwNDo1NTowNFrOFav12g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU5MTEzMA==", "bodyText": "Invalid version", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20524#discussion_r363591130", "createdAt": "2020-01-07T04:55:04Z", "author": {"login": "nadeeshaan"}, "path": "language-server/modules/langserver-core/src/test/java/org/ballerinalang/langserver/sourceprune/SignatureSourcePruneTest.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package org.ballerinalang.langserver.sourceprune;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonObject;\n+import org.ballerinalang.langserver.LSContextOperation;\n+import org.ballerinalang.langserver.common.CommonKeys;\n+import org.ballerinalang.langserver.common.utils.CommonUtil;\n+import org.ballerinalang.langserver.compiler.DocumentServiceKeys;\n+import org.ballerinalang.langserver.compiler.LSContext;\n+import org.ballerinalang.langserver.compiler.LSServiceOperationContext;\n+import org.ballerinalang.langserver.compiler.workspace.WorkspaceDocumentException;\n+import org.ballerinalang.langserver.compiler.workspace.WorkspaceDocumentManagerImpl;\n+import org.ballerinalang.langserver.completions.util.SourcePruneException;\n+import org.ballerinalang.langserver.signature.sourceprune.SignatureTokenTraverserFactory;\n+import org.ballerinalang.langserver.util.FileUtils;\n+import org.eclipse.lsp4j.Position;\n+import org.eclipse.lsp4j.TextDocumentPositionParams;\n+import org.testng.Assert;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Optional;\n+\n+/**\n+ * Test the source prune operation with specific sources individual from the signature operation.\n+ *\n+ * @since 1.0.5", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89a10b44bdbeb4e9bc902a4e2c2be5307df59e9f"}, "originalPosition": 32}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 608, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}