{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc1MzgyNjI2", "number": 25521, "title": "Remove functional binding pattern", "bodyText": "Purpose\n\nRemove functional binding pattern. Fixes #25263\nUpdate error binding pattern syntax. Fixes #25386\nFixes #25448\n\nCheck List\n\n Read the Contributing Guide\n Updated Change Log\n Checked Tooling Support (#)\n Added necessary tests\n\n Unit Tests\n Spec Conformance Tests\n Integration Tests\n Ballerina By Example Tests\n\n\n Increased Test Coverage\n Added necessary documentation\n\n API documentation\n Module documentation in Module.md files\n Ballerina By Examples", "createdAt": "2020-08-28T12:39:40Z", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25521", "merged": true, "mergeCommit": {"oid": "b660805a7c2e11af75bb471914724ae5ada66e86"}, "closed": true, "closedAt": "2020-09-04T10:13:15Z", "author": {"login": "rdulmina"}, "timelineItems": {"totalCount": 30, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdCUaq7gH2gAyNDc1MzgyNjI2OjU4NDE5MjU3MjdlZWI1NjY5MTFmMmNhNjg1Y2VkZjI3ZTU3ZDU5NDI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdFiHTEAFqTQ4MjUxODAzNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "5841925727eeb566911f2ca685cedf27e57d5942", "author": {"user": {"login": "rdulmina", "name": "Dulmina Renuke"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/5841925727eeb566911f2ca685cedf27e57d5942", "committedDate": "2020-08-25T10:12:19Z", "message": "Binding pattern parsing changes.\nRemove functional binding patterns and update error binding pattern parsing logic."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d2ce5bdf056a8d42843aa301e86bdd43e34e0109", "author": {"user": {"login": "rdulmina", "name": "Dulmina Renuke"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/d2ce5bdf056a8d42843aa301e86bdd43e34e0109", "committedDate": "2020-08-27T06:42:13Z", "message": "Update recovery for new spec."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "841262545ec0709b995cc33eaba8587df5d8a89a", "author": {"user": {"login": "rdulmina", "name": "Dulmina Renuke"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/841262545ec0709b995cc33eaba8587df5d8a89a", "committedDate": "2020-08-27T06:43:49Z", "message": "Add node class files."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "05fa03b5aa4cdf20dafc103b458c84bc5f781ccf", "author": {"user": {"login": "rdulmina", "name": "Dulmina Renuke"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/05fa03b5aa4cdf20dafc103b458c84bc5f781ccf", "committedDate": "2020-08-27T11:25:20Z", "message": "Remove unwanted contexts."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c4757f6f773167e2a86cb71ff2ec1ee2494bc6cd", "author": {"user": {"login": "rdulmina", "name": "Dulmina Renuke"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c4757f6f773167e2a86cb71ff2ec1ee2494bc6cd", "committedDate": "2020-08-28T10:45:26Z", "message": "Update assert files."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c9cdca8aef668a97c08ae917977a0b969bd141e9", "author": {"user": {"login": "rdulmina", "name": "Dulmina Renuke"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c9cdca8aef668a97c08ae917977a0b969bd141e9", "committedDate": "2020-08-28T10:48:03Z", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into remove-functional"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9f1d06f49f7decb0b0aeea3fc68fb6af65ce197a", "author": {"user": {"login": "rdulmina", "name": "Dulmina Renuke"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/9f1d06f49f7decb0b0aeea3fc68fb6af65ce197a", "committedDate": "2020-08-28T13:43:23Z", "message": "Add isOptional attribute to typeReference."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3b4630b236465fec3fa0f7f5e7af17f296cde857", "author": {"user": {"login": "rdulmina", "name": "Dulmina Renuke"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3b4630b236465fec3fa0f7f5e7af17f296cde857", "committedDate": "2020-08-31T06:08:03Z", "message": "Fix formatter errors."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5860cbb1fabc9568d21f14286e5fb967e30a25a8", "author": {"user": {"login": "rdulmina", "name": "Dulmina Renuke"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/5860cbb1fabc9568d21f14286e5fb967e30a25a8", "committedDate": "2020-08-31T06:52:35Z", "message": "Remove commented code line."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "faa3e90a6822d4987ce7b32e8ee0a029c089227e", "author": {"user": {"login": "rdulmina", "name": "Dulmina Renuke"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/faa3e90a6822d4987ce7b32e8ee0a029c089227e", "committedDate": "2020-08-31T08:04:00Z", "message": "NodeTransformer changes for error BP."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6f463e26cffe70fa199501d0e15a35528d76fdcc", "author": {"user": {"login": "rdulmina", "name": "Dulmina Renuke"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6f463e26cffe70fa199501d0e15a35528d76fdcc", "committedDate": "2020-08-31T08:49:48Z", "message": "Fix checkstyle issues in NodeTransformer."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b41322879eb96347fa9c8a37b214133843649a43", "author": {"user": {"login": "rdulmina", "name": "Dulmina Renuke"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b41322879eb96347fa9c8a37b214133843649a43", "committedDate": "2020-08-31T10:09:33Z", "message": "Fix parsing issue in error BP."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f0ce5bd8aa709ec92eaf376cb3d1278def8465ce", "author": {"user": {"login": "rdulmina", "name": "Dulmina Renuke"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f0ce5bd8aa709ec92eaf376cb3d1278def8465ce", "committedDate": "2020-08-31T11:00:45Z", "message": "Fix assertion fail in language server."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d84d99b561102ee76d405d898e1dc6c8d4e70a1b", "author": {"user": {"login": "rdulmina", "name": "Dulmina Renuke"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/d84d99b561102ee76d405d898e1dc6c8d4e70a1b", "committedDate": "2020-09-01T06:22:37Z", "message": "Fix parsing issue in errorBP."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e1ff5f322a78418ebbe1e4f6acd0ee0d1e823926", "author": {"user": {"login": "rdulmina", "name": "Dulmina Renuke"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e1ff5f322a78418ebbe1e4f6acd0ee0d1e823926", "committedDate": "2020-09-02T04:15:51Z", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into remove-functional"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "36f157d698ad8405860bf35c4413fe95b31d49ba", "author": {"user": {"login": "rdulmina", "name": "Dulmina Renuke"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/36f157d698ad8405860bf35c4413fe95b31d49ba", "committedDate": "2020-09-02T07:07:50Z", "message": "Add a println for test purpose."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7228e331e4b0559a1d92076a21e2ebec9d2f824e", "author": {"user": {"login": "rdulmina", "name": "Dulmina Renuke"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7228e331e4b0559a1d92076a21e2ebec9d2f824e", "committedDate": "2020-09-02T12:39:09Z", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into remove-functional"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f838a70ba26890edd7c319b862e7bed6a8321e2f", "author": {"user": {"login": "rdulmina", "name": "Dulmina Renuke"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f838a70ba26890edd7c319b862e7bed6a8321e2f", "committedDate": "2020-09-02T13:43:24Z", "message": "Remove println."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxNDY1NTg0", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25521#pullrequestreview-481465584", "createdAt": "2020-09-03T03:25:31Z", "commit": {"oid": "f838a70ba26890edd7c319b862e7bed6a8321e2f"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QwMzoyNTozMVrOHMUeOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QwNDowMDo0MVrOHMVBhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjY4MDM3Ng==", "bodyText": "lets use the expanded name for BP:  parseAsErrorBindingPattern", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25521#discussion_r482680376", "createdAt": "2020-09-03T03:25:31Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -12975,165 +12987,277 @@ private boolean isEndOfMappingBindingPattern(SyntaxKind nextTokenKind) {\n         return nextTokenKind == SyntaxKind.CLOSE_BRACE_TOKEN;\n     }\n \n+    private STNode parseErrorTypeDescOrErrorBP(STNode annots) {\n+        STToken nextNextToken = peek(2);\n+        switch (nextNextToken.kind) {\n+            case OPEN_PAREN_TOKEN:// Error binding pattern\n+                return parseAsErrorBP();\n+            case LT_TOKEN:\n+                return parseAsErrorTypeDesc(annots);\n+            case IDENTIFIER_TOKEN:\n+                // If the next token is identifier it can be either error a; or error a (errorMessage);\n+                SyntaxKind nextNextNextTokenKind = peek(3).kind;\n+                if (nextNextNextTokenKind == SyntaxKind.COLON_TOKEN ||\n+                        nextNextNextTokenKind == SyntaxKind.OPEN_PAREN_TOKEN) {\n+                    return parseAsErrorBP();\n+                }\n+                // Fall through.\n+            default:\n+                return parseAsErrorTypeDesc(annots);\n+        }\n+    }\n+\n+    private STNode parseAsErrorBP() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f838a70ba26890edd7c319b862e7bed6a8321e2f"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjY4MDY2Nw==", "bodyText": "Need a newline after }", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25521#discussion_r482680667", "createdAt": "2020-09-03T03:26:40Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -12975,165 +12987,277 @@ private boolean isEndOfMappingBindingPattern(SyntaxKind nextTokenKind) {\n         return nextTokenKind == SyntaxKind.CLOSE_BRACE_TOKEN;\n     }\n \n+    private STNode parseErrorTypeDescOrErrorBP(STNode annots) {\n+        STToken nextNextToken = peek(2);\n+        switch (nextNextToken.kind) {\n+            case OPEN_PAREN_TOKEN:// Error binding pattern\n+                return parseAsErrorBP();\n+            case LT_TOKEN:\n+                return parseAsErrorTypeDesc(annots);\n+            case IDENTIFIER_TOKEN:\n+                // If the next token is identifier it can be either error a; or error a (errorMessage);\n+                SyntaxKind nextNextNextTokenKind = peek(3).kind;\n+                if (nextNextNextTokenKind == SyntaxKind.COLON_TOKEN ||\n+                        nextNextNextTokenKind == SyntaxKind.OPEN_PAREN_TOKEN) {\n+                    return parseAsErrorBP();\n+                }\n+                // Fall through.\n+            default:\n+                return parseAsErrorTypeDesc(annots);\n+        }\n+    }\n+\n+    private STNode parseAsErrorBP() {\n+        startContext(ParserRuleContext.ASSIGNMENT_STMT);\n+        return parseAssignmentStmtRhs(parseErrorBindingPattern());\n+    }\n+\n+    private STNode parseAsErrorTypeDesc(STNode annots) {\n+        STNode finalKeyword = STNodeFactory.createEmptyNode();\n+        return parseVariableDecl(getAnnotations(annots), finalKeyword, false);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f838a70ba26890edd7c319b862e7bed6a8321e2f"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjY4Mzc3Mg==", "bodyText": "Should we loop on a condition like isErrorArgsListEnd()?\nThen we can exit early for cases like eof-token, ) token, etc..", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25521#discussion_r482683772", "createdAt": "2020-09-03T03:38:41Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -12975,165 +12987,277 @@ private boolean isEndOfMappingBindingPattern(SyntaxKind nextTokenKind) {\n         return nextTokenKind == SyntaxKind.CLOSE_BRACE_TOKEN;\n     }\n \n+    private STNode parseErrorTypeDescOrErrorBP(STNode annots) {\n+        STToken nextNextToken = peek(2);\n+        switch (nextNextToken.kind) {\n+            case OPEN_PAREN_TOKEN:// Error binding pattern\n+                return parseAsErrorBP();\n+            case LT_TOKEN:\n+                return parseAsErrorTypeDesc(annots);\n+            case IDENTIFIER_TOKEN:\n+                // If the next token is identifier it can be either error a; or error a (errorMessage);\n+                SyntaxKind nextNextNextTokenKind = peek(3).kind;\n+                if (nextNextNextTokenKind == SyntaxKind.COLON_TOKEN ||\n+                        nextNextNextTokenKind == SyntaxKind.OPEN_PAREN_TOKEN) {\n+                    return parseAsErrorBP();\n+                }\n+                // Fall through.\n+            default:\n+                return parseAsErrorTypeDesc(annots);\n+        }\n+    }\n+\n+    private STNode parseAsErrorBP() {\n+        startContext(ParserRuleContext.ASSIGNMENT_STMT);\n+        return parseAssignmentStmtRhs(parseErrorBindingPattern());\n+    }\n+\n+    private STNode parseAsErrorTypeDesc(STNode annots) {\n+        STNode finalKeyword = STNodeFactory.createEmptyNode();\n+        return parseVariableDecl(getAnnotations(annots), finalKeyword, false);\n+    }\n     /**\n      * Parse error binding pattern node.\n      * <p>\n-     * <code>functional-binding-pattern := error ( arg-list-binding-pattern )</code>\n+     * <code>error-binding-pattern := error [error-type-reference] ( error-arg-list-binding-pattern )</code>\n+     * <br/><br/>\n+     * error-arg-list-binding-pattern :=\n+     *    error-message-binding-pattern [, error-cause-binding-pattern] [, error-field-binding-patterns]\n+     *    | [error-field-binding-patterns]\n+     * <br/><br/>\n+     * error-message-binding-pattern := simple-binding-pattern\n+     * <br/><br/>\n+     * error-cause-binding-pattern := simple-binding-pattern | error-binding-pattern\n+     * <br/><br/>\n+     * simple-binding-pattern := capture-binding-pattern | wildcard-binding-pattern\n+     * <br/><br/>\n+     * error-field-binding-patterns :=\n+     *    named-arg-binding-pattern (, named-arg-binding-pattern)* [, rest-binding-pattern]\n+     *    | rest-binding-pattern\n+     * <br/><br/>\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n      * \n      * @return Error binding pattern node.\n      */\n     private STNode parseErrorBindingPattern() {\n-        startContext(ParserRuleContext.FUNCTIONAL_BINDING_PATTERN);\n-        STNode typeDesc = parseErrorKeyword();\n-        return parseFunctionalBindingPattern(typeDesc);\n+        startContext(ParserRuleContext.ERROR_BINDING_PATTERN);\n+        STNode errorKeyword = parseErrorKeyword();\n+        return parseErrorBindingPattern(errorKeyword);\n+    }\n+\n+    private STNode parseErrorBindingPattern(STNode errorKeyword) {\n+        STToken nextToken = peek();\n+        STNode typeRef;\n+        switch (nextToken.kind) {\n+            case IDENTIFIER_TOKEN:\n+                typeRef = parseTypeReference();\n+                break;\n+            case OPEN_PAREN_TOKEN:\n+                typeRef = STNodeFactory.createEmptyNode();\n+                break;\n+            default:\n+                recover(peek(), ParserRuleContext.ERROR_BINDING_PATTERN_ERROR_KEYWORD_RHS);\n+                return parseErrorBindingPattern(errorKeyword);\n+        }\n+        return parseErrorBindingPattern(errorKeyword, typeRef);\n+    }\n+\n+    private STNode parseErrorBindingPattern(STNode errorKeyword, STNode typeRef) {\n+        STNode openParenthesis = parseOpenParenthesis(ParserRuleContext.OPEN_PARENTHESIS);\n+        STNode argListBindingPatterns = parseErrorArgListBindingPatterns();\n+        STNode closeParenthesis = parseCloseParenthesis();\n+        endContext();\n+        return STNodeFactory.createErrorBindingPatternNode(errorKeyword, typeRef, openParenthesis,\n+                argListBindingPatterns, closeParenthesis);\n     }\n \n     /**\n-     * Parse functional binding pattern.\n+     * Parse error arg list binding pattern.\n      * <p>\n      * <code>\n-     * functional-binding-pattern := functionally-constructible-type-reference ( arg-list-binding-pattern )\n+     * error-arg-list-binding-pattern :=\n+     * error-message-binding-pattern [, error-cause-binding-pattern] [, error-field-binding-patterns]\n+     * | [error-field-binding-patterns]\n      * <br/><br/>\n-     * functionally-constructible-type-reference := error | type-reference\n+     *\n+     * error-message-binding-pattern := simple-binding-pattern\n+     * <br/><br/>\n+     *\n+     * error-cause-binding-pattern := simple-binding-pattern | error-binding-pattern\n+     * <br/><br/>\n+     *\n+     * simple-binding-pattern := capture-binding-pattern | wildcard-binding-pattern\n+     * <br/><br/>\n+     *\n+     * error-field-binding-patterns :=\n+     * named-arg-binding-pattern (, named-arg-binding-pattern)* [, rest-binding-pattern]\n+     * | rest-binding-pattern\n+     * <br/><br/>\n+     *\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n      * </code>\n-     * \n-     * @param typeDesc Functionally constructible type reference\n-     * @return Functional binding pattern node.\n+     *\n+     * @return Error arg list binding patterns.\n      */\n-    private STNode parseFunctionalBindingPattern(STNode typeDesc) {\n-        STNode openParenthesis = parseOpenParenthesis(ParserRuleContext.ARG_LIST_START);\n-        STNode argListBindingPatterns = parseArgListBindingPatterns();\n-        STNode closeParenthesis = parseCloseParenthesis();\n-        endContext();\n-        return STNodeFactory.createFunctionalBindingPatternNode(typeDesc, openParenthesis, argListBindingPatterns,\n-                closeParenthesis);\n-    }\n-\n-    private STNode parseArgListBindingPatterns() {\n+    private STNode parseErrorArgListBindingPatterns() {\n         List<STNode> argListBindingPatterns = new ArrayList<>();\n         SyntaxKind lastValidArgKind = SyntaxKind.CAPTURE_BINDING_PATTERN;\n         STToken nextToken = peek();\n \n         if (isEndOfParametersList(nextToken.kind)) {\n             return STNodeFactory.createNodeList(argListBindingPatterns);\n         }\n-        argListBindingPatterns.add(parseArgBindingPattern());\n \n-        nextToken = peek();\n-        while (!isEndOfParametersList(nextToken.kind)) {\n-            STNode argEnd = parseArgsBindingPatternEnd();\n-            if (argEnd == null) {\n-                // null marks the end of args\n-                break;\n-            }\n+        int argCount = 1;\n+        boolean isArgEnd = false;\n+        while (!isArgEnd) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f838a70ba26890edd7c319b862e7bed6a8321e2f"}, "originalPosition": 219}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjY4NDIyNw==", "bodyText": "Taking this snippet out (immediately after the parseErrorArgsBindingPatternEnd) will simplify the logic", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25521#discussion_r482684227", "createdAt": "2020-09-03T03:40:26Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -12975,165 +12987,277 @@ private boolean isEndOfMappingBindingPattern(SyntaxKind nextTokenKind) {\n         return nextTokenKind == SyntaxKind.CLOSE_BRACE_TOKEN;\n     }\n \n+    private STNode parseErrorTypeDescOrErrorBP(STNode annots) {\n+        STToken nextNextToken = peek(2);\n+        switch (nextNextToken.kind) {\n+            case OPEN_PAREN_TOKEN:// Error binding pattern\n+                return parseAsErrorBP();\n+            case LT_TOKEN:\n+                return parseAsErrorTypeDesc(annots);\n+            case IDENTIFIER_TOKEN:\n+                // If the next token is identifier it can be either error a; or error a (errorMessage);\n+                SyntaxKind nextNextNextTokenKind = peek(3).kind;\n+                if (nextNextNextTokenKind == SyntaxKind.COLON_TOKEN ||\n+                        nextNextNextTokenKind == SyntaxKind.OPEN_PAREN_TOKEN) {\n+                    return parseAsErrorBP();\n+                }\n+                // Fall through.\n+            default:\n+                return parseAsErrorTypeDesc(annots);\n+        }\n+    }\n+\n+    private STNode parseAsErrorBP() {\n+        startContext(ParserRuleContext.ASSIGNMENT_STMT);\n+        return parseAssignmentStmtRhs(parseErrorBindingPattern());\n+    }\n+\n+    private STNode parseAsErrorTypeDesc(STNode annots) {\n+        STNode finalKeyword = STNodeFactory.createEmptyNode();\n+        return parseVariableDecl(getAnnotations(annots), finalKeyword, false);\n+    }\n     /**\n      * Parse error binding pattern node.\n      * <p>\n-     * <code>functional-binding-pattern := error ( arg-list-binding-pattern )</code>\n+     * <code>error-binding-pattern := error [error-type-reference] ( error-arg-list-binding-pattern )</code>\n+     * <br/><br/>\n+     * error-arg-list-binding-pattern :=\n+     *    error-message-binding-pattern [, error-cause-binding-pattern] [, error-field-binding-patterns]\n+     *    | [error-field-binding-patterns]\n+     * <br/><br/>\n+     * error-message-binding-pattern := simple-binding-pattern\n+     * <br/><br/>\n+     * error-cause-binding-pattern := simple-binding-pattern | error-binding-pattern\n+     * <br/><br/>\n+     * simple-binding-pattern := capture-binding-pattern | wildcard-binding-pattern\n+     * <br/><br/>\n+     * error-field-binding-patterns :=\n+     *    named-arg-binding-pattern (, named-arg-binding-pattern)* [, rest-binding-pattern]\n+     *    | rest-binding-pattern\n+     * <br/><br/>\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n      * \n      * @return Error binding pattern node.\n      */\n     private STNode parseErrorBindingPattern() {\n-        startContext(ParserRuleContext.FUNCTIONAL_BINDING_PATTERN);\n-        STNode typeDesc = parseErrorKeyword();\n-        return parseFunctionalBindingPattern(typeDesc);\n+        startContext(ParserRuleContext.ERROR_BINDING_PATTERN);\n+        STNode errorKeyword = parseErrorKeyword();\n+        return parseErrorBindingPattern(errorKeyword);\n+    }\n+\n+    private STNode parseErrorBindingPattern(STNode errorKeyword) {\n+        STToken nextToken = peek();\n+        STNode typeRef;\n+        switch (nextToken.kind) {\n+            case IDENTIFIER_TOKEN:\n+                typeRef = parseTypeReference();\n+                break;\n+            case OPEN_PAREN_TOKEN:\n+                typeRef = STNodeFactory.createEmptyNode();\n+                break;\n+            default:\n+                recover(peek(), ParserRuleContext.ERROR_BINDING_PATTERN_ERROR_KEYWORD_RHS);\n+                return parseErrorBindingPattern(errorKeyword);\n+        }\n+        return parseErrorBindingPattern(errorKeyword, typeRef);\n+    }\n+\n+    private STNode parseErrorBindingPattern(STNode errorKeyword, STNode typeRef) {\n+        STNode openParenthesis = parseOpenParenthesis(ParserRuleContext.OPEN_PARENTHESIS);\n+        STNode argListBindingPatterns = parseErrorArgListBindingPatterns();\n+        STNode closeParenthesis = parseCloseParenthesis();\n+        endContext();\n+        return STNodeFactory.createErrorBindingPatternNode(errorKeyword, typeRef, openParenthesis,\n+                argListBindingPatterns, closeParenthesis);\n     }\n \n     /**\n-     * Parse functional binding pattern.\n+     * Parse error arg list binding pattern.\n      * <p>\n      * <code>\n-     * functional-binding-pattern := functionally-constructible-type-reference ( arg-list-binding-pattern )\n+     * error-arg-list-binding-pattern :=\n+     * error-message-binding-pattern [, error-cause-binding-pattern] [, error-field-binding-patterns]\n+     * | [error-field-binding-patterns]\n      * <br/><br/>\n-     * functionally-constructible-type-reference := error | type-reference\n+     *\n+     * error-message-binding-pattern := simple-binding-pattern\n+     * <br/><br/>\n+     *\n+     * error-cause-binding-pattern := simple-binding-pattern | error-binding-pattern\n+     * <br/><br/>\n+     *\n+     * simple-binding-pattern := capture-binding-pattern | wildcard-binding-pattern\n+     * <br/><br/>\n+     *\n+     * error-field-binding-patterns :=\n+     * named-arg-binding-pattern (, named-arg-binding-pattern)* [, rest-binding-pattern]\n+     * | rest-binding-pattern\n+     * <br/><br/>\n+     *\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n      * </code>\n-     * \n-     * @param typeDesc Functionally constructible type reference\n-     * @return Functional binding pattern node.\n+     *\n+     * @return Error arg list binding patterns.\n      */\n-    private STNode parseFunctionalBindingPattern(STNode typeDesc) {\n-        STNode openParenthesis = parseOpenParenthesis(ParserRuleContext.ARG_LIST_START);\n-        STNode argListBindingPatterns = parseArgListBindingPatterns();\n-        STNode closeParenthesis = parseCloseParenthesis();\n-        endContext();\n-        return STNodeFactory.createFunctionalBindingPatternNode(typeDesc, openParenthesis, argListBindingPatterns,\n-                closeParenthesis);\n-    }\n-\n-    private STNode parseArgListBindingPatterns() {\n+    private STNode parseErrorArgListBindingPatterns() {\n         List<STNode> argListBindingPatterns = new ArrayList<>();\n         SyntaxKind lastValidArgKind = SyntaxKind.CAPTURE_BINDING_PATTERN;\n         STToken nextToken = peek();\n \n         if (isEndOfParametersList(nextToken.kind)) {\n             return STNodeFactory.createNodeList(argListBindingPatterns);\n         }\n-        argListBindingPatterns.add(parseArgBindingPattern());\n \n-        nextToken = peek();\n-        while (!isEndOfParametersList(nextToken.kind)) {\n-            STNode argEnd = parseArgsBindingPatternEnd();\n-            if (argEnd == null) {\n-                // null marks the end of args\n-                break;\n-            }\n+        int argCount = 1;\n+        boolean isArgEnd = false;\n+        while (!isArgEnd) {\n \n-            nextToken = peek();\n-            STNode currentArg = parseArgBindingPattern();\n-            DiagnosticErrorCode errorCode = validateArgBindingPatternOrder(lastValidArgKind, currentArg.kind);\n+            STNode currentArg = parseErrorArgListBindingPattern(argCount);\n+            DiagnosticErrorCode errorCode = validateArgBindingPatternOrder(lastValidArgKind, currentArg.kind,\n+                    argCount);\n+            STNode argEnd = parseErrorArgsBindingPatternEnd(argCount);\n             if (errorCode == null) {\n-                argListBindingPatterns.add(argEnd);\n                 argListBindingPatterns.add(currentArg);\n+                if (argEnd == null) {\n+                    // null marks the end of args\n+                    break;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f838a70ba26890edd7c319b862e7bed6a8321e2f"}, "originalPosition": 233}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjY4NzAyOA==", "bodyText": "toString() method will include minutiae including comments, invalid tokens, etc..", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25521#discussion_r482687028", "createdAt": "2020-09-03T03:51:29Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -12975,165 +12987,277 @@ private boolean isEndOfMappingBindingPattern(SyntaxKind nextTokenKind) {\n         return nextTokenKind == SyntaxKind.CLOSE_BRACE_TOKEN;\n     }\n \n+    private STNode parseErrorTypeDescOrErrorBP(STNode annots) {\n+        STToken nextNextToken = peek(2);\n+        switch (nextNextToken.kind) {\n+            case OPEN_PAREN_TOKEN:// Error binding pattern\n+                return parseAsErrorBP();\n+            case LT_TOKEN:\n+                return parseAsErrorTypeDesc(annots);\n+            case IDENTIFIER_TOKEN:\n+                // If the next token is identifier it can be either error a; or error a (errorMessage);\n+                SyntaxKind nextNextNextTokenKind = peek(3).kind;\n+                if (nextNextNextTokenKind == SyntaxKind.COLON_TOKEN ||\n+                        nextNextNextTokenKind == SyntaxKind.OPEN_PAREN_TOKEN) {\n+                    return parseAsErrorBP();\n+                }\n+                // Fall through.\n+            default:\n+                return parseAsErrorTypeDesc(annots);\n+        }\n+    }\n+\n+    private STNode parseAsErrorBP() {\n+        startContext(ParserRuleContext.ASSIGNMENT_STMT);\n+        return parseAssignmentStmtRhs(parseErrorBindingPattern());\n+    }\n+\n+    private STNode parseAsErrorTypeDesc(STNode annots) {\n+        STNode finalKeyword = STNodeFactory.createEmptyNode();\n+        return parseVariableDecl(getAnnotations(annots), finalKeyword, false);\n+    }\n     /**\n      * Parse error binding pattern node.\n      * <p>\n-     * <code>functional-binding-pattern := error ( arg-list-binding-pattern )</code>\n+     * <code>error-binding-pattern := error [error-type-reference] ( error-arg-list-binding-pattern )</code>\n+     * <br/><br/>\n+     * error-arg-list-binding-pattern :=\n+     *    error-message-binding-pattern [, error-cause-binding-pattern] [, error-field-binding-patterns]\n+     *    | [error-field-binding-patterns]\n+     * <br/><br/>\n+     * error-message-binding-pattern := simple-binding-pattern\n+     * <br/><br/>\n+     * error-cause-binding-pattern := simple-binding-pattern | error-binding-pattern\n+     * <br/><br/>\n+     * simple-binding-pattern := capture-binding-pattern | wildcard-binding-pattern\n+     * <br/><br/>\n+     * error-field-binding-patterns :=\n+     *    named-arg-binding-pattern (, named-arg-binding-pattern)* [, rest-binding-pattern]\n+     *    | rest-binding-pattern\n+     * <br/><br/>\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n      * \n      * @return Error binding pattern node.\n      */\n     private STNode parseErrorBindingPattern() {\n-        startContext(ParserRuleContext.FUNCTIONAL_BINDING_PATTERN);\n-        STNode typeDesc = parseErrorKeyword();\n-        return parseFunctionalBindingPattern(typeDesc);\n+        startContext(ParserRuleContext.ERROR_BINDING_PATTERN);\n+        STNode errorKeyword = parseErrorKeyword();\n+        return parseErrorBindingPattern(errorKeyword);\n+    }\n+\n+    private STNode parseErrorBindingPattern(STNode errorKeyword) {\n+        STToken nextToken = peek();\n+        STNode typeRef;\n+        switch (nextToken.kind) {\n+            case IDENTIFIER_TOKEN:\n+                typeRef = parseTypeReference();\n+                break;\n+            case OPEN_PAREN_TOKEN:\n+                typeRef = STNodeFactory.createEmptyNode();\n+                break;\n+            default:\n+                recover(peek(), ParserRuleContext.ERROR_BINDING_PATTERN_ERROR_KEYWORD_RHS);\n+                return parseErrorBindingPattern(errorKeyword);\n+        }\n+        return parseErrorBindingPattern(errorKeyword, typeRef);\n+    }\n+\n+    private STNode parseErrorBindingPattern(STNode errorKeyword, STNode typeRef) {\n+        STNode openParenthesis = parseOpenParenthesis(ParserRuleContext.OPEN_PARENTHESIS);\n+        STNode argListBindingPatterns = parseErrorArgListBindingPatterns();\n+        STNode closeParenthesis = parseCloseParenthesis();\n+        endContext();\n+        return STNodeFactory.createErrorBindingPatternNode(errorKeyword, typeRef, openParenthesis,\n+                argListBindingPatterns, closeParenthesis);\n     }\n \n     /**\n-     * Parse functional binding pattern.\n+     * Parse error arg list binding pattern.\n      * <p>\n      * <code>\n-     * functional-binding-pattern := functionally-constructible-type-reference ( arg-list-binding-pattern )\n+     * error-arg-list-binding-pattern :=\n+     * error-message-binding-pattern [, error-cause-binding-pattern] [, error-field-binding-patterns]\n+     * | [error-field-binding-patterns]\n      * <br/><br/>\n-     * functionally-constructible-type-reference := error | type-reference\n+     *\n+     * error-message-binding-pattern := simple-binding-pattern\n+     * <br/><br/>\n+     *\n+     * error-cause-binding-pattern := simple-binding-pattern | error-binding-pattern\n+     * <br/><br/>\n+     *\n+     * simple-binding-pattern := capture-binding-pattern | wildcard-binding-pattern\n+     * <br/><br/>\n+     *\n+     * error-field-binding-patterns :=\n+     * named-arg-binding-pattern (, named-arg-binding-pattern)* [, rest-binding-pattern]\n+     * | rest-binding-pattern\n+     * <br/><br/>\n+     *\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n      * </code>\n-     * \n-     * @param typeDesc Functionally constructible type reference\n-     * @return Functional binding pattern node.\n+     *\n+     * @return Error arg list binding patterns.\n      */\n-    private STNode parseFunctionalBindingPattern(STNode typeDesc) {\n-        STNode openParenthesis = parseOpenParenthesis(ParserRuleContext.ARG_LIST_START);\n-        STNode argListBindingPatterns = parseArgListBindingPatterns();\n-        STNode closeParenthesis = parseCloseParenthesis();\n-        endContext();\n-        return STNodeFactory.createFunctionalBindingPatternNode(typeDesc, openParenthesis, argListBindingPatterns,\n-                closeParenthesis);\n-    }\n-\n-    private STNode parseArgListBindingPatterns() {\n+    private STNode parseErrorArgListBindingPatterns() {\n         List<STNode> argListBindingPatterns = new ArrayList<>();\n         SyntaxKind lastValidArgKind = SyntaxKind.CAPTURE_BINDING_PATTERN;\n         STToken nextToken = peek();\n \n         if (isEndOfParametersList(nextToken.kind)) {\n             return STNodeFactory.createNodeList(argListBindingPatterns);\n         }\n-        argListBindingPatterns.add(parseArgBindingPattern());\n \n-        nextToken = peek();\n-        while (!isEndOfParametersList(nextToken.kind)) {\n-            STNode argEnd = parseArgsBindingPatternEnd();\n-            if (argEnd == null) {\n-                // null marks the end of args\n-                break;\n-            }\n+        int argCount = 1;\n+        boolean isArgEnd = false;\n+        while (!isArgEnd) {\n \n-            nextToken = peek();\n-            STNode currentArg = parseArgBindingPattern();\n-            DiagnosticErrorCode errorCode = validateArgBindingPatternOrder(lastValidArgKind, currentArg.kind);\n+            STNode currentArg = parseErrorArgListBindingPattern(argCount);\n+            DiagnosticErrorCode errorCode = validateArgBindingPatternOrder(lastValidArgKind, currentArg.kind,\n+                    argCount);\n+            STNode argEnd = parseErrorArgsBindingPatternEnd(argCount);\n             if (errorCode == null) {\n-                argListBindingPatterns.add(argEnd);\n                 argListBindingPatterns.add(currentArg);\n+                if (argEnd == null) {\n+                    // null marks the end of args\n+                    break;\n+                }\n+                argListBindingPatterns.add(argEnd);\n                 lastValidArgKind = currentArg.kind;\n+                argCount++;\n             } else {\n-                updateLastNodeInListWithInvalidNode(argListBindingPatterns, argEnd, null);\n-                updateLastNodeInListWithInvalidNode(argListBindingPatterns, currentArg, errorCode);\n+                if (argListBindingPatterns.size() != 0) {\n+                    updateLastNodeInListWithInvalidNode(argListBindingPatterns, currentArg, errorCode);\n+                    if (argEnd != null) {\n+                        updateLastNodeInListWithInvalidNode(argListBindingPatterns, argEnd, null);\n+                    }\n+                } else {\n+                    addInvalidNodeToNextToken(currentArg, errorCode, currentArg.toString().trim());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f838a70ba26890edd7c319b862e7bed6a8321e2f"}, "originalPosition": 247}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjY4OTQxMw==", "bodyText": "Can we only rely on the lastValidArgKind?\nI feel we can do all the validation only using the lastValidArgKind..", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25521#discussion_r482689413", "createdAt": "2020-09-03T04:00:41Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -12975,165 +12987,277 @@ private boolean isEndOfMappingBindingPattern(SyntaxKind nextTokenKind) {\n         return nextTokenKind == SyntaxKind.CLOSE_BRACE_TOKEN;\n     }\n \n+    private STNode parseErrorTypeDescOrErrorBP(STNode annots) {\n+        STToken nextNextToken = peek(2);\n+        switch (nextNextToken.kind) {\n+            case OPEN_PAREN_TOKEN:// Error binding pattern\n+                return parseAsErrorBP();\n+            case LT_TOKEN:\n+                return parseAsErrorTypeDesc(annots);\n+            case IDENTIFIER_TOKEN:\n+                // If the next token is identifier it can be either error a; or error a (errorMessage);\n+                SyntaxKind nextNextNextTokenKind = peek(3).kind;\n+                if (nextNextNextTokenKind == SyntaxKind.COLON_TOKEN ||\n+                        nextNextNextTokenKind == SyntaxKind.OPEN_PAREN_TOKEN) {\n+                    return parseAsErrorBP();\n+                }\n+                // Fall through.\n+            default:\n+                return parseAsErrorTypeDesc(annots);\n+        }\n+    }\n+\n+    private STNode parseAsErrorBP() {\n+        startContext(ParserRuleContext.ASSIGNMENT_STMT);\n+        return parseAssignmentStmtRhs(parseErrorBindingPattern());\n+    }\n+\n+    private STNode parseAsErrorTypeDesc(STNode annots) {\n+        STNode finalKeyword = STNodeFactory.createEmptyNode();\n+        return parseVariableDecl(getAnnotations(annots), finalKeyword, false);\n+    }\n     /**\n      * Parse error binding pattern node.\n      * <p>\n-     * <code>functional-binding-pattern := error ( arg-list-binding-pattern )</code>\n+     * <code>error-binding-pattern := error [error-type-reference] ( error-arg-list-binding-pattern )</code>\n+     * <br/><br/>\n+     * error-arg-list-binding-pattern :=\n+     *    error-message-binding-pattern [, error-cause-binding-pattern] [, error-field-binding-patterns]\n+     *    | [error-field-binding-patterns]\n+     * <br/><br/>\n+     * error-message-binding-pattern := simple-binding-pattern\n+     * <br/><br/>\n+     * error-cause-binding-pattern := simple-binding-pattern | error-binding-pattern\n+     * <br/><br/>\n+     * simple-binding-pattern := capture-binding-pattern | wildcard-binding-pattern\n+     * <br/><br/>\n+     * error-field-binding-patterns :=\n+     *    named-arg-binding-pattern (, named-arg-binding-pattern)* [, rest-binding-pattern]\n+     *    | rest-binding-pattern\n+     * <br/><br/>\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n      * \n      * @return Error binding pattern node.\n      */\n     private STNode parseErrorBindingPattern() {\n-        startContext(ParserRuleContext.FUNCTIONAL_BINDING_PATTERN);\n-        STNode typeDesc = parseErrorKeyword();\n-        return parseFunctionalBindingPattern(typeDesc);\n+        startContext(ParserRuleContext.ERROR_BINDING_PATTERN);\n+        STNode errorKeyword = parseErrorKeyword();\n+        return parseErrorBindingPattern(errorKeyword);\n+    }\n+\n+    private STNode parseErrorBindingPattern(STNode errorKeyword) {\n+        STToken nextToken = peek();\n+        STNode typeRef;\n+        switch (nextToken.kind) {\n+            case IDENTIFIER_TOKEN:\n+                typeRef = parseTypeReference();\n+                break;\n+            case OPEN_PAREN_TOKEN:\n+                typeRef = STNodeFactory.createEmptyNode();\n+                break;\n+            default:\n+                recover(peek(), ParserRuleContext.ERROR_BINDING_PATTERN_ERROR_KEYWORD_RHS);\n+                return parseErrorBindingPattern(errorKeyword);\n+        }\n+        return parseErrorBindingPattern(errorKeyword, typeRef);\n+    }\n+\n+    private STNode parseErrorBindingPattern(STNode errorKeyword, STNode typeRef) {\n+        STNode openParenthesis = parseOpenParenthesis(ParserRuleContext.OPEN_PARENTHESIS);\n+        STNode argListBindingPatterns = parseErrorArgListBindingPatterns();\n+        STNode closeParenthesis = parseCloseParenthesis();\n+        endContext();\n+        return STNodeFactory.createErrorBindingPatternNode(errorKeyword, typeRef, openParenthesis,\n+                argListBindingPatterns, closeParenthesis);\n     }\n \n     /**\n-     * Parse functional binding pattern.\n+     * Parse error arg list binding pattern.\n      * <p>\n      * <code>\n-     * functional-binding-pattern := functionally-constructible-type-reference ( arg-list-binding-pattern )\n+     * error-arg-list-binding-pattern :=\n+     * error-message-binding-pattern [, error-cause-binding-pattern] [, error-field-binding-patterns]\n+     * | [error-field-binding-patterns]\n      * <br/><br/>\n-     * functionally-constructible-type-reference := error | type-reference\n+     *\n+     * error-message-binding-pattern := simple-binding-pattern\n+     * <br/><br/>\n+     *\n+     * error-cause-binding-pattern := simple-binding-pattern | error-binding-pattern\n+     * <br/><br/>\n+     *\n+     * simple-binding-pattern := capture-binding-pattern | wildcard-binding-pattern\n+     * <br/><br/>\n+     *\n+     * error-field-binding-patterns :=\n+     * named-arg-binding-pattern (, named-arg-binding-pattern)* [, rest-binding-pattern]\n+     * | rest-binding-pattern\n+     * <br/><br/>\n+     *\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n      * </code>\n-     * \n-     * @param typeDesc Functionally constructible type reference\n-     * @return Functional binding pattern node.\n+     *\n+     * @return Error arg list binding patterns.\n      */\n-    private STNode parseFunctionalBindingPattern(STNode typeDesc) {\n-        STNode openParenthesis = parseOpenParenthesis(ParserRuleContext.ARG_LIST_START);\n-        STNode argListBindingPatterns = parseArgListBindingPatterns();\n-        STNode closeParenthesis = parseCloseParenthesis();\n-        endContext();\n-        return STNodeFactory.createFunctionalBindingPatternNode(typeDesc, openParenthesis, argListBindingPatterns,\n-                closeParenthesis);\n-    }\n-\n-    private STNode parseArgListBindingPatterns() {\n+    private STNode parseErrorArgListBindingPatterns() {\n         List<STNode> argListBindingPatterns = new ArrayList<>();\n         SyntaxKind lastValidArgKind = SyntaxKind.CAPTURE_BINDING_PATTERN;\n         STToken nextToken = peek();\n \n         if (isEndOfParametersList(nextToken.kind)) {\n             return STNodeFactory.createNodeList(argListBindingPatterns);\n         }\n-        argListBindingPatterns.add(parseArgBindingPattern());\n \n-        nextToken = peek();\n-        while (!isEndOfParametersList(nextToken.kind)) {\n-            STNode argEnd = parseArgsBindingPatternEnd();\n-            if (argEnd == null) {\n-                // null marks the end of args\n-                break;\n-            }\n+        int argCount = 1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f838a70ba26890edd7c319b862e7bed6a8321e2f"}, "originalPosition": 217}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8f7a81692afe2f04d27870c2b5429e9aace71c3a", "author": {"user": {"login": "rdulmina", "name": "Dulmina Renuke"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/8f7a81692afe2f04d27870c2b5429e9aace71c3a", "committedDate": "2020-09-03T07:40:16Z", "message": "Refactor code."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "787979b0b2560417f598df580ba4cb210d22df57", "author": {"user": {"login": "rdulmina", "name": "Dulmina Renuke"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/787979b0b2560417f598df580ba4cb210d22df57", "committedDate": "2020-09-03T11:13:21Z", "message": "Clean the parsing logic for error-arg-list-binding-pattern."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4fe4b452947e1ee6675d1844c7e6d0bf979ef4ae", "author": {"user": {"login": "rdulmina", "name": "Dulmina Renuke"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/4fe4b452947e1ee6675d1844c7e6d0bf979ef4ae", "committedDate": "2020-09-03T12:10:03Z", "message": "Undo change to foreach_stmt_ctx_config2.json"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d8952388abc9dc177fbbaa824119b226ab5f12e1", "author": {"user": {"login": "rdulmina", "name": "Dulmina Renuke"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/d8952388abc9dc177fbbaa824119b226ab5f12e1", "committedDate": "2020-09-03T12:14:22Z", "message": "Update foreach_stmt_ctx_config2.json"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "255f71f6cb32ac76eeaff6ac8070aeec6dac51a6", "author": {"user": {"login": "rdulmina", "name": "Dulmina Renuke"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/255f71f6cb32ac76eeaff6ac8070aeec6dac51a6", "committedDate": "2020-09-03T14:03:25Z", "message": "Add new line to foreach_stmt_ctx_config2.json"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b2692e264ba3b0fe8bbc1f6ad685ba672e2e27f3", "author": {"user": {"login": "rdulmina", "name": "Dulmina Renuke"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b2692e264ba3b0fe8bbc1f6ad685ba672e2e27f3", "committedDate": "2020-09-03T15:44:19Z", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into remove-functional"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ff68af2d65f78ca06028bb945229cc4b6f7ae95f", "author": {"user": {"login": "rdulmina", "name": "Dulmina Renuke"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/ff68af2d65f78ca06028bb945229cc4b6f7ae95f", "committedDate": "2020-09-04T03:54:22Z", "message": "Reformat foreach_stmt_ctx_config2.json"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fb5c77a46bd333f3ff429cd8719fc02787459f00", "author": {"user": {"login": "rdulmina", "name": "Dulmina Renuke"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/fb5c77a46bd333f3ff429cd8719fc02787459f00", "committedDate": "2020-09-04T08:17:23Z", "message": "Fix CCE in NodeTransformer."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "908a5cf1fb56973e75669cd616060a22550392d8", "author": {"user": {"login": "rdulmina", "name": "Dulmina Renuke"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/908a5cf1fb56973e75669cd616060a22550392d8", "committedDate": "2020-09-04T09:21:53Z", "message": "Update foreach_stmt_ctx_config2.json"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1e5d00d599006b3f4394f18f682a051cd40b2a2e", "author": {"user": {"login": "rdulmina", "name": "Dulmina Renuke"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1e5d00d599006b3f4394f18f682a051cd40b2a2e", "committedDate": "2020-09-04T09:22:30Z", "message": "Add new line."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgyNTE4MDM1", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25521#pullrequestreview-482518035", "createdAt": "2020-09-04T09:51:31Z", "commit": {"oid": "1e5d00d599006b3f4394f18f682a051cd40b2a2e"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwOTo1MTozMVrOHNHWKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwOTo1MTozMVrOHNHWKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzUxMzg5Ng==", "bodyText": "can merge the else and the if", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25521#discussion_r483513896", "createdAt": "2020-09-04T09:51:31Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -12975,165 +12987,265 @@ private boolean isEndOfMappingBindingPattern(SyntaxKind nextTokenKind) {\n         return nextTokenKind == SyntaxKind.CLOSE_BRACE_TOKEN;\n     }\n \n+    private STNode parseErrorTypeDescOrErrorBP(STNode annots) {\n+        STToken nextNextToken = peek(2);\n+        switch (nextNextToken.kind) {\n+            case OPEN_PAREN_TOKEN:// Error binding pattern\n+                return parseAsErrorBindingPattern();\n+            case LT_TOKEN:\n+                return parseAsErrorTypeDesc(annots);\n+            case IDENTIFIER_TOKEN:\n+                // If the next token is identifier it can be either error a; or error a (errorMessage);\n+                SyntaxKind nextNextNextTokenKind = peek(3).kind;\n+                if (nextNextNextTokenKind == SyntaxKind.COLON_TOKEN ||\n+                        nextNextNextTokenKind == SyntaxKind.OPEN_PAREN_TOKEN) {\n+                    return parseAsErrorBindingPattern();\n+                }\n+                // Fall through.\n+            default:\n+                return parseAsErrorTypeDesc(annots);\n+        }\n+    }\n+\n+    private STNode parseAsErrorBindingPattern() {\n+        startContext(ParserRuleContext.ASSIGNMENT_STMT);\n+        return parseAssignmentStmtRhs(parseErrorBindingPattern());\n+    }\n+\n+    private STNode parseAsErrorTypeDesc(STNode annots) {\n+        STNode finalKeyword = STNodeFactory.createEmptyNode();\n+        return parseVariableDecl(getAnnotations(annots), finalKeyword, false);\n+    }\n+\n     /**\n      * Parse error binding pattern node.\n      * <p>\n-     * <code>functional-binding-pattern := error ( arg-list-binding-pattern )</code>\n+     * <code>error-binding-pattern := error [error-type-reference] ( error-arg-list-binding-pattern )</code>\n+     * <br/><br/>\n+     * error-arg-list-binding-pattern :=\n+     *    error-message-binding-pattern [, error-cause-binding-pattern] [, error-field-binding-patterns]\n+     *    | [error-field-binding-patterns]\n+     * <br/><br/>\n+     * error-message-binding-pattern := simple-binding-pattern\n+     * <br/><br/>\n+     * error-cause-binding-pattern := simple-binding-pattern | error-binding-pattern\n+     * <br/><br/>\n+     * simple-binding-pattern := capture-binding-pattern | wildcard-binding-pattern\n+     * <br/><br/>\n+     * error-field-binding-patterns :=\n+     *    named-arg-binding-pattern (, named-arg-binding-pattern)* [, rest-binding-pattern]\n+     *    | rest-binding-pattern\n+     * <br/><br/>\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n      * \n      * @return Error binding pattern node.\n      */\n     private STNode parseErrorBindingPattern() {\n-        startContext(ParserRuleContext.FUNCTIONAL_BINDING_PATTERN);\n-        STNode typeDesc = parseErrorKeyword();\n-        return parseFunctionalBindingPattern(typeDesc);\n+        startContext(ParserRuleContext.ERROR_BINDING_PATTERN);\n+        STNode errorKeyword = parseErrorKeyword();\n+        return parseErrorBindingPattern(errorKeyword);\n+    }\n+\n+    private STNode parseErrorBindingPattern(STNode errorKeyword) {\n+        STToken nextToken = peek();\n+        STNode typeRef;\n+        switch (nextToken.kind) {\n+            case IDENTIFIER_TOKEN:\n+                typeRef = parseTypeReference();\n+                break;\n+            case OPEN_PAREN_TOKEN:\n+                typeRef = STNodeFactory.createEmptyNode();\n+                break;\n+            default:\n+                recover(peek(), ParserRuleContext.ERROR_BINDING_PATTERN_ERROR_KEYWORD_RHS);\n+                return parseErrorBindingPattern(errorKeyword);\n+        }\n+        return parseErrorBindingPattern(errorKeyword, typeRef);\n+    }\n+\n+    private STNode parseErrorBindingPattern(STNode errorKeyword, STNode typeRef) {\n+        STNode openParenthesis = parseOpenParenthesis(ParserRuleContext.OPEN_PARENTHESIS);\n+        STNode argListBindingPatterns = parseErrorArgListBindingPatterns();\n+        STNode closeParenthesis = parseCloseParenthesis();\n+        endContext();\n+        return STNodeFactory.createErrorBindingPatternNode(errorKeyword, typeRef, openParenthesis,\n+                argListBindingPatterns, closeParenthesis);\n     }\n \n     /**\n-     * Parse functional binding pattern.\n+     * Parse error arg list binding pattern.\n      * <p>\n      * <code>\n-     * functional-binding-pattern := functionally-constructible-type-reference ( arg-list-binding-pattern )\n+     * error-arg-list-binding-pattern :=\n+     * error-message-binding-pattern [, error-cause-binding-pattern] [, error-field-binding-patterns]\n+     * | [error-field-binding-patterns]\n      * <br/><br/>\n-     * functionally-constructible-type-reference := error | type-reference\n+     *\n+     * error-message-binding-pattern := simple-binding-pattern\n+     * <br/><br/>\n+     *\n+     * error-cause-binding-pattern := simple-binding-pattern | error-binding-pattern\n+     * <br/><br/>\n+     *\n+     * simple-binding-pattern := capture-binding-pattern | wildcard-binding-pattern\n+     * <br/><br/>\n+     *\n+     * error-field-binding-patterns :=\n+     * named-arg-binding-pattern (, named-arg-binding-pattern)* [, rest-binding-pattern]\n+     * | rest-binding-pattern\n+     * <br/><br/>\n+     *\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n      * </code>\n-     * \n-     * @param typeDesc Functionally constructible type reference\n-     * @return Functional binding pattern node.\n+     *\n+     * @return Error arg list binding patterns.\n      */\n-    private STNode parseFunctionalBindingPattern(STNode typeDesc) {\n-        STNode openParenthesis = parseOpenParenthesis(ParserRuleContext.ARG_LIST_START);\n-        STNode argListBindingPatterns = parseArgListBindingPatterns();\n-        STNode closeParenthesis = parseCloseParenthesis();\n-        endContext();\n-        return STNodeFactory.createFunctionalBindingPatternNode(typeDesc, openParenthesis, argListBindingPatterns,\n-                closeParenthesis);\n-    }\n-\n-    private STNode parseArgListBindingPatterns() {\n+    private STNode parseErrorArgListBindingPatterns() {\n         List<STNode> argListBindingPatterns = new ArrayList<>();\n-        SyntaxKind lastValidArgKind = SyntaxKind.CAPTURE_BINDING_PATTERN;\n-        STToken nextToken = peek();\n-\n-        if (isEndOfParametersList(nextToken.kind)) {\n+        if (isEndOfErrorFieldBindingPatterns()) {\n             return STNodeFactory.createNodeList(argListBindingPatterns);\n         }\n-        argListBindingPatterns.add(parseArgBindingPattern());\n+        STNode firstArg = parseErrorArgListBindingPattern(ParserRuleContext.ERROR_ARG_LIST_BINDING_PATTERN_START);\n+        if (firstArg.kind == SyntaxKind.CAPTURE_BINDING_PATTERN ||\n+                firstArg.kind == SyntaxKind.WILDCARD_BINDING_PATTERN) {\n \n-        nextToken = peek();\n-        while (!isEndOfParametersList(nextToken.kind)) {\n-            STNode argEnd = parseArgsBindingPatternEnd();\n+            argListBindingPatterns.add(firstArg);\n+            STNode argEnd = parseErrorArgsBindingPatternEnd(ParserRuleContext.ERROR_MESSAGE_BINDING_PATTERN_END);\n+            if (argEnd != null) {\n+                // null marks the end of args\n+                STNode secondArg = parseErrorArgListBindingPattern(ParserRuleContext.ERROR_MESSAGE_BINDING_PATTERN_RHS);\n+                if (isValidSecondArgBindingPattern(secondArg.kind)) {\n+                    argListBindingPatterns.add(argEnd);\n+                    argListBindingPatterns.add(secondArg);\n+                } else {\n+                    updateLastNodeInListWithInvalidNode(argListBindingPatterns, argEnd, null);\n+                    updateLastNodeInListWithInvalidNode(argListBindingPatterns, secondArg,\n+                            DiagnosticErrorCode.ERROR_BINDING_PATTERN_NOT_ALLOWED);\n+                }\n+            }\n+        } else {\n+            if (firstArg.kind != SyntaxKind.NAMED_ARG_BINDING_PATTERN &&", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e5d00d599006b3f4394f18f682a051cd40b2a2e"}, "originalPosition": 233}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4769, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}