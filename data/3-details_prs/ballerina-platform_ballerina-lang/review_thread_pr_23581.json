{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI0NTY3NzQz", "number": 23581, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwMzozMjo0NlrOEAvoSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMzowMDo1NlrOEBu7cg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MjE1ODE5OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwMzozMjo0NlrOGcNqqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwODoyMzozMlrOGcTZ0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIzNzIyNg==", "bodyText": "Can we use parseMemberAccessExpr? Because it already handles the contexts as well, and I feel both grammar are the same:\nexpression xml-step-start [expression] is equivalent to both:\n\nexpression [expression] and\nexpression xml-step-start xml-step-extend\n\nSo we can simply return if its not .< and parseExpressionRhs will take care of the rest. wdyt?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23581#discussion_r432237226", "createdAt": "2020-05-29T03:32:46Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -12025,4 +12043,338 @@ private STNode parseByteArrayContent(SyntaxKind kind) {\n \n         return content;\n     }\n+\n+    /**\n+     * Parse xml filter expression.\n+     * <p>\n+     * <code>xml-filter-expr := expression .< xml-name-pattern ></code>\n+     *\n+     * @param lhsExpr Preceding expression of .< token\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLFilterExpression(STNode lhsExpr) {\n+        STNode xmlNamePatternChain = parseXMLFilterExpressionRhs();\n+        return STNodeFactory.createXMLFilterExpressionNode(lhsExpr, xmlNamePatternChain);\n+    }\n+\n+    /**\n+     * Parse xml filter expression rhs.\n+     * <p>\n+     * <code>filer-expression-rhs := .< xml-name-pattern ></code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLFilterExpressionRhs() {\n+        STNode dotLTToken = parseDotLTToken();\n+        return parseXMLNamePatternChain(dotLTToken);\n+    }\n+\n+    /**\n+     * Parse xml name pattern chain.\n+     * <p>\n+     * <code>\n+     * xml-name-pattern-chain := filer-expression-rhs | xml-element-children-step | xml-element-descendants-step\n+     * <br/>\n+     * filer-expression-rhs := .< xml-name-pattern >\n+     * <br/>\n+     * xml-element-children-step := /< xml-name-pattern >\n+     * <br/>\n+     * xml-element-descendants-step := /**\\/<xml-name-pattern >\n+     * </code>\n+     *\n+     * @param startToken Preceding token of xml name pattern\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLNamePatternChain(STNode startToken) {\n+        STNode xmlNamePattern = parseXMLNamePattern();\n+        STNode gtToken = parseGTToken();\n+        return STNodeFactory.createXMLNamePatternChainingNode(startToken, xmlNamePattern, gtToken);\n+    }\n+\n+    /**\n+     * Parse <code> .< </code> token.\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseDotLTToken() {\n+        STToken nextToken = peek();\n+        if (nextToken.kind == SyntaxKind.DOT_LT_TOKEN) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(nextToken, ParserRuleContext.DOT_LT_TOKEN);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse xml name pattern.\n+     * <p>\n+     * <code>xml-name-pattern := xml-atomic-name-pattern [| xml-atomic-name-pattern]*</code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLNamePattern() {\n+        List<STNode> xmlAtomicNamePatternList = new ArrayList<>();\n+        STToken nextToken = peek();\n+\n+        // Return an empty list\n+        if (isEndOfXMLNamePattern(nextToken.kind)) {\n+            this.errorHandler.reportMissingTokenError(\"missing xml atomic name pattern\");\n+            return STNodeFactory.createNodeList(xmlAtomicNamePatternList);\n+        }\n+\n+        // Parse first xml atomic name pattern, that has no leading pipe token\n+        STNode xmlAtomicNamePattern = parseXMLAtomicNamePattern();\n+        xmlAtomicNamePatternList.add(xmlAtomicNamePattern);\n+\n+        // Parse the remaining xml atomic name patterns\n+        nextToken = peek();\n+        STNode leadingPipe;\n+        while (!isEndOfXMLNamePattern(nextToken.kind)) {\n+            leadingPipe = parsePipeToken();\n+            xmlAtomicNamePatternList.add(leadingPipe);\n+            xmlAtomicNamePattern = parseXMLAtomicNamePattern();\n+            xmlAtomicNamePatternList.add(xmlAtomicNamePattern);\n+            nextToken = peek();\n+        }\n+\n+        return STNodeFactory.createNodeList(xmlAtomicNamePatternList);\n+    }\n+\n+    private boolean isEndOfXMLNamePattern(SyntaxKind tokenKind) {\n+        switch (tokenKind) {\n+            case IDENTIFIER_TOKEN:\n+            case ASTERISK_TOKEN:\n+            case COLON_TOKEN:\n+                return false;\n+            case GT_TOKEN:\n+            case EOF_TOKEN:\n+            case AT_TOKEN:\n+            case DOCUMENTATION_LINE:\n+            case CLOSE_BRACE_TOKEN:\n+            case SEMICOLON_TOKEN:\n+            case PUBLIC_KEYWORD:\n+            case PRIVATE_KEYWORD:\n+            case FUNCTION_KEYWORD:\n+            case RETURNS_KEYWORD:\n+            case SERVICE_KEYWORD:\n+            case TYPE_KEYWORD:\n+            case LISTENER_KEYWORD:\n+            case CONST_KEYWORD:\n+            case FINAL_KEYWORD:\n+            case RESOURCE_KEYWORD:\n+                return true;\n+            default:\n+                return isSimpleType(tokenKind);\n+        }\n+    }\n+\n+    /**\n+     * Parse xml atomic name pattern.\n+     * <p>\n+     * <code>\n+     * xml-atomic-name-pattern :=\n+     *   *\n+     *   | identifier\n+     *   | xml-namespace-prefix : identifier\n+     *   | xml-namespace-prefix : *\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLAtomicNamePattern() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.ASTERISK_TOKEN) {\n+            return consume();\n+        } else if (token.kind == SyntaxKind.IDENTIFIER_TOKEN) {\n+            STNode identifier = consume();\n+            return parseXMLAtomicNameIdentifier(identifier);\n+        }\n+        return STNodeFactory.createEmptyNode();\n+    }\n+\n+    private STNode parseXMLAtomicNameIdentifier(STNode identifier) {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.COLON_TOKEN) {\n+            STNode colon = consume();\n+            STToken nextToken = peek();\n+            if (nextToken.kind == SyntaxKind.IDENTIFIER_TOKEN || nextToken.kind == SyntaxKind.ASTERISK_TOKEN) {\n+                STToken endToken = consume();\n+                return STNodeFactory.createXMLAtomicNamePatternNode(identifier, colon, endToken);\n+            }\n+        }\n+        return STNodeFactory.createSimpleNameReferenceNode(identifier);\n+    }\n+\n+    /**\n+     * Parse xml step expression.\n+     * <p>\n+     * <code>xml-step-expr := expression xml-step-start xml-step-extend*</code>\n+     *\n+     * @param lhsExpr Preceding expression of /*, /<, or /**\\/< token\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLStepExpression(STNode lhsExpr) {\n+        STNode xmlStepStart = parseXMLStepStart();\n+        STNode xmlStepExtendList = parseXMLStepExtendList();\n+        return STNodeFactory.createXMLStepExpressionNode(lhsExpr, xmlStepStart, xmlStepExtendList);\n+    }\n+\n+    /**\n+     * Parse xml filter expression rhs.\n+     * <p>\n+     * <code>\n+     *  xml-step-start :=\n+     *      xml-all-children-step\n+     *      | xml-element-children-step\n+     *      | xml-element-descendants-step\n+     * <br/>\n+     * xml-all-children-step := /*\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLStepStart() {\n+        STToken token = peek();\n+        STNode startToken;\n+\n+        switch (token.kind) {\n+            case SLASH_ASTERISK_TOKEN:\n+                return consume();\n+            case DOUBLE_SLASH_DOUBLE_ASTERISK_LT_TOKEN:\n+                startToken = parseDoubleSlashDoubleAsteriskLTToken();\n+                break;\n+            case SLASH_LT_TOKEN:\n+            default:\n+                startToken = parseSlashLTToken();\n+                break;\n+        }\n+        return parseXMLNamePatternChain(startToken);\n+    }\n+\n+    /**\n+     * Parse <code> /< </code> token.\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseSlashLTToken() {\n+        STToken nextToken = peek();\n+        if (nextToken.kind == SyntaxKind.SLASH_LT_TOKEN) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(nextToken, ParserRuleContext.SLASH_LT_TOKEN);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse <code> /< </code> token.\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseDoubleSlashDoubleAsteriskLTToken() {\n+        STToken nextToken = peek();\n+        if (nextToken.kind == SyntaxKind.DOUBLE_SLASH_DOUBLE_ASTERISK_LT_TOKEN) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(nextToken, ParserRuleContext.DOUBLE_SLASH_DOUBLE_ASTERISK_LT_TOKEN);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse xml step extend list.\n+     * <p>\n+     * <code>xml-step-extend-list := xml-step-extend*</code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLStepExtendList() {\n+        List<STNode> xmlStepExtendList = new ArrayList<>();\n+        STToken nextToken = peek();\n+\n+        // Return an empty list\n+        if (isEndOfXMLStepExtend(nextToken.kind)) {\n+            return STNodeFactory.createNodeList(xmlStepExtendList);\n+        }\n+\n+        nextToken = peek();\n+        STNode xmlStepExtend;\n+        while (!isEndOfXMLNamePattern(nextToken.kind)) {\n+            xmlStepExtend = parseXMLStepExtend();\n+            xmlStepExtendList.add(xmlStepExtend);\n+            nextToken = peek();\n+        }\n+\n+        return STNodeFactory.createNodeList(xmlStepExtendList);\n+    }\n+\n+    private boolean isEndOfXMLStepExtend(SyntaxKind tokenKind) {\n+        switch (tokenKind) {\n+            case DOT_LT_TOKEN:\n+            case OPEN_BRACKET_TOKEN:\n+            case DOT_TOKEN:\n+                return false;\n+            default:\n+                return true;\n+        }\n+    }\n+\n+    /**\n+     * Parse xml step extend list.\n+     * <p>\n+     * <code>\n+     * xml-step-extend :=\n+     *    .< xml-name-pattern >\n+     *    | [ expression ]\n+     *    | . method-name ( arg-list )\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLStepExtend() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case DOT_LT_TOKEN:\n+                return parseXMLFilterExpressionRhs();\n+            case DOT_TOKEN:\n+                return parseMethodCallChain();\n+            // token kind is already validated in isEndOfXMLStepExtend and reach here.\n+            // therefore, a recover solution is not required for the default case.\n+            case OPEN_BRACKET_TOKEN:\n+            default:\n+                return parseOpenBracketExpressionChain();\n+\n+        }\n+    }\n+\n+    /**\n+     * Parse open bracket expression chain.\n+     * <p>\n+     * <code>open-bracket-expression-chain := `[` expression `]`</code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseOpenBracketExpressionChain() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2fafddc846bc83ee150b1b775050d159dab1b671"}, "originalPosition": 362}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI3MjAyMw==", "bodyText": "Please review the last commit.\nWith above change we will have problems like following.\na /* .<*> [e] .b()\nearlier [e] and .b() are parsed as two xml-step-extends. Now [e] .b() is combined and make a single method-call-expr\na /* [d] [e] .<*>\nearlier [d], [e] and .<*> are parsed as three xml-step-extends. Now [d] [e] .<*> is parsed as a xml-filter-expr as it has expr .<xml-name-pattern> grammar.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23581#discussion_r432272023", "createdAt": "2020-05-29T06:01:59Z", "author": {"login": "lochana-chathura"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -12025,4 +12043,338 @@ private STNode parseByteArrayContent(SyntaxKind kind) {\n \n         return content;\n     }\n+\n+    /**\n+     * Parse xml filter expression.\n+     * <p>\n+     * <code>xml-filter-expr := expression .< xml-name-pattern ></code>\n+     *\n+     * @param lhsExpr Preceding expression of .< token\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLFilterExpression(STNode lhsExpr) {\n+        STNode xmlNamePatternChain = parseXMLFilterExpressionRhs();\n+        return STNodeFactory.createXMLFilterExpressionNode(lhsExpr, xmlNamePatternChain);\n+    }\n+\n+    /**\n+     * Parse xml filter expression rhs.\n+     * <p>\n+     * <code>filer-expression-rhs := .< xml-name-pattern ></code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLFilterExpressionRhs() {\n+        STNode dotLTToken = parseDotLTToken();\n+        return parseXMLNamePatternChain(dotLTToken);\n+    }\n+\n+    /**\n+     * Parse xml name pattern chain.\n+     * <p>\n+     * <code>\n+     * xml-name-pattern-chain := filer-expression-rhs | xml-element-children-step | xml-element-descendants-step\n+     * <br/>\n+     * filer-expression-rhs := .< xml-name-pattern >\n+     * <br/>\n+     * xml-element-children-step := /< xml-name-pattern >\n+     * <br/>\n+     * xml-element-descendants-step := /**\\/<xml-name-pattern >\n+     * </code>\n+     *\n+     * @param startToken Preceding token of xml name pattern\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLNamePatternChain(STNode startToken) {\n+        STNode xmlNamePattern = parseXMLNamePattern();\n+        STNode gtToken = parseGTToken();\n+        return STNodeFactory.createXMLNamePatternChainingNode(startToken, xmlNamePattern, gtToken);\n+    }\n+\n+    /**\n+     * Parse <code> .< </code> token.\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseDotLTToken() {\n+        STToken nextToken = peek();\n+        if (nextToken.kind == SyntaxKind.DOT_LT_TOKEN) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(nextToken, ParserRuleContext.DOT_LT_TOKEN);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse xml name pattern.\n+     * <p>\n+     * <code>xml-name-pattern := xml-atomic-name-pattern [| xml-atomic-name-pattern]*</code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLNamePattern() {\n+        List<STNode> xmlAtomicNamePatternList = new ArrayList<>();\n+        STToken nextToken = peek();\n+\n+        // Return an empty list\n+        if (isEndOfXMLNamePattern(nextToken.kind)) {\n+            this.errorHandler.reportMissingTokenError(\"missing xml atomic name pattern\");\n+            return STNodeFactory.createNodeList(xmlAtomicNamePatternList);\n+        }\n+\n+        // Parse first xml atomic name pattern, that has no leading pipe token\n+        STNode xmlAtomicNamePattern = parseXMLAtomicNamePattern();\n+        xmlAtomicNamePatternList.add(xmlAtomicNamePattern);\n+\n+        // Parse the remaining xml atomic name patterns\n+        nextToken = peek();\n+        STNode leadingPipe;\n+        while (!isEndOfXMLNamePattern(nextToken.kind)) {\n+            leadingPipe = parsePipeToken();\n+            xmlAtomicNamePatternList.add(leadingPipe);\n+            xmlAtomicNamePattern = parseXMLAtomicNamePattern();\n+            xmlAtomicNamePatternList.add(xmlAtomicNamePattern);\n+            nextToken = peek();\n+        }\n+\n+        return STNodeFactory.createNodeList(xmlAtomicNamePatternList);\n+    }\n+\n+    private boolean isEndOfXMLNamePattern(SyntaxKind tokenKind) {\n+        switch (tokenKind) {\n+            case IDENTIFIER_TOKEN:\n+            case ASTERISK_TOKEN:\n+            case COLON_TOKEN:\n+                return false;\n+            case GT_TOKEN:\n+            case EOF_TOKEN:\n+            case AT_TOKEN:\n+            case DOCUMENTATION_LINE:\n+            case CLOSE_BRACE_TOKEN:\n+            case SEMICOLON_TOKEN:\n+            case PUBLIC_KEYWORD:\n+            case PRIVATE_KEYWORD:\n+            case FUNCTION_KEYWORD:\n+            case RETURNS_KEYWORD:\n+            case SERVICE_KEYWORD:\n+            case TYPE_KEYWORD:\n+            case LISTENER_KEYWORD:\n+            case CONST_KEYWORD:\n+            case FINAL_KEYWORD:\n+            case RESOURCE_KEYWORD:\n+                return true;\n+            default:\n+                return isSimpleType(tokenKind);\n+        }\n+    }\n+\n+    /**\n+     * Parse xml atomic name pattern.\n+     * <p>\n+     * <code>\n+     * xml-atomic-name-pattern :=\n+     *   *\n+     *   | identifier\n+     *   | xml-namespace-prefix : identifier\n+     *   | xml-namespace-prefix : *\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLAtomicNamePattern() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.ASTERISK_TOKEN) {\n+            return consume();\n+        } else if (token.kind == SyntaxKind.IDENTIFIER_TOKEN) {\n+            STNode identifier = consume();\n+            return parseXMLAtomicNameIdentifier(identifier);\n+        }\n+        return STNodeFactory.createEmptyNode();\n+    }\n+\n+    private STNode parseXMLAtomicNameIdentifier(STNode identifier) {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.COLON_TOKEN) {\n+            STNode colon = consume();\n+            STToken nextToken = peek();\n+            if (nextToken.kind == SyntaxKind.IDENTIFIER_TOKEN || nextToken.kind == SyntaxKind.ASTERISK_TOKEN) {\n+                STToken endToken = consume();\n+                return STNodeFactory.createXMLAtomicNamePatternNode(identifier, colon, endToken);\n+            }\n+        }\n+        return STNodeFactory.createSimpleNameReferenceNode(identifier);\n+    }\n+\n+    /**\n+     * Parse xml step expression.\n+     * <p>\n+     * <code>xml-step-expr := expression xml-step-start xml-step-extend*</code>\n+     *\n+     * @param lhsExpr Preceding expression of /*, /<, or /**\\/< token\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLStepExpression(STNode lhsExpr) {\n+        STNode xmlStepStart = parseXMLStepStart();\n+        STNode xmlStepExtendList = parseXMLStepExtendList();\n+        return STNodeFactory.createXMLStepExpressionNode(lhsExpr, xmlStepStart, xmlStepExtendList);\n+    }\n+\n+    /**\n+     * Parse xml filter expression rhs.\n+     * <p>\n+     * <code>\n+     *  xml-step-start :=\n+     *      xml-all-children-step\n+     *      | xml-element-children-step\n+     *      | xml-element-descendants-step\n+     * <br/>\n+     * xml-all-children-step := /*\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLStepStart() {\n+        STToken token = peek();\n+        STNode startToken;\n+\n+        switch (token.kind) {\n+            case SLASH_ASTERISK_TOKEN:\n+                return consume();\n+            case DOUBLE_SLASH_DOUBLE_ASTERISK_LT_TOKEN:\n+                startToken = parseDoubleSlashDoubleAsteriskLTToken();\n+                break;\n+            case SLASH_LT_TOKEN:\n+            default:\n+                startToken = parseSlashLTToken();\n+                break;\n+        }\n+        return parseXMLNamePatternChain(startToken);\n+    }\n+\n+    /**\n+     * Parse <code> /< </code> token.\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseSlashLTToken() {\n+        STToken nextToken = peek();\n+        if (nextToken.kind == SyntaxKind.SLASH_LT_TOKEN) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(nextToken, ParserRuleContext.SLASH_LT_TOKEN);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse <code> /< </code> token.\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseDoubleSlashDoubleAsteriskLTToken() {\n+        STToken nextToken = peek();\n+        if (nextToken.kind == SyntaxKind.DOUBLE_SLASH_DOUBLE_ASTERISK_LT_TOKEN) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(nextToken, ParserRuleContext.DOUBLE_SLASH_DOUBLE_ASTERISK_LT_TOKEN);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse xml step extend list.\n+     * <p>\n+     * <code>xml-step-extend-list := xml-step-extend*</code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLStepExtendList() {\n+        List<STNode> xmlStepExtendList = new ArrayList<>();\n+        STToken nextToken = peek();\n+\n+        // Return an empty list\n+        if (isEndOfXMLStepExtend(nextToken.kind)) {\n+            return STNodeFactory.createNodeList(xmlStepExtendList);\n+        }\n+\n+        nextToken = peek();\n+        STNode xmlStepExtend;\n+        while (!isEndOfXMLNamePattern(nextToken.kind)) {\n+            xmlStepExtend = parseXMLStepExtend();\n+            xmlStepExtendList.add(xmlStepExtend);\n+            nextToken = peek();\n+        }\n+\n+        return STNodeFactory.createNodeList(xmlStepExtendList);\n+    }\n+\n+    private boolean isEndOfXMLStepExtend(SyntaxKind tokenKind) {\n+        switch (tokenKind) {\n+            case DOT_LT_TOKEN:\n+            case OPEN_BRACKET_TOKEN:\n+            case DOT_TOKEN:\n+                return false;\n+            default:\n+                return true;\n+        }\n+    }\n+\n+    /**\n+     * Parse xml step extend list.\n+     * <p>\n+     * <code>\n+     * xml-step-extend :=\n+     *    .< xml-name-pattern >\n+     *    | [ expression ]\n+     *    | . method-name ( arg-list )\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLStepExtend() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case DOT_LT_TOKEN:\n+                return parseXMLFilterExpressionRhs();\n+            case DOT_TOKEN:\n+                return parseMethodCallChain();\n+            // token kind is already validated in isEndOfXMLStepExtend and reach here.\n+            // therefore, a recover solution is not required for the default case.\n+            case OPEN_BRACKET_TOKEN:\n+            default:\n+                return parseOpenBracketExpressionChain();\n+\n+        }\n+    }\n+\n+    /**\n+     * Parse open bracket expression chain.\n+     * <p>\n+     * <code>open-bracket-expression-chain := `[` expression `]`</code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseOpenBracketExpressionChain() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIzNzIyNg=="}, "originalCommit": {"oid": "2fafddc846bc83ee150b1b775050d159dab1b671"}, "originalPosition": 362}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMzMTIxNw==", "bodyText": "I think thats OK.\nThat separation in the grammar is used to describe the runtime behaviour. For the parser, it's a one structure.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23581#discussion_r432331217", "createdAt": "2020-05-29T08:23:32Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -12025,4 +12043,338 @@ private STNode parseByteArrayContent(SyntaxKind kind) {\n \n         return content;\n     }\n+\n+    /**\n+     * Parse xml filter expression.\n+     * <p>\n+     * <code>xml-filter-expr := expression .< xml-name-pattern ></code>\n+     *\n+     * @param lhsExpr Preceding expression of .< token\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLFilterExpression(STNode lhsExpr) {\n+        STNode xmlNamePatternChain = parseXMLFilterExpressionRhs();\n+        return STNodeFactory.createXMLFilterExpressionNode(lhsExpr, xmlNamePatternChain);\n+    }\n+\n+    /**\n+     * Parse xml filter expression rhs.\n+     * <p>\n+     * <code>filer-expression-rhs := .< xml-name-pattern ></code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLFilterExpressionRhs() {\n+        STNode dotLTToken = parseDotLTToken();\n+        return parseXMLNamePatternChain(dotLTToken);\n+    }\n+\n+    /**\n+     * Parse xml name pattern chain.\n+     * <p>\n+     * <code>\n+     * xml-name-pattern-chain := filer-expression-rhs | xml-element-children-step | xml-element-descendants-step\n+     * <br/>\n+     * filer-expression-rhs := .< xml-name-pattern >\n+     * <br/>\n+     * xml-element-children-step := /< xml-name-pattern >\n+     * <br/>\n+     * xml-element-descendants-step := /**\\/<xml-name-pattern >\n+     * </code>\n+     *\n+     * @param startToken Preceding token of xml name pattern\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLNamePatternChain(STNode startToken) {\n+        STNode xmlNamePattern = parseXMLNamePattern();\n+        STNode gtToken = parseGTToken();\n+        return STNodeFactory.createXMLNamePatternChainingNode(startToken, xmlNamePattern, gtToken);\n+    }\n+\n+    /**\n+     * Parse <code> .< </code> token.\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseDotLTToken() {\n+        STToken nextToken = peek();\n+        if (nextToken.kind == SyntaxKind.DOT_LT_TOKEN) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(nextToken, ParserRuleContext.DOT_LT_TOKEN);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse xml name pattern.\n+     * <p>\n+     * <code>xml-name-pattern := xml-atomic-name-pattern [| xml-atomic-name-pattern]*</code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLNamePattern() {\n+        List<STNode> xmlAtomicNamePatternList = new ArrayList<>();\n+        STToken nextToken = peek();\n+\n+        // Return an empty list\n+        if (isEndOfXMLNamePattern(nextToken.kind)) {\n+            this.errorHandler.reportMissingTokenError(\"missing xml atomic name pattern\");\n+            return STNodeFactory.createNodeList(xmlAtomicNamePatternList);\n+        }\n+\n+        // Parse first xml atomic name pattern, that has no leading pipe token\n+        STNode xmlAtomicNamePattern = parseXMLAtomicNamePattern();\n+        xmlAtomicNamePatternList.add(xmlAtomicNamePattern);\n+\n+        // Parse the remaining xml atomic name patterns\n+        nextToken = peek();\n+        STNode leadingPipe;\n+        while (!isEndOfXMLNamePattern(nextToken.kind)) {\n+            leadingPipe = parsePipeToken();\n+            xmlAtomicNamePatternList.add(leadingPipe);\n+            xmlAtomicNamePattern = parseXMLAtomicNamePattern();\n+            xmlAtomicNamePatternList.add(xmlAtomicNamePattern);\n+            nextToken = peek();\n+        }\n+\n+        return STNodeFactory.createNodeList(xmlAtomicNamePatternList);\n+    }\n+\n+    private boolean isEndOfXMLNamePattern(SyntaxKind tokenKind) {\n+        switch (tokenKind) {\n+            case IDENTIFIER_TOKEN:\n+            case ASTERISK_TOKEN:\n+            case COLON_TOKEN:\n+                return false;\n+            case GT_TOKEN:\n+            case EOF_TOKEN:\n+            case AT_TOKEN:\n+            case DOCUMENTATION_LINE:\n+            case CLOSE_BRACE_TOKEN:\n+            case SEMICOLON_TOKEN:\n+            case PUBLIC_KEYWORD:\n+            case PRIVATE_KEYWORD:\n+            case FUNCTION_KEYWORD:\n+            case RETURNS_KEYWORD:\n+            case SERVICE_KEYWORD:\n+            case TYPE_KEYWORD:\n+            case LISTENER_KEYWORD:\n+            case CONST_KEYWORD:\n+            case FINAL_KEYWORD:\n+            case RESOURCE_KEYWORD:\n+                return true;\n+            default:\n+                return isSimpleType(tokenKind);\n+        }\n+    }\n+\n+    /**\n+     * Parse xml atomic name pattern.\n+     * <p>\n+     * <code>\n+     * xml-atomic-name-pattern :=\n+     *   *\n+     *   | identifier\n+     *   | xml-namespace-prefix : identifier\n+     *   | xml-namespace-prefix : *\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLAtomicNamePattern() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.ASTERISK_TOKEN) {\n+            return consume();\n+        } else if (token.kind == SyntaxKind.IDENTIFIER_TOKEN) {\n+            STNode identifier = consume();\n+            return parseXMLAtomicNameIdentifier(identifier);\n+        }\n+        return STNodeFactory.createEmptyNode();\n+    }\n+\n+    private STNode parseXMLAtomicNameIdentifier(STNode identifier) {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.COLON_TOKEN) {\n+            STNode colon = consume();\n+            STToken nextToken = peek();\n+            if (nextToken.kind == SyntaxKind.IDENTIFIER_TOKEN || nextToken.kind == SyntaxKind.ASTERISK_TOKEN) {\n+                STToken endToken = consume();\n+                return STNodeFactory.createXMLAtomicNamePatternNode(identifier, colon, endToken);\n+            }\n+        }\n+        return STNodeFactory.createSimpleNameReferenceNode(identifier);\n+    }\n+\n+    /**\n+     * Parse xml step expression.\n+     * <p>\n+     * <code>xml-step-expr := expression xml-step-start xml-step-extend*</code>\n+     *\n+     * @param lhsExpr Preceding expression of /*, /<, or /**\\/< token\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLStepExpression(STNode lhsExpr) {\n+        STNode xmlStepStart = parseXMLStepStart();\n+        STNode xmlStepExtendList = parseXMLStepExtendList();\n+        return STNodeFactory.createXMLStepExpressionNode(lhsExpr, xmlStepStart, xmlStepExtendList);\n+    }\n+\n+    /**\n+     * Parse xml filter expression rhs.\n+     * <p>\n+     * <code>\n+     *  xml-step-start :=\n+     *      xml-all-children-step\n+     *      | xml-element-children-step\n+     *      | xml-element-descendants-step\n+     * <br/>\n+     * xml-all-children-step := /*\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLStepStart() {\n+        STToken token = peek();\n+        STNode startToken;\n+\n+        switch (token.kind) {\n+            case SLASH_ASTERISK_TOKEN:\n+                return consume();\n+            case DOUBLE_SLASH_DOUBLE_ASTERISK_LT_TOKEN:\n+                startToken = parseDoubleSlashDoubleAsteriskLTToken();\n+                break;\n+            case SLASH_LT_TOKEN:\n+            default:\n+                startToken = parseSlashLTToken();\n+                break;\n+        }\n+        return parseXMLNamePatternChain(startToken);\n+    }\n+\n+    /**\n+     * Parse <code> /< </code> token.\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseSlashLTToken() {\n+        STToken nextToken = peek();\n+        if (nextToken.kind == SyntaxKind.SLASH_LT_TOKEN) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(nextToken, ParserRuleContext.SLASH_LT_TOKEN);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse <code> /< </code> token.\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseDoubleSlashDoubleAsteriskLTToken() {\n+        STToken nextToken = peek();\n+        if (nextToken.kind == SyntaxKind.DOUBLE_SLASH_DOUBLE_ASTERISK_LT_TOKEN) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(nextToken, ParserRuleContext.DOUBLE_SLASH_DOUBLE_ASTERISK_LT_TOKEN);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse xml step extend list.\n+     * <p>\n+     * <code>xml-step-extend-list := xml-step-extend*</code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLStepExtendList() {\n+        List<STNode> xmlStepExtendList = new ArrayList<>();\n+        STToken nextToken = peek();\n+\n+        // Return an empty list\n+        if (isEndOfXMLStepExtend(nextToken.kind)) {\n+            return STNodeFactory.createNodeList(xmlStepExtendList);\n+        }\n+\n+        nextToken = peek();\n+        STNode xmlStepExtend;\n+        while (!isEndOfXMLNamePattern(nextToken.kind)) {\n+            xmlStepExtend = parseXMLStepExtend();\n+            xmlStepExtendList.add(xmlStepExtend);\n+            nextToken = peek();\n+        }\n+\n+        return STNodeFactory.createNodeList(xmlStepExtendList);\n+    }\n+\n+    private boolean isEndOfXMLStepExtend(SyntaxKind tokenKind) {\n+        switch (tokenKind) {\n+            case DOT_LT_TOKEN:\n+            case OPEN_BRACKET_TOKEN:\n+            case DOT_TOKEN:\n+                return false;\n+            default:\n+                return true;\n+        }\n+    }\n+\n+    /**\n+     * Parse xml step extend list.\n+     * <p>\n+     * <code>\n+     * xml-step-extend :=\n+     *    .< xml-name-pattern >\n+     *    | [ expression ]\n+     *    | . method-name ( arg-list )\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLStepExtend() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case DOT_LT_TOKEN:\n+                return parseXMLFilterExpressionRhs();\n+            case DOT_TOKEN:\n+                return parseMethodCallChain();\n+            // token kind is already validated in isEndOfXMLStepExtend and reach here.\n+            // therefore, a recover solution is not required for the default case.\n+            case OPEN_BRACKET_TOKEN:\n+            default:\n+                return parseOpenBracketExpressionChain();\n+\n+        }\n+    }\n+\n+    /**\n+     * Parse open bracket expression chain.\n+     * <p>\n+     * <code>open-bracket-expression-chain := `[` expression `]`</code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseOpenBracketExpressionChain() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIzNzIyNg=="}, "originalCommit": {"oid": "2fafddc846bc83ee150b1b775050d159dab1b671"}, "originalPosition": 362}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MjE2MzEyOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwMzozNjoyM1rOGcNtiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwMzozNjoyM1rOGcNtiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIzNzk2Mw==", "bodyText": "Probably be able to simply let the parseExpressionRhs handles it, similar to above.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23581#discussion_r432237963", "createdAt": "2020-05-29T03:36:23Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -12025,4 +12043,338 @@ private STNode parseByteArrayContent(SyntaxKind kind) {\n \n         return content;\n     }\n+\n+    /**\n+     * Parse xml filter expression.\n+     * <p>\n+     * <code>xml-filter-expr := expression .< xml-name-pattern ></code>\n+     *\n+     * @param lhsExpr Preceding expression of .< token\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLFilterExpression(STNode lhsExpr) {\n+        STNode xmlNamePatternChain = parseXMLFilterExpressionRhs();\n+        return STNodeFactory.createXMLFilterExpressionNode(lhsExpr, xmlNamePatternChain);\n+    }\n+\n+    /**\n+     * Parse xml filter expression rhs.\n+     * <p>\n+     * <code>filer-expression-rhs := .< xml-name-pattern ></code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLFilterExpressionRhs() {\n+        STNode dotLTToken = parseDotLTToken();\n+        return parseXMLNamePatternChain(dotLTToken);\n+    }\n+\n+    /**\n+     * Parse xml name pattern chain.\n+     * <p>\n+     * <code>\n+     * xml-name-pattern-chain := filer-expression-rhs | xml-element-children-step | xml-element-descendants-step\n+     * <br/>\n+     * filer-expression-rhs := .< xml-name-pattern >\n+     * <br/>\n+     * xml-element-children-step := /< xml-name-pattern >\n+     * <br/>\n+     * xml-element-descendants-step := /**\\/<xml-name-pattern >\n+     * </code>\n+     *\n+     * @param startToken Preceding token of xml name pattern\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLNamePatternChain(STNode startToken) {\n+        STNode xmlNamePattern = parseXMLNamePattern();\n+        STNode gtToken = parseGTToken();\n+        return STNodeFactory.createXMLNamePatternChainingNode(startToken, xmlNamePattern, gtToken);\n+    }\n+\n+    /**\n+     * Parse <code> .< </code> token.\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseDotLTToken() {\n+        STToken nextToken = peek();\n+        if (nextToken.kind == SyntaxKind.DOT_LT_TOKEN) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(nextToken, ParserRuleContext.DOT_LT_TOKEN);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse xml name pattern.\n+     * <p>\n+     * <code>xml-name-pattern := xml-atomic-name-pattern [| xml-atomic-name-pattern]*</code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLNamePattern() {\n+        List<STNode> xmlAtomicNamePatternList = new ArrayList<>();\n+        STToken nextToken = peek();\n+\n+        // Return an empty list\n+        if (isEndOfXMLNamePattern(nextToken.kind)) {\n+            this.errorHandler.reportMissingTokenError(\"missing xml atomic name pattern\");\n+            return STNodeFactory.createNodeList(xmlAtomicNamePatternList);\n+        }\n+\n+        // Parse first xml atomic name pattern, that has no leading pipe token\n+        STNode xmlAtomicNamePattern = parseXMLAtomicNamePattern();\n+        xmlAtomicNamePatternList.add(xmlAtomicNamePattern);\n+\n+        // Parse the remaining xml atomic name patterns\n+        nextToken = peek();\n+        STNode leadingPipe;\n+        while (!isEndOfXMLNamePattern(nextToken.kind)) {\n+            leadingPipe = parsePipeToken();\n+            xmlAtomicNamePatternList.add(leadingPipe);\n+            xmlAtomicNamePattern = parseXMLAtomicNamePattern();\n+            xmlAtomicNamePatternList.add(xmlAtomicNamePattern);\n+            nextToken = peek();\n+        }\n+\n+        return STNodeFactory.createNodeList(xmlAtomicNamePatternList);\n+    }\n+\n+    private boolean isEndOfXMLNamePattern(SyntaxKind tokenKind) {\n+        switch (tokenKind) {\n+            case IDENTIFIER_TOKEN:\n+            case ASTERISK_TOKEN:\n+            case COLON_TOKEN:\n+                return false;\n+            case GT_TOKEN:\n+            case EOF_TOKEN:\n+            case AT_TOKEN:\n+            case DOCUMENTATION_LINE:\n+            case CLOSE_BRACE_TOKEN:\n+            case SEMICOLON_TOKEN:\n+            case PUBLIC_KEYWORD:\n+            case PRIVATE_KEYWORD:\n+            case FUNCTION_KEYWORD:\n+            case RETURNS_KEYWORD:\n+            case SERVICE_KEYWORD:\n+            case TYPE_KEYWORD:\n+            case LISTENER_KEYWORD:\n+            case CONST_KEYWORD:\n+            case FINAL_KEYWORD:\n+            case RESOURCE_KEYWORD:\n+                return true;\n+            default:\n+                return isSimpleType(tokenKind);\n+        }\n+    }\n+\n+    /**\n+     * Parse xml atomic name pattern.\n+     * <p>\n+     * <code>\n+     * xml-atomic-name-pattern :=\n+     *   *\n+     *   | identifier\n+     *   | xml-namespace-prefix : identifier\n+     *   | xml-namespace-prefix : *\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLAtomicNamePattern() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.ASTERISK_TOKEN) {\n+            return consume();\n+        } else if (token.kind == SyntaxKind.IDENTIFIER_TOKEN) {\n+            STNode identifier = consume();\n+            return parseXMLAtomicNameIdentifier(identifier);\n+        }\n+        return STNodeFactory.createEmptyNode();\n+    }\n+\n+    private STNode parseXMLAtomicNameIdentifier(STNode identifier) {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.COLON_TOKEN) {\n+            STNode colon = consume();\n+            STToken nextToken = peek();\n+            if (nextToken.kind == SyntaxKind.IDENTIFIER_TOKEN || nextToken.kind == SyntaxKind.ASTERISK_TOKEN) {\n+                STToken endToken = consume();\n+                return STNodeFactory.createXMLAtomicNamePatternNode(identifier, colon, endToken);\n+            }\n+        }\n+        return STNodeFactory.createSimpleNameReferenceNode(identifier);\n+    }\n+\n+    /**\n+     * Parse xml step expression.\n+     * <p>\n+     * <code>xml-step-expr := expression xml-step-start xml-step-extend*</code>\n+     *\n+     * @param lhsExpr Preceding expression of /*, /<, or /**\\/< token\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLStepExpression(STNode lhsExpr) {\n+        STNode xmlStepStart = parseXMLStepStart();\n+        STNode xmlStepExtendList = parseXMLStepExtendList();\n+        return STNodeFactory.createXMLStepExpressionNode(lhsExpr, xmlStepStart, xmlStepExtendList);\n+    }\n+\n+    /**\n+     * Parse xml filter expression rhs.\n+     * <p>\n+     * <code>\n+     *  xml-step-start :=\n+     *      xml-all-children-step\n+     *      | xml-element-children-step\n+     *      | xml-element-descendants-step\n+     * <br/>\n+     * xml-all-children-step := /*\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLStepStart() {\n+        STToken token = peek();\n+        STNode startToken;\n+\n+        switch (token.kind) {\n+            case SLASH_ASTERISK_TOKEN:\n+                return consume();\n+            case DOUBLE_SLASH_DOUBLE_ASTERISK_LT_TOKEN:\n+                startToken = parseDoubleSlashDoubleAsteriskLTToken();\n+                break;\n+            case SLASH_LT_TOKEN:\n+            default:\n+                startToken = parseSlashLTToken();\n+                break;\n+        }\n+        return parseXMLNamePatternChain(startToken);\n+    }\n+\n+    /**\n+     * Parse <code> /< </code> token.\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseSlashLTToken() {\n+        STToken nextToken = peek();\n+        if (nextToken.kind == SyntaxKind.SLASH_LT_TOKEN) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(nextToken, ParserRuleContext.SLASH_LT_TOKEN);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse <code> /< </code> token.\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseDoubleSlashDoubleAsteriskLTToken() {\n+        STToken nextToken = peek();\n+        if (nextToken.kind == SyntaxKind.DOUBLE_SLASH_DOUBLE_ASTERISK_LT_TOKEN) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(nextToken, ParserRuleContext.DOUBLE_SLASH_DOUBLE_ASTERISK_LT_TOKEN);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse xml step extend list.\n+     * <p>\n+     * <code>xml-step-extend-list := xml-step-extend*</code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLStepExtendList() {\n+        List<STNode> xmlStepExtendList = new ArrayList<>();\n+        STToken nextToken = peek();\n+\n+        // Return an empty list\n+        if (isEndOfXMLStepExtend(nextToken.kind)) {\n+            return STNodeFactory.createNodeList(xmlStepExtendList);\n+        }\n+\n+        nextToken = peek();\n+        STNode xmlStepExtend;\n+        while (!isEndOfXMLNamePattern(nextToken.kind)) {\n+            xmlStepExtend = parseXMLStepExtend();\n+            xmlStepExtendList.add(xmlStepExtend);\n+            nextToken = peek();\n+        }\n+\n+        return STNodeFactory.createNodeList(xmlStepExtendList);\n+    }\n+\n+    private boolean isEndOfXMLStepExtend(SyntaxKind tokenKind) {\n+        switch (tokenKind) {\n+            case DOT_LT_TOKEN:\n+            case OPEN_BRACKET_TOKEN:\n+            case DOT_TOKEN:\n+                return false;\n+            default:\n+                return true;\n+        }\n+    }\n+\n+    /**\n+     * Parse xml step extend list.\n+     * <p>\n+     * <code>\n+     * xml-step-extend :=\n+     *    .< xml-name-pattern >\n+     *    | [ expression ]\n+     *    | . method-name ( arg-list )\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLStepExtend() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case DOT_LT_TOKEN:\n+                return parseXMLFilterExpressionRhs();\n+            case DOT_TOKEN:\n+                return parseMethodCallChain();\n+            // token kind is already validated in isEndOfXMLStepExtend and reach here.\n+            // therefore, a recover solution is not required for the default case.\n+            case OPEN_BRACKET_TOKEN:\n+            default:\n+                return parseOpenBracketExpressionChain();\n+\n+        }\n+    }\n+\n+    /**\n+     * Parse open bracket expression chain.\n+     * <p>\n+     * <code>open-bracket-expression-chain := `[` expression `]`</code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseOpenBracketExpressionChain() {\n+        STNode openBracketToken = parseOpenBracket();\n+        STNode expression = parseExpression();\n+        STNode closeBracketToken = parseCloseBracket();\n+        return STNodeFactory.createOpenBracketExpressionChainingNode(openBracketToken, expression, closeBracketToken);\n+    }\n+\n+    /**\n+     * Parse method call chain.\n+     * <p>\n+     * <code>method-call-chain := `.` method-name `(` arg-list `)`</code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseMethodCallChain() {\n+        STNode dotToken = parseDotToken();\n+        STNode methodName = parseIdentifier(ParserRuleContext.FIELD_OR_FUNC_NAME);\n+        STNode openParen = parseOpenParenthesis(ParserRuleContext.ARG_LIST_START);\n+        STNode args = parseArgsList();\n+        STNode closeParen = parseCloseParenthesis();\n+        return STNodeFactory.createMethodCallChainingNode(dotToken, methodName, openParen, args, closeParen);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2fafddc846bc83ee150b1b775050d159dab1b671"}, "originalPosition": 382}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MjgxMzk5OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwODo0MTo0NVrOGcT_3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQwNTo1Mzo1NFrOGc_e9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM0MDk1Ng==", "bodyText": "I think we don't need parseXMLStepExtendListmethod at all :)\nReason is .<, . and [ are already handled by parseExpressionRhs method. So xml-step-expression node always have only lhsExpr and xmlStepStart", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23581#discussion_r432340956", "createdAt": "2020-05-29T08:41:45Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -12025,4 +12043,307 @@ private STNode parseByteArrayContent(SyntaxKind kind) {\n \n         return content;\n     }\n+\n+    /**\n+     * Parse xml filter expression.\n+     * <p>\n+     * <code>xml-filter-expr := expression .< xml-name-pattern ></code>\n+     *\n+     * @param lhsExpr Preceding expression of .< token\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLFilterExpression(STNode lhsExpr) {\n+        STNode xmlNamePatternChain = parseXMLFilterExpressionRhs();\n+        return STNodeFactory.createXMLFilterExpressionNode(lhsExpr, xmlNamePatternChain);\n+    }\n+\n+    /**\n+     * Parse xml filter expression rhs.\n+     * <p>\n+     * <code>filer-expression-rhs := .< xml-name-pattern ></code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLFilterExpressionRhs() {\n+        STNode dotLTToken = parseDotLTToken();\n+        return parseXMLNamePatternChain(dotLTToken);\n+    }\n+\n+    /**\n+     * Parse xml name pattern chain.\n+     * <p>\n+     * <code>\n+     * xml-name-pattern-chain := filer-expression-rhs | xml-element-children-step | xml-element-descendants-step\n+     * <br/>\n+     * filer-expression-rhs := .< xml-name-pattern >\n+     * <br/>\n+     * xml-element-children-step := /< xml-name-pattern >\n+     * <br/>\n+     * xml-element-descendants-step := /**\\/<xml-name-pattern >\n+     * </code>\n+     *\n+     * @param startToken Preceding token of xml name pattern\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLNamePatternChain(STNode startToken) {\n+        STNode xmlNamePattern = parseXMLNamePattern();\n+        STNode gtToken = parseGTToken();\n+        return STNodeFactory.createXMLNamePatternChainingNode(startToken, xmlNamePattern, gtToken);\n+    }\n+\n+    /**\n+     * Parse <code> .< </code> token.\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseDotLTToken() {\n+        STToken nextToken = peek();\n+        if (nextToken.kind == SyntaxKind.DOT_LT_TOKEN) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(nextToken, ParserRuleContext.DOT_LT_TOKEN);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse xml name pattern.\n+     * <p>\n+     * <code>xml-name-pattern := xml-atomic-name-pattern [| xml-atomic-name-pattern]*</code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLNamePattern() {\n+        List<STNode> xmlAtomicNamePatternList = new ArrayList<>();\n+        STToken nextToken = peek();\n+\n+        // Return an empty list\n+        if (isEndOfXMLNamePattern(nextToken.kind)) {\n+            this.errorHandler.reportMissingTokenError(\"missing xml atomic name pattern\");\n+            return STNodeFactory.createNodeList(xmlAtomicNamePatternList);\n+        }\n+\n+        // Parse first xml atomic name pattern, that has no leading pipe token\n+        STNode xmlAtomicNamePattern = parseXMLAtomicNamePattern();\n+        xmlAtomicNamePatternList.add(xmlAtomicNamePattern);\n+\n+        // Parse the remaining xml atomic name patterns\n+        nextToken = peek();\n+        STNode leadingPipe;\n+        while (!isEndOfXMLNamePattern(nextToken.kind)) {\n+            leadingPipe = parsePipeToken();\n+            xmlAtomicNamePatternList.add(leadingPipe);\n+            xmlAtomicNamePattern = parseXMLAtomicNamePattern();\n+            xmlAtomicNamePatternList.add(xmlAtomicNamePattern);\n+            nextToken = peek();\n+        }\n+\n+        return STNodeFactory.createNodeList(xmlAtomicNamePatternList);\n+    }\n+\n+    private boolean isEndOfXMLNamePattern(SyntaxKind tokenKind) {\n+        switch (tokenKind) {\n+            case IDENTIFIER_TOKEN:\n+            case ASTERISK_TOKEN:\n+            case COLON_TOKEN:\n+                return false;\n+            case GT_TOKEN:\n+            case EOF_TOKEN:\n+            case AT_TOKEN:\n+            case DOCUMENTATION_LINE:\n+            case CLOSE_BRACE_TOKEN:\n+            case SEMICOLON_TOKEN:\n+            case PUBLIC_KEYWORD:\n+            case PRIVATE_KEYWORD:\n+            case FUNCTION_KEYWORD:\n+            case RETURNS_KEYWORD:\n+            case SERVICE_KEYWORD:\n+            case TYPE_KEYWORD:\n+            case LISTENER_KEYWORD:\n+            case CONST_KEYWORD:\n+            case FINAL_KEYWORD:\n+            case RESOURCE_KEYWORD:\n+                return true;\n+            default:\n+                return isSimpleType(tokenKind);\n+        }\n+    }\n+\n+    /**\n+     * Parse xml atomic name pattern.\n+     * <p>\n+     * <code>\n+     * xml-atomic-name-pattern :=\n+     *   *\n+     *   | identifier\n+     *   | xml-namespace-prefix : identifier\n+     *   | xml-namespace-prefix : *\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLAtomicNamePattern() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.ASTERISK_TOKEN) {\n+            return consume();\n+        } else if (token.kind == SyntaxKind.IDENTIFIER_TOKEN) {\n+            STNode identifier = consume();\n+            return parseXMLAtomicNameIdentifier(identifier);\n+        }\n+        return STNodeFactory.createEmptyNode();\n+    }\n+\n+    private STNode parseXMLAtomicNameIdentifier(STNode identifier) {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.COLON_TOKEN) {\n+            STNode colon = consume();\n+            STToken nextToken = peek();\n+            if (nextToken.kind == SyntaxKind.IDENTIFIER_TOKEN || nextToken.kind == SyntaxKind.ASTERISK_TOKEN) {\n+                STToken endToken = consume();\n+                return STNodeFactory.createXMLAtomicNamePatternNode(identifier, colon, endToken);\n+            }\n+        }\n+        return STNodeFactory.createSimpleNameReferenceNode(identifier);\n+    }\n+\n+    /**\n+     * Parse xml step expression.\n+     * <p>\n+     * <code>xml-step-expr := expression xml-step-start xml-step-extend*</code>\n+     *\n+     * @param lhsExpr Preceding expression of /*, /<, or /**\\/< token\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLStepExpression(STNode lhsExpr) {\n+        STNode xmlStepStart = parseXMLStepStart();\n+        STNode xmlStepExtendList = parseXMLStepExtendList();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b66404743dd61d9e3e1f2f255c210ab92a0376ff"}, "originalPosition": 232}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM0MTc4Mw==", "bodyText": "The problem here is, theres a grammar ambiguity.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23581#discussion_r432341783", "createdAt": "2020-05-29T08:43:19Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -12025,4 +12043,307 @@ private STNode parseByteArrayContent(SyntaxKind kind) {\n \n         return content;\n     }\n+\n+    /**\n+     * Parse xml filter expression.\n+     * <p>\n+     * <code>xml-filter-expr := expression .< xml-name-pattern ></code>\n+     *\n+     * @param lhsExpr Preceding expression of .< token\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLFilterExpression(STNode lhsExpr) {\n+        STNode xmlNamePatternChain = parseXMLFilterExpressionRhs();\n+        return STNodeFactory.createXMLFilterExpressionNode(lhsExpr, xmlNamePatternChain);\n+    }\n+\n+    /**\n+     * Parse xml filter expression rhs.\n+     * <p>\n+     * <code>filer-expression-rhs := .< xml-name-pattern ></code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLFilterExpressionRhs() {\n+        STNode dotLTToken = parseDotLTToken();\n+        return parseXMLNamePatternChain(dotLTToken);\n+    }\n+\n+    /**\n+     * Parse xml name pattern chain.\n+     * <p>\n+     * <code>\n+     * xml-name-pattern-chain := filer-expression-rhs | xml-element-children-step | xml-element-descendants-step\n+     * <br/>\n+     * filer-expression-rhs := .< xml-name-pattern >\n+     * <br/>\n+     * xml-element-children-step := /< xml-name-pattern >\n+     * <br/>\n+     * xml-element-descendants-step := /**\\/<xml-name-pattern >\n+     * </code>\n+     *\n+     * @param startToken Preceding token of xml name pattern\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLNamePatternChain(STNode startToken) {\n+        STNode xmlNamePattern = parseXMLNamePattern();\n+        STNode gtToken = parseGTToken();\n+        return STNodeFactory.createXMLNamePatternChainingNode(startToken, xmlNamePattern, gtToken);\n+    }\n+\n+    /**\n+     * Parse <code> .< </code> token.\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseDotLTToken() {\n+        STToken nextToken = peek();\n+        if (nextToken.kind == SyntaxKind.DOT_LT_TOKEN) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(nextToken, ParserRuleContext.DOT_LT_TOKEN);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse xml name pattern.\n+     * <p>\n+     * <code>xml-name-pattern := xml-atomic-name-pattern [| xml-atomic-name-pattern]*</code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLNamePattern() {\n+        List<STNode> xmlAtomicNamePatternList = new ArrayList<>();\n+        STToken nextToken = peek();\n+\n+        // Return an empty list\n+        if (isEndOfXMLNamePattern(nextToken.kind)) {\n+            this.errorHandler.reportMissingTokenError(\"missing xml atomic name pattern\");\n+            return STNodeFactory.createNodeList(xmlAtomicNamePatternList);\n+        }\n+\n+        // Parse first xml atomic name pattern, that has no leading pipe token\n+        STNode xmlAtomicNamePattern = parseXMLAtomicNamePattern();\n+        xmlAtomicNamePatternList.add(xmlAtomicNamePattern);\n+\n+        // Parse the remaining xml atomic name patterns\n+        nextToken = peek();\n+        STNode leadingPipe;\n+        while (!isEndOfXMLNamePattern(nextToken.kind)) {\n+            leadingPipe = parsePipeToken();\n+            xmlAtomicNamePatternList.add(leadingPipe);\n+            xmlAtomicNamePattern = parseXMLAtomicNamePattern();\n+            xmlAtomicNamePatternList.add(xmlAtomicNamePattern);\n+            nextToken = peek();\n+        }\n+\n+        return STNodeFactory.createNodeList(xmlAtomicNamePatternList);\n+    }\n+\n+    private boolean isEndOfXMLNamePattern(SyntaxKind tokenKind) {\n+        switch (tokenKind) {\n+            case IDENTIFIER_TOKEN:\n+            case ASTERISK_TOKEN:\n+            case COLON_TOKEN:\n+                return false;\n+            case GT_TOKEN:\n+            case EOF_TOKEN:\n+            case AT_TOKEN:\n+            case DOCUMENTATION_LINE:\n+            case CLOSE_BRACE_TOKEN:\n+            case SEMICOLON_TOKEN:\n+            case PUBLIC_KEYWORD:\n+            case PRIVATE_KEYWORD:\n+            case FUNCTION_KEYWORD:\n+            case RETURNS_KEYWORD:\n+            case SERVICE_KEYWORD:\n+            case TYPE_KEYWORD:\n+            case LISTENER_KEYWORD:\n+            case CONST_KEYWORD:\n+            case FINAL_KEYWORD:\n+            case RESOURCE_KEYWORD:\n+                return true;\n+            default:\n+                return isSimpleType(tokenKind);\n+        }\n+    }\n+\n+    /**\n+     * Parse xml atomic name pattern.\n+     * <p>\n+     * <code>\n+     * xml-atomic-name-pattern :=\n+     *   *\n+     *   | identifier\n+     *   | xml-namespace-prefix : identifier\n+     *   | xml-namespace-prefix : *\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLAtomicNamePattern() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.ASTERISK_TOKEN) {\n+            return consume();\n+        } else if (token.kind == SyntaxKind.IDENTIFIER_TOKEN) {\n+            STNode identifier = consume();\n+            return parseXMLAtomicNameIdentifier(identifier);\n+        }\n+        return STNodeFactory.createEmptyNode();\n+    }\n+\n+    private STNode parseXMLAtomicNameIdentifier(STNode identifier) {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.COLON_TOKEN) {\n+            STNode colon = consume();\n+            STToken nextToken = peek();\n+            if (nextToken.kind == SyntaxKind.IDENTIFIER_TOKEN || nextToken.kind == SyntaxKind.ASTERISK_TOKEN) {\n+                STToken endToken = consume();\n+                return STNodeFactory.createXMLAtomicNamePatternNode(identifier, colon, endToken);\n+            }\n+        }\n+        return STNodeFactory.createSimpleNameReferenceNode(identifier);\n+    }\n+\n+    /**\n+     * Parse xml step expression.\n+     * <p>\n+     * <code>xml-step-expr := expression xml-step-start xml-step-extend*</code>\n+     *\n+     * @param lhsExpr Preceding expression of /*, /<, or /**\\/< token\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLStepExpression(STNode lhsExpr) {\n+        STNode xmlStepStart = parseXMLStepStart();\n+        STNode xmlStepExtendList = parseXMLStepExtendList();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM0MDk1Ng=="}, "originalCommit": {"oid": "b66404743dd61d9e3e1f2f255c210ab92a0376ff"}, "originalPosition": 232}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzA1MTI5OQ==", "bodyText": "Then the syntax tree for  a /* .<*> [e] .b() xml-step-expr would look like;\n{\n  \"kind\": \"METHOD_CALL\",\n  \"children\": [\n    {\n      \"kind\": \"INDEXED_EXPRESSION\",\n      \"children\": [\n        {\n          \"kind\": \"XML_FILTER_EXPRESSION\",\n          \"children\": [\n            {\n              \"kind\": \"XML_STEP_EXPRESSION\",\n              \"children\": [\n                {\n                  \"kind\": \"IDENTIFIER_TOKEN\",\n                  \"value\": \"a\"\n                },\n                {\n                  \"kind\": \"SLASH_ASTERISK_TOKEN\"\n                }\n              ]\n            },\n            {\n              \"kind\": \"XML_NAME_PATTERN_CHAIN\",\n              \"children\": [\n                {\n                  \"kind\": \"DOT_LT_TOKEN\"\n                },\n                {\n                  \"kind\": \"LIST\",\n                  \"children\": [\n                    {\n                      \"kind\": \"ASTERISK_TOKEN\"\n                    }\n                  ]\n                },\n                {\n                  \"kind\": \"GT_TOKEN\"\n                }\n              ]\n            }\n          ]\n        },\n        {\n          \"kind\": \"OPEN_BRACKET_TOKEN\"\n        },\n        {\n          \"kind\": \"LIST\",\n          \"children\": [\n            {\n              \"kind\": \"IDENTIFIER_TOKEN\",\n              \"value\": \"e\"\n            }\n          ]\n        },\n        {\n          \"kind\": \"CLOSE_BRACKET_TOKEN\"\n        }\n      ]\n    },\n    {\n      \"kind\": \"DOT_TOKEN\"\n    },\n    {\n      \"kind\": \"IDENTIFIER_TOKEN\",\n      \"value\": \"b\"\n    },\n    {\n      \"kind\": \"OPEN_PAREN_TOKEN\"\n    },\n    {\n      \"kind\": \"LIST\",\n      \"children\": []\n    },\n    {\n      \"kind\": \"CLOSE_PAREN_TOKEN\"\n    }\n  ]\n}\n\nIs it alright? I'm not quite sure.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23581#discussion_r433051299", "createdAt": "2020-06-01T05:44:52Z", "author": {"login": "lochana-chathura"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -12025,4 +12043,307 @@ private STNode parseByteArrayContent(SyntaxKind kind) {\n \n         return content;\n     }\n+\n+    /**\n+     * Parse xml filter expression.\n+     * <p>\n+     * <code>xml-filter-expr := expression .< xml-name-pattern ></code>\n+     *\n+     * @param lhsExpr Preceding expression of .< token\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLFilterExpression(STNode lhsExpr) {\n+        STNode xmlNamePatternChain = parseXMLFilterExpressionRhs();\n+        return STNodeFactory.createXMLFilterExpressionNode(lhsExpr, xmlNamePatternChain);\n+    }\n+\n+    /**\n+     * Parse xml filter expression rhs.\n+     * <p>\n+     * <code>filer-expression-rhs := .< xml-name-pattern ></code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLFilterExpressionRhs() {\n+        STNode dotLTToken = parseDotLTToken();\n+        return parseXMLNamePatternChain(dotLTToken);\n+    }\n+\n+    /**\n+     * Parse xml name pattern chain.\n+     * <p>\n+     * <code>\n+     * xml-name-pattern-chain := filer-expression-rhs | xml-element-children-step | xml-element-descendants-step\n+     * <br/>\n+     * filer-expression-rhs := .< xml-name-pattern >\n+     * <br/>\n+     * xml-element-children-step := /< xml-name-pattern >\n+     * <br/>\n+     * xml-element-descendants-step := /**\\/<xml-name-pattern >\n+     * </code>\n+     *\n+     * @param startToken Preceding token of xml name pattern\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLNamePatternChain(STNode startToken) {\n+        STNode xmlNamePattern = parseXMLNamePattern();\n+        STNode gtToken = parseGTToken();\n+        return STNodeFactory.createXMLNamePatternChainingNode(startToken, xmlNamePattern, gtToken);\n+    }\n+\n+    /**\n+     * Parse <code> .< </code> token.\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseDotLTToken() {\n+        STToken nextToken = peek();\n+        if (nextToken.kind == SyntaxKind.DOT_LT_TOKEN) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(nextToken, ParserRuleContext.DOT_LT_TOKEN);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse xml name pattern.\n+     * <p>\n+     * <code>xml-name-pattern := xml-atomic-name-pattern [| xml-atomic-name-pattern]*</code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLNamePattern() {\n+        List<STNode> xmlAtomicNamePatternList = new ArrayList<>();\n+        STToken nextToken = peek();\n+\n+        // Return an empty list\n+        if (isEndOfXMLNamePattern(nextToken.kind)) {\n+            this.errorHandler.reportMissingTokenError(\"missing xml atomic name pattern\");\n+            return STNodeFactory.createNodeList(xmlAtomicNamePatternList);\n+        }\n+\n+        // Parse first xml atomic name pattern, that has no leading pipe token\n+        STNode xmlAtomicNamePattern = parseXMLAtomicNamePattern();\n+        xmlAtomicNamePatternList.add(xmlAtomicNamePattern);\n+\n+        // Parse the remaining xml atomic name patterns\n+        nextToken = peek();\n+        STNode leadingPipe;\n+        while (!isEndOfXMLNamePattern(nextToken.kind)) {\n+            leadingPipe = parsePipeToken();\n+            xmlAtomicNamePatternList.add(leadingPipe);\n+            xmlAtomicNamePattern = parseXMLAtomicNamePattern();\n+            xmlAtomicNamePatternList.add(xmlAtomicNamePattern);\n+            nextToken = peek();\n+        }\n+\n+        return STNodeFactory.createNodeList(xmlAtomicNamePatternList);\n+    }\n+\n+    private boolean isEndOfXMLNamePattern(SyntaxKind tokenKind) {\n+        switch (tokenKind) {\n+            case IDENTIFIER_TOKEN:\n+            case ASTERISK_TOKEN:\n+            case COLON_TOKEN:\n+                return false;\n+            case GT_TOKEN:\n+            case EOF_TOKEN:\n+            case AT_TOKEN:\n+            case DOCUMENTATION_LINE:\n+            case CLOSE_BRACE_TOKEN:\n+            case SEMICOLON_TOKEN:\n+            case PUBLIC_KEYWORD:\n+            case PRIVATE_KEYWORD:\n+            case FUNCTION_KEYWORD:\n+            case RETURNS_KEYWORD:\n+            case SERVICE_KEYWORD:\n+            case TYPE_KEYWORD:\n+            case LISTENER_KEYWORD:\n+            case CONST_KEYWORD:\n+            case FINAL_KEYWORD:\n+            case RESOURCE_KEYWORD:\n+                return true;\n+            default:\n+                return isSimpleType(tokenKind);\n+        }\n+    }\n+\n+    /**\n+     * Parse xml atomic name pattern.\n+     * <p>\n+     * <code>\n+     * xml-atomic-name-pattern :=\n+     *   *\n+     *   | identifier\n+     *   | xml-namespace-prefix : identifier\n+     *   | xml-namespace-prefix : *\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLAtomicNamePattern() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.ASTERISK_TOKEN) {\n+            return consume();\n+        } else if (token.kind == SyntaxKind.IDENTIFIER_TOKEN) {\n+            STNode identifier = consume();\n+            return parseXMLAtomicNameIdentifier(identifier);\n+        }\n+        return STNodeFactory.createEmptyNode();\n+    }\n+\n+    private STNode parseXMLAtomicNameIdentifier(STNode identifier) {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.COLON_TOKEN) {\n+            STNode colon = consume();\n+            STToken nextToken = peek();\n+            if (nextToken.kind == SyntaxKind.IDENTIFIER_TOKEN || nextToken.kind == SyntaxKind.ASTERISK_TOKEN) {\n+                STToken endToken = consume();\n+                return STNodeFactory.createXMLAtomicNamePatternNode(identifier, colon, endToken);\n+            }\n+        }\n+        return STNodeFactory.createSimpleNameReferenceNode(identifier);\n+    }\n+\n+    /**\n+     * Parse xml step expression.\n+     * <p>\n+     * <code>xml-step-expr := expression xml-step-start xml-step-extend*</code>\n+     *\n+     * @param lhsExpr Preceding expression of /*, /<, or /**\\/< token\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLStepExpression(STNode lhsExpr) {\n+        STNode xmlStepStart = parseXMLStepStart();\n+        STNode xmlStepExtendList = parseXMLStepExtendList();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM0MDk1Ng=="}, "originalCommit": {"oid": "b66404743dd61d9e3e1f2f255c210ab92a0376ff"}, "originalPosition": 232}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzA1MzQyOA==", "bodyText": "@SupunS plz review the last commit 9c01f06 for the above change.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23581#discussion_r433053428", "createdAt": "2020-06-01T05:53:54Z", "author": {"login": "lochana-chathura"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -12025,4 +12043,307 @@ private STNode parseByteArrayContent(SyntaxKind kind) {\n \n         return content;\n     }\n+\n+    /**\n+     * Parse xml filter expression.\n+     * <p>\n+     * <code>xml-filter-expr := expression .< xml-name-pattern ></code>\n+     *\n+     * @param lhsExpr Preceding expression of .< token\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLFilterExpression(STNode lhsExpr) {\n+        STNode xmlNamePatternChain = parseXMLFilterExpressionRhs();\n+        return STNodeFactory.createXMLFilterExpressionNode(lhsExpr, xmlNamePatternChain);\n+    }\n+\n+    /**\n+     * Parse xml filter expression rhs.\n+     * <p>\n+     * <code>filer-expression-rhs := .< xml-name-pattern ></code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLFilterExpressionRhs() {\n+        STNode dotLTToken = parseDotLTToken();\n+        return parseXMLNamePatternChain(dotLTToken);\n+    }\n+\n+    /**\n+     * Parse xml name pattern chain.\n+     * <p>\n+     * <code>\n+     * xml-name-pattern-chain := filer-expression-rhs | xml-element-children-step | xml-element-descendants-step\n+     * <br/>\n+     * filer-expression-rhs := .< xml-name-pattern >\n+     * <br/>\n+     * xml-element-children-step := /< xml-name-pattern >\n+     * <br/>\n+     * xml-element-descendants-step := /**\\/<xml-name-pattern >\n+     * </code>\n+     *\n+     * @param startToken Preceding token of xml name pattern\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLNamePatternChain(STNode startToken) {\n+        STNode xmlNamePattern = parseXMLNamePattern();\n+        STNode gtToken = parseGTToken();\n+        return STNodeFactory.createXMLNamePatternChainingNode(startToken, xmlNamePattern, gtToken);\n+    }\n+\n+    /**\n+     * Parse <code> .< </code> token.\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseDotLTToken() {\n+        STToken nextToken = peek();\n+        if (nextToken.kind == SyntaxKind.DOT_LT_TOKEN) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(nextToken, ParserRuleContext.DOT_LT_TOKEN);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse xml name pattern.\n+     * <p>\n+     * <code>xml-name-pattern := xml-atomic-name-pattern [| xml-atomic-name-pattern]*</code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLNamePattern() {\n+        List<STNode> xmlAtomicNamePatternList = new ArrayList<>();\n+        STToken nextToken = peek();\n+\n+        // Return an empty list\n+        if (isEndOfXMLNamePattern(nextToken.kind)) {\n+            this.errorHandler.reportMissingTokenError(\"missing xml atomic name pattern\");\n+            return STNodeFactory.createNodeList(xmlAtomicNamePatternList);\n+        }\n+\n+        // Parse first xml atomic name pattern, that has no leading pipe token\n+        STNode xmlAtomicNamePattern = parseXMLAtomicNamePattern();\n+        xmlAtomicNamePatternList.add(xmlAtomicNamePattern);\n+\n+        // Parse the remaining xml atomic name patterns\n+        nextToken = peek();\n+        STNode leadingPipe;\n+        while (!isEndOfXMLNamePattern(nextToken.kind)) {\n+            leadingPipe = parsePipeToken();\n+            xmlAtomicNamePatternList.add(leadingPipe);\n+            xmlAtomicNamePattern = parseXMLAtomicNamePattern();\n+            xmlAtomicNamePatternList.add(xmlAtomicNamePattern);\n+            nextToken = peek();\n+        }\n+\n+        return STNodeFactory.createNodeList(xmlAtomicNamePatternList);\n+    }\n+\n+    private boolean isEndOfXMLNamePattern(SyntaxKind tokenKind) {\n+        switch (tokenKind) {\n+            case IDENTIFIER_TOKEN:\n+            case ASTERISK_TOKEN:\n+            case COLON_TOKEN:\n+                return false;\n+            case GT_TOKEN:\n+            case EOF_TOKEN:\n+            case AT_TOKEN:\n+            case DOCUMENTATION_LINE:\n+            case CLOSE_BRACE_TOKEN:\n+            case SEMICOLON_TOKEN:\n+            case PUBLIC_KEYWORD:\n+            case PRIVATE_KEYWORD:\n+            case FUNCTION_KEYWORD:\n+            case RETURNS_KEYWORD:\n+            case SERVICE_KEYWORD:\n+            case TYPE_KEYWORD:\n+            case LISTENER_KEYWORD:\n+            case CONST_KEYWORD:\n+            case FINAL_KEYWORD:\n+            case RESOURCE_KEYWORD:\n+                return true;\n+            default:\n+                return isSimpleType(tokenKind);\n+        }\n+    }\n+\n+    /**\n+     * Parse xml atomic name pattern.\n+     * <p>\n+     * <code>\n+     * xml-atomic-name-pattern :=\n+     *   *\n+     *   | identifier\n+     *   | xml-namespace-prefix : identifier\n+     *   | xml-namespace-prefix : *\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLAtomicNamePattern() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.ASTERISK_TOKEN) {\n+            return consume();\n+        } else if (token.kind == SyntaxKind.IDENTIFIER_TOKEN) {\n+            STNode identifier = consume();\n+            return parseXMLAtomicNameIdentifier(identifier);\n+        }\n+        return STNodeFactory.createEmptyNode();\n+    }\n+\n+    private STNode parseXMLAtomicNameIdentifier(STNode identifier) {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.COLON_TOKEN) {\n+            STNode colon = consume();\n+            STToken nextToken = peek();\n+            if (nextToken.kind == SyntaxKind.IDENTIFIER_TOKEN || nextToken.kind == SyntaxKind.ASTERISK_TOKEN) {\n+                STToken endToken = consume();\n+                return STNodeFactory.createXMLAtomicNamePatternNode(identifier, colon, endToken);\n+            }\n+        }\n+        return STNodeFactory.createSimpleNameReferenceNode(identifier);\n+    }\n+\n+    /**\n+     * Parse xml step expression.\n+     * <p>\n+     * <code>xml-step-expr := expression xml-step-start xml-step-extend*</code>\n+     *\n+     * @param lhsExpr Preceding expression of /*, /<, or /**\\/< token\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLStepExpression(STNode lhsExpr) {\n+        STNode xmlStepStart = parseXMLStepStart();\n+        STNode xmlStepExtendList = parseXMLStepExtendList();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM0MDk1Ng=="}, "originalCommit": {"oid": "b66404743dd61d9e3e1f2f255c210ab92a0376ff"}, "originalPosition": 232}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NzUyMTc5OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQwNjoxMjozOFrOGc_zCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQwNjoyMDowN1rOGc_7DA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzA1ODU3MA==", "bodyText": "Can lhsExpr be null?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23581#discussion_r433058570", "createdAt": "2020-06-01T06:12:38Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -4516,7 +4522,7 @@ private STNode parseExpressionRhs(SyntaxKind tokenKind, OperatorPrecedence curre\n             return lhsExpr;\n         }\n \n-        if (lhsExpr.kind == SyntaxKind.ASYNC_SEND_ACTION) {\n+        if (lhsExpr != null && lhsExpr.kind == SyntaxKind.ASYNC_SEND_ACTION) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c01f069e108ef6ae158daaed3cbfb385371606b"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzA2MDYyMA==", "bodyText": "That is from the previous commit. Now we don't need that. I'll correct.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23581#discussion_r433060620", "createdAt": "2020-06-01T06:20:07Z", "author": {"login": "lochana-chathura"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -4516,7 +4522,7 @@ private STNode parseExpressionRhs(SyntaxKind tokenKind, OperatorPrecedence curre\n             return lhsExpr;\n         }\n \n-        if (lhsExpr.kind == SyntaxKind.ASYNC_SEND_ACTION) {\n+        if (lhsExpr != null && lhsExpr.kind == SyntaxKind.ASYNC_SEND_ACTION) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzA1ODU3MA=="}, "originalCommit": {"oid": "9c01f069e108ef6ae158daaed3cbfb385371606b"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwMjQ4OTI2OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMjo1MDozM1rOGdwE3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMjo1MDozM1rOGdwE3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg0OTU2NQ==", "bodyText": "Better to move starting and ending contexts inside the parseXMLAtomicNamePattern", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23581#discussion_r433849565", "createdAt": "2020-06-02T12:50:33Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -11100,6 +11124,266 @@ private STNode parseByteArrayContent(SyntaxKind kind) {\n         return content;\n     }\n \n+    /**\n+     * Parse xml filter expression.\n+     * <p>\n+     * <code>xml-filter-expr := expression .< xml-name-pattern ></code>\n+     *\n+     * @param lhsExpr Preceding expression of .< token\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLFilterExpression(STNode lhsExpr) {\n+        STNode xmlNamePatternChain = parseXMLFilterExpressionRhs();\n+        return STNodeFactory.createXMLFilterExpressionNode(lhsExpr, xmlNamePatternChain);\n+    }\n+\n+    /**\n+     * Parse xml filter expression rhs.\n+     * <p>\n+     * <code>filer-expression-rhs := .< xml-name-pattern ></code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLFilterExpressionRhs() {\n+        STNode dotLTToken = parseDotLTToken();\n+        return parseXMLNamePatternChain(dotLTToken);\n+    }\n+\n+    /**\n+     * Parse xml name pattern chain.\n+     * <p>\n+     * <code>\n+     * xml-name-pattern-chain := filer-expression-rhs | xml-element-children-step | xml-element-descendants-step\n+     * <br/>\n+     * filer-expression-rhs := .< xml-name-pattern >\n+     * <br/>\n+     * xml-element-children-step := /< xml-name-pattern >\n+     * <br/>\n+     * xml-element-descendants-step := /**\\/<xml-name-pattern >\n+     * </code>\n+     *\n+     * @param startToken Preceding token of xml name pattern\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLNamePatternChain(STNode startToken) {\n+        startContext(ParserRuleContext.XML_NAME_PATTERN);\n+        STNode xmlNamePattern = parseXMLNamePattern();\n+        STNode gtToken = parseGTToken();\n+        endContext();\n+        return STNodeFactory.createXMLNamePatternChainingNode(startToken, xmlNamePattern, gtToken);\n+    }\n+\n+    /**\n+     * Parse <code> .< </code> token.\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseDotLTToken() {\n+        STToken nextToken = peek();\n+        if (nextToken.kind == SyntaxKind.DOT_LT_TOKEN) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(nextToken, ParserRuleContext.DOT_LT_TOKEN);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse xml name pattern.\n+     * <p>\n+     * <code>xml-name-pattern := xml-atomic-name-pattern [| xml-atomic-name-pattern]*</code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLNamePattern() {\n+        List<STNode> xmlAtomicNamePatternList = new ArrayList<>();\n+        STToken nextToken = peek();\n+\n+        // Return an empty list\n+        if (isEndOfXMLNamePattern(nextToken.kind)) {\n+            this.errorHandler.reportMissingTokenError(\"missing xml atomic name pattern\");\n+            return STNodeFactory.createNodeList(xmlAtomicNamePatternList);\n+        }\n+\n+        // Parse first xml atomic name pattern, that has no leading pipe token\n+        startContext(ParserRuleContext.XML_ATOMIC_NAME_PATTERN);\n+        STNode xmlAtomicNamePattern = parseXMLAtomicNamePattern();\n+        endContext();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7777e528ff4a4e146a5a2c7e808fc68bc9971c9"}, "originalPosition": 149}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwMjUwMjY3OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMjo1NDoxNVrOGdwNtg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMjo1NDoxNVrOGdwNtg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg1MTgzMA==", "bodyText": "Since the nextToken is used only at this place, can simply use peek() here itself. No need of a local variable..", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23581#discussion_r433851830", "createdAt": "2020-06-02T12:54:15Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -11100,6 +11124,266 @@ private STNode parseByteArrayContent(SyntaxKind kind) {\n         return content;\n     }\n \n+    /**\n+     * Parse xml filter expression.\n+     * <p>\n+     * <code>xml-filter-expr := expression .< xml-name-pattern ></code>\n+     *\n+     * @param lhsExpr Preceding expression of .< token\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLFilterExpression(STNode lhsExpr) {\n+        STNode xmlNamePatternChain = parseXMLFilterExpressionRhs();\n+        return STNodeFactory.createXMLFilterExpressionNode(lhsExpr, xmlNamePatternChain);\n+    }\n+\n+    /**\n+     * Parse xml filter expression rhs.\n+     * <p>\n+     * <code>filer-expression-rhs := .< xml-name-pattern ></code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLFilterExpressionRhs() {\n+        STNode dotLTToken = parseDotLTToken();\n+        return parseXMLNamePatternChain(dotLTToken);\n+    }\n+\n+    /**\n+     * Parse xml name pattern chain.\n+     * <p>\n+     * <code>\n+     * xml-name-pattern-chain := filer-expression-rhs | xml-element-children-step | xml-element-descendants-step\n+     * <br/>\n+     * filer-expression-rhs := .< xml-name-pattern >\n+     * <br/>\n+     * xml-element-children-step := /< xml-name-pattern >\n+     * <br/>\n+     * xml-element-descendants-step := /**\\/<xml-name-pattern >\n+     * </code>\n+     *\n+     * @param startToken Preceding token of xml name pattern\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLNamePatternChain(STNode startToken) {\n+        startContext(ParserRuleContext.XML_NAME_PATTERN);\n+        STNode xmlNamePattern = parseXMLNamePattern();\n+        STNode gtToken = parseGTToken();\n+        endContext();\n+        return STNodeFactory.createXMLNamePatternChainingNode(startToken, xmlNamePattern, gtToken);\n+    }\n+\n+    /**\n+     * Parse <code> .< </code> token.\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseDotLTToken() {\n+        STToken nextToken = peek();\n+        if (nextToken.kind == SyntaxKind.DOT_LT_TOKEN) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(nextToken, ParserRuleContext.DOT_LT_TOKEN);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse xml name pattern.\n+     * <p>\n+     * <code>xml-name-pattern := xml-atomic-name-pattern [| xml-atomic-name-pattern]*</code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLNamePattern() {\n+        List<STNode> xmlAtomicNamePatternList = new ArrayList<>();\n+        STToken nextToken = peek();\n+\n+        // Return an empty list\n+        if (isEndOfXMLNamePattern(nextToken.kind)) {\n+            this.errorHandler.reportMissingTokenError(\"missing xml atomic name pattern\");\n+            return STNodeFactory.createNodeList(xmlAtomicNamePatternList);\n+        }\n+\n+        // Parse first xml atomic name pattern, that has no leading pipe token\n+        startContext(ParserRuleContext.XML_ATOMIC_NAME_PATTERN);\n+        STNode xmlAtomicNamePattern = parseXMLAtomicNamePattern();\n+        endContext();\n+        xmlAtomicNamePatternList.add(xmlAtomicNamePattern);\n+\n+        // Parse the remaining xml atomic name patterns\n+        nextToken = peek();\n+        STNode leadingPipe;\n+        while (!isEndOfXMLNamePattern(nextToken.kind)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7777e528ff4a4e146a5a2c7e808fc68bc9971c9"}, "originalPosition": 155}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwMjUxODU2OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMjo1ODoyM1rOGdwXrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMjo1ODoyM1rOGdwXrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg1NDM4MQ==", "bodyText": "since getParentContext() is called more than once, better to move it to a local variable.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23581#discussion_r433854381", "createdAt": "2020-06-02T12:58:23Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -2246,6 +2324,8 @@ private ParserRuleContext getNextRuleInternal(ParserRuleContext currentCtx, int\n             case PIPE:\n                 if (getParentContext() == ParserRuleContext.ALTERNATE_WAIT_EXPRS) {\n                     return ParserRuleContext.EXPRESSION;\n+                } else if (getParentContext() == ParserRuleContext.XML_NAME_PATTERN) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7777e528ff4a4e146a5a2c7e808fc68bc9971c9"}, "originalPosition": 248}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwMjUyODEyOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-treegen/src/main/resources/syntax_tree_descriptor.json", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMzowMDo0MlrOGdwdXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMzowMDo0MlrOGdwdXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg1NTgzOQ==", "bodyText": "how about simply prefix?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23581#discussion_r433855839", "createdAt": "2020-06-02T13:00:42Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-treegen/src/main/resources/syntax_tree_descriptor.json", "diffHunk": "@@ -3450,6 +3450,80 @@\n                     \"type\": \"Token\"\n                 }\n             ]\n+        },\n+        {\n+            \"name\": \"XMLNavigateExpressionNode\",\n+            \"base\": \"ExpressionNode\",\n+            \"isAbstract\": true\n+        },\n+        {\n+            \"name\": \"XMLFilterExpressionNode\",\n+            \"base\": \"XMLNavigateExpressionNode\",\n+            \"kind\": \"XML_FILTER_EXPRESSION\",\n+            \"attributes\": [\n+                {\n+                    \"name\": \"expression\",\n+                    \"type\": \"ExpressionNode\"\n+                },\n+                {\n+                    \"name\": \"xmlPatternChain\",\n+                    \"type\": \"XMLNamePatternChainingNode\"\n+                }\n+            ]\n+        },\n+        {\n+            \"name\": \"XMLStepExpressionNode\",\n+            \"base\": \"XMLNavigateExpressionNode\",\n+            \"kind\": \"XML_STEP_EXPRESSION\",\n+            \"attributes\": [\n+                {\n+                    \"name\": \"expression\",\n+                    \"type\": \"ExpressionNode\"\n+                },\n+                {\n+                    \"name\": \"xmlStepStart\",\n+                    \"type\": \"Node\"\n+                }\n+            ]\n+        },\n+        {\n+            \"name\": \"XMLNamePatternChainingNode\",\n+            \"base\": \"Node\",\n+            \"kind\": \"XML_NAME_PATTERN_CHAIN\",\n+            \"attributes\": [\n+                {\n+                    \"name\": \"startToken\",\n+                    \"type\": \"Token\"\n+                },\n+                {\n+                    \"name\": \"xmlNamePattern\",\n+                    \"type\": \"Node\",\n+                    \"occurrences\": \"MULTIPLE_SEPARATED\"\n+                },\n+                {\n+                    \"name\": \"gtToken\",\n+                    \"type\": \"Token\"\n+                }\n+            ]\n+        },\n+        {\n+            \"name\": \"XMLAtomicNamePatternNode\",\n+            \"base\": \"Node\",\n+            \"kind\": \"XML_ATOMIC_NAME_PATTERN\",\n+            \"attributes\": [\n+                {\n+                    \"name\": \"xmlNamespacePrefix\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7777e528ff4a4e146a5a2c7e808fc68bc9971c9"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwMjUyOTE0OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-treegen/src/main/resources/syntax_tree_descriptor.json", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMzowMDo1NlrOGdwd-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMzowMDo1NlrOGdwd-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg1NTk5Mw==", "bodyText": "can we say name?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23581#discussion_r433855993", "createdAt": "2020-06-02T13:00:56Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-treegen/src/main/resources/syntax_tree_descriptor.json", "diffHunk": "@@ -3450,6 +3450,80 @@\n                     \"type\": \"Token\"\n                 }\n             ]\n+        },\n+        {\n+            \"name\": \"XMLNavigateExpressionNode\",\n+            \"base\": \"ExpressionNode\",\n+            \"isAbstract\": true\n+        },\n+        {\n+            \"name\": \"XMLFilterExpressionNode\",\n+            \"base\": \"XMLNavigateExpressionNode\",\n+            \"kind\": \"XML_FILTER_EXPRESSION\",\n+            \"attributes\": [\n+                {\n+                    \"name\": \"expression\",\n+                    \"type\": \"ExpressionNode\"\n+                },\n+                {\n+                    \"name\": \"xmlPatternChain\",\n+                    \"type\": \"XMLNamePatternChainingNode\"\n+                }\n+            ]\n+        },\n+        {\n+            \"name\": \"XMLStepExpressionNode\",\n+            \"base\": \"XMLNavigateExpressionNode\",\n+            \"kind\": \"XML_STEP_EXPRESSION\",\n+            \"attributes\": [\n+                {\n+                    \"name\": \"expression\",\n+                    \"type\": \"ExpressionNode\"\n+                },\n+                {\n+                    \"name\": \"xmlStepStart\",\n+                    \"type\": \"Node\"\n+                }\n+            ]\n+        },\n+        {\n+            \"name\": \"XMLNamePatternChainingNode\",\n+            \"base\": \"Node\",\n+            \"kind\": \"XML_NAME_PATTERN_CHAIN\",\n+            \"attributes\": [\n+                {\n+                    \"name\": \"startToken\",\n+                    \"type\": \"Token\"\n+                },\n+                {\n+                    \"name\": \"xmlNamePattern\",\n+                    \"type\": \"Node\",\n+                    \"occurrences\": \"MULTIPLE_SEPARATED\"\n+                },\n+                {\n+                    \"name\": \"gtToken\",\n+                    \"type\": \"Token\"\n+                }\n+            ]\n+        },\n+        {\n+            \"name\": \"XMLAtomicNamePatternNode\",\n+            \"base\": \"Node\",\n+            \"kind\": \"XML_ATOMIC_NAME_PATTERN\",\n+            \"attributes\": [\n+                {\n+                    \"name\": \"xmlNamespacePrefix\",\n+                    \"type\": \"Token\"\n+                },\n+                {\n+                    \"name\": \"colon\",\n+                    \"type\": \"Token\"\n+                },\n+                {\n+                    \"name\": \"endToken\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7777e528ff4a4e146a5a2c7e808fc68bc9971c9"}, "originalPosition": 74}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3518, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}