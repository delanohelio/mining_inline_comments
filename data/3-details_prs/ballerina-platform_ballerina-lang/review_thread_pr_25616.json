{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc5MzcwOTA4", "number": 25616, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODo1MjozNFrOEgTPeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwOToyMTozMVrOEgT3lA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMzA1MTQ1OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-compiler-api/src/main/java/org/ballerina/compiler/api/symbols/Qualifiers.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODo1MjozNFrOHNFaig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwOTowNjozM1rOHNF5Jg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ4MjI1MA==", "bodyText": "This should probably remain a singular name I think. Looks sorta weird when used in APIs otherwise. e.g., List<Qualifier> reads as a list of qualifiers whereas List<Qualifiers> sorta gives the impression that it's a list of list of qualifiers. We've used the singular form in enums in other places. e.g., Flag", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25616#discussion_r483482250", "createdAt": "2020-09-04T08:52:34Z", "author": {"login": "pubudu91"}, "path": "compiler/ballerina-compiler-api/src/main/java/org/ballerina/compiler/api/symbols/Qualifiers.java", "diffHunk": "@@ -22,15 +22,15 @@\n  * \n  * @since 2.0.0\n  */\n-public enum Qualifier {\n+public enum Qualifiers {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b44bc6e62f56a55f062d0fc36752a22f6d7f9e1b"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ5MDA4Ng==", "bodyText": "I see. Ack. Updated the PR.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25616#discussion_r483490086", "createdAt": "2020-09-04T09:06:33Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-compiler-api/src/main/java/org/ballerina/compiler/api/symbols/Qualifiers.java", "diffHunk": "@@ -22,15 +22,15 @@\n  * \n  * @since 2.0.0\n  */\n-public enum Qualifier {\n+public enum Qualifiers {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ4MjI1MA=="}, "originalCommit": {"oid": "b44bc6e62f56a55f062d0fc36752a22f6d7f9e1b"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMzE1NDEyOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-compiler-api/src/main/java/org/ballerina/compiler/impl/TypesFactory.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwOToyMTozMVrOHNGY2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxMDoxMDo1MlrOHNH7GQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ5ODIwMA==", "bodyText": "Shouldn't these two have corresponding typedescs?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25616#discussion_r483498200", "createdAt": "2020-09-04T09:21:31Z", "author": {"login": "pubudu91"}, "path": "compiler/ballerina-compiler-api/src/main/java/org/ballerina/compiler/impl/TypesFactory.java", "diffHunk": "@@ -63,68 +65,134 @@ public static BallerinaTypeDescriptor getTypeDescriptor(BType bType) {\n     /**\n      * Get the type descriptor for the given type.\n      *\n-     * @param bType BType tp get the type descriptor\n-     * @param rawTypeOnly Whether convert the type descriptor to type reference or keep the raw type\n+     * @param bType {@link BType} of the type descriptor\n+     * @param rawTypeOnly Whether to convert the type descriptor to type reference or keep the raw type\n      * @return {@link BallerinaTypeDescriptor} generated\n      */\n     public static BallerinaTypeDescriptor getTypeDescriptor(BType bType, boolean rawTypeOnly) {\n         BallerinaTypeDescriptor typeDescriptorImpl;\n         if (bType == null) {\n             return null;\n         }\n+\n         ModuleID moduleID = bType.tsymbol == null ? null : new BallerinaModuleID(bType.tsymbol.pkgID);\n+\n+        // TODO: Revisit this: Why need a type-reference type?\n+        if (isTypeReference(bType, rawTypeOnly)) {\n+            return new BallerinaTypeReferenceTypeDescriptor(moduleID, bType, bType.tsymbol.getName().getValue());\n+        }\n+\n         switch (bType.getKind()) {\n             case OBJECT:\n-                typeDescriptorImpl = new BallerinaObjectTypeDescriptor(moduleID, (BObjectType) bType);\n-                break;\n+                return new BallerinaObjectTypeDescriptor(moduleID, (BObjectType) bType);\n             case RECORD:\n-                typeDescriptorImpl = new BallerinaRecordTypeDescriptor(moduleID, (BRecordType) bType);\n-                break;\n+                return new BallerinaRecordTypeDescriptor(moduleID, (BRecordType) bType);\n             case ERROR:\n-                typeDescriptorImpl = new BallerinaErrorTypeDescriptor(moduleID, (BErrorType) bType);\n-                break;\n+                return new BallerinaErrorTypeDescriptor(moduleID, (BErrorType) bType);\n             case UNION:\n-                typeDescriptorImpl = new BallerinaUnionTypeDescriptor(moduleID, (BUnionType) bType);\n-                break;\n+                return new BallerinaUnionTypeDescriptor(moduleID, (BUnionType) bType);\n             case FUTURE:\n-                typeDescriptorImpl = new BallerinaFutureTypeDescriptor(moduleID, (BFutureType) bType);\n-                break;\n+                return new BallerinaFutureTypeDescriptor(moduleID, (BFutureType) bType);\n             case MAP:\n-                typeDescriptorImpl = new BallerinaMapTypeDescriptor(moduleID, (BMapType) bType);\n-                break;\n+                return new BallerinaMapTypeDescriptor(moduleID, (BMapType) bType);\n             case STREAM:\n-                typeDescriptorImpl = new BallerinaStreamTypeDescriptor(moduleID, (BStreamType) bType);\n-                break;\n+                return new BallerinaStreamTypeDescriptor(moduleID, (BStreamType) bType);\n             case ARRAY:\n-                typeDescriptorImpl = new BallerinaArrayTypeDescriptor(moduleID, (BArrayType) bType);\n-                break;\n+                return new BallerinaArrayTypeDescriptor(moduleID, (BArrayType) bType);\n             case TUPLE:\n-                typeDescriptorImpl = new BallerinaTupleTypeDescriptor(moduleID, (BTupleType) bType);\n-                break;\n+                return new BallerinaTupleTypeDescriptor(moduleID, (BTupleType) bType);\n             case TYPEDESC:\n-                typeDescriptorImpl = new BallerinaTypeDescTypeDescriptor(moduleID, (BTypedescType) bType);\n-                break;\n+                return new BallerinaTypeDescTypeDescriptor(moduleID, (BTypedescType) bType);\n             case NIL:\n                 return new BallerinaNilTypeDescriptor(moduleID, (BNilType) bType);\n             case OTHER:\n                 if (bType instanceof BInvokableType) {\n-                    typeDescriptorImpl =\n-                            new BallerinaFunctionTypeDescriptor(moduleID, (BInvokableTypeSymbol) bType.tsymbol);\n-                } else {\n-                    String name = bType.getKind().typeName();\n-                    typeDescriptorImpl = new BallerinaBuiltinTypeDescriptor(moduleID, name, bType);\n+                    return new BallerinaFunctionTypeDescriptor(moduleID, (BInvokableTypeSymbol) bType.tsymbol);\n                 }\n-                break;\n+                // fall through\n             default:\n-                String name = bType.getKind().typeName();\n-                return new BallerinaBuiltinTypeDescriptor(moduleID, name, bType);\n+                return new BallerinaSimpleTypeDescriptor(moduleID, bType);\n+        }\n+    }\n+\n+    private static boolean isTypeReference(BType bType, boolean rawTypeOnly) {\n+        if (rawTypeOnly || bType.tsymbol == null) {\n+            return false;\n+        }\n+\n+        if ((bType.tsymbol.flags & Flags.ANONYMOUS) == Flags.ANONYMOUS) {\n+            return false;\n         }\n \n-        if (!rawTypeOnly && bType.tsymbol != null && ((bType.tsymbol.flags & Flags.ANONYMOUS) != Flags.ANONYMOUS) &&\n-                !bType.tsymbol.getName().getValue().isEmpty()) {\n-            typeDescriptorImpl =\n-                    new BallerinaTypeReferenceTypeDescriptor(moduleID, bType, bType.tsymbol.getName().getValue());\n+        return !bType.tsymbol.getName().getValue().isEmpty();\n+    }\n+\n+    public static TypeDescKind getTypeDescKind(TypeKind bTypeKind) {\n+        switch (bTypeKind) {\n+            case ANY:\n+                return TypeDescKind.ANY;\n+            case ANYDATA:\n+                return TypeDescKind.ANYDATA;\n+            case ARRAY:\n+                return TypeDescKind.ARRAY;\n+            case BOOLEAN:\n+                return TypeDescKind.BOOLEAN;\n+            case BYTE:\n+                return TypeDescKind.BYTE;\n+            case DECIMAL:\n+                return TypeDescKind.DECIMAL;\n+            case FLOAT:\n+                return TypeDescKind.FLOAT;\n+            case HANDLE:\n+                return TypeDescKind.HANDLE;\n+            case INT:\n+                return TypeDescKind.INT;\n+            case NEVER:\n+                return TypeDescKind.NEVER;\n+            case NIL:\n+                return TypeDescKind.NIL;\n+            case STRING:\n+                return TypeDescKind.STRING;\n+            case JSON:\n+                return TypeDescKind.JSON;\n+            case XML:\n+                return TypeDescKind.XML;\n+            case FUNCTION:\n+                return TypeDescKind.FUNCTION;\n+            case FUTURE:\n+                return TypeDescKind.FUTURE;\n+            case MAP:\n+                return TypeDescKind.MAP;\n+            case OBJECT:\n+                return TypeDescKind.OBJECT;\n+            case STREAM:\n+                return TypeDescKind.STREAM;\n+            case TUPLE:\n+                return TypeDescKind.TUPLE;\n+            case TYPEDESC:\n+                return TypeDescKind.TYPEDESC;\n+            case UNION:\n+                return TypeDescKind.UNION;\n+            case INTERSECTION:\n+                return TypeDescKind.INTERSECTION;\n+            case ERROR:\n+                return TypeDescKind.ERROR;\n+            case ANNOTATION:\n+            case BLOB:\n+            case CHANNEL:\n+            case CONNECTOR:\n+            case ENDPOINT:\n+            case FINITE:\n+            case NONE:\n+            case OTHER:\n+            case PACKAGE:\n+            case READONLY:\n+            case SERVICE:\n+            case TABLE:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9693527fe1e86ca9b56b58f7d2485b275cecb54"}, "originalPosition": 194}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzUwNjI0Ng==", "bodyText": "Probably yes. I only refactored the existing ones. We need to add all the missing types.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25616#discussion_r483506246", "createdAt": "2020-09-04T09:36:44Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-compiler-api/src/main/java/org/ballerina/compiler/impl/TypesFactory.java", "diffHunk": "@@ -63,68 +65,134 @@ public static BallerinaTypeDescriptor getTypeDescriptor(BType bType) {\n     /**\n      * Get the type descriptor for the given type.\n      *\n-     * @param bType BType tp get the type descriptor\n-     * @param rawTypeOnly Whether convert the type descriptor to type reference or keep the raw type\n+     * @param bType {@link BType} of the type descriptor\n+     * @param rawTypeOnly Whether to convert the type descriptor to type reference or keep the raw type\n      * @return {@link BallerinaTypeDescriptor} generated\n      */\n     public static BallerinaTypeDescriptor getTypeDescriptor(BType bType, boolean rawTypeOnly) {\n         BallerinaTypeDescriptor typeDescriptorImpl;\n         if (bType == null) {\n             return null;\n         }\n+\n         ModuleID moduleID = bType.tsymbol == null ? null : new BallerinaModuleID(bType.tsymbol.pkgID);\n+\n+        // TODO: Revisit this: Why need a type-reference type?\n+        if (isTypeReference(bType, rawTypeOnly)) {\n+            return new BallerinaTypeReferenceTypeDescriptor(moduleID, bType, bType.tsymbol.getName().getValue());\n+        }\n+\n         switch (bType.getKind()) {\n             case OBJECT:\n-                typeDescriptorImpl = new BallerinaObjectTypeDescriptor(moduleID, (BObjectType) bType);\n-                break;\n+                return new BallerinaObjectTypeDescriptor(moduleID, (BObjectType) bType);\n             case RECORD:\n-                typeDescriptorImpl = new BallerinaRecordTypeDescriptor(moduleID, (BRecordType) bType);\n-                break;\n+                return new BallerinaRecordTypeDescriptor(moduleID, (BRecordType) bType);\n             case ERROR:\n-                typeDescriptorImpl = new BallerinaErrorTypeDescriptor(moduleID, (BErrorType) bType);\n-                break;\n+                return new BallerinaErrorTypeDescriptor(moduleID, (BErrorType) bType);\n             case UNION:\n-                typeDescriptorImpl = new BallerinaUnionTypeDescriptor(moduleID, (BUnionType) bType);\n-                break;\n+                return new BallerinaUnionTypeDescriptor(moduleID, (BUnionType) bType);\n             case FUTURE:\n-                typeDescriptorImpl = new BallerinaFutureTypeDescriptor(moduleID, (BFutureType) bType);\n-                break;\n+                return new BallerinaFutureTypeDescriptor(moduleID, (BFutureType) bType);\n             case MAP:\n-                typeDescriptorImpl = new BallerinaMapTypeDescriptor(moduleID, (BMapType) bType);\n-                break;\n+                return new BallerinaMapTypeDescriptor(moduleID, (BMapType) bType);\n             case STREAM:\n-                typeDescriptorImpl = new BallerinaStreamTypeDescriptor(moduleID, (BStreamType) bType);\n-                break;\n+                return new BallerinaStreamTypeDescriptor(moduleID, (BStreamType) bType);\n             case ARRAY:\n-                typeDescriptorImpl = new BallerinaArrayTypeDescriptor(moduleID, (BArrayType) bType);\n-                break;\n+                return new BallerinaArrayTypeDescriptor(moduleID, (BArrayType) bType);\n             case TUPLE:\n-                typeDescriptorImpl = new BallerinaTupleTypeDescriptor(moduleID, (BTupleType) bType);\n-                break;\n+                return new BallerinaTupleTypeDescriptor(moduleID, (BTupleType) bType);\n             case TYPEDESC:\n-                typeDescriptorImpl = new BallerinaTypeDescTypeDescriptor(moduleID, (BTypedescType) bType);\n-                break;\n+                return new BallerinaTypeDescTypeDescriptor(moduleID, (BTypedescType) bType);\n             case NIL:\n                 return new BallerinaNilTypeDescriptor(moduleID, (BNilType) bType);\n             case OTHER:\n                 if (bType instanceof BInvokableType) {\n-                    typeDescriptorImpl =\n-                            new BallerinaFunctionTypeDescriptor(moduleID, (BInvokableTypeSymbol) bType.tsymbol);\n-                } else {\n-                    String name = bType.getKind().typeName();\n-                    typeDescriptorImpl = new BallerinaBuiltinTypeDescriptor(moduleID, name, bType);\n+                    return new BallerinaFunctionTypeDescriptor(moduleID, (BInvokableTypeSymbol) bType.tsymbol);\n                 }\n-                break;\n+                // fall through\n             default:\n-                String name = bType.getKind().typeName();\n-                return new BallerinaBuiltinTypeDescriptor(moduleID, name, bType);\n+                return new BallerinaSimpleTypeDescriptor(moduleID, bType);\n+        }\n+    }\n+\n+    private static boolean isTypeReference(BType bType, boolean rawTypeOnly) {\n+        if (rawTypeOnly || bType.tsymbol == null) {\n+            return false;\n+        }\n+\n+        if ((bType.tsymbol.flags & Flags.ANONYMOUS) == Flags.ANONYMOUS) {\n+            return false;\n         }\n \n-        if (!rawTypeOnly && bType.tsymbol != null && ((bType.tsymbol.flags & Flags.ANONYMOUS) != Flags.ANONYMOUS) &&\n-                !bType.tsymbol.getName().getValue().isEmpty()) {\n-            typeDescriptorImpl =\n-                    new BallerinaTypeReferenceTypeDescriptor(moduleID, bType, bType.tsymbol.getName().getValue());\n+        return !bType.tsymbol.getName().getValue().isEmpty();\n+    }\n+\n+    public static TypeDescKind getTypeDescKind(TypeKind bTypeKind) {\n+        switch (bTypeKind) {\n+            case ANY:\n+                return TypeDescKind.ANY;\n+            case ANYDATA:\n+                return TypeDescKind.ANYDATA;\n+            case ARRAY:\n+                return TypeDescKind.ARRAY;\n+            case BOOLEAN:\n+                return TypeDescKind.BOOLEAN;\n+            case BYTE:\n+                return TypeDescKind.BYTE;\n+            case DECIMAL:\n+                return TypeDescKind.DECIMAL;\n+            case FLOAT:\n+                return TypeDescKind.FLOAT;\n+            case HANDLE:\n+                return TypeDescKind.HANDLE;\n+            case INT:\n+                return TypeDescKind.INT;\n+            case NEVER:\n+                return TypeDescKind.NEVER;\n+            case NIL:\n+                return TypeDescKind.NIL;\n+            case STRING:\n+                return TypeDescKind.STRING;\n+            case JSON:\n+                return TypeDescKind.JSON;\n+            case XML:\n+                return TypeDescKind.XML;\n+            case FUNCTION:\n+                return TypeDescKind.FUNCTION;\n+            case FUTURE:\n+                return TypeDescKind.FUTURE;\n+            case MAP:\n+                return TypeDescKind.MAP;\n+            case OBJECT:\n+                return TypeDescKind.OBJECT;\n+            case STREAM:\n+                return TypeDescKind.STREAM;\n+            case TUPLE:\n+                return TypeDescKind.TUPLE;\n+            case TYPEDESC:\n+                return TypeDescKind.TYPEDESC;\n+            case UNION:\n+                return TypeDescKind.UNION;\n+            case INTERSECTION:\n+                return TypeDescKind.INTERSECTION;\n+            case ERROR:\n+                return TypeDescKind.ERROR;\n+            case ANNOTATION:\n+            case BLOB:\n+            case CHANNEL:\n+            case CONNECTOR:\n+            case ENDPOINT:\n+            case FINITE:\n+            case NONE:\n+            case OTHER:\n+            case PACKAGE:\n+            case READONLY:\n+            case SERVICE:\n+            case TABLE:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ5ODIwMA=="}, "originalCommit": {"oid": "e9693527fe1e86ca9b56b58f7d2485b275cecb54"}, "originalPosition": 194}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzUyMzM1Mw==", "bodyText": "Ack.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25616#discussion_r483523353", "createdAt": "2020-09-04T10:10:52Z", "author": {"login": "pubudu91"}, "path": "compiler/ballerina-compiler-api/src/main/java/org/ballerina/compiler/impl/TypesFactory.java", "diffHunk": "@@ -63,68 +65,134 @@ public static BallerinaTypeDescriptor getTypeDescriptor(BType bType) {\n     /**\n      * Get the type descriptor for the given type.\n      *\n-     * @param bType BType tp get the type descriptor\n-     * @param rawTypeOnly Whether convert the type descriptor to type reference or keep the raw type\n+     * @param bType {@link BType} of the type descriptor\n+     * @param rawTypeOnly Whether to convert the type descriptor to type reference or keep the raw type\n      * @return {@link BallerinaTypeDescriptor} generated\n      */\n     public static BallerinaTypeDescriptor getTypeDescriptor(BType bType, boolean rawTypeOnly) {\n         BallerinaTypeDescriptor typeDescriptorImpl;\n         if (bType == null) {\n             return null;\n         }\n+\n         ModuleID moduleID = bType.tsymbol == null ? null : new BallerinaModuleID(bType.tsymbol.pkgID);\n+\n+        // TODO: Revisit this: Why need a type-reference type?\n+        if (isTypeReference(bType, rawTypeOnly)) {\n+            return new BallerinaTypeReferenceTypeDescriptor(moduleID, bType, bType.tsymbol.getName().getValue());\n+        }\n+\n         switch (bType.getKind()) {\n             case OBJECT:\n-                typeDescriptorImpl = new BallerinaObjectTypeDescriptor(moduleID, (BObjectType) bType);\n-                break;\n+                return new BallerinaObjectTypeDescriptor(moduleID, (BObjectType) bType);\n             case RECORD:\n-                typeDescriptorImpl = new BallerinaRecordTypeDescriptor(moduleID, (BRecordType) bType);\n-                break;\n+                return new BallerinaRecordTypeDescriptor(moduleID, (BRecordType) bType);\n             case ERROR:\n-                typeDescriptorImpl = new BallerinaErrorTypeDescriptor(moduleID, (BErrorType) bType);\n-                break;\n+                return new BallerinaErrorTypeDescriptor(moduleID, (BErrorType) bType);\n             case UNION:\n-                typeDescriptorImpl = new BallerinaUnionTypeDescriptor(moduleID, (BUnionType) bType);\n-                break;\n+                return new BallerinaUnionTypeDescriptor(moduleID, (BUnionType) bType);\n             case FUTURE:\n-                typeDescriptorImpl = new BallerinaFutureTypeDescriptor(moduleID, (BFutureType) bType);\n-                break;\n+                return new BallerinaFutureTypeDescriptor(moduleID, (BFutureType) bType);\n             case MAP:\n-                typeDescriptorImpl = new BallerinaMapTypeDescriptor(moduleID, (BMapType) bType);\n-                break;\n+                return new BallerinaMapTypeDescriptor(moduleID, (BMapType) bType);\n             case STREAM:\n-                typeDescriptorImpl = new BallerinaStreamTypeDescriptor(moduleID, (BStreamType) bType);\n-                break;\n+                return new BallerinaStreamTypeDescriptor(moduleID, (BStreamType) bType);\n             case ARRAY:\n-                typeDescriptorImpl = new BallerinaArrayTypeDescriptor(moduleID, (BArrayType) bType);\n-                break;\n+                return new BallerinaArrayTypeDescriptor(moduleID, (BArrayType) bType);\n             case TUPLE:\n-                typeDescriptorImpl = new BallerinaTupleTypeDescriptor(moduleID, (BTupleType) bType);\n-                break;\n+                return new BallerinaTupleTypeDescriptor(moduleID, (BTupleType) bType);\n             case TYPEDESC:\n-                typeDescriptorImpl = new BallerinaTypeDescTypeDescriptor(moduleID, (BTypedescType) bType);\n-                break;\n+                return new BallerinaTypeDescTypeDescriptor(moduleID, (BTypedescType) bType);\n             case NIL:\n                 return new BallerinaNilTypeDescriptor(moduleID, (BNilType) bType);\n             case OTHER:\n                 if (bType instanceof BInvokableType) {\n-                    typeDescriptorImpl =\n-                            new BallerinaFunctionTypeDescriptor(moduleID, (BInvokableTypeSymbol) bType.tsymbol);\n-                } else {\n-                    String name = bType.getKind().typeName();\n-                    typeDescriptorImpl = new BallerinaBuiltinTypeDescriptor(moduleID, name, bType);\n+                    return new BallerinaFunctionTypeDescriptor(moduleID, (BInvokableTypeSymbol) bType.tsymbol);\n                 }\n-                break;\n+                // fall through\n             default:\n-                String name = bType.getKind().typeName();\n-                return new BallerinaBuiltinTypeDescriptor(moduleID, name, bType);\n+                return new BallerinaSimpleTypeDescriptor(moduleID, bType);\n+        }\n+    }\n+\n+    private static boolean isTypeReference(BType bType, boolean rawTypeOnly) {\n+        if (rawTypeOnly || bType.tsymbol == null) {\n+            return false;\n+        }\n+\n+        if ((bType.tsymbol.flags & Flags.ANONYMOUS) == Flags.ANONYMOUS) {\n+            return false;\n         }\n \n-        if (!rawTypeOnly && bType.tsymbol != null && ((bType.tsymbol.flags & Flags.ANONYMOUS) != Flags.ANONYMOUS) &&\n-                !bType.tsymbol.getName().getValue().isEmpty()) {\n-            typeDescriptorImpl =\n-                    new BallerinaTypeReferenceTypeDescriptor(moduleID, bType, bType.tsymbol.getName().getValue());\n+        return !bType.tsymbol.getName().getValue().isEmpty();\n+    }\n+\n+    public static TypeDescKind getTypeDescKind(TypeKind bTypeKind) {\n+        switch (bTypeKind) {\n+            case ANY:\n+                return TypeDescKind.ANY;\n+            case ANYDATA:\n+                return TypeDescKind.ANYDATA;\n+            case ARRAY:\n+                return TypeDescKind.ARRAY;\n+            case BOOLEAN:\n+                return TypeDescKind.BOOLEAN;\n+            case BYTE:\n+                return TypeDescKind.BYTE;\n+            case DECIMAL:\n+                return TypeDescKind.DECIMAL;\n+            case FLOAT:\n+                return TypeDescKind.FLOAT;\n+            case HANDLE:\n+                return TypeDescKind.HANDLE;\n+            case INT:\n+                return TypeDescKind.INT;\n+            case NEVER:\n+                return TypeDescKind.NEVER;\n+            case NIL:\n+                return TypeDescKind.NIL;\n+            case STRING:\n+                return TypeDescKind.STRING;\n+            case JSON:\n+                return TypeDescKind.JSON;\n+            case XML:\n+                return TypeDescKind.XML;\n+            case FUNCTION:\n+                return TypeDescKind.FUNCTION;\n+            case FUTURE:\n+                return TypeDescKind.FUTURE;\n+            case MAP:\n+                return TypeDescKind.MAP;\n+            case OBJECT:\n+                return TypeDescKind.OBJECT;\n+            case STREAM:\n+                return TypeDescKind.STREAM;\n+            case TUPLE:\n+                return TypeDescKind.TUPLE;\n+            case TYPEDESC:\n+                return TypeDescKind.TYPEDESC;\n+            case UNION:\n+                return TypeDescKind.UNION;\n+            case INTERSECTION:\n+                return TypeDescKind.INTERSECTION;\n+            case ERROR:\n+                return TypeDescKind.ERROR;\n+            case ANNOTATION:\n+            case BLOB:\n+            case CHANNEL:\n+            case CONNECTOR:\n+            case ENDPOINT:\n+            case FINITE:\n+            case NONE:\n+            case OTHER:\n+            case PACKAGE:\n+            case READONLY:\n+            case SERVICE:\n+            case TABLE:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ5ODIwMA=="}, "originalCommit": {"oid": "e9693527fe1e86ca9b56b58f7d2485b275cecb54"}, "originalPosition": 194}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 184, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}