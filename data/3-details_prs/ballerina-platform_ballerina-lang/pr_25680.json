{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDgyNjIzOTY5", "number": 25680, "title": "[Formatter] Fix and enable formatting test scenarios ", "bodyText": "Purpose\nEnables formatting test scenarios and refactors the code implementation.\nFixes #25372\nApproach\n\nDescribe how you are implementing the solutions along with the design details.\n\nSamples\n\nProvide high-level details about the samples related to this feature.\n\nRemarks\n\nList any other known issues, related PRs, TODO items, or any other notes related to the PR.\n\nCheck List\n\n Read the Contributing Guide\n Updated Change Log\n Checked Tooling Support (#)\n Added necessary tests\n\n Unit Tests\n Spec Conformance Tests\n Integration Tests\n Ballerina By Example Tests\n\n\n Increased Test Coverage\n Added necessary documentation\n\n API documentation\n Module documentation in Module.md files\n Ballerina By Examples", "createdAt": "2020-09-09T07:57:51Z", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25680", "merged": true, "mergeCommit": {"oid": "5e5138a9cf0d197a0d8fa873460ae40701ed77a5"}, "closed": true, "closedAt": "2020-09-14T03:40:17Z", "author": {"login": "IrushiL"}, "timelineItems": {"totalCount": 52, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdHgPzsAFqTQ4NTg3NzA1MA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdIqsLnAFqTQ4NzM5NDU1MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg1ODc3MDUw", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25680#pullrequestreview-485877050", "createdAt": "2020-09-10T12:29:26Z", "commit": {"oid": "d7c8311da6403c402327513c87a6e040a6db4ce6"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxMjoyOToyNlrOHPxK2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxMjo0NzoxNVrOHPx1gQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjI5NjI4MQ==", "bodyText": "We could use a switch-case in-place of the if-else. It can nicely handle these multiple matches as well.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25680#discussion_r486296281", "createdAt": "2020-09-10T12:29:26Z", "author": {"login": "SupunS"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/FormatterUtils.java", "diffHunk": "@@ -0,0 +1,230 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.core;\n+\n+import io.ballerina.tools.text.LinePosition;\n+import io.ballerina.tools.text.LineRange;\n+import io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory;\n+import io.ballerinalang.compiler.syntax.tree.Minutiae;\n+import io.ballerinalang.compiler.syntax.tree.MinutiaeList;\n+import io.ballerinalang.compiler.syntax.tree.Node;\n+import io.ballerinalang.compiler.syntax.tree.SyntaxKind;\n+import io.ballerinalang.compiler.syntax.tree.Token;\n+import org.wso2.ballerinalang.compiler.util.diagnotic.DiagnosticPos;\n+\n+import static io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory.createMinutiaeList;\n+import static io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory.createWhitespaceMinutiae;\n+\n+/**\n+ * Class that contains the util functions used by the formatting tree modifier.\n+ */\n+class FormatterUtils {\n+\n+    /**\n+     * Get the node position.\n+     *\n+     * @param node node\n+     * @return node position\n+     */\n+    static DiagnosticPos getPosition(Node node) {\n+        if (node == null) {\n+            return null;\n+        }\n+        LineRange range = node.lineRange();\n+        LinePosition startPos = range.startLine();\n+        LinePosition endPos = range.endLine();\n+        int startOffset = startPos.offset();\n+        if (node.kind().equals(SyntaxKind.FUNCTION_DEFINITION) || node.kind().equals(SyntaxKind.TYPE_DEFINITION) ||\n+                node.kind().equals(SyntaxKind.CONST_DECLARATION)) {\n+            startOffset = (startOffset / 4) * 4;\n+        }\n+        return new DiagnosticPos(null, startPos.line() + 1, endPos.line() + 1,\n+                startOffset, endPos.offset());\n+    }\n+\n+    // TODO: Use a generic way to get the parent node using querying.\n+    static <T extends Node> Node getParent(T node, SyntaxKind syntaxKind) {\n+        Node parent = node.parent();\n+        if (parent == null) {\n+            parent = node;\n+        }\n+        SyntaxKind parentKind = parent.kind();\n+        if (parentKind == SyntaxKind.MODULE_VAR_DECL) {\n+            if (parent.parent() != null && parent.parent().kind() == SyntaxKind.MODULE_PART &&\n+                    syntaxKind == SyntaxKind.QUALIFIED_NAME_REFERENCE) {\n+                return null;\n+            }\n+            return parent;\n+        } else if (parentKind == SyntaxKind.FUNCTION_DEFINITION ||\n+                parentKind == SyntaxKind.IF_ELSE_STATEMENT ||\n+                parentKind == SyntaxKind.ELSE_BLOCK ||\n+                parentKind == SyntaxKind.WHILE_STATEMENT ||\n+                parentKind == SyntaxKind.CONST_DECLARATION ||\n+                parentKind == SyntaxKind.METHOD_DECLARATION ||\n+                parentKind == SyntaxKind.TYPE_DEFINITION) {\n+            return parent;\n+        } else if (syntaxKind == SyntaxKind.SIMPLE_NAME_REFERENCE) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d7c8311da6403c402327513c87a6e040a6db4ce6"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjI5NzA3OA==", "bodyText": "since parent.parent() is used multiple times within the function, we can extract it to a variable", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25680#discussion_r486297078", "createdAt": "2020-09-10T12:30:43Z", "author": {"login": "SupunS"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/FormatterUtils.java", "diffHunk": "@@ -0,0 +1,230 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.core;\n+\n+import io.ballerina.tools.text.LinePosition;\n+import io.ballerina.tools.text.LineRange;\n+import io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory;\n+import io.ballerinalang.compiler.syntax.tree.Minutiae;\n+import io.ballerinalang.compiler.syntax.tree.MinutiaeList;\n+import io.ballerinalang.compiler.syntax.tree.Node;\n+import io.ballerinalang.compiler.syntax.tree.SyntaxKind;\n+import io.ballerinalang.compiler.syntax.tree.Token;\n+import org.wso2.ballerinalang.compiler.util.diagnotic.DiagnosticPos;\n+\n+import static io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory.createMinutiaeList;\n+import static io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory.createWhitespaceMinutiae;\n+\n+/**\n+ * Class that contains the util functions used by the formatting tree modifier.\n+ */\n+class FormatterUtils {\n+\n+    /**\n+     * Get the node position.\n+     *\n+     * @param node node\n+     * @return node position\n+     */\n+    static DiagnosticPos getPosition(Node node) {\n+        if (node == null) {\n+            return null;\n+        }\n+        LineRange range = node.lineRange();\n+        LinePosition startPos = range.startLine();\n+        LinePosition endPos = range.endLine();\n+        int startOffset = startPos.offset();\n+        if (node.kind().equals(SyntaxKind.FUNCTION_DEFINITION) || node.kind().equals(SyntaxKind.TYPE_DEFINITION) ||\n+                node.kind().equals(SyntaxKind.CONST_DECLARATION)) {\n+            startOffset = (startOffset / 4) * 4;\n+        }\n+        return new DiagnosticPos(null, startPos.line() + 1, endPos.line() + 1,\n+                startOffset, endPos.offset());\n+    }\n+\n+    // TODO: Use a generic way to get the parent node using querying.\n+    static <T extends Node> Node getParent(T node, SyntaxKind syntaxKind) {\n+        Node parent = node.parent();\n+        if (parent == null) {\n+            parent = node;\n+        }\n+        SyntaxKind parentKind = parent.kind();\n+        if (parentKind == SyntaxKind.MODULE_VAR_DECL) {\n+            if (parent.parent() != null && parent.parent().kind() == SyntaxKind.MODULE_PART &&", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d7c8311da6403c402327513c87a6e040a6db4ce6"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjI5NzYxOA==", "bodyText": "Shall we we use == instead of .equals()?\nLets fix in all places.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25680#discussion_r486297618", "createdAt": "2020-09-10T12:31:41Z", "author": {"login": "SupunS"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/FormatterUtils.java", "diffHunk": "@@ -0,0 +1,230 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.core;\n+\n+import io.ballerina.tools.text.LinePosition;\n+import io.ballerina.tools.text.LineRange;\n+import io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory;\n+import io.ballerinalang.compiler.syntax.tree.Minutiae;\n+import io.ballerinalang.compiler.syntax.tree.MinutiaeList;\n+import io.ballerinalang.compiler.syntax.tree.Node;\n+import io.ballerinalang.compiler.syntax.tree.SyntaxKind;\n+import io.ballerinalang.compiler.syntax.tree.Token;\n+import org.wso2.ballerinalang.compiler.util.diagnotic.DiagnosticPos;\n+\n+import static io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory.createMinutiaeList;\n+import static io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory.createWhitespaceMinutiae;\n+\n+/**\n+ * Class that contains the util functions used by the formatting tree modifier.\n+ */\n+class FormatterUtils {\n+\n+    /**\n+     * Get the node position.\n+     *\n+     * @param node node\n+     * @return node position\n+     */\n+    static DiagnosticPos getPosition(Node node) {\n+        if (node == null) {\n+            return null;\n+        }\n+        LineRange range = node.lineRange();\n+        LinePosition startPos = range.startLine();\n+        LinePosition endPos = range.endLine();\n+        int startOffset = startPos.offset();\n+        if (node.kind().equals(SyntaxKind.FUNCTION_DEFINITION) || node.kind().equals(SyntaxKind.TYPE_DEFINITION) ||", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d7c8311da6403c402327513c87a6e040a6db4ce6"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjI5ODMwOQ==", "bodyText": "can extract node.parent().kind() to a variable", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25680#discussion_r486298309", "createdAt": "2020-09-10T12:32:48Z", "author": {"login": "SupunS"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/FormatterUtils.java", "diffHunk": "@@ -0,0 +1,230 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.core;\n+\n+import io.ballerina.tools.text.LinePosition;\n+import io.ballerina.tools.text.LineRange;\n+import io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory;\n+import io.ballerinalang.compiler.syntax.tree.Minutiae;\n+import io.ballerinalang.compiler.syntax.tree.MinutiaeList;\n+import io.ballerinalang.compiler.syntax.tree.Node;\n+import io.ballerinalang.compiler.syntax.tree.SyntaxKind;\n+import io.ballerinalang.compiler.syntax.tree.Token;\n+import org.wso2.ballerinalang.compiler.util.diagnotic.DiagnosticPos;\n+\n+import static io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory.createMinutiaeList;\n+import static io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory.createWhitespaceMinutiae;\n+\n+/**\n+ * Class that contains the util functions used by the formatting tree modifier.\n+ */\n+class FormatterUtils {\n+\n+    /**\n+     * Get the node position.\n+     *\n+     * @param node node\n+     * @return node position\n+     */\n+    static DiagnosticPos getPosition(Node node) {\n+        if (node == null) {\n+            return null;\n+        }\n+        LineRange range = node.lineRange();\n+        LinePosition startPos = range.startLine();\n+        LinePosition endPos = range.endLine();\n+        int startOffset = startPos.offset();\n+        if (node.kind().equals(SyntaxKind.FUNCTION_DEFINITION) || node.kind().equals(SyntaxKind.TYPE_DEFINITION) ||\n+                node.kind().equals(SyntaxKind.CONST_DECLARATION)) {\n+            startOffset = (startOffset / 4) * 4;\n+        }\n+        return new DiagnosticPos(null, startPos.line() + 1, endPos.line() + 1,\n+                startOffset, endPos.offset());\n+    }\n+\n+    // TODO: Use a generic way to get the parent node using querying.\n+    static <T extends Node> Node getParent(T node, SyntaxKind syntaxKind) {\n+        Node parent = node.parent();\n+        if (parent == null) {\n+            parent = node;\n+        }\n+        SyntaxKind parentKind = parent.kind();\n+        if (parentKind == SyntaxKind.MODULE_VAR_DECL) {\n+            if (parent.parent() != null && parent.parent().kind() == SyntaxKind.MODULE_PART &&\n+                    syntaxKind == SyntaxKind.QUALIFIED_NAME_REFERENCE) {\n+                return null;\n+            }\n+            return parent;\n+        } else if (parentKind == SyntaxKind.FUNCTION_DEFINITION ||\n+                parentKind == SyntaxKind.IF_ELSE_STATEMENT ||\n+                parentKind == SyntaxKind.ELSE_BLOCK ||\n+                parentKind == SyntaxKind.WHILE_STATEMENT ||\n+                parentKind == SyntaxKind.CONST_DECLARATION ||\n+                parentKind == SyntaxKind.METHOD_DECLARATION ||\n+                parentKind == SyntaxKind.TYPE_DEFINITION) {\n+            return parent;\n+        } else if (syntaxKind == SyntaxKind.SIMPLE_NAME_REFERENCE) {\n+            if (parentKind == SyntaxKind.REQUIRED_PARAM ||\n+                    parentKind == SyntaxKind.POSITIONAL_ARG ||\n+                    parentKind == SyntaxKind.BINARY_EXPRESSION ||\n+                    parentKind == SyntaxKind.RETURN_STATEMENT ||\n+                    parentKind == SyntaxKind.REMOTE_METHOD_CALL_ACTION ||\n+                    parentKind.equals(SyntaxKind.FIELD_ACCESS) ||\n+                    (parentKind == SyntaxKind.FUNCTION_CALL && parent.parent() != null &&\n+                            parent.parent().kind() == SyntaxKind.ASSIGNMENT_STATEMENT)) {\n+                return null;\n+            }\n+            return getParent(parent, syntaxKind);\n+        } else if (syntaxKind.equals(SyntaxKind.STRING_TYPE_DESC) &&\n+                parentKind.equals(SyntaxKind.RECORD_FIELD) && parent.parent() != null &&\n+                parent.parent().kind().equals(SyntaxKind.RECORD_TYPE_DESC)) {\n+            return getParent(parent, syntaxKind);\n+        } else if (parentKind == SyntaxKind.SERVICE_DECLARATION ||\n+                parentKind == SyntaxKind.BINARY_EXPRESSION) {\n+            if (syntaxKind == SyntaxKind.QUALIFIED_NAME_REFERENCE) {\n+                return null;\n+            }\n+            return parent;\n+        } else if (parentKind == SyntaxKind.REQUIRED_PARAM) {\n+            return null;\n+        } else if (parentKind.equals(SyntaxKind.OBJECT_TYPE_DESC)) {\n+            if (parent.parent() != null && parent.parent().kind().equals(SyntaxKind.RETURN_TYPE_DESCRIPTOR)) {\n+                return parent.parent().parent().parent();\n+            } else if (parent.parent() != null && parent.parent().kind().equals(SyntaxKind.TYPE_DEFINITION)) {\n+                return getParent(parent, syntaxKind);\n+            } else {\n+                return parent;\n+            }\n+        } else if (parent.parent() != null) {\n+            return getParent(parent, syntaxKind);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    static int getIndentation(Node node, int indentation, FormattingOptions formattingOptions) {\n+        if (node == null) {\n+            return indentation;\n+        }\n+        if (node.parent() != null && (node.parent().kind().equals(SyntaxKind.BLOCK_STATEMENT) ||\n+                node.parent().kind().equals(SyntaxKind.FUNCTION_BODY_BLOCK) ||", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d7c8311da6403c402327513c87a6e040a6db4ce6"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjMwMDI2Nw==", "bodyText": "extract  blockStatementNode.parent().kind() to a variable", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25680#discussion_r486300267", "createdAt": "2020-09-10T12:36:07Z", "author": {"login": "SupunS"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/FormattingTreeModifier.java", "diffHunk": "@@ -913,10 +972,17 @@ public MetadataNode transform(MetadataNode metadataNode) {\n \n     @Override\n     public BlockStatementNode transform(BlockStatementNode blockStatementNode) {\n-        if (!isInLineRange(blockStatementNode)) {\n+        if (!isInLineRange(blockStatementNode, lineRange)) {\n             return blockStatementNode;\n         }\n-        int startColumn = getStartColumn(blockStatementNode, blockStatementNode.kind(), false);\n+        boolean addSpaces = false;\n+        if (blockStatementNode.parent().kind().equals(SyntaxKind.NAMED_WORKER_DECLARATION) ||\n+                blockStatementNode.parent().kind().equals(SyntaxKind.QUERY_ACTION) ||\n+                blockStatementNode.parent().kind().equals(SyntaxKind.FOREACH_STATEMENT) ||\n+                blockStatementNode.parent().kind().equals(SyntaxKind.FUNCTION_BODY_BLOCK)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d7c8311da6403c402327513c87a6e040a6db4ce6"}, "originalPosition": 583}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjMwMzAzMw==", "bodyText": "Whats the node we are getting here by listConstructorExpressionNode.children().get(1)?\nCan we use the specific method in ListConstructorExpressionNode class?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25680#discussion_r486303033", "createdAt": "2020-09-10T12:40:29Z", "author": {"login": "SupunS"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/FormattingTreeModifier.java", "diffHunk": "@@ -1437,18 +1636,29 @@ public ByteArrayLiteralNode transform(ByteArrayLiteralNode byteArrayLiteralNode)\n \n     @Override\n     public ListConstructorExpressionNode transform(ListConstructorExpressionNode listConstructorExpressionNode) {\n+        if (!isInLineRange(listConstructorExpressionNode, lineRange)) {\n+            return listConstructorExpressionNode;\n+        }\n+        int newLines = 0;\n+        if (listConstructorExpressionNode.children().get(1).kind().equals(SyntaxKind.MAPPING_CONSTRUCTOR)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d7c8311da6403c402327513c87a6e040a6db4ce6"}, "originalPosition": 1061}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjMwNDgyNg==", "bodyText": "Condition of this is-block is a tad too big. Let's extract it to a separate function.\nWe can simply do: addSpaces = newlyAddedFunction();", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25680#discussion_r486304826", "createdAt": "2020-09-10T12:43:27Z", "author": {"login": "SupunS"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NodeFormattingMetrics.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.core;\n+\n+import io.ballerinalang.compiler.syntax.tree.BuiltinSimpleNameReferenceNode;\n+import io.ballerinalang.compiler.syntax.tree.Node;\n+import io.ballerinalang.compiler.syntax.tree.NonTerminalNode;\n+import io.ballerinalang.compiler.syntax.tree.ObjectFieldNode;\n+import io.ballerinalang.compiler.syntax.tree.SyntaxKind;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+\n+/**\n+ * Class that stores the formatting metrics for a particular node.\n+ */\n+class NodeFormattingMetrics {\n+\n+    private Node node;\n+    private NonTerminalNode parent;\n+    private NonTerminalNode grandParent;\n+\n+    NodeFormattingMetrics(Node node) {\n+\n+        this.node = node;\n+        this.parent = node.parent();\n+        if (parent != null) {\n+            this.grandParent = parent.parent();\n+        } else {\n+            this.grandParent = null;\n+        }\n+        setNodeMetrics();\n+    }\n+\n+    private void setNodeMetrics() {\n+        if (node instanceof BuiltinSimpleNameReferenceNode) {\n+            handleBuiltinSimpleNameReferenceNode();\n+        }\n+    }\n+\n+    boolean handleBuiltinSimpleNameReferenceNode() {\n+        boolean addSpaces = true;\n+        ArrayList<SyntaxKind> parentNodes = new ArrayList<>(\n+                Arrays.asList(\n+                        SyntaxKind.FUNCTION_CALL,\n+                        SyntaxKind.TYPE_TEST_EXPRESSION,\n+                        SyntaxKind.TYPE_PARAMETER,\n+                        SyntaxKind.TYPE_CAST_PARAM,\n+                        SyntaxKind.UNION_TYPE_DESC,\n+                        SyntaxKind.XML_TYPE_DESC));\n+        if (parent != null && (parentNodes.contains(parent.kind()) || grandParent != null &&\n+                ((parent.kind().equals(SyntaxKind.TYPED_BINDING_PATTERN) &&\n+                        grandParent.kind().equals(SyntaxKind.FOREACH_STATEMENT)) ||\n+                (parent.kind().equals(SyntaxKind.UNION_TYPE_DESC) &&\n+                        grandParent.kind().equals(SyntaxKind.PARAMETERIZED_TYPE_DESC)) ||\n+                (parent.kind().equals(SyntaxKind.OBJECT_FIELD) &&\n+                        ((ObjectFieldNode) parent).visibilityQualifier().isPresent()) ||\n+                (grandParent.kind().equals(SyntaxKind.LOCAL_VAR_DECL) &&\n+                        grandParent.children().get(1).equals(parent)) ||\n+                grandParent.kind().equals(SyntaxKind.FROM_CLAUSE) ||\n+                grandParent.kind().equals(SyntaxKind.PARAMETERIZED_TYPE_DESC)))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d7c8311da6403c402327513c87a6e040a6db4ce6"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjMwNDk5OA==", "bodyText": "Same as above", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25680#discussion_r486304998", "createdAt": "2020-09-10T12:43:44Z", "author": {"login": "SupunS"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NodeFormattingMetrics.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.core;\n+\n+import io.ballerinalang.compiler.syntax.tree.BuiltinSimpleNameReferenceNode;\n+import io.ballerinalang.compiler.syntax.tree.Node;\n+import io.ballerinalang.compiler.syntax.tree.NonTerminalNode;\n+import io.ballerinalang.compiler.syntax.tree.ObjectFieldNode;\n+import io.ballerinalang.compiler.syntax.tree.SyntaxKind;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+\n+/**\n+ * Class that stores the formatting metrics for a particular node.\n+ */\n+class NodeFormattingMetrics {\n+\n+    private Node node;\n+    private NonTerminalNode parent;\n+    private NonTerminalNode grandParent;\n+\n+    NodeFormattingMetrics(Node node) {\n+\n+        this.node = node;\n+        this.parent = node.parent();\n+        if (parent != null) {\n+            this.grandParent = parent.parent();\n+        } else {\n+            this.grandParent = null;\n+        }\n+        setNodeMetrics();\n+    }\n+\n+    private void setNodeMetrics() {\n+        if (node instanceof BuiltinSimpleNameReferenceNode) {\n+            handleBuiltinSimpleNameReferenceNode();\n+        }\n+    }\n+\n+    boolean handleBuiltinSimpleNameReferenceNode() {\n+        boolean addSpaces = true;\n+        ArrayList<SyntaxKind> parentNodes = new ArrayList<>(\n+                Arrays.asList(\n+                        SyntaxKind.FUNCTION_CALL,\n+                        SyntaxKind.TYPE_TEST_EXPRESSION,\n+                        SyntaxKind.TYPE_PARAMETER,\n+                        SyntaxKind.TYPE_CAST_PARAM,\n+                        SyntaxKind.UNION_TYPE_DESC,\n+                        SyntaxKind.XML_TYPE_DESC));\n+        if (parent != null && (parentNodes.contains(parent.kind()) || grandParent != null &&\n+                ((parent.kind().equals(SyntaxKind.TYPED_BINDING_PATTERN) &&\n+                        grandParent.kind().equals(SyntaxKind.FOREACH_STATEMENT)) ||\n+                (parent.kind().equals(SyntaxKind.UNION_TYPE_DESC) &&\n+                        grandParent.kind().equals(SyntaxKind.PARAMETERIZED_TYPE_DESC)) ||\n+                (parent.kind().equals(SyntaxKind.OBJECT_FIELD) &&\n+                        ((ObjectFieldNode) parent).visibilityQualifier().isPresent()) ||\n+                (grandParent.kind().equals(SyntaxKind.LOCAL_VAR_DECL) &&\n+                        grandParent.children().get(1).equals(parent)) ||\n+                grandParent.kind().equals(SyntaxKind.FROM_CLAUSE) ||\n+                grandParent.kind().equals(SyntaxKind.PARAMETERIZED_TYPE_DESC)))) {\n+            addSpaces = false;\n+        }\n+        if (parent != null && grandParent != null && (parent.kind().equals(SyntaxKind.UNION_TYPE_DESC) &&\n+                !grandParent.kind().equals(SyntaxKind.TYPE_CAST_PARAM) && parent.children().get(0).equals(node))) {\n+            addSpaces = true;\n+        }\n+        return addSpaces;\n+    }\n+\n+    boolean handleSimpleNameReferenceNode() {\n+        boolean addSpaces = false;\n+        ArrayList<SyntaxKind> parentNodes = new ArrayList<>(\n+                Arrays.asList(\n+                        SyntaxKind.TYPED_BINDING_PATTERN,\n+                        SyntaxKind.FIELD_ACCESS,\n+                        SyntaxKind.RECORD_FIELD_WITH_DEFAULT_VALUE,\n+                        SyntaxKind.OPTIONAL_TYPE_DESC,\n+                        SyntaxKind.ARRAY_TYPE_DESC));\n+        if (parent != null && ((parentNodes.contains(parent.kind())) || grandParent != null &&\n+                ((parent.kind().equals(SyntaxKind.INDEXED_EXPRESSION) &&\n+                        grandParent.kind().equals(SyntaxKind.ASSIGNMENT_STATEMENT)) ||\n+                ((parent.kind().equals(SyntaxKind.ASYNC_SEND_ACTION) ||\n+                parent.kind().equals(SyntaxKind.ASSIGNMENT_STATEMENT)) &&\n+                        parent.children().get(0).equals(node))))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d7c8311da6403c402327513c87a6e040a6db4ce6"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjMwNzIwMQ==", "bodyText": "Do we need the outer wrapper new ArrayList<>()? I think Arrays.asList() returns an array-list", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25680#discussion_r486307201", "createdAt": "2020-09-10T12:47:15Z", "author": {"login": "SupunS"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NodeFormattingMetrics.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.core;\n+\n+import io.ballerinalang.compiler.syntax.tree.BuiltinSimpleNameReferenceNode;\n+import io.ballerinalang.compiler.syntax.tree.Node;\n+import io.ballerinalang.compiler.syntax.tree.NonTerminalNode;\n+import io.ballerinalang.compiler.syntax.tree.ObjectFieldNode;\n+import io.ballerinalang.compiler.syntax.tree.SyntaxKind;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+\n+/**\n+ * Class that stores the formatting metrics for a particular node.\n+ */\n+class NodeFormattingMetrics {\n+\n+    private Node node;\n+    private NonTerminalNode parent;\n+    private NonTerminalNode grandParent;\n+\n+    NodeFormattingMetrics(Node node) {\n+\n+        this.node = node;\n+        this.parent = node.parent();\n+        if (parent != null) {\n+            this.grandParent = parent.parent();\n+        } else {\n+            this.grandParent = null;\n+        }\n+        setNodeMetrics();\n+    }\n+\n+    private void setNodeMetrics() {\n+        if (node instanceof BuiltinSimpleNameReferenceNode) {\n+            handleBuiltinSimpleNameReferenceNode();\n+        }\n+    }\n+\n+    boolean handleBuiltinSimpleNameReferenceNode() {\n+        boolean addSpaces = true;\n+        ArrayList<SyntaxKind> parentNodes = new ArrayList<>(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d7c8311da6403c402327513c87a6e040a6db4ce6"}, "originalPosition": 56}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d7c8311da6403c402327513c87a6e040a6db4ce6", "author": {"user": {"login": "IrushiL", "name": "Irushi Liyanage"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/d7c8311da6403c402327513c87a6e040a6db4ce6", "committedDate": "2020-09-09T07:14:07Z", "message": "Refactor the code"}, "afterCommit": {"oid": "dd0f7a1d7682bff895bfce8537f5c5cf56f9e2df", "author": {"user": {"login": "IrushiL", "name": "Irushi Liyanage"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/dd0f7a1d7682bff895bfce8537f5c5cf56f9e2df", "committedDate": "2020-09-11T03:53:47Z", "message": "Resolve merge conflicts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "30a038f9bbe0c1375c7c2edc2864a1854064d801", "author": {"user": {"login": "IrushiL", "name": "Irushi Liyanage"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/30a038f9bbe0c1375c7c2edc2864a1854064d801", "committedDate": "2020-09-11T07:54:43Z", "message": "Enable types/behavioural/error_type_1.bal test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ce9058f1ed69f51b31e2c7f23da25bc90e85cf63", "author": {"user": {"login": "IrushiL", "name": "Irushi Liyanage"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/ce9058f1ed69f51b31e2c7f23da25bc90e85cf63", "committedDate": "2020-09-11T07:54:43Z", "message": "Enable types/behavioural/error_type_3.bal test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a661e9d91d220979b3ae8edd6d67fcb6dd700e4a", "author": {"user": {"login": "IrushiL", "name": "Irushi Liyanage"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a661e9d91d220979b3ae8edd6d67fcb6dd700e4a", "committedDate": "2020-09-11T07:54:43Z", "message": "Fix types/behavioural/error_type_4.bal test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f954a15395b16dda7050bc8b135ae54cffbfcd99", "author": {"user": {"login": "IrushiL", "name": "Irushi Liyanage"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f954a15395b16dda7050bc8b135ae54cffbfcd99", "committedDate": "2020-09-11T07:54:43Z", "message": "Fix types/behavioural/function_type_2.bal test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3d5ed31d48284bab38c238bf5627b656ef9f4296", "author": {"user": {"login": "IrushiL", "name": "Irushi Liyanage"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3d5ed31d48284bab38c238bf5627b656ef9f4296", "committedDate": "2020-09-11T07:54:43Z", "message": "Refactor code and fix formatting issues"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b1ddb004f597c4773b6d8ac5acfc5886ca035b36", "author": {"user": {"login": "IrushiL", "name": "Irushi Liyanage"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b1ddb004f597c4773b6d8ac5acfc5886ca035b36", "committedDate": "2020-09-11T07:54:43Z", "message": "Enable check actions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "27c973826fa00e2fb99000d420b8ac1a51371838", "author": {"user": {"login": "IrushiL", "name": "Irushi Liyanage"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/27c973826fa00e2fb99000d420b8ac1a51371838", "committedDate": "2020-09-11T07:54:43Z", "message": "Enable query action tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bc13ec44aacfac61877cded6cf162b5b1ffd206c", "author": {"user": {"login": "IrushiL", "name": "Irushi Liyanage"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/bc13ec44aacfac61877cded6cf162b5b1ffd206c", "committedDate": "2020-09-11T07:54:43Z", "message": "Enable send-receive actions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1185e35cca245f642a34a88669daf5b0a30d5caf", "author": {"user": {"login": "IrushiL", "name": "Irushi Liyanage"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1185e35cca245f642a34a88669daf5b0a30d5caf", "committedDate": "2020-09-11T07:54:43Z", "message": "Enable start action tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "04744054471e78be063d3755dd5e78e56e592f27", "author": {"user": {"login": "IrushiL", "name": "Irushi Liyanage"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/04744054471e78be063d3755dd5e78e56e592f27", "committedDate": "2020-09-11T07:54:43Z", "message": "Enable trap action tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bba83f8ccafa533e4eb486e9ff5c8eb25bded487", "author": {"user": {"login": "IrushiL", "name": "Irushi Liyanage"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/bba83f8ccafa533e4eb486e9ff5c8eb25bded487", "committedDate": "2020-09-11T07:54:43Z", "message": "Enable the type cast actions test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ca199ed6752632c2778ea9ce6951047f8799bddf", "author": {"user": {"login": "IrushiL", "name": "Irushi Liyanage"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/ca199ed6752632c2778ea9ce6951047f8799bddf", "committedDate": "2020-09-11T07:54:43Z", "message": "Enable wait action tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "abe137d475dde997aff4c1c1839df0fb218b932f", "author": {"user": {"login": "IrushiL", "name": "Irushi Liyanage"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/abe137d475dde997aff4c1c1839df0fb218b932f", "committedDate": "2020-09-11T07:54:43Z", "message": "Enable function definition declaration test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "22de62187bf401b5816ac9e2b8c200c8adca7a04", "author": {"user": {"login": "IrushiL", "name": "Irushi Liyanage"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/22de62187bf401b5816ac9e2b8c200c8adca7a04", "committedDate": "2020-09-11T07:54:44Z", "message": "Enable import declarations test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d35f73ae4bb9e010d6d87772e807b8f04ca6e390", "author": {"user": {"login": "IrushiL", "name": "Irushi Liyanage"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/d35f73ae4bb9e010d6d87772e807b8f04ca6e390", "committedDate": "2020-09-11T07:54:44Z", "message": "Enable module type definition test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a8ef28718265298554e8d286a8bd02e34fbeb277", "author": {"user": {"login": "IrushiL", "name": "Irushi Liyanage"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a8ef28718265298554e8d286a8bd02e34fbeb277", "committedDate": "2020-09-11T07:54:44Z", "message": "Enable module variable declarations test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "31c7ef1b95b7fbce440b6398778cc7095af013b0", "author": {"user": {"login": "IrushiL", "name": "Irushi Liyanage"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/31c7ef1b95b7fbce440b6398778cc7095af013b0", "committedDate": "2020-09-11T07:54:44Z", "message": "Enable service listener declaration test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6ba774ac62285d3244c00589a28af120329a63f9", "author": {"user": {"login": "IrushiL", "name": "Irushi Liyanage"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6ba774ac62285d3244c00589a28af120329a63f9", "committedDate": "2020-09-11T07:54:44Z", "message": "Enable expressions test cases"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "49fb447c4c7d0fbcd28b1e2915fe16b6ddd05129", "author": {"user": {"login": "IrushiL", "name": "Irushi Liyanage"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/49fb447c4c7d0fbcd28b1e2915fe16b6ddd05129", "committedDate": "2020-09-11T07:54:44Z", "message": "Enable object constructor expression test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5d91baba86cb6c5140429ed706e1bd792469a749", "author": {"user": {"login": "IrushiL", "name": "Irushi Liyanage"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/5d91baba86cb6c5140429ed706e1bd792469a749", "committedDate": "2020-09-11T07:54:44Z", "message": "Enable type test expression tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "972015936ef4e4ac3d846dc19bb9d913440b7421", "author": {"user": {"login": "IrushiL", "name": "Irushi Liyanage"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/972015936ef4e4ac3d846dc19bb9d913440b7421", "committedDate": "2020-09-11T07:54:44Z", "message": "Enable unary expressions test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a5c94b7608ce94892c4ccaa2fbc6d2352e2d573d", "author": {"user": {"login": "IrushiL", "name": "Irushi Liyanage"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a5c94b7608ce94892c4ccaa2fbc6d2352e2d573d", "committedDate": "2020-09-11T07:54:44Z", "message": "Enable block statement tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "70bc47f1ec4486988e645077e2f6ec6b1d8f9eab", "author": {"user": {"login": "IrushiL", "name": "Irushi Liyanage"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/70bc47f1ec4486988e645077e2f6ec6b1d8f9eab", "committedDate": "2020-09-11T07:54:44Z", "message": "Enable types/structured/map_type_2.bal test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "be2c5b8ab2ab440bb8f526bb40c0ec85b9a2543e", "author": {"user": {"login": "IrushiL", "name": "Irushi Liyanage"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/be2c5b8ab2ab440bb8f526bb40c0ec85b9a2543e", "committedDate": "2020-09-11T07:54:44Z", "message": "Enable structured type tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0b13d212fc267f69dadfea15cc02adc78b3a085b", "author": {"user": {"login": "IrushiL", "name": "Irushi Liyanage"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/0b13d212fc267f69dadfea15cc02adc78b3a085b", "committedDate": "2020-09-11T07:54:44Z", "message": "Enable simple types tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "39ee15f7c660a660a54c402e585230d430314456", "author": {"user": {"login": "IrushiL", "name": "Irushi Liyanage"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/39ee15f7c660a660a54c402e585230d430314456", "committedDate": "2020-09-11T07:54:44Z", "message": "Enable behavioural types tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "41b714ae96709954543aa3381934c91d793b176e", "author": {"user": {"login": "IrushiL", "name": "Irushi Liyanage"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/41b714ae96709954543aa3381934c91d793b176e", "committedDate": "2020-09-11T07:54:44Z", "message": "Enable other/never_type_1.bal test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a8b51af2452ccaf29555aa1f694cdc55cf8ac498", "author": {"user": {"login": "IrushiL", "name": "Irushi Liyanage"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a8b51af2452ccaf29555aa1f694cdc55cf8ac498", "committedDate": "2020-09-11T07:54:44Z", "message": "Enable Raw Template Expressions Test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a5ac92535461ab19efc0cb7219047fa3a35e864f", "author": {"user": {"login": "IrushiL", "name": "Irushi Liyanage"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a5ac92535461ab19efc0cb7219047fa3a35e864f", "committedDate": "2020-09-11T07:54:44Z", "message": "Enable constant expression test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "927e6230173ea0aa11fc3af47fb50b639018f668", "author": {"user": {"login": "IrushiL", "name": "Irushi Liyanage"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/927e6230173ea0aa11fc3af47fb50b639018f668", "committedDate": "2020-09-11T07:54:44Z", "message": "Enable string template expression test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "97fe33c9a44f15e376492decdf4551ee5c7ddf44", "author": {"user": {"login": "IrushiL", "name": "Irushi Liyanage"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/97fe33c9a44f15e376492decdf4551ee5c7ddf44", "committedDate": "2020-09-11T07:54:44Z", "message": "Enable range expression tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5a6f429e0eb5be901b196ee1c7feec3add8af019", "author": {"user": {"login": "IrushiL", "name": "Irushi Liyanage"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/5a6f429e0eb5be901b196ee1c7feec3add8af019", "committedDate": "2020-09-11T08:04:05Z", "message": "Enable statement test cases"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bfefcf242c6dc112d556a4509c93676e21f90e79", "author": {"user": {"login": "IrushiL", "name": "Irushi Liyanage"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/bfefcf242c6dc112d556a4509c93676e21f90e79", "committedDate": "2020-09-11T08:05:05Z", "message": "Enable range expression tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "973c7d678f24b61c41326e08ec0d717a9f77bc04", "author": {"user": {"login": "IrushiL", "name": "Irushi Liyanage"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/973c7d678f24b61c41326e08ec0d717a9f77bc04", "committedDate": "2020-09-11T08:05:05Z", "message": "Enable the while statement test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bdf56be23a7c1622cf7f7495f6e9ea43c17bb317", "author": {"user": {"login": "IrushiL", "name": "Irushi Liyanage"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/bdf56be23a7c1622cf7f7495f6e9ea43c17bb317", "committedDate": "2020-09-11T08:05:05Z", "message": "Refactor the code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "62f45eb97d5b922e5d26469781103001a6929898", "author": {"user": {"login": "IrushiL", "name": "Irushi Liyanage"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/62f45eb97d5b922e5d26469781103001a6929898", "committedDate": "2020-09-11T08:05:05Z", "message": "Format and refactor the code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "493d4bdd274c4939bd07d23d628327062ba9789c", "author": {"user": {"login": "IrushiL", "name": "Irushi Liyanage"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/493d4bdd274c4939bd07d23d628327062ba9789c", "committedDate": "2020-09-11T08:05:06Z", "message": "Add preserve new line feature"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6d01748bd2b4ff382ab972160eb042f38626a40c", "author": {"user": {"login": "IrushiL", "name": "Irushi Liyanage"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6d01748bd2b4ff382ab972160eb042f38626a40c", "committedDate": "2020-09-11T08:05:06Z", "message": "Refactor the code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "122271b1c507190d7486341f9517f4eaea04a006", "author": {"user": {"login": "IrushiL", "name": "Irushi Liyanage"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/122271b1c507190d7486341f9517f4eaea04a006", "committedDate": "2020-09-11T08:05:06Z", "message": "Refactor and address review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3b7b2c3bea571596f7f577579f38e6f9e97b669e", "author": {"user": {"login": "IrushiL", "name": "Irushi Liyanage"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3b7b2c3bea571596f7f577579f38e6f9e97b669e", "committedDate": "2020-09-11T08:05:06Z", "message": "Fix formatting and refactoring the code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a32b23903d07628e738d72356b0f855315d9df36", "author": {"user": {"login": "IrushiL", "name": "Irushi Liyanage"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a32b23903d07628e738d72356b0f855315d9df36", "committedDate": "2020-09-11T08:05:06Z", "message": "Resolve merge conflicts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ae022884dc4113885037a0706b11e5f82da98bb2", "author": {"user": {"login": "IrushiL", "name": "Irushi Liyanage"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/ae022884dc4113885037a0706b11e5f82da98bb2", "committedDate": "2020-09-11T08:05:06Z", "message": "Enable more test scenarios"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "abf30d5163ce0ebdc71f6463696d834f80cc2f05", "author": {"user": {"login": "IrushiL", "name": "Irushi Liyanage"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/abf30d5163ce0ebdc71f6463696d834f80cc2f05", "committedDate": "2020-09-11T12:36:51Z", "message": "Resolve merge conflicts"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "dd0f7a1d7682bff895bfce8537f5c5cf56f9e2df", "author": {"user": {"login": "IrushiL", "name": "Irushi Liyanage"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/dd0f7a1d7682bff895bfce8537f5c5cf56f9e2df", "committedDate": "2020-09-11T03:53:47Z", "message": "Resolve merge conflicts"}, "afterCommit": {"oid": "abf30d5163ce0ebdc71f6463696d834f80cc2f05", "author": {"user": {"login": "IrushiL", "name": "Irushi Liyanage"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/abf30d5163ce0ebdc71f6463696d834f80cc2f05", "committedDate": "2020-09-11T12:36:51Z", "message": "Resolve merge conflicts"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg2OTk4MDgz", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25680#pullrequestreview-486998083", "createdAt": "2020-09-11T17:37:53Z", "commit": {"oid": "abf30d5163ce0ebdc71f6463696d834f80cc2f05"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNzozNzo1M1rOHQn2Cw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNzozNzo1M1rOHQn2Cw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE5MjA3NQ==", "bodyText": "Instead of returning a possibly null node, shall we use Optional here?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25680#discussion_r487192075", "createdAt": "2020-09-11T17:37:53Z", "author": {"login": "nadeeshaan"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/FormatterUtils.java", "diffHunk": "@@ -0,0 +1,415 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.core;\n+\n+import io.ballerina.tools.text.LinePosition;\n+import io.ballerina.tools.text.LineRange;\n+import io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory;\n+import io.ballerinalang.compiler.syntax.tree.ChildNodeList;\n+import io.ballerinalang.compiler.syntax.tree.Minutiae;\n+import io.ballerinalang.compiler.syntax.tree.MinutiaeList;\n+import io.ballerinalang.compiler.syntax.tree.Node;\n+import io.ballerinalang.compiler.syntax.tree.NonTerminalNode;\n+import io.ballerinalang.compiler.syntax.tree.SyntaxKind;\n+import io.ballerinalang.compiler.syntax.tree.Token;\n+import org.wso2.ballerinalang.compiler.util.diagnotic.DiagnosticPos;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import static io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory.createMinutiaeList;\n+import static io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory.createWhitespaceMinutiae;\n+\n+/**\n+ * Class that contains the util functions used by the formatting tree modifier.\n+ */\n+class FormatterUtils {\n+\n+    private static final String LINE_SEPARATOR = \"line.separator\";\n+\n+    /**\n+     * Get the node position.\n+     *\n+     * @param node node\n+     * @return node position\n+     */\n+    static DiagnosticPos getPosition(Node node) {\n+        if (node == null) {\n+            return null;\n+        }\n+        LineRange range = node.lineRange();\n+        LinePosition startPos = range.startLine();\n+        LinePosition endPos = range.endLine();\n+        int startOffset = startPos.offset();\n+        if (node.kind() == (SyntaxKind.FUNCTION_DEFINITION) || node.kind() == (SyntaxKind.TYPE_DEFINITION) ||\n+                node.kind() == (SyntaxKind.CONST_DECLARATION) || node.kind() == (SyntaxKind.OBJECT_TYPE_DESC)) {\n+            startOffset = (startOffset / 4) * 4;\n+        }\n+        return new DiagnosticPos(null, startPos.line() + 1, endPos.line() + 1,\n+                startOffset, endPos.offset());\n+    }\n+\n+    // TODO: Use a generic way to get the parent node using querying.\n+    static <T extends Node> Node getParent(T node, SyntaxKind syntaxKind) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abf30d5163ce0ebdc71f6463696d834f80cc2f05"}, "originalPosition": 68}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg3MDAxMjQx", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25680#pullrequestreview-487001241", "createdAt": "2020-09-11T17:42:27Z", "commit": {"oid": "abf30d5163ce0ebdc71f6463696d834f80cc2f05"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNzo0MjoyOFrOHQn_nA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNzo1NzoxN1rOHQoceQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE5NDUyNA==", "bodyText": "Since the if, else-if ladder is complex, shall we stick to individual if clauses? It seems we return within each clause and there is no fall through.this way we can remove several inner else clauses and will become the logic bit cleaner", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25680#discussion_r487194524", "createdAt": "2020-09-11T17:42:28Z", "author": {"login": "nadeeshaan"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/FormatterUtils.java", "diffHunk": "@@ -0,0 +1,415 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.core;\n+\n+import io.ballerina.tools.text.LinePosition;\n+import io.ballerina.tools.text.LineRange;\n+import io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory;\n+import io.ballerinalang.compiler.syntax.tree.ChildNodeList;\n+import io.ballerinalang.compiler.syntax.tree.Minutiae;\n+import io.ballerinalang.compiler.syntax.tree.MinutiaeList;\n+import io.ballerinalang.compiler.syntax.tree.Node;\n+import io.ballerinalang.compiler.syntax.tree.NonTerminalNode;\n+import io.ballerinalang.compiler.syntax.tree.SyntaxKind;\n+import io.ballerinalang.compiler.syntax.tree.Token;\n+import org.wso2.ballerinalang.compiler.util.diagnotic.DiagnosticPos;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import static io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory.createMinutiaeList;\n+import static io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory.createWhitespaceMinutiae;\n+\n+/**\n+ * Class that contains the util functions used by the formatting tree modifier.\n+ */\n+class FormatterUtils {\n+\n+    private static final String LINE_SEPARATOR = \"line.separator\";\n+\n+    /**\n+     * Get the node position.\n+     *\n+     * @param node node\n+     * @return node position\n+     */\n+    static DiagnosticPos getPosition(Node node) {\n+        if (node == null) {\n+            return null;\n+        }\n+        LineRange range = node.lineRange();\n+        LinePosition startPos = range.startLine();\n+        LinePosition endPos = range.endLine();\n+        int startOffset = startPos.offset();\n+        if (node.kind() == (SyntaxKind.FUNCTION_DEFINITION) || node.kind() == (SyntaxKind.TYPE_DEFINITION) ||\n+                node.kind() == (SyntaxKind.CONST_DECLARATION) || node.kind() == (SyntaxKind.OBJECT_TYPE_DESC)) {\n+            startOffset = (startOffset / 4) * 4;\n+        }\n+        return new DiagnosticPos(null, startPos.line() + 1, endPos.line() + 1,\n+                startOffset, endPos.offset());\n+    }\n+\n+    // TODO: Use a generic way to get the parent node using querying.\n+    static <T extends Node> Node getParent(T node, SyntaxKind syntaxKind) {\n+        Node parent = node.parent();\n+        if (parent == null) {\n+            parent = node;\n+        }\n+        Node grandParent = parent.parent();\n+        SyntaxKind parentKind = parent.kind();\n+        if (parentKind == (SyntaxKind.MODULE_VAR_DECL)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abf30d5163ce0ebdc71f6463696d834f80cc2f05"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE5NTQzNw==", "bodyText": "let's add a private constructor", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25680#discussion_r487195437", "createdAt": "2020-09-11T17:44:19Z", "author": {"login": "nadeeshaan"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/FormatterUtils.java", "diffHunk": "@@ -0,0 +1,415 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.core;\n+\n+import io.ballerina.tools.text.LinePosition;\n+import io.ballerina.tools.text.LineRange;\n+import io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory;\n+import io.ballerinalang.compiler.syntax.tree.ChildNodeList;\n+import io.ballerinalang.compiler.syntax.tree.Minutiae;\n+import io.ballerinalang.compiler.syntax.tree.MinutiaeList;\n+import io.ballerinalang.compiler.syntax.tree.Node;\n+import io.ballerinalang.compiler.syntax.tree.NonTerminalNode;\n+import io.ballerinalang.compiler.syntax.tree.SyntaxKind;\n+import io.ballerinalang.compiler.syntax.tree.Token;\n+import org.wso2.ballerinalang.compiler.util.diagnotic.DiagnosticPos;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import static io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory.createMinutiaeList;\n+import static io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory.createWhitespaceMinutiae;\n+\n+/**\n+ * Class that contains the util functions used by the formatting tree modifier.\n+ */\n+class FormatterUtils {\n+\n+    private static final String LINE_SEPARATOR = \"line.separator\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abf30d5163ce0ebdc71f6463696d834f80cc2f05"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE5NzQwNg==", "bodyText": "Effectively we return here a null, is it possible to return an Optional as the return type of the method?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25680#discussion_r487197406", "createdAt": "2020-09-11T17:48:12Z", "author": {"login": "nadeeshaan"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/FormatterUtils.java", "diffHunk": "@@ -0,0 +1,415 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.core;\n+\n+import io.ballerina.tools.text.LinePosition;\n+import io.ballerina.tools.text.LineRange;\n+import io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory;\n+import io.ballerinalang.compiler.syntax.tree.ChildNodeList;\n+import io.ballerinalang.compiler.syntax.tree.Minutiae;\n+import io.ballerinalang.compiler.syntax.tree.MinutiaeList;\n+import io.ballerinalang.compiler.syntax.tree.Node;\n+import io.ballerinalang.compiler.syntax.tree.NonTerminalNode;\n+import io.ballerinalang.compiler.syntax.tree.SyntaxKind;\n+import io.ballerinalang.compiler.syntax.tree.Token;\n+import org.wso2.ballerinalang.compiler.util.diagnotic.DiagnosticPos;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import static io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory.createMinutiaeList;\n+import static io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory.createWhitespaceMinutiae;\n+\n+/**\n+ * Class that contains the util functions used by the formatting tree modifier.\n+ */\n+class FormatterUtils {\n+\n+    private static final String LINE_SEPARATOR = \"line.separator\";\n+\n+    /**\n+     * Get the node position.\n+     *\n+     * @param node node\n+     * @return node position\n+     */\n+    static DiagnosticPos getPosition(Node node) {\n+        if (node == null) {\n+            return null;\n+        }\n+        LineRange range = node.lineRange();\n+        LinePosition startPos = range.startLine();\n+        LinePosition endPos = range.endLine();\n+        int startOffset = startPos.offset();\n+        if (node.kind() == (SyntaxKind.FUNCTION_DEFINITION) || node.kind() == (SyntaxKind.TYPE_DEFINITION) ||\n+                node.kind() == (SyntaxKind.CONST_DECLARATION) || node.kind() == (SyntaxKind.OBJECT_TYPE_DESC)) {\n+            startOffset = (startOffset / 4) * 4;\n+        }\n+        return new DiagnosticPos(null, startPos.line() + 1, endPos.line() + 1,\n+                startOffset, endPos.offset());\n+    }\n+\n+    // TODO: Use a generic way to get the parent node using querying.\n+    static <T extends Node> Node getParent(T node, SyntaxKind syntaxKind) {\n+        Node parent = node.parent();\n+        if (parent == null) {\n+            parent = node;\n+        }\n+        Node grandParent = parent.parent();\n+        SyntaxKind parentKind = parent.kind();\n+        if (parentKind == (SyntaxKind.MODULE_VAR_DECL)) {\n+            if (grandParent != null && grandParent.kind() == (SyntaxKind.MODULE_PART) &&\n+                    syntaxKind == (SyntaxKind.QUALIFIED_NAME_REFERENCE)) {\n+                return null;\n+            }\n+            return parent;\n+        } else if (parentKind == (SyntaxKind.FUNCTION_DEFINITION) ||\n+                parentKind == (SyntaxKind.ELSE_BLOCK) ||\n+                parentKind == (SyntaxKind.IF_ELSE_STATEMENT) ||\n+                parentKind == (SyntaxKind.LOCAL_TYPE_DEFINITION_STATEMENT) ||\n+                parentKind == (SyntaxKind.WHILE_STATEMENT) ||\n+                parentKind == (SyntaxKind.CONST_DECLARATION) ||\n+                parentKind == (SyntaxKind.METHOD_DECLARATION) ||\n+                parentKind == (SyntaxKind.TYPE_DEFINITION)) {\n+            return parent;\n+        } else if (syntaxKind == (SyntaxKind.SIMPLE_NAME_REFERENCE)) {\n+            if (parentKind == (SyntaxKind.REQUIRED_PARAM) ||\n+                    parentKind == (SyntaxKind.POSITIONAL_ARG) ||\n+                    parentKind == (SyntaxKind.BINARY_EXPRESSION) ||\n+                    parentKind == (SyntaxKind.BRACED_EXPRESSION) ||\n+                    parentKind == (SyntaxKind.RETURN_STATEMENT) ||\n+                    parentKind == (SyntaxKind.REMOTE_METHOD_CALL_ACTION) ||\n+                    parentKind == (SyntaxKind.FIELD_ACCESS) ||\n+                    (parentKind == (SyntaxKind.FUNCTION_CALL) && grandParent != null &&\n+                            grandParent.kind() == (SyntaxKind.ASSIGNMENT_STATEMENT))) {\n+                return null;\n+            }\n+            return getParent(parent, syntaxKind);\n+        } else if (syntaxKind == (SyntaxKind.STRING_TYPE_DESC) &&\n+                parentKind == (SyntaxKind.RECORD_FIELD) && grandParent != null &&\n+                grandParent.kind() == (SyntaxKind.RECORD_TYPE_DESC)) {\n+            return getParent(parent, syntaxKind);\n+        } else if (parentKind == (SyntaxKind.SERVICE_DECLARATION) ||\n+                parentKind == (SyntaxKind.BINARY_EXPRESSION)) {\n+            if (syntaxKind == (SyntaxKind.QUALIFIED_NAME_REFERENCE)) {\n+                return null;\n+            }\n+            return parent;\n+        } else if (parentKind == (SyntaxKind.REQUIRED_PARAM)) {\n+            return null;\n+        } else if (parentKind == (SyntaxKind.OBJECT_TYPE_DESC)) {\n+            if (grandParent != null && grandParent.kind() == (SyntaxKind.RETURN_TYPE_DESCRIPTOR)) {\n+                return grandParent.parent().parent();\n+            } else if (grandParent != null && grandParent.kind() == (SyntaxKind.TYPE_DEFINITION)) {\n+                return getParent(parent, syntaxKind);\n+            } else {\n+                return parent;\n+            }\n+        } else if (grandParent != null) {\n+            return getParent(parent, syntaxKind);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    static int getIndentation(Node node, int indentation, FormattingOptions formattingOptions) {\n+        if (node == null) {\n+            return indentation;\n+        }\n+        if (node.parent() != null) {\n+            SyntaxKind parentKind = node.parent().kind();\n+            if (parentKind == SyntaxKind.BLOCK_STATEMENT ||\n+                    parentKind == SyntaxKind.FUNCTION_BODY_BLOCK ||\n+                    parentKind == SyntaxKind.LIST_CONSTRUCTOR ||\n+                    parentKind == SyntaxKind.TYPE_DEFINITION ||\n+                    parentKind == SyntaxKind.METHOD_DECLARATION ||\n+                    parentKind == SyntaxKind.MAPPING_CONSTRUCTOR) {\n+                indentation += formattingOptions.getTabSize();\n+            }\n+        }\n+        return getIndentation(node.parent(), indentation, formattingOptions);\n+    }\n+\n+    private static MinutiaeList getCommentMinutiae(MinutiaeList minutiaeList, boolean isLeading) {\n+        MinutiaeList minutiaes = AbstractNodeFactory.createEmptyMinutiaeList();\n+        for (int i = 0; i < minutiaeList.size(); i++) {\n+            if (minutiaeList.get(i).kind() == (SyntaxKind.COMMENT_MINUTIAE)) {\n+                if (i > 0) {\n+                    minutiaes = minutiaes.add(minutiaeList.get(i - 1));\n+                }\n+                minutiaes = minutiaes.add(minutiaeList.get(i));\n+                if ((i + 1) < minutiaeList.size() && isLeading) {\n+                    minutiaes = minutiaes.add(minutiaeList.get(i + 1));\n+                }\n+            }\n+        }\n+        return minutiaes;\n+    }\n+\n+    private static String getWhiteSpaces(int column, int newLines) {\n+        StringBuilder whiteSpaces = new StringBuilder();\n+        for (int i = 0; i <= (newLines - 1); i++) {\n+            whiteSpaces.append(System.getProperty(LINE_SEPARATOR));\n+        }\n+        for (int i = 0; i <= (column - 1); i++) {\n+            whiteSpaces.append(\" \");\n+        }\n+        return whiteSpaces.toString();\n+    }\n+\n+    /**\n+     * Initialize the token with empty minutiae lists.\n+     *\n+     * @param node node\n+     * @return token with empty minutiae\n+     */\n+    static <T extends Token> Token getToken(T node) {\n+        if (node == null) {\n+            return node;\n+        }\n+        MinutiaeList leadingMinutiaeList = AbstractNodeFactory.createEmptyMinutiaeList();\n+        MinutiaeList trailingMinutiaeList = AbstractNodeFactory.createEmptyMinutiaeList();\n+        if (node.containsLeadingMinutiae()) {\n+            leadingMinutiaeList = getCommentMinutiae(node.leadingMinutiae(), true);\n+        }\n+        if (node.containsTrailingMinutiae()) {\n+            trailingMinutiaeList = getCommentMinutiae(node.trailingMinutiae(), false);\n+        }\n+        return node.modify(leadingMinutiaeList, trailingMinutiaeList);\n+    }\n+\n+    static boolean isInLineRange(Node node, LineRange lineRange) {\n+        if (lineRange == null) {\n+            return true;\n+        }\n+        int nodeStartLine = node.lineRange().startLine().line();\n+        int nodeStartOffset = node.lineRange().startLine().offset();\n+        int nodeEndLine = node.lineRange().endLine().line();\n+        int nodeEndOffset = node.lineRange().endLine().offset();\n+\n+        int startLine = lineRange.startLine().line();\n+        int startOffset = lineRange.startLine().offset();\n+        int endLine = lineRange.endLine().line();\n+        int endOffset = lineRange.endLine().offset();\n+\n+        if (nodeStartLine >= startLine && nodeEndLine <= endLine) {\n+            if (nodeStartLine == startLine || nodeEndLine == endLine) {\n+                return nodeStartOffset >= startOffset && nodeEndOffset <= endOffset;\n+            }\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Update the minutiae and return the token.\n+     *\n+     * @param token            token\n+     * @param leadingSpaces    leading spaces\n+     * @param trailingSpaces   trailing spaces\n+     * @param leadingNewLines  leading new lines\n+     * @param trailingNewLines trailing new lines\n+     * @return updated token\n+     */\n+    static Token formatToken(Token token, int leadingSpaces, int trailingSpaces, int leadingNewLines,\n+                             int trailingNewLines) {\n+        if (token == null) {\n+            return token;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abf30d5163ce0ebdc71f6463696d834f80cc2f05"}, "originalPosition": 232}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE5ODAyNQ==", "bodyText": "Let's do an early return here", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25680#discussion_r487198025", "createdAt": "2020-09-11T17:49:27Z", "author": {"login": "nadeeshaan"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/FormatterUtils.java", "diffHunk": "@@ -0,0 +1,415 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.core;\n+\n+import io.ballerina.tools.text.LinePosition;\n+import io.ballerina.tools.text.LineRange;\n+import io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory;\n+import io.ballerinalang.compiler.syntax.tree.ChildNodeList;\n+import io.ballerinalang.compiler.syntax.tree.Minutiae;\n+import io.ballerinalang.compiler.syntax.tree.MinutiaeList;\n+import io.ballerinalang.compiler.syntax.tree.Node;\n+import io.ballerinalang.compiler.syntax.tree.NonTerminalNode;\n+import io.ballerinalang.compiler.syntax.tree.SyntaxKind;\n+import io.ballerinalang.compiler.syntax.tree.Token;\n+import org.wso2.ballerinalang.compiler.util.diagnotic.DiagnosticPos;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import static io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory.createMinutiaeList;\n+import static io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory.createWhitespaceMinutiae;\n+\n+/**\n+ * Class that contains the util functions used by the formatting tree modifier.\n+ */\n+class FormatterUtils {\n+\n+    private static final String LINE_SEPARATOR = \"line.separator\";\n+\n+    /**\n+     * Get the node position.\n+     *\n+     * @param node node\n+     * @return node position\n+     */\n+    static DiagnosticPos getPosition(Node node) {\n+        if (node == null) {\n+            return null;\n+        }\n+        LineRange range = node.lineRange();\n+        LinePosition startPos = range.startLine();\n+        LinePosition endPos = range.endLine();\n+        int startOffset = startPos.offset();\n+        if (node.kind() == (SyntaxKind.FUNCTION_DEFINITION) || node.kind() == (SyntaxKind.TYPE_DEFINITION) ||\n+                node.kind() == (SyntaxKind.CONST_DECLARATION) || node.kind() == (SyntaxKind.OBJECT_TYPE_DESC)) {\n+            startOffset = (startOffset / 4) * 4;\n+        }\n+        return new DiagnosticPos(null, startPos.line() + 1, endPos.line() + 1,\n+                startOffset, endPos.offset());\n+    }\n+\n+    // TODO: Use a generic way to get the parent node using querying.\n+    static <T extends Node> Node getParent(T node, SyntaxKind syntaxKind) {\n+        Node parent = node.parent();\n+        if (parent == null) {\n+            parent = node;\n+        }\n+        Node grandParent = parent.parent();\n+        SyntaxKind parentKind = parent.kind();\n+        if (parentKind == (SyntaxKind.MODULE_VAR_DECL)) {\n+            if (grandParent != null && grandParent.kind() == (SyntaxKind.MODULE_PART) &&\n+                    syntaxKind == (SyntaxKind.QUALIFIED_NAME_REFERENCE)) {\n+                return null;\n+            }\n+            return parent;\n+        } else if (parentKind == (SyntaxKind.FUNCTION_DEFINITION) ||\n+                parentKind == (SyntaxKind.ELSE_BLOCK) ||\n+                parentKind == (SyntaxKind.IF_ELSE_STATEMENT) ||\n+                parentKind == (SyntaxKind.LOCAL_TYPE_DEFINITION_STATEMENT) ||\n+                parentKind == (SyntaxKind.WHILE_STATEMENT) ||\n+                parentKind == (SyntaxKind.CONST_DECLARATION) ||\n+                parentKind == (SyntaxKind.METHOD_DECLARATION) ||\n+                parentKind == (SyntaxKind.TYPE_DEFINITION)) {\n+            return parent;\n+        } else if (syntaxKind == (SyntaxKind.SIMPLE_NAME_REFERENCE)) {\n+            if (parentKind == (SyntaxKind.REQUIRED_PARAM) ||\n+                    parentKind == (SyntaxKind.POSITIONAL_ARG) ||\n+                    parentKind == (SyntaxKind.BINARY_EXPRESSION) ||\n+                    parentKind == (SyntaxKind.BRACED_EXPRESSION) ||\n+                    parentKind == (SyntaxKind.RETURN_STATEMENT) ||\n+                    parentKind == (SyntaxKind.REMOTE_METHOD_CALL_ACTION) ||\n+                    parentKind == (SyntaxKind.FIELD_ACCESS) ||\n+                    (parentKind == (SyntaxKind.FUNCTION_CALL) && grandParent != null &&\n+                            grandParent.kind() == (SyntaxKind.ASSIGNMENT_STATEMENT))) {\n+                return null;\n+            }\n+            return getParent(parent, syntaxKind);\n+        } else if (syntaxKind == (SyntaxKind.STRING_TYPE_DESC) &&\n+                parentKind == (SyntaxKind.RECORD_FIELD) && grandParent != null &&\n+                grandParent.kind() == (SyntaxKind.RECORD_TYPE_DESC)) {\n+            return getParent(parent, syntaxKind);\n+        } else if (parentKind == (SyntaxKind.SERVICE_DECLARATION) ||\n+                parentKind == (SyntaxKind.BINARY_EXPRESSION)) {\n+            if (syntaxKind == (SyntaxKind.QUALIFIED_NAME_REFERENCE)) {\n+                return null;\n+            }\n+            return parent;\n+        } else if (parentKind == (SyntaxKind.REQUIRED_PARAM)) {\n+            return null;\n+        } else if (parentKind == (SyntaxKind.OBJECT_TYPE_DESC)) {\n+            if (grandParent != null && grandParent.kind() == (SyntaxKind.RETURN_TYPE_DESCRIPTOR)) {\n+                return grandParent.parent().parent();\n+            } else if (grandParent != null && grandParent.kind() == (SyntaxKind.TYPE_DEFINITION)) {\n+                return getParent(parent, syntaxKind);\n+            } else {\n+                return parent;\n+            }\n+        } else if (grandParent != null) {\n+            return getParent(parent, syntaxKind);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    static int getIndentation(Node node, int indentation, FormattingOptions formattingOptions) {\n+        if (node == null) {\n+            return indentation;\n+        }\n+        if (node.parent() != null) {\n+            SyntaxKind parentKind = node.parent().kind();\n+            if (parentKind == SyntaxKind.BLOCK_STATEMENT ||\n+                    parentKind == SyntaxKind.FUNCTION_BODY_BLOCK ||\n+                    parentKind == SyntaxKind.LIST_CONSTRUCTOR ||\n+                    parentKind == SyntaxKind.TYPE_DEFINITION ||\n+                    parentKind == SyntaxKind.METHOD_DECLARATION ||\n+                    parentKind == SyntaxKind.MAPPING_CONSTRUCTOR) {\n+                indentation += formattingOptions.getTabSize();\n+            }\n+        }\n+        return getIndentation(node.parent(), indentation, formattingOptions);\n+    }\n+\n+    private static MinutiaeList getCommentMinutiae(MinutiaeList minutiaeList, boolean isLeading) {\n+        MinutiaeList minutiaes = AbstractNodeFactory.createEmptyMinutiaeList();\n+        for (int i = 0; i < minutiaeList.size(); i++) {\n+            if (minutiaeList.get(i).kind() == (SyntaxKind.COMMENT_MINUTIAE)) {\n+                if (i > 0) {\n+                    minutiaes = minutiaes.add(minutiaeList.get(i - 1));\n+                }\n+                minutiaes = minutiaes.add(minutiaeList.get(i));\n+                if ((i + 1) < minutiaeList.size() && isLeading) {\n+                    minutiaes = minutiaes.add(minutiaeList.get(i + 1));\n+                }\n+            }\n+        }\n+        return minutiaes;\n+    }\n+\n+    private static String getWhiteSpaces(int column, int newLines) {\n+        StringBuilder whiteSpaces = new StringBuilder();\n+        for (int i = 0; i <= (newLines - 1); i++) {\n+            whiteSpaces.append(System.getProperty(LINE_SEPARATOR));\n+        }\n+        for (int i = 0; i <= (column - 1); i++) {\n+            whiteSpaces.append(\" \");\n+        }\n+        return whiteSpaces.toString();\n+    }\n+\n+    /**\n+     * Initialize the token with empty minutiae lists.\n+     *\n+     * @param node node\n+     * @return token with empty minutiae\n+     */\n+    static <T extends Token> Token getToken(T node) {\n+        if (node == null) {\n+            return node;\n+        }\n+        MinutiaeList leadingMinutiaeList = AbstractNodeFactory.createEmptyMinutiaeList();\n+        MinutiaeList trailingMinutiaeList = AbstractNodeFactory.createEmptyMinutiaeList();\n+        if (node.containsLeadingMinutiae()) {\n+            leadingMinutiaeList = getCommentMinutiae(node.leadingMinutiae(), true);\n+        }\n+        if (node.containsTrailingMinutiae()) {\n+            trailingMinutiaeList = getCommentMinutiae(node.trailingMinutiae(), false);\n+        }\n+        return node.modify(leadingMinutiaeList, trailingMinutiaeList);\n+    }\n+\n+    static boolean isInLineRange(Node node, LineRange lineRange) {\n+        if (lineRange == null) {\n+            return true;\n+        }\n+        int nodeStartLine = node.lineRange().startLine().line();\n+        int nodeStartOffset = node.lineRange().startLine().offset();\n+        int nodeEndLine = node.lineRange().endLine().line();\n+        int nodeEndOffset = node.lineRange().endLine().offset();\n+\n+        int startLine = lineRange.startLine().line();\n+        int startOffset = lineRange.startLine().offset();\n+        int endLine = lineRange.endLine().line();\n+        int endOffset = lineRange.endLine().offset();\n+\n+        if (nodeStartLine >= startLine && nodeEndLine <= endLine) {\n+            if (nodeStartLine == startLine || nodeEndLine == endLine) {\n+                return nodeStartOffset >= startOffset && nodeEndOffset <= endOffset;\n+            }\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Update the minutiae and return the token.\n+     *\n+     * @param token            token\n+     * @param leadingSpaces    leading spaces\n+     * @param trailingSpaces   trailing spaces\n+     * @param leadingNewLines  leading new lines\n+     * @param trailingNewLines trailing new lines\n+     * @return updated token\n+     */\n+    static Token formatToken(Token token, int leadingSpaces, int trailingSpaces, int leadingNewLines,\n+                             int trailingNewLines) {\n+        if (token == null) {\n+            return token;\n+        }\n+        MinutiaeList newLeadingMinutiaeList = modifyMinutiaeList(leadingSpaces, leadingNewLines);\n+        MinutiaeList newTrailingMinutiaeList = modifyMinutiaeList(trailingSpaces, trailingNewLines);\n+\n+        return token.modify(newLeadingMinutiaeList, newTrailingMinutiaeList);\n+    }\n+\n+    private static MinutiaeList modifyMinutiaeList(int spaces, int newLines) {\n+        Minutiae minutiae = createWhitespaceMinutiae(getWhiteSpaces(spaces, newLines));\n+        return createMinutiaeList(minutiae);\n+    }\n+\n+    private static int getChildLocation(NonTerminalNode parent, Node child) {\n+        if (parent != null && child != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abf30d5163ce0ebdc71f6463696d834f80cc2f05"}, "originalPosition": 246}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE5OTQxOQ==", "bodyText": "we can remove the else clause since we do a return within the if clause", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25680#discussion_r487199419", "createdAt": "2020-09-11T17:52:17Z", "author": {"login": "nadeeshaan"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/FormatterUtils.java", "diffHunk": "@@ -0,0 +1,415 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.core;\n+\n+import io.ballerina.tools.text.LinePosition;\n+import io.ballerina.tools.text.LineRange;\n+import io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory;\n+import io.ballerinalang.compiler.syntax.tree.ChildNodeList;\n+import io.ballerinalang.compiler.syntax.tree.Minutiae;\n+import io.ballerinalang.compiler.syntax.tree.MinutiaeList;\n+import io.ballerinalang.compiler.syntax.tree.Node;\n+import io.ballerinalang.compiler.syntax.tree.NonTerminalNode;\n+import io.ballerinalang.compiler.syntax.tree.SyntaxKind;\n+import io.ballerinalang.compiler.syntax.tree.Token;\n+import org.wso2.ballerinalang.compiler.util.diagnotic.DiagnosticPos;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import static io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory.createMinutiaeList;\n+import static io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory.createWhitespaceMinutiae;\n+\n+/**\n+ * Class that contains the util functions used by the formatting tree modifier.\n+ */\n+class FormatterUtils {\n+\n+    private static final String LINE_SEPARATOR = \"line.separator\";\n+\n+    /**\n+     * Get the node position.\n+     *\n+     * @param node node\n+     * @return node position\n+     */\n+    static DiagnosticPos getPosition(Node node) {\n+        if (node == null) {\n+            return null;\n+        }\n+        LineRange range = node.lineRange();\n+        LinePosition startPos = range.startLine();\n+        LinePosition endPos = range.endLine();\n+        int startOffset = startPos.offset();\n+        if (node.kind() == (SyntaxKind.FUNCTION_DEFINITION) || node.kind() == (SyntaxKind.TYPE_DEFINITION) ||\n+                node.kind() == (SyntaxKind.CONST_DECLARATION) || node.kind() == (SyntaxKind.OBJECT_TYPE_DESC)) {\n+            startOffset = (startOffset / 4) * 4;\n+        }\n+        return new DiagnosticPos(null, startPos.line() + 1, endPos.line() + 1,\n+                startOffset, endPos.offset());\n+    }\n+\n+    // TODO: Use a generic way to get the parent node using querying.\n+    static <T extends Node> Node getParent(T node, SyntaxKind syntaxKind) {\n+        Node parent = node.parent();\n+        if (parent == null) {\n+            parent = node;\n+        }\n+        Node grandParent = parent.parent();\n+        SyntaxKind parentKind = parent.kind();\n+        if (parentKind == (SyntaxKind.MODULE_VAR_DECL)) {\n+            if (grandParent != null && grandParent.kind() == (SyntaxKind.MODULE_PART) &&\n+                    syntaxKind == (SyntaxKind.QUALIFIED_NAME_REFERENCE)) {\n+                return null;\n+            }\n+            return parent;\n+        } else if (parentKind == (SyntaxKind.FUNCTION_DEFINITION) ||\n+                parentKind == (SyntaxKind.ELSE_BLOCK) ||\n+                parentKind == (SyntaxKind.IF_ELSE_STATEMENT) ||\n+                parentKind == (SyntaxKind.LOCAL_TYPE_DEFINITION_STATEMENT) ||\n+                parentKind == (SyntaxKind.WHILE_STATEMENT) ||\n+                parentKind == (SyntaxKind.CONST_DECLARATION) ||\n+                parentKind == (SyntaxKind.METHOD_DECLARATION) ||\n+                parentKind == (SyntaxKind.TYPE_DEFINITION)) {\n+            return parent;\n+        } else if (syntaxKind == (SyntaxKind.SIMPLE_NAME_REFERENCE)) {\n+            if (parentKind == (SyntaxKind.REQUIRED_PARAM) ||\n+                    parentKind == (SyntaxKind.POSITIONAL_ARG) ||\n+                    parentKind == (SyntaxKind.BINARY_EXPRESSION) ||\n+                    parentKind == (SyntaxKind.BRACED_EXPRESSION) ||\n+                    parentKind == (SyntaxKind.RETURN_STATEMENT) ||\n+                    parentKind == (SyntaxKind.REMOTE_METHOD_CALL_ACTION) ||\n+                    parentKind == (SyntaxKind.FIELD_ACCESS) ||\n+                    (parentKind == (SyntaxKind.FUNCTION_CALL) && grandParent != null &&\n+                            grandParent.kind() == (SyntaxKind.ASSIGNMENT_STATEMENT))) {\n+                return null;\n+            }\n+            return getParent(parent, syntaxKind);\n+        } else if (syntaxKind == (SyntaxKind.STRING_TYPE_DESC) &&\n+                parentKind == (SyntaxKind.RECORD_FIELD) && grandParent != null &&\n+                grandParent.kind() == (SyntaxKind.RECORD_TYPE_DESC)) {\n+            return getParent(parent, syntaxKind);\n+        } else if (parentKind == (SyntaxKind.SERVICE_DECLARATION) ||\n+                parentKind == (SyntaxKind.BINARY_EXPRESSION)) {\n+            if (syntaxKind == (SyntaxKind.QUALIFIED_NAME_REFERENCE)) {\n+                return null;\n+            }\n+            return parent;\n+        } else if (parentKind == (SyntaxKind.REQUIRED_PARAM)) {\n+            return null;\n+        } else if (parentKind == (SyntaxKind.OBJECT_TYPE_DESC)) {\n+            if (grandParent != null && grandParent.kind() == (SyntaxKind.RETURN_TYPE_DESCRIPTOR)) {\n+                return grandParent.parent().parent();\n+            } else if (grandParent != null && grandParent.kind() == (SyntaxKind.TYPE_DEFINITION)) {\n+                return getParent(parent, syntaxKind);\n+            } else {\n+                return parent;\n+            }\n+        } else if (grandParent != null) {\n+            return getParent(parent, syntaxKind);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    static int getIndentation(Node node, int indentation, FormattingOptions formattingOptions) {\n+        if (node == null) {\n+            return indentation;\n+        }\n+        if (node.parent() != null) {\n+            SyntaxKind parentKind = node.parent().kind();\n+            if (parentKind == SyntaxKind.BLOCK_STATEMENT ||\n+                    parentKind == SyntaxKind.FUNCTION_BODY_BLOCK ||\n+                    parentKind == SyntaxKind.LIST_CONSTRUCTOR ||\n+                    parentKind == SyntaxKind.TYPE_DEFINITION ||\n+                    parentKind == SyntaxKind.METHOD_DECLARATION ||\n+                    parentKind == SyntaxKind.MAPPING_CONSTRUCTOR) {\n+                indentation += formattingOptions.getTabSize();\n+            }\n+        }\n+        return getIndentation(node.parent(), indentation, formattingOptions);\n+    }\n+\n+    private static MinutiaeList getCommentMinutiae(MinutiaeList minutiaeList, boolean isLeading) {\n+        MinutiaeList minutiaes = AbstractNodeFactory.createEmptyMinutiaeList();\n+        for (int i = 0; i < minutiaeList.size(); i++) {\n+            if (minutiaeList.get(i).kind() == (SyntaxKind.COMMENT_MINUTIAE)) {\n+                if (i > 0) {\n+                    minutiaes = minutiaes.add(minutiaeList.get(i - 1));\n+                }\n+                minutiaes = minutiaes.add(minutiaeList.get(i));\n+                if ((i + 1) < minutiaeList.size() && isLeading) {\n+                    minutiaes = minutiaes.add(minutiaeList.get(i + 1));\n+                }\n+            }\n+        }\n+        return minutiaes;\n+    }\n+\n+    private static String getWhiteSpaces(int column, int newLines) {\n+        StringBuilder whiteSpaces = new StringBuilder();\n+        for (int i = 0; i <= (newLines - 1); i++) {\n+            whiteSpaces.append(System.getProperty(LINE_SEPARATOR));\n+        }\n+        for (int i = 0; i <= (column - 1); i++) {\n+            whiteSpaces.append(\" \");\n+        }\n+        return whiteSpaces.toString();\n+    }\n+\n+    /**\n+     * Initialize the token with empty minutiae lists.\n+     *\n+     * @param node node\n+     * @return token with empty minutiae\n+     */\n+    static <T extends Token> Token getToken(T node) {\n+        if (node == null) {\n+            return node;\n+        }\n+        MinutiaeList leadingMinutiaeList = AbstractNodeFactory.createEmptyMinutiaeList();\n+        MinutiaeList trailingMinutiaeList = AbstractNodeFactory.createEmptyMinutiaeList();\n+        if (node.containsLeadingMinutiae()) {\n+            leadingMinutiaeList = getCommentMinutiae(node.leadingMinutiae(), true);\n+        }\n+        if (node.containsTrailingMinutiae()) {\n+            trailingMinutiaeList = getCommentMinutiae(node.trailingMinutiae(), false);\n+        }\n+        return node.modify(leadingMinutiaeList, trailingMinutiaeList);\n+    }\n+\n+    static boolean isInLineRange(Node node, LineRange lineRange) {\n+        if (lineRange == null) {\n+            return true;\n+        }\n+        int nodeStartLine = node.lineRange().startLine().line();\n+        int nodeStartOffset = node.lineRange().startLine().offset();\n+        int nodeEndLine = node.lineRange().endLine().line();\n+        int nodeEndOffset = node.lineRange().endLine().offset();\n+\n+        int startLine = lineRange.startLine().line();\n+        int startOffset = lineRange.startLine().offset();\n+        int endLine = lineRange.endLine().line();\n+        int endOffset = lineRange.endLine().offset();\n+\n+        if (nodeStartLine >= startLine && nodeEndLine <= endLine) {\n+            if (nodeStartLine == startLine || nodeEndLine == endLine) {\n+                return nodeStartOffset >= startOffset && nodeEndOffset <= endOffset;\n+            }\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Update the minutiae and return the token.\n+     *\n+     * @param token            token\n+     * @param leadingSpaces    leading spaces\n+     * @param trailingSpaces   trailing spaces\n+     * @param leadingNewLines  leading new lines\n+     * @param trailingNewLines trailing new lines\n+     * @return updated token\n+     */\n+    static Token formatToken(Token token, int leadingSpaces, int trailingSpaces, int leadingNewLines,\n+                             int trailingNewLines) {\n+        if (token == null) {\n+            return token;\n+        }\n+        MinutiaeList newLeadingMinutiaeList = modifyMinutiaeList(leadingSpaces, leadingNewLines);\n+        MinutiaeList newTrailingMinutiaeList = modifyMinutiaeList(trailingSpaces, trailingNewLines);\n+\n+        return token.modify(newLeadingMinutiaeList, newTrailingMinutiaeList);\n+    }\n+\n+    private static MinutiaeList modifyMinutiaeList(int spaces, int newLines) {\n+        Minutiae minutiae = createWhitespaceMinutiae(getWhiteSpaces(spaces, newLines));\n+        return createMinutiaeList(minutiae);\n+    }\n+\n+    private static int getChildLocation(NonTerminalNode parent, Node child) {\n+        if (parent != null && child != null) {\n+            for (int i = 0; i < parent.children().size(); i++) {\n+                if (parent.children().get(i).equals(child)) {\n+                    return i;\n+                }\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    private static int regexCount(String context, String pattern) {\n+        Matcher matcher = Pattern.compile(String.valueOf(pattern)).matcher(context);\n+        int response = 0;\n+        while (matcher.find()) {\n+            response++;\n+        }\n+        return response;\n+    }\n+\n+    private static Token getStartingToken(Node node) {\n+        if (node instanceof Token) {\n+            return (Token) node;\n+        }\n+        ChildNodeList childNodeList = ((NonTerminalNode) node).children();\n+        return getStartingToken(childNodeList.get(0));\n+    }\n+\n+    private static Token getEndingToken(Node node) {\n+        if (node instanceof Token) {\n+            return (Token) node;\n+        }\n+        ChildNodeList childNodeList = ((NonTerminalNode) node).children();\n+        return getStartingToken(childNodeList.get(childNodeList.size() - 1));\n+    }\n+\n+    static boolean preserveNewLine(NonTerminalNode node) {\n+        ArrayList<SyntaxKind> endTokens = new ArrayList<>(\n+                Arrays.asList(\n+                        SyntaxKind.CLOSE_BRACE_TOKEN,\n+                        SyntaxKind.CLOSE_BRACE_PIPE_TOKEN,\n+                        SyntaxKind.CLOSE_BRACKET_TOKEN,\n+                        SyntaxKind.CLOSE_PAREN_TOKEN));\n+        boolean preserve = false;\n+        MinutiaeList nodeEnd = getEndingToken(node).trailingMinutiae();\n+        if (nodeEnd.toString().contains(System.getProperty(LINE_SEPARATOR))) {\n+            int childIndex = getChildLocation(node.parent(), node);\n+            if (childIndex != -1) {\n+                Node nextNode = node.parent().children().get(childIndex + 1);\n+                if (nextNode != null && !endTokens.contains(nextNode.kind())) {\n+                    MinutiaeList siblingStart = getStartingToken(nextNode).leadingMinutiae();\n+                    int newLines = regexCount(nodeEnd.toString(), System.getProperty(LINE_SEPARATOR));\n+                    if (siblingStart.toString().contains(System.getProperty(LINE_SEPARATOR)) || newLines > 1) {\n+                        preserve = true;\n+                    }\n+                }\n+            }\n+        }\n+        return preserve;\n+    }\n+\n+    private static ArrayList<NonTerminalNode> nestedIfBlock(NonTerminalNode node) {\n+        NonTerminalNode parent = node.parent();\n+        ArrayList<NonTerminalNode> nestedParent = new ArrayList<>();\n+        if (parent == null) {\n+            return new ArrayList<>(0);\n+        } else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abf30d5163ce0ebdc71f6463696d834f80cc2f05"}, "originalPosition": 311}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzIwMDA1Ng==", "bodyText": "instead of returning null, is it possible to return the empty list?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25680#discussion_r487200056", "createdAt": "2020-09-11T17:53:44Z", "author": {"login": "nadeeshaan"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/FormatterUtils.java", "diffHunk": "@@ -0,0 +1,415 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.core;\n+\n+import io.ballerina.tools.text.LinePosition;\n+import io.ballerina.tools.text.LineRange;\n+import io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory;\n+import io.ballerinalang.compiler.syntax.tree.ChildNodeList;\n+import io.ballerinalang.compiler.syntax.tree.Minutiae;\n+import io.ballerinalang.compiler.syntax.tree.MinutiaeList;\n+import io.ballerinalang.compiler.syntax.tree.Node;\n+import io.ballerinalang.compiler.syntax.tree.NonTerminalNode;\n+import io.ballerinalang.compiler.syntax.tree.SyntaxKind;\n+import io.ballerinalang.compiler.syntax.tree.Token;\n+import org.wso2.ballerinalang.compiler.util.diagnotic.DiagnosticPos;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import static io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory.createMinutiaeList;\n+import static io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory.createWhitespaceMinutiae;\n+\n+/**\n+ * Class that contains the util functions used by the formatting tree modifier.\n+ */\n+class FormatterUtils {\n+\n+    private static final String LINE_SEPARATOR = \"line.separator\";\n+\n+    /**\n+     * Get the node position.\n+     *\n+     * @param node node\n+     * @return node position\n+     */\n+    static DiagnosticPos getPosition(Node node) {\n+        if (node == null) {\n+            return null;\n+        }\n+        LineRange range = node.lineRange();\n+        LinePosition startPos = range.startLine();\n+        LinePosition endPos = range.endLine();\n+        int startOffset = startPos.offset();\n+        if (node.kind() == (SyntaxKind.FUNCTION_DEFINITION) || node.kind() == (SyntaxKind.TYPE_DEFINITION) ||\n+                node.kind() == (SyntaxKind.CONST_DECLARATION) || node.kind() == (SyntaxKind.OBJECT_TYPE_DESC)) {\n+            startOffset = (startOffset / 4) * 4;\n+        }\n+        return new DiagnosticPos(null, startPos.line() + 1, endPos.line() + 1,\n+                startOffset, endPos.offset());\n+    }\n+\n+    // TODO: Use a generic way to get the parent node using querying.\n+    static <T extends Node> Node getParent(T node, SyntaxKind syntaxKind) {\n+        Node parent = node.parent();\n+        if (parent == null) {\n+            parent = node;\n+        }\n+        Node grandParent = parent.parent();\n+        SyntaxKind parentKind = parent.kind();\n+        if (parentKind == (SyntaxKind.MODULE_VAR_DECL)) {\n+            if (grandParent != null && grandParent.kind() == (SyntaxKind.MODULE_PART) &&\n+                    syntaxKind == (SyntaxKind.QUALIFIED_NAME_REFERENCE)) {\n+                return null;\n+            }\n+            return parent;\n+        } else if (parentKind == (SyntaxKind.FUNCTION_DEFINITION) ||\n+                parentKind == (SyntaxKind.ELSE_BLOCK) ||\n+                parentKind == (SyntaxKind.IF_ELSE_STATEMENT) ||\n+                parentKind == (SyntaxKind.LOCAL_TYPE_DEFINITION_STATEMENT) ||\n+                parentKind == (SyntaxKind.WHILE_STATEMENT) ||\n+                parentKind == (SyntaxKind.CONST_DECLARATION) ||\n+                parentKind == (SyntaxKind.METHOD_DECLARATION) ||\n+                parentKind == (SyntaxKind.TYPE_DEFINITION)) {\n+            return parent;\n+        } else if (syntaxKind == (SyntaxKind.SIMPLE_NAME_REFERENCE)) {\n+            if (parentKind == (SyntaxKind.REQUIRED_PARAM) ||\n+                    parentKind == (SyntaxKind.POSITIONAL_ARG) ||\n+                    parentKind == (SyntaxKind.BINARY_EXPRESSION) ||\n+                    parentKind == (SyntaxKind.BRACED_EXPRESSION) ||\n+                    parentKind == (SyntaxKind.RETURN_STATEMENT) ||\n+                    parentKind == (SyntaxKind.REMOTE_METHOD_CALL_ACTION) ||\n+                    parentKind == (SyntaxKind.FIELD_ACCESS) ||\n+                    (parentKind == (SyntaxKind.FUNCTION_CALL) && grandParent != null &&\n+                            grandParent.kind() == (SyntaxKind.ASSIGNMENT_STATEMENT))) {\n+                return null;\n+            }\n+            return getParent(parent, syntaxKind);\n+        } else if (syntaxKind == (SyntaxKind.STRING_TYPE_DESC) &&\n+                parentKind == (SyntaxKind.RECORD_FIELD) && grandParent != null &&\n+                grandParent.kind() == (SyntaxKind.RECORD_TYPE_DESC)) {\n+            return getParent(parent, syntaxKind);\n+        } else if (parentKind == (SyntaxKind.SERVICE_DECLARATION) ||\n+                parentKind == (SyntaxKind.BINARY_EXPRESSION)) {\n+            if (syntaxKind == (SyntaxKind.QUALIFIED_NAME_REFERENCE)) {\n+                return null;\n+            }\n+            return parent;\n+        } else if (parentKind == (SyntaxKind.REQUIRED_PARAM)) {\n+            return null;\n+        } else if (parentKind == (SyntaxKind.OBJECT_TYPE_DESC)) {\n+            if (grandParent != null && grandParent.kind() == (SyntaxKind.RETURN_TYPE_DESCRIPTOR)) {\n+                return grandParent.parent().parent();\n+            } else if (grandParent != null && grandParent.kind() == (SyntaxKind.TYPE_DEFINITION)) {\n+                return getParent(parent, syntaxKind);\n+            } else {\n+                return parent;\n+            }\n+        } else if (grandParent != null) {\n+            return getParent(parent, syntaxKind);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    static int getIndentation(Node node, int indentation, FormattingOptions formattingOptions) {\n+        if (node == null) {\n+            return indentation;\n+        }\n+        if (node.parent() != null) {\n+            SyntaxKind parentKind = node.parent().kind();\n+            if (parentKind == SyntaxKind.BLOCK_STATEMENT ||\n+                    parentKind == SyntaxKind.FUNCTION_BODY_BLOCK ||\n+                    parentKind == SyntaxKind.LIST_CONSTRUCTOR ||\n+                    parentKind == SyntaxKind.TYPE_DEFINITION ||\n+                    parentKind == SyntaxKind.METHOD_DECLARATION ||\n+                    parentKind == SyntaxKind.MAPPING_CONSTRUCTOR) {\n+                indentation += formattingOptions.getTabSize();\n+            }\n+        }\n+        return getIndentation(node.parent(), indentation, formattingOptions);\n+    }\n+\n+    private static MinutiaeList getCommentMinutiae(MinutiaeList minutiaeList, boolean isLeading) {\n+        MinutiaeList minutiaes = AbstractNodeFactory.createEmptyMinutiaeList();\n+        for (int i = 0; i < minutiaeList.size(); i++) {\n+            if (minutiaeList.get(i).kind() == (SyntaxKind.COMMENT_MINUTIAE)) {\n+                if (i > 0) {\n+                    minutiaes = minutiaes.add(minutiaeList.get(i - 1));\n+                }\n+                minutiaes = minutiaes.add(minutiaeList.get(i));\n+                if ((i + 1) < minutiaeList.size() && isLeading) {\n+                    minutiaes = minutiaes.add(minutiaeList.get(i + 1));\n+                }\n+            }\n+        }\n+        return minutiaes;\n+    }\n+\n+    private static String getWhiteSpaces(int column, int newLines) {\n+        StringBuilder whiteSpaces = new StringBuilder();\n+        for (int i = 0; i <= (newLines - 1); i++) {\n+            whiteSpaces.append(System.getProperty(LINE_SEPARATOR));\n+        }\n+        for (int i = 0; i <= (column - 1); i++) {\n+            whiteSpaces.append(\" \");\n+        }\n+        return whiteSpaces.toString();\n+    }\n+\n+    /**\n+     * Initialize the token with empty minutiae lists.\n+     *\n+     * @param node node\n+     * @return token with empty minutiae\n+     */\n+    static <T extends Token> Token getToken(T node) {\n+        if (node == null) {\n+            return node;\n+        }\n+        MinutiaeList leadingMinutiaeList = AbstractNodeFactory.createEmptyMinutiaeList();\n+        MinutiaeList trailingMinutiaeList = AbstractNodeFactory.createEmptyMinutiaeList();\n+        if (node.containsLeadingMinutiae()) {\n+            leadingMinutiaeList = getCommentMinutiae(node.leadingMinutiae(), true);\n+        }\n+        if (node.containsTrailingMinutiae()) {\n+            trailingMinutiaeList = getCommentMinutiae(node.trailingMinutiae(), false);\n+        }\n+        return node.modify(leadingMinutiaeList, trailingMinutiaeList);\n+    }\n+\n+    static boolean isInLineRange(Node node, LineRange lineRange) {\n+        if (lineRange == null) {\n+            return true;\n+        }\n+        int nodeStartLine = node.lineRange().startLine().line();\n+        int nodeStartOffset = node.lineRange().startLine().offset();\n+        int nodeEndLine = node.lineRange().endLine().line();\n+        int nodeEndOffset = node.lineRange().endLine().offset();\n+\n+        int startLine = lineRange.startLine().line();\n+        int startOffset = lineRange.startLine().offset();\n+        int endLine = lineRange.endLine().line();\n+        int endOffset = lineRange.endLine().offset();\n+\n+        if (nodeStartLine >= startLine && nodeEndLine <= endLine) {\n+            if (nodeStartLine == startLine || nodeEndLine == endLine) {\n+                return nodeStartOffset >= startOffset && nodeEndOffset <= endOffset;\n+            }\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Update the minutiae and return the token.\n+     *\n+     * @param token            token\n+     * @param leadingSpaces    leading spaces\n+     * @param trailingSpaces   trailing spaces\n+     * @param leadingNewLines  leading new lines\n+     * @param trailingNewLines trailing new lines\n+     * @return updated token\n+     */\n+    static Token formatToken(Token token, int leadingSpaces, int trailingSpaces, int leadingNewLines,\n+                             int trailingNewLines) {\n+        if (token == null) {\n+            return token;\n+        }\n+        MinutiaeList newLeadingMinutiaeList = modifyMinutiaeList(leadingSpaces, leadingNewLines);\n+        MinutiaeList newTrailingMinutiaeList = modifyMinutiaeList(trailingSpaces, trailingNewLines);\n+\n+        return token.modify(newLeadingMinutiaeList, newTrailingMinutiaeList);\n+    }\n+\n+    private static MinutiaeList modifyMinutiaeList(int spaces, int newLines) {\n+        Minutiae minutiae = createWhitespaceMinutiae(getWhiteSpaces(spaces, newLines));\n+        return createMinutiaeList(minutiae);\n+    }\n+\n+    private static int getChildLocation(NonTerminalNode parent, Node child) {\n+        if (parent != null && child != null) {\n+            for (int i = 0; i < parent.children().size(); i++) {\n+                if (parent.children().get(i).equals(child)) {\n+                    return i;\n+                }\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    private static int regexCount(String context, String pattern) {\n+        Matcher matcher = Pattern.compile(String.valueOf(pattern)).matcher(context);\n+        int response = 0;\n+        while (matcher.find()) {\n+            response++;\n+        }\n+        return response;\n+    }\n+\n+    private static Token getStartingToken(Node node) {\n+        if (node instanceof Token) {\n+            return (Token) node;\n+        }\n+        ChildNodeList childNodeList = ((NonTerminalNode) node).children();\n+        return getStartingToken(childNodeList.get(0));\n+    }\n+\n+    private static Token getEndingToken(Node node) {\n+        if (node instanceof Token) {\n+            return (Token) node;\n+        }\n+        ChildNodeList childNodeList = ((NonTerminalNode) node).children();\n+        return getStartingToken(childNodeList.get(childNodeList.size() - 1));\n+    }\n+\n+    static boolean preserveNewLine(NonTerminalNode node) {\n+        ArrayList<SyntaxKind> endTokens = new ArrayList<>(\n+                Arrays.asList(\n+                        SyntaxKind.CLOSE_BRACE_TOKEN,\n+                        SyntaxKind.CLOSE_BRACE_PIPE_TOKEN,\n+                        SyntaxKind.CLOSE_BRACKET_TOKEN,\n+                        SyntaxKind.CLOSE_PAREN_TOKEN));\n+        boolean preserve = false;\n+        MinutiaeList nodeEnd = getEndingToken(node).trailingMinutiae();\n+        if (nodeEnd.toString().contains(System.getProperty(LINE_SEPARATOR))) {\n+            int childIndex = getChildLocation(node.parent(), node);\n+            if (childIndex != -1) {\n+                Node nextNode = node.parent().children().get(childIndex + 1);\n+                if (nextNode != null && !endTokens.contains(nextNode.kind())) {\n+                    MinutiaeList siblingStart = getStartingToken(nextNode).leadingMinutiae();\n+                    int newLines = regexCount(nodeEnd.toString(), System.getProperty(LINE_SEPARATOR));\n+                    if (siblingStart.toString().contains(System.getProperty(LINE_SEPARATOR)) || newLines > 1) {\n+                        preserve = true;\n+                    }\n+                }\n+            }\n+        }\n+        return preserve;\n+    }\n+\n+    private static ArrayList<NonTerminalNode> nestedIfBlock(NonTerminalNode node) {\n+        NonTerminalNode parent = node.parent();\n+        ArrayList<NonTerminalNode> nestedParent = new ArrayList<>();\n+        if (parent == null) {\n+            return new ArrayList<>(0);\n+        } else {\n+            while (parent != null) {\n+                if (parent.kind() == (node.kind())) {\n+                    nestedParent.add(parent);\n+                }\n+                parent = parent.parent();\n+            }\n+        }\n+        return nestedParent.isEmpty() ? null : nestedParent;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abf30d5163ce0ebdc71f6463696d834f80cc2f05"}, "originalPosition": 319}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzIwMDk4MA==", "bodyText": "let's remove the else-if ladder and stick to the if clauses since each clause have a return", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25680#discussion_r487200980", "createdAt": "2020-09-11T17:55:30Z", "author": {"login": "nadeeshaan"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/FormatterUtils.java", "diffHunk": "@@ -0,0 +1,415 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.core;\n+\n+import io.ballerina.tools.text.LinePosition;\n+import io.ballerina.tools.text.LineRange;\n+import io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory;\n+import io.ballerinalang.compiler.syntax.tree.ChildNodeList;\n+import io.ballerinalang.compiler.syntax.tree.Minutiae;\n+import io.ballerinalang.compiler.syntax.tree.MinutiaeList;\n+import io.ballerinalang.compiler.syntax.tree.Node;\n+import io.ballerinalang.compiler.syntax.tree.NonTerminalNode;\n+import io.ballerinalang.compiler.syntax.tree.SyntaxKind;\n+import io.ballerinalang.compiler.syntax.tree.Token;\n+import org.wso2.ballerinalang.compiler.util.diagnotic.DiagnosticPos;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import static io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory.createMinutiaeList;\n+import static io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory.createWhitespaceMinutiae;\n+\n+/**\n+ * Class that contains the util functions used by the formatting tree modifier.\n+ */\n+class FormatterUtils {\n+\n+    private static final String LINE_SEPARATOR = \"line.separator\";\n+\n+    /**\n+     * Get the node position.\n+     *\n+     * @param node node\n+     * @return node position\n+     */\n+    static DiagnosticPos getPosition(Node node) {\n+        if (node == null) {\n+            return null;\n+        }\n+        LineRange range = node.lineRange();\n+        LinePosition startPos = range.startLine();\n+        LinePosition endPos = range.endLine();\n+        int startOffset = startPos.offset();\n+        if (node.kind() == (SyntaxKind.FUNCTION_DEFINITION) || node.kind() == (SyntaxKind.TYPE_DEFINITION) ||\n+                node.kind() == (SyntaxKind.CONST_DECLARATION) || node.kind() == (SyntaxKind.OBJECT_TYPE_DESC)) {\n+            startOffset = (startOffset / 4) * 4;\n+        }\n+        return new DiagnosticPos(null, startPos.line() + 1, endPos.line() + 1,\n+                startOffset, endPos.offset());\n+    }\n+\n+    // TODO: Use a generic way to get the parent node using querying.\n+    static <T extends Node> Node getParent(T node, SyntaxKind syntaxKind) {\n+        Node parent = node.parent();\n+        if (parent == null) {\n+            parent = node;\n+        }\n+        Node grandParent = parent.parent();\n+        SyntaxKind parentKind = parent.kind();\n+        if (parentKind == (SyntaxKind.MODULE_VAR_DECL)) {\n+            if (grandParent != null && grandParent.kind() == (SyntaxKind.MODULE_PART) &&\n+                    syntaxKind == (SyntaxKind.QUALIFIED_NAME_REFERENCE)) {\n+                return null;\n+            }\n+            return parent;\n+        } else if (parentKind == (SyntaxKind.FUNCTION_DEFINITION) ||\n+                parentKind == (SyntaxKind.ELSE_BLOCK) ||\n+                parentKind == (SyntaxKind.IF_ELSE_STATEMENT) ||\n+                parentKind == (SyntaxKind.LOCAL_TYPE_DEFINITION_STATEMENT) ||\n+                parentKind == (SyntaxKind.WHILE_STATEMENT) ||\n+                parentKind == (SyntaxKind.CONST_DECLARATION) ||\n+                parentKind == (SyntaxKind.METHOD_DECLARATION) ||\n+                parentKind == (SyntaxKind.TYPE_DEFINITION)) {\n+            return parent;\n+        } else if (syntaxKind == (SyntaxKind.SIMPLE_NAME_REFERENCE)) {\n+            if (parentKind == (SyntaxKind.REQUIRED_PARAM) ||\n+                    parentKind == (SyntaxKind.POSITIONAL_ARG) ||\n+                    parentKind == (SyntaxKind.BINARY_EXPRESSION) ||\n+                    parentKind == (SyntaxKind.BRACED_EXPRESSION) ||\n+                    parentKind == (SyntaxKind.RETURN_STATEMENT) ||\n+                    parentKind == (SyntaxKind.REMOTE_METHOD_CALL_ACTION) ||\n+                    parentKind == (SyntaxKind.FIELD_ACCESS) ||\n+                    (parentKind == (SyntaxKind.FUNCTION_CALL) && grandParent != null &&\n+                            grandParent.kind() == (SyntaxKind.ASSIGNMENT_STATEMENT))) {\n+                return null;\n+            }\n+            return getParent(parent, syntaxKind);\n+        } else if (syntaxKind == (SyntaxKind.STRING_TYPE_DESC) &&\n+                parentKind == (SyntaxKind.RECORD_FIELD) && grandParent != null &&\n+                grandParent.kind() == (SyntaxKind.RECORD_TYPE_DESC)) {\n+            return getParent(parent, syntaxKind);\n+        } else if (parentKind == (SyntaxKind.SERVICE_DECLARATION) ||\n+                parentKind == (SyntaxKind.BINARY_EXPRESSION)) {\n+            if (syntaxKind == (SyntaxKind.QUALIFIED_NAME_REFERENCE)) {\n+                return null;\n+            }\n+            return parent;\n+        } else if (parentKind == (SyntaxKind.REQUIRED_PARAM)) {\n+            return null;\n+        } else if (parentKind == (SyntaxKind.OBJECT_TYPE_DESC)) {\n+            if (grandParent != null && grandParent.kind() == (SyntaxKind.RETURN_TYPE_DESCRIPTOR)) {\n+                return grandParent.parent().parent();\n+            } else if (grandParent != null && grandParent.kind() == (SyntaxKind.TYPE_DEFINITION)) {\n+                return getParent(parent, syntaxKind);\n+            } else {\n+                return parent;\n+            }\n+        } else if (grandParent != null) {\n+            return getParent(parent, syntaxKind);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    static int getIndentation(Node node, int indentation, FormattingOptions formattingOptions) {\n+        if (node == null) {\n+            return indentation;\n+        }\n+        if (node.parent() != null) {\n+            SyntaxKind parentKind = node.parent().kind();\n+            if (parentKind == SyntaxKind.BLOCK_STATEMENT ||\n+                    parentKind == SyntaxKind.FUNCTION_BODY_BLOCK ||\n+                    parentKind == SyntaxKind.LIST_CONSTRUCTOR ||\n+                    parentKind == SyntaxKind.TYPE_DEFINITION ||\n+                    parentKind == SyntaxKind.METHOD_DECLARATION ||\n+                    parentKind == SyntaxKind.MAPPING_CONSTRUCTOR) {\n+                indentation += formattingOptions.getTabSize();\n+            }\n+        }\n+        return getIndentation(node.parent(), indentation, formattingOptions);\n+    }\n+\n+    private static MinutiaeList getCommentMinutiae(MinutiaeList minutiaeList, boolean isLeading) {\n+        MinutiaeList minutiaes = AbstractNodeFactory.createEmptyMinutiaeList();\n+        for (int i = 0; i < minutiaeList.size(); i++) {\n+            if (minutiaeList.get(i).kind() == (SyntaxKind.COMMENT_MINUTIAE)) {\n+                if (i > 0) {\n+                    minutiaes = minutiaes.add(minutiaeList.get(i - 1));\n+                }\n+                minutiaes = minutiaes.add(minutiaeList.get(i));\n+                if ((i + 1) < minutiaeList.size() && isLeading) {\n+                    minutiaes = minutiaes.add(minutiaeList.get(i + 1));\n+                }\n+            }\n+        }\n+        return minutiaes;\n+    }\n+\n+    private static String getWhiteSpaces(int column, int newLines) {\n+        StringBuilder whiteSpaces = new StringBuilder();\n+        for (int i = 0; i <= (newLines - 1); i++) {\n+            whiteSpaces.append(System.getProperty(LINE_SEPARATOR));\n+        }\n+        for (int i = 0; i <= (column - 1); i++) {\n+            whiteSpaces.append(\" \");\n+        }\n+        return whiteSpaces.toString();\n+    }\n+\n+    /**\n+     * Initialize the token with empty minutiae lists.\n+     *\n+     * @param node node\n+     * @return token with empty minutiae\n+     */\n+    static <T extends Token> Token getToken(T node) {\n+        if (node == null) {\n+            return node;\n+        }\n+        MinutiaeList leadingMinutiaeList = AbstractNodeFactory.createEmptyMinutiaeList();\n+        MinutiaeList trailingMinutiaeList = AbstractNodeFactory.createEmptyMinutiaeList();\n+        if (node.containsLeadingMinutiae()) {\n+            leadingMinutiaeList = getCommentMinutiae(node.leadingMinutiae(), true);\n+        }\n+        if (node.containsTrailingMinutiae()) {\n+            trailingMinutiaeList = getCommentMinutiae(node.trailingMinutiae(), false);\n+        }\n+        return node.modify(leadingMinutiaeList, trailingMinutiaeList);\n+    }\n+\n+    static boolean isInLineRange(Node node, LineRange lineRange) {\n+        if (lineRange == null) {\n+            return true;\n+        }\n+        int nodeStartLine = node.lineRange().startLine().line();\n+        int nodeStartOffset = node.lineRange().startLine().offset();\n+        int nodeEndLine = node.lineRange().endLine().line();\n+        int nodeEndOffset = node.lineRange().endLine().offset();\n+\n+        int startLine = lineRange.startLine().line();\n+        int startOffset = lineRange.startLine().offset();\n+        int endLine = lineRange.endLine().line();\n+        int endOffset = lineRange.endLine().offset();\n+\n+        if (nodeStartLine >= startLine && nodeEndLine <= endLine) {\n+            if (nodeStartLine == startLine || nodeEndLine == endLine) {\n+                return nodeStartOffset >= startOffset && nodeEndOffset <= endOffset;\n+            }\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Update the minutiae and return the token.\n+     *\n+     * @param token            token\n+     * @param leadingSpaces    leading spaces\n+     * @param trailingSpaces   trailing spaces\n+     * @param leadingNewLines  leading new lines\n+     * @param trailingNewLines trailing new lines\n+     * @return updated token\n+     */\n+    static Token formatToken(Token token, int leadingSpaces, int trailingSpaces, int leadingNewLines,\n+                             int trailingNewLines) {\n+        if (token == null) {\n+            return token;\n+        }\n+        MinutiaeList newLeadingMinutiaeList = modifyMinutiaeList(leadingSpaces, leadingNewLines);\n+        MinutiaeList newTrailingMinutiaeList = modifyMinutiaeList(trailingSpaces, trailingNewLines);\n+\n+        return token.modify(newLeadingMinutiaeList, newTrailingMinutiaeList);\n+    }\n+\n+    private static MinutiaeList modifyMinutiaeList(int spaces, int newLines) {\n+        Minutiae minutiae = createWhitespaceMinutiae(getWhiteSpaces(spaces, newLines));\n+        return createMinutiaeList(minutiae);\n+    }\n+\n+    private static int getChildLocation(NonTerminalNode parent, Node child) {\n+        if (parent != null && child != null) {\n+            for (int i = 0; i < parent.children().size(); i++) {\n+                if (parent.children().get(i).equals(child)) {\n+                    return i;\n+                }\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    private static int regexCount(String context, String pattern) {\n+        Matcher matcher = Pattern.compile(String.valueOf(pattern)).matcher(context);\n+        int response = 0;\n+        while (matcher.find()) {\n+            response++;\n+        }\n+        return response;\n+    }\n+\n+    private static Token getStartingToken(Node node) {\n+        if (node instanceof Token) {\n+            return (Token) node;\n+        }\n+        ChildNodeList childNodeList = ((NonTerminalNode) node).children();\n+        return getStartingToken(childNodeList.get(0));\n+    }\n+\n+    private static Token getEndingToken(Node node) {\n+        if (node instanceof Token) {\n+            return (Token) node;\n+        }\n+        ChildNodeList childNodeList = ((NonTerminalNode) node).children();\n+        return getStartingToken(childNodeList.get(childNodeList.size() - 1));\n+    }\n+\n+    static boolean preserveNewLine(NonTerminalNode node) {\n+        ArrayList<SyntaxKind> endTokens = new ArrayList<>(\n+                Arrays.asList(\n+                        SyntaxKind.CLOSE_BRACE_TOKEN,\n+                        SyntaxKind.CLOSE_BRACE_PIPE_TOKEN,\n+                        SyntaxKind.CLOSE_BRACKET_TOKEN,\n+                        SyntaxKind.CLOSE_PAREN_TOKEN));\n+        boolean preserve = false;\n+        MinutiaeList nodeEnd = getEndingToken(node).trailingMinutiae();\n+        if (nodeEnd.toString().contains(System.getProperty(LINE_SEPARATOR))) {\n+            int childIndex = getChildLocation(node.parent(), node);\n+            if (childIndex != -1) {\n+                Node nextNode = node.parent().children().get(childIndex + 1);\n+                if (nextNode != null && !endTokens.contains(nextNode.kind())) {\n+                    MinutiaeList siblingStart = getStartingToken(nextNode).leadingMinutiae();\n+                    int newLines = regexCount(nodeEnd.toString(), System.getProperty(LINE_SEPARATOR));\n+                    if (siblingStart.toString().contains(System.getProperty(LINE_SEPARATOR)) || newLines > 1) {\n+                        preserve = true;\n+                    }\n+                }\n+            }\n+        }\n+        return preserve;\n+    }\n+\n+    private static ArrayList<NonTerminalNode> nestedIfBlock(NonTerminalNode node) {\n+        NonTerminalNode parent = node.parent();\n+        ArrayList<NonTerminalNode> nestedParent = new ArrayList<>();\n+        if (parent == null) {\n+            return new ArrayList<>(0);\n+        } else {\n+            while (parent != null) {\n+                if (parent.kind() == (node.kind())) {\n+                    nestedParent.add(parent);\n+                }\n+                parent = parent.parent();\n+            }\n+        }\n+        return nestedParent.isEmpty() ? null : nestedParent;\n+    }\n+\n+    /**\n+     * return the indented start column.\n+     *\n+     * @param node       node\n+     * @param addSpaces  add spaces or not\n+     * @return start position\n+     */\n+    static int getStartColumn(Node node, boolean addSpaces, FormattingOptions formattingOptions) {\n+        Node parent;\n+        if (node.kind() == (SyntaxKind.IF_ELSE_STATEMENT)) {\n+            Indentation indent = getIfElseParent((NonTerminalNode) node);\n+            parent = indent.getParent();\n+            addSpaces = indent.getAddSpaces();\n+        } else if (node.kind() == (SyntaxKind.BLOCK_STATEMENT)) {\n+            Indentation indent = getBlockParent(node);\n+            parent = indent.getParent();\n+            addSpaces = indent.getAddSpaces();\n+        } else {\n+            parent = getParent(node, node.kind());\n+        }\n+        if (parent != null) {\n+            int indentation = 0;\n+            if (addSpaces) {\n+                indentation = (FormatterUtils.getIndentation(node, 0, formattingOptions));\n+            }\n+            return getPosition(parent).sCol + indentation;\n+        }\n+        return 0;\n+    }\n+\n+    private static Indentation getIfElseParent(NonTerminalNode node) {\n+        NonTerminalNode parent = node.parent();\n+        if (parent == null) {\n+            parent = node;\n+        }\n+        if (parent.kind() == (SyntaxKind.FUNCTION_DEFINITION)) {\n+            return new Indentation(parent, true);\n+        } else if (parent.parent() != null) {\n+            return getIfElseParent(parent);\n+        }\n+        return new Indentation(null, false);\n+    }\n+\n+    private static Indentation getBlockParent(Node node) {\n+        Node parent = node.parent();\n+        if (parent == null) {\n+            parent = node;\n+        }\n+        ArrayList<SyntaxKind> parentWithSpaces = new ArrayList<>(\n+                Arrays.asList(\n+                        SyntaxKind.WHILE_STATEMENT,\n+                        SyntaxKind.FUNCTION_DEFINITION));\n+        ArrayList<SyntaxKind> parentWithoutSpaces = new ArrayList<>(\n+                Arrays.asList(\n+                        SyntaxKind.NAMED_WORKER_DECLARATION,\n+                        SyntaxKind.LOCAL_VAR_DECL,\n+                        SyntaxKind.FOREACH_STATEMENT));\n+\n+        if (parentWithSpaces.contains(parent.kind())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abf30d5163ce0ebdc71f6463696d834f80cc2f05"}, "originalPosition": 380}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzIwMTkxMw==", "bodyText": "Any reason to omit the type parameter of the List?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25680#discussion_r487201913", "createdAt": "2020-09-11T17:57:17Z", "author": {"login": "nadeeshaan"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NodeIndentation.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.core;\n+\n+import io.ballerinalang.compiler.syntax.tree.Node;\n+import io.ballerinalang.compiler.syntax.tree.NonTerminalNode;\n+import io.ballerinalang.compiler.syntax.tree.ObjectFieldNode;\n+import io.ballerinalang.compiler.syntax.tree.SyntaxKind;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static org.ballerinalang.formatter.core.FormatterUtils.getStartColumn;\n+\n+/**\n+ * Class that computes the formatting indentation for a particular node.\n+ */\n+class NodeIndentation {\n+\n+    private NodeIndentation() {\n+\n+    }\n+\n+    static int builtinSimpleNameReferenceNode(Node node, FormattingOptions options) {\n+        NonTerminalNode parent = node.parent();\n+        NonTerminalNode grandParent = null;\n+        if (parent != null) {\n+            grandParent = parent.parent();\n+        }\n+        boolean addSpaces = true;\n+        List parentNodes = Arrays.asList(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abf30d5163ce0ebdc71f6463696d834f80cc2f05"}, "originalPosition": 45}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "be0004ea9e643a30dbb949c4f229c6d4ef2cff6e", "author": {"user": {"login": "IrushiL", "name": "Irushi Liyanage"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/be0004ea9e643a30dbb949c4f229c6d4ef2cff6e", "committedDate": "2020-09-11T22:35:38Z", "message": "Enable test case scenarios"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b8a6d427b72da7ed6bef5fd6903e35765e5abb83", "author": {"user": {"login": "IrushiL", "name": "Irushi Liyanage"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b8a6d427b72da7ed6bef5fd6903e35765e5abb83", "committedDate": "2020-09-14T01:54:50Z", "message": "Fix review comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg3MzkyOTIx", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25680#pullrequestreview-487392921", "createdAt": "2020-09-14T03:25:59Z", "commit": {"oid": "b8a6d427b72da7ed6bef5fd6903e35765e5abb83"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg3Mzk0NTUx", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25680#pullrequestreview-487394551", "createdAt": "2020-09-14T03:32:54Z", "commit": {"oid": "b8a6d427b72da7ed6bef5fd6903e35765e5abb83"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4687, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}