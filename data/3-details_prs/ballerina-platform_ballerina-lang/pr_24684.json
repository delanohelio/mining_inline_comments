{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ2OTY4MTkx", "number": 24684, "title": "Enable documentaion tests for new parser", "bodyText": "Purpose\n\nEnable documentation tests for new parser\nRevamp markdown documentation parsing added by #24515\n\nApproach\nN/A\nSamples\nN/A\nRemarks\nN/A\nCheck List\n\n Read the Contributing Guide\n Updated Change Log\n Checked Tooling Support (#)\n Added necessary tests\n\n Unit Tests\n Spec Conformance Tests\n Integration Tests\n Ballerina By Example Tests\n\n\n Increased Test Coverage\n Added necessary documentation\n\n API documentation\n Module documentation in Module.md files\n Ballerina By Examples", "createdAt": "2020-07-09T16:29:21Z", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24684", "merged": true, "mergeCommit": {"oid": "618d9209d8392351a5f46381a1ebe6c3e5a4200d"}, "closed": true, "closedAt": "2020-07-14T08:09:06Z", "author": {"login": "lochana-chathura"}, "timelineItems": {"totalCount": 30, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcy20VeAH2gAyNDQ2OTY4MTkxOjI2M2Y0YmExMjRhMGNkNzM0ZDljZTBhNjY2MThmNDA5NTliNWQ4ZjU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc0xYHbAFqTQ0Nzg3ODEzNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "263f4ba124a0cd734d9ce0a66618f40959b5d8f5", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/263f4ba124a0cd734d9ce0a66618f40959b5d8f5", "committedDate": "2020-07-08T09:14:20Z", "message": "Fix trivia capturing for the hash token"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9d38e1d25c983920481c21e7f0a3aed17db1bd81", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/9d38e1d25c983920481c21e7f0a3aed17db1bd81", "committedDate": "2020-07-08T10:21:04Z", "message": "Fix parameter name capturing in the lexer"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f30f7cb37f3c2ce743eab040c311cc614005d29e", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f30f7cb37f3c2ce743eab040c311cc614005d29e", "committedDate": "2020-07-08T10:32:35Z", "message": "Fix node transformer for multiline documentation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5054e3ca471a8c91bceb5623f2c66a09e85e78a0", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/5054e3ca471a8c91bceb5623f2c66a09e85e78a0", "committedDate": "2020-07-09T04:00:48Z", "message": "Fix diagnostic positions for documentation in node transformer"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a2e5a99318a589ab4ef2bc597e6e3bcbf61f3a0e", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a2e5a99318a589ab4ef2bc597e6e3bcbf61f3a0e", "committedDate": "2020-07-09T05:08:07Z", "message": "Add \"const\" keyword to the special keywords supported by BFM"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3fc6264fe88f0d345fe26038eea1f0adc33d2aa2", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3fc6264fe88f0d345fe26038eea1f0adc33d2aa2", "committedDate": "2020-07-09T09:34:44Z", "message": "Fix documentation for object fields and change getTextWithWhitespaceTrivia logic in node transformer"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5da380e3c78a638ddea1d17b97c0e0df80d83995", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/5da380e3c78a638ddea1d17b97c0e0df80d83995", "committedDate": "2020-07-09T12:27:44Z", "message": "Fix trivia capturing for documentation tokens"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "41152096bf954ebb02ed7604cf0d6c68b9264f5f", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/41152096bf954ebb02ed7604cf0d6c68b9264f5f", "committedDate": "2020-07-09T12:34:13Z", "message": "Fix node transformer for wrong diagnostic positions in doc and update doc text logic for the lexer changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3432d0d67aacf680b66d301b12d8fbc0fb3db1ec", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3432d0d67aacf680b66d301b12d8fbc0fb3db1ec", "committedDate": "2020-07-09T14:09:26Z", "message": "Fix testMultilineDocsWithDeprecation failing"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "436fcdac71daf6ad78df21a3da4636b3de740722", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/436fcdac71daf6ad78df21a3da4636b3de740722", "committedDate": "2020-07-09T16:17:36Z", "message": "Fix tests with deprecated annotation failing with a runtime exception"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ1Nzg1NzM1", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24684#pullrequestreview-445785735", "createdAt": "2020-07-09T16:35:48Z", "commit": {"oid": "5fdaef55ff3320891ad724ff67bfc7022653132f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNjozNTo0OFrOGvZD6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNjozNTo0OFrOGvZD6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM0Njg1Nw==", "bodyText": "Support for the special keyword const was added, as it is going to be included in the spec. (ballerina-platform/ballerina-spec#336)\nKeyword is already supported in the DocumentationAnalyzer and used in the unit tests as well.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24684#discussion_r452346857", "createdAt": "2020-07-09T16:35:48Z", "author": {"login": "lochana-chathura"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaLexer.java", "diffHunk": "@@ -1719,6 +1750,7 @@ private boolean processDocumentationReference(int nextChar) {\n             case LexerTerminals.MODULE:\n             case LexerTerminals.FUNCTION:\n             case LexerTerminals.PARAMETER:\n+            case LexerTerminals.CONST:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5fdaef55ff3320891ad724ff67bfc7022653132f"}, "originalPosition": 89}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3fd9b6c8d501850fc7fb98efd7167f502bcf3c4a", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3fd9b6c8d501850fc7fb98efd7167f502bcf3c4a", "committedDate": "2020-07-09T16:40:05Z", "message": "Enable DocumentationAnalyzer for new parser and all documentation unit tests"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5fdaef55ff3320891ad724ff67bfc7022653132f", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/5fdaef55ff3320891ad724ff67bfc7022653132f", "committedDate": "2020-07-09T16:21:35Z", "message": "Enable DocumentationAnalyzer for new parser and all documentation unit tests"}, "afterCommit": {"oid": "3fd9b6c8d501850fc7fb98efd7167f502bcf3c4a", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3fd9b6c8d501850fc7fb98efd7167f502bcf3c4a", "committedDate": "2020-07-09T16:40:05Z", "message": "Enable DocumentationAnalyzer for new parser and all documentation unit tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2MTA1MzEy", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24684#pullrequestreview-446105312", "createdAt": "2020-07-10T03:51:47Z", "commit": {"oid": "3fd9b6c8d501850fc7fb98efd7167f502bcf3c4a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwMzo1MTo0N1rOGvpA8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwMzo1MTo0N1rOGvpA8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjYwODI0MA==", "bodyText": "IMO amount of leading whitespaces shouldn't matter.\nIs it possible to send this from the lexer itself, as a token?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24684#discussion_r452608240", "createdAt": "2020-07-10T03:51:47Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -12815,7 +12815,7 @@ private STNode parseDocumentationLine(STNode hashToken) {\n             case 1:\n                 STNode docElement = docElements.get(0);\n                 if (docElement.kind == SyntaxKind.DOCUMENTATION_DESCRIPTION) {\n-                    if (((STToken) docElement).text().startsWith(\"# Deprecated\")) {\n+                    if (((STToken) docElement).text().startsWith(\" # Deprecated\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3fd9b6c8d501850fc7fb98efd7167f502bcf3c4a"}, "originalPosition": 5}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b7587b9d8be02e0ab4febbef9f517b317becad98", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b7587b9d8be02e0ab4febbef9f517b317becad98", "committedDate": "2020-07-10T09:05:44Z", "message": "Add deprecation literal support from lexer"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8e12d1a8bceec6c1a55ddda07761eee8045f4847", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/8e12d1a8bceec6c1a55ddda07761eee8045f4847", "committedDate": "2020-07-10T08:39:44Z", "message": "Add deprecation literal support from lexer"}, "afterCommit": {"oid": "b7587b9d8be02e0ab4febbef9f517b317becad98", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b7587b9d8be02e0ab4febbef9f517b317becad98", "committedDate": "2020-07-10T09:05:44Z", "message": "Add deprecation literal support from lexer"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "df475bac38759853611065cb316b663e0b6acc31", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/df475bac38759853611065cb316b663e0b6acc31", "committedDate": "2020-07-10T09:31:32Z", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into doc-support"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "56c5202c60fceab2e57c3acec5150d564a9cd375", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/56c5202c60fceab2e57c3acec5150d564a9cd375", "committedDate": "2020-07-10T11:13:12Z", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into doc-support"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ea914c6e27a2591e0de66f268f3957a88134d37a", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/ea914c6e27a2591e0de66f268f3957a88134d37a", "committedDate": "2020-07-10T11:22:31Z", "message": "Fix build failing due to wrong doc parameter name from upstream"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2MzM0ODc4", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24684#pullrequestreview-446334878", "createdAt": "2020-07-10T11:42:44Z", "commit": {"oid": "ea914c6e27a2591e0de66f268f3957a88134d37a"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxMTo0Mjo0NFrOGv0Pfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxMTo1MzoyN1rOGv0gBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc5MjE5MQ==", "bodyText": "we can do this in a better-performance way:\nchar[] deprecatedChars = {'D', 'E', 'P', 'R', 'E', 'C', 'A', 'T', 'E', 'D' };\n\nif ((char) lookAheadChar != deprecatedChars[i]) {\n}", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24684#discussion_r452792191", "createdAt": "2020-07-10T11:42:44Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaLexer.java", "diffHunk": "@@ -1578,13 +1598,60 @@ private STToken readTokenInBracedContentInInterpolation() {\n      */\n \n     private STToken readDocumentationToken() {\n-        int nextChar = peek();\n-        if (nextChar == LexerTerminals.PLUS) {\n+        // Look ahead and see if next non-trivial char is a plus char or a hash char.\n+        // If it is a plus char, process trivial chars as leading trivia of the plus token.\n+        // If it is a hash char, look ahead and see if it is followed by a deprecation literal.\n+        // Else, let trivial chars be a part of the documentation description.\n+        int lookAheadCount = 0;\n+        int lookAheadChar = reader.peek(lookAheadCount);\n+        while (lookAheadChar == LexerTerminals.SPACE || lookAheadChar == LexerTerminals.TAB) {\n+            lookAheadCount++;\n+            lookAheadChar = reader.peek(lookAheadCount);\n+        }\n+\n+        if (lookAheadChar == LexerTerminals.PLUS) {\n+            return processPlusToken();\n+        } else if (lookAheadChar == LexerTerminals.HASH) {\n+            return processDeprecationLiteralToken(lookAheadCount);\n+        } else {\n+            return readDocumentationInternalToken();\n+        }\n+    }\n+\n+    private STToken processPlusToken() {\n+        processLeadingTrivia();\n+        reader.advance();\n+        switchMode(ParserMode.DOCUMENTATION_PARAMETER);\n+        return getDocumentationSyntaxToken(SyntaxKind.PLUS_TOKEN);\n+    }\n+\n+    private STToken processDeprecationLiteralToken(int lookAheadCount) {\n+        // Look ahead and see if next non-trivial char belongs to a deprecation literal.\n+        // There could be spaces and tabs in between.\n+        lookAheadCount++;\n+        int lookAheadChar = reader.peek(lookAheadCount);\n+        while (lookAheadChar == LexerTerminals.SPACE || lookAheadChar == LexerTerminals.TAB) {\n+            lookAheadCount++;\n+            lookAheadChar = reader.peek(lookAheadCount);\n+        }\n+\n+        // Look ahead for a \"Deprecated\" word match.\n+        for (int i = 0; i < 10; i++) {\n+            if ((char) lookAheadChar != LexerTerminals.DEPRECATED.charAt(i)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea914c6e27a2591e0de66f268f3957a88134d37a"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc5NjQyMw==", "bodyText": "why do we need this while loop?\nis it possible to avoid getLexeme().endsWith(LexerTerminals.DEPRECATED) check? Coz regex-related operations on top of java Strings (such as contains(), endsWith(), startsWith(), etc ) can be really expensive..", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24684#discussion_r452796423", "createdAt": "2020-07-10T11:53:27Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaLexer.java", "diffHunk": "@@ -1578,13 +1598,60 @@ private STToken readTokenInBracedContentInInterpolation() {\n      */\n \n     private STToken readDocumentationToken() {\n-        int nextChar = peek();\n-        if (nextChar == LexerTerminals.PLUS) {\n+        // Look ahead and see if next non-trivial char is a plus char or a hash char.\n+        // If it is a plus char, process trivial chars as leading trivia of the plus token.\n+        // If it is a hash char, look ahead and see if it is followed by a deprecation literal.\n+        // Else, let trivial chars be a part of the documentation description.\n+        int lookAheadCount = 0;\n+        int lookAheadChar = reader.peek(lookAheadCount);\n+        while (lookAheadChar == LexerTerminals.SPACE || lookAheadChar == LexerTerminals.TAB) {\n+            lookAheadCount++;\n+            lookAheadChar = reader.peek(lookAheadCount);\n+        }\n+\n+        if (lookAheadChar == LexerTerminals.PLUS) {\n+            return processPlusToken();\n+        } else if (lookAheadChar == LexerTerminals.HASH) {\n+            return processDeprecationLiteralToken(lookAheadCount);\n+        } else {\n+            return readDocumentationInternalToken();\n+        }\n+    }\n+\n+    private STToken processPlusToken() {\n+        processLeadingTrivia();\n+        reader.advance();\n+        switchMode(ParserMode.DOCUMENTATION_PARAMETER);\n+        return getDocumentationSyntaxToken(SyntaxKind.PLUS_TOKEN);\n+    }\n+\n+    private STToken processDeprecationLiteralToken(int lookAheadCount) {\n+        // Look ahead and see if next non-trivial char belongs to a deprecation literal.\n+        // There could be spaces and tabs in between.\n+        lookAheadCount++;\n+        int lookAheadChar = reader.peek(lookAheadCount);\n+        while (lookAheadChar == LexerTerminals.SPACE || lookAheadChar == LexerTerminals.TAB) {\n+            lookAheadCount++;\n+            lookAheadChar = reader.peek(lookAheadCount);\n+        }\n+\n+        // Look ahead for a \"Deprecated\" word match.\n+        for (int i = 0; i < 10; i++) {\n+            if ((char) lookAheadChar != LexerTerminals.DEPRECATED.charAt(i)) {\n+                // No match. Hence return a documentation internal token.\n+                return readDocumentationInternalToken();\n+            }\n+            lookAheadCount++;\n+            lookAheadChar = reader.peek(lookAheadCount);\n+        }\n+\n+        // There is a match. Hence return a deprecation literal.\n+        processLeadingTrivia();\n+        reader.mark();\n+        while (!getLexeme().endsWith(LexerTerminals.DEPRECATED)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea914c6e27a2591e0de66f268f3957a88134d37a"}, "originalPosition": 115}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2331d5519a2a7055ee6b37a9a44e4998551c54be", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2331d5519a2a7055ee6b37a9a44e4998551c54be", "committedDate": "2020-07-10T12:37:13Z", "message": "Improve processDeprecationLiteralToken"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c7f42aace81cc8272e14bdcf625cea75c0e47ba7", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c7f42aace81cc8272e14bdcf625cea75c0e47ba7", "committedDate": "2020-07-11T12:44:29Z", "message": "Introduce separate syntax kinds for all documentation syntax"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dd1c79f726714c4c1e43ba493ddcca4482da4516", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/dd1c79f726714c4c1e43ba493ddcca4482da4516", "committedDate": "2020-07-13T11:02:08Z", "message": "Revamp documentation parsing"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0c457a6196e4dffea3bf2dad08f699fa6a8d9149", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/0c457a6196e4dffea3bf2dad08f699fa6a8d9149", "committedDate": "2020-07-13T17:07:17Z", "message": "Fix leading trivia parsing in DocumentationLexer"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d2c63e4bd2d52f7228747bebaf9770893898cfcf", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/d2c63e4bd2d52f7228747bebaf9770893898cfcf", "committedDate": "2020-07-14T04:35:02Z", "message": "Fix multi line documentation parsing"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "539b9a3249762df2d9ee53f93d80ded17d663cb6", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/539b9a3249762df2d9ee53f93d80ded17d663cb6", "committedDate": "2020-07-14T06:10:56Z", "message": "Change documentation node names and generate tree"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "69d41e9bf8bfa70b227df509adf47465e5350b13", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/69d41e9bf8bfa70b227df509adf47465e5350b13", "committedDate": "2020-07-14T07:02:16Z", "message": "Refactor code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "037a99c8cd7e235b40a9b508c4e5ad0647724b7a", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/037a99c8cd7e235b40a9b508c4e5ad0647724b7a", "committedDate": "2020-07-14T07:03:47Z", "message": "Update test cases for node name changes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ3ODYxMzcz", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24684#pullrequestreview-447861373", "createdAt": "2020-07-14T07:37:25Z", "commit": {"oid": "037a99c8cd7e235b40a9b508c4e5ad0647724b7a"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQwNzozNzoyNVrOGxH6cA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQwNzo1ODowMVrOGxIm7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDE2MzA1Ng==", "bodyText": "what about the newlines? don't we need to add it to the trailing trivia?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24684#discussion_r454163056", "createdAt": "2020-07-14T07:37:25Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaLexer.java", "diffHunk": "@@ -1362,6 +1306,70 @@ private STToken processSlashToken() {\n         }\n     }\n \n+    /**\n+     * Process and return documentation string.\n+     * <p>\n+     * <code>\n+     * DocumentationContentString := ( BlankSpace* # [DocumentationContent] )+\n+     * <br/>\n+     * DocumentationContent := (^ 0xA)* 0xA\n+     * <br/>\n+     * BlankSpace := Tab | Space\n+     * <br/>\n+     * Space := 0x20\n+     * <br/>\n+     * Tab := 0x9\n+     * </code>\n+     *\n+     * @return Documentation string token\n+     */\n+    private STToken processDocumentationContentString() {\n+        int nextChar = peek();\n+        while (!reader.isEOF()) {\n+            switch (nextChar) {\n+                case LexerTerminals.CARRIAGE_RETURN:\n+                case LexerTerminals.NEWLINE:\n+\n+                    // Advance reader for the new line\n+                    if (peek() == LexerTerminals.CARRIAGE_RETURN && reader.peek(1) == LexerTerminals.NEWLINE) {\n+                        reader.advance();\n+                    }\n+                    reader.advance();\n+\n+                    // Look ahead and see if next line also belongs to the documentation.\n+                    // i.e. look for a `WS #` match\n+                    // If there's a match, advance reader for the next line as well.\n+                    // Otherwise terminate documentation content after the new line.\n+                    int lookAheadCount = 0;\n+                    int lookAheadChar = reader.peek(lookAheadCount);\n+                    while (lookAheadChar == LexerTerminals.SPACE || lookAheadChar == LexerTerminals.TAB) {\n+                        lookAheadCount++;\n+                        lookAheadChar = reader.peek(lookAheadCount);\n+                    }\n+\n+                    if (lookAheadChar != LexerTerminals.HASH) {\n+                        // Next line does not belong to documentation, hence break\n+                        break;\n+                    }\n+\n+                    reader.advance(lookAheadCount);\n+                    nextChar = peek();\n+                    continue;\n+                default:\n+                    reader.advance();\n+                    nextChar = peek();\n+                    continue;\n+            }\n+            break;\n+        }\n+\n+        STNode leadingTrivia = STNodeFactory.createNodeList(this.leadingTriviaList);\n+        String lexeme = getLexeme();\n+        STNode trailingTrivia = STNodeFactory.createNodeList(new ArrayList<>(0)); // No trailing trivia", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "037a99c8cd7e235b40a9b508c4e5ad0647724b7a"}, "originalPosition": 156}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDE2NDc2Mw==", "bodyText": "What does this method do? is it flattening the doc-lists?\nCan we do it right after getting the results from parseDocumentationString()? Then you don't have to traverse through the outer-list for a second time.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24684#discussion_r454164763", "createdAt": "2020-07-14T07:40:44Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -12994,242 +12994,70 @@ private DiagnosticErrorCode validateArgMatchPatternOrder(SyntaxKind prevArgKind,\n         return errorCode;\n     }\n \n-    // --------------------------------- Documentation ---------------------------------\n-\n-    /*\n-     * This section parses documentation.\n-     * Ballerina flavored markdown (BFM) is supported by the documentation.\n-     *\n-     * During the parsing, parser will never go to the error handler.\n-     * In case of an error, simply missing token will be returned.\n-     */\n-\n     /**\n-     * Parse documentation string.\n-     * <p>\n-     * <code>\n-     * DocumentationString :=\n-     *          ( DocumentationLine\n-     *          | ReferenceDocumentationLine\n-     *          | DeprecationDocumentationLine\n-     *          | ParameterDocumentationLine\n-     *          | ReturnParameterDocumentationLine\n-     *          | InvalidDocumentationLine ) +\n-     * </code>\n-     * <p>\n-     * Refer {@link BallerinaLexer#readDocumentationToken}\n+     * Parse markdown documentation.\n      *\n-     * @return Parsed node\n+     * @return markdown documentation node\n      */\n-    private STNode parseDocumentationString() {\n-        List<STNode> docLines = new ArrayList<>();\n-        STToken nextToken = peek();\n-        while (nextToken.kind == SyntaxKind.HASH_TOKEN) {\n-            docLines.add(parseSingleDocumentationLine());\n-            nextToken = peek();\n-        }\n-\n-        STNode documentationLines = STNodeFactory.createNodeList(docLines);\n-        return STNodeFactory.createDocumentationStringNode(documentationLines);\n-    }\n+    private STNode parseMarkdownDocumentation() {\n+        List<STNode> markdownDocLineList = new ArrayList<>();\n \n-    /**\n-     * Parse a single documentation line.\n-     *\n-     * @return Parsed node\n-     */\n-    private STNode parseSingleDocumentationLine() {\n-        STNode hashToken = consume();\n+        // With multi-line documentation, there could be more than one documentation string.\n+        // e.g.\n+        // # line1 (this is captured as one documentation string)\n+        //\n+        // # line2 (this is captured as another documentation string)\n         STToken nextToken = peek();\n-        if (nextToken.kind == SyntaxKind.PLUS_TOKEN) {\n-            return parseParameterDocumentationLine(hashToken);\n-        }\n-        return parseDocumentationLine(hashToken);\n-    }\n-\n-    /**\n-     * Parse documentation line, deprecation documentation line and reference documentation line.\n-     *\n-     * @param hashToken Hash token at the beginning of the line\n-     * @return Parsed node\n-     */\n-    private STNode parseDocumentationLine(STNode hashToken) {\n-        List<STNode> docElements = parseDocumentationElements();\n-        STNode docElementList = STNodeFactory.createNodeList(docElements);\n-\n-        switch (docElements.size()) {\n-            case 0:\n-                // When documentation line is only a `#` token\n-                return createDocumentationLineNode(hashToken, docElementList);\n-            case 1:\n-                STNode docElement = docElements.get(0);\n-                if (docElement.kind == SyntaxKind.DOCUMENTATION_DESCRIPTION) {\n-                    if (((STToken) docElement).text().startsWith(\"# Deprecated\")) {\n-                        return createDeprecationDocumentationLineNode(hashToken, docElementList);\n-                    }\n-                    return createDocumentationLineNode(hashToken, docElementList);\n-                }\n-                // Else fall through\n-            default:\n-                return createReferenceDocumentationLineNode(hashToken, docElementList);\n-        }\n-    }\n-\n-    private List<STNode> parseDocumentationElements() {\n-        List<STNode> docElements = new ArrayList<>();\n-        STNode docElement;\n-        SyntaxKind nextTokenKind = peek().kind;\n-        while (!isEndOfIntermediateDocumentation(nextTokenKind)) {\n-            if (nextTokenKind == SyntaxKind.DOCUMENTATION_DESCRIPTION) {\n-                docElement = consume();\n-\n-            } else {\n-                docElement = parseDocumentationReference();\n-            }\n-            docElements.add(docElement);\n-            nextTokenKind = peek().kind;\n-        }\n-        return docElements;\n-    }\n-\n-    private STNode parseDocumentationReference() {\n-        STNode referenceType = STNodeFactory.createEmptyNode();\n-        if (isDocumentReferenceType(peek().kind)) {\n-            referenceType = consume();\n+        while (nextToken.kind == SyntaxKind.DOCUMENTATION_STRING) {\n+            STToken documentationString = consume();\n+            STNode markdownDocLines = parseDocumentationString(documentationString);\n+            markdownDocLineList.add(markdownDocLines);\n+            nextToken = peek();\n         }\n \n-        STNode startBacktick = parseDocumentationBacktickToken();\n-        STNode backtickContent = parseBacktickContent();\n-        STNode endBacktick = parseDocumentationBacktickToken();\n-\n-        return STNodeFactory.createDocumentationReferenceNode(referenceType, startBacktick, backtickContent,\n-                endBacktick);\n-    }\n-\n-    private boolean isDocumentReferenceType(SyntaxKind kind) {\n-        switch (kind) {\n-            case TYPE_DOC_REFERENCE_TOKEN:\n-            case SERVICE_DOC_REFERENCE_TOKEN:\n-            case VARIABLE_DOC_REFERENCE_TOKEN:\n-            case VAR_DOC_REFERENCE_TOKEN:\n-            case ANNOTATION_DOC_REFERENCE_TOKEN:\n-            case MODULE_DOC_REFERENCE_TOKEN:\n-            case FUNCTION_DOC_REFERENCE_TOKEN:\n-            case PARAMETER_DOC_REFERENCE_TOKEN:\n-                return true;\n-            default:\n-                return false;\n-        }\n+        STNode arrangedMarkdownDocLines = rearrangeMarkdownDocumentationLines(markdownDocLineList);\n+        return STNodeFactory.createMarkdownDocumentationNode(arrangedMarkdownDocLines);\n     }\n \n     /**\n-     * Parse parameter documentation line and return parameter documentation line.\n+     * Parse documentation string.\n      *\n-     * @param hashToken Hash token at the beginning of the line\n-     * @return Parsed node\n+     * @return markdown documentation line list node\n      */\n-    private STNode parseParameterDocumentationLine(STNode hashToken) {\n-        STNode plusToken = consume();\n-        STNode parameterName = parseParameterName();\n-        STNode minusToken = parseMinusToken();\n-\n-        List<STNode> docElements = parseDocumentationElements();\n-        STNode docElementList = STNodeFactory.createNodeList(docElements);\n+    private STNode parseDocumentationString(STToken documentationStringToken) {\n+        List<STNode> leadingTriviaList = getLeadingTriviaList(documentationStringToken.leadingMinutiae());\n+        TextDocument textDocument = TextDocuments.from(documentationStringToken.text());\n \n-        SyntaxKind kind;\n-        if (parameterName.kind == SyntaxKind.RETURN_KEYWORD) {\n-            kind = SyntaxKind.RETURN_PARAMETER_DOCUMENTATION_LINE;\n-        } else {\n-            kind = SyntaxKind.PARAMETER_DOCUMENTATION_LINE;\n-        }\n+        DocumentationLexer documentationLexer = new DocumentationLexer(textDocument.getCharacterReader(),\n+                leadingTriviaList);\n+        AbstractTokenReader tokenReader = new TokenReader(documentationLexer);\n+        DocumentationParser documentationParser = new DocumentationParser(tokenReader);\n \n-        return STNodeFactory.createParameterDocumentationLineNode(kind, hashToken, plusToken, parameterName, minusToken,\n-                docElementList);\n+        return documentationParser.parse();\n     }\n \n-    private boolean isEndOfIntermediateDocumentation(SyntaxKind kind) {\n-        switch (kind) {\n-            case DOCUMENTATION_DESCRIPTION:\n-            case PLUS_TOKEN:\n-            case PARAMETER_NAME:\n-            case MINUS_TOKEN:\n-            case BACKTICK_TOKEN:\n-            case BACKTICK_CONTENT:\n-                return false;\n-            default:\n-                return !isDocumentReferenceType(kind);\n-        }\n-    }\n+    private List<STNode> getLeadingTriviaList(STNode leadingMinutiaeNode) {\n+        List<STNode> leadingTriviaList = new ArrayList<>();\n \n-    /**\n-     * Parse parameter name token.\n-     *\n-     * @return Parsed node\n-     */\n-    private STNode parseParameterName() {\n-        SyntaxKind tokenKind = peek().kind;\n-        if (tokenKind == SyntaxKind.PARAMETER_NAME || tokenKind == SyntaxKind.RETURN_KEYWORD) {\n-            return consume();\n-        } else {\n-            return STNodeFactory.createMissingToken(SyntaxKind.PARAMETER_NAME);\n+        int bucketCount = leadingMinutiaeNode.bucketCount();\n+        for (int i = 0; i < bucketCount; i++) {\n+            leadingTriviaList.add(leadingMinutiaeNode.childInBucket(i));\n         }\n+        return leadingTriviaList;\n     }\n \n-    /**\n-     * Parse minus token.\n-     *\n-     * @return Parsed node\n-     */\n-    private STNode parseMinusToken() {\n-        STToken token = peek();\n-        if (token.kind == SyntaxKind.MINUS_TOKEN) {\n-            return consume();\n-        } else {\n-            return STNodeFactory.createMissingToken(SyntaxKind.MINUS_TOKEN);\n-        }\n-    }\n+    private STNode rearrangeMarkdownDocumentationLines(List<STNode> markdownDocLineList) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "037a99c8cd7e235b40a9b508c4e5ad0647724b7a"}, "originalPosition": 313}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDE3NDQ0NQ==", "bodyText": "we can define this as a class-level final static variable, since its a constant.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24684#discussion_r454174445", "createdAt": "2020-07-14T07:58:01Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/DocumentationLexer.java", "diffHunk": "@@ -0,0 +1,691 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.ballerinalang.compiler.internal.parser;\n+\n+\n+import io.ballerinalang.compiler.internal.parser.tree.STNode;\n+import io.ballerinalang.compiler.internal.parser.tree.STNodeFactory;\n+import io.ballerinalang.compiler.internal.parser.tree.STToken;\n+import io.ballerinalang.compiler.syntax.tree.SyntaxKind;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * A LL(k) lexer for documentation in ballerina.\n+ *\n+ * @since 2.0.0\n+ */\n+public class DocumentationLexer extends AbstractLexer {\n+\n+    public DocumentationLexer(CharReader charReader, List<STNode> leadingTriviaList) {\n+        super(charReader, ParserMode.DOCUMENTATION_INIT);\n+        this.leadingTriviaList = leadingTriviaList;\n+    }\n+\n+    /**\n+     * Get the next lexical token.\n+     *\n+     * @return Next lexical token.\n+     */\n+    @Override\n+    public STToken nextToken() {\n+        STToken token;\n+        switch (this.mode) {\n+            case DOCUMENTATION_INIT:\n+                processLeadingTrivia();\n+                token = readDocumentationInitToken();\n+                break;\n+            case DOCUMENTATION:\n+                this.leadingTriviaList = new ArrayList<>(0);\n+                token = readDocumentationToken();\n+                break;\n+            case DOCUMENTATION_INTERNAL:\n+                this.leadingTriviaList = new ArrayList<>(0);\n+                token = readDocumentationInternalToken();\n+                break;\n+            case DOCUMENTATION_PARAMETER:\n+                processLeadingTrivia();\n+                token = readDocumentationParameterToken();\n+                break;\n+            case DOCUMENTATION_REFERENCE_TYPE:\n+                processLeadingTrivia();\n+                token = readDocumentationReferenceTypeToken();\n+                break;\n+            case DOCUMENTATION_BACKTICK_CONTENT:\n+                this.leadingTriviaList = new ArrayList<>(0);\n+                token = readDocumentationBacktickContentToken();\n+                break;\n+            default:\n+                token = null;\n+        }\n+        return token;\n+    }\n+\n+    /*\n+     * Private Methods\n+     */\n+\n+    /**\n+     * Returns the next character from the reader, without consuming the stream.\n+     *\n+     * @return Next character\n+     */\n+    private int peek() {\n+        return this.reader.peek();\n+    }\n+\n+    /**\n+     * Get the text associated with the current token.\n+     *\n+     * @return Text associated with the current token.\n+     */\n+    private String getLexeme() {\n+        return reader.getMarkedChars();\n+    }\n+\n+    /**\n+     * <p>\n+     * Check whether a given char is an identifier start char.\n+     * </p>\n+     * <code>IdentifierInitialChar := A .. Z | a .. z | _ | UnicodeIdentifierChar</code>\n+     *\n+     * @param c character to check\n+     * @return <code>true</code>, if the character is an identifier start char. <code>false</code> otherwise.\n+     */\n+    private boolean isIdentifierInitialChar(int c) {\n+        // TODO: pre-mark all possible characters, using a mask. And use that mask here to check\n+        if ('A' <= c && c <= 'Z') {\n+            return true;\n+        }\n+\n+        if ('a' <= c && c <= 'z') {\n+            return true;\n+        }\n+\n+        if (c == '_') {\n+            return true;\n+        }\n+\n+        // TODO: if (UnicodeIdentifierChar) return false;\n+        return false;\n+    }\n+\n+    /**\n+     * <p>\n+     * Check whether a given char is an identifier following char.\n+     * </p>\n+     * <code>IdentifierFollowingChar := IdentifierInitialChar | Digit</code>\n+     *\n+     * @param c character to check\n+     * @return <code>true</code>, if the character is an identifier following char. <code>false</code> otherwise.\n+     */\n+    private boolean isIdentifierFollowingChar(int c) {\n+        return isIdentifierInitialChar(c) || isDigit(c);\n+    }\n+\n+    /**\n+     * <p>\n+     * Check whether a given char is a digit.\n+     * </p>\n+     * <code>Digit := 0..9</code>\n+     *\n+     * @param c character to check\n+     * @return <code>true</code>, if the character represents a digit. <code>false</code> otherwise.\n+     */\n+    static boolean isDigit(int c) {\n+        return ('0' <= c && c <= '9');\n+    }\n+\n+    /**\n+     * Process leading trivia.\n+     */\n+    private void processLeadingTrivia() {\n+        // new leading trivia will be added to the current leading trivia list\n+        processSyntaxTrivia(this.leadingTriviaList, true);\n+    }\n+\n+    /**\n+     * Reset leading trivia.\n+     */\n+    private void resetLeadingTrivia() {\n+        this.leadingTriviaList = new ArrayList<>(0);\n+    }\n+\n+    /**\n+     * Process and return trailing trivia.\n+     *\n+     * @return Trailing trivia\n+     */\n+    private STNode processTrailingTrivia() {\n+        List<STNode> triviaList = new ArrayList<>(10);\n+        processSyntaxTrivia(triviaList, false);\n+        return STNodeFactory.createNodeList(triviaList);\n+    }\n+\n+    /**\n+     * Process syntax trivia and add it to the provided list.\n+     * <p>\n+     * <code>syntax-trivia := whitespace | end-of-line </code>\n+     *\n+     * @param triviaList List of trivia\n+     * @param isLeading Flag indicating whether the currently processing leading trivia or not\n+     */\n+    private void processSyntaxTrivia(List<STNode> triviaList, boolean isLeading) {\n+        while (!reader.isEOF()) {\n+            reader.mark();\n+            char c = reader.peek();\n+            switch (c) {\n+                case LexerTerminals.SPACE:\n+                case LexerTerminals.TAB:\n+                case LexerTerminals.FORM_FEED:\n+                    triviaList.add(processWhitespaces());\n+                    break;\n+                case LexerTerminals.CARRIAGE_RETURN:\n+                case LexerTerminals.NEWLINE:\n+                    triviaList.add(processEndOfLine());\n+                    if (isLeading) {\n+                        break;\n+                    }\n+                    return;\n+                default:\n+                    return;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Process whitespace up to an end of line.\n+     * <p>\n+     * <code>whitespace := 0x9 | 0xC | 0x20</code>\n+     *\n+     * @return Whitespace trivia\n+     */\n+    private STNode processWhitespaces() {\n+        while (!reader.isEOF()) {\n+            char c = reader.peek();\n+            switch (c) {\n+                case LexerTerminals.SPACE:\n+                case LexerTerminals.TAB:\n+                case LexerTerminals.FORM_FEED:\n+                    reader.advance();\n+                    continue;\n+                case LexerTerminals.CARRIAGE_RETURN:\n+                case LexerTerminals.NEWLINE:\n+                    break;\n+                default:\n+                    break;\n+            }\n+            break;\n+        }\n+\n+        return STNodeFactory.createMinutiae(SyntaxKind.WHITESPACE_MINUTIAE, getLexeme());\n+    }\n+\n+    /**\n+     * Process end of line.\n+     * <p>\n+     * <code>end-of-line := 0xA | 0xD</code>\n+     *\n+     * @return End of line trivia\n+     */\n+    private STNode processEndOfLine() {\n+        char c = reader.peek();\n+        switch (c) {\n+            case LexerTerminals.NEWLINE:\n+                reader.advance();\n+                return STNodeFactory.createMinutiae(SyntaxKind.END_OF_LINE_MINUTIAE, getLexeme());\n+            case LexerTerminals.CARRIAGE_RETURN:\n+                reader.advance();\n+                if (reader.peek() == LexerTerminals.NEWLINE) {\n+                    reader.advance();\n+                }\n+                return STNodeFactory.createMinutiae(SyntaxKind.END_OF_LINE_MINUTIAE, getLexeme());\n+            default:\n+                throw new IllegalStateException();\n+        }\n+    }\n+\n+    private STToken getDocumentationSyntaxToken(SyntaxKind kind) {\n+        STNode leadingTrivia = STNodeFactory.createNodeList(this.leadingTriviaList);\n+        resetLeadingTrivia();\n+\n+        STNode trailingTrivia = processTrailingTrivia();\n+        // check for end of line minutiae and terminate current documentation mode.\n+        int bucketCount = trailingTrivia.bucketCount();\n+        if (bucketCount > 0 &&\n+                trailingTrivia.childInBucket(bucketCount - 1).kind == SyntaxKind.END_OF_LINE_MINUTIAE) {\n+            endMode();\n+        }\n+        return STNodeFactory.createToken(kind, leadingTrivia, trailingTrivia);\n+    }\n+\n+    private STToken getDocumentationSyntaxTokenWithNoTrivia(SyntaxKind kind) {\n+        STNode leadingTrivia = STNodeFactory.createNodeList(this.leadingTriviaList);\n+        resetLeadingTrivia();\n+\n+        // We reach here only for the hash token, minus token and backtick token in the documentation mode.\n+        // Trivia for those tokens can only be an end of line.\n+        // Rest of the trivia after that belongs to the documentation description or the backtick content.\n+        STNode trailingTrivia;\n+        List<STNode> triviaList = new ArrayList<>(1);\n+\n+        int nextChar = peek();\n+        if (nextChar == LexerTerminals.NEWLINE || nextChar == LexerTerminals.CARRIAGE_RETURN) {\n+            reader.mark();\n+            triviaList.add(processEndOfLine());\n+            // end of line reached, hence end documentation mode\n+            endMode();\n+        }\n+\n+        trailingTrivia = STNodeFactory.createNodeList(triviaList);\n+        return STNodeFactory.createToken(kind, leadingTrivia, trailingTrivia);\n+    }\n+\n+    private STToken getDocumentationLiteral(SyntaxKind kind) {\n+        STNode leadingTrivia = STNodeFactory.createNodeList(this.leadingTriviaList);\n+        resetLeadingTrivia();\n+\n+        String lexeme = getLexeme();\n+        STNode trailingTrivia = processTrailingTrivia();\n+\n+        // Check for end of line minutiae and terminate the current documentation mode.\n+        int bucketCount = trailingTrivia.bucketCount();\n+        if (bucketCount > 0 &&\n+                trailingTrivia.childInBucket(bucketCount - 1).kind == SyntaxKind.END_OF_LINE_MINUTIAE) {\n+            endMode();\n+        }\n+        return STNodeFactory.createLiteralValueToken(kind, lexeme, leadingTrivia, trailingTrivia);\n+    }\n+\n+    private STToken getDocumentationDescriptionToken() {\n+        STNode leadingTrivia = STNodeFactory.createNodeList(this.leadingTriviaList);\n+        resetLeadingTrivia();\n+        String lexeme = getLexeme();\n+        STNode trailingTrivia = processTrailingTrivia();\n+        return STNodeFactory.createLiteralValueToken(SyntaxKind.DOCUMENTATION_DESCRIPTION, lexeme, leadingTrivia,\n+                trailingTrivia);\n+    }\n+\n+    /*\n+     * ------------------------------------------------------------------------------------------------------------\n+     * DOCUMENTATION_INIT Mode\n+     * ------------------------------------------------------------------------------------------------------------\n+     */\n+\n+    private STToken readDocumentationInitToken() {\n+        reader.mark();\n+        if (reader.isEOF()) {\n+            return getDocumentationSyntaxToken(SyntaxKind.EOF_TOKEN);\n+        }\n+\n+        int nextChar = peek();\n+        if (nextChar == LexerTerminals.HASH) {\n+            reader.advance();\n+            startMode(ParserMode.DOCUMENTATION);\n+            return getDocumentationSyntaxTokenWithNoTrivia(SyntaxKind.HASH_TOKEN);\n+        } else {\n+            throw new IllegalStateException(\"documentation line should always start with a hash\");\n+        }\n+    }\n+\n+    /*\n+     * ------------------------------------------------------------------------------------------------------------\n+     * DOCUMENTATION Mode\n+     * ------------------------------------------------------------------------------------------------------------\n+     */\n+\n+    private STToken readDocumentationToken() {\n+        // Look ahead and see if next non-trivial char is a plus char or a hash char.\n+        // If it is a plus char, process trivial chars as leading trivia of the plus token.\n+        // If it is a hash char, look ahead and see if it is followed by a deprecation literal.\n+        // Else, let trivial chars be a part of the documentation description.\n+        int lookAheadCount = 0;\n+        int lookAheadChar = reader.peek(lookAheadCount);\n+        while (lookAheadChar == LexerTerminals.SPACE || lookAheadChar == LexerTerminals.TAB) {\n+            lookAheadCount++;\n+            lookAheadChar = reader.peek(lookAheadCount);\n+        }\n+\n+        if (lookAheadChar == LexerTerminals.PLUS) {\n+            return processPlusToken();\n+        } else if (lookAheadChar == LexerTerminals.HASH) {\n+            return processDeprecationLiteralToken(lookAheadCount);\n+        } else {\n+            return readDocumentationInternalToken();\n+        }\n+    }\n+\n+    private STToken processPlusToken() {\n+        processLeadingTrivia();\n+        reader.advance();\n+        switchMode(ParserMode.DOCUMENTATION_PARAMETER);\n+        return getDocumentationSyntaxToken(SyntaxKind.PLUS_TOKEN);\n+    }\n+\n+    private STToken processDeprecationLiteralToken(int lookAheadCount) {\n+        // Look ahead and see if next non-trivial char belongs to a deprecation literal.\n+        // There could be spaces and tabs in between.\n+        lookAheadCount++;\n+        int lookAheadChar = reader.peek(lookAheadCount);\n+\n+        int whitespaceCount = 0;\n+        while (lookAheadChar == LexerTerminals.SPACE || lookAheadChar == LexerTerminals.TAB) {\n+            lookAheadCount++;\n+            whitespaceCount++;\n+            lookAheadChar = reader.peek(lookAheadCount);\n+        }\n+\n+        // Look ahead for a \"Deprecated\" word match.\n+        char[] deprecatedChars = {'D', 'e', 'p', 'r', 'e', 'c', 'a', 't', 'e', 'd' };", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "037a99c8cd7e235b40a9b508c4e5ad0647724b7a"}, "originalPosition": 395}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ3ODc4MTM3", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24684#pullrequestreview-447878137", "createdAt": "2020-07-14T08:01:50Z", "commit": {"oid": "037a99c8cd7e235b40a9b508c4e5ad0647724b7a"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4181, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}