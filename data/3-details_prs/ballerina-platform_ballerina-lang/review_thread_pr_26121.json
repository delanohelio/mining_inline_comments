{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkzODU0MDcz", "number": 26121, "reviewThreads": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwNTowNDoyM1rOEn7IdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxMjowNzo1MVrOEoDGVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwMjk4NzQxOnYy", "diffSide": "RIGHT", "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwNTowNDoyM1rOHYujcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwNzo0NDozMlrOHYyB4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY5MDYwOQ==", "bodyText": "no need of a WS after the last component of the module name?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26121#discussion_r495690609", "createdAt": "2020-09-28T05:04:23Z", "author": {"login": "SupunS"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "diffHunk": "@@ -399,6 +429,392 @@ public RecordFieldWithDefaultValueNode transform(RecordFieldWithDefaultValueNode\n                 .apply();\n     }\n \n+    @Override\n+    public ImportDeclarationNode transform(ImportDeclarationNode importDeclarationNode) {\n+        Token importKeyword = formatToken(importDeclarationNode.importKeyword(), 0, 0);\n+\n+        if (importDeclarationNode.orgName().isPresent()) {\n+            ImportOrgNameNode orgName = formatNode(importDeclarationNode.orgName().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withOrgName(orgName).apply();\n+        }\n+        SeparatedNodeList<IdentifierToken> moduleNames = formatSeparatedNodeList(importDeclarationNode.moduleName(),\n+                0, 0, 0, 0, 0, 0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a775b9cadbd9a21307035b40d50e91dc8e229ffe"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc0NzU1Mw==", "bodyText": "Fixed.\nIt is needed if a prefix or version is specified, else it should not be there.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26121#discussion_r495747553", "createdAt": "2020-09-28T07:44:32Z", "author": {"login": "IrushiL"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "diffHunk": "@@ -399,6 +429,392 @@ public RecordFieldWithDefaultValueNode transform(RecordFieldWithDefaultValueNode\n                 .apply();\n     }\n \n+    @Override\n+    public ImportDeclarationNode transform(ImportDeclarationNode importDeclarationNode) {\n+        Token importKeyword = formatToken(importDeclarationNode.importKeyword(), 0, 0);\n+\n+        if (importDeclarationNode.orgName().isPresent()) {\n+            ImportOrgNameNode orgName = formatNode(importDeclarationNode.orgName().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withOrgName(orgName).apply();\n+        }\n+        SeparatedNodeList<IdentifierToken> moduleNames = formatSeparatedNodeList(importDeclarationNode.moduleName(),\n+                0, 0, 0, 0, 0, 0);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY5MDYwOQ=="}, "originalCommit": {"oid": "a775b9cadbd9a21307035b40d50e91dc8e229ffe"}, "originalPosition": 116}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwMjk4OTMzOnYy", "diffSide": "RIGHT", "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwNTowNTozNlrOHYukcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwNzo0NToxMlrOHYyDPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY5MDg2NA==", "bodyText": "here also should keep a trailing ws", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26121#discussion_r495690864", "createdAt": "2020-09-28T05:05:36Z", "author": {"login": "SupunS"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "diffHunk": "@@ -399,6 +429,392 @@ public RecordFieldWithDefaultValueNode transform(RecordFieldWithDefaultValueNode\n                 .apply();\n     }\n \n+    @Override\n+    public ImportDeclarationNode transform(ImportDeclarationNode importDeclarationNode) {\n+        Token importKeyword = formatToken(importDeclarationNode.importKeyword(), 0, 0);\n+\n+        if (importDeclarationNode.orgName().isPresent()) {\n+            ImportOrgNameNode orgName = formatNode(importDeclarationNode.orgName().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withOrgName(orgName).apply();\n+        }\n+        SeparatedNodeList<IdentifierToken> moduleNames = formatSeparatedNodeList(importDeclarationNode.moduleName(),\n+                0, 0, 0, 0, 0, 0);\n+\n+        if (importDeclarationNode.version().isPresent()) {\n+            ImportVersionNode version = formatNode(importDeclarationNode.version().get(), 0, 0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a775b9cadbd9a21307035b40d50e91dc8e229ffe"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc0NzkwMA==", "bodyText": "Fixed to have a trailing WS if there is a prefix defined.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26121#discussion_r495747900", "createdAt": "2020-09-28T07:45:12Z", "author": {"login": "IrushiL"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "diffHunk": "@@ -399,6 +429,392 @@ public RecordFieldWithDefaultValueNode transform(RecordFieldWithDefaultValueNode\n                 .apply();\n     }\n \n+    @Override\n+    public ImportDeclarationNode transform(ImportDeclarationNode importDeclarationNode) {\n+        Token importKeyword = formatToken(importDeclarationNode.importKeyword(), 0, 0);\n+\n+        if (importDeclarationNode.orgName().isPresent()) {\n+            ImportOrgNameNode orgName = formatNode(importDeclarationNode.orgName().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withOrgName(orgName).apply();\n+        }\n+        SeparatedNodeList<IdentifierToken> moduleNames = formatSeparatedNodeList(importDeclarationNode.moduleName(),\n+                0, 0, 0, 0, 0, 0);\n+\n+        if (importDeclarationNode.version().isPresent()) {\n+            ImportVersionNode version = formatNode(importDeclarationNode.version().get(), 0, 0);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY5MDg2NA=="}, "originalCommit": {"oid": "a775b9cadbd9a21307035b40d50e91dc8e229ffe"}, "originalPosition": 119}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwMjk4OTY0OnYy", "diffSide": "RIGHT", "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwNTowNTo0NVrOHYuklA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwNzo0NjoxOVrOHYyFXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY5MDkwMA==", "bodyText": "same as above", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26121#discussion_r495690900", "createdAt": "2020-09-28T05:05:45Z", "author": {"login": "SupunS"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "diffHunk": "@@ -399,6 +429,392 @@ public RecordFieldWithDefaultValueNode transform(RecordFieldWithDefaultValueNode\n                 .apply();\n     }\n \n+    @Override\n+    public ImportDeclarationNode transform(ImportDeclarationNode importDeclarationNode) {\n+        Token importKeyword = formatToken(importDeclarationNode.importKeyword(), 0, 0);\n+\n+        if (importDeclarationNode.orgName().isPresent()) {\n+            ImportOrgNameNode orgName = formatNode(importDeclarationNode.orgName().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withOrgName(orgName).apply();\n+        }\n+        SeparatedNodeList<IdentifierToken> moduleNames = formatSeparatedNodeList(importDeclarationNode.moduleName(),\n+                0, 0, 0, 0, 0, 0);\n+\n+        if (importDeclarationNode.version().isPresent()) {\n+            ImportVersionNode version = formatNode(importDeclarationNode.version().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withVersion(version).apply();\n+        }\n+        if (importDeclarationNode.prefix().isPresent()) {\n+            ImportPrefixNode prefix = formatNode(importDeclarationNode.prefix().get(), 0, 0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a775b9cadbd9a21307035b40d50e91dc8e229ffe"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc0ODQ0Ng==", "bodyText": "Here a trailing WS is not required AFAIU.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26121#discussion_r495748446", "createdAt": "2020-09-28T07:46:19Z", "author": {"login": "IrushiL"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "diffHunk": "@@ -399,6 +429,392 @@ public RecordFieldWithDefaultValueNode transform(RecordFieldWithDefaultValueNode\n                 .apply();\n     }\n \n+    @Override\n+    public ImportDeclarationNode transform(ImportDeclarationNode importDeclarationNode) {\n+        Token importKeyword = formatToken(importDeclarationNode.importKeyword(), 0, 0);\n+\n+        if (importDeclarationNode.orgName().isPresent()) {\n+            ImportOrgNameNode orgName = formatNode(importDeclarationNode.orgName().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withOrgName(orgName).apply();\n+        }\n+        SeparatedNodeList<IdentifierToken> moduleNames = formatSeparatedNodeList(importDeclarationNode.moduleName(),\n+                0, 0, 0, 0, 0, 0);\n+\n+        if (importDeclarationNode.version().isPresent()) {\n+            ImportVersionNode version = formatNode(importDeclarationNode.version().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withVersion(version).apply();\n+        }\n+        if (importDeclarationNode.prefix().isPresent()) {\n+            ImportPrefixNode prefix = formatNode(importDeclarationNode.prefix().get(), 0, 0);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY5MDkwMA=="}, "originalCommit": {"oid": "a775b9cadbd9a21307035b40d50e91dc8e229ffe"}, "originalPosition": 123}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwMjk5MjY2OnYy", "diffSide": "RIGHT", "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwNTowNzo0MFrOHYumNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwNzo0Njo0NVrOHYyGKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY5MTMxOQ==", "bodyText": "last token inside every method should get the  trailing whitesapces and  newlines from this.trailingWS and this.trailingNL.\nLet's follow that pattern religiously in all methods :)", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26121#discussion_r495691319", "createdAt": "2020-09-28T05:07:40Z", "author": {"login": "SupunS"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "diffHunk": "@@ -399,6 +429,392 @@ public RecordFieldWithDefaultValueNode transform(RecordFieldWithDefaultValueNode\n                 .apply();\n     }\n \n+    @Override\n+    public ImportDeclarationNode transform(ImportDeclarationNode importDeclarationNode) {\n+        Token importKeyword = formatToken(importDeclarationNode.importKeyword(), 0, 0);\n+\n+        if (importDeclarationNode.orgName().isPresent()) {\n+            ImportOrgNameNode orgName = formatNode(importDeclarationNode.orgName().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withOrgName(orgName).apply();\n+        }\n+        SeparatedNodeList<IdentifierToken> moduleNames = formatSeparatedNodeList(importDeclarationNode.moduleName(),\n+                0, 0, 0, 0, 0, 0);\n+\n+        if (importDeclarationNode.version().isPresent()) {\n+            ImportVersionNode version = formatNode(importDeclarationNode.version().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withVersion(version).apply();\n+        }\n+        if (importDeclarationNode.prefix().isPresent()) {\n+            ImportPrefixNode prefix = formatNode(importDeclarationNode.prefix().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withPrefix(prefix).apply();\n+        }\n+        Token semicolon = formatToken(importDeclarationNode.semicolon(), 0, 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a775b9cadbd9a21307035b40d50e91dc8e229ffe"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc0ODY1MQ==", "bodyText": "Fixed", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26121#discussion_r495748651", "createdAt": "2020-09-28T07:46:45Z", "author": {"login": "IrushiL"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "diffHunk": "@@ -399,6 +429,392 @@ public RecordFieldWithDefaultValueNode transform(RecordFieldWithDefaultValueNode\n                 .apply();\n     }\n \n+    @Override\n+    public ImportDeclarationNode transform(ImportDeclarationNode importDeclarationNode) {\n+        Token importKeyword = formatToken(importDeclarationNode.importKeyword(), 0, 0);\n+\n+        if (importDeclarationNode.orgName().isPresent()) {\n+            ImportOrgNameNode orgName = formatNode(importDeclarationNode.orgName().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withOrgName(orgName).apply();\n+        }\n+        SeparatedNodeList<IdentifierToken> moduleNames = formatSeparatedNodeList(importDeclarationNode.moduleName(),\n+                0, 0, 0, 0, 0, 0);\n+\n+        if (importDeclarationNode.version().isPresent()) {\n+            ImportVersionNode version = formatNode(importDeclarationNode.version().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withVersion(version).apply();\n+        }\n+        if (importDeclarationNode.prefix().isPresent()) {\n+            ImportPrefixNode prefix = formatNode(importDeclarationNode.prefix().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withPrefix(prefix).apply();\n+        }\n+        Token semicolon = formatToken(importDeclarationNode.semicolon(), 0, 1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY5MTMxOQ=="}, "originalCommit": {"oid": "a775b9cadbd9a21307035b40d50e91dc8e229ffe"}, "originalPosition": 126}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwMjk5NTI2OnYy", "diffSide": "RIGHT", "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwNTowOToyOVrOHYunsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwNzo0NzoxMFrOHYyHAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY5MTY5Nw==", "bodyText": "I think its good to add all the child nodes of the import decl node along with this..\nsuch as ImportVersionNode, ImportPrefixNode", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26121#discussion_r495691697", "createdAt": "2020-09-28T05:09:29Z", "author": {"login": "SupunS"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "diffHunk": "@@ -399,6 +429,392 @@ public RecordFieldWithDefaultValueNode transform(RecordFieldWithDefaultValueNode\n                 .apply();\n     }\n \n+    @Override\n+    public ImportDeclarationNode transform(ImportDeclarationNode importDeclarationNode) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a775b9cadbd9a21307035b40d50e91dc8e229ffe"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc0ODg2NQ==", "bodyText": "Done", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26121#discussion_r495748865", "createdAt": "2020-09-28T07:47:10Z", "author": {"login": "IrushiL"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "diffHunk": "@@ -399,6 +429,392 @@ public RecordFieldWithDefaultValueNode transform(RecordFieldWithDefaultValueNode\n                 .apply();\n     }\n \n+    @Override\n+    public ImportDeclarationNode transform(ImportDeclarationNode importDeclarationNode) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY5MTY5Nw=="}, "originalCommit": {"oid": "a775b9cadbd9a21307035b40d50e91dc8e229ffe"}, "originalPosition": 108}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwMjk5ODMwOnYy", "diffSide": "RIGHT", "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwNToxMTowN1rOHYupTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwODo0NDo0OVrOHY0Cgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY5MjEwOQ==", "bodyText": "if theres an on-fail clause, then we shouldn't use this.trailingWS and this.trailingNL\nSame goes for all other places where on-fail clause applies", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26121#discussion_r495692109", "createdAt": "2020-09-28T05:11:07Z", "author": {"login": "SupunS"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "diffHunk": "@@ -399,6 +429,392 @@ public RecordFieldWithDefaultValueNode transform(RecordFieldWithDefaultValueNode\n                 .apply();\n     }\n \n+    @Override\n+    public ImportDeclarationNode transform(ImportDeclarationNode importDeclarationNode) {\n+        Token importKeyword = formatToken(importDeclarationNode.importKeyword(), 0, 0);\n+\n+        if (importDeclarationNode.orgName().isPresent()) {\n+            ImportOrgNameNode orgName = formatNode(importDeclarationNode.orgName().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withOrgName(orgName).apply();\n+        }\n+        SeparatedNodeList<IdentifierToken> moduleNames = formatSeparatedNodeList(importDeclarationNode.moduleName(),\n+                0, 0, 0, 0, 0, 0);\n+\n+        if (importDeclarationNode.version().isPresent()) {\n+            ImportVersionNode version = formatNode(importDeclarationNode.version().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withVersion(version).apply();\n+        }\n+        if (importDeclarationNode.prefix().isPresent()) {\n+            ImportPrefixNode prefix = formatNode(importDeclarationNode.prefix().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withPrefix(prefix).apply();\n+        }\n+        Token semicolon = formatToken(importDeclarationNode.semicolon(), 0, 1);\n+\n+        return importDeclarationNode.modify()\n+                .withImportKeyword(importKeyword)\n+                .withModuleName(moduleNames)\n+                .withSemicolon(semicolon)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ServiceDeclarationNode transform(ServiceDeclarationNode serviceDeclarationNode) {\n+        if (serviceDeclarationNode.metadata().isPresent()) {\n+            MetadataNode metadata = formatNode(serviceDeclarationNode.metadata().get(), 1, 0);\n+            serviceDeclarationNode = serviceDeclarationNode.modify().withMetadata(metadata).apply();\n+        }\n+\n+        Token serviceKeyword = formatToken(serviceDeclarationNode.serviceKeyword(), 1, 0);\n+        IdentifierToken serviceName = formatToken(serviceDeclarationNode.serviceName(), 1, 0);\n+        Token onKeyword = formatToken(serviceDeclarationNode.onKeyword(), 1, 0);\n+        SeparatedNodeList<ExpressionNode> expressions =\n+                formatSeparatedNodeList(serviceDeclarationNode.expressions(), 0, 0, 0, 0);\n+        Node serviceBody = formatNode(serviceDeclarationNode.serviceBody(), this.trailingWS, this.trailingNL);\n+\n+        return serviceDeclarationNode.modify()\n+                .withServiceKeyword(serviceKeyword)\n+                .withServiceName(serviceName)\n+                .withOnKeyword(onKeyword)\n+                .withExpressions(expressions)\n+                .withServiceBody(serviceBody)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ExplicitNewExpressionNode transform(ExplicitNewExpressionNode explicitNewExpressionNode) {\n+        Token newKeywordToken = formatToken(explicitNewExpressionNode.newKeyword(), 1, 0);\n+        TypeDescriptorNode typeDescriptorNode = formatNode(explicitNewExpressionNode.typeDescriptor(), 0, 0);\n+        ParenthesizedArgList parenthesizedArgList = formatNode(explicitNewExpressionNode.parenthesizedArgList(), 0, 0);\n+\n+        return explicitNewExpressionNode.modify()\n+                .withNewKeyword(newKeywordToken)\n+                .withTypeDescriptor(typeDescriptorNode)\n+                .withParenthesizedArgList(parenthesizedArgList)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ParenthesizedArgList transform(ParenthesizedArgList parenthesizedArgList) {\n+        Token openParenToken = formatToken(parenthesizedArgList.openParenToken(), 0, 0);\n+        SeparatedNodeList<FunctionArgumentNode> arguments = formatSeparatedNodeList(parenthesizedArgList\n+                .arguments(), 0, 0, 0, 0);\n+        Token closeParenToken = formatToken(parenthesizedArgList.closeParenToken(), 1, 0);\n+\n+        return parenthesizedArgList.modify()\n+                .withOpenParenToken(openParenToken)\n+                .withArguments(arguments)\n+                .withCloseParenToken(closeParenToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ServiceBodyNode transform(ServiceBodyNode serviceBodyNode) {\n+        Token openBraceToken = formatToken(serviceBodyNode.openBraceToken(), 0, 1);\n+        indent(); // increase indentation for the statements to follow.\n+        NodeList<Node> resources = formatNodeList(serviceBodyNode.resources(), 0, 1, 0, 1);\n+        unindent(); // reset the indentation\n+        Token closeBraceToken = formatToken(serviceBodyNode.closeBraceToken(), this.trailingWS, this.trailingNL);\n+\n+        return serviceBodyNode.modify()\n+                .withOpenBraceToken(openBraceToken)\n+                .withResources(resources)\n+                .withCloseBraceToken(closeBraceToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public QualifiedNameReferenceNode transform(QualifiedNameReferenceNode qualifiedNameReferenceNode) {\n+        Token modulePrefix = formatToken(qualifiedNameReferenceNode.modulePrefix(), 0, 0);\n+        Token colon = formatToken((Token) qualifiedNameReferenceNode.colon(), 0, 0);\n+        IdentifierToken identifier = formatToken(qualifiedNameReferenceNode.identifier(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return qualifiedNameReferenceNode.modify()\n+                .withModulePrefix(modulePrefix)\n+                .withColon(colon)\n+                .withIdentifier(identifier)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ReturnTypeDescriptorNode transform(ReturnTypeDescriptorNode returnTypeDescriptorNode) {\n+        Token returnsKeyword = formatToken(returnTypeDescriptorNode.returnsKeyword(), 1, 0);\n+        NodeList<AnnotationNode> annotations = formatNodeList(returnTypeDescriptorNode.annotations(), 0, 0, 1, 0);\n+        Node type = formatNode(returnTypeDescriptorNode.type(), 1, 0);\n+\n+        return returnTypeDescriptorNode.modify()\n+                .withReturnsKeyword(returnsKeyword)\n+                .withAnnotations(annotations)\n+                .withType(type)\n+                .apply();\n+    }\n+\n+    @Override\n+    public OptionalTypeDescriptorNode transform(OptionalTypeDescriptorNode optionalTypeDescriptorNode) {\n+        Node typeDescriptor = formatNode(optionalTypeDescriptorNode.typeDescriptor(), 0, 0);\n+        Token questionMarkToken = formatToken(optionalTypeDescriptorNode.questionMarkToken(), 1, 0);\n+\n+        return optionalTypeDescriptorNode.modify()\n+                .withTypeDescriptor(typeDescriptor)\n+                .withQuestionMarkToken(questionMarkToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ExpressionStatementNode transform(ExpressionStatementNode expressionStatementNode) {\n+        ExpressionNode expression = formatNode(expressionStatementNode.expression(), this.trailingWS, this.trailingNL);\n+        Token semicolonToken = formatToken(expressionStatementNode.semicolonToken(), this.trailingWS, this.trailingNL);\n+\n+        return expressionStatementNode.modify()\n+                .withExpression(expression)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public CheckExpressionNode transform(CheckExpressionNode checkExpressionNode) {\n+        Token checkKeyword = formatToken(checkExpressionNode.checkKeyword(), 1, 0);\n+        ExpressionNode expressionNode = formatNode(checkExpressionNode.expression(), this.trailingWS, this.trailingNL);\n+\n+        return checkExpressionNode.modify()\n+                .withCheckKeyword(checkKeyword)\n+                .withExpression(expressionNode)\n+                .apply();\n+    }\n+\n+    @Override\n+    public RemoteMethodCallActionNode transform(RemoteMethodCallActionNode remoteMethodCallActionNode) {\n+        ExpressionNode expression = formatNode(remoteMethodCallActionNode.expression(), 0, 0);\n+        Token rightArrowToken = formatToken(remoteMethodCallActionNode.rightArrowToken(), 0, 0);\n+        SimpleNameReferenceNode methodName = formatNode(remoteMethodCallActionNode.methodName(), 0, 0);\n+        Token openParenToken = formatToken(remoteMethodCallActionNode.openParenToken(), 0, 0);\n+        SeparatedNodeList<FunctionArgumentNode> arguments = formatSeparatedNodeList(remoteMethodCallActionNode\n+                .arguments(), 1, 0, 0, 0);\n+        Token closeParenToken = formatToken(remoteMethodCallActionNode.closeParenToken(), 0, 0);\n+\n+        return remoteMethodCallActionNode.modify()\n+                .withExpression(expression)\n+                .withRightArrowToken(rightArrowToken)\n+                .withMethodName(methodName)\n+                .withOpenParenToken(openParenToken)\n+                .withArguments(arguments)\n+                .withCloseParenToken(closeParenToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public SimpleNameReferenceNode transform(SimpleNameReferenceNode simpleNameReferenceNode) {\n+        Token name = formatToken(simpleNameReferenceNode.name(), this.trailingWS, 0);\n+\n+        return simpleNameReferenceNode.modify()\n+                .withName(name)\n+                .apply();\n+    }\n+\n+    @Override\n+    public TypeDefinitionNode transform(TypeDefinitionNode typeDefinitionNode) {\n+        if (typeDefinitionNode.metadata().isPresent()) {\n+            MetadataNode metadata = formatNode(typeDefinitionNode.metadata().get(), 1, 0);\n+            typeDefinitionNode = typeDefinitionNode.modify().withMetadata(metadata).apply();\n+        }\n+        if (typeDefinitionNode.visibilityQualifier().isPresent()) {\n+            Token visibilityQualifier = formatToken(typeDefinitionNode.visibilityQualifier().get(), 1, 0);\n+            typeDefinitionNode = typeDefinitionNode.modify().withVisibilityQualifier(visibilityQualifier).apply();\n+        }\n+\n+        Token typeKeyword = formatToken(typeDefinitionNode.typeKeyword(), 1, 0);\n+        Token typeName = formatToken(typeDefinitionNode.typeName(), 1, 0);\n+        Node typeDescriptor = formatNode(typeDefinitionNode.typeDescriptor(), 1, 0);\n+        Token semicolonToken = formatToken(typeDefinitionNode.semicolonToken(), this.trailingWS, this.trailingNL);\n+\n+        return typeDefinitionNode.modify()\n+                .withTypeKeyword(typeKeyword)\n+                .withTypeName(typeName)\n+                .withTypeDescriptor(typeDescriptor)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public SingletonTypeDescriptorNode transform(SingletonTypeDescriptorNode singletonTypeDescriptorNode) {\n+        ExpressionNode simpleContExprNode = formatNode(singletonTypeDescriptorNode.simpleContExprNode(), 1, 0);\n+        return singletonTypeDescriptorNode.modify()\n+                .withSimpleContExprNode(simpleContExprNode)\n+                .apply();\n+    }\n+\n+    @Override\n+    public WhileStatementNode transform(WhileStatementNode whileStatementNode) {\n+        Token whileKeyword = formatToken(whileStatementNode.whileKeyword(), 1, 0);\n+        ExpressionNode condition = formatNode(whileStatementNode.condition(), 1, 0);\n+        BlockStatementNode whileBody = formatNode(whileStatementNode.whileBody(), this.trailingWS, this.trailingNL);\n+\n+        if (whileStatementNode.onFailClause().isPresent()) {\n+            OnFailClauseNode onFailClause = formatNode(whileStatementNode.onFailClause().get(),\n+                    this.trailingWS, this.trailingNL);\n+            whileStatementNode = whileStatementNode.modify().withOnFailClause(onFailClause).apply();\n+        }\n+\n+        return whileStatementNode.modify()\n+                .withWhileKeyword(whileKeyword)\n+                .withCondition(condition)\n+                .withWhileBody(whileBody)\n+                .apply();\n+    }\n+\n+    @Override\n+    public BracedExpressionNode transform(BracedExpressionNode bracedExpressionNode) {\n+        Token openParen = formatToken(bracedExpressionNode.openParen(), 0, 0);\n+        ExpressionNode expression = formatNode(bracedExpressionNode.expression(), 0, 0);\n+        Token closeParen = formatToken(bracedExpressionNode.closeParen(), 1, 0);\n+\n+        return bracedExpressionNode.modify()\n+                .withOpenParen(openParen)\n+                .withExpression(expression)\n+                .withCloseParen(closeParen)\n+                .apply();\n+    }\n+\n+    @Override\n+    public AssignmentStatementNode transform(AssignmentStatementNode assignmentStatementNode) {\n+        Node varRef = formatNode(assignmentStatementNode.varRef(), 1, 0);\n+        Token equalsToken = formatToken(assignmentStatementNode.equalsToken(), 1, 0);\n+        ExpressionNode expression = formatNode(assignmentStatementNode.expression(), 0, 0);\n+        Token semicolonToken = formatToken(assignmentStatementNode.semicolonToken(), this.trailingWS, this.trailingNL);\n+\n+        return assignmentStatementNode.modify()\n+                .withVarRef(varRef)\n+                .withEqualsToken(equalsToken)\n+                .withExpression(expression)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public CompoundAssignmentStatementNode transform(CompoundAssignmentStatementNode compoundAssignmentStatementNode) {\n+        ExpressionNode lhsExpression = formatNode(compoundAssignmentStatementNode.lhsExpression(), 1, 0);\n+        Token binaryOperator = formatToken(compoundAssignmentStatementNode.binaryOperator(), 0, 0);\n+        Token equalsToken = formatToken(compoundAssignmentStatementNode.equalsToken(), 1, 0);\n+        ExpressionNode rhsExpression = formatNode(compoundAssignmentStatementNode.rhsExpression(), 0, 0);\n+        Token semicolonToken = formatToken(compoundAssignmentStatementNode.semicolonToken(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return compoundAssignmentStatementNode.modify()\n+                .withLhsExpression(lhsExpression)\n+                .withBinaryOperator(binaryOperator)\n+                .withEqualsToken(equalsToken)\n+                .withRhsExpression(rhsExpression)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public DoStatementNode transform(DoStatementNode doStatementNode) {\n+        Token doKeyword = formatToken(doStatementNode.doKeyword(), 1, 0);\n+        BlockStatementNode blockStatement = formatNode(doStatementNode.blockStatement(),\n+                this.trailingWS, this.trailingNL);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a775b9cadbd9a21307035b40d50e91dc8e229ffe"}, "originalPosition": 390}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc4MDQ4Mw==", "bodyText": "Fixed", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26121#discussion_r495780483", "createdAt": "2020-09-28T08:44:49Z", "author": {"login": "IrushiL"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "diffHunk": "@@ -399,6 +429,392 @@ public RecordFieldWithDefaultValueNode transform(RecordFieldWithDefaultValueNode\n                 .apply();\n     }\n \n+    @Override\n+    public ImportDeclarationNode transform(ImportDeclarationNode importDeclarationNode) {\n+        Token importKeyword = formatToken(importDeclarationNode.importKeyword(), 0, 0);\n+\n+        if (importDeclarationNode.orgName().isPresent()) {\n+            ImportOrgNameNode orgName = formatNode(importDeclarationNode.orgName().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withOrgName(orgName).apply();\n+        }\n+        SeparatedNodeList<IdentifierToken> moduleNames = formatSeparatedNodeList(importDeclarationNode.moduleName(),\n+                0, 0, 0, 0, 0, 0);\n+\n+        if (importDeclarationNode.version().isPresent()) {\n+            ImportVersionNode version = formatNode(importDeclarationNode.version().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withVersion(version).apply();\n+        }\n+        if (importDeclarationNode.prefix().isPresent()) {\n+            ImportPrefixNode prefix = formatNode(importDeclarationNode.prefix().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withPrefix(prefix).apply();\n+        }\n+        Token semicolon = formatToken(importDeclarationNode.semicolon(), 0, 1);\n+\n+        return importDeclarationNode.modify()\n+                .withImportKeyword(importKeyword)\n+                .withModuleName(moduleNames)\n+                .withSemicolon(semicolon)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ServiceDeclarationNode transform(ServiceDeclarationNode serviceDeclarationNode) {\n+        if (serviceDeclarationNode.metadata().isPresent()) {\n+            MetadataNode metadata = formatNode(serviceDeclarationNode.metadata().get(), 1, 0);\n+            serviceDeclarationNode = serviceDeclarationNode.modify().withMetadata(metadata).apply();\n+        }\n+\n+        Token serviceKeyword = formatToken(serviceDeclarationNode.serviceKeyword(), 1, 0);\n+        IdentifierToken serviceName = formatToken(serviceDeclarationNode.serviceName(), 1, 0);\n+        Token onKeyword = formatToken(serviceDeclarationNode.onKeyword(), 1, 0);\n+        SeparatedNodeList<ExpressionNode> expressions =\n+                formatSeparatedNodeList(serviceDeclarationNode.expressions(), 0, 0, 0, 0);\n+        Node serviceBody = formatNode(serviceDeclarationNode.serviceBody(), this.trailingWS, this.trailingNL);\n+\n+        return serviceDeclarationNode.modify()\n+                .withServiceKeyword(serviceKeyword)\n+                .withServiceName(serviceName)\n+                .withOnKeyword(onKeyword)\n+                .withExpressions(expressions)\n+                .withServiceBody(serviceBody)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ExplicitNewExpressionNode transform(ExplicitNewExpressionNode explicitNewExpressionNode) {\n+        Token newKeywordToken = formatToken(explicitNewExpressionNode.newKeyword(), 1, 0);\n+        TypeDescriptorNode typeDescriptorNode = formatNode(explicitNewExpressionNode.typeDescriptor(), 0, 0);\n+        ParenthesizedArgList parenthesizedArgList = formatNode(explicitNewExpressionNode.parenthesizedArgList(), 0, 0);\n+\n+        return explicitNewExpressionNode.modify()\n+                .withNewKeyword(newKeywordToken)\n+                .withTypeDescriptor(typeDescriptorNode)\n+                .withParenthesizedArgList(parenthesizedArgList)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ParenthesizedArgList transform(ParenthesizedArgList parenthesizedArgList) {\n+        Token openParenToken = formatToken(parenthesizedArgList.openParenToken(), 0, 0);\n+        SeparatedNodeList<FunctionArgumentNode> arguments = formatSeparatedNodeList(parenthesizedArgList\n+                .arguments(), 0, 0, 0, 0);\n+        Token closeParenToken = formatToken(parenthesizedArgList.closeParenToken(), 1, 0);\n+\n+        return parenthesizedArgList.modify()\n+                .withOpenParenToken(openParenToken)\n+                .withArguments(arguments)\n+                .withCloseParenToken(closeParenToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ServiceBodyNode transform(ServiceBodyNode serviceBodyNode) {\n+        Token openBraceToken = formatToken(serviceBodyNode.openBraceToken(), 0, 1);\n+        indent(); // increase indentation for the statements to follow.\n+        NodeList<Node> resources = formatNodeList(serviceBodyNode.resources(), 0, 1, 0, 1);\n+        unindent(); // reset the indentation\n+        Token closeBraceToken = formatToken(serviceBodyNode.closeBraceToken(), this.trailingWS, this.trailingNL);\n+\n+        return serviceBodyNode.modify()\n+                .withOpenBraceToken(openBraceToken)\n+                .withResources(resources)\n+                .withCloseBraceToken(closeBraceToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public QualifiedNameReferenceNode transform(QualifiedNameReferenceNode qualifiedNameReferenceNode) {\n+        Token modulePrefix = formatToken(qualifiedNameReferenceNode.modulePrefix(), 0, 0);\n+        Token colon = formatToken((Token) qualifiedNameReferenceNode.colon(), 0, 0);\n+        IdentifierToken identifier = formatToken(qualifiedNameReferenceNode.identifier(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return qualifiedNameReferenceNode.modify()\n+                .withModulePrefix(modulePrefix)\n+                .withColon(colon)\n+                .withIdentifier(identifier)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ReturnTypeDescriptorNode transform(ReturnTypeDescriptorNode returnTypeDescriptorNode) {\n+        Token returnsKeyword = formatToken(returnTypeDescriptorNode.returnsKeyword(), 1, 0);\n+        NodeList<AnnotationNode> annotations = formatNodeList(returnTypeDescriptorNode.annotations(), 0, 0, 1, 0);\n+        Node type = formatNode(returnTypeDescriptorNode.type(), 1, 0);\n+\n+        return returnTypeDescriptorNode.modify()\n+                .withReturnsKeyword(returnsKeyword)\n+                .withAnnotations(annotations)\n+                .withType(type)\n+                .apply();\n+    }\n+\n+    @Override\n+    public OptionalTypeDescriptorNode transform(OptionalTypeDescriptorNode optionalTypeDescriptorNode) {\n+        Node typeDescriptor = formatNode(optionalTypeDescriptorNode.typeDescriptor(), 0, 0);\n+        Token questionMarkToken = formatToken(optionalTypeDescriptorNode.questionMarkToken(), 1, 0);\n+\n+        return optionalTypeDescriptorNode.modify()\n+                .withTypeDescriptor(typeDescriptor)\n+                .withQuestionMarkToken(questionMarkToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ExpressionStatementNode transform(ExpressionStatementNode expressionStatementNode) {\n+        ExpressionNode expression = formatNode(expressionStatementNode.expression(), this.trailingWS, this.trailingNL);\n+        Token semicolonToken = formatToken(expressionStatementNode.semicolonToken(), this.trailingWS, this.trailingNL);\n+\n+        return expressionStatementNode.modify()\n+                .withExpression(expression)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public CheckExpressionNode transform(CheckExpressionNode checkExpressionNode) {\n+        Token checkKeyword = formatToken(checkExpressionNode.checkKeyword(), 1, 0);\n+        ExpressionNode expressionNode = formatNode(checkExpressionNode.expression(), this.trailingWS, this.trailingNL);\n+\n+        return checkExpressionNode.modify()\n+                .withCheckKeyword(checkKeyword)\n+                .withExpression(expressionNode)\n+                .apply();\n+    }\n+\n+    @Override\n+    public RemoteMethodCallActionNode transform(RemoteMethodCallActionNode remoteMethodCallActionNode) {\n+        ExpressionNode expression = formatNode(remoteMethodCallActionNode.expression(), 0, 0);\n+        Token rightArrowToken = formatToken(remoteMethodCallActionNode.rightArrowToken(), 0, 0);\n+        SimpleNameReferenceNode methodName = formatNode(remoteMethodCallActionNode.methodName(), 0, 0);\n+        Token openParenToken = formatToken(remoteMethodCallActionNode.openParenToken(), 0, 0);\n+        SeparatedNodeList<FunctionArgumentNode> arguments = formatSeparatedNodeList(remoteMethodCallActionNode\n+                .arguments(), 1, 0, 0, 0);\n+        Token closeParenToken = formatToken(remoteMethodCallActionNode.closeParenToken(), 0, 0);\n+\n+        return remoteMethodCallActionNode.modify()\n+                .withExpression(expression)\n+                .withRightArrowToken(rightArrowToken)\n+                .withMethodName(methodName)\n+                .withOpenParenToken(openParenToken)\n+                .withArguments(arguments)\n+                .withCloseParenToken(closeParenToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public SimpleNameReferenceNode transform(SimpleNameReferenceNode simpleNameReferenceNode) {\n+        Token name = formatToken(simpleNameReferenceNode.name(), this.trailingWS, 0);\n+\n+        return simpleNameReferenceNode.modify()\n+                .withName(name)\n+                .apply();\n+    }\n+\n+    @Override\n+    public TypeDefinitionNode transform(TypeDefinitionNode typeDefinitionNode) {\n+        if (typeDefinitionNode.metadata().isPresent()) {\n+            MetadataNode metadata = formatNode(typeDefinitionNode.metadata().get(), 1, 0);\n+            typeDefinitionNode = typeDefinitionNode.modify().withMetadata(metadata).apply();\n+        }\n+        if (typeDefinitionNode.visibilityQualifier().isPresent()) {\n+            Token visibilityQualifier = formatToken(typeDefinitionNode.visibilityQualifier().get(), 1, 0);\n+            typeDefinitionNode = typeDefinitionNode.modify().withVisibilityQualifier(visibilityQualifier).apply();\n+        }\n+\n+        Token typeKeyword = formatToken(typeDefinitionNode.typeKeyword(), 1, 0);\n+        Token typeName = formatToken(typeDefinitionNode.typeName(), 1, 0);\n+        Node typeDescriptor = formatNode(typeDefinitionNode.typeDescriptor(), 1, 0);\n+        Token semicolonToken = formatToken(typeDefinitionNode.semicolonToken(), this.trailingWS, this.trailingNL);\n+\n+        return typeDefinitionNode.modify()\n+                .withTypeKeyword(typeKeyword)\n+                .withTypeName(typeName)\n+                .withTypeDescriptor(typeDescriptor)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public SingletonTypeDescriptorNode transform(SingletonTypeDescriptorNode singletonTypeDescriptorNode) {\n+        ExpressionNode simpleContExprNode = formatNode(singletonTypeDescriptorNode.simpleContExprNode(), 1, 0);\n+        return singletonTypeDescriptorNode.modify()\n+                .withSimpleContExprNode(simpleContExprNode)\n+                .apply();\n+    }\n+\n+    @Override\n+    public WhileStatementNode transform(WhileStatementNode whileStatementNode) {\n+        Token whileKeyword = formatToken(whileStatementNode.whileKeyword(), 1, 0);\n+        ExpressionNode condition = formatNode(whileStatementNode.condition(), 1, 0);\n+        BlockStatementNode whileBody = formatNode(whileStatementNode.whileBody(), this.trailingWS, this.trailingNL);\n+\n+        if (whileStatementNode.onFailClause().isPresent()) {\n+            OnFailClauseNode onFailClause = formatNode(whileStatementNode.onFailClause().get(),\n+                    this.trailingWS, this.trailingNL);\n+            whileStatementNode = whileStatementNode.modify().withOnFailClause(onFailClause).apply();\n+        }\n+\n+        return whileStatementNode.modify()\n+                .withWhileKeyword(whileKeyword)\n+                .withCondition(condition)\n+                .withWhileBody(whileBody)\n+                .apply();\n+    }\n+\n+    @Override\n+    public BracedExpressionNode transform(BracedExpressionNode bracedExpressionNode) {\n+        Token openParen = formatToken(bracedExpressionNode.openParen(), 0, 0);\n+        ExpressionNode expression = formatNode(bracedExpressionNode.expression(), 0, 0);\n+        Token closeParen = formatToken(bracedExpressionNode.closeParen(), 1, 0);\n+\n+        return bracedExpressionNode.modify()\n+                .withOpenParen(openParen)\n+                .withExpression(expression)\n+                .withCloseParen(closeParen)\n+                .apply();\n+    }\n+\n+    @Override\n+    public AssignmentStatementNode transform(AssignmentStatementNode assignmentStatementNode) {\n+        Node varRef = formatNode(assignmentStatementNode.varRef(), 1, 0);\n+        Token equalsToken = formatToken(assignmentStatementNode.equalsToken(), 1, 0);\n+        ExpressionNode expression = formatNode(assignmentStatementNode.expression(), 0, 0);\n+        Token semicolonToken = formatToken(assignmentStatementNode.semicolonToken(), this.trailingWS, this.trailingNL);\n+\n+        return assignmentStatementNode.modify()\n+                .withVarRef(varRef)\n+                .withEqualsToken(equalsToken)\n+                .withExpression(expression)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public CompoundAssignmentStatementNode transform(CompoundAssignmentStatementNode compoundAssignmentStatementNode) {\n+        ExpressionNode lhsExpression = formatNode(compoundAssignmentStatementNode.lhsExpression(), 1, 0);\n+        Token binaryOperator = formatToken(compoundAssignmentStatementNode.binaryOperator(), 0, 0);\n+        Token equalsToken = formatToken(compoundAssignmentStatementNode.equalsToken(), 1, 0);\n+        ExpressionNode rhsExpression = formatNode(compoundAssignmentStatementNode.rhsExpression(), 0, 0);\n+        Token semicolonToken = formatToken(compoundAssignmentStatementNode.semicolonToken(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return compoundAssignmentStatementNode.modify()\n+                .withLhsExpression(lhsExpression)\n+                .withBinaryOperator(binaryOperator)\n+                .withEqualsToken(equalsToken)\n+                .withRhsExpression(rhsExpression)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public DoStatementNode transform(DoStatementNode doStatementNode) {\n+        Token doKeyword = formatToken(doStatementNode.doKeyword(), 1, 0);\n+        BlockStatementNode blockStatement = formatNode(doStatementNode.blockStatement(),\n+                this.trailingWS, this.trailingNL);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY5MjEwOQ=="}, "originalCommit": {"oid": "a775b9cadbd9a21307035b40d50e91dc8e229ffe"}, "originalPosition": 390}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwMzAwNzU1OnYy", "diffSide": "RIGHT", "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwNToxNzowOFrOHYuukw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwODo0NDo1NlrOHY0CxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY5MzQ1OQ==", "bodyText": "I feel we should keep a WS after the last expression.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26121#discussion_r495693459", "createdAt": "2020-09-28T05:17:08Z", "author": {"login": "SupunS"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "diffHunk": "@@ -399,6 +429,392 @@ public RecordFieldWithDefaultValueNode transform(RecordFieldWithDefaultValueNode\n                 .apply();\n     }\n \n+    @Override\n+    public ImportDeclarationNode transform(ImportDeclarationNode importDeclarationNode) {\n+        Token importKeyword = formatToken(importDeclarationNode.importKeyword(), 0, 0);\n+\n+        if (importDeclarationNode.orgName().isPresent()) {\n+            ImportOrgNameNode orgName = formatNode(importDeclarationNode.orgName().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withOrgName(orgName).apply();\n+        }\n+        SeparatedNodeList<IdentifierToken> moduleNames = formatSeparatedNodeList(importDeclarationNode.moduleName(),\n+                0, 0, 0, 0, 0, 0);\n+\n+        if (importDeclarationNode.version().isPresent()) {\n+            ImportVersionNode version = formatNode(importDeclarationNode.version().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withVersion(version).apply();\n+        }\n+        if (importDeclarationNode.prefix().isPresent()) {\n+            ImportPrefixNode prefix = formatNode(importDeclarationNode.prefix().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withPrefix(prefix).apply();\n+        }\n+        Token semicolon = formatToken(importDeclarationNode.semicolon(), 0, 1);\n+\n+        return importDeclarationNode.modify()\n+                .withImportKeyword(importKeyword)\n+                .withModuleName(moduleNames)\n+                .withSemicolon(semicolon)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ServiceDeclarationNode transform(ServiceDeclarationNode serviceDeclarationNode) {\n+        if (serviceDeclarationNode.metadata().isPresent()) {\n+            MetadataNode metadata = formatNode(serviceDeclarationNode.metadata().get(), 1, 0);\n+            serviceDeclarationNode = serviceDeclarationNode.modify().withMetadata(metadata).apply();\n+        }\n+\n+        Token serviceKeyword = formatToken(serviceDeclarationNode.serviceKeyword(), 1, 0);\n+        IdentifierToken serviceName = formatToken(serviceDeclarationNode.serviceName(), 1, 0);\n+        Token onKeyword = formatToken(serviceDeclarationNode.onKeyword(), 1, 0);\n+        SeparatedNodeList<ExpressionNode> expressions =\n+                formatSeparatedNodeList(serviceDeclarationNode.expressions(), 0, 0, 0, 0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a775b9cadbd9a21307035b40d50e91dc8e229ffe"}, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc4MDU0OQ==", "bodyText": "Fixed", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26121#discussion_r495780549", "createdAt": "2020-09-28T08:44:56Z", "author": {"login": "IrushiL"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "diffHunk": "@@ -399,6 +429,392 @@ public RecordFieldWithDefaultValueNode transform(RecordFieldWithDefaultValueNode\n                 .apply();\n     }\n \n+    @Override\n+    public ImportDeclarationNode transform(ImportDeclarationNode importDeclarationNode) {\n+        Token importKeyword = formatToken(importDeclarationNode.importKeyword(), 0, 0);\n+\n+        if (importDeclarationNode.orgName().isPresent()) {\n+            ImportOrgNameNode orgName = formatNode(importDeclarationNode.orgName().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withOrgName(orgName).apply();\n+        }\n+        SeparatedNodeList<IdentifierToken> moduleNames = formatSeparatedNodeList(importDeclarationNode.moduleName(),\n+                0, 0, 0, 0, 0, 0);\n+\n+        if (importDeclarationNode.version().isPresent()) {\n+            ImportVersionNode version = formatNode(importDeclarationNode.version().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withVersion(version).apply();\n+        }\n+        if (importDeclarationNode.prefix().isPresent()) {\n+            ImportPrefixNode prefix = formatNode(importDeclarationNode.prefix().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withPrefix(prefix).apply();\n+        }\n+        Token semicolon = formatToken(importDeclarationNode.semicolon(), 0, 1);\n+\n+        return importDeclarationNode.modify()\n+                .withImportKeyword(importKeyword)\n+                .withModuleName(moduleNames)\n+                .withSemicolon(semicolon)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ServiceDeclarationNode transform(ServiceDeclarationNode serviceDeclarationNode) {\n+        if (serviceDeclarationNode.metadata().isPresent()) {\n+            MetadataNode metadata = formatNode(serviceDeclarationNode.metadata().get(), 1, 0);\n+            serviceDeclarationNode = serviceDeclarationNode.modify().withMetadata(metadata).apply();\n+        }\n+\n+        Token serviceKeyword = formatToken(serviceDeclarationNode.serviceKeyword(), 1, 0);\n+        IdentifierToken serviceName = formatToken(serviceDeclarationNode.serviceName(), 1, 0);\n+        Token onKeyword = formatToken(serviceDeclarationNode.onKeyword(), 1, 0);\n+        SeparatedNodeList<ExpressionNode> expressions =\n+                formatSeparatedNodeList(serviceDeclarationNode.expressions(), 0, 0, 0, 0);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY5MzQ1OQ=="}, "originalCommit": {"oid": "a775b9cadbd9a21307035b40d50e91dc8e229ffe"}, "originalPosition": 146}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwMzAxMjQxOnYy", "diffSide": "RIGHT", "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwNToyMDoxMFrOHYuxbw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwODo0NTowN1rOHY0DRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY5NDE5MQ==", "bodyText": "Might need a WS after the binding pattern. otherwise will cause a syntax error", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26121#discussion_r495694191", "createdAt": "2020-09-28T05:20:10Z", "author": {"login": "SupunS"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "diffHunk": "@@ -399,6 +429,392 @@ public RecordFieldWithDefaultValueNode transform(RecordFieldWithDefaultValueNode\n                 .apply();\n     }\n \n+    @Override\n+    public ImportDeclarationNode transform(ImportDeclarationNode importDeclarationNode) {\n+        Token importKeyword = formatToken(importDeclarationNode.importKeyword(), 0, 0);\n+\n+        if (importDeclarationNode.orgName().isPresent()) {\n+            ImportOrgNameNode orgName = formatNode(importDeclarationNode.orgName().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withOrgName(orgName).apply();\n+        }\n+        SeparatedNodeList<IdentifierToken> moduleNames = formatSeparatedNodeList(importDeclarationNode.moduleName(),\n+                0, 0, 0, 0, 0, 0);\n+\n+        if (importDeclarationNode.version().isPresent()) {\n+            ImportVersionNode version = formatNode(importDeclarationNode.version().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withVersion(version).apply();\n+        }\n+        if (importDeclarationNode.prefix().isPresent()) {\n+            ImportPrefixNode prefix = formatNode(importDeclarationNode.prefix().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withPrefix(prefix).apply();\n+        }\n+        Token semicolon = formatToken(importDeclarationNode.semicolon(), 0, 1);\n+\n+        return importDeclarationNode.modify()\n+                .withImportKeyword(importKeyword)\n+                .withModuleName(moduleNames)\n+                .withSemicolon(semicolon)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ServiceDeclarationNode transform(ServiceDeclarationNode serviceDeclarationNode) {\n+        if (serviceDeclarationNode.metadata().isPresent()) {\n+            MetadataNode metadata = formatNode(serviceDeclarationNode.metadata().get(), 1, 0);\n+            serviceDeclarationNode = serviceDeclarationNode.modify().withMetadata(metadata).apply();\n+        }\n+\n+        Token serviceKeyword = formatToken(serviceDeclarationNode.serviceKeyword(), 1, 0);\n+        IdentifierToken serviceName = formatToken(serviceDeclarationNode.serviceName(), 1, 0);\n+        Token onKeyword = formatToken(serviceDeclarationNode.onKeyword(), 1, 0);\n+        SeparatedNodeList<ExpressionNode> expressions =\n+                formatSeparatedNodeList(serviceDeclarationNode.expressions(), 0, 0, 0, 0);\n+        Node serviceBody = formatNode(serviceDeclarationNode.serviceBody(), this.trailingWS, this.trailingNL);\n+\n+        return serviceDeclarationNode.modify()\n+                .withServiceKeyword(serviceKeyword)\n+                .withServiceName(serviceName)\n+                .withOnKeyword(onKeyword)\n+                .withExpressions(expressions)\n+                .withServiceBody(serviceBody)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ExplicitNewExpressionNode transform(ExplicitNewExpressionNode explicitNewExpressionNode) {\n+        Token newKeywordToken = formatToken(explicitNewExpressionNode.newKeyword(), 1, 0);\n+        TypeDescriptorNode typeDescriptorNode = formatNode(explicitNewExpressionNode.typeDescriptor(), 0, 0);\n+        ParenthesizedArgList parenthesizedArgList = formatNode(explicitNewExpressionNode.parenthesizedArgList(), 0, 0);\n+\n+        return explicitNewExpressionNode.modify()\n+                .withNewKeyword(newKeywordToken)\n+                .withTypeDescriptor(typeDescriptorNode)\n+                .withParenthesizedArgList(parenthesizedArgList)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ParenthesizedArgList transform(ParenthesizedArgList parenthesizedArgList) {\n+        Token openParenToken = formatToken(parenthesizedArgList.openParenToken(), 0, 0);\n+        SeparatedNodeList<FunctionArgumentNode> arguments = formatSeparatedNodeList(parenthesizedArgList\n+                .arguments(), 0, 0, 0, 0);\n+        Token closeParenToken = formatToken(parenthesizedArgList.closeParenToken(), 1, 0);\n+\n+        return parenthesizedArgList.modify()\n+                .withOpenParenToken(openParenToken)\n+                .withArguments(arguments)\n+                .withCloseParenToken(closeParenToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ServiceBodyNode transform(ServiceBodyNode serviceBodyNode) {\n+        Token openBraceToken = formatToken(serviceBodyNode.openBraceToken(), 0, 1);\n+        indent(); // increase indentation for the statements to follow.\n+        NodeList<Node> resources = formatNodeList(serviceBodyNode.resources(), 0, 1, 0, 1);\n+        unindent(); // reset the indentation\n+        Token closeBraceToken = formatToken(serviceBodyNode.closeBraceToken(), this.trailingWS, this.trailingNL);\n+\n+        return serviceBodyNode.modify()\n+                .withOpenBraceToken(openBraceToken)\n+                .withResources(resources)\n+                .withCloseBraceToken(closeBraceToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public QualifiedNameReferenceNode transform(QualifiedNameReferenceNode qualifiedNameReferenceNode) {\n+        Token modulePrefix = formatToken(qualifiedNameReferenceNode.modulePrefix(), 0, 0);\n+        Token colon = formatToken((Token) qualifiedNameReferenceNode.colon(), 0, 0);\n+        IdentifierToken identifier = formatToken(qualifiedNameReferenceNode.identifier(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return qualifiedNameReferenceNode.modify()\n+                .withModulePrefix(modulePrefix)\n+                .withColon(colon)\n+                .withIdentifier(identifier)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ReturnTypeDescriptorNode transform(ReturnTypeDescriptorNode returnTypeDescriptorNode) {\n+        Token returnsKeyword = formatToken(returnTypeDescriptorNode.returnsKeyword(), 1, 0);\n+        NodeList<AnnotationNode> annotations = formatNodeList(returnTypeDescriptorNode.annotations(), 0, 0, 1, 0);\n+        Node type = formatNode(returnTypeDescriptorNode.type(), 1, 0);\n+\n+        return returnTypeDescriptorNode.modify()\n+                .withReturnsKeyword(returnsKeyword)\n+                .withAnnotations(annotations)\n+                .withType(type)\n+                .apply();\n+    }\n+\n+    @Override\n+    public OptionalTypeDescriptorNode transform(OptionalTypeDescriptorNode optionalTypeDescriptorNode) {\n+        Node typeDescriptor = formatNode(optionalTypeDescriptorNode.typeDescriptor(), 0, 0);\n+        Token questionMarkToken = formatToken(optionalTypeDescriptorNode.questionMarkToken(), 1, 0);\n+\n+        return optionalTypeDescriptorNode.modify()\n+                .withTypeDescriptor(typeDescriptor)\n+                .withQuestionMarkToken(questionMarkToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ExpressionStatementNode transform(ExpressionStatementNode expressionStatementNode) {\n+        ExpressionNode expression = formatNode(expressionStatementNode.expression(), this.trailingWS, this.trailingNL);\n+        Token semicolonToken = formatToken(expressionStatementNode.semicolonToken(), this.trailingWS, this.trailingNL);\n+\n+        return expressionStatementNode.modify()\n+                .withExpression(expression)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public CheckExpressionNode transform(CheckExpressionNode checkExpressionNode) {\n+        Token checkKeyword = formatToken(checkExpressionNode.checkKeyword(), 1, 0);\n+        ExpressionNode expressionNode = formatNode(checkExpressionNode.expression(), this.trailingWS, this.trailingNL);\n+\n+        return checkExpressionNode.modify()\n+                .withCheckKeyword(checkKeyword)\n+                .withExpression(expressionNode)\n+                .apply();\n+    }\n+\n+    @Override\n+    public RemoteMethodCallActionNode transform(RemoteMethodCallActionNode remoteMethodCallActionNode) {\n+        ExpressionNode expression = formatNode(remoteMethodCallActionNode.expression(), 0, 0);\n+        Token rightArrowToken = formatToken(remoteMethodCallActionNode.rightArrowToken(), 0, 0);\n+        SimpleNameReferenceNode methodName = formatNode(remoteMethodCallActionNode.methodName(), 0, 0);\n+        Token openParenToken = formatToken(remoteMethodCallActionNode.openParenToken(), 0, 0);\n+        SeparatedNodeList<FunctionArgumentNode> arguments = formatSeparatedNodeList(remoteMethodCallActionNode\n+                .arguments(), 1, 0, 0, 0);\n+        Token closeParenToken = formatToken(remoteMethodCallActionNode.closeParenToken(), 0, 0);\n+\n+        return remoteMethodCallActionNode.modify()\n+                .withExpression(expression)\n+                .withRightArrowToken(rightArrowToken)\n+                .withMethodName(methodName)\n+                .withOpenParenToken(openParenToken)\n+                .withArguments(arguments)\n+                .withCloseParenToken(closeParenToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public SimpleNameReferenceNode transform(SimpleNameReferenceNode simpleNameReferenceNode) {\n+        Token name = formatToken(simpleNameReferenceNode.name(), this.trailingWS, 0);\n+\n+        return simpleNameReferenceNode.modify()\n+                .withName(name)\n+                .apply();\n+    }\n+\n+    @Override\n+    public TypeDefinitionNode transform(TypeDefinitionNode typeDefinitionNode) {\n+        if (typeDefinitionNode.metadata().isPresent()) {\n+            MetadataNode metadata = formatNode(typeDefinitionNode.metadata().get(), 1, 0);\n+            typeDefinitionNode = typeDefinitionNode.modify().withMetadata(metadata).apply();\n+        }\n+        if (typeDefinitionNode.visibilityQualifier().isPresent()) {\n+            Token visibilityQualifier = formatToken(typeDefinitionNode.visibilityQualifier().get(), 1, 0);\n+            typeDefinitionNode = typeDefinitionNode.modify().withVisibilityQualifier(visibilityQualifier).apply();\n+        }\n+\n+        Token typeKeyword = formatToken(typeDefinitionNode.typeKeyword(), 1, 0);\n+        Token typeName = formatToken(typeDefinitionNode.typeName(), 1, 0);\n+        Node typeDescriptor = formatNode(typeDefinitionNode.typeDescriptor(), 1, 0);\n+        Token semicolonToken = formatToken(typeDefinitionNode.semicolonToken(), this.trailingWS, this.trailingNL);\n+\n+        return typeDefinitionNode.modify()\n+                .withTypeKeyword(typeKeyword)\n+                .withTypeName(typeName)\n+                .withTypeDescriptor(typeDescriptor)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public SingletonTypeDescriptorNode transform(SingletonTypeDescriptorNode singletonTypeDescriptorNode) {\n+        ExpressionNode simpleContExprNode = formatNode(singletonTypeDescriptorNode.simpleContExprNode(), 1, 0);\n+        return singletonTypeDescriptorNode.modify()\n+                .withSimpleContExprNode(simpleContExprNode)\n+                .apply();\n+    }\n+\n+    @Override\n+    public WhileStatementNode transform(WhileStatementNode whileStatementNode) {\n+        Token whileKeyword = formatToken(whileStatementNode.whileKeyword(), 1, 0);\n+        ExpressionNode condition = formatNode(whileStatementNode.condition(), 1, 0);\n+        BlockStatementNode whileBody = formatNode(whileStatementNode.whileBody(), this.trailingWS, this.trailingNL);\n+\n+        if (whileStatementNode.onFailClause().isPresent()) {\n+            OnFailClauseNode onFailClause = formatNode(whileStatementNode.onFailClause().get(),\n+                    this.trailingWS, this.trailingNL);\n+            whileStatementNode = whileStatementNode.modify().withOnFailClause(onFailClause).apply();\n+        }\n+\n+        return whileStatementNode.modify()\n+                .withWhileKeyword(whileKeyword)\n+                .withCondition(condition)\n+                .withWhileBody(whileBody)\n+                .apply();\n+    }\n+\n+    @Override\n+    public BracedExpressionNode transform(BracedExpressionNode bracedExpressionNode) {\n+        Token openParen = formatToken(bracedExpressionNode.openParen(), 0, 0);\n+        ExpressionNode expression = formatNode(bracedExpressionNode.expression(), 0, 0);\n+        Token closeParen = formatToken(bracedExpressionNode.closeParen(), 1, 0);\n+\n+        return bracedExpressionNode.modify()\n+                .withOpenParen(openParen)\n+                .withExpression(expression)\n+                .withCloseParen(closeParen)\n+                .apply();\n+    }\n+\n+    @Override\n+    public AssignmentStatementNode transform(AssignmentStatementNode assignmentStatementNode) {\n+        Node varRef = formatNode(assignmentStatementNode.varRef(), 1, 0);\n+        Token equalsToken = formatToken(assignmentStatementNode.equalsToken(), 1, 0);\n+        ExpressionNode expression = formatNode(assignmentStatementNode.expression(), 0, 0);\n+        Token semicolonToken = formatToken(assignmentStatementNode.semicolonToken(), this.trailingWS, this.trailingNL);\n+\n+        return assignmentStatementNode.modify()\n+                .withVarRef(varRef)\n+                .withEqualsToken(equalsToken)\n+                .withExpression(expression)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public CompoundAssignmentStatementNode transform(CompoundAssignmentStatementNode compoundAssignmentStatementNode) {\n+        ExpressionNode lhsExpression = formatNode(compoundAssignmentStatementNode.lhsExpression(), 1, 0);\n+        Token binaryOperator = formatToken(compoundAssignmentStatementNode.binaryOperator(), 0, 0);\n+        Token equalsToken = formatToken(compoundAssignmentStatementNode.equalsToken(), 1, 0);\n+        ExpressionNode rhsExpression = formatNode(compoundAssignmentStatementNode.rhsExpression(), 0, 0);\n+        Token semicolonToken = formatToken(compoundAssignmentStatementNode.semicolonToken(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return compoundAssignmentStatementNode.modify()\n+                .withLhsExpression(lhsExpression)\n+                .withBinaryOperator(binaryOperator)\n+                .withEqualsToken(equalsToken)\n+                .withRhsExpression(rhsExpression)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public DoStatementNode transform(DoStatementNode doStatementNode) {\n+        Token doKeyword = formatToken(doStatementNode.doKeyword(), 1, 0);\n+        BlockStatementNode blockStatement = formatNode(doStatementNode.blockStatement(),\n+                this.trailingWS, this.trailingNL);\n+\n+        if (doStatementNode.onFailClause().isPresent()) {\n+            OnFailClauseNode onFailClause = formatNode(doStatementNode.onFailClause().get(),\n+                    this.trailingWS, this.trailingNL);\n+            doStatementNode = doStatementNode.modify().withOnFailClause(onFailClause).apply();\n+        }\n+\n+        return doStatementNode.modify()\n+                .withDoKeyword(doKeyword)\n+                .withBlockStatement(blockStatement)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ForEachStatementNode transform(ForEachStatementNode forEachStatementNode) {\n+        Token forEachKeyword = formatToken(forEachStatementNode.forEachKeyword(), 1, 0);\n+        TypedBindingPatternNode typedBindingPattern = formatNode(forEachStatementNode.typedBindingPattern(), 0, 0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a775b9cadbd9a21307035b40d50e91dc8e229ffe"}, "originalPosition": 407}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc4MDY3Ng==", "bodyText": "Fixed", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26121#discussion_r495780676", "createdAt": "2020-09-28T08:45:07Z", "author": {"login": "IrushiL"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "diffHunk": "@@ -399,6 +429,392 @@ public RecordFieldWithDefaultValueNode transform(RecordFieldWithDefaultValueNode\n                 .apply();\n     }\n \n+    @Override\n+    public ImportDeclarationNode transform(ImportDeclarationNode importDeclarationNode) {\n+        Token importKeyword = formatToken(importDeclarationNode.importKeyword(), 0, 0);\n+\n+        if (importDeclarationNode.orgName().isPresent()) {\n+            ImportOrgNameNode orgName = formatNode(importDeclarationNode.orgName().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withOrgName(orgName).apply();\n+        }\n+        SeparatedNodeList<IdentifierToken> moduleNames = formatSeparatedNodeList(importDeclarationNode.moduleName(),\n+                0, 0, 0, 0, 0, 0);\n+\n+        if (importDeclarationNode.version().isPresent()) {\n+            ImportVersionNode version = formatNode(importDeclarationNode.version().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withVersion(version).apply();\n+        }\n+        if (importDeclarationNode.prefix().isPresent()) {\n+            ImportPrefixNode prefix = formatNode(importDeclarationNode.prefix().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withPrefix(prefix).apply();\n+        }\n+        Token semicolon = formatToken(importDeclarationNode.semicolon(), 0, 1);\n+\n+        return importDeclarationNode.modify()\n+                .withImportKeyword(importKeyword)\n+                .withModuleName(moduleNames)\n+                .withSemicolon(semicolon)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ServiceDeclarationNode transform(ServiceDeclarationNode serviceDeclarationNode) {\n+        if (serviceDeclarationNode.metadata().isPresent()) {\n+            MetadataNode metadata = formatNode(serviceDeclarationNode.metadata().get(), 1, 0);\n+            serviceDeclarationNode = serviceDeclarationNode.modify().withMetadata(metadata).apply();\n+        }\n+\n+        Token serviceKeyword = formatToken(serviceDeclarationNode.serviceKeyword(), 1, 0);\n+        IdentifierToken serviceName = formatToken(serviceDeclarationNode.serviceName(), 1, 0);\n+        Token onKeyword = formatToken(serviceDeclarationNode.onKeyword(), 1, 0);\n+        SeparatedNodeList<ExpressionNode> expressions =\n+                formatSeparatedNodeList(serviceDeclarationNode.expressions(), 0, 0, 0, 0);\n+        Node serviceBody = formatNode(serviceDeclarationNode.serviceBody(), this.trailingWS, this.trailingNL);\n+\n+        return serviceDeclarationNode.modify()\n+                .withServiceKeyword(serviceKeyword)\n+                .withServiceName(serviceName)\n+                .withOnKeyword(onKeyword)\n+                .withExpressions(expressions)\n+                .withServiceBody(serviceBody)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ExplicitNewExpressionNode transform(ExplicitNewExpressionNode explicitNewExpressionNode) {\n+        Token newKeywordToken = formatToken(explicitNewExpressionNode.newKeyword(), 1, 0);\n+        TypeDescriptorNode typeDescriptorNode = formatNode(explicitNewExpressionNode.typeDescriptor(), 0, 0);\n+        ParenthesizedArgList parenthesizedArgList = formatNode(explicitNewExpressionNode.parenthesizedArgList(), 0, 0);\n+\n+        return explicitNewExpressionNode.modify()\n+                .withNewKeyword(newKeywordToken)\n+                .withTypeDescriptor(typeDescriptorNode)\n+                .withParenthesizedArgList(parenthesizedArgList)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ParenthesizedArgList transform(ParenthesizedArgList parenthesizedArgList) {\n+        Token openParenToken = formatToken(parenthesizedArgList.openParenToken(), 0, 0);\n+        SeparatedNodeList<FunctionArgumentNode> arguments = formatSeparatedNodeList(parenthesizedArgList\n+                .arguments(), 0, 0, 0, 0);\n+        Token closeParenToken = formatToken(parenthesizedArgList.closeParenToken(), 1, 0);\n+\n+        return parenthesizedArgList.modify()\n+                .withOpenParenToken(openParenToken)\n+                .withArguments(arguments)\n+                .withCloseParenToken(closeParenToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ServiceBodyNode transform(ServiceBodyNode serviceBodyNode) {\n+        Token openBraceToken = formatToken(serviceBodyNode.openBraceToken(), 0, 1);\n+        indent(); // increase indentation for the statements to follow.\n+        NodeList<Node> resources = formatNodeList(serviceBodyNode.resources(), 0, 1, 0, 1);\n+        unindent(); // reset the indentation\n+        Token closeBraceToken = formatToken(serviceBodyNode.closeBraceToken(), this.trailingWS, this.trailingNL);\n+\n+        return serviceBodyNode.modify()\n+                .withOpenBraceToken(openBraceToken)\n+                .withResources(resources)\n+                .withCloseBraceToken(closeBraceToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public QualifiedNameReferenceNode transform(QualifiedNameReferenceNode qualifiedNameReferenceNode) {\n+        Token modulePrefix = formatToken(qualifiedNameReferenceNode.modulePrefix(), 0, 0);\n+        Token colon = formatToken((Token) qualifiedNameReferenceNode.colon(), 0, 0);\n+        IdentifierToken identifier = formatToken(qualifiedNameReferenceNode.identifier(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return qualifiedNameReferenceNode.modify()\n+                .withModulePrefix(modulePrefix)\n+                .withColon(colon)\n+                .withIdentifier(identifier)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ReturnTypeDescriptorNode transform(ReturnTypeDescriptorNode returnTypeDescriptorNode) {\n+        Token returnsKeyword = formatToken(returnTypeDescriptorNode.returnsKeyword(), 1, 0);\n+        NodeList<AnnotationNode> annotations = formatNodeList(returnTypeDescriptorNode.annotations(), 0, 0, 1, 0);\n+        Node type = formatNode(returnTypeDescriptorNode.type(), 1, 0);\n+\n+        return returnTypeDescriptorNode.modify()\n+                .withReturnsKeyword(returnsKeyword)\n+                .withAnnotations(annotations)\n+                .withType(type)\n+                .apply();\n+    }\n+\n+    @Override\n+    public OptionalTypeDescriptorNode transform(OptionalTypeDescriptorNode optionalTypeDescriptorNode) {\n+        Node typeDescriptor = formatNode(optionalTypeDescriptorNode.typeDescriptor(), 0, 0);\n+        Token questionMarkToken = formatToken(optionalTypeDescriptorNode.questionMarkToken(), 1, 0);\n+\n+        return optionalTypeDescriptorNode.modify()\n+                .withTypeDescriptor(typeDescriptor)\n+                .withQuestionMarkToken(questionMarkToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ExpressionStatementNode transform(ExpressionStatementNode expressionStatementNode) {\n+        ExpressionNode expression = formatNode(expressionStatementNode.expression(), this.trailingWS, this.trailingNL);\n+        Token semicolonToken = formatToken(expressionStatementNode.semicolonToken(), this.trailingWS, this.trailingNL);\n+\n+        return expressionStatementNode.modify()\n+                .withExpression(expression)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public CheckExpressionNode transform(CheckExpressionNode checkExpressionNode) {\n+        Token checkKeyword = formatToken(checkExpressionNode.checkKeyword(), 1, 0);\n+        ExpressionNode expressionNode = formatNode(checkExpressionNode.expression(), this.trailingWS, this.trailingNL);\n+\n+        return checkExpressionNode.modify()\n+                .withCheckKeyword(checkKeyword)\n+                .withExpression(expressionNode)\n+                .apply();\n+    }\n+\n+    @Override\n+    public RemoteMethodCallActionNode transform(RemoteMethodCallActionNode remoteMethodCallActionNode) {\n+        ExpressionNode expression = formatNode(remoteMethodCallActionNode.expression(), 0, 0);\n+        Token rightArrowToken = formatToken(remoteMethodCallActionNode.rightArrowToken(), 0, 0);\n+        SimpleNameReferenceNode methodName = formatNode(remoteMethodCallActionNode.methodName(), 0, 0);\n+        Token openParenToken = formatToken(remoteMethodCallActionNode.openParenToken(), 0, 0);\n+        SeparatedNodeList<FunctionArgumentNode> arguments = formatSeparatedNodeList(remoteMethodCallActionNode\n+                .arguments(), 1, 0, 0, 0);\n+        Token closeParenToken = formatToken(remoteMethodCallActionNode.closeParenToken(), 0, 0);\n+\n+        return remoteMethodCallActionNode.modify()\n+                .withExpression(expression)\n+                .withRightArrowToken(rightArrowToken)\n+                .withMethodName(methodName)\n+                .withOpenParenToken(openParenToken)\n+                .withArguments(arguments)\n+                .withCloseParenToken(closeParenToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public SimpleNameReferenceNode transform(SimpleNameReferenceNode simpleNameReferenceNode) {\n+        Token name = formatToken(simpleNameReferenceNode.name(), this.trailingWS, 0);\n+\n+        return simpleNameReferenceNode.modify()\n+                .withName(name)\n+                .apply();\n+    }\n+\n+    @Override\n+    public TypeDefinitionNode transform(TypeDefinitionNode typeDefinitionNode) {\n+        if (typeDefinitionNode.metadata().isPresent()) {\n+            MetadataNode metadata = formatNode(typeDefinitionNode.metadata().get(), 1, 0);\n+            typeDefinitionNode = typeDefinitionNode.modify().withMetadata(metadata).apply();\n+        }\n+        if (typeDefinitionNode.visibilityQualifier().isPresent()) {\n+            Token visibilityQualifier = formatToken(typeDefinitionNode.visibilityQualifier().get(), 1, 0);\n+            typeDefinitionNode = typeDefinitionNode.modify().withVisibilityQualifier(visibilityQualifier).apply();\n+        }\n+\n+        Token typeKeyword = formatToken(typeDefinitionNode.typeKeyword(), 1, 0);\n+        Token typeName = formatToken(typeDefinitionNode.typeName(), 1, 0);\n+        Node typeDescriptor = formatNode(typeDefinitionNode.typeDescriptor(), 1, 0);\n+        Token semicolonToken = formatToken(typeDefinitionNode.semicolonToken(), this.trailingWS, this.trailingNL);\n+\n+        return typeDefinitionNode.modify()\n+                .withTypeKeyword(typeKeyword)\n+                .withTypeName(typeName)\n+                .withTypeDescriptor(typeDescriptor)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public SingletonTypeDescriptorNode transform(SingletonTypeDescriptorNode singletonTypeDescriptorNode) {\n+        ExpressionNode simpleContExprNode = formatNode(singletonTypeDescriptorNode.simpleContExprNode(), 1, 0);\n+        return singletonTypeDescriptorNode.modify()\n+                .withSimpleContExprNode(simpleContExprNode)\n+                .apply();\n+    }\n+\n+    @Override\n+    public WhileStatementNode transform(WhileStatementNode whileStatementNode) {\n+        Token whileKeyword = formatToken(whileStatementNode.whileKeyword(), 1, 0);\n+        ExpressionNode condition = formatNode(whileStatementNode.condition(), 1, 0);\n+        BlockStatementNode whileBody = formatNode(whileStatementNode.whileBody(), this.trailingWS, this.trailingNL);\n+\n+        if (whileStatementNode.onFailClause().isPresent()) {\n+            OnFailClauseNode onFailClause = formatNode(whileStatementNode.onFailClause().get(),\n+                    this.trailingWS, this.trailingNL);\n+            whileStatementNode = whileStatementNode.modify().withOnFailClause(onFailClause).apply();\n+        }\n+\n+        return whileStatementNode.modify()\n+                .withWhileKeyword(whileKeyword)\n+                .withCondition(condition)\n+                .withWhileBody(whileBody)\n+                .apply();\n+    }\n+\n+    @Override\n+    public BracedExpressionNode transform(BracedExpressionNode bracedExpressionNode) {\n+        Token openParen = formatToken(bracedExpressionNode.openParen(), 0, 0);\n+        ExpressionNode expression = formatNode(bracedExpressionNode.expression(), 0, 0);\n+        Token closeParen = formatToken(bracedExpressionNode.closeParen(), 1, 0);\n+\n+        return bracedExpressionNode.modify()\n+                .withOpenParen(openParen)\n+                .withExpression(expression)\n+                .withCloseParen(closeParen)\n+                .apply();\n+    }\n+\n+    @Override\n+    public AssignmentStatementNode transform(AssignmentStatementNode assignmentStatementNode) {\n+        Node varRef = formatNode(assignmentStatementNode.varRef(), 1, 0);\n+        Token equalsToken = formatToken(assignmentStatementNode.equalsToken(), 1, 0);\n+        ExpressionNode expression = formatNode(assignmentStatementNode.expression(), 0, 0);\n+        Token semicolonToken = formatToken(assignmentStatementNode.semicolonToken(), this.trailingWS, this.trailingNL);\n+\n+        return assignmentStatementNode.modify()\n+                .withVarRef(varRef)\n+                .withEqualsToken(equalsToken)\n+                .withExpression(expression)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public CompoundAssignmentStatementNode transform(CompoundAssignmentStatementNode compoundAssignmentStatementNode) {\n+        ExpressionNode lhsExpression = formatNode(compoundAssignmentStatementNode.lhsExpression(), 1, 0);\n+        Token binaryOperator = formatToken(compoundAssignmentStatementNode.binaryOperator(), 0, 0);\n+        Token equalsToken = formatToken(compoundAssignmentStatementNode.equalsToken(), 1, 0);\n+        ExpressionNode rhsExpression = formatNode(compoundAssignmentStatementNode.rhsExpression(), 0, 0);\n+        Token semicolonToken = formatToken(compoundAssignmentStatementNode.semicolonToken(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return compoundAssignmentStatementNode.modify()\n+                .withLhsExpression(lhsExpression)\n+                .withBinaryOperator(binaryOperator)\n+                .withEqualsToken(equalsToken)\n+                .withRhsExpression(rhsExpression)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public DoStatementNode transform(DoStatementNode doStatementNode) {\n+        Token doKeyword = formatToken(doStatementNode.doKeyword(), 1, 0);\n+        BlockStatementNode blockStatement = formatNode(doStatementNode.blockStatement(),\n+                this.trailingWS, this.trailingNL);\n+\n+        if (doStatementNode.onFailClause().isPresent()) {\n+            OnFailClauseNode onFailClause = formatNode(doStatementNode.onFailClause().get(),\n+                    this.trailingWS, this.trailingNL);\n+            doStatementNode = doStatementNode.modify().withOnFailClause(onFailClause).apply();\n+        }\n+\n+        return doStatementNode.modify()\n+                .withDoKeyword(doKeyword)\n+                .withBlockStatement(blockStatement)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ForEachStatementNode transform(ForEachStatementNode forEachStatementNode) {\n+        Token forEachKeyword = formatToken(forEachStatementNode.forEachKeyword(), 1, 0);\n+        TypedBindingPatternNode typedBindingPattern = formatNode(forEachStatementNode.typedBindingPattern(), 0, 0);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY5NDE5MQ=="}, "originalCommit": {"oid": "a775b9cadbd9a21307035b40d50e91dc8e229ffe"}, "originalPosition": 407}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNDI4MjQ0OnYy", "diffSide": "RIGHT", "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxMjowNDo0N1rOHY6kTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxMjoyODo1NlrOHY7Whw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg4NzQzOQ==", "bodyText": "moving this inside the below if (hasOnFailClause) { block would be cleaner..", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26121#discussion_r495887439", "createdAt": "2020-09-28T12:04:47Z", "author": {"login": "SupunS"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "diffHunk": "@@ -399,6 +429,436 @@ public RecordFieldWithDefaultValueNode transform(RecordFieldWithDefaultValueNode\n                 .apply();\n     }\n \n+    @Override\n+    public ImportDeclarationNode transform(ImportDeclarationNode importDeclarationNode) {\n+        Token importKeyword = formatToken(importDeclarationNode.importKeyword(), 1, 0);\n+\n+        boolean hasOrgName = importDeclarationNode.orgName().isPresent();\n+        boolean hasVersion = importDeclarationNode.version().isPresent();\n+        boolean hasPrefix = importDeclarationNode.prefix().isPresent();\n+\n+        if (hasOrgName) {\n+            ImportOrgNameNode orgName = formatNode(importDeclarationNode.orgName().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withOrgName(orgName).apply();\n+        }\n+        SeparatedNodeList<IdentifierToken> moduleNames = formatSeparatedNodeList(importDeclarationNode.moduleName(),\n+                0, 0, 0, 0, (hasVersion || hasPrefix) ? 1 : 0, 0);\n+\n+        if (hasVersion) {\n+            ImportVersionNode version = formatNode(importDeclarationNode.version().get(), hasPrefix ? 1 : 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withVersion(version).apply();\n+        }\n+        if (hasPrefix) {\n+            ImportPrefixNode prefix = formatNode(importDeclarationNode.prefix().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withPrefix(prefix).apply();\n+        }\n+        Token semicolon = formatToken(importDeclarationNode.semicolon(), this.trailingWS, this.trailingNL);\n+\n+        return importDeclarationNode.modify()\n+                .withImportKeyword(importKeyword)\n+                .withModuleName(moduleNames)\n+                .withSemicolon(semicolon)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ImportOrgNameNode transform(ImportOrgNameNode importOrgNameNode) {\n+        Token orgName = formatToken(importOrgNameNode.orgName(), 0, 0);\n+        Token slashToken = formatToken(importOrgNameNode.slashToken(), 0, 0);\n+\n+        return importOrgNameNode.modify()\n+                .withOrgName(orgName)\n+                .withSlashToken(slashToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ImportPrefixNode transform(ImportPrefixNode importPrefixNode) {\n+        Token asKeyword = formatToken(importPrefixNode.asKeyword(), 1, 0);\n+        Token prefix = formatToken(importPrefixNode.prefix(), 0, 0);\n+\n+        return importPrefixNode.modify()\n+                .withAsKeyword(asKeyword)\n+                .withPrefix(prefix)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ImportVersionNode transform(ImportVersionNode importVersionNode) {\n+        Token versionKeyword = formatToken(importVersionNode.versionKeyword(), 1, 0);\n+        SeparatedNodeList<Token> versionNumber = formatSeparatedNodeList(importVersionNode.versionNumber(),\n+                0, 0, 0, 0, this.trailingWS, 0);\n+\n+        return importVersionNode.modify()\n+                .withVersionKeyword(versionKeyword)\n+                .withVersionNumber(versionNumber)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ServiceDeclarationNode transform(ServiceDeclarationNode serviceDeclarationNode) {\n+        if (serviceDeclarationNode.metadata().isPresent()) {\n+            MetadataNode metadata = formatNode(serviceDeclarationNode.metadata().get(), 1, 0);\n+            serviceDeclarationNode = serviceDeclarationNode.modify().withMetadata(metadata).apply();\n+        }\n+\n+        Token serviceKeyword = formatToken(serviceDeclarationNode.serviceKeyword(), 1, 0);\n+        IdentifierToken serviceName = formatToken(serviceDeclarationNode.serviceName(), 1, 0);\n+        Token onKeyword = formatToken(serviceDeclarationNode.onKeyword(), 1, 0);\n+        SeparatedNodeList<ExpressionNode> expressions =\n+                formatSeparatedNodeList(serviceDeclarationNode.expressions(), 0, 0, 1, 0);\n+        Node serviceBody = formatNode(serviceDeclarationNode.serviceBody(), this.trailingWS, this.trailingNL);\n+\n+        return serviceDeclarationNode.modify()\n+                .withServiceKeyword(serviceKeyword)\n+                .withServiceName(serviceName)\n+                .withOnKeyword(onKeyword)\n+                .withExpressions(expressions)\n+                .withServiceBody(serviceBody)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ExplicitNewExpressionNode transform(ExplicitNewExpressionNode explicitNewExpressionNode) {\n+        Token newKeywordToken = formatToken(explicitNewExpressionNode.newKeyword(), 1, 0);\n+        TypeDescriptorNode typeDescriptorNode = formatNode(explicitNewExpressionNode.typeDescriptor(), 0, 0);\n+        ParenthesizedArgList parenthesizedArgList = formatNode(explicitNewExpressionNode.parenthesizedArgList(), 0, 0);\n+\n+        return explicitNewExpressionNode.modify()\n+                .withNewKeyword(newKeywordToken)\n+                .withTypeDescriptor(typeDescriptorNode)\n+                .withParenthesizedArgList(parenthesizedArgList)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ParenthesizedArgList transform(ParenthesizedArgList parenthesizedArgList) {\n+        Token openParenToken = formatToken(parenthesizedArgList.openParenToken(), 0, 0);\n+        SeparatedNodeList<FunctionArgumentNode> arguments = formatSeparatedNodeList(parenthesizedArgList\n+                .arguments(), 0, 0, 0, 0);\n+        Token closeParenToken = formatToken(parenthesizedArgList.closeParenToken(), this.trailingWS, this.trailingNL);\n+\n+        return parenthesizedArgList.modify()\n+                .withOpenParenToken(openParenToken)\n+                .withArguments(arguments)\n+                .withCloseParenToken(closeParenToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ServiceBodyNode transform(ServiceBodyNode serviceBodyNode) {\n+        Token openBraceToken = formatToken(serviceBodyNode.openBraceToken(), 0, 1);\n+        indent(); // increase indentation for the statements to follow.\n+        NodeList<Node> resources = formatNodeList(serviceBodyNode.resources(), 0, 1, 0, 1);\n+        unindent(); // reset the indentation\n+        Token closeBraceToken = formatToken(serviceBodyNode.closeBraceToken(), this.trailingWS, this.trailingNL);\n+\n+        return serviceBodyNode.modify()\n+                .withOpenBraceToken(openBraceToken)\n+                .withResources(resources)\n+                .withCloseBraceToken(closeBraceToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public QualifiedNameReferenceNode transform(QualifiedNameReferenceNode qualifiedNameReferenceNode) {\n+        Token modulePrefix = formatToken(qualifiedNameReferenceNode.modulePrefix(), 0, 0);\n+        Token colon = formatToken((Token) qualifiedNameReferenceNode.colon(), 0, 0);\n+        IdentifierToken identifier = formatToken(qualifiedNameReferenceNode.identifier(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return qualifiedNameReferenceNode.modify()\n+                .withModulePrefix(modulePrefix)\n+                .withColon(colon)\n+                .withIdentifier(identifier)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ReturnTypeDescriptorNode transform(ReturnTypeDescriptorNode returnTypeDescriptorNode) {\n+        Token returnsKeyword = formatToken(returnTypeDescriptorNode.returnsKeyword(), 1, 0);\n+        NodeList<AnnotationNode> annotations = formatNodeList(returnTypeDescriptorNode.annotations(), 0, 0, 1, 0);\n+        Node type = formatNode(returnTypeDescriptorNode.type(), 1, 0);\n+\n+        return returnTypeDescriptorNode.modify()\n+                .withReturnsKeyword(returnsKeyword)\n+                .withAnnotations(annotations)\n+                .withType(type)\n+                .apply();\n+    }\n+\n+    @Override\n+    public OptionalTypeDescriptorNode transform(OptionalTypeDescriptorNode optionalTypeDescriptorNode) {\n+        Node typeDescriptor = formatNode(optionalTypeDescriptorNode.typeDescriptor(), 0, 0);\n+        Token questionMarkToken = formatToken(optionalTypeDescriptorNode.questionMarkToken(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return optionalTypeDescriptorNode.modify()\n+                .withTypeDescriptor(typeDescriptor)\n+                .withQuestionMarkToken(questionMarkToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ExpressionStatementNode transform(ExpressionStatementNode expressionStatementNode) {\n+        ExpressionNode expression = formatNode(expressionStatementNode.expression(), 0, 0);\n+        Token semicolonToken = formatToken(expressionStatementNode.semicolonToken(), this.trailingWS, this.trailingNL);\n+\n+        return expressionStatementNode.modify()\n+                .withExpression(expression)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public CheckExpressionNode transform(CheckExpressionNode checkExpressionNode) {\n+        Token checkKeyword = formatToken(checkExpressionNode.checkKeyword(), 1, 0);\n+        ExpressionNode expressionNode = formatNode(checkExpressionNode.expression(), this.trailingWS, this.trailingNL);\n+\n+        return checkExpressionNode.modify()\n+                .withCheckKeyword(checkKeyword)\n+                .withExpression(expressionNode)\n+                .apply();\n+    }\n+\n+    @Override\n+    public RemoteMethodCallActionNode transform(RemoteMethodCallActionNode remoteMethodCallActionNode) {\n+        ExpressionNode expression = formatNode(remoteMethodCallActionNode.expression(), 0, 0);\n+        Token rightArrowToken = formatToken(remoteMethodCallActionNode.rightArrowToken(), 0, 0);\n+        SimpleNameReferenceNode methodName = formatNode(remoteMethodCallActionNode.methodName(), 0, 0);\n+        Token openParenToken = formatToken(remoteMethodCallActionNode.openParenToken(), 0, 0);\n+        SeparatedNodeList<FunctionArgumentNode> arguments = formatSeparatedNodeList(remoteMethodCallActionNode\n+                .arguments(), 1, 0, 0, 0);\n+        Token closeParenToken = formatToken(remoteMethodCallActionNode.closeParenToken(), this.trailingWS, this.trailingNL);\n+\n+        return remoteMethodCallActionNode.modify()\n+                .withExpression(expression)\n+                .withRightArrowToken(rightArrowToken)\n+                .withMethodName(methodName)\n+                .withOpenParenToken(openParenToken)\n+                .withArguments(arguments)\n+                .withCloseParenToken(closeParenToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public SimpleNameReferenceNode transform(SimpleNameReferenceNode simpleNameReferenceNode) {\n+        Token name = formatToken(simpleNameReferenceNode.name(), this.trailingWS, this.trailingNL);\n+\n+        return simpleNameReferenceNode.modify()\n+                .withName(name)\n+                .apply();\n+    }\n+\n+    @Override\n+    public TypeDefinitionNode transform(TypeDefinitionNode typeDefinitionNode) {\n+        if (typeDefinitionNode.metadata().isPresent()) {\n+            MetadataNode metadata = formatNode(typeDefinitionNode.metadata().get(), 1, 0);\n+            typeDefinitionNode = typeDefinitionNode.modify().withMetadata(metadata).apply();\n+        }\n+        if (typeDefinitionNode.visibilityQualifier().isPresent()) {\n+            Token visibilityQualifier = formatToken(typeDefinitionNode.visibilityQualifier().get(), 1, 0);\n+            typeDefinitionNode = typeDefinitionNode.modify().withVisibilityQualifier(visibilityQualifier).apply();\n+        }\n+\n+        Token typeKeyword = formatToken(typeDefinitionNode.typeKeyword(), 1, 0);\n+        Token typeName = formatToken(typeDefinitionNode.typeName(), 1, 0);\n+        Node typeDescriptor = formatNode(typeDefinitionNode.typeDescriptor(), 1, 0);\n+        Token semicolonToken = formatToken(typeDefinitionNode.semicolonToken(), this.trailingWS, this.trailingNL);\n+\n+        return typeDefinitionNode.modify()\n+                .withTypeKeyword(typeKeyword)\n+                .withTypeName(typeName)\n+                .withTypeDescriptor(typeDescriptor)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public SingletonTypeDescriptorNode transform(SingletonTypeDescriptorNode singletonTypeDescriptorNode) {\n+        ExpressionNode simpleContExprNode = formatNode(singletonTypeDescriptorNode.simpleContExprNode(), 1, 0);\n+        return singletonTypeDescriptorNode.modify()\n+                .withSimpleContExprNode(simpleContExprNode)\n+                .apply();\n+    }\n+\n+    @Override\n+    public WhileStatementNode transform(WhileStatementNode whileStatementNode) {\n+        boolean hasOnFailClause = whileStatementNode.onFailClause().isPresent();\n+        Token whileKeyword = formatToken(whileStatementNode.whileKeyword(), 1, 0);\n+        ExpressionNode condition = formatNode(whileStatementNode.condition(), 1, 0);\n+        BlockStatementNode whileBody = formatNode(whileStatementNode.whileBody(),\n+                hasOnFailClause ? 1 : this.trailingWS, hasOnFailClause ? 0 : this.trailingNL);\n+\n+        if (hasOnFailClause) {\n+            OnFailClauseNode onFailClause = formatNode(whileStatementNode.onFailClause().get(),\n+                    this.trailingWS, this.trailingNL);\n+            whileStatementNode = whileStatementNode.modify().withOnFailClause(onFailClause).apply();\n+        }\n+\n+        return whileStatementNode.modify()\n+                .withWhileKeyword(whileKeyword)\n+                .withCondition(condition)\n+                .withWhileBody(whileBody)\n+                .apply();\n+    }\n+\n+    @Override\n+    public BracedExpressionNode transform(BracedExpressionNode bracedExpressionNode) {\n+        Token openParen = formatToken(bracedExpressionNode.openParen(), 0, 0);\n+        ExpressionNode expression = formatNode(bracedExpressionNode.expression(), 0, 0);\n+        Token closeParen = formatToken(bracedExpressionNode.closeParen(), this.trailingWS, this.trailingNL);\n+\n+        return bracedExpressionNode.modify()\n+                .withOpenParen(openParen)\n+                .withExpression(expression)\n+                .withCloseParen(closeParen)\n+                .apply();\n+    }\n+\n+    @Override\n+    public AssignmentStatementNode transform(AssignmentStatementNode assignmentStatementNode) {\n+        Node varRef = formatNode(assignmentStatementNode.varRef(), 1, 0);\n+        Token equalsToken = formatToken(assignmentStatementNode.equalsToken(), 1, 0);\n+        ExpressionNode expression = formatNode(assignmentStatementNode.expression(), 0, 0);\n+        Token semicolonToken = formatToken(assignmentStatementNode.semicolonToken(), this.trailingWS, this.trailingNL);\n+\n+        return assignmentStatementNode.modify()\n+                .withVarRef(varRef)\n+                .withEqualsToken(equalsToken)\n+                .withExpression(expression)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public CompoundAssignmentStatementNode transform(CompoundAssignmentStatementNode compoundAssignmentStatementNode) {\n+        ExpressionNode lhsExpression = formatNode(compoundAssignmentStatementNode.lhsExpression(), 1, 0);\n+        Token binaryOperator = formatToken(compoundAssignmentStatementNode.binaryOperator(), 0, 0);\n+        Token equalsToken = formatToken(compoundAssignmentStatementNode.equalsToken(), 1, 0);\n+        ExpressionNode rhsExpression = formatNode(compoundAssignmentStatementNode.rhsExpression(), 0, 0);\n+        Token semicolonToken = formatToken(compoundAssignmentStatementNode.semicolonToken(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return compoundAssignmentStatementNode.modify()\n+                .withLhsExpression(lhsExpression)\n+                .withBinaryOperator(binaryOperator)\n+                .withEqualsToken(equalsToken)\n+                .withRhsExpression(rhsExpression)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public DoStatementNode transform(DoStatementNode doStatementNode) {\n+        boolean hasOnFailClause = doStatementNode.onFailClause().isPresent();\n+\n+        Token doKeyword = formatToken(doStatementNode.doKeyword(), 1, 0);\n+        BlockStatementNode blockStatement = formatNode(doStatementNode.blockStatement(),\n+                hasOnFailClause ? 1 : this.trailingWS, hasOnFailClause ? 0 : this.trailingNL);\n+\n+        if (hasOnFailClause) {\n+            OnFailClauseNode onFailClause = formatNode(doStatementNode.onFailClause().get(),\n+                    this.trailingWS, this.trailingNL);\n+            doStatementNode = doStatementNode.modify().withOnFailClause(onFailClause).apply();\n+        }\n+\n+        return doStatementNode.modify()\n+                .withDoKeyword(doKeyword)\n+                .withBlockStatement(blockStatement)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ForEachStatementNode transform(ForEachStatementNode forEachStatementNode) {\n+        boolean hasOnFailClause = forEachStatementNode.onFailClause().isPresent();\n+\n+        Token forEachKeyword = formatToken(forEachStatementNode.forEachKeyword(), 1, 0);\n+        TypedBindingPatternNode typedBindingPattern = formatNode(forEachStatementNode.typedBindingPattern(), 1, 0);\n+        Token inKeyword = formatToken(forEachStatementNode.inKeyword(), 1, 0);\n+        Node actionOrExpressionNode = formatNode(forEachStatementNode.actionOrExpressionNode(), 1, 0);\n+        StatementNode blockStatement = formatNode(forEachStatementNode.blockStatement(),\n+                hasOnFailClause ? 1 : this.trailingWS, hasOnFailClause ? 0 : this.trailingNL);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bd7b0d855a3e4ed165fc3da4b34b7de38a82199"}, "originalPosition": 456}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTkwMDI5NQ==", "bodyText": "Done", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26121#discussion_r495900295", "createdAt": "2020-09-28T12:28:56Z", "author": {"login": "IrushiL"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "diffHunk": "@@ -399,6 +429,436 @@ public RecordFieldWithDefaultValueNode transform(RecordFieldWithDefaultValueNode\n                 .apply();\n     }\n \n+    @Override\n+    public ImportDeclarationNode transform(ImportDeclarationNode importDeclarationNode) {\n+        Token importKeyword = formatToken(importDeclarationNode.importKeyword(), 1, 0);\n+\n+        boolean hasOrgName = importDeclarationNode.orgName().isPresent();\n+        boolean hasVersion = importDeclarationNode.version().isPresent();\n+        boolean hasPrefix = importDeclarationNode.prefix().isPresent();\n+\n+        if (hasOrgName) {\n+            ImportOrgNameNode orgName = formatNode(importDeclarationNode.orgName().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withOrgName(orgName).apply();\n+        }\n+        SeparatedNodeList<IdentifierToken> moduleNames = formatSeparatedNodeList(importDeclarationNode.moduleName(),\n+                0, 0, 0, 0, (hasVersion || hasPrefix) ? 1 : 0, 0);\n+\n+        if (hasVersion) {\n+            ImportVersionNode version = formatNode(importDeclarationNode.version().get(), hasPrefix ? 1 : 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withVersion(version).apply();\n+        }\n+        if (hasPrefix) {\n+            ImportPrefixNode prefix = formatNode(importDeclarationNode.prefix().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withPrefix(prefix).apply();\n+        }\n+        Token semicolon = formatToken(importDeclarationNode.semicolon(), this.trailingWS, this.trailingNL);\n+\n+        return importDeclarationNode.modify()\n+                .withImportKeyword(importKeyword)\n+                .withModuleName(moduleNames)\n+                .withSemicolon(semicolon)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ImportOrgNameNode transform(ImportOrgNameNode importOrgNameNode) {\n+        Token orgName = formatToken(importOrgNameNode.orgName(), 0, 0);\n+        Token slashToken = formatToken(importOrgNameNode.slashToken(), 0, 0);\n+\n+        return importOrgNameNode.modify()\n+                .withOrgName(orgName)\n+                .withSlashToken(slashToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ImportPrefixNode transform(ImportPrefixNode importPrefixNode) {\n+        Token asKeyword = formatToken(importPrefixNode.asKeyword(), 1, 0);\n+        Token prefix = formatToken(importPrefixNode.prefix(), 0, 0);\n+\n+        return importPrefixNode.modify()\n+                .withAsKeyword(asKeyword)\n+                .withPrefix(prefix)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ImportVersionNode transform(ImportVersionNode importVersionNode) {\n+        Token versionKeyword = formatToken(importVersionNode.versionKeyword(), 1, 0);\n+        SeparatedNodeList<Token> versionNumber = formatSeparatedNodeList(importVersionNode.versionNumber(),\n+                0, 0, 0, 0, this.trailingWS, 0);\n+\n+        return importVersionNode.modify()\n+                .withVersionKeyword(versionKeyword)\n+                .withVersionNumber(versionNumber)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ServiceDeclarationNode transform(ServiceDeclarationNode serviceDeclarationNode) {\n+        if (serviceDeclarationNode.metadata().isPresent()) {\n+            MetadataNode metadata = formatNode(serviceDeclarationNode.metadata().get(), 1, 0);\n+            serviceDeclarationNode = serviceDeclarationNode.modify().withMetadata(metadata).apply();\n+        }\n+\n+        Token serviceKeyword = formatToken(serviceDeclarationNode.serviceKeyword(), 1, 0);\n+        IdentifierToken serviceName = formatToken(serviceDeclarationNode.serviceName(), 1, 0);\n+        Token onKeyword = formatToken(serviceDeclarationNode.onKeyword(), 1, 0);\n+        SeparatedNodeList<ExpressionNode> expressions =\n+                formatSeparatedNodeList(serviceDeclarationNode.expressions(), 0, 0, 1, 0);\n+        Node serviceBody = formatNode(serviceDeclarationNode.serviceBody(), this.trailingWS, this.trailingNL);\n+\n+        return serviceDeclarationNode.modify()\n+                .withServiceKeyword(serviceKeyword)\n+                .withServiceName(serviceName)\n+                .withOnKeyword(onKeyword)\n+                .withExpressions(expressions)\n+                .withServiceBody(serviceBody)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ExplicitNewExpressionNode transform(ExplicitNewExpressionNode explicitNewExpressionNode) {\n+        Token newKeywordToken = formatToken(explicitNewExpressionNode.newKeyword(), 1, 0);\n+        TypeDescriptorNode typeDescriptorNode = formatNode(explicitNewExpressionNode.typeDescriptor(), 0, 0);\n+        ParenthesizedArgList parenthesizedArgList = formatNode(explicitNewExpressionNode.parenthesizedArgList(), 0, 0);\n+\n+        return explicitNewExpressionNode.modify()\n+                .withNewKeyword(newKeywordToken)\n+                .withTypeDescriptor(typeDescriptorNode)\n+                .withParenthesizedArgList(parenthesizedArgList)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ParenthesizedArgList transform(ParenthesizedArgList parenthesizedArgList) {\n+        Token openParenToken = formatToken(parenthesizedArgList.openParenToken(), 0, 0);\n+        SeparatedNodeList<FunctionArgumentNode> arguments = formatSeparatedNodeList(parenthesizedArgList\n+                .arguments(), 0, 0, 0, 0);\n+        Token closeParenToken = formatToken(parenthesizedArgList.closeParenToken(), this.trailingWS, this.trailingNL);\n+\n+        return parenthesizedArgList.modify()\n+                .withOpenParenToken(openParenToken)\n+                .withArguments(arguments)\n+                .withCloseParenToken(closeParenToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ServiceBodyNode transform(ServiceBodyNode serviceBodyNode) {\n+        Token openBraceToken = formatToken(serviceBodyNode.openBraceToken(), 0, 1);\n+        indent(); // increase indentation for the statements to follow.\n+        NodeList<Node> resources = formatNodeList(serviceBodyNode.resources(), 0, 1, 0, 1);\n+        unindent(); // reset the indentation\n+        Token closeBraceToken = formatToken(serviceBodyNode.closeBraceToken(), this.trailingWS, this.trailingNL);\n+\n+        return serviceBodyNode.modify()\n+                .withOpenBraceToken(openBraceToken)\n+                .withResources(resources)\n+                .withCloseBraceToken(closeBraceToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public QualifiedNameReferenceNode transform(QualifiedNameReferenceNode qualifiedNameReferenceNode) {\n+        Token modulePrefix = formatToken(qualifiedNameReferenceNode.modulePrefix(), 0, 0);\n+        Token colon = formatToken((Token) qualifiedNameReferenceNode.colon(), 0, 0);\n+        IdentifierToken identifier = formatToken(qualifiedNameReferenceNode.identifier(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return qualifiedNameReferenceNode.modify()\n+                .withModulePrefix(modulePrefix)\n+                .withColon(colon)\n+                .withIdentifier(identifier)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ReturnTypeDescriptorNode transform(ReturnTypeDescriptorNode returnTypeDescriptorNode) {\n+        Token returnsKeyword = formatToken(returnTypeDescriptorNode.returnsKeyword(), 1, 0);\n+        NodeList<AnnotationNode> annotations = formatNodeList(returnTypeDescriptorNode.annotations(), 0, 0, 1, 0);\n+        Node type = formatNode(returnTypeDescriptorNode.type(), 1, 0);\n+\n+        return returnTypeDescriptorNode.modify()\n+                .withReturnsKeyword(returnsKeyword)\n+                .withAnnotations(annotations)\n+                .withType(type)\n+                .apply();\n+    }\n+\n+    @Override\n+    public OptionalTypeDescriptorNode transform(OptionalTypeDescriptorNode optionalTypeDescriptorNode) {\n+        Node typeDescriptor = formatNode(optionalTypeDescriptorNode.typeDescriptor(), 0, 0);\n+        Token questionMarkToken = formatToken(optionalTypeDescriptorNode.questionMarkToken(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return optionalTypeDescriptorNode.modify()\n+                .withTypeDescriptor(typeDescriptor)\n+                .withQuestionMarkToken(questionMarkToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ExpressionStatementNode transform(ExpressionStatementNode expressionStatementNode) {\n+        ExpressionNode expression = formatNode(expressionStatementNode.expression(), 0, 0);\n+        Token semicolonToken = formatToken(expressionStatementNode.semicolonToken(), this.trailingWS, this.trailingNL);\n+\n+        return expressionStatementNode.modify()\n+                .withExpression(expression)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public CheckExpressionNode transform(CheckExpressionNode checkExpressionNode) {\n+        Token checkKeyword = formatToken(checkExpressionNode.checkKeyword(), 1, 0);\n+        ExpressionNode expressionNode = formatNode(checkExpressionNode.expression(), this.trailingWS, this.trailingNL);\n+\n+        return checkExpressionNode.modify()\n+                .withCheckKeyword(checkKeyword)\n+                .withExpression(expressionNode)\n+                .apply();\n+    }\n+\n+    @Override\n+    public RemoteMethodCallActionNode transform(RemoteMethodCallActionNode remoteMethodCallActionNode) {\n+        ExpressionNode expression = formatNode(remoteMethodCallActionNode.expression(), 0, 0);\n+        Token rightArrowToken = formatToken(remoteMethodCallActionNode.rightArrowToken(), 0, 0);\n+        SimpleNameReferenceNode methodName = formatNode(remoteMethodCallActionNode.methodName(), 0, 0);\n+        Token openParenToken = formatToken(remoteMethodCallActionNode.openParenToken(), 0, 0);\n+        SeparatedNodeList<FunctionArgumentNode> arguments = formatSeparatedNodeList(remoteMethodCallActionNode\n+                .arguments(), 1, 0, 0, 0);\n+        Token closeParenToken = formatToken(remoteMethodCallActionNode.closeParenToken(), this.trailingWS, this.trailingNL);\n+\n+        return remoteMethodCallActionNode.modify()\n+                .withExpression(expression)\n+                .withRightArrowToken(rightArrowToken)\n+                .withMethodName(methodName)\n+                .withOpenParenToken(openParenToken)\n+                .withArguments(arguments)\n+                .withCloseParenToken(closeParenToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public SimpleNameReferenceNode transform(SimpleNameReferenceNode simpleNameReferenceNode) {\n+        Token name = formatToken(simpleNameReferenceNode.name(), this.trailingWS, this.trailingNL);\n+\n+        return simpleNameReferenceNode.modify()\n+                .withName(name)\n+                .apply();\n+    }\n+\n+    @Override\n+    public TypeDefinitionNode transform(TypeDefinitionNode typeDefinitionNode) {\n+        if (typeDefinitionNode.metadata().isPresent()) {\n+            MetadataNode metadata = formatNode(typeDefinitionNode.metadata().get(), 1, 0);\n+            typeDefinitionNode = typeDefinitionNode.modify().withMetadata(metadata).apply();\n+        }\n+        if (typeDefinitionNode.visibilityQualifier().isPresent()) {\n+            Token visibilityQualifier = formatToken(typeDefinitionNode.visibilityQualifier().get(), 1, 0);\n+            typeDefinitionNode = typeDefinitionNode.modify().withVisibilityQualifier(visibilityQualifier).apply();\n+        }\n+\n+        Token typeKeyword = formatToken(typeDefinitionNode.typeKeyword(), 1, 0);\n+        Token typeName = formatToken(typeDefinitionNode.typeName(), 1, 0);\n+        Node typeDescriptor = formatNode(typeDefinitionNode.typeDescriptor(), 1, 0);\n+        Token semicolonToken = formatToken(typeDefinitionNode.semicolonToken(), this.trailingWS, this.trailingNL);\n+\n+        return typeDefinitionNode.modify()\n+                .withTypeKeyword(typeKeyword)\n+                .withTypeName(typeName)\n+                .withTypeDescriptor(typeDescriptor)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public SingletonTypeDescriptorNode transform(SingletonTypeDescriptorNode singletonTypeDescriptorNode) {\n+        ExpressionNode simpleContExprNode = formatNode(singletonTypeDescriptorNode.simpleContExprNode(), 1, 0);\n+        return singletonTypeDescriptorNode.modify()\n+                .withSimpleContExprNode(simpleContExprNode)\n+                .apply();\n+    }\n+\n+    @Override\n+    public WhileStatementNode transform(WhileStatementNode whileStatementNode) {\n+        boolean hasOnFailClause = whileStatementNode.onFailClause().isPresent();\n+        Token whileKeyword = formatToken(whileStatementNode.whileKeyword(), 1, 0);\n+        ExpressionNode condition = formatNode(whileStatementNode.condition(), 1, 0);\n+        BlockStatementNode whileBody = formatNode(whileStatementNode.whileBody(),\n+                hasOnFailClause ? 1 : this.trailingWS, hasOnFailClause ? 0 : this.trailingNL);\n+\n+        if (hasOnFailClause) {\n+            OnFailClauseNode onFailClause = formatNode(whileStatementNode.onFailClause().get(),\n+                    this.trailingWS, this.trailingNL);\n+            whileStatementNode = whileStatementNode.modify().withOnFailClause(onFailClause).apply();\n+        }\n+\n+        return whileStatementNode.modify()\n+                .withWhileKeyword(whileKeyword)\n+                .withCondition(condition)\n+                .withWhileBody(whileBody)\n+                .apply();\n+    }\n+\n+    @Override\n+    public BracedExpressionNode transform(BracedExpressionNode bracedExpressionNode) {\n+        Token openParen = formatToken(bracedExpressionNode.openParen(), 0, 0);\n+        ExpressionNode expression = formatNode(bracedExpressionNode.expression(), 0, 0);\n+        Token closeParen = formatToken(bracedExpressionNode.closeParen(), this.trailingWS, this.trailingNL);\n+\n+        return bracedExpressionNode.modify()\n+                .withOpenParen(openParen)\n+                .withExpression(expression)\n+                .withCloseParen(closeParen)\n+                .apply();\n+    }\n+\n+    @Override\n+    public AssignmentStatementNode transform(AssignmentStatementNode assignmentStatementNode) {\n+        Node varRef = formatNode(assignmentStatementNode.varRef(), 1, 0);\n+        Token equalsToken = formatToken(assignmentStatementNode.equalsToken(), 1, 0);\n+        ExpressionNode expression = formatNode(assignmentStatementNode.expression(), 0, 0);\n+        Token semicolonToken = formatToken(assignmentStatementNode.semicolonToken(), this.trailingWS, this.trailingNL);\n+\n+        return assignmentStatementNode.modify()\n+                .withVarRef(varRef)\n+                .withEqualsToken(equalsToken)\n+                .withExpression(expression)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public CompoundAssignmentStatementNode transform(CompoundAssignmentStatementNode compoundAssignmentStatementNode) {\n+        ExpressionNode lhsExpression = formatNode(compoundAssignmentStatementNode.lhsExpression(), 1, 0);\n+        Token binaryOperator = formatToken(compoundAssignmentStatementNode.binaryOperator(), 0, 0);\n+        Token equalsToken = formatToken(compoundAssignmentStatementNode.equalsToken(), 1, 0);\n+        ExpressionNode rhsExpression = formatNode(compoundAssignmentStatementNode.rhsExpression(), 0, 0);\n+        Token semicolonToken = formatToken(compoundAssignmentStatementNode.semicolonToken(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return compoundAssignmentStatementNode.modify()\n+                .withLhsExpression(lhsExpression)\n+                .withBinaryOperator(binaryOperator)\n+                .withEqualsToken(equalsToken)\n+                .withRhsExpression(rhsExpression)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public DoStatementNode transform(DoStatementNode doStatementNode) {\n+        boolean hasOnFailClause = doStatementNode.onFailClause().isPresent();\n+\n+        Token doKeyword = formatToken(doStatementNode.doKeyword(), 1, 0);\n+        BlockStatementNode blockStatement = formatNode(doStatementNode.blockStatement(),\n+                hasOnFailClause ? 1 : this.trailingWS, hasOnFailClause ? 0 : this.trailingNL);\n+\n+        if (hasOnFailClause) {\n+            OnFailClauseNode onFailClause = formatNode(doStatementNode.onFailClause().get(),\n+                    this.trailingWS, this.trailingNL);\n+            doStatementNode = doStatementNode.modify().withOnFailClause(onFailClause).apply();\n+        }\n+\n+        return doStatementNode.modify()\n+                .withDoKeyword(doKeyword)\n+                .withBlockStatement(blockStatement)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ForEachStatementNode transform(ForEachStatementNode forEachStatementNode) {\n+        boolean hasOnFailClause = forEachStatementNode.onFailClause().isPresent();\n+\n+        Token forEachKeyword = formatToken(forEachStatementNode.forEachKeyword(), 1, 0);\n+        TypedBindingPatternNode typedBindingPattern = formatNode(forEachStatementNode.typedBindingPattern(), 1, 0);\n+        Token inKeyword = formatToken(forEachStatementNode.inKeyword(), 1, 0);\n+        Node actionOrExpressionNode = formatNode(forEachStatementNode.actionOrExpressionNode(), 1, 0);\n+        StatementNode blockStatement = formatNode(forEachStatementNode.blockStatement(),\n+                hasOnFailClause ? 1 : this.trailingWS, hasOnFailClause ? 0 : this.trailingNL);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg4NzQzOQ=="}, "originalCommit": {"oid": "5bd7b0d855a3e4ed165fc3da4b34b7de38a82199"}, "originalPosition": 456}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNDI4NDk2OnYy", "diffSide": "RIGHT", "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxMjowNTozMVrOHY6l1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxMjoyOTo1NVrOHY7Y0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg4NzgzMA==", "bodyText": "should use global var for WS and NL", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26121#discussion_r495887830", "createdAt": "2020-09-28T12:05:31Z", "author": {"login": "SupunS"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "diffHunk": "@@ -399,6 +429,436 @@ public RecordFieldWithDefaultValueNode transform(RecordFieldWithDefaultValueNode\n                 .apply();\n     }\n \n+    @Override\n+    public ImportDeclarationNode transform(ImportDeclarationNode importDeclarationNode) {\n+        Token importKeyword = formatToken(importDeclarationNode.importKeyword(), 1, 0);\n+\n+        boolean hasOrgName = importDeclarationNode.orgName().isPresent();\n+        boolean hasVersion = importDeclarationNode.version().isPresent();\n+        boolean hasPrefix = importDeclarationNode.prefix().isPresent();\n+\n+        if (hasOrgName) {\n+            ImportOrgNameNode orgName = formatNode(importDeclarationNode.orgName().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withOrgName(orgName).apply();\n+        }\n+        SeparatedNodeList<IdentifierToken> moduleNames = formatSeparatedNodeList(importDeclarationNode.moduleName(),\n+                0, 0, 0, 0, (hasVersion || hasPrefix) ? 1 : 0, 0);\n+\n+        if (hasVersion) {\n+            ImportVersionNode version = formatNode(importDeclarationNode.version().get(), hasPrefix ? 1 : 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withVersion(version).apply();\n+        }\n+        if (hasPrefix) {\n+            ImportPrefixNode prefix = formatNode(importDeclarationNode.prefix().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withPrefix(prefix).apply();\n+        }\n+        Token semicolon = formatToken(importDeclarationNode.semicolon(), this.trailingWS, this.trailingNL);\n+\n+        return importDeclarationNode.modify()\n+                .withImportKeyword(importKeyword)\n+                .withModuleName(moduleNames)\n+                .withSemicolon(semicolon)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ImportOrgNameNode transform(ImportOrgNameNode importOrgNameNode) {\n+        Token orgName = formatToken(importOrgNameNode.orgName(), 0, 0);\n+        Token slashToken = formatToken(importOrgNameNode.slashToken(), 0, 0);\n+\n+        return importOrgNameNode.modify()\n+                .withOrgName(orgName)\n+                .withSlashToken(slashToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ImportPrefixNode transform(ImportPrefixNode importPrefixNode) {\n+        Token asKeyword = formatToken(importPrefixNode.asKeyword(), 1, 0);\n+        Token prefix = formatToken(importPrefixNode.prefix(), 0, 0);\n+\n+        return importPrefixNode.modify()\n+                .withAsKeyword(asKeyword)\n+                .withPrefix(prefix)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ImportVersionNode transform(ImportVersionNode importVersionNode) {\n+        Token versionKeyword = formatToken(importVersionNode.versionKeyword(), 1, 0);\n+        SeparatedNodeList<Token> versionNumber = formatSeparatedNodeList(importVersionNode.versionNumber(),\n+                0, 0, 0, 0, this.trailingWS, 0);\n+\n+        return importVersionNode.modify()\n+                .withVersionKeyword(versionKeyword)\n+                .withVersionNumber(versionNumber)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ServiceDeclarationNode transform(ServiceDeclarationNode serviceDeclarationNode) {\n+        if (serviceDeclarationNode.metadata().isPresent()) {\n+            MetadataNode metadata = formatNode(serviceDeclarationNode.metadata().get(), 1, 0);\n+            serviceDeclarationNode = serviceDeclarationNode.modify().withMetadata(metadata).apply();\n+        }\n+\n+        Token serviceKeyword = formatToken(serviceDeclarationNode.serviceKeyword(), 1, 0);\n+        IdentifierToken serviceName = formatToken(serviceDeclarationNode.serviceName(), 1, 0);\n+        Token onKeyword = formatToken(serviceDeclarationNode.onKeyword(), 1, 0);\n+        SeparatedNodeList<ExpressionNode> expressions =\n+                formatSeparatedNodeList(serviceDeclarationNode.expressions(), 0, 0, 1, 0);\n+        Node serviceBody = formatNode(serviceDeclarationNode.serviceBody(), this.trailingWS, this.trailingNL);\n+\n+        return serviceDeclarationNode.modify()\n+                .withServiceKeyword(serviceKeyword)\n+                .withServiceName(serviceName)\n+                .withOnKeyword(onKeyword)\n+                .withExpressions(expressions)\n+                .withServiceBody(serviceBody)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ExplicitNewExpressionNode transform(ExplicitNewExpressionNode explicitNewExpressionNode) {\n+        Token newKeywordToken = formatToken(explicitNewExpressionNode.newKeyword(), 1, 0);\n+        TypeDescriptorNode typeDescriptorNode = formatNode(explicitNewExpressionNode.typeDescriptor(), 0, 0);\n+        ParenthesizedArgList parenthesizedArgList = formatNode(explicitNewExpressionNode.parenthesizedArgList(), 0, 0);\n+\n+        return explicitNewExpressionNode.modify()\n+                .withNewKeyword(newKeywordToken)\n+                .withTypeDescriptor(typeDescriptorNode)\n+                .withParenthesizedArgList(parenthesizedArgList)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ParenthesizedArgList transform(ParenthesizedArgList parenthesizedArgList) {\n+        Token openParenToken = formatToken(parenthesizedArgList.openParenToken(), 0, 0);\n+        SeparatedNodeList<FunctionArgumentNode> arguments = formatSeparatedNodeList(parenthesizedArgList\n+                .arguments(), 0, 0, 0, 0);\n+        Token closeParenToken = formatToken(parenthesizedArgList.closeParenToken(), this.trailingWS, this.trailingNL);\n+\n+        return parenthesizedArgList.modify()\n+                .withOpenParenToken(openParenToken)\n+                .withArguments(arguments)\n+                .withCloseParenToken(closeParenToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ServiceBodyNode transform(ServiceBodyNode serviceBodyNode) {\n+        Token openBraceToken = formatToken(serviceBodyNode.openBraceToken(), 0, 1);\n+        indent(); // increase indentation for the statements to follow.\n+        NodeList<Node> resources = formatNodeList(serviceBodyNode.resources(), 0, 1, 0, 1);\n+        unindent(); // reset the indentation\n+        Token closeBraceToken = formatToken(serviceBodyNode.closeBraceToken(), this.trailingWS, this.trailingNL);\n+\n+        return serviceBodyNode.modify()\n+                .withOpenBraceToken(openBraceToken)\n+                .withResources(resources)\n+                .withCloseBraceToken(closeBraceToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public QualifiedNameReferenceNode transform(QualifiedNameReferenceNode qualifiedNameReferenceNode) {\n+        Token modulePrefix = formatToken(qualifiedNameReferenceNode.modulePrefix(), 0, 0);\n+        Token colon = formatToken((Token) qualifiedNameReferenceNode.colon(), 0, 0);\n+        IdentifierToken identifier = formatToken(qualifiedNameReferenceNode.identifier(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return qualifiedNameReferenceNode.modify()\n+                .withModulePrefix(modulePrefix)\n+                .withColon(colon)\n+                .withIdentifier(identifier)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ReturnTypeDescriptorNode transform(ReturnTypeDescriptorNode returnTypeDescriptorNode) {\n+        Token returnsKeyword = formatToken(returnTypeDescriptorNode.returnsKeyword(), 1, 0);\n+        NodeList<AnnotationNode> annotations = formatNodeList(returnTypeDescriptorNode.annotations(), 0, 0, 1, 0);\n+        Node type = formatNode(returnTypeDescriptorNode.type(), 1, 0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bd7b0d855a3e4ed165fc3da4b34b7de38a82199"}, "originalPosition": 256}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTkwMDg4Mw==", "bodyText": "Done", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26121#discussion_r495900883", "createdAt": "2020-09-28T12:29:55Z", "author": {"login": "IrushiL"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "diffHunk": "@@ -399,6 +429,436 @@ public RecordFieldWithDefaultValueNode transform(RecordFieldWithDefaultValueNode\n                 .apply();\n     }\n \n+    @Override\n+    public ImportDeclarationNode transform(ImportDeclarationNode importDeclarationNode) {\n+        Token importKeyword = formatToken(importDeclarationNode.importKeyword(), 1, 0);\n+\n+        boolean hasOrgName = importDeclarationNode.orgName().isPresent();\n+        boolean hasVersion = importDeclarationNode.version().isPresent();\n+        boolean hasPrefix = importDeclarationNode.prefix().isPresent();\n+\n+        if (hasOrgName) {\n+            ImportOrgNameNode orgName = formatNode(importDeclarationNode.orgName().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withOrgName(orgName).apply();\n+        }\n+        SeparatedNodeList<IdentifierToken> moduleNames = formatSeparatedNodeList(importDeclarationNode.moduleName(),\n+                0, 0, 0, 0, (hasVersion || hasPrefix) ? 1 : 0, 0);\n+\n+        if (hasVersion) {\n+            ImportVersionNode version = formatNode(importDeclarationNode.version().get(), hasPrefix ? 1 : 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withVersion(version).apply();\n+        }\n+        if (hasPrefix) {\n+            ImportPrefixNode prefix = formatNode(importDeclarationNode.prefix().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withPrefix(prefix).apply();\n+        }\n+        Token semicolon = formatToken(importDeclarationNode.semicolon(), this.trailingWS, this.trailingNL);\n+\n+        return importDeclarationNode.modify()\n+                .withImportKeyword(importKeyword)\n+                .withModuleName(moduleNames)\n+                .withSemicolon(semicolon)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ImportOrgNameNode transform(ImportOrgNameNode importOrgNameNode) {\n+        Token orgName = formatToken(importOrgNameNode.orgName(), 0, 0);\n+        Token slashToken = formatToken(importOrgNameNode.slashToken(), 0, 0);\n+\n+        return importOrgNameNode.modify()\n+                .withOrgName(orgName)\n+                .withSlashToken(slashToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ImportPrefixNode transform(ImportPrefixNode importPrefixNode) {\n+        Token asKeyword = formatToken(importPrefixNode.asKeyword(), 1, 0);\n+        Token prefix = formatToken(importPrefixNode.prefix(), 0, 0);\n+\n+        return importPrefixNode.modify()\n+                .withAsKeyword(asKeyword)\n+                .withPrefix(prefix)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ImportVersionNode transform(ImportVersionNode importVersionNode) {\n+        Token versionKeyword = formatToken(importVersionNode.versionKeyword(), 1, 0);\n+        SeparatedNodeList<Token> versionNumber = formatSeparatedNodeList(importVersionNode.versionNumber(),\n+                0, 0, 0, 0, this.trailingWS, 0);\n+\n+        return importVersionNode.modify()\n+                .withVersionKeyword(versionKeyword)\n+                .withVersionNumber(versionNumber)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ServiceDeclarationNode transform(ServiceDeclarationNode serviceDeclarationNode) {\n+        if (serviceDeclarationNode.metadata().isPresent()) {\n+            MetadataNode metadata = formatNode(serviceDeclarationNode.metadata().get(), 1, 0);\n+            serviceDeclarationNode = serviceDeclarationNode.modify().withMetadata(metadata).apply();\n+        }\n+\n+        Token serviceKeyword = formatToken(serviceDeclarationNode.serviceKeyword(), 1, 0);\n+        IdentifierToken serviceName = formatToken(serviceDeclarationNode.serviceName(), 1, 0);\n+        Token onKeyword = formatToken(serviceDeclarationNode.onKeyword(), 1, 0);\n+        SeparatedNodeList<ExpressionNode> expressions =\n+                formatSeparatedNodeList(serviceDeclarationNode.expressions(), 0, 0, 1, 0);\n+        Node serviceBody = formatNode(serviceDeclarationNode.serviceBody(), this.trailingWS, this.trailingNL);\n+\n+        return serviceDeclarationNode.modify()\n+                .withServiceKeyword(serviceKeyword)\n+                .withServiceName(serviceName)\n+                .withOnKeyword(onKeyword)\n+                .withExpressions(expressions)\n+                .withServiceBody(serviceBody)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ExplicitNewExpressionNode transform(ExplicitNewExpressionNode explicitNewExpressionNode) {\n+        Token newKeywordToken = formatToken(explicitNewExpressionNode.newKeyword(), 1, 0);\n+        TypeDescriptorNode typeDescriptorNode = formatNode(explicitNewExpressionNode.typeDescriptor(), 0, 0);\n+        ParenthesizedArgList parenthesizedArgList = formatNode(explicitNewExpressionNode.parenthesizedArgList(), 0, 0);\n+\n+        return explicitNewExpressionNode.modify()\n+                .withNewKeyword(newKeywordToken)\n+                .withTypeDescriptor(typeDescriptorNode)\n+                .withParenthesizedArgList(parenthesizedArgList)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ParenthesizedArgList transform(ParenthesizedArgList parenthesizedArgList) {\n+        Token openParenToken = formatToken(parenthesizedArgList.openParenToken(), 0, 0);\n+        SeparatedNodeList<FunctionArgumentNode> arguments = formatSeparatedNodeList(parenthesizedArgList\n+                .arguments(), 0, 0, 0, 0);\n+        Token closeParenToken = formatToken(parenthesizedArgList.closeParenToken(), this.trailingWS, this.trailingNL);\n+\n+        return parenthesizedArgList.modify()\n+                .withOpenParenToken(openParenToken)\n+                .withArguments(arguments)\n+                .withCloseParenToken(closeParenToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ServiceBodyNode transform(ServiceBodyNode serviceBodyNode) {\n+        Token openBraceToken = formatToken(serviceBodyNode.openBraceToken(), 0, 1);\n+        indent(); // increase indentation for the statements to follow.\n+        NodeList<Node> resources = formatNodeList(serviceBodyNode.resources(), 0, 1, 0, 1);\n+        unindent(); // reset the indentation\n+        Token closeBraceToken = formatToken(serviceBodyNode.closeBraceToken(), this.trailingWS, this.trailingNL);\n+\n+        return serviceBodyNode.modify()\n+                .withOpenBraceToken(openBraceToken)\n+                .withResources(resources)\n+                .withCloseBraceToken(closeBraceToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public QualifiedNameReferenceNode transform(QualifiedNameReferenceNode qualifiedNameReferenceNode) {\n+        Token modulePrefix = formatToken(qualifiedNameReferenceNode.modulePrefix(), 0, 0);\n+        Token colon = formatToken((Token) qualifiedNameReferenceNode.colon(), 0, 0);\n+        IdentifierToken identifier = formatToken(qualifiedNameReferenceNode.identifier(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return qualifiedNameReferenceNode.modify()\n+                .withModulePrefix(modulePrefix)\n+                .withColon(colon)\n+                .withIdentifier(identifier)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ReturnTypeDescriptorNode transform(ReturnTypeDescriptorNode returnTypeDescriptorNode) {\n+        Token returnsKeyword = formatToken(returnTypeDescriptorNode.returnsKeyword(), 1, 0);\n+        NodeList<AnnotationNode> annotations = formatNodeList(returnTypeDescriptorNode.annotations(), 0, 0, 1, 0);\n+        Node type = formatNode(returnTypeDescriptorNode.type(), 1, 0);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg4NzgzMA=="}, "originalCommit": {"oid": "5bd7b0d855a3e4ed165fc3da4b34b7de38a82199"}, "originalPosition": 256}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNDI4NTc0OnYy", "diffSide": "RIGHT", "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxMjowNTo0NFrOHY6mPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxMjozMDoxNFrOHY7ZiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg4NzkzNA==", "bodyText": "should use global var for WS and NL", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26121#discussion_r495887934", "createdAt": "2020-09-28T12:05:44Z", "author": {"login": "SupunS"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "diffHunk": "@@ -399,6 +429,436 @@ public RecordFieldWithDefaultValueNode transform(RecordFieldWithDefaultValueNode\n                 .apply();\n     }\n \n+    @Override\n+    public ImportDeclarationNode transform(ImportDeclarationNode importDeclarationNode) {\n+        Token importKeyword = formatToken(importDeclarationNode.importKeyword(), 1, 0);\n+\n+        boolean hasOrgName = importDeclarationNode.orgName().isPresent();\n+        boolean hasVersion = importDeclarationNode.version().isPresent();\n+        boolean hasPrefix = importDeclarationNode.prefix().isPresent();\n+\n+        if (hasOrgName) {\n+            ImportOrgNameNode orgName = formatNode(importDeclarationNode.orgName().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withOrgName(orgName).apply();\n+        }\n+        SeparatedNodeList<IdentifierToken> moduleNames = formatSeparatedNodeList(importDeclarationNode.moduleName(),\n+                0, 0, 0, 0, (hasVersion || hasPrefix) ? 1 : 0, 0);\n+\n+        if (hasVersion) {\n+            ImportVersionNode version = formatNode(importDeclarationNode.version().get(), hasPrefix ? 1 : 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withVersion(version).apply();\n+        }\n+        if (hasPrefix) {\n+            ImportPrefixNode prefix = formatNode(importDeclarationNode.prefix().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withPrefix(prefix).apply();\n+        }\n+        Token semicolon = formatToken(importDeclarationNode.semicolon(), this.trailingWS, this.trailingNL);\n+\n+        return importDeclarationNode.modify()\n+                .withImportKeyword(importKeyword)\n+                .withModuleName(moduleNames)\n+                .withSemicolon(semicolon)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ImportOrgNameNode transform(ImportOrgNameNode importOrgNameNode) {\n+        Token orgName = formatToken(importOrgNameNode.orgName(), 0, 0);\n+        Token slashToken = formatToken(importOrgNameNode.slashToken(), 0, 0);\n+\n+        return importOrgNameNode.modify()\n+                .withOrgName(orgName)\n+                .withSlashToken(slashToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ImportPrefixNode transform(ImportPrefixNode importPrefixNode) {\n+        Token asKeyword = formatToken(importPrefixNode.asKeyword(), 1, 0);\n+        Token prefix = formatToken(importPrefixNode.prefix(), 0, 0);\n+\n+        return importPrefixNode.modify()\n+                .withAsKeyword(asKeyword)\n+                .withPrefix(prefix)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ImportVersionNode transform(ImportVersionNode importVersionNode) {\n+        Token versionKeyword = formatToken(importVersionNode.versionKeyword(), 1, 0);\n+        SeparatedNodeList<Token> versionNumber = formatSeparatedNodeList(importVersionNode.versionNumber(),\n+                0, 0, 0, 0, this.trailingWS, 0);\n+\n+        return importVersionNode.modify()\n+                .withVersionKeyword(versionKeyword)\n+                .withVersionNumber(versionNumber)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ServiceDeclarationNode transform(ServiceDeclarationNode serviceDeclarationNode) {\n+        if (serviceDeclarationNode.metadata().isPresent()) {\n+            MetadataNode metadata = formatNode(serviceDeclarationNode.metadata().get(), 1, 0);\n+            serviceDeclarationNode = serviceDeclarationNode.modify().withMetadata(metadata).apply();\n+        }\n+\n+        Token serviceKeyword = formatToken(serviceDeclarationNode.serviceKeyword(), 1, 0);\n+        IdentifierToken serviceName = formatToken(serviceDeclarationNode.serviceName(), 1, 0);\n+        Token onKeyword = formatToken(serviceDeclarationNode.onKeyword(), 1, 0);\n+        SeparatedNodeList<ExpressionNode> expressions =\n+                formatSeparatedNodeList(serviceDeclarationNode.expressions(), 0, 0, 1, 0);\n+        Node serviceBody = formatNode(serviceDeclarationNode.serviceBody(), this.trailingWS, this.trailingNL);\n+\n+        return serviceDeclarationNode.modify()\n+                .withServiceKeyword(serviceKeyword)\n+                .withServiceName(serviceName)\n+                .withOnKeyword(onKeyword)\n+                .withExpressions(expressions)\n+                .withServiceBody(serviceBody)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ExplicitNewExpressionNode transform(ExplicitNewExpressionNode explicitNewExpressionNode) {\n+        Token newKeywordToken = formatToken(explicitNewExpressionNode.newKeyword(), 1, 0);\n+        TypeDescriptorNode typeDescriptorNode = formatNode(explicitNewExpressionNode.typeDescriptor(), 0, 0);\n+        ParenthesizedArgList parenthesizedArgList = formatNode(explicitNewExpressionNode.parenthesizedArgList(), 0, 0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bd7b0d855a3e4ed165fc3da4b34b7de38a82199"}, "originalPosition": 200}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTkwMTA2NQ==", "bodyText": "Done", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26121#discussion_r495901065", "createdAt": "2020-09-28T12:30:14Z", "author": {"login": "IrushiL"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "diffHunk": "@@ -399,6 +429,436 @@ public RecordFieldWithDefaultValueNode transform(RecordFieldWithDefaultValueNode\n                 .apply();\n     }\n \n+    @Override\n+    public ImportDeclarationNode transform(ImportDeclarationNode importDeclarationNode) {\n+        Token importKeyword = formatToken(importDeclarationNode.importKeyword(), 1, 0);\n+\n+        boolean hasOrgName = importDeclarationNode.orgName().isPresent();\n+        boolean hasVersion = importDeclarationNode.version().isPresent();\n+        boolean hasPrefix = importDeclarationNode.prefix().isPresent();\n+\n+        if (hasOrgName) {\n+            ImportOrgNameNode orgName = formatNode(importDeclarationNode.orgName().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withOrgName(orgName).apply();\n+        }\n+        SeparatedNodeList<IdentifierToken> moduleNames = formatSeparatedNodeList(importDeclarationNode.moduleName(),\n+                0, 0, 0, 0, (hasVersion || hasPrefix) ? 1 : 0, 0);\n+\n+        if (hasVersion) {\n+            ImportVersionNode version = formatNode(importDeclarationNode.version().get(), hasPrefix ? 1 : 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withVersion(version).apply();\n+        }\n+        if (hasPrefix) {\n+            ImportPrefixNode prefix = formatNode(importDeclarationNode.prefix().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withPrefix(prefix).apply();\n+        }\n+        Token semicolon = formatToken(importDeclarationNode.semicolon(), this.trailingWS, this.trailingNL);\n+\n+        return importDeclarationNode.modify()\n+                .withImportKeyword(importKeyword)\n+                .withModuleName(moduleNames)\n+                .withSemicolon(semicolon)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ImportOrgNameNode transform(ImportOrgNameNode importOrgNameNode) {\n+        Token orgName = formatToken(importOrgNameNode.orgName(), 0, 0);\n+        Token slashToken = formatToken(importOrgNameNode.slashToken(), 0, 0);\n+\n+        return importOrgNameNode.modify()\n+                .withOrgName(orgName)\n+                .withSlashToken(slashToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ImportPrefixNode transform(ImportPrefixNode importPrefixNode) {\n+        Token asKeyword = formatToken(importPrefixNode.asKeyword(), 1, 0);\n+        Token prefix = formatToken(importPrefixNode.prefix(), 0, 0);\n+\n+        return importPrefixNode.modify()\n+                .withAsKeyword(asKeyword)\n+                .withPrefix(prefix)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ImportVersionNode transform(ImportVersionNode importVersionNode) {\n+        Token versionKeyword = formatToken(importVersionNode.versionKeyword(), 1, 0);\n+        SeparatedNodeList<Token> versionNumber = formatSeparatedNodeList(importVersionNode.versionNumber(),\n+                0, 0, 0, 0, this.trailingWS, 0);\n+\n+        return importVersionNode.modify()\n+                .withVersionKeyword(versionKeyword)\n+                .withVersionNumber(versionNumber)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ServiceDeclarationNode transform(ServiceDeclarationNode serviceDeclarationNode) {\n+        if (serviceDeclarationNode.metadata().isPresent()) {\n+            MetadataNode metadata = formatNode(serviceDeclarationNode.metadata().get(), 1, 0);\n+            serviceDeclarationNode = serviceDeclarationNode.modify().withMetadata(metadata).apply();\n+        }\n+\n+        Token serviceKeyword = formatToken(serviceDeclarationNode.serviceKeyword(), 1, 0);\n+        IdentifierToken serviceName = formatToken(serviceDeclarationNode.serviceName(), 1, 0);\n+        Token onKeyword = formatToken(serviceDeclarationNode.onKeyword(), 1, 0);\n+        SeparatedNodeList<ExpressionNode> expressions =\n+                formatSeparatedNodeList(serviceDeclarationNode.expressions(), 0, 0, 1, 0);\n+        Node serviceBody = formatNode(serviceDeclarationNode.serviceBody(), this.trailingWS, this.trailingNL);\n+\n+        return serviceDeclarationNode.modify()\n+                .withServiceKeyword(serviceKeyword)\n+                .withServiceName(serviceName)\n+                .withOnKeyword(onKeyword)\n+                .withExpressions(expressions)\n+                .withServiceBody(serviceBody)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ExplicitNewExpressionNode transform(ExplicitNewExpressionNode explicitNewExpressionNode) {\n+        Token newKeywordToken = formatToken(explicitNewExpressionNode.newKeyword(), 1, 0);\n+        TypeDescriptorNode typeDescriptorNode = formatNode(explicitNewExpressionNode.typeDescriptor(), 0, 0);\n+        ParenthesizedArgList parenthesizedArgList = formatNode(explicitNewExpressionNode.parenthesizedArgList(), 0, 0);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg4NzkzNA=="}, "originalCommit": {"oid": "5bd7b0d855a3e4ed165fc3da4b34b7de38a82199"}, "originalPosition": 200}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNDI4ODE4OnYy", "diffSide": "RIGHT", "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxMjowNjoyMVrOHY6npA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxMjozMDozMFrOHY7aLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg4ODI5Mg==", "bodyText": "should use global var for WS and NL", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26121#discussion_r495888292", "createdAt": "2020-09-28T12:06:21Z", "author": {"login": "SupunS"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "diffHunk": "@@ -399,6 +429,436 @@ public RecordFieldWithDefaultValueNode transform(RecordFieldWithDefaultValueNode\n                 .apply();\n     }\n \n+    @Override\n+    public ImportDeclarationNode transform(ImportDeclarationNode importDeclarationNode) {\n+        Token importKeyword = formatToken(importDeclarationNode.importKeyword(), 1, 0);\n+\n+        boolean hasOrgName = importDeclarationNode.orgName().isPresent();\n+        boolean hasVersion = importDeclarationNode.version().isPresent();\n+        boolean hasPrefix = importDeclarationNode.prefix().isPresent();\n+\n+        if (hasOrgName) {\n+            ImportOrgNameNode orgName = formatNode(importDeclarationNode.orgName().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withOrgName(orgName).apply();\n+        }\n+        SeparatedNodeList<IdentifierToken> moduleNames = formatSeparatedNodeList(importDeclarationNode.moduleName(),\n+                0, 0, 0, 0, (hasVersion || hasPrefix) ? 1 : 0, 0);\n+\n+        if (hasVersion) {\n+            ImportVersionNode version = formatNode(importDeclarationNode.version().get(), hasPrefix ? 1 : 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withVersion(version).apply();\n+        }\n+        if (hasPrefix) {\n+            ImportPrefixNode prefix = formatNode(importDeclarationNode.prefix().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withPrefix(prefix).apply();\n+        }\n+        Token semicolon = formatToken(importDeclarationNode.semicolon(), this.trailingWS, this.trailingNL);\n+\n+        return importDeclarationNode.modify()\n+                .withImportKeyword(importKeyword)\n+                .withModuleName(moduleNames)\n+                .withSemicolon(semicolon)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ImportOrgNameNode transform(ImportOrgNameNode importOrgNameNode) {\n+        Token orgName = formatToken(importOrgNameNode.orgName(), 0, 0);\n+        Token slashToken = formatToken(importOrgNameNode.slashToken(), 0, 0);\n+\n+        return importOrgNameNode.modify()\n+                .withOrgName(orgName)\n+                .withSlashToken(slashToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ImportPrefixNode transform(ImportPrefixNode importPrefixNode) {\n+        Token asKeyword = formatToken(importPrefixNode.asKeyword(), 1, 0);\n+        Token prefix = formatToken(importPrefixNode.prefix(), 0, 0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bd7b0d855a3e4ed165fc3da4b34b7de38a82199"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTkwMTIyOQ==", "bodyText": "Done", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26121#discussion_r495901229", "createdAt": "2020-09-28T12:30:30Z", "author": {"login": "IrushiL"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "diffHunk": "@@ -399,6 +429,436 @@ public RecordFieldWithDefaultValueNode transform(RecordFieldWithDefaultValueNode\n                 .apply();\n     }\n \n+    @Override\n+    public ImportDeclarationNode transform(ImportDeclarationNode importDeclarationNode) {\n+        Token importKeyword = formatToken(importDeclarationNode.importKeyword(), 1, 0);\n+\n+        boolean hasOrgName = importDeclarationNode.orgName().isPresent();\n+        boolean hasVersion = importDeclarationNode.version().isPresent();\n+        boolean hasPrefix = importDeclarationNode.prefix().isPresent();\n+\n+        if (hasOrgName) {\n+            ImportOrgNameNode orgName = formatNode(importDeclarationNode.orgName().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withOrgName(orgName).apply();\n+        }\n+        SeparatedNodeList<IdentifierToken> moduleNames = formatSeparatedNodeList(importDeclarationNode.moduleName(),\n+                0, 0, 0, 0, (hasVersion || hasPrefix) ? 1 : 0, 0);\n+\n+        if (hasVersion) {\n+            ImportVersionNode version = formatNode(importDeclarationNode.version().get(), hasPrefix ? 1 : 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withVersion(version).apply();\n+        }\n+        if (hasPrefix) {\n+            ImportPrefixNode prefix = formatNode(importDeclarationNode.prefix().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withPrefix(prefix).apply();\n+        }\n+        Token semicolon = formatToken(importDeclarationNode.semicolon(), this.trailingWS, this.trailingNL);\n+\n+        return importDeclarationNode.modify()\n+                .withImportKeyword(importKeyword)\n+                .withModuleName(moduleNames)\n+                .withSemicolon(semicolon)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ImportOrgNameNode transform(ImportOrgNameNode importOrgNameNode) {\n+        Token orgName = formatToken(importOrgNameNode.orgName(), 0, 0);\n+        Token slashToken = formatToken(importOrgNameNode.slashToken(), 0, 0);\n+\n+        return importOrgNameNode.modify()\n+                .withOrgName(orgName)\n+                .withSlashToken(slashToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ImportPrefixNode transform(ImportPrefixNode importPrefixNode) {\n+        Token asKeyword = formatToken(importPrefixNode.asKeyword(), 1, 0);\n+        Token prefix = formatToken(importPrefixNode.prefix(), 0, 0);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg4ODI5Mg=="}, "originalCommit": {"oid": "5bd7b0d855a3e4ed165fc3da4b34b7de38a82199"}, "originalPosition": 153}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNDI4ODcyOnYy", "diffSide": "RIGHT", "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxMjowNjozMlrOHY6n9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxMjozMDo1MlrOHY7a_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg4ODM3NQ==", "bodyText": "should use global var for trailingNL", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26121#discussion_r495888375", "createdAt": "2020-09-28T12:06:32Z", "author": {"login": "SupunS"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "diffHunk": "@@ -399,6 +429,436 @@ public RecordFieldWithDefaultValueNode transform(RecordFieldWithDefaultValueNode\n                 .apply();\n     }\n \n+    @Override\n+    public ImportDeclarationNode transform(ImportDeclarationNode importDeclarationNode) {\n+        Token importKeyword = formatToken(importDeclarationNode.importKeyword(), 1, 0);\n+\n+        boolean hasOrgName = importDeclarationNode.orgName().isPresent();\n+        boolean hasVersion = importDeclarationNode.version().isPresent();\n+        boolean hasPrefix = importDeclarationNode.prefix().isPresent();\n+\n+        if (hasOrgName) {\n+            ImportOrgNameNode orgName = formatNode(importDeclarationNode.orgName().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withOrgName(orgName).apply();\n+        }\n+        SeparatedNodeList<IdentifierToken> moduleNames = formatSeparatedNodeList(importDeclarationNode.moduleName(),\n+                0, 0, 0, 0, (hasVersion || hasPrefix) ? 1 : 0, 0);\n+\n+        if (hasVersion) {\n+            ImportVersionNode version = formatNode(importDeclarationNode.version().get(), hasPrefix ? 1 : 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withVersion(version).apply();\n+        }\n+        if (hasPrefix) {\n+            ImportPrefixNode prefix = formatNode(importDeclarationNode.prefix().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withPrefix(prefix).apply();\n+        }\n+        Token semicolon = formatToken(importDeclarationNode.semicolon(), this.trailingWS, this.trailingNL);\n+\n+        return importDeclarationNode.modify()\n+                .withImportKeyword(importKeyword)\n+                .withModuleName(moduleNames)\n+                .withSemicolon(semicolon)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ImportOrgNameNode transform(ImportOrgNameNode importOrgNameNode) {\n+        Token orgName = formatToken(importOrgNameNode.orgName(), 0, 0);\n+        Token slashToken = formatToken(importOrgNameNode.slashToken(), 0, 0);\n+\n+        return importOrgNameNode.modify()\n+                .withOrgName(orgName)\n+                .withSlashToken(slashToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ImportPrefixNode transform(ImportPrefixNode importPrefixNode) {\n+        Token asKeyword = formatToken(importPrefixNode.asKeyword(), 1, 0);\n+        Token prefix = formatToken(importPrefixNode.prefix(), 0, 0);\n+\n+        return importPrefixNode.modify()\n+                .withAsKeyword(asKeyword)\n+                .withPrefix(prefix)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ImportVersionNode transform(ImportVersionNode importVersionNode) {\n+        Token versionKeyword = formatToken(importVersionNode.versionKeyword(), 1, 0);\n+        SeparatedNodeList<Token> versionNumber = formatSeparatedNodeList(importVersionNode.versionNumber(),\n+                0, 0, 0, 0, this.trailingWS, 0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bd7b0d855a3e4ed165fc3da4b34b7de38a82199"}, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTkwMTQzOQ==", "bodyText": "Done", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26121#discussion_r495901439", "createdAt": "2020-09-28T12:30:52Z", "author": {"login": "IrushiL"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "diffHunk": "@@ -399,6 +429,436 @@ public RecordFieldWithDefaultValueNode transform(RecordFieldWithDefaultValueNode\n                 .apply();\n     }\n \n+    @Override\n+    public ImportDeclarationNode transform(ImportDeclarationNode importDeclarationNode) {\n+        Token importKeyword = formatToken(importDeclarationNode.importKeyword(), 1, 0);\n+\n+        boolean hasOrgName = importDeclarationNode.orgName().isPresent();\n+        boolean hasVersion = importDeclarationNode.version().isPresent();\n+        boolean hasPrefix = importDeclarationNode.prefix().isPresent();\n+\n+        if (hasOrgName) {\n+            ImportOrgNameNode orgName = formatNode(importDeclarationNode.orgName().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withOrgName(orgName).apply();\n+        }\n+        SeparatedNodeList<IdentifierToken> moduleNames = formatSeparatedNodeList(importDeclarationNode.moduleName(),\n+                0, 0, 0, 0, (hasVersion || hasPrefix) ? 1 : 0, 0);\n+\n+        if (hasVersion) {\n+            ImportVersionNode version = formatNode(importDeclarationNode.version().get(), hasPrefix ? 1 : 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withVersion(version).apply();\n+        }\n+        if (hasPrefix) {\n+            ImportPrefixNode prefix = formatNode(importDeclarationNode.prefix().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withPrefix(prefix).apply();\n+        }\n+        Token semicolon = formatToken(importDeclarationNode.semicolon(), this.trailingWS, this.trailingNL);\n+\n+        return importDeclarationNode.modify()\n+                .withImportKeyword(importKeyword)\n+                .withModuleName(moduleNames)\n+                .withSemicolon(semicolon)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ImportOrgNameNode transform(ImportOrgNameNode importOrgNameNode) {\n+        Token orgName = formatToken(importOrgNameNode.orgName(), 0, 0);\n+        Token slashToken = formatToken(importOrgNameNode.slashToken(), 0, 0);\n+\n+        return importOrgNameNode.modify()\n+                .withOrgName(orgName)\n+                .withSlashToken(slashToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ImportPrefixNode transform(ImportPrefixNode importPrefixNode) {\n+        Token asKeyword = formatToken(importPrefixNode.asKeyword(), 1, 0);\n+        Token prefix = formatToken(importPrefixNode.prefix(), 0, 0);\n+\n+        return importPrefixNode.modify()\n+                .withAsKeyword(asKeyword)\n+                .withPrefix(prefix)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ImportVersionNode transform(ImportVersionNode importVersionNode) {\n+        Token versionKeyword = formatToken(importVersionNode.versionKeyword(), 1, 0);\n+        SeparatedNodeList<Token> versionNumber = formatSeparatedNodeList(importVersionNode.versionNumber(),\n+                0, 0, 0, 0, this.trailingWS, 0);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg4ODM3NQ=="}, "originalCommit": {"oid": "5bd7b0d855a3e4ed165fc3da4b34b7de38a82199"}, "originalPosition": 165}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNDI5MDI1OnYy", "diffSide": "RIGHT", "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxMjowNzowMFrOHY6o5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxMjozMzo0OVrOHY7hbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg4ODYxNA==", "bodyText": "should use global var for WS and NL", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26121#discussion_r495888614", "createdAt": "2020-09-28T12:07:00Z", "author": {"login": "SupunS"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "diffHunk": "@@ -399,6 +429,436 @@ public RecordFieldWithDefaultValueNode transform(RecordFieldWithDefaultValueNode\n                 .apply();\n     }\n \n+    @Override\n+    public ImportDeclarationNode transform(ImportDeclarationNode importDeclarationNode) {\n+        Token importKeyword = formatToken(importDeclarationNode.importKeyword(), 1, 0);\n+\n+        boolean hasOrgName = importDeclarationNode.orgName().isPresent();\n+        boolean hasVersion = importDeclarationNode.version().isPresent();\n+        boolean hasPrefix = importDeclarationNode.prefix().isPresent();\n+\n+        if (hasOrgName) {\n+            ImportOrgNameNode orgName = formatNode(importDeclarationNode.orgName().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withOrgName(orgName).apply();\n+        }\n+        SeparatedNodeList<IdentifierToken> moduleNames = formatSeparatedNodeList(importDeclarationNode.moduleName(),\n+                0, 0, 0, 0, (hasVersion || hasPrefix) ? 1 : 0, 0);\n+\n+        if (hasVersion) {\n+            ImportVersionNode version = formatNode(importDeclarationNode.version().get(), hasPrefix ? 1 : 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withVersion(version).apply();\n+        }\n+        if (hasPrefix) {\n+            ImportPrefixNode prefix = formatNode(importDeclarationNode.prefix().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withPrefix(prefix).apply();\n+        }\n+        Token semicolon = formatToken(importDeclarationNode.semicolon(), this.trailingWS, this.trailingNL);\n+\n+        return importDeclarationNode.modify()\n+                .withImportKeyword(importKeyword)\n+                .withModuleName(moduleNames)\n+                .withSemicolon(semicolon)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ImportOrgNameNode transform(ImportOrgNameNode importOrgNameNode) {\n+        Token orgName = formatToken(importOrgNameNode.orgName(), 0, 0);\n+        Token slashToken = formatToken(importOrgNameNode.slashToken(), 0, 0);\n+\n+        return importOrgNameNode.modify()\n+                .withOrgName(orgName)\n+                .withSlashToken(slashToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ImportPrefixNode transform(ImportPrefixNode importPrefixNode) {\n+        Token asKeyword = formatToken(importPrefixNode.asKeyword(), 1, 0);\n+        Token prefix = formatToken(importPrefixNode.prefix(), 0, 0);\n+\n+        return importPrefixNode.modify()\n+                .withAsKeyword(asKeyword)\n+                .withPrefix(prefix)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ImportVersionNode transform(ImportVersionNode importVersionNode) {\n+        Token versionKeyword = formatToken(importVersionNode.versionKeyword(), 1, 0);\n+        SeparatedNodeList<Token> versionNumber = formatSeparatedNodeList(importVersionNode.versionNumber(),\n+                0, 0, 0, 0, this.trailingWS, 0);\n+\n+        return importVersionNode.modify()\n+                .withVersionKeyword(versionKeyword)\n+                .withVersionNumber(versionNumber)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ServiceDeclarationNode transform(ServiceDeclarationNode serviceDeclarationNode) {\n+        if (serviceDeclarationNode.metadata().isPresent()) {\n+            MetadataNode metadata = formatNode(serviceDeclarationNode.metadata().get(), 1, 0);\n+            serviceDeclarationNode = serviceDeclarationNode.modify().withMetadata(metadata).apply();\n+        }\n+\n+        Token serviceKeyword = formatToken(serviceDeclarationNode.serviceKeyword(), 1, 0);\n+        IdentifierToken serviceName = formatToken(serviceDeclarationNode.serviceName(), 1, 0);\n+        Token onKeyword = formatToken(serviceDeclarationNode.onKeyword(), 1, 0);\n+        SeparatedNodeList<ExpressionNode> expressions =\n+                formatSeparatedNodeList(serviceDeclarationNode.expressions(), 0, 0, 1, 0);\n+        Node serviceBody = formatNode(serviceDeclarationNode.serviceBody(), this.trailingWS, this.trailingNL);\n+\n+        return serviceDeclarationNode.modify()\n+                .withServiceKeyword(serviceKeyword)\n+                .withServiceName(serviceName)\n+                .withOnKeyword(onKeyword)\n+                .withExpressions(expressions)\n+                .withServiceBody(serviceBody)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ExplicitNewExpressionNode transform(ExplicitNewExpressionNode explicitNewExpressionNode) {\n+        Token newKeywordToken = formatToken(explicitNewExpressionNode.newKeyword(), 1, 0);\n+        TypeDescriptorNode typeDescriptorNode = formatNode(explicitNewExpressionNode.typeDescriptor(), 0, 0);\n+        ParenthesizedArgList parenthesizedArgList = formatNode(explicitNewExpressionNode.parenthesizedArgList(), 0, 0);\n+\n+        return explicitNewExpressionNode.modify()\n+                .withNewKeyword(newKeywordToken)\n+                .withTypeDescriptor(typeDescriptorNode)\n+                .withParenthesizedArgList(parenthesizedArgList)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ParenthesizedArgList transform(ParenthesizedArgList parenthesizedArgList) {\n+        Token openParenToken = formatToken(parenthesizedArgList.openParenToken(), 0, 0);\n+        SeparatedNodeList<FunctionArgumentNode> arguments = formatSeparatedNodeList(parenthesizedArgList\n+                .arguments(), 0, 0, 0, 0);\n+        Token closeParenToken = formatToken(parenthesizedArgList.closeParenToken(), this.trailingWS, this.trailingNL);\n+\n+        return parenthesizedArgList.modify()\n+                .withOpenParenToken(openParenToken)\n+                .withArguments(arguments)\n+                .withCloseParenToken(closeParenToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ServiceBodyNode transform(ServiceBodyNode serviceBodyNode) {\n+        Token openBraceToken = formatToken(serviceBodyNode.openBraceToken(), 0, 1);\n+        indent(); // increase indentation for the statements to follow.\n+        NodeList<Node> resources = formatNodeList(serviceBodyNode.resources(), 0, 1, 0, 1);\n+        unindent(); // reset the indentation\n+        Token closeBraceToken = formatToken(serviceBodyNode.closeBraceToken(), this.trailingWS, this.trailingNL);\n+\n+        return serviceBodyNode.modify()\n+                .withOpenBraceToken(openBraceToken)\n+                .withResources(resources)\n+                .withCloseBraceToken(closeBraceToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public QualifiedNameReferenceNode transform(QualifiedNameReferenceNode qualifiedNameReferenceNode) {\n+        Token modulePrefix = formatToken(qualifiedNameReferenceNode.modulePrefix(), 0, 0);\n+        Token colon = formatToken((Token) qualifiedNameReferenceNode.colon(), 0, 0);\n+        IdentifierToken identifier = formatToken(qualifiedNameReferenceNode.identifier(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return qualifiedNameReferenceNode.modify()\n+                .withModulePrefix(modulePrefix)\n+                .withColon(colon)\n+                .withIdentifier(identifier)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ReturnTypeDescriptorNode transform(ReturnTypeDescriptorNode returnTypeDescriptorNode) {\n+        Token returnsKeyword = formatToken(returnTypeDescriptorNode.returnsKeyword(), 1, 0);\n+        NodeList<AnnotationNode> annotations = formatNodeList(returnTypeDescriptorNode.annotations(), 0, 0, 1, 0);\n+        Node type = formatNode(returnTypeDescriptorNode.type(), 1, 0);\n+\n+        return returnTypeDescriptorNode.modify()\n+                .withReturnsKeyword(returnsKeyword)\n+                .withAnnotations(annotations)\n+                .withType(type)\n+                .apply();\n+    }\n+\n+    @Override\n+    public OptionalTypeDescriptorNode transform(OptionalTypeDescriptorNode optionalTypeDescriptorNode) {\n+        Node typeDescriptor = formatNode(optionalTypeDescriptorNode.typeDescriptor(), 0, 0);\n+        Token questionMarkToken = formatToken(optionalTypeDescriptorNode.questionMarkToken(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return optionalTypeDescriptorNode.modify()\n+                .withTypeDescriptor(typeDescriptor)\n+                .withQuestionMarkToken(questionMarkToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ExpressionStatementNode transform(ExpressionStatementNode expressionStatementNode) {\n+        ExpressionNode expression = formatNode(expressionStatementNode.expression(), 0, 0);\n+        Token semicolonToken = formatToken(expressionStatementNode.semicolonToken(), this.trailingWS, this.trailingNL);\n+\n+        return expressionStatementNode.modify()\n+                .withExpression(expression)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public CheckExpressionNode transform(CheckExpressionNode checkExpressionNode) {\n+        Token checkKeyword = formatToken(checkExpressionNode.checkKeyword(), 1, 0);\n+        ExpressionNode expressionNode = formatNode(checkExpressionNode.expression(), this.trailingWS, this.trailingNL);\n+\n+        return checkExpressionNode.modify()\n+                .withCheckKeyword(checkKeyword)\n+                .withExpression(expressionNode)\n+                .apply();\n+    }\n+\n+    @Override\n+    public RemoteMethodCallActionNode transform(RemoteMethodCallActionNode remoteMethodCallActionNode) {\n+        ExpressionNode expression = formatNode(remoteMethodCallActionNode.expression(), 0, 0);\n+        Token rightArrowToken = formatToken(remoteMethodCallActionNode.rightArrowToken(), 0, 0);\n+        SimpleNameReferenceNode methodName = formatNode(remoteMethodCallActionNode.methodName(), 0, 0);\n+        Token openParenToken = formatToken(remoteMethodCallActionNode.openParenToken(), 0, 0);\n+        SeparatedNodeList<FunctionArgumentNode> arguments = formatSeparatedNodeList(remoteMethodCallActionNode\n+                .arguments(), 1, 0, 0, 0);\n+        Token closeParenToken = formatToken(remoteMethodCallActionNode.closeParenToken(), this.trailingWS, this.trailingNL);\n+\n+        return remoteMethodCallActionNode.modify()\n+                .withExpression(expression)\n+                .withRightArrowToken(rightArrowToken)\n+                .withMethodName(methodName)\n+                .withOpenParenToken(openParenToken)\n+                .withArguments(arguments)\n+                .withCloseParenToken(closeParenToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public SimpleNameReferenceNode transform(SimpleNameReferenceNode simpleNameReferenceNode) {\n+        Token name = formatToken(simpleNameReferenceNode.name(), this.trailingWS, this.trailingNL);\n+\n+        return simpleNameReferenceNode.modify()\n+                .withName(name)\n+                .apply();\n+    }\n+\n+    @Override\n+    public TypeDefinitionNode transform(TypeDefinitionNode typeDefinitionNode) {\n+        if (typeDefinitionNode.metadata().isPresent()) {\n+            MetadataNode metadata = formatNode(typeDefinitionNode.metadata().get(), 1, 0);\n+            typeDefinitionNode = typeDefinitionNode.modify().withMetadata(metadata).apply();\n+        }\n+        if (typeDefinitionNode.visibilityQualifier().isPresent()) {\n+            Token visibilityQualifier = formatToken(typeDefinitionNode.visibilityQualifier().get(), 1, 0);\n+            typeDefinitionNode = typeDefinitionNode.modify().withVisibilityQualifier(visibilityQualifier).apply();\n+        }\n+\n+        Token typeKeyword = formatToken(typeDefinitionNode.typeKeyword(), 1, 0);\n+        Token typeName = formatToken(typeDefinitionNode.typeName(), 1, 0);\n+        Node typeDescriptor = formatNode(typeDefinitionNode.typeDescriptor(), 1, 0);\n+        Token semicolonToken = formatToken(typeDefinitionNode.semicolonToken(), this.trailingWS, this.trailingNL);\n+\n+        return typeDefinitionNode.modify()\n+                .withTypeKeyword(typeKeyword)\n+                .withTypeName(typeName)\n+                .withTypeDescriptor(typeDescriptor)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public SingletonTypeDescriptorNode transform(SingletonTypeDescriptorNode singletonTypeDescriptorNode) {\n+        ExpressionNode simpleContExprNode = formatNode(singletonTypeDescriptorNode.simpleContExprNode(), 1, 0);\n+        return singletonTypeDescriptorNode.modify()\n+                .withSimpleContExprNode(simpleContExprNode)\n+                .apply();\n+    }\n+\n+    @Override\n+    public WhileStatementNode transform(WhileStatementNode whileStatementNode) {\n+        boolean hasOnFailClause = whileStatementNode.onFailClause().isPresent();\n+        Token whileKeyword = formatToken(whileStatementNode.whileKeyword(), 1, 0);\n+        ExpressionNode condition = formatNode(whileStatementNode.condition(), 1, 0);\n+        BlockStatementNode whileBody = formatNode(whileStatementNode.whileBody(),\n+                hasOnFailClause ? 1 : this.trailingWS, hasOnFailClause ? 0 : this.trailingNL);\n+\n+        if (hasOnFailClause) {\n+            OnFailClauseNode onFailClause = formatNode(whileStatementNode.onFailClause().get(),\n+                    this.trailingWS, this.trailingNL);\n+            whileStatementNode = whileStatementNode.modify().withOnFailClause(onFailClause).apply();\n+        }\n+\n+        return whileStatementNode.modify()\n+                .withWhileKeyword(whileKeyword)\n+                .withCondition(condition)\n+                .withWhileBody(whileBody)\n+                .apply();\n+    }\n+\n+    @Override\n+    public BracedExpressionNode transform(BracedExpressionNode bracedExpressionNode) {\n+        Token openParen = formatToken(bracedExpressionNode.openParen(), 0, 0);\n+        ExpressionNode expression = formatNode(bracedExpressionNode.expression(), 0, 0);\n+        Token closeParen = formatToken(bracedExpressionNode.closeParen(), this.trailingWS, this.trailingNL);\n+\n+        return bracedExpressionNode.modify()\n+                .withOpenParen(openParen)\n+                .withExpression(expression)\n+                .withCloseParen(closeParen)\n+                .apply();\n+    }\n+\n+    @Override\n+    public AssignmentStatementNode transform(AssignmentStatementNode assignmentStatementNode) {\n+        Node varRef = formatNode(assignmentStatementNode.varRef(), 1, 0);\n+        Token equalsToken = formatToken(assignmentStatementNode.equalsToken(), 1, 0);\n+        ExpressionNode expression = formatNode(assignmentStatementNode.expression(), 0, 0);\n+        Token semicolonToken = formatToken(assignmentStatementNode.semicolonToken(), this.trailingWS, this.trailingNL);\n+\n+        return assignmentStatementNode.modify()\n+                .withVarRef(varRef)\n+                .withEqualsToken(equalsToken)\n+                .withExpression(expression)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public CompoundAssignmentStatementNode transform(CompoundAssignmentStatementNode compoundAssignmentStatementNode) {\n+        ExpressionNode lhsExpression = formatNode(compoundAssignmentStatementNode.lhsExpression(), 1, 0);\n+        Token binaryOperator = formatToken(compoundAssignmentStatementNode.binaryOperator(), 0, 0);\n+        Token equalsToken = formatToken(compoundAssignmentStatementNode.equalsToken(), 1, 0);\n+        ExpressionNode rhsExpression = formatNode(compoundAssignmentStatementNode.rhsExpression(), 0, 0);\n+        Token semicolonToken = formatToken(compoundAssignmentStatementNode.semicolonToken(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return compoundAssignmentStatementNode.modify()\n+                .withLhsExpression(lhsExpression)\n+                .withBinaryOperator(binaryOperator)\n+                .withEqualsToken(equalsToken)\n+                .withRhsExpression(rhsExpression)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public DoStatementNode transform(DoStatementNode doStatementNode) {\n+        boolean hasOnFailClause = doStatementNode.onFailClause().isPresent();\n+\n+        Token doKeyword = formatToken(doStatementNode.doKeyword(), 1, 0);\n+        BlockStatementNode blockStatement = formatNode(doStatementNode.blockStatement(),\n+                hasOnFailClause ? 1 : this.trailingWS, hasOnFailClause ? 0 : this.trailingNL);\n+\n+        if (hasOnFailClause) {\n+            OnFailClauseNode onFailClause = formatNode(doStatementNode.onFailClause().get(),\n+                    this.trailingWS, this.trailingNL);\n+            doStatementNode = doStatementNode.modify().withOnFailClause(onFailClause).apply();\n+        }\n+\n+        return doStatementNode.modify()\n+                .withDoKeyword(doKeyword)\n+                .withBlockStatement(blockStatement)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ForEachStatementNode transform(ForEachStatementNode forEachStatementNode) {\n+        boolean hasOnFailClause = forEachStatementNode.onFailClause().isPresent();\n+\n+        Token forEachKeyword = formatToken(forEachStatementNode.forEachKeyword(), 1, 0);\n+        TypedBindingPatternNode typedBindingPattern = formatNode(forEachStatementNode.typedBindingPattern(), 1, 0);\n+        Token inKeyword = formatToken(forEachStatementNode.inKeyword(), 1, 0);\n+        Node actionOrExpressionNode = formatNode(forEachStatementNode.actionOrExpressionNode(), 1, 0);\n+        StatementNode blockStatement = formatNode(forEachStatementNode.blockStatement(),\n+                hasOnFailClause ? 1 : this.trailingWS, hasOnFailClause ? 0 : this.trailingNL);\n+\n+        if (hasOnFailClause) {\n+            OnFailClauseNode onFailClause = formatNode(forEachStatementNode.onFailClause().get(),\n+                    this.trailingWS, this.trailingNL);\n+            forEachStatementNode = forEachStatementNode.modify().withOnFailClause(onFailClause).apply();\n+        }\n+\n+        return forEachStatementNode.modify()\n+                .withForEachKeyword(forEachKeyword)\n+                .withTypedBindingPattern(typedBindingPattern)\n+                .withInKeyword(inKeyword)\n+                .withActionOrExpressionNode(actionOrExpressionNode)\n+                .withBlockStatement(blockStatement)\n+                .apply();\n+    }\n+\n+    @Override\n+    public BinaryExpressionNode transform(BinaryExpressionNode binaryExpressionNode) {\n+        Node lhsExpr = formatNode(binaryExpressionNode.lhsExpr(), 1, 0);\n+        Token operator = formatToken(binaryExpressionNode.operator(), 1, 0);\n+        Node rhsExpr = formatNode(binaryExpressionNode.rhsExpr(), this.trailingWS, this.trailingNL);\n+\n+        return binaryExpressionNode.modify()\n+                .withLhsExpr(lhsExpr)\n+                .withOperator(operator)\n+                .withRhsExpr(rhsExpr)\n+                .apply();\n+    }\n+\n+    @Override\n+    public OnFailClauseNode transform(OnFailClauseNode onFailClauseNode) {\n+        Token onKeyword = formatToken(onFailClauseNode.onKeyword(), 1, 0);\n+        Token failKeyword = formatToken(onFailClauseNode.failKeyword(), 1, 0);\n+        TypeDescriptorNode typeDescriptor = formatNode(onFailClauseNode.typeDescriptor(), 1, 0);\n+        IdentifierToken failErrorName = formatToken(onFailClauseNode.failErrorName(), 1, 0);\n+        BlockStatementNode blockStatement = formatNode(onFailClauseNode.blockStatement(), 0, 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bd7b0d855a3e4ed165fc3da4b34b7de38a82199"}, "originalPosition": 492}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTkwMzA4Nw==", "bodyText": "Done", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26121#discussion_r495903087", "createdAt": "2020-09-28T12:33:49Z", "author": {"login": "IrushiL"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "diffHunk": "@@ -399,6 +429,436 @@ public RecordFieldWithDefaultValueNode transform(RecordFieldWithDefaultValueNode\n                 .apply();\n     }\n \n+    @Override\n+    public ImportDeclarationNode transform(ImportDeclarationNode importDeclarationNode) {\n+        Token importKeyword = formatToken(importDeclarationNode.importKeyword(), 1, 0);\n+\n+        boolean hasOrgName = importDeclarationNode.orgName().isPresent();\n+        boolean hasVersion = importDeclarationNode.version().isPresent();\n+        boolean hasPrefix = importDeclarationNode.prefix().isPresent();\n+\n+        if (hasOrgName) {\n+            ImportOrgNameNode orgName = formatNode(importDeclarationNode.orgName().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withOrgName(orgName).apply();\n+        }\n+        SeparatedNodeList<IdentifierToken> moduleNames = formatSeparatedNodeList(importDeclarationNode.moduleName(),\n+                0, 0, 0, 0, (hasVersion || hasPrefix) ? 1 : 0, 0);\n+\n+        if (hasVersion) {\n+            ImportVersionNode version = formatNode(importDeclarationNode.version().get(), hasPrefix ? 1 : 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withVersion(version).apply();\n+        }\n+        if (hasPrefix) {\n+            ImportPrefixNode prefix = formatNode(importDeclarationNode.prefix().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withPrefix(prefix).apply();\n+        }\n+        Token semicolon = formatToken(importDeclarationNode.semicolon(), this.trailingWS, this.trailingNL);\n+\n+        return importDeclarationNode.modify()\n+                .withImportKeyword(importKeyword)\n+                .withModuleName(moduleNames)\n+                .withSemicolon(semicolon)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ImportOrgNameNode transform(ImportOrgNameNode importOrgNameNode) {\n+        Token orgName = formatToken(importOrgNameNode.orgName(), 0, 0);\n+        Token slashToken = formatToken(importOrgNameNode.slashToken(), 0, 0);\n+\n+        return importOrgNameNode.modify()\n+                .withOrgName(orgName)\n+                .withSlashToken(slashToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ImportPrefixNode transform(ImportPrefixNode importPrefixNode) {\n+        Token asKeyword = formatToken(importPrefixNode.asKeyword(), 1, 0);\n+        Token prefix = formatToken(importPrefixNode.prefix(), 0, 0);\n+\n+        return importPrefixNode.modify()\n+                .withAsKeyword(asKeyword)\n+                .withPrefix(prefix)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ImportVersionNode transform(ImportVersionNode importVersionNode) {\n+        Token versionKeyword = formatToken(importVersionNode.versionKeyword(), 1, 0);\n+        SeparatedNodeList<Token> versionNumber = formatSeparatedNodeList(importVersionNode.versionNumber(),\n+                0, 0, 0, 0, this.trailingWS, 0);\n+\n+        return importVersionNode.modify()\n+                .withVersionKeyword(versionKeyword)\n+                .withVersionNumber(versionNumber)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ServiceDeclarationNode transform(ServiceDeclarationNode serviceDeclarationNode) {\n+        if (serviceDeclarationNode.metadata().isPresent()) {\n+            MetadataNode metadata = formatNode(serviceDeclarationNode.metadata().get(), 1, 0);\n+            serviceDeclarationNode = serviceDeclarationNode.modify().withMetadata(metadata).apply();\n+        }\n+\n+        Token serviceKeyword = formatToken(serviceDeclarationNode.serviceKeyword(), 1, 0);\n+        IdentifierToken serviceName = formatToken(serviceDeclarationNode.serviceName(), 1, 0);\n+        Token onKeyword = formatToken(serviceDeclarationNode.onKeyword(), 1, 0);\n+        SeparatedNodeList<ExpressionNode> expressions =\n+                formatSeparatedNodeList(serviceDeclarationNode.expressions(), 0, 0, 1, 0);\n+        Node serviceBody = formatNode(serviceDeclarationNode.serviceBody(), this.trailingWS, this.trailingNL);\n+\n+        return serviceDeclarationNode.modify()\n+                .withServiceKeyword(serviceKeyword)\n+                .withServiceName(serviceName)\n+                .withOnKeyword(onKeyword)\n+                .withExpressions(expressions)\n+                .withServiceBody(serviceBody)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ExplicitNewExpressionNode transform(ExplicitNewExpressionNode explicitNewExpressionNode) {\n+        Token newKeywordToken = formatToken(explicitNewExpressionNode.newKeyword(), 1, 0);\n+        TypeDescriptorNode typeDescriptorNode = formatNode(explicitNewExpressionNode.typeDescriptor(), 0, 0);\n+        ParenthesizedArgList parenthesizedArgList = formatNode(explicitNewExpressionNode.parenthesizedArgList(), 0, 0);\n+\n+        return explicitNewExpressionNode.modify()\n+                .withNewKeyword(newKeywordToken)\n+                .withTypeDescriptor(typeDescriptorNode)\n+                .withParenthesizedArgList(parenthesizedArgList)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ParenthesizedArgList transform(ParenthesizedArgList parenthesizedArgList) {\n+        Token openParenToken = formatToken(parenthesizedArgList.openParenToken(), 0, 0);\n+        SeparatedNodeList<FunctionArgumentNode> arguments = formatSeparatedNodeList(parenthesizedArgList\n+                .arguments(), 0, 0, 0, 0);\n+        Token closeParenToken = formatToken(parenthesizedArgList.closeParenToken(), this.trailingWS, this.trailingNL);\n+\n+        return parenthesizedArgList.modify()\n+                .withOpenParenToken(openParenToken)\n+                .withArguments(arguments)\n+                .withCloseParenToken(closeParenToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ServiceBodyNode transform(ServiceBodyNode serviceBodyNode) {\n+        Token openBraceToken = formatToken(serviceBodyNode.openBraceToken(), 0, 1);\n+        indent(); // increase indentation for the statements to follow.\n+        NodeList<Node> resources = formatNodeList(serviceBodyNode.resources(), 0, 1, 0, 1);\n+        unindent(); // reset the indentation\n+        Token closeBraceToken = formatToken(serviceBodyNode.closeBraceToken(), this.trailingWS, this.trailingNL);\n+\n+        return serviceBodyNode.modify()\n+                .withOpenBraceToken(openBraceToken)\n+                .withResources(resources)\n+                .withCloseBraceToken(closeBraceToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public QualifiedNameReferenceNode transform(QualifiedNameReferenceNode qualifiedNameReferenceNode) {\n+        Token modulePrefix = formatToken(qualifiedNameReferenceNode.modulePrefix(), 0, 0);\n+        Token colon = formatToken((Token) qualifiedNameReferenceNode.colon(), 0, 0);\n+        IdentifierToken identifier = formatToken(qualifiedNameReferenceNode.identifier(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return qualifiedNameReferenceNode.modify()\n+                .withModulePrefix(modulePrefix)\n+                .withColon(colon)\n+                .withIdentifier(identifier)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ReturnTypeDescriptorNode transform(ReturnTypeDescriptorNode returnTypeDescriptorNode) {\n+        Token returnsKeyword = formatToken(returnTypeDescriptorNode.returnsKeyword(), 1, 0);\n+        NodeList<AnnotationNode> annotations = formatNodeList(returnTypeDescriptorNode.annotations(), 0, 0, 1, 0);\n+        Node type = formatNode(returnTypeDescriptorNode.type(), 1, 0);\n+\n+        return returnTypeDescriptorNode.modify()\n+                .withReturnsKeyword(returnsKeyword)\n+                .withAnnotations(annotations)\n+                .withType(type)\n+                .apply();\n+    }\n+\n+    @Override\n+    public OptionalTypeDescriptorNode transform(OptionalTypeDescriptorNode optionalTypeDescriptorNode) {\n+        Node typeDescriptor = formatNode(optionalTypeDescriptorNode.typeDescriptor(), 0, 0);\n+        Token questionMarkToken = formatToken(optionalTypeDescriptorNode.questionMarkToken(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return optionalTypeDescriptorNode.modify()\n+                .withTypeDescriptor(typeDescriptor)\n+                .withQuestionMarkToken(questionMarkToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ExpressionStatementNode transform(ExpressionStatementNode expressionStatementNode) {\n+        ExpressionNode expression = formatNode(expressionStatementNode.expression(), 0, 0);\n+        Token semicolonToken = formatToken(expressionStatementNode.semicolonToken(), this.trailingWS, this.trailingNL);\n+\n+        return expressionStatementNode.modify()\n+                .withExpression(expression)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public CheckExpressionNode transform(CheckExpressionNode checkExpressionNode) {\n+        Token checkKeyword = formatToken(checkExpressionNode.checkKeyword(), 1, 0);\n+        ExpressionNode expressionNode = formatNode(checkExpressionNode.expression(), this.trailingWS, this.trailingNL);\n+\n+        return checkExpressionNode.modify()\n+                .withCheckKeyword(checkKeyword)\n+                .withExpression(expressionNode)\n+                .apply();\n+    }\n+\n+    @Override\n+    public RemoteMethodCallActionNode transform(RemoteMethodCallActionNode remoteMethodCallActionNode) {\n+        ExpressionNode expression = formatNode(remoteMethodCallActionNode.expression(), 0, 0);\n+        Token rightArrowToken = formatToken(remoteMethodCallActionNode.rightArrowToken(), 0, 0);\n+        SimpleNameReferenceNode methodName = formatNode(remoteMethodCallActionNode.methodName(), 0, 0);\n+        Token openParenToken = formatToken(remoteMethodCallActionNode.openParenToken(), 0, 0);\n+        SeparatedNodeList<FunctionArgumentNode> arguments = formatSeparatedNodeList(remoteMethodCallActionNode\n+                .arguments(), 1, 0, 0, 0);\n+        Token closeParenToken = formatToken(remoteMethodCallActionNode.closeParenToken(), this.trailingWS, this.trailingNL);\n+\n+        return remoteMethodCallActionNode.modify()\n+                .withExpression(expression)\n+                .withRightArrowToken(rightArrowToken)\n+                .withMethodName(methodName)\n+                .withOpenParenToken(openParenToken)\n+                .withArguments(arguments)\n+                .withCloseParenToken(closeParenToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public SimpleNameReferenceNode transform(SimpleNameReferenceNode simpleNameReferenceNode) {\n+        Token name = formatToken(simpleNameReferenceNode.name(), this.trailingWS, this.trailingNL);\n+\n+        return simpleNameReferenceNode.modify()\n+                .withName(name)\n+                .apply();\n+    }\n+\n+    @Override\n+    public TypeDefinitionNode transform(TypeDefinitionNode typeDefinitionNode) {\n+        if (typeDefinitionNode.metadata().isPresent()) {\n+            MetadataNode metadata = formatNode(typeDefinitionNode.metadata().get(), 1, 0);\n+            typeDefinitionNode = typeDefinitionNode.modify().withMetadata(metadata).apply();\n+        }\n+        if (typeDefinitionNode.visibilityQualifier().isPresent()) {\n+            Token visibilityQualifier = formatToken(typeDefinitionNode.visibilityQualifier().get(), 1, 0);\n+            typeDefinitionNode = typeDefinitionNode.modify().withVisibilityQualifier(visibilityQualifier).apply();\n+        }\n+\n+        Token typeKeyword = formatToken(typeDefinitionNode.typeKeyword(), 1, 0);\n+        Token typeName = formatToken(typeDefinitionNode.typeName(), 1, 0);\n+        Node typeDescriptor = formatNode(typeDefinitionNode.typeDescriptor(), 1, 0);\n+        Token semicolonToken = formatToken(typeDefinitionNode.semicolonToken(), this.trailingWS, this.trailingNL);\n+\n+        return typeDefinitionNode.modify()\n+                .withTypeKeyword(typeKeyword)\n+                .withTypeName(typeName)\n+                .withTypeDescriptor(typeDescriptor)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public SingletonTypeDescriptorNode transform(SingletonTypeDescriptorNode singletonTypeDescriptorNode) {\n+        ExpressionNode simpleContExprNode = formatNode(singletonTypeDescriptorNode.simpleContExprNode(), 1, 0);\n+        return singletonTypeDescriptorNode.modify()\n+                .withSimpleContExprNode(simpleContExprNode)\n+                .apply();\n+    }\n+\n+    @Override\n+    public WhileStatementNode transform(WhileStatementNode whileStatementNode) {\n+        boolean hasOnFailClause = whileStatementNode.onFailClause().isPresent();\n+        Token whileKeyword = formatToken(whileStatementNode.whileKeyword(), 1, 0);\n+        ExpressionNode condition = formatNode(whileStatementNode.condition(), 1, 0);\n+        BlockStatementNode whileBody = formatNode(whileStatementNode.whileBody(),\n+                hasOnFailClause ? 1 : this.trailingWS, hasOnFailClause ? 0 : this.trailingNL);\n+\n+        if (hasOnFailClause) {\n+            OnFailClauseNode onFailClause = formatNode(whileStatementNode.onFailClause().get(),\n+                    this.trailingWS, this.trailingNL);\n+            whileStatementNode = whileStatementNode.modify().withOnFailClause(onFailClause).apply();\n+        }\n+\n+        return whileStatementNode.modify()\n+                .withWhileKeyword(whileKeyword)\n+                .withCondition(condition)\n+                .withWhileBody(whileBody)\n+                .apply();\n+    }\n+\n+    @Override\n+    public BracedExpressionNode transform(BracedExpressionNode bracedExpressionNode) {\n+        Token openParen = formatToken(bracedExpressionNode.openParen(), 0, 0);\n+        ExpressionNode expression = formatNode(bracedExpressionNode.expression(), 0, 0);\n+        Token closeParen = formatToken(bracedExpressionNode.closeParen(), this.trailingWS, this.trailingNL);\n+\n+        return bracedExpressionNode.modify()\n+                .withOpenParen(openParen)\n+                .withExpression(expression)\n+                .withCloseParen(closeParen)\n+                .apply();\n+    }\n+\n+    @Override\n+    public AssignmentStatementNode transform(AssignmentStatementNode assignmentStatementNode) {\n+        Node varRef = formatNode(assignmentStatementNode.varRef(), 1, 0);\n+        Token equalsToken = formatToken(assignmentStatementNode.equalsToken(), 1, 0);\n+        ExpressionNode expression = formatNode(assignmentStatementNode.expression(), 0, 0);\n+        Token semicolonToken = formatToken(assignmentStatementNode.semicolonToken(), this.trailingWS, this.trailingNL);\n+\n+        return assignmentStatementNode.modify()\n+                .withVarRef(varRef)\n+                .withEqualsToken(equalsToken)\n+                .withExpression(expression)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public CompoundAssignmentStatementNode transform(CompoundAssignmentStatementNode compoundAssignmentStatementNode) {\n+        ExpressionNode lhsExpression = formatNode(compoundAssignmentStatementNode.lhsExpression(), 1, 0);\n+        Token binaryOperator = formatToken(compoundAssignmentStatementNode.binaryOperator(), 0, 0);\n+        Token equalsToken = formatToken(compoundAssignmentStatementNode.equalsToken(), 1, 0);\n+        ExpressionNode rhsExpression = formatNode(compoundAssignmentStatementNode.rhsExpression(), 0, 0);\n+        Token semicolonToken = formatToken(compoundAssignmentStatementNode.semicolonToken(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return compoundAssignmentStatementNode.modify()\n+                .withLhsExpression(lhsExpression)\n+                .withBinaryOperator(binaryOperator)\n+                .withEqualsToken(equalsToken)\n+                .withRhsExpression(rhsExpression)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public DoStatementNode transform(DoStatementNode doStatementNode) {\n+        boolean hasOnFailClause = doStatementNode.onFailClause().isPresent();\n+\n+        Token doKeyword = formatToken(doStatementNode.doKeyword(), 1, 0);\n+        BlockStatementNode blockStatement = formatNode(doStatementNode.blockStatement(),\n+                hasOnFailClause ? 1 : this.trailingWS, hasOnFailClause ? 0 : this.trailingNL);\n+\n+        if (hasOnFailClause) {\n+            OnFailClauseNode onFailClause = formatNode(doStatementNode.onFailClause().get(),\n+                    this.trailingWS, this.trailingNL);\n+            doStatementNode = doStatementNode.modify().withOnFailClause(onFailClause).apply();\n+        }\n+\n+        return doStatementNode.modify()\n+                .withDoKeyword(doKeyword)\n+                .withBlockStatement(blockStatement)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ForEachStatementNode transform(ForEachStatementNode forEachStatementNode) {\n+        boolean hasOnFailClause = forEachStatementNode.onFailClause().isPresent();\n+\n+        Token forEachKeyword = formatToken(forEachStatementNode.forEachKeyword(), 1, 0);\n+        TypedBindingPatternNode typedBindingPattern = formatNode(forEachStatementNode.typedBindingPattern(), 1, 0);\n+        Token inKeyword = formatToken(forEachStatementNode.inKeyword(), 1, 0);\n+        Node actionOrExpressionNode = formatNode(forEachStatementNode.actionOrExpressionNode(), 1, 0);\n+        StatementNode blockStatement = formatNode(forEachStatementNode.blockStatement(),\n+                hasOnFailClause ? 1 : this.trailingWS, hasOnFailClause ? 0 : this.trailingNL);\n+\n+        if (hasOnFailClause) {\n+            OnFailClauseNode onFailClause = formatNode(forEachStatementNode.onFailClause().get(),\n+                    this.trailingWS, this.trailingNL);\n+            forEachStatementNode = forEachStatementNode.modify().withOnFailClause(onFailClause).apply();\n+        }\n+\n+        return forEachStatementNode.modify()\n+                .withForEachKeyword(forEachKeyword)\n+                .withTypedBindingPattern(typedBindingPattern)\n+                .withInKeyword(inKeyword)\n+                .withActionOrExpressionNode(actionOrExpressionNode)\n+                .withBlockStatement(blockStatement)\n+                .apply();\n+    }\n+\n+    @Override\n+    public BinaryExpressionNode transform(BinaryExpressionNode binaryExpressionNode) {\n+        Node lhsExpr = formatNode(binaryExpressionNode.lhsExpr(), 1, 0);\n+        Token operator = formatToken(binaryExpressionNode.operator(), 1, 0);\n+        Node rhsExpr = formatNode(binaryExpressionNode.rhsExpr(), this.trailingWS, this.trailingNL);\n+\n+        return binaryExpressionNode.modify()\n+                .withLhsExpr(lhsExpr)\n+                .withOperator(operator)\n+                .withRhsExpr(rhsExpr)\n+                .apply();\n+    }\n+\n+    @Override\n+    public OnFailClauseNode transform(OnFailClauseNode onFailClauseNode) {\n+        Token onKeyword = formatToken(onFailClauseNode.onKeyword(), 1, 0);\n+        Token failKeyword = formatToken(onFailClauseNode.failKeyword(), 1, 0);\n+        TypeDescriptorNode typeDescriptor = formatNode(onFailClauseNode.typeDescriptor(), 1, 0);\n+        IdentifierToken failErrorName = formatToken(onFailClauseNode.failErrorName(), 1, 0);\n+        BlockStatementNode blockStatement = formatNode(onFailClauseNode.blockStatement(), 0, 1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg4ODYxNA=="}, "originalCommit": {"oid": "5bd7b0d855a3e4ed165fc3da4b34b7de38a82199"}, "originalPosition": 492}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNDI5MjcxOnYy", "diffSide": "RIGHT", "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxMjowNzo1MVrOHY6qbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxMjozMjoxOFrOHY7eJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg4OTAwNQ==", "bodyText": "moving this inside the below if (hasOnFailClause) { block would be cleaner..", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26121#discussion_r495889005", "createdAt": "2020-09-28T12:07:51Z", "author": {"login": "SupunS"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "diffHunk": "@@ -399,6 +429,436 @@ public RecordFieldWithDefaultValueNode transform(RecordFieldWithDefaultValueNode\n                 .apply();\n     }\n \n+    @Override\n+    public ImportDeclarationNode transform(ImportDeclarationNode importDeclarationNode) {\n+        Token importKeyword = formatToken(importDeclarationNode.importKeyword(), 1, 0);\n+\n+        boolean hasOrgName = importDeclarationNode.orgName().isPresent();\n+        boolean hasVersion = importDeclarationNode.version().isPresent();\n+        boolean hasPrefix = importDeclarationNode.prefix().isPresent();\n+\n+        if (hasOrgName) {\n+            ImportOrgNameNode orgName = formatNode(importDeclarationNode.orgName().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withOrgName(orgName).apply();\n+        }\n+        SeparatedNodeList<IdentifierToken> moduleNames = formatSeparatedNodeList(importDeclarationNode.moduleName(),\n+                0, 0, 0, 0, (hasVersion || hasPrefix) ? 1 : 0, 0);\n+\n+        if (hasVersion) {\n+            ImportVersionNode version = formatNode(importDeclarationNode.version().get(), hasPrefix ? 1 : 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withVersion(version).apply();\n+        }\n+        if (hasPrefix) {\n+            ImportPrefixNode prefix = formatNode(importDeclarationNode.prefix().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withPrefix(prefix).apply();\n+        }\n+        Token semicolon = formatToken(importDeclarationNode.semicolon(), this.trailingWS, this.trailingNL);\n+\n+        return importDeclarationNode.modify()\n+                .withImportKeyword(importKeyword)\n+                .withModuleName(moduleNames)\n+                .withSemicolon(semicolon)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ImportOrgNameNode transform(ImportOrgNameNode importOrgNameNode) {\n+        Token orgName = formatToken(importOrgNameNode.orgName(), 0, 0);\n+        Token slashToken = formatToken(importOrgNameNode.slashToken(), 0, 0);\n+\n+        return importOrgNameNode.modify()\n+                .withOrgName(orgName)\n+                .withSlashToken(slashToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ImportPrefixNode transform(ImportPrefixNode importPrefixNode) {\n+        Token asKeyword = formatToken(importPrefixNode.asKeyword(), 1, 0);\n+        Token prefix = formatToken(importPrefixNode.prefix(), 0, 0);\n+\n+        return importPrefixNode.modify()\n+                .withAsKeyword(asKeyword)\n+                .withPrefix(prefix)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ImportVersionNode transform(ImportVersionNode importVersionNode) {\n+        Token versionKeyword = formatToken(importVersionNode.versionKeyword(), 1, 0);\n+        SeparatedNodeList<Token> versionNumber = formatSeparatedNodeList(importVersionNode.versionNumber(),\n+                0, 0, 0, 0, this.trailingWS, 0);\n+\n+        return importVersionNode.modify()\n+                .withVersionKeyword(versionKeyword)\n+                .withVersionNumber(versionNumber)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ServiceDeclarationNode transform(ServiceDeclarationNode serviceDeclarationNode) {\n+        if (serviceDeclarationNode.metadata().isPresent()) {\n+            MetadataNode metadata = formatNode(serviceDeclarationNode.metadata().get(), 1, 0);\n+            serviceDeclarationNode = serviceDeclarationNode.modify().withMetadata(metadata).apply();\n+        }\n+\n+        Token serviceKeyword = formatToken(serviceDeclarationNode.serviceKeyword(), 1, 0);\n+        IdentifierToken serviceName = formatToken(serviceDeclarationNode.serviceName(), 1, 0);\n+        Token onKeyword = formatToken(serviceDeclarationNode.onKeyword(), 1, 0);\n+        SeparatedNodeList<ExpressionNode> expressions =\n+                formatSeparatedNodeList(serviceDeclarationNode.expressions(), 0, 0, 1, 0);\n+        Node serviceBody = formatNode(serviceDeclarationNode.serviceBody(), this.trailingWS, this.trailingNL);\n+\n+        return serviceDeclarationNode.modify()\n+                .withServiceKeyword(serviceKeyword)\n+                .withServiceName(serviceName)\n+                .withOnKeyword(onKeyword)\n+                .withExpressions(expressions)\n+                .withServiceBody(serviceBody)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ExplicitNewExpressionNode transform(ExplicitNewExpressionNode explicitNewExpressionNode) {\n+        Token newKeywordToken = formatToken(explicitNewExpressionNode.newKeyword(), 1, 0);\n+        TypeDescriptorNode typeDescriptorNode = formatNode(explicitNewExpressionNode.typeDescriptor(), 0, 0);\n+        ParenthesizedArgList parenthesizedArgList = formatNode(explicitNewExpressionNode.parenthesizedArgList(), 0, 0);\n+\n+        return explicitNewExpressionNode.modify()\n+                .withNewKeyword(newKeywordToken)\n+                .withTypeDescriptor(typeDescriptorNode)\n+                .withParenthesizedArgList(parenthesizedArgList)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ParenthesizedArgList transform(ParenthesizedArgList parenthesizedArgList) {\n+        Token openParenToken = formatToken(parenthesizedArgList.openParenToken(), 0, 0);\n+        SeparatedNodeList<FunctionArgumentNode> arguments = formatSeparatedNodeList(parenthesizedArgList\n+                .arguments(), 0, 0, 0, 0);\n+        Token closeParenToken = formatToken(parenthesizedArgList.closeParenToken(), this.trailingWS, this.trailingNL);\n+\n+        return parenthesizedArgList.modify()\n+                .withOpenParenToken(openParenToken)\n+                .withArguments(arguments)\n+                .withCloseParenToken(closeParenToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ServiceBodyNode transform(ServiceBodyNode serviceBodyNode) {\n+        Token openBraceToken = formatToken(serviceBodyNode.openBraceToken(), 0, 1);\n+        indent(); // increase indentation for the statements to follow.\n+        NodeList<Node> resources = formatNodeList(serviceBodyNode.resources(), 0, 1, 0, 1);\n+        unindent(); // reset the indentation\n+        Token closeBraceToken = formatToken(serviceBodyNode.closeBraceToken(), this.trailingWS, this.trailingNL);\n+\n+        return serviceBodyNode.modify()\n+                .withOpenBraceToken(openBraceToken)\n+                .withResources(resources)\n+                .withCloseBraceToken(closeBraceToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public QualifiedNameReferenceNode transform(QualifiedNameReferenceNode qualifiedNameReferenceNode) {\n+        Token modulePrefix = formatToken(qualifiedNameReferenceNode.modulePrefix(), 0, 0);\n+        Token colon = formatToken((Token) qualifiedNameReferenceNode.colon(), 0, 0);\n+        IdentifierToken identifier = formatToken(qualifiedNameReferenceNode.identifier(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return qualifiedNameReferenceNode.modify()\n+                .withModulePrefix(modulePrefix)\n+                .withColon(colon)\n+                .withIdentifier(identifier)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ReturnTypeDescriptorNode transform(ReturnTypeDescriptorNode returnTypeDescriptorNode) {\n+        Token returnsKeyword = formatToken(returnTypeDescriptorNode.returnsKeyword(), 1, 0);\n+        NodeList<AnnotationNode> annotations = formatNodeList(returnTypeDescriptorNode.annotations(), 0, 0, 1, 0);\n+        Node type = formatNode(returnTypeDescriptorNode.type(), 1, 0);\n+\n+        return returnTypeDescriptorNode.modify()\n+                .withReturnsKeyword(returnsKeyword)\n+                .withAnnotations(annotations)\n+                .withType(type)\n+                .apply();\n+    }\n+\n+    @Override\n+    public OptionalTypeDescriptorNode transform(OptionalTypeDescriptorNode optionalTypeDescriptorNode) {\n+        Node typeDescriptor = formatNode(optionalTypeDescriptorNode.typeDescriptor(), 0, 0);\n+        Token questionMarkToken = formatToken(optionalTypeDescriptorNode.questionMarkToken(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return optionalTypeDescriptorNode.modify()\n+                .withTypeDescriptor(typeDescriptor)\n+                .withQuestionMarkToken(questionMarkToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ExpressionStatementNode transform(ExpressionStatementNode expressionStatementNode) {\n+        ExpressionNode expression = formatNode(expressionStatementNode.expression(), 0, 0);\n+        Token semicolonToken = formatToken(expressionStatementNode.semicolonToken(), this.trailingWS, this.trailingNL);\n+\n+        return expressionStatementNode.modify()\n+                .withExpression(expression)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public CheckExpressionNode transform(CheckExpressionNode checkExpressionNode) {\n+        Token checkKeyword = formatToken(checkExpressionNode.checkKeyword(), 1, 0);\n+        ExpressionNode expressionNode = formatNode(checkExpressionNode.expression(), this.trailingWS, this.trailingNL);\n+\n+        return checkExpressionNode.modify()\n+                .withCheckKeyword(checkKeyword)\n+                .withExpression(expressionNode)\n+                .apply();\n+    }\n+\n+    @Override\n+    public RemoteMethodCallActionNode transform(RemoteMethodCallActionNode remoteMethodCallActionNode) {\n+        ExpressionNode expression = formatNode(remoteMethodCallActionNode.expression(), 0, 0);\n+        Token rightArrowToken = formatToken(remoteMethodCallActionNode.rightArrowToken(), 0, 0);\n+        SimpleNameReferenceNode methodName = formatNode(remoteMethodCallActionNode.methodName(), 0, 0);\n+        Token openParenToken = formatToken(remoteMethodCallActionNode.openParenToken(), 0, 0);\n+        SeparatedNodeList<FunctionArgumentNode> arguments = formatSeparatedNodeList(remoteMethodCallActionNode\n+                .arguments(), 1, 0, 0, 0);\n+        Token closeParenToken = formatToken(remoteMethodCallActionNode.closeParenToken(), this.trailingWS, this.trailingNL);\n+\n+        return remoteMethodCallActionNode.modify()\n+                .withExpression(expression)\n+                .withRightArrowToken(rightArrowToken)\n+                .withMethodName(methodName)\n+                .withOpenParenToken(openParenToken)\n+                .withArguments(arguments)\n+                .withCloseParenToken(closeParenToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public SimpleNameReferenceNode transform(SimpleNameReferenceNode simpleNameReferenceNode) {\n+        Token name = formatToken(simpleNameReferenceNode.name(), this.trailingWS, this.trailingNL);\n+\n+        return simpleNameReferenceNode.modify()\n+                .withName(name)\n+                .apply();\n+    }\n+\n+    @Override\n+    public TypeDefinitionNode transform(TypeDefinitionNode typeDefinitionNode) {\n+        if (typeDefinitionNode.metadata().isPresent()) {\n+            MetadataNode metadata = formatNode(typeDefinitionNode.metadata().get(), 1, 0);\n+            typeDefinitionNode = typeDefinitionNode.modify().withMetadata(metadata).apply();\n+        }\n+        if (typeDefinitionNode.visibilityQualifier().isPresent()) {\n+            Token visibilityQualifier = formatToken(typeDefinitionNode.visibilityQualifier().get(), 1, 0);\n+            typeDefinitionNode = typeDefinitionNode.modify().withVisibilityQualifier(visibilityQualifier).apply();\n+        }\n+\n+        Token typeKeyword = formatToken(typeDefinitionNode.typeKeyword(), 1, 0);\n+        Token typeName = formatToken(typeDefinitionNode.typeName(), 1, 0);\n+        Node typeDescriptor = formatNode(typeDefinitionNode.typeDescriptor(), 1, 0);\n+        Token semicolonToken = formatToken(typeDefinitionNode.semicolonToken(), this.trailingWS, this.trailingNL);\n+\n+        return typeDefinitionNode.modify()\n+                .withTypeKeyword(typeKeyword)\n+                .withTypeName(typeName)\n+                .withTypeDescriptor(typeDescriptor)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public SingletonTypeDescriptorNode transform(SingletonTypeDescriptorNode singletonTypeDescriptorNode) {\n+        ExpressionNode simpleContExprNode = formatNode(singletonTypeDescriptorNode.simpleContExprNode(), 1, 0);\n+        return singletonTypeDescriptorNode.modify()\n+                .withSimpleContExprNode(simpleContExprNode)\n+                .apply();\n+    }\n+\n+    @Override\n+    public WhileStatementNode transform(WhileStatementNode whileStatementNode) {\n+        boolean hasOnFailClause = whileStatementNode.onFailClause().isPresent();\n+        Token whileKeyword = formatToken(whileStatementNode.whileKeyword(), 1, 0);\n+        ExpressionNode condition = formatNode(whileStatementNode.condition(), 1, 0);\n+        BlockStatementNode whileBody = formatNode(whileStatementNode.whileBody(),\n+                hasOnFailClause ? 1 : this.trailingWS, hasOnFailClause ? 0 : this.trailingNL);\n+\n+        if (hasOnFailClause) {\n+            OnFailClauseNode onFailClause = formatNode(whileStatementNode.onFailClause().get(),\n+                    this.trailingWS, this.trailingNL);\n+            whileStatementNode = whileStatementNode.modify().withOnFailClause(onFailClause).apply();\n+        }\n+\n+        return whileStatementNode.modify()\n+                .withWhileKeyword(whileKeyword)\n+                .withCondition(condition)\n+                .withWhileBody(whileBody)\n+                .apply();\n+    }\n+\n+    @Override\n+    public BracedExpressionNode transform(BracedExpressionNode bracedExpressionNode) {\n+        Token openParen = formatToken(bracedExpressionNode.openParen(), 0, 0);\n+        ExpressionNode expression = formatNode(bracedExpressionNode.expression(), 0, 0);\n+        Token closeParen = formatToken(bracedExpressionNode.closeParen(), this.trailingWS, this.trailingNL);\n+\n+        return bracedExpressionNode.modify()\n+                .withOpenParen(openParen)\n+                .withExpression(expression)\n+                .withCloseParen(closeParen)\n+                .apply();\n+    }\n+\n+    @Override\n+    public AssignmentStatementNode transform(AssignmentStatementNode assignmentStatementNode) {\n+        Node varRef = formatNode(assignmentStatementNode.varRef(), 1, 0);\n+        Token equalsToken = formatToken(assignmentStatementNode.equalsToken(), 1, 0);\n+        ExpressionNode expression = formatNode(assignmentStatementNode.expression(), 0, 0);\n+        Token semicolonToken = formatToken(assignmentStatementNode.semicolonToken(), this.trailingWS, this.trailingNL);\n+\n+        return assignmentStatementNode.modify()\n+                .withVarRef(varRef)\n+                .withEqualsToken(equalsToken)\n+                .withExpression(expression)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public CompoundAssignmentStatementNode transform(CompoundAssignmentStatementNode compoundAssignmentStatementNode) {\n+        ExpressionNode lhsExpression = formatNode(compoundAssignmentStatementNode.lhsExpression(), 1, 0);\n+        Token binaryOperator = formatToken(compoundAssignmentStatementNode.binaryOperator(), 0, 0);\n+        Token equalsToken = formatToken(compoundAssignmentStatementNode.equalsToken(), 1, 0);\n+        ExpressionNode rhsExpression = formatNode(compoundAssignmentStatementNode.rhsExpression(), 0, 0);\n+        Token semicolonToken = formatToken(compoundAssignmentStatementNode.semicolonToken(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return compoundAssignmentStatementNode.modify()\n+                .withLhsExpression(lhsExpression)\n+                .withBinaryOperator(binaryOperator)\n+                .withEqualsToken(equalsToken)\n+                .withRhsExpression(rhsExpression)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public DoStatementNode transform(DoStatementNode doStatementNode) {\n+        boolean hasOnFailClause = doStatementNode.onFailClause().isPresent();\n+\n+        Token doKeyword = formatToken(doStatementNode.doKeyword(), 1, 0);\n+        BlockStatementNode blockStatement = formatNode(doStatementNode.blockStatement(),\n+                hasOnFailClause ? 1 : this.trailingWS, hasOnFailClause ? 0 : this.trailingNL);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bd7b0d855a3e4ed165fc3da4b34b7de38a82199"}, "originalPosition": 433}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTkwMjI0Nw==", "bodyText": "Done", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26121#discussion_r495902247", "createdAt": "2020-09-28T12:32:18Z", "author": {"login": "IrushiL"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "diffHunk": "@@ -399,6 +429,436 @@ public RecordFieldWithDefaultValueNode transform(RecordFieldWithDefaultValueNode\n                 .apply();\n     }\n \n+    @Override\n+    public ImportDeclarationNode transform(ImportDeclarationNode importDeclarationNode) {\n+        Token importKeyword = formatToken(importDeclarationNode.importKeyword(), 1, 0);\n+\n+        boolean hasOrgName = importDeclarationNode.orgName().isPresent();\n+        boolean hasVersion = importDeclarationNode.version().isPresent();\n+        boolean hasPrefix = importDeclarationNode.prefix().isPresent();\n+\n+        if (hasOrgName) {\n+            ImportOrgNameNode orgName = formatNode(importDeclarationNode.orgName().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withOrgName(orgName).apply();\n+        }\n+        SeparatedNodeList<IdentifierToken> moduleNames = formatSeparatedNodeList(importDeclarationNode.moduleName(),\n+                0, 0, 0, 0, (hasVersion || hasPrefix) ? 1 : 0, 0);\n+\n+        if (hasVersion) {\n+            ImportVersionNode version = formatNode(importDeclarationNode.version().get(), hasPrefix ? 1 : 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withVersion(version).apply();\n+        }\n+        if (hasPrefix) {\n+            ImportPrefixNode prefix = formatNode(importDeclarationNode.prefix().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withPrefix(prefix).apply();\n+        }\n+        Token semicolon = formatToken(importDeclarationNode.semicolon(), this.trailingWS, this.trailingNL);\n+\n+        return importDeclarationNode.modify()\n+                .withImportKeyword(importKeyword)\n+                .withModuleName(moduleNames)\n+                .withSemicolon(semicolon)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ImportOrgNameNode transform(ImportOrgNameNode importOrgNameNode) {\n+        Token orgName = formatToken(importOrgNameNode.orgName(), 0, 0);\n+        Token slashToken = formatToken(importOrgNameNode.slashToken(), 0, 0);\n+\n+        return importOrgNameNode.modify()\n+                .withOrgName(orgName)\n+                .withSlashToken(slashToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ImportPrefixNode transform(ImportPrefixNode importPrefixNode) {\n+        Token asKeyword = formatToken(importPrefixNode.asKeyword(), 1, 0);\n+        Token prefix = formatToken(importPrefixNode.prefix(), 0, 0);\n+\n+        return importPrefixNode.modify()\n+                .withAsKeyword(asKeyword)\n+                .withPrefix(prefix)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ImportVersionNode transform(ImportVersionNode importVersionNode) {\n+        Token versionKeyword = formatToken(importVersionNode.versionKeyword(), 1, 0);\n+        SeparatedNodeList<Token> versionNumber = formatSeparatedNodeList(importVersionNode.versionNumber(),\n+                0, 0, 0, 0, this.trailingWS, 0);\n+\n+        return importVersionNode.modify()\n+                .withVersionKeyword(versionKeyword)\n+                .withVersionNumber(versionNumber)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ServiceDeclarationNode transform(ServiceDeclarationNode serviceDeclarationNode) {\n+        if (serviceDeclarationNode.metadata().isPresent()) {\n+            MetadataNode metadata = formatNode(serviceDeclarationNode.metadata().get(), 1, 0);\n+            serviceDeclarationNode = serviceDeclarationNode.modify().withMetadata(metadata).apply();\n+        }\n+\n+        Token serviceKeyword = formatToken(serviceDeclarationNode.serviceKeyword(), 1, 0);\n+        IdentifierToken serviceName = formatToken(serviceDeclarationNode.serviceName(), 1, 0);\n+        Token onKeyword = formatToken(serviceDeclarationNode.onKeyword(), 1, 0);\n+        SeparatedNodeList<ExpressionNode> expressions =\n+                formatSeparatedNodeList(serviceDeclarationNode.expressions(), 0, 0, 1, 0);\n+        Node serviceBody = formatNode(serviceDeclarationNode.serviceBody(), this.trailingWS, this.trailingNL);\n+\n+        return serviceDeclarationNode.modify()\n+                .withServiceKeyword(serviceKeyword)\n+                .withServiceName(serviceName)\n+                .withOnKeyword(onKeyword)\n+                .withExpressions(expressions)\n+                .withServiceBody(serviceBody)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ExplicitNewExpressionNode transform(ExplicitNewExpressionNode explicitNewExpressionNode) {\n+        Token newKeywordToken = formatToken(explicitNewExpressionNode.newKeyword(), 1, 0);\n+        TypeDescriptorNode typeDescriptorNode = formatNode(explicitNewExpressionNode.typeDescriptor(), 0, 0);\n+        ParenthesizedArgList parenthesizedArgList = formatNode(explicitNewExpressionNode.parenthesizedArgList(), 0, 0);\n+\n+        return explicitNewExpressionNode.modify()\n+                .withNewKeyword(newKeywordToken)\n+                .withTypeDescriptor(typeDescriptorNode)\n+                .withParenthesizedArgList(parenthesizedArgList)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ParenthesizedArgList transform(ParenthesizedArgList parenthesizedArgList) {\n+        Token openParenToken = formatToken(parenthesizedArgList.openParenToken(), 0, 0);\n+        SeparatedNodeList<FunctionArgumentNode> arguments = formatSeparatedNodeList(parenthesizedArgList\n+                .arguments(), 0, 0, 0, 0);\n+        Token closeParenToken = formatToken(parenthesizedArgList.closeParenToken(), this.trailingWS, this.trailingNL);\n+\n+        return parenthesizedArgList.modify()\n+                .withOpenParenToken(openParenToken)\n+                .withArguments(arguments)\n+                .withCloseParenToken(closeParenToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ServiceBodyNode transform(ServiceBodyNode serviceBodyNode) {\n+        Token openBraceToken = formatToken(serviceBodyNode.openBraceToken(), 0, 1);\n+        indent(); // increase indentation for the statements to follow.\n+        NodeList<Node> resources = formatNodeList(serviceBodyNode.resources(), 0, 1, 0, 1);\n+        unindent(); // reset the indentation\n+        Token closeBraceToken = formatToken(serviceBodyNode.closeBraceToken(), this.trailingWS, this.trailingNL);\n+\n+        return serviceBodyNode.modify()\n+                .withOpenBraceToken(openBraceToken)\n+                .withResources(resources)\n+                .withCloseBraceToken(closeBraceToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public QualifiedNameReferenceNode transform(QualifiedNameReferenceNode qualifiedNameReferenceNode) {\n+        Token modulePrefix = formatToken(qualifiedNameReferenceNode.modulePrefix(), 0, 0);\n+        Token colon = formatToken((Token) qualifiedNameReferenceNode.colon(), 0, 0);\n+        IdentifierToken identifier = formatToken(qualifiedNameReferenceNode.identifier(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return qualifiedNameReferenceNode.modify()\n+                .withModulePrefix(modulePrefix)\n+                .withColon(colon)\n+                .withIdentifier(identifier)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ReturnTypeDescriptorNode transform(ReturnTypeDescriptorNode returnTypeDescriptorNode) {\n+        Token returnsKeyword = formatToken(returnTypeDescriptorNode.returnsKeyword(), 1, 0);\n+        NodeList<AnnotationNode> annotations = formatNodeList(returnTypeDescriptorNode.annotations(), 0, 0, 1, 0);\n+        Node type = formatNode(returnTypeDescriptorNode.type(), 1, 0);\n+\n+        return returnTypeDescriptorNode.modify()\n+                .withReturnsKeyword(returnsKeyword)\n+                .withAnnotations(annotations)\n+                .withType(type)\n+                .apply();\n+    }\n+\n+    @Override\n+    public OptionalTypeDescriptorNode transform(OptionalTypeDescriptorNode optionalTypeDescriptorNode) {\n+        Node typeDescriptor = formatNode(optionalTypeDescriptorNode.typeDescriptor(), 0, 0);\n+        Token questionMarkToken = formatToken(optionalTypeDescriptorNode.questionMarkToken(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return optionalTypeDescriptorNode.modify()\n+                .withTypeDescriptor(typeDescriptor)\n+                .withQuestionMarkToken(questionMarkToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ExpressionStatementNode transform(ExpressionStatementNode expressionStatementNode) {\n+        ExpressionNode expression = formatNode(expressionStatementNode.expression(), 0, 0);\n+        Token semicolonToken = formatToken(expressionStatementNode.semicolonToken(), this.trailingWS, this.trailingNL);\n+\n+        return expressionStatementNode.modify()\n+                .withExpression(expression)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public CheckExpressionNode transform(CheckExpressionNode checkExpressionNode) {\n+        Token checkKeyword = formatToken(checkExpressionNode.checkKeyword(), 1, 0);\n+        ExpressionNode expressionNode = formatNode(checkExpressionNode.expression(), this.trailingWS, this.trailingNL);\n+\n+        return checkExpressionNode.modify()\n+                .withCheckKeyword(checkKeyword)\n+                .withExpression(expressionNode)\n+                .apply();\n+    }\n+\n+    @Override\n+    public RemoteMethodCallActionNode transform(RemoteMethodCallActionNode remoteMethodCallActionNode) {\n+        ExpressionNode expression = formatNode(remoteMethodCallActionNode.expression(), 0, 0);\n+        Token rightArrowToken = formatToken(remoteMethodCallActionNode.rightArrowToken(), 0, 0);\n+        SimpleNameReferenceNode methodName = formatNode(remoteMethodCallActionNode.methodName(), 0, 0);\n+        Token openParenToken = formatToken(remoteMethodCallActionNode.openParenToken(), 0, 0);\n+        SeparatedNodeList<FunctionArgumentNode> arguments = formatSeparatedNodeList(remoteMethodCallActionNode\n+                .arguments(), 1, 0, 0, 0);\n+        Token closeParenToken = formatToken(remoteMethodCallActionNode.closeParenToken(), this.trailingWS, this.trailingNL);\n+\n+        return remoteMethodCallActionNode.modify()\n+                .withExpression(expression)\n+                .withRightArrowToken(rightArrowToken)\n+                .withMethodName(methodName)\n+                .withOpenParenToken(openParenToken)\n+                .withArguments(arguments)\n+                .withCloseParenToken(closeParenToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public SimpleNameReferenceNode transform(SimpleNameReferenceNode simpleNameReferenceNode) {\n+        Token name = formatToken(simpleNameReferenceNode.name(), this.trailingWS, this.trailingNL);\n+\n+        return simpleNameReferenceNode.modify()\n+                .withName(name)\n+                .apply();\n+    }\n+\n+    @Override\n+    public TypeDefinitionNode transform(TypeDefinitionNode typeDefinitionNode) {\n+        if (typeDefinitionNode.metadata().isPresent()) {\n+            MetadataNode metadata = formatNode(typeDefinitionNode.metadata().get(), 1, 0);\n+            typeDefinitionNode = typeDefinitionNode.modify().withMetadata(metadata).apply();\n+        }\n+        if (typeDefinitionNode.visibilityQualifier().isPresent()) {\n+            Token visibilityQualifier = formatToken(typeDefinitionNode.visibilityQualifier().get(), 1, 0);\n+            typeDefinitionNode = typeDefinitionNode.modify().withVisibilityQualifier(visibilityQualifier).apply();\n+        }\n+\n+        Token typeKeyword = formatToken(typeDefinitionNode.typeKeyword(), 1, 0);\n+        Token typeName = formatToken(typeDefinitionNode.typeName(), 1, 0);\n+        Node typeDescriptor = formatNode(typeDefinitionNode.typeDescriptor(), 1, 0);\n+        Token semicolonToken = formatToken(typeDefinitionNode.semicolonToken(), this.trailingWS, this.trailingNL);\n+\n+        return typeDefinitionNode.modify()\n+                .withTypeKeyword(typeKeyword)\n+                .withTypeName(typeName)\n+                .withTypeDescriptor(typeDescriptor)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public SingletonTypeDescriptorNode transform(SingletonTypeDescriptorNode singletonTypeDescriptorNode) {\n+        ExpressionNode simpleContExprNode = formatNode(singletonTypeDescriptorNode.simpleContExprNode(), 1, 0);\n+        return singletonTypeDescriptorNode.modify()\n+                .withSimpleContExprNode(simpleContExprNode)\n+                .apply();\n+    }\n+\n+    @Override\n+    public WhileStatementNode transform(WhileStatementNode whileStatementNode) {\n+        boolean hasOnFailClause = whileStatementNode.onFailClause().isPresent();\n+        Token whileKeyword = formatToken(whileStatementNode.whileKeyword(), 1, 0);\n+        ExpressionNode condition = formatNode(whileStatementNode.condition(), 1, 0);\n+        BlockStatementNode whileBody = formatNode(whileStatementNode.whileBody(),\n+                hasOnFailClause ? 1 : this.trailingWS, hasOnFailClause ? 0 : this.trailingNL);\n+\n+        if (hasOnFailClause) {\n+            OnFailClauseNode onFailClause = formatNode(whileStatementNode.onFailClause().get(),\n+                    this.trailingWS, this.trailingNL);\n+            whileStatementNode = whileStatementNode.modify().withOnFailClause(onFailClause).apply();\n+        }\n+\n+        return whileStatementNode.modify()\n+                .withWhileKeyword(whileKeyword)\n+                .withCondition(condition)\n+                .withWhileBody(whileBody)\n+                .apply();\n+    }\n+\n+    @Override\n+    public BracedExpressionNode transform(BracedExpressionNode bracedExpressionNode) {\n+        Token openParen = formatToken(bracedExpressionNode.openParen(), 0, 0);\n+        ExpressionNode expression = formatNode(bracedExpressionNode.expression(), 0, 0);\n+        Token closeParen = formatToken(bracedExpressionNode.closeParen(), this.trailingWS, this.trailingNL);\n+\n+        return bracedExpressionNode.modify()\n+                .withOpenParen(openParen)\n+                .withExpression(expression)\n+                .withCloseParen(closeParen)\n+                .apply();\n+    }\n+\n+    @Override\n+    public AssignmentStatementNode transform(AssignmentStatementNode assignmentStatementNode) {\n+        Node varRef = formatNode(assignmentStatementNode.varRef(), 1, 0);\n+        Token equalsToken = formatToken(assignmentStatementNode.equalsToken(), 1, 0);\n+        ExpressionNode expression = formatNode(assignmentStatementNode.expression(), 0, 0);\n+        Token semicolonToken = formatToken(assignmentStatementNode.semicolonToken(), this.trailingWS, this.trailingNL);\n+\n+        return assignmentStatementNode.modify()\n+                .withVarRef(varRef)\n+                .withEqualsToken(equalsToken)\n+                .withExpression(expression)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public CompoundAssignmentStatementNode transform(CompoundAssignmentStatementNode compoundAssignmentStatementNode) {\n+        ExpressionNode lhsExpression = formatNode(compoundAssignmentStatementNode.lhsExpression(), 1, 0);\n+        Token binaryOperator = formatToken(compoundAssignmentStatementNode.binaryOperator(), 0, 0);\n+        Token equalsToken = formatToken(compoundAssignmentStatementNode.equalsToken(), 1, 0);\n+        ExpressionNode rhsExpression = formatNode(compoundAssignmentStatementNode.rhsExpression(), 0, 0);\n+        Token semicolonToken = formatToken(compoundAssignmentStatementNode.semicolonToken(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return compoundAssignmentStatementNode.modify()\n+                .withLhsExpression(lhsExpression)\n+                .withBinaryOperator(binaryOperator)\n+                .withEqualsToken(equalsToken)\n+                .withRhsExpression(rhsExpression)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public DoStatementNode transform(DoStatementNode doStatementNode) {\n+        boolean hasOnFailClause = doStatementNode.onFailClause().isPresent();\n+\n+        Token doKeyword = formatToken(doStatementNode.doKeyword(), 1, 0);\n+        BlockStatementNode blockStatement = formatNode(doStatementNode.blockStatement(),\n+                hasOnFailClause ? 1 : this.trailingWS, hasOnFailClause ? 0 : this.trailingNL);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg4OTAwNQ=="}, "originalCommit": {"oid": "5bd7b0d855a3e4ed165fc3da4b34b7de38a82199"}, "originalPosition": 433}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4820, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}