{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA5NDM2MzQx", "number": 22917, "title": "Introduce new API to validate OAuth2 tokens & move OAuth2 caching operations to validation logic [master]", "bodyText": "Purpose\nThis PR introduces new API (oauth2:validateOAuth2Token) to validate OAuth2 token and moves the OAuth2 caching operations (addToCache & validateFromCache) into oauth2:validateOAuth2Token API since the caching operations should be engaged for both direct and indirect API calls of oauth2:validateOAuth2Token API.\nCheck List\n\n Read the Contributing Guide\n Updated Change Log\n Checked Tooling Support (#)\n Added necessary tests\n\n Unit Tests\n Spec Conformance Tests\n Integration Tests\n Ballerina By Example Tests\n\n\n Increased Test Coverage\n Added necessary documentation\n\n API documentation\n Module documentation in Module.md files\n Ballerina By Examples", "createdAt": "2020-04-27T11:25:19Z", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22917", "merged": true, "mergeCommit": {"oid": "7813df613570c64698749abe25bebf1cb4e457cf"}, "closed": true, "closedAt": "2020-04-29T09:56:50Z", "author": {"login": "ldclakmal"}, "timelineItems": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcbsFZGgH2gAyNDA5NDM2MzQxOmI2MzM0ZTEzZjRiZDFkZmQxMDIwODM0YjU4Nzk3ZTg3NTJkMzIzZWI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABccTsNngFqTQwMjQzNTczMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "b6334e13f4bd1dfd1020834b58797e8752d323eb", "author": {"user": {"login": "ldclakmal", "name": "Chanaka Lakmal"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b6334e13f4bd1dfd1020834b58797e8752d323eb", "committedDate": "2020-04-27T09:43:45Z", "message": "Add new API to validate OAuth2 token"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d7886d178fbc76e48555088973e06ec7ff14488f", "author": {"user": {"login": "ldclakmal", "name": "Chanaka Lakmal"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/d7886d178fbc76e48555088973e06ec7ff14488f", "committedDate": "2020-04-27T10:09:29Z", "message": "Move OAuth2 caching operations to validation logic"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "815d2685c5eba78197a8cc0b727ef1c44613dad6", "author": {"user": {"login": "ldclakmal", "name": "Chanaka Lakmal"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/815d2685c5eba78197a8cc0b727ef1c44613dad6", "committedDate": "2020-04-27T11:06:40Z", "message": "Build introspection response with all parameters"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ac27cd1c4720767c4b7c4079947ef3ea58f6f668", "author": {"user": {"login": "ldclakmal", "name": "Chanaka Lakmal"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/ac27cd1c4720767c4b7c4079947ef3ea58f6f668", "committedDate": "2020-04-27T11:21:22Z", "message": "Update caching and retrieving implementation"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAyMzY5NzU1", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22917#pullrequestreview-402369755", "createdAt": "2020-04-29T05:19:35Z", "commit": {"oid": "ff83dc80c4afbcd940b49c0035b3a0dfbeafc642"}, "state": "COMMENTED", "comments": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwNToxOTozNlrOGNwD0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwNToyNjozM1rOGNwLiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA3MjA4MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            # + token - OAuth2 token that needs to be validated\n          \n          \n            \n            # + token - OAuth2 token, which needs to be validated", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22917#discussion_r417072081", "createdAt": "2020-04-29T05:19:36Z", "author": {"login": "praneesha"}, "path": "stdlib/oauth2/src/main/ballerina/src/oauth2/inbound_oauth2_provider.bal", "diffHunk": "@@ -60,108 +52,183 @@ public type InboundOAuth2Provider object {\n #\n # + credential - OAuth2 token to be authenticated\n # + return - `true` if authentication is successful, `false` otherwise, or else an `auth:Error` if an error occurred\n-    public function authenticate(string credential) returns boolean|auth:Error {\n+    public function authenticate(string credential) returns @tainted (boolean|auth:Error) {\n         if (credential == \"\") {\n             return false;\n         }\n \n-        cache:Cache? oauth2Cache = self.inboundOAuth2Cache;\n-        if (oauth2Cache is cache:Cache && oauth2Cache.hasKey(credential)) {\n-            InboundOAuth2CacheEntry? oauth2CacheEntry = authenticateFromCache(oauth2Cache, credential);\n-            if (oauth2CacheEntry is InboundOAuth2CacheEntry) {\n+        IntrospectionResponse|Error validationResult = validateOAuth2Token(credential, self.introspectionServerConfig);\n+        if (validationResult is IntrospectionResponse) {\n+            if (validationResult.active) {\n                 auth:setAuthenticationContext(\"oauth2\", credential);\n-                auth:setPrincipal(oauth2CacheEntry.username, oauth2CacheEntry.username,\n-                                  getScopes(oauth2CacheEntry.scopes));\n-                return true;\n+                auth:setPrincipal(validationResult?.username, validationResult?.username,\n+                                  getScopes(validationResult?.scopes));\n             }\n+            return validationResult.active;\n+        } else {\n+            return prepareAuthError(\"OAuth2 validation failed.\", validationResult);\n         }\n+    }\n+};\n \n-        // Build the request to be send to the introspection endpoint.\n-        // Refer: https://tools.ietf.org/html/rfc7662#section-2.1\n-        http:Request req = new;\n-        string textPayload = \"token=\" + credential;\n-        string? tokenTypeHint = self.tokenTypeHint;\n-        if (tokenTypeHint is string) {\n-            textPayload += \"&token_type_hint=\" + tokenTypeHint;\n-        }\n-        req.setTextPayload(textPayload, mime:APPLICATION_FORM_URLENCODED);\n-        http:Response|http:ClientError response = self.introspectionClient->post(\"\", req);\n-        if (response is http:Response) {\n-            json|error result = response.getJsonPayload();\n-            if (result is error) {\n-                return <@untainted> prepareAuthError(result.reason(), result);\n-            }\n-\n-            json payload = <json>result;\n-            boolean active = <boolean>payload.active;\n-            if (active) {\n-                string? username = ();\n-                string? scopes = ();\n-                int exp;\n-\n-                if (payload.username is string) {\n-                    username = <@untainted> <string>payload.username;\n-                }\n-                if (payload.scope is string) {\n-                    scopes = <@untainted> <string>payload.scope;\n-                }\n-                if (payload.exp is int) {\n-                    exp = <@untainted> <int>payload.exp;\n-                } else {\n-                    exp = self.defaultTokenExpTimeInSeconds +  (time:currentTime().time / 1000);\n-                }\n+# Validates the given OAuth2 token.\n+# ```ballerina\n+# oauth2:IntrospectionResponse|oauth2:Error result = oauth2:validateOAuth2Token(token, introspectionServerConfig);\n+# ```\n+#\n+# + token - OAuth2 token that needs to be validated", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff83dc80c4afbcd940b49c0035b3a0dfbeafc642"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA3MjEzOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            # + return - OAuth2 introspection server response or else a `oauth2:Error` if token validation fails\n          \n          \n            \n            # + return - OAuth2 introspection server response or else an `oauth2:Error` if token validation fails", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22917#discussion_r417072138", "createdAt": "2020-04-29T05:19:51Z", "author": {"login": "praneesha"}, "path": "stdlib/oauth2/src/main/ballerina/src/oauth2/inbound_oauth2_provider.bal", "diffHunk": "@@ -60,108 +52,183 @@ public type InboundOAuth2Provider object {\n #\n # + credential - OAuth2 token to be authenticated\n # + return - `true` if authentication is successful, `false` otherwise, or else an `auth:Error` if an error occurred\n-    public function authenticate(string credential) returns boolean|auth:Error {\n+    public function authenticate(string credential) returns @tainted (boolean|auth:Error) {\n         if (credential == \"\") {\n             return false;\n         }\n \n-        cache:Cache? oauth2Cache = self.inboundOAuth2Cache;\n-        if (oauth2Cache is cache:Cache && oauth2Cache.hasKey(credential)) {\n-            InboundOAuth2CacheEntry? oauth2CacheEntry = authenticateFromCache(oauth2Cache, credential);\n-            if (oauth2CacheEntry is InboundOAuth2CacheEntry) {\n+        IntrospectionResponse|Error validationResult = validateOAuth2Token(credential, self.introspectionServerConfig);\n+        if (validationResult is IntrospectionResponse) {\n+            if (validationResult.active) {\n                 auth:setAuthenticationContext(\"oauth2\", credential);\n-                auth:setPrincipal(oauth2CacheEntry.username, oauth2CacheEntry.username,\n-                                  getScopes(oauth2CacheEntry.scopes));\n-                return true;\n+                auth:setPrincipal(validationResult?.username, validationResult?.username,\n+                                  getScopes(validationResult?.scopes));\n             }\n+            return validationResult.active;\n+        } else {\n+            return prepareAuthError(\"OAuth2 validation failed.\", validationResult);\n         }\n+    }\n+};\n \n-        // Build the request to be send to the introspection endpoint.\n-        // Refer: https://tools.ietf.org/html/rfc7662#section-2.1\n-        http:Request req = new;\n-        string textPayload = \"token=\" + credential;\n-        string? tokenTypeHint = self.tokenTypeHint;\n-        if (tokenTypeHint is string) {\n-            textPayload += \"&token_type_hint=\" + tokenTypeHint;\n-        }\n-        req.setTextPayload(textPayload, mime:APPLICATION_FORM_URLENCODED);\n-        http:Response|http:ClientError response = self.introspectionClient->post(\"\", req);\n-        if (response is http:Response) {\n-            json|error result = response.getJsonPayload();\n-            if (result is error) {\n-                return <@untainted> prepareAuthError(result.reason(), result);\n-            }\n-\n-            json payload = <json>result;\n-            boolean active = <boolean>payload.active;\n-            if (active) {\n-                string? username = ();\n-                string? scopes = ();\n-                int exp;\n-\n-                if (payload.username is string) {\n-                    username = <@untainted> <string>payload.username;\n-                }\n-                if (payload.scope is string) {\n-                    scopes = <@untainted> <string>payload.scope;\n-                }\n-                if (payload.exp is int) {\n-                    exp = <@untainted> <int>payload.exp;\n-                } else {\n-                    exp = self.defaultTokenExpTimeInSeconds +  (time:currentTime().time / 1000);\n-                }\n+# Validates the given OAuth2 token.\n+# ```ballerina\n+# oauth2:IntrospectionResponse|oauth2:Error result = oauth2:validateOAuth2Token(token, introspectionServerConfig);\n+# ```\n+#\n+# + token - OAuth2 token that needs to be validated\n+# + config -  OAuth2 introspection server configurations\n+# + return - OAuth2 introspection server response or else a `oauth2:Error` if token validation fails", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff83dc80c4afbcd940b49c0035b3a0dfbeafc642"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA3MjIwNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                // Build the request to be send to the introspection endpoint.\n          \n          \n            \n                // Builds the request to be sent to the introspection endpoint.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22917#discussion_r417072207", "createdAt": "2020-04-29T05:20:06Z", "author": {"login": "praneesha"}, "path": "stdlib/oauth2/src/main/ballerina/src/oauth2/inbound_oauth2_provider.bal", "diffHunk": "@@ -60,108 +52,183 @@ public type InboundOAuth2Provider object {\n #\n # + credential - OAuth2 token to be authenticated\n # + return - `true` if authentication is successful, `false` otherwise, or else an `auth:Error` if an error occurred\n-    public function authenticate(string credential) returns boolean|auth:Error {\n+    public function authenticate(string credential) returns @tainted (boolean|auth:Error) {\n         if (credential == \"\") {\n             return false;\n         }\n \n-        cache:Cache? oauth2Cache = self.inboundOAuth2Cache;\n-        if (oauth2Cache is cache:Cache && oauth2Cache.hasKey(credential)) {\n-            InboundOAuth2CacheEntry? oauth2CacheEntry = authenticateFromCache(oauth2Cache, credential);\n-            if (oauth2CacheEntry is InboundOAuth2CacheEntry) {\n+        IntrospectionResponse|Error validationResult = validateOAuth2Token(credential, self.introspectionServerConfig);\n+        if (validationResult is IntrospectionResponse) {\n+            if (validationResult.active) {\n                 auth:setAuthenticationContext(\"oauth2\", credential);\n-                auth:setPrincipal(oauth2CacheEntry.username, oauth2CacheEntry.username,\n-                                  getScopes(oauth2CacheEntry.scopes));\n-                return true;\n+                auth:setPrincipal(validationResult?.username, validationResult?.username,\n+                                  getScopes(validationResult?.scopes));\n             }\n+            return validationResult.active;\n+        } else {\n+            return prepareAuthError(\"OAuth2 validation failed.\", validationResult);\n         }\n+    }\n+};\n \n-        // Build the request to be send to the introspection endpoint.\n-        // Refer: https://tools.ietf.org/html/rfc7662#section-2.1\n-        http:Request req = new;\n-        string textPayload = \"token=\" + credential;\n-        string? tokenTypeHint = self.tokenTypeHint;\n-        if (tokenTypeHint is string) {\n-            textPayload += \"&token_type_hint=\" + tokenTypeHint;\n-        }\n-        req.setTextPayload(textPayload, mime:APPLICATION_FORM_URLENCODED);\n-        http:Response|http:ClientError response = self.introspectionClient->post(\"\", req);\n-        if (response is http:Response) {\n-            json|error result = response.getJsonPayload();\n-            if (result is error) {\n-                return <@untainted> prepareAuthError(result.reason(), result);\n-            }\n-\n-            json payload = <json>result;\n-            boolean active = <boolean>payload.active;\n-            if (active) {\n-                string? username = ();\n-                string? scopes = ();\n-                int exp;\n-\n-                if (payload.username is string) {\n-                    username = <@untainted> <string>payload.username;\n-                }\n-                if (payload.scope is string) {\n-                    scopes = <@untainted> <string>payload.scope;\n-                }\n-                if (payload.exp is int) {\n-                    exp = <@untainted> <int>payload.exp;\n-                } else {\n-                    exp = self.defaultTokenExpTimeInSeconds +  (time:currentTime().time / 1000);\n-                }\n+# Validates the given OAuth2 token.\n+# ```ballerina\n+# oauth2:IntrospectionResponse|oauth2:Error result = oauth2:validateOAuth2Token(token, introspectionServerConfig);\n+# ```\n+#\n+# + token - OAuth2 token that needs to be validated\n+# + config -  OAuth2 introspection server configurations\n+# + return - OAuth2 introspection server response or else a `oauth2:Error` if token validation fails\n+public function validateOAuth2Token(string token, IntrospectionServerConfig config)\n+                                    returns @tainted (IntrospectionResponse|Error) {\n+    cache:Cache? oauth2Cache = config?.oauth2Cache;\n+    if (oauth2Cache is cache:Cache && oauth2Cache.hasKey(token)) {\n+        IntrospectionResponse? response = validateFromCache(oauth2Cache, token);\n+        if (response is IntrospectionResponse) {\n+            return response;\n+        }\n+    }\n \n-                if (oauth2Cache is cache:Cache) {\n-                    addToAuthenticationCache(oauth2Cache, credential, username, scopes, exp);\n-                }\n-                auth:setAuthenticationContext(\"oauth2\", credential);\n-                auth:setPrincipal(username, username, getScopes(scopes ?: \"\"));\n-                return true;\n+    // Build the request to be send to the introspection endpoint.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff83dc80c4afbcd940b49c0035b3a0dfbeafc642"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA3MjUxMA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                // Refer: https://tools.ietf.org/html/rfc7662#section-2.1\n          \n          \n            \n                // For more information, see the [OAuth 2.0 Token Introspection RFC](https://tools.ietf.org/html/rfc7662#section-2.1)", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22917#discussion_r417072510", "createdAt": "2020-04-29T05:21:10Z", "author": {"login": "praneesha"}, "path": "stdlib/oauth2/src/main/ballerina/src/oauth2/inbound_oauth2_provider.bal", "diffHunk": "@@ -60,108 +52,183 @@ public type InboundOAuth2Provider object {\n #\n # + credential - OAuth2 token to be authenticated\n # + return - `true` if authentication is successful, `false` otherwise, or else an `auth:Error` if an error occurred\n-    public function authenticate(string credential) returns boolean|auth:Error {\n+    public function authenticate(string credential) returns @tainted (boolean|auth:Error) {\n         if (credential == \"\") {\n             return false;\n         }\n \n-        cache:Cache? oauth2Cache = self.inboundOAuth2Cache;\n-        if (oauth2Cache is cache:Cache && oauth2Cache.hasKey(credential)) {\n-            InboundOAuth2CacheEntry? oauth2CacheEntry = authenticateFromCache(oauth2Cache, credential);\n-            if (oauth2CacheEntry is InboundOAuth2CacheEntry) {\n+        IntrospectionResponse|Error validationResult = validateOAuth2Token(credential, self.introspectionServerConfig);\n+        if (validationResult is IntrospectionResponse) {\n+            if (validationResult.active) {\n                 auth:setAuthenticationContext(\"oauth2\", credential);\n-                auth:setPrincipal(oauth2CacheEntry.username, oauth2CacheEntry.username,\n-                                  getScopes(oauth2CacheEntry.scopes));\n-                return true;\n+                auth:setPrincipal(validationResult?.username, validationResult?.username,\n+                                  getScopes(validationResult?.scopes));\n             }\n+            return validationResult.active;\n+        } else {\n+            return prepareAuthError(\"OAuth2 validation failed.\", validationResult);\n         }\n+    }\n+};\n \n-        // Build the request to be send to the introspection endpoint.\n-        // Refer: https://tools.ietf.org/html/rfc7662#section-2.1\n-        http:Request req = new;\n-        string textPayload = \"token=\" + credential;\n-        string? tokenTypeHint = self.tokenTypeHint;\n-        if (tokenTypeHint is string) {\n-            textPayload += \"&token_type_hint=\" + tokenTypeHint;\n-        }\n-        req.setTextPayload(textPayload, mime:APPLICATION_FORM_URLENCODED);\n-        http:Response|http:ClientError response = self.introspectionClient->post(\"\", req);\n-        if (response is http:Response) {\n-            json|error result = response.getJsonPayload();\n-            if (result is error) {\n-                return <@untainted> prepareAuthError(result.reason(), result);\n-            }\n-\n-            json payload = <json>result;\n-            boolean active = <boolean>payload.active;\n-            if (active) {\n-                string? username = ();\n-                string? scopes = ();\n-                int exp;\n-\n-                if (payload.username is string) {\n-                    username = <@untainted> <string>payload.username;\n-                }\n-                if (payload.scope is string) {\n-                    scopes = <@untainted> <string>payload.scope;\n-                }\n-                if (payload.exp is int) {\n-                    exp = <@untainted> <int>payload.exp;\n-                } else {\n-                    exp = self.defaultTokenExpTimeInSeconds +  (time:currentTime().time / 1000);\n-                }\n+# Validates the given OAuth2 token.\n+# ```ballerina\n+# oauth2:IntrospectionResponse|oauth2:Error result = oauth2:validateOAuth2Token(token, introspectionServerConfig);\n+# ```\n+#\n+# + token - OAuth2 token that needs to be validated\n+# + config -  OAuth2 introspection server configurations\n+# + return - OAuth2 introspection server response or else a `oauth2:Error` if token validation fails\n+public function validateOAuth2Token(string token, IntrospectionServerConfig config)\n+                                    returns @tainted (IntrospectionResponse|Error) {\n+    cache:Cache? oauth2Cache = config?.oauth2Cache;\n+    if (oauth2Cache is cache:Cache && oauth2Cache.hasKey(token)) {\n+        IntrospectionResponse? response = validateFromCache(oauth2Cache, token);\n+        if (response is IntrospectionResponse) {\n+            return response;\n+        }\n+    }\n \n-                if (oauth2Cache is cache:Cache) {\n-                    addToAuthenticationCache(oauth2Cache, credential, username, scopes, exp);\n-                }\n-                auth:setAuthenticationContext(\"oauth2\", credential);\n-                auth:setPrincipal(username, username, getScopes(scopes ?: \"\"));\n-                return true;\n+    // Build the request to be send to the introspection endpoint.\n+    // Refer: https://tools.ietf.org/html/rfc7662#section-2.1", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff83dc80c4afbcd940b49c0035b3a0dfbeafc642"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA3MjcxNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // If the exp parameter is not set by introspection response, use cache default expiry by\n          \n          \n            \n                    // If the `exp` parameter is not set by the introspection response, use the cache default expiry by", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22917#discussion_r417072717", "createdAt": "2020-04-29T05:21:52Z", "author": {"login": "praneesha"}, "path": "stdlib/oauth2/src/main/ballerina/src/oauth2/inbound_oauth2_provider.bal", "diffHunk": "@@ -60,108 +52,183 @@ public type InboundOAuth2Provider object {\n #\n # + credential - OAuth2 token to be authenticated\n # + return - `true` if authentication is successful, `false` otherwise, or else an `auth:Error` if an error occurred\n-    public function authenticate(string credential) returns boolean|auth:Error {\n+    public function authenticate(string credential) returns @tainted (boolean|auth:Error) {\n         if (credential == \"\") {\n             return false;\n         }\n \n-        cache:Cache? oauth2Cache = self.inboundOAuth2Cache;\n-        if (oauth2Cache is cache:Cache && oauth2Cache.hasKey(credential)) {\n-            InboundOAuth2CacheEntry? oauth2CacheEntry = authenticateFromCache(oauth2Cache, credential);\n-            if (oauth2CacheEntry is InboundOAuth2CacheEntry) {\n+        IntrospectionResponse|Error validationResult = validateOAuth2Token(credential, self.introspectionServerConfig);\n+        if (validationResult is IntrospectionResponse) {\n+            if (validationResult.active) {\n                 auth:setAuthenticationContext(\"oauth2\", credential);\n-                auth:setPrincipal(oauth2CacheEntry.username, oauth2CacheEntry.username,\n-                                  getScopes(oauth2CacheEntry.scopes));\n-                return true;\n+                auth:setPrincipal(validationResult?.username, validationResult?.username,\n+                                  getScopes(validationResult?.scopes));\n             }\n+            return validationResult.active;\n+        } else {\n+            return prepareAuthError(\"OAuth2 validation failed.\", validationResult);\n         }\n+    }\n+};\n \n-        // Build the request to be send to the introspection endpoint.\n-        // Refer: https://tools.ietf.org/html/rfc7662#section-2.1\n-        http:Request req = new;\n-        string textPayload = \"token=\" + credential;\n-        string? tokenTypeHint = self.tokenTypeHint;\n-        if (tokenTypeHint is string) {\n-            textPayload += \"&token_type_hint=\" + tokenTypeHint;\n-        }\n-        req.setTextPayload(textPayload, mime:APPLICATION_FORM_URLENCODED);\n-        http:Response|http:ClientError response = self.introspectionClient->post(\"\", req);\n-        if (response is http:Response) {\n-            json|error result = response.getJsonPayload();\n-            if (result is error) {\n-                return <@untainted> prepareAuthError(result.reason(), result);\n-            }\n-\n-            json payload = <json>result;\n-            boolean active = <boolean>payload.active;\n-            if (active) {\n-                string? username = ();\n-                string? scopes = ();\n-                int exp;\n-\n-                if (payload.username is string) {\n-                    username = <@untainted> <string>payload.username;\n-                }\n-                if (payload.scope is string) {\n-                    scopes = <@untainted> <string>payload.scope;\n-                }\n-                if (payload.exp is int) {\n-                    exp = <@untainted> <int>payload.exp;\n-                } else {\n-                    exp = self.defaultTokenExpTimeInSeconds +  (time:currentTime().time / 1000);\n-                }\n+# Validates the given OAuth2 token.\n+# ```ballerina\n+# oauth2:IntrospectionResponse|oauth2:Error result = oauth2:validateOAuth2Token(token, introspectionServerConfig);\n+# ```\n+#\n+# + token - OAuth2 token that needs to be validated\n+# + config -  OAuth2 introspection server configurations\n+# + return - OAuth2 introspection server response or else a `oauth2:Error` if token validation fails\n+public function validateOAuth2Token(string token, IntrospectionServerConfig config)\n+                                    returns @tainted (IntrospectionResponse|Error) {\n+    cache:Cache? oauth2Cache = config?.oauth2Cache;\n+    if (oauth2Cache is cache:Cache && oauth2Cache.hasKey(token)) {\n+        IntrospectionResponse? response = validateFromCache(oauth2Cache, token);\n+        if (response is IntrospectionResponse) {\n+            return response;\n+        }\n+    }\n \n-                if (oauth2Cache is cache:Cache) {\n-                    addToAuthenticationCache(oauth2Cache, credential, username, scopes, exp);\n-                }\n-                auth:setAuthenticationContext(\"oauth2\", credential);\n-                auth:setPrincipal(username, username, getScopes(scopes ?: \"\"));\n-                return true;\n+    // Build the request to be send to the introspection endpoint.\n+    // Refer: https://tools.ietf.org/html/rfc7662#section-2.1\n+    http:Request req = new;\n+    string textPayload = \"token=\" + token;\n+    string? tokenTypeHint = config?.tokenTypeHint;\n+    if (tokenTypeHint is string) {\n+        textPayload += \"&token_type_hint=\" + tokenTypeHint;\n+    }\n+    req.setTextPayload(textPayload, mime:APPLICATION_FORM_URLENCODED);\n+    http:Client introspectionClient = new(config.url, config.clientConfig);\n+    http:Response|http:ClientError response = introspectionClient->post(\"\", req);\n+    if (response is http:Response) {\n+        json|error result = response.getJsonPayload();\n+        if (result is error) {\n+            return <@untainted> prepareError(result.reason(), result);\n+        }\n+        IntrospectionResponse introspectionResponse = prepareIntrospectionResponse(<json>result);\n+        if (introspectionResponse.active) {\n+            if (oauth2Cache is cache:Cache) {\n+                addToCache(oauth2Cache, token, introspectionResponse, config.defaultTokenExpTimeInSeconds);\n             }\n-            return false;\n-        } else {\n-            return prepareAuthError(\"Failed to call the introspection endpoint.\", response);\n         }\n+        return introspectionResponse;\n+    } else {\n+        return prepareError(\"Failed to call the introspection endpoint.\", response);\n     }\n-};\n+}\n \n-function addToAuthenticationCache(cache:Cache oauth2Cache, string token, string? username, string? scopes, int exp) {\n-    InboundOAuth2CacheEntry oauth2CacheEntry = {username: username ?: \"\", scopes: scopes ?: \"\"};\n-    cache:Error? result = oauth2Cache.put(token, oauth2CacheEntry, exp);\n+function prepareIntrospectionResponse(json payload) returns IntrospectionResponse {\n+    boolean active = <boolean>payload.active;\n+    IntrospectionResponse introspectionResponse = {\n+        active: active\n+    };\n+    if (active) {\n+        if (payload.scope is string) {\n+            introspectionResponse.scopes = <@untainted> <string>payload.scope;\n+        }\n+        if (payload.client_id is string) {\n+            introspectionResponse.clientId = <@untainted> <string>payload.client_id;\n+        }\n+        if (payload.username is string) {\n+            introspectionResponse.username = <@untainted> <string>payload.username;\n+        }\n+        if (payload.token_type is string) {\n+            introspectionResponse.tokenType = <@untainted> <string>payload.token_type;\n+        }\n+        if (payload.exp is int) {\n+            introspectionResponse.exp = <@untainted> <int>payload.exp;\n+        }\n+        if (payload.iat is int) {\n+            introspectionResponse.iat = <@untainted> <int>payload.iat;\n+        }\n+        if (payload.nbf is int) {\n+            introspectionResponse.nbf = <@untainted> <int>payload.nbf;\n+        }\n+        if (payload.sub is string) {\n+            introspectionResponse.sub = <@untainted> <string>payload.sub;\n+        }\n+        if (payload.aud is string) {\n+            introspectionResponse.aud = <@untainted> <string>payload.aud;\n+        }\n+        if (payload.iss is string) {\n+            introspectionResponse.iss = <@untainted> <string>payload.iss;\n+        }\n+        if (payload.jti is string) {\n+            introspectionResponse.jti = <@untainted> <string>payload.jti;\n+        }\n+    }\n+    return introspectionResponse;\n+}\n+\n+function addToCache(cache:Cache oauth2Cache, string token, IntrospectionResponse response,\n+                    int defaultTokenExpTimeInSeconds) {\n+    cache:Error? result;\n+    if (response?.exp is int) {\n+        result = oauth2Cache.put(token, response);\n+    } else {\n+        // If the exp parameter is not set by introspection response, use cache default expiry by", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff83dc80c4afbcd940b49c0035b3a0dfbeafc642"}, "originalPosition": 203}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA3Mjc5Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // defaultTokenExpTimeInSeconds. Then the cached value will be removed when retrieving.\n          \n          \n            \n                    // the `defaultTokenExpTimeInSeconds`. Then, the cached value will be removed when retrieving.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22917#discussion_r417072793", "createdAt": "2020-04-29T05:22:05Z", "author": {"login": "praneesha"}, "path": "stdlib/oauth2/src/main/ballerina/src/oauth2/inbound_oauth2_provider.bal", "diffHunk": "@@ -60,108 +52,183 @@ public type InboundOAuth2Provider object {\n #\n # + credential - OAuth2 token to be authenticated\n # + return - `true` if authentication is successful, `false` otherwise, or else an `auth:Error` if an error occurred\n-    public function authenticate(string credential) returns boolean|auth:Error {\n+    public function authenticate(string credential) returns @tainted (boolean|auth:Error) {\n         if (credential == \"\") {\n             return false;\n         }\n \n-        cache:Cache? oauth2Cache = self.inboundOAuth2Cache;\n-        if (oauth2Cache is cache:Cache && oauth2Cache.hasKey(credential)) {\n-            InboundOAuth2CacheEntry? oauth2CacheEntry = authenticateFromCache(oauth2Cache, credential);\n-            if (oauth2CacheEntry is InboundOAuth2CacheEntry) {\n+        IntrospectionResponse|Error validationResult = validateOAuth2Token(credential, self.introspectionServerConfig);\n+        if (validationResult is IntrospectionResponse) {\n+            if (validationResult.active) {\n                 auth:setAuthenticationContext(\"oauth2\", credential);\n-                auth:setPrincipal(oauth2CacheEntry.username, oauth2CacheEntry.username,\n-                                  getScopes(oauth2CacheEntry.scopes));\n-                return true;\n+                auth:setPrincipal(validationResult?.username, validationResult?.username,\n+                                  getScopes(validationResult?.scopes));\n             }\n+            return validationResult.active;\n+        } else {\n+            return prepareAuthError(\"OAuth2 validation failed.\", validationResult);\n         }\n+    }\n+};\n \n-        // Build the request to be send to the introspection endpoint.\n-        // Refer: https://tools.ietf.org/html/rfc7662#section-2.1\n-        http:Request req = new;\n-        string textPayload = \"token=\" + credential;\n-        string? tokenTypeHint = self.tokenTypeHint;\n-        if (tokenTypeHint is string) {\n-            textPayload += \"&token_type_hint=\" + tokenTypeHint;\n-        }\n-        req.setTextPayload(textPayload, mime:APPLICATION_FORM_URLENCODED);\n-        http:Response|http:ClientError response = self.introspectionClient->post(\"\", req);\n-        if (response is http:Response) {\n-            json|error result = response.getJsonPayload();\n-            if (result is error) {\n-                return <@untainted> prepareAuthError(result.reason(), result);\n-            }\n-\n-            json payload = <json>result;\n-            boolean active = <boolean>payload.active;\n-            if (active) {\n-                string? username = ();\n-                string? scopes = ();\n-                int exp;\n-\n-                if (payload.username is string) {\n-                    username = <@untainted> <string>payload.username;\n-                }\n-                if (payload.scope is string) {\n-                    scopes = <@untainted> <string>payload.scope;\n-                }\n-                if (payload.exp is int) {\n-                    exp = <@untainted> <int>payload.exp;\n-                } else {\n-                    exp = self.defaultTokenExpTimeInSeconds +  (time:currentTime().time / 1000);\n-                }\n+# Validates the given OAuth2 token.\n+# ```ballerina\n+# oauth2:IntrospectionResponse|oauth2:Error result = oauth2:validateOAuth2Token(token, introspectionServerConfig);\n+# ```\n+#\n+# + token - OAuth2 token that needs to be validated\n+# + config -  OAuth2 introspection server configurations\n+# + return - OAuth2 introspection server response or else a `oauth2:Error` if token validation fails\n+public function validateOAuth2Token(string token, IntrospectionServerConfig config)\n+                                    returns @tainted (IntrospectionResponse|Error) {\n+    cache:Cache? oauth2Cache = config?.oauth2Cache;\n+    if (oauth2Cache is cache:Cache && oauth2Cache.hasKey(token)) {\n+        IntrospectionResponse? response = validateFromCache(oauth2Cache, token);\n+        if (response is IntrospectionResponse) {\n+            return response;\n+        }\n+    }\n \n-                if (oauth2Cache is cache:Cache) {\n-                    addToAuthenticationCache(oauth2Cache, credential, username, scopes, exp);\n-                }\n-                auth:setAuthenticationContext(\"oauth2\", credential);\n-                auth:setPrincipal(username, username, getScopes(scopes ?: \"\"));\n-                return true;\n+    // Build the request to be send to the introspection endpoint.\n+    // Refer: https://tools.ietf.org/html/rfc7662#section-2.1\n+    http:Request req = new;\n+    string textPayload = \"token=\" + token;\n+    string? tokenTypeHint = config?.tokenTypeHint;\n+    if (tokenTypeHint is string) {\n+        textPayload += \"&token_type_hint=\" + tokenTypeHint;\n+    }\n+    req.setTextPayload(textPayload, mime:APPLICATION_FORM_URLENCODED);\n+    http:Client introspectionClient = new(config.url, config.clientConfig);\n+    http:Response|http:ClientError response = introspectionClient->post(\"\", req);\n+    if (response is http:Response) {\n+        json|error result = response.getJsonPayload();\n+        if (result is error) {\n+            return <@untainted> prepareError(result.reason(), result);\n+        }\n+        IntrospectionResponse introspectionResponse = prepareIntrospectionResponse(<json>result);\n+        if (introspectionResponse.active) {\n+            if (oauth2Cache is cache:Cache) {\n+                addToCache(oauth2Cache, token, introspectionResponse, config.defaultTokenExpTimeInSeconds);\n             }\n-            return false;\n-        } else {\n-            return prepareAuthError(\"Failed to call the introspection endpoint.\", response);\n         }\n+        return introspectionResponse;\n+    } else {\n+        return prepareError(\"Failed to call the introspection endpoint.\", response);\n     }\n-};\n+}\n \n-function addToAuthenticationCache(cache:Cache oauth2Cache, string token, string? username, string? scopes, int exp) {\n-    InboundOAuth2CacheEntry oauth2CacheEntry = {username: username ?: \"\", scopes: scopes ?: \"\"};\n-    cache:Error? result = oauth2Cache.put(token, oauth2CacheEntry, exp);\n+function prepareIntrospectionResponse(json payload) returns IntrospectionResponse {\n+    boolean active = <boolean>payload.active;\n+    IntrospectionResponse introspectionResponse = {\n+        active: active\n+    };\n+    if (active) {\n+        if (payload.scope is string) {\n+            introspectionResponse.scopes = <@untainted> <string>payload.scope;\n+        }\n+        if (payload.client_id is string) {\n+            introspectionResponse.clientId = <@untainted> <string>payload.client_id;\n+        }\n+        if (payload.username is string) {\n+            introspectionResponse.username = <@untainted> <string>payload.username;\n+        }\n+        if (payload.token_type is string) {\n+            introspectionResponse.tokenType = <@untainted> <string>payload.token_type;\n+        }\n+        if (payload.exp is int) {\n+            introspectionResponse.exp = <@untainted> <int>payload.exp;\n+        }\n+        if (payload.iat is int) {\n+            introspectionResponse.iat = <@untainted> <int>payload.iat;\n+        }\n+        if (payload.nbf is int) {\n+            introspectionResponse.nbf = <@untainted> <int>payload.nbf;\n+        }\n+        if (payload.sub is string) {\n+            introspectionResponse.sub = <@untainted> <string>payload.sub;\n+        }\n+        if (payload.aud is string) {\n+            introspectionResponse.aud = <@untainted> <string>payload.aud;\n+        }\n+        if (payload.iss is string) {\n+            introspectionResponse.iss = <@untainted> <string>payload.iss;\n+        }\n+        if (payload.jti is string) {\n+            introspectionResponse.jti = <@untainted> <string>payload.jti;\n+        }\n+    }\n+    return introspectionResponse;\n+}\n+\n+function addToCache(cache:Cache oauth2Cache, string token, IntrospectionResponse response,\n+                    int defaultTokenExpTimeInSeconds) {\n+    cache:Error? result;\n+    if (response?.exp is int) {\n+        result = oauth2Cache.put(token, response);\n+    } else {\n+        // If the exp parameter is not set by introspection response, use cache default expiry by\n+        // defaultTokenExpTimeInSeconds. Then the cached value will be removed when retrieving.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff83dc80c4afbcd940b49c0035b3a0dfbeafc642"}, "originalPosition": 204}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA3Mjk2Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // If the cached value is expired (defaultTokenExpTimeInSeconds is passed), it will return ().\n          \n          \n            \n                    // If the cached value is expired (defaultTokenExpTimeInSeconds is passed), it will return `()`.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22917#discussion_r417072963", "createdAt": "2020-04-29T05:22:21Z", "author": {"login": "praneesha"}, "path": "stdlib/oauth2/src/main/ballerina/src/oauth2/inbound_oauth2_provider.bal", "diffHunk": "@@ -60,108 +52,183 @@ public type InboundOAuth2Provider object {\n #\n # + credential - OAuth2 token to be authenticated\n # + return - `true` if authentication is successful, `false` otherwise, or else an `auth:Error` if an error occurred\n-    public function authenticate(string credential) returns boolean|auth:Error {\n+    public function authenticate(string credential) returns @tainted (boolean|auth:Error) {\n         if (credential == \"\") {\n             return false;\n         }\n \n-        cache:Cache? oauth2Cache = self.inboundOAuth2Cache;\n-        if (oauth2Cache is cache:Cache && oauth2Cache.hasKey(credential)) {\n-            InboundOAuth2CacheEntry? oauth2CacheEntry = authenticateFromCache(oauth2Cache, credential);\n-            if (oauth2CacheEntry is InboundOAuth2CacheEntry) {\n+        IntrospectionResponse|Error validationResult = validateOAuth2Token(credential, self.introspectionServerConfig);\n+        if (validationResult is IntrospectionResponse) {\n+            if (validationResult.active) {\n                 auth:setAuthenticationContext(\"oauth2\", credential);\n-                auth:setPrincipal(oauth2CacheEntry.username, oauth2CacheEntry.username,\n-                                  getScopes(oauth2CacheEntry.scopes));\n-                return true;\n+                auth:setPrincipal(validationResult?.username, validationResult?.username,\n+                                  getScopes(validationResult?.scopes));\n             }\n+            return validationResult.active;\n+        } else {\n+            return prepareAuthError(\"OAuth2 validation failed.\", validationResult);\n         }\n+    }\n+};\n \n-        // Build the request to be send to the introspection endpoint.\n-        // Refer: https://tools.ietf.org/html/rfc7662#section-2.1\n-        http:Request req = new;\n-        string textPayload = \"token=\" + credential;\n-        string? tokenTypeHint = self.tokenTypeHint;\n-        if (tokenTypeHint is string) {\n-            textPayload += \"&token_type_hint=\" + tokenTypeHint;\n-        }\n-        req.setTextPayload(textPayload, mime:APPLICATION_FORM_URLENCODED);\n-        http:Response|http:ClientError response = self.introspectionClient->post(\"\", req);\n-        if (response is http:Response) {\n-            json|error result = response.getJsonPayload();\n-            if (result is error) {\n-                return <@untainted> prepareAuthError(result.reason(), result);\n-            }\n-\n-            json payload = <json>result;\n-            boolean active = <boolean>payload.active;\n-            if (active) {\n-                string? username = ();\n-                string? scopes = ();\n-                int exp;\n-\n-                if (payload.username is string) {\n-                    username = <@untainted> <string>payload.username;\n-                }\n-                if (payload.scope is string) {\n-                    scopes = <@untainted> <string>payload.scope;\n-                }\n-                if (payload.exp is int) {\n-                    exp = <@untainted> <int>payload.exp;\n-                } else {\n-                    exp = self.defaultTokenExpTimeInSeconds +  (time:currentTime().time / 1000);\n-                }\n+# Validates the given OAuth2 token.\n+# ```ballerina\n+# oauth2:IntrospectionResponse|oauth2:Error result = oauth2:validateOAuth2Token(token, introspectionServerConfig);\n+# ```\n+#\n+# + token - OAuth2 token that needs to be validated\n+# + config -  OAuth2 introspection server configurations\n+# + return - OAuth2 introspection server response or else a `oauth2:Error` if token validation fails\n+public function validateOAuth2Token(string token, IntrospectionServerConfig config)\n+                                    returns @tainted (IntrospectionResponse|Error) {\n+    cache:Cache? oauth2Cache = config?.oauth2Cache;\n+    if (oauth2Cache is cache:Cache && oauth2Cache.hasKey(token)) {\n+        IntrospectionResponse? response = validateFromCache(oauth2Cache, token);\n+        if (response is IntrospectionResponse) {\n+            return response;\n+        }\n+    }\n \n-                if (oauth2Cache is cache:Cache) {\n-                    addToAuthenticationCache(oauth2Cache, credential, username, scopes, exp);\n-                }\n-                auth:setAuthenticationContext(\"oauth2\", credential);\n-                auth:setPrincipal(username, username, getScopes(scopes ?: \"\"));\n-                return true;\n+    // Build the request to be send to the introspection endpoint.\n+    // Refer: https://tools.ietf.org/html/rfc7662#section-2.1\n+    http:Request req = new;\n+    string textPayload = \"token=\" + token;\n+    string? tokenTypeHint = config?.tokenTypeHint;\n+    if (tokenTypeHint is string) {\n+        textPayload += \"&token_type_hint=\" + tokenTypeHint;\n+    }\n+    req.setTextPayload(textPayload, mime:APPLICATION_FORM_URLENCODED);\n+    http:Client introspectionClient = new(config.url, config.clientConfig);\n+    http:Response|http:ClientError response = introspectionClient->post(\"\", req);\n+    if (response is http:Response) {\n+        json|error result = response.getJsonPayload();\n+        if (result is error) {\n+            return <@untainted> prepareError(result.reason(), result);\n+        }\n+        IntrospectionResponse introspectionResponse = prepareIntrospectionResponse(<json>result);\n+        if (introspectionResponse.active) {\n+            if (oauth2Cache is cache:Cache) {\n+                addToCache(oauth2Cache, token, introspectionResponse, config.defaultTokenExpTimeInSeconds);\n             }\n-            return false;\n-        } else {\n-            return prepareAuthError(\"Failed to call the introspection endpoint.\", response);\n         }\n+        return introspectionResponse;\n+    } else {\n+        return prepareError(\"Failed to call the introspection endpoint.\", response);\n     }\n-};\n+}\n \n-function addToAuthenticationCache(cache:Cache oauth2Cache, string token, string? username, string? scopes, int exp) {\n-    InboundOAuth2CacheEntry oauth2CacheEntry = {username: username ?: \"\", scopes: scopes ?: \"\"};\n-    cache:Error? result = oauth2Cache.put(token, oauth2CacheEntry, exp);\n+function prepareIntrospectionResponse(json payload) returns IntrospectionResponse {\n+    boolean active = <boolean>payload.active;\n+    IntrospectionResponse introspectionResponse = {\n+        active: active\n+    };\n+    if (active) {\n+        if (payload.scope is string) {\n+            introspectionResponse.scopes = <@untainted> <string>payload.scope;\n+        }\n+        if (payload.client_id is string) {\n+            introspectionResponse.clientId = <@untainted> <string>payload.client_id;\n+        }\n+        if (payload.username is string) {\n+            introspectionResponse.username = <@untainted> <string>payload.username;\n+        }\n+        if (payload.token_type is string) {\n+            introspectionResponse.tokenType = <@untainted> <string>payload.token_type;\n+        }\n+        if (payload.exp is int) {\n+            introspectionResponse.exp = <@untainted> <int>payload.exp;\n+        }\n+        if (payload.iat is int) {\n+            introspectionResponse.iat = <@untainted> <int>payload.iat;\n+        }\n+        if (payload.nbf is int) {\n+            introspectionResponse.nbf = <@untainted> <int>payload.nbf;\n+        }\n+        if (payload.sub is string) {\n+            introspectionResponse.sub = <@untainted> <string>payload.sub;\n+        }\n+        if (payload.aud is string) {\n+            introspectionResponse.aud = <@untainted> <string>payload.aud;\n+        }\n+        if (payload.iss is string) {\n+            introspectionResponse.iss = <@untainted> <string>payload.iss;\n+        }\n+        if (payload.jti is string) {\n+            introspectionResponse.jti = <@untainted> <string>payload.jti;\n+        }\n+    }\n+    return introspectionResponse;\n+}\n+\n+function addToCache(cache:Cache oauth2Cache, string token, IntrospectionResponse response,\n+                    int defaultTokenExpTimeInSeconds) {\n+    cache:Error? result;\n+    if (response?.exp is int) {\n+        result = oauth2Cache.put(token, response);\n+    } else {\n+        // If the exp parameter is not set by introspection response, use cache default expiry by\n+        // defaultTokenExpTimeInSeconds. Then the cached value will be removed when retrieving.\n+        result = oauth2Cache.put(token, response, defaultTokenExpTimeInSeconds);\n+    }\n     if (result is cache:Error) {\n         log:printDebug(function() returns string {\n-            return \"Failed to add JWT to the cache\";\n+            return \"Failed to add OAuth2 token to the cache. Introspection response: \" + response.toString();\n         });\n         return;\n     }\n-    if (username is string) {\n-        string user = username;\n+    log:printDebug(function() returns string {\n+        return \"OAuth2 token added to the cache. Introspection response: \" + response.toString();\n+    });\n+}\n+\n+function validateFromCache(cache:Cache oauth2Cache, string token) returns IntrospectionResponse? {\n+    any|cache:Error cachedValue = oauth2Cache.get(token);\n+    if (cachedValue is ()) {\n+        // If the cached value is expired (defaultTokenExpTimeInSeconds is passed), it will return ().", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff83dc80c4afbcd940b49c0035b3a0dfbeafc642"}, "originalPosition": 224}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA3MzAwOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        return \"Failed to validate token from from the cache, since token is expired.\";\n          \n          \n            \n                        return \"Failed to validate the token from the cache since the token is expired.\";", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22917#discussion_r417073008", "createdAt": "2020-04-29T05:22:35Z", "author": {"login": "praneesha"}, "path": "stdlib/oauth2/src/main/ballerina/src/oauth2/inbound_oauth2_provider.bal", "diffHunk": "@@ -60,108 +52,183 @@ public type InboundOAuth2Provider object {\n #\n # + credential - OAuth2 token to be authenticated\n # + return - `true` if authentication is successful, `false` otherwise, or else an `auth:Error` if an error occurred\n-    public function authenticate(string credential) returns boolean|auth:Error {\n+    public function authenticate(string credential) returns @tainted (boolean|auth:Error) {\n         if (credential == \"\") {\n             return false;\n         }\n \n-        cache:Cache? oauth2Cache = self.inboundOAuth2Cache;\n-        if (oauth2Cache is cache:Cache && oauth2Cache.hasKey(credential)) {\n-            InboundOAuth2CacheEntry? oauth2CacheEntry = authenticateFromCache(oauth2Cache, credential);\n-            if (oauth2CacheEntry is InboundOAuth2CacheEntry) {\n+        IntrospectionResponse|Error validationResult = validateOAuth2Token(credential, self.introspectionServerConfig);\n+        if (validationResult is IntrospectionResponse) {\n+            if (validationResult.active) {\n                 auth:setAuthenticationContext(\"oauth2\", credential);\n-                auth:setPrincipal(oauth2CacheEntry.username, oauth2CacheEntry.username,\n-                                  getScopes(oauth2CacheEntry.scopes));\n-                return true;\n+                auth:setPrincipal(validationResult?.username, validationResult?.username,\n+                                  getScopes(validationResult?.scopes));\n             }\n+            return validationResult.active;\n+        } else {\n+            return prepareAuthError(\"OAuth2 validation failed.\", validationResult);\n         }\n+    }\n+};\n \n-        // Build the request to be send to the introspection endpoint.\n-        // Refer: https://tools.ietf.org/html/rfc7662#section-2.1\n-        http:Request req = new;\n-        string textPayload = \"token=\" + credential;\n-        string? tokenTypeHint = self.tokenTypeHint;\n-        if (tokenTypeHint is string) {\n-            textPayload += \"&token_type_hint=\" + tokenTypeHint;\n-        }\n-        req.setTextPayload(textPayload, mime:APPLICATION_FORM_URLENCODED);\n-        http:Response|http:ClientError response = self.introspectionClient->post(\"\", req);\n-        if (response is http:Response) {\n-            json|error result = response.getJsonPayload();\n-            if (result is error) {\n-                return <@untainted> prepareAuthError(result.reason(), result);\n-            }\n-\n-            json payload = <json>result;\n-            boolean active = <boolean>payload.active;\n-            if (active) {\n-                string? username = ();\n-                string? scopes = ();\n-                int exp;\n-\n-                if (payload.username is string) {\n-                    username = <@untainted> <string>payload.username;\n-                }\n-                if (payload.scope is string) {\n-                    scopes = <@untainted> <string>payload.scope;\n-                }\n-                if (payload.exp is int) {\n-                    exp = <@untainted> <int>payload.exp;\n-                } else {\n-                    exp = self.defaultTokenExpTimeInSeconds +  (time:currentTime().time / 1000);\n-                }\n+# Validates the given OAuth2 token.\n+# ```ballerina\n+# oauth2:IntrospectionResponse|oauth2:Error result = oauth2:validateOAuth2Token(token, introspectionServerConfig);\n+# ```\n+#\n+# + token - OAuth2 token that needs to be validated\n+# + config -  OAuth2 introspection server configurations\n+# + return - OAuth2 introspection server response or else a `oauth2:Error` if token validation fails\n+public function validateOAuth2Token(string token, IntrospectionServerConfig config)\n+                                    returns @tainted (IntrospectionResponse|Error) {\n+    cache:Cache? oauth2Cache = config?.oauth2Cache;\n+    if (oauth2Cache is cache:Cache && oauth2Cache.hasKey(token)) {\n+        IntrospectionResponse? response = validateFromCache(oauth2Cache, token);\n+        if (response is IntrospectionResponse) {\n+            return response;\n+        }\n+    }\n \n-                if (oauth2Cache is cache:Cache) {\n-                    addToAuthenticationCache(oauth2Cache, credential, username, scopes, exp);\n-                }\n-                auth:setAuthenticationContext(\"oauth2\", credential);\n-                auth:setPrincipal(username, username, getScopes(scopes ?: \"\"));\n-                return true;\n+    // Build the request to be send to the introspection endpoint.\n+    // Refer: https://tools.ietf.org/html/rfc7662#section-2.1\n+    http:Request req = new;\n+    string textPayload = \"token=\" + token;\n+    string? tokenTypeHint = config?.tokenTypeHint;\n+    if (tokenTypeHint is string) {\n+        textPayload += \"&token_type_hint=\" + tokenTypeHint;\n+    }\n+    req.setTextPayload(textPayload, mime:APPLICATION_FORM_URLENCODED);\n+    http:Client introspectionClient = new(config.url, config.clientConfig);\n+    http:Response|http:ClientError response = introspectionClient->post(\"\", req);\n+    if (response is http:Response) {\n+        json|error result = response.getJsonPayload();\n+        if (result is error) {\n+            return <@untainted> prepareError(result.reason(), result);\n+        }\n+        IntrospectionResponse introspectionResponse = prepareIntrospectionResponse(<json>result);\n+        if (introspectionResponse.active) {\n+            if (oauth2Cache is cache:Cache) {\n+                addToCache(oauth2Cache, token, introspectionResponse, config.defaultTokenExpTimeInSeconds);\n             }\n-            return false;\n-        } else {\n-            return prepareAuthError(\"Failed to call the introspection endpoint.\", response);\n         }\n+        return introspectionResponse;\n+    } else {\n+        return prepareError(\"Failed to call the introspection endpoint.\", response);\n     }\n-};\n+}\n \n-function addToAuthenticationCache(cache:Cache oauth2Cache, string token, string? username, string? scopes, int exp) {\n-    InboundOAuth2CacheEntry oauth2CacheEntry = {username: username ?: \"\", scopes: scopes ?: \"\"};\n-    cache:Error? result = oauth2Cache.put(token, oauth2CacheEntry, exp);\n+function prepareIntrospectionResponse(json payload) returns IntrospectionResponse {\n+    boolean active = <boolean>payload.active;\n+    IntrospectionResponse introspectionResponse = {\n+        active: active\n+    };\n+    if (active) {\n+        if (payload.scope is string) {\n+            introspectionResponse.scopes = <@untainted> <string>payload.scope;\n+        }\n+        if (payload.client_id is string) {\n+            introspectionResponse.clientId = <@untainted> <string>payload.client_id;\n+        }\n+        if (payload.username is string) {\n+            introspectionResponse.username = <@untainted> <string>payload.username;\n+        }\n+        if (payload.token_type is string) {\n+            introspectionResponse.tokenType = <@untainted> <string>payload.token_type;\n+        }\n+        if (payload.exp is int) {\n+            introspectionResponse.exp = <@untainted> <int>payload.exp;\n+        }\n+        if (payload.iat is int) {\n+            introspectionResponse.iat = <@untainted> <int>payload.iat;\n+        }\n+        if (payload.nbf is int) {\n+            introspectionResponse.nbf = <@untainted> <int>payload.nbf;\n+        }\n+        if (payload.sub is string) {\n+            introspectionResponse.sub = <@untainted> <string>payload.sub;\n+        }\n+        if (payload.aud is string) {\n+            introspectionResponse.aud = <@untainted> <string>payload.aud;\n+        }\n+        if (payload.iss is string) {\n+            introspectionResponse.iss = <@untainted> <string>payload.iss;\n+        }\n+        if (payload.jti is string) {\n+            introspectionResponse.jti = <@untainted> <string>payload.jti;\n+        }\n+    }\n+    return introspectionResponse;\n+}\n+\n+function addToCache(cache:Cache oauth2Cache, string token, IntrospectionResponse response,\n+                    int defaultTokenExpTimeInSeconds) {\n+    cache:Error? result;\n+    if (response?.exp is int) {\n+        result = oauth2Cache.put(token, response);\n+    } else {\n+        // If the exp parameter is not set by introspection response, use cache default expiry by\n+        // defaultTokenExpTimeInSeconds. Then the cached value will be removed when retrieving.\n+        result = oauth2Cache.put(token, response, defaultTokenExpTimeInSeconds);\n+    }\n     if (result is cache:Error) {\n         log:printDebug(function() returns string {\n-            return \"Failed to add JWT to the cache\";\n+            return \"Failed to add OAuth2 token to the cache. Introspection response: \" + response.toString();\n         });\n         return;\n     }\n-    if (username is string) {\n-        string user = username;\n+    log:printDebug(function() returns string {\n+        return \"OAuth2 token added to the cache. Introspection response: \" + response.toString();\n+    });\n+}\n+\n+function validateFromCache(cache:Cache oauth2Cache, string token) returns IntrospectionResponse? {\n+    any|cache:Error cachedValue = oauth2Cache.get(token);\n+    if (cachedValue is ()) {\n+        // If the cached value is expired (defaultTokenExpTimeInSeconds is passed), it will return ().\n         log:printDebug(function() returns string {\n-            return \"Add authenticated user: \" + user + \" to the cache.\";\n+            return \"Failed to validate token from from the cache, since token is expired.\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff83dc80c4afbcd940b49c0035b3a0dfbeafc642"}, "originalPosition": 227}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA3MzA2Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        return \"Failed to validate token from from the cache. Cache error: \" + cachedValue.toString();\n          \n          \n            \n                        return \"Failed to validate the token from the cache. Cache error: \" + cachedValue.toString();", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22917#discussion_r417073067", "createdAt": "2020-04-29T05:22:48Z", "author": {"login": "praneesha"}, "path": "stdlib/oauth2/src/main/ballerina/src/oauth2/inbound_oauth2_provider.bal", "diffHunk": "@@ -60,108 +52,183 @@ public type InboundOAuth2Provider object {\n #\n # + credential - OAuth2 token to be authenticated\n # + return - `true` if authentication is successful, `false` otherwise, or else an `auth:Error` if an error occurred\n-    public function authenticate(string credential) returns boolean|auth:Error {\n+    public function authenticate(string credential) returns @tainted (boolean|auth:Error) {\n         if (credential == \"\") {\n             return false;\n         }\n \n-        cache:Cache? oauth2Cache = self.inboundOAuth2Cache;\n-        if (oauth2Cache is cache:Cache && oauth2Cache.hasKey(credential)) {\n-            InboundOAuth2CacheEntry? oauth2CacheEntry = authenticateFromCache(oauth2Cache, credential);\n-            if (oauth2CacheEntry is InboundOAuth2CacheEntry) {\n+        IntrospectionResponse|Error validationResult = validateOAuth2Token(credential, self.introspectionServerConfig);\n+        if (validationResult is IntrospectionResponse) {\n+            if (validationResult.active) {\n                 auth:setAuthenticationContext(\"oauth2\", credential);\n-                auth:setPrincipal(oauth2CacheEntry.username, oauth2CacheEntry.username,\n-                                  getScopes(oauth2CacheEntry.scopes));\n-                return true;\n+                auth:setPrincipal(validationResult?.username, validationResult?.username,\n+                                  getScopes(validationResult?.scopes));\n             }\n+            return validationResult.active;\n+        } else {\n+            return prepareAuthError(\"OAuth2 validation failed.\", validationResult);\n         }\n+    }\n+};\n \n-        // Build the request to be send to the introspection endpoint.\n-        // Refer: https://tools.ietf.org/html/rfc7662#section-2.1\n-        http:Request req = new;\n-        string textPayload = \"token=\" + credential;\n-        string? tokenTypeHint = self.tokenTypeHint;\n-        if (tokenTypeHint is string) {\n-            textPayload += \"&token_type_hint=\" + tokenTypeHint;\n-        }\n-        req.setTextPayload(textPayload, mime:APPLICATION_FORM_URLENCODED);\n-        http:Response|http:ClientError response = self.introspectionClient->post(\"\", req);\n-        if (response is http:Response) {\n-            json|error result = response.getJsonPayload();\n-            if (result is error) {\n-                return <@untainted> prepareAuthError(result.reason(), result);\n-            }\n-\n-            json payload = <json>result;\n-            boolean active = <boolean>payload.active;\n-            if (active) {\n-                string? username = ();\n-                string? scopes = ();\n-                int exp;\n-\n-                if (payload.username is string) {\n-                    username = <@untainted> <string>payload.username;\n-                }\n-                if (payload.scope is string) {\n-                    scopes = <@untainted> <string>payload.scope;\n-                }\n-                if (payload.exp is int) {\n-                    exp = <@untainted> <int>payload.exp;\n-                } else {\n-                    exp = self.defaultTokenExpTimeInSeconds +  (time:currentTime().time / 1000);\n-                }\n+# Validates the given OAuth2 token.\n+# ```ballerina\n+# oauth2:IntrospectionResponse|oauth2:Error result = oauth2:validateOAuth2Token(token, introspectionServerConfig);\n+# ```\n+#\n+# + token - OAuth2 token that needs to be validated\n+# + config -  OAuth2 introspection server configurations\n+# + return - OAuth2 introspection server response or else a `oauth2:Error` if token validation fails\n+public function validateOAuth2Token(string token, IntrospectionServerConfig config)\n+                                    returns @tainted (IntrospectionResponse|Error) {\n+    cache:Cache? oauth2Cache = config?.oauth2Cache;\n+    if (oauth2Cache is cache:Cache && oauth2Cache.hasKey(token)) {\n+        IntrospectionResponse? response = validateFromCache(oauth2Cache, token);\n+        if (response is IntrospectionResponse) {\n+            return response;\n+        }\n+    }\n \n-                if (oauth2Cache is cache:Cache) {\n-                    addToAuthenticationCache(oauth2Cache, credential, username, scopes, exp);\n-                }\n-                auth:setAuthenticationContext(\"oauth2\", credential);\n-                auth:setPrincipal(username, username, getScopes(scopes ?: \"\"));\n-                return true;\n+    // Build the request to be send to the introspection endpoint.\n+    // Refer: https://tools.ietf.org/html/rfc7662#section-2.1\n+    http:Request req = new;\n+    string textPayload = \"token=\" + token;\n+    string? tokenTypeHint = config?.tokenTypeHint;\n+    if (tokenTypeHint is string) {\n+        textPayload += \"&token_type_hint=\" + tokenTypeHint;\n+    }\n+    req.setTextPayload(textPayload, mime:APPLICATION_FORM_URLENCODED);\n+    http:Client introspectionClient = new(config.url, config.clientConfig);\n+    http:Response|http:ClientError response = introspectionClient->post(\"\", req);\n+    if (response is http:Response) {\n+        json|error result = response.getJsonPayload();\n+        if (result is error) {\n+            return <@untainted> prepareError(result.reason(), result);\n+        }\n+        IntrospectionResponse introspectionResponse = prepareIntrospectionResponse(<json>result);\n+        if (introspectionResponse.active) {\n+            if (oauth2Cache is cache:Cache) {\n+                addToCache(oauth2Cache, token, introspectionResponse, config.defaultTokenExpTimeInSeconds);\n             }\n-            return false;\n-        } else {\n-            return prepareAuthError(\"Failed to call the introspection endpoint.\", response);\n         }\n+        return introspectionResponse;\n+    } else {\n+        return prepareError(\"Failed to call the introspection endpoint.\", response);\n     }\n-};\n+}\n \n-function addToAuthenticationCache(cache:Cache oauth2Cache, string token, string? username, string? scopes, int exp) {\n-    InboundOAuth2CacheEntry oauth2CacheEntry = {username: username ?: \"\", scopes: scopes ?: \"\"};\n-    cache:Error? result = oauth2Cache.put(token, oauth2CacheEntry, exp);\n+function prepareIntrospectionResponse(json payload) returns IntrospectionResponse {\n+    boolean active = <boolean>payload.active;\n+    IntrospectionResponse introspectionResponse = {\n+        active: active\n+    };\n+    if (active) {\n+        if (payload.scope is string) {\n+            introspectionResponse.scopes = <@untainted> <string>payload.scope;\n+        }\n+        if (payload.client_id is string) {\n+            introspectionResponse.clientId = <@untainted> <string>payload.client_id;\n+        }\n+        if (payload.username is string) {\n+            introspectionResponse.username = <@untainted> <string>payload.username;\n+        }\n+        if (payload.token_type is string) {\n+            introspectionResponse.tokenType = <@untainted> <string>payload.token_type;\n+        }\n+        if (payload.exp is int) {\n+            introspectionResponse.exp = <@untainted> <int>payload.exp;\n+        }\n+        if (payload.iat is int) {\n+            introspectionResponse.iat = <@untainted> <int>payload.iat;\n+        }\n+        if (payload.nbf is int) {\n+            introspectionResponse.nbf = <@untainted> <int>payload.nbf;\n+        }\n+        if (payload.sub is string) {\n+            introspectionResponse.sub = <@untainted> <string>payload.sub;\n+        }\n+        if (payload.aud is string) {\n+            introspectionResponse.aud = <@untainted> <string>payload.aud;\n+        }\n+        if (payload.iss is string) {\n+            introspectionResponse.iss = <@untainted> <string>payload.iss;\n+        }\n+        if (payload.jti is string) {\n+            introspectionResponse.jti = <@untainted> <string>payload.jti;\n+        }\n+    }\n+    return introspectionResponse;\n+}\n+\n+function addToCache(cache:Cache oauth2Cache, string token, IntrospectionResponse response,\n+                    int defaultTokenExpTimeInSeconds) {\n+    cache:Error? result;\n+    if (response?.exp is int) {\n+        result = oauth2Cache.put(token, response);\n+    } else {\n+        // If the exp parameter is not set by introspection response, use cache default expiry by\n+        // defaultTokenExpTimeInSeconds. Then the cached value will be removed when retrieving.\n+        result = oauth2Cache.put(token, response, defaultTokenExpTimeInSeconds);\n+    }\n     if (result is cache:Error) {\n         log:printDebug(function() returns string {\n-            return \"Failed to add JWT to the cache\";\n+            return \"Failed to add OAuth2 token to the cache. Introspection response: \" + response.toString();\n         });\n         return;\n     }\n-    if (username is string) {\n-        string user = username;\n+    log:printDebug(function() returns string {\n+        return \"OAuth2 token added to the cache. Introspection response: \" + response.toString();\n+    });\n+}\n+\n+function validateFromCache(cache:Cache oauth2Cache, string token) returns IntrospectionResponse? {\n+    any|cache:Error cachedValue = oauth2Cache.get(token);\n+    if (cachedValue is ()) {\n+        // If the cached value is expired (defaultTokenExpTimeInSeconds is passed), it will return ().\n         log:printDebug(function() returns string {\n-            return \"Add authenticated user: \" + user + \" to the cache.\";\n+            return \"Failed to validate token from from the cache, since token is expired.\";\n         });\n+        return;\n     }\n-}\n-\n-function authenticateFromCache(cache:Cache oauth2Cache, string token) returns InboundOAuth2CacheEntry? {\n-    if (oauth2Cache.hasKey(token)) {\n-        InboundOAuth2CacheEntry oauth2CacheEntry = <InboundOAuth2CacheEntry>oauth2Cache.get(token);\n+    if (cachedValue is cache:Error) {\n         log:printDebug(function() returns string {\n-            return \"Get authenticated user: \" + oauth2CacheEntry.username + \" from the cache.\";\n+            return \"Failed to validate token from from the cache. Cache error: \" + cachedValue.toString();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff83dc80c4afbcd940b49c0035b3a0dfbeafc642"}, "originalPosition": 239}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA3MzE3NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                // expTime can be (), that means the defaultTokenExpTimeInSeconds is not exceeded yet. Hence the token is still\n          \n          \n            \n                // The `expTime` can be `()`. This means that the `defaultTokenExpTimeInSeconds` is not exceeded yet. Hence, the token is still", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22917#discussion_r417073175", "createdAt": "2020-04-29T05:23:18Z", "author": {"login": "praneesha"}, "path": "stdlib/oauth2/src/main/ballerina/src/oauth2/inbound_oauth2_provider.bal", "diffHunk": "@@ -60,108 +52,183 @@ public type InboundOAuth2Provider object {\n #\n # + credential - OAuth2 token to be authenticated\n # + return - `true` if authentication is successful, `false` otherwise, or else an `auth:Error` if an error occurred\n-    public function authenticate(string credential) returns boolean|auth:Error {\n+    public function authenticate(string credential) returns @tainted (boolean|auth:Error) {\n         if (credential == \"\") {\n             return false;\n         }\n \n-        cache:Cache? oauth2Cache = self.inboundOAuth2Cache;\n-        if (oauth2Cache is cache:Cache && oauth2Cache.hasKey(credential)) {\n-            InboundOAuth2CacheEntry? oauth2CacheEntry = authenticateFromCache(oauth2Cache, credential);\n-            if (oauth2CacheEntry is InboundOAuth2CacheEntry) {\n+        IntrospectionResponse|Error validationResult = validateOAuth2Token(credential, self.introspectionServerConfig);\n+        if (validationResult is IntrospectionResponse) {\n+            if (validationResult.active) {\n                 auth:setAuthenticationContext(\"oauth2\", credential);\n-                auth:setPrincipal(oauth2CacheEntry.username, oauth2CacheEntry.username,\n-                                  getScopes(oauth2CacheEntry.scopes));\n-                return true;\n+                auth:setPrincipal(validationResult?.username, validationResult?.username,\n+                                  getScopes(validationResult?.scopes));\n             }\n+            return validationResult.active;\n+        } else {\n+            return prepareAuthError(\"OAuth2 validation failed.\", validationResult);\n         }\n+    }\n+};\n \n-        // Build the request to be send to the introspection endpoint.\n-        // Refer: https://tools.ietf.org/html/rfc7662#section-2.1\n-        http:Request req = new;\n-        string textPayload = \"token=\" + credential;\n-        string? tokenTypeHint = self.tokenTypeHint;\n-        if (tokenTypeHint is string) {\n-            textPayload += \"&token_type_hint=\" + tokenTypeHint;\n-        }\n-        req.setTextPayload(textPayload, mime:APPLICATION_FORM_URLENCODED);\n-        http:Response|http:ClientError response = self.introspectionClient->post(\"\", req);\n-        if (response is http:Response) {\n-            json|error result = response.getJsonPayload();\n-            if (result is error) {\n-                return <@untainted> prepareAuthError(result.reason(), result);\n-            }\n-\n-            json payload = <json>result;\n-            boolean active = <boolean>payload.active;\n-            if (active) {\n-                string? username = ();\n-                string? scopes = ();\n-                int exp;\n-\n-                if (payload.username is string) {\n-                    username = <@untainted> <string>payload.username;\n-                }\n-                if (payload.scope is string) {\n-                    scopes = <@untainted> <string>payload.scope;\n-                }\n-                if (payload.exp is int) {\n-                    exp = <@untainted> <int>payload.exp;\n-                } else {\n-                    exp = self.defaultTokenExpTimeInSeconds +  (time:currentTime().time / 1000);\n-                }\n+# Validates the given OAuth2 token.\n+# ```ballerina\n+# oauth2:IntrospectionResponse|oauth2:Error result = oauth2:validateOAuth2Token(token, introspectionServerConfig);\n+# ```\n+#\n+# + token - OAuth2 token that needs to be validated\n+# + config -  OAuth2 introspection server configurations\n+# + return - OAuth2 introspection server response or else a `oauth2:Error` if token validation fails\n+public function validateOAuth2Token(string token, IntrospectionServerConfig config)\n+                                    returns @tainted (IntrospectionResponse|Error) {\n+    cache:Cache? oauth2Cache = config?.oauth2Cache;\n+    if (oauth2Cache is cache:Cache && oauth2Cache.hasKey(token)) {\n+        IntrospectionResponse? response = validateFromCache(oauth2Cache, token);\n+        if (response is IntrospectionResponse) {\n+            return response;\n+        }\n+    }\n \n-                if (oauth2Cache is cache:Cache) {\n-                    addToAuthenticationCache(oauth2Cache, credential, username, scopes, exp);\n-                }\n-                auth:setAuthenticationContext(\"oauth2\", credential);\n-                auth:setPrincipal(username, username, getScopes(scopes ?: \"\"));\n-                return true;\n+    // Build the request to be send to the introspection endpoint.\n+    // Refer: https://tools.ietf.org/html/rfc7662#section-2.1\n+    http:Request req = new;\n+    string textPayload = \"token=\" + token;\n+    string? tokenTypeHint = config?.tokenTypeHint;\n+    if (tokenTypeHint is string) {\n+        textPayload += \"&token_type_hint=\" + tokenTypeHint;\n+    }\n+    req.setTextPayload(textPayload, mime:APPLICATION_FORM_URLENCODED);\n+    http:Client introspectionClient = new(config.url, config.clientConfig);\n+    http:Response|http:ClientError response = introspectionClient->post(\"\", req);\n+    if (response is http:Response) {\n+        json|error result = response.getJsonPayload();\n+        if (result is error) {\n+            return <@untainted> prepareError(result.reason(), result);\n+        }\n+        IntrospectionResponse introspectionResponse = prepareIntrospectionResponse(<json>result);\n+        if (introspectionResponse.active) {\n+            if (oauth2Cache is cache:Cache) {\n+                addToCache(oauth2Cache, token, introspectionResponse, config.defaultTokenExpTimeInSeconds);\n             }\n-            return false;\n-        } else {\n-            return prepareAuthError(\"Failed to call the introspection endpoint.\", response);\n         }\n+        return introspectionResponse;\n+    } else {\n+        return prepareError(\"Failed to call the introspection endpoint.\", response);\n     }\n-};\n+}\n \n-function addToAuthenticationCache(cache:Cache oauth2Cache, string token, string? username, string? scopes, int exp) {\n-    InboundOAuth2CacheEntry oauth2CacheEntry = {username: username ?: \"\", scopes: scopes ?: \"\"};\n-    cache:Error? result = oauth2Cache.put(token, oauth2CacheEntry, exp);\n+function prepareIntrospectionResponse(json payload) returns IntrospectionResponse {\n+    boolean active = <boolean>payload.active;\n+    IntrospectionResponse introspectionResponse = {\n+        active: active\n+    };\n+    if (active) {\n+        if (payload.scope is string) {\n+            introspectionResponse.scopes = <@untainted> <string>payload.scope;\n+        }\n+        if (payload.client_id is string) {\n+            introspectionResponse.clientId = <@untainted> <string>payload.client_id;\n+        }\n+        if (payload.username is string) {\n+            introspectionResponse.username = <@untainted> <string>payload.username;\n+        }\n+        if (payload.token_type is string) {\n+            introspectionResponse.tokenType = <@untainted> <string>payload.token_type;\n+        }\n+        if (payload.exp is int) {\n+            introspectionResponse.exp = <@untainted> <int>payload.exp;\n+        }\n+        if (payload.iat is int) {\n+            introspectionResponse.iat = <@untainted> <int>payload.iat;\n+        }\n+        if (payload.nbf is int) {\n+            introspectionResponse.nbf = <@untainted> <int>payload.nbf;\n+        }\n+        if (payload.sub is string) {\n+            introspectionResponse.sub = <@untainted> <string>payload.sub;\n+        }\n+        if (payload.aud is string) {\n+            introspectionResponse.aud = <@untainted> <string>payload.aud;\n+        }\n+        if (payload.iss is string) {\n+            introspectionResponse.iss = <@untainted> <string>payload.iss;\n+        }\n+        if (payload.jti is string) {\n+            introspectionResponse.jti = <@untainted> <string>payload.jti;\n+        }\n+    }\n+    return introspectionResponse;\n+}\n+\n+function addToCache(cache:Cache oauth2Cache, string token, IntrospectionResponse response,\n+                    int defaultTokenExpTimeInSeconds) {\n+    cache:Error? result;\n+    if (response?.exp is int) {\n+        result = oauth2Cache.put(token, response);\n+    } else {\n+        // If the exp parameter is not set by introspection response, use cache default expiry by\n+        // defaultTokenExpTimeInSeconds. Then the cached value will be removed when retrieving.\n+        result = oauth2Cache.put(token, response, defaultTokenExpTimeInSeconds);\n+    }\n     if (result is cache:Error) {\n         log:printDebug(function() returns string {\n-            return \"Failed to add JWT to the cache\";\n+            return \"Failed to add OAuth2 token to the cache. Introspection response: \" + response.toString();\n         });\n         return;\n     }\n-    if (username is string) {\n-        string user = username;\n+    log:printDebug(function() returns string {\n+        return \"OAuth2 token added to the cache. Introspection response: \" + response.toString();\n+    });\n+}\n+\n+function validateFromCache(cache:Cache oauth2Cache, string token) returns IntrospectionResponse? {\n+    any|cache:Error cachedValue = oauth2Cache.get(token);\n+    if (cachedValue is ()) {\n+        // If the cached value is expired (defaultTokenExpTimeInSeconds is passed), it will return ().\n         log:printDebug(function() returns string {\n-            return \"Add authenticated user: \" + user + \" to the cache.\";\n+            return \"Failed to validate token from from the cache, since token is expired.\";\n         });\n+        return;\n     }\n-}\n-\n-function authenticateFromCache(cache:Cache oauth2Cache, string token) returns InboundOAuth2CacheEntry? {\n-    if (oauth2Cache.hasKey(token)) {\n-        InboundOAuth2CacheEntry oauth2CacheEntry = <InboundOAuth2CacheEntry>oauth2Cache.get(token);\n+    if (cachedValue is cache:Error) {\n         log:printDebug(function() returns string {\n-            return \"Get authenticated user: \" + oauth2CacheEntry.username + \" from the cache.\";\n+            return \"Failed to validate token from from the cache. Cache error: \" + cachedValue.toString();\n         });\n-        return oauth2CacheEntry;\n+        return;\n+    }\n+    IntrospectionResponse response = <IntrospectionResponse>cachedValue;\n+    int? expTime = response?.exp;\n+    // expTime can be (), that means the defaultTokenExpTimeInSeconds is not exceeded yet. Hence the token is still", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff83dc80c4afbcd940b49c0035b3a0dfbeafc642"}, "originalPosition": 246}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA3MzUxNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                // valid. Convert to current time and check the expiry time is exceeds if the expTime is int.\n          \n          \n            \n                // valid. If the `expTime` is given in int, convert this to the current time and check if the expiry time is exceeded.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22917#discussion_r417073517", "createdAt": "2020-04-29T05:24:25Z", "author": {"login": "praneesha"}, "path": "stdlib/oauth2/src/main/ballerina/src/oauth2/inbound_oauth2_provider.bal", "diffHunk": "@@ -60,108 +52,183 @@ public type InboundOAuth2Provider object {\n #\n # + credential - OAuth2 token to be authenticated\n # + return - `true` if authentication is successful, `false` otherwise, or else an `auth:Error` if an error occurred\n-    public function authenticate(string credential) returns boolean|auth:Error {\n+    public function authenticate(string credential) returns @tainted (boolean|auth:Error) {\n         if (credential == \"\") {\n             return false;\n         }\n \n-        cache:Cache? oauth2Cache = self.inboundOAuth2Cache;\n-        if (oauth2Cache is cache:Cache && oauth2Cache.hasKey(credential)) {\n-            InboundOAuth2CacheEntry? oauth2CacheEntry = authenticateFromCache(oauth2Cache, credential);\n-            if (oauth2CacheEntry is InboundOAuth2CacheEntry) {\n+        IntrospectionResponse|Error validationResult = validateOAuth2Token(credential, self.introspectionServerConfig);\n+        if (validationResult is IntrospectionResponse) {\n+            if (validationResult.active) {\n                 auth:setAuthenticationContext(\"oauth2\", credential);\n-                auth:setPrincipal(oauth2CacheEntry.username, oauth2CacheEntry.username,\n-                                  getScopes(oauth2CacheEntry.scopes));\n-                return true;\n+                auth:setPrincipal(validationResult?.username, validationResult?.username,\n+                                  getScopes(validationResult?.scopes));\n             }\n+            return validationResult.active;\n+        } else {\n+            return prepareAuthError(\"OAuth2 validation failed.\", validationResult);\n         }\n+    }\n+};\n \n-        // Build the request to be send to the introspection endpoint.\n-        // Refer: https://tools.ietf.org/html/rfc7662#section-2.1\n-        http:Request req = new;\n-        string textPayload = \"token=\" + credential;\n-        string? tokenTypeHint = self.tokenTypeHint;\n-        if (tokenTypeHint is string) {\n-            textPayload += \"&token_type_hint=\" + tokenTypeHint;\n-        }\n-        req.setTextPayload(textPayload, mime:APPLICATION_FORM_URLENCODED);\n-        http:Response|http:ClientError response = self.introspectionClient->post(\"\", req);\n-        if (response is http:Response) {\n-            json|error result = response.getJsonPayload();\n-            if (result is error) {\n-                return <@untainted> prepareAuthError(result.reason(), result);\n-            }\n-\n-            json payload = <json>result;\n-            boolean active = <boolean>payload.active;\n-            if (active) {\n-                string? username = ();\n-                string? scopes = ();\n-                int exp;\n-\n-                if (payload.username is string) {\n-                    username = <@untainted> <string>payload.username;\n-                }\n-                if (payload.scope is string) {\n-                    scopes = <@untainted> <string>payload.scope;\n-                }\n-                if (payload.exp is int) {\n-                    exp = <@untainted> <int>payload.exp;\n-                } else {\n-                    exp = self.defaultTokenExpTimeInSeconds +  (time:currentTime().time / 1000);\n-                }\n+# Validates the given OAuth2 token.\n+# ```ballerina\n+# oauth2:IntrospectionResponse|oauth2:Error result = oauth2:validateOAuth2Token(token, introspectionServerConfig);\n+# ```\n+#\n+# + token - OAuth2 token that needs to be validated\n+# + config -  OAuth2 introspection server configurations\n+# + return - OAuth2 introspection server response or else a `oauth2:Error` if token validation fails\n+public function validateOAuth2Token(string token, IntrospectionServerConfig config)\n+                                    returns @tainted (IntrospectionResponse|Error) {\n+    cache:Cache? oauth2Cache = config?.oauth2Cache;\n+    if (oauth2Cache is cache:Cache && oauth2Cache.hasKey(token)) {\n+        IntrospectionResponse? response = validateFromCache(oauth2Cache, token);\n+        if (response is IntrospectionResponse) {\n+            return response;\n+        }\n+    }\n \n-                if (oauth2Cache is cache:Cache) {\n-                    addToAuthenticationCache(oauth2Cache, credential, username, scopes, exp);\n-                }\n-                auth:setAuthenticationContext(\"oauth2\", credential);\n-                auth:setPrincipal(username, username, getScopes(scopes ?: \"\"));\n-                return true;\n+    // Build the request to be send to the introspection endpoint.\n+    // Refer: https://tools.ietf.org/html/rfc7662#section-2.1\n+    http:Request req = new;\n+    string textPayload = \"token=\" + token;\n+    string? tokenTypeHint = config?.tokenTypeHint;\n+    if (tokenTypeHint is string) {\n+        textPayload += \"&token_type_hint=\" + tokenTypeHint;\n+    }\n+    req.setTextPayload(textPayload, mime:APPLICATION_FORM_URLENCODED);\n+    http:Client introspectionClient = new(config.url, config.clientConfig);\n+    http:Response|http:ClientError response = introspectionClient->post(\"\", req);\n+    if (response is http:Response) {\n+        json|error result = response.getJsonPayload();\n+        if (result is error) {\n+            return <@untainted> prepareError(result.reason(), result);\n+        }\n+        IntrospectionResponse introspectionResponse = prepareIntrospectionResponse(<json>result);\n+        if (introspectionResponse.active) {\n+            if (oauth2Cache is cache:Cache) {\n+                addToCache(oauth2Cache, token, introspectionResponse, config.defaultTokenExpTimeInSeconds);\n             }\n-            return false;\n-        } else {\n-            return prepareAuthError(\"Failed to call the introspection endpoint.\", response);\n         }\n+        return introspectionResponse;\n+    } else {\n+        return prepareError(\"Failed to call the introspection endpoint.\", response);\n     }\n-};\n+}\n \n-function addToAuthenticationCache(cache:Cache oauth2Cache, string token, string? username, string? scopes, int exp) {\n-    InboundOAuth2CacheEntry oauth2CacheEntry = {username: username ?: \"\", scopes: scopes ?: \"\"};\n-    cache:Error? result = oauth2Cache.put(token, oauth2CacheEntry, exp);\n+function prepareIntrospectionResponse(json payload) returns IntrospectionResponse {\n+    boolean active = <boolean>payload.active;\n+    IntrospectionResponse introspectionResponse = {\n+        active: active\n+    };\n+    if (active) {\n+        if (payload.scope is string) {\n+            introspectionResponse.scopes = <@untainted> <string>payload.scope;\n+        }\n+        if (payload.client_id is string) {\n+            introspectionResponse.clientId = <@untainted> <string>payload.client_id;\n+        }\n+        if (payload.username is string) {\n+            introspectionResponse.username = <@untainted> <string>payload.username;\n+        }\n+        if (payload.token_type is string) {\n+            introspectionResponse.tokenType = <@untainted> <string>payload.token_type;\n+        }\n+        if (payload.exp is int) {\n+            introspectionResponse.exp = <@untainted> <int>payload.exp;\n+        }\n+        if (payload.iat is int) {\n+            introspectionResponse.iat = <@untainted> <int>payload.iat;\n+        }\n+        if (payload.nbf is int) {\n+            introspectionResponse.nbf = <@untainted> <int>payload.nbf;\n+        }\n+        if (payload.sub is string) {\n+            introspectionResponse.sub = <@untainted> <string>payload.sub;\n+        }\n+        if (payload.aud is string) {\n+            introspectionResponse.aud = <@untainted> <string>payload.aud;\n+        }\n+        if (payload.iss is string) {\n+            introspectionResponse.iss = <@untainted> <string>payload.iss;\n+        }\n+        if (payload.jti is string) {\n+            introspectionResponse.jti = <@untainted> <string>payload.jti;\n+        }\n+    }\n+    return introspectionResponse;\n+}\n+\n+function addToCache(cache:Cache oauth2Cache, string token, IntrospectionResponse response,\n+                    int defaultTokenExpTimeInSeconds) {\n+    cache:Error? result;\n+    if (response?.exp is int) {\n+        result = oauth2Cache.put(token, response);\n+    } else {\n+        // If the exp parameter is not set by introspection response, use cache default expiry by\n+        // defaultTokenExpTimeInSeconds. Then the cached value will be removed when retrieving.\n+        result = oauth2Cache.put(token, response, defaultTokenExpTimeInSeconds);\n+    }\n     if (result is cache:Error) {\n         log:printDebug(function() returns string {\n-            return \"Failed to add JWT to the cache\";\n+            return \"Failed to add OAuth2 token to the cache. Introspection response: \" + response.toString();\n         });\n         return;\n     }\n-    if (username is string) {\n-        string user = username;\n+    log:printDebug(function() returns string {\n+        return \"OAuth2 token added to the cache. Introspection response: \" + response.toString();\n+    });\n+}\n+\n+function validateFromCache(cache:Cache oauth2Cache, string token) returns IntrospectionResponse? {\n+    any|cache:Error cachedValue = oauth2Cache.get(token);\n+    if (cachedValue is ()) {\n+        // If the cached value is expired (defaultTokenExpTimeInSeconds is passed), it will return ().\n         log:printDebug(function() returns string {\n-            return \"Add authenticated user: \" + user + \" to the cache.\";\n+            return \"Failed to validate token from from the cache, since token is expired.\";\n         });\n+        return;\n     }\n-}\n-\n-function authenticateFromCache(cache:Cache oauth2Cache, string token) returns InboundOAuth2CacheEntry? {\n-    if (oauth2Cache.hasKey(token)) {\n-        InboundOAuth2CacheEntry oauth2CacheEntry = <InboundOAuth2CacheEntry>oauth2Cache.get(token);\n+    if (cachedValue is cache:Error) {\n         log:printDebug(function() returns string {\n-            return \"Get authenticated user: \" + oauth2CacheEntry.username + \" from the cache.\";\n+            return \"Failed to validate token from from the cache. Cache error: \" + cachedValue.toString();\n         });\n-        return oauth2CacheEntry;\n+        return;\n+    }\n+    IntrospectionResponse response = <IntrospectionResponse>cachedValue;\n+    int? expTime = response?.exp;\n+    // expTime can be (), that means the defaultTokenExpTimeInSeconds is not exceeded yet. Hence the token is still\n+    // valid. Convert to current time and check the expiry time is exceeds if the expTime is int.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff83dc80c4afbcd940b49c0035b3a0dfbeafc642"}, "originalPosition": 247}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA3MzYxMA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            # Reads the scope(s) for the user with the given username.\n          \n          \n            \n            # Reads the scope(s) of the user with the given username.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22917#discussion_r417073610", "createdAt": "2020-04-29T05:24:48Z", "author": {"login": "praneesha"}, "path": "stdlib/oauth2/src/main/ballerina/src/oauth2/inbound_oauth2_provider.bal", "diffHunk": "@@ -60,108 +52,183 @@ public type InboundOAuth2Provider object {\n #\n # + credential - OAuth2 token to be authenticated\n # + return - `true` if authentication is successful, `false` otherwise, or else an `auth:Error` if an error occurred\n-    public function authenticate(string credential) returns boolean|auth:Error {\n+    public function authenticate(string credential) returns @tainted (boolean|auth:Error) {\n         if (credential == \"\") {\n             return false;\n         }\n \n-        cache:Cache? oauth2Cache = self.inboundOAuth2Cache;\n-        if (oauth2Cache is cache:Cache && oauth2Cache.hasKey(credential)) {\n-            InboundOAuth2CacheEntry? oauth2CacheEntry = authenticateFromCache(oauth2Cache, credential);\n-            if (oauth2CacheEntry is InboundOAuth2CacheEntry) {\n+        IntrospectionResponse|Error validationResult = validateOAuth2Token(credential, self.introspectionServerConfig);\n+        if (validationResult is IntrospectionResponse) {\n+            if (validationResult.active) {\n                 auth:setAuthenticationContext(\"oauth2\", credential);\n-                auth:setPrincipal(oauth2CacheEntry.username, oauth2CacheEntry.username,\n-                                  getScopes(oauth2CacheEntry.scopes));\n-                return true;\n+                auth:setPrincipal(validationResult?.username, validationResult?.username,\n+                                  getScopes(validationResult?.scopes));\n             }\n+            return validationResult.active;\n+        } else {\n+            return prepareAuthError(\"OAuth2 validation failed.\", validationResult);\n         }\n+    }\n+};\n \n-        // Build the request to be send to the introspection endpoint.\n-        // Refer: https://tools.ietf.org/html/rfc7662#section-2.1\n-        http:Request req = new;\n-        string textPayload = \"token=\" + credential;\n-        string? tokenTypeHint = self.tokenTypeHint;\n-        if (tokenTypeHint is string) {\n-            textPayload += \"&token_type_hint=\" + tokenTypeHint;\n-        }\n-        req.setTextPayload(textPayload, mime:APPLICATION_FORM_URLENCODED);\n-        http:Response|http:ClientError response = self.introspectionClient->post(\"\", req);\n-        if (response is http:Response) {\n-            json|error result = response.getJsonPayload();\n-            if (result is error) {\n-                return <@untainted> prepareAuthError(result.reason(), result);\n-            }\n-\n-            json payload = <json>result;\n-            boolean active = <boolean>payload.active;\n-            if (active) {\n-                string? username = ();\n-                string? scopes = ();\n-                int exp;\n-\n-                if (payload.username is string) {\n-                    username = <@untainted> <string>payload.username;\n-                }\n-                if (payload.scope is string) {\n-                    scopes = <@untainted> <string>payload.scope;\n-                }\n-                if (payload.exp is int) {\n-                    exp = <@untainted> <int>payload.exp;\n-                } else {\n-                    exp = self.defaultTokenExpTimeInSeconds +  (time:currentTime().time / 1000);\n-                }\n+# Validates the given OAuth2 token.\n+# ```ballerina\n+# oauth2:IntrospectionResponse|oauth2:Error result = oauth2:validateOAuth2Token(token, introspectionServerConfig);\n+# ```\n+#\n+# + token - OAuth2 token that needs to be validated\n+# + config -  OAuth2 introspection server configurations\n+# + return - OAuth2 introspection server response or else a `oauth2:Error` if token validation fails\n+public function validateOAuth2Token(string token, IntrospectionServerConfig config)\n+                                    returns @tainted (IntrospectionResponse|Error) {\n+    cache:Cache? oauth2Cache = config?.oauth2Cache;\n+    if (oauth2Cache is cache:Cache && oauth2Cache.hasKey(token)) {\n+        IntrospectionResponse? response = validateFromCache(oauth2Cache, token);\n+        if (response is IntrospectionResponse) {\n+            return response;\n+        }\n+    }\n \n-                if (oauth2Cache is cache:Cache) {\n-                    addToAuthenticationCache(oauth2Cache, credential, username, scopes, exp);\n-                }\n-                auth:setAuthenticationContext(\"oauth2\", credential);\n-                auth:setPrincipal(username, username, getScopes(scopes ?: \"\"));\n-                return true;\n+    // Build the request to be send to the introspection endpoint.\n+    // Refer: https://tools.ietf.org/html/rfc7662#section-2.1\n+    http:Request req = new;\n+    string textPayload = \"token=\" + token;\n+    string? tokenTypeHint = config?.tokenTypeHint;\n+    if (tokenTypeHint is string) {\n+        textPayload += \"&token_type_hint=\" + tokenTypeHint;\n+    }\n+    req.setTextPayload(textPayload, mime:APPLICATION_FORM_URLENCODED);\n+    http:Client introspectionClient = new(config.url, config.clientConfig);\n+    http:Response|http:ClientError response = introspectionClient->post(\"\", req);\n+    if (response is http:Response) {\n+        json|error result = response.getJsonPayload();\n+        if (result is error) {\n+            return <@untainted> prepareError(result.reason(), result);\n+        }\n+        IntrospectionResponse introspectionResponse = prepareIntrospectionResponse(<json>result);\n+        if (introspectionResponse.active) {\n+            if (oauth2Cache is cache:Cache) {\n+                addToCache(oauth2Cache, token, introspectionResponse, config.defaultTokenExpTimeInSeconds);\n             }\n-            return false;\n-        } else {\n-            return prepareAuthError(\"Failed to call the introspection endpoint.\", response);\n         }\n+        return introspectionResponse;\n+    } else {\n+        return prepareError(\"Failed to call the introspection endpoint.\", response);\n     }\n-};\n+}\n \n-function addToAuthenticationCache(cache:Cache oauth2Cache, string token, string? username, string? scopes, int exp) {\n-    InboundOAuth2CacheEntry oauth2CacheEntry = {username: username ?: \"\", scopes: scopes ?: \"\"};\n-    cache:Error? result = oauth2Cache.put(token, oauth2CacheEntry, exp);\n+function prepareIntrospectionResponse(json payload) returns IntrospectionResponse {\n+    boolean active = <boolean>payload.active;\n+    IntrospectionResponse introspectionResponse = {\n+        active: active\n+    };\n+    if (active) {\n+        if (payload.scope is string) {\n+            introspectionResponse.scopes = <@untainted> <string>payload.scope;\n+        }\n+        if (payload.client_id is string) {\n+            introspectionResponse.clientId = <@untainted> <string>payload.client_id;\n+        }\n+        if (payload.username is string) {\n+            introspectionResponse.username = <@untainted> <string>payload.username;\n+        }\n+        if (payload.token_type is string) {\n+            introspectionResponse.tokenType = <@untainted> <string>payload.token_type;\n+        }\n+        if (payload.exp is int) {\n+            introspectionResponse.exp = <@untainted> <int>payload.exp;\n+        }\n+        if (payload.iat is int) {\n+            introspectionResponse.iat = <@untainted> <int>payload.iat;\n+        }\n+        if (payload.nbf is int) {\n+            introspectionResponse.nbf = <@untainted> <int>payload.nbf;\n+        }\n+        if (payload.sub is string) {\n+            introspectionResponse.sub = <@untainted> <string>payload.sub;\n+        }\n+        if (payload.aud is string) {\n+            introspectionResponse.aud = <@untainted> <string>payload.aud;\n+        }\n+        if (payload.iss is string) {\n+            introspectionResponse.iss = <@untainted> <string>payload.iss;\n+        }\n+        if (payload.jti is string) {\n+            introspectionResponse.jti = <@untainted> <string>payload.jti;\n+        }\n+    }\n+    return introspectionResponse;\n+}\n+\n+function addToCache(cache:Cache oauth2Cache, string token, IntrospectionResponse response,\n+                    int defaultTokenExpTimeInSeconds) {\n+    cache:Error? result;\n+    if (response?.exp is int) {\n+        result = oauth2Cache.put(token, response);\n+    } else {\n+        // If the exp parameter is not set by introspection response, use cache default expiry by\n+        // defaultTokenExpTimeInSeconds. Then the cached value will be removed when retrieving.\n+        result = oauth2Cache.put(token, response, defaultTokenExpTimeInSeconds);\n+    }\n     if (result is cache:Error) {\n         log:printDebug(function() returns string {\n-            return \"Failed to add JWT to the cache\";\n+            return \"Failed to add OAuth2 token to the cache. Introspection response: \" + response.toString();\n         });\n         return;\n     }\n-    if (username is string) {\n-        string user = username;\n+    log:printDebug(function() returns string {\n+        return \"OAuth2 token added to the cache. Introspection response: \" + response.toString();\n+    });\n+}\n+\n+function validateFromCache(cache:Cache oauth2Cache, string token) returns IntrospectionResponse? {\n+    any|cache:Error cachedValue = oauth2Cache.get(token);\n+    if (cachedValue is ()) {\n+        // If the cached value is expired (defaultTokenExpTimeInSeconds is passed), it will return ().\n         log:printDebug(function() returns string {\n-            return \"Add authenticated user: \" + user + \" to the cache.\";\n+            return \"Failed to validate token from from the cache, since token is expired.\";\n         });\n+        return;\n     }\n-}\n-\n-function authenticateFromCache(cache:Cache oauth2Cache, string token) returns InboundOAuth2CacheEntry? {\n-    if (oauth2Cache.hasKey(token)) {\n-        InboundOAuth2CacheEntry oauth2CacheEntry = <InboundOAuth2CacheEntry>oauth2Cache.get(token);\n+    if (cachedValue is cache:Error) {\n         log:printDebug(function() returns string {\n-            return \"Get authenticated user: \" + oauth2CacheEntry.username + \" from the cache.\";\n+            return \"Failed to validate token from from the cache. Cache error: \" + cachedValue.toString();\n         });\n-        return oauth2CacheEntry;\n+        return;\n+    }\n+    IntrospectionResponse response = <IntrospectionResponse>cachedValue;\n+    int? expTime = response?.exp;\n+    // expTime can be (), that means the defaultTokenExpTimeInSeconds is not exceeded yet. Hence the token is still\n+    // valid. Convert to current time and check the expiry time is exceeds if the expTime is int.\n+    if (expTime is () || expTime > (time:currentTime().time / 1000)) {\n+        log:printDebug(function() returns string {\n+            return \"OAuth2 token validated from the cache. Introspection response: \" + response.toString();\n+        });\n+        return response;\n+    } else {\n+        cache:Error? result = oauth2Cache.invalidate(token);\n+        if (result is cache:Error) {\n+            log:printDebug(function() returns string {\n+                return \"Failed to invalidate OAuth2 token from the cache. Introspection response: \" + response.toString();\n+            });\n+        }\n     }\n }\n \n # Reads the scope(s) for the user with the given username.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff83dc80c4afbcd940b49c0035b3a0dfbeafc642"}, "originalPosition": 263}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA3MzY2Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            # + return - Array of groups for the user denoted by the username\n          \n          \n            \n            # + return - Array of groups for the user who is denoted by the username", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22917#discussion_r417073663", "createdAt": "2020-04-29T05:24:58Z", "author": {"login": "praneesha"}, "path": "stdlib/oauth2/src/main/ballerina/src/oauth2/inbound_oauth2_provider.bal", "diffHunk": "@@ -60,108 +52,183 @@ public type InboundOAuth2Provider object {\n #\n # + credential - OAuth2 token to be authenticated\n # + return - `true` if authentication is successful, `false` otherwise, or else an `auth:Error` if an error occurred\n-    public function authenticate(string credential) returns boolean|auth:Error {\n+    public function authenticate(string credential) returns @tainted (boolean|auth:Error) {\n         if (credential == \"\") {\n             return false;\n         }\n \n-        cache:Cache? oauth2Cache = self.inboundOAuth2Cache;\n-        if (oauth2Cache is cache:Cache && oauth2Cache.hasKey(credential)) {\n-            InboundOAuth2CacheEntry? oauth2CacheEntry = authenticateFromCache(oauth2Cache, credential);\n-            if (oauth2CacheEntry is InboundOAuth2CacheEntry) {\n+        IntrospectionResponse|Error validationResult = validateOAuth2Token(credential, self.introspectionServerConfig);\n+        if (validationResult is IntrospectionResponse) {\n+            if (validationResult.active) {\n                 auth:setAuthenticationContext(\"oauth2\", credential);\n-                auth:setPrincipal(oauth2CacheEntry.username, oauth2CacheEntry.username,\n-                                  getScopes(oauth2CacheEntry.scopes));\n-                return true;\n+                auth:setPrincipal(validationResult?.username, validationResult?.username,\n+                                  getScopes(validationResult?.scopes));\n             }\n+            return validationResult.active;\n+        } else {\n+            return prepareAuthError(\"OAuth2 validation failed.\", validationResult);\n         }\n+    }\n+};\n \n-        // Build the request to be send to the introspection endpoint.\n-        // Refer: https://tools.ietf.org/html/rfc7662#section-2.1\n-        http:Request req = new;\n-        string textPayload = \"token=\" + credential;\n-        string? tokenTypeHint = self.tokenTypeHint;\n-        if (tokenTypeHint is string) {\n-            textPayload += \"&token_type_hint=\" + tokenTypeHint;\n-        }\n-        req.setTextPayload(textPayload, mime:APPLICATION_FORM_URLENCODED);\n-        http:Response|http:ClientError response = self.introspectionClient->post(\"\", req);\n-        if (response is http:Response) {\n-            json|error result = response.getJsonPayload();\n-            if (result is error) {\n-                return <@untainted> prepareAuthError(result.reason(), result);\n-            }\n-\n-            json payload = <json>result;\n-            boolean active = <boolean>payload.active;\n-            if (active) {\n-                string? username = ();\n-                string? scopes = ();\n-                int exp;\n-\n-                if (payload.username is string) {\n-                    username = <@untainted> <string>payload.username;\n-                }\n-                if (payload.scope is string) {\n-                    scopes = <@untainted> <string>payload.scope;\n-                }\n-                if (payload.exp is int) {\n-                    exp = <@untainted> <int>payload.exp;\n-                } else {\n-                    exp = self.defaultTokenExpTimeInSeconds +  (time:currentTime().time / 1000);\n-                }\n+# Validates the given OAuth2 token.\n+# ```ballerina\n+# oauth2:IntrospectionResponse|oauth2:Error result = oauth2:validateOAuth2Token(token, introspectionServerConfig);\n+# ```\n+#\n+# + token - OAuth2 token that needs to be validated\n+# + config -  OAuth2 introspection server configurations\n+# + return - OAuth2 introspection server response or else a `oauth2:Error` if token validation fails\n+public function validateOAuth2Token(string token, IntrospectionServerConfig config)\n+                                    returns @tainted (IntrospectionResponse|Error) {\n+    cache:Cache? oauth2Cache = config?.oauth2Cache;\n+    if (oauth2Cache is cache:Cache && oauth2Cache.hasKey(token)) {\n+        IntrospectionResponse? response = validateFromCache(oauth2Cache, token);\n+        if (response is IntrospectionResponse) {\n+            return response;\n+        }\n+    }\n \n-                if (oauth2Cache is cache:Cache) {\n-                    addToAuthenticationCache(oauth2Cache, credential, username, scopes, exp);\n-                }\n-                auth:setAuthenticationContext(\"oauth2\", credential);\n-                auth:setPrincipal(username, username, getScopes(scopes ?: \"\"));\n-                return true;\n+    // Build the request to be send to the introspection endpoint.\n+    // Refer: https://tools.ietf.org/html/rfc7662#section-2.1\n+    http:Request req = new;\n+    string textPayload = \"token=\" + token;\n+    string? tokenTypeHint = config?.tokenTypeHint;\n+    if (tokenTypeHint is string) {\n+        textPayload += \"&token_type_hint=\" + tokenTypeHint;\n+    }\n+    req.setTextPayload(textPayload, mime:APPLICATION_FORM_URLENCODED);\n+    http:Client introspectionClient = new(config.url, config.clientConfig);\n+    http:Response|http:ClientError response = introspectionClient->post(\"\", req);\n+    if (response is http:Response) {\n+        json|error result = response.getJsonPayload();\n+        if (result is error) {\n+            return <@untainted> prepareError(result.reason(), result);\n+        }\n+        IntrospectionResponse introspectionResponse = prepareIntrospectionResponse(<json>result);\n+        if (introspectionResponse.active) {\n+            if (oauth2Cache is cache:Cache) {\n+                addToCache(oauth2Cache, token, introspectionResponse, config.defaultTokenExpTimeInSeconds);\n             }\n-            return false;\n-        } else {\n-            return prepareAuthError(\"Failed to call the introspection endpoint.\", response);\n         }\n+        return introspectionResponse;\n+    } else {\n+        return prepareError(\"Failed to call the introspection endpoint.\", response);\n     }\n-};\n+}\n \n-function addToAuthenticationCache(cache:Cache oauth2Cache, string token, string? username, string? scopes, int exp) {\n-    InboundOAuth2CacheEntry oauth2CacheEntry = {username: username ?: \"\", scopes: scopes ?: \"\"};\n-    cache:Error? result = oauth2Cache.put(token, oauth2CacheEntry, exp);\n+function prepareIntrospectionResponse(json payload) returns IntrospectionResponse {\n+    boolean active = <boolean>payload.active;\n+    IntrospectionResponse introspectionResponse = {\n+        active: active\n+    };\n+    if (active) {\n+        if (payload.scope is string) {\n+            introspectionResponse.scopes = <@untainted> <string>payload.scope;\n+        }\n+        if (payload.client_id is string) {\n+            introspectionResponse.clientId = <@untainted> <string>payload.client_id;\n+        }\n+        if (payload.username is string) {\n+            introspectionResponse.username = <@untainted> <string>payload.username;\n+        }\n+        if (payload.token_type is string) {\n+            introspectionResponse.tokenType = <@untainted> <string>payload.token_type;\n+        }\n+        if (payload.exp is int) {\n+            introspectionResponse.exp = <@untainted> <int>payload.exp;\n+        }\n+        if (payload.iat is int) {\n+            introspectionResponse.iat = <@untainted> <int>payload.iat;\n+        }\n+        if (payload.nbf is int) {\n+            introspectionResponse.nbf = <@untainted> <int>payload.nbf;\n+        }\n+        if (payload.sub is string) {\n+            introspectionResponse.sub = <@untainted> <string>payload.sub;\n+        }\n+        if (payload.aud is string) {\n+            introspectionResponse.aud = <@untainted> <string>payload.aud;\n+        }\n+        if (payload.iss is string) {\n+            introspectionResponse.iss = <@untainted> <string>payload.iss;\n+        }\n+        if (payload.jti is string) {\n+            introspectionResponse.jti = <@untainted> <string>payload.jti;\n+        }\n+    }\n+    return introspectionResponse;\n+}\n+\n+function addToCache(cache:Cache oauth2Cache, string token, IntrospectionResponse response,\n+                    int defaultTokenExpTimeInSeconds) {\n+    cache:Error? result;\n+    if (response?.exp is int) {\n+        result = oauth2Cache.put(token, response);\n+    } else {\n+        // If the exp parameter is not set by introspection response, use cache default expiry by\n+        // defaultTokenExpTimeInSeconds. Then the cached value will be removed when retrieving.\n+        result = oauth2Cache.put(token, response, defaultTokenExpTimeInSeconds);\n+    }\n     if (result is cache:Error) {\n         log:printDebug(function() returns string {\n-            return \"Failed to add JWT to the cache\";\n+            return \"Failed to add OAuth2 token to the cache. Introspection response: \" + response.toString();\n         });\n         return;\n     }\n-    if (username is string) {\n-        string user = username;\n+    log:printDebug(function() returns string {\n+        return \"OAuth2 token added to the cache. Introspection response: \" + response.toString();\n+    });\n+}\n+\n+function validateFromCache(cache:Cache oauth2Cache, string token) returns IntrospectionResponse? {\n+    any|cache:Error cachedValue = oauth2Cache.get(token);\n+    if (cachedValue is ()) {\n+        // If the cached value is expired (defaultTokenExpTimeInSeconds is passed), it will return ().\n         log:printDebug(function() returns string {\n-            return \"Add authenticated user: \" + user + \" to the cache.\";\n+            return \"Failed to validate token from from the cache, since token is expired.\";\n         });\n+        return;\n     }\n-}\n-\n-function authenticateFromCache(cache:Cache oauth2Cache, string token) returns InboundOAuth2CacheEntry? {\n-    if (oauth2Cache.hasKey(token)) {\n-        InboundOAuth2CacheEntry oauth2CacheEntry = <InboundOAuth2CacheEntry>oauth2Cache.get(token);\n+    if (cachedValue is cache:Error) {\n         log:printDebug(function() returns string {\n-            return \"Get authenticated user: \" + oauth2CacheEntry.username + \" from the cache.\";\n+            return \"Failed to validate token from from the cache. Cache error: \" + cachedValue.toString();\n         });\n-        return oauth2CacheEntry;\n+        return;\n+    }\n+    IntrospectionResponse response = <IntrospectionResponse>cachedValue;\n+    int? expTime = response?.exp;\n+    // expTime can be (), that means the defaultTokenExpTimeInSeconds is not exceeded yet. Hence the token is still\n+    // valid. Convert to current time and check the expiry time is exceeds if the expTime is int.\n+    if (expTime is () || expTime > (time:currentTime().time / 1000)) {\n+        log:printDebug(function() returns string {\n+            return \"OAuth2 token validated from the cache. Introspection response: \" + response.toString();\n+        });\n+        return response;\n+    } else {\n+        cache:Error? result = oauth2Cache.invalidate(token);\n+        if (result is cache:Error) {\n+            log:printDebug(function() returns string {\n+                return \"Failed to invalidate OAuth2 token from the cache. Introspection response: \" + response.toString();\n+            });\n+        }\n     }\n }\n \n # Reads the scope(s) for the user with the given username.\n #\n # + scopes - Set of scopes seperated with a space\n # + return - Array of groups for the user denoted by the username", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff83dc80c4afbcd940b49c0035b3a0dfbeafc642"}, "originalPosition": 266}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA3MzY5MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            # Represents introspection server onfigurations.\n          \n          \n            \n            # Represents the introspection server configurations.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22917#discussion_r417073691", "createdAt": "2020-04-29T05:25:09Z", "author": {"login": "praneesha"}, "path": "stdlib/oauth2/src/main/ballerina/src/oauth2/inbound_oauth2_provider.bal", "diffHunk": "@@ -60,108 +52,183 @@ public type InboundOAuth2Provider object {\n #\n # + credential - OAuth2 token to be authenticated\n # + return - `true` if authentication is successful, `false` otherwise, or else an `auth:Error` if an error occurred\n-    public function authenticate(string credential) returns boolean|auth:Error {\n+    public function authenticate(string credential) returns @tainted (boolean|auth:Error) {\n         if (credential == \"\") {\n             return false;\n         }\n \n-        cache:Cache? oauth2Cache = self.inboundOAuth2Cache;\n-        if (oauth2Cache is cache:Cache && oauth2Cache.hasKey(credential)) {\n-            InboundOAuth2CacheEntry? oauth2CacheEntry = authenticateFromCache(oauth2Cache, credential);\n-            if (oauth2CacheEntry is InboundOAuth2CacheEntry) {\n+        IntrospectionResponse|Error validationResult = validateOAuth2Token(credential, self.introspectionServerConfig);\n+        if (validationResult is IntrospectionResponse) {\n+            if (validationResult.active) {\n                 auth:setAuthenticationContext(\"oauth2\", credential);\n-                auth:setPrincipal(oauth2CacheEntry.username, oauth2CacheEntry.username,\n-                                  getScopes(oauth2CacheEntry.scopes));\n-                return true;\n+                auth:setPrincipal(validationResult?.username, validationResult?.username,\n+                                  getScopes(validationResult?.scopes));\n             }\n+            return validationResult.active;\n+        } else {\n+            return prepareAuthError(\"OAuth2 validation failed.\", validationResult);\n         }\n+    }\n+};\n \n-        // Build the request to be send to the introspection endpoint.\n-        // Refer: https://tools.ietf.org/html/rfc7662#section-2.1\n-        http:Request req = new;\n-        string textPayload = \"token=\" + credential;\n-        string? tokenTypeHint = self.tokenTypeHint;\n-        if (tokenTypeHint is string) {\n-            textPayload += \"&token_type_hint=\" + tokenTypeHint;\n-        }\n-        req.setTextPayload(textPayload, mime:APPLICATION_FORM_URLENCODED);\n-        http:Response|http:ClientError response = self.introspectionClient->post(\"\", req);\n-        if (response is http:Response) {\n-            json|error result = response.getJsonPayload();\n-            if (result is error) {\n-                return <@untainted> prepareAuthError(result.reason(), result);\n-            }\n-\n-            json payload = <json>result;\n-            boolean active = <boolean>payload.active;\n-            if (active) {\n-                string? username = ();\n-                string? scopes = ();\n-                int exp;\n-\n-                if (payload.username is string) {\n-                    username = <@untainted> <string>payload.username;\n-                }\n-                if (payload.scope is string) {\n-                    scopes = <@untainted> <string>payload.scope;\n-                }\n-                if (payload.exp is int) {\n-                    exp = <@untainted> <int>payload.exp;\n-                } else {\n-                    exp = self.defaultTokenExpTimeInSeconds +  (time:currentTime().time / 1000);\n-                }\n+# Validates the given OAuth2 token.\n+# ```ballerina\n+# oauth2:IntrospectionResponse|oauth2:Error result = oauth2:validateOAuth2Token(token, introspectionServerConfig);\n+# ```\n+#\n+# + token - OAuth2 token that needs to be validated\n+# + config -  OAuth2 introspection server configurations\n+# + return - OAuth2 introspection server response or else a `oauth2:Error` if token validation fails\n+public function validateOAuth2Token(string token, IntrospectionServerConfig config)\n+                                    returns @tainted (IntrospectionResponse|Error) {\n+    cache:Cache? oauth2Cache = config?.oauth2Cache;\n+    if (oauth2Cache is cache:Cache && oauth2Cache.hasKey(token)) {\n+        IntrospectionResponse? response = validateFromCache(oauth2Cache, token);\n+        if (response is IntrospectionResponse) {\n+            return response;\n+        }\n+    }\n \n-                if (oauth2Cache is cache:Cache) {\n-                    addToAuthenticationCache(oauth2Cache, credential, username, scopes, exp);\n-                }\n-                auth:setAuthenticationContext(\"oauth2\", credential);\n-                auth:setPrincipal(username, username, getScopes(scopes ?: \"\"));\n-                return true;\n+    // Build the request to be send to the introspection endpoint.\n+    // Refer: https://tools.ietf.org/html/rfc7662#section-2.1\n+    http:Request req = new;\n+    string textPayload = \"token=\" + token;\n+    string? tokenTypeHint = config?.tokenTypeHint;\n+    if (tokenTypeHint is string) {\n+        textPayload += \"&token_type_hint=\" + tokenTypeHint;\n+    }\n+    req.setTextPayload(textPayload, mime:APPLICATION_FORM_URLENCODED);\n+    http:Client introspectionClient = new(config.url, config.clientConfig);\n+    http:Response|http:ClientError response = introspectionClient->post(\"\", req);\n+    if (response is http:Response) {\n+        json|error result = response.getJsonPayload();\n+        if (result is error) {\n+            return <@untainted> prepareError(result.reason(), result);\n+        }\n+        IntrospectionResponse introspectionResponse = prepareIntrospectionResponse(<json>result);\n+        if (introspectionResponse.active) {\n+            if (oauth2Cache is cache:Cache) {\n+                addToCache(oauth2Cache, token, introspectionResponse, config.defaultTokenExpTimeInSeconds);\n             }\n-            return false;\n-        } else {\n-            return prepareAuthError(\"Failed to call the introspection endpoint.\", response);\n         }\n+        return introspectionResponse;\n+    } else {\n+        return prepareError(\"Failed to call the introspection endpoint.\", response);\n     }\n-};\n+}\n \n-function addToAuthenticationCache(cache:Cache oauth2Cache, string token, string? username, string? scopes, int exp) {\n-    InboundOAuth2CacheEntry oauth2CacheEntry = {username: username ?: \"\", scopes: scopes ?: \"\"};\n-    cache:Error? result = oauth2Cache.put(token, oauth2CacheEntry, exp);\n+function prepareIntrospectionResponse(json payload) returns IntrospectionResponse {\n+    boolean active = <boolean>payload.active;\n+    IntrospectionResponse introspectionResponse = {\n+        active: active\n+    };\n+    if (active) {\n+        if (payload.scope is string) {\n+            introspectionResponse.scopes = <@untainted> <string>payload.scope;\n+        }\n+        if (payload.client_id is string) {\n+            introspectionResponse.clientId = <@untainted> <string>payload.client_id;\n+        }\n+        if (payload.username is string) {\n+            introspectionResponse.username = <@untainted> <string>payload.username;\n+        }\n+        if (payload.token_type is string) {\n+            introspectionResponse.tokenType = <@untainted> <string>payload.token_type;\n+        }\n+        if (payload.exp is int) {\n+            introspectionResponse.exp = <@untainted> <int>payload.exp;\n+        }\n+        if (payload.iat is int) {\n+            introspectionResponse.iat = <@untainted> <int>payload.iat;\n+        }\n+        if (payload.nbf is int) {\n+            introspectionResponse.nbf = <@untainted> <int>payload.nbf;\n+        }\n+        if (payload.sub is string) {\n+            introspectionResponse.sub = <@untainted> <string>payload.sub;\n+        }\n+        if (payload.aud is string) {\n+            introspectionResponse.aud = <@untainted> <string>payload.aud;\n+        }\n+        if (payload.iss is string) {\n+            introspectionResponse.iss = <@untainted> <string>payload.iss;\n+        }\n+        if (payload.jti is string) {\n+            introspectionResponse.jti = <@untainted> <string>payload.jti;\n+        }\n+    }\n+    return introspectionResponse;\n+}\n+\n+function addToCache(cache:Cache oauth2Cache, string token, IntrospectionResponse response,\n+                    int defaultTokenExpTimeInSeconds) {\n+    cache:Error? result;\n+    if (response?.exp is int) {\n+        result = oauth2Cache.put(token, response);\n+    } else {\n+        // If the exp parameter is not set by introspection response, use cache default expiry by\n+        // defaultTokenExpTimeInSeconds. Then the cached value will be removed when retrieving.\n+        result = oauth2Cache.put(token, response, defaultTokenExpTimeInSeconds);\n+    }\n     if (result is cache:Error) {\n         log:printDebug(function() returns string {\n-            return \"Failed to add JWT to the cache\";\n+            return \"Failed to add OAuth2 token to the cache. Introspection response: \" + response.toString();\n         });\n         return;\n     }\n-    if (username is string) {\n-        string user = username;\n+    log:printDebug(function() returns string {\n+        return \"OAuth2 token added to the cache. Introspection response: \" + response.toString();\n+    });\n+}\n+\n+function validateFromCache(cache:Cache oauth2Cache, string token) returns IntrospectionResponse? {\n+    any|cache:Error cachedValue = oauth2Cache.get(token);\n+    if (cachedValue is ()) {\n+        // If the cached value is expired (defaultTokenExpTimeInSeconds is passed), it will return ().\n         log:printDebug(function() returns string {\n-            return \"Add authenticated user: \" + user + \" to the cache.\";\n+            return \"Failed to validate token from from the cache, since token is expired.\";\n         });\n+        return;\n     }\n-}\n-\n-function authenticateFromCache(cache:Cache oauth2Cache, string token) returns InboundOAuth2CacheEntry? {\n-    if (oauth2Cache.hasKey(token)) {\n-        InboundOAuth2CacheEntry oauth2CacheEntry = <InboundOAuth2CacheEntry>oauth2Cache.get(token);\n+    if (cachedValue is cache:Error) {\n         log:printDebug(function() returns string {\n-            return \"Get authenticated user: \" + oauth2CacheEntry.username + \" from the cache.\";\n+            return \"Failed to validate token from from the cache. Cache error: \" + cachedValue.toString();\n         });\n-        return oauth2CacheEntry;\n+        return;\n+    }\n+    IntrospectionResponse response = <IntrospectionResponse>cachedValue;\n+    int? expTime = response?.exp;\n+    // expTime can be (), that means the defaultTokenExpTimeInSeconds is not exceeded yet. Hence the token is still\n+    // valid. Convert to current time and check the expiry time is exceeds if the expTime is int.\n+    if (expTime is () || expTime > (time:currentTime().time / 1000)) {\n+        log:printDebug(function() returns string {\n+            return \"OAuth2 token validated from the cache. Introspection response: \" + response.toString();\n+        });\n+        return response;\n+    } else {\n+        cache:Error? result = oauth2Cache.invalidate(token);\n+        if (result is cache:Error) {\n+            log:printDebug(function() returns string {\n+                return \"Failed to invalidate OAuth2 token from the cache. Introspection response: \" + response.toString();\n+            });\n+        }\n     }\n }\n \n # Reads the scope(s) for the user with the given username.\n #\n # + scopes - Set of scopes seperated with a space\n # + return - Array of groups for the user denoted by the username\n-public function getScopes(string scopes) returns string[] {\n-    string scopeVal = scopes.trim();\n-    if (scopeVal == \"\") {\n+function getScopes(string? scopes) returns string[] {\n+    if (scopes is ()) {\n         return [];\n+    } else {\n+        string scopeVal = scopes.trim();\n+        if (scopeVal == \"\") {\n+            return [];\n+        }\n+        return stringutils:split(scopeVal, \" \");\n     }\n-    return stringutils:split(scopeVal, \" \");\n }\n \n # Represents introspection server onfigurations.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff83dc80c4afbcd940b49c0035b3a0dfbeafc642"}, "originalPosition": 283}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA3MzcyNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            # Represents introspection server response.\n          \n          \n            \n            # Represents the introspection server response.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22917#discussion_r417073725", "createdAt": "2020-04-29T05:25:19Z", "author": {"login": "praneesha"}, "path": "stdlib/oauth2/src/main/ballerina/src/oauth2/inbound_oauth2_provider.bal", "diffHunk": "@@ -179,11 +246,31 @@ public type IntrospectionServerConfig record {|\n     http:ClientConfiguration clientConfig = {};\n |};\n \n-# Represents cached OAuth2 information.\n+# Represents introspection server response.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff83dc80c4afbcd940b49c0035b3a0dfbeafc642"}, "originalPosition": 289}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA3Mzg2MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            # + clientId - Client identifier for the OAuth 2.0 client that requested this token\n          \n          \n            \n            # + clientId - Client identifier for the OAuth 2.0 client, which requested this token", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22917#discussion_r417073861", "createdAt": "2020-04-29T05:25:52Z", "author": {"login": "praneesha"}, "path": "stdlib/oauth2/src/main/ballerina/src/oauth2/inbound_oauth2_provider.bal", "diffHunk": "@@ -179,11 +246,31 @@ public type IntrospectionServerConfig record {|\n     http:ClientConfiguration clientConfig = {};\n |};\n \n-# Represents cached OAuth2 information.\n+# Represents introspection server response.\n #\n-# + username - Username of the OAuth2 validated user\n-# + scopes - Scopes of the OAuth2 validated user\n-public type InboundOAuth2CacheEntry record {|\n-    string username;\n-    string scopes;\n+# + active - Boolean indicator of whether or not the presented token is currently active\n+# + scopes - A JSON string containing a space-separated list of scopes associated with this token\n+# + clientId - Client identifier for the OAuth 2.0 client that requested this token", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff83dc80c4afbcd940b49c0035b3a0dfbeafc642"}, "originalPosition": 298}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA3NDAwNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            # + iat - Token originally issued time (seconds since the Epoch)\n          \n          \n            \n            # + iat - Time when the token was issued originally (seconds since the Epoch)", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22917#discussion_r417074006", "createdAt": "2020-04-29T05:26:20Z", "author": {"login": "praneesha"}, "path": "stdlib/oauth2/src/main/ballerina/src/oauth2/inbound_oauth2_provider.bal", "diffHunk": "@@ -179,11 +246,31 @@ public type IntrospectionServerConfig record {|\n     http:ClientConfiguration clientConfig = {};\n |};\n \n-# Represents cached OAuth2 information.\n+# Represents introspection server response.\n #\n-# + username - Username of the OAuth2 validated user\n-# + scopes - Scopes of the OAuth2 validated user\n-public type InboundOAuth2CacheEntry record {|\n-    string username;\n-    string scopes;\n+# + active - Boolean indicator of whether or not the presented token is currently active\n+# + scopes - A JSON string containing a space-separated list of scopes associated with this token\n+# + clientId - Client identifier for the OAuth 2.0 client that requested this token\n+# + username - Resource owner who authorized this token\n+# + tokenType - Type of the token\n+# + exp - Expiry time (seconds since the Epoch)\n+# + iat - Token originally issued time (seconds since the Epoch)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff83dc80c4afbcd940b49c0035b3a0dfbeafc642"}, "originalPosition": 302}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA3NDA1OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            # + nbf - Token is not to be used before time (seconds since the Epoch)\n          \n          \n            \n            # + nbf - Token is not to be used before this time (seconds since the Epoch)", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22917#discussion_r417074059", "createdAt": "2020-04-29T05:26:33Z", "author": {"login": "praneesha"}, "path": "stdlib/oauth2/src/main/ballerina/src/oauth2/inbound_oauth2_provider.bal", "diffHunk": "@@ -179,11 +246,31 @@ public type IntrospectionServerConfig record {|\n     http:ClientConfiguration clientConfig = {};\n |};\n \n-# Represents cached OAuth2 information.\n+# Represents introspection server response.\n #\n-# + username - Username of the OAuth2 validated user\n-# + scopes - Scopes of the OAuth2 validated user\n-public type InboundOAuth2CacheEntry record {|\n-    string username;\n-    string scopes;\n+# + active - Boolean indicator of whether or not the presented token is currently active\n+# + scopes - A JSON string containing a space-separated list of scopes associated with this token\n+# + clientId - Client identifier for the OAuth 2.0 client that requested this token\n+# + username - Resource owner who authorized this token\n+# + tokenType - Type of the token\n+# + exp - Expiry time (seconds since the Epoch)\n+# + iat - Token originally issued time (seconds since the Epoch)\n+# + nbf - Token is not to be used before time (seconds since the Epoch)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff83dc80c4afbcd940b49c0035b3a0dfbeafc642"}, "originalPosition": 303}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAyMzcyNTg3", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22917#pullrequestreview-402372587", "createdAt": "2020-04-29T05:30:08Z", "commit": {"oid": "ff83dc80c4afbcd940b49c0035b3a0dfbeafc642"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwNTozMDowOFrOGNwPAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwNTozMDowOFrOGNwPAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA3NDk0NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            # Validates the given OAuth2 token.\n          \n          \n            \n            # Validates the given OAuth2 token by calling the OAuth2 introspection endpoint.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22917#discussion_r417074944", "createdAt": "2020-04-29T05:30:08Z", "author": {"login": "ldclakmal"}, "path": "stdlib/oauth2/src/main/ballerina/src/oauth2/inbound_oauth2_provider.bal", "diffHunk": "@@ -60,108 +52,183 @@ public type InboundOAuth2Provider object {\n #\n # + credential - OAuth2 token to be authenticated\n # + return - `true` if authentication is successful, `false` otherwise, or else an `auth:Error` if an error occurred\n-    public function authenticate(string credential) returns boolean|auth:Error {\n+    public function authenticate(string credential) returns @tainted (boolean|auth:Error) {\n         if (credential == \"\") {\n             return false;\n         }\n \n-        cache:Cache? oauth2Cache = self.inboundOAuth2Cache;\n-        if (oauth2Cache is cache:Cache && oauth2Cache.hasKey(credential)) {\n-            InboundOAuth2CacheEntry? oauth2CacheEntry = authenticateFromCache(oauth2Cache, credential);\n-            if (oauth2CacheEntry is InboundOAuth2CacheEntry) {\n+        IntrospectionResponse|Error validationResult = validateOAuth2Token(credential, self.introspectionServerConfig);\n+        if (validationResult is IntrospectionResponse) {\n+            if (validationResult.active) {\n                 auth:setAuthenticationContext(\"oauth2\", credential);\n-                auth:setPrincipal(oauth2CacheEntry.username, oauth2CacheEntry.username,\n-                                  getScopes(oauth2CacheEntry.scopes));\n-                return true;\n+                auth:setPrincipal(validationResult?.username, validationResult?.username,\n+                                  getScopes(validationResult?.scopes));\n             }\n+            return validationResult.active;\n+        } else {\n+            return prepareAuthError(\"OAuth2 validation failed.\", validationResult);\n         }\n+    }\n+};\n \n-        // Build the request to be send to the introspection endpoint.\n-        // Refer: https://tools.ietf.org/html/rfc7662#section-2.1\n-        http:Request req = new;\n-        string textPayload = \"token=\" + credential;\n-        string? tokenTypeHint = self.tokenTypeHint;\n-        if (tokenTypeHint is string) {\n-            textPayload += \"&token_type_hint=\" + tokenTypeHint;\n-        }\n-        req.setTextPayload(textPayload, mime:APPLICATION_FORM_URLENCODED);\n-        http:Response|http:ClientError response = self.introspectionClient->post(\"\", req);\n-        if (response is http:Response) {\n-            json|error result = response.getJsonPayload();\n-            if (result is error) {\n-                return <@untainted> prepareAuthError(result.reason(), result);\n-            }\n-\n-            json payload = <json>result;\n-            boolean active = <boolean>payload.active;\n-            if (active) {\n-                string? username = ();\n-                string? scopes = ();\n-                int exp;\n-\n-                if (payload.username is string) {\n-                    username = <@untainted> <string>payload.username;\n-                }\n-                if (payload.scope is string) {\n-                    scopes = <@untainted> <string>payload.scope;\n-                }\n-                if (payload.exp is int) {\n-                    exp = <@untainted> <int>payload.exp;\n-                } else {\n-                    exp = self.defaultTokenExpTimeInSeconds +  (time:currentTime().time / 1000);\n-                }\n+# Validates the given OAuth2 token.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff83dc80c4afbcd940b49c0035b3a0dfbeafc642"}, "originalPosition": 95}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0eb181f4861e7abc20f3051400ac8dfc608e0d2f", "author": {"user": {"login": "ldclakmal", "name": "Chanaka Lakmal"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/0eb181f4861e7abc20f3051400ac8dfc608e0d2f", "committedDate": "2020-04-29T05:46:57Z", "message": "Refactor code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7ddbcb2ed83a4f05c3e876d31e949e790f6518e1", "author": {"user": {"login": "ldclakmal", "name": "Chanaka Lakmal"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7ddbcb2ed83a4f05c3e876d31e949e790f6518e1", "committedDate": "2020-04-29T05:52:48Z", "message": "Apply suggestions from code review"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d8fae3ac31566f0f8736847fa19e13ccefa6ef2f", "author": {"user": {"login": "ldclakmal", "name": "Chanaka Lakmal"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/d8fae3ac31566f0f8736847fa19e13ccefa6ef2f", "committedDate": "2020-04-29T05:32:25Z", "message": "Apply suggestions from code review\n\nCo-Authored-By: praneesha <praneesha@wso2.com>"}, "afterCommit": {"oid": "7ddbcb2ed83a4f05c3e876d31e949e790f6518e1", "author": {"user": {"login": "ldclakmal", "name": "Chanaka Lakmal"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7ddbcb2ed83a4f05c3e876d31e949e790f6518e1", "committedDate": "2020-04-29T05:52:48Z", "message": "Apply suggestions from code review"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAyNDM1NzMy", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22917#pullrequestreview-402435732", "createdAt": "2020-04-29T07:52:28Z", "commit": {"oid": "7ddbcb2ed83a4f05c3e876d31e949e790f6518e1"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3499, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}