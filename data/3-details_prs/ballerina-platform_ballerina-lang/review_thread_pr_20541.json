{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzU5ODg3ODg4", "number": 20541, "reviewThreads": {"totalCount": 22, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMlQwNjozNDowNFrODXXEMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOVQwNTowNzo1NVrODZBueg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI1ODIxNzQ1OnYy", "diffSide": "RIGHT", "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/impl/KafkaListenerImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMlQwNjozNDowNFrOFcoEmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMlQwNjozNDowNFrOFcoEmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU2MDk4Ng==", "bodyText": "Is NATIVE_CONSUMER_CONFIG always present? Cause otherwise, getNativeData can return Null. Therefore possible NPE.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#discussion_r365560986", "createdAt": "2020-01-12T06:34:04Z", "author": {"login": "grainier"}, "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/impl/KafkaListenerImpl.java", "diffHunk": "@@ -59,8 +70,9 @@ public KafkaListenerImpl(Strand strand, ObjectValue listener, ObjectValue servic\n     @Override\n     public void onRecordsReceived(ConsumerRecords records, KafkaConsumer kafkaConsumer, String groupId) {\n         listener.addNativeData(NATIVE_CONSUMER, kafkaConsumer);\n-        Executor.submit(this.scheduler, service, KAFKA_RESOURCE_ON_MESSAGE, callback,\n-                null, getResourceParameters(service, this.listener, records, groupId));\n+        String url = ((Properties) listener.getNativeData(NATIVE_CONSUMER_CONFIG)).getProperty(BOOTSTRAP_SERVERS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "23fc14a844b861aaa296b4bfbe8c5cc473faa755"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI1ODIxODM2OnYy", "diffSide": "RIGHT", "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/impl/KafkaListenerImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMlQwNjozNzoxM1rOFcoFAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMlQwNjozNzoxM1rOFcoFAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU2MTA4OA==", "bodyText": "Why this line has to repeat all the time? Can't we resolve URL at the init and then re-use it?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#discussion_r365561088", "createdAt": "2020-01-12T06:37:13Z", "author": {"login": "grainier"}, "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/impl/KafkaListenerImpl.java", "diffHunk": "@@ -83,6 +95,38 @@ public void onRecordsReceived(ConsumerRecords records,\n     @Override\n     public void onError(Throwable throwable) {\n         logger.error(\"Kafka Ballerina server connector retrieved exception: \" + throwable.getMessage(), throwable);\n+        String url = ((Properties) listener.getNativeData(NATIVE_CONSUMER_CONFIG)).getProperty(BOOTSTRAP_SERVERS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "23fc14a844b861aaa296b4bfbe8c5cc473faa755"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI1ODIyMDUyOnYy", "diffSide": "RIGHT", "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/impl/KafkaListenerImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMlQwNjo0NTowN1rOFcoGCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMlQwNjo0NTowN1rOFcoGCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU2MTM1NA==", "bodyText": "This is repeated in 120-125. Can't we refactor?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#discussion_r365561354", "createdAt": "2020-01-12T06:45:07Z", "author": {"login": "grainier"}, "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/impl/KafkaListenerImpl.java", "diffHunk": "@@ -83,6 +95,38 @@ public void onRecordsReceived(ConsumerRecords records,\n     @Override\n     public void onError(Throwable throwable) {\n         logger.error(\"Kafka Ballerina server connector retrieved exception: \" + throwable.getMessage(), throwable);\n+        String url = ((Properties) listener.getNativeData(NATIVE_CONSUMER_CONFIG)).getProperty(BOOTSTRAP_SERVERS);\n+        KafkaMetricsUtil.reportConsumerError(url, KafkaObservabilityConstants.ERROR_TYPE_MSG_RECEIVED);\n+    }\n+\n+    private void executeResource(String url, ConsumerRecords records, String groupId) {\n+        if (ObserveUtils.isTracingEnabled()) {\n+            Map<String, Object> properties = new HashMap<>();\n+            KafkaObserverContext observerContext = new KafkaObserverContext(\n+                    KafkaObservabilityConstants.CONTEXT_CONSUMER, url);\n+            properties.put(ObservabilityConstants.KEY_OBSERVER_CONTEXT, observerContext);\n+            Executor.submit(this.scheduler, service, KAFKA_RESOURCE_ON_MESSAGE, callback,\n+                            properties, getResourceParameters(service, this.listener, records, groupId));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "23fc14a844b861aaa296b4bfbe8c5cc473faa755"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI1ODIyMjMxOnYy", "diffSide": "RIGHT", "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/nativeimpl/consumer/Assign.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMlQwNjo0OTo1M1rOFcoG4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMlQwNjo0OTo1M1rOFcoG4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU2MTU3MQ==", "bodyText": "Declare with interface (or super) type.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#discussion_r365561571", "createdAt": "2020-01-12T06:49:53Z", "author": {"login": "grainier"}, "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/nativeimpl/consumer/Assign.java", "diffHunk": "@@ -41,11 +46,14 @@\n     private static final Logger logger = LoggerFactory.getLogger(Assign.class);\n \n     public static Object assign(ObjectValue consumerObject, ArrayValue topicPartitions) {\n+        String bootstrapServers = KafkaUtils.getBootstrapServers(consumerObject);\n+        KafkaTracingUtil.traceResourceInvocation(Scheduler.getStrand(), bootstrapServers);\n         KafkaConsumer<byte[], byte[]> kafkaConsumer = (KafkaConsumer) consumerObject.getNativeData(NATIVE_CONSUMER);\n         ArrayList<TopicPartition> partitions = getTopicPartitionList(topicPartitions, logger);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "23fc14a844b861aaa296b4bfbe8c5cc473faa755"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3MjQzMzg4OnYy", "diffSide": "RIGHT", "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/nativeimpl/consumer/CommitOffset.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwNToxMDoxMVrOFeu_zw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwNToxMDoxMVrOFeu_zw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc3MTU5OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final Logger logger = LoggerFactory.getLogger(Close.class);\n          \n          \n            \n                private static final Logger logger = LoggerFactory.getLogger(CommitOffset.class);", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#discussion_r367771599", "createdAt": "2020-01-17T05:10:11Z", "author": {"login": "chamil321"}, "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/nativeimpl/consumer/CommitOffset.java", "diffHunk": "@@ -49,6 +53,7 @@\n     private static final Logger logger = LoggerFactory.getLogger(Close.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "edbad225b205e517825119ded44a06483595d436"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3MjQzNTc3OnYy", "diffSide": "RIGHT", "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/nativeimpl/consumer/Connect.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwNToxMTo0M1rOFevA3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwNToxMTo0M1rOFevA3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc3MTg2OA==", "bodyText": "Indentation issue?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#discussion_r367771868", "createdAt": "2020-01-17T05:11:43Z", "author": {"login": "chamil321"}, "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/nativeimpl/consumer/Connect.java", "diffHunk": "@@ -46,16 +51,23 @@ public static Object connect(ObjectValue consumerObject) {\n         // Check whether already native consumer is attached to the struct.\n         // This can be happen either from Kafka service or via programmatically.\n         if (Objects.nonNull(consumerObject.getNativeData(NATIVE_CONSUMER))) {\n+            KafkaMetricsUtil.reportConsumerError(consumerObject, KafkaObservabilityConstants.ERROR_TYPE_CONNECTION);\n             return createKafkaError(\"Kafka consumer is already connected to external broker. \" +\n-                    \"Please close it before re-connecting the external broker again.\", CONSUMER_ERROR);\n+                                            \"Please close it before re-connecting the external broker again.\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "edbad225b205e517825119ded44a06483595d436"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3MjQ0ODIwOnYy", "diffSide": "RIGHT", "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/nativeimpl/consumer/SubscribeWithPartitionRebalance.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwNToyMjoxN1rOFevIKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwNzozNzoyOFrOFew1fw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc3MzczNw==", "bodyText": "Ideally the method should be changed to avoid getting Strand as a parameter.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#discussion_r367773737", "createdAt": "2020-01-17T05:22:17Z", "author": {"login": "chamil321"}, "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/nativeimpl/consumer/SubscribeWithPartitionRebalance.java", "diffHunk": "@@ -68,16 +71,19 @@\n \n     public static Object subscribeWithPartitionRebalance(Strand strand, ObjectValue consumerObject, ArrayValue topics,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "edbad225b205e517825119ded44a06483595d436"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc3NDMwOA==", "bodyText": "This should have been done during the kafka - Java interop task. Must have missed", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#discussion_r367774308", "createdAt": "2020-01-17T05:25:35Z", "author": {"login": "chamil321"}, "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/nativeimpl/consumer/SubscribeWithPartitionRebalance.java", "diffHunk": "@@ -68,16 +71,19 @@\n \n     public static Object subscribeWithPartitionRebalance(Strand strand, ObjectValue consumerObject, ArrayValue topics,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc3MzczNw=="}, "originalCommit": {"oid": "edbad225b205e517825119ded44a06483595d436"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzgwMTcyNw==", "bodyText": "This is not changed due to we cannot pass function pointers to an inter-op function (at least then). @aashikam", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#discussion_r367801727", "createdAt": "2020-01-17T07:37:28Z", "author": {"login": "ThisaruGuruge"}, "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/nativeimpl/consumer/SubscribeWithPartitionRebalance.java", "diffHunk": "@@ -68,16 +71,19 @@\n \n     public static Object subscribeWithPartitionRebalance(Strand strand, ObjectValue consumerObject, ArrayValue topics,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc3MzczNw=="}, "originalCommit": {"oid": "edbad225b205e517825119ded44a06483595d436"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3MjQ0OTIzOnYy", "diffSide": "RIGHT", "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/nativeimpl/consumer/SubscribeWithPartitionRebalance.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwNToyMzowNVrOFevIvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwNToyMzowNVrOFevIvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc3Mzg4NQ==", "bodyText": "use Scheduler.getStrand() here as well. The parameter should be avoided", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#discussion_r367773885", "createdAt": "2020-01-17T05:23:05Z", "author": {"login": "chamil321"}, "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/nativeimpl/consumer/SubscribeWithPartitionRebalance.java", "diffHunk": "@@ -68,16 +71,19 @@\n \n     public static Object subscribeWithPartitionRebalance(Strand strand, ObjectValue consumerObject, ArrayValue topics,\n                                                          FPValue onPartitionsRevoked, FPValue onPartitionsAssigned) {\n-\n+        KafkaTracingUtil.traceResourceInvocation(Scheduler.getStrand(), consumerObject);\n         NonBlockingCallback callback = new NonBlockingCallback(strand);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "edbad225b205e517825119ded44a06483595d436"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3MjQ1NTA4OnYy", "diffSide": "RIGHT", "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/observability/KafkaMetricsUtil.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwNToyODowNVrOFevMNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwNToyODowNVrOFevMNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc3NDc3NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Reports a new producer connection.\n          \n          \n            \n                 * Reports a new consumer connection.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#discussion_r367774774", "createdAt": "2020-01-17T05:28:05Z", "author": {"login": "chamil321"}, "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/observability/KafkaMetricsUtil.java", "diffHunk": "@@ -0,0 +1,364 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.ballerinalang.messaging.kafka.observability;\n+\n+import org.apache.kafka.clients.consumer.ConsumerRecord;\n+import org.apache.kafka.clients.consumer.ConsumerRecords;\n+import org.ballerinalang.jvm.observability.ObserveUtils;\n+import org.ballerinalang.jvm.observability.metrics.DefaultMetricRegistry;\n+import org.ballerinalang.jvm.observability.metrics.MetricId;\n+import org.ballerinalang.jvm.observability.metrics.MetricRegistry;\n+import org.ballerinalang.jvm.values.ObjectValue;\n+import org.ballerinalang.messaging.kafka.utils.KafkaUtils;\n+\n+import java.util.Set;\n+\n+/**\n+ * Providing metrics functionality to the Kafka. connector\n+ *\n+ * @since 1.1.0\n+ */\n+public class KafkaMetricsUtil {\n+\n+    private static final MetricRegistry metricRegistry = DefaultMetricRegistry.getInstance();\n+\n+    /**\n+     * Reports a new producer connection.\n+     *\n+     * @param producerObject producerObject.\n+     */\n+    public static void reportNewProducer(ObjectValue producerObject) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_PRODUCER,\n+                                                                        KafkaUtils.getClientId(producerObject),\n+                                                                        KafkaUtils.getBootstrapServers(producerObject));\n+        incrementGauge(observerContext, KafkaObservabilityConstants.METRIC_PUBLISHERS[0],\n+                       KafkaObservabilityConstants.METRIC_PUBLISHERS[1]);\n+    }\n+\n+    /**\n+     * Reports a new producer connection.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "edbad225b205e517825119ded44a06483595d436"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3MjQ3MDU5OnYy", "diffSide": "RIGHT", "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/observability/KafkaMetricsUtil.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwNTo0MjowNlrOFevVgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwNTo0MjowNlrOFevVgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc3NzE1Mg==", "bodyText": "Shall we created separate method for unsetGauge rather having a integer parameter to distinguish the logic?\nIt is more clearer and consistent with other methods.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#discussion_r367777152", "createdAt": "2020-01-17T05:42:06Z", "author": {"login": "chamil321"}, "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/observability/KafkaMetricsUtil.java", "diffHunk": "@@ -0,0 +1,364 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.ballerinalang.messaging.kafka.observability;\n+\n+import org.apache.kafka.clients.consumer.ConsumerRecord;\n+import org.apache.kafka.clients.consumer.ConsumerRecords;\n+import org.ballerinalang.jvm.observability.ObserveUtils;\n+import org.ballerinalang.jvm.observability.metrics.DefaultMetricRegistry;\n+import org.ballerinalang.jvm.observability.metrics.MetricId;\n+import org.ballerinalang.jvm.observability.metrics.MetricRegistry;\n+import org.ballerinalang.jvm.values.ObjectValue;\n+import org.ballerinalang.messaging.kafka.utils.KafkaUtils;\n+\n+import java.util.Set;\n+\n+/**\n+ * Providing metrics functionality to the Kafka. connector\n+ *\n+ * @since 1.1.0\n+ */\n+public class KafkaMetricsUtil {\n+\n+    private static final MetricRegistry metricRegistry = DefaultMetricRegistry.getInstance();\n+\n+    /**\n+     * Reports a new producer connection.\n+     *\n+     * @param producerObject producerObject.\n+     */\n+    public static void reportNewProducer(ObjectValue producerObject) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_PRODUCER,\n+                                                                        KafkaUtils.getClientId(producerObject),\n+                                                                        KafkaUtils.getBootstrapServers(producerObject));\n+        incrementGauge(observerContext, KafkaObservabilityConstants.METRIC_PUBLISHERS[0],\n+                       KafkaObservabilityConstants.METRIC_PUBLISHERS[1]);\n+    }\n+\n+    /**\n+     * Reports a new producer connection.\n+     *\n+     * @param consumerObject consumer object\n+     */\n+    public static void reportNewConsumer(ObjectValue consumerObject) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_CONSUMER,\n+                                                                        KafkaUtils.getClientId(consumerObject),\n+                                                                        KafkaUtils.getBootstrapServers(consumerObject));\n+        incrementGauge(observerContext, KafkaObservabilityConstants.METRIC_CONSUMERS[0],\n+                       KafkaObservabilityConstants.METRIC_CONSUMERS[1]);\n+    }\n+\n+    /**\n+     * Reports a producer disconnection.\n+     *\n+     * @param producerObject producer object.\n+     */\n+    public static void reportProducerClose(ObjectValue producerObject) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_PRODUCER,\n+                                                                        KafkaUtils.getClientId(producerObject),\n+                                                                        KafkaUtils.getBootstrapServers(producerObject));\n+        decrementGauge(observerContext, KafkaObservabilityConstants.METRIC_PUBLISHERS[0],\n+                       KafkaObservabilityConstants.METRIC_PUBLISHERS[1]);\n+    }\n+\n+    /**\n+     * Reports a consumer close.\n+     *\n+     * @param consumerObject consumer object.\n+     */\n+    public static void reportConsumerClose(ObjectValue consumerObject) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_CONSUMER,\n+                                                                        KafkaUtils.getClientId(consumerObject),\n+                                                                        KafkaUtils.getBootstrapServers(consumerObject));\n+        decrementGauge(observerContext, KafkaObservabilityConstants.METRIC_CONSUMERS[0],\n+                       KafkaObservabilityConstants.METRIC_CONSUMERS[1]);\n+    }\n+\n+    /**\n+     * Reports a message being published by a Kafka producer.\n+     *\n+     * @param producerObject  producer object.\n+     * @param topic Subject the message is published to.\n+     * @param size  Size in bytes of the message.\n+     */\n+    public static void reportPublish(ObjectValue producerObject, String topic, int size) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_PRODUCER,\n+                                                                        KafkaUtils.getClientId(producerObject),\n+                                                                        KafkaUtils.getBootstrapServers(producerObject),\n+                                                                        topic);\n+        reportPublish(observerContext, size);\n+    }\n+\n+    /**\n+     * Reports a consumer subscribing to a subject.\n+     *\n+     * @param consumerObject    Consumer object.\n+     * @param topicsList        List of topics that the consumer subscribes to.\n+     */\n+    public static void reportBulkSubscription(ObjectValue consumerObject, Set<String> topicsList) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        for (String topic : topicsList) {\n+            reportSubscription(consumerObject, topic);\n+        }\n+    }\n+\n+\n+    /**\n+     * Reports a consumer subscribing to a topic.\n+     *\n+     * @param consumerObject    Consumer object.\n+     * @param topic             Topic that the consumer subscribes to.\n+     */\n+    public static void reportSubscription(ObjectValue consumerObject, String topic) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_CONSUMER,\n+                                                                        KafkaUtils.getClientId(consumerObject),\n+                                                                        KafkaUtils.getBootstrapServers(consumerObject),\n+                                                                        topic);\n+        setGauge(observerContext, KafkaObservabilityConstants.METRIC_SUBSCRIPTION[0],\n+                       KafkaObservabilityConstants.METRIC_SUBSCRIPTION[1], 1);\n+    }\n+\n+    /**\n+     * Reports a consumer unsubscribing from a subject.\n+     *\n+     * @param consumerObject    Consumer object.\n+     * @param topic             Subject that the consumer unsubscribes from.\n+     */\n+    public static void reportUnsubscription(ObjectValue consumerObject, String topic) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_CONSUMER,\n+                                                                        KafkaUtils.getClientId(consumerObject),\n+                                                                        KafkaUtils.getBootstrapServers(consumerObject),\n+                                                                        topic);\n+        setGauge(observerContext, KafkaObservabilityConstants.METRIC_SUBSCRIPTION[0],", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "edbad225b205e517825119ded44a06483595d436"}, "originalPosition": 171}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3MjQ3NDg3OnYy", "diffSide": "RIGHT", "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/observability/KafkaObservabilityConstants.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwNTo0NjowNlrOFevYHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwNTo0NjowNlrOFevYHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc3NzgyMg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Constants for NATS Observability.\n          \n          \n            \n             * Constants for Kafka Observability.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#discussion_r367777822", "createdAt": "2020-01-17T05:46:06Z", "author": {"login": "chamil321"}, "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/observability/KafkaObservabilityConstants.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.ballerinalang.messaging.kafka.observability;\n+\n+/**\n+ * Constants for NATS Observability.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "edbad225b205e517825119ded44a06483595d436"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3MjQ3NTYxOnYy", "diffSide": "RIGHT", "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/observability/KafkaObserverContext.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwNTo0Njo0OVrOFevYmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwNTo0Njo0OVrOFevYmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc3Nzk0Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Extension of ObserverContext for NATS.\n          \n          \n            \n             * Extension of ObserverContext for Kafka.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#discussion_r367777947", "createdAt": "2020-01-17T05:46:49Z", "author": {"login": "chamil321"}, "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/observability/KafkaObserverContext.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.ballerinalang.messaging.kafka.observability;\n+\n+import org.ballerinalang.jvm.observability.ObserverContext;\n+import org.ballerinalang.jvm.observability.metrics.Tag;\n+import org.ballerinalang.jvm.observability.metrics.Tags;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Extension of ObserverContext for NATS.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "edbad225b205e517825119ded44a06483595d436"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3MzE3MjI5OnYy", "diffSide": "RIGHT", "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/observability/KafkaMetricsUtil.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxMToxMzo0MFrOFe1-XQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxMToxMzo0MFrOFe1-XQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg4NTkxNw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * @since 1.1.0\n          \n          \n            \n             * @since 1.2.0", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#discussion_r367885917", "createdAt": "2020-01-17T11:13:40Z", "author": {"login": "wggihan"}, "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/observability/KafkaMetricsUtil.java", "diffHunk": "@@ -0,0 +1,373 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.ballerinalang.messaging.kafka.observability;\n+\n+import org.apache.kafka.clients.consumer.ConsumerRecord;\n+import org.apache.kafka.clients.consumer.ConsumerRecords;\n+import org.ballerinalang.jvm.observability.ObserveUtils;\n+import org.ballerinalang.jvm.observability.metrics.DefaultMetricRegistry;\n+import org.ballerinalang.jvm.observability.metrics.MetricId;\n+import org.ballerinalang.jvm.observability.metrics.MetricRegistry;\n+import org.ballerinalang.jvm.values.ObjectValue;\n+import org.ballerinalang.messaging.kafka.utils.KafkaUtils;\n+\n+import java.util.Set;\n+\n+/**\n+ * Providing metrics functionality to the Kafka connector.\n+ *\n+ * @since 1.1.0", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dff95d227db71e659b3a9f90678ee7c3d50076f5"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3MzE3NjIyOnYy", "diffSide": "RIGHT", "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/observability/KafkaMetricsUtil.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxMToxNToyNVrOFe2Axw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxMToxNToyNVrOFe2Axw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg4NjUzNQ==", "bodyText": "Extra line.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#discussion_r367886535", "createdAt": "2020-01-17T11:15:25Z", "author": {"login": "wggihan"}, "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/observability/KafkaMetricsUtil.java", "diffHunk": "@@ -0,0 +1,373 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.ballerinalang.messaging.kafka.observability;\n+\n+import org.apache.kafka.clients.consumer.ConsumerRecord;\n+import org.apache.kafka.clients.consumer.ConsumerRecords;\n+import org.ballerinalang.jvm.observability.ObserveUtils;\n+import org.ballerinalang.jvm.observability.metrics.DefaultMetricRegistry;\n+import org.ballerinalang.jvm.observability.metrics.MetricId;\n+import org.ballerinalang.jvm.observability.metrics.MetricRegistry;\n+import org.ballerinalang.jvm.values.ObjectValue;\n+import org.ballerinalang.messaging.kafka.utils.KafkaUtils;\n+\n+import java.util.Set;\n+\n+/**\n+ * Providing metrics functionality to the Kafka connector.\n+ *\n+ * @since 1.1.0\n+ */\n+public class KafkaMetricsUtil {\n+\n+    private static final MetricRegistry metricRegistry = DefaultMetricRegistry.getInstance();\n+\n+    /**\n+     * Reports a new producer connection.\n+     *\n+     * @param producerObject producerObject.\n+     */\n+    public static void reportNewProducer(ObjectValue producerObject) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_PRODUCER,\n+                                                                        KafkaUtils.getClientId(producerObject),\n+                                                                        KafkaUtils.getBootstrapServers(producerObject));\n+        incrementGauge(observerContext, KafkaObservabilityConstants.METRIC_PUBLISHERS[0],\n+                       KafkaObservabilityConstants.METRIC_PUBLISHERS[1]);\n+    }\n+\n+    /**\n+     * Reports a new consumer connection.\n+     *\n+     * @param consumerObject consumer object\n+     */\n+    public static void reportNewConsumer(ObjectValue consumerObject) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_CONSUMER,\n+                                                                        KafkaUtils.getClientId(consumerObject),\n+                                                                        KafkaUtils.getBootstrapServers(consumerObject));\n+        incrementGauge(observerContext, KafkaObservabilityConstants.METRIC_CONSUMERS[0],\n+                       KafkaObservabilityConstants.METRIC_CONSUMERS[1]);\n+    }\n+\n+    /**\n+     * Reports a producer disconnection.\n+     *\n+     * @param producerObject producer object.\n+     */\n+    public static void reportProducerClose(ObjectValue producerObject) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_PRODUCER,\n+                                                                        KafkaUtils.getClientId(producerObject),\n+                                                                        KafkaUtils.getBootstrapServers(producerObject));\n+        decrementGauge(observerContext, KafkaObservabilityConstants.METRIC_PUBLISHERS[0],\n+                       KafkaObservabilityConstants.METRIC_PUBLISHERS[1]);\n+    }\n+\n+    /**\n+     * Reports a consumer close.\n+     *\n+     * @param consumerObject consumer object.\n+     */\n+    public static void reportConsumerClose(ObjectValue consumerObject) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_CONSUMER,\n+                                                                        KafkaUtils.getClientId(consumerObject),\n+                                                                        KafkaUtils.getBootstrapServers(consumerObject));\n+        decrementGauge(observerContext, KafkaObservabilityConstants.METRIC_CONSUMERS[0],\n+                       KafkaObservabilityConstants.METRIC_CONSUMERS[1]);\n+    }\n+\n+    /**\n+     * Reports a message being published by a Kafka producer.\n+     *\n+     * @param producerObject  producer object.\n+     * @param topic Subject the message is published to.\n+     * @param size  Size in bytes of the message.\n+     */\n+    public static void reportPublish(ObjectValue producerObject, String topic, int size) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_PRODUCER,\n+                                                                        KafkaUtils.getClientId(producerObject),\n+                                                                        KafkaUtils.getBootstrapServers(producerObject),\n+                                                                        topic);\n+        reportPublish(observerContext, size);\n+    }\n+\n+    /**\n+     * Reports a consumer subscribing to a subject.\n+     *\n+     * @param consumerObject    Consumer object.\n+     * @param topicsList        List of topics that the consumer subscribes to.\n+     */\n+    public static void reportBulkSubscription(ObjectValue consumerObject, Set<String> topicsList) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        for (String topic : topicsList) {\n+            reportSubscription(consumerObject, topic);\n+        }\n+    }\n+\n+\n+    /**\n+     * Reports a consumer subscribing to a topic.\n+     *\n+     * @param consumerObject    Consumer object.\n+     * @param topic             Topic that the consumer subscribes to.\n+     */\n+    public static void reportSubscription(ObjectValue consumerObject, String topic) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_CONSUMER,\n+                                                                        KafkaUtils.getClientId(consumerObject),\n+                                                                        KafkaUtils.getBootstrapServers(consumerObject),\n+                                                                        topic);\n+        setGauge(observerContext, KafkaObservabilityConstants.METRIC_SUBSCRIPTION[0],\n+                       KafkaObservabilityConstants.METRIC_SUBSCRIPTION[1], 1);\n+    }\n+\n+    /**\n+     * Reports a consumer unsubscribing from a subject.\n+     *\n+     * @param consumerObject    Consumer object.\n+     * @param topic             Subject that the consumer unsubscribes from.\n+     */\n+    public static void reportUnsubscription(ObjectValue consumerObject, String topic) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_CONSUMER,\n+                                                                        KafkaUtils.getClientId(consumerObject),\n+                                                                        KafkaUtils.getBootstrapServers(consumerObject),\n+                                                                        topic);\n+        resetGauge(observerContext, KafkaObservabilityConstants.METRIC_SUBSCRIPTION[0],\n+                       KafkaObservabilityConstants.METRIC_SUBSCRIPTION[1]);\n+    }\n+\n+    /**\n+     * Reports a consumer unsubscribing from multiple topics.\n+     *\n+     * @param consumerObject    Consumer object.\n+     * @param topics            Subjects that the consumer unsubscribes from.\n+     */\n+    public static void reportBulkUnsubscription(ObjectValue consumerObject, Set<String> topics) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        for (String subject : topics) {\n+            KafkaMetricsUtil.reportUnsubscription(consumerObject, subject);\n+        }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dff95d227db71e659b3a9f90678ee7c3d50076f5"}, "originalPosition": 188}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3MzE3ODQ3OnYy", "diffSide": "RIGHT", "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/observability/KafkaMetricsUtil.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxMToxNjoyMFrOFe2CMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxMToxNjoyMFrOFe2CMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg4Njg5Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Reports a consumer consuming a message.\n          \n          \n            \n                 * Reports a message consumption of the consumer.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#discussion_r367886897", "createdAt": "2020-01-17T11:16:20Z", "author": {"login": "wggihan"}, "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/observability/KafkaMetricsUtil.java", "diffHunk": "@@ -0,0 +1,373 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.ballerinalang.messaging.kafka.observability;\n+\n+import org.apache.kafka.clients.consumer.ConsumerRecord;\n+import org.apache.kafka.clients.consumer.ConsumerRecords;\n+import org.ballerinalang.jvm.observability.ObserveUtils;\n+import org.ballerinalang.jvm.observability.metrics.DefaultMetricRegistry;\n+import org.ballerinalang.jvm.observability.metrics.MetricId;\n+import org.ballerinalang.jvm.observability.metrics.MetricRegistry;\n+import org.ballerinalang.jvm.values.ObjectValue;\n+import org.ballerinalang.messaging.kafka.utils.KafkaUtils;\n+\n+import java.util.Set;\n+\n+/**\n+ * Providing metrics functionality to the Kafka connector.\n+ *\n+ * @since 1.1.0\n+ */\n+public class KafkaMetricsUtil {\n+\n+    private static final MetricRegistry metricRegistry = DefaultMetricRegistry.getInstance();\n+\n+    /**\n+     * Reports a new producer connection.\n+     *\n+     * @param producerObject producerObject.\n+     */\n+    public static void reportNewProducer(ObjectValue producerObject) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_PRODUCER,\n+                                                                        KafkaUtils.getClientId(producerObject),\n+                                                                        KafkaUtils.getBootstrapServers(producerObject));\n+        incrementGauge(observerContext, KafkaObservabilityConstants.METRIC_PUBLISHERS[0],\n+                       KafkaObservabilityConstants.METRIC_PUBLISHERS[1]);\n+    }\n+\n+    /**\n+     * Reports a new consumer connection.\n+     *\n+     * @param consumerObject consumer object\n+     */\n+    public static void reportNewConsumer(ObjectValue consumerObject) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_CONSUMER,\n+                                                                        KafkaUtils.getClientId(consumerObject),\n+                                                                        KafkaUtils.getBootstrapServers(consumerObject));\n+        incrementGauge(observerContext, KafkaObservabilityConstants.METRIC_CONSUMERS[0],\n+                       KafkaObservabilityConstants.METRIC_CONSUMERS[1]);\n+    }\n+\n+    /**\n+     * Reports a producer disconnection.\n+     *\n+     * @param producerObject producer object.\n+     */\n+    public static void reportProducerClose(ObjectValue producerObject) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_PRODUCER,\n+                                                                        KafkaUtils.getClientId(producerObject),\n+                                                                        KafkaUtils.getBootstrapServers(producerObject));\n+        decrementGauge(observerContext, KafkaObservabilityConstants.METRIC_PUBLISHERS[0],\n+                       KafkaObservabilityConstants.METRIC_PUBLISHERS[1]);\n+    }\n+\n+    /**\n+     * Reports a consumer close.\n+     *\n+     * @param consumerObject consumer object.\n+     */\n+    public static void reportConsumerClose(ObjectValue consumerObject) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_CONSUMER,\n+                                                                        KafkaUtils.getClientId(consumerObject),\n+                                                                        KafkaUtils.getBootstrapServers(consumerObject));\n+        decrementGauge(observerContext, KafkaObservabilityConstants.METRIC_CONSUMERS[0],\n+                       KafkaObservabilityConstants.METRIC_CONSUMERS[1]);\n+    }\n+\n+    /**\n+     * Reports a message being published by a Kafka producer.\n+     *\n+     * @param producerObject  producer object.\n+     * @param topic Subject the message is published to.\n+     * @param size  Size in bytes of the message.\n+     */\n+    public static void reportPublish(ObjectValue producerObject, String topic, int size) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_PRODUCER,\n+                                                                        KafkaUtils.getClientId(producerObject),\n+                                                                        KafkaUtils.getBootstrapServers(producerObject),\n+                                                                        topic);\n+        reportPublish(observerContext, size);\n+    }\n+\n+    /**\n+     * Reports a consumer subscribing to a subject.\n+     *\n+     * @param consumerObject    Consumer object.\n+     * @param topicsList        List of topics that the consumer subscribes to.\n+     */\n+    public static void reportBulkSubscription(ObjectValue consumerObject, Set<String> topicsList) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        for (String topic : topicsList) {\n+            reportSubscription(consumerObject, topic);\n+        }\n+    }\n+\n+\n+    /**\n+     * Reports a consumer subscribing to a topic.\n+     *\n+     * @param consumerObject    Consumer object.\n+     * @param topic             Topic that the consumer subscribes to.\n+     */\n+    public static void reportSubscription(ObjectValue consumerObject, String topic) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_CONSUMER,\n+                                                                        KafkaUtils.getClientId(consumerObject),\n+                                                                        KafkaUtils.getBootstrapServers(consumerObject),\n+                                                                        topic);\n+        setGauge(observerContext, KafkaObservabilityConstants.METRIC_SUBSCRIPTION[0],\n+                       KafkaObservabilityConstants.METRIC_SUBSCRIPTION[1], 1);\n+    }\n+\n+    /**\n+     * Reports a consumer unsubscribing from a subject.\n+     *\n+     * @param consumerObject    Consumer object.\n+     * @param topic             Subject that the consumer unsubscribes from.\n+     */\n+    public static void reportUnsubscription(ObjectValue consumerObject, String topic) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_CONSUMER,\n+                                                                        KafkaUtils.getClientId(consumerObject),\n+                                                                        KafkaUtils.getBootstrapServers(consumerObject),\n+                                                                        topic);\n+        resetGauge(observerContext, KafkaObservabilityConstants.METRIC_SUBSCRIPTION[0],\n+                       KafkaObservabilityConstants.METRIC_SUBSCRIPTION[1]);\n+    }\n+\n+    /**\n+     * Reports a consumer unsubscribing from multiple topics.\n+     *\n+     * @param consumerObject    Consumer object.\n+     * @param topics            Subjects that the consumer unsubscribes from.\n+     */\n+    public static void reportBulkUnsubscription(ObjectValue consumerObject, Set<String> topics) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        for (String subject : topics) {\n+            KafkaMetricsUtil.reportUnsubscription(consumerObject, subject);\n+        }\n+\n+    }\n+\n+    /**\n+     * Reports a consumer consuming a message.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dff95d227db71e659b3a9f90678ee7c3d50076f5"}, "originalPosition": 192}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3MzE4MzA2OnYy", "diffSide": "RIGHT", "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/observability/KafkaObservabilityConstants.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxMToxODoxMFrOFe2E9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxMToxODoxMFrOFe2E9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg4NzYwNw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * @since 1.1.0\n          \n          \n            \n             * @since 1.2.0", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#discussion_r367887607", "createdAt": "2020-01-17T11:18:10Z", "author": {"login": "wggihan"}, "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/observability/KafkaObservabilityConstants.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.ballerinalang.messaging.kafka.observability;\n+\n+/**\n+ * Constants for Kafka Observability.\n+ *\n+ * @since 1.1.0", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dff95d227db71e659b3a9f90678ee7c3d50076f5"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3MzE4Mzg5OnYy", "diffSide": "RIGHT", "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/observability/KafkaObserverContext.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxMToxODozNVrOFe2Ffg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxMToxODozNVrOFe2Ffg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg4Nzc0Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * @since 1.1.0\n          \n          \n            \n             * @since 1.2.0", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#discussion_r367887742", "createdAt": "2020-01-17T11:18:35Z", "author": {"login": "wggihan"}, "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/observability/KafkaObserverContext.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.ballerinalang.messaging.kafka.observability;\n+\n+import org.ballerinalang.jvm.observability.ObserverContext;\n+import org.ballerinalang.jvm.observability.metrics.Tag;\n+import org.ballerinalang.jvm.observability.metrics.Tags;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Extension of ObserverContext for Kafka.\n+ *\n+ * @since 1.1.0", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dff95d227db71e659b3a9f90678ee7c3d50076f5"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3MzE4NTA4OnYy", "diffSide": "RIGHT", "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/observability/KafkaTracingUtil.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxMToxOTowNlrOFe2GQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxMToxOTowNlrOFe2GQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg4NzkzNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * @since 1.1.0\n          \n          \n            \n             * @since 1.2.0", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#discussion_r367887936", "createdAt": "2020-01-17T11:19:06Z", "author": {"login": "wggihan"}, "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/observability/KafkaTracingUtil.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.ballerinalang.messaging.kafka.observability;\n+\n+import org.ballerinalang.jvm.observability.ObserveUtils;\n+import org.ballerinalang.jvm.observability.ObserverContext;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.values.ObjectValue;\n+import org.ballerinalang.messaging.kafka.utils.KafkaUtils;\n+\n+import java.util.Optional;\n+\n+/**\n+ * Providing tracing functionality to Kafka.\n+ *\n+ * @since 1.1.0", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dff95d227db71e659b3a9f90678ee7c3d50076f5"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3MzIwMjgzOnYy", "diffSide": "RIGHT", "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/utils/KafkaUtils.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxMToyNjoxOVrOFe2Q-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxMToyNjoxOVrOFe2Q-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg5MDY4MA==", "bodyText": "Don't catch NPE. Handle null value. Apply to other places as well.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#discussion_r367890680", "createdAt": "2020-01-17T11:26:19Z", "author": {"login": "wggihan"}, "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/utils/KafkaUtils.java", "diffHunk": "@@ -689,4 +695,34 @@ public static String getBrokerNames(ObjectValue listener) {\n     public static String getTopicNamesString(ArrayList<String> topicsList) {\n         return String.join(\", \", topicsList);\n     }\n+\n+    public static String getClientIdFromProperties(Properties properties) {\n+        String clientId = properties.getProperty(KafkaConstants.CLIENT_ID);\n+        if (clientId == null) {\n+            return KafkaObservabilityConstants.UNKNOWN;\n+        }\n+        return  clientId;\n+    }\n+\n+    public static String getBootstrapServers(ObjectValue object) {\n+        try {\n+            return (String) object.getNativeData(KafkaConstants.BOOTSTRAP_SERVERS);\n+        } catch (NullPointerException ex) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dff95d227db71e659b3a9f90678ee7c3d50076f5"}, "originalPosition": 362}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3MzQ1ODkzOnYy", "diffSide": "RIGHT", "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/utils/KafkaUtils.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxMzoxNzo1N1rOFe4rpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxMzoxNzo1N1rOFe4rpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkzMDI3OQ==", "bodyText": "Extra line.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#discussion_r367930279", "createdAt": "2020-01-17T13:17:57Z", "author": {"login": "wggihan"}, "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/utils/KafkaUtils.java", "diffHunk": "@@ -689,4 +695,39 @@ public static String getBrokerNames(ObjectValue listener) {\n     public static String getTopicNamesString(ArrayList<String> topicsList) {\n         return String.join(\", \", topicsList);\n     }\n+\n+    public static String getClientIdFromProperties(Properties properties) {\n+        if (properties == null) {\n+            return KafkaObservabilityConstants.UNKNOWN;\n+        }\n+        String clientId = properties.getProperty(KafkaConstants.CLIENT_ID);\n+        if (clientId == null) {\n+            return KafkaObservabilityConstants.UNKNOWN;\n+        }\n+        return  clientId;\n+    }\n+\n+    public static String getBootstrapServers(ObjectValue object) {\n+        if (object == null) {\n+            return KafkaObservabilityConstants.UNKNOWN;\n+        }\n+        String bootstrapServers = (String) object.getNativeData(KafkaConstants.BOOTSTRAP_SERVERS);\n+        if (bootstrapServers == null) {\n+            return KafkaObservabilityConstants.UNKNOWN;\n+        }\n+        return bootstrapServers;\n+    }\n+\n+    public static String getClientId(ObjectValue object) {\n+        if (object == null) {\n+            return KafkaObservabilityConstants.UNKNOWN;\n+        }\n+        String clientId = (String) object.getNativeData(KafkaConstants.CLIENT_ID);\n+        if (clientId == null) {\n+            return KafkaObservabilityConstants.UNKNOWN;\n+        }\n+        return clientId;\n+    }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "686745345044b18037d8f38ab3480fab94f4dfa1"}, "originalPosition": 383}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NTY5MjY1OnYy", "diffSide": "RIGHT", "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/observability/KafkaMetricsUtil.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOVQwNTowNzoyOVrOFfNMLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOVQwNTowNzoyOVrOFfNMLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI2NjI4NA==", "bodyText": "Extra empty line?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#discussion_r368266284", "createdAt": "2020-01-19T05:07:29Z", "author": {"login": "ThisaruGuruge"}, "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/observability/KafkaMetricsUtil.java", "diffHunk": "@@ -0,0 +1,372 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.ballerinalang.messaging.kafka.observability;\n+\n+import org.apache.kafka.clients.consumer.ConsumerRecord;\n+import org.apache.kafka.clients.consumer.ConsumerRecords;\n+import org.ballerinalang.jvm.observability.ObserveUtils;\n+import org.ballerinalang.jvm.observability.metrics.DefaultMetricRegistry;\n+import org.ballerinalang.jvm.observability.metrics.MetricId;\n+import org.ballerinalang.jvm.observability.metrics.MetricRegistry;\n+import org.ballerinalang.jvm.values.ObjectValue;\n+import org.ballerinalang.messaging.kafka.utils.KafkaUtils;\n+\n+import java.util.Set;\n+\n+/**\n+ * Providing metrics functionality to the Kafka connector.\n+ *\n+ * @since 1.2.0\n+ */\n+public class KafkaMetricsUtil {\n+\n+    private static final MetricRegistry metricRegistry = DefaultMetricRegistry.getInstance();\n+\n+    /**\n+     * Reports a new producer connection.\n+     *\n+     * @param producerObject producerObject.\n+     */\n+    public static void reportNewProducer(ObjectValue producerObject) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_PRODUCER,\n+                                                                        KafkaUtils.getClientId(producerObject),\n+                                                                        KafkaUtils.getBootstrapServers(producerObject));\n+        incrementGauge(observerContext, KafkaObservabilityConstants.METRIC_PUBLISHERS[0],\n+                       KafkaObservabilityConstants.METRIC_PUBLISHERS[1]);\n+    }\n+\n+    /**\n+     * Reports a new consumer connection.\n+     *\n+     * @param consumerObject consumer object\n+     */\n+    public static void reportNewConsumer(ObjectValue consumerObject) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_CONSUMER,\n+                                                                        KafkaUtils.getClientId(consumerObject),\n+                                                                        KafkaUtils.getBootstrapServers(consumerObject));\n+        incrementGauge(observerContext, KafkaObservabilityConstants.METRIC_CONSUMERS[0],\n+                       KafkaObservabilityConstants.METRIC_CONSUMERS[1]);\n+    }\n+\n+    /**\n+     * Reports a producer disconnection.\n+     *\n+     * @param producerObject producer object.\n+     */\n+    public static void reportProducerClose(ObjectValue producerObject) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_PRODUCER,\n+                                                                        KafkaUtils.getClientId(producerObject),\n+                                                                        KafkaUtils.getBootstrapServers(producerObject));\n+        decrementGauge(observerContext, KafkaObservabilityConstants.METRIC_PUBLISHERS[0],\n+                       KafkaObservabilityConstants.METRIC_PUBLISHERS[1]);\n+    }\n+\n+    /**\n+     * Reports a consumer close.\n+     *\n+     * @param consumerObject consumer object.\n+     */\n+    public static void reportConsumerClose(ObjectValue consumerObject) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_CONSUMER,\n+                                                                        KafkaUtils.getClientId(consumerObject),\n+                                                                        KafkaUtils.getBootstrapServers(consumerObject));\n+        decrementGauge(observerContext, KafkaObservabilityConstants.METRIC_CONSUMERS[0],\n+                       KafkaObservabilityConstants.METRIC_CONSUMERS[1]);\n+    }\n+\n+    /**\n+     * Reports a message being published by a Kafka producer.\n+     *\n+     * @param producerObject  producer object.\n+     * @param topic Subject the message is published to.\n+     * @param size  Size in bytes of the message.\n+     */\n+    public static void reportPublish(ObjectValue producerObject, String topic, int size) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_PRODUCER,\n+                                                                        KafkaUtils.getClientId(producerObject),\n+                                                                        KafkaUtils.getBootstrapServers(producerObject),\n+                                                                        topic);\n+        reportPublish(observerContext, size);\n+    }\n+\n+    /**\n+     * Reports a consumer subscribing to a subject.\n+     *\n+     * @param consumerObject    Consumer object.\n+     * @param topicsList        List of topics that the consumer subscribes to.\n+     */\n+    public static void reportBulkSubscription(ObjectValue consumerObject, Set<String> topicsList) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        for (String topic : topicsList) {\n+            reportSubscription(consumerObject, topic);\n+        }\n+    }\n+\n+\n+    /**\n+     * Reports a consumer subscribing to a topic.\n+     *\n+     * @param consumerObject    Consumer object.\n+     * @param topic             Topic that the consumer subscribes to.\n+     */\n+    public static void reportSubscription(ObjectValue consumerObject, String topic) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_CONSUMER,\n+                                                                        KafkaUtils.getClientId(consumerObject),\n+                                                                        KafkaUtils.getBootstrapServers(consumerObject),\n+                                                                        topic);\n+        setGauge(observerContext, KafkaObservabilityConstants.METRIC_SUBSCRIPTION[0],\n+                       KafkaObservabilityConstants.METRIC_SUBSCRIPTION[1], 1);\n+    }\n+\n+    /**\n+     * Reports a consumer unsubscribing from a subject.\n+     *\n+     * @param consumerObject    Consumer object.\n+     * @param topic             Subject that the consumer unsubscribes from.\n+     */\n+    public static void reportUnsubscription(ObjectValue consumerObject, String topic) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_CONSUMER,\n+                                                                        KafkaUtils.getClientId(consumerObject),\n+                                                                        KafkaUtils.getBootstrapServers(consumerObject),\n+                                                                        topic);\n+        resetGauge(observerContext, KafkaObservabilityConstants.METRIC_SUBSCRIPTION[0],\n+                       KafkaObservabilityConstants.METRIC_SUBSCRIPTION[1]);\n+    }\n+\n+    /**\n+     * Reports a consumer unsubscribing from multiple topics.\n+     *\n+     * @param consumerObject    Consumer object.\n+     * @param topics            Subjects that the consumer unsubscribes from.\n+     */\n+    public static void reportBulkUnsubscription(ObjectValue consumerObject, Set<String> topics) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        for (String subject : topics) {\n+            KafkaMetricsUtil.reportUnsubscription(consumerObject, subject);\n+        }\n+    }\n+\n+    /**\n+     * Reports a message consumption of a consumer.\n+     *\n+     * @param consumerObject    Consumer object.\n+     * @param topic             Subject that the consumer receives the message from.\n+     * @param size              Size of the message in bytes.\n+     */\n+    public static void reportConsume(ObjectValue consumerObject, String topic, int size) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_CONSUMER,\n+                                                                        KafkaUtils.getClientId(consumerObject),\n+                                                                        KafkaUtils.getBootstrapServers(consumerObject),\n+                                                                        topic);\n+        reportConsume(observerContext, size);\n+    }\n+\n+    /**\n+     * Reports a consumer consuming a record of messages.\n+     *\n+     * @param consumerObject    Consumer object.\n+     * @param records           Records\n+     */\n+    public static void reportConsume(ObjectValue consumerObject, ConsumerRecords records) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        records.forEach(record -> {\n+            KafkaMetricsUtil.reportConsume(consumerObject, ((ConsumerRecord) record).topic(),\n+                                           ((ConsumerRecord) record).serializedValueSize());\n+        });\n+    }\n+\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "686745345044b18037d8f38ab3480fab94f4dfa1"}, "originalPosition": 224}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NTY5Mjc0OnYy", "diffSide": "RIGHT", "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/observability/KafkaMetricsUtil.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOVQwNTowNzo1NVrOFfNMNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOVQwNTowNzo1NVrOFfNMNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI2NjI5NA==", "bodyText": "Extra empty line?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#discussion_r368266294", "createdAt": "2020-01-19T05:07:55Z", "author": {"login": "ThisaruGuruge"}, "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/observability/KafkaMetricsUtil.java", "diffHunk": "@@ -0,0 +1,372 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.ballerinalang.messaging.kafka.observability;\n+\n+import org.apache.kafka.clients.consumer.ConsumerRecord;\n+import org.apache.kafka.clients.consumer.ConsumerRecords;\n+import org.ballerinalang.jvm.observability.ObserveUtils;\n+import org.ballerinalang.jvm.observability.metrics.DefaultMetricRegistry;\n+import org.ballerinalang.jvm.observability.metrics.MetricId;\n+import org.ballerinalang.jvm.observability.metrics.MetricRegistry;\n+import org.ballerinalang.jvm.values.ObjectValue;\n+import org.ballerinalang.messaging.kafka.utils.KafkaUtils;\n+\n+import java.util.Set;\n+\n+/**\n+ * Providing metrics functionality to the Kafka connector.\n+ *\n+ * @since 1.2.0\n+ */\n+public class KafkaMetricsUtil {\n+\n+    private static final MetricRegistry metricRegistry = DefaultMetricRegistry.getInstance();\n+\n+    /**\n+     * Reports a new producer connection.\n+     *\n+     * @param producerObject producerObject.\n+     */\n+    public static void reportNewProducer(ObjectValue producerObject) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_PRODUCER,\n+                                                                        KafkaUtils.getClientId(producerObject),\n+                                                                        KafkaUtils.getBootstrapServers(producerObject));\n+        incrementGauge(observerContext, KafkaObservabilityConstants.METRIC_PUBLISHERS[0],\n+                       KafkaObservabilityConstants.METRIC_PUBLISHERS[1]);\n+    }\n+\n+    /**\n+     * Reports a new consumer connection.\n+     *\n+     * @param consumerObject consumer object\n+     */\n+    public static void reportNewConsumer(ObjectValue consumerObject) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_CONSUMER,\n+                                                                        KafkaUtils.getClientId(consumerObject),\n+                                                                        KafkaUtils.getBootstrapServers(consumerObject));\n+        incrementGauge(observerContext, KafkaObservabilityConstants.METRIC_CONSUMERS[0],\n+                       KafkaObservabilityConstants.METRIC_CONSUMERS[1]);\n+    }\n+\n+    /**\n+     * Reports a producer disconnection.\n+     *\n+     * @param producerObject producer object.\n+     */\n+    public static void reportProducerClose(ObjectValue producerObject) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_PRODUCER,\n+                                                                        KafkaUtils.getClientId(producerObject),\n+                                                                        KafkaUtils.getBootstrapServers(producerObject));\n+        decrementGauge(observerContext, KafkaObservabilityConstants.METRIC_PUBLISHERS[0],\n+                       KafkaObservabilityConstants.METRIC_PUBLISHERS[1]);\n+    }\n+\n+    /**\n+     * Reports a consumer close.\n+     *\n+     * @param consumerObject consumer object.\n+     */\n+    public static void reportConsumerClose(ObjectValue consumerObject) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_CONSUMER,\n+                                                                        KafkaUtils.getClientId(consumerObject),\n+                                                                        KafkaUtils.getBootstrapServers(consumerObject));\n+        decrementGauge(observerContext, KafkaObservabilityConstants.METRIC_CONSUMERS[0],\n+                       KafkaObservabilityConstants.METRIC_CONSUMERS[1]);\n+    }\n+\n+    /**\n+     * Reports a message being published by a Kafka producer.\n+     *\n+     * @param producerObject  producer object.\n+     * @param topic Subject the message is published to.\n+     * @param size  Size in bytes of the message.\n+     */\n+    public static void reportPublish(ObjectValue producerObject, String topic, int size) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_PRODUCER,\n+                                                                        KafkaUtils.getClientId(producerObject),\n+                                                                        KafkaUtils.getBootstrapServers(producerObject),\n+                                                                        topic);\n+        reportPublish(observerContext, size);\n+    }\n+\n+    /**\n+     * Reports a consumer subscribing to a subject.\n+     *\n+     * @param consumerObject    Consumer object.\n+     * @param topicsList        List of topics that the consumer subscribes to.\n+     */\n+    public static void reportBulkSubscription(ObjectValue consumerObject, Set<String> topicsList) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        for (String topic : topicsList) {\n+            reportSubscription(consumerObject, topic);\n+        }\n+    }\n+\n+\n+    /**\n+     * Reports a consumer subscribing to a topic.\n+     *\n+     * @param consumerObject    Consumer object.\n+     * @param topic             Topic that the consumer subscribes to.\n+     */\n+    public static void reportSubscription(ObjectValue consumerObject, String topic) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_CONSUMER,\n+                                                                        KafkaUtils.getClientId(consumerObject),\n+                                                                        KafkaUtils.getBootstrapServers(consumerObject),\n+                                                                        topic);\n+        setGauge(observerContext, KafkaObservabilityConstants.METRIC_SUBSCRIPTION[0],\n+                       KafkaObservabilityConstants.METRIC_SUBSCRIPTION[1], 1);\n+    }\n+\n+    /**\n+     * Reports a consumer unsubscribing from a subject.\n+     *\n+     * @param consumerObject    Consumer object.\n+     * @param topic             Subject that the consumer unsubscribes from.\n+     */\n+    public static void reportUnsubscription(ObjectValue consumerObject, String topic) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_CONSUMER,\n+                                                                        KafkaUtils.getClientId(consumerObject),\n+                                                                        KafkaUtils.getBootstrapServers(consumerObject),\n+                                                                        topic);\n+        resetGauge(observerContext, KafkaObservabilityConstants.METRIC_SUBSCRIPTION[0],\n+                       KafkaObservabilityConstants.METRIC_SUBSCRIPTION[1]);\n+    }\n+\n+    /**\n+     * Reports a consumer unsubscribing from multiple topics.\n+     *\n+     * @param consumerObject    Consumer object.\n+     * @param topics            Subjects that the consumer unsubscribes from.\n+     */\n+    public static void reportBulkUnsubscription(ObjectValue consumerObject, Set<String> topics) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        for (String subject : topics) {\n+            KafkaMetricsUtil.reportUnsubscription(consumerObject, subject);\n+        }\n+    }\n+\n+    /**\n+     * Reports a message consumption of a consumer.\n+     *\n+     * @param consumerObject    Consumer object.\n+     * @param topic             Subject that the consumer receives the message from.\n+     * @param size              Size of the message in bytes.\n+     */\n+    public static void reportConsume(ObjectValue consumerObject, String topic, int size) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_CONSUMER,\n+                                                                        KafkaUtils.getClientId(consumerObject),\n+                                                                        KafkaUtils.getBootstrapServers(consumerObject),\n+                                                                        topic);\n+        reportConsume(observerContext, size);\n+    }\n+\n+    /**\n+     * Reports a consumer consuming a record of messages.\n+     *\n+     * @param consumerObject    Consumer object.\n+     * @param records           Records\n+     */\n+    public static void reportConsume(ObjectValue consumerObject, ConsumerRecords records) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        records.forEach(record -> {\n+            KafkaMetricsUtil.reportConsume(consumerObject, ((ConsumerRecord) record).topic(),\n+                                           ((ConsumerRecord) record).serializedValueSize());\n+        });\n+    }\n+\n+\n+    /**\n+     * Reports an error generated by a producer. This method is called when the URL/subject of the current producer is\n+     * unknown. e.g. when a Kafka connection doesn't exist for a producer.\n+     *\n+     * @param producerObject    Producer object.\n+     * @param errorType         Type of the error.\n+     */\n+    public static void reportProducerError(ObjectValue producerObject, String errorType) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        reportError(KafkaObservabilityConstants.CONTEXT_PRODUCER, producerObject, errorType);\n+    }\n+\n+    /**\n+     * Reports an error generated by a consumer. This method is called when the URL/subject of the current consumer is\n+     * unknown. e.g. when a Kafka connection doesn't exist for a consumer.\n+     *\n+     * @param errorType type of the error.\n+     */\n+    public static void reportConsumerError(String errorType) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        reportError(KafkaObservabilityConstants.CONTEXT_CONSUMER, errorType);\n+    }\n+\n+    /**\n+     * Reports an error generated by a consumer. This method is called when the URL/subject of the current consumer is\n+     * unknown. e.g. when a Kafka connection doesn't exist for a consumer.\n+     *\n+     * @param consumerObject    Consumer object.\n+     * @param errorType         Type of the error.\n+     */\n+    public static void reportConsumerError(ObjectValue consumerObject, String errorType) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        reportError(KafkaObservabilityConstants.CONTEXT_CONSUMER, consumerObject, errorType);\n+    }\n+\n+    /**\n+     * Reports an error generated by a consumer.\n+     *\n+     * @param consumerObject    Consumer object.\n+     * @param topic             Subject that the consumer is subscribed to.\n+     * @param errorType         Type of the error.\n+     */\n+    public static void reportConsumerError(ObjectValue consumerObject, String topic, String errorType) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        reportError(consumerObject, topic, KafkaObservabilityConstants.CONTEXT_CONSUMER, errorType);\n+    }\n+\n+    private static void reportPublish(KafkaObserverContext observerContext, int size) {\n+        incrementCounter(observerContext, KafkaObservabilityConstants.METRIC_PUBLISHED[0],\n+                         KafkaObservabilityConstants.METRIC_PUBLISHED[1]);\n+        incrementCounter(observerContext, KafkaObservabilityConstants.METRIC_PUBLISHED_SIZE[0],\n+                         KafkaObservabilityConstants.METRIC_PUBLISHED_SIZE[1], size);\n+    }\n+\n+    private static void reportConsume(KafkaObserverContext observerContext, int size) {\n+        incrementCounter(observerContext, KafkaObservabilityConstants.METRIC_CONSUMED[0],\n+                         KafkaObservabilityConstants.METRIC_CONSUMED[1]);\n+        incrementCounter(observerContext, KafkaObservabilityConstants.METRIC_CONSUMED_SIZE[0],\n+                         KafkaObservabilityConstants.METRIC_CONSUMED_SIZE[1], size);\n+    }\n+\n+    public static void reportError(String context, String errorType) {\n+        KafkaObserverContext observerContext = new KafkaObserverContext(context);\n+        observerContext.addTag(KafkaObservabilityConstants.TAG_ERROR_TYPE, errorType);\n+        incrementCounter(observerContext, KafkaObservabilityConstants.METRIC_ERRORS[0],\n+                         KafkaObservabilityConstants.METRIC_ERRORS[1]);\n+    }\n+\n+    public static void reportError(String context, ObjectValue object, String errorType) {\n+        KafkaObserverContext observerContext = new KafkaObserverContext(context,\n+                                                                        KafkaUtils.getClientId(object),\n+                                                                        KafkaUtils.getBootstrapServers(object));\n+        observerContext.addTag(KafkaObservabilityConstants.TAG_ERROR_TYPE, errorType);\n+        incrementCounter(observerContext, KafkaObservabilityConstants.METRIC_ERRORS[0],\n+                         KafkaObservabilityConstants.METRIC_ERRORS[1]);\n+    }\n+\n+    public static void reportError(ObjectValue object, String topic, String context, String errorType) {\n+        KafkaObserverContext observerContext = new KafkaObserverContext(context,\n+                                                                        KafkaUtils.getClientId(object),\n+                                                                        KafkaUtils.getBootstrapServers(object),\n+                                                                        topic);\n+        observerContext.addTag(KafkaObservabilityConstants.TAG_ERROR_TYPE, errorType);\n+        incrementCounter(observerContext, KafkaObservabilityConstants.METRIC_ERRORS[0],\n+                         KafkaObservabilityConstants.METRIC_ERRORS[1]);\n+    }\n+\n+    private static void incrementCounter(KafkaObserverContext observerContext, String name, String desc) {\n+        incrementCounter(observerContext, name, desc, 1);\n+    }\n+\n+    private static void incrementCounter(KafkaObserverContext observerContext, String name, String desc, int amount) {\n+        if (metricRegistry == null) {\n+            return;\n+        }\n+        metricRegistry.counter(new MetricId(\n+                KafkaObservabilityConstants.CONNECTOR_NAME + \"_\" + name, desc, observerContext.getAllTags()))\n+                .increment(amount);\n+    }\n+\n+    private static void incrementGauge(KafkaObserverContext observerContext, String name, String desc) {\n+        if (metricRegistry == null) {\n+            return;\n+        }\n+        metricRegistry.gauge(new MetricId(\n+                KafkaObservabilityConstants.CONNECTOR_NAME + \"_\" + name, desc, observerContext.getAllTags()))\n+                .increment();\n+    }\n+\n+    private static void decrementGauge(KafkaObserverContext observerContext, String name, String desc) {\n+        if (metricRegistry == null) {\n+            return;\n+        }\n+        metricRegistry.gauge(new MetricId(\n+                KafkaObservabilityConstants.CONNECTOR_NAME + \"_\" + name, desc, observerContext.getAllTags()))\n+                .decrement();\n+    }\n+\n+    private static void setGauge(KafkaObserverContext observerContext, String name, String desc, int value) {\n+        if (metricRegistry == null) {\n+            return;\n+        }\n+        metricRegistry.gauge(new MetricId(\n+                KafkaObservabilityConstants.CONNECTOR_NAME + \"_\" + name, desc, observerContext.getAllTags()))\n+                .setValue(value);\n+    }\n+\n+    private static void resetGauge(KafkaObserverContext observerContext, String name, String desc) {\n+        if (metricRegistry == null) {\n+            return;\n+        }\n+        metricRegistry.gauge(new MetricId(\n+                KafkaObservabilityConstants.CONNECTOR_NAME + \"_\" + name, desc, observerContext.getAllTags()))\n+                .setValue(0);\n+    }\n+\n+    private KafkaMetricsUtil() {\n+    }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "686745345044b18037d8f38ab3480fab94f4dfa1"}, "originalPosition": 371}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 622, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}