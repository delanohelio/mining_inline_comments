{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDYyNTcwOTQ2", "number": 25122, "reviewThreads": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQwOToxMjoyOVrOEU6joQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwODo0OTozOVrOEXiHnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMzY2MzY5OnYy", "diffSide": "RIGHT", "path": "misc/formatter/modules/formatter-cli/src/main/java/org/ballerinalang/formatter/cli/FormatCmd.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQwOToxMjoyOVrOG7YBHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwNzo1MDo1MFrOG-sXxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkxMjY2OA==", "bodyText": "@IrushiL ; Does this have to be 2020?\nThere were some other classes too", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25122#discussion_r464912668", "createdAt": "2020-08-04T09:12:29Z", "author": {"login": "keizer619"}, "path": "misc/formatter/modules/formatter-cli/src/main/java/org/ballerinalang/formatter/cli/FormatCmd.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/*\n+ * Copyright (c) 2019, WSO2 Inc. (http://wso2.com) All Rights Reserved.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b72faad13b973766a11b0c45bcb8d94015a18b6"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODM5MTg3OA==", "bodyText": "Thanks, will change this.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25122#discussion_r468391878", "createdAt": "2020-08-11T07:50:50Z", "author": {"login": "IrushiL"}, "path": "misc/formatter/modules/formatter-cli/src/main/java/org/ballerinalang/formatter/cli/FormatCmd.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/*\n+ * Copyright (c) 2019, WSO2 Inc. (http://wso2.com) All Rights Reserved.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkxMjY2OA=="}, "originalCommit": {"oid": "1b72faad13b973766a11b0c45bcb8d94015a18b6"}, "originalPosition": 2}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMTU2NDYzOnYy", "diffSide": "RIGHT", "path": "misc/formatter/modules/formatter-cli/src/test/java/org/ballerinalang/formatter/cli/FormatCmdTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQwNTowNDozM1rOG8ja1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwNzo1MDoxNlrOG-sWbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjE0ODA1NQ==", "bodyText": "Why this is commented everywhere?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25122#discussion_r466148055", "createdAt": "2020-08-06T05:04:33Z", "author": {"login": "suganyasuven"}, "path": "misc/formatter/modules/formatter-cli/src/test/java/org/ballerinalang/formatter/cli/FormatCmdTest.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * Copyright (c) 2019, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.ballerinalang.formatter.cli;\n+\n+import org.ballerinalang.tool.BLauncherException;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Format CLI tool test suit for testing tool's exceptions.\n+ */\n+public class FormatCmdTest {\n+    private static final Path RES_DIR = Paths.get(\"src/test/resources/\").toAbsolutePath();\n+\n+    @Test(description = \"Test to check the exception for too many argument provided.\")\n+    public void formatCLITooManyArgumentsTest() {\n+        Path sourceRoot = RES_DIR.resolve(\"notAProject\");\n+        List<String> argList = new ArrayList<>();\n+        argList.add(\"pkg2\");\n+        argList.add(\"asd\");\n+        try {\n+//            FormatUtil.execute(argList, false, false, sourceRoot);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b72faad13b973766a11b0c45bcb8d94015a18b6"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODM5MTUzNQ==", "bodyText": "This is still under implementation.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25122#discussion_r468391535", "createdAt": "2020-08-11T07:50:16Z", "author": {"login": "IrushiL"}, "path": "misc/formatter/modules/formatter-cli/src/test/java/org/ballerinalang/formatter/cli/FormatCmdTest.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * Copyright (c) 2019, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.ballerinalang.formatter.cli;\n+\n+import org.ballerinalang.tool.BLauncherException;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Format CLI tool test suit for testing tool's exceptions.\n+ */\n+public class FormatCmdTest {\n+    private static final Path RES_DIR = Paths.get(\"src/test/resources/\").toAbsolutePath();\n+\n+    @Test(description = \"Test to check the exception for too many argument provided.\")\n+    public void formatCLITooManyArgumentsTest() {\n+        Path sourceRoot = RES_DIR.resolve(\"notAProject\");\n+        List<String> argList = new ArrayList<>();\n+        argList.add(\"pkg2\");\n+        argList.add(\"asd\");\n+        try {\n+//            FormatUtil.execute(argList, false, false, sourceRoot);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjE0ODA1NQ=="}, "originalCommit": {"oid": "1b72faad13b973766a11b0c45bcb8d94015a18b6"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMDgwMjc0OnYy", "diffSide": "RIGHT", "path": "misc/formatter/modules/formatter-cli/src/main/java/org/ballerinalang/formatter/cli/FormatUtil.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwNzoyMTozN1rOG_U7Qw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwODozNzo1MFrOG_XheA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA1NjMyMw==", "bodyText": "If there a bal files inside nested directories of the module directory, then the file path gets changed?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25122#discussion_r469056323", "createdAt": "2020-08-12T07:21:37Z", "author": {"login": "hemikak"}, "path": "misc/formatter/modules/formatter-cli/src/main/java/org/ballerinalang/formatter/cli/FormatUtil.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.cli;\n+\n+import org.ballerinalang.compiler.CompilerPhase;\n+import org.ballerinalang.formatter.core.Formatter;\n+import org.ballerinalang.tool.BLauncherCmd;\n+import org.ballerinalang.tool.LauncherUtils;\n+import org.wso2.ballerinalang.compiler.Compiler;\n+import org.wso2.ballerinalang.compiler.tree.BLangCompilationUnit;\n+import org.wso2.ballerinalang.compiler.tree.BLangPackage;\n+import org.wso2.ballerinalang.compiler.tree.BLangTestablePackage;\n+import org.wso2.ballerinalang.compiler.util.CompilerContext;\n+import org.wso2.ballerinalang.compiler.util.CompilerOptions;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.io.PrintStream;\n+import java.io.UnsupportedEncodingException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+\n+import static org.ballerinalang.compiler.CompilerOptionName.COMPILER_PHASE;\n+import static org.ballerinalang.compiler.CompilerOptionName.EXPERIMENTAL_FEATURES_ENABLED;\n+import static org.ballerinalang.compiler.CompilerOptionName.LOCK_ENABLED;\n+import static org.ballerinalang.compiler.CompilerOptionName.NEW_PARSER_ENABLED;\n+import static org.ballerinalang.compiler.CompilerOptionName.OFFLINE;\n+import static org.ballerinalang.compiler.CompilerOptionName.PRESERVE_WHITESPACE;\n+import static org.ballerinalang.compiler.CompilerOptionName.PROJECT_DIR;\n+import static org.ballerinalang.compiler.CompilerOptionName.SKIP_TESTS;\n+import static org.ballerinalang.compiler.CompilerOptionName.TEST_ENABLED;\n+\n+/**\n+ * Util class for compilation and format execution for formatting CLI tool.\n+ */\n+class FormatUtil {\n+    static final String CMD_NAME = \"format\";\n+    private static final PrintStream outStream = System.err;\n+    private static EmptyPrintStream emptyPrintStream;\n+\n+    /**\n+     * Execute formatter.\n+     *\n+     * @param argList        argument list from the console\n+     * @param helpFlag       flag to get the help page\n+     * @param dryRun         run the whole formatting\n+     * @param sourceRootPath execution path\n+     */\n+    static void execute(List<String> argList, boolean helpFlag, boolean dryRun, Path sourceRootPath) {\n+        if (helpFlag) {\n+            String commandUsageInfo = BLauncherCmd.getCommandUsageInfo(CMD_NAME);\n+            outStream.println(commandUsageInfo);\n+            return;\n+        }\n+\n+        if (argList != null && argList.size() > 1) {\n+            throw LauncherUtils.createLauncherException(Messages.getArgumentError());\n+        }\n+\n+        String moduleName;\n+        String ballerinaFilePath;\n+\n+        try {\n+            // If parameters are available user has given either the module name or the ballerina file path.\n+            // Else user is in a ballerina project and expecting to format the whole ballerina project\n+            if (argList != null && !argList.isEmpty()) {\n+                if (FormatUtil.isBalFile(argList.get(0))) {\n+                    ballerinaFilePath = argList.get(0);\n+                    Path filePath = Paths.get(ballerinaFilePath);\n+\n+                    // If the file doesn't exist or is a directory.\n+                    if (!filePath.toFile().exists() || filePath.toFile().isDirectory()) {\n+                        throw LauncherUtils.createLauncherException(Messages.getNoBallerinaFile(ballerinaFilePath));\n+                    }\n+\n+                    String source = new String(Files.readAllBytes(filePath), StandardCharsets.UTF_8);\n+                    // Format and get the generated formatted source code content.\n+                    String formattedSourceCode = Formatter.format(source);\n+\n+                    if (doChangesAvailable(source, formattedSourceCode)) {\n+                        if (!dryRun) {\n+                            // Write the formatted content back to the file.\n+                            FormatUtil.writeFile(filePath.toAbsolutePath().toString(), formattedSourceCode);\n+                            outStream.println(Messages.getModifiedFiles() + System.lineSeparator() + ballerinaFilePath);\n+                            outStream.println(System.lineSeparator() + Messages.getSuccessMessage());\n+                        } else {\n+                            outStream.println(Messages.getFilesToModify() + System.lineSeparator() + ballerinaFilePath);\n+                        }\n+                    } else {\n+                        outStream.println(Messages.getNoChanges());\n+                    }\n+                } else if (Paths.get(argList.get(0)).toFile().isFile()) {\n+                    // If file is a regular file but not a ballerina source file\n+                    // throw the following exception.\n+                    throw LauncherUtils.createLauncherException(Messages.getNotABallerinaFile());\n+                } else {\n+                    moduleName = argList.get(0);\n+\n+                    // Check whether the module dir exists.\n+                    if (!FormatUtil.isModuleExist(moduleName, sourceRootPath)) {\n+                        // If module directory doesn't exist and contains a \".\"\n+                        // throw a exception to say file or module doesn't exist.\n+                        // Else throw a exception to say module doesn't exist.\n+                        if (moduleName.contains(\".\")) {\n+                            throw LauncherUtils.createLauncherException(Messages\n+                                    .getNoBallerinaModuleOrFile(moduleName));\n+                        } else {\n+                            throw LauncherUtils.createLauncherException(Messages.getNoModuleFound(moduleName));\n+                        }\n+                    }\n+\n+                    // Check whether the given directory is not in a ballerina project.\n+                    if (FormatUtil.notABallerinaProject(sourceRootPath)) {\n+                        throw LauncherUtils.createLauncherException(Messages.getNotBallerinaProject());\n+                    }\n+                    BLangPackage bLangPackage = FormatUtil\n+                            .compileModule(sourceRootPath, getModuleName(moduleName));\n+\n+                    // Iterate and format the ballerina package.\n+                    List<String> formattedFiles = iterateAndFormat(bLangPackage, sourceRootPath, dryRun);\n+                    generateChangeReport(formattedFiles, dryRun);\n+                }\n+            } else {\n+                List<BLangPackage> packages = FormatUtil.compileProject(sourceRootPath);\n+                List<String> formattedFiles = new ArrayList<>();\n+                // Iterate and format all the ballerina packages.\n+                for (BLangPackage bLangPackage : packages) {\n+                    formattedFiles.addAll(iterateAndFormat(bLangPackage, sourceRootPath, dryRun));\n+                }\n+\n+                generateChangeReport(formattedFiles, dryRun);\n+            }\n+        } catch (IOException | NullPointerException e) {\n+            throw LauncherUtils.createLauncherException(Messages.getException());\n+        }\n+    }\n+\n+    private static void generateChangeReport(List<String> formattedFiles, boolean dryRun) {\n+        if (!formattedFiles.isEmpty()) {\n+            StringBuilder fileList = new StringBuilder();\n+            if (dryRun) {\n+                fileList.append(Messages.getFilesToModify()).append(System.lineSeparator());\n+            } else {\n+                fileList.append(Messages.getModifiedFiles()).append(System.lineSeparator());\n+            }\n+            for (String file : formattedFiles) {\n+                fileList.append(file).append(System.lineSeparator());\n+            }\n+            outStream.println(fileList.toString());\n+            if (!dryRun) {\n+                outStream.println(Messages.getSuccessMessage());\n+            }\n+        } else {\n+            outStream.println(Messages.getNoChanges());\n+        }\n+    }\n+\n+    private static String getModuleName(String moduleName) {\n+        String pattern = Pattern.quote(File.separator);\n+        String[] splitedTokens = moduleName.split(pattern);\n+        return splitedTokens[splitedTokens.length - 1];\n+    }\n+\n+    /**\n+     * Compile whole ballerina project.\n+     *\n+     * @param sourceRoot source root\n+     * @return {@link List<BLangPackage>} list of BLangPackages\n+     */\n+    private static List<BLangPackage> compileProject(Path sourceRoot) throws UnsupportedEncodingException {\n+        emptyPrintStream = new EmptyPrintStream();\n+        CompilerContext context = getCompilerContext(sourceRoot);\n+        Compiler compiler = Compiler.getInstance(context);\n+        // Set an EmptyPrintStream to hide unnecessary outputs from compiler.\n+        compiler.setOutStream(emptyPrintStream);\n+        return compiler.compilePackages(false);\n+    }\n+\n+    /**\n+     * Compile only a ballerina module.\n+     *\n+     * @param sourceRoot source root\n+     * @param moduleName name of the module to be compiled\n+     * @return {@link BLangPackage} ballerina package\n+     */\n+    private static BLangPackage compileModule(Path sourceRoot, String moduleName) throws UnsupportedEncodingException {\n+        emptyPrintStream = new EmptyPrintStream();\n+        CompilerContext context = getCompilerContext(sourceRoot);\n+        Compiler compiler = Compiler.getInstance(context);\n+        // Set an EmptyPrintStream to hide unnecessary outputs from compiler.\n+        compiler.setOutStream(emptyPrintStream);\n+        return compiler.compile(moduleName);\n+    }\n+\n+    private static void formatAndWrite(BLangCompilationUnit compilationUnit, Path sourceRootPath,\n+                                       List<String> formattedFiles, boolean dryRun) throws IOException {\n+        String fileName = sourceRootPath.toString() + File.separator\n+                + \"src\"\n+                + File.separator\n+                + compilationUnit.getPosition().getSource().getPackageName()\n+                + File.separator\n+                + compilationUnit.getPosition().getSource().getCompilationUnitName();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85029404a6672a4d0d0d519148be5b133324530f"}, "originalPosition": 223}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA5ODg3Mg==", "bodyText": "This formatAndWrite function is called iteratively for each BLangCompilationUnit. The getCompilationUnits() function used to obtain the compilation units resolves the .bal files residing inside subdirectories as well.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25122#discussion_r469098872", "createdAt": "2020-08-12T08:37:50Z", "author": {"login": "IrushiL"}, "path": "misc/formatter/modules/formatter-cli/src/main/java/org/ballerinalang/formatter/cli/FormatUtil.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.cli;\n+\n+import org.ballerinalang.compiler.CompilerPhase;\n+import org.ballerinalang.formatter.core.Formatter;\n+import org.ballerinalang.tool.BLauncherCmd;\n+import org.ballerinalang.tool.LauncherUtils;\n+import org.wso2.ballerinalang.compiler.Compiler;\n+import org.wso2.ballerinalang.compiler.tree.BLangCompilationUnit;\n+import org.wso2.ballerinalang.compiler.tree.BLangPackage;\n+import org.wso2.ballerinalang.compiler.tree.BLangTestablePackage;\n+import org.wso2.ballerinalang.compiler.util.CompilerContext;\n+import org.wso2.ballerinalang.compiler.util.CompilerOptions;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.io.PrintStream;\n+import java.io.UnsupportedEncodingException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+\n+import static org.ballerinalang.compiler.CompilerOptionName.COMPILER_PHASE;\n+import static org.ballerinalang.compiler.CompilerOptionName.EXPERIMENTAL_FEATURES_ENABLED;\n+import static org.ballerinalang.compiler.CompilerOptionName.LOCK_ENABLED;\n+import static org.ballerinalang.compiler.CompilerOptionName.NEW_PARSER_ENABLED;\n+import static org.ballerinalang.compiler.CompilerOptionName.OFFLINE;\n+import static org.ballerinalang.compiler.CompilerOptionName.PRESERVE_WHITESPACE;\n+import static org.ballerinalang.compiler.CompilerOptionName.PROJECT_DIR;\n+import static org.ballerinalang.compiler.CompilerOptionName.SKIP_TESTS;\n+import static org.ballerinalang.compiler.CompilerOptionName.TEST_ENABLED;\n+\n+/**\n+ * Util class for compilation and format execution for formatting CLI tool.\n+ */\n+class FormatUtil {\n+    static final String CMD_NAME = \"format\";\n+    private static final PrintStream outStream = System.err;\n+    private static EmptyPrintStream emptyPrintStream;\n+\n+    /**\n+     * Execute formatter.\n+     *\n+     * @param argList        argument list from the console\n+     * @param helpFlag       flag to get the help page\n+     * @param dryRun         run the whole formatting\n+     * @param sourceRootPath execution path\n+     */\n+    static void execute(List<String> argList, boolean helpFlag, boolean dryRun, Path sourceRootPath) {\n+        if (helpFlag) {\n+            String commandUsageInfo = BLauncherCmd.getCommandUsageInfo(CMD_NAME);\n+            outStream.println(commandUsageInfo);\n+            return;\n+        }\n+\n+        if (argList != null && argList.size() > 1) {\n+            throw LauncherUtils.createLauncherException(Messages.getArgumentError());\n+        }\n+\n+        String moduleName;\n+        String ballerinaFilePath;\n+\n+        try {\n+            // If parameters are available user has given either the module name or the ballerina file path.\n+            // Else user is in a ballerina project and expecting to format the whole ballerina project\n+            if (argList != null && !argList.isEmpty()) {\n+                if (FormatUtil.isBalFile(argList.get(0))) {\n+                    ballerinaFilePath = argList.get(0);\n+                    Path filePath = Paths.get(ballerinaFilePath);\n+\n+                    // If the file doesn't exist or is a directory.\n+                    if (!filePath.toFile().exists() || filePath.toFile().isDirectory()) {\n+                        throw LauncherUtils.createLauncherException(Messages.getNoBallerinaFile(ballerinaFilePath));\n+                    }\n+\n+                    String source = new String(Files.readAllBytes(filePath), StandardCharsets.UTF_8);\n+                    // Format and get the generated formatted source code content.\n+                    String formattedSourceCode = Formatter.format(source);\n+\n+                    if (doChangesAvailable(source, formattedSourceCode)) {\n+                        if (!dryRun) {\n+                            // Write the formatted content back to the file.\n+                            FormatUtil.writeFile(filePath.toAbsolutePath().toString(), formattedSourceCode);\n+                            outStream.println(Messages.getModifiedFiles() + System.lineSeparator() + ballerinaFilePath);\n+                            outStream.println(System.lineSeparator() + Messages.getSuccessMessage());\n+                        } else {\n+                            outStream.println(Messages.getFilesToModify() + System.lineSeparator() + ballerinaFilePath);\n+                        }\n+                    } else {\n+                        outStream.println(Messages.getNoChanges());\n+                    }\n+                } else if (Paths.get(argList.get(0)).toFile().isFile()) {\n+                    // If file is a regular file but not a ballerina source file\n+                    // throw the following exception.\n+                    throw LauncherUtils.createLauncherException(Messages.getNotABallerinaFile());\n+                } else {\n+                    moduleName = argList.get(0);\n+\n+                    // Check whether the module dir exists.\n+                    if (!FormatUtil.isModuleExist(moduleName, sourceRootPath)) {\n+                        // If module directory doesn't exist and contains a \".\"\n+                        // throw a exception to say file or module doesn't exist.\n+                        // Else throw a exception to say module doesn't exist.\n+                        if (moduleName.contains(\".\")) {\n+                            throw LauncherUtils.createLauncherException(Messages\n+                                    .getNoBallerinaModuleOrFile(moduleName));\n+                        } else {\n+                            throw LauncherUtils.createLauncherException(Messages.getNoModuleFound(moduleName));\n+                        }\n+                    }\n+\n+                    // Check whether the given directory is not in a ballerina project.\n+                    if (FormatUtil.notABallerinaProject(sourceRootPath)) {\n+                        throw LauncherUtils.createLauncherException(Messages.getNotBallerinaProject());\n+                    }\n+                    BLangPackage bLangPackage = FormatUtil\n+                            .compileModule(sourceRootPath, getModuleName(moduleName));\n+\n+                    // Iterate and format the ballerina package.\n+                    List<String> formattedFiles = iterateAndFormat(bLangPackage, sourceRootPath, dryRun);\n+                    generateChangeReport(formattedFiles, dryRun);\n+                }\n+            } else {\n+                List<BLangPackage> packages = FormatUtil.compileProject(sourceRootPath);\n+                List<String> formattedFiles = new ArrayList<>();\n+                // Iterate and format all the ballerina packages.\n+                for (BLangPackage bLangPackage : packages) {\n+                    formattedFiles.addAll(iterateAndFormat(bLangPackage, sourceRootPath, dryRun));\n+                }\n+\n+                generateChangeReport(formattedFiles, dryRun);\n+            }\n+        } catch (IOException | NullPointerException e) {\n+            throw LauncherUtils.createLauncherException(Messages.getException());\n+        }\n+    }\n+\n+    private static void generateChangeReport(List<String> formattedFiles, boolean dryRun) {\n+        if (!formattedFiles.isEmpty()) {\n+            StringBuilder fileList = new StringBuilder();\n+            if (dryRun) {\n+                fileList.append(Messages.getFilesToModify()).append(System.lineSeparator());\n+            } else {\n+                fileList.append(Messages.getModifiedFiles()).append(System.lineSeparator());\n+            }\n+            for (String file : formattedFiles) {\n+                fileList.append(file).append(System.lineSeparator());\n+            }\n+            outStream.println(fileList.toString());\n+            if (!dryRun) {\n+                outStream.println(Messages.getSuccessMessage());\n+            }\n+        } else {\n+            outStream.println(Messages.getNoChanges());\n+        }\n+    }\n+\n+    private static String getModuleName(String moduleName) {\n+        String pattern = Pattern.quote(File.separator);\n+        String[] splitedTokens = moduleName.split(pattern);\n+        return splitedTokens[splitedTokens.length - 1];\n+    }\n+\n+    /**\n+     * Compile whole ballerina project.\n+     *\n+     * @param sourceRoot source root\n+     * @return {@link List<BLangPackage>} list of BLangPackages\n+     */\n+    private static List<BLangPackage> compileProject(Path sourceRoot) throws UnsupportedEncodingException {\n+        emptyPrintStream = new EmptyPrintStream();\n+        CompilerContext context = getCompilerContext(sourceRoot);\n+        Compiler compiler = Compiler.getInstance(context);\n+        // Set an EmptyPrintStream to hide unnecessary outputs from compiler.\n+        compiler.setOutStream(emptyPrintStream);\n+        return compiler.compilePackages(false);\n+    }\n+\n+    /**\n+     * Compile only a ballerina module.\n+     *\n+     * @param sourceRoot source root\n+     * @param moduleName name of the module to be compiled\n+     * @return {@link BLangPackage} ballerina package\n+     */\n+    private static BLangPackage compileModule(Path sourceRoot, String moduleName) throws UnsupportedEncodingException {\n+        emptyPrintStream = new EmptyPrintStream();\n+        CompilerContext context = getCompilerContext(sourceRoot);\n+        Compiler compiler = Compiler.getInstance(context);\n+        // Set an EmptyPrintStream to hide unnecessary outputs from compiler.\n+        compiler.setOutStream(emptyPrintStream);\n+        return compiler.compile(moduleName);\n+    }\n+\n+    private static void formatAndWrite(BLangCompilationUnit compilationUnit, Path sourceRootPath,\n+                                       List<String> formattedFiles, boolean dryRun) throws IOException {\n+        String fileName = sourceRootPath.toString() + File.separator\n+                + \"src\"\n+                + File.separator\n+                + compilationUnit.getPosition().getSource().getPackageName()\n+                + File.separator\n+                + compilationUnit.getPosition().getSource().getCompilationUnitName();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA1NjMyMw=="}, "originalCommit": {"oid": "85029404a6672a4d0d0d519148be5b133324530f"}, "originalPosition": 223}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMDgxMDkyOnYy", "diffSide": "RIGHT", "path": "misc/formatter/modules/formatter-cli/src/main/java/org/ballerinalang/formatter/cli/FormatCmd.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwNzoyMzo1NVrOG_VADQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwODowOTozMVrOG_WfEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA1NzU0OQ==", "bodyText": "Dry run is hidden ? Why ?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25122#discussion_r469057549", "createdAt": "2020-08-12T07:23:55Z", "author": {"login": "hemikak"}, "path": "misc/formatter/modules/formatter-cli/src/main/java/org/ballerinalang/formatter/cli/FormatCmd.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.cli;\n+\n+import org.ballerinalang.tool.BLauncherCmd;\n+import picocli.CommandLine;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.List;\n+\n+/**\n+ * Class to implement \"format\" command for ballerina.\n+ * Ex: ballerina format [ballerinaFile | ModuleName] [-d | --dry-run]\n+ */\n+@CommandLine.Command(name = \"format\", description = \"format given Ballerina source file\")\n+public class FormatCmd implements BLauncherCmd {\n+    private static final String USER_DIR = \"user.dir\";\n+    private static final String NOT_SUPPORTED_MESSAGE = \"user.dir\";\n+\n+    @CommandLine.Parameters\n+    private List<String> argList;\n+\n+    @CommandLine.Option(names = {\"-h\", \"--help\"}, hidden = true)\n+    private boolean helpFlag;\n+\n+    @CommandLine.Option(names = {\"-d\", \"--dry-run\"}, hidden = true)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85029404a6672a4d0d0d519148be5b133324530f"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA4MTg3NA==", "bodyText": "Removed the hidden attribute.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25122#discussion_r469081874", "createdAt": "2020-08-12T08:09:31Z", "author": {"login": "IrushiL"}, "path": "misc/formatter/modules/formatter-cli/src/main/java/org/ballerinalang/formatter/cli/FormatCmd.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.cli;\n+\n+import org.ballerinalang.tool.BLauncherCmd;\n+import picocli.CommandLine;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.List;\n+\n+/**\n+ * Class to implement \"format\" command for ballerina.\n+ * Ex: ballerina format [ballerinaFile | ModuleName] [-d | --dry-run]\n+ */\n+@CommandLine.Command(name = \"format\", description = \"format given Ballerina source file\")\n+public class FormatCmd implements BLauncherCmd {\n+    private static final String USER_DIR = \"user.dir\";\n+    private static final String NOT_SUPPORTED_MESSAGE = \"user.dir\";\n+\n+    @CommandLine.Parameters\n+    private List<String> argList;\n+\n+    @CommandLine.Option(names = {\"-h\", \"--help\"}, hidden = true)\n+    private boolean helpFlag;\n+\n+    @CommandLine.Option(names = {\"-d\", \"--dry-run\"}, hidden = true)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA1NzU0OQ=="}, "originalCommit": {"oid": "85029404a6672a4d0d0d519148be5b133324530f"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMDgxMTgyOnYy", "diffSide": "RIGHT", "path": "misc/formatter/modules/formatter-cli/src/main/java/org/ballerinalang/formatter/cli/FormatUtil.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwNzoyNDoxMlrOG_VAmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwODowOToxM1rOG_Wecg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA1NzY4OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    // throw a exception to say file or module doesn't exist.\n          \n          \n            \n                                    // throw an exception to say file or module doesn't exist.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25122#discussion_r469057688", "createdAt": "2020-08-12T07:24:12Z", "author": {"login": "azinneera"}, "path": "misc/formatter/modules/formatter-cli/src/main/java/org/ballerinalang/formatter/cli/FormatUtil.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.cli;\n+\n+import org.ballerinalang.compiler.CompilerPhase;\n+import org.ballerinalang.formatter.core.Formatter;\n+import org.ballerinalang.tool.BLauncherCmd;\n+import org.ballerinalang.tool.LauncherUtils;\n+import org.wso2.ballerinalang.compiler.Compiler;\n+import org.wso2.ballerinalang.compiler.tree.BLangCompilationUnit;\n+import org.wso2.ballerinalang.compiler.tree.BLangPackage;\n+import org.wso2.ballerinalang.compiler.tree.BLangTestablePackage;\n+import org.wso2.ballerinalang.compiler.util.CompilerContext;\n+import org.wso2.ballerinalang.compiler.util.CompilerOptions;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.io.PrintStream;\n+import java.io.UnsupportedEncodingException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+\n+import static org.ballerinalang.compiler.CompilerOptionName.COMPILER_PHASE;\n+import static org.ballerinalang.compiler.CompilerOptionName.EXPERIMENTAL_FEATURES_ENABLED;\n+import static org.ballerinalang.compiler.CompilerOptionName.LOCK_ENABLED;\n+import static org.ballerinalang.compiler.CompilerOptionName.NEW_PARSER_ENABLED;\n+import static org.ballerinalang.compiler.CompilerOptionName.OFFLINE;\n+import static org.ballerinalang.compiler.CompilerOptionName.PRESERVE_WHITESPACE;\n+import static org.ballerinalang.compiler.CompilerOptionName.PROJECT_DIR;\n+import static org.ballerinalang.compiler.CompilerOptionName.SKIP_TESTS;\n+import static org.ballerinalang.compiler.CompilerOptionName.TEST_ENABLED;\n+\n+/**\n+ * Util class for compilation and format execution for formatting CLI tool.\n+ */\n+class FormatUtil {\n+    static final String CMD_NAME = \"format\";\n+    private static final PrintStream outStream = System.err;\n+    private static EmptyPrintStream emptyPrintStream;\n+\n+    /**\n+     * Execute formatter.\n+     *\n+     * @param argList        argument list from the console\n+     * @param helpFlag       flag to get the help page\n+     * @param dryRun         run the whole formatting\n+     * @param sourceRootPath execution path\n+     */\n+    static void execute(List<String> argList, boolean helpFlag, boolean dryRun, Path sourceRootPath) {\n+        if (helpFlag) {\n+            String commandUsageInfo = BLauncherCmd.getCommandUsageInfo(CMD_NAME);\n+            outStream.println(commandUsageInfo);\n+            return;\n+        }\n+\n+        if (argList != null && argList.size() > 1) {\n+            throw LauncherUtils.createLauncherException(Messages.getArgumentError());\n+        }\n+\n+        String moduleName;\n+        String ballerinaFilePath;\n+\n+        try {\n+            // If parameters are available user has given either the module name or the ballerina file path.\n+            // Else user is in a ballerina project and expecting to format the whole ballerina project\n+            if (argList != null && !argList.isEmpty()) {\n+                if (FormatUtil.isBalFile(argList.get(0))) {\n+                    ballerinaFilePath = argList.get(0);\n+                    Path filePath = Paths.get(ballerinaFilePath);\n+\n+                    // If the file doesn't exist or is a directory.\n+                    if (!filePath.toFile().exists() || filePath.toFile().isDirectory()) {\n+                        throw LauncherUtils.createLauncherException(Messages.getNoBallerinaFile(ballerinaFilePath));\n+                    }\n+\n+                    String source = new String(Files.readAllBytes(filePath), StandardCharsets.UTF_8);\n+                    // Format and get the generated formatted source code content.\n+                    String formattedSourceCode = Formatter.format(source);\n+\n+                    if (doChangesAvailable(source, formattedSourceCode)) {\n+                        if (!dryRun) {\n+                            // Write the formatted content back to the file.\n+                            FormatUtil.writeFile(filePath.toAbsolutePath().toString(), formattedSourceCode);\n+                            outStream.println(Messages.getModifiedFiles() + System.lineSeparator() + ballerinaFilePath);\n+                            outStream.println(System.lineSeparator() + Messages.getSuccessMessage());\n+                        } else {\n+                            outStream.println(Messages.getFilesToModify() + System.lineSeparator() + ballerinaFilePath);\n+                        }\n+                    } else {\n+                        outStream.println(Messages.getNoChanges());\n+                    }\n+                } else if (Paths.get(argList.get(0)).toFile().isFile()) {\n+                    // If file is a regular file but not a ballerina source file\n+                    // throw the following exception.\n+                    throw LauncherUtils.createLauncherException(Messages.getNotABallerinaFile());\n+                } else {\n+                    moduleName = argList.get(0);\n+\n+                    // Check whether the module dir exists.\n+                    if (!FormatUtil.isModuleExist(moduleName, sourceRootPath)) {\n+                        // If module directory doesn't exist and contains a \".\"\n+                        // throw a exception to say file or module doesn't exist.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85029404a6672a4d0d0d519148be5b133324530f"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA4MTcxNA==", "bodyText": "Done", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25122#discussion_r469081714", "createdAt": "2020-08-12T08:09:13Z", "author": {"login": "IrushiL"}, "path": "misc/formatter/modules/formatter-cli/src/main/java/org/ballerinalang/formatter/cli/FormatUtil.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.cli;\n+\n+import org.ballerinalang.compiler.CompilerPhase;\n+import org.ballerinalang.formatter.core.Formatter;\n+import org.ballerinalang.tool.BLauncherCmd;\n+import org.ballerinalang.tool.LauncherUtils;\n+import org.wso2.ballerinalang.compiler.Compiler;\n+import org.wso2.ballerinalang.compiler.tree.BLangCompilationUnit;\n+import org.wso2.ballerinalang.compiler.tree.BLangPackage;\n+import org.wso2.ballerinalang.compiler.tree.BLangTestablePackage;\n+import org.wso2.ballerinalang.compiler.util.CompilerContext;\n+import org.wso2.ballerinalang.compiler.util.CompilerOptions;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.io.PrintStream;\n+import java.io.UnsupportedEncodingException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+\n+import static org.ballerinalang.compiler.CompilerOptionName.COMPILER_PHASE;\n+import static org.ballerinalang.compiler.CompilerOptionName.EXPERIMENTAL_FEATURES_ENABLED;\n+import static org.ballerinalang.compiler.CompilerOptionName.LOCK_ENABLED;\n+import static org.ballerinalang.compiler.CompilerOptionName.NEW_PARSER_ENABLED;\n+import static org.ballerinalang.compiler.CompilerOptionName.OFFLINE;\n+import static org.ballerinalang.compiler.CompilerOptionName.PRESERVE_WHITESPACE;\n+import static org.ballerinalang.compiler.CompilerOptionName.PROJECT_DIR;\n+import static org.ballerinalang.compiler.CompilerOptionName.SKIP_TESTS;\n+import static org.ballerinalang.compiler.CompilerOptionName.TEST_ENABLED;\n+\n+/**\n+ * Util class for compilation and format execution for formatting CLI tool.\n+ */\n+class FormatUtil {\n+    static final String CMD_NAME = \"format\";\n+    private static final PrintStream outStream = System.err;\n+    private static EmptyPrintStream emptyPrintStream;\n+\n+    /**\n+     * Execute formatter.\n+     *\n+     * @param argList        argument list from the console\n+     * @param helpFlag       flag to get the help page\n+     * @param dryRun         run the whole formatting\n+     * @param sourceRootPath execution path\n+     */\n+    static void execute(List<String> argList, boolean helpFlag, boolean dryRun, Path sourceRootPath) {\n+        if (helpFlag) {\n+            String commandUsageInfo = BLauncherCmd.getCommandUsageInfo(CMD_NAME);\n+            outStream.println(commandUsageInfo);\n+            return;\n+        }\n+\n+        if (argList != null && argList.size() > 1) {\n+            throw LauncherUtils.createLauncherException(Messages.getArgumentError());\n+        }\n+\n+        String moduleName;\n+        String ballerinaFilePath;\n+\n+        try {\n+            // If parameters are available user has given either the module name or the ballerina file path.\n+            // Else user is in a ballerina project and expecting to format the whole ballerina project\n+            if (argList != null && !argList.isEmpty()) {\n+                if (FormatUtil.isBalFile(argList.get(0))) {\n+                    ballerinaFilePath = argList.get(0);\n+                    Path filePath = Paths.get(ballerinaFilePath);\n+\n+                    // If the file doesn't exist or is a directory.\n+                    if (!filePath.toFile().exists() || filePath.toFile().isDirectory()) {\n+                        throw LauncherUtils.createLauncherException(Messages.getNoBallerinaFile(ballerinaFilePath));\n+                    }\n+\n+                    String source = new String(Files.readAllBytes(filePath), StandardCharsets.UTF_8);\n+                    // Format and get the generated formatted source code content.\n+                    String formattedSourceCode = Formatter.format(source);\n+\n+                    if (doChangesAvailable(source, formattedSourceCode)) {\n+                        if (!dryRun) {\n+                            // Write the formatted content back to the file.\n+                            FormatUtil.writeFile(filePath.toAbsolutePath().toString(), formattedSourceCode);\n+                            outStream.println(Messages.getModifiedFiles() + System.lineSeparator() + ballerinaFilePath);\n+                            outStream.println(System.lineSeparator() + Messages.getSuccessMessage());\n+                        } else {\n+                            outStream.println(Messages.getFilesToModify() + System.lineSeparator() + ballerinaFilePath);\n+                        }\n+                    } else {\n+                        outStream.println(Messages.getNoChanges());\n+                    }\n+                } else if (Paths.get(argList.get(0)).toFile().isFile()) {\n+                    // If file is a regular file but not a ballerina source file\n+                    // throw the following exception.\n+                    throw LauncherUtils.createLauncherException(Messages.getNotABallerinaFile());\n+                } else {\n+                    moduleName = argList.get(0);\n+\n+                    // Check whether the module dir exists.\n+                    if (!FormatUtil.isModuleExist(moduleName, sourceRootPath)) {\n+                        // If module directory doesn't exist and contains a \".\"\n+                        // throw a exception to say file or module doesn't exist.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA1NzY4OA=="}, "originalCommit": {"oid": "85029404a6672a4d0d0d519148be5b133324530f"}, "originalPosition": 123}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMDgxMzMxOnYy", "diffSide": "RIGHT", "path": "misc/formatter/modules/formatter-cli/src/main/java/org/ballerinalang/formatter/cli/FormatUtil.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwNzoyNDozOVrOG_VBfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwODowODo0NlrOG_Wdhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA1NzkxNw==", "bodyText": "Should tests run ?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25122#discussion_r469057917", "createdAt": "2020-08-12T07:24:39Z", "author": {"login": "hemikak"}, "path": "misc/formatter/modules/formatter-cli/src/main/java/org/ballerinalang/formatter/cli/FormatUtil.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.cli;\n+\n+import org.ballerinalang.compiler.CompilerPhase;\n+import org.ballerinalang.formatter.core.Formatter;\n+import org.ballerinalang.tool.BLauncherCmd;\n+import org.ballerinalang.tool.LauncherUtils;\n+import org.wso2.ballerinalang.compiler.Compiler;\n+import org.wso2.ballerinalang.compiler.tree.BLangCompilationUnit;\n+import org.wso2.ballerinalang.compiler.tree.BLangPackage;\n+import org.wso2.ballerinalang.compiler.tree.BLangTestablePackage;\n+import org.wso2.ballerinalang.compiler.util.CompilerContext;\n+import org.wso2.ballerinalang.compiler.util.CompilerOptions;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.io.PrintStream;\n+import java.io.UnsupportedEncodingException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+\n+import static org.ballerinalang.compiler.CompilerOptionName.COMPILER_PHASE;\n+import static org.ballerinalang.compiler.CompilerOptionName.EXPERIMENTAL_FEATURES_ENABLED;\n+import static org.ballerinalang.compiler.CompilerOptionName.LOCK_ENABLED;\n+import static org.ballerinalang.compiler.CompilerOptionName.NEW_PARSER_ENABLED;\n+import static org.ballerinalang.compiler.CompilerOptionName.OFFLINE;\n+import static org.ballerinalang.compiler.CompilerOptionName.PRESERVE_WHITESPACE;\n+import static org.ballerinalang.compiler.CompilerOptionName.PROJECT_DIR;\n+import static org.ballerinalang.compiler.CompilerOptionName.SKIP_TESTS;\n+import static org.ballerinalang.compiler.CompilerOptionName.TEST_ENABLED;\n+\n+/**\n+ * Util class for compilation and format execution for formatting CLI tool.\n+ */\n+class FormatUtil {\n+    static final String CMD_NAME = \"format\";\n+    private static final PrintStream outStream = System.err;\n+    private static EmptyPrintStream emptyPrintStream;\n+\n+    /**\n+     * Execute formatter.\n+     *\n+     * @param argList        argument list from the console\n+     * @param helpFlag       flag to get the help page\n+     * @param dryRun         run the whole formatting\n+     * @param sourceRootPath execution path\n+     */\n+    static void execute(List<String> argList, boolean helpFlag, boolean dryRun, Path sourceRootPath) {\n+        if (helpFlag) {\n+            String commandUsageInfo = BLauncherCmd.getCommandUsageInfo(CMD_NAME);\n+            outStream.println(commandUsageInfo);\n+            return;\n+        }\n+\n+        if (argList != null && argList.size() > 1) {\n+            throw LauncherUtils.createLauncherException(Messages.getArgumentError());\n+        }\n+\n+        String moduleName;\n+        String ballerinaFilePath;\n+\n+        try {\n+            // If parameters are available user has given either the module name or the ballerina file path.\n+            // Else user is in a ballerina project and expecting to format the whole ballerina project\n+            if (argList != null && !argList.isEmpty()) {\n+                if (FormatUtil.isBalFile(argList.get(0))) {\n+                    ballerinaFilePath = argList.get(0);\n+                    Path filePath = Paths.get(ballerinaFilePath);\n+\n+                    // If the file doesn't exist or is a directory.\n+                    if (!filePath.toFile().exists() || filePath.toFile().isDirectory()) {\n+                        throw LauncherUtils.createLauncherException(Messages.getNoBallerinaFile(ballerinaFilePath));\n+                    }\n+\n+                    String source = new String(Files.readAllBytes(filePath), StandardCharsets.UTF_8);\n+                    // Format and get the generated formatted source code content.\n+                    String formattedSourceCode = Formatter.format(source);\n+\n+                    if (doChangesAvailable(source, formattedSourceCode)) {\n+                        if (!dryRun) {\n+                            // Write the formatted content back to the file.\n+                            FormatUtil.writeFile(filePath.toAbsolutePath().toString(), formattedSourceCode);\n+                            outStream.println(Messages.getModifiedFiles() + System.lineSeparator() + ballerinaFilePath);\n+                            outStream.println(System.lineSeparator() + Messages.getSuccessMessage());\n+                        } else {\n+                            outStream.println(Messages.getFilesToModify() + System.lineSeparator() + ballerinaFilePath);\n+                        }\n+                    } else {\n+                        outStream.println(Messages.getNoChanges());\n+                    }\n+                } else if (Paths.get(argList.get(0)).toFile().isFile()) {\n+                    // If file is a regular file but not a ballerina source file\n+                    // throw the following exception.\n+                    throw LauncherUtils.createLauncherException(Messages.getNotABallerinaFile());\n+                } else {\n+                    moduleName = argList.get(0);\n+\n+                    // Check whether the module dir exists.\n+                    if (!FormatUtil.isModuleExist(moduleName, sourceRootPath)) {\n+                        // If module directory doesn't exist and contains a \".\"\n+                        // throw a exception to say file or module doesn't exist.\n+                        // Else throw a exception to say module doesn't exist.\n+                        if (moduleName.contains(\".\")) {\n+                            throw LauncherUtils.createLauncherException(Messages\n+                                    .getNoBallerinaModuleOrFile(moduleName));\n+                        } else {\n+                            throw LauncherUtils.createLauncherException(Messages.getNoModuleFound(moduleName));\n+                        }\n+                    }\n+\n+                    // Check whether the given directory is not in a ballerina project.\n+                    if (FormatUtil.notABallerinaProject(sourceRootPath)) {\n+                        throw LauncherUtils.createLauncherException(Messages.getNotBallerinaProject());\n+                    }\n+                    BLangPackage bLangPackage = FormatUtil\n+                            .compileModule(sourceRootPath, getModuleName(moduleName));\n+\n+                    // Iterate and format the ballerina package.\n+                    List<String> formattedFiles = iterateAndFormat(bLangPackage, sourceRootPath, dryRun);\n+                    generateChangeReport(formattedFiles, dryRun);\n+                }\n+            } else {\n+                List<BLangPackage> packages = FormatUtil.compileProject(sourceRootPath);\n+                List<String> formattedFiles = new ArrayList<>();\n+                // Iterate and format all the ballerina packages.\n+                for (BLangPackage bLangPackage : packages) {\n+                    formattedFiles.addAll(iterateAndFormat(bLangPackage, sourceRootPath, dryRun));\n+                }\n+\n+                generateChangeReport(formattedFiles, dryRun);\n+            }\n+        } catch (IOException | NullPointerException e) {\n+            throw LauncherUtils.createLauncherException(Messages.getException());\n+        }\n+    }\n+\n+    private static void generateChangeReport(List<String> formattedFiles, boolean dryRun) {\n+        if (!formattedFiles.isEmpty()) {\n+            StringBuilder fileList = new StringBuilder();\n+            if (dryRun) {\n+                fileList.append(Messages.getFilesToModify()).append(System.lineSeparator());\n+            } else {\n+                fileList.append(Messages.getModifiedFiles()).append(System.lineSeparator());\n+            }\n+            for (String file : formattedFiles) {\n+                fileList.append(file).append(System.lineSeparator());\n+            }\n+            outStream.println(fileList.toString());\n+            if (!dryRun) {\n+                outStream.println(Messages.getSuccessMessage());\n+            }\n+        } else {\n+            outStream.println(Messages.getNoChanges());\n+        }\n+    }\n+\n+    private static String getModuleName(String moduleName) {\n+        String pattern = Pattern.quote(File.separator);\n+        String[] splitedTokens = moduleName.split(pattern);\n+        return splitedTokens[splitedTokens.length - 1];\n+    }\n+\n+    /**\n+     * Compile whole ballerina project.\n+     *\n+     * @param sourceRoot source root\n+     * @return {@link List<BLangPackage>} list of BLangPackages\n+     */\n+    private static List<BLangPackage> compileProject(Path sourceRoot) throws UnsupportedEncodingException {\n+        emptyPrintStream = new EmptyPrintStream();\n+        CompilerContext context = getCompilerContext(sourceRoot);\n+        Compiler compiler = Compiler.getInstance(context);\n+        // Set an EmptyPrintStream to hide unnecessary outputs from compiler.\n+        compiler.setOutStream(emptyPrintStream);\n+        return compiler.compilePackages(false);\n+    }\n+\n+    /**\n+     * Compile only a ballerina module.\n+     *\n+     * @param sourceRoot source root\n+     * @param moduleName name of the module to be compiled\n+     * @return {@link BLangPackage} ballerina package\n+     */\n+    private static BLangPackage compileModule(Path sourceRoot, String moduleName) throws UnsupportedEncodingException {\n+        emptyPrintStream = new EmptyPrintStream();\n+        CompilerContext context = getCompilerContext(sourceRoot);\n+        Compiler compiler = Compiler.getInstance(context);\n+        // Set an EmptyPrintStream to hide unnecessary outputs from compiler.\n+        compiler.setOutStream(emptyPrintStream);\n+        return compiler.compile(moduleName);\n+    }\n+\n+    private static void formatAndWrite(BLangCompilationUnit compilationUnit, Path sourceRootPath,\n+                                       List<String> formattedFiles, boolean dryRun) throws IOException {\n+        String fileName = sourceRootPath.toString() + File.separator\n+                + \"src\"\n+                + File.separator\n+                + compilationUnit.getPosition().getSource().getPackageName()\n+                + File.separator\n+                + compilationUnit.getPosition().getSource().getCompilationUnitName();\n+\n+        // Format and get the formatted source.\n+        String formattedSource = Formatter.format(new String(Files.readAllBytes(Paths.get(fileName)),\n+                StandardCharsets.UTF_8));\n+\n+        if (doChangesAvailable(formattedSource, formattedSource)) {\n+            if (!dryRun) {\n+                // Write formatted content to the file.\n+                FormatUtil.writeFile(fileName, formattedSource);\n+            }\n+            formattedFiles.add(fileName);\n+        }\n+    }\n+\n+    private static List<String> iterateAndFormat(BLangPackage bLangPackage, Path sourceRootPath, boolean dryRun)\n+            throws IOException {\n+        List<String> formattedFiles = new ArrayList<>();\n+\n+        // Iterate compilation units and format.\n+        for (BLangCompilationUnit compilationUnit : bLangPackage.getCompilationUnits()) {\n+            formatAndWrite(compilationUnit, sourceRootPath, formattedFiles, dryRun);\n+        }\n+\n+        // Iterate testable packages and format.\n+        for (BLangTestablePackage testablePackage : bLangPackage.getTestablePkgs()) {\n+            for (BLangCompilationUnit compilationUnit : testablePackage.getCompilationUnits()) {\n+                formatAndWrite(compilationUnit, sourceRootPath, formattedFiles, dryRun);\n+            }\n+        }\n+\n+        return formattedFiles;\n+    }\n+\n+    /**\n+     * Get prepared compiler context.\n+     *\n+     * @param sourceRootPath ballerina compilable source root path\n+     * @return {@link CompilerContext} compiler context\n+     */\n+    private static CompilerContext getCompilerContext(Path sourceRootPath) {\n+        CompilerPhase compilerPhase = CompilerPhase.DEFINE;\n+        CompilerContext context = new CompilerContext();\n+        CompilerOptions options = CompilerOptions.getInstance(context);\n+        options.put(PROJECT_DIR, sourceRootPath.toString());\n+        options.put(OFFLINE, Boolean.toString(false));\n+        options.put(COMPILER_PHASE, compilerPhase.toString());\n+        options.put(SKIP_TESTS, Boolean.toString(false));\n+        options.put(TEST_ENABLED, \"true\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85029404a6672a4d0d0d519148be5b133324530f"}, "originalPosition": 271}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA4MTQ3OA==", "bodyText": "Since this is for the formatting purpose, running tests is not required.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25122#discussion_r469081478", "createdAt": "2020-08-12T08:08:46Z", "author": {"login": "IrushiL"}, "path": "misc/formatter/modules/formatter-cli/src/main/java/org/ballerinalang/formatter/cli/FormatUtil.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.cli;\n+\n+import org.ballerinalang.compiler.CompilerPhase;\n+import org.ballerinalang.formatter.core.Formatter;\n+import org.ballerinalang.tool.BLauncherCmd;\n+import org.ballerinalang.tool.LauncherUtils;\n+import org.wso2.ballerinalang.compiler.Compiler;\n+import org.wso2.ballerinalang.compiler.tree.BLangCompilationUnit;\n+import org.wso2.ballerinalang.compiler.tree.BLangPackage;\n+import org.wso2.ballerinalang.compiler.tree.BLangTestablePackage;\n+import org.wso2.ballerinalang.compiler.util.CompilerContext;\n+import org.wso2.ballerinalang.compiler.util.CompilerOptions;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.io.PrintStream;\n+import java.io.UnsupportedEncodingException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+\n+import static org.ballerinalang.compiler.CompilerOptionName.COMPILER_PHASE;\n+import static org.ballerinalang.compiler.CompilerOptionName.EXPERIMENTAL_FEATURES_ENABLED;\n+import static org.ballerinalang.compiler.CompilerOptionName.LOCK_ENABLED;\n+import static org.ballerinalang.compiler.CompilerOptionName.NEW_PARSER_ENABLED;\n+import static org.ballerinalang.compiler.CompilerOptionName.OFFLINE;\n+import static org.ballerinalang.compiler.CompilerOptionName.PRESERVE_WHITESPACE;\n+import static org.ballerinalang.compiler.CompilerOptionName.PROJECT_DIR;\n+import static org.ballerinalang.compiler.CompilerOptionName.SKIP_TESTS;\n+import static org.ballerinalang.compiler.CompilerOptionName.TEST_ENABLED;\n+\n+/**\n+ * Util class for compilation and format execution for formatting CLI tool.\n+ */\n+class FormatUtil {\n+    static final String CMD_NAME = \"format\";\n+    private static final PrintStream outStream = System.err;\n+    private static EmptyPrintStream emptyPrintStream;\n+\n+    /**\n+     * Execute formatter.\n+     *\n+     * @param argList        argument list from the console\n+     * @param helpFlag       flag to get the help page\n+     * @param dryRun         run the whole formatting\n+     * @param sourceRootPath execution path\n+     */\n+    static void execute(List<String> argList, boolean helpFlag, boolean dryRun, Path sourceRootPath) {\n+        if (helpFlag) {\n+            String commandUsageInfo = BLauncherCmd.getCommandUsageInfo(CMD_NAME);\n+            outStream.println(commandUsageInfo);\n+            return;\n+        }\n+\n+        if (argList != null && argList.size() > 1) {\n+            throw LauncherUtils.createLauncherException(Messages.getArgumentError());\n+        }\n+\n+        String moduleName;\n+        String ballerinaFilePath;\n+\n+        try {\n+            // If parameters are available user has given either the module name or the ballerina file path.\n+            // Else user is in a ballerina project and expecting to format the whole ballerina project\n+            if (argList != null && !argList.isEmpty()) {\n+                if (FormatUtil.isBalFile(argList.get(0))) {\n+                    ballerinaFilePath = argList.get(0);\n+                    Path filePath = Paths.get(ballerinaFilePath);\n+\n+                    // If the file doesn't exist or is a directory.\n+                    if (!filePath.toFile().exists() || filePath.toFile().isDirectory()) {\n+                        throw LauncherUtils.createLauncherException(Messages.getNoBallerinaFile(ballerinaFilePath));\n+                    }\n+\n+                    String source = new String(Files.readAllBytes(filePath), StandardCharsets.UTF_8);\n+                    // Format and get the generated formatted source code content.\n+                    String formattedSourceCode = Formatter.format(source);\n+\n+                    if (doChangesAvailable(source, formattedSourceCode)) {\n+                        if (!dryRun) {\n+                            // Write the formatted content back to the file.\n+                            FormatUtil.writeFile(filePath.toAbsolutePath().toString(), formattedSourceCode);\n+                            outStream.println(Messages.getModifiedFiles() + System.lineSeparator() + ballerinaFilePath);\n+                            outStream.println(System.lineSeparator() + Messages.getSuccessMessage());\n+                        } else {\n+                            outStream.println(Messages.getFilesToModify() + System.lineSeparator() + ballerinaFilePath);\n+                        }\n+                    } else {\n+                        outStream.println(Messages.getNoChanges());\n+                    }\n+                } else if (Paths.get(argList.get(0)).toFile().isFile()) {\n+                    // If file is a regular file but not a ballerina source file\n+                    // throw the following exception.\n+                    throw LauncherUtils.createLauncherException(Messages.getNotABallerinaFile());\n+                } else {\n+                    moduleName = argList.get(0);\n+\n+                    // Check whether the module dir exists.\n+                    if (!FormatUtil.isModuleExist(moduleName, sourceRootPath)) {\n+                        // If module directory doesn't exist and contains a \".\"\n+                        // throw a exception to say file or module doesn't exist.\n+                        // Else throw a exception to say module doesn't exist.\n+                        if (moduleName.contains(\".\")) {\n+                            throw LauncherUtils.createLauncherException(Messages\n+                                    .getNoBallerinaModuleOrFile(moduleName));\n+                        } else {\n+                            throw LauncherUtils.createLauncherException(Messages.getNoModuleFound(moduleName));\n+                        }\n+                    }\n+\n+                    // Check whether the given directory is not in a ballerina project.\n+                    if (FormatUtil.notABallerinaProject(sourceRootPath)) {\n+                        throw LauncherUtils.createLauncherException(Messages.getNotBallerinaProject());\n+                    }\n+                    BLangPackage bLangPackage = FormatUtil\n+                            .compileModule(sourceRootPath, getModuleName(moduleName));\n+\n+                    // Iterate and format the ballerina package.\n+                    List<String> formattedFiles = iterateAndFormat(bLangPackage, sourceRootPath, dryRun);\n+                    generateChangeReport(formattedFiles, dryRun);\n+                }\n+            } else {\n+                List<BLangPackage> packages = FormatUtil.compileProject(sourceRootPath);\n+                List<String> formattedFiles = new ArrayList<>();\n+                // Iterate and format all the ballerina packages.\n+                for (BLangPackage bLangPackage : packages) {\n+                    formattedFiles.addAll(iterateAndFormat(bLangPackage, sourceRootPath, dryRun));\n+                }\n+\n+                generateChangeReport(formattedFiles, dryRun);\n+            }\n+        } catch (IOException | NullPointerException e) {\n+            throw LauncherUtils.createLauncherException(Messages.getException());\n+        }\n+    }\n+\n+    private static void generateChangeReport(List<String> formattedFiles, boolean dryRun) {\n+        if (!formattedFiles.isEmpty()) {\n+            StringBuilder fileList = new StringBuilder();\n+            if (dryRun) {\n+                fileList.append(Messages.getFilesToModify()).append(System.lineSeparator());\n+            } else {\n+                fileList.append(Messages.getModifiedFiles()).append(System.lineSeparator());\n+            }\n+            for (String file : formattedFiles) {\n+                fileList.append(file).append(System.lineSeparator());\n+            }\n+            outStream.println(fileList.toString());\n+            if (!dryRun) {\n+                outStream.println(Messages.getSuccessMessage());\n+            }\n+        } else {\n+            outStream.println(Messages.getNoChanges());\n+        }\n+    }\n+\n+    private static String getModuleName(String moduleName) {\n+        String pattern = Pattern.quote(File.separator);\n+        String[] splitedTokens = moduleName.split(pattern);\n+        return splitedTokens[splitedTokens.length - 1];\n+    }\n+\n+    /**\n+     * Compile whole ballerina project.\n+     *\n+     * @param sourceRoot source root\n+     * @return {@link List<BLangPackage>} list of BLangPackages\n+     */\n+    private static List<BLangPackage> compileProject(Path sourceRoot) throws UnsupportedEncodingException {\n+        emptyPrintStream = new EmptyPrintStream();\n+        CompilerContext context = getCompilerContext(sourceRoot);\n+        Compiler compiler = Compiler.getInstance(context);\n+        // Set an EmptyPrintStream to hide unnecessary outputs from compiler.\n+        compiler.setOutStream(emptyPrintStream);\n+        return compiler.compilePackages(false);\n+    }\n+\n+    /**\n+     * Compile only a ballerina module.\n+     *\n+     * @param sourceRoot source root\n+     * @param moduleName name of the module to be compiled\n+     * @return {@link BLangPackage} ballerina package\n+     */\n+    private static BLangPackage compileModule(Path sourceRoot, String moduleName) throws UnsupportedEncodingException {\n+        emptyPrintStream = new EmptyPrintStream();\n+        CompilerContext context = getCompilerContext(sourceRoot);\n+        Compiler compiler = Compiler.getInstance(context);\n+        // Set an EmptyPrintStream to hide unnecessary outputs from compiler.\n+        compiler.setOutStream(emptyPrintStream);\n+        return compiler.compile(moduleName);\n+    }\n+\n+    private static void formatAndWrite(BLangCompilationUnit compilationUnit, Path sourceRootPath,\n+                                       List<String> formattedFiles, boolean dryRun) throws IOException {\n+        String fileName = sourceRootPath.toString() + File.separator\n+                + \"src\"\n+                + File.separator\n+                + compilationUnit.getPosition().getSource().getPackageName()\n+                + File.separator\n+                + compilationUnit.getPosition().getSource().getCompilationUnitName();\n+\n+        // Format and get the formatted source.\n+        String formattedSource = Formatter.format(new String(Files.readAllBytes(Paths.get(fileName)),\n+                StandardCharsets.UTF_8));\n+\n+        if (doChangesAvailable(formattedSource, formattedSource)) {\n+            if (!dryRun) {\n+                // Write formatted content to the file.\n+                FormatUtil.writeFile(fileName, formattedSource);\n+            }\n+            formattedFiles.add(fileName);\n+        }\n+    }\n+\n+    private static List<String> iterateAndFormat(BLangPackage bLangPackage, Path sourceRootPath, boolean dryRun)\n+            throws IOException {\n+        List<String> formattedFiles = new ArrayList<>();\n+\n+        // Iterate compilation units and format.\n+        for (BLangCompilationUnit compilationUnit : bLangPackage.getCompilationUnits()) {\n+            formatAndWrite(compilationUnit, sourceRootPath, formattedFiles, dryRun);\n+        }\n+\n+        // Iterate testable packages and format.\n+        for (BLangTestablePackage testablePackage : bLangPackage.getTestablePkgs()) {\n+            for (BLangCompilationUnit compilationUnit : testablePackage.getCompilationUnits()) {\n+                formatAndWrite(compilationUnit, sourceRootPath, formattedFiles, dryRun);\n+            }\n+        }\n+\n+        return formattedFiles;\n+    }\n+\n+    /**\n+     * Get prepared compiler context.\n+     *\n+     * @param sourceRootPath ballerina compilable source root path\n+     * @return {@link CompilerContext} compiler context\n+     */\n+    private static CompilerContext getCompilerContext(Path sourceRootPath) {\n+        CompilerPhase compilerPhase = CompilerPhase.DEFINE;\n+        CompilerContext context = new CompilerContext();\n+        CompilerOptions options = CompilerOptions.getInstance(context);\n+        options.put(PROJECT_DIR, sourceRootPath.toString());\n+        options.put(OFFLINE, Boolean.toString(false));\n+        options.put(COMPILER_PHASE, compilerPhase.toString());\n+        options.put(SKIP_TESTS, Boolean.toString(false));\n+        options.put(TEST_ENABLED, \"true\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA1NzkxNw=="}, "originalCommit": {"oid": "85029404a6672a4d0d0d519148be5b133324530f"}, "originalPosition": 271}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMDgxNzg1OnYy", "diffSide": "RIGHT", "path": "misc/formatter/modules/formatter-cli/src/main/java/org/ballerinalang/formatter/cli/FormatUtil.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwNzoyNjowMlrOG_VEMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwODowNzo1N1rOG_Wb0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA1ODYwOQ==", "bodyText": "Better function name would be isBallerinaProject instead of negative reply.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25122#discussion_r469058609", "createdAt": "2020-08-12T07:26:02Z", "author": {"login": "hemikak"}, "path": "misc/formatter/modules/formatter-cli/src/main/java/org/ballerinalang/formatter/cli/FormatUtil.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.cli;\n+\n+import org.ballerinalang.compiler.CompilerPhase;\n+import org.ballerinalang.formatter.core.Formatter;\n+import org.ballerinalang.tool.BLauncherCmd;\n+import org.ballerinalang.tool.LauncherUtils;\n+import org.wso2.ballerinalang.compiler.Compiler;\n+import org.wso2.ballerinalang.compiler.tree.BLangCompilationUnit;\n+import org.wso2.ballerinalang.compiler.tree.BLangPackage;\n+import org.wso2.ballerinalang.compiler.tree.BLangTestablePackage;\n+import org.wso2.ballerinalang.compiler.util.CompilerContext;\n+import org.wso2.ballerinalang.compiler.util.CompilerOptions;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.io.PrintStream;\n+import java.io.UnsupportedEncodingException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+\n+import static org.ballerinalang.compiler.CompilerOptionName.COMPILER_PHASE;\n+import static org.ballerinalang.compiler.CompilerOptionName.EXPERIMENTAL_FEATURES_ENABLED;\n+import static org.ballerinalang.compiler.CompilerOptionName.LOCK_ENABLED;\n+import static org.ballerinalang.compiler.CompilerOptionName.NEW_PARSER_ENABLED;\n+import static org.ballerinalang.compiler.CompilerOptionName.OFFLINE;\n+import static org.ballerinalang.compiler.CompilerOptionName.PRESERVE_WHITESPACE;\n+import static org.ballerinalang.compiler.CompilerOptionName.PROJECT_DIR;\n+import static org.ballerinalang.compiler.CompilerOptionName.SKIP_TESTS;\n+import static org.ballerinalang.compiler.CompilerOptionName.TEST_ENABLED;\n+\n+/**\n+ * Util class for compilation and format execution for formatting CLI tool.\n+ */\n+class FormatUtil {\n+    static final String CMD_NAME = \"format\";\n+    private static final PrintStream outStream = System.err;\n+    private static EmptyPrintStream emptyPrintStream;\n+\n+    /**\n+     * Execute formatter.\n+     *\n+     * @param argList        argument list from the console\n+     * @param helpFlag       flag to get the help page\n+     * @param dryRun         run the whole formatting\n+     * @param sourceRootPath execution path\n+     */\n+    static void execute(List<String> argList, boolean helpFlag, boolean dryRun, Path sourceRootPath) {\n+        if (helpFlag) {\n+            String commandUsageInfo = BLauncherCmd.getCommandUsageInfo(CMD_NAME);\n+            outStream.println(commandUsageInfo);\n+            return;\n+        }\n+\n+        if (argList != null && argList.size() > 1) {\n+            throw LauncherUtils.createLauncherException(Messages.getArgumentError());\n+        }\n+\n+        String moduleName;\n+        String ballerinaFilePath;\n+\n+        try {\n+            // If parameters are available user has given either the module name or the ballerina file path.\n+            // Else user is in a ballerina project and expecting to format the whole ballerina project\n+            if (argList != null && !argList.isEmpty()) {\n+                if (FormatUtil.isBalFile(argList.get(0))) {\n+                    ballerinaFilePath = argList.get(0);\n+                    Path filePath = Paths.get(ballerinaFilePath);\n+\n+                    // If the file doesn't exist or is a directory.\n+                    if (!filePath.toFile().exists() || filePath.toFile().isDirectory()) {\n+                        throw LauncherUtils.createLauncherException(Messages.getNoBallerinaFile(ballerinaFilePath));\n+                    }\n+\n+                    String source = new String(Files.readAllBytes(filePath), StandardCharsets.UTF_8);\n+                    // Format and get the generated formatted source code content.\n+                    String formattedSourceCode = Formatter.format(source);\n+\n+                    if (doChangesAvailable(source, formattedSourceCode)) {\n+                        if (!dryRun) {\n+                            // Write the formatted content back to the file.\n+                            FormatUtil.writeFile(filePath.toAbsolutePath().toString(), formattedSourceCode);\n+                            outStream.println(Messages.getModifiedFiles() + System.lineSeparator() + ballerinaFilePath);\n+                            outStream.println(System.lineSeparator() + Messages.getSuccessMessage());\n+                        } else {\n+                            outStream.println(Messages.getFilesToModify() + System.lineSeparator() + ballerinaFilePath);\n+                        }\n+                    } else {\n+                        outStream.println(Messages.getNoChanges());\n+                    }\n+                } else if (Paths.get(argList.get(0)).toFile().isFile()) {\n+                    // If file is a regular file but not a ballerina source file\n+                    // throw the following exception.\n+                    throw LauncherUtils.createLauncherException(Messages.getNotABallerinaFile());\n+                } else {\n+                    moduleName = argList.get(0);\n+\n+                    // Check whether the module dir exists.\n+                    if (!FormatUtil.isModuleExist(moduleName, sourceRootPath)) {\n+                        // If module directory doesn't exist and contains a \".\"\n+                        // throw a exception to say file or module doesn't exist.\n+                        // Else throw a exception to say module doesn't exist.\n+                        if (moduleName.contains(\".\")) {\n+                            throw LauncherUtils.createLauncherException(Messages\n+                                    .getNoBallerinaModuleOrFile(moduleName));\n+                        } else {\n+                            throw LauncherUtils.createLauncherException(Messages.getNoModuleFound(moduleName));\n+                        }\n+                    }\n+\n+                    // Check whether the given directory is not in a ballerina project.\n+                    if (FormatUtil.notABallerinaProject(sourceRootPath)) {\n+                        throw LauncherUtils.createLauncherException(Messages.getNotBallerinaProject());\n+                    }\n+                    BLangPackage bLangPackage = FormatUtil\n+                            .compileModule(sourceRootPath, getModuleName(moduleName));\n+\n+                    // Iterate and format the ballerina package.\n+                    List<String> formattedFiles = iterateAndFormat(bLangPackage, sourceRootPath, dryRun);\n+                    generateChangeReport(formattedFiles, dryRun);\n+                }\n+            } else {\n+                List<BLangPackage> packages = FormatUtil.compileProject(sourceRootPath);\n+                List<String> formattedFiles = new ArrayList<>();\n+                // Iterate and format all the ballerina packages.\n+                for (BLangPackage bLangPackage : packages) {\n+                    formattedFiles.addAll(iterateAndFormat(bLangPackage, sourceRootPath, dryRun));\n+                }\n+\n+                generateChangeReport(formattedFiles, dryRun);\n+            }\n+        } catch (IOException | NullPointerException e) {\n+            throw LauncherUtils.createLauncherException(Messages.getException());\n+        }\n+    }\n+\n+    private static void generateChangeReport(List<String> formattedFiles, boolean dryRun) {\n+        if (!formattedFiles.isEmpty()) {\n+            StringBuilder fileList = new StringBuilder();\n+            if (dryRun) {\n+                fileList.append(Messages.getFilesToModify()).append(System.lineSeparator());\n+            } else {\n+                fileList.append(Messages.getModifiedFiles()).append(System.lineSeparator());\n+            }\n+            for (String file : formattedFiles) {\n+                fileList.append(file).append(System.lineSeparator());\n+            }\n+            outStream.println(fileList.toString());\n+            if (!dryRun) {\n+                outStream.println(Messages.getSuccessMessage());\n+            }\n+        } else {\n+            outStream.println(Messages.getNoChanges());\n+        }\n+    }\n+\n+    private static String getModuleName(String moduleName) {\n+        String pattern = Pattern.quote(File.separator);\n+        String[] splitedTokens = moduleName.split(pattern);\n+        return splitedTokens[splitedTokens.length - 1];\n+    }\n+\n+    /**\n+     * Compile whole ballerina project.\n+     *\n+     * @param sourceRoot source root\n+     * @return {@link List<BLangPackage>} list of BLangPackages\n+     */\n+    private static List<BLangPackage> compileProject(Path sourceRoot) throws UnsupportedEncodingException {\n+        emptyPrintStream = new EmptyPrintStream();\n+        CompilerContext context = getCompilerContext(sourceRoot);\n+        Compiler compiler = Compiler.getInstance(context);\n+        // Set an EmptyPrintStream to hide unnecessary outputs from compiler.\n+        compiler.setOutStream(emptyPrintStream);\n+        return compiler.compilePackages(false);\n+    }\n+\n+    /**\n+     * Compile only a ballerina module.\n+     *\n+     * @param sourceRoot source root\n+     * @param moduleName name of the module to be compiled\n+     * @return {@link BLangPackage} ballerina package\n+     */\n+    private static BLangPackage compileModule(Path sourceRoot, String moduleName) throws UnsupportedEncodingException {\n+        emptyPrintStream = new EmptyPrintStream();\n+        CompilerContext context = getCompilerContext(sourceRoot);\n+        Compiler compiler = Compiler.getInstance(context);\n+        // Set an EmptyPrintStream to hide unnecessary outputs from compiler.\n+        compiler.setOutStream(emptyPrintStream);\n+        return compiler.compile(moduleName);\n+    }\n+\n+    private static void formatAndWrite(BLangCompilationUnit compilationUnit, Path sourceRootPath,\n+                                       List<String> formattedFiles, boolean dryRun) throws IOException {\n+        String fileName = sourceRootPath.toString() + File.separator\n+                + \"src\"\n+                + File.separator\n+                + compilationUnit.getPosition().getSource().getPackageName()\n+                + File.separator\n+                + compilationUnit.getPosition().getSource().getCompilationUnitName();\n+\n+        // Format and get the formatted source.\n+        String formattedSource = Formatter.format(new String(Files.readAllBytes(Paths.get(fileName)),\n+                StandardCharsets.UTF_8));\n+\n+        if (doChangesAvailable(formattedSource, formattedSource)) {\n+            if (!dryRun) {\n+                // Write formatted content to the file.\n+                FormatUtil.writeFile(fileName, formattedSource);\n+            }\n+            formattedFiles.add(fileName);\n+        }\n+    }\n+\n+    private static List<String> iterateAndFormat(BLangPackage bLangPackage, Path sourceRootPath, boolean dryRun)\n+            throws IOException {\n+        List<String> formattedFiles = new ArrayList<>();\n+\n+        // Iterate compilation units and format.\n+        for (BLangCompilationUnit compilationUnit : bLangPackage.getCompilationUnits()) {\n+            formatAndWrite(compilationUnit, sourceRootPath, formattedFiles, dryRun);\n+        }\n+\n+        // Iterate testable packages and format.\n+        for (BLangTestablePackage testablePackage : bLangPackage.getTestablePkgs()) {\n+            for (BLangCompilationUnit compilationUnit : testablePackage.getCompilationUnits()) {\n+                formatAndWrite(compilationUnit, sourceRootPath, formattedFiles, dryRun);\n+            }\n+        }\n+\n+        return formattedFiles;\n+    }\n+\n+    /**\n+     * Get prepared compiler context.\n+     *\n+     * @param sourceRootPath ballerina compilable source root path\n+     * @return {@link CompilerContext} compiler context\n+     */\n+    private static CompilerContext getCompilerContext(Path sourceRootPath) {\n+        CompilerPhase compilerPhase = CompilerPhase.DEFINE;\n+        CompilerContext context = new CompilerContext();\n+        CompilerOptions options = CompilerOptions.getInstance(context);\n+        options.put(PROJECT_DIR, sourceRootPath.toString());\n+        options.put(OFFLINE, Boolean.toString(false));\n+        options.put(COMPILER_PHASE, compilerPhase.toString());\n+        options.put(SKIP_TESTS, Boolean.toString(false));\n+        options.put(TEST_ENABLED, \"true\");\n+        options.put(LOCK_ENABLED, Boolean.toString(false));\n+        options.put(EXPERIMENTAL_FEATURES_ENABLED, Boolean.toString(true));\n+        options.put(PRESERVE_WHITESPACE, Boolean.toString(true));\n+        options.put(NEW_PARSER_ENABLED, Boolean.toString(false));\n+\n+        return context;\n+    }\n+\n+    /**\n+     * Check whether the given module name exists.\n+     *\n+     * @param module      module name\n+     * @param projectRoot path of the ballerina project root\n+     * @return {@link Boolean} true or false\n+     */\n+    private static boolean isModuleExist(String module, Path projectRoot) {\n+        Path modulePath;\n+        if (module.startsWith(\"src/\")) {\n+            modulePath = projectRoot.resolve(module);\n+        } else {\n+            modulePath = projectRoot.resolve(\"src\").resolve(module);\n+        }\n+\n+        return modulePath.toFile().isDirectory();\n+    }\n+\n+    /**\n+     * Check whether the given path isn't a source root of a ballerina project.\n+     *\n+     * @param path - path where the command is executed from\n+     * @return {@link boolean} true or false\n+     */\n+    private static boolean notABallerinaProject(Path path) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85029404a6672a4d0d0d519148be5b133324530f"}, "originalPosition": 304}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA4MTA0MA==", "bodyText": "Done", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25122#discussion_r469081040", "createdAt": "2020-08-12T08:07:57Z", "author": {"login": "IrushiL"}, "path": "misc/formatter/modules/formatter-cli/src/main/java/org/ballerinalang/formatter/cli/FormatUtil.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.cli;\n+\n+import org.ballerinalang.compiler.CompilerPhase;\n+import org.ballerinalang.formatter.core.Formatter;\n+import org.ballerinalang.tool.BLauncherCmd;\n+import org.ballerinalang.tool.LauncherUtils;\n+import org.wso2.ballerinalang.compiler.Compiler;\n+import org.wso2.ballerinalang.compiler.tree.BLangCompilationUnit;\n+import org.wso2.ballerinalang.compiler.tree.BLangPackage;\n+import org.wso2.ballerinalang.compiler.tree.BLangTestablePackage;\n+import org.wso2.ballerinalang.compiler.util.CompilerContext;\n+import org.wso2.ballerinalang.compiler.util.CompilerOptions;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.io.PrintStream;\n+import java.io.UnsupportedEncodingException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+\n+import static org.ballerinalang.compiler.CompilerOptionName.COMPILER_PHASE;\n+import static org.ballerinalang.compiler.CompilerOptionName.EXPERIMENTAL_FEATURES_ENABLED;\n+import static org.ballerinalang.compiler.CompilerOptionName.LOCK_ENABLED;\n+import static org.ballerinalang.compiler.CompilerOptionName.NEW_PARSER_ENABLED;\n+import static org.ballerinalang.compiler.CompilerOptionName.OFFLINE;\n+import static org.ballerinalang.compiler.CompilerOptionName.PRESERVE_WHITESPACE;\n+import static org.ballerinalang.compiler.CompilerOptionName.PROJECT_DIR;\n+import static org.ballerinalang.compiler.CompilerOptionName.SKIP_TESTS;\n+import static org.ballerinalang.compiler.CompilerOptionName.TEST_ENABLED;\n+\n+/**\n+ * Util class for compilation and format execution for formatting CLI tool.\n+ */\n+class FormatUtil {\n+    static final String CMD_NAME = \"format\";\n+    private static final PrintStream outStream = System.err;\n+    private static EmptyPrintStream emptyPrintStream;\n+\n+    /**\n+     * Execute formatter.\n+     *\n+     * @param argList        argument list from the console\n+     * @param helpFlag       flag to get the help page\n+     * @param dryRun         run the whole formatting\n+     * @param sourceRootPath execution path\n+     */\n+    static void execute(List<String> argList, boolean helpFlag, boolean dryRun, Path sourceRootPath) {\n+        if (helpFlag) {\n+            String commandUsageInfo = BLauncherCmd.getCommandUsageInfo(CMD_NAME);\n+            outStream.println(commandUsageInfo);\n+            return;\n+        }\n+\n+        if (argList != null && argList.size() > 1) {\n+            throw LauncherUtils.createLauncherException(Messages.getArgumentError());\n+        }\n+\n+        String moduleName;\n+        String ballerinaFilePath;\n+\n+        try {\n+            // If parameters are available user has given either the module name or the ballerina file path.\n+            // Else user is in a ballerina project and expecting to format the whole ballerina project\n+            if (argList != null && !argList.isEmpty()) {\n+                if (FormatUtil.isBalFile(argList.get(0))) {\n+                    ballerinaFilePath = argList.get(0);\n+                    Path filePath = Paths.get(ballerinaFilePath);\n+\n+                    // If the file doesn't exist or is a directory.\n+                    if (!filePath.toFile().exists() || filePath.toFile().isDirectory()) {\n+                        throw LauncherUtils.createLauncherException(Messages.getNoBallerinaFile(ballerinaFilePath));\n+                    }\n+\n+                    String source = new String(Files.readAllBytes(filePath), StandardCharsets.UTF_8);\n+                    // Format and get the generated formatted source code content.\n+                    String formattedSourceCode = Formatter.format(source);\n+\n+                    if (doChangesAvailable(source, formattedSourceCode)) {\n+                        if (!dryRun) {\n+                            // Write the formatted content back to the file.\n+                            FormatUtil.writeFile(filePath.toAbsolutePath().toString(), formattedSourceCode);\n+                            outStream.println(Messages.getModifiedFiles() + System.lineSeparator() + ballerinaFilePath);\n+                            outStream.println(System.lineSeparator() + Messages.getSuccessMessage());\n+                        } else {\n+                            outStream.println(Messages.getFilesToModify() + System.lineSeparator() + ballerinaFilePath);\n+                        }\n+                    } else {\n+                        outStream.println(Messages.getNoChanges());\n+                    }\n+                } else if (Paths.get(argList.get(0)).toFile().isFile()) {\n+                    // If file is a regular file but not a ballerina source file\n+                    // throw the following exception.\n+                    throw LauncherUtils.createLauncherException(Messages.getNotABallerinaFile());\n+                } else {\n+                    moduleName = argList.get(0);\n+\n+                    // Check whether the module dir exists.\n+                    if (!FormatUtil.isModuleExist(moduleName, sourceRootPath)) {\n+                        // If module directory doesn't exist and contains a \".\"\n+                        // throw a exception to say file or module doesn't exist.\n+                        // Else throw a exception to say module doesn't exist.\n+                        if (moduleName.contains(\".\")) {\n+                            throw LauncherUtils.createLauncherException(Messages\n+                                    .getNoBallerinaModuleOrFile(moduleName));\n+                        } else {\n+                            throw LauncherUtils.createLauncherException(Messages.getNoModuleFound(moduleName));\n+                        }\n+                    }\n+\n+                    // Check whether the given directory is not in a ballerina project.\n+                    if (FormatUtil.notABallerinaProject(sourceRootPath)) {\n+                        throw LauncherUtils.createLauncherException(Messages.getNotBallerinaProject());\n+                    }\n+                    BLangPackage bLangPackage = FormatUtil\n+                            .compileModule(sourceRootPath, getModuleName(moduleName));\n+\n+                    // Iterate and format the ballerina package.\n+                    List<String> formattedFiles = iterateAndFormat(bLangPackage, sourceRootPath, dryRun);\n+                    generateChangeReport(formattedFiles, dryRun);\n+                }\n+            } else {\n+                List<BLangPackage> packages = FormatUtil.compileProject(sourceRootPath);\n+                List<String> formattedFiles = new ArrayList<>();\n+                // Iterate and format all the ballerina packages.\n+                for (BLangPackage bLangPackage : packages) {\n+                    formattedFiles.addAll(iterateAndFormat(bLangPackage, sourceRootPath, dryRun));\n+                }\n+\n+                generateChangeReport(formattedFiles, dryRun);\n+            }\n+        } catch (IOException | NullPointerException e) {\n+            throw LauncherUtils.createLauncherException(Messages.getException());\n+        }\n+    }\n+\n+    private static void generateChangeReport(List<String> formattedFiles, boolean dryRun) {\n+        if (!formattedFiles.isEmpty()) {\n+            StringBuilder fileList = new StringBuilder();\n+            if (dryRun) {\n+                fileList.append(Messages.getFilesToModify()).append(System.lineSeparator());\n+            } else {\n+                fileList.append(Messages.getModifiedFiles()).append(System.lineSeparator());\n+            }\n+            for (String file : formattedFiles) {\n+                fileList.append(file).append(System.lineSeparator());\n+            }\n+            outStream.println(fileList.toString());\n+            if (!dryRun) {\n+                outStream.println(Messages.getSuccessMessage());\n+            }\n+        } else {\n+            outStream.println(Messages.getNoChanges());\n+        }\n+    }\n+\n+    private static String getModuleName(String moduleName) {\n+        String pattern = Pattern.quote(File.separator);\n+        String[] splitedTokens = moduleName.split(pattern);\n+        return splitedTokens[splitedTokens.length - 1];\n+    }\n+\n+    /**\n+     * Compile whole ballerina project.\n+     *\n+     * @param sourceRoot source root\n+     * @return {@link List<BLangPackage>} list of BLangPackages\n+     */\n+    private static List<BLangPackage> compileProject(Path sourceRoot) throws UnsupportedEncodingException {\n+        emptyPrintStream = new EmptyPrintStream();\n+        CompilerContext context = getCompilerContext(sourceRoot);\n+        Compiler compiler = Compiler.getInstance(context);\n+        // Set an EmptyPrintStream to hide unnecessary outputs from compiler.\n+        compiler.setOutStream(emptyPrintStream);\n+        return compiler.compilePackages(false);\n+    }\n+\n+    /**\n+     * Compile only a ballerina module.\n+     *\n+     * @param sourceRoot source root\n+     * @param moduleName name of the module to be compiled\n+     * @return {@link BLangPackage} ballerina package\n+     */\n+    private static BLangPackage compileModule(Path sourceRoot, String moduleName) throws UnsupportedEncodingException {\n+        emptyPrintStream = new EmptyPrintStream();\n+        CompilerContext context = getCompilerContext(sourceRoot);\n+        Compiler compiler = Compiler.getInstance(context);\n+        // Set an EmptyPrintStream to hide unnecessary outputs from compiler.\n+        compiler.setOutStream(emptyPrintStream);\n+        return compiler.compile(moduleName);\n+    }\n+\n+    private static void formatAndWrite(BLangCompilationUnit compilationUnit, Path sourceRootPath,\n+                                       List<String> formattedFiles, boolean dryRun) throws IOException {\n+        String fileName = sourceRootPath.toString() + File.separator\n+                + \"src\"\n+                + File.separator\n+                + compilationUnit.getPosition().getSource().getPackageName()\n+                + File.separator\n+                + compilationUnit.getPosition().getSource().getCompilationUnitName();\n+\n+        // Format and get the formatted source.\n+        String formattedSource = Formatter.format(new String(Files.readAllBytes(Paths.get(fileName)),\n+                StandardCharsets.UTF_8));\n+\n+        if (doChangesAvailable(formattedSource, formattedSource)) {\n+            if (!dryRun) {\n+                // Write formatted content to the file.\n+                FormatUtil.writeFile(fileName, formattedSource);\n+            }\n+            formattedFiles.add(fileName);\n+        }\n+    }\n+\n+    private static List<String> iterateAndFormat(BLangPackage bLangPackage, Path sourceRootPath, boolean dryRun)\n+            throws IOException {\n+        List<String> formattedFiles = new ArrayList<>();\n+\n+        // Iterate compilation units and format.\n+        for (BLangCompilationUnit compilationUnit : bLangPackage.getCompilationUnits()) {\n+            formatAndWrite(compilationUnit, sourceRootPath, formattedFiles, dryRun);\n+        }\n+\n+        // Iterate testable packages and format.\n+        for (BLangTestablePackage testablePackage : bLangPackage.getTestablePkgs()) {\n+            for (BLangCompilationUnit compilationUnit : testablePackage.getCompilationUnits()) {\n+                formatAndWrite(compilationUnit, sourceRootPath, formattedFiles, dryRun);\n+            }\n+        }\n+\n+        return formattedFiles;\n+    }\n+\n+    /**\n+     * Get prepared compiler context.\n+     *\n+     * @param sourceRootPath ballerina compilable source root path\n+     * @return {@link CompilerContext} compiler context\n+     */\n+    private static CompilerContext getCompilerContext(Path sourceRootPath) {\n+        CompilerPhase compilerPhase = CompilerPhase.DEFINE;\n+        CompilerContext context = new CompilerContext();\n+        CompilerOptions options = CompilerOptions.getInstance(context);\n+        options.put(PROJECT_DIR, sourceRootPath.toString());\n+        options.put(OFFLINE, Boolean.toString(false));\n+        options.put(COMPILER_PHASE, compilerPhase.toString());\n+        options.put(SKIP_TESTS, Boolean.toString(false));\n+        options.put(TEST_ENABLED, \"true\");\n+        options.put(LOCK_ENABLED, Boolean.toString(false));\n+        options.put(EXPERIMENTAL_FEATURES_ENABLED, Boolean.toString(true));\n+        options.put(PRESERVE_WHITESPACE, Boolean.toString(true));\n+        options.put(NEW_PARSER_ENABLED, Boolean.toString(false));\n+\n+        return context;\n+    }\n+\n+    /**\n+     * Check whether the given module name exists.\n+     *\n+     * @param module      module name\n+     * @param projectRoot path of the ballerina project root\n+     * @return {@link Boolean} true or false\n+     */\n+    private static boolean isModuleExist(String module, Path projectRoot) {\n+        Path modulePath;\n+        if (module.startsWith(\"src/\")) {\n+            modulePath = projectRoot.resolve(module);\n+        } else {\n+            modulePath = projectRoot.resolve(\"src\").resolve(module);\n+        }\n+\n+        return modulePath.toFile().isDirectory();\n+    }\n+\n+    /**\n+     * Check whether the given path isn't a source root of a ballerina project.\n+     *\n+     * @param path - path where the command is executed from\n+     * @return {@link boolean} true or false\n+     */\n+    private static boolean notABallerinaProject(Path path) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA1ODYwOQ=="}, "originalCommit": {"oid": "85029404a6672a4d0d0d519148be5b133324530f"}, "originalPosition": 304}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMDgxOTc0OnYy", "diffSide": "RIGHT", "path": "misc/formatter/modules/formatter-cli/src/main/java/org/ballerinalang/formatter/cli/FormatUtil.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwNzoyNjo0MFrOG_VFXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwODowNTozN1rOG_WXPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA1ODkwOA==", "bodyText": "Shall we append the original exception e as well? That would  give more information on the error.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25122#discussion_r469058908", "createdAt": "2020-08-12T07:26:40Z", "author": {"login": "azinneera"}, "path": "misc/formatter/modules/formatter-cli/src/main/java/org/ballerinalang/formatter/cli/FormatUtil.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.cli;\n+\n+import org.ballerinalang.compiler.CompilerPhase;\n+import org.ballerinalang.formatter.core.Formatter;\n+import org.ballerinalang.tool.BLauncherCmd;\n+import org.ballerinalang.tool.LauncherUtils;\n+import org.wso2.ballerinalang.compiler.Compiler;\n+import org.wso2.ballerinalang.compiler.tree.BLangCompilationUnit;\n+import org.wso2.ballerinalang.compiler.tree.BLangPackage;\n+import org.wso2.ballerinalang.compiler.tree.BLangTestablePackage;\n+import org.wso2.ballerinalang.compiler.util.CompilerContext;\n+import org.wso2.ballerinalang.compiler.util.CompilerOptions;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.io.PrintStream;\n+import java.io.UnsupportedEncodingException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+\n+import static org.ballerinalang.compiler.CompilerOptionName.COMPILER_PHASE;\n+import static org.ballerinalang.compiler.CompilerOptionName.EXPERIMENTAL_FEATURES_ENABLED;\n+import static org.ballerinalang.compiler.CompilerOptionName.LOCK_ENABLED;\n+import static org.ballerinalang.compiler.CompilerOptionName.NEW_PARSER_ENABLED;\n+import static org.ballerinalang.compiler.CompilerOptionName.OFFLINE;\n+import static org.ballerinalang.compiler.CompilerOptionName.PRESERVE_WHITESPACE;\n+import static org.ballerinalang.compiler.CompilerOptionName.PROJECT_DIR;\n+import static org.ballerinalang.compiler.CompilerOptionName.SKIP_TESTS;\n+import static org.ballerinalang.compiler.CompilerOptionName.TEST_ENABLED;\n+\n+/**\n+ * Util class for compilation and format execution for formatting CLI tool.\n+ */\n+class FormatUtil {\n+    static final String CMD_NAME = \"format\";\n+    private static final PrintStream outStream = System.err;\n+    private static EmptyPrintStream emptyPrintStream;\n+\n+    /**\n+     * Execute formatter.\n+     *\n+     * @param argList        argument list from the console\n+     * @param helpFlag       flag to get the help page\n+     * @param dryRun         run the whole formatting\n+     * @param sourceRootPath execution path\n+     */\n+    static void execute(List<String> argList, boolean helpFlag, boolean dryRun, Path sourceRootPath) {\n+        if (helpFlag) {\n+            String commandUsageInfo = BLauncherCmd.getCommandUsageInfo(CMD_NAME);\n+            outStream.println(commandUsageInfo);\n+            return;\n+        }\n+\n+        if (argList != null && argList.size() > 1) {\n+            throw LauncherUtils.createLauncherException(Messages.getArgumentError());\n+        }\n+\n+        String moduleName;\n+        String ballerinaFilePath;\n+\n+        try {\n+            // If parameters are available user has given either the module name or the ballerina file path.\n+            // Else user is in a ballerina project and expecting to format the whole ballerina project\n+            if (argList != null && !argList.isEmpty()) {\n+                if (FormatUtil.isBalFile(argList.get(0))) {\n+                    ballerinaFilePath = argList.get(0);\n+                    Path filePath = Paths.get(ballerinaFilePath);\n+\n+                    // If the file doesn't exist or is a directory.\n+                    if (!filePath.toFile().exists() || filePath.toFile().isDirectory()) {\n+                        throw LauncherUtils.createLauncherException(Messages.getNoBallerinaFile(ballerinaFilePath));\n+                    }\n+\n+                    String source = new String(Files.readAllBytes(filePath), StandardCharsets.UTF_8);\n+                    // Format and get the generated formatted source code content.\n+                    String formattedSourceCode = Formatter.format(source);\n+\n+                    if (doChangesAvailable(source, formattedSourceCode)) {\n+                        if (!dryRun) {\n+                            // Write the formatted content back to the file.\n+                            FormatUtil.writeFile(filePath.toAbsolutePath().toString(), formattedSourceCode);\n+                            outStream.println(Messages.getModifiedFiles() + System.lineSeparator() + ballerinaFilePath);\n+                            outStream.println(System.lineSeparator() + Messages.getSuccessMessage());\n+                        } else {\n+                            outStream.println(Messages.getFilesToModify() + System.lineSeparator() + ballerinaFilePath);\n+                        }\n+                    } else {\n+                        outStream.println(Messages.getNoChanges());\n+                    }\n+                } else if (Paths.get(argList.get(0)).toFile().isFile()) {\n+                    // If file is a regular file but not a ballerina source file\n+                    // throw the following exception.\n+                    throw LauncherUtils.createLauncherException(Messages.getNotABallerinaFile());\n+                } else {\n+                    moduleName = argList.get(0);\n+\n+                    // Check whether the module dir exists.\n+                    if (!FormatUtil.isModuleExist(moduleName, sourceRootPath)) {\n+                        // If module directory doesn't exist and contains a \".\"\n+                        // throw a exception to say file or module doesn't exist.\n+                        // Else throw a exception to say module doesn't exist.\n+                        if (moduleName.contains(\".\")) {\n+                            throw LauncherUtils.createLauncherException(Messages\n+                                    .getNoBallerinaModuleOrFile(moduleName));\n+                        } else {\n+                            throw LauncherUtils.createLauncherException(Messages.getNoModuleFound(moduleName));\n+                        }\n+                    }\n+\n+                    // Check whether the given directory is not in a ballerina project.\n+                    if (FormatUtil.notABallerinaProject(sourceRootPath)) {\n+                        throw LauncherUtils.createLauncherException(Messages.getNotBallerinaProject());\n+                    }\n+                    BLangPackage bLangPackage = FormatUtil\n+                            .compileModule(sourceRootPath, getModuleName(moduleName));\n+\n+                    // Iterate and format the ballerina package.\n+                    List<String> formattedFiles = iterateAndFormat(bLangPackage, sourceRootPath, dryRun);\n+                    generateChangeReport(formattedFiles, dryRun);\n+                }\n+            } else {\n+                List<BLangPackage> packages = FormatUtil.compileProject(sourceRootPath);\n+                List<String> formattedFiles = new ArrayList<>();\n+                // Iterate and format all the ballerina packages.\n+                for (BLangPackage bLangPackage : packages) {\n+                    formattedFiles.addAll(iterateAndFormat(bLangPackage, sourceRootPath, dryRun));\n+                }\n+\n+                generateChangeReport(formattedFiles, dryRun);\n+            }\n+        } catch (IOException | NullPointerException e) {\n+            throw LauncherUtils.createLauncherException(Messages.getException());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85029404a6672a4d0d0d519148be5b133324530f"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA3OTg3MA==", "bodyText": "Done", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25122#discussion_r469079870", "createdAt": "2020-08-12T08:05:37Z", "author": {"login": "IrushiL"}, "path": "misc/formatter/modules/formatter-cli/src/main/java/org/ballerinalang/formatter/cli/FormatUtil.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.cli;\n+\n+import org.ballerinalang.compiler.CompilerPhase;\n+import org.ballerinalang.formatter.core.Formatter;\n+import org.ballerinalang.tool.BLauncherCmd;\n+import org.ballerinalang.tool.LauncherUtils;\n+import org.wso2.ballerinalang.compiler.Compiler;\n+import org.wso2.ballerinalang.compiler.tree.BLangCompilationUnit;\n+import org.wso2.ballerinalang.compiler.tree.BLangPackage;\n+import org.wso2.ballerinalang.compiler.tree.BLangTestablePackage;\n+import org.wso2.ballerinalang.compiler.util.CompilerContext;\n+import org.wso2.ballerinalang.compiler.util.CompilerOptions;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.io.PrintStream;\n+import java.io.UnsupportedEncodingException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+\n+import static org.ballerinalang.compiler.CompilerOptionName.COMPILER_PHASE;\n+import static org.ballerinalang.compiler.CompilerOptionName.EXPERIMENTAL_FEATURES_ENABLED;\n+import static org.ballerinalang.compiler.CompilerOptionName.LOCK_ENABLED;\n+import static org.ballerinalang.compiler.CompilerOptionName.NEW_PARSER_ENABLED;\n+import static org.ballerinalang.compiler.CompilerOptionName.OFFLINE;\n+import static org.ballerinalang.compiler.CompilerOptionName.PRESERVE_WHITESPACE;\n+import static org.ballerinalang.compiler.CompilerOptionName.PROJECT_DIR;\n+import static org.ballerinalang.compiler.CompilerOptionName.SKIP_TESTS;\n+import static org.ballerinalang.compiler.CompilerOptionName.TEST_ENABLED;\n+\n+/**\n+ * Util class for compilation and format execution for formatting CLI tool.\n+ */\n+class FormatUtil {\n+    static final String CMD_NAME = \"format\";\n+    private static final PrintStream outStream = System.err;\n+    private static EmptyPrintStream emptyPrintStream;\n+\n+    /**\n+     * Execute formatter.\n+     *\n+     * @param argList        argument list from the console\n+     * @param helpFlag       flag to get the help page\n+     * @param dryRun         run the whole formatting\n+     * @param sourceRootPath execution path\n+     */\n+    static void execute(List<String> argList, boolean helpFlag, boolean dryRun, Path sourceRootPath) {\n+        if (helpFlag) {\n+            String commandUsageInfo = BLauncherCmd.getCommandUsageInfo(CMD_NAME);\n+            outStream.println(commandUsageInfo);\n+            return;\n+        }\n+\n+        if (argList != null && argList.size() > 1) {\n+            throw LauncherUtils.createLauncherException(Messages.getArgumentError());\n+        }\n+\n+        String moduleName;\n+        String ballerinaFilePath;\n+\n+        try {\n+            // If parameters are available user has given either the module name or the ballerina file path.\n+            // Else user is in a ballerina project and expecting to format the whole ballerina project\n+            if (argList != null && !argList.isEmpty()) {\n+                if (FormatUtil.isBalFile(argList.get(0))) {\n+                    ballerinaFilePath = argList.get(0);\n+                    Path filePath = Paths.get(ballerinaFilePath);\n+\n+                    // If the file doesn't exist or is a directory.\n+                    if (!filePath.toFile().exists() || filePath.toFile().isDirectory()) {\n+                        throw LauncherUtils.createLauncherException(Messages.getNoBallerinaFile(ballerinaFilePath));\n+                    }\n+\n+                    String source = new String(Files.readAllBytes(filePath), StandardCharsets.UTF_8);\n+                    // Format and get the generated formatted source code content.\n+                    String formattedSourceCode = Formatter.format(source);\n+\n+                    if (doChangesAvailable(source, formattedSourceCode)) {\n+                        if (!dryRun) {\n+                            // Write the formatted content back to the file.\n+                            FormatUtil.writeFile(filePath.toAbsolutePath().toString(), formattedSourceCode);\n+                            outStream.println(Messages.getModifiedFiles() + System.lineSeparator() + ballerinaFilePath);\n+                            outStream.println(System.lineSeparator() + Messages.getSuccessMessage());\n+                        } else {\n+                            outStream.println(Messages.getFilesToModify() + System.lineSeparator() + ballerinaFilePath);\n+                        }\n+                    } else {\n+                        outStream.println(Messages.getNoChanges());\n+                    }\n+                } else if (Paths.get(argList.get(0)).toFile().isFile()) {\n+                    // If file is a regular file but not a ballerina source file\n+                    // throw the following exception.\n+                    throw LauncherUtils.createLauncherException(Messages.getNotABallerinaFile());\n+                } else {\n+                    moduleName = argList.get(0);\n+\n+                    // Check whether the module dir exists.\n+                    if (!FormatUtil.isModuleExist(moduleName, sourceRootPath)) {\n+                        // If module directory doesn't exist and contains a \".\"\n+                        // throw a exception to say file or module doesn't exist.\n+                        // Else throw a exception to say module doesn't exist.\n+                        if (moduleName.contains(\".\")) {\n+                            throw LauncherUtils.createLauncherException(Messages\n+                                    .getNoBallerinaModuleOrFile(moduleName));\n+                        } else {\n+                            throw LauncherUtils.createLauncherException(Messages.getNoModuleFound(moduleName));\n+                        }\n+                    }\n+\n+                    // Check whether the given directory is not in a ballerina project.\n+                    if (FormatUtil.notABallerinaProject(sourceRootPath)) {\n+                        throw LauncherUtils.createLauncherException(Messages.getNotBallerinaProject());\n+                    }\n+                    BLangPackage bLangPackage = FormatUtil\n+                            .compileModule(sourceRootPath, getModuleName(moduleName));\n+\n+                    // Iterate and format the ballerina package.\n+                    List<String> formattedFiles = iterateAndFormat(bLangPackage, sourceRootPath, dryRun);\n+                    generateChangeReport(formattedFiles, dryRun);\n+                }\n+            } else {\n+                List<BLangPackage> packages = FormatUtil.compileProject(sourceRootPath);\n+                List<String> formattedFiles = new ArrayList<>();\n+                // Iterate and format all the ballerina packages.\n+                for (BLangPackage bLangPackage : packages) {\n+                    formattedFiles.addAll(iterateAndFormat(bLangPackage, sourceRootPath, dryRun));\n+                }\n+\n+                generateChangeReport(formattedFiles, dryRun);\n+            }\n+        } catch (IOException | NullPointerException e) {\n+            throw LauncherUtils.createLauncherException(Messages.getException());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA1ODkwOA=="}, "originalCommit": {"oid": "85029404a6672a4d0d0d519148be5b133324530f"}, "originalPosition": 155}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMDgxOTkxOnYy", "diffSide": "RIGHT", "path": "misc/formatter/modules/formatter-cli/src/main/java/org/ballerinalang/formatter/cli/FormatUtil.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwNzoyNjo0NFrOG_VFeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwODowNToyNlrOG_WW7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA1ODkzNw==", "bodyText": "Does areChangesAvailable makes sense instead of doChangesAvailable ?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25122#discussion_r469058937", "createdAt": "2020-08-12T07:26:44Z", "author": {"login": "hemikak"}, "path": "misc/formatter/modules/formatter-cli/src/main/java/org/ballerinalang/formatter/cli/FormatUtil.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.cli;\n+\n+import org.ballerinalang.compiler.CompilerPhase;\n+import org.ballerinalang.formatter.core.Formatter;\n+import org.ballerinalang.tool.BLauncherCmd;\n+import org.ballerinalang.tool.LauncherUtils;\n+import org.wso2.ballerinalang.compiler.Compiler;\n+import org.wso2.ballerinalang.compiler.tree.BLangCompilationUnit;\n+import org.wso2.ballerinalang.compiler.tree.BLangPackage;\n+import org.wso2.ballerinalang.compiler.tree.BLangTestablePackage;\n+import org.wso2.ballerinalang.compiler.util.CompilerContext;\n+import org.wso2.ballerinalang.compiler.util.CompilerOptions;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.io.PrintStream;\n+import java.io.UnsupportedEncodingException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+\n+import static org.ballerinalang.compiler.CompilerOptionName.COMPILER_PHASE;\n+import static org.ballerinalang.compiler.CompilerOptionName.EXPERIMENTAL_FEATURES_ENABLED;\n+import static org.ballerinalang.compiler.CompilerOptionName.LOCK_ENABLED;\n+import static org.ballerinalang.compiler.CompilerOptionName.NEW_PARSER_ENABLED;\n+import static org.ballerinalang.compiler.CompilerOptionName.OFFLINE;\n+import static org.ballerinalang.compiler.CompilerOptionName.PRESERVE_WHITESPACE;\n+import static org.ballerinalang.compiler.CompilerOptionName.PROJECT_DIR;\n+import static org.ballerinalang.compiler.CompilerOptionName.SKIP_TESTS;\n+import static org.ballerinalang.compiler.CompilerOptionName.TEST_ENABLED;\n+\n+/**\n+ * Util class for compilation and format execution for formatting CLI tool.\n+ */\n+class FormatUtil {\n+    static final String CMD_NAME = \"format\";\n+    private static final PrintStream outStream = System.err;\n+    private static EmptyPrintStream emptyPrintStream;\n+\n+    /**\n+     * Execute formatter.\n+     *\n+     * @param argList        argument list from the console\n+     * @param helpFlag       flag to get the help page\n+     * @param dryRun         run the whole formatting\n+     * @param sourceRootPath execution path\n+     */\n+    static void execute(List<String> argList, boolean helpFlag, boolean dryRun, Path sourceRootPath) {\n+        if (helpFlag) {\n+            String commandUsageInfo = BLauncherCmd.getCommandUsageInfo(CMD_NAME);\n+            outStream.println(commandUsageInfo);\n+            return;\n+        }\n+\n+        if (argList != null && argList.size() > 1) {\n+            throw LauncherUtils.createLauncherException(Messages.getArgumentError());\n+        }\n+\n+        String moduleName;\n+        String ballerinaFilePath;\n+\n+        try {\n+            // If parameters are available user has given either the module name or the ballerina file path.\n+            // Else user is in a ballerina project and expecting to format the whole ballerina project\n+            if (argList != null && !argList.isEmpty()) {\n+                if (FormatUtil.isBalFile(argList.get(0))) {\n+                    ballerinaFilePath = argList.get(0);\n+                    Path filePath = Paths.get(ballerinaFilePath);\n+\n+                    // If the file doesn't exist or is a directory.\n+                    if (!filePath.toFile().exists() || filePath.toFile().isDirectory()) {\n+                        throw LauncherUtils.createLauncherException(Messages.getNoBallerinaFile(ballerinaFilePath));\n+                    }\n+\n+                    String source = new String(Files.readAllBytes(filePath), StandardCharsets.UTF_8);\n+                    // Format and get the generated formatted source code content.\n+                    String formattedSourceCode = Formatter.format(source);\n+\n+                    if (doChangesAvailable(source, formattedSourceCode)) {\n+                        if (!dryRun) {\n+                            // Write the formatted content back to the file.\n+                            FormatUtil.writeFile(filePath.toAbsolutePath().toString(), formattedSourceCode);\n+                            outStream.println(Messages.getModifiedFiles() + System.lineSeparator() + ballerinaFilePath);\n+                            outStream.println(System.lineSeparator() + Messages.getSuccessMessage());\n+                        } else {\n+                            outStream.println(Messages.getFilesToModify() + System.lineSeparator() + ballerinaFilePath);\n+                        }\n+                    } else {\n+                        outStream.println(Messages.getNoChanges());\n+                    }\n+                } else if (Paths.get(argList.get(0)).toFile().isFile()) {\n+                    // If file is a regular file but not a ballerina source file\n+                    // throw the following exception.\n+                    throw LauncherUtils.createLauncherException(Messages.getNotABallerinaFile());\n+                } else {\n+                    moduleName = argList.get(0);\n+\n+                    // Check whether the module dir exists.\n+                    if (!FormatUtil.isModuleExist(moduleName, sourceRootPath)) {\n+                        // If module directory doesn't exist and contains a \".\"\n+                        // throw a exception to say file or module doesn't exist.\n+                        // Else throw a exception to say module doesn't exist.\n+                        if (moduleName.contains(\".\")) {\n+                            throw LauncherUtils.createLauncherException(Messages\n+                                    .getNoBallerinaModuleOrFile(moduleName));\n+                        } else {\n+                            throw LauncherUtils.createLauncherException(Messages.getNoModuleFound(moduleName));\n+                        }\n+                    }\n+\n+                    // Check whether the given directory is not in a ballerina project.\n+                    if (FormatUtil.notABallerinaProject(sourceRootPath)) {\n+                        throw LauncherUtils.createLauncherException(Messages.getNotBallerinaProject());\n+                    }\n+                    BLangPackage bLangPackage = FormatUtil\n+                            .compileModule(sourceRootPath, getModuleName(moduleName));\n+\n+                    // Iterate and format the ballerina package.\n+                    List<String> formattedFiles = iterateAndFormat(bLangPackage, sourceRootPath, dryRun);\n+                    generateChangeReport(formattedFiles, dryRun);\n+                }\n+            } else {\n+                List<BLangPackage> packages = FormatUtil.compileProject(sourceRootPath);\n+                List<String> formattedFiles = new ArrayList<>();\n+                // Iterate and format all the ballerina packages.\n+                for (BLangPackage bLangPackage : packages) {\n+                    formattedFiles.addAll(iterateAndFormat(bLangPackage, sourceRootPath, dryRun));\n+                }\n+\n+                generateChangeReport(formattedFiles, dryRun);\n+            }\n+        } catch (IOException | NullPointerException e) {\n+            throw LauncherUtils.createLauncherException(Messages.getException());\n+        }\n+    }\n+\n+    private static void generateChangeReport(List<String> formattedFiles, boolean dryRun) {\n+        if (!formattedFiles.isEmpty()) {\n+            StringBuilder fileList = new StringBuilder();\n+            if (dryRun) {\n+                fileList.append(Messages.getFilesToModify()).append(System.lineSeparator());\n+            } else {\n+                fileList.append(Messages.getModifiedFiles()).append(System.lineSeparator());\n+            }\n+            for (String file : formattedFiles) {\n+                fileList.append(file).append(System.lineSeparator());\n+            }\n+            outStream.println(fileList.toString());\n+            if (!dryRun) {\n+                outStream.println(Messages.getSuccessMessage());\n+            }\n+        } else {\n+            outStream.println(Messages.getNoChanges());\n+        }\n+    }\n+\n+    private static String getModuleName(String moduleName) {\n+        String pattern = Pattern.quote(File.separator);\n+        String[] splitedTokens = moduleName.split(pattern);\n+        return splitedTokens[splitedTokens.length - 1];\n+    }\n+\n+    /**\n+     * Compile whole ballerina project.\n+     *\n+     * @param sourceRoot source root\n+     * @return {@link List<BLangPackage>} list of BLangPackages\n+     */\n+    private static List<BLangPackage> compileProject(Path sourceRoot) throws UnsupportedEncodingException {\n+        emptyPrintStream = new EmptyPrintStream();\n+        CompilerContext context = getCompilerContext(sourceRoot);\n+        Compiler compiler = Compiler.getInstance(context);\n+        // Set an EmptyPrintStream to hide unnecessary outputs from compiler.\n+        compiler.setOutStream(emptyPrintStream);\n+        return compiler.compilePackages(false);\n+    }\n+\n+    /**\n+     * Compile only a ballerina module.\n+     *\n+     * @param sourceRoot source root\n+     * @param moduleName name of the module to be compiled\n+     * @return {@link BLangPackage} ballerina package\n+     */\n+    private static BLangPackage compileModule(Path sourceRoot, String moduleName) throws UnsupportedEncodingException {\n+        emptyPrintStream = new EmptyPrintStream();\n+        CompilerContext context = getCompilerContext(sourceRoot);\n+        Compiler compiler = Compiler.getInstance(context);\n+        // Set an EmptyPrintStream to hide unnecessary outputs from compiler.\n+        compiler.setOutStream(emptyPrintStream);\n+        return compiler.compile(moduleName);\n+    }\n+\n+    private static void formatAndWrite(BLangCompilationUnit compilationUnit, Path sourceRootPath,\n+                                       List<String> formattedFiles, boolean dryRun) throws IOException {\n+        String fileName = sourceRootPath.toString() + File.separator\n+                + \"src\"\n+                + File.separator\n+                + compilationUnit.getPosition().getSource().getPackageName()\n+                + File.separator\n+                + compilationUnit.getPosition().getSource().getCompilationUnitName();\n+\n+        // Format and get the formatted source.\n+        String formattedSource = Formatter.format(new String(Files.readAllBytes(Paths.get(fileName)),\n+                StandardCharsets.UTF_8));\n+\n+        if (doChangesAvailable(formattedSource, formattedSource)) {\n+            if (!dryRun) {\n+                // Write formatted content to the file.\n+                FormatUtil.writeFile(fileName, formattedSource);\n+            }\n+            formattedFiles.add(fileName);\n+        }\n+    }\n+\n+    private static List<String> iterateAndFormat(BLangPackage bLangPackage, Path sourceRootPath, boolean dryRun)\n+            throws IOException {\n+        List<String> formattedFiles = new ArrayList<>();\n+\n+        // Iterate compilation units and format.\n+        for (BLangCompilationUnit compilationUnit : bLangPackage.getCompilationUnits()) {\n+            formatAndWrite(compilationUnit, sourceRootPath, formattedFiles, dryRun);\n+        }\n+\n+        // Iterate testable packages and format.\n+        for (BLangTestablePackage testablePackage : bLangPackage.getTestablePkgs()) {\n+            for (BLangCompilationUnit compilationUnit : testablePackage.getCompilationUnits()) {\n+                formatAndWrite(compilationUnit, sourceRootPath, formattedFiles, dryRun);\n+            }\n+        }\n+\n+        return formattedFiles;\n+    }\n+\n+    /**\n+     * Get prepared compiler context.\n+     *\n+     * @param sourceRootPath ballerina compilable source root path\n+     * @return {@link CompilerContext} compiler context\n+     */\n+    private static CompilerContext getCompilerContext(Path sourceRootPath) {\n+        CompilerPhase compilerPhase = CompilerPhase.DEFINE;\n+        CompilerContext context = new CompilerContext();\n+        CompilerOptions options = CompilerOptions.getInstance(context);\n+        options.put(PROJECT_DIR, sourceRootPath.toString());\n+        options.put(OFFLINE, Boolean.toString(false));\n+        options.put(COMPILER_PHASE, compilerPhase.toString());\n+        options.put(SKIP_TESTS, Boolean.toString(false));\n+        options.put(TEST_ENABLED, \"true\");\n+        options.put(LOCK_ENABLED, Boolean.toString(false));\n+        options.put(EXPERIMENTAL_FEATURES_ENABLED, Boolean.toString(true));\n+        options.put(PRESERVE_WHITESPACE, Boolean.toString(true));\n+        options.put(NEW_PARSER_ENABLED, Boolean.toString(false));\n+\n+        return context;\n+    }\n+\n+    /**\n+     * Check whether the given module name exists.\n+     *\n+     * @param module      module name\n+     * @param projectRoot path of the ballerina project root\n+     * @return {@link Boolean} true or false\n+     */\n+    private static boolean isModuleExist(String module, Path projectRoot) {\n+        Path modulePath;\n+        if (module.startsWith(\"src/\")) {\n+            modulePath = projectRoot.resolve(module);\n+        } else {\n+            modulePath = projectRoot.resolve(\"src\").resolve(module);\n+        }\n+\n+        return modulePath.toFile().isDirectory();\n+    }\n+\n+    /**\n+     * Check whether the given path isn't a source root of a ballerina project.\n+     *\n+     * @param path - path where the command is executed from\n+     * @return {@link boolean} true or false\n+     */\n+    private static boolean notABallerinaProject(Path path) {\n+        Path cachePath = path.resolve(\"Ballerina.toml\");\n+        return !cachePath.toFile().exists();\n+    }\n+\n+    /**\n+     * Write content to a file.\n+     *\n+     * @param filePath - path of the file to add the content\n+     * @param content  - content to be added to the file\n+     * @throws IOException - throws and IO exception\n+     */\n+    private static void writeFile(String filePath, String content) throws IOException {\n+        OutputStreamWriter fileWriter = null;\n+        try {\n+            try (FileOutputStream fileStream = new FileOutputStream(new File(filePath))) {\n+                fileWriter = new OutputStreamWriter(fileStream, StandardCharsets.UTF_8);\n+            }\n+            fileWriter.write(content);\n+        } finally {\n+            if (fileWriter != null) {\n+                fileWriter.close();\n+            }\n+        }\n+    }\n+\n+    private static boolean doChangesAvailable(String originalSource, String formattedSource) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85029404a6672a4d0d0d519148be5b133324530f"}, "originalPosition": 330}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA3OTc4OA==", "bodyText": "Done", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25122#discussion_r469079788", "createdAt": "2020-08-12T08:05:26Z", "author": {"login": "IrushiL"}, "path": "misc/formatter/modules/formatter-cli/src/main/java/org/ballerinalang/formatter/cli/FormatUtil.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.cli;\n+\n+import org.ballerinalang.compiler.CompilerPhase;\n+import org.ballerinalang.formatter.core.Formatter;\n+import org.ballerinalang.tool.BLauncherCmd;\n+import org.ballerinalang.tool.LauncherUtils;\n+import org.wso2.ballerinalang.compiler.Compiler;\n+import org.wso2.ballerinalang.compiler.tree.BLangCompilationUnit;\n+import org.wso2.ballerinalang.compiler.tree.BLangPackage;\n+import org.wso2.ballerinalang.compiler.tree.BLangTestablePackage;\n+import org.wso2.ballerinalang.compiler.util.CompilerContext;\n+import org.wso2.ballerinalang.compiler.util.CompilerOptions;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.io.PrintStream;\n+import java.io.UnsupportedEncodingException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+\n+import static org.ballerinalang.compiler.CompilerOptionName.COMPILER_PHASE;\n+import static org.ballerinalang.compiler.CompilerOptionName.EXPERIMENTAL_FEATURES_ENABLED;\n+import static org.ballerinalang.compiler.CompilerOptionName.LOCK_ENABLED;\n+import static org.ballerinalang.compiler.CompilerOptionName.NEW_PARSER_ENABLED;\n+import static org.ballerinalang.compiler.CompilerOptionName.OFFLINE;\n+import static org.ballerinalang.compiler.CompilerOptionName.PRESERVE_WHITESPACE;\n+import static org.ballerinalang.compiler.CompilerOptionName.PROJECT_DIR;\n+import static org.ballerinalang.compiler.CompilerOptionName.SKIP_TESTS;\n+import static org.ballerinalang.compiler.CompilerOptionName.TEST_ENABLED;\n+\n+/**\n+ * Util class for compilation and format execution for formatting CLI tool.\n+ */\n+class FormatUtil {\n+    static final String CMD_NAME = \"format\";\n+    private static final PrintStream outStream = System.err;\n+    private static EmptyPrintStream emptyPrintStream;\n+\n+    /**\n+     * Execute formatter.\n+     *\n+     * @param argList        argument list from the console\n+     * @param helpFlag       flag to get the help page\n+     * @param dryRun         run the whole formatting\n+     * @param sourceRootPath execution path\n+     */\n+    static void execute(List<String> argList, boolean helpFlag, boolean dryRun, Path sourceRootPath) {\n+        if (helpFlag) {\n+            String commandUsageInfo = BLauncherCmd.getCommandUsageInfo(CMD_NAME);\n+            outStream.println(commandUsageInfo);\n+            return;\n+        }\n+\n+        if (argList != null && argList.size() > 1) {\n+            throw LauncherUtils.createLauncherException(Messages.getArgumentError());\n+        }\n+\n+        String moduleName;\n+        String ballerinaFilePath;\n+\n+        try {\n+            // If parameters are available user has given either the module name or the ballerina file path.\n+            // Else user is in a ballerina project and expecting to format the whole ballerina project\n+            if (argList != null && !argList.isEmpty()) {\n+                if (FormatUtil.isBalFile(argList.get(0))) {\n+                    ballerinaFilePath = argList.get(0);\n+                    Path filePath = Paths.get(ballerinaFilePath);\n+\n+                    // If the file doesn't exist or is a directory.\n+                    if (!filePath.toFile().exists() || filePath.toFile().isDirectory()) {\n+                        throw LauncherUtils.createLauncherException(Messages.getNoBallerinaFile(ballerinaFilePath));\n+                    }\n+\n+                    String source = new String(Files.readAllBytes(filePath), StandardCharsets.UTF_8);\n+                    // Format and get the generated formatted source code content.\n+                    String formattedSourceCode = Formatter.format(source);\n+\n+                    if (doChangesAvailable(source, formattedSourceCode)) {\n+                        if (!dryRun) {\n+                            // Write the formatted content back to the file.\n+                            FormatUtil.writeFile(filePath.toAbsolutePath().toString(), formattedSourceCode);\n+                            outStream.println(Messages.getModifiedFiles() + System.lineSeparator() + ballerinaFilePath);\n+                            outStream.println(System.lineSeparator() + Messages.getSuccessMessage());\n+                        } else {\n+                            outStream.println(Messages.getFilesToModify() + System.lineSeparator() + ballerinaFilePath);\n+                        }\n+                    } else {\n+                        outStream.println(Messages.getNoChanges());\n+                    }\n+                } else if (Paths.get(argList.get(0)).toFile().isFile()) {\n+                    // If file is a regular file but not a ballerina source file\n+                    // throw the following exception.\n+                    throw LauncherUtils.createLauncherException(Messages.getNotABallerinaFile());\n+                } else {\n+                    moduleName = argList.get(0);\n+\n+                    // Check whether the module dir exists.\n+                    if (!FormatUtil.isModuleExist(moduleName, sourceRootPath)) {\n+                        // If module directory doesn't exist and contains a \".\"\n+                        // throw a exception to say file or module doesn't exist.\n+                        // Else throw a exception to say module doesn't exist.\n+                        if (moduleName.contains(\".\")) {\n+                            throw LauncherUtils.createLauncherException(Messages\n+                                    .getNoBallerinaModuleOrFile(moduleName));\n+                        } else {\n+                            throw LauncherUtils.createLauncherException(Messages.getNoModuleFound(moduleName));\n+                        }\n+                    }\n+\n+                    // Check whether the given directory is not in a ballerina project.\n+                    if (FormatUtil.notABallerinaProject(sourceRootPath)) {\n+                        throw LauncherUtils.createLauncherException(Messages.getNotBallerinaProject());\n+                    }\n+                    BLangPackage bLangPackage = FormatUtil\n+                            .compileModule(sourceRootPath, getModuleName(moduleName));\n+\n+                    // Iterate and format the ballerina package.\n+                    List<String> formattedFiles = iterateAndFormat(bLangPackage, sourceRootPath, dryRun);\n+                    generateChangeReport(formattedFiles, dryRun);\n+                }\n+            } else {\n+                List<BLangPackage> packages = FormatUtil.compileProject(sourceRootPath);\n+                List<String> formattedFiles = new ArrayList<>();\n+                // Iterate and format all the ballerina packages.\n+                for (BLangPackage bLangPackage : packages) {\n+                    formattedFiles.addAll(iterateAndFormat(bLangPackage, sourceRootPath, dryRun));\n+                }\n+\n+                generateChangeReport(formattedFiles, dryRun);\n+            }\n+        } catch (IOException | NullPointerException e) {\n+            throw LauncherUtils.createLauncherException(Messages.getException());\n+        }\n+    }\n+\n+    private static void generateChangeReport(List<String> formattedFiles, boolean dryRun) {\n+        if (!formattedFiles.isEmpty()) {\n+            StringBuilder fileList = new StringBuilder();\n+            if (dryRun) {\n+                fileList.append(Messages.getFilesToModify()).append(System.lineSeparator());\n+            } else {\n+                fileList.append(Messages.getModifiedFiles()).append(System.lineSeparator());\n+            }\n+            for (String file : formattedFiles) {\n+                fileList.append(file).append(System.lineSeparator());\n+            }\n+            outStream.println(fileList.toString());\n+            if (!dryRun) {\n+                outStream.println(Messages.getSuccessMessage());\n+            }\n+        } else {\n+            outStream.println(Messages.getNoChanges());\n+        }\n+    }\n+\n+    private static String getModuleName(String moduleName) {\n+        String pattern = Pattern.quote(File.separator);\n+        String[] splitedTokens = moduleName.split(pattern);\n+        return splitedTokens[splitedTokens.length - 1];\n+    }\n+\n+    /**\n+     * Compile whole ballerina project.\n+     *\n+     * @param sourceRoot source root\n+     * @return {@link List<BLangPackage>} list of BLangPackages\n+     */\n+    private static List<BLangPackage> compileProject(Path sourceRoot) throws UnsupportedEncodingException {\n+        emptyPrintStream = new EmptyPrintStream();\n+        CompilerContext context = getCompilerContext(sourceRoot);\n+        Compiler compiler = Compiler.getInstance(context);\n+        // Set an EmptyPrintStream to hide unnecessary outputs from compiler.\n+        compiler.setOutStream(emptyPrintStream);\n+        return compiler.compilePackages(false);\n+    }\n+\n+    /**\n+     * Compile only a ballerina module.\n+     *\n+     * @param sourceRoot source root\n+     * @param moduleName name of the module to be compiled\n+     * @return {@link BLangPackage} ballerina package\n+     */\n+    private static BLangPackage compileModule(Path sourceRoot, String moduleName) throws UnsupportedEncodingException {\n+        emptyPrintStream = new EmptyPrintStream();\n+        CompilerContext context = getCompilerContext(sourceRoot);\n+        Compiler compiler = Compiler.getInstance(context);\n+        // Set an EmptyPrintStream to hide unnecessary outputs from compiler.\n+        compiler.setOutStream(emptyPrintStream);\n+        return compiler.compile(moduleName);\n+    }\n+\n+    private static void formatAndWrite(BLangCompilationUnit compilationUnit, Path sourceRootPath,\n+                                       List<String> formattedFiles, boolean dryRun) throws IOException {\n+        String fileName = sourceRootPath.toString() + File.separator\n+                + \"src\"\n+                + File.separator\n+                + compilationUnit.getPosition().getSource().getPackageName()\n+                + File.separator\n+                + compilationUnit.getPosition().getSource().getCompilationUnitName();\n+\n+        // Format and get the formatted source.\n+        String formattedSource = Formatter.format(new String(Files.readAllBytes(Paths.get(fileName)),\n+                StandardCharsets.UTF_8));\n+\n+        if (doChangesAvailable(formattedSource, formattedSource)) {\n+            if (!dryRun) {\n+                // Write formatted content to the file.\n+                FormatUtil.writeFile(fileName, formattedSource);\n+            }\n+            formattedFiles.add(fileName);\n+        }\n+    }\n+\n+    private static List<String> iterateAndFormat(BLangPackage bLangPackage, Path sourceRootPath, boolean dryRun)\n+            throws IOException {\n+        List<String> formattedFiles = new ArrayList<>();\n+\n+        // Iterate compilation units and format.\n+        for (BLangCompilationUnit compilationUnit : bLangPackage.getCompilationUnits()) {\n+            formatAndWrite(compilationUnit, sourceRootPath, formattedFiles, dryRun);\n+        }\n+\n+        // Iterate testable packages and format.\n+        for (BLangTestablePackage testablePackage : bLangPackage.getTestablePkgs()) {\n+            for (BLangCompilationUnit compilationUnit : testablePackage.getCompilationUnits()) {\n+                formatAndWrite(compilationUnit, sourceRootPath, formattedFiles, dryRun);\n+            }\n+        }\n+\n+        return formattedFiles;\n+    }\n+\n+    /**\n+     * Get prepared compiler context.\n+     *\n+     * @param sourceRootPath ballerina compilable source root path\n+     * @return {@link CompilerContext} compiler context\n+     */\n+    private static CompilerContext getCompilerContext(Path sourceRootPath) {\n+        CompilerPhase compilerPhase = CompilerPhase.DEFINE;\n+        CompilerContext context = new CompilerContext();\n+        CompilerOptions options = CompilerOptions.getInstance(context);\n+        options.put(PROJECT_DIR, sourceRootPath.toString());\n+        options.put(OFFLINE, Boolean.toString(false));\n+        options.put(COMPILER_PHASE, compilerPhase.toString());\n+        options.put(SKIP_TESTS, Boolean.toString(false));\n+        options.put(TEST_ENABLED, \"true\");\n+        options.put(LOCK_ENABLED, Boolean.toString(false));\n+        options.put(EXPERIMENTAL_FEATURES_ENABLED, Boolean.toString(true));\n+        options.put(PRESERVE_WHITESPACE, Boolean.toString(true));\n+        options.put(NEW_PARSER_ENABLED, Boolean.toString(false));\n+\n+        return context;\n+    }\n+\n+    /**\n+     * Check whether the given module name exists.\n+     *\n+     * @param module      module name\n+     * @param projectRoot path of the ballerina project root\n+     * @return {@link Boolean} true or false\n+     */\n+    private static boolean isModuleExist(String module, Path projectRoot) {\n+        Path modulePath;\n+        if (module.startsWith(\"src/\")) {\n+            modulePath = projectRoot.resolve(module);\n+        } else {\n+            modulePath = projectRoot.resolve(\"src\").resolve(module);\n+        }\n+\n+        return modulePath.toFile().isDirectory();\n+    }\n+\n+    /**\n+     * Check whether the given path isn't a source root of a ballerina project.\n+     *\n+     * @param path - path where the command is executed from\n+     * @return {@link boolean} true or false\n+     */\n+    private static boolean notABallerinaProject(Path path) {\n+        Path cachePath = path.resolve(\"Ballerina.toml\");\n+        return !cachePath.toFile().exists();\n+    }\n+\n+    /**\n+     * Write content to a file.\n+     *\n+     * @param filePath - path of the file to add the content\n+     * @param content  - content to be added to the file\n+     * @throws IOException - throws and IO exception\n+     */\n+    private static void writeFile(String filePath, String content) throws IOException {\n+        OutputStreamWriter fileWriter = null;\n+        try {\n+            try (FileOutputStream fileStream = new FileOutputStream(new File(filePath))) {\n+                fileWriter = new OutputStreamWriter(fileStream, StandardCharsets.UTF_8);\n+            }\n+            fileWriter.write(content);\n+        } finally {\n+            if (fileWriter != null) {\n+                fileWriter.close();\n+            }\n+        }\n+    }\n+\n+    private static boolean doChangesAvailable(String originalSource, String formattedSource) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA1ODkzNw=="}, "originalCommit": {"oid": "85029404a6672a4d0d0d519148be5b133324530f"}, "originalPosition": 330}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMDgyMjI2OnYy", "diffSide": "RIGHT", "path": "misc/formatter/modules/formatter-cli/src/main/resources/META-INF/services/org.ballerinalang.tool.BLauncherCmd", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwNzoyNzoyMlrOG_VG5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwODowNToxNlrOG_WWkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA1OTMwMQ==", "bodyText": "Should there be an entry in this ?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25122#discussion_r469059301", "createdAt": "2020-08-12T07:27:22Z", "author": {"login": "hemikak"}, "path": "misc/formatter/modules/formatter-cli/src/main/resources/META-INF/services/org.ballerinalang.tool.BLauncherCmd", "diffHunk": "@@ -0,0 +1 @@\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85029404a6672a4d0d0d519148be5b133324530f"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA3OTY5OA==", "bodyText": "This was done to keep the previous ballerina-formatter CLI working instead of this one which is for the new parser. But now the previous ballerina-formatter CLI tool is removed and this one is enabled.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25122#discussion_r469079698", "createdAt": "2020-08-12T08:05:16Z", "author": {"login": "IrushiL"}, "path": "misc/formatter/modules/formatter-cli/src/main/resources/META-INF/services/org.ballerinalang.tool.BLauncherCmd", "diffHunk": "@@ -0,0 +1 @@\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA1OTMwMQ=="}, "originalCommit": {"oid": "85029404a6672a4d0d0d519148be5b133324530f"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMDgyNTcyOnYy", "diffSide": "RIGHT", "path": "misc/formatter/modules/formatter-cli/src/test/java/org/ballerinalang/formatter/cli/FormatCmdTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwNzoyODozMFrOG_VJFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwODowMDoyM1rOG_WMbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA1OTg2Mg==", "bodyText": "Will this work in windows ? Using resolve function would help. Paths.get(\"src\").resolve(\"test\").resolve(\"resources\").toAbsolutePath()", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25122#discussion_r469059862", "createdAt": "2020-08-12T07:28:30Z", "author": {"login": "hemikak"}, "path": "misc/formatter/modules/formatter-cli/src/test/java/org/ballerinalang/formatter/cli/FormatCmdTest.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.ballerinalang.formatter.cli;\n+\n+import org.ballerinalang.tool.BLauncherException;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Format CLI tool test suit for testing tool's exceptions.\n+ */\n+public class FormatCmdTest {\n+    private static final Path RES_DIR = Paths.get(\"src/test/resources/\").toAbsolutePath();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85029404a6672a4d0d0d519148be5b133324530f"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA2MjI0OA==", "bodyText": "Check for other similar places", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25122#discussion_r469062248", "createdAt": "2020-08-12T07:32:57Z", "author": {"login": "hemikak"}, "path": "misc/formatter/modules/formatter-cli/src/test/java/org/ballerinalang/formatter/cli/FormatCmdTest.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.ballerinalang.formatter.cli;\n+\n+import org.ballerinalang.tool.BLauncherException;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Format CLI tool test suit for testing tool's exceptions.\n+ */\n+public class FormatCmdTest {\n+    private static final Path RES_DIR = Paths.get(\"src/test/resources/\").toAbsolutePath();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA1OTg2Mg=="}, "originalCommit": {"oid": "85029404a6672a4d0d0d519148be5b133324530f"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA3NzEwMw==", "bodyText": "Done", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25122#discussion_r469077103", "createdAt": "2020-08-12T08:00:23Z", "author": {"login": "IrushiL"}, "path": "misc/formatter/modules/formatter-cli/src/test/java/org/ballerinalang/formatter/cli/FormatCmdTest.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.ballerinalang.formatter.cli;\n+\n+import org.ballerinalang.tool.BLauncherException;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Format CLI tool test suit for testing tool's exceptions.\n+ */\n+public class FormatCmdTest {\n+    private static final Path RES_DIR = Paths.get(\"src/test/resources/\").toAbsolutePath();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA1OTg2Mg=="}, "originalCommit": {"oid": "85029404a6672a4d0d0d519148be5b133324530f"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMDgyODk1OnYy", "diffSide": "RIGHT", "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/Formatter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwNzoyOToyOFrOG_VLEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwODowMDowN1rOG_WL1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA2MDM2OQ==", "bodyText": "Is this TODO still valid ?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25122#discussion_r469060369", "createdAt": "2020-08-12T07:29:28Z", "author": {"login": "hemikak"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/Formatter.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.core;\n+\n+import io.ballerinalang.compiler.syntax.tree.ModulePartNode;\n+import io.ballerinalang.compiler.syntax.tree.SyntaxTree;\n+import io.ballerinalang.compiler.text.LineRange;\n+import io.ballerinalang.compiler.text.TextDocument;\n+import io.ballerinalang.compiler.text.TextDocuments;\n+\n+/**\n+ * Class that exposes the formatting APIs.\n+ */\n+public class Formatter {\n+\n+    // TODO: Add test cases for syntax error scenarios as well", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85029404a6672a4d0d0d519148be5b133324530f"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA3Njk0OA==", "bodyText": "Yes, but moved it into FormatterTest class since it is more applicable there.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25122#discussion_r469076948", "createdAt": "2020-08-12T08:00:07Z", "author": {"login": "IrushiL"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/Formatter.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.core;\n+\n+import io.ballerinalang.compiler.syntax.tree.ModulePartNode;\n+import io.ballerinalang.compiler.syntax.tree.SyntaxTree;\n+import io.ballerinalang.compiler.text.LineRange;\n+import io.ballerinalang.compiler.text.TextDocument;\n+import io.ballerinalang.compiler.text.TextDocuments;\n+\n+/**\n+ * Class that exposes the formatting APIs.\n+ */\n+public class Formatter {\n+\n+    // TODO: Add test cases for syntax error scenarios as well", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA2MDM2OQ=="}, "originalCommit": {"oid": "85029404a6672a4d0d0d519148be5b133324530f"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMDg0Mjk3OnYy", "diffSide": "RIGHT", "path": "misc/formatter/modules/formatter-cli/src/main/java/org/ballerinalang/formatter/cli/FormatUtil.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwNzozMzozMVrOG_VTnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwNzo1ODoxOVrOG_WIEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA2MjU1OQ==", "bodyText": "You can use Paths.get().resolve().... instead of using File.separator", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25122#discussion_r469062559", "createdAt": "2020-08-12T07:33:31Z", "author": {"login": "hemikak"}, "path": "misc/formatter/modules/formatter-cli/src/main/java/org/ballerinalang/formatter/cli/FormatUtil.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.cli;\n+\n+import org.ballerinalang.compiler.CompilerPhase;\n+import org.ballerinalang.formatter.core.Formatter;\n+import org.ballerinalang.tool.BLauncherCmd;\n+import org.ballerinalang.tool.LauncherUtils;\n+import org.wso2.ballerinalang.compiler.Compiler;\n+import org.wso2.ballerinalang.compiler.tree.BLangCompilationUnit;\n+import org.wso2.ballerinalang.compiler.tree.BLangPackage;\n+import org.wso2.ballerinalang.compiler.tree.BLangTestablePackage;\n+import org.wso2.ballerinalang.compiler.util.CompilerContext;\n+import org.wso2.ballerinalang.compiler.util.CompilerOptions;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.io.PrintStream;\n+import java.io.UnsupportedEncodingException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+\n+import static org.ballerinalang.compiler.CompilerOptionName.COMPILER_PHASE;\n+import static org.ballerinalang.compiler.CompilerOptionName.EXPERIMENTAL_FEATURES_ENABLED;\n+import static org.ballerinalang.compiler.CompilerOptionName.LOCK_ENABLED;\n+import static org.ballerinalang.compiler.CompilerOptionName.NEW_PARSER_ENABLED;\n+import static org.ballerinalang.compiler.CompilerOptionName.OFFLINE;\n+import static org.ballerinalang.compiler.CompilerOptionName.PRESERVE_WHITESPACE;\n+import static org.ballerinalang.compiler.CompilerOptionName.PROJECT_DIR;\n+import static org.ballerinalang.compiler.CompilerOptionName.SKIP_TESTS;\n+import static org.ballerinalang.compiler.CompilerOptionName.TEST_ENABLED;\n+\n+/**\n+ * Util class for compilation and format execution for formatting CLI tool.\n+ */\n+class FormatUtil {\n+    static final String CMD_NAME = \"format\";\n+    private static final PrintStream outStream = System.err;\n+    private static EmptyPrintStream emptyPrintStream;\n+\n+    /**\n+     * Execute formatter.\n+     *\n+     * @param argList        argument list from the console\n+     * @param helpFlag       flag to get the help page\n+     * @param dryRun         run the whole formatting\n+     * @param sourceRootPath execution path\n+     */\n+    static void execute(List<String> argList, boolean helpFlag, boolean dryRun, Path sourceRootPath) {\n+        if (helpFlag) {\n+            String commandUsageInfo = BLauncherCmd.getCommandUsageInfo(CMD_NAME);\n+            outStream.println(commandUsageInfo);\n+            return;\n+        }\n+\n+        if (argList != null && argList.size() > 1) {\n+            throw LauncherUtils.createLauncherException(Messages.getArgumentError());\n+        }\n+\n+        String moduleName;\n+        String ballerinaFilePath;\n+\n+        try {\n+            // If parameters are available user has given either the module name or the ballerina file path.\n+            // Else user is in a ballerina project and expecting to format the whole ballerina project\n+            if (argList != null && !argList.isEmpty()) {\n+                if (FormatUtil.isBalFile(argList.get(0))) {\n+                    ballerinaFilePath = argList.get(0);\n+                    Path filePath = Paths.get(ballerinaFilePath);\n+\n+                    // If the file doesn't exist or is a directory.\n+                    if (!filePath.toFile().exists() || filePath.toFile().isDirectory()) {\n+                        throw LauncherUtils.createLauncherException(Messages.getNoBallerinaFile(ballerinaFilePath));\n+                    }\n+\n+                    String source = new String(Files.readAllBytes(filePath), StandardCharsets.UTF_8);\n+                    // Format and get the generated formatted source code content.\n+                    String formattedSourceCode = Formatter.format(source);\n+\n+                    if (doChangesAvailable(source, formattedSourceCode)) {\n+                        if (!dryRun) {\n+                            // Write the formatted content back to the file.\n+                            FormatUtil.writeFile(filePath.toAbsolutePath().toString(), formattedSourceCode);\n+                            outStream.println(Messages.getModifiedFiles() + System.lineSeparator() + ballerinaFilePath);\n+                            outStream.println(System.lineSeparator() + Messages.getSuccessMessage());\n+                        } else {\n+                            outStream.println(Messages.getFilesToModify() + System.lineSeparator() + ballerinaFilePath);\n+                        }\n+                    } else {\n+                        outStream.println(Messages.getNoChanges());\n+                    }\n+                } else if (Paths.get(argList.get(0)).toFile().isFile()) {\n+                    // If file is a regular file but not a ballerina source file\n+                    // throw the following exception.\n+                    throw LauncherUtils.createLauncherException(Messages.getNotABallerinaFile());\n+                } else {\n+                    moduleName = argList.get(0);\n+\n+                    // Check whether the module dir exists.\n+                    if (!FormatUtil.isModuleExist(moduleName, sourceRootPath)) {\n+                        // If module directory doesn't exist and contains a \".\"\n+                        // throw a exception to say file or module doesn't exist.\n+                        // Else throw a exception to say module doesn't exist.\n+                        if (moduleName.contains(\".\")) {\n+                            throw LauncherUtils.createLauncherException(Messages\n+                                    .getNoBallerinaModuleOrFile(moduleName));\n+                        } else {\n+                            throw LauncherUtils.createLauncherException(Messages.getNoModuleFound(moduleName));\n+                        }\n+                    }\n+\n+                    // Check whether the given directory is not in a ballerina project.\n+                    if (FormatUtil.notABallerinaProject(sourceRootPath)) {\n+                        throw LauncherUtils.createLauncherException(Messages.getNotBallerinaProject());\n+                    }\n+                    BLangPackage bLangPackage = FormatUtil\n+                            .compileModule(sourceRootPath, getModuleName(moduleName));\n+\n+                    // Iterate and format the ballerina package.\n+                    List<String> formattedFiles = iterateAndFormat(bLangPackage, sourceRootPath, dryRun);\n+                    generateChangeReport(formattedFiles, dryRun);\n+                }\n+            } else {\n+                List<BLangPackage> packages = FormatUtil.compileProject(sourceRootPath);\n+                List<String> formattedFiles = new ArrayList<>();\n+                // Iterate and format all the ballerina packages.\n+                for (BLangPackage bLangPackage : packages) {\n+                    formattedFiles.addAll(iterateAndFormat(bLangPackage, sourceRootPath, dryRun));\n+                }\n+\n+                generateChangeReport(formattedFiles, dryRun);\n+            }\n+        } catch (IOException | NullPointerException e) {\n+            throw LauncherUtils.createLauncherException(Messages.getException());\n+        }\n+    }\n+\n+    private static void generateChangeReport(List<String> formattedFiles, boolean dryRun) {\n+        if (!formattedFiles.isEmpty()) {\n+            StringBuilder fileList = new StringBuilder();\n+            if (dryRun) {\n+                fileList.append(Messages.getFilesToModify()).append(System.lineSeparator());\n+            } else {\n+                fileList.append(Messages.getModifiedFiles()).append(System.lineSeparator());\n+            }\n+            for (String file : formattedFiles) {\n+                fileList.append(file).append(System.lineSeparator());\n+            }\n+            outStream.println(fileList.toString());\n+            if (!dryRun) {\n+                outStream.println(Messages.getSuccessMessage());\n+            }\n+        } else {\n+            outStream.println(Messages.getNoChanges());\n+        }\n+    }\n+\n+    private static String getModuleName(String moduleName) {\n+        String pattern = Pattern.quote(File.separator);\n+        String[] splitedTokens = moduleName.split(pattern);\n+        return splitedTokens[splitedTokens.length - 1];\n+    }\n+\n+    /**\n+     * Compile whole ballerina project.\n+     *\n+     * @param sourceRoot source root\n+     * @return {@link List<BLangPackage>} list of BLangPackages\n+     */\n+    private static List<BLangPackage> compileProject(Path sourceRoot) throws UnsupportedEncodingException {\n+        emptyPrintStream = new EmptyPrintStream();\n+        CompilerContext context = getCompilerContext(sourceRoot);\n+        Compiler compiler = Compiler.getInstance(context);\n+        // Set an EmptyPrintStream to hide unnecessary outputs from compiler.\n+        compiler.setOutStream(emptyPrintStream);\n+        return compiler.compilePackages(false);\n+    }\n+\n+    /**\n+     * Compile only a ballerina module.\n+     *\n+     * @param sourceRoot source root\n+     * @param moduleName name of the module to be compiled\n+     * @return {@link BLangPackage} ballerina package\n+     */\n+    private static BLangPackage compileModule(Path sourceRoot, String moduleName) throws UnsupportedEncodingException {\n+        emptyPrintStream = new EmptyPrintStream();\n+        CompilerContext context = getCompilerContext(sourceRoot);\n+        Compiler compiler = Compiler.getInstance(context);\n+        // Set an EmptyPrintStream to hide unnecessary outputs from compiler.\n+        compiler.setOutStream(emptyPrintStream);\n+        return compiler.compile(moduleName);\n+    }\n+\n+    private static void formatAndWrite(BLangCompilationUnit compilationUnit, Path sourceRootPath,\n+                                       List<String> formattedFiles, boolean dryRun) throws IOException {\n+        String fileName = sourceRootPath.toString() + File.separator", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85029404a6672a4d0d0d519148be5b133324530f"}, "originalPosition": 218}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA3NTk4NA==", "bodyText": "Done", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25122#discussion_r469075984", "createdAt": "2020-08-12T07:58:19Z", "author": {"login": "IrushiL"}, "path": "misc/formatter/modules/formatter-cli/src/main/java/org/ballerinalang/formatter/cli/FormatUtil.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.cli;\n+\n+import org.ballerinalang.compiler.CompilerPhase;\n+import org.ballerinalang.formatter.core.Formatter;\n+import org.ballerinalang.tool.BLauncherCmd;\n+import org.ballerinalang.tool.LauncherUtils;\n+import org.wso2.ballerinalang.compiler.Compiler;\n+import org.wso2.ballerinalang.compiler.tree.BLangCompilationUnit;\n+import org.wso2.ballerinalang.compiler.tree.BLangPackage;\n+import org.wso2.ballerinalang.compiler.tree.BLangTestablePackage;\n+import org.wso2.ballerinalang.compiler.util.CompilerContext;\n+import org.wso2.ballerinalang.compiler.util.CompilerOptions;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.io.PrintStream;\n+import java.io.UnsupportedEncodingException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+\n+import static org.ballerinalang.compiler.CompilerOptionName.COMPILER_PHASE;\n+import static org.ballerinalang.compiler.CompilerOptionName.EXPERIMENTAL_FEATURES_ENABLED;\n+import static org.ballerinalang.compiler.CompilerOptionName.LOCK_ENABLED;\n+import static org.ballerinalang.compiler.CompilerOptionName.NEW_PARSER_ENABLED;\n+import static org.ballerinalang.compiler.CompilerOptionName.OFFLINE;\n+import static org.ballerinalang.compiler.CompilerOptionName.PRESERVE_WHITESPACE;\n+import static org.ballerinalang.compiler.CompilerOptionName.PROJECT_DIR;\n+import static org.ballerinalang.compiler.CompilerOptionName.SKIP_TESTS;\n+import static org.ballerinalang.compiler.CompilerOptionName.TEST_ENABLED;\n+\n+/**\n+ * Util class for compilation and format execution for formatting CLI tool.\n+ */\n+class FormatUtil {\n+    static final String CMD_NAME = \"format\";\n+    private static final PrintStream outStream = System.err;\n+    private static EmptyPrintStream emptyPrintStream;\n+\n+    /**\n+     * Execute formatter.\n+     *\n+     * @param argList        argument list from the console\n+     * @param helpFlag       flag to get the help page\n+     * @param dryRun         run the whole formatting\n+     * @param sourceRootPath execution path\n+     */\n+    static void execute(List<String> argList, boolean helpFlag, boolean dryRun, Path sourceRootPath) {\n+        if (helpFlag) {\n+            String commandUsageInfo = BLauncherCmd.getCommandUsageInfo(CMD_NAME);\n+            outStream.println(commandUsageInfo);\n+            return;\n+        }\n+\n+        if (argList != null && argList.size() > 1) {\n+            throw LauncherUtils.createLauncherException(Messages.getArgumentError());\n+        }\n+\n+        String moduleName;\n+        String ballerinaFilePath;\n+\n+        try {\n+            // If parameters are available user has given either the module name or the ballerina file path.\n+            // Else user is in a ballerina project and expecting to format the whole ballerina project\n+            if (argList != null && !argList.isEmpty()) {\n+                if (FormatUtil.isBalFile(argList.get(0))) {\n+                    ballerinaFilePath = argList.get(0);\n+                    Path filePath = Paths.get(ballerinaFilePath);\n+\n+                    // If the file doesn't exist or is a directory.\n+                    if (!filePath.toFile().exists() || filePath.toFile().isDirectory()) {\n+                        throw LauncherUtils.createLauncherException(Messages.getNoBallerinaFile(ballerinaFilePath));\n+                    }\n+\n+                    String source = new String(Files.readAllBytes(filePath), StandardCharsets.UTF_8);\n+                    // Format and get the generated formatted source code content.\n+                    String formattedSourceCode = Formatter.format(source);\n+\n+                    if (doChangesAvailable(source, formattedSourceCode)) {\n+                        if (!dryRun) {\n+                            // Write the formatted content back to the file.\n+                            FormatUtil.writeFile(filePath.toAbsolutePath().toString(), formattedSourceCode);\n+                            outStream.println(Messages.getModifiedFiles() + System.lineSeparator() + ballerinaFilePath);\n+                            outStream.println(System.lineSeparator() + Messages.getSuccessMessage());\n+                        } else {\n+                            outStream.println(Messages.getFilesToModify() + System.lineSeparator() + ballerinaFilePath);\n+                        }\n+                    } else {\n+                        outStream.println(Messages.getNoChanges());\n+                    }\n+                } else if (Paths.get(argList.get(0)).toFile().isFile()) {\n+                    // If file is a regular file but not a ballerina source file\n+                    // throw the following exception.\n+                    throw LauncherUtils.createLauncherException(Messages.getNotABallerinaFile());\n+                } else {\n+                    moduleName = argList.get(0);\n+\n+                    // Check whether the module dir exists.\n+                    if (!FormatUtil.isModuleExist(moduleName, sourceRootPath)) {\n+                        // If module directory doesn't exist and contains a \".\"\n+                        // throw a exception to say file or module doesn't exist.\n+                        // Else throw a exception to say module doesn't exist.\n+                        if (moduleName.contains(\".\")) {\n+                            throw LauncherUtils.createLauncherException(Messages\n+                                    .getNoBallerinaModuleOrFile(moduleName));\n+                        } else {\n+                            throw LauncherUtils.createLauncherException(Messages.getNoModuleFound(moduleName));\n+                        }\n+                    }\n+\n+                    // Check whether the given directory is not in a ballerina project.\n+                    if (FormatUtil.notABallerinaProject(sourceRootPath)) {\n+                        throw LauncherUtils.createLauncherException(Messages.getNotBallerinaProject());\n+                    }\n+                    BLangPackage bLangPackage = FormatUtil\n+                            .compileModule(sourceRootPath, getModuleName(moduleName));\n+\n+                    // Iterate and format the ballerina package.\n+                    List<String> formattedFiles = iterateAndFormat(bLangPackage, sourceRootPath, dryRun);\n+                    generateChangeReport(formattedFiles, dryRun);\n+                }\n+            } else {\n+                List<BLangPackage> packages = FormatUtil.compileProject(sourceRootPath);\n+                List<String> formattedFiles = new ArrayList<>();\n+                // Iterate and format all the ballerina packages.\n+                for (BLangPackage bLangPackage : packages) {\n+                    formattedFiles.addAll(iterateAndFormat(bLangPackage, sourceRootPath, dryRun));\n+                }\n+\n+                generateChangeReport(formattedFiles, dryRun);\n+            }\n+        } catch (IOException | NullPointerException e) {\n+            throw LauncherUtils.createLauncherException(Messages.getException());\n+        }\n+    }\n+\n+    private static void generateChangeReport(List<String> formattedFiles, boolean dryRun) {\n+        if (!formattedFiles.isEmpty()) {\n+            StringBuilder fileList = new StringBuilder();\n+            if (dryRun) {\n+                fileList.append(Messages.getFilesToModify()).append(System.lineSeparator());\n+            } else {\n+                fileList.append(Messages.getModifiedFiles()).append(System.lineSeparator());\n+            }\n+            for (String file : formattedFiles) {\n+                fileList.append(file).append(System.lineSeparator());\n+            }\n+            outStream.println(fileList.toString());\n+            if (!dryRun) {\n+                outStream.println(Messages.getSuccessMessage());\n+            }\n+        } else {\n+            outStream.println(Messages.getNoChanges());\n+        }\n+    }\n+\n+    private static String getModuleName(String moduleName) {\n+        String pattern = Pattern.quote(File.separator);\n+        String[] splitedTokens = moduleName.split(pattern);\n+        return splitedTokens[splitedTokens.length - 1];\n+    }\n+\n+    /**\n+     * Compile whole ballerina project.\n+     *\n+     * @param sourceRoot source root\n+     * @return {@link List<BLangPackage>} list of BLangPackages\n+     */\n+    private static List<BLangPackage> compileProject(Path sourceRoot) throws UnsupportedEncodingException {\n+        emptyPrintStream = new EmptyPrintStream();\n+        CompilerContext context = getCompilerContext(sourceRoot);\n+        Compiler compiler = Compiler.getInstance(context);\n+        // Set an EmptyPrintStream to hide unnecessary outputs from compiler.\n+        compiler.setOutStream(emptyPrintStream);\n+        return compiler.compilePackages(false);\n+    }\n+\n+    /**\n+     * Compile only a ballerina module.\n+     *\n+     * @param sourceRoot source root\n+     * @param moduleName name of the module to be compiled\n+     * @return {@link BLangPackage} ballerina package\n+     */\n+    private static BLangPackage compileModule(Path sourceRoot, String moduleName) throws UnsupportedEncodingException {\n+        emptyPrintStream = new EmptyPrintStream();\n+        CompilerContext context = getCompilerContext(sourceRoot);\n+        Compiler compiler = Compiler.getInstance(context);\n+        // Set an EmptyPrintStream to hide unnecessary outputs from compiler.\n+        compiler.setOutStream(emptyPrintStream);\n+        return compiler.compile(moduleName);\n+    }\n+\n+    private static void formatAndWrite(BLangCompilationUnit compilationUnit, Path sourceRootPath,\n+                                       List<String> formattedFiles, boolean dryRun) throws IOException {\n+        String fileName = sourceRootPath.toString() + File.separator", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA2MjU1OQ=="}, "originalCommit": {"oid": "85029404a6672a4d0d0d519148be5b133324530f"}, "originalPosition": 218}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMDk3MDc2OnYy", "diffSide": "RIGHT", "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/Formatter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwODoxMDo1N1rOG_WiSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwODoxMjo0NlrOG_WmBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA4MjY5Nw==", "bodyText": "Method never used", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25122#discussion_r469082697", "createdAt": "2020-08-12T08:10:57Z", "author": {"login": "pramodya1994"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/Formatter.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.core;\n+\n+import io.ballerinalang.compiler.syntax.tree.ModulePartNode;\n+import io.ballerinalang.compiler.syntax.tree.SyntaxTree;\n+import io.ballerinalang.compiler.text.LineRange;\n+import io.ballerinalang.compiler.text.TextDocument;\n+import io.ballerinalang.compiler.text.TextDocuments;\n+\n+/**\n+ * Class that exposes the formatting APIs.\n+ */\n+public class Formatter {\n+\n+    /**\n+     * Formats the provided source string and returns back the formatted source string.\n+     *\n+     * @param source A Ballerina source in string form\n+     * @return A modified source string after formatting changes\n+     */\n+    public static String format(String source) {\n+        return format(source, new FormattingOptions());\n+    }\n+\n+    /**\n+     * Formats a line range of the provided SyntaxTree. All the nodes falling within the line range\n+     * specified will be formatted.\n+     *\n+     * @param syntaxTree The complete SyntaxTree, of which a part is to be formatted\n+     * @param range LineRange which specifies the range to be formatted\n+     * @return The modified SyntaxTree after formatting changes\n+     */\n+    public static SyntaxTree format(SyntaxTree syntaxTree, LineRange range) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd11e18d02f89bd7c4083018f0ceaba728cbf5eb"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA4MzY1NQ==", "bodyText": "This is an API exposed by the formatter core.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25122#discussion_r469083655", "createdAt": "2020-08-12T08:12:46Z", "author": {"login": "IrushiL"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/Formatter.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.core;\n+\n+import io.ballerinalang.compiler.syntax.tree.ModulePartNode;\n+import io.ballerinalang.compiler.syntax.tree.SyntaxTree;\n+import io.ballerinalang.compiler.text.LineRange;\n+import io.ballerinalang.compiler.text.TextDocument;\n+import io.ballerinalang.compiler.text.TextDocuments;\n+\n+/**\n+ * Class that exposes the formatting APIs.\n+ */\n+public class Formatter {\n+\n+    /**\n+     * Formats the provided source string and returns back the formatted source string.\n+     *\n+     * @param source A Ballerina source in string form\n+     * @return A modified source string after formatting changes\n+     */\n+    public static String format(String source) {\n+        return format(source, new FormattingOptions());\n+    }\n+\n+    /**\n+     * Formats a line range of the provided SyntaxTree. All the nodes falling within the line range\n+     * specified will be formatted.\n+     *\n+     * @param syntaxTree The complete SyntaxTree, of which a part is to be formatted\n+     * @param range LineRange which specifies the range to be formatted\n+     * @return The modified SyntaxTree after formatting changes\n+     */\n+    public static SyntaxTree format(SyntaxTree syntaxTree, LineRange range) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA4MjY5Nw=="}, "originalCommit": {"oid": "bd11e18d02f89bd7c4083018f0ceaba728cbf5eb"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMDk3MjE1OnYy", "diffSide": "RIGHT", "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/Formatter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwODoxMToyOFrOG_WjOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwODoxMzozNVrOG_Wncw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA4MjkzNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static String format(String source, FormattingOptions options) {\n          \n          \n            \n                private static String format(String source, FormattingOptions options) {", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25122#discussion_r469082936", "createdAt": "2020-08-12T08:11:28Z", "author": {"login": "pramodya1994"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/Formatter.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.core;\n+\n+import io.ballerinalang.compiler.syntax.tree.ModulePartNode;\n+import io.ballerinalang.compiler.syntax.tree.SyntaxTree;\n+import io.ballerinalang.compiler.text.LineRange;\n+import io.ballerinalang.compiler.text.TextDocument;\n+import io.ballerinalang.compiler.text.TextDocuments;\n+\n+/**\n+ * Class that exposes the formatting APIs.\n+ */\n+public class Formatter {\n+\n+    /**\n+     * Formats the provided source string and returns back the formatted source string.\n+     *\n+     * @param source A Ballerina source in string form\n+     * @return A modified source string after formatting changes\n+     */\n+    public static String format(String source) {\n+        return format(source, new FormattingOptions());\n+    }\n+\n+    /**\n+     * Formats a line range of the provided SyntaxTree. All the nodes falling within the line range\n+     * specified will be formatted.\n+     *\n+     * @param syntaxTree The complete SyntaxTree, of which a part is to be formatted\n+     * @param range LineRange which specifies the range to be formatted\n+     * @return The modified SyntaxTree after formatting changes\n+     */\n+    public static SyntaxTree format(SyntaxTree syntaxTree, LineRange range) {\n+        return format(syntaxTree, range, new FormattingOptions());\n+    }\n+\n+    /**\n+     * Formats the provided SyntaxTree and returns back a formatted SyntaxTree.\n+     *\n+     * @param syntaxTree The SyntaxTree which is to be formatted\n+     * @return The modified SyntaxTree after formatting changes\n+     */\n+    public static SyntaxTree format(SyntaxTree syntaxTree) {\n+        return format(syntaxTree, new FormattingOptions());\n+    }\n+\n+    /**\n+     * Formats the provided source string while using the formatting options provided.\n+     *\n+     * @param source A Ballerina source in string form\n+     * @param options Formatting options that are to be used when formatting\n+     * @return A modified source string after formatting changes\n+     */\n+    public static String format(String source, FormattingOptions options) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd11e18d02f89bd7c4083018f0ceaba728cbf5eb"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA4NDAxOQ==", "bodyText": "This is an API exposed by the formatter core, it is to be used by other modules such as the lang-sever and the formatter CLI.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25122#discussion_r469084019", "createdAt": "2020-08-12T08:13:35Z", "author": {"login": "IrushiL"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/Formatter.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.core;\n+\n+import io.ballerinalang.compiler.syntax.tree.ModulePartNode;\n+import io.ballerinalang.compiler.syntax.tree.SyntaxTree;\n+import io.ballerinalang.compiler.text.LineRange;\n+import io.ballerinalang.compiler.text.TextDocument;\n+import io.ballerinalang.compiler.text.TextDocuments;\n+\n+/**\n+ * Class that exposes the formatting APIs.\n+ */\n+public class Formatter {\n+\n+    /**\n+     * Formats the provided source string and returns back the formatted source string.\n+     *\n+     * @param source A Ballerina source in string form\n+     * @return A modified source string after formatting changes\n+     */\n+    public static String format(String source) {\n+        return format(source, new FormattingOptions());\n+    }\n+\n+    /**\n+     * Formats a line range of the provided SyntaxTree. All the nodes falling within the line range\n+     * specified will be formatted.\n+     *\n+     * @param syntaxTree The complete SyntaxTree, of which a part is to be formatted\n+     * @param range LineRange which specifies the range to be formatted\n+     * @return The modified SyntaxTree after formatting changes\n+     */\n+    public static SyntaxTree format(SyntaxTree syntaxTree, LineRange range) {\n+        return format(syntaxTree, range, new FormattingOptions());\n+    }\n+\n+    /**\n+     * Formats the provided SyntaxTree and returns back a formatted SyntaxTree.\n+     *\n+     * @param syntaxTree The SyntaxTree which is to be formatted\n+     * @return The modified SyntaxTree after formatting changes\n+     */\n+    public static SyntaxTree format(SyntaxTree syntaxTree) {\n+        return format(syntaxTree, new FormattingOptions());\n+    }\n+\n+    /**\n+     * Formats the provided source string while using the formatting options provided.\n+     *\n+     * @param source A Ballerina source in string form\n+     * @param options Formatting options that are to be used when formatting\n+     * @return A modified source string after formatting changes\n+     */\n+    public static String format(String source, FormattingOptions options) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA4MjkzNg=="}, "originalCommit": {"oid": "bd11e18d02f89bd7c4083018f0ceaba728cbf5eb"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMDk3NDQzOnYy", "diffSide": "RIGHT", "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/Formatter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwODoxMjowMVrOG_Wkgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwODoxMzo1MFrOG_Wn9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA4MzI2Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static SyntaxTree format(SyntaxTree syntaxTree, LineRange range, FormattingOptions options) {\n          \n          \n            \n                private static SyntaxTree format(SyntaxTree syntaxTree, LineRange range, FormattingOptions options) {", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25122#discussion_r469083266", "createdAt": "2020-08-12T08:12:01Z", "author": {"login": "pramodya1994"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/Formatter.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.core;\n+\n+import io.ballerinalang.compiler.syntax.tree.ModulePartNode;\n+import io.ballerinalang.compiler.syntax.tree.SyntaxTree;\n+import io.ballerinalang.compiler.text.LineRange;\n+import io.ballerinalang.compiler.text.TextDocument;\n+import io.ballerinalang.compiler.text.TextDocuments;\n+\n+/**\n+ * Class that exposes the formatting APIs.\n+ */\n+public class Formatter {\n+\n+    /**\n+     * Formats the provided source string and returns back the formatted source string.\n+     *\n+     * @param source A Ballerina source in string form\n+     * @return A modified source string after formatting changes\n+     */\n+    public static String format(String source) {\n+        return format(source, new FormattingOptions());\n+    }\n+\n+    /**\n+     * Formats a line range of the provided SyntaxTree. All the nodes falling within the line range\n+     * specified will be formatted.\n+     *\n+     * @param syntaxTree The complete SyntaxTree, of which a part is to be formatted\n+     * @param range LineRange which specifies the range to be formatted\n+     * @return The modified SyntaxTree after formatting changes\n+     */\n+    public static SyntaxTree format(SyntaxTree syntaxTree, LineRange range) {\n+        return format(syntaxTree, range, new FormattingOptions());\n+    }\n+\n+    /**\n+     * Formats the provided SyntaxTree and returns back a formatted SyntaxTree.\n+     *\n+     * @param syntaxTree The SyntaxTree which is to be formatted\n+     * @return The modified SyntaxTree after formatting changes\n+     */\n+    public static SyntaxTree format(SyntaxTree syntaxTree) {\n+        return format(syntaxTree, new FormattingOptions());\n+    }\n+\n+    /**\n+     * Formats the provided source string while using the formatting options provided.\n+     *\n+     * @param source A Ballerina source in string form\n+     * @param options Formatting options that are to be used when formatting\n+     * @return A modified source string after formatting changes\n+     */\n+    public static String format(String source, FormattingOptions options) {\n+        TextDocument textDocument = TextDocuments.from(source);\n+        SyntaxTree syntaxTree = SyntaxTree.from(textDocument);\n+        FormattingTreeModifier treeModifier = new FormattingTreeModifier();\n+        ModulePartNode newModulePart = treeModifier.transform((ModulePartNode) syntaxTree.rootNode());\n+        if (options != null) {\n+            treeModifier.setFormattingOptions(options);\n+        }\n+        return syntaxTree.modifyWith(newModulePart).toSourceCode();\n+    }\n+\n+    /**\n+     * Formats a line range of the provided SyntaxTree while using the formatting options provided. All the\n+     * nodes falling within the line range provided will be formatted.\n+     *\n+     * @param syntaxTree The complete SyntaxTree, of which a part is to be formatted\n+     * @param range LineRange which needs to be formatted\n+     * @param options Formatting options that are to be used when formatting\n+     * @return The modified SyntaxTree after formatting changes\n+     */\n+    public static SyntaxTree format(SyntaxTree syntaxTree, LineRange range, FormattingOptions options) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd11e18d02f89bd7c4083018f0ceaba728cbf5eb"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA4NDE0OA==", "bodyText": "This is an API exposed by the formatter core, it is to be used by other modules such as the lang-sever and the formatter CLI.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25122#discussion_r469084148", "createdAt": "2020-08-12T08:13:50Z", "author": {"login": "IrushiL"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/Formatter.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.core;\n+\n+import io.ballerinalang.compiler.syntax.tree.ModulePartNode;\n+import io.ballerinalang.compiler.syntax.tree.SyntaxTree;\n+import io.ballerinalang.compiler.text.LineRange;\n+import io.ballerinalang.compiler.text.TextDocument;\n+import io.ballerinalang.compiler.text.TextDocuments;\n+\n+/**\n+ * Class that exposes the formatting APIs.\n+ */\n+public class Formatter {\n+\n+    /**\n+     * Formats the provided source string and returns back the formatted source string.\n+     *\n+     * @param source A Ballerina source in string form\n+     * @return A modified source string after formatting changes\n+     */\n+    public static String format(String source) {\n+        return format(source, new FormattingOptions());\n+    }\n+\n+    /**\n+     * Formats a line range of the provided SyntaxTree. All the nodes falling within the line range\n+     * specified will be formatted.\n+     *\n+     * @param syntaxTree The complete SyntaxTree, of which a part is to be formatted\n+     * @param range LineRange which specifies the range to be formatted\n+     * @return The modified SyntaxTree after formatting changes\n+     */\n+    public static SyntaxTree format(SyntaxTree syntaxTree, LineRange range) {\n+        return format(syntaxTree, range, new FormattingOptions());\n+    }\n+\n+    /**\n+     * Formats the provided SyntaxTree and returns back a formatted SyntaxTree.\n+     *\n+     * @param syntaxTree The SyntaxTree which is to be formatted\n+     * @return The modified SyntaxTree after formatting changes\n+     */\n+    public static SyntaxTree format(SyntaxTree syntaxTree) {\n+        return format(syntaxTree, new FormattingOptions());\n+    }\n+\n+    /**\n+     * Formats the provided source string while using the formatting options provided.\n+     *\n+     * @param source A Ballerina source in string form\n+     * @param options Formatting options that are to be used when formatting\n+     * @return A modified source string after formatting changes\n+     */\n+    public static String format(String source, FormattingOptions options) {\n+        TextDocument textDocument = TextDocuments.from(source);\n+        SyntaxTree syntaxTree = SyntaxTree.from(textDocument);\n+        FormattingTreeModifier treeModifier = new FormattingTreeModifier();\n+        ModulePartNode newModulePart = treeModifier.transform((ModulePartNode) syntaxTree.rootNode());\n+        if (options != null) {\n+            treeModifier.setFormattingOptions(options);\n+        }\n+        return syntaxTree.modifyWith(newModulePart).toSourceCode();\n+    }\n+\n+    /**\n+     * Formats a line range of the provided SyntaxTree while using the formatting options provided. All the\n+     * nodes falling within the line range provided will be formatted.\n+     *\n+     * @param syntaxTree The complete SyntaxTree, of which a part is to be formatted\n+     * @param range LineRange which needs to be formatted\n+     * @param options Formatting options that are to be used when formatting\n+     * @return The modified SyntaxTree after formatting changes\n+     */\n+    public static SyntaxTree format(SyntaxTree syntaxTree, LineRange range, FormattingOptions options) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA4MzI2Ng=="}, "originalCommit": {"oid": "bd11e18d02f89bd7c4083018f0ceaba728cbf5eb"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMDk3NTk2OnYy", "diffSide": "RIGHT", "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/Formatter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwODoxMjoyN1rOG_WlbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwODoxMzo1NlrOG_WoNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA4MzUwMA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static SyntaxTree format(SyntaxTree syntaxTree, FormattingOptions options) {\n          \n          \n            \n                private static SyntaxTree format(SyntaxTree syntaxTree, FormattingOptions options) {", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25122#discussion_r469083500", "createdAt": "2020-08-12T08:12:27Z", "author": {"login": "pramodya1994"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/Formatter.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.core;\n+\n+import io.ballerinalang.compiler.syntax.tree.ModulePartNode;\n+import io.ballerinalang.compiler.syntax.tree.SyntaxTree;\n+import io.ballerinalang.compiler.text.LineRange;\n+import io.ballerinalang.compiler.text.TextDocument;\n+import io.ballerinalang.compiler.text.TextDocuments;\n+\n+/**\n+ * Class that exposes the formatting APIs.\n+ */\n+public class Formatter {\n+\n+    /**\n+     * Formats the provided source string and returns back the formatted source string.\n+     *\n+     * @param source A Ballerina source in string form\n+     * @return A modified source string after formatting changes\n+     */\n+    public static String format(String source) {\n+        return format(source, new FormattingOptions());\n+    }\n+\n+    /**\n+     * Formats a line range of the provided SyntaxTree. All the nodes falling within the line range\n+     * specified will be formatted.\n+     *\n+     * @param syntaxTree The complete SyntaxTree, of which a part is to be formatted\n+     * @param range LineRange which specifies the range to be formatted\n+     * @return The modified SyntaxTree after formatting changes\n+     */\n+    public static SyntaxTree format(SyntaxTree syntaxTree, LineRange range) {\n+        return format(syntaxTree, range, new FormattingOptions());\n+    }\n+\n+    /**\n+     * Formats the provided SyntaxTree and returns back a formatted SyntaxTree.\n+     *\n+     * @param syntaxTree The SyntaxTree which is to be formatted\n+     * @return The modified SyntaxTree after formatting changes\n+     */\n+    public static SyntaxTree format(SyntaxTree syntaxTree) {\n+        return format(syntaxTree, new FormattingOptions());\n+    }\n+\n+    /**\n+     * Formats the provided source string while using the formatting options provided.\n+     *\n+     * @param source A Ballerina source in string form\n+     * @param options Formatting options that are to be used when formatting\n+     * @return A modified source string after formatting changes\n+     */\n+    public static String format(String source, FormattingOptions options) {\n+        TextDocument textDocument = TextDocuments.from(source);\n+        SyntaxTree syntaxTree = SyntaxTree.from(textDocument);\n+        FormattingTreeModifier treeModifier = new FormattingTreeModifier();\n+        ModulePartNode newModulePart = treeModifier.transform((ModulePartNode) syntaxTree.rootNode());\n+        if (options != null) {\n+            treeModifier.setFormattingOptions(options);\n+        }\n+        return syntaxTree.modifyWith(newModulePart).toSourceCode();\n+    }\n+\n+    /**\n+     * Formats a line range of the provided SyntaxTree while using the formatting options provided. All the\n+     * nodes falling within the line range provided will be formatted.\n+     *\n+     * @param syntaxTree The complete SyntaxTree, of which a part is to be formatted\n+     * @param range LineRange which needs to be formatted\n+     * @param options Formatting options that are to be used when formatting\n+     * @return The modified SyntaxTree after formatting changes\n+     */\n+    public static SyntaxTree format(SyntaxTree syntaxTree, LineRange range, FormattingOptions options) {\n+        FormattingTreeModifier treeModifier = new FormattingTreeModifier();\n+        ModulePartNode modulePartNode = syntaxTree.rootNode();\n+        treeModifier.setLineRange(range);\n+        if (options != null) {\n+            treeModifier.setFormattingOptions(options);\n+        }\n+        return syntaxTree.modifyWith(treeModifier.transform(modulePartNode));\n+    }\n+\n+    /**\n+     * Formats the provided SyntaxTree while using the formatting options provided.\n+     *\n+     * @param syntaxTree The SyntaxTree which is to be formatted\n+     * @param options Formatting options that are to be used when formatting\n+     * @return The modified SyntaxTree after formatting changes\n+     */\n+    public static SyntaxTree format(SyntaxTree syntaxTree, FormattingOptions options) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd11e18d02f89bd7c4083018f0ceaba728cbf5eb"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA4NDIxMw==", "bodyText": "This is an API exposed by the formatter core, it is to be used by other modules such as the lang-sever and the formatter CLI.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25122#discussion_r469084213", "createdAt": "2020-08-12T08:13:56Z", "author": {"login": "IrushiL"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/Formatter.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.core;\n+\n+import io.ballerinalang.compiler.syntax.tree.ModulePartNode;\n+import io.ballerinalang.compiler.syntax.tree.SyntaxTree;\n+import io.ballerinalang.compiler.text.LineRange;\n+import io.ballerinalang.compiler.text.TextDocument;\n+import io.ballerinalang.compiler.text.TextDocuments;\n+\n+/**\n+ * Class that exposes the formatting APIs.\n+ */\n+public class Formatter {\n+\n+    /**\n+     * Formats the provided source string and returns back the formatted source string.\n+     *\n+     * @param source A Ballerina source in string form\n+     * @return A modified source string after formatting changes\n+     */\n+    public static String format(String source) {\n+        return format(source, new FormattingOptions());\n+    }\n+\n+    /**\n+     * Formats a line range of the provided SyntaxTree. All the nodes falling within the line range\n+     * specified will be formatted.\n+     *\n+     * @param syntaxTree The complete SyntaxTree, of which a part is to be formatted\n+     * @param range LineRange which specifies the range to be formatted\n+     * @return The modified SyntaxTree after formatting changes\n+     */\n+    public static SyntaxTree format(SyntaxTree syntaxTree, LineRange range) {\n+        return format(syntaxTree, range, new FormattingOptions());\n+    }\n+\n+    /**\n+     * Formats the provided SyntaxTree and returns back a formatted SyntaxTree.\n+     *\n+     * @param syntaxTree The SyntaxTree which is to be formatted\n+     * @return The modified SyntaxTree after formatting changes\n+     */\n+    public static SyntaxTree format(SyntaxTree syntaxTree) {\n+        return format(syntaxTree, new FormattingOptions());\n+    }\n+\n+    /**\n+     * Formats the provided source string while using the formatting options provided.\n+     *\n+     * @param source A Ballerina source in string form\n+     * @param options Formatting options that are to be used when formatting\n+     * @return A modified source string after formatting changes\n+     */\n+    public static String format(String source, FormattingOptions options) {\n+        TextDocument textDocument = TextDocuments.from(source);\n+        SyntaxTree syntaxTree = SyntaxTree.from(textDocument);\n+        FormattingTreeModifier treeModifier = new FormattingTreeModifier();\n+        ModulePartNode newModulePart = treeModifier.transform((ModulePartNode) syntaxTree.rootNode());\n+        if (options != null) {\n+            treeModifier.setFormattingOptions(options);\n+        }\n+        return syntaxTree.modifyWith(newModulePart).toSourceCode();\n+    }\n+\n+    /**\n+     * Formats a line range of the provided SyntaxTree while using the formatting options provided. All the\n+     * nodes falling within the line range provided will be formatted.\n+     *\n+     * @param syntaxTree The complete SyntaxTree, of which a part is to be formatted\n+     * @param range LineRange which needs to be formatted\n+     * @param options Formatting options that are to be used when formatting\n+     * @return The modified SyntaxTree after formatting changes\n+     */\n+    public static SyntaxTree format(SyntaxTree syntaxTree, LineRange range, FormattingOptions options) {\n+        FormattingTreeModifier treeModifier = new FormattingTreeModifier();\n+        ModulePartNode modulePartNode = syntaxTree.rootNode();\n+        treeModifier.setLineRange(range);\n+        if (options != null) {\n+            treeModifier.setFormattingOptions(options);\n+        }\n+        return syntaxTree.modifyWith(treeModifier.transform(modulePartNode));\n+    }\n+\n+    /**\n+     * Formats the provided SyntaxTree while using the formatting options provided.\n+     *\n+     * @param syntaxTree The SyntaxTree which is to be formatted\n+     * @param options Formatting options that are to be used when formatting\n+     * @return The modified SyntaxTree after formatting changes\n+     */\n+    public static SyntaxTree format(SyntaxTree syntaxTree, FormattingOptions options) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA4MzUwMA=="}, "originalCommit": {"oid": "bd11e18d02f89bd7c4083018f0ceaba728cbf5eb"}, "originalPosition": 105}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMTExNzExOnYy", "diffSide": "RIGHT", "path": "misc/formatter/modules/formatter-core/src/test/java/org/ballerinalang/formatter/core/expressions/StringTemplateExpressionsTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwODo0OTozOVrOG_X8fQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwOTozNDoyN1rOG_ZkBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEwNTc4OQ==", "bodyText": "Why do we have a test class for each expression or construct type. Can we simply rely on a file structure to organize the test cases and run from a single test runner.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25122#discussion_r469105789", "createdAt": "2020-08-12T08:49:39Z", "author": {"login": "hevayo"}, "path": "misc/formatter/modules/formatter-core/src/test/java/org/ballerinalang/formatter/core/expressions/StringTemplateExpressionsTest.java", "diffHunk": "@@ -0,0 +1,54 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.core.expressions;\n+\n+import org.ballerinalang.formatter.core.FormatterTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.nio.file.Paths;\n+import java.util.Collections;\n+import java.util.List;\n+\n+/**\n+ * Test the formatting of string template expressions.\n+ *\n+ * @since 2.0.0\n+ */\n+public class StringTemplateExpressionsTest extends FormatterTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2cd5c53f28192688cf2a96e1d6fbdd66cd64d6e1"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEzMjI5Mg==", "bodyText": "Here the test classes extend a single test runner but there are test classes added for each subcategory since some of these subcategories contain a lot of test cases. But since this results in a large number of test classes, I will try to refactor this in the future.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25122#discussion_r469132292", "createdAt": "2020-08-12T09:34:27Z", "author": {"login": "IrushiL"}, "path": "misc/formatter/modules/formatter-core/src/test/java/org/ballerinalang/formatter/core/expressions/StringTemplateExpressionsTest.java", "diffHunk": "@@ -0,0 +1,54 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.core.expressions;\n+\n+import org.ballerinalang.formatter.core.FormatterTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.nio.file.Paths;\n+import java.util.Collections;\n+import java.util.List;\n+\n+/**\n+ * Test the formatting of string template expressions.\n+ *\n+ * @since 2.0.0\n+ */\n+public class StringTemplateExpressionsTest extends FormatterTest {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEwNTc4OQ=="}, "originalCommit": {"oid": "2cd5c53f28192688cf2a96e1d6fbdd66cd64d6e1"}, "originalPosition": 32}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 341, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}