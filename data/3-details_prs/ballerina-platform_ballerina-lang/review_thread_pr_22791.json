{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA2MTAwMDcy", "number": 22791, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxMToyMjo0NFrOD1ub4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNlQxMzowMToyMlrOD2UjnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3NjYxOTIwOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxMToyMjo0NFrOGLTDDQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QwODoxMjoxOVrOGMWa7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDQ5OTU5Nw==", "bodyText": "unwanted/wrong doc comment", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22791#discussion_r414499597", "createdAt": "2020-04-24T11:22:44Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -5871,6 +5898,76 @@ private boolean isValidLHSExpression(SyntaxKind tokenKind) {\n     }\n \n     /**\n+     * Parse parameterized type descriptor.\n+     * parameterized-type-descriptor := map type-parameter | future type-parameter | typedesc type-parameter\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseParameterizedTypeDescriptor() {\n+        STNode parameterizedTypeKeyword;\n+        STToken nextToken = peek();\n+\n+        switch(nextToken.kind) {\n+            case MAP_KEYWORD: // map type desc\n+                startContext(ParserRuleContext.MAP_TYPE_DESCRIPTOR);\n+                parameterizedTypeKeyword = consume();\n+                break;\n+            case FUTURE_KEYWORD: // future type desc\n+                startContext(ParserRuleContext.FUTURE_TYPE_DESCRIPTOR);\n+                parameterizedTypeKeyword = consume();\n+                break;\n+            default:// typedesc type desc\n+                startContext(ParserRuleContext.TYPEDESC_TYPE_DESCRIPTOR);\n+                if (nextToken.kind == SyntaxKind.TYPEDESC_KEYWORD) {\n+                    parameterizedTypeKeyword = consume();\n+                } else {\n+                    Solution sol = recover(nextToken, ParserRuleContext.TYPEDESC_KEYWORD);\n+                    parameterizedTypeKeyword =  sol.recoveredNode;\n+                }\n+        }\n+\n+        STNode ltToken = parseLTToken();\n+        STNode typeNode = parseTypeDescriptor();\n+        STNode gtToken = parseGTToken();\n+\n+        endContext();\n+        return STNodeFactory.createParameterizedTypeDescriptorNode(parameterizedTypeKeyword, ltToken, typeNode,\n+                gtToken);\n+    }\n+\n+\n+    /**\n+     * Parse <code> < </code> token.\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseGTToken() {\n+        STToken nextToken = peek();\n+        if (nextToken.kind == SyntaxKind.GT_TOKEN) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(nextToken, ParserRuleContext.GT);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse <code> > </code> token.\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseLTToken() {\n+        STToken nextToken = peek();\n+        if (nextToken.kind == SyntaxKind.LT_TOKEN) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(nextToken, ParserRuleContext.LT);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse null-keyword.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f495ea53bf081a936049d81dc6f8647d9abafe47"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYwMzQzNg==", "bodyText": "removed", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22791#discussion_r415603436", "createdAt": "2020-04-27T08:12:19Z", "author": {"login": "rdulmina"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -5871,6 +5898,76 @@ private boolean isValidLHSExpression(SyntaxKind tokenKind) {\n     }\n \n     /**\n+     * Parse parameterized type descriptor.\n+     * parameterized-type-descriptor := map type-parameter | future type-parameter | typedesc type-parameter\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseParameterizedTypeDescriptor() {\n+        STNode parameterizedTypeKeyword;\n+        STToken nextToken = peek();\n+\n+        switch(nextToken.kind) {\n+            case MAP_KEYWORD: // map type desc\n+                startContext(ParserRuleContext.MAP_TYPE_DESCRIPTOR);\n+                parameterizedTypeKeyword = consume();\n+                break;\n+            case FUTURE_KEYWORD: // future type desc\n+                startContext(ParserRuleContext.FUTURE_TYPE_DESCRIPTOR);\n+                parameterizedTypeKeyword = consume();\n+                break;\n+            default:// typedesc type desc\n+                startContext(ParserRuleContext.TYPEDESC_TYPE_DESCRIPTOR);\n+                if (nextToken.kind == SyntaxKind.TYPEDESC_KEYWORD) {\n+                    parameterizedTypeKeyword = consume();\n+                } else {\n+                    Solution sol = recover(nextToken, ParserRuleContext.TYPEDESC_KEYWORD);\n+                    parameterizedTypeKeyword =  sol.recoveredNode;\n+                }\n+        }\n+\n+        STNode ltToken = parseLTToken();\n+        STNode typeNode = parseTypeDescriptor();\n+        STNode gtToken = parseGTToken();\n+\n+        endContext();\n+        return STNodeFactory.createParameterizedTypeDescriptorNode(parameterizedTypeKeyword, ltToken, typeNode,\n+                gtToken);\n+    }\n+\n+\n+    /**\n+     * Parse <code> < </code> token.\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseGTToken() {\n+        STToken nextToken = peek();\n+        if (nextToken.kind == SyntaxKind.GT_TOKEN) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(nextToken, ParserRuleContext.GT);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse <code> > </code> token.\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseLTToken() {\n+        STToken nextToken = peek();\n+        if (nextToken.kind == SyntaxKind.LT_TOKEN) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(nextToken, ParserRuleContext.LT);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse null-keyword.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDQ5OTU5Nw=="}, "originalCommit": {"oid": "f495ea53bf081a936049d81dc6f8647d9abafe47"}, "originalPosition": 149}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3NjYyODg3OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxMToyNToxOFrOGLTIsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxODoxMDoxOFrOGLjbLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDUwMTA0MA==", "bodyText": "Can we live with one context?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22791#discussion_r414501040", "createdAt": "2020-04-24T11:25:18Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -5871,6 +5898,76 @@ private boolean isValidLHSExpression(SyntaxKind tokenKind) {\n     }\n \n     /**\n+     * Parse parameterized type descriptor.\n+     * parameterized-type-descriptor := map type-parameter | future type-parameter | typedesc type-parameter\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseParameterizedTypeDescriptor() {\n+        STNode parameterizedTypeKeyword;\n+        STToken nextToken = peek();\n+\n+        switch(nextToken.kind) {\n+            case MAP_KEYWORD: // map type desc\n+                startContext(ParserRuleContext.MAP_TYPE_DESCRIPTOR);\n+                parameterizedTypeKeyword = consume();\n+                break;\n+            case FUTURE_KEYWORD: // future type desc\n+                startContext(ParserRuleContext.FUTURE_TYPE_DESCRIPTOR);\n+                parameterizedTypeKeyword = consume();\n+                break;\n+            default:// typedesc type desc\n+                startContext(ParserRuleContext.TYPEDESC_TYPE_DESCRIPTOR);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f495ea53bf081a936049d81dc6f8647d9abafe47"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc2NzkxOA==", "bodyText": "I'll look into that", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22791#discussion_r414767918", "createdAt": "2020-04-24T18:10:18Z", "author": {"login": "rdulmina"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -5871,6 +5898,76 @@ private boolean isValidLHSExpression(SyntaxKind tokenKind) {\n     }\n \n     /**\n+     * Parse parameterized type descriptor.\n+     * parameterized-type-descriptor := map type-parameter | future type-parameter | typedesc type-parameter\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseParameterizedTypeDescriptor() {\n+        STNode parameterizedTypeKeyword;\n+        STToken nextToken = peek();\n+\n+        switch(nextToken.kind) {\n+            case MAP_KEYWORD: // map type desc\n+                startContext(ParserRuleContext.MAP_TYPE_DESCRIPTOR);\n+                parameterizedTypeKeyword = consume();\n+                break;\n+            case FUTURE_KEYWORD: // future type desc\n+                startContext(ParserRuleContext.FUTURE_TYPE_DESCRIPTOR);\n+                parameterizedTypeKeyword = consume();\n+                break;\n+            default:// typedesc type desc\n+                startContext(ParserRuleContext.TYPEDESC_TYPE_DESCRIPTOR);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDUwMTA0MA=="}, "originalCommit": {"oid": "f495ea53bf081a936049d81dc6f8647d9abafe47"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3NjY0NjM5OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxMToyOTo1M1rOGLTSlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QwODoxMToxOFrOGMWYTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDUwMzU3Mg==", "bodyText": "Can we live with one list?\nSo the issue here is the left-recursion?\nOne way to handle the left-recursion is, TYPE_DESCRIPTORS list only has non-recursive ones. But when we reach the end of type-desc (eg: getNextRuleForTypeDesc()), we have three alternative paths:\n\nNext rule for type desc, just like what we have now (lets say this is X).\nOptional type desc path, next rule is ?.\nArray type desc path. Next rule is [.\n\nThen we can check on the alternative paths [X, ?, [ ], like any other alternative path search.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22791#discussion_r414503572", "createdAt": "2020-04-24T11:29:53Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -122,7 +122,16 @@\n     // TODO: add other type descriptors\n     private static final ParserRuleContext[] TYPE_DESCRIPTORS =\n             { ParserRuleContext.SIMPLE_TYPE_DESCRIPTOR, ParserRuleContext.OBJECT_TYPE_DESCRIPTOR,\n-                    ParserRuleContext.RECORD_TYPE_DESCRIPTOR, ParserRuleContext.NIL_TYPE_DESCRIPTOR };\n+                    ParserRuleContext.RECORD_TYPE_DESCRIPTOR, ParserRuleContext.NIL_TYPE_DESCRIPTOR,\n+                    ParserRuleContext.MAP_TYPE_DESCRIPTOR, ParserRuleContext.FUTURE_TYPE_DESCRIPTOR,\n+                    ParserRuleContext.TYPEDESC_TYPE_DESCRIPTOR, ParserRuleContext.ARRAY_TYPE_DESCRIPTOR,\n+                    ParserRuleContext.OPTIONAL_TYPE_DESCRIPTOR};\n+\n+    private static final ParserRuleContext[] TYPE_DESCRIPTORS_WITHOUT_COMPLEX =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f495ea53bf081a936049d81dc6f8647d9abafe47"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc2Nzk4Ng==", "bodyText": "I'll look into that", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22791#discussion_r414767986", "createdAt": "2020-04-24T18:10:27Z", "author": {"login": "rdulmina"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -122,7 +122,16 @@\n     // TODO: add other type descriptors\n     private static final ParserRuleContext[] TYPE_DESCRIPTORS =\n             { ParserRuleContext.SIMPLE_TYPE_DESCRIPTOR, ParserRuleContext.OBJECT_TYPE_DESCRIPTOR,\n-                    ParserRuleContext.RECORD_TYPE_DESCRIPTOR, ParserRuleContext.NIL_TYPE_DESCRIPTOR };\n+                    ParserRuleContext.RECORD_TYPE_DESCRIPTOR, ParserRuleContext.NIL_TYPE_DESCRIPTOR,\n+                    ParserRuleContext.MAP_TYPE_DESCRIPTOR, ParserRuleContext.FUTURE_TYPE_DESCRIPTOR,\n+                    ParserRuleContext.TYPEDESC_TYPE_DESCRIPTOR, ParserRuleContext.ARRAY_TYPE_DESCRIPTOR,\n+                    ParserRuleContext.OPTIONAL_TYPE_DESCRIPTOR};\n+\n+    private static final ParserRuleContext[] TYPE_DESCRIPTORS_WITHOUT_COMPLEX =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDUwMzU3Mg=="}, "originalCommit": {"oid": "f495ea53bf081a936049d81dc6f8647d9abafe47"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYwMjc2NQ==", "bodyText": "Changes done", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22791#discussion_r415602765", "createdAt": "2020-04-27T08:11:18Z", "author": {"login": "rdulmina"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -122,7 +122,16 @@\n     // TODO: add other type descriptors\n     private static final ParserRuleContext[] TYPE_DESCRIPTORS =\n             { ParserRuleContext.SIMPLE_TYPE_DESCRIPTOR, ParserRuleContext.OBJECT_TYPE_DESCRIPTOR,\n-                    ParserRuleContext.RECORD_TYPE_DESCRIPTOR, ParserRuleContext.NIL_TYPE_DESCRIPTOR };\n+                    ParserRuleContext.RECORD_TYPE_DESCRIPTOR, ParserRuleContext.NIL_TYPE_DESCRIPTOR,\n+                    ParserRuleContext.MAP_TYPE_DESCRIPTOR, ParserRuleContext.FUTURE_TYPE_DESCRIPTOR,\n+                    ParserRuleContext.TYPEDESC_TYPE_DESCRIPTOR, ParserRuleContext.ARRAY_TYPE_DESCRIPTOR,\n+                    ParserRuleContext.OPTIONAL_TYPE_DESCRIPTOR};\n+\n+    private static final ParserRuleContext[] TYPE_DESCRIPTORS_WITHOUT_COMPLEX =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDUwMzU3Mg=="}, "originalCommit": {"oid": "f495ea53bf081a936049d81dc6f8647d9abafe47"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3NjcyNzI4OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxMTo1MDo0N1rOGLUAHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QwODoxMToyMFrOGMWYXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDUxNTIyOA==", "bodyText": "we should not switch contexts other than in the getNextRule() method's switch case.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22791#discussion_r414515228", "createdAt": "2020-04-24T11:50:47Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -2388,21 +2450,22 @@ private ParserRuleContext getNextRuleForDot() {\n      *\n      * @return Next parser context\n      */\n-    private ParserRuleContext getNextRuleForQuestionMark() {\n+    private ParserRuleContext getNextRuleForQuestionMark(int nextLookahead) {\n         ParserRuleContext parentCtx = getParentContext();\n         switch (parentCtx) {\n             case OPTIONAL_TYPE_DESCRIPTOR:\n-                endContext();\n-                parentCtx = getParentContext();\n-                switch (parentCtx) {\n-                    case MODULE_TYPE_DEFINITION:\n-                        return ParserRuleContext.SEMICOLON;\n-                    case RETURN_TYPE_DESCRIPTOR:\n-                        return ParserRuleContext.FUNC_BODY;\n-                    default:\n-                        return ParserRuleContext.VARIABLE_NAME;\n+                STToken nextToken = this.tokenReader.peek(nextLookahead);\n+                //int?[] scenario\n+                if (nextToken.kind == SyntaxKind.OPEN_BRACKET_TOKEN) {\n+                    switchContext(ParserRuleContext.ARRAY_TYPE_DESCRIPTOR);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f495ea53bf081a936049d81dc6f8647d9abafe47"}, "originalPosition": 167}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYwMjc4Mw==", "bodyText": "Resloved.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22791#discussion_r415602783", "createdAt": "2020-04-27T08:11:20Z", "author": {"login": "rdulmina"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -2388,21 +2450,22 @@ private ParserRuleContext getNextRuleForDot() {\n      *\n      * @return Next parser context\n      */\n-    private ParserRuleContext getNextRuleForQuestionMark() {\n+    private ParserRuleContext getNextRuleForQuestionMark(int nextLookahead) {\n         ParserRuleContext parentCtx = getParentContext();\n         switch (parentCtx) {\n             case OPTIONAL_TYPE_DESCRIPTOR:\n-                endContext();\n-                parentCtx = getParentContext();\n-                switch (parentCtx) {\n-                    case MODULE_TYPE_DEFINITION:\n-                        return ParserRuleContext.SEMICOLON;\n-                    case RETURN_TYPE_DESCRIPTOR:\n-                        return ParserRuleContext.FUNC_BODY;\n-                    default:\n-                        return ParserRuleContext.VARIABLE_NAME;\n+                STToken nextToken = this.tokenReader.peek(nextLookahead);\n+                //int?[] scenario\n+                if (nextToken.kind == SyntaxKind.OPEN_BRACKET_TOKEN) {\n+                    switchContext(ParserRuleContext.ARRAY_TYPE_DESCRIPTOR);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDUxNTIyOA=="}, "originalCommit": {"oid": "f495ea53bf081a936049d81dc6f8647d9abafe47"}, "originalPosition": 167}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4Mjg2NDkyOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-treegen/src/main/resources/syntax_tree_descriptor.json", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNlQxMzowMToyMlrOGMEQHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QwODoxNjozMVrOGMWl7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTMwNTc1Nw==", "bodyText": "base should be TypeDescriptorNode... Its a newly added one with the tree-refactor", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22791#discussion_r415305757", "createdAt": "2020-04-26T13:01:22Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-treegen/src/main/resources/syntax_tree_descriptor.json", "diffHunk": "@@ -1526,6 +1526,29 @@\n                 }\n             ]\n         },\n+        {\n+            \"name\": \"ParameterizedTypeDescriptorNode\",\n+            \"base\": \"Node\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f495ea53bf081a936049d81dc6f8647d9abafe47"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYwNjI1NA==", "bodyText": "Changed", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22791#discussion_r415606254", "createdAt": "2020-04-27T08:16:31Z", "author": {"login": "rdulmina"}, "path": "compiler/ballerina-treegen/src/main/resources/syntax_tree_descriptor.json", "diffHunk": "@@ -1526,6 +1526,29 @@\n                 }\n             ]\n         },\n+        {\n+            \"name\": \"ParameterizedTypeDescriptorNode\",\n+            \"base\": \"Node\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTMwNTc1Nw=="}, "originalCommit": {"oid": "f495ea53bf081a936049d81dc6f8647d9abafe47"}, "originalPosition": 6}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3880, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}