{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA3MjA2OTQz", "number": 26445, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwMzoxNDo0M1rOEwDfmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwNDowNzoxMVrOEwEFEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4ODI0MzQ3OnYy", "diffSide": "RIGHT", "path": "language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/codeaction/CodeActionUtil.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwMzoxNDo0M1rOHlYqFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwNjoxMjo0MlrOHlbsyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk2MzM0OQ==", "bodyText": "Do we still depend on the AST models? We should depend on the Syntax Tree, since we have the particular APIs", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26445#discussion_r508963349", "createdAt": "2020-10-21T03:14:43Z", "author": {"login": "nadeeshaan"}, "path": "language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/codeaction/CodeActionUtil.java", "diffHunk": "@@ -80,38 +68,38 @@ private CodeActionUtil() {\n      * @return {@link String}   Top level node type\n      */\n     public static CodeActionNodeType topLevelNodeInLine(LSContext context, TextDocumentIdentifier identifier,\n-                                                        int cursorLine, WorkspaceDocumentManager docManager) {\n+                                                        int cursorLine, WorkspaceDocumentManager docManager)\n+            throws CompilationFailedException {\n         Optional<Path> filePath = CommonUtil.getPathFromURI(identifier.getUri());\n-        if (!filePath.isPresent()) {\n+        if (filePath.isEmpty()) {\n             return null;\n         }\n \n-        try {\n-            BLangPackage bLangPackage = LSModuleCompiler.getBLangPackage(context, docManager, false, false);\n-            String relativeSourcePath = context.get(DocumentServiceKeys.RELATIVE_FILE_PATH_KEY);\n-            BLangPackage evalPkg = CommonUtil.getSourceOwnerBLangPackage(relativeSourcePath, bLangPackage);\n-            List<Diagnostic> diagnostics = bLangPackage.getDiagnostics();\n-            context.put(CodeActionKeys.DIAGNOSTICS_KEY, CodeActionUtil.toDiagnostics(diagnostics));\n+        BLangPackage bLangPackage = LSModuleCompiler.getBLangPackage(context, docManager, false, false);\n+        String relativeSourcePath = context.get(DocumentServiceKeys.RELATIVE_FILE_PATH_KEY);\n+        BLangPackage evalPkg = CommonUtil.getSourceOwnerBLangPackage(relativeSourcePath, bLangPackage);\n+        List<Diagnostic> diagnostics = bLangPackage.getDiagnostics();\n+        context.put(CodeActionKeys.DIAGNOSTICS_KEY, CodeActionUtil.toDiagnostics(diagnostics));\n \n-            Optional<BLangCompilationUnit> filteredCUnit = evalPkg.compUnits.stream()\n-                    .filter(cUnit -> cUnit.getPosition().getSource()\n-                            .cUnitName.replace(\"/\", CommonUtil.FILE_SEPARATOR)\n-                            .equals(relativeSourcePath))\n-                    .findAny();\n+        Optional<BLangCompilationUnit> filteredCUnit = evalPkg.compUnits.stream()\n+                .filter(cUnit -> cUnit.getPosition().getSource()\n+                        .cUnitName.replace(\"/\", CommonUtil.FILE_SEPARATOR)\n+                        .equals(relativeSourcePath))\n+                .findAny();\n \n-            if (!filteredCUnit.isPresent()) {\n-                return null;\n-            }\n+        if (filteredCUnit.isEmpty()) {\n+            return null;\n+        }\n \n-            for (TopLevelNode topLevelNode : filteredCUnit.get().getTopLevelNodes()) {\n-                DiagnosticPos diagnosticPos = CommonUtil.toZeroBasedPosition(((BLangNode) topLevelNode).pos);\n-                if (topLevelNode instanceof BLangService) {\n-                    if (diagnosticPos.sLine == cursorLine) {\n-                        return CodeActionNodeType.SERVICE;\n-                    }\n-                    if (cursorLine > diagnosticPos.sLine && cursorLine < diagnosticPos.eLine) {\n-                        // Cursor within the service\n-                        for (BLangFunction resourceFunction : ((BLangService) topLevelNode).resourceFunctions) {\n+        for (TopLevelNode topLevelNode : filteredCUnit.get().getTopLevelNodes()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6060891b04e74d9abbf05ee82c90bc1a91221eea"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTAxMzE5NQ==", "bodyText": "Ack, will migrate this. Earlier tried but couldn't achieve due to limitations in semantic-api. now we should be able to migrate.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26445#discussion_r509013195", "createdAt": "2020-10-21T06:12:42Z", "author": {"login": "rasika"}, "path": "language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/codeaction/CodeActionUtil.java", "diffHunk": "@@ -80,38 +68,38 @@ private CodeActionUtil() {\n      * @return {@link String}   Top level node type\n      */\n     public static CodeActionNodeType topLevelNodeInLine(LSContext context, TextDocumentIdentifier identifier,\n-                                                        int cursorLine, WorkspaceDocumentManager docManager) {\n+                                                        int cursorLine, WorkspaceDocumentManager docManager)\n+            throws CompilationFailedException {\n         Optional<Path> filePath = CommonUtil.getPathFromURI(identifier.getUri());\n-        if (!filePath.isPresent()) {\n+        if (filePath.isEmpty()) {\n             return null;\n         }\n \n-        try {\n-            BLangPackage bLangPackage = LSModuleCompiler.getBLangPackage(context, docManager, false, false);\n-            String relativeSourcePath = context.get(DocumentServiceKeys.RELATIVE_FILE_PATH_KEY);\n-            BLangPackage evalPkg = CommonUtil.getSourceOwnerBLangPackage(relativeSourcePath, bLangPackage);\n-            List<Diagnostic> diagnostics = bLangPackage.getDiagnostics();\n-            context.put(CodeActionKeys.DIAGNOSTICS_KEY, CodeActionUtil.toDiagnostics(diagnostics));\n+        BLangPackage bLangPackage = LSModuleCompiler.getBLangPackage(context, docManager, false, false);\n+        String relativeSourcePath = context.get(DocumentServiceKeys.RELATIVE_FILE_PATH_KEY);\n+        BLangPackage evalPkg = CommonUtil.getSourceOwnerBLangPackage(relativeSourcePath, bLangPackage);\n+        List<Diagnostic> diagnostics = bLangPackage.getDiagnostics();\n+        context.put(CodeActionKeys.DIAGNOSTICS_KEY, CodeActionUtil.toDiagnostics(diagnostics));\n \n-            Optional<BLangCompilationUnit> filteredCUnit = evalPkg.compUnits.stream()\n-                    .filter(cUnit -> cUnit.getPosition().getSource()\n-                            .cUnitName.replace(\"/\", CommonUtil.FILE_SEPARATOR)\n-                            .equals(relativeSourcePath))\n-                    .findAny();\n+        Optional<BLangCompilationUnit> filteredCUnit = evalPkg.compUnits.stream()\n+                .filter(cUnit -> cUnit.getPosition().getSource()\n+                        .cUnitName.replace(\"/\", CommonUtil.FILE_SEPARATOR)\n+                        .equals(relativeSourcePath))\n+                .findAny();\n \n-            if (!filteredCUnit.isPresent()) {\n-                return null;\n-            }\n+        if (filteredCUnit.isEmpty()) {\n+            return null;\n+        }\n \n-            for (TopLevelNode topLevelNode : filteredCUnit.get().getTopLevelNodes()) {\n-                DiagnosticPos diagnosticPos = CommonUtil.toZeroBasedPosition(((BLangNode) topLevelNode).pos);\n-                if (topLevelNode instanceof BLangService) {\n-                    if (diagnosticPos.sLine == cursorLine) {\n-                        return CodeActionNodeType.SERVICE;\n-                    }\n-                    if (cursorLine > diagnosticPos.sLine && cursorLine < diagnosticPos.eLine) {\n-                        // Cursor within the service\n-                        for (BLangFunction resourceFunction : ((BLangService) topLevelNode).resourceFunctions) {\n+        for (TopLevelNode topLevelNode : filteredCUnit.get().getTopLevelNodes()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk2MzM0OQ=="}, "originalCommit": {"oid": "6060891b04e74d9abbf05ee82c90bc1a91221eea"}, "originalPosition": 95}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4ODI3ODAxOnYy", "diffSide": "RIGHT", "path": "language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/codeaction/impl/CreateFunctionCodeAction.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwMzozMjozMFrOHlY9kg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwNTowODowOFrOHlacIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk2ODMzOA==", "bodyText": "May be we can omit the variable here, if we need more clarification, let's put a comment", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26445#discussion_r508968338", "createdAt": "2020-10-21T03:32:30Z", "author": {"login": "nadeeshaan"}, "path": "language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/codeaction/impl/CreateFunctionCodeAction.java", "diffHunk": "@@ -74,30 +60,19 @@\n         List<Object> args = Arrays.asList(lineArg, colArg, uriArg);\n         Matcher matcher = CommandConstants.UNDEFINED_FUNCTION_PATTERN.matcher(diagnosticMessage);\n         String functionName = (matcher.find() && matcher.groupCount() > 0) ? matcher.group(1) + \"(...)\" : \"\";\n-        WorkspaceDocumentManager docManager = context.get(DocumentServiceKeys.DOC_MANAGER_KEY);\n-        String diagnosedContent = getDiagnosedContent(diagnostic, context, document);\n         try {\n-            LSDocumentIdentifier lsDocument = docManager.getLSDocument(CommonUtil.getPathFromURI(uri).get());\n-            context.put(ReferencesKeys.OFFSET_CURSOR_N_TRY_NEXT_BEST, true);\n-            context.put(ReferencesKeys.DO_NOT_SKIP_NULL_SYMBOLS, true);\n-            Position afterAliasPos = offsetPositionToInvocation(diagnosedContent, position);\n-            // TODO: Try to use referenceAtCursor\n-            SymbolReferencesModel.Reference refAtCursor = getReferenceAtCursor(context, lsDocument, afterAliasPos);\n-            BLangNode bLangNode = refAtCursor.getbLangNode();\n-            BLangInvocation node = null;\n-            if (bLangNode instanceof BLangInvocation) {\n-                node = (BLangInvocation) bLangNode;\n+            Position diagPos = diagnostic.getRange().getStart();\n+            NonTerminalNode cursorNode = CommonUtil.findNode(context, diagPos, CommonUtil.getPathFromURI(uri).get());\n+            while (cursorNode != null &&\n+                    cursorNode.kind() != SyntaxKind.MODULE_PART &&\n+                    cursorNode.kind() != SyntaxKind.FUNCTION_DEFINITION &&\n+                    cursorNode.kind() != SyntaxKind.FUNCTION_CALL) {\n+                cursorNode = cursorNode.parent();\n             }\n-            if (node != null && node.pkgAlias.value.isEmpty()) {\n-                boolean isWithinProject = (node.expr == null);\n-                if (node.expr != null) {\n-                    BLangPackage bLangPackage = context.get(DocumentServiceKeys.CURRENT_BLANG_PACKAGE_CONTEXT_KEY);\n-                    List<String> currentModules = document.getProjectModules();\n-                    PackageID nodePkgId = node.expr.type.tsymbol.pkgID;\n-                    isWithinProject = bLangPackage.packageID.orgName.equals(nodePkgId.orgName) &&\n-                            currentModules.contains(nodePkgId.name.value);\n-                }\n-                if (isWithinProject) {\n+            if (cursorNode != null && cursorNode.kind() == SyntaxKind.FUNCTION_CALL) {\n+                FunctionCallExpressionNode callExpr = (FunctionCallExpressionNode) cursorNode;\n+                boolean isWithinFile = callExpr.functionName().kind() == SyntaxKind.SIMPLE_NAME_REFERENCE;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6060891b04e74d9abbf05ee82c90bc1a91221eea"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk5MjU0NA==", "bodyText": "Since the name FunctionCallExpressionNode is bit longer; it wraps the statement into multiple lines. Thus, introduced this local variable.\nboolean isWithinFile = ((FunctionCallExpressionNode) cursorNode).functionName().kind() == SyntaxKind.SIMPLE_NAME_REFERENCE;", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26445#discussion_r508992544", "createdAt": "2020-10-21T05:08:08Z", "author": {"login": "rasika"}, "path": "language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/codeaction/impl/CreateFunctionCodeAction.java", "diffHunk": "@@ -74,30 +60,19 @@\n         List<Object> args = Arrays.asList(lineArg, colArg, uriArg);\n         Matcher matcher = CommandConstants.UNDEFINED_FUNCTION_PATTERN.matcher(diagnosticMessage);\n         String functionName = (matcher.find() && matcher.groupCount() > 0) ? matcher.group(1) + \"(...)\" : \"\";\n-        WorkspaceDocumentManager docManager = context.get(DocumentServiceKeys.DOC_MANAGER_KEY);\n-        String diagnosedContent = getDiagnosedContent(diagnostic, context, document);\n         try {\n-            LSDocumentIdentifier lsDocument = docManager.getLSDocument(CommonUtil.getPathFromURI(uri).get());\n-            context.put(ReferencesKeys.OFFSET_CURSOR_N_TRY_NEXT_BEST, true);\n-            context.put(ReferencesKeys.DO_NOT_SKIP_NULL_SYMBOLS, true);\n-            Position afterAliasPos = offsetPositionToInvocation(diagnosedContent, position);\n-            // TODO: Try to use referenceAtCursor\n-            SymbolReferencesModel.Reference refAtCursor = getReferenceAtCursor(context, lsDocument, afterAliasPos);\n-            BLangNode bLangNode = refAtCursor.getbLangNode();\n-            BLangInvocation node = null;\n-            if (bLangNode instanceof BLangInvocation) {\n-                node = (BLangInvocation) bLangNode;\n+            Position diagPos = diagnostic.getRange().getStart();\n+            NonTerminalNode cursorNode = CommonUtil.findNode(context, diagPos, CommonUtil.getPathFromURI(uri).get());\n+            while (cursorNode != null &&\n+                    cursorNode.kind() != SyntaxKind.MODULE_PART &&\n+                    cursorNode.kind() != SyntaxKind.FUNCTION_DEFINITION &&\n+                    cursorNode.kind() != SyntaxKind.FUNCTION_CALL) {\n+                cursorNode = cursorNode.parent();\n             }\n-            if (node != null && node.pkgAlias.value.isEmpty()) {\n-                boolean isWithinProject = (node.expr == null);\n-                if (node.expr != null) {\n-                    BLangPackage bLangPackage = context.get(DocumentServiceKeys.CURRENT_BLANG_PACKAGE_CONTEXT_KEY);\n-                    List<String> currentModules = document.getProjectModules();\n-                    PackageID nodePkgId = node.expr.type.tsymbol.pkgID;\n-                    isWithinProject = bLangPackage.packageID.orgName.equals(nodePkgId.orgName) &&\n-                            currentModules.contains(nodePkgId.name.value);\n-                }\n-                if (isWithinProject) {\n+            if (cursorNode != null && cursorNode.kind() == SyntaxKind.FUNCTION_CALL) {\n+                FunctionCallExpressionNode callExpr = (FunctionCallExpressionNode) cursorNode;\n+                boolean isWithinFile = callExpr.functionName().kind() == SyntaxKind.SIMPLE_NAME_REFERENCE;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk2ODMzOA=="}, "originalCommit": {"oid": "6060891b04e74d9abbf05ee82c90bc1a91221eea"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4ODI4Nzc2OnYy", "diffSide": "RIGHT", "path": "language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/codeaction/impl/DiagBasedCodeAction.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwMzozNzo1OFrOHlZDNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwNDoxNjoyOVrOHlZoqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk2OTc4Mg==", "bodyText": "Are these checks valid? We are comparing two different hierarchies, semantic API against the AST.\nPlease revisit the if-else ladder", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26445#discussion_r508969782", "createdAt": "2020-10-21T03:37:58Z", "author": {"login": "nadeeshaan"}, "path": "language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/codeaction/impl/DiagBasedCodeAction.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.langserver.codeaction.impl;\n+\n+import io.ballerina.compiler.api.types.BallerinaTypeDescriptor;\n+import org.ballerinalang.langserver.common.ImportsAcceptor;\n+import org.ballerinalang.langserver.common.utils.FunctionGenerator;\n+import org.ballerinalang.langserver.commons.LSContext;\n+import org.ballerinalang.langserver.commons.codeaction.LSCodeActionProviderException;\n+import org.ballerinalang.langserver.compiler.DocumentServiceKeys;\n+import org.ballerinalang.model.tree.TopLevelNode;\n+import org.ballerinalang.model.tree.expressions.ExpressionNode;\n+import org.ballerinalang.model.tree.expressions.RecordLiteralNode;\n+import org.eclipse.lsp4j.CodeAction;\n+import org.eclipse.lsp4j.Diagnostic;\n+import org.eclipse.lsp4j.TextEdit;\n+import org.wso2.ballerinalang.compiler.semantics.analyzer.Types;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BRecordType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BTupleType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BType;\n+import org.wso2.ballerinalang.compiler.tree.BLangPackage;\n+import org.wso2.ballerinalang.compiler.tree.BLangTypeDefinition;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangBinaryExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangFieldBasedAccess;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangInvocation;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangListConstructorExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangQueryExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangRecordLiteral;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangRecordTypeNode;\n+import org.wso2.ballerinalang.compiler.util.CompilerContext;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.StringJoiner;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Interface for diagnostics based code actions.\n+ *\n+ * @since 2.0.0\n+ */\n+public interface DiagBasedCodeAction {\n+\n+    List<CodeAction> get(Diagnostic diagnostic, List<Diagnostic> allDiagnostics, LSContext context)\n+            throws LSCodeActionProviderException;\n+\n+\n+    static List<String> getPossibleTypes(LSContext context,\n+                                         BallerinaTypeDescriptor typeDescriptor,\n+                                         List<TextEdit> edits,\n+                                         CompilerContext compilerContext) {\n+        ImportsAcceptor importsAcceptor = new ImportsAcceptor(context);\n+\n+        List<String> types = new ArrayList<>();\n+\n+        String variableType = FunctionGenerator.generateTypeDefinition(importsAcceptor, typeDescriptor, context);\n+        if (typeDescriptor instanceof BLangInvocation) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6060891b04e74d9abbf05ee82c90bc1a91221eea"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk3OTM2OA==", "bodyText": "No, this has to revamped when we get type-info for literals. Kept it intact since for the reference of code-migration and it doesn't affect the other flow. Should we remove these checks?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26445#discussion_r508979368", "createdAt": "2020-10-21T04:16:29Z", "author": {"login": "rasika"}, "path": "language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/codeaction/impl/DiagBasedCodeAction.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.langserver.codeaction.impl;\n+\n+import io.ballerina.compiler.api.types.BallerinaTypeDescriptor;\n+import org.ballerinalang.langserver.common.ImportsAcceptor;\n+import org.ballerinalang.langserver.common.utils.FunctionGenerator;\n+import org.ballerinalang.langserver.commons.LSContext;\n+import org.ballerinalang.langserver.commons.codeaction.LSCodeActionProviderException;\n+import org.ballerinalang.langserver.compiler.DocumentServiceKeys;\n+import org.ballerinalang.model.tree.TopLevelNode;\n+import org.ballerinalang.model.tree.expressions.ExpressionNode;\n+import org.ballerinalang.model.tree.expressions.RecordLiteralNode;\n+import org.eclipse.lsp4j.CodeAction;\n+import org.eclipse.lsp4j.Diagnostic;\n+import org.eclipse.lsp4j.TextEdit;\n+import org.wso2.ballerinalang.compiler.semantics.analyzer.Types;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BRecordType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BTupleType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BType;\n+import org.wso2.ballerinalang.compiler.tree.BLangPackage;\n+import org.wso2.ballerinalang.compiler.tree.BLangTypeDefinition;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangBinaryExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangFieldBasedAccess;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangInvocation;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangListConstructorExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangQueryExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangRecordLiteral;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangRecordTypeNode;\n+import org.wso2.ballerinalang.compiler.util.CompilerContext;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.StringJoiner;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Interface for diagnostics based code actions.\n+ *\n+ * @since 2.0.0\n+ */\n+public interface DiagBasedCodeAction {\n+\n+    List<CodeAction> get(Diagnostic diagnostic, List<Diagnostic> allDiagnostics, LSContext context)\n+            throws LSCodeActionProviderException;\n+\n+\n+    static List<String> getPossibleTypes(LSContext context,\n+                                         BallerinaTypeDescriptor typeDescriptor,\n+                                         List<TextEdit> edits,\n+                                         CompilerContext compilerContext) {\n+        ImportsAcceptor importsAcceptor = new ImportsAcceptor(context);\n+\n+        List<String> types = new ArrayList<>();\n+\n+        String variableType = FunctionGenerator.generateTypeDefinition(importsAcceptor, typeDescriptor, context);\n+        if (typeDescriptor instanceof BLangInvocation) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk2OTc4Mg=="}, "originalCommit": {"oid": "6060891b04e74d9abbf05ee82c90bc1a91221eea"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4ODI5MDUxOnYy", "diffSide": "RIGHT", "path": "language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/codeaction/impl/DiagBasedCodeAction.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwMzozOToyOVrOHlZEtw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxMDowMDowN1rOHlkDMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk3MDE2Nw==", "bodyText": "If commenting the code section is intentional, let's add a TODO as well", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26445#discussion_r508970167", "createdAt": "2020-10-21T03:39:29Z", "author": {"login": "nadeeshaan"}, "path": "language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/codeaction/impl/DiagBasedCodeAction.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.langserver.codeaction.impl;\n+\n+import io.ballerina.compiler.api.types.BallerinaTypeDescriptor;\n+import org.ballerinalang.langserver.common.ImportsAcceptor;\n+import org.ballerinalang.langserver.common.utils.FunctionGenerator;\n+import org.ballerinalang.langserver.commons.LSContext;\n+import org.ballerinalang.langserver.commons.codeaction.LSCodeActionProviderException;\n+import org.ballerinalang.langserver.compiler.DocumentServiceKeys;\n+import org.ballerinalang.model.tree.TopLevelNode;\n+import org.ballerinalang.model.tree.expressions.ExpressionNode;\n+import org.ballerinalang.model.tree.expressions.RecordLiteralNode;\n+import org.eclipse.lsp4j.CodeAction;\n+import org.eclipse.lsp4j.Diagnostic;\n+import org.eclipse.lsp4j.TextEdit;\n+import org.wso2.ballerinalang.compiler.semantics.analyzer.Types;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BRecordType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BTupleType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BType;\n+import org.wso2.ballerinalang.compiler.tree.BLangPackage;\n+import org.wso2.ballerinalang.compiler.tree.BLangTypeDefinition;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangBinaryExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangFieldBasedAccess;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangInvocation;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangListConstructorExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangQueryExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangRecordLiteral;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangRecordTypeNode;\n+import org.wso2.ballerinalang.compiler.util.CompilerContext;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.StringJoiner;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Interface for diagnostics based code actions.\n+ *\n+ * @since 2.0.0\n+ */\n+public interface DiagBasedCodeAction {\n+\n+    List<CodeAction> get(Diagnostic diagnostic, List<Diagnostic> allDiagnostics, LSContext context)\n+            throws LSCodeActionProviderException;\n+\n+\n+    static List<String> getPossibleTypes(LSContext context,\n+                                         BallerinaTypeDescriptor typeDescriptor,\n+                                         List<TextEdit> edits,\n+                                         CompilerContext compilerContext) {\n+        ImportsAcceptor importsAcceptor = new ImportsAcceptor(context);\n+\n+        List<String> types = new ArrayList<>();\n+\n+        String variableType = FunctionGenerator.generateTypeDefinition(importsAcceptor, typeDescriptor, context);\n+        if (typeDescriptor instanceof BLangInvocation) {\n+            types.add(variableType);\n+        } else if (typeDescriptor instanceof BLangFieldBasedAccess) {\n+            types.add(variableType);\n+        } else if (typeDescriptor instanceof BLangRecordLiteral) {\n+            // Record\n+            List<BLangPackage> bLangPackages = context.get(DocumentServiceKeys.BLANG_PACKAGES_CONTEXT_KEY);\n+            BRecordType matchingRecordType = null;\n+            Types typesChk = Types.getInstance(compilerContext);\n+            for (BLangPackage pkg : bLangPackages) {\n+                for (TopLevelNode topLevelNode : pkg.topLevelNodes) {\n+                    if (topLevelNode instanceof BLangTypeDefinition &&\n+                            ((BLangTypeDefinition) topLevelNode).typeNode instanceof BLangRecordTypeNode &&\n+                            ((BLangTypeDefinition) topLevelNode).typeNode.type instanceof BRecordType) {\n+                        BRecordType type = (BRecordType) ((BLangTypeDefinition) topLevelNode).typeNode.type;\n+                        if (typesChk.checkStructEquivalency(((BLangRecordLiteral) typeDescriptor).type, type) &&\n+                                !type.tsymbol.name.value.startsWith(\"$\")) {\n+                            matchingRecordType = type;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // Matching Record\n+            if (matchingRecordType != null) {\n+                String recType = FunctionGenerator.generateTypeDefinition(importsAcceptor, typeDescriptor, context);\n+                types.add(recType);\n+            }\n+\n+            // Anon Record\n+            String rType = FunctionGenerator.generateTypeDefinition(importsAcceptor, typeDescriptor, context);\n+            BLangRecordLiteral recordLiteral = (BLangRecordLiteral) typeDescriptor;\n+            types.add((recordLiteral.fields.size() > 0) ? rType : \"record {}\");\n+\n+            // JSON\n+            types.add(\"json\");\n+\n+            // Map\n+            BType prevType = null;\n+            boolean isConstrainedMap = true;\n+            for (RecordLiteralNode.RecordField recordField : recordLiteral.fields) {\n+                if (recordField instanceof BLangRecordLiteral.BLangRecordKeyValueField) {\n+                    BLangRecordLiteral.BLangRecordKeyValueField kvField =\n+                            (BLangRecordLiteral.BLangRecordKeyValueField) recordField;\n+                    BType type = kvField.valueExpr.type;\n+                    if (prevType != null &&\n+                            !prevType.tsymbol.name.getValue().equals(type.tsymbol.name.getValue())) {\n+                        isConstrainedMap = false;\n+                    }\n+                    prevType = type;\n+                }\n+            }\n+            if (isConstrainedMap && prevType != null) {\n+                String type = FunctionGenerator.generateTypeDefinition(importsAcceptor, typeDescriptor,\n+                                                                       context);\n+                types.add(\"map<\" + type + \">\");\n+            } else {\n+                types.add(\"map<any>\");\n+            }\n+        } else if (typeDescriptor instanceof BLangListConstructorExpr) {\n+            BLangListConstructorExpr listExpr = (BLangListConstructorExpr) typeDescriptor;\n+            if (listExpr.expectedType instanceof BTupleType) {\n+                BTupleType tupleType = (BTupleType) listExpr.expectedType;\n+                String arrayType = null;\n+//                String prevType = null;\n+//                String prevInnerType = null;\n+                boolean isArrayCandidate = !tupleType.tupleTypes.isEmpty();\n+                StringJoiner tupleJoiner = new StringJoiner(\", \");\n+                for (BType type : tupleType.tupleTypes) {\n+                    String newType = FunctionGenerator.generateTypeDefinition(importsAcceptor, typeDescriptor,\n+                                                                              context);\n+//                    if (prevType != null && !prevType.equals(newType)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6060891b04e74d9abbf05ee82c90bc1a91221eea"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk3OTk5MA==", "bodyText": "Yes, whole method getPossibleTypes need to revamp after literals type-info is avaialble", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26445#discussion_r508979990", "createdAt": "2020-10-21T04:18:58Z", "author": {"login": "rasika"}, "path": "language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/codeaction/impl/DiagBasedCodeAction.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.langserver.codeaction.impl;\n+\n+import io.ballerina.compiler.api.types.BallerinaTypeDescriptor;\n+import org.ballerinalang.langserver.common.ImportsAcceptor;\n+import org.ballerinalang.langserver.common.utils.FunctionGenerator;\n+import org.ballerinalang.langserver.commons.LSContext;\n+import org.ballerinalang.langserver.commons.codeaction.LSCodeActionProviderException;\n+import org.ballerinalang.langserver.compiler.DocumentServiceKeys;\n+import org.ballerinalang.model.tree.TopLevelNode;\n+import org.ballerinalang.model.tree.expressions.ExpressionNode;\n+import org.ballerinalang.model.tree.expressions.RecordLiteralNode;\n+import org.eclipse.lsp4j.CodeAction;\n+import org.eclipse.lsp4j.Diagnostic;\n+import org.eclipse.lsp4j.TextEdit;\n+import org.wso2.ballerinalang.compiler.semantics.analyzer.Types;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BRecordType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BTupleType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BType;\n+import org.wso2.ballerinalang.compiler.tree.BLangPackage;\n+import org.wso2.ballerinalang.compiler.tree.BLangTypeDefinition;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangBinaryExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangFieldBasedAccess;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangInvocation;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangListConstructorExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangQueryExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangRecordLiteral;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangRecordTypeNode;\n+import org.wso2.ballerinalang.compiler.util.CompilerContext;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.StringJoiner;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Interface for diagnostics based code actions.\n+ *\n+ * @since 2.0.0\n+ */\n+public interface DiagBasedCodeAction {\n+\n+    List<CodeAction> get(Diagnostic diagnostic, List<Diagnostic> allDiagnostics, LSContext context)\n+            throws LSCodeActionProviderException;\n+\n+\n+    static List<String> getPossibleTypes(LSContext context,\n+                                         BallerinaTypeDescriptor typeDescriptor,\n+                                         List<TextEdit> edits,\n+                                         CompilerContext compilerContext) {\n+        ImportsAcceptor importsAcceptor = new ImportsAcceptor(context);\n+\n+        List<String> types = new ArrayList<>();\n+\n+        String variableType = FunctionGenerator.generateTypeDefinition(importsAcceptor, typeDescriptor, context);\n+        if (typeDescriptor instanceof BLangInvocation) {\n+            types.add(variableType);\n+        } else if (typeDescriptor instanceof BLangFieldBasedAccess) {\n+            types.add(variableType);\n+        } else if (typeDescriptor instanceof BLangRecordLiteral) {\n+            // Record\n+            List<BLangPackage> bLangPackages = context.get(DocumentServiceKeys.BLANG_PACKAGES_CONTEXT_KEY);\n+            BRecordType matchingRecordType = null;\n+            Types typesChk = Types.getInstance(compilerContext);\n+            for (BLangPackage pkg : bLangPackages) {\n+                for (TopLevelNode topLevelNode : pkg.topLevelNodes) {\n+                    if (topLevelNode instanceof BLangTypeDefinition &&\n+                            ((BLangTypeDefinition) topLevelNode).typeNode instanceof BLangRecordTypeNode &&\n+                            ((BLangTypeDefinition) topLevelNode).typeNode.type instanceof BRecordType) {\n+                        BRecordType type = (BRecordType) ((BLangTypeDefinition) topLevelNode).typeNode.type;\n+                        if (typesChk.checkStructEquivalency(((BLangRecordLiteral) typeDescriptor).type, type) &&\n+                                !type.tsymbol.name.value.startsWith(\"$\")) {\n+                            matchingRecordType = type;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // Matching Record\n+            if (matchingRecordType != null) {\n+                String recType = FunctionGenerator.generateTypeDefinition(importsAcceptor, typeDescriptor, context);\n+                types.add(recType);\n+            }\n+\n+            // Anon Record\n+            String rType = FunctionGenerator.generateTypeDefinition(importsAcceptor, typeDescriptor, context);\n+            BLangRecordLiteral recordLiteral = (BLangRecordLiteral) typeDescriptor;\n+            types.add((recordLiteral.fields.size() > 0) ? rType : \"record {}\");\n+\n+            // JSON\n+            types.add(\"json\");\n+\n+            // Map\n+            BType prevType = null;\n+            boolean isConstrainedMap = true;\n+            for (RecordLiteralNode.RecordField recordField : recordLiteral.fields) {\n+                if (recordField instanceof BLangRecordLiteral.BLangRecordKeyValueField) {\n+                    BLangRecordLiteral.BLangRecordKeyValueField kvField =\n+                            (BLangRecordLiteral.BLangRecordKeyValueField) recordField;\n+                    BType type = kvField.valueExpr.type;\n+                    if (prevType != null &&\n+                            !prevType.tsymbol.name.getValue().equals(type.tsymbol.name.getValue())) {\n+                        isConstrainedMap = false;\n+                    }\n+                    prevType = type;\n+                }\n+            }\n+            if (isConstrainedMap && prevType != null) {\n+                String type = FunctionGenerator.generateTypeDefinition(importsAcceptor, typeDescriptor,\n+                                                                       context);\n+                types.add(\"map<\" + type + \">\");\n+            } else {\n+                types.add(\"map<any>\");\n+            }\n+        } else if (typeDescriptor instanceof BLangListConstructorExpr) {\n+            BLangListConstructorExpr listExpr = (BLangListConstructorExpr) typeDescriptor;\n+            if (listExpr.expectedType instanceof BTupleType) {\n+                BTupleType tupleType = (BTupleType) listExpr.expectedType;\n+                String arrayType = null;\n+//                String prevType = null;\n+//                String prevInnerType = null;\n+                boolean isArrayCandidate = !tupleType.tupleTypes.isEmpty();\n+                StringJoiner tupleJoiner = new StringJoiner(\", \");\n+                for (BType type : tupleType.tupleTypes) {\n+                    String newType = FunctionGenerator.generateTypeDefinition(importsAcceptor, typeDescriptor,\n+                                                                              context);\n+//                    if (prevType != null && !prevType.equals(newType)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk3MDE2Nw=="}, "originalCommit": {"oid": "6060891b04e74d9abbf05ee82c90bc1a91221eea"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTE1MDAwMQ==", "bodyText": "Added a TODO", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26445#discussion_r509150001", "createdAt": "2020-10-21T10:00:07Z", "author": {"login": "rasika"}, "path": "language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/codeaction/impl/DiagBasedCodeAction.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.langserver.codeaction.impl;\n+\n+import io.ballerina.compiler.api.types.BallerinaTypeDescriptor;\n+import org.ballerinalang.langserver.common.ImportsAcceptor;\n+import org.ballerinalang.langserver.common.utils.FunctionGenerator;\n+import org.ballerinalang.langserver.commons.LSContext;\n+import org.ballerinalang.langserver.commons.codeaction.LSCodeActionProviderException;\n+import org.ballerinalang.langserver.compiler.DocumentServiceKeys;\n+import org.ballerinalang.model.tree.TopLevelNode;\n+import org.ballerinalang.model.tree.expressions.ExpressionNode;\n+import org.ballerinalang.model.tree.expressions.RecordLiteralNode;\n+import org.eclipse.lsp4j.CodeAction;\n+import org.eclipse.lsp4j.Diagnostic;\n+import org.eclipse.lsp4j.TextEdit;\n+import org.wso2.ballerinalang.compiler.semantics.analyzer.Types;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BRecordType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BTupleType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BType;\n+import org.wso2.ballerinalang.compiler.tree.BLangPackage;\n+import org.wso2.ballerinalang.compiler.tree.BLangTypeDefinition;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangBinaryExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangFieldBasedAccess;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangInvocation;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangListConstructorExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangQueryExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangRecordLiteral;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangRecordTypeNode;\n+import org.wso2.ballerinalang.compiler.util.CompilerContext;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.StringJoiner;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Interface for diagnostics based code actions.\n+ *\n+ * @since 2.0.0\n+ */\n+public interface DiagBasedCodeAction {\n+\n+    List<CodeAction> get(Diagnostic diagnostic, List<Diagnostic> allDiagnostics, LSContext context)\n+            throws LSCodeActionProviderException;\n+\n+\n+    static List<String> getPossibleTypes(LSContext context,\n+                                         BallerinaTypeDescriptor typeDescriptor,\n+                                         List<TextEdit> edits,\n+                                         CompilerContext compilerContext) {\n+        ImportsAcceptor importsAcceptor = new ImportsAcceptor(context);\n+\n+        List<String> types = new ArrayList<>();\n+\n+        String variableType = FunctionGenerator.generateTypeDefinition(importsAcceptor, typeDescriptor, context);\n+        if (typeDescriptor instanceof BLangInvocation) {\n+            types.add(variableType);\n+        } else if (typeDescriptor instanceof BLangFieldBasedAccess) {\n+            types.add(variableType);\n+        } else if (typeDescriptor instanceof BLangRecordLiteral) {\n+            // Record\n+            List<BLangPackage> bLangPackages = context.get(DocumentServiceKeys.BLANG_PACKAGES_CONTEXT_KEY);\n+            BRecordType matchingRecordType = null;\n+            Types typesChk = Types.getInstance(compilerContext);\n+            for (BLangPackage pkg : bLangPackages) {\n+                for (TopLevelNode topLevelNode : pkg.topLevelNodes) {\n+                    if (topLevelNode instanceof BLangTypeDefinition &&\n+                            ((BLangTypeDefinition) topLevelNode).typeNode instanceof BLangRecordTypeNode &&\n+                            ((BLangTypeDefinition) topLevelNode).typeNode.type instanceof BRecordType) {\n+                        BRecordType type = (BRecordType) ((BLangTypeDefinition) topLevelNode).typeNode.type;\n+                        if (typesChk.checkStructEquivalency(((BLangRecordLiteral) typeDescriptor).type, type) &&\n+                                !type.tsymbol.name.value.startsWith(\"$\")) {\n+                            matchingRecordType = type;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // Matching Record\n+            if (matchingRecordType != null) {\n+                String recType = FunctionGenerator.generateTypeDefinition(importsAcceptor, typeDescriptor, context);\n+                types.add(recType);\n+            }\n+\n+            // Anon Record\n+            String rType = FunctionGenerator.generateTypeDefinition(importsAcceptor, typeDescriptor, context);\n+            BLangRecordLiteral recordLiteral = (BLangRecordLiteral) typeDescriptor;\n+            types.add((recordLiteral.fields.size() > 0) ? rType : \"record {}\");\n+\n+            // JSON\n+            types.add(\"json\");\n+\n+            // Map\n+            BType prevType = null;\n+            boolean isConstrainedMap = true;\n+            for (RecordLiteralNode.RecordField recordField : recordLiteral.fields) {\n+                if (recordField instanceof BLangRecordLiteral.BLangRecordKeyValueField) {\n+                    BLangRecordLiteral.BLangRecordKeyValueField kvField =\n+                            (BLangRecordLiteral.BLangRecordKeyValueField) recordField;\n+                    BType type = kvField.valueExpr.type;\n+                    if (prevType != null &&\n+                            !prevType.tsymbol.name.getValue().equals(type.tsymbol.name.getValue())) {\n+                        isConstrainedMap = false;\n+                    }\n+                    prevType = type;\n+                }\n+            }\n+            if (isConstrainedMap && prevType != null) {\n+                String type = FunctionGenerator.generateTypeDefinition(importsAcceptor, typeDescriptor,\n+                                                                       context);\n+                types.add(\"map<\" + type + \">\");\n+            } else {\n+                types.add(\"map<any>\");\n+            }\n+        } else if (typeDescriptor instanceof BLangListConstructorExpr) {\n+            BLangListConstructorExpr listExpr = (BLangListConstructorExpr) typeDescriptor;\n+            if (listExpr.expectedType instanceof BTupleType) {\n+                BTupleType tupleType = (BTupleType) listExpr.expectedType;\n+                String arrayType = null;\n+//                String prevType = null;\n+//                String prevInnerType = null;\n+                boolean isArrayCandidate = !tupleType.tupleTypes.isEmpty();\n+                StringJoiner tupleJoiner = new StringJoiner(\", \");\n+                for (BType type : tupleType.tupleTypes) {\n+                    String newType = FunctionGenerator.generateTypeDefinition(importsAcceptor, typeDescriptor,\n+                                                                              context);\n+//                    if (prevType != null && !prevType.equals(newType)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk3MDE2Nw=="}, "originalCommit": {"oid": "6060891b04e74d9abbf05ee82c90bc1a91221eea"}, "originalPosition": 141}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4ODMwMjg0OnYy", "diffSide": "RIGHT", "path": "language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/codeaction/impl/OptimizeImportsCodeAction.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwMzo0NTo0M1rOHlZLTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwNToyMjozOVrOHlasiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk3MTg1NA==", "bodyText": "let's use a meaningful variable name", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26445#discussion_r508971854", "createdAt": "2020-10-21T03:45:43Z", "author": {"login": "nadeeshaan"}, "path": "language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/codeaction/impl/OptimizeImportsCodeAction.java", "diffHunk": "@@ -126,9 +137,12 @@\n         }\n \n         // Re-order imports\n-        List<BLangImportPackage> orderedImports = fileImports.stream()\n-                .sorted(Comparator.comparing((Function<BLangImportPackage, String>) o -> o.orgName.value)\n-                                .thenComparing(o -> o.getAlias().value))\n+        List<ImportDeclarationNode> allImports = new ArrayList<>();\n+        fileImports.iterator().forEachRemaining(allImports::add);\n+        final List<ImportDeclarationNode> orderedImports = allImports.stream()\n+                .sorted(Comparator.comparing((Function<ImportDeclarationNode, String>) o -> o.orgName().isPresent() ?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6060891b04e74d9abbf05ee82c90bc1a91221eea"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk4ODY0Mw==", "bodyText": "i think we have one letter names for lambdas in many places. otherwise it will be lengthy and need to wrap for multiple lines. wdyt?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26445#discussion_r508988643", "createdAt": "2020-10-21T04:53:27Z", "author": {"login": "rasika"}, "path": "language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/codeaction/impl/OptimizeImportsCodeAction.java", "diffHunk": "@@ -126,9 +137,12 @@\n         }\n \n         // Re-order imports\n-        List<BLangImportPackage> orderedImports = fileImports.stream()\n-                .sorted(Comparator.comparing((Function<BLangImportPackage, String>) o -> o.orgName.value)\n-                                .thenComparing(o -> o.getAlias().value))\n+        List<ImportDeclarationNode> allImports = new ArrayList<>();\n+        fileImports.iterator().forEachRemaining(allImports::add);\n+        final List<ImportDeclarationNode> orderedImports = allImports.stream()\n+                .sorted(Comparator.comparing((Function<ImportDeclarationNode, String>) o -> o.orgName().isPresent() ?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk3MTg1NA=="}, "originalCommit": {"oid": "6060891b04e74d9abbf05ee82c90bc1a91221eea"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk5Njc0Nw==", "bodyText": "+1", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26445#discussion_r508996747", "createdAt": "2020-10-21T05:22:39Z", "author": {"login": "nadeeshaan"}, "path": "language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/codeaction/impl/OptimizeImportsCodeAction.java", "diffHunk": "@@ -126,9 +137,12 @@\n         }\n \n         // Re-order imports\n-        List<BLangImportPackage> orderedImports = fileImports.stream()\n-                .sorted(Comparator.comparing((Function<BLangImportPackage, String>) o -> o.orgName.value)\n-                                .thenComparing(o -> o.getAlias().value))\n+        List<ImportDeclarationNode> allImports = new ArrayList<>();\n+        fileImports.iterator().forEachRemaining(allImports::add);\n+        final List<ImportDeclarationNode> orderedImports = allImports.stream()\n+                .sorted(Comparator.comparing((Function<ImportDeclarationNode, String>) o -> o.orgName().isPresent() ?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk3MTg1NA=="}, "originalCommit": {"oid": "6060891b04e74d9abbf05ee82c90bc1a91221eea"}, "originalPosition": 103}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4ODMzOTM5OnYy", "diffSide": "RIGHT", "path": "language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/common/utils/CommonUtil.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwNDowNzoxMVrOHlZf8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwNDowNzoxMVrOHlZf8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk3NzEzOA==", "bodyText": "Let's add a doc comment for the public APIs", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26445#discussion_r508977138", "createdAt": "2020-10-21T04:07:11Z", "author": {"login": "nadeeshaan"}, "path": "language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/common/utils/CommonUtil.java", "diffHunk": "@@ -814,6 +824,47 @@ public static String getPackagePrefix(ImportsAcceptor importsAcceptor, PackageID\n         return pkgPrefix;\n     }\n \n+    public static String getModulePrefix(ImportsAcceptor importsAcceptor, ModuleID currentModuleId,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6060891b04e74d9abbf05ee82c90bc1a91221eea"}, "originalPosition": 138}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4792, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}