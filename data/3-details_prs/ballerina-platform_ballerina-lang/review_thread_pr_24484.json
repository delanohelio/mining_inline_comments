{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQxMjIyMzEw", "number": 24484, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNFQwNDo0Njo0NFrOELWt_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQyMDozNDoyNFrOEO2SCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwMzQyMDE1OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/CodeAnalyzer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNFQwNDo0Njo0NFrOGs54yg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxMDo1MzoxOVrOGtSevQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTczODk1NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // A record type is inferred for a record literal even if the CET is a map, if the mapping\n          \n          \n            \n                    // constructor expression has `readonly` fields.\n          \n          \n            \n                    // A record type is inferred for a record literal even if the CET (contextually expected type) is a map, if \n          \n          \n            \n                    // the mapping constructor expression has `readonly` fields.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24484#discussion_r449738954", "createdAt": "2020-07-04T04:46:44Z", "author": {"login": "KRVPerera"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/CodeAnalyzer.java", "diffHunk": "@@ -1998,7 +1998,14 @@ public void visit(BLangRecordLiteral recordLiteral) {\n \n         Set<Object> names = new HashSet<>();\n         BType type = recordLiteral.type;\n-        boolean isOpenRecord = type != null && type.tag == TypeTags.RECORD && !((BRecordType) type).sealed;\n+        boolean isRecord = type != null && type.tag == TypeTags.RECORD;\n+        boolean isOpenRecord = isRecord && !((BRecordType) type).sealed;\n+\n+        // A record type is inferred for a record literal even if the CET is a map, if the mapping\n+        // constructor expression has `readonly` fields.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4da316a9935e882730f3910cd71d89089862c50"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE0MTg4NQ==", "bodyText": "Fixed in 290649c.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24484#discussion_r450141885", "createdAt": "2020-07-06T10:53:19Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/CodeAnalyzer.java", "diffHunk": "@@ -1998,7 +1998,14 @@ public void visit(BLangRecordLiteral recordLiteral) {\n \n         Set<Object> names = new HashSet<>();\n         BType type = recordLiteral.type;\n-        boolean isOpenRecord = type != null && type.tag == TypeTags.RECORD && !((BRecordType) type).sealed;\n+        boolean isRecord = type != null && type.tag == TypeTags.RECORD;\n+        boolean isOpenRecord = isRecord && !((BRecordType) type).sealed;\n+\n+        // A record type is inferred for a record literal even if the CET is a map, if the mapping\n+        // constructor expression has `readonly` fields.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTczODk1NA=="}, "originalCommit": {"oid": "b4da316a9935e882730f3910cd71d89089862c50"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwMzQyNjUyOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNFQwNDo1ODo1MFrOGs57rA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxMDo1MzoxM1rOGtSejQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTczOTY5Mg==", "bodyText": "origExpType type is not used.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24484#discussion_r449739692", "createdAt": "2020-07-04T04:58:50Z", "author": {"login": "KRVPerera"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -360,16 +348,35 @@ public BType checkExpr(BLangExpression expr, SymbolEnv env, BType expType, Diagn\n \n         expr.accept(this);\n \n-        expr.type = resultType.tag != TypeTags.INTERSECTION ? resultType :\n-                ((BIntersectionType) resultType).effectiveType;\n+        if (resultType.tag == TypeTags.INTERSECTION) {\n+            resultType = ((BIntersectionType) resultType).effectiveType;\n+        }\n+\n+        expr.type = resultType;\n         expr.typeChecked = isTypeChecked;\n         this.env = prevEnv;\n         this.expType = preExpType;\n         this.diagCode = preDiagCode;\n-        if (resultType.tag != TypeTags.SEMANTIC_ERROR) {\n+\n+        validateAndSetExprExpectedType(expr, expType);\n+\n+        return resultType;\n+    }\n+\n+    private void validateAndSetExprExpectedType(BLangExpression expr, BType origExpType) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4da316a9935e882730f3910cd71d89089862c50"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE0MTgzNw==", "bodyText": "Thanks, fixed in 290649c.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24484#discussion_r450141837", "createdAt": "2020-07-06T10:53:13Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -360,16 +348,35 @@ public BType checkExpr(BLangExpression expr, SymbolEnv env, BType expType, Diagn\n \n         expr.accept(this);\n \n-        expr.type = resultType.tag != TypeTags.INTERSECTION ? resultType :\n-                ((BIntersectionType) resultType).effectiveType;\n+        if (resultType.tag == TypeTags.INTERSECTION) {\n+            resultType = ((BIntersectionType) resultType).effectiveType;\n+        }\n+\n+        expr.type = resultType;\n         expr.typeChecked = isTypeChecked;\n         this.env = prevEnv;\n         this.expType = preExpType;\n         this.diagCode = preDiagCode;\n-        if (resultType.tag != TypeTags.SEMANTIC_ERROR) {\n+\n+        validateAndSetExprExpectedType(expr, expType);\n+\n+        return resultType;\n+    }\n+\n+    private void validateAndSetExprExpectedType(BLangExpression expr, BType origExpType) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTczOTY5Mg=="}, "originalCommit": {"oid": "b4da316a9935e882730f3910cd71d89089862c50"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzOTg1MDg4OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/CodeAnalyzer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxOTozNDo0NVrOGyM7wA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxOTo1Njo1MFrOGyNp2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI5Mzg4OA==", "bodyText": "Not related to this PR, but there shouldn't be a case where the type of a record literal is null in code analyzer right?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24484#discussion_r455293888", "createdAt": "2020-07-15T19:34:45Z", "author": {"login": "pubudu91"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/CodeAnalyzer.java", "diffHunk": "@@ -2020,7 +2020,14 @@ public void visit(BLangRecordLiteral recordLiteral) {\n \n         Set<Object> names = new HashSet<>();\n         BType type = recordLiteral.type;\n-        boolean isOpenRecord = type != null && type.tag == TypeTags.RECORD && !((BRecordType) type).sealed;\n+        boolean isRecord = type != null && type.tag == TypeTags.RECORD;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed729d2aa3f90d27522bb8d1f867a4ee61da6cd8"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMwNTY5MQ==", "bodyText": "Yeah, ideally should never be null.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24484#discussion_r455305691", "createdAt": "2020-07-15T19:56:50Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/CodeAnalyzer.java", "diffHunk": "@@ -2020,7 +2020,14 @@ public void visit(BLangRecordLiteral recordLiteral) {\n \n         Set<Object> names = new HashSet<>();\n         BType type = recordLiteral.type;\n-        boolean isOpenRecord = type != null && type.tag == TypeTags.RECORD && !((BRecordType) type).sealed;\n+        boolean isRecord = type != null && type.tag == TypeTags.RECORD;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI5Mzg4OA=="}, "originalCommit": {"oid": "ed729d2aa3f90d27522bb8d1f867a4ee61da6cd8"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzOTg4OTQxOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/CodeAnalyzer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxOTo0NjozMFrOGyNT2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQyMDowNTo1NlrOGyN8mA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMwMDA1Nw==", "bodyText": "Why is the expected type changed here?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24484#discussion_r455300057", "createdAt": "2020-07-15T19:46:30Z", "author": {"login": "pubudu91"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/CodeAnalyzer.java", "diffHunk": "@@ -2084,6 +2091,10 @@ public void visit(BLangRecordLiteral recordLiteral) {\n                 }\n             }\n         }\n+\n+        if (isInferredRecordForMapCET) {\n+            recordLiteral.expectedType = type;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed729d2aa3f90d27522bb8d1f867a4ee61da6cd8"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMxMDQ4OA==", "bodyText": "We don't log the error at L2079 if a record type is inferred for a mapping constructor expression when the contextually expected type is a map type.\ne.g.,\nmap<int> m = {\n   readonly a: 1,\n   b: 2\n};\nHere the actual type of the constructed value is record {| readonly int a; int...; |}. Usually you'll have to use a literal key to provide for the rest field (b in the sample), but that is not required when a record type is inferred for a map ACET.\nTo do this, we need to know here what the original applicable expected type was.\nUsually, the expectedType field of an expression is overridden in checkExpr, but for this particular scenario we don't do it because we need to know the exact ACET - see \n  \n    \n      ballerina-lang/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java\n    \n    \n         Line 378\n      in\n      ed729d2\n    \n    \n    \n    \n\n        \n          \n           // If the expected type is a map, but a record type is inferred due to the presence of `readonly` fields in \n        \n    \n  \n\n\nI don't think this is required, but just for uniformity we set the expectedType as the normal path here.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24484#discussion_r455310488", "createdAt": "2020-07-15T20:05:56Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/CodeAnalyzer.java", "diffHunk": "@@ -2084,6 +2091,10 @@ public void visit(BLangRecordLiteral recordLiteral) {\n                 }\n             }\n         }\n+\n+        if (isInferredRecordForMapCET) {\n+            recordLiteral.expectedType = type;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMwMDA1Nw=="}, "originalCommit": {"oid": "ed729d2aa3f90d27522bb8d1f867a4ee61da6cd8"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzOTk1MzY2OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQyMDowNTozN1rOGyN73w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQyMDowNTozN1rOGyN73w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMxMDMwMw==", "bodyText": "Shall we move this above line 371? When placed here, it looks like a dangling comment", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24484#discussion_r455310303", "createdAt": "2020-07-15T20:05:37Z", "author": {"login": "pubudu91"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -360,16 +348,35 @@ public BType checkExpr(BLangExpression expr, SymbolEnv env, BType expType, Diagn\n \n         expr.accept(this);\n \n-        expr.type = resultType.tag != TypeTags.INTERSECTION ? resultType :\n-                ((BIntersectionType) resultType).effectiveType;\n+        if (resultType.tag == TypeTags.INTERSECTION) {\n+            resultType = ((BIntersectionType) resultType).effectiveType;\n+        }\n+\n+        expr.type = resultType;\n         expr.typeChecked = isTypeChecked;\n         this.env = prevEnv;\n         this.expType = preExpType;\n         this.diagCode = preDiagCode;\n-        if (resultType.tag != TypeTags.SEMANTIC_ERROR) {\n+\n+        validateAndSetExprExpectedType(expr);\n+\n+        return resultType;\n+    }\n+\n+    private void validateAndSetExprExpectedType(BLangExpression expr) {\n+        if (resultType.tag == TypeTags.SEMANTIC_ERROR) {\n+            return;\n+        }\n+\n+        if (expr.getKind() != NodeKind.RECORD_LITERAL_EXPR ||\n+                expr.expectedType == null ||\n+                expr.expectedType.tag != TypeTags.MAP ||\n+                expr.type.tag != TypeTags.RECORD) {\n             expr.expectedType = resultType;\n         }\n-        return resultType;\n+\n+        // If the expected type is a map, but a record type is inferred due to the presence of `readonly` fields in\n+        // the mapping constructor expression, we don't override the expected type.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed729d2aa3f90d27522bb8d1f867a4ee61da6cd8"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzOTk1NTkyOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQyMDowNjoyMFrOGyN9Sw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQyMTowODoxMFrOGyQKmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMxMDY2Nw==", "bodyText": "Wouldn't the inverse of this check read better?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24484#discussion_r455310667", "createdAt": "2020-07-15T20:06:20Z", "author": {"login": "pubudu91"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -360,16 +348,35 @@ public BType checkExpr(BLangExpression expr, SymbolEnv env, BType expType, Diagn\n \n         expr.accept(this);\n \n-        expr.type = resultType.tag != TypeTags.INTERSECTION ? resultType :\n-                ((BIntersectionType) resultType).effectiveType;\n+        if (resultType.tag == TypeTags.INTERSECTION) {\n+            resultType = ((BIntersectionType) resultType).effectiveType;\n+        }\n+\n+        expr.type = resultType;\n         expr.typeChecked = isTypeChecked;\n         this.env = prevEnv;\n         this.expType = preExpType;\n         this.diagCode = preDiagCode;\n-        if (resultType.tag != TypeTags.SEMANTIC_ERROR) {\n+\n+        validateAndSetExprExpectedType(expr);\n+\n+        return resultType;\n+    }\n+\n+    private void validateAndSetExprExpectedType(BLangExpression expr) {\n+        if (resultType.tag == TypeTags.SEMANTIC_ERROR) {\n+            return;\n+        }\n+\n+        if (expr.getKind() != NodeKind.RECORD_LITERAL_EXPR ||\n+                expr.expectedType == null ||\n+                expr.expectedType.tag != TypeTags.MAP ||\n+                expr.type.tag != TypeTags.RECORD) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed729d2aa3f90d27522bb8d1f867a4ee61da6cd8"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTM0Njg0MA==", "bodyText": "I actually found this more readable \ud83d\ude03 But when swapping the comment, I changed it to return early if it matches the inverse, so it's kinda swapped now.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24484#discussion_r455346840", "createdAt": "2020-07-15T21:08:10Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -360,16 +348,35 @@ public BType checkExpr(BLangExpression expr, SymbolEnv env, BType expType, Diagn\n \n         expr.accept(this);\n \n-        expr.type = resultType.tag != TypeTags.INTERSECTION ? resultType :\n-                ((BIntersectionType) resultType).effectiveType;\n+        if (resultType.tag == TypeTags.INTERSECTION) {\n+            resultType = ((BIntersectionType) resultType).effectiveType;\n+        }\n+\n+        expr.type = resultType;\n         expr.typeChecked = isTypeChecked;\n         this.env = prevEnv;\n         this.expType = preExpType;\n         this.diagCode = preDiagCode;\n-        if (resultType.tag != TypeTags.SEMANTIC_ERROR) {\n+\n+        validateAndSetExprExpectedType(expr);\n+\n+        return resultType;\n+    }\n+\n+    private void validateAndSetExprExpectedType(BLangExpression expr) {\n+        if (resultType.tag == TypeTags.SEMANTIC_ERROR) {\n+            return;\n+        }\n+\n+        if (expr.getKind() != NodeKind.RECORD_LITERAL_EXPR ||\n+                expr.expectedType == null ||\n+                expr.expectedType.tag != TypeTags.MAP ||\n+                expr.type.tag != TypeTags.RECORD) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMxMDY2Nw=="}, "originalCommit": {"oid": "ed729d2aa3f90d27522bb8d1f867a4ee61da6cd8"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0MDA0NjE4OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQyMDozMzozNlrOGyO1Pg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQyMTowODo0NFrOGyQMkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMyNDk5MA==", "bodyText": "I think we should consider providing common info such as the name, type of a field through an API. Would simplify code like this. Again, I mean as a future improvement.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24484#discussion_r455324990", "createdAt": "2020-07-15T20:33:36Z", "author": {"login": "pubudu91"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -1481,51 +1497,193 @@ private boolean exprIncompatible(BType eType, BLangExpression expr) {\n         return checkExpr(exprToCheck, this.env, eType) == symTable.semanticError;\n     }\n \n-    private BType[] getExprListUniqueTypes(List<BLangExpression> exprs, SymbolEnv env) {\n-        LinkedHashSet<BType> typesSet = new LinkedHashSet<>(checkExprList(exprs, env));\n-        return typesSet.toArray(new BType[0]);\n+    private List<BType> checkExprList(List<BLangExpression> exprs, SymbolEnv env) {\n+        return checkExprList(exprs, env, symTable.noType);\n     }\n \n-    private List<BType> checkExprList(List<BLangExpression> exprs, SymbolEnv env) {\n+    private List<BType> checkExprList(List<BLangExpression> exprs, SymbolEnv env, BType expType) {\n         List<BType> types = new ArrayList<>();\n         SymbolEnv prevEnv = this.env;\n         BType preExpType = this.expType;\n         this.env = env;\n-        this.expType = symTable.noType;\n+        this.expType = expType;\n         for (BLangExpression e : exprs) {\n-            checkExpr(e, this.env);\n+            checkExpr(e, this.env, expType);\n             types.add(resultType);\n         }\n         this.env = prevEnv;\n         this.expType = preExpType;\n         return types;\n     }\n \n-    private BType getInferredTupleType(BLangListConstructorExpr listConstructor) {\n-        List<BType> memTypes = checkExprList(listConstructor.exprs, env);\n+    private BType getInferredTupleType(BLangListConstructorExpr listConstructor, BType expType) {\n+        List<BType> memTypes = checkExprList(listConstructor.exprs, env, expType);\n \n         for (BType memType : memTypes) {\n             if (memType == symTable.semanticError) {\n                 return symTable.semanticError;\n             }\n         }\n \n-        return new BTupleType(memTypes);\n+        BTupleType tupleType = new BTupleType(memTypes);\n+\n+        if (expType.tag != TypeTags.READONLY) {\n+            return tupleType;\n+        }\n+\n+        tupleType.flags |= Flags.READONLY;\n+        return tupleType;\n     }\n \n     public void visit(BLangRecordLiteral recordLiteral) {\n         int expTypeTag = expType.tag;\n \n-        if (expTypeTag == TypeTags.NONE) {\n-            expType = defineInferredRecordType(recordLiteral);\n+        if (expTypeTag == TypeTags.NONE || expTypeTag == TypeTags.READONLY) {\n+            expType = defineInferredRecordType(recordLiteral, expType);\n         } else if (expTypeTag == TypeTags.OBJECT) {\n-            dlog.error(recordLiteral.pos,\n-                       DiagnosticCode.INVALID_RECORD_LITERAL, expType);\n+            dlog.error(recordLiteral.pos, DiagnosticCode.INVALID_RECORD_LITERAL, expType);\n             resultType = symTable.semanticError;\n             return;\n         }\n \n-        resultType = checkMappingConstructorCompatibility(expType, recordLiteral);\n+        resultType = getEffectiveMappingType(recordLiteral,\n+                                             checkMappingConstructorCompatibility(expType, recordLiteral));\n+    }\n+\n+    private BType getEffectiveMappingType(BLangRecordLiteral recordLiteral, BType applicableMappingType) {\n+        if (applicableMappingType == symTable.semanticError ||\n+                (applicableMappingType.tag == TypeTags.RECORD && Symbols.isFlagOn(applicableMappingType.flags,\n+                                                                                  Flags.READONLY))) {\n+            return applicableMappingType;\n+        }\n+\n+        Map<String, RecordLiteralNode.RecordField> readOnlyFields = new LinkedHashMap<>();\n+        LinkedHashMap<String, BField> applicableTypeFields =\n+                applicableMappingType.tag == TypeTags.RECORD ? ((BRecordType) applicableMappingType).fields :\n+                        new LinkedHashMap<>();\n+\n+        for (RecordLiteralNode.RecordField field : recordLiteral.fields) {\n+            if (field.getKind() == NodeKind.RECORD_LITERAL_SPREAD_OP) {\n+                continue;\n+            }\n+\n+            String name;\n+            if (field.isKeyValueField()) {\n+                BLangRecordKeyValueField keyValueField = (BLangRecordKeyValueField) field;\n+\n+                if (!keyValueField.readonly) {\n+                    continue;\n+                }\n+\n+                BLangExpression keyExpr = keyValueField.key.expr;\n+                if (keyExpr.getKind() == NodeKind.SIMPLE_VARIABLE_REF) {\n+                    name = ((BLangSimpleVarRef) keyExpr).variableName.value;\n+                } else {\n+                    name = (String) ((BLangLiteral) keyExpr).value;\n+                }\n+            } else {\n+                BLangRecordVarNameField varNameField = (BLangRecordVarNameField) field;\n+\n+                if (!varNameField.readonly) {\n+                    continue;\n+                }\n+                name = varNameField.variableName.value;\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed729d2aa3f90d27522bb8d1f867a4ee61da6cd8"}, "originalPosition": 297}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTM0NzM0NA==", "bodyText": "Yeah, +1.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24484#discussion_r455347344", "createdAt": "2020-07-15T21:08:44Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -1481,51 +1497,193 @@ private boolean exprIncompatible(BType eType, BLangExpression expr) {\n         return checkExpr(exprToCheck, this.env, eType) == symTable.semanticError;\n     }\n \n-    private BType[] getExprListUniqueTypes(List<BLangExpression> exprs, SymbolEnv env) {\n-        LinkedHashSet<BType> typesSet = new LinkedHashSet<>(checkExprList(exprs, env));\n-        return typesSet.toArray(new BType[0]);\n+    private List<BType> checkExprList(List<BLangExpression> exprs, SymbolEnv env) {\n+        return checkExprList(exprs, env, symTable.noType);\n     }\n \n-    private List<BType> checkExprList(List<BLangExpression> exprs, SymbolEnv env) {\n+    private List<BType> checkExprList(List<BLangExpression> exprs, SymbolEnv env, BType expType) {\n         List<BType> types = new ArrayList<>();\n         SymbolEnv prevEnv = this.env;\n         BType preExpType = this.expType;\n         this.env = env;\n-        this.expType = symTable.noType;\n+        this.expType = expType;\n         for (BLangExpression e : exprs) {\n-            checkExpr(e, this.env);\n+            checkExpr(e, this.env, expType);\n             types.add(resultType);\n         }\n         this.env = prevEnv;\n         this.expType = preExpType;\n         return types;\n     }\n \n-    private BType getInferredTupleType(BLangListConstructorExpr listConstructor) {\n-        List<BType> memTypes = checkExprList(listConstructor.exprs, env);\n+    private BType getInferredTupleType(BLangListConstructorExpr listConstructor, BType expType) {\n+        List<BType> memTypes = checkExprList(listConstructor.exprs, env, expType);\n \n         for (BType memType : memTypes) {\n             if (memType == symTable.semanticError) {\n                 return symTable.semanticError;\n             }\n         }\n \n-        return new BTupleType(memTypes);\n+        BTupleType tupleType = new BTupleType(memTypes);\n+\n+        if (expType.tag != TypeTags.READONLY) {\n+            return tupleType;\n+        }\n+\n+        tupleType.flags |= Flags.READONLY;\n+        return tupleType;\n     }\n \n     public void visit(BLangRecordLiteral recordLiteral) {\n         int expTypeTag = expType.tag;\n \n-        if (expTypeTag == TypeTags.NONE) {\n-            expType = defineInferredRecordType(recordLiteral);\n+        if (expTypeTag == TypeTags.NONE || expTypeTag == TypeTags.READONLY) {\n+            expType = defineInferredRecordType(recordLiteral, expType);\n         } else if (expTypeTag == TypeTags.OBJECT) {\n-            dlog.error(recordLiteral.pos,\n-                       DiagnosticCode.INVALID_RECORD_LITERAL, expType);\n+            dlog.error(recordLiteral.pos, DiagnosticCode.INVALID_RECORD_LITERAL, expType);\n             resultType = symTable.semanticError;\n             return;\n         }\n \n-        resultType = checkMappingConstructorCompatibility(expType, recordLiteral);\n+        resultType = getEffectiveMappingType(recordLiteral,\n+                                             checkMappingConstructorCompatibility(expType, recordLiteral));\n+    }\n+\n+    private BType getEffectiveMappingType(BLangRecordLiteral recordLiteral, BType applicableMappingType) {\n+        if (applicableMappingType == symTable.semanticError ||\n+                (applicableMappingType.tag == TypeTags.RECORD && Symbols.isFlagOn(applicableMappingType.flags,\n+                                                                                  Flags.READONLY))) {\n+            return applicableMappingType;\n+        }\n+\n+        Map<String, RecordLiteralNode.RecordField> readOnlyFields = new LinkedHashMap<>();\n+        LinkedHashMap<String, BField> applicableTypeFields =\n+                applicableMappingType.tag == TypeTags.RECORD ? ((BRecordType) applicableMappingType).fields :\n+                        new LinkedHashMap<>();\n+\n+        for (RecordLiteralNode.RecordField field : recordLiteral.fields) {\n+            if (field.getKind() == NodeKind.RECORD_LITERAL_SPREAD_OP) {\n+                continue;\n+            }\n+\n+            String name;\n+            if (field.isKeyValueField()) {\n+                BLangRecordKeyValueField keyValueField = (BLangRecordKeyValueField) field;\n+\n+                if (!keyValueField.readonly) {\n+                    continue;\n+                }\n+\n+                BLangExpression keyExpr = keyValueField.key.expr;\n+                if (keyExpr.getKind() == NodeKind.SIMPLE_VARIABLE_REF) {\n+                    name = ((BLangSimpleVarRef) keyExpr).variableName.value;\n+                } else {\n+                    name = (String) ((BLangLiteral) keyExpr).value;\n+                }\n+            } else {\n+                BLangRecordVarNameField varNameField = (BLangRecordVarNameField) field;\n+\n+                if (!varNameField.readonly) {\n+                    continue;\n+                }\n+                name = varNameField.variableName.value;\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMyNDk5MA=="}, "originalCommit": {"oid": "ed729d2aa3f90d27522bb8d1f867a4ee61da6cd8"}, "originalPosition": 297}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0MDA0ODc1OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQyMDozNDoyNFrOGyO21g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQyMDozNDoyNFrOGyO21g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMyNTM5OA==", "bodyText": "Another example of what I mentioned above.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24484#discussion_r455325398", "createdAt": "2020-07-15T20:34:24Z", "author": {"login": "pubudu91"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -1481,51 +1497,193 @@ private boolean exprIncompatible(BType eType, BLangExpression expr) {\n         return checkExpr(exprToCheck, this.env, eType) == symTable.semanticError;\n     }\n \n-    private BType[] getExprListUniqueTypes(List<BLangExpression> exprs, SymbolEnv env) {\n-        LinkedHashSet<BType> typesSet = new LinkedHashSet<>(checkExprList(exprs, env));\n-        return typesSet.toArray(new BType[0]);\n+    private List<BType> checkExprList(List<BLangExpression> exprs, SymbolEnv env) {\n+        return checkExprList(exprs, env, symTable.noType);\n     }\n \n-    private List<BType> checkExprList(List<BLangExpression> exprs, SymbolEnv env) {\n+    private List<BType> checkExprList(List<BLangExpression> exprs, SymbolEnv env, BType expType) {\n         List<BType> types = new ArrayList<>();\n         SymbolEnv prevEnv = this.env;\n         BType preExpType = this.expType;\n         this.env = env;\n-        this.expType = symTable.noType;\n+        this.expType = expType;\n         for (BLangExpression e : exprs) {\n-            checkExpr(e, this.env);\n+            checkExpr(e, this.env, expType);\n             types.add(resultType);\n         }\n         this.env = prevEnv;\n         this.expType = preExpType;\n         return types;\n     }\n \n-    private BType getInferredTupleType(BLangListConstructorExpr listConstructor) {\n-        List<BType> memTypes = checkExprList(listConstructor.exprs, env);\n+    private BType getInferredTupleType(BLangListConstructorExpr listConstructor, BType expType) {\n+        List<BType> memTypes = checkExprList(listConstructor.exprs, env, expType);\n \n         for (BType memType : memTypes) {\n             if (memType == symTable.semanticError) {\n                 return symTable.semanticError;\n             }\n         }\n \n-        return new BTupleType(memTypes);\n+        BTupleType tupleType = new BTupleType(memTypes);\n+\n+        if (expType.tag != TypeTags.READONLY) {\n+            return tupleType;\n+        }\n+\n+        tupleType.flags |= Flags.READONLY;\n+        return tupleType;\n     }\n \n     public void visit(BLangRecordLiteral recordLiteral) {\n         int expTypeTag = expType.tag;\n \n-        if (expTypeTag == TypeTags.NONE) {\n-            expType = defineInferredRecordType(recordLiteral);\n+        if (expTypeTag == TypeTags.NONE || expTypeTag == TypeTags.READONLY) {\n+            expType = defineInferredRecordType(recordLiteral, expType);\n         } else if (expTypeTag == TypeTags.OBJECT) {\n-            dlog.error(recordLiteral.pos,\n-                       DiagnosticCode.INVALID_RECORD_LITERAL, expType);\n+            dlog.error(recordLiteral.pos, DiagnosticCode.INVALID_RECORD_LITERAL, expType);\n             resultType = symTable.semanticError;\n             return;\n         }\n \n-        resultType = checkMappingConstructorCompatibility(expType, recordLiteral);\n+        resultType = getEffectiveMappingType(recordLiteral,\n+                                             checkMappingConstructorCompatibility(expType, recordLiteral));\n+    }\n+\n+    private BType getEffectiveMappingType(BLangRecordLiteral recordLiteral, BType applicableMappingType) {\n+        if (applicableMappingType == symTable.semanticError ||\n+                (applicableMappingType.tag == TypeTags.RECORD && Symbols.isFlagOn(applicableMappingType.flags,\n+                                                                                  Flags.READONLY))) {\n+            return applicableMappingType;\n+        }\n+\n+        Map<String, RecordLiteralNode.RecordField> readOnlyFields = new LinkedHashMap<>();\n+        LinkedHashMap<String, BField> applicableTypeFields =\n+                applicableMappingType.tag == TypeTags.RECORD ? ((BRecordType) applicableMappingType).fields :\n+                        new LinkedHashMap<>();\n+\n+        for (RecordLiteralNode.RecordField field : recordLiteral.fields) {\n+            if (field.getKind() == NodeKind.RECORD_LITERAL_SPREAD_OP) {\n+                continue;\n+            }\n+\n+            String name;\n+            if (field.isKeyValueField()) {\n+                BLangRecordKeyValueField keyValueField = (BLangRecordKeyValueField) field;\n+\n+                if (!keyValueField.readonly) {\n+                    continue;\n+                }\n+\n+                BLangExpression keyExpr = keyValueField.key.expr;\n+                if (keyExpr.getKind() == NodeKind.SIMPLE_VARIABLE_REF) {\n+                    name = ((BLangSimpleVarRef) keyExpr).variableName.value;\n+                } else {\n+                    name = (String) ((BLangLiteral) keyExpr).value;\n+                }\n+            } else {\n+                BLangRecordVarNameField varNameField = (BLangRecordVarNameField) field;\n+\n+                if (!varNameField.readonly) {\n+                    continue;\n+                }\n+                name = varNameField.variableName.value;\n+            }\n+\n+            if (applicableTypeFields.containsKey(name) &&\n+                    Symbols.isFlagOn(applicableTypeFields.get(name).symbol.flags, Flags.READONLY)) {\n+                continue;\n+            }\n+\n+            readOnlyFields.put(name, field);\n+        }\n+\n+        if (readOnlyFields.isEmpty()) {\n+            return applicableMappingType;\n+        }\n+\n+        PackageID pkgID = env.enclPkg.symbol.pkgID;\n+        BRecordTypeSymbol recordSymbol = createRecordTypeSymbol(pkgID);\n+\n+        LinkedHashMap<String, BField> newFields = new LinkedHashMap<>();\n+\n+        for (Map.Entry<String, RecordLiteralNode.RecordField> readOnlyEntry : readOnlyFields.entrySet()) {\n+            RecordLiteralNode.RecordField field = readOnlyEntry.getValue();\n+\n+            String key = readOnlyEntry.getKey();\n+            Name fieldName = names.fromString(key);\n+\n+            BType readOnlyFieldType;\n+            if (field.isKeyValueField()) {\n+                readOnlyFieldType = ((BLangRecordKeyValueField) field).valueExpr.type;\n+            } else {\n+                // Has to be a varname field.\n+                readOnlyFieldType = ((BLangRecordVarNameField) field).type;\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed729d2aa3f90d27522bb8d1f867a4ee61da6cd8"}, "originalPosition": 328}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3297, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}