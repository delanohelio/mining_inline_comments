{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQyNjc0ODEx", "number": 27584, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQwNzoxMToyMlrOFQQk7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQwNzozNjoyMVrOFQRASw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUyNTkzMTMzOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/DocumentationParser.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQwNzoxMToyMlrOIWA82Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQwODo1Nzo0NlrOIWEWWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTk1NTE2MQ==", "bodyText": "Don't we give a warning for invalid backtick content with NO_KEY. Also combineAndCreateBacktickContentToken can be renamed to combineAndCreateInvalidBacktickContentToken", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/27584#discussion_r559955161", "createdAt": "2021-01-19T07:11:22Z", "author": {"login": "rdulmina"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/DocumentationParser.java", "diffHunk": "@@ -266,10 +378,81 @@ private STNode parseBacktickToken() {\n     }\n \n     /**\n-     * Parse back-tick content token.\n+     * Parse back-tick content.\n      *\n+     * @param referenceType Node that precedes the backtick block\n      * @return Parsed node\n      */\n+    private STNode parseBacktickContent(STNode referenceType) {\n+        ReferenceGenre referenceGenre = getReferenceGenre(referenceType);\n+        if (isValidBacktickContentSequence(referenceGenre)) {\n+            return parseBacktickContent();\n+        }\n+\n+        STNode contentToken = combineAndCreateBacktickContentToken();\n+        if (referenceGenre != ReferenceGenre.NO_KEY) {\n+            // Log warning for backtick block with a reference type, but content is invalid.\n+            contentToken = SyntaxErrors.addDiagnostic(contentToken,\n+                    DiagnosticWarningCode.WARNING_INVALID_DOCUMENTATION_IDENTIFIER, ((STToken) contentToken).text());\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "07f0c01f5c865704e7656d4403565261ec092167"}, "originalPosition": 156}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDAxMDg0Mw==", "bodyText": "We need to clarify it with the spec. There were several reference like above in repo atm. Create an issue for that. #27958\n+1 on changing the name. Will do once clarified.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/27584#discussion_r560010843", "createdAt": "2021-01-19T08:57:46Z", "author": {"login": "lochana-chathura"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/DocumentationParser.java", "diffHunk": "@@ -266,10 +378,81 @@ private STNode parseBacktickToken() {\n     }\n \n     /**\n-     * Parse back-tick content token.\n+     * Parse back-tick content.\n      *\n+     * @param referenceType Node that precedes the backtick block\n      * @return Parsed node\n      */\n+    private STNode parseBacktickContent(STNode referenceType) {\n+        ReferenceGenre referenceGenre = getReferenceGenre(referenceType);\n+        if (isValidBacktickContentSequence(referenceGenre)) {\n+            return parseBacktickContent();\n+        }\n+\n+        STNode contentToken = combineAndCreateBacktickContentToken();\n+        if (referenceGenre != ReferenceGenre.NO_KEY) {\n+            // Log warning for backtick block with a reference type, but content is invalid.\n+            contentToken = SyntaxErrors.addDiagnostic(contentToken,\n+                    DiagnosticWarningCode.WARNING_INVALID_DOCUMENTATION_IDENTIFIER, ((STToken) contentToken).text());\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTk1NTE2MQ=="}, "originalCommit": {"oid": "07f0c01f5c865704e7656d4403565261ec092167"}, "originalPosition": 156}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUyNTk0MDAxOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/AbstractLexer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQwNzoxNDo1OFrOIWBB6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQwOTowMDoyMlrOIWEdOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTk1NjQ1Nw==", "bodyText": "We can remove these new lines.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/27584#discussion_r559956457", "createdAt": "2021-01-19T07:14:58Z", "author": {"login": "rdulmina"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/AbstractLexer.java", "diffHunk": "@@ -134,4 +134,117 @@ protected STNode getLeadingTrivia() {\n         this.leadingTriviaList = new ArrayList<>(INITIAL_TRIVIA_CAPACITY);\n         return trivia;\n     }\n+\n+    /**\n+     * Check whether a given char is an identifier following char.\n+     * <p>\n+     * <code>IdentifierFollowingChar := IdentifierInitialChar | Digit</code>\n+     *\n+     * @param c character to check\n+     * @return <code>true</code>, if the character is an identifier following char. <code>false</code> otherwise.\n+     */\n+    protected static boolean isIdentifierFollowingChar(int c) {\n+        return isIdentifierInitialChar(c) || isDigit(c);\n+    }\n+\n+    /**\n+     * Check whether a given char is a digit.\n+     * <p>\n+     * <code>Digit := 0..9</code>\n+     *\n+     * @param c character to check\n+     * @return <code>true</code>, if the character represents a digit. <code>false</code> otherwise.\n+     */\n+    protected static boolean isDigit(int c) {\n+        return ('0' <= c && c <= '9');\n+    }\n+\n+    /**\n+     * Check whether a given char is a hexa digit.\n+     * <p>\n+     * <code>HexDigit := Digit | a .. f | A .. F</code>\n+     *\n+     * @param c character to check\n+     * @return <code>true</code>, if the character represents a hex digit. <code>false</code> otherwise.\n+     */\n+    protected static boolean isHexDigit(int c) {\n+        if ('a' <= c && c <= 'f') {\n+            return true;\n+        }\n+        if ('A' <= c && c <= 'F') {\n+            return true;\n+        }\n+        return isDigit(c);\n+    }\n+\n+    /**\n+     * Check whether a given char is an identifier start char.\n+     * <p>\n+     * <code>IdentifierInitialChar := A .. Z | a .. z | _ | UnicodeIdentifierChar</code>\n+     *\n+     * @param c character to check\n+     * @return <code>true</code>, if the character is an identifier start char. <code>false</code> otherwise.\n+     */\n+    protected static boolean isIdentifierInitialChar(int c) {\n+        if ('A' <= c && c <= 'Z') {\n+            return true;\n+        }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "07f0c01f5c865704e7656d4403565261ec092167"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDAxMjYwMA==", "bodyText": "I think leaving a newline after a block whenever appropriate is a good practice. Ref: #26717 (comment) also.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/27584#discussion_r560012600", "createdAt": "2021-01-19T09:00:22Z", "author": {"login": "lochana-chathura"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/AbstractLexer.java", "diffHunk": "@@ -134,4 +134,117 @@ protected STNode getLeadingTrivia() {\n         this.leadingTriviaList = new ArrayList<>(INITIAL_TRIVIA_CAPACITY);\n         return trivia;\n     }\n+\n+    /**\n+     * Check whether a given char is an identifier following char.\n+     * <p>\n+     * <code>IdentifierFollowingChar := IdentifierInitialChar | Digit</code>\n+     *\n+     * @param c character to check\n+     * @return <code>true</code>, if the character is an identifier following char. <code>false</code> otherwise.\n+     */\n+    protected static boolean isIdentifierFollowingChar(int c) {\n+        return isIdentifierInitialChar(c) || isDigit(c);\n+    }\n+\n+    /**\n+     * Check whether a given char is a digit.\n+     * <p>\n+     * <code>Digit := 0..9</code>\n+     *\n+     * @param c character to check\n+     * @return <code>true</code>, if the character represents a digit. <code>false</code> otherwise.\n+     */\n+    protected static boolean isDigit(int c) {\n+        return ('0' <= c && c <= '9');\n+    }\n+\n+    /**\n+     * Check whether a given char is a hexa digit.\n+     * <p>\n+     * <code>HexDigit := Digit | a .. f | A .. F</code>\n+     *\n+     * @param c character to check\n+     * @return <code>true</code>, if the character represents a hex digit. <code>false</code> otherwise.\n+     */\n+    protected static boolean isHexDigit(int c) {\n+        if ('a' <= c && c <= 'f') {\n+            return true;\n+        }\n+        if ('A' <= c && c <= 'F') {\n+            return true;\n+        }\n+        return isDigit(c);\n+    }\n+\n+    /**\n+     * Check whether a given char is an identifier start char.\n+     * <p>\n+     * <code>IdentifierInitialChar := A .. Z | a .. z | _ | UnicodeIdentifierChar</code>\n+     *\n+     * @param c character to check\n+     * @return <code>true</code>, if the character is an identifier start char. <code>false</code> otherwise.\n+     */\n+    protected static boolean isIdentifierInitialChar(int c) {\n+        if ('A' <= c && c <= 'Z') {\n+            return true;\n+        }\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTk1NjQ1Nw=="}, "originalCommit": {"oid": "07f0c01f5c865704e7656d4403565261ec092167"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUyNTk1MzE3OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/DocumentationLexer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQwNzoxOToxNlrOIWBJKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQwNzoxOToxNlrOIWBJKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTk1ODMxMw==", "bodyText": "Can remove the new line here as well", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/27584#discussion_r559958313", "createdAt": "2021-01-19T07:19:16Z", "author": {"login": "rdulmina"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/DocumentationLexer.java", "diffHunk": "@@ -117,56 +107,97 @@ private String getLexeme() {\n     }\n \n     /**\n-     * <p>\n-     * Check whether a given char is an identifier start char.\n-     * </p>\n-     * <code>IdentifierInitialChar := A .. Z | a .. z | _ | UnicodeIdentifierChar</code>\n-     *\n-     * @param c character to check\n-     * @return <code>true</code>, if the character is an identifier start char. <code>false</code> otherwise.\n+     * Check whether a given char is a possible identifier start.\n      */\n-    private boolean isIdentifierInitialChar(int c) {\n-        // TODO: pre-mark all possible characters, using a mask. And use that mask here to check\n-        if ('A' <= c && c <= 'Z') {\n-            return true;\n-        }\n-\n-        if ('a' <= c && c <= 'z') {\n-            return true;\n-        }\n-\n-        if (c == '_') {\n-            return true;\n+    private boolean isPossibleIdentifierStart(int startChar) {\n+        switch (startChar) {\n+            case LexerTerminals.SINGLE_QUOTE:\n+            case LexerTerminals.BACKSLASH:\n+                return true;\n+            default:\n+                return isIdentifierInitialChar(startChar);\n         }\n-\n-        // TODO: if (UnicodeIdentifierChar) return false;\n-        return false;\n     }\n \n     /**\n+     * Process identifier end.\n      * <p>\n-     * Check whether a given char is an identifier following char.\n-     * </p>\n-     * <code>IdentifierFollowingChar := IdentifierInitialChar | Digit</code>\n+     * <code>\n+     * IdentifierEnd := IdentifierChar*\n+     * <br/>\n+     * IdentifierChar := IdentifierFollowingChar | IdentifierEscape\n+     * <br/>\n+     * IdentifierEscape := IdentifierSingleEscape | NumericEscape\n+     * </code>\n      *\n-     * @param c character to check\n-     * @return <code>true</code>, if the character is an identifier following char. <code>false</code> otherwise.\n+     * @param initialEscape Denotes whether <code>\\</code> is at the beginning of the identifier\n      */\n-    private boolean isIdentifierFollowingChar(int c) {\n-        return isIdentifierInitialChar(c) || isDigit(c);\n+    private void processIdentifierEnd(boolean initialEscape) {\n+        while (!reader.isEOF()) {\n+            int k = 1;\n+            int nextChar = reader.peek();\n+            if (isIdentifierFollowingChar(nextChar)) {\n+                reader.advance();\n+                continue;\n+            }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "07f0c01f5c865704e7656d4403565261ec092167"}, "originalPosition": 105}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUyNjAwMTM5OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/DocumentationParser.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQwNzozNjoyMVrOIWBlNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQwOToxNDoyMVrOIWFAvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTk2NTQ5NA==", "bodyText": "If we can return false from the calling methods (ie hasQualifiedIdentifier and hasBacktickExpr) whenever peek(lookahead.offset).kind == SyntaxKind.BACKTIC_CONTENT then we can simplify this by removing the Lookahead class", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/27584#discussion_r559965494", "createdAt": "2021-01-19T07:36:21Z", "author": {"login": "rdulmina"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/DocumentationParser.java", "diffHunk": "@@ -157,13 +158,124 @@ private STNode parseDocumentationReference() {\n         }\n \n         STNode startBacktick = parseBacktickToken();\n-        STNode backtickContent = parseBacktickContent();\n+        STNode backtickContent = parseBacktickContent(referenceType);\n         STNode endBacktick = parseBacktickToken();\n-\n         return STNodeFactory.createDocumentationReferenceNode(referenceType, startBacktick, backtickContent,\n                 endBacktick);\n     }\n \n+    /**\n+     * Represents the current position with respect to the head in a token-sequence-search.\n+     */\n+    private static class Lookahead {\n+        private int offset = 1;\n+    }\n+\n+    /**\n+     * Genre of the reference that precedes the backtick block.\n+     */\n+    private enum ReferenceGenre {\n+        NO_KEY, SPECIAL_KEY, FUNCTION_KEY\n+    }\n+\n+    /**\n+     * Look ahead and see if upcoming token sequence is valid.\n+     *\n+     * @param refGenre Genre of the backtick block reference\n+     * @return <code>true</code> if content is valid<code>false</code> otherwise.\n+     */\n+    private boolean isValidBacktickContentSequence(ReferenceGenre refGenre) {\n+        boolean hasMatch;\n+        Lookahead lookahead = new Lookahead();\n+        switch (refGenre) {\n+            case SPECIAL_KEY:\n+                // Look for x, m:x match\n+                hasMatch = hasQualifiedIdentifier(lookahead);\n+                break;\n+            case FUNCTION_KEY:\n+                // Look for x, m:x, x(), m:x(), T.y(), m:T.y() match\n+                hasMatch = hasBacktickExpr(lookahead, true);\n+                break;\n+            case NO_KEY:\n+                // Look for x(), m:x(), T.y(), m:T.y() match\n+                hasMatch = hasBacktickExpr(lookahead, false);\n+                break;\n+            default:\n+                throw new IllegalStateException(\"Unsupported backtick reference genre\");\n+        }\n+\n+        return hasMatch && peek(lookahead.offset).kind == SyntaxKind.BACKTICK_TOKEN;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "07f0c01f5c865704e7656d4403565261ec092167"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDAyMTY5NA==", "bodyText": "As we discussed offline problem is, methods like hasIdentifier is called in other places as well. eg. hasQualifiedIdentifer, hasBacktickExpr.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/27584#discussion_r560021694", "createdAt": "2021-01-19T09:14:21Z", "author": {"login": "lochana-chathura"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/DocumentationParser.java", "diffHunk": "@@ -157,13 +158,124 @@ private STNode parseDocumentationReference() {\n         }\n \n         STNode startBacktick = parseBacktickToken();\n-        STNode backtickContent = parseBacktickContent();\n+        STNode backtickContent = parseBacktickContent(referenceType);\n         STNode endBacktick = parseBacktickToken();\n-\n         return STNodeFactory.createDocumentationReferenceNode(referenceType, startBacktick, backtickContent,\n                 endBacktick);\n     }\n \n+    /**\n+     * Represents the current position with respect to the head in a token-sequence-search.\n+     */\n+    private static class Lookahead {\n+        private int offset = 1;\n+    }\n+\n+    /**\n+     * Genre of the reference that precedes the backtick block.\n+     */\n+    private enum ReferenceGenre {\n+        NO_KEY, SPECIAL_KEY, FUNCTION_KEY\n+    }\n+\n+    /**\n+     * Look ahead and see if upcoming token sequence is valid.\n+     *\n+     * @param refGenre Genre of the backtick block reference\n+     * @return <code>true</code> if content is valid<code>false</code> otherwise.\n+     */\n+    private boolean isValidBacktickContentSequence(ReferenceGenre refGenre) {\n+        boolean hasMatch;\n+        Lookahead lookahead = new Lookahead();\n+        switch (refGenre) {\n+            case SPECIAL_KEY:\n+                // Look for x, m:x match\n+                hasMatch = hasQualifiedIdentifier(lookahead);\n+                break;\n+            case FUNCTION_KEY:\n+                // Look for x, m:x, x(), m:x(), T.y(), m:T.y() match\n+                hasMatch = hasBacktickExpr(lookahead, true);\n+                break;\n+            case NO_KEY:\n+                // Look for x(), m:x(), T.y(), m:T.y() match\n+                hasMatch = hasBacktickExpr(lookahead, false);\n+                break;\n+            default:\n+                throw new IllegalStateException(\"Unsupported backtick reference genre\");\n+        }\n+\n+        return hasMatch && peek(lookahead.offset).kind == SyntaxKind.BACKTICK_TOKEN;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTk2NTQ5NA=="}, "originalCommit": {"oid": "07f0c01f5c865704e7656d4403565261ec092167"}, "originalPosition": 60}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2778, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}