{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkzOTQzODMx", "number": 26130, "title": "Add annotation completion support", "bodyText": "Purpose\n\nWith this add the annotation completion support for the available attachment types.\n\nCheck List\n\n Read the Contributing Guide\n Updated Change Log\n Checked Tooling Support (#)\n Added necessary tests\n\n Unit Tests\n Spec Conformance Tests\n Integration Tests\n Ballerina By Example Tests\n\n\n Increased Test Coverage\n Added necessary documentation\n\n API documentation\n Module documentation in Module.md files\n Ballerina By Examples", "createdAt": "2020-09-28T07:26:34Z", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26130", "merged": true, "mergeCommit": {"oid": "3f5b3ae2beb339a48fee0103c2da963a8a4d2652"}, "closed": true, "closedAt": "2020-09-28T09:05:27Z", "author": {"login": "nadeeshaan"}, "timelineItems": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdNORNRgH2gAyNDkzOTQzODMxOjE2ZDY2M2RkMDA4MDVkZmM2YTZkOTdiNzNkNzU1MWE2MjE0MzA1YTM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdNPZNrAFqTQ5NzI4OTUzNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "16d663dd00805dfc6a6d97b73d7551a6214305a3", "author": {"user": {"login": "nadeeshaan", "name": "Nadeeshaan Gunasinghe"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/16d663dd00805dfc6a6d97b73d7551a6214305a3", "committedDate": "2020-09-28T07:15:43Z", "message": "add annotation completion support"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "27c761f3fd41abf876d5e23e0dde47ecac8e117c", "author": {"user": {"login": "nadeeshaan", "name": "Nadeeshaan Gunasinghe"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/27c761f3fd41abf876d5e23e0dde47ecac8e117c", "committedDate": "2020-09-28T07:31:08Z", "message": "add java doc for public API"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3Mjg5NTM2", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26130#pullrequestreview-497289536", "createdAt": "2020-09-28T08:25:13Z", "commit": {"oid": "27c761f3fd41abf876d5e23e0dde47ecac8e117c"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwODoyNToxM1rOHYzW6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwODozNDowMlrOHYzqpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc2OTMyMw==", "bodyText": "Shall we rename this into a more meaningful name like annotations or filteredAnnotations", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26130#discussion_r495769323", "createdAt": "2020-09-28T08:25:13Z", "author": {"login": "rasika"}, "path": "language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/completions/providers/context/AnnotationNodeContext.java", "diffHunk": "@@ -71,53 +71,112 @@ public AnnotationNodeContext() {\n             }\n         }\n \n-        Node annotRef = node.annotReference();\n-        String finalAlias = annotRef.kind() != SyntaxKind.QUALIFIED_NAME_REFERENCE ? null\n-                : ((QualifiedNameReferenceNode) annotRef).modulePrefix().text();\n         Map<String, String> pkgAliasMap = context.get(DocumentServiceKeys.CURRENT_DOC_IMPORTS_KEY).stream()\n                 .filter(pkg -> pkg.symbol != null)\n                 .collect(Collectors.toMap(pkg -> pkg.symbol.pkgID.toString(), pkg -> pkg.alias.value));\n \n+        if (this.onQualifiedNameIdentifier(context, node.annotReference())) {\n+            QualifiedNameReferenceNode qNameRef = (QualifiedNameReferenceNode) node.annotReference();\n+            return this.getAnnotationsInModule(context, qNameRef.modulePrefix().text(), attachedNode, pkgAliasMap);\n+        }\n+\n         LSAnnotationCache.getInstance().getAnnotationMapForType(attachedNode, context)\n                 .forEach((key, value) -> value.forEach(annotation -> {\n-                    String annotationPkgAlias = annotation.pkgID.nameComps\n-                            .get(annotation.pkgID.nameComps.size() - 1).value;\n-                    String annotationPkg = annotation.pkgID.toString();\n-                    // compare with the import statements' package alias\n-                    if (finalAlias == null || finalAlias.equals(annotationPkgAlias)\n-                            || finalAlias.equals(pkgAliasMap.get(annotationPkg))) {\n-                        completionItems.add(CommonUtil.getAnnotationCompletionItem(key, annotation, context, finalAlias,\n-                                pkgAliasMap));\n-                    }\n+                    boolean withAlias = this.withAlias(context, node, annotation.pkgID);\n+                    completionItems.add(CommonUtil.getAnnotationCompletionItem(key, annotation, context, withAlias,\n+                            pkgAliasMap));\n                 }));\n-        completionItems.addAll(this.getAnnotationsInModule(context, attachedNode, pkgAliasMap));\n+        completionItems.addAll(this.getCurrentModuleAnnotations(context, attachedNode, pkgAliasMap));\n         return completionItems;\n     }\n \n-    private List<LSCompletionItem> getAnnotationsInModule(LSContext ctx, SyntaxKind kind,\n-                                                          Map<String, String> pkgAliasMap) {\n+    private boolean withAlias(LSContext context, AnnotationNode node, PackageID annotationOwner) {\n+        PackageID currentModule = context.get(DocumentServiceKeys.CURRENT_PACKAGE_ID_KEY);\n+        String orgName = annotationOwner.orgName.getValue();\n+        String value = annotationOwner.getName().getValue();\n+        return node.annotReference().kind() != SyntaxKind.QUALIFIED_NAME_REFERENCE\n+                && !currentModule.name.value.equals(annotationOwner.name.value) && !(\"ballerina\".equals(orgName)\n+                && \"lang.annotations\".equals(value));\n+    }\n+\n+    private List<LSCompletionItem> getCurrentModuleAnnotations(LSContext ctx, SyntaxKind kind,\n+                                                               Map<String, String> pkgAliasMap) {\n         BLangPackage bLangPackage = ctx.get(DocumentServiceKeys.CURRENT_BLANG_PACKAGE_CONTEXT_KEY);\n-        List<LSCompletionItem> completionItems = new ArrayList<>();\n-        List<BLangAnnotation> annotations = bLangPackage.topLevelNodes.stream()\n+        List<BAnnotationSymbol> annotations = bLangPackage.topLevelNodes.stream()\n                 .filter(topLevelNode -> topLevelNode instanceof BLangAnnotation)\n-                .map(topLevelNode -> (BLangAnnotation) topLevelNode)\n+                .map(topLevelNode -> (BAnnotationSymbol) ((BLangAnnotation) topLevelNode).symbol)\n+                .collect(Collectors.toList());\n+\n+        return this.getAnnotationCompletionsForSymbols(ctx, annotations, kind, pkgAliasMap);\n+    }\n+\n+    private List<LSCompletionItem> getAnnotationsInModule(LSContext context, String alias, SyntaxKind kind,\n+                                                          Map<String, String> pkgAliasMap) {\n+        Optional<Scope.ScopeEntry> moduleEntry = CommonUtil.packageSymbolFromAlias(context, alias);\n+        if (!moduleEntry.isPresent()) {\n+            List<LSCompletionItem> completionItems = new ArrayList<>();\n+            // Import statement has not been added. Hence try resolving from the annotation cache\n+            LSAnnotationCache.getInstance().getAnnotationsInModule(context, alias, kind)\n+                    .forEach((key, value) -> value.forEach(annotation -> {\n+                        completionItems.add(CommonUtil.getAnnotationCompletionItem(key, annotation, context, false,\n+                                pkgAliasMap));\n+                    }));\n+\n+            return completionItems;\n+        }\n+\n+        List<BAnnotationSymbol> collect = moduleEntry.get().symbol.scope.entries.values().stream()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27c761f3fd41abf876d5e23e0dde47ecac8e117c"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc3NDM3Mg==", "bodyText": "Can we move node.parent().kind() into local variable and Line 140-144 can be simplified into a ternary return statement.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26130#discussion_r495774372", "createdAt": "2020-09-28T08:34:02Z", "author": {"login": "rasika"}, "path": "language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/completions/providers/context/AnnotationNodeContext.java", "diffHunk": "@@ -71,53 +71,112 @@ public AnnotationNodeContext() {\n             }\n         }\n \n-        Node annotRef = node.annotReference();\n-        String finalAlias = annotRef.kind() != SyntaxKind.QUALIFIED_NAME_REFERENCE ? null\n-                : ((QualifiedNameReferenceNode) annotRef).modulePrefix().text();\n         Map<String, String> pkgAliasMap = context.get(DocumentServiceKeys.CURRENT_DOC_IMPORTS_KEY).stream()\n                 .filter(pkg -> pkg.symbol != null)\n                 .collect(Collectors.toMap(pkg -> pkg.symbol.pkgID.toString(), pkg -> pkg.alias.value));\n \n+        if (this.onQualifiedNameIdentifier(context, node.annotReference())) {\n+            QualifiedNameReferenceNode qNameRef = (QualifiedNameReferenceNode) node.annotReference();\n+            return this.getAnnotationsInModule(context, qNameRef.modulePrefix().text(), attachedNode, pkgAliasMap);\n+        }\n+\n         LSAnnotationCache.getInstance().getAnnotationMapForType(attachedNode, context)\n                 .forEach((key, value) -> value.forEach(annotation -> {\n-                    String annotationPkgAlias = annotation.pkgID.nameComps\n-                            .get(annotation.pkgID.nameComps.size() - 1).value;\n-                    String annotationPkg = annotation.pkgID.toString();\n-                    // compare with the import statements' package alias\n-                    if (finalAlias == null || finalAlias.equals(annotationPkgAlias)\n-                            || finalAlias.equals(pkgAliasMap.get(annotationPkg))) {\n-                        completionItems.add(CommonUtil.getAnnotationCompletionItem(key, annotation, context, finalAlias,\n-                                pkgAliasMap));\n-                    }\n+                    boolean withAlias = this.withAlias(context, node, annotation.pkgID);\n+                    completionItems.add(CommonUtil.getAnnotationCompletionItem(key, annotation, context, withAlias,\n+                            pkgAliasMap));\n                 }));\n-        completionItems.addAll(this.getAnnotationsInModule(context, attachedNode, pkgAliasMap));\n+        completionItems.addAll(this.getCurrentModuleAnnotations(context, attachedNode, pkgAliasMap));\n         return completionItems;\n     }\n \n-    private List<LSCompletionItem> getAnnotationsInModule(LSContext ctx, SyntaxKind kind,\n-                                                          Map<String, String> pkgAliasMap) {\n+    private boolean withAlias(LSContext context, AnnotationNode node, PackageID annotationOwner) {\n+        PackageID currentModule = context.get(DocumentServiceKeys.CURRENT_PACKAGE_ID_KEY);\n+        String orgName = annotationOwner.orgName.getValue();\n+        String value = annotationOwner.getName().getValue();\n+        return node.annotReference().kind() != SyntaxKind.QUALIFIED_NAME_REFERENCE\n+                && !currentModule.name.value.equals(annotationOwner.name.value) && !(\"ballerina\".equals(orgName)\n+                && \"lang.annotations\".equals(value));\n+    }\n+\n+    private List<LSCompletionItem> getCurrentModuleAnnotations(LSContext ctx, SyntaxKind kind,\n+                                                               Map<String, String> pkgAliasMap) {\n         BLangPackage bLangPackage = ctx.get(DocumentServiceKeys.CURRENT_BLANG_PACKAGE_CONTEXT_KEY);\n-        List<LSCompletionItem> completionItems = new ArrayList<>();\n-        List<BLangAnnotation> annotations = bLangPackage.topLevelNodes.stream()\n+        List<BAnnotationSymbol> annotations = bLangPackage.topLevelNodes.stream()\n                 .filter(topLevelNode -> topLevelNode instanceof BLangAnnotation)\n-                .map(topLevelNode -> (BLangAnnotation) topLevelNode)\n+                .map(topLevelNode -> (BAnnotationSymbol) ((BLangAnnotation) topLevelNode).symbol)\n+                .collect(Collectors.toList());\n+\n+        return this.getAnnotationCompletionsForSymbols(ctx, annotations, kind, pkgAliasMap);\n+    }\n+\n+    private List<LSCompletionItem> getAnnotationsInModule(LSContext context, String alias, SyntaxKind kind,\n+                                                          Map<String, String> pkgAliasMap) {\n+        Optional<Scope.ScopeEntry> moduleEntry = CommonUtil.packageSymbolFromAlias(context, alias);\n+        if (!moduleEntry.isPresent()) {\n+            List<LSCompletionItem> completionItems = new ArrayList<>();\n+            // Import statement has not been added. Hence try resolving from the annotation cache\n+            LSAnnotationCache.getInstance().getAnnotationsInModule(context, alias, kind)\n+                    .forEach((key, value) -> value.forEach(annotation -> {\n+                        completionItems.add(CommonUtil.getAnnotationCompletionItem(key, annotation, context, false,\n+                                pkgAliasMap));\n+                    }));\n+\n+            return completionItems;\n+        }\n+\n+        List<BAnnotationSymbol> collect = moduleEntry.get().symbol.scope.entries.values().stream()\n+                .filter(entry -> {\n+                    BSymbol symbol = entry.symbol;\n+                    return symbol instanceof BAnnotationSymbol && ((symbol.flags & Flags.PUBLIC) == Flags.PUBLIC);\n+                })\n+                .map(scopeEntry -> (BAnnotationSymbol) scopeEntry.symbol)\n                 .collect(Collectors.toList());\n-        BLangNode scopeNode = ctx.get(CompletionKeys.SCOPE_NODE_KEY);\n \n-        annotations.forEach(bLangAnnotation -> {\n-            BAnnotationSymbol symbol = (BAnnotationSymbol) bLangAnnotation.symbol;\n+        return this.getAnnotationCompletionsForSymbols(context, collect, kind, pkgAliasMap);\n+    }\n+\n+    private SyntaxKind getParentSyntaxKind(AnnotationNode node) {\n+        if (node.parent().kind() == SyntaxKind.METADATA) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27c761f3fd41abf876d5e23e0dde47ecac8e117c"}, "originalPosition": 136}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4463, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}