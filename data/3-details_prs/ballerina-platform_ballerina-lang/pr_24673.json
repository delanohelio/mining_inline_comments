{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ2Njk3NjI1", "number": 24673, "title": "Add query clause for sorting", "bodyText": "Purpose\n\nAdd order by clause support for query expression to carry out sorting\n\nFixes #24423\nApproach\n\nDescribe how you are implementing the solutions along with the design details.\n\nSamples\nStudent[] studentList =\n       from var person in personList \n       order by pid descending, firstname ascending\n       select {\n           pid: person.id,\n           firstname : person.fname,\n           addressList : person.addrList\n       };\n       \n\nRemarks\n\nKnown issue #24751\n\nCheck List\n\n Read the Contributing Guide\n Updated Change Log\n Checked Tooling Support (#)\n Added necessary tests\n\n Unit Tests\n Spec Conformance Tests\n Integration Tests\n Ballerina By Example Tests\n\n\n Increased Test Coverage\n Added necessary documentation\n\n API documentation\n Module documentation in Module.md files\n Ballerina By Examples", "createdAt": "2020-07-09T08:18:01Z", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673", "merged": true, "mergeCommit": {"oid": "eb4b2de68c9c5dd4097da59598784ad42f21d1b6"}, "closed": true, "closedAt": "2020-07-24T07:34:38Z", "author": {"login": "lasinicl"}, "timelineItems": {"totalCount": 70, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcs9n1SAH2gAyNDQ2Njk3NjI1OmVkOWFlM2RhZjYxN2UyZjIwN2I0NTE2ZDEyZmE5YTM1YTVkODFiMTA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdm_dLlgFqTU1NDM4MzE0Mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "ed9ae3daf617e2f207b4516d12fa9a35a5d81b10", "author": {"user": {"login": "lasinicl", "name": "Lasini Liyange"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/ed9ae3daf617e2f207b4516d12fa9a35a5d81b10", "committedDate": "2020-06-20T01:46:28Z", "message": "Merge pull request #9 from ballerina-platform/master\n\nUpdate master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f5db9af15c0d8a08e6b1a563d53cafe49217928e", "author": {"user": {"login": "lasinicl", "name": "Lasini Liyange"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f5db9af15c0d8a08e6b1a563d53cafe49217928e", "committedDate": "2020-06-21T06:36:39Z", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "de9d450841b360886f97a4be97f72287024c2d87", "author": {"user": {"login": "lasinicl", "name": "Lasini Liyange"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/de9d450841b360886f97a4be97f72287024c2d87", "committedDate": "2020-07-07T13:20:57Z", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into fix-24423-orderby"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "592e87b837b5ed76d3026a4674966c5f6e87c3fe", "author": {"user": {"login": "lasinicl", "name": "Lasini Liyange"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/592e87b837b5ed76d3026a4674966c5f6e87c3fe", "committedDate": "2020-07-07T14:52:18Z", "message": "Add grammar for order by clause"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "86dd0252363c9fc3117fb3f2c7472d1982f7bbd5", "author": {"user": {"login": "lasinicl", "name": "Lasini Liyange"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/86dd0252363c9fc3117fb3f2c7472d1982f7bbd5", "committedDate": "2020-07-07T14:53:38Z", "message": "Add nodes and visitors for order by clause"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d8b8cb38c7a160e6d137cab0d58cdb90f5bfc1a2", "author": {"user": {"login": "lasinicl", "name": "Lasini Liyange"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/d8b8cb38c7a160e6d137cab0d58cdb90f5bfc1a2", "committedDate": "2020-07-07T14:55:00Z", "message": "Add visitor for order by clause"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "933fcc16e611c7ee30c14a48f16aa82ba0ad4289", "author": {"user": {"login": "lasinicl", "name": "Lasini Liyange"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/933fcc16e611c7ee30c14a48f16aa82ba0ad4289", "committedDate": "2020-07-07T14:55:35Z", "message": "Add nodes and impl for order by clause"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0a18c440095eaefa82bcbf2520b6853afd67d410", "author": {"user": {"login": "lasinicl", "name": "Lasini Liyange"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/0a18c440095eaefa82bcbf2520b6853afd67d410", "committedDate": "2020-07-07T14:55:57Z", "message": "Add desugar for order by clause"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e0adce54d6f7ccd2a2dcf068e4db97c1024a9e2b", "author": {"user": {"login": "lasinicl", "name": "Lasini Liyange"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e0adce54d6f7ccd2a2dcf068e4db97c1024a9e2b", "committedDate": "2020-07-07T15:01:06Z", "message": "Update comment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1ada6591b3ba786540c118237d87fce5ac951411", "author": {"user": {"login": "lasinicl", "name": "Lasini Liyange"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1ada6591b3ba786540c118237d87fce5ac951411", "committedDate": "2020-07-08T11:07:42Z", "message": "Update sorting function"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "41d90d5a75e5cb64feea1d17b9821a0d793880a6", "author": {"user": {"login": "lasinicl", "name": "Lasini Liyange"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/41d90d5a75e5cb64feea1d17b9821a0d793880a6", "committedDate": "2020-07-08T11:08:05Z", "message": "Add simple test for order by"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3eb20c518fb9727f3330b1003c4f730641e8fa1b", "author": {"user": {"login": "lasinicl", "name": "Lasini Liyange"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3eb20c518fb9727f3330b1003c4f730641e8fa1b", "committedDate": "2020-07-08T11:25:58Z", "message": "Update query desugar"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a2642d86e59ce1fa653fcce0ca9dced5ee5c833e", "author": {"user": {"login": "lasinicl", "name": "Lasini Liyange"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a2642d86e59ce1fa653fcce0ca9dced5ee5c833e", "committedDate": "2020-07-09T08:10:02Z", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into fix-24423-orderby\n\n\u0001 Conflicts:\n\u0001\tlanglib/lang.query/src/main/ballerina/src/lang.query/helpers.bal"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d5b6c2427c9dedeebd3804d519e18c9e1412ea77", "author": {"user": {"login": "lasinicl", "name": "Lasini Liyange"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/d5b6c2427c9dedeebd3804d519e18c9e1412ea77", "committedDate": "2020-07-09T08:10:43Z", "message": "Resolve conflict in helpers"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "29790e190eb133ed4cd0d31dcc877227ff977909", "author": {"user": {"login": "lasinicl", "name": "Lasini Liyange"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/29790e190eb133ed4cd0d31dcc877227ff977909", "committedDate": "2020-07-10T03:25:20Z", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into fix-24423-orderby"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "927a9a13528063e3fa99f052a6f1096270c07805", "author": {"user": {"login": "lasinicl", "name": "Lasini Liyange"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/927a9a13528063e3fa99f052a6f1096270c07805", "committedDate": "2020-07-10T09:29:53Z", "message": "Add new parser support for order by clause"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "073acb1dc07286f3a4c755ba05de3b0d737abf8a", "author": {"user": {"login": "lasinicl", "name": "Lasini Liyange"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/073acb1dc07286f3a4c755ba05de3b0d737abf8a", "committedDate": "2020-07-10T09:30:43Z", "message": "Fix check style issues"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ab307c7282c542e757f6e575a0900cc5f1537d9b", "author": {"user": {"login": "lasinicl", "name": "Lasini Liyange"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/ab307c7282c542e757f6e575a0900cc5f1537d9b", "committedDate": "2020-07-10T09:32:55Z", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into fix-24423-orderby\n\n\u0001 Conflicts:\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/syntax/tree/SyntaxKind.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "528efe74f2aee8f3a188ffd80de6db149db5fb1f", "author": {"user": {"login": "lasinicl", "name": "Lasini Liyange"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/528efe74f2aee8f3a188ffd80de6db149db5fb1f", "committedDate": "2020-07-10T09:34:17Z", "message": "Resolve conflict in SyntaxKind"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6b96fd0577f922d53d7578a1b459f68e09088105", "author": {"user": {"login": "lasinicl", "name": "Lasini Liyange"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6b96fd0577f922d53d7578a1b459f68e09088105", "committedDate": "2020-07-10T13:32:32Z", "message": "Resolve conflict in SyntaxKind\nAdd tests for order by clause"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "910da4603836b04b2364b6a555ca9d5b57475010", "author": {"user": {"login": "lasinicl", "name": "Lasini Liyange"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/910da4603836b04b2364b6a555ca9d5b57475010", "committedDate": "2020-07-14T05:07:00Z", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into fix-24423-orderby"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bb7eb8beaeed76f3bdee4b650c969c48b1ef443a", "author": {"user": {"login": "lasinicl", "name": "Lasini Liyange"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/bb7eb8beaeed76f3bdee4b650c969c48b1ef443a", "committedDate": "2020-07-14T07:38:15Z", "message": "Fix issue in handling result type in order by"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b33d4fa130b33cdab76ee7b590e00e4f17e610f3", "author": {"user": {"login": "lasinicl", "name": "Lasini Liyange"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b33d4fa130b33cdab76ee7b590e00e4f17e610f3", "committedDate": "2020-07-14T07:38:42Z", "message": "Add tests for order by clause"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "08cac2a6e67748a119d13d19479797079e1c3f7c", "author": {"user": {"login": "lasinicl", "name": "Lasini Liyange"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/08cac2a6e67748a119d13d19479797079e1c3f7c", "committedDate": "2020-07-14T07:39:12Z", "message": "Fix lang-server tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8c9fff25717b6559afccd361e0b2da7bc529ab1b", "author": {"user": {"login": "lasinicl", "name": "Lasini Liyange"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/8c9fff25717b6559afccd361e0b2da7bc529ab1b", "committedDate": "2020-07-14T08:52:05Z", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into fix-24423-orderby\n\n\u0001 Conflicts:\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/tree/STNodeFactory.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/tree/STTreeModifier.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/syntax/tree/NodeFactory.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/syntax/tree/SyntaxKind.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/syntax/tree/TreeModifier.java\n\u0001\tcompiler/ballerina-treegen/src/main/resources/syntax_tree_descriptor.json"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "67b76dbfd43f7751b34cd610dc0382d8c1f00222", "author": {"user": {"login": "lasinicl", "name": "Lasini Liyange"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/67b76dbfd43f7751b34cd610dc0382d8c1f00222", "committedDate": "2020-07-16T06:48:10Z", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into fix-24423-orderby"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f5d138b601a40c7bf2c13557c352246565d23b26", "author": {"user": {"login": "lasinicl", "name": "Lasini Liyange"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f5d138b601a40c7bf2c13557c352246565d23b26", "committedDate": "2020-07-16T07:01:27Z", "message": "Add suggested changes to order by impl"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "51c98ac3dd40db0337e5598d365ee10a4af7215a", "author": {"user": {"login": "lasinicl", "name": "Lasini Liyange"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/51c98ac3dd40db0337e5598d365ee10a4af7215a", "committedDate": "2020-07-16T07:17:10Z", "message": "Fix checkstyle"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ5NzI1NjEx", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#pullrequestreview-449725611", "createdAt": "2020-07-16T10:36:18Z", "commit": {"oid": "51c98ac3dd40db0337e5598d365ee10a4af7215a"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxMDozNjoxOFrOGylKRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxMDo1Mjo0NlrOGylrhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTY5MDgyMA==", "bodyText": "remove new line", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r455690820", "createdAt": "2020-07-16T10:36:18Z", "author": {"login": "pcnfernando"}, "path": "compiler/ballerina-lang/src/main/java/org/ballerinalang/model/TreeBuilder.java", "diffHunk": "@@ -772,6 +776,15 @@ public static OnClauseNode createOnClauseNode() {\n         return new BLangOnClause();\n     }\n \n+    public static OrderKeyNode createOrderKeyNode() {\n+        return new BLangOrderKey();\n+    }\n+\n+    public static OrderByClauseNode createOrderByClauseNode() {\n+        return new BLangOrderByClause();\n+    }\n+\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "51c98ac3dd40db0337e5598d365ee10a4af7215a"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTY5MjA4Ng==", "bodyText": "it should be since swan lake. Check other places as well for classes you introduced", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r455692086", "createdAt": "2020-07-16T10:38:46Z", "author": {"login": "pcnfernando"}, "path": "compiler/ballerina-lang/src/main/java/org/ballerinalang/model/clauses/OrderByClauseNode.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+\n+package org.ballerinalang.model.clauses;\n+\n+import org.ballerinalang.model.tree.Node;\n+\n+import java.util.List;\n+\n+/**\n+ * The interface with the APIs to implement the \"order by\" clause.\n+ *\n+ * @since 2.0.0", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "51c98ac3dd40db0337e5598d365ee10a4af7215a"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTY5MjYyMg==", "bodyText": "Try to group this with query errors", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r455692622", "createdAt": "2020-07-16T10:39:45Z", "author": {"login": "pcnfernando"}, "path": "compiler/ballerina-lang/src/main/java/org/ballerinalang/util/diagnostic/DiagnosticCode.java", "diffHunk": "@@ -431,6 +431,8 @@\n     ERROR_TYPE_EXPECTED(\"error.type.expected\"),\n     MISSING_REQUIRED_METHOD_NEXT(\"missing.required.method.next\"),\n \n+    ORDER_BY_NOT_SUPPORTED(\"order.by.not.supported\"),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "51c98ac3dd40db0337e5598d365ee10a4af7215a"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTY5NTc2MQ==", "bodyText": "why are we filtering again? can't we have just the \"t\"? When can orElse be executed?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r455695761", "createdAt": "2020-07-16T10:45:49Z", "author": {"login": "pcnfernando"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/QueryDesugar.java", "diffHunk": "@@ -298,6 +310,54 @@ BLangStatementExpression desugar(BLangQueryAction queryAction, SymbolEnv env) {\n         return stmtExpr;\n     }\n \n+    /**\n+     * Get result type of the query output.\n+     *\n+     * @param type type of query expression.\n+     * @return result type.\n+     */\n+    private BType resolveExprType(BType type) {\n+        if (type.tag == TypeTags.STREAM) {\n+            return ((BStreamType) type).constraint;\n+        } else if (type.tag == TypeTags.TABLE) {\n+            return ((BTableType) type).constraint;\n+        } else if (type.tag == TypeTags.ARRAY) {\n+            return ((BArrayType) type).eType;\n+        } else if (type.tag == TypeTags.UNION) {\n+            List<BType> exprTypes = new ArrayList<>(((BUnionType) type).getMemberTypes());\n+            for (BType t : exprTypes) {\n+                BType returnType;\n+                if (t.tag == TypeTags.STREAM) {\n+                    returnType = ((BUnionType) type).getMemberTypes()\n+                            .stream().filter(m -> m.tag == TypeTags.STREAM)\n+                            .findFirst().orElse(symTable.streamType);\n+                    return ((BStreamType) returnType).constraint;\n+                } else if (t.tag == TypeTags.TABLE) {\n+                    returnType = ((BUnionType) type).getMemberTypes()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "51c98ac3dd40db0337e5598d365ee10a4af7215a"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTY5NjIwMw==", "bodyText": "Add class comment", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r455696203", "createdAt": "2020-07-16T10:46:43Z", "author": {"login": "pcnfernando"}, "path": "compiler/ballerina-lang/src/main/java/org/ballerinalang/model/clauses/OrderKeyNode.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+\n+package org.ballerinalang.model.clauses;\n+\n+import org.ballerinalang.model.tree.Node;\n+import org.ballerinalang.model.tree.expressions.ExpressionNode;\n+\n+/**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "51c98ac3dd40db0337e5598d365ee10a4af7215a"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTY5ODA3NQ==", "bodyText": "Try to add the ballerina statements you are introducing as comments during desugaring", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r455698075", "createdAt": "2020-07-16T10:50:24Z", "author": {"login": "pcnfernando"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/QueryDesugar.java", "diffHunk": "@@ -241,6 +247,12 @@ BLangStatementExpression desugar(BLangQueryExpr queryExpr, SymbolEnv env) {\n         BLangBlockStmt queryBlock = ASTBuilderUtil.createBlockStmt(pos);\n         BLangVariableReference streamRef = buildStream(clauses, queryExpr.type, env, queryBlock);\n         BLangStatementExpression streamStmtExpr;\n+        if (orderByClause != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "51c98ac3dd40db0337e5598d365ee10a4af7215a"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTY5OTMzMw==", "bodyText": "you can simplify this if", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r455699333", "createdAt": "2020-07-16T10:52:46Z", "author": {"login": "pcnfernando"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/parser/BLangNodeTransformer.java", "diffHunk": "@@ -3274,6 +3278,30 @@ public BLangNode transform(JoinClauseNode joinClauseNode) {\n         return joinClause;\n     }\n \n+    @Override\n+    public BLangNode transform(OrderByClauseNode orderByClauseNode) {\n+        BLangOrderByClause orderByClause = (BLangOrderByClause) TreeBuilder.createOrderByClauseNode();\n+        orderByClause.pos = getPosition(orderByClauseNode);\n+        for (OrderKeyNode orderKeyNode : orderByClauseNode.orderKey()) {\n+            orderByClause.addOrderKey(createOrderKey(orderKeyNode));\n+        }\n+        return orderByClause;\n+    }\n+\n+    public BLangOrderKey createOrderKey(OrderKeyNode orderKeyNode) {\n+        BLangOrderKey orderKey = (BLangOrderKey) TreeBuilder.createOrderKeyNode();\n+        orderKey.pos = getPosition(orderKeyNode);\n+        orderKey.expression = createExpression(orderKeyNode.expression());\n+        if (orderKeyNode.ascendingKeyword().isPresent()) {\n+            orderKey.isAscending = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "51c98ac3dd40db0337e5598d365ee10a4af7215a"}, "originalPosition": 37}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9ea4f5674df6ebfa2d19e6c864c4ff0771a5ed34", "author": {"user": {"login": "lasinicl", "name": "Lasini Liyange"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/9ea4f5674df6ebfa2d19e6c864c4ff0771a5ed34", "committedDate": "2020-07-16T11:47:49Z", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into fix-24423-orderby\n\n\u0001 Conflicts:\n\u0001\tcompiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/parser/antlr4/BallerinaLexer.java\n\u0001\tcompiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/parser/antlr4/BallerinaLexer.tokens\n\u0001\tcompiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/parser/antlr4/BallerinaParser.java\n\u0001\tcompiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/parser/antlr4/BallerinaParser.tokens\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/ParserRuleContext.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b116dd3f3e2be4acb36edb8ca19da102d5507ba5", "author": {"user": {"login": "lasinicl", "name": "Lasini Liyange"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b116dd3f3e2be4acb36edb8ca19da102d5507ba5", "committedDate": "2020-07-16T12:31:25Z", "message": "Add suggested changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "577fc0045e224a0d25c53aeccbed4149ee017bf7", "author": {"user": {"login": "lasinicl", "name": "Lasini Liyange"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/577fc0045e224a0d25c53aeccbed4149ee017bf7", "committedDate": "2020-07-17T02:50:19Z", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into fix-24423-orderby\n\n\u0001 Conflicts:\n\u0001\tlanguage-server/modules/langserver-core/src/test/resources/completion/function/iterableOperation1.json\n\u0001\tlanguage-server/modules/langserver-core/src/test/resources/completion/function/iterableOperation2.json\n\u0001\tlanguage-server/modules/langserver-core/src/test/resources/completion/function/variableBoundItemSuggestions2.json"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "57bf9f2e7d952ed4dd19cd54153df9ffb585a629", "author": {"user": {"login": "lasinicl", "name": "Lasini Liyange"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/57bf9f2e7d952ed4dd19cd54153df9ffb585a629", "committedDate": "2020-07-17T03:17:01Z", "message": "Resolve conflicts in LS tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUwMzg0NTQ4", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#pullrequestreview-450384548", "createdAt": "2020-07-17T05:38:21Z", "commit": {"oid": "57bf9f2e7d952ed4dd19cd54153df9ffb585a629"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUwMzkxMDQ5", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#pullrequestreview-450391049", "createdAt": "2020-07-17T05:57:59Z", "commit": {"oid": "57bf9f2e7d952ed4dd19cd54153df9ffb585a629"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwNTo1Nzo1OVrOGzGU7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwNTo1Nzo1OVrOGzGU7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIzNDIyMw==", "bodyText": "Same as before, check whether OrElse() will be executed?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r456234223", "createdAt": "2020-07-17T05:57:59Z", "author": {"login": "pcnfernando"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/CodeAnalyzer.java", "diffHunk": "@@ -2711,11 +2714,84 @@ public void visit(BLangQueryExpr queryExpr) {\n                         this.dlog.error(collection.pos, DiagnosticCode.NOT_ALLOWED_STREAM_USAGE_WITH_FROM);\n                     }\n                 }\n+            } else if (clause.getKind() == NodeKind.ORDER_BY) {\n+                checkOrderFieldValidity(queryExpr.type, (BLangOrderByClause) clause);\n             }\n             analyzeNode(clause, env);\n         }\n     }\n \n+    private void checkOrderFieldValidity(BType resultType, BLangOrderByClause clause) {\n+        if (resultType.tag == TypeTags.ARRAY) {\n+            resultType = ((BArrayType) resultType).eType;\n+        } else if (resultType.tag == TypeTags.TABLE) {\n+            resultType = ((BTableType) resultType).constraint;\n+        } else if (resultType.tag == TypeTags.STREAM) {\n+            resultType = ((BStreamType) resultType).constraint;\n+        } else if (resultType.tag == TypeTags.UNION) {\n+            List<BType> exprTypes = new ArrayList<>(((BUnionType) resultType).getMemberTypes());\n+            for (BType t : exprTypes) {\n+                BType returnType;\n+                if (t.tag == TypeTags.STREAM) {\n+                    returnType = ((BUnionType) resultType).getMemberTypes()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "57bf9f2e7d952ed4dd19cd54153df9ffb585a629"}, "originalPosition": 40}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUwMzkxMTAx", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#pullrequestreview-450391101", "createdAt": "2020-07-17T05:58:09Z", "commit": {"oid": "57bf9f2e7d952ed4dd19cd54153df9ffb585a629"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "182ed4f795674a1e6c2c49f463d7ed020b5165cf", "author": {"user": {"login": "lasinicl", "name": "Lasini Liyange"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/182ed4f795674a1e6c2c49f463d7ed020b5165cf", "committedDate": "2020-07-17T06:08:28Z", "message": "Add review changes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUxMjA3Njk5", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#pullrequestreview-451207699", "createdAt": "2020-07-20T01:22:03Z", "commit": {"oid": "182ed4f795674a1e6c2c49f463d7ed020b5165cf"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwMToyMjowNFrOGz0DTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwMToyMjowNFrOGz0DTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk4MzM3NQ==", "bodyText": "Why don't we have to check string, xml cases here?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r456983375", "createdAt": "2020-07-20T01:22:04Z", "author": {"login": "grainier"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/CodeAnalyzer.java", "diffHunk": "@@ -2711,11 +2714,74 @@ public void visit(BLangQueryExpr queryExpr) {\n                         this.dlog.error(collection.pos, DiagnosticCode.NOT_ALLOWED_STREAM_USAGE_WITH_FROM);\n                     }\n                 }\n+            } else if (clause.getKind() == NodeKind.ORDER_BY) {\n+                checkOrderFieldValidity(queryExpr.type, (BLangOrderByClause) clause);\n             }\n             analyzeNode(clause, env);\n         }\n     }\n \n+    private void checkOrderFieldValidity(BType resultType, BLangOrderByClause clause) {\n+        if (resultType.tag == TypeTags.ARRAY) {\n+            resultType = ((BArrayType) resultType).eType;\n+        } else if (resultType.tag == TypeTags.TABLE) {\n+            resultType = ((BTableType) resultType).constraint;\n+        } else if (resultType.tag == TypeTags.STREAM) {\n+            resultType = ((BStreamType) resultType).constraint;\n+        } else if (resultType.tag == TypeTags.UNION) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "182ed4f795674a1e6c2c49f463d7ed020b5165cf"}, "originalPosition": 35}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUxMjA5MjUx", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#pullrequestreview-451209251", "createdAt": "2020-07-20T01:24:43Z", "commit": {"oid": "182ed4f795674a1e6c2c49f463d7ed020b5165cf"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwMToyNDo0M1rOGz0Eyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwMToyNDo0M1rOGz0Eyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk4Mzc1NA==", "bodyText": "You've written a similar function in CodeAnalyzer as well (but without string, XML checks). Is there a way to refactor both into one. Maybe we can but in Types?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r456983754", "createdAt": "2020-07-20T01:24:43Z", "author": {"login": "grainier"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/QueryDesugar.java", "diffHunk": "@@ -298,6 +311,38 @@ BLangStatementExpression desugar(BLangQueryAction queryAction, SymbolEnv env) {\n         return stmtExpr;\n     }\n \n+    /**\n+     * Get result type of the query output.\n+     *\n+     * @param type type of query expression.\n+     * @return result type.\n+     */\n+    private BType resolveExprType(BType type) {\n+        if (type.tag == TypeTags.STREAM) {\n+            return ((BStreamType) type).constraint;\n+        } else if (type.tag == TypeTags.TABLE) {\n+            return ((BTableType) type).constraint;\n+        } else if (type.tag == TypeTags.ARRAY) {\n+            return ((BArrayType) type).eType;\n+        } else if (type.tag == TypeTags.UNION) {\n+            List<BType> exprTypes = new ArrayList<>(((BUnionType) type).getMemberTypes());\n+            for (BType returnType : exprTypes) {\n+                if (returnType.tag == TypeTags.STREAM) {\n+                    return ((BStreamType) returnType).constraint;\n+                } else if (returnType.tag == TypeTags.TABLE) {\n+                    return ((BTableType) returnType).constraint;\n+                }  else if (returnType.tag == TypeTags.ARRAY) {\n+                    return ((BArrayType) returnType).eType;\n+                } else if (returnType.tag == TypeTags.STRING) {\n+                    return returnType;\n+                } else if (returnType.tag == TypeTags.XML) {\n+                    return returnType;\n+                }\n+            }\n+        }\n+        return type;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "182ed4f795674a1e6c2c49f463d7ed020b5165cf"}, "originalPosition": 89}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7b6186f15b73503ca8317f5255e2ff7c1e5f6fde", "author": {"user": {"login": "lasinicl", "name": "Lasini Liyange"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7b6186f15b73503ca8317f5255e2ff7c1e5f6fde", "committedDate": "2020-07-20T02:52:36Z", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into fix-24423-orderby"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bc635f60e0d9f24bcd4d97af86cf6cf074e482fb", "author": {"user": {"login": "lasinicl", "name": "Lasini Liyange"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/bc635f60e0d9f24bcd4d97af86cf6cf074e482fb", "committedDate": "2020-07-20T03:35:51Z", "message": "Fix review suggestions"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUxNDE5NDM4", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#pullrequestreview-451419438", "createdAt": "2020-07-20T08:56:59Z", "commit": {"oid": "bc635f60e0d9f24bcd4d97af86cf6cf074e482fb"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwODo1Njo1OVrOG0A7jA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwOToyMToyNlrOG0CChQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzE5NDM4MA==", "bodyText": "Do we need to pass the context as a param?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r457194380", "createdAt": "2020-07-20T08:56:59Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -10287,6 +10356,98 @@ private STNode parseLetClause(boolean isRhsExpr) {\n         return STNodeFactory.createLetClauseNode(letKeyword, letVarDeclarations);\n     }\n \n+    /**\n+     * Parse order by clause.\n+     * <p>\n+     * <code>order-by-clause := order by expression (ascending | descending)? (expression (ascending | descending)?)*\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseOrderByClause(boolean isRhsExpr) {\n+        STToken nextToken = peek();\n+        if (nextToken.kind != SyntaxKind.ORDER_KEYWORD) {\n+            return STNodeFactory.createEmptyNode();\n+        }\n+        STNode orderKeyword = parseOrderKeyword();\n+        STNode byKeyword = parseByKeyword();\n+        STNode orderKeys = parseOrderKeyList(ParserRuleContext.ORDER_KEY, isRhsExpr);\n+\n+        byKeyword = cloneWithDiagnosticIfListEmpty(orderKeys, byKeyword,\n+                DiagnosticErrorCode.ERROR_MISSING_EXPRESSION);\n+\n+        return STNodeFactory.createOrderByClauseNode(orderKeyword, byKeyword, orderKeys);\n+    }\n+\n+    /**\n+     * Parse order key.\n+     * <p>\n+     * <code>order-key-list := order-key [, order-key]*</code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseOrderKeyList(ParserRuleContext context, boolean isRhsExpr) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc635f60e0d9f24bcd4d97af86cf6cf074e482fb"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzIwMDU3OA==", "bodyText": "Need to update resumeParsing method with each of these newly added methods (if they are calling the recover method)", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r457200578", "createdAt": "2020-07-20T09:05:06Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -10179,6 +10188,66 @@ private STNode parseOuterKeyword() {\n         }\n     }\n \n+    /**\n+     * Parse order-keyword.\n+     *\n+     * @return Order-keyword node\n+     */\n+    private STNode parseOrderKeyword() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc635f60e0d9f24bcd4d97af86cf6cf074e482fb"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzIwMjM0MA==", "bodyText": "When a comma separated list is parsed, theres a possibility of having some extraneous token after a member, that is not captured by isEndOfOrderKeys.\nTherefore we check the token before parsing the separator - because after recovering, we could even reach the end of the list. So we have to do something similar to parseListConstructorMemberEnd()/parseArgEnd() methods.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r457202340", "createdAt": "2020-07-20T09:07:20Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -10287,6 +10356,98 @@ private STNode parseLetClause(boolean isRhsExpr) {\n         return STNodeFactory.createLetClauseNode(letKeyword, letVarDeclarations);\n     }\n \n+    /**\n+     * Parse order by clause.\n+     * <p>\n+     * <code>order-by-clause := order by expression (ascending | descending)? (expression (ascending | descending)?)*\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseOrderByClause(boolean isRhsExpr) {\n+        STToken nextToken = peek();\n+        if (nextToken.kind != SyntaxKind.ORDER_KEYWORD) {\n+            return STNodeFactory.createEmptyNode();\n+        }\n+        STNode orderKeyword = parseOrderKeyword();\n+        STNode byKeyword = parseByKeyword();\n+        STNode orderKeys = parseOrderKeyList(ParserRuleContext.ORDER_KEY, isRhsExpr);\n+\n+        byKeyword = cloneWithDiagnosticIfListEmpty(orderKeys, byKeyword,\n+                DiagnosticErrorCode.ERROR_MISSING_EXPRESSION);\n+\n+        return STNodeFactory.createOrderByClauseNode(orderKeyword, byKeyword, orderKeys);\n+    }\n+\n+    /**\n+     * Parse order key.\n+     * <p>\n+     * <code>order-key-list := order-key [, order-key]*</code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseOrderKeyList(ParserRuleContext context, boolean isRhsExpr) {\n+        startContext(context);\n+        List<STNode> orderKeys = new ArrayList<>();\n+        STToken nextToken = peek();\n+\n+        // Make sure at least one order key is present\n+        if (isEndOfOrderKeys(nextToken.kind)) {\n+            endContext();\n+            return STNodeFactory.createEmptyNodeList();\n+        }\n+\n+        // Parse first order key, that has no leading comma\n+        STNode orderKey = parseOrderKey(isRhsExpr);\n+        orderKeys.add(orderKey);\n+\n+        // Parse the remaining order keys\n+        nextToken = peek();\n+        STNode leadingComma;\n+        while (!isEndOfOrderKeys(nextToken.kind)) {\n+            leadingComma = parseComma();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc635f60e0d9f24bcd4d97af86cf6cf074e482fb"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzIwMzA0OQ==", "bodyText": "Can you explain the reason for checking !isTypeStartingToken()?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r457203049", "createdAt": "2020-07-20T09:08:23Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -10287,6 +10356,98 @@ private STNode parseLetClause(boolean isRhsExpr) {\n         return STNodeFactory.createLetClauseNode(letKeyword, letVarDeclarations);\n     }\n \n+    /**\n+     * Parse order by clause.\n+     * <p>\n+     * <code>order-by-clause := order by expression (ascending | descending)? (expression (ascending | descending)?)*\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseOrderByClause(boolean isRhsExpr) {\n+        STToken nextToken = peek();\n+        if (nextToken.kind != SyntaxKind.ORDER_KEYWORD) {\n+            return STNodeFactory.createEmptyNode();\n+        }\n+        STNode orderKeyword = parseOrderKeyword();\n+        STNode byKeyword = parseByKeyword();\n+        STNode orderKeys = parseOrderKeyList(ParserRuleContext.ORDER_KEY, isRhsExpr);\n+\n+        byKeyword = cloneWithDiagnosticIfListEmpty(orderKeys, byKeyword,\n+                DiagnosticErrorCode.ERROR_MISSING_EXPRESSION);\n+\n+        return STNodeFactory.createOrderByClauseNode(orderKeyword, byKeyword, orderKeys);\n+    }\n+\n+    /**\n+     * Parse order key.\n+     * <p>\n+     * <code>order-key-list := order-key [, order-key]*</code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseOrderKeyList(ParserRuleContext context, boolean isRhsExpr) {\n+        startContext(context);\n+        List<STNode> orderKeys = new ArrayList<>();\n+        STToken nextToken = peek();\n+\n+        // Make sure at least one order key is present\n+        if (isEndOfOrderKeys(nextToken.kind)) {\n+            endContext();\n+            return STNodeFactory.createEmptyNodeList();\n+        }\n+\n+        // Parse first order key, that has no leading comma\n+        STNode orderKey = parseOrderKey(isRhsExpr);\n+        orderKeys.add(orderKey);\n+\n+        // Parse the remaining order keys\n+        nextToken = peek();\n+        STNode leadingComma;\n+        while (!isEndOfOrderKeys(nextToken.kind)) {\n+            leadingComma = parseComma();\n+            orderKeys.add(leadingComma);\n+            orderKey = parseOrderKey(isRhsExpr);\n+            orderKeys.add(orderKey);\n+            nextToken = peek();\n+        }\n+\n+        endContext();\n+        return STNodeFactory.createNodeList(orderKeys);\n+    }\n+\n+    private boolean isEndOfOrderKeys(SyntaxKind tokenKind) {\n+        switch (tokenKind) {\n+            case COMMA_TOKEN:\n+                return false;\n+            case IN_KEYWORD:\n+                return true;\n+            default:\n+                return !isTypeStartingToken(tokenKind);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc635f60e0d9f24bcd4d97af86cf6cf074e482fb"}, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzIwNDI0MA==", "bodyText": "Add case EOF", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r457204240", "createdAt": "2020-07-20T09:10:07Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -10287,6 +10356,98 @@ private STNode parseLetClause(boolean isRhsExpr) {\n         return STNodeFactory.createLetClauseNode(letKeyword, letVarDeclarations);\n     }\n \n+    /**\n+     * Parse order by clause.\n+     * <p>\n+     * <code>order-by-clause := order by expression (ascending | descending)? (expression (ascending | descending)?)*\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseOrderByClause(boolean isRhsExpr) {\n+        STToken nextToken = peek();\n+        if (nextToken.kind != SyntaxKind.ORDER_KEYWORD) {\n+            return STNodeFactory.createEmptyNode();\n+        }\n+        STNode orderKeyword = parseOrderKeyword();\n+        STNode byKeyword = parseByKeyword();\n+        STNode orderKeys = parseOrderKeyList(ParserRuleContext.ORDER_KEY, isRhsExpr);\n+\n+        byKeyword = cloneWithDiagnosticIfListEmpty(orderKeys, byKeyword,\n+                DiagnosticErrorCode.ERROR_MISSING_EXPRESSION);\n+\n+        return STNodeFactory.createOrderByClauseNode(orderKeyword, byKeyword, orderKeys);\n+    }\n+\n+    /**\n+     * Parse order key.\n+     * <p>\n+     * <code>order-key-list := order-key [, order-key]*</code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseOrderKeyList(ParserRuleContext context, boolean isRhsExpr) {\n+        startContext(context);\n+        List<STNode> orderKeys = new ArrayList<>();\n+        STToken nextToken = peek();\n+\n+        // Make sure at least one order key is present\n+        if (isEndOfOrderKeys(nextToken.kind)) {\n+            endContext();\n+            return STNodeFactory.createEmptyNodeList();\n+        }\n+\n+        // Parse first order key, that has no leading comma\n+        STNode orderKey = parseOrderKey(isRhsExpr);\n+        orderKeys.add(orderKey);\n+\n+        // Parse the remaining order keys\n+        nextToken = peek();\n+        STNode leadingComma;\n+        while (!isEndOfOrderKeys(nextToken.kind)) {\n+            leadingComma = parseComma();\n+            orderKeys.add(leadingComma);\n+            orderKey = parseOrderKey(isRhsExpr);\n+            orderKeys.add(orderKey);\n+            nextToken = peek();\n+        }\n+\n+        endContext();\n+        return STNodeFactory.createNodeList(orderKeys);\n+    }\n+\n+    private boolean isEndOfOrderKeys(SyntaxKind tokenKind) {\n+        switch (tokenKind) {\n+            case COMMA_TOKEN:\n+                return false;\n+            case IN_KEYWORD:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc635f60e0d9f24bcd4d97af86cf6cf074e482fb"}, "originalPosition": 158}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzIwNjQ5NQ==", "bodyText": "A switch-case would better suite for this.\nWe may have to go for error-recovery if the next token is neither ascending,descending nor a valid-token that is possible to come after the  order-key", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r457206495", "createdAt": "2020-07-20T09:13:16Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -10287,6 +10356,98 @@ private STNode parseLetClause(boolean isRhsExpr) {\n         return STNodeFactory.createLetClauseNode(letKeyword, letVarDeclarations);\n     }\n \n+    /**\n+     * Parse order by clause.\n+     * <p>\n+     * <code>order-by-clause := order by expression (ascending | descending)? (expression (ascending | descending)?)*\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseOrderByClause(boolean isRhsExpr) {\n+        STToken nextToken = peek();\n+        if (nextToken.kind != SyntaxKind.ORDER_KEYWORD) {\n+            return STNodeFactory.createEmptyNode();\n+        }\n+        STNode orderKeyword = parseOrderKeyword();\n+        STNode byKeyword = parseByKeyword();\n+        STNode orderKeys = parseOrderKeyList(ParserRuleContext.ORDER_KEY, isRhsExpr);\n+\n+        byKeyword = cloneWithDiagnosticIfListEmpty(orderKeys, byKeyword,\n+                DiagnosticErrorCode.ERROR_MISSING_EXPRESSION);\n+\n+        return STNodeFactory.createOrderByClauseNode(orderKeyword, byKeyword, orderKeys);\n+    }\n+\n+    /**\n+     * Parse order key.\n+     * <p>\n+     * <code>order-key-list := order-key [, order-key]*</code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseOrderKeyList(ParserRuleContext context, boolean isRhsExpr) {\n+        startContext(context);\n+        List<STNode> orderKeys = new ArrayList<>();\n+        STToken nextToken = peek();\n+\n+        // Make sure at least one order key is present\n+        if (isEndOfOrderKeys(nextToken.kind)) {\n+            endContext();\n+            return STNodeFactory.createEmptyNodeList();\n+        }\n+\n+        // Parse first order key, that has no leading comma\n+        STNode orderKey = parseOrderKey(isRhsExpr);\n+        orderKeys.add(orderKey);\n+\n+        // Parse the remaining order keys\n+        nextToken = peek();\n+        STNode leadingComma;\n+        while (!isEndOfOrderKeys(nextToken.kind)) {\n+            leadingComma = parseComma();\n+            orderKeys.add(leadingComma);\n+            orderKey = parseOrderKey(isRhsExpr);\n+            orderKeys.add(orderKey);\n+            nextToken = peek();\n+        }\n+\n+        endContext();\n+        return STNodeFactory.createNodeList(orderKeys);\n+    }\n+\n+    private boolean isEndOfOrderKeys(SyntaxKind tokenKind) {\n+        switch (tokenKind) {\n+            case COMMA_TOKEN:\n+                return false;\n+            case IN_KEYWORD:\n+                return true;\n+            default:\n+                return !isTypeStartingToken(tokenKind);\n+        }\n+    }\n+\n+    /**\n+     * Parse order key.\n+     * <p>\n+     * <code>order-key := expression (ascending | descending)?</code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseOrderKey(boolean isRhsExpr) {\n+        STNode expression = parseExpression(OperatorPrecedence.QUERY, isRhsExpr, false);\n+        STToken nextToken = peek();\n+        if (nextToken.kind == SyntaxKind.ASCENDING_KEYWORD) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc635f60e0d9f24bcd4d97af86cf6cf074e482fb"}, "originalPosition": 175}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzIwODU5OQ==", "bodyText": "theres an overlap in the numbers (another set of keywords starts with 250) - shall we update the \"Type keywords\" (the ones that are below) to start with 300?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r457208599", "createdAt": "2020-07-20T09:16:02Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/syntax/tree/SyntaxKind.java", "diffHunk": "@@ -98,6 +98,10 @@\n     JOIN_KEYWORD(244, \"join\"),\n     OUTER_KEYWORD(245, \"outer\"),\n     EQUALS_KEYWORD(246, \"equals\"),\n+    ORDER_KEYWORD(247, \"order\"),\n+    BY_KEYWORD(248, \"by\"),\n+    ASCENDING_KEYWORD(249, \"ascending\"),\n+    DESCENDING_KEYWORD(250, \"descending\"),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc635f60e0d9f24bcd4d97af86cf6cf074e482fb"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzIxMjU0OQ==", "bodyText": "Defining both as optional allows someone to add both keywords at once in the syntax-tree.\nI think we need to have only one optional-field and that should hold the value regardless its ascending or descending.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r457212549", "createdAt": "2020-07-20T09:21:26Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-treegen/src/main/resources/syntax_tree_descriptor.json", "diffHunk": "@@ -4093,6 +4093,47 @@\n                     \"type\": \"Token\"\n                 }\n             ]\n+        },\n+        {\n+            \"name\": \"OrderByClauseNode\",\n+            \"base\": \"ClauseNode\",\n+            \"kind\": \"ORDER_BY_CLAUSE\",\n+            \"attributes\": [\n+                {\n+                    \"name\": \"orderKeyword\",\n+                    \"type\": \"Token\"\n+                },\n+                {\n+                    \"name\": \"byKeyword\",\n+                    \"type\": \"Token\"\n+                },\n+                {\n+                    \"name\": \"orderKey\",\n+                    \"type\": \"OrderKeyNode\",\n+                    \"occurrences\": \"MULTIPLE_SEPARATED\"\n+                }\n+            ]\n+        },\n+        {\n+            \"name\": \"OrderKeyNode\",\n+            \"base\": \"Node\",\n+            \"kind\": \"ORDER_KEY\",\n+            \"attributes\": [\n+                {\n+                    \"name\": \"expression\",\n+                    \"type\": \"ExpressionNode\"\n+                },\n+                {\n+                    \"name\": \"ascendingKeyword\",\n+                    \"type\": \"Token\",\n+                    \"isOptional\": true\n+                },\n+                {\n+                    \"name\": \"descendingKeyword\",\n+                    \"type\": \"Token\",\n+                    \"isOptional\": true\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc635f60e0d9f24bcd4d97af86cf6cf074e482fb"}, "originalPosition": 43}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUxNDQ4Mjgx", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#pullrequestreview-451448281", "createdAt": "2020-07-20T09:35:25Z", "commit": {"oid": "bc635f60e0d9f24bcd4d97af86cf6cf074e482fb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwOTozNToyNVrOG0CtnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwOTozNToyNVrOG0CtnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzIyMzU4MA==", "bodyText": "I think we can avoid this check. If first token is not ORDER_KEYWORD it will be handled inside parseOrderKeyword()", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r457223580", "createdAt": "2020-07-20T09:35:25Z", "author": {"login": "lochana-chathura"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -10287,6 +10356,98 @@ private STNode parseLetClause(boolean isRhsExpr) {\n         return STNodeFactory.createLetClauseNode(letKeyword, letVarDeclarations);\n     }\n \n+    /**\n+     * Parse order by clause.\n+     * <p>\n+     * <code>order-by-clause := order by expression (ascending | descending)? (expression (ascending | descending)?)*\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseOrderByClause(boolean isRhsExpr) {\n+        STToken nextToken = peek();\n+        if (nextToken.kind != SyntaxKind.ORDER_KEYWORD) {\n+            return STNodeFactory.createEmptyNode();\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc635f60e0d9f24bcd4d97af86cf6cf074e482fb"}, "originalPosition": 106}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUxNDQ5NzAx", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#pullrequestreview-451449701", "createdAt": "2020-07-20T09:37:19Z", "commit": {"oid": "bc635f60e0d9f24bcd4d97af86cf6cf074e482fb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwOTozNzoxOVrOG0Cyyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwOTozNzoxOVrOG0Cyyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzIyNDkwNw==", "bodyText": "this looks more cleaner to me. order-by-clause := order by (expression (ascending | descending)?)+\nWDYT?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r457224907", "createdAt": "2020-07-20T09:37:19Z", "author": {"login": "lochana-chathura"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -10287,6 +10356,98 @@ private STNode parseLetClause(boolean isRhsExpr) {\n         return STNodeFactory.createLetClauseNode(letKeyword, letVarDeclarations);\n     }\n \n+    /**\n+     * Parse order by clause.\n+     * <p>\n+     * <code>order-by-clause := order by expression (ascending | descending)? (expression (ascending | descending)?)*", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc635f60e0d9f24bcd4d97af86cf6cf074e482fb"}, "originalPosition": 97}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUxNDUxOTcy", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#pullrequestreview-451451972", "createdAt": "2020-07-20T09:40:26Z", "commit": {"oid": "bc635f60e0d9f24bcd4d97af86cf6cf074e482fb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwOTo0MDoyN1rOG0C7dA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwOTo0MDoyN1rOG0C7dA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzIyNzEyNA==", "bodyText": "Shall we add order-clause to documentation above; intermediate-clause := from-clause | where-clause | let-clause", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r457227124", "createdAt": "2020-07-20T09:40:27Z", "author": {"login": "lochana-chathura"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -10129,6 +10133,11 @@ private STNode parseIntermediateClause(SyntaxKind nextTokenKind, boolean isRhsEx\n             case JOIN_KEYWORD:\n             case OUTER_KEYWORD:\n                 return parseJoinClause(isRhsExpr);\n+            case ORDER_KEYWORD:\n+            case BY_KEYWORD:\n+            case ASCENDING_KEYWORD:\n+            case DESCENDING_KEYWORD:\n+                return parseOrderByClause(isRhsExpr);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc635f60e0d9f24bcd4d97af86cf6cf074e482fb"}, "originalPosition": 19}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUxNDUzMDY4", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#pullrequestreview-451453068", "createdAt": "2020-07-20T09:41:55Z", "commit": {"oid": "bc635f60e0d9f24bcd4d97af86cf6cf074e482fb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwOTo0MTo1NVrOG0C_uw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwOTo0MTo1NVrOG0C_uw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzIyODIxOQ==", "bodyText": "Let's use STNodeFactory.createEmptyNode(); instead of passing null, in all places", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r457228219", "createdAt": "2020-07-20T09:41:55Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -10287,6 +10356,98 @@ private STNode parseLetClause(boolean isRhsExpr) {\n         return STNodeFactory.createLetClauseNode(letKeyword, letVarDeclarations);\n     }\n \n+    /**\n+     * Parse order by clause.\n+     * <p>\n+     * <code>order-by-clause := order by expression (ascending | descending)? (expression (ascending | descending)?)*\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseOrderByClause(boolean isRhsExpr) {\n+        STToken nextToken = peek();\n+        if (nextToken.kind != SyntaxKind.ORDER_KEYWORD) {\n+            return STNodeFactory.createEmptyNode();\n+        }\n+        STNode orderKeyword = parseOrderKeyword();\n+        STNode byKeyword = parseByKeyword();\n+        STNode orderKeys = parseOrderKeyList(ParserRuleContext.ORDER_KEY, isRhsExpr);\n+\n+        byKeyword = cloneWithDiagnosticIfListEmpty(orderKeys, byKeyword,\n+                DiagnosticErrorCode.ERROR_MISSING_EXPRESSION);\n+\n+        return STNodeFactory.createOrderByClauseNode(orderKeyword, byKeyword, orderKeys);\n+    }\n+\n+    /**\n+     * Parse order key.\n+     * <p>\n+     * <code>order-key-list := order-key [, order-key]*</code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseOrderKeyList(ParserRuleContext context, boolean isRhsExpr) {\n+        startContext(context);\n+        List<STNode> orderKeys = new ArrayList<>();\n+        STToken nextToken = peek();\n+\n+        // Make sure at least one order key is present\n+        if (isEndOfOrderKeys(nextToken.kind)) {\n+            endContext();\n+            return STNodeFactory.createEmptyNodeList();\n+        }\n+\n+        // Parse first order key, that has no leading comma\n+        STNode orderKey = parseOrderKey(isRhsExpr);\n+        orderKeys.add(orderKey);\n+\n+        // Parse the remaining order keys\n+        nextToken = peek();\n+        STNode leadingComma;\n+        while (!isEndOfOrderKeys(nextToken.kind)) {\n+            leadingComma = parseComma();\n+            orderKeys.add(leadingComma);\n+            orderKey = parseOrderKey(isRhsExpr);\n+            orderKeys.add(orderKey);\n+            nextToken = peek();\n+        }\n+\n+        endContext();\n+        return STNodeFactory.createNodeList(orderKeys);\n+    }\n+\n+    private boolean isEndOfOrderKeys(SyntaxKind tokenKind) {\n+        switch (tokenKind) {\n+            case COMMA_TOKEN:\n+                return false;\n+            case IN_KEYWORD:\n+                return true;\n+            default:\n+                return !isTypeStartingToken(tokenKind);\n+        }\n+    }\n+\n+    /**\n+     * Parse order key.\n+     * <p>\n+     * <code>order-key := expression (ascending | descending)?</code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseOrderKey(boolean isRhsExpr) {\n+        STNode expression = parseExpression(OperatorPrecedence.QUERY, isRhsExpr, false);\n+        STToken nextToken = peek();\n+        if (nextToken.kind == SyntaxKind.ASCENDING_KEYWORD) {\n+            STNode ascendingKeyword = parseAscendingKeyword();\n+            return STNodeFactory.createOrderKeyNode(expression, ascendingKeyword, null);\n+        } else if (nextToken.kind == SyntaxKind.DESCENDING_KEYWORD) {\n+            STNode descendingKeyword = parseDescendingKeyword();\n+            return STNodeFactory.createOrderKeyNode(expression, null, descendingKeyword);\n+        } else {\n+            return STNodeFactory.createOrderKeyNode(expression, null, null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc635f60e0d9f24bcd4d97af86cf6cf074e482fb"}, "originalPosition": 182}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "985bbb2e864a57c5d1c528102ebcabf40195147b", "author": {"user": {"login": "lasinicl", "name": "Lasini Liyange"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/985bbb2e864a57c5d1c528102ebcabf40195147b", "committedDate": "2020-07-21T03:09:38Z", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into fix-24423-orderby"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "58d2092fb0bb2bdb8d2d5b51238010a8c1ae86ba", "author": {"user": {"login": "lasinicl", "name": "Lasini Liyange"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/58d2092fb0bb2bdb8d2d5b51238010a8c1ae86ba", "committedDate": "2020-07-22T06:54:54Z", "message": "Resolve conflicts"}, "afterCommit": {"oid": "af9a3880cc3b95ce4f8bd395144ea33c04801ab3", "author": {"user": {"login": "lasinicl", "name": "Lasini Liyange"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/af9a3880cc3b95ce4f8bd395144ea33c04801ab3", "committedDate": "2020-07-22T08:46:35Z", "message": "Add parser tests for order by"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b12529edb2207e5d8bacd22fa9cc19336923edf7", "author": {"user": {"login": "lasinicl", "name": "Lasini Liyange"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b12529edb2207e5d8bacd22fa9cc19336923edf7", "committedDate": "2020-07-22T08:51:11Z", "message": "Add suggested parser changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bf463ccbaf59499c3ed92a45f23fd8e28335b7de", "author": {"user": {"login": "lasinicl", "name": "Lasini Liyange"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/bf463ccbaf59499c3ed92a45f23fd8e28335b7de", "committedDate": "2020-07-22T08:51:55Z", "message": "Add parser tests for order by"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "af9a3880cc3b95ce4f8bd395144ea33c04801ab3", "author": {"user": {"login": "lasinicl", "name": "Lasini Liyange"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/af9a3880cc3b95ce4f8bd395144ea33c04801ab3", "committedDate": "2020-07-22T08:46:35Z", "message": "Add parser tests for order by"}, "afterCommit": {"oid": "bf463ccbaf59499c3ed92a45f23fd8e28335b7de", "author": {"user": {"login": "lasinicl", "name": "Lasini Liyange"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/bf463ccbaf59499c3ed92a45f23fd8e28335b7de", "committedDate": "2020-07-22T08:51:55Z", "message": "Add parser tests for order by"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7fe11d09825d1d23906b5bd48ef85e95cb58e4a1", "author": {"user": {"login": "lasinicl", "name": "Lasini Liyange"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7fe11d09825d1d23906b5bd48ef85e95cb58e4a1", "committedDate": "2020-07-22T09:03:06Z", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into fix-24423-orderby\n\n\u0001 Conflicts:\n\u0001\tcompiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/parser/antlr4/BallerinaParser.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/diagnostics/DiagnosticErrorCode.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/syntax/tree/SyntaxKind.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4500b550b4b38ebcf432e84af6615fdf37f8c7bc", "author": {"user": {"login": "lasinicl", "name": "Lasini Liyange"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/4500b550b4b38ebcf432e84af6615fdf37f8c7bc", "committedDate": "2020-07-22T09:16:07Z", "message": "Resolve conflicts"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUzMjQ5NjU1", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#pullrequestreview-453249655", "createdAt": "2020-07-22T12:02:13Z", "commit": {"oid": "4500b550b4b38ebcf432e84af6615fdf37f8c7bc"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMjowMjoxM1rOG1fS5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMjo0MjoyMFrOG1gnSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc0MDQ1NA==", "bodyText": "Would be better to replace this with a switch-case. It'l be faster and neat than the if-else, since there many conditions.\nCan do the same for the above method as well.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r458740454", "createdAt": "2020-07-22T12:02:13Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -3432,4 +3432,65 @@ private boolean checkFillerValue(BArrayType type) {\n         }\n         return hasFillerValue(type.eType);\n     }\n+\n+    /**\n+     * Get result type of the query output.\n+     *\n+     * @param type type of query expression.\n+     * @return result type.\n+     */\n+    public BType resolveExprType(BType type) {\n+        if (type.tag == TypeTags.STREAM) {\n+            return ((BStreamType) type).constraint;\n+        } else if (type.tag == TypeTags.TABLE) {\n+            return ((BTableType) type).constraint;\n+        } else if (type.tag == TypeTags.ARRAY) {\n+            return ((BArrayType) type).eType;\n+        } else if (type.tag == TypeTags.UNION) {\n+            List<BType> exprTypes = new ArrayList<>(((BUnionType) type).getMemberTypes());\n+            for (BType returnType : exprTypes) {\n+                if (returnType.tag == TypeTags.STREAM) {\n+                    return ((BStreamType) returnType).constraint;\n+                } else if (returnType.tag == TypeTags.TABLE) {\n+                    return ((BTableType) returnType).constraint;\n+                }  else if (returnType.tag == TypeTags.ARRAY) {\n+                    return ((BArrayType) returnType).eType;\n+                } else if (returnType.tag == TypeTags.STRING) {\n+                    return returnType;\n+                } else if (returnType.tag == TypeTags.XML) {\n+                    return returnType;\n+                }\n+            }\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Check whether a type is a basic type.\n+     *\n+     * @param type type of the field.\n+     * @return boolean whether the type is basic type or not.\n+     */\n+    public boolean checkBasicType(BType type) {\n+        if (type.tag == TypeTags.INT) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4500b550b4b38ebcf432e84af6615fdf37f8c7bc"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc0MDY5Mg==", "bodyText": "Should BYTE type also go here?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r458740692", "createdAt": "2020-07-22T12:02:43Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -3432,4 +3432,65 @@ private boolean checkFillerValue(BArrayType type) {\n         }\n         return hasFillerValue(type.eType);\n     }\n+\n+    /**\n+     * Get result type of the query output.\n+     *\n+     * @param type type of query expression.\n+     * @return result type.\n+     */\n+    public BType resolveExprType(BType type) {\n+        if (type.tag == TypeTags.STREAM) {\n+            return ((BStreamType) type).constraint;\n+        } else if (type.tag == TypeTags.TABLE) {\n+            return ((BTableType) type).constraint;\n+        } else if (type.tag == TypeTags.ARRAY) {\n+            return ((BArrayType) type).eType;\n+        } else if (type.tag == TypeTags.UNION) {\n+            List<BType> exprTypes = new ArrayList<>(((BUnionType) type).getMemberTypes());\n+            for (BType returnType : exprTypes) {\n+                if (returnType.tag == TypeTags.STREAM) {\n+                    return ((BStreamType) returnType).constraint;\n+                } else if (returnType.tag == TypeTags.TABLE) {\n+                    return ((BTableType) returnType).constraint;\n+                }  else if (returnType.tag == TypeTags.ARRAY) {\n+                    return ((BArrayType) returnType).eType;\n+                } else if (returnType.tag == TypeTags.STRING) {\n+                    return returnType;\n+                } else if (returnType.tag == TypeTags.XML) {\n+                    return returnType;\n+                }\n+            }\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Check whether a type is a basic type.\n+     *\n+     * @param type type of the field.\n+     * @return boolean whether the type is basic type or not.\n+     */\n+    public boolean checkBasicType(BType type) {\n+        if (type.tag == TypeTags.INT) {\n+            return true;\n+        } else if (type.tag == TypeTags.FLOAT) {\n+            return true;\n+        } else if (type.tag == TypeTags.DECIMAL) {\n+            return true;\n+        } else if (type.tag == TypeTags.STRING) {\n+            return true;\n+        } else if (type.tag == TypeTags.BOOLEAN) {\n+            return true;\n+        } else if (type.tag == TypeTags.NIL) {\n+            return true;\n+        } else if (type.tag == TypeTags.UNION) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4500b550b4b38ebcf432e84af6615fdf37f8c7bc"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc0MTE5OA==", "bodyText": "extra newline", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r458741198", "createdAt": "2020-07-22T12:03:44Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/parser/NodeCloner.java", "diffHunk": "@@ -1395,6 +1397,23 @@ public void visit(BLangOnClause source) {\n         clone.expression = clone(source.expression);\n     }\n \n+    @Override\n+    public void visit(BLangOrderKey source) {\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4500b550b4b38ebcf432e84af6615fdf37f8c7bc"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc0MTIyOQ==", "bodyText": "extra newline", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r458741229", "createdAt": "2020-07-22T12:03:48Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/parser/NodeCloner.java", "diffHunk": "@@ -1395,6 +1397,23 @@ public void visit(BLangOnClause source) {\n         clone.expression = clone(source.expression);\n     }\n \n+    @Override\n+    public void visit(BLangOrderKey source) {\n+\n+        BLangOrderKey clone = new BLangOrderKey();\n+        source.cloneRef = clone;\n+        clone.expression = clone(source.expression);\n+        clone.isAscending = source.isAscending;\n+    }\n+\n+    @Override\n+    public void visit(BLangOrderByClause source) {\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4500b550b4b38ebcf432e84af6615fdf37f8c7bc"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc0MjQyNg==", "bodyText": "shall we invert the condition and do an early-exit? That way we can avoid one level of right-indentations.\neg:\nif (resultType.tag != TypeTags.RECORD) {\n    return;\n}", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r458742426", "createdAt": "2020-07-22T12:06:20Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/CodeAnalyzer.java", "diffHunk": "@@ -2712,11 +2715,34 @@ public void visit(BLangQueryExpr queryExpr) {\n                         this.dlog.error(collection.pos, DiagnosticCode.NOT_ALLOWED_STREAM_USAGE_WITH_FROM);\n                     }\n                 }\n+            } else if (clause.getKind() == NodeKind.ORDER_BY) {\n+                checkOrderFieldValidity(queryExpr.type, (BLangOrderByClause) clause);\n             }\n             analyzeNode(clause, env);\n         }\n     }\n \n+    private void checkOrderFieldValidity(BType resultType, BLangOrderByClause clause) {\n+        resultType = types.resolveExprType(resultType);\n+        if (resultType.tag == TypeTags.RECORD) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4500b550b4b38ebcf432e84af6615fdf37f8c7bc"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc0MzIyOA==", "bodyText": "can remove these extra newlines", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r458743228", "createdAt": "2020-07-22T12:07:57Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -10397,6 +10417,201 @@ private STNode parseLetClause(boolean isRhsExpr) {\n         return STNodeFactory.createLetClauseNode(letKeyword, letVarDeclarations);\n     }\n \n+    /**\n+     * Parse order-keyword.\n+     *\n+     * @return Order-keyword node\n+     */\n+    private STNode parseOrderKeyword() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.ORDER_KEYWORD) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(token, ParserRuleContext.ORDER_KEYWORD);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse by-keyword.\n+     *\n+     * @return By-keyword node\n+     */\n+    private STNode parseByKeyword() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.BY_KEYWORD) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(token, ParserRuleContext.BY_KEYWORD);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse ascending-keyword.\n+     *\n+     * @return Ascending-keyword node\n+     */\n+    private STNode parseAscendingKeyword() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.ASCENDING_KEYWORD) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(token, ParserRuleContext.ASCENDING_KEYWORD);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse descending-keyword.\n+     *\n+     * @return Descending-keyword node\n+     */\n+    private STNode parseDescendingKeyword() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.DESCENDING_KEYWORD) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(token, ParserRuleContext.DESCENDING_KEYWORD);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse order by clause.\n+     * <p>\n+     * <code>order-by-clause := order by order-key-list\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseOrderByClause(boolean isRhsExpr) {\n+        STNode orderKeyword = parseOrderKeyword();\n+        STNode byKeyword = parseByKeyword();\n+        STNode orderKeys = parseOrderKeyList(isRhsExpr);\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4500b550b4b38ebcf432e84af6615fdf37f8c7bc"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc0MzgwMA==", "bodyText": "comment is sort of not correct, since we don't do any validation here..", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r458743800", "createdAt": "2020-07-22T12:09:03Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -10397,6 +10417,201 @@ private STNode parseLetClause(boolean isRhsExpr) {\n         return STNodeFactory.createLetClauseNode(letKeyword, letVarDeclarations);\n     }\n \n+    /**\n+     * Parse order-keyword.\n+     *\n+     * @return Order-keyword node\n+     */\n+    private STNode parseOrderKeyword() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.ORDER_KEYWORD) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(token, ParserRuleContext.ORDER_KEYWORD);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse by-keyword.\n+     *\n+     * @return By-keyword node\n+     */\n+    private STNode parseByKeyword() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.BY_KEYWORD) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(token, ParserRuleContext.BY_KEYWORD);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse ascending-keyword.\n+     *\n+     * @return Ascending-keyword node\n+     */\n+    private STNode parseAscendingKeyword() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.ASCENDING_KEYWORD) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(token, ParserRuleContext.ASCENDING_KEYWORD);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse descending-keyword.\n+     *\n+     * @return Descending-keyword node\n+     */\n+    private STNode parseDescendingKeyword() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.DESCENDING_KEYWORD) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(token, ParserRuleContext.DESCENDING_KEYWORD);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse order by clause.\n+     * <p>\n+     * <code>order-by-clause := order by order-key-list\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseOrderByClause(boolean isRhsExpr) {\n+        STNode orderKeyword = parseOrderKeyword();\n+        STNode byKeyword = parseByKeyword();\n+        STNode orderKeys = parseOrderKeyList(isRhsExpr);\n+\n+        byKeyword = cloneWithDiagnosticIfListEmpty(orderKeys, byKeyword,\n+                DiagnosticErrorCode.ERROR_MISSING_ORDER_KEY);\n+\n+        return STNodeFactory.createOrderByClauseNode(orderKeyword, byKeyword, orderKeys);\n+    }\n+\n+    /**\n+     * Parse order key.\n+     * <p>\n+     * <code>order-key-list := order-key [, order-key]*</code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseOrderKeyList(boolean isRhsExpr) {\n+        startContext(ParserRuleContext.ORDER_KEY);\n+        List<STNode> orderKeys = new ArrayList<>();\n+        STToken nextToken = peek();\n+\n+        // Make sure at least one order key is present", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4500b550b4b38ebcf432e84af6615fdf37f8c7bc"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc0NTYyMA==", "bodyText": "since this list has only one member, we can remove the list and directly use EXPRESSION as the next rule, where ORDER_KEY_LIST_START is used. Can remove it from hasAlternativePaths() methods also, since it has only one path", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r458745620", "createdAt": "2020-07-22T12:12:34Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -558,6 +559,12 @@\n     private static final ParserRuleContext[] NAMED_ARG_MATCH_PATTERN_RHS =\n             { ParserRuleContext.NAMED_ARG_MATCH_PATTERN, ParserRuleContext.REST_MATCH_PATTERN };\n \n+    private static final ParserRuleContext[] ORDER_KEY_LIST_START =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4500b550b4b38ebcf432e84af6615fdf37f8c7bc"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc0NjM0Ng==", "bodyText": "Need to update the isProductionWithAlternatives with the same.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r458746346", "createdAt": "2020-07-22T12:13:55Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -1174,6 +1185,8 @@ private boolean hasAlternativePaths(ParserRuleContext currentCtx) {\n             case TABLE_KEY_RHS:\n             case ERROR_TYPE_PARAMS:\n             case LET_VAR_DECL_START:\n+            case ORDER_KEY_LIST_START:\n+            case ORDER_KEY_LIST_END:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4500b550b4b38ebcf432e84af6615fdf37f8c7bc"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc1MTUyMA==", "bodyText": "Here we states which tokens can occur after some expression.\neg: ... order by foo <cursor>\nsince what follows after by keyword is an expression, we can put many tokens inplace of <cursor>, such as a binary operator (foo + bar), a dot (foo.bar), etc. So we need to add all those.\nYou can check for the common things compared to the other cases in the switch-case. Additionally, there can be ParserRuleContext.ORDER_CLAUSE_END.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r458751520", "createdAt": "2020-07-22T12:23:45Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -1906,6 +1925,11 @@ private Result seekMatchInExpressionRhs(int lookahead, int currentDepth, int cur\n                         ParserRuleContext.XML_NAVIGATE_EXPR, ParserRuleContext.MEMBER_ACCESS_KEY_EXPR,\n                         ParserRuleContext.LET_CLAUSE_END };\n                 break;\n+            case ORDER_KEY:\n+                alternatives = new ParserRuleContext[] { ParserRuleContext.COMMA, ParserRuleContext.EXPRESSION,\n+                        ParserRuleContext.ASCENDING_KEYWORD, ParserRuleContext.DESCENDING_KEYWORD,\n+                        ParserRuleContext.ORDER_CLAUSE_END };\n+                break;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4500b550b4b38ebcf432e84af6615fdf37f8c7bc"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc1MzAyNw==", "bodyText": "I think we shouldn't need to add it here, since an order-keyword cannot exist inside a let-var-decl.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r458753027", "createdAt": "2020-07-22T12:26:23Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -2688,6 +2717,21 @@ private ParserRuleContext getNextRuleForKeywords(ParserRuleContext currentCtx, i\n                     endContext(); // end let-clause-let-var-decl\n                 }\n                 return ParserRuleContext.EXPRESSION;\n+            case ORDER_KEYWORD:\n+                parentCtx = getParentContext();\n+                if (parentCtx == ParserRuleContext.LET_CLAUSE_LET_VAR_DECL) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4500b550b4b38ebcf432e84af6615fdf37f8c7bc"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc1NzM3MQ==", "bodyText": "Looks like a new context is not started for ORDER_CLAUSE_END, so this condition may never be true?\nI think a better approach would be to say, next token context after the ascending/descending keywords is ORDER_KEY_RHS. And it has alternative paths - ORDER_KEY and ORDER_CLAUSE_END", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r458757371", "createdAt": "2020-07-22T12:34:04Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -2688,6 +2717,21 @@ private ParserRuleContext getNextRuleForKeywords(ParserRuleContext currentCtx, i\n                     endContext(); // end let-clause-let-var-decl\n                 }\n                 return ParserRuleContext.EXPRESSION;\n+            case ORDER_KEYWORD:\n+                parentCtx = getParentContext();\n+                if (parentCtx == ParserRuleContext.LET_CLAUSE_LET_VAR_DECL) {\n+                    endContext(); // end let-clause-let-var-decl\n+                }\n+                return ParserRuleContext.BY_KEYWORD;\n+            case BY_KEYWORD:\n+                return ParserRuleContext.ORDER_KEY;\n+            case ASCENDING_KEYWORD:\n+            case DESCENDING_KEYWORD:\n+                parentCtx = getParentContext();\n+                if (parentCtx == ParserRuleContext.ORDER_CLAUSE_END) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4500b550b4b38ebcf432e84af6615fdf37f8c7bc"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc1Nzc5Mw==", "bodyText": "I think you'll have to end the context which-ever path it takes, otherwise there will be nested contexts started without ending them", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r458757793", "createdAt": "2020-07-22T12:34:48Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -2688,6 +2717,21 @@ private ParserRuleContext getNextRuleForKeywords(ParserRuleContext currentCtx, i\n                     endContext(); // end let-clause-let-var-decl\n                 }\n                 return ParserRuleContext.EXPRESSION;\n+            case ORDER_KEYWORD:\n+                parentCtx = getParentContext();\n+                if (parentCtx == ParserRuleContext.LET_CLAUSE_LET_VAR_DECL) {\n+                    endContext(); // end let-clause-let-var-decl\n+                }\n+                return ParserRuleContext.BY_KEYWORD;\n+            case BY_KEYWORD:\n+                return ParserRuleContext.ORDER_KEY;\n+            case ASCENDING_KEYWORD:\n+            case DESCENDING_KEYWORD:\n+                parentCtx = getParentContext();\n+                if (parentCtx == ParserRuleContext.ORDER_CLAUSE_END) {\n+                    endContext(); // end order-key", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4500b550b4b38ebcf432e84af6615fdf37f8c7bc"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc2MDA5NA==", "bodyText": "These two should be replaced by a single field.\neg:\n\"attributes\": [\n    {\n        \"name\": \"expression\",\n        \"type\": \"ExpressionNode\"\n    },\n    {\n        \"name\": \"order\",\n        \"type\": \"Token\"\n        \"isOptional\": true\n    }\n]\n\nThis way, only one can exist at a time.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r458760094", "createdAt": "2020-07-22T12:38:52Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-treegen/src/main/resources/syntax_tree_descriptor.json", "diffHunk": "@@ -4093,6 +4093,46 @@\n                     \"type\": \"Token\"\n                 }\n             ]\n+        },\n+        {\n+            \"name\": \"OrderByClauseNode\",\n+            \"base\": \"ClauseNode\",\n+            \"kind\": \"ORDER_BY_CLAUSE\",\n+            \"attributes\": [\n+                {\n+                    \"name\": \"orderKeyword\",\n+                    \"type\": \"Token\"\n+                },\n+                {\n+                    \"name\": \"byKeyword\",\n+                    \"type\": \"Token\"\n+                },\n+                {\n+                    \"name\": \"orderKey\",\n+                    \"type\": \"OrderKeyNode\",\n+                    \"occurrences\": \"MULTIPLE_SEPARATED\"\n+                }\n+            ]\n+        },\n+        {\n+            \"name\": \"OrderKeyNode\",\n+            \"base\": \"Node\",\n+            \"kind\": \"ORDER_KEY\",\n+            \"attributes\": [\n+                {\n+                    \"name\": \"expression\",\n+                    \"type\": \"ExpressionNode\"\n+                },\n+                {\n+                    \"name\": \"ascendingKeyword\",\n+                    \"type\": \"Token\"\n+                },\n+                {\n+                    \"name\": \"descendingKeyword\",\n+                    \"type\": \"Token\",\n+                    \"isOptional\": true\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4500b550b4b38ebcf432e84af6615fdf37f8c7bc"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc2MjA1OA==", "bodyText": "does this includes negative tests (tests with incorrect syntaxes) also?\n\nIf yes - shall we split it in to two? There are separate sections in the same test file for positive tests and negative tests\nIf not - shall we add some?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r458762058", "createdAt": "2020-07-22T12:42:20Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/test/java/io/ballerinalang/compiler/parser/test/syntax/expressions/QueryExpressionTest.java", "diffHunk": "@@ -169,4 +169,16 @@ public void testQueryWithOperatorPrecedenceWithExtraClauses() {\n         test(\"from int a in b select c let int a = b + from int f in g select h\",\n                 \"query-expr/query_expr_assert_38.json\");\n     }\n+\n+    @Test\n+    public void testQueryWithOrderByClause() {\n+        test(\"from int a in b where c let int d = e order by f select g\", \"query-expr/query_expr_assert_39.json\");\n+        test(\"from int a in b where c let int d = e order by f ascending, g select h\", \"query-expr\" +\n+                \"/query_expr_assert_40.json\");\n+        test(\"from int a in b order by c ascending, d descending select e\", \"query-expr\" +\n+                \"/query_expr_assert_41.json\");\n+        test(\"from int a in b order by select c\", \"query-expr/query_expr_assert_42.json\");\n+        test(\"from int a in b order c select d\", \"query-expr/query_expr_assert_43.json\");\n+        test(\"from int a in b order by c ascending d select e\", \"query-expr/query_expr_assert_44.json\");\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4500b550b4b38ebcf432e84af6615fdf37f8c7bc"}, "originalPosition": 15}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "58dfc6c222bbbb04b121ac786046074a2f87d868", "author": {"user": {"login": "lasinicl", "name": "Lasini Liyange"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/58dfc6c222bbbb04b121ac786046074a2f87d868", "committedDate": "2020-07-22T17:56:50Z", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into fix-24423-orderby"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b0ac97e40ffa9e9514c5b8dfbe23ab2907608643", "author": {"user": {"login": "lasinicl", "name": "Lasini Liyange"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b0ac97e40ffa9e9514c5b8dfbe23ab2907608643", "committedDate": "2020-07-22T17:58:12Z", "message": "Add suggested changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7a92cd644050b80a0d22c0ac8a735d36ac940bcd", "author": {"user": {"login": "lasinicl", "name": "Lasini Liyange"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7a92cd644050b80a0d22c0ac8a735d36ac940bcd", "committedDate": "2020-07-24T03:28:41Z", "message": "Add alternative paths for order direction"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "80a50c338ba24a1fe76958900307a11142f5acc1", "author": {"user": {"login": "lasinicl", "name": "Lasini Liyange"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/80a50c338ba24a1fe76958900307a11142f5acc1", "committedDate": "2020-07-24T03:29:35Z", "message": "Add alternative paths for order direction"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "65deb30390b1ecb766a7c27a44a6f8c4175fb266", "author": {"user": {"login": "lasinicl", "name": "Lasini Liyange"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/65deb30390b1ecb766a7c27a44a6f8c4175fb266", "committedDate": "2020-07-24T03:29:55Z", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into fix-24423-orderby"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0NjI0OTA3", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#pullrequestreview-454624907", "createdAt": "2020-07-24T04:09:40Z", "commit": {"oid": "65deb30390b1ecb766a7c27a44a6f8c4175fb266"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0NjI3MjUx", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#pullrequestreview-454627251", "createdAt": "2020-07-24T04:21:36Z", "commit": {"oid": "65deb30390b1ecb766a7c27a44a6f8c4175fb266"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU0MzYxMTAy", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#pullrequestreview-554361102", "createdAt": "2020-12-17T08:10:22Z", "commit": {"oid": "65deb30390b1ecb766a7c27a44a6f8c4175fb266"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwODoxMDoyMlrOIHpW3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwODoxMDoyMlrOIHpW3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg4ODU0Mw==", "bodyText": "try to use .isEmpty() rather when ever possible. these provided functions are more optimized", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r544888543", "createdAt": "2020-12-17T08:10:22Z", "author": {"login": "pcnfernando"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/parser/BLangPackageBuilder.java", "diffHunk": "@@ -2091,6 +2095,25 @@ void createOnClause(DiagnosticPos pos, Set<Whitespace> ws) {\n         joinClause.onClause = onClause;\n     }\n \n+    void createOrderByKey(DiagnosticPos pos, Set<Whitespace> ws, boolean isAscending) {\n+        BLangOrderKey orderKey = (BLangOrderKey) TreeBuilder.createOrderKeyNode();\n+        orderKey.pos = pos;\n+        orderKey.setOrderKey(this.exprNodeStack.pop());\n+        orderKey.setOrderDirection(isAscending);\n+        orderKeyListStack.push(orderKey);\n+    }\n+\n+    void createOrderByClause(DiagnosticPos pos, Set<Whitespace> ws) {\n+        BLangOrderByClause orderByClause = (BLangOrderByClause) TreeBuilder.createOrderByClauseNode();\n+        orderByClause.addWS(ws);\n+        orderByClause.pos = pos;\n+        Collections.reverse(orderKeyListStack);\n+        while (orderKeyListStack.size() > 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65deb30390b1ecb766a7c27a44a6f8c4175fb266"}, "originalPosition": 35}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU0MzYxNTI0", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#pullrequestreview-554361524", "createdAt": "2020-12-17T08:11:02Z", "commit": {"oid": "65deb30390b1ecb766a7c27a44a6f8c4175fb266"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwODoxMTowMlrOIHpYTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwODoxMTowMlrOIHpYTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg4ODkwOA==", "bodyText": "merge the two ifs", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r544888908", "createdAt": "2020-12-17T08:11:02Z", "author": {"login": "pcnfernando"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/parser/BLangParserListener.java", "diffHunk": "@@ -2933,6 +2933,31 @@ public void exitBinaryEqualsExpression(BallerinaParser.BinaryEqualsExpressionCon\n         this.pkgBuilder.createBinaryExpr(getCurrentPos(ctx), getWS(ctx), ctx.getChild(1).getText());\n     }\n \n+    @Override\n+    public void exitOrderKey(BallerinaParser.OrderKeyContext ctx) {\n+        if (isInErrorState) {\n+            return;\n+        }\n+\n+        boolean isAscending = true;\n+        if (ctx.orderDirection() != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65deb30390b1ecb766a7c27a44a6f8c4175fb266"}, "originalPosition": 11}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU0MzYzNjM5", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#pullrequestreview-554363639", "createdAt": "2020-12-17T08:14:09Z", "commit": {"oid": "65deb30390b1ecb766a7c27a44a6f8c4175fb266"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwODoxNDowOVrOIHpfIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwODoxNDowOVrOIHpfIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg5MDY1Ng==", "bodyText": "You can move orderKeyNode.getOrderKey().toString() as common local var", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r544890656", "createdAt": "2020-12-17T08:14:09Z", "author": {"login": "pcnfernando"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/CodeAnalyzer.java", "diffHunk": "@@ -2712,11 +2715,35 @@ public void visit(BLangQueryExpr queryExpr) {\n                         this.dlog.error(collection.pos, DiagnosticCode.NOT_ALLOWED_STREAM_USAGE_WITH_FROM);\n                     }\n                 }\n+            } else if (clause.getKind() == NodeKind.ORDER_BY) {\n+                checkOrderFieldValidity(queryExpr.type, (BLangOrderByClause) clause);\n             }\n             analyzeNode(clause, env);\n         }\n     }\n \n+    private void checkOrderFieldValidity(BType resultType, BLangOrderByClause clause) {\n+        resultType = types.resolveExprType(resultType);\n+        if (resultType.tag != TypeTags.RECORD) {\n+            return;\n+        }\n+        BRecordType recordType = (BRecordType) resultType;\n+        Map<String, BField> recordFields = recordType.fields;\n+        for (OrderKeyNode orderKeyNode : clause.getOrderKeyList()) {\n+            if (!recordFields.containsKey(orderKeyNode.getOrderKey().toString())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65deb30390b1ecb766a7c27a44a6f8c4175fb266"}, "originalPosition": 36}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU0MzY0OTQ1", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#pullrequestreview-554364945", "createdAt": "2020-12-17T08:16:05Z", "commit": {"oid": "65deb30390b1ecb766a7c27a44a6f8c4175fb266"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwODoxNjowNlrOIHpjxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwODoxNjowNlrOIHpjxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg5MTg0Ng==", "bodyText": "You can get this as common var and check !null instead of contains and use commonly for both if/else", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r544891846", "createdAt": "2020-12-17T08:16:06Z", "author": {"login": "pcnfernando"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/CodeAnalyzer.java", "diffHunk": "@@ -2712,11 +2715,35 @@ public void visit(BLangQueryExpr queryExpr) {\n                         this.dlog.error(collection.pos, DiagnosticCode.NOT_ALLOWED_STREAM_USAGE_WITH_FROM);\n                     }\n                 }\n+            } else if (clause.getKind() == NodeKind.ORDER_BY) {\n+                checkOrderFieldValidity(queryExpr.type, (BLangOrderByClause) clause);\n             }\n             analyzeNode(clause, env);\n         }\n     }\n \n+    private void checkOrderFieldValidity(BType resultType, BLangOrderByClause clause) {\n+        resultType = types.resolveExprType(resultType);\n+        if (resultType.tag != TypeTags.RECORD) {\n+            return;\n+        }\n+        BRecordType recordType = (BRecordType) resultType;\n+        Map<String, BField> recordFields = recordType.fields;\n+        for (OrderKeyNode orderKeyNode : clause.getOrderKeyList()) {\n+            if (!recordFields.containsKey(orderKeyNode.getOrderKey().toString())) {\n+                dlog.error(((BLangOrderKey) orderKeyNode).expression.pos,\n+                        DiagnosticCode.UNDEFINED_FIELD_IN_RECORD,\n+                        ((BLangOrderKey) orderKeyNode).expression, resultType);\n+            } else if (orderKeyNode.getOrderKey().toString() != null) {\n+                BType exprType = recordFields.get(orderKeyNode.getOrderKey().toString()).type;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65deb30390b1ecb766a7c27a44a6f8c4175fb266"}, "originalPosition": 41}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU0MzY3MDA3", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#pullrequestreview-554367007", "createdAt": "2020-12-17T08:19:07Z", "commit": {"oid": "65deb30390b1ecb766a7c27a44a6f8c4175fb266"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwODoxOTowN1rOIHpqyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwODoxOTowN1rOIHpqyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg5MzY0Mg==", "bodyText": "Unnecessary new line", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r544893642", "createdAt": "2020-12-17T08:19:07Z", "author": {"login": "pcnfernando"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/tree/clauses/BLangOrderByClause.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.wso2.ballerinalang.compiler.tree.clauses;\n+\n+import org.ballerinalang.model.clauses.OrderByClauseNode;\n+import org.ballerinalang.model.clauses.OrderKeyNode;\n+import org.ballerinalang.model.tree.NodeKind;\n+import org.wso2.ballerinalang.compiler.tree.BLangNode;\n+import org.wso2.ballerinalang.compiler.tree.BLangNodeVisitor;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.StringJoiner;\n+\n+/**\n+ * Implementation of \"order by\" clause statement.\n+ *\n+ * @since Swan Lake\n+ */\n+public class BLangOrderByClause extends BLangNode implements OrderByClauseNode {\n+    public List<OrderKeyNode> orderByKeyList = new ArrayList<>();\n+\n+    public BLangOrderByClause() {\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65deb30390b1ecb766a7c27a44a6f8c4175fb266"}, "originalPosition": 39}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU0Mzc0NDYy", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#pullrequestreview-554374462", "createdAt": "2020-12-17T08:29:57Z", "commit": {"oid": "65deb30390b1ecb766a7c27a44a6f8c4175fb266"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwODoyOTo1N1rOIHqEIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwODoyOTo1N1rOIHqEIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDkwMDEyOA==", "bodyText": "You can use java streams api for joinning as well. No need to update it here. Just a suggestion for later since it's more descriptive.\neg:\norderByKeyList.stream()\n      .map(key -> key.toString())\n      .collect(Collectors.joining(\",\"));", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r544900128", "createdAt": "2020-12-17T08:29:57Z", "author": {"login": "pcnfernando"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/tree/clauses/BLangOrderByClause.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.wso2.ballerinalang.compiler.tree.clauses;\n+\n+import org.ballerinalang.model.clauses.OrderByClauseNode;\n+import org.ballerinalang.model.clauses.OrderKeyNode;\n+import org.ballerinalang.model.tree.NodeKind;\n+import org.wso2.ballerinalang.compiler.tree.BLangNode;\n+import org.wso2.ballerinalang.compiler.tree.BLangNodeVisitor;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.StringJoiner;\n+\n+/**\n+ * Implementation of \"order by\" clause statement.\n+ *\n+ * @since Swan Lake\n+ */\n+public class BLangOrderByClause extends BLangNode implements OrderByClauseNode {\n+    public List<OrderKeyNode> orderByKeyList = new ArrayList<>();\n+\n+    public BLangOrderByClause() {\n+\n+    }\n+\n+    @Override\n+    public NodeKind getKind() {\n+        return NodeKind.ORDER_BY;\n+    }\n+\n+    @Override\n+    public void accept(BLangNodeVisitor visitor) {\n+        visitor.visit(this);\n+    }\n+\n+    @Override\n+    public void addOrderKey(OrderKeyNode orderKeyNode) {\n+        orderByKeyList.add(orderKeyNode);\n+    }\n+\n+    @Override\n+    public List<OrderKeyNode> getOrderKeyList() {\n+        return orderByKeyList;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        StringJoiner declarations = new StringJoiner(\", \");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65deb30390b1ecb766a7c27a44a6f8c4175fb266"}, "originalPosition": 64}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU0MzgxNDg5", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#pullrequestreview-554381489", "createdAt": "2020-12-17T08:39:56Z", "commit": {"oid": "65deb30390b1ecb766a7c27a44a6f8c4175fb266"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwODozOTo1N1rOIHqbsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwODozOTo1N1rOIHqbsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDkwNjE2MA==", "bodyText": "unnecessary line break", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r544906160", "createdAt": "2020-12-17T08:39:57Z", "author": {"login": "pcnfernando"}, "path": "langlib/lang.query/src/main/ballerina/src/lang.query/helpers.bal", "diffHunk": "@@ -141,6 +156,169 @@ public function consumeStream(stream<Type, error?> strm) returns error? {\n     }\n }\n \n+public type StreamOrderBy object {\n+    public string[] sortFields;\n+    public boolean[] sortTypes;\n+\n+    public function init(string[] sortFields, boolean[] sortTypes) {\n+        self.sortFields = sortFields;\n+        self.sortTypes = sortTypes;\n+    }\n+\n+    public function topDownMergeSort(@tainted Type[] events) returns @tainted Type[]{\n+        int index = 0;\n+        int n = events.length();\n+        Type[] b = [];\n+        while (index < n) {\n+            b[index] = events[index];\n+            index += 1;\n+        }\n+        self.topDownSplitMerge(b, 0, n, events);\n+        return events;\n+    }\n+\n+    function topDownSplitMerge(@tainted Type[] b, int iBegin, int iEnd, @tainted Type[] a) {\n+        if (iEnd - iBegin < 2) {\n+            return;\n+        }\n+        int iMiddle = (iEnd + iBegin) / 2;\n+        self.topDownSplitMerge(a, iBegin, iMiddle, b);\n+        self.topDownSplitMerge(a, iMiddle, iEnd, b);\n+        self.topDownMerge(b, iBegin, iMiddle, iEnd, a);\n+    }\n+\n+    function topDownMerge(@tainted Type[] a, int iBegin, int iMiddle, int iEnd, @tainted Type[] b) {\n+        int i = iBegin;\n+        int j = iMiddle;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65deb30390b1ecb766a7c27a44a6f8c4175fb266"}, "originalPosition": 67}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU0MzgyMTY4", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#pullrequestreview-554382168", "createdAt": "2020-12-17T08:40:53Z", "commit": {"oid": "65deb30390b1ecb766a7c27a44a6f8c4175fb266"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwODo0MDo1M1rOIHqdzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwODo0MDo1M1rOIHqdzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDkwNjcwMA==", "bodyText": "unnecessary new line", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r544906700", "createdAt": "2020-12-17T08:40:53Z", "author": {"login": "pcnfernando"}, "path": "langlib/lang.query/src/main/ballerina/src/lang.query/helpers.bal", "diffHunk": "@@ -141,6 +156,169 @@ public function consumeStream(stream<Type, error?> strm) returns error? {\n     }\n }\n \n+public type StreamOrderBy object {\n+    public string[] sortFields;\n+    public boolean[] sortTypes;\n+\n+    public function init(string[] sortFields, boolean[] sortTypes) {\n+        self.sortFields = sortFields;\n+        self.sortTypes = sortTypes;\n+    }\n+\n+    public function topDownMergeSort(@tainted Type[] events) returns @tainted Type[]{\n+        int index = 0;\n+        int n = events.length();\n+        Type[] b = [];\n+        while (index < n) {\n+            b[index] = events[index];\n+            index += 1;\n+        }\n+        self.topDownSplitMerge(b, 0, n, events);\n+        return events;\n+    }\n+\n+    function topDownSplitMerge(@tainted Type[] b, int iBegin, int iEnd, @tainted Type[] a) {\n+        if (iEnd - iBegin < 2) {\n+            return;\n+        }\n+        int iMiddle = (iEnd + iBegin) / 2;\n+        self.topDownSplitMerge(a, iBegin, iMiddle, b);\n+        self.topDownSplitMerge(a, iMiddle, iEnd, b);\n+        self.topDownMerge(b, iBegin, iMiddle, iEnd, a);\n+    }\n+\n+    function topDownMerge(@tainted Type[] a, int iBegin, int iMiddle, int iEnd, @tainted Type[] b) {\n+        int i = iBegin;\n+        int j = iMiddle;\n+\n+        int k = iBegin;\n+        while (k < iEnd) {\n+            if (i < iMiddle && (j >= iEnd || self.sortFunc(a[i], a[j], 0) < 0)) {\n+                b[k] = a[i];\n+                i = i + 1;\n+            } else {\n+                b[k] = a[j];\n+                j = j + 1;\n+            }\n+            k += 1;\n+        }\n+    }\n+\n+    function sortFunc(Type x, Type y, int fieldIndex) returns @tainted int {\n+        map<anydata> xMapValue = <map<anydata>>x;\n+        map<anydata> yMapValue = <map<anydata>>y;\n+\n+        var xFieldValue = xMapValue.get(self.sortFields[fieldIndex]);\n+        var yFieldValue = yMapValue.get(self.sortFields[fieldIndex]);\n+\n+        if (xFieldValue is ()) {\n+            if (yFieldValue is ()) {\n+                return 0;\n+            } else {\n+                return 1;\n+            }\n+        } else if (yFieldValue is ()) {\n+            return -1;\n+        } else if (xFieldValue is (int|float|decimal)) {\n+            if (yFieldValue is (int|float|decimal)) {\n+                int c;\n+                if (self.sortTypes[fieldIndex]) {\n+                    c = self.numberSort(xFieldValue, yFieldValue);\n+                } else {\n+                    c = self.numberSort(yFieldValue, xFieldValue);\n+                }\n+                return self.callNextSortFunc(x, y, c, fieldIndex + 1);\n+            } else {\n+                panic error(\"Inconsistent order field value\",\n+                message = self.sortFields[fieldIndex] + \" order field contain non-numeric values\");\n+            }\n+        } else if (xFieldValue is string) {\n+            if (yFieldValue is string) {\n+                int c;\n+                if (self.sortTypes[fieldIndex]) {\n+                    c = self.stringSort(xFieldValue, yFieldValue);\n+                } else {\n+                    c = self.stringSort(yFieldValue, xFieldValue);\n+                }\n+                return self.callNextSortFunc(x, y, c, fieldIndex + 1);\n+            } else {\n+                panic error(\"Inconsistent order field value\",\n+                message = self.sortFields[fieldIndex] + \" order field contain non-string type values\");\n+            }\n+        } else if (xFieldValue is boolean) {\n+            if (yFieldValue is boolean) {\n+                int c;\n+                if (self.sortTypes[fieldIndex]) {\n+                    c = self.booleanSort(xFieldValue, yFieldValue);\n+                } else {\n+                    c = self.booleanSort(yFieldValue, xFieldValue);\n+                }\n+                return self.callNextSortFunc(x, y, c, fieldIndex + 1);\n+            } else {\n+                  panic error(\"Inconsistent order field value\",\n+                  message = self.sortFields[fieldIndex] + \" order field contain non-boolean type values\");\n+            }\n+        } else {\n+            panic error(\"Unable to perform order by\",\n+            message = self.sortFields[fieldIndex] + \" field type incorrect\");\n+        }\n+    }\n+\n+    public function numberSort(int|float|decimal val1, int|float|decimal val2) returns int {\n+        if (val1 is int) {\n+            if (val2 is int) {\n+                return val1 - val2;\n+            } else if (val2 is float) {\n+                return <float>val1 < val2 ? -1 : <float>val1 == val2 ? 0 : 1;\n+            } else {\n+                return <decimal>val1 < val2 ? -1 : <decimal>val1 == val2 ? 0 : 1;\n+            }\n+        } else if (val1 is float) {\n+            if (val2 is int) {\n+                return val1 < <float>val2 ? -1 : val1 == <float>val2 ? 0 : 1;\n+            } else if (val2 is float){\n+                return val1 < val2 ? -1 : val1 == val2 ? 0 : 1;\n+            } else {\n+                return <decimal>val1 < val2 ? -1 : <decimal>val1 == val2 ? 0 : 1;\n+            }\n+        } else {\n+            if (val2 is (int|float)) {\n+                return val1 < <decimal>val2 ? -1 : val1 == <decimal>val2 ? 0 : 1;\n+            } else {\n+                return val1 < val2 ? -1 : val1 == val2 ? 0 : 1;\n+            }\n+        }\n+    }\n+\n+    public function stringSort(string st1, string st2) returns int {\n+        return strings:codePointCompare(st1, st2);\n+    }\n+\n+    public function booleanSort(boolean b1, boolean b2) returns int {\n+        if (b1) {\n+            if (b2) {\n+                return 0;\n+            } else {\n+                return 1;\n+            }\n+        } else {\n+            if (b2) {\n+                return -1;\n+            } else {\n+                return 0;\n+            }\n+        }\n+    }\n+\n+    function callNextSortFunc(Type x, Type y, int c, int fieldIndex) returns @tainted int {\n+        int result = c;\n+        if (result == 0 && (self.sortTypes.length() > fieldIndex)) {\n+            result = self.sortFunc(x, y, fieldIndex);\n+        }\n+        return result;\n+    }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65deb30390b1ecb766a7c27a44a6f8c4175fb266"}, "originalPosition": 194}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU0MzgzMTQz", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#pullrequestreview-554383143", "createdAt": "2020-12-17T08:42:15Z", "commit": {"oid": "65deb30390b1ecb766a7c27a44a6f8c4175fb266"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwODo0MjoxNVrOIHqhPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwODo0MjoxNVrOIHqhPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDkwNzU4MA==", "bodyText": "missing eof", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r544907580", "createdAt": "2020-12-17T08:42:15Z", "author": {"login": "pcnfernando"}, "path": "tests/jballerina-unit-test/src/test/resources/test-src/query/order-by-clause-negative.bal", "diffHunk": "@@ -0,0 +1,80 @@\n+type Person record {|\n+    string firstName;\n+    string lastName;\n+    int age;\n+|};\n+\n+type Customer record {|\n+    string name;\n+    Address address;\n+|};\n+\n+type Address record {|\n+    int unitNo;\n+    string street;\n+|};\n+\n+type PersonTable table<Person> key(firstName);\n+\n+function testOrderByClauseWithInvalidOrderField() {\n+    Person p1 = {firstName: \"Alex\", lastName: \"George\", age: 23};\n+    Person p2 = {firstName: \"Ranjan\", lastName: \"Fonseka\", age: 30};\n+    Person p3 = {firstName: \"John\", lastName: \"David\", age: 33};\n+    Person p4 = {firstName: \"John\", lastName: \"Fonseka\", age: 28};\n+\n+    Person[] personList = [p1, p2, p3, p4];\n+\n+    Person[] outputPersonStream = from var person in personList\n+        order by lastname descending\n+        select {\n+            firstName: person.firstName,\n+            lastName: person.lastName,\n+            age: person.age\n+        };\n+}\n+\n+function testOrderByClauseWithInvalidOrderField2() {\n+    Person p1 = {firstName: \"Alex\", lastName: \"George\", age: 23};\n+    Person p2 = {firstName: \"Ranjan\", lastName: \"Fonseka\", age: 30};\n+    Person p3 = {firstName: \"John\", lastName: \"David\", age: 33};\n+    Person p4 = {firstName: \"John\", lastName: \"Fonseka\", age: 28};\n+\n+    Person[] personList = [p1, p2, p3, p4];\n+\n+    PersonTable|error personTable = table key(firstName) from var person in personList\n+        order by lastname descending\n+        select {\n+            firstName: person.firstName,\n+            lastName: person.lastName,\n+            age: person.age\n+        };\n+}\n+\n+function testOrderByClauseWithInvalidOrderField3() {\n+    Person p1 = {firstName: \"Alex\", lastName: \"George\", age: 23};\n+    Person p2 = {firstName: \"Ranjan\", lastName: \"Fonseka\", age: 30};\n+    Person p3 = {firstName: \"John\", lastName: \"David\", age: 33};\n+    Person p4 = {firstName: \"John\", lastName: \"Fonseka\", age: 28};\n+\n+    Person[] personList = [p1, p2, p3, p4];\n+\n+    stream<Person> personTable = stream from var person in personList\n+        order by lastname descending\n+        select {\n+            firstName: person.firstName,\n+            lastName: person.lastName,\n+            age: person.age\n+        };\n+}\n+\n+function testOrderByClauseWithComplexTypeFieldInOrderBy() {\n+    Customer c1 = {name: \"James\", address: {unitNo: 1, street: \"Main Street\"}};\n+    Customer c2 = {name: \"Frank\", address: {unitNo: 2, street: \"Main Street\"}};\n+    Customer c3 = {name: \"Nina\", address: {unitNo: 3, street: \"Palm Grove\"}};\n+\n+    Customer[] customerList = [c1, c2, c3];\n+\n+    Customer[] opList = from var customer in customerList\n+        order by address\n+        select customer;\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65deb30390b1ecb766a7c27a44a6f8c4175fb266"}, "originalPosition": 80}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4175, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}