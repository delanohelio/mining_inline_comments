{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzczNjAxMDA5", "number": 20989, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxMTo0NTowNFrODexfyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxMjoxOTozNlrODfhkyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNTk0ODI1OnYy", "diffSide": "RIGHT", "path": "tests/jballerina-integration-test/src/test/resources/grpc/src/clients/19_grpc_map_field_client.bal", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxMTo0NTowNFrOFoF_wA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxMTo0NTowNFrOFoF_wA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzU4NTYwMA==", "bodyText": "Shall we stick to the 120 max line width? Check all the places.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20989#discussion_r377585600", "createdAt": "2020-02-11T11:45:04Z", "author": {"login": "anupama-pathirage"}, "path": "tests/jballerina-integration-test/src/test/resources/grpc/src/clients/19_grpc_map_field_client.bal", "diffHunk": "@@ -0,0 +1,168 @@\n+// Copyright (c) 2020 WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+//\n+// WSO2 Inc. licenses this file to you under the Apache License,\n+// Version 2.0 (the \"License\"); you may not use this file except\n+// in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+import ballerina/grpc;\n+import ballerina/io;\n+\n+NegotiatorBlockingClient blockingEp = new(\"http://localhost:9109\");\n+\n+public function main (string... args) {\n+    io:println(\"starting negotiator client\");\n+    io:println(testMapFields());\n+    io:println(testOptionalFields());\n+}\n+\n+public function testMapFields() returns string {\n+    MetricsPublishRequest request = {id: \"xxxxx\", metrics: [{timestamp:1580966325916,\n+    name:\"ballerina/http/Caller_3XX_requests_total_count\",value:0.0,tags:[{key:\"action\", value:\"respond\"}]}]};\n+    grpc:Headers|error publishMetrics = blockingEp->publishMetrics(request);\n+    if (publishMetrics is error) {\n+        return io:sprintf(\"Metrics publish failed: %s - %s\", publishMetrics.reason(), <string> publishMetrics.detail()[\"message\"]);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "171eb9d9ef3355cfe8a1adcb0f695902a849b3f3"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNTk1NzQ4OnYy", "diffSide": "RIGHT", "path": "tests/jballerina-integration-test/src/test/resources/grpc/src/grpcservices/19_grpc_map_service.bal", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxMTo0ODoyOFrOFoGFZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxMTo0ODo0NVrOFoGF9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzU4NzA0NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                record {| string key; string value; |}[] tags = [];\n          \n          \n            \n                record {|string key; string value;|}[] tags = [];", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20989#discussion_r377587045", "createdAt": "2020-02-11T11:48:28Z", "author": {"login": "anupama-pathirage"}, "path": "tests/jballerina-integration-test/src/test/resources/grpc/src/grpcservices/19_grpc_map_service.bal", "diffHunk": "@@ -0,0 +1,143 @@\n+// Copyright (c) 2020 WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+//\n+// WSO2 Inc. licenses this file to you under the Apache License,\n+// Version 2.0 (the \"License\"); you may not use this file except\n+// in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+import ballerina/grpc;\n+import ballerina/io;\n+import ballerina/log;\n+\n+listener grpc:Listener negotiatorep = new (9109);\n+\n+@grpc:ServiceDescriptor {\n+    descriptor: ROOT_DESCRIPTOR_19,\n+    descMap: getDescriptorMap19()\n+}\n+service Negotiator on negotiatorep {\n+\n+    resource function handshake(grpc:Caller caller, HandshakeRequest value) {\n+        log:printInfo(io:sprintf(\"Handshake request: %s\", value.toString()));\n+\n+        if (value.jsonStr != \"\") {\n+            error? sendError = caller->sendError(grpc:INVALID_ARGUMENT, \"jsonStr should be an empty string.\");\n+            return;\n+        }\n+        if (value.programHash != \"\") {\n+            error? sendError = caller->sendError(grpc:INVALID_ARGUMENT, \"programHash should be an empty string.\");\n+            return;\n+        }\n+        if (value.userId != \"\") {\n+            error? sendError = caller->sendError(grpc:INVALID_ARGUMENT, \"userId should be an empty string.\");\n+            return;\n+        }\n+        if (value.instanceId != \"\") {\n+            error? sendError = caller->sendError(grpc:INVALID_ARGUMENT, \"instanceId should be an empty string.\");\n+            return;\n+        }\n+        if (value.applicationId != \"\") {\n+            error? sendError = caller->sendError(grpc:INVALID_ARGUMENT, \"applicationId should be an empty string.\");\n+            return;\n+        }\n+        HandshakeResponse response = {id:\"123456\", protocols:[\"http\", \"https\"]};\n+        error? send = caller->send(response);\n+        if (send is error) {\n+            log:printError(\"Error while sending the response.\", send);\n+        } else {\n+            error? complete = caller->complete();\n+        }\n+    }\n+\n+    resource function publishMetrics(grpc:Caller caller, MetricsPublishRequest value) {\n+        log:printInfo(io:sprintf(\"publishMetrics request: %s\", value.toString()));\n+\n+        if (value.metrics.length() < 0) {\n+            error? sendError = caller->sendError(grpc:INVALID_ARGUMENT, \"metrics cannot be an empty array.\");\n+            return;\n+        }\n+        foreach var metric in value.metrics {\n+             log:printInfo(io:sprintf(\"metric value: %s\", metric.toString()));\n+             if (metric.tags.length() < 0) {\n+                 error? sendError = caller->sendError(grpc:INVALID_ARGUMENT, \"tags cannot be an empty array.\");\n+                 return;\n+             }\n+        }\n+        error? complete = caller->complete();\n+    }\n+\n+    resource function publishTraces(grpc:Caller caller, TracesPublishRequest value) {\n+        log:printInfo(io:sprintf(\"publishTraces request: %s\", value.toString()));\n+        error? complete = caller->complete();\n+        io:println(complete);\n+    }\n+}\n+\n+public type Empty record {|\n+|};\n+\n+public type HandshakeResponse record {|\n+    string id = \"\";\n+    string[] protocols = [];\n+|};\n+\n+public type MetricsPublishRequest record {|\n+    string id = \"\";\n+    Metric[] metrics = [];\n+|};\n+\n+public type Metric record {|\n+    int timestamp = 0;\n+    string name = \"\";\n+    float value = 0.0;\n+    record {| string key; string value; |}[] tags = [];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "171eb9d9ef3355cfe8a1adcb0f695902a849b3f3"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzU4NzE4OA==", "bodyText": "Shall we reformat the .bal files?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20989#discussion_r377587188", "createdAt": "2020-02-11T11:48:45Z", "author": {"login": "anupama-pathirage"}, "path": "tests/jballerina-integration-test/src/test/resources/grpc/src/grpcservices/19_grpc_map_service.bal", "diffHunk": "@@ -0,0 +1,143 @@\n+// Copyright (c) 2020 WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+//\n+// WSO2 Inc. licenses this file to you under the Apache License,\n+// Version 2.0 (the \"License\"); you may not use this file except\n+// in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+import ballerina/grpc;\n+import ballerina/io;\n+import ballerina/log;\n+\n+listener grpc:Listener negotiatorep = new (9109);\n+\n+@grpc:ServiceDescriptor {\n+    descriptor: ROOT_DESCRIPTOR_19,\n+    descMap: getDescriptorMap19()\n+}\n+service Negotiator on negotiatorep {\n+\n+    resource function handshake(grpc:Caller caller, HandshakeRequest value) {\n+        log:printInfo(io:sprintf(\"Handshake request: %s\", value.toString()));\n+\n+        if (value.jsonStr != \"\") {\n+            error? sendError = caller->sendError(grpc:INVALID_ARGUMENT, \"jsonStr should be an empty string.\");\n+            return;\n+        }\n+        if (value.programHash != \"\") {\n+            error? sendError = caller->sendError(grpc:INVALID_ARGUMENT, \"programHash should be an empty string.\");\n+            return;\n+        }\n+        if (value.userId != \"\") {\n+            error? sendError = caller->sendError(grpc:INVALID_ARGUMENT, \"userId should be an empty string.\");\n+            return;\n+        }\n+        if (value.instanceId != \"\") {\n+            error? sendError = caller->sendError(grpc:INVALID_ARGUMENT, \"instanceId should be an empty string.\");\n+            return;\n+        }\n+        if (value.applicationId != \"\") {\n+            error? sendError = caller->sendError(grpc:INVALID_ARGUMENT, \"applicationId should be an empty string.\");\n+            return;\n+        }\n+        HandshakeResponse response = {id:\"123456\", protocols:[\"http\", \"https\"]};\n+        error? send = caller->send(response);\n+        if (send is error) {\n+            log:printError(\"Error while sending the response.\", send);\n+        } else {\n+            error? complete = caller->complete();\n+        }\n+    }\n+\n+    resource function publishMetrics(grpc:Caller caller, MetricsPublishRequest value) {\n+        log:printInfo(io:sprintf(\"publishMetrics request: %s\", value.toString()));\n+\n+        if (value.metrics.length() < 0) {\n+            error? sendError = caller->sendError(grpc:INVALID_ARGUMENT, \"metrics cannot be an empty array.\");\n+            return;\n+        }\n+        foreach var metric in value.metrics {\n+             log:printInfo(io:sprintf(\"metric value: %s\", metric.toString()));\n+             if (metric.tags.length() < 0) {\n+                 error? sendError = caller->sendError(grpc:INVALID_ARGUMENT, \"tags cannot be an empty array.\");\n+                 return;\n+             }\n+        }\n+        error? complete = caller->complete();\n+    }\n+\n+    resource function publishTraces(grpc:Caller caller, TracesPublishRequest value) {\n+        log:printInfo(io:sprintf(\"publishTraces request: %s\", value.toString()));\n+        error? complete = caller->complete();\n+        io:println(complete);\n+    }\n+}\n+\n+public type Empty record {|\n+|};\n+\n+public type HandshakeResponse record {|\n+    string id = \"\";\n+    string[] protocols = [];\n+|};\n+\n+public type MetricsPublishRequest record {|\n+    string id = \"\";\n+    Metric[] metrics = [];\n+|};\n+\n+public type Metric record {|\n+    int timestamp = 0;\n+    string name = \"\";\n+    float value = 0.0;\n+    record {| string key; string value; |}[] tags = [];", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzU4NzA0NQ=="}, "originalCommit": {"oid": "171eb9d9ef3355cfe8a1adcb0f695902a849b3f3"}, "originalPosition": 102}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0MzgyNTM4OnYy", "diffSide": "RIGHT", "path": "stdlib/grpc/src/main/java/org/ballerinalang/net/grpc/nativeimpl/client/FunctionUtils.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxMjoxOTozNlrOFpRtqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QwNTowMDo0NlrOFqYiWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODgyNjE1NA==", "bodyText": "What is the special reason to notify the error to callback and return error subsequently?\nIf the exception has occurred before the non-blocking call, then call back should not be called ideally. We can simply unblock strand[1] and return error. Problem is if we notify the callback when the non-blocking task is not processed, that can cause strand state issues.\n[1] https://github.com/ballerina-platform/ballerina-lang/blob/master/stdlib/http/src/main/java/org/ballerinalang/net/http/nativeimpl/connection/Respond.java#L122", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20989#discussion_r378826154", "createdAt": "2020-02-13T12:19:36Z", "author": {"login": "chamil321"}, "path": "stdlib/grpc/src/main/java/org/ballerinalang/net/grpc/nativeimpl/client/FunctionUtils.java", "diffHunk": "@@ -248,18 +248,22 @@ public static Object externBlockingExecute(ObjectValue clientEndpoint, String me\n                 requestMsg.setHeaders(headers);\n             }\n             BlockingStub blockingStub = (BlockingStub) connectionStub;\n+            DataContext dataContext = null;\n             try {\n                 MethodDescriptor.MethodType methodType = getMethodType(methodDescriptor);\n                 if (methodType.equals(MethodDescriptor.MethodType.UNARY)) {\n \n-                    DataContext dataContext = new DataContext(Scheduler.getStrand(),\n+                    dataContext = new DataContext(Scheduler.getStrand(),\n                             new NonBlockingCallback(Scheduler.getStrand()));\n                     blockingStub.executeUnary(requestMsg, methodDescriptors.get(methodName), dataContext);\n                 } else {\n                     return notifyErrorReply(INTERNAL, \"Error while executing the client call. Method type \" +\n                             methodType.name() + \" not supported\");\n                 }\n             } catch (Exception e) {\n+                if (dataContext != null) {\n+                    dataContext.getCallback().notifyFailure(MessageUtils.getConnectorError(e));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7643f94d85669726cfa1c3cd367d10941ed0261c"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTk4NTExMA==", "bodyText": "We need to release the strand when there is an error before doing the network call. Thanks for the suggestion", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20989#discussion_r379985110", "createdAt": "2020-02-17T04:52:51Z", "author": {"login": "daneshk"}, "path": "stdlib/grpc/src/main/java/org/ballerinalang/net/grpc/nativeimpl/client/FunctionUtils.java", "diffHunk": "@@ -248,18 +248,22 @@ public static Object externBlockingExecute(ObjectValue clientEndpoint, String me\n                 requestMsg.setHeaders(headers);\n             }\n             BlockingStub blockingStub = (BlockingStub) connectionStub;\n+            DataContext dataContext = null;\n             try {\n                 MethodDescriptor.MethodType methodType = getMethodType(methodDescriptor);\n                 if (methodType.equals(MethodDescriptor.MethodType.UNARY)) {\n \n-                    DataContext dataContext = new DataContext(Scheduler.getStrand(),\n+                    dataContext = new DataContext(Scheduler.getStrand(),\n                             new NonBlockingCallback(Scheduler.getStrand()));\n                     blockingStub.executeUnary(requestMsg, methodDescriptors.get(methodName), dataContext);\n                 } else {\n                     return notifyErrorReply(INTERNAL, \"Error while executing the client call. Method type \" +\n                             methodType.name() + \" not supported\");\n                 }\n             } catch (Exception e) {\n+                if (dataContext != null) {\n+                    dataContext.getCallback().notifyFailure(MessageUtils.getConnectorError(e));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODgyNjE1NA=="}, "originalCommit": {"oid": "7643f94d85669726cfa1c3cd367d10941ed0261c"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTk4NjUyMg==", "bodyText": "Fixed in 25dc241", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20989#discussion_r379986522", "createdAt": "2020-02-17T05:00:46Z", "author": {"login": "daneshk"}, "path": "stdlib/grpc/src/main/java/org/ballerinalang/net/grpc/nativeimpl/client/FunctionUtils.java", "diffHunk": "@@ -248,18 +248,22 @@ public static Object externBlockingExecute(ObjectValue clientEndpoint, String me\n                 requestMsg.setHeaders(headers);\n             }\n             BlockingStub blockingStub = (BlockingStub) connectionStub;\n+            DataContext dataContext = null;\n             try {\n                 MethodDescriptor.MethodType methodType = getMethodType(methodDescriptor);\n                 if (methodType.equals(MethodDescriptor.MethodType.UNARY)) {\n \n-                    DataContext dataContext = new DataContext(Scheduler.getStrand(),\n+                    dataContext = new DataContext(Scheduler.getStrand(),\n                             new NonBlockingCallback(Scheduler.getStrand()));\n                     blockingStub.executeUnary(requestMsg, methodDescriptors.get(methodName), dataContext);\n                 } else {\n                     return notifyErrorReply(INTERNAL, \"Error while executing the client call. Method type \" +\n                             methodType.name() + \" not supported\");\n                 }\n             } catch (Exception e) {\n+                if (dataContext != null) {\n+                    dataContext.getCallback().notifyFailure(MessageUtils.getConnectorError(e));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODgyNjE1NA=="}, "originalCommit": {"oid": "7643f94d85669726cfa1c3cd367d10941ed0261c"}, "originalPosition": 19}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1214, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}