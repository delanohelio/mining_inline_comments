{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIyNzA5NTk4", "number": 23479, "title": "Add maping-binding-pattern support to Typed Binding Pattern", "bodyText": "Add maping-binding-pattern support to Typed Binding Pattern\nmapping-binding-pattern := { field-binding-patterns }\nfield-binding-patterns :=\nfield-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n| [ rest-binding-pattern ]\nfield-binding-pattern :=\nfield-name : binding-pattern\n| variable-name\nrest-binding-pattern := ... variable-name\nCheck List\n\n Read the Contributing Guide\n Updated Change Log\n Checked Tooling Support (#)\n Added necessary tests\n\n Unit Tests\n Spec Conformance Tests\n Integration Tests\n Ballerina By Example Tests\n\n\n Increased Test Coverage\n Added necessary documentation\n\n API documentation\n Module documentation in Module.md files\n Ballerina By Examples", "createdAt": "2020-05-25T11:46:42Z", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23479", "merged": true, "mergeCommit": {"oid": "c85f7816730c5f61b977773a3a69d6a7e4f13a28"}, "closed": true, "closedAt": "2020-05-29T02:34:23Z", "author": {"login": "m36dot"}, "timelineItems": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABckudVnAH2gAyNDIyNzA5NTk4OjEzZTFlM2FjZWRhMTZlOThkMGM4YzhkNDk5MDAxMTk5YzJjODYzYmM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcl5HrFgFqTQyMDYxNDkzNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "13e1e3aceda16e98d0c8c8d499001199c2c863bc", "author": {"user": {"login": "m36dot", "name": "Saif Abdul Cassim"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/13e1e3aceda16e98d0c8c8d499001199c2c863bc", "committedDate": "2020-05-25T11:35:02Z", "message": "Add maping-binding-pattern support"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4c1b83eed0c1630c2a956072d78864a2b4332a76", "author": {"user": {"login": "m36dot", "name": "Saif Abdul Cassim"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/4c1b83eed0c1630c2a956072d78864a2b4332a76", "committedDate": "2020-05-25T12:18:26Z", "message": "Refactor Code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f9df7de6510c02e8190e436e1ffef38f016581cc", "author": {"user": {"login": "m36dot", "name": "Saif Abdul Cassim"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f9df7de6510c02e8190e436e1ffef38f016581cc", "committedDate": "2020-05-25T12:22:57Z", "message": "Refactor code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a9e616c312e66de69a60a209f2af8be80c64dd5c", "author": {"user": {"login": "m36dot", "name": "Saif Abdul Cassim"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a9e616c312e66de69a60a209f2af8be80c64dd5c", "committedDate": "2020-05-26T05:49:06Z", "message": "Fix recovery for mappingbindingpattern"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE4ODM2ODg1", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23479#pullrequestreview-418836885", "createdAt": "2020-05-27T03:44:26Z", "commit": {"oid": "a9e616c312e66de69a60a209f2af8be80c64dd5c"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwMzo0NDoyNlrOGa4big==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwNTowNzoyM1rOGa5kpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0MDcxNA==", "bodyText": "Can we get rid of this remove operation? Is it possible to avoid adding, rather than removing", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23479#discussion_r430840714", "createdAt": "2020-05-27T03:44:26Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -10208,6 +10212,149 @@ private Boolean isFollowTypedBindingPattern(SyntaxKind tokenKind) {\n         }\n     }\n \n+    /**\n+     * Parse mapping-binding-patterns.\n+     *\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     *\n+     * @return mapping-binding-pattern node\n+     */\n+    private STNode parseMappingBindingPattern() {\n+        startContext(ParserRuleContext.MAPPING_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBrace = parseOpenBrace();\n+\n+        STNode mappingBindingPatternMember = parseMappingBindingPatternMember();\n+        bindingPatterns.add(mappingBindingPatternMember);\n+\n+        // parsing the main chunck of mapping-binding-pattern\n+        STToken token = peek(); // get next valid token\n+        STNode mappingBindingPatternRhs = null;\n+        while (!isEndOfMappingBindingPattern(token.kind) &&\n+                mappingBindingPatternMember.kind != SyntaxKind.REST_BINDING_PATTERN) {\n+            mappingBindingPatternRhs = parseMappingBindingpatternRhs(token.kind);\n+            if (mappingBindingPatternRhs == null) {\n+                break;\n+            }\n+\n+            bindingPatterns.add(mappingBindingPatternRhs);\n+            mappingBindingPatternMember = parseMappingBindingPatternMember();\n+            bindingPatterns.add(mappingBindingPatternMember);\n+            token = peek();\n+        }\n+\n+        STNode closeBrace = parseCloseBrace();\n+\n+        // seperating out the rest-binding-pattern\n+        STNode restBindingPattern;\n+        if (mappingBindingPatternMember.kind == SyntaxKind.REST_BINDING_PATTERN) {\n+            restBindingPattern = bindingPatterns.remove(bindingPatterns.size() - 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9e616c312e66de69a60a209f2af8be80c64dd5c"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0MTIyMw==", "bodyText": "Should this be moved inside the loop?\nAccording to the grammar, list can be empty too", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23479#discussion_r430841223", "createdAt": "2020-05-27T03:46:37Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -10208,6 +10212,149 @@ private Boolean isFollowTypedBindingPattern(SyntaxKind tokenKind) {\n         }\n     }\n \n+    /**\n+     * Parse mapping-binding-patterns.\n+     *\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     *\n+     * @return mapping-binding-pattern node\n+     */\n+    private STNode parseMappingBindingPattern() {\n+        startContext(ParserRuleContext.MAPPING_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBrace = parseOpenBrace();\n+\n+        STNode mappingBindingPatternMember = parseMappingBindingPatternMember();\n+        bindingPatterns.add(mappingBindingPatternMember);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9e616c312e66de69a60a209f2af8be80c64dd5c"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0MjA3MQ==", "bodyText": "since what this method does is parsing the next token followed by the member, how about parseMappingBindingPatternMemberEnd for method name?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23479#discussion_r430842071", "createdAt": "2020-05-27T03:50:26Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -10208,6 +10212,149 @@ private Boolean isFollowTypedBindingPattern(SyntaxKind tokenKind) {\n         }\n     }\n \n+    /**\n+     * Parse mapping-binding-patterns.\n+     *\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     *\n+     * @return mapping-binding-pattern node\n+     */\n+    private STNode parseMappingBindingPattern() {\n+        startContext(ParserRuleContext.MAPPING_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBrace = parseOpenBrace();\n+\n+        STNode mappingBindingPatternMember = parseMappingBindingPatternMember();\n+        bindingPatterns.add(mappingBindingPatternMember);\n+\n+        // parsing the main chunck of mapping-binding-pattern\n+        STToken token = peek(); // get next valid token\n+        STNode mappingBindingPatternRhs = null;\n+        while (!isEndOfMappingBindingPattern(token.kind) &&\n+                mappingBindingPatternMember.kind != SyntaxKind.REST_BINDING_PATTERN) {\n+            mappingBindingPatternRhs = parseMappingBindingpatternRhs(token.kind);\n+            if (mappingBindingPatternRhs == null) {\n+                break;\n+            }\n+\n+            bindingPatterns.add(mappingBindingPatternRhs);\n+            mappingBindingPatternMember = parseMappingBindingPatternMember();\n+            bindingPatterns.add(mappingBindingPatternMember);\n+            token = peek();\n+        }\n+\n+        STNode closeBrace = parseCloseBrace();\n+\n+        // seperating out the rest-binding-pattern\n+        STNode restBindingPattern;\n+        if (mappingBindingPatternMember.kind == SyntaxKind.REST_BINDING_PATTERN) {\n+            restBindingPattern = bindingPatterns.remove(bindingPatterns.size() - 1);\n+        } else {\n+            restBindingPattern = STNodeFactory.createEmptyNode();\n+        }\n+\n+        STNode bindingPatternsNode = STNodeFactory.createNodeList(bindingPatterns);\n+        endContext();\n+        return STNodeFactory.createMappingBindingPatternNode(openBrace, bindingPatternsNode, restBindingPattern,\n+                closeBrace);\n+    }\n+\n+    /**\n+     * Parse mapping-binding-pattern entry.\n+     *\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     *\n+     * @return mapping-binding-pattern node\n+     */\n+    private STNode parseMappingBindingPatternMember() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case ELLIPSIS_TOKEN:\n+                return parseRestBindingPattern();\n+            default:\n+                return parseFieldBindingPattern();\n+        }\n+    }\n+\n+    private STNode parseMappingBindingpatternRhs() {\n+        return parseMappingBindingpatternRhs(peek().kind);\n+    }\n+\n+    private STNode parseMappingBindingpatternRhs(SyntaxKind nextTokenKind) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9e616c312e66de69a60a209f2af8be80c64dd5c"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0MjE0MA==", "bodyText": "MAPPING_BINDING_PATTERN_MEMBER_END", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23479#discussion_r430842140", "createdAt": "2020-05-27T03:50:46Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -10208,6 +10212,149 @@ private Boolean isFollowTypedBindingPattern(SyntaxKind tokenKind) {\n         }\n     }\n \n+    /**\n+     * Parse mapping-binding-patterns.\n+     *\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     *\n+     * @return mapping-binding-pattern node\n+     */\n+    private STNode parseMappingBindingPattern() {\n+        startContext(ParserRuleContext.MAPPING_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBrace = parseOpenBrace();\n+\n+        STNode mappingBindingPatternMember = parseMappingBindingPatternMember();\n+        bindingPatterns.add(mappingBindingPatternMember);\n+\n+        // parsing the main chunck of mapping-binding-pattern\n+        STToken token = peek(); // get next valid token\n+        STNode mappingBindingPatternRhs = null;\n+        while (!isEndOfMappingBindingPattern(token.kind) &&\n+                mappingBindingPatternMember.kind != SyntaxKind.REST_BINDING_PATTERN) {\n+            mappingBindingPatternRhs = parseMappingBindingpatternRhs(token.kind);\n+            if (mappingBindingPatternRhs == null) {\n+                break;\n+            }\n+\n+            bindingPatterns.add(mappingBindingPatternRhs);\n+            mappingBindingPatternMember = parseMappingBindingPatternMember();\n+            bindingPatterns.add(mappingBindingPatternMember);\n+            token = peek();\n+        }\n+\n+        STNode closeBrace = parseCloseBrace();\n+\n+        // seperating out the rest-binding-pattern\n+        STNode restBindingPattern;\n+        if (mappingBindingPatternMember.kind == SyntaxKind.REST_BINDING_PATTERN) {\n+            restBindingPattern = bindingPatterns.remove(bindingPatterns.size() - 1);\n+        } else {\n+            restBindingPattern = STNodeFactory.createEmptyNode();\n+        }\n+\n+        STNode bindingPatternsNode = STNodeFactory.createNodeList(bindingPatterns);\n+        endContext();\n+        return STNodeFactory.createMappingBindingPatternNode(openBrace, bindingPatternsNode, restBindingPattern,\n+                closeBrace);\n+    }\n+\n+    /**\n+     * Parse mapping-binding-pattern entry.\n+     *\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     *\n+     * @return mapping-binding-pattern node\n+     */\n+    private STNode parseMappingBindingPatternMember() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case ELLIPSIS_TOKEN:\n+                return parseRestBindingPattern();\n+            default:\n+                return parseFieldBindingPattern();\n+        }\n+    }\n+\n+    private STNode parseMappingBindingpatternRhs() {\n+        return parseMappingBindingpatternRhs(peek().kind);\n+    }\n+\n+    private STNode parseMappingBindingpatternRhs(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case COMMA_TOKEN:\n+                return parseComma();\n+            case CLOSE_BRACE_TOKEN:\n+                return null;\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.MAPPING_BINDING_PATTERN_END_OR_CONTINUE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9e616c312e66de69a60a209f2af8be80c64dd5c"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0MjY4NA==", "bodyText": "Should only keep CLOSE_BRACE_TOKEN and EOF_TOKEN and remove others. Because only these two are the ones that we can treat as the 'end' for sure. Anything else should go to recovery.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23479#discussion_r430842684", "createdAt": "2020-05-27T03:53:12Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -10208,6 +10212,149 @@ private Boolean isFollowTypedBindingPattern(SyntaxKind tokenKind) {\n         }\n     }\n \n+    /**\n+     * Parse mapping-binding-patterns.\n+     *\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     *\n+     * @return mapping-binding-pattern node\n+     */\n+    private STNode parseMappingBindingPattern() {\n+        startContext(ParserRuleContext.MAPPING_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBrace = parseOpenBrace();\n+\n+        STNode mappingBindingPatternMember = parseMappingBindingPatternMember();\n+        bindingPatterns.add(mappingBindingPatternMember);\n+\n+        // parsing the main chunck of mapping-binding-pattern\n+        STToken token = peek(); // get next valid token\n+        STNode mappingBindingPatternRhs = null;\n+        while (!isEndOfMappingBindingPattern(token.kind) &&\n+                mappingBindingPatternMember.kind != SyntaxKind.REST_BINDING_PATTERN) {\n+            mappingBindingPatternRhs = parseMappingBindingpatternRhs(token.kind);\n+            if (mappingBindingPatternRhs == null) {\n+                break;\n+            }\n+\n+            bindingPatterns.add(mappingBindingPatternRhs);\n+            mappingBindingPatternMember = parseMappingBindingPatternMember();\n+            bindingPatterns.add(mappingBindingPatternMember);\n+            token = peek();\n+        }\n+\n+        STNode closeBrace = parseCloseBrace();\n+\n+        // seperating out the rest-binding-pattern\n+        STNode restBindingPattern;\n+        if (mappingBindingPatternMember.kind == SyntaxKind.REST_BINDING_PATTERN) {\n+            restBindingPattern = bindingPatterns.remove(bindingPatterns.size() - 1);\n+        } else {\n+            restBindingPattern = STNodeFactory.createEmptyNode();\n+        }\n+\n+        STNode bindingPatternsNode = STNodeFactory.createNodeList(bindingPatterns);\n+        endContext();\n+        return STNodeFactory.createMappingBindingPatternNode(openBrace, bindingPatternsNode, restBindingPattern,\n+                closeBrace);\n+    }\n+\n+    /**\n+     * Parse mapping-binding-pattern entry.\n+     *\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     *\n+     * @return mapping-binding-pattern node\n+     */\n+    private STNode parseMappingBindingPatternMember() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case ELLIPSIS_TOKEN:\n+                return parseRestBindingPattern();\n+            default:\n+                return parseFieldBindingPattern();\n+        }\n+    }\n+\n+    private STNode parseMappingBindingpatternRhs() {\n+        return parseMappingBindingpatternRhs(peek().kind);\n+    }\n+\n+    private STNode parseMappingBindingpatternRhs(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case COMMA_TOKEN:\n+                return parseComma();\n+            case CLOSE_BRACE_TOKEN:\n+                return null;\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.MAPPING_BINDING_PATTERN_END_OR_CONTINUE);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseMappingBindingpatternRhs(solution.tokenKind);\n+        }\n+    }\n+\n+    /**\n+     * Parse field-binding-pattern.\n+     *\n+     * field-binding-pattern := field-name : binding-pattern | varname\n+     *\n+     * @return field-binding-pattern node\n+     */\n+    private STNode parseFieldBindingPattern() {\n+        startContext(ParserRuleContext.FIELD_BINDING_PATTERN);\n+        STNode fieldName = parseVariableName();\n+        STNode colon = STNodeFactory.createEmptyNode();\n+        STNode bindingPattern = STNodeFactory.createEmptyNode();\n+\n+        if (!isEndOfFieldBindingPattern(peek().kind)) {\n+            colon = parseColon();\n+            bindingPattern = parseBindingPattern();\n+        }\n+        endContext();\n+        return STNodeFactory.createFieldBindingPatternNode(fieldName,\n+                colon,\n+                bindingPattern);\n+    }\n+\n+    private boolean isEndOfMappingBindingPattern(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case IN_KEYWORD:\n+            case CLOSE_BRACE_TOKEN:\n+            case EOF_TOKEN:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9e616c312e66de69a60a209f2af8be80c64dd5c"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0MjkxMw==", "bodyText": "replace with a switch case.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23479#discussion_r430842913", "createdAt": "2020-05-27T03:54:24Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -10208,6 +10212,149 @@ private Boolean isFollowTypedBindingPattern(SyntaxKind tokenKind) {\n         }\n     }\n \n+    /**\n+     * Parse mapping-binding-patterns.\n+     *\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     *\n+     * @return mapping-binding-pattern node\n+     */\n+    private STNode parseMappingBindingPattern() {\n+        startContext(ParserRuleContext.MAPPING_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBrace = parseOpenBrace();\n+\n+        STNode mappingBindingPatternMember = parseMappingBindingPatternMember();\n+        bindingPatterns.add(mappingBindingPatternMember);\n+\n+        // parsing the main chunck of mapping-binding-pattern\n+        STToken token = peek(); // get next valid token\n+        STNode mappingBindingPatternRhs = null;\n+        while (!isEndOfMappingBindingPattern(token.kind) &&\n+                mappingBindingPatternMember.kind != SyntaxKind.REST_BINDING_PATTERN) {\n+            mappingBindingPatternRhs = parseMappingBindingpatternRhs(token.kind);\n+            if (mappingBindingPatternRhs == null) {\n+                break;\n+            }\n+\n+            bindingPatterns.add(mappingBindingPatternRhs);\n+            mappingBindingPatternMember = parseMappingBindingPatternMember();\n+            bindingPatterns.add(mappingBindingPatternMember);\n+            token = peek();\n+        }\n+\n+        STNode closeBrace = parseCloseBrace();\n+\n+        // seperating out the rest-binding-pattern\n+        STNode restBindingPattern;\n+        if (mappingBindingPatternMember.kind == SyntaxKind.REST_BINDING_PATTERN) {\n+            restBindingPattern = bindingPatterns.remove(bindingPatterns.size() - 1);\n+        } else {\n+            restBindingPattern = STNodeFactory.createEmptyNode();\n+        }\n+\n+        STNode bindingPatternsNode = STNodeFactory.createNodeList(bindingPatterns);\n+        endContext();\n+        return STNodeFactory.createMappingBindingPatternNode(openBrace, bindingPatternsNode, restBindingPattern,\n+                closeBrace);\n+    }\n+\n+    /**\n+     * Parse mapping-binding-pattern entry.\n+     *\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     *\n+     * @return mapping-binding-pattern node\n+     */\n+    private STNode parseMappingBindingPatternMember() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case ELLIPSIS_TOKEN:\n+                return parseRestBindingPattern();\n+            default:\n+                return parseFieldBindingPattern();\n+        }\n+    }\n+\n+    private STNode parseMappingBindingpatternRhs() {\n+        return parseMappingBindingpatternRhs(peek().kind);\n+    }\n+\n+    private STNode parseMappingBindingpatternRhs(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case COMMA_TOKEN:\n+                return parseComma();\n+            case CLOSE_BRACE_TOKEN:\n+                return null;\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.MAPPING_BINDING_PATTERN_END_OR_CONTINUE);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseMappingBindingpatternRhs(solution.tokenKind);\n+        }\n+    }\n+\n+    /**\n+     * Parse field-binding-pattern.\n+     *\n+     * field-binding-pattern := field-name : binding-pattern | varname\n+     *\n+     * @return field-binding-pattern node\n+     */\n+    private STNode parseFieldBindingPattern() {\n+        startContext(ParserRuleContext.FIELD_BINDING_PATTERN);\n+        STNode fieldName = parseVariableName();\n+        STNode colon = STNodeFactory.createEmptyNode();\n+        STNode bindingPattern = STNodeFactory.createEmptyNode();\n+\n+        if (!isEndOfFieldBindingPattern(peek().kind)) {\n+            colon = parseColon();\n+            bindingPattern = parseBindingPattern();\n+        }\n+        endContext();\n+        return STNodeFactory.createFieldBindingPatternNode(fieldName,\n+                colon,\n+                bindingPattern);\n+    }\n+\n+    private boolean isEndOfMappingBindingPattern(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case IN_KEYWORD:\n+            case CLOSE_BRACE_TOKEN:\n+            case EOF_TOKEN:\n+            case EQUAL_TOKEN:\n+                return true;\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean isEndOfFieldBindingPattern(SyntaxKind nextTokenKind) {\n+        if (isEndOfMappingBindingPattern(nextTokenKind) ||", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9e616c312e66de69a60a209f2af8be80c64dd5c"}, "originalPosition": 158}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0Mzk4Mw==", "bodyText": "Can we live without starting a context?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23479#discussion_r430843983", "createdAt": "2020-05-27T03:59:15Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -10208,6 +10212,149 @@ private Boolean isFollowTypedBindingPattern(SyntaxKind tokenKind) {\n         }\n     }\n \n+    /**\n+     * Parse mapping-binding-patterns.\n+     *\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     *\n+     * @return mapping-binding-pattern node\n+     */\n+    private STNode parseMappingBindingPattern() {\n+        startContext(ParserRuleContext.MAPPING_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBrace = parseOpenBrace();\n+\n+        STNode mappingBindingPatternMember = parseMappingBindingPatternMember();\n+        bindingPatterns.add(mappingBindingPatternMember);\n+\n+        // parsing the main chunck of mapping-binding-pattern\n+        STToken token = peek(); // get next valid token\n+        STNode mappingBindingPatternRhs = null;\n+        while (!isEndOfMappingBindingPattern(token.kind) &&\n+                mappingBindingPatternMember.kind != SyntaxKind.REST_BINDING_PATTERN) {\n+            mappingBindingPatternRhs = parseMappingBindingpatternRhs(token.kind);\n+            if (mappingBindingPatternRhs == null) {\n+                break;\n+            }\n+\n+            bindingPatterns.add(mappingBindingPatternRhs);\n+            mappingBindingPatternMember = parseMappingBindingPatternMember();\n+            bindingPatterns.add(mappingBindingPatternMember);\n+            token = peek();\n+        }\n+\n+        STNode closeBrace = parseCloseBrace();\n+\n+        // seperating out the rest-binding-pattern\n+        STNode restBindingPattern;\n+        if (mappingBindingPatternMember.kind == SyntaxKind.REST_BINDING_PATTERN) {\n+            restBindingPattern = bindingPatterns.remove(bindingPatterns.size() - 1);\n+        } else {\n+            restBindingPattern = STNodeFactory.createEmptyNode();\n+        }\n+\n+        STNode bindingPatternsNode = STNodeFactory.createNodeList(bindingPatterns);\n+        endContext();\n+        return STNodeFactory.createMappingBindingPatternNode(openBrace, bindingPatternsNode, restBindingPattern,\n+                closeBrace);\n+    }\n+\n+    /**\n+     * Parse mapping-binding-pattern entry.\n+     *\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     *\n+     * @return mapping-binding-pattern node\n+     */\n+    private STNode parseMappingBindingPatternMember() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case ELLIPSIS_TOKEN:\n+                return parseRestBindingPattern();\n+            default:\n+                return parseFieldBindingPattern();\n+        }\n+    }\n+\n+    private STNode parseMappingBindingpatternRhs() {\n+        return parseMappingBindingpatternRhs(peek().kind);\n+    }\n+\n+    private STNode parseMappingBindingpatternRhs(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case COMMA_TOKEN:\n+                return parseComma();\n+            case CLOSE_BRACE_TOKEN:\n+                return null;\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.MAPPING_BINDING_PATTERN_END_OR_CONTINUE);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseMappingBindingpatternRhs(solution.tokenKind);\n+        }\n+    }\n+\n+    /**\n+     * Parse field-binding-pattern.\n+     *\n+     * field-binding-pattern := field-name : binding-pattern | varname\n+     *\n+     * @return field-binding-pattern node\n+     */\n+    private STNode parseFieldBindingPattern() {\n+        startContext(ParserRuleContext.FIELD_BINDING_PATTERN);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9e616c312e66de69a60a209f2af8be80c64dd5c"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0NDIzNw==", "bodyText": "MAPPING_BINDING_PATTERN_MEMBER", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23479#discussion_r430844237", "createdAt": "2020-05-27T04:00:20Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -397,14 +397,24 @@\n             { ParserRuleContext.CLOSE_PARENTHESIS, ParserRuleContext.TYPE_DESCRIPTOR };\n \n     private static final ParserRuleContext[] BINDING_PATTERN =\n-            { ParserRuleContext.CAPTURE_BINDING_PATTERN, ParserRuleContext.LIST_BINDING_PATTERN };\n+            { ParserRuleContext.CAPTURE_BINDING_PATTERN, ParserRuleContext.LIST_BINDING_PATTERN,\n+                    ParserRuleContext.MAPPING_BINDING_PATTERN};\n \n     private static final ParserRuleContext[] LIST_BINDING_PATTERN_CONTENTS =\n             { ParserRuleContext.REST_BINDING_PATTERN, ParserRuleContext.BINDING_PATTERN };\n \n+    private static final ParserRuleContext[] MAPPING_BINDING_PATTERN_CONTENTS =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9e616c312e66de69a60a209f2af8be80c64dd5c"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg1Njc3MA==", "bodyText": "Next rule should be \"colon, comma, or close bracket\"", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23479#discussion_r430856770", "createdAt": "2020-05-27T04:56:28Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -3049,7 +3096,11 @@ private ParserRuleContext getNextRuleForVarName() {\n             return getNextRuleForTypedBindingPattern();\n         } else if (parentCtx == ParserRuleContext.REST_BINDING_PATTERN) {\n             return getNextRuleForTypedBindingPattern();\n-        } else if (isStatement(parentCtx) || parentCtx == ParserRuleContext.LISTENER_DECL ||\n+        } else if (parentCtx == ParserRuleContext.FIELD_BINDING_PATTERN) {\n+            return getNextRuleForTypedBindingPattern();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9e616c312e66de69a60a209f2af8be80c64dd5c"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg1ODYyMw==", "bodyText": "Since both of these exist together, I think we should have two separate representations for the two kinds of field-binding-patterns", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23479#discussion_r430858623", "createdAt": "2020-05-27T05:04:09Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-treegen/src/main/resources/syntax_tree_descriptor.json", "diffHunk": "@@ -2917,6 +2917,52 @@\n                 }\n             ]\n         },\n+        {\n+            \"name\": \"MappingBindingPatternNode\",\n+            \"base\": \"BindingPatternNode\",\n+            \"kind\": \"MAPPING_BINDING_PATTERN\",\n+            \"attributes\": [\n+                {\n+                    \"name\": \"openBrace\",\n+                    \"type\": \"Token\"\n+                },\n+                {\n+                    \"name\": \"fieldBindingPatterns\",\n+                    \"type\": \"FieldBindingPatternNode\",\n+                    \"occurrences\": \"MULTIPLE_SEPARATED\"\n+                },\n+                {\n+                    \"name\": \"restBindingPattern\",\n+                    \"type\": \"RestBindingPatternNode\",\n+                    \"isOptional\": true\n+                },\n+                {\n+                    \"name\": \"closeBrace\",\n+                    \"type\": \"Token\"\n+                }\n+            ]\n+        },\n+        {\n+            \"name\": \"FieldBindingPatternNode\",\n+            \"base\": \"Node\",\n+            \"kind\": \"FIELD_BINDING_PATTERN\",\n+            \"attributes\": [\n+                {\n+                    \"name\": \"variableName\",\n+                    \"type\": \"SimpleNameReferenceNode\"\n+                },\n+                {\n+                    \"name\": \"colon\",\n+                    \"type\": \"Token\",\n+                    \"isOptional\": true\n+                },\n+                {\n+                    \"name\": \"bindingPattern\",\n+                    \"type\": \"BindingPatternNode\",\n+                    \"isOptional\": true\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9e616c312e66de69a60a209f2af8be80c64dd5c"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg1OTQzMA==", "bodyText": "Since this can be either field-name or variable-name, we shouldn't use parseVariableName().\nPlease refer to parseWaitField() and parseReceiveField(), those has a similar scenarios.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23479#discussion_r430859430", "createdAt": "2020-05-27T05:07:23Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -10208,6 +10212,149 @@ private Boolean isFollowTypedBindingPattern(SyntaxKind tokenKind) {\n         }\n     }\n \n+    /**\n+     * Parse mapping-binding-patterns.\n+     *\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     *\n+     * @return mapping-binding-pattern node\n+     */\n+    private STNode parseMappingBindingPattern() {\n+        startContext(ParserRuleContext.MAPPING_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBrace = parseOpenBrace();\n+\n+        STNode mappingBindingPatternMember = parseMappingBindingPatternMember();\n+        bindingPatterns.add(mappingBindingPatternMember);\n+\n+        // parsing the main chunck of mapping-binding-pattern\n+        STToken token = peek(); // get next valid token\n+        STNode mappingBindingPatternRhs = null;\n+        while (!isEndOfMappingBindingPattern(token.kind) &&\n+                mappingBindingPatternMember.kind != SyntaxKind.REST_BINDING_PATTERN) {\n+            mappingBindingPatternRhs = parseMappingBindingpatternRhs(token.kind);\n+            if (mappingBindingPatternRhs == null) {\n+                break;\n+            }\n+\n+            bindingPatterns.add(mappingBindingPatternRhs);\n+            mappingBindingPatternMember = parseMappingBindingPatternMember();\n+            bindingPatterns.add(mappingBindingPatternMember);\n+            token = peek();\n+        }\n+\n+        STNode closeBrace = parseCloseBrace();\n+\n+        // seperating out the rest-binding-pattern\n+        STNode restBindingPattern;\n+        if (mappingBindingPatternMember.kind == SyntaxKind.REST_BINDING_PATTERN) {\n+            restBindingPattern = bindingPatterns.remove(bindingPatterns.size() - 1);\n+        } else {\n+            restBindingPattern = STNodeFactory.createEmptyNode();\n+        }\n+\n+        STNode bindingPatternsNode = STNodeFactory.createNodeList(bindingPatterns);\n+        endContext();\n+        return STNodeFactory.createMappingBindingPatternNode(openBrace, bindingPatternsNode, restBindingPattern,\n+                closeBrace);\n+    }\n+\n+    /**\n+     * Parse mapping-binding-pattern entry.\n+     *\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     *\n+     * @return mapping-binding-pattern node\n+     */\n+    private STNode parseMappingBindingPatternMember() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case ELLIPSIS_TOKEN:\n+                return parseRestBindingPattern();\n+            default:\n+                return parseFieldBindingPattern();\n+        }\n+    }\n+\n+    private STNode parseMappingBindingpatternRhs() {\n+        return parseMappingBindingpatternRhs(peek().kind);\n+    }\n+\n+    private STNode parseMappingBindingpatternRhs(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case COMMA_TOKEN:\n+                return parseComma();\n+            case CLOSE_BRACE_TOKEN:\n+                return null;\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.MAPPING_BINDING_PATTERN_END_OR_CONTINUE);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseMappingBindingpatternRhs(solution.tokenKind);\n+        }\n+    }\n+\n+    /**\n+     * Parse field-binding-pattern.\n+     *\n+     * field-binding-pattern := field-name : binding-pattern | varname\n+     *\n+     * @return field-binding-pattern node\n+     */\n+    private STNode parseFieldBindingPattern() {\n+        startContext(ParserRuleContext.FIELD_BINDING_PATTERN);\n+        STNode fieldName = parseVariableName();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9e616c312e66de69a60a209f2af8be80c64dd5c"}, "originalPosition": 131}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c2ce50ee2d02a6f5483fd7d773b46b9b61cbd9de", "author": {"user": {"login": "m36dot", "name": "Saif Abdul Cassim"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c2ce50ee2d02a6f5483fd7d773b46b9b61cbd9de", "committedDate": "2020-05-27T09:58:48Z", "message": "Refactor code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3ca49aa3c22a0e3a32938f10865cb44bfea8f577", "author": {"user": {"login": "m36dot", "name": "Saif Abdul Cassim"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3ca49aa3c22a0e3a32938f10865cb44bfea8f577", "committedDate": "2020-05-27T13:54:05Z", "message": "Refactor Mapping binding Pattern"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "60cd13078d9fb521b7792b73890dc5e3aa7fcb53", "author": {"user": {"login": "m36dot", "name": "Saif Abdul Cassim"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/60cd13078d9fb521b7792b73890dc5e3aa7fcb53", "committedDate": "2020-05-27T13:54:36Z", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into mappingbindingpattern"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1ab321ba6a1d7a74d3fd6f652cb3e27d27894256", "author": {"user": {"login": "m36dot", "name": "Saif Abdul Cassim"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1ab321ba6a1d7a74d3fd6f652cb3e27d27894256", "committedDate": "2020-05-27T13:35:30Z", "message": "Add Maping binding pattern"}, "afterCommit": {"oid": "c2ce50ee2d02a6f5483fd7d773b46b9b61cbd9de", "author": {"user": {"login": "m36dot", "name": "Saif Abdul Cassim"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c2ce50ee2d02a6f5483fd7d773b46b9b61cbd9de", "committedDate": "2020-05-27T09:58:48Z", "message": "Refactor code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bf37765019721e126529d5a02ae4975186ee5620", "author": {"user": {"login": "m36dot", "name": "Saif Abdul Cassim"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/bf37765019721e126529d5a02ae4975186ee5620", "committedDate": "2020-05-28T04:52:38Z", "message": "Refactor how Field binding pattern is parsed"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "61d16c5c72b259abb613d3d9347c479fafdc71a9", "author": {"user": {"login": "m36dot", "name": "Saif Abdul Cassim"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/61d16c5c72b259abb613d3d9347c479fafdc71a9", "committedDate": "2020-05-28T05:04:01Z", "message": "Change assert to incorporate mapping binding pattern in recovery"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "47c117cb8e4c7754500432a9e1165f0096d2e52f", "author": {"user": {"login": "m36dot", "name": "Saif Abdul Cassim"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/47c117cb8e4c7754500432a9e1165f0096d2e52f", "committedDate": "2020-05-28T05:15:04Z", "message": "Fix merge conflicts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4a70be8d4bc9c5a8450d75cd755dd4d7a3c0e886", "author": {"user": {"login": "m36dot", "name": "Saif Abdul Cassim"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/4a70be8d4bc9c5a8450d75cd755dd4d7a3c0e886", "committedDate": "2020-05-28T06:27:57Z", "message": "Fix spotbugs and checkstyle issues"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwNjE0OTM2", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23479#pullrequestreview-420614936", "createdAt": "2020-05-29T02:34:15Z", "commit": {"oid": "4a70be8d4bc9c5a8450d75cd755dd4d7a3c0e886"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4544, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}