{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzU5ODg3ODg4", "number": 20541, "title": "Add observability (metrics and tracing) to Kafka connector", "bodyText": "Purpose\nAdd observability (metrics and tracing) to Kafka connector", "createdAt": "2020-01-07T08:54:23Z", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541", "merged": true, "mergeCommit": {"oid": "c3f9853812ab8bd5c3868a80535401d709c33965"}, "closed": true, "closedAt": "2020-01-20T09:32:51Z", "author": {"login": "kaneeldias"}, "timelineItems": {"totalCount": 28, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb4SQ3WABqjI5MzA1MjAwNzI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABb8JJlcAFqTM0NTE3NDYyMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b053a969d8ecc3272ab72a918e9ebe17b90b787c", "author": {"user": {"login": "kaneeldias", "name": "Kaneel Dias"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b053a969d8ecc3272ab72a918e9ebe17b90b787c", "committedDate": "2020-01-07T08:52:15Z", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into kafka-observability"}, "afterCommit": {"oid": "05eed3df9a6b72d1a85a09a9bfc7844ed20224fc", "author": {"user": {"login": "kaneeldias", "name": "Kaneel Dias"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/05eed3df9a6b72d1a85a09a9bfc7844ed20224fc", "committedDate": "2020-01-08T09:49:40Z", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into kafka-observability"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "05eed3df9a6b72d1a85a09a9bfc7844ed20224fc", "author": {"user": {"login": "kaneeldias", "name": "Kaneel Dias"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/05eed3df9a6b72d1a85a09a9bfc7844ed20224fc", "committedDate": "2020-01-08T09:49:40Z", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into kafka-observability"}, "afterCommit": {"oid": "23fc14a844b861aaa296b4bfbe8c5cc473faa755", "author": {"user": {"login": "kaneeldias", "name": "Kaneel Dias"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/23fc14a844b861aaa296b4bfbe8c5cc473faa755", "committedDate": "2020-01-08T09:52:17Z", "message": "Add observability (metrics and tracing) to Kafka connector"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQxNTU2MzA2", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#pullrequestreview-341556306", "createdAt": "2020-01-12T06:34:03Z", "commit": {"oid": "23fc14a844b861aaa296b4bfbe8c5cc473faa755"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMlQwNjozNDowNFrOFcoEmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMlQwNjozNDowNFrOFcoEmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU2MDk4Ng==", "bodyText": "Is NATIVE_CONSUMER_CONFIG always present? Cause otherwise, getNativeData can return Null. Therefore possible NPE.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#discussion_r365560986", "createdAt": "2020-01-12T06:34:04Z", "author": {"login": "grainier"}, "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/impl/KafkaListenerImpl.java", "diffHunk": "@@ -59,8 +70,9 @@ public KafkaListenerImpl(Strand strand, ObjectValue listener, ObjectValue servic\n     @Override\n     public void onRecordsReceived(ConsumerRecords records, KafkaConsumer kafkaConsumer, String groupId) {\n         listener.addNativeData(NATIVE_CONSUMER, kafkaConsumer);\n-        Executor.submit(this.scheduler, service, KAFKA_RESOURCE_ON_MESSAGE, callback,\n-                null, getResourceParameters(service, this.listener, records, groupId));\n+        String url = ((Properties) listener.getNativeData(NATIVE_CONSUMER_CONFIG)).getProperty(BOOTSTRAP_SERVERS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "23fc14a844b861aaa296b4bfbe8c5cc473faa755"}, "originalPosition": 36}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQxNTU2Mzg0", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#pullrequestreview-341556384", "createdAt": "2020-01-12T06:37:13Z", "commit": {"oid": "23fc14a844b861aaa296b4bfbe8c5cc473faa755"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMlQwNjozNzoxM1rOFcoFAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMlQwNjozNzoxM1rOFcoFAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU2MTA4OA==", "bodyText": "Why this line has to repeat all the time? Can't we resolve URL at the init and then re-use it?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#discussion_r365561088", "createdAt": "2020-01-12T06:37:13Z", "author": {"login": "grainier"}, "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/impl/KafkaListenerImpl.java", "diffHunk": "@@ -83,6 +95,38 @@ public void onRecordsReceived(ConsumerRecords records,\n     @Override\n     public void onError(Throwable throwable) {\n         logger.error(\"Kafka Ballerina server connector retrieved exception: \" + throwable.getMessage(), throwable);\n+        String url = ((Properties) listener.getNativeData(NATIVE_CONSUMER_CONFIG)).getProperty(BOOTSTRAP_SERVERS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "23fc14a844b861aaa296b4bfbe8c5cc473faa755"}, "originalPosition": 63}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQxNTU2NTk3", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#pullrequestreview-341556597", "createdAt": "2020-01-12T06:45:07Z", "commit": {"oid": "23fc14a844b861aaa296b4bfbe8c5cc473faa755"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMlQwNjo0NTowN1rOFcoGCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMlQwNjo0NTowN1rOFcoGCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU2MTM1NA==", "bodyText": "This is repeated in 120-125. Can't we refactor?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#discussion_r365561354", "createdAt": "2020-01-12T06:45:07Z", "author": {"login": "grainier"}, "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/impl/KafkaListenerImpl.java", "diffHunk": "@@ -83,6 +95,38 @@ public void onRecordsReceived(ConsumerRecords records,\n     @Override\n     public void onError(Throwable throwable) {\n         logger.error(\"Kafka Ballerina server connector retrieved exception: \" + throwable.getMessage(), throwable);\n+        String url = ((Properties) listener.getNativeData(NATIVE_CONSUMER_CONFIG)).getProperty(BOOTSTRAP_SERVERS);\n+        KafkaMetricsUtil.reportConsumerError(url, KafkaObservabilityConstants.ERROR_TYPE_MSG_RECEIVED);\n+    }\n+\n+    private void executeResource(String url, ConsumerRecords records, String groupId) {\n+        if (ObserveUtils.isTracingEnabled()) {\n+            Map<String, Object> properties = new HashMap<>();\n+            KafkaObserverContext observerContext = new KafkaObserverContext(\n+                    KafkaObservabilityConstants.CONTEXT_CONSUMER, url);\n+            properties.put(ObservabilityConstants.KEY_OBSERVER_CONTEXT, observerContext);\n+            Executor.submit(this.scheduler, service, KAFKA_RESOURCE_ON_MESSAGE, callback,\n+                            properties, getResourceParameters(service, this.listener, records, groupId));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "23fc14a844b861aaa296b4bfbe8c5cc473faa755"}, "originalPosition": 74}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQxNTU2Nzcz", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#pullrequestreview-341556773", "createdAt": "2020-01-12T06:49:52Z", "commit": {"oid": "23fc14a844b861aaa296b4bfbe8c5cc473faa755"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMlQwNjo0OTo1M1rOFcoG4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMlQwNjo0OTo1M1rOFcoG4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU2MTU3MQ==", "bodyText": "Declare with interface (or super) type.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#discussion_r365561571", "createdAt": "2020-01-12T06:49:53Z", "author": {"login": "grainier"}, "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/nativeimpl/consumer/Assign.java", "diffHunk": "@@ -41,11 +46,14 @@\n     private static final Logger logger = LoggerFactory.getLogger(Assign.class);\n \n     public static Object assign(ObjectValue consumerObject, ArrayValue topicPartitions) {\n+        String bootstrapServers = KafkaUtils.getBootstrapServers(consumerObject);\n+        KafkaTracingUtil.traceResourceInvocation(Scheduler.getStrand(), bootstrapServers);\n         KafkaConsumer<byte[], byte[]> kafkaConsumer = (KafkaConsumer) consumerObject.getNativeData(NATIVE_CONSUMER);\n         ArrayList<TopicPartition> partitions = getTopicPartitionList(topicPartitions, logger);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "23fc14a844b861aaa296b4bfbe8c5cc473faa755"}, "originalPosition": 21}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "23fc14a844b861aaa296b4bfbe8c5cc473faa755", "author": {"user": {"login": "kaneeldias", "name": "Kaneel Dias"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/23fc14a844b861aaa296b4bfbe8c5cc473faa755", "committedDate": "2020-01-08T09:52:17Z", "message": "Add observability (metrics and tracing) to Kafka connector"}, "afterCommit": {"oid": "a62e9877d1b606a8d0227f1fb097dd58918b04f4", "author": {"user": {"login": "kaneeldias", "name": "Kaneel Dias"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a62e9877d1b606a8d0227f1fb097dd58918b04f4", "committedDate": "2020-01-13T05:34:32Z", "message": "Add observability (metrics and tracing) to Kafka connector"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a62e9877d1b606a8d0227f1fb097dd58918b04f4", "author": {"user": {"login": "kaneeldias", "name": "Kaneel Dias"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a62e9877d1b606a8d0227f1fb097dd58918b04f4", "committedDate": "2020-01-13T05:34:32Z", "message": "Add observability (metrics and tracing) to Kafka connector"}, "afterCommit": {"oid": "495d5f1f92d833cdebfdd986c5470289ee92cb47", "author": {"user": {"login": "kaneeldias", "name": "Kaneel Dias"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/495d5f1f92d833cdebfdd986c5470289ee92cb47", "committedDate": "2020-01-13T05:47:19Z", "message": "Add observability (metrics and tracing) to Kafka connector"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "495d5f1f92d833cdebfdd986c5470289ee92cb47", "author": {"user": {"login": "kaneeldias", "name": "Kaneel Dias"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/495d5f1f92d833cdebfdd986c5470289ee92cb47", "committedDate": "2020-01-13T05:47:19Z", "message": "Add observability (metrics and tracing) to Kafka connector"}, "afterCommit": {"oid": "eb0c4d08a3da553ca61d23bdaff916fd1f64ba8f", "author": {"user": {"login": "kaneeldias", "name": "Kaneel Dias"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/eb0c4d08a3da553ca61d23bdaff916fd1f64ba8f", "committedDate": "2020-01-13T06:09:14Z", "message": "Add observability (metrics and tracing) to Kafka connector"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "eb0c4d08a3da553ca61d23bdaff916fd1f64ba8f", "author": {"user": {"login": "kaneeldias", "name": "Kaneel Dias"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/eb0c4d08a3da553ca61d23bdaff916fd1f64ba8f", "committedDate": "2020-01-13T06:09:14Z", "message": "Add observability (metrics and tracing) to Kafka connector"}, "afterCommit": {"oid": "67338734d987580144b7c58daa78a3176925d414", "author": {"user": {"login": "kaneeldias", "name": "Kaneel Dias"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/67338734d987580144b7c58daa78a3176925d414", "committedDate": "2020-01-13T06:15:38Z", "message": "Add observability (metrics and tracing) to Kafka connector"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "67338734d987580144b7c58daa78a3176925d414", "author": {"user": {"login": "kaneeldias", "name": "Kaneel Dias"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/67338734d987580144b7c58daa78a3176925d414", "committedDate": "2020-01-13T06:15:38Z", "message": "Add observability (metrics and tracing) to Kafka connector"}, "afterCommit": {"oid": "b03ab6c782a7f44878926a72bb6639c4a77a3bd3", "author": {"user": {"login": "kaneeldias", "name": "Kaneel Dias"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b03ab6c782a7f44878926a72bb6639c4a77a3bd3", "committedDate": "2020-01-13T07:41:40Z", "message": "Add observability (metrics and tracing) to Kafka connector"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b03ab6c782a7f44878926a72bb6639c4a77a3bd3", "author": {"user": {"login": "kaneeldias", "name": "Kaneel Dias"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b03ab6c782a7f44878926a72bb6639c4a77a3bd3", "committedDate": "2020-01-13T07:41:40Z", "message": "Add observability (metrics and tracing) to Kafka connector"}, "afterCommit": {"oid": "edbad225b205e517825119ded44a06483595d436", "author": {"user": {"login": "kaneeldias", "name": "Kaneel Dias"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/edbad225b205e517825119ded44a06483595d436", "committedDate": "2020-01-14T06:11:29Z", "message": "Add observability (metrics and tracing) to Kafka connector"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0MzY2NDI4", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#pullrequestreview-344366428", "createdAt": "2020-01-17T05:10:11Z", "commit": {"oid": "edbad225b205e517825119ded44a06483595d436"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwNToxMDoxMVrOFeu_zw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwNTo0Njo0OVrOFevYmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc3MTU5OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final Logger logger = LoggerFactory.getLogger(Close.class);\n          \n          \n            \n                private static final Logger logger = LoggerFactory.getLogger(CommitOffset.class);", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#discussion_r367771599", "createdAt": "2020-01-17T05:10:11Z", "author": {"login": "chamil321"}, "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/nativeimpl/consumer/CommitOffset.java", "diffHunk": "@@ -49,6 +53,7 @@\n     private static final Logger logger = LoggerFactory.getLogger(Close.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "edbad225b205e517825119ded44a06483595d436"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc3MTg2OA==", "bodyText": "Indentation issue?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#discussion_r367771868", "createdAt": "2020-01-17T05:11:43Z", "author": {"login": "chamil321"}, "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/nativeimpl/consumer/Connect.java", "diffHunk": "@@ -46,16 +51,23 @@ public static Object connect(ObjectValue consumerObject) {\n         // Check whether already native consumer is attached to the struct.\n         // This can be happen either from Kafka service or via programmatically.\n         if (Objects.nonNull(consumerObject.getNativeData(NATIVE_CONSUMER))) {\n+            KafkaMetricsUtil.reportConsumerError(consumerObject, KafkaObservabilityConstants.ERROR_TYPE_CONNECTION);\n             return createKafkaError(\"Kafka consumer is already connected to external broker. \" +\n-                    \"Please close it before re-connecting the external broker again.\", CONSUMER_ERROR);\n+                                            \"Please close it before re-connecting the external broker again.\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "edbad225b205e517825119ded44a06483595d436"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc3MzczNw==", "bodyText": "Ideally the method should be changed to avoid getting Strand as a parameter.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#discussion_r367773737", "createdAt": "2020-01-17T05:22:17Z", "author": {"login": "chamil321"}, "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/nativeimpl/consumer/SubscribeWithPartitionRebalance.java", "diffHunk": "@@ -68,16 +71,19 @@\n \n     public static Object subscribeWithPartitionRebalance(Strand strand, ObjectValue consumerObject, ArrayValue topics,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "edbad225b205e517825119ded44a06483595d436"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc3Mzg4NQ==", "bodyText": "use Scheduler.getStrand() here as well. The parameter should be avoided", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#discussion_r367773885", "createdAt": "2020-01-17T05:23:05Z", "author": {"login": "chamil321"}, "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/nativeimpl/consumer/SubscribeWithPartitionRebalance.java", "diffHunk": "@@ -68,16 +71,19 @@\n \n     public static Object subscribeWithPartitionRebalance(Strand strand, ObjectValue consumerObject, ArrayValue topics,\n                                                          FPValue onPartitionsRevoked, FPValue onPartitionsAssigned) {\n-\n+        KafkaTracingUtil.traceResourceInvocation(Scheduler.getStrand(), consumerObject);\n         NonBlockingCallback callback = new NonBlockingCallback(strand);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "edbad225b205e517825119ded44a06483595d436"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc3NDMwOA==", "bodyText": "This should have been done during the kafka - Java interop task. Must have missed", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#discussion_r367774308", "createdAt": "2020-01-17T05:25:35Z", "author": {"login": "chamil321"}, "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/nativeimpl/consumer/SubscribeWithPartitionRebalance.java", "diffHunk": "@@ -68,16 +71,19 @@\n \n     public static Object subscribeWithPartitionRebalance(Strand strand, ObjectValue consumerObject, ArrayValue topics,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc3MzczNw=="}, "originalCommit": {"oid": "edbad225b205e517825119ded44a06483595d436"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc3NDc3NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Reports a new producer connection.\n          \n          \n            \n                 * Reports a new consumer connection.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#discussion_r367774774", "createdAt": "2020-01-17T05:28:05Z", "author": {"login": "chamil321"}, "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/observability/KafkaMetricsUtil.java", "diffHunk": "@@ -0,0 +1,364 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.ballerinalang.messaging.kafka.observability;\n+\n+import org.apache.kafka.clients.consumer.ConsumerRecord;\n+import org.apache.kafka.clients.consumer.ConsumerRecords;\n+import org.ballerinalang.jvm.observability.ObserveUtils;\n+import org.ballerinalang.jvm.observability.metrics.DefaultMetricRegistry;\n+import org.ballerinalang.jvm.observability.metrics.MetricId;\n+import org.ballerinalang.jvm.observability.metrics.MetricRegistry;\n+import org.ballerinalang.jvm.values.ObjectValue;\n+import org.ballerinalang.messaging.kafka.utils.KafkaUtils;\n+\n+import java.util.Set;\n+\n+/**\n+ * Providing metrics functionality to the Kafka. connector\n+ *\n+ * @since 1.1.0\n+ */\n+public class KafkaMetricsUtil {\n+\n+    private static final MetricRegistry metricRegistry = DefaultMetricRegistry.getInstance();\n+\n+    /**\n+     * Reports a new producer connection.\n+     *\n+     * @param producerObject producerObject.\n+     */\n+    public static void reportNewProducer(ObjectValue producerObject) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_PRODUCER,\n+                                                                        KafkaUtils.getClientId(producerObject),\n+                                                                        KafkaUtils.getBootstrapServers(producerObject));\n+        incrementGauge(observerContext, KafkaObservabilityConstants.METRIC_PUBLISHERS[0],\n+                       KafkaObservabilityConstants.METRIC_PUBLISHERS[1]);\n+    }\n+\n+    /**\n+     * Reports a new producer connection.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "edbad225b205e517825119ded44a06483595d436"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc3NzE1Mg==", "bodyText": "Shall we created separate method for unsetGauge rather having a integer parameter to distinguish the logic?\nIt is more clearer and consistent with other methods.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#discussion_r367777152", "createdAt": "2020-01-17T05:42:06Z", "author": {"login": "chamil321"}, "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/observability/KafkaMetricsUtil.java", "diffHunk": "@@ -0,0 +1,364 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.ballerinalang.messaging.kafka.observability;\n+\n+import org.apache.kafka.clients.consumer.ConsumerRecord;\n+import org.apache.kafka.clients.consumer.ConsumerRecords;\n+import org.ballerinalang.jvm.observability.ObserveUtils;\n+import org.ballerinalang.jvm.observability.metrics.DefaultMetricRegistry;\n+import org.ballerinalang.jvm.observability.metrics.MetricId;\n+import org.ballerinalang.jvm.observability.metrics.MetricRegistry;\n+import org.ballerinalang.jvm.values.ObjectValue;\n+import org.ballerinalang.messaging.kafka.utils.KafkaUtils;\n+\n+import java.util.Set;\n+\n+/**\n+ * Providing metrics functionality to the Kafka. connector\n+ *\n+ * @since 1.1.0\n+ */\n+public class KafkaMetricsUtil {\n+\n+    private static final MetricRegistry metricRegistry = DefaultMetricRegistry.getInstance();\n+\n+    /**\n+     * Reports a new producer connection.\n+     *\n+     * @param producerObject producerObject.\n+     */\n+    public static void reportNewProducer(ObjectValue producerObject) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_PRODUCER,\n+                                                                        KafkaUtils.getClientId(producerObject),\n+                                                                        KafkaUtils.getBootstrapServers(producerObject));\n+        incrementGauge(observerContext, KafkaObservabilityConstants.METRIC_PUBLISHERS[0],\n+                       KafkaObservabilityConstants.METRIC_PUBLISHERS[1]);\n+    }\n+\n+    /**\n+     * Reports a new producer connection.\n+     *\n+     * @param consumerObject consumer object\n+     */\n+    public static void reportNewConsumer(ObjectValue consumerObject) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_CONSUMER,\n+                                                                        KafkaUtils.getClientId(consumerObject),\n+                                                                        KafkaUtils.getBootstrapServers(consumerObject));\n+        incrementGauge(observerContext, KafkaObservabilityConstants.METRIC_CONSUMERS[0],\n+                       KafkaObservabilityConstants.METRIC_CONSUMERS[1]);\n+    }\n+\n+    /**\n+     * Reports a producer disconnection.\n+     *\n+     * @param producerObject producer object.\n+     */\n+    public static void reportProducerClose(ObjectValue producerObject) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_PRODUCER,\n+                                                                        KafkaUtils.getClientId(producerObject),\n+                                                                        KafkaUtils.getBootstrapServers(producerObject));\n+        decrementGauge(observerContext, KafkaObservabilityConstants.METRIC_PUBLISHERS[0],\n+                       KafkaObservabilityConstants.METRIC_PUBLISHERS[1]);\n+    }\n+\n+    /**\n+     * Reports a consumer close.\n+     *\n+     * @param consumerObject consumer object.\n+     */\n+    public static void reportConsumerClose(ObjectValue consumerObject) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_CONSUMER,\n+                                                                        KafkaUtils.getClientId(consumerObject),\n+                                                                        KafkaUtils.getBootstrapServers(consumerObject));\n+        decrementGauge(observerContext, KafkaObservabilityConstants.METRIC_CONSUMERS[0],\n+                       KafkaObservabilityConstants.METRIC_CONSUMERS[1]);\n+    }\n+\n+    /**\n+     * Reports a message being published by a Kafka producer.\n+     *\n+     * @param producerObject  producer object.\n+     * @param topic Subject the message is published to.\n+     * @param size  Size in bytes of the message.\n+     */\n+    public static void reportPublish(ObjectValue producerObject, String topic, int size) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_PRODUCER,\n+                                                                        KafkaUtils.getClientId(producerObject),\n+                                                                        KafkaUtils.getBootstrapServers(producerObject),\n+                                                                        topic);\n+        reportPublish(observerContext, size);\n+    }\n+\n+    /**\n+     * Reports a consumer subscribing to a subject.\n+     *\n+     * @param consumerObject    Consumer object.\n+     * @param topicsList        List of topics that the consumer subscribes to.\n+     */\n+    public static void reportBulkSubscription(ObjectValue consumerObject, Set<String> topicsList) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        for (String topic : topicsList) {\n+            reportSubscription(consumerObject, topic);\n+        }\n+    }\n+\n+\n+    /**\n+     * Reports a consumer subscribing to a topic.\n+     *\n+     * @param consumerObject    Consumer object.\n+     * @param topic             Topic that the consumer subscribes to.\n+     */\n+    public static void reportSubscription(ObjectValue consumerObject, String topic) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_CONSUMER,\n+                                                                        KafkaUtils.getClientId(consumerObject),\n+                                                                        KafkaUtils.getBootstrapServers(consumerObject),\n+                                                                        topic);\n+        setGauge(observerContext, KafkaObservabilityConstants.METRIC_SUBSCRIPTION[0],\n+                       KafkaObservabilityConstants.METRIC_SUBSCRIPTION[1], 1);\n+    }\n+\n+    /**\n+     * Reports a consumer unsubscribing from a subject.\n+     *\n+     * @param consumerObject    Consumer object.\n+     * @param topic             Subject that the consumer unsubscribes from.\n+     */\n+    public static void reportUnsubscription(ObjectValue consumerObject, String topic) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_CONSUMER,\n+                                                                        KafkaUtils.getClientId(consumerObject),\n+                                                                        KafkaUtils.getBootstrapServers(consumerObject),\n+                                                                        topic);\n+        setGauge(observerContext, KafkaObservabilityConstants.METRIC_SUBSCRIPTION[0],", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "edbad225b205e517825119ded44a06483595d436"}, "originalPosition": 171}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc3NzgyMg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Constants for NATS Observability.\n          \n          \n            \n             * Constants for Kafka Observability.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#discussion_r367777822", "createdAt": "2020-01-17T05:46:06Z", "author": {"login": "chamil321"}, "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/observability/KafkaObservabilityConstants.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.ballerinalang.messaging.kafka.observability;\n+\n+/**\n+ * Constants for NATS Observability.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "edbad225b205e517825119ded44a06483595d436"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc3Nzk0Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Extension of ObserverContext for NATS.\n          \n          \n            \n             * Extension of ObserverContext for Kafka.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#discussion_r367777947", "createdAt": "2020-01-17T05:46:49Z", "author": {"login": "chamil321"}, "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/observability/KafkaObserverContext.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.ballerinalang.messaging.kafka.observability;\n+\n+import org.ballerinalang.jvm.observability.ObserverContext;\n+import org.ballerinalang.jvm.observability.metrics.Tag;\n+import org.ballerinalang.jvm.observability.metrics.Tags;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Extension of ObserverContext for NATS.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "edbad225b205e517825119ded44a06483595d436"}, "originalPosition": 30}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "edbad225b205e517825119ded44a06483595d436", "author": {"user": {"login": "kaneeldias", "name": "Kaneel Dias"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/edbad225b205e517825119ded44a06483595d436", "committedDate": "2020-01-14T06:11:29Z", "message": "Add observability (metrics and tracing) to Kafka connector"}, "afterCommit": {"oid": "dff95d227db71e659b3a9f90678ee7c3d50076f5", "author": {"user": {"login": "kaneeldias", "name": "Kaneel Dias"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/dff95d227db71e659b3a9f90678ee7c3d50076f5", "committedDate": "2020-01-17T11:01:53Z", "message": "Add observability (metrics and tracing) to Kafka connector"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0NTEyMTA0", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#pullrequestreview-344512104", "createdAt": "2020-01-17T11:13:40Z", "commit": {"oid": "dff95d227db71e659b3a9f90678ee7c3d50076f5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxMToxMzo0MFrOFe1-XQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxMToxMzo0MFrOFe1-XQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg4NTkxNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * @since 1.1.0\n          \n          \n            \n             * @since 1.2.0", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#discussion_r367885917", "createdAt": "2020-01-17T11:13:40Z", "author": {"login": "wggihan"}, "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/observability/KafkaMetricsUtil.java", "diffHunk": "@@ -0,0 +1,373 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.ballerinalang.messaging.kafka.observability;\n+\n+import org.apache.kafka.clients.consumer.ConsumerRecord;\n+import org.apache.kafka.clients.consumer.ConsumerRecords;\n+import org.ballerinalang.jvm.observability.ObserveUtils;\n+import org.ballerinalang.jvm.observability.metrics.DefaultMetricRegistry;\n+import org.ballerinalang.jvm.observability.metrics.MetricId;\n+import org.ballerinalang.jvm.observability.metrics.MetricRegistry;\n+import org.ballerinalang.jvm.values.ObjectValue;\n+import org.ballerinalang.messaging.kafka.utils.KafkaUtils;\n+\n+import java.util.Set;\n+\n+/**\n+ * Providing metrics functionality to the Kafka connector.\n+ *\n+ * @since 1.1.0", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dff95d227db71e659b3a9f90678ee7c3d50076f5"}, "originalPosition": 35}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0NTEyOTAx", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#pullrequestreview-344512901", "createdAt": "2020-01-17T11:15:24Z", "commit": {"oid": "dff95d227db71e659b3a9f90678ee7c3d50076f5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxMToxNToyNVrOFe2Axw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxMToxNToyNVrOFe2Axw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg4NjUzNQ==", "bodyText": "Extra line.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#discussion_r367886535", "createdAt": "2020-01-17T11:15:25Z", "author": {"login": "wggihan"}, "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/observability/KafkaMetricsUtil.java", "diffHunk": "@@ -0,0 +1,373 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.ballerinalang.messaging.kafka.observability;\n+\n+import org.apache.kafka.clients.consumer.ConsumerRecord;\n+import org.apache.kafka.clients.consumer.ConsumerRecords;\n+import org.ballerinalang.jvm.observability.ObserveUtils;\n+import org.ballerinalang.jvm.observability.metrics.DefaultMetricRegistry;\n+import org.ballerinalang.jvm.observability.metrics.MetricId;\n+import org.ballerinalang.jvm.observability.metrics.MetricRegistry;\n+import org.ballerinalang.jvm.values.ObjectValue;\n+import org.ballerinalang.messaging.kafka.utils.KafkaUtils;\n+\n+import java.util.Set;\n+\n+/**\n+ * Providing metrics functionality to the Kafka connector.\n+ *\n+ * @since 1.1.0\n+ */\n+public class KafkaMetricsUtil {\n+\n+    private static final MetricRegistry metricRegistry = DefaultMetricRegistry.getInstance();\n+\n+    /**\n+     * Reports a new producer connection.\n+     *\n+     * @param producerObject producerObject.\n+     */\n+    public static void reportNewProducer(ObjectValue producerObject) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_PRODUCER,\n+                                                                        KafkaUtils.getClientId(producerObject),\n+                                                                        KafkaUtils.getBootstrapServers(producerObject));\n+        incrementGauge(observerContext, KafkaObservabilityConstants.METRIC_PUBLISHERS[0],\n+                       KafkaObservabilityConstants.METRIC_PUBLISHERS[1]);\n+    }\n+\n+    /**\n+     * Reports a new consumer connection.\n+     *\n+     * @param consumerObject consumer object\n+     */\n+    public static void reportNewConsumer(ObjectValue consumerObject) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_CONSUMER,\n+                                                                        KafkaUtils.getClientId(consumerObject),\n+                                                                        KafkaUtils.getBootstrapServers(consumerObject));\n+        incrementGauge(observerContext, KafkaObservabilityConstants.METRIC_CONSUMERS[0],\n+                       KafkaObservabilityConstants.METRIC_CONSUMERS[1]);\n+    }\n+\n+    /**\n+     * Reports a producer disconnection.\n+     *\n+     * @param producerObject producer object.\n+     */\n+    public static void reportProducerClose(ObjectValue producerObject) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_PRODUCER,\n+                                                                        KafkaUtils.getClientId(producerObject),\n+                                                                        KafkaUtils.getBootstrapServers(producerObject));\n+        decrementGauge(observerContext, KafkaObservabilityConstants.METRIC_PUBLISHERS[0],\n+                       KafkaObservabilityConstants.METRIC_PUBLISHERS[1]);\n+    }\n+\n+    /**\n+     * Reports a consumer close.\n+     *\n+     * @param consumerObject consumer object.\n+     */\n+    public static void reportConsumerClose(ObjectValue consumerObject) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_CONSUMER,\n+                                                                        KafkaUtils.getClientId(consumerObject),\n+                                                                        KafkaUtils.getBootstrapServers(consumerObject));\n+        decrementGauge(observerContext, KafkaObservabilityConstants.METRIC_CONSUMERS[0],\n+                       KafkaObservabilityConstants.METRIC_CONSUMERS[1]);\n+    }\n+\n+    /**\n+     * Reports a message being published by a Kafka producer.\n+     *\n+     * @param producerObject  producer object.\n+     * @param topic Subject the message is published to.\n+     * @param size  Size in bytes of the message.\n+     */\n+    public static void reportPublish(ObjectValue producerObject, String topic, int size) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_PRODUCER,\n+                                                                        KafkaUtils.getClientId(producerObject),\n+                                                                        KafkaUtils.getBootstrapServers(producerObject),\n+                                                                        topic);\n+        reportPublish(observerContext, size);\n+    }\n+\n+    /**\n+     * Reports a consumer subscribing to a subject.\n+     *\n+     * @param consumerObject    Consumer object.\n+     * @param topicsList        List of topics that the consumer subscribes to.\n+     */\n+    public static void reportBulkSubscription(ObjectValue consumerObject, Set<String> topicsList) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        for (String topic : topicsList) {\n+            reportSubscription(consumerObject, topic);\n+        }\n+    }\n+\n+\n+    /**\n+     * Reports a consumer subscribing to a topic.\n+     *\n+     * @param consumerObject    Consumer object.\n+     * @param topic             Topic that the consumer subscribes to.\n+     */\n+    public static void reportSubscription(ObjectValue consumerObject, String topic) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_CONSUMER,\n+                                                                        KafkaUtils.getClientId(consumerObject),\n+                                                                        KafkaUtils.getBootstrapServers(consumerObject),\n+                                                                        topic);\n+        setGauge(observerContext, KafkaObservabilityConstants.METRIC_SUBSCRIPTION[0],\n+                       KafkaObservabilityConstants.METRIC_SUBSCRIPTION[1], 1);\n+    }\n+\n+    /**\n+     * Reports a consumer unsubscribing from a subject.\n+     *\n+     * @param consumerObject    Consumer object.\n+     * @param topic             Subject that the consumer unsubscribes from.\n+     */\n+    public static void reportUnsubscription(ObjectValue consumerObject, String topic) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_CONSUMER,\n+                                                                        KafkaUtils.getClientId(consumerObject),\n+                                                                        KafkaUtils.getBootstrapServers(consumerObject),\n+                                                                        topic);\n+        resetGauge(observerContext, KafkaObservabilityConstants.METRIC_SUBSCRIPTION[0],\n+                       KafkaObservabilityConstants.METRIC_SUBSCRIPTION[1]);\n+    }\n+\n+    /**\n+     * Reports a consumer unsubscribing from multiple topics.\n+     *\n+     * @param consumerObject    Consumer object.\n+     * @param topics            Subjects that the consumer unsubscribes from.\n+     */\n+    public static void reportBulkUnsubscription(ObjectValue consumerObject, Set<String> topics) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        for (String subject : topics) {\n+            KafkaMetricsUtil.reportUnsubscription(consumerObject, subject);\n+        }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dff95d227db71e659b3a9f90678ee7c3d50076f5"}, "originalPosition": 188}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0NTEzMzM0", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#pullrequestreview-344513334", "createdAt": "2020-01-17T11:16:19Z", "commit": {"oid": "dff95d227db71e659b3a9f90678ee7c3d50076f5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxMToxNjoyMFrOFe2CMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxMToxNjoyMFrOFe2CMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg4Njg5Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Reports a consumer consuming a message.\n          \n          \n            \n                 * Reports a message consumption of the consumer.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#discussion_r367886897", "createdAt": "2020-01-17T11:16:20Z", "author": {"login": "wggihan"}, "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/observability/KafkaMetricsUtil.java", "diffHunk": "@@ -0,0 +1,373 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.ballerinalang.messaging.kafka.observability;\n+\n+import org.apache.kafka.clients.consumer.ConsumerRecord;\n+import org.apache.kafka.clients.consumer.ConsumerRecords;\n+import org.ballerinalang.jvm.observability.ObserveUtils;\n+import org.ballerinalang.jvm.observability.metrics.DefaultMetricRegistry;\n+import org.ballerinalang.jvm.observability.metrics.MetricId;\n+import org.ballerinalang.jvm.observability.metrics.MetricRegistry;\n+import org.ballerinalang.jvm.values.ObjectValue;\n+import org.ballerinalang.messaging.kafka.utils.KafkaUtils;\n+\n+import java.util.Set;\n+\n+/**\n+ * Providing metrics functionality to the Kafka connector.\n+ *\n+ * @since 1.1.0\n+ */\n+public class KafkaMetricsUtil {\n+\n+    private static final MetricRegistry metricRegistry = DefaultMetricRegistry.getInstance();\n+\n+    /**\n+     * Reports a new producer connection.\n+     *\n+     * @param producerObject producerObject.\n+     */\n+    public static void reportNewProducer(ObjectValue producerObject) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_PRODUCER,\n+                                                                        KafkaUtils.getClientId(producerObject),\n+                                                                        KafkaUtils.getBootstrapServers(producerObject));\n+        incrementGauge(observerContext, KafkaObservabilityConstants.METRIC_PUBLISHERS[0],\n+                       KafkaObservabilityConstants.METRIC_PUBLISHERS[1]);\n+    }\n+\n+    /**\n+     * Reports a new consumer connection.\n+     *\n+     * @param consumerObject consumer object\n+     */\n+    public static void reportNewConsumer(ObjectValue consumerObject) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_CONSUMER,\n+                                                                        KafkaUtils.getClientId(consumerObject),\n+                                                                        KafkaUtils.getBootstrapServers(consumerObject));\n+        incrementGauge(observerContext, KafkaObservabilityConstants.METRIC_CONSUMERS[0],\n+                       KafkaObservabilityConstants.METRIC_CONSUMERS[1]);\n+    }\n+\n+    /**\n+     * Reports a producer disconnection.\n+     *\n+     * @param producerObject producer object.\n+     */\n+    public static void reportProducerClose(ObjectValue producerObject) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_PRODUCER,\n+                                                                        KafkaUtils.getClientId(producerObject),\n+                                                                        KafkaUtils.getBootstrapServers(producerObject));\n+        decrementGauge(observerContext, KafkaObservabilityConstants.METRIC_PUBLISHERS[0],\n+                       KafkaObservabilityConstants.METRIC_PUBLISHERS[1]);\n+    }\n+\n+    /**\n+     * Reports a consumer close.\n+     *\n+     * @param consumerObject consumer object.\n+     */\n+    public static void reportConsumerClose(ObjectValue consumerObject) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_CONSUMER,\n+                                                                        KafkaUtils.getClientId(consumerObject),\n+                                                                        KafkaUtils.getBootstrapServers(consumerObject));\n+        decrementGauge(observerContext, KafkaObservabilityConstants.METRIC_CONSUMERS[0],\n+                       KafkaObservabilityConstants.METRIC_CONSUMERS[1]);\n+    }\n+\n+    /**\n+     * Reports a message being published by a Kafka producer.\n+     *\n+     * @param producerObject  producer object.\n+     * @param topic Subject the message is published to.\n+     * @param size  Size in bytes of the message.\n+     */\n+    public static void reportPublish(ObjectValue producerObject, String topic, int size) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_PRODUCER,\n+                                                                        KafkaUtils.getClientId(producerObject),\n+                                                                        KafkaUtils.getBootstrapServers(producerObject),\n+                                                                        topic);\n+        reportPublish(observerContext, size);\n+    }\n+\n+    /**\n+     * Reports a consumer subscribing to a subject.\n+     *\n+     * @param consumerObject    Consumer object.\n+     * @param topicsList        List of topics that the consumer subscribes to.\n+     */\n+    public static void reportBulkSubscription(ObjectValue consumerObject, Set<String> topicsList) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        for (String topic : topicsList) {\n+            reportSubscription(consumerObject, topic);\n+        }\n+    }\n+\n+\n+    /**\n+     * Reports a consumer subscribing to a topic.\n+     *\n+     * @param consumerObject    Consumer object.\n+     * @param topic             Topic that the consumer subscribes to.\n+     */\n+    public static void reportSubscription(ObjectValue consumerObject, String topic) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_CONSUMER,\n+                                                                        KafkaUtils.getClientId(consumerObject),\n+                                                                        KafkaUtils.getBootstrapServers(consumerObject),\n+                                                                        topic);\n+        setGauge(observerContext, KafkaObservabilityConstants.METRIC_SUBSCRIPTION[0],\n+                       KafkaObservabilityConstants.METRIC_SUBSCRIPTION[1], 1);\n+    }\n+\n+    /**\n+     * Reports a consumer unsubscribing from a subject.\n+     *\n+     * @param consumerObject    Consumer object.\n+     * @param topic             Subject that the consumer unsubscribes from.\n+     */\n+    public static void reportUnsubscription(ObjectValue consumerObject, String topic) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_CONSUMER,\n+                                                                        KafkaUtils.getClientId(consumerObject),\n+                                                                        KafkaUtils.getBootstrapServers(consumerObject),\n+                                                                        topic);\n+        resetGauge(observerContext, KafkaObservabilityConstants.METRIC_SUBSCRIPTION[0],\n+                       KafkaObservabilityConstants.METRIC_SUBSCRIPTION[1]);\n+    }\n+\n+    /**\n+     * Reports a consumer unsubscribing from multiple topics.\n+     *\n+     * @param consumerObject    Consumer object.\n+     * @param topics            Subjects that the consumer unsubscribes from.\n+     */\n+    public static void reportBulkUnsubscription(ObjectValue consumerObject, Set<String> topics) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        for (String subject : topics) {\n+            KafkaMetricsUtil.reportUnsubscription(consumerObject, subject);\n+        }\n+\n+    }\n+\n+    /**\n+     * Reports a consumer consuming a message.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dff95d227db71e659b3a9f90678ee7c3d50076f5"}, "originalPosition": 192}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0NTE0MjUw", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#pullrequestreview-344514250", "createdAt": "2020-01-17T11:18:10Z", "commit": {"oid": "dff95d227db71e659b3a9f90678ee7c3d50076f5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxMToxODoxMFrOFe2E9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxMToxODoxMFrOFe2E9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg4NzYwNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * @since 1.1.0\n          \n          \n            \n             * @since 1.2.0", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#discussion_r367887607", "createdAt": "2020-01-17T11:18:10Z", "author": {"login": "wggihan"}, "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/observability/KafkaObservabilityConstants.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.ballerinalang.messaging.kafka.observability;\n+\n+/**\n+ * Constants for Kafka Observability.\n+ *\n+ * @since 1.1.0", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dff95d227db71e659b3a9f90678ee7c3d50076f5"}, "originalPosition": 24}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0NTE0NDM5", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#pullrequestreview-344514439", "createdAt": "2020-01-17T11:18:35Z", "commit": {"oid": "dff95d227db71e659b3a9f90678ee7c3d50076f5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxMToxODozNVrOFe2Ffg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxMToxODozNVrOFe2Ffg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg4Nzc0Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * @since 1.1.0\n          \n          \n            \n             * @since 1.2.0", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#discussion_r367887742", "createdAt": "2020-01-17T11:18:35Z", "author": {"login": "wggihan"}, "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/observability/KafkaObserverContext.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.ballerinalang.messaging.kafka.observability;\n+\n+import org.ballerinalang.jvm.observability.ObserverContext;\n+import org.ballerinalang.jvm.observability.metrics.Tag;\n+import org.ballerinalang.jvm.observability.metrics.Tags;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Extension of ObserverContext for Kafka.\n+ *\n+ * @since 1.1.0", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dff95d227db71e659b3a9f90678ee7c3d50076f5"}, "originalPosition": 32}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0NTE0NzA0", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#pullrequestreview-344514704", "createdAt": "2020-01-17T11:19:06Z", "commit": {"oid": "dff95d227db71e659b3a9f90678ee7c3d50076f5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxMToxOTowNlrOFe2GQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxMToxOTowNlrOFe2GQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg4NzkzNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * @since 1.1.0\n          \n          \n            \n             * @since 1.2.0", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#discussion_r367887936", "createdAt": "2020-01-17T11:19:06Z", "author": {"login": "wggihan"}, "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/observability/KafkaTracingUtil.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.ballerinalang.messaging.kafka.observability;\n+\n+import org.ballerinalang.jvm.observability.ObserveUtils;\n+import org.ballerinalang.jvm.observability.ObserverContext;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.values.ObjectValue;\n+import org.ballerinalang.messaging.kafka.utils.KafkaUtils;\n+\n+import java.util.Optional;\n+\n+/**\n+ * Providing tracing functionality to Kafka.\n+ *\n+ * @since 1.1.0", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dff95d227db71e659b3a9f90678ee7c3d50076f5"}, "originalPosition": 32}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0NTE4Mjgw", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#pullrequestreview-344518280", "createdAt": "2020-01-17T11:26:19Z", "commit": {"oid": "dff95d227db71e659b3a9f90678ee7c3d50076f5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxMToyNjoxOVrOFe2Q-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxMToyNjoxOVrOFe2Q-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg5MDY4MA==", "bodyText": "Don't catch NPE. Handle null value. Apply to other places as well.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#discussion_r367890680", "createdAt": "2020-01-17T11:26:19Z", "author": {"login": "wggihan"}, "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/utils/KafkaUtils.java", "diffHunk": "@@ -689,4 +695,34 @@ public static String getBrokerNames(ObjectValue listener) {\n     public static String getTopicNamesString(ArrayList<String> topicsList) {\n         return String.join(\", \", topicsList);\n     }\n+\n+    public static String getClientIdFromProperties(Properties properties) {\n+        String clientId = properties.getProperty(KafkaConstants.CLIENT_ID);\n+        if (clientId == null) {\n+            return KafkaObservabilityConstants.UNKNOWN;\n+        }\n+        return  clientId;\n+    }\n+\n+    public static String getBootstrapServers(ObjectValue object) {\n+        try {\n+            return (String) object.getNativeData(KafkaConstants.BOOTSTRAP_SERVERS);\n+        } catch (NullPointerException ex) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dff95d227db71e659b3a9f90678ee7c3d50076f5"}, "originalPosition": 362}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "dff95d227db71e659b3a9f90678ee7c3d50076f5", "author": {"user": {"login": "kaneeldias", "name": "Kaneel Dias"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/dff95d227db71e659b3a9f90678ee7c3d50076f5", "committedDate": "2020-01-17T11:01:53Z", "message": "Add observability (metrics and tracing) to Kafka connector"}, "afterCommit": {"oid": "686745345044b18037d8f38ab3480fab94f4dfa1", "author": {"user": {"login": "kaneeldias", "name": "Kaneel Dias"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/686745345044b18037d8f38ab3480fab94f4dfa1", "committedDate": "2020-01-17T11:33:01Z", "message": "Add observability (metrics and tracing) to Kafka connector"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0NTcwNjY0", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#pullrequestreview-344570664", "createdAt": "2020-01-17T13:17:57Z", "commit": {"oid": "686745345044b18037d8f38ab3480fab94f4dfa1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxMzoxNzo1N1rOFe4rpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxMzoxNzo1N1rOFe4rpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkzMDI3OQ==", "bodyText": "Extra line.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#discussion_r367930279", "createdAt": "2020-01-17T13:17:57Z", "author": {"login": "wggihan"}, "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/utils/KafkaUtils.java", "diffHunk": "@@ -689,4 +695,39 @@ public static String getBrokerNames(ObjectValue listener) {\n     public static String getTopicNamesString(ArrayList<String> topicsList) {\n         return String.join(\", \", topicsList);\n     }\n+\n+    public static String getClientIdFromProperties(Properties properties) {\n+        if (properties == null) {\n+            return KafkaObservabilityConstants.UNKNOWN;\n+        }\n+        String clientId = properties.getProperty(KafkaConstants.CLIENT_ID);\n+        if (clientId == null) {\n+            return KafkaObservabilityConstants.UNKNOWN;\n+        }\n+        return  clientId;\n+    }\n+\n+    public static String getBootstrapServers(ObjectValue object) {\n+        if (object == null) {\n+            return KafkaObservabilityConstants.UNKNOWN;\n+        }\n+        String bootstrapServers = (String) object.getNativeData(KafkaConstants.BOOTSTRAP_SERVERS);\n+        if (bootstrapServers == null) {\n+            return KafkaObservabilityConstants.UNKNOWN;\n+        }\n+        return bootstrapServers;\n+    }\n+\n+    public static String getClientId(ObjectValue object) {\n+        if (object == null) {\n+            return KafkaObservabilityConstants.UNKNOWN;\n+        }\n+        String clientId = (String) object.getNativeData(KafkaConstants.CLIENT_ID);\n+        if (clientId == null) {\n+            return KafkaObservabilityConstants.UNKNOWN;\n+        }\n+        return clientId;\n+    }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "686745345044b18037d8f38ab3480fab94f4dfa1"}, "originalPosition": 383}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0OTc3MjY1", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#pullrequestreview-344977265", "createdAt": "2020-01-19T05:07:28Z", "commit": {"oid": "686745345044b18037d8f38ab3480fab94f4dfa1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOVQwNTowNzoyOVrOFfNMLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOVQwNTowNzoyOVrOFfNMLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI2NjI4NA==", "bodyText": "Extra empty line?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#discussion_r368266284", "createdAt": "2020-01-19T05:07:29Z", "author": {"login": "ThisaruGuruge"}, "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/observability/KafkaMetricsUtil.java", "diffHunk": "@@ -0,0 +1,372 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.ballerinalang.messaging.kafka.observability;\n+\n+import org.apache.kafka.clients.consumer.ConsumerRecord;\n+import org.apache.kafka.clients.consumer.ConsumerRecords;\n+import org.ballerinalang.jvm.observability.ObserveUtils;\n+import org.ballerinalang.jvm.observability.metrics.DefaultMetricRegistry;\n+import org.ballerinalang.jvm.observability.metrics.MetricId;\n+import org.ballerinalang.jvm.observability.metrics.MetricRegistry;\n+import org.ballerinalang.jvm.values.ObjectValue;\n+import org.ballerinalang.messaging.kafka.utils.KafkaUtils;\n+\n+import java.util.Set;\n+\n+/**\n+ * Providing metrics functionality to the Kafka connector.\n+ *\n+ * @since 1.2.0\n+ */\n+public class KafkaMetricsUtil {\n+\n+    private static final MetricRegistry metricRegistry = DefaultMetricRegistry.getInstance();\n+\n+    /**\n+     * Reports a new producer connection.\n+     *\n+     * @param producerObject producerObject.\n+     */\n+    public static void reportNewProducer(ObjectValue producerObject) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_PRODUCER,\n+                                                                        KafkaUtils.getClientId(producerObject),\n+                                                                        KafkaUtils.getBootstrapServers(producerObject));\n+        incrementGauge(observerContext, KafkaObservabilityConstants.METRIC_PUBLISHERS[0],\n+                       KafkaObservabilityConstants.METRIC_PUBLISHERS[1]);\n+    }\n+\n+    /**\n+     * Reports a new consumer connection.\n+     *\n+     * @param consumerObject consumer object\n+     */\n+    public static void reportNewConsumer(ObjectValue consumerObject) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_CONSUMER,\n+                                                                        KafkaUtils.getClientId(consumerObject),\n+                                                                        KafkaUtils.getBootstrapServers(consumerObject));\n+        incrementGauge(observerContext, KafkaObservabilityConstants.METRIC_CONSUMERS[0],\n+                       KafkaObservabilityConstants.METRIC_CONSUMERS[1]);\n+    }\n+\n+    /**\n+     * Reports a producer disconnection.\n+     *\n+     * @param producerObject producer object.\n+     */\n+    public static void reportProducerClose(ObjectValue producerObject) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_PRODUCER,\n+                                                                        KafkaUtils.getClientId(producerObject),\n+                                                                        KafkaUtils.getBootstrapServers(producerObject));\n+        decrementGauge(observerContext, KafkaObservabilityConstants.METRIC_PUBLISHERS[0],\n+                       KafkaObservabilityConstants.METRIC_PUBLISHERS[1]);\n+    }\n+\n+    /**\n+     * Reports a consumer close.\n+     *\n+     * @param consumerObject consumer object.\n+     */\n+    public static void reportConsumerClose(ObjectValue consumerObject) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_CONSUMER,\n+                                                                        KafkaUtils.getClientId(consumerObject),\n+                                                                        KafkaUtils.getBootstrapServers(consumerObject));\n+        decrementGauge(observerContext, KafkaObservabilityConstants.METRIC_CONSUMERS[0],\n+                       KafkaObservabilityConstants.METRIC_CONSUMERS[1]);\n+    }\n+\n+    /**\n+     * Reports a message being published by a Kafka producer.\n+     *\n+     * @param producerObject  producer object.\n+     * @param topic Subject the message is published to.\n+     * @param size  Size in bytes of the message.\n+     */\n+    public static void reportPublish(ObjectValue producerObject, String topic, int size) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_PRODUCER,\n+                                                                        KafkaUtils.getClientId(producerObject),\n+                                                                        KafkaUtils.getBootstrapServers(producerObject),\n+                                                                        topic);\n+        reportPublish(observerContext, size);\n+    }\n+\n+    /**\n+     * Reports a consumer subscribing to a subject.\n+     *\n+     * @param consumerObject    Consumer object.\n+     * @param topicsList        List of topics that the consumer subscribes to.\n+     */\n+    public static void reportBulkSubscription(ObjectValue consumerObject, Set<String> topicsList) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        for (String topic : topicsList) {\n+            reportSubscription(consumerObject, topic);\n+        }\n+    }\n+\n+\n+    /**\n+     * Reports a consumer subscribing to a topic.\n+     *\n+     * @param consumerObject    Consumer object.\n+     * @param topic             Topic that the consumer subscribes to.\n+     */\n+    public static void reportSubscription(ObjectValue consumerObject, String topic) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_CONSUMER,\n+                                                                        KafkaUtils.getClientId(consumerObject),\n+                                                                        KafkaUtils.getBootstrapServers(consumerObject),\n+                                                                        topic);\n+        setGauge(observerContext, KafkaObservabilityConstants.METRIC_SUBSCRIPTION[0],\n+                       KafkaObservabilityConstants.METRIC_SUBSCRIPTION[1], 1);\n+    }\n+\n+    /**\n+     * Reports a consumer unsubscribing from a subject.\n+     *\n+     * @param consumerObject    Consumer object.\n+     * @param topic             Subject that the consumer unsubscribes from.\n+     */\n+    public static void reportUnsubscription(ObjectValue consumerObject, String topic) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_CONSUMER,\n+                                                                        KafkaUtils.getClientId(consumerObject),\n+                                                                        KafkaUtils.getBootstrapServers(consumerObject),\n+                                                                        topic);\n+        resetGauge(observerContext, KafkaObservabilityConstants.METRIC_SUBSCRIPTION[0],\n+                       KafkaObservabilityConstants.METRIC_SUBSCRIPTION[1]);\n+    }\n+\n+    /**\n+     * Reports a consumer unsubscribing from multiple topics.\n+     *\n+     * @param consumerObject    Consumer object.\n+     * @param topics            Subjects that the consumer unsubscribes from.\n+     */\n+    public static void reportBulkUnsubscription(ObjectValue consumerObject, Set<String> topics) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        for (String subject : topics) {\n+            KafkaMetricsUtil.reportUnsubscription(consumerObject, subject);\n+        }\n+    }\n+\n+    /**\n+     * Reports a message consumption of a consumer.\n+     *\n+     * @param consumerObject    Consumer object.\n+     * @param topic             Subject that the consumer receives the message from.\n+     * @param size              Size of the message in bytes.\n+     */\n+    public static void reportConsume(ObjectValue consumerObject, String topic, int size) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_CONSUMER,\n+                                                                        KafkaUtils.getClientId(consumerObject),\n+                                                                        KafkaUtils.getBootstrapServers(consumerObject),\n+                                                                        topic);\n+        reportConsume(observerContext, size);\n+    }\n+\n+    /**\n+     * Reports a consumer consuming a record of messages.\n+     *\n+     * @param consumerObject    Consumer object.\n+     * @param records           Records\n+     */\n+    public static void reportConsume(ObjectValue consumerObject, ConsumerRecords records) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        records.forEach(record -> {\n+            KafkaMetricsUtil.reportConsume(consumerObject, ((ConsumerRecord) record).topic(),\n+                                           ((ConsumerRecord) record).serializedValueSize());\n+        });\n+    }\n+\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "686745345044b18037d8f38ab3480fab94f4dfa1"}, "originalPosition": 224}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0OTc3Mjgy", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#pullrequestreview-344977282", "createdAt": "2020-01-19T05:07:55Z", "commit": {"oid": "686745345044b18037d8f38ab3480fab94f4dfa1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOVQwNTowNzo1NVrOFfNMNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOVQwNTowNzo1NVrOFfNMNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI2NjI5NA==", "bodyText": "Extra empty line?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#discussion_r368266294", "createdAt": "2020-01-19T05:07:55Z", "author": {"login": "ThisaruGuruge"}, "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/observability/KafkaMetricsUtil.java", "diffHunk": "@@ -0,0 +1,372 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.ballerinalang.messaging.kafka.observability;\n+\n+import org.apache.kafka.clients.consumer.ConsumerRecord;\n+import org.apache.kafka.clients.consumer.ConsumerRecords;\n+import org.ballerinalang.jvm.observability.ObserveUtils;\n+import org.ballerinalang.jvm.observability.metrics.DefaultMetricRegistry;\n+import org.ballerinalang.jvm.observability.metrics.MetricId;\n+import org.ballerinalang.jvm.observability.metrics.MetricRegistry;\n+import org.ballerinalang.jvm.values.ObjectValue;\n+import org.ballerinalang.messaging.kafka.utils.KafkaUtils;\n+\n+import java.util.Set;\n+\n+/**\n+ * Providing metrics functionality to the Kafka connector.\n+ *\n+ * @since 1.2.0\n+ */\n+public class KafkaMetricsUtil {\n+\n+    private static final MetricRegistry metricRegistry = DefaultMetricRegistry.getInstance();\n+\n+    /**\n+     * Reports a new producer connection.\n+     *\n+     * @param producerObject producerObject.\n+     */\n+    public static void reportNewProducer(ObjectValue producerObject) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_PRODUCER,\n+                                                                        KafkaUtils.getClientId(producerObject),\n+                                                                        KafkaUtils.getBootstrapServers(producerObject));\n+        incrementGauge(observerContext, KafkaObservabilityConstants.METRIC_PUBLISHERS[0],\n+                       KafkaObservabilityConstants.METRIC_PUBLISHERS[1]);\n+    }\n+\n+    /**\n+     * Reports a new consumer connection.\n+     *\n+     * @param consumerObject consumer object\n+     */\n+    public static void reportNewConsumer(ObjectValue consumerObject) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_CONSUMER,\n+                                                                        KafkaUtils.getClientId(consumerObject),\n+                                                                        KafkaUtils.getBootstrapServers(consumerObject));\n+        incrementGauge(observerContext, KafkaObservabilityConstants.METRIC_CONSUMERS[0],\n+                       KafkaObservabilityConstants.METRIC_CONSUMERS[1]);\n+    }\n+\n+    /**\n+     * Reports a producer disconnection.\n+     *\n+     * @param producerObject producer object.\n+     */\n+    public static void reportProducerClose(ObjectValue producerObject) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_PRODUCER,\n+                                                                        KafkaUtils.getClientId(producerObject),\n+                                                                        KafkaUtils.getBootstrapServers(producerObject));\n+        decrementGauge(observerContext, KafkaObservabilityConstants.METRIC_PUBLISHERS[0],\n+                       KafkaObservabilityConstants.METRIC_PUBLISHERS[1]);\n+    }\n+\n+    /**\n+     * Reports a consumer close.\n+     *\n+     * @param consumerObject consumer object.\n+     */\n+    public static void reportConsumerClose(ObjectValue consumerObject) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_CONSUMER,\n+                                                                        KafkaUtils.getClientId(consumerObject),\n+                                                                        KafkaUtils.getBootstrapServers(consumerObject));\n+        decrementGauge(observerContext, KafkaObservabilityConstants.METRIC_CONSUMERS[0],\n+                       KafkaObservabilityConstants.METRIC_CONSUMERS[1]);\n+    }\n+\n+    /**\n+     * Reports a message being published by a Kafka producer.\n+     *\n+     * @param producerObject  producer object.\n+     * @param topic Subject the message is published to.\n+     * @param size  Size in bytes of the message.\n+     */\n+    public static void reportPublish(ObjectValue producerObject, String topic, int size) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_PRODUCER,\n+                                                                        KafkaUtils.getClientId(producerObject),\n+                                                                        KafkaUtils.getBootstrapServers(producerObject),\n+                                                                        topic);\n+        reportPublish(observerContext, size);\n+    }\n+\n+    /**\n+     * Reports a consumer subscribing to a subject.\n+     *\n+     * @param consumerObject    Consumer object.\n+     * @param topicsList        List of topics that the consumer subscribes to.\n+     */\n+    public static void reportBulkSubscription(ObjectValue consumerObject, Set<String> topicsList) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        for (String topic : topicsList) {\n+            reportSubscription(consumerObject, topic);\n+        }\n+    }\n+\n+\n+    /**\n+     * Reports a consumer subscribing to a topic.\n+     *\n+     * @param consumerObject    Consumer object.\n+     * @param topic             Topic that the consumer subscribes to.\n+     */\n+    public static void reportSubscription(ObjectValue consumerObject, String topic) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_CONSUMER,\n+                                                                        KafkaUtils.getClientId(consumerObject),\n+                                                                        KafkaUtils.getBootstrapServers(consumerObject),\n+                                                                        topic);\n+        setGauge(observerContext, KafkaObservabilityConstants.METRIC_SUBSCRIPTION[0],\n+                       KafkaObservabilityConstants.METRIC_SUBSCRIPTION[1], 1);\n+    }\n+\n+    /**\n+     * Reports a consumer unsubscribing from a subject.\n+     *\n+     * @param consumerObject    Consumer object.\n+     * @param topic             Subject that the consumer unsubscribes from.\n+     */\n+    public static void reportUnsubscription(ObjectValue consumerObject, String topic) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_CONSUMER,\n+                                                                        KafkaUtils.getClientId(consumerObject),\n+                                                                        KafkaUtils.getBootstrapServers(consumerObject),\n+                                                                        topic);\n+        resetGauge(observerContext, KafkaObservabilityConstants.METRIC_SUBSCRIPTION[0],\n+                       KafkaObservabilityConstants.METRIC_SUBSCRIPTION[1]);\n+    }\n+\n+    /**\n+     * Reports a consumer unsubscribing from multiple topics.\n+     *\n+     * @param consumerObject    Consumer object.\n+     * @param topics            Subjects that the consumer unsubscribes from.\n+     */\n+    public static void reportBulkUnsubscription(ObjectValue consumerObject, Set<String> topics) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        for (String subject : topics) {\n+            KafkaMetricsUtil.reportUnsubscription(consumerObject, subject);\n+        }\n+    }\n+\n+    /**\n+     * Reports a message consumption of a consumer.\n+     *\n+     * @param consumerObject    Consumer object.\n+     * @param topic             Subject that the consumer receives the message from.\n+     * @param size              Size of the message in bytes.\n+     */\n+    public static void reportConsume(ObjectValue consumerObject, String topic, int size) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_CONSUMER,\n+                                                                        KafkaUtils.getClientId(consumerObject),\n+                                                                        KafkaUtils.getBootstrapServers(consumerObject),\n+                                                                        topic);\n+        reportConsume(observerContext, size);\n+    }\n+\n+    /**\n+     * Reports a consumer consuming a record of messages.\n+     *\n+     * @param consumerObject    Consumer object.\n+     * @param records           Records\n+     */\n+    public static void reportConsume(ObjectValue consumerObject, ConsumerRecords records) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        records.forEach(record -> {\n+            KafkaMetricsUtil.reportConsume(consumerObject, ((ConsumerRecord) record).topic(),\n+                                           ((ConsumerRecord) record).serializedValueSize());\n+        });\n+    }\n+\n+\n+    /**\n+     * Reports an error generated by a producer. This method is called when the URL/subject of the current producer is\n+     * unknown. e.g. when a Kafka connection doesn't exist for a producer.\n+     *\n+     * @param producerObject    Producer object.\n+     * @param errorType         Type of the error.\n+     */\n+    public static void reportProducerError(ObjectValue producerObject, String errorType) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        reportError(KafkaObservabilityConstants.CONTEXT_PRODUCER, producerObject, errorType);\n+    }\n+\n+    /**\n+     * Reports an error generated by a consumer. This method is called when the URL/subject of the current consumer is\n+     * unknown. e.g. when a Kafka connection doesn't exist for a consumer.\n+     *\n+     * @param errorType type of the error.\n+     */\n+    public static void reportConsumerError(String errorType) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        reportError(KafkaObservabilityConstants.CONTEXT_CONSUMER, errorType);\n+    }\n+\n+    /**\n+     * Reports an error generated by a consumer. This method is called when the URL/subject of the current consumer is\n+     * unknown. e.g. when a Kafka connection doesn't exist for a consumer.\n+     *\n+     * @param consumerObject    Consumer object.\n+     * @param errorType         Type of the error.\n+     */\n+    public static void reportConsumerError(ObjectValue consumerObject, String errorType) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        reportError(KafkaObservabilityConstants.CONTEXT_CONSUMER, consumerObject, errorType);\n+    }\n+\n+    /**\n+     * Reports an error generated by a consumer.\n+     *\n+     * @param consumerObject    Consumer object.\n+     * @param topic             Subject that the consumer is subscribed to.\n+     * @param errorType         Type of the error.\n+     */\n+    public static void reportConsumerError(ObjectValue consumerObject, String topic, String errorType) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        reportError(consumerObject, topic, KafkaObservabilityConstants.CONTEXT_CONSUMER, errorType);\n+    }\n+\n+    private static void reportPublish(KafkaObserverContext observerContext, int size) {\n+        incrementCounter(observerContext, KafkaObservabilityConstants.METRIC_PUBLISHED[0],\n+                         KafkaObservabilityConstants.METRIC_PUBLISHED[1]);\n+        incrementCounter(observerContext, KafkaObservabilityConstants.METRIC_PUBLISHED_SIZE[0],\n+                         KafkaObservabilityConstants.METRIC_PUBLISHED_SIZE[1], size);\n+    }\n+\n+    private static void reportConsume(KafkaObserverContext observerContext, int size) {\n+        incrementCounter(observerContext, KafkaObservabilityConstants.METRIC_CONSUMED[0],\n+                         KafkaObservabilityConstants.METRIC_CONSUMED[1]);\n+        incrementCounter(observerContext, KafkaObservabilityConstants.METRIC_CONSUMED_SIZE[0],\n+                         KafkaObservabilityConstants.METRIC_CONSUMED_SIZE[1], size);\n+    }\n+\n+    public static void reportError(String context, String errorType) {\n+        KafkaObserverContext observerContext = new KafkaObserverContext(context);\n+        observerContext.addTag(KafkaObservabilityConstants.TAG_ERROR_TYPE, errorType);\n+        incrementCounter(observerContext, KafkaObservabilityConstants.METRIC_ERRORS[0],\n+                         KafkaObservabilityConstants.METRIC_ERRORS[1]);\n+    }\n+\n+    public static void reportError(String context, ObjectValue object, String errorType) {\n+        KafkaObserverContext observerContext = new KafkaObserverContext(context,\n+                                                                        KafkaUtils.getClientId(object),\n+                                                                        KafkaUtils.getBootstrapServers(object));\n+        observerContext.addTag(KafkaObservabilityConstants.TAG_ERROR_TYPE, errorType);\n+        incrementCounter(observerContext, KafkaObservabilityConstants.METRIC_ERRORS[0],\n+                         KafkaObservabilityConstants.METRIC_ERRORS[1]);\n+    }\n+\n+    public static void reportError(ObjectValue object, String topic, String context, String errorType) {\n+        KafkaObserverContext observerContext = new KafkaObserverContext(context,\n+                                                                        KafkaUtils.getClientId(object),\n+                                                                        KafkaUtils.getBootstrapServers(object),\n+                                                                        topic);\n+        observerContext.addTag(KafkaObservabilityConstants.TAG_ERROR_TYPE, errorType);\n+        incrementCounter(observerContext, KafkaObservabilityConstants.METRIC_ERRORS[0],\n+                         KafkaObservabilityConstants.METRIC_ERRORS[1]);\n+    }\n+\n+    private static void incrementCounter(KafkaObserverContext observerContext, String name, String desc) {\n+        incrementCounter(observerContext, name, desc, 1);\n+    }\n+\n+    private static void incrementCounter(KafkaObserverContext observerContext, String name, String desc, int amount) {\n+        if (metricRegistry == null) {\n+            return;\n+        }\n+        metricRegistry.counter(new MetricId(\n+                KafkaObservabilityConstants.CONNECTOR_NAME + \"_\" + name, desc, observerContext.getAllTags()))\n+                .increment(amount);\n+    }\n+\n+    private static void incrementGauge(KafkaObserverContext observerContext, String name, String desc) {\n+        if (metricRegistry == null) {\n+            return;\n+        }\n+        metricRegistry.gauge(new MetricId(\n+                KafkaObservabilityConstants.CONNECTOR_NAME + \"_\" + name, desc, observerContext.getAllTags()))\n+                .increment();\n+    }\n+\n+    private static void decrementGauge(KafkaObserverContext observerContext, String name, String desc) {\n+        if (metricRegistry == null) {\n+            return;\n+        }\n+        metricRegistry.gauge(new MetricId(\n+                KafkaObservabilityConstants.CONNECTOR_NAME + \"_\" + name, desc, observerContext.getAllTags()))\n+                .decrement();\n+    }\n+\n+    private static void setGauge(KafkaObserverContext observerContext, String name, String desc, int value) {\n+        if (metricRegistry == null) {\n+            return;\n+        }\n+        metricRegistry.gauge(new MetricId(\n+                KafkaObservabilityConstants.CONNECTOR_NAME + \"_\" + name, desc, observerContext.getAllTags()))\n+                .setValue(value);\n+    }\n+\n+    private static void resetGauge(KafkaObserverContext observerContext, String name, String desc) {\n+        if (metricRegistry == null) {\n+            return;\n+        }\n+        metricRegistry.gauge(new MetricId(\n+                KafkaObservabilityConstants.CONNECTOR_NAME + \"_\" + name, desc, observerContext.getAllTags()))\n+                .setValue(0);\n+    }\n+\n+    private KafkaMetricsUtil() {\n+    }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "686745345044b18037d8f38ab3480fab94f4dfa1"}, "originalPosition": 371}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4e2343bcf2392e3752abd3d88f0bca06050d50ee", "author": {"user": {"login": "kaneeldias", "name": "Kaneel Dias"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/4e2343bcf2392e3752abd3d88f0bca06050d50ee", "committedDate": "2020-01-20T04:24:48Z", "message": "Add observability (metrics and tracing) to Kafka connector"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "686745345044b18037d8f38ab3480fab94f4dfa1", "author": {"user": {"login": "kaneeldias", "name": "Kaneel Dias"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/686745345044b18037d8f38ab3480fab94f4dfa1", "committedDate": "2020-01-17T11:33:01Z", "message": "Add observability (metrics and tracing) to Kafka connector"}, "afterCommit": {"oid": "4e2343bcf2392e3752abd3d88f0bca06050d50ee", "author": {"user": {"login": "kaneeldias", "name": "Kaneel Dias"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/4e2343bcf2392e3752abd3d88f0bca06050d50ee", "committedDate": "2020-01-20T04:24:48Z", "message": "Add observability (metrics and tracing) to Kafka connector"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1MTc0NjIx", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#pullrequestreview-345174621", "createdAt": "2020-01-20T09:30:00Z", "commit": {"oid": "4e2343bcf2392e3752abd3d88f0bca06050d50ee"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4454, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}