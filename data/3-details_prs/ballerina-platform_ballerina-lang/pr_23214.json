{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE3NDA0ODIw", "number": 23214, "title": "Add Typed-binding-pattern support for incremental parser", "bodyText": "Add typed-binding-pattern support for foreach statement\nAdd capture-binding-pattern support for typed-binding-pattern\nAdd list-binding-pattern support for typed-binding-pattern\nAdd rest-binding-pattern support for typed-binding-pattern\nCloses #22938\nCloses #23079\nCloses #23083\nCloses #23081\nApproach\n\nDescribe how you are implementing the solutions along with the design details.\n\nSamples\n\nProvide high-level details about the samples related to this feature.\n\nRemarks\n\nList any other known issues, related PRs, TODO items, or any other notes related to the PR.\n\nCheck List\n\n Read the Contributing Guide\n Updated Change Log\n Checked Tooling Support (#)\n Added necessary tests\n\n Unit Tests\n Spec Conformance Tests\n Integration Tests\n Ballerina By Example Tests\n\n\n Increased Test Coverage\n Added necessary documentation\n\n API documentation\n Module documentation in Module.md files\n Ballerina By Examples", "createdAt": "2020-05-13T14:33:20Z", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214", "merged": true, "mergeCommit": {"oid": "574e52096fef4f8295cc4deff0d5c81cf835aef1"}, "closed": true, "closedAt": "2020-05-19T13:48:54Z", "author": {"login": "m36dot"}, "timelineItems": {"totalCount": 37, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcgMfnRgH2gAyNDE3NDA0ODIwOjY0NDliZmNmY2Q1MTI1MzA4NmNhN2IyMzI0ZWMyYmM2N2VmZmVhMzg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABci0xgtgFqTQxNDQ2MzU1Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "6449bfcfcd51253086ca7b2324ec2bc67effea38", "author": {"user": {"login": "m36dot", "name": "Saif Abdul Cassim"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6449bfcfcd51253086ca7b2324ec2bc67effea38", "committedDate": "2020-05-11T09:45:03Z", "message": "changed fork statement to use typed-binding-pattern"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "20ad7527783dfeec06b77abed6bac4ba6df28eee", "author": {"user": {"login": "m36dot", "name": "Saif Abdul Cassim"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/20ad7527783dfeec06b77abed6bac4ba6df28eee", "committedDate": "2020-05-11T10:16:46Z", "message": "fix merge conflict"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e3192bb4020ecd16a80ef142f256b69938334983", "author": {"user": {"login": "m36dot", "name": "Saif Abdul Cassim"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e3192bb4020ecd16a80ef142f256b69938334983", "committedDate": "2020-05-11T15:05:02Z", "message": "Add typed-binding-pattern support to foreach-statement"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8d5c3c7f5926259ac2e8719654528af7ea8b27af", "author": {"user": {"login": "m36dot", "name": "Saif Abdul Cassim"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/8d5c3c7f5926259ac2e8719654528af7ea8b27af", "committedDate": "2020-05-12T09:06:25Z", "message": "Fix binding pattern structure"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "44327d5db23ce24a178a4bba4fd5ce19327d4a27", "author": {"user": {"login": "m36dot", "name": "Saif Abdul Cassim"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/44327d5db23ce24a178a4bba4fd5ce19327d4a27", "committedDate": "2020-05-12T09:13:01Z", "message": "Fix Typos"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4920cdf8715bc87416b3ad6c528185471b4b6b7f", "author": {"user": {"login": "m36dot", "name": "Saif Abdul Cassim"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/4920cdf8715bc87416b3ad6c528185471b4b6b7f", "committedDate": "2020-05-12T09:13:54Z", "message": "Add structure change in json tree"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3f3e797eedd2018ff77cca9b4994dea141d3bd69", "author": {"user": {"login": "m36dot", "name": "Saif Abdul Cassim"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3f3e797eedd2018ff77cca9b4994dea141d3bd69", "committedDate": "2020-05-12T09:16:44Z", "message": "Fix typos"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "933e0b2cd61ab29c58ce8ca988e3983af5b9d155", "author": {"user": {"login": "m36dot", "name": "Saif Abdul Cassim"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/933e0b2cd61ab29c58ce8ca988e3983af5b9d155", "committedDate": "2020-05-12T09:18:36Z", "message": "Fix typo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b40619b9a68db5c2547dbd6bef6e2c408e4c294e", "author": {"user": {"login": "m36dot", "name": "Saif Abdul Cassim"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b40619b9a68db5c2547dbd6bef6e2c408e4c294e", "committedDate": "2020-05-12T09:29:08Z", "message": "Fix merge conflicts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "708915d7a5044e50901639712f0a45822f9936b6", "author": {"user": {"login": "m36dot", "name": "Saif Abdul Cassim"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/708915d7a5044e50901639712f0a45822f9936b6", "committedDate": "2020-05-12T14:58:57Z", "message": "Add list-binding-pattern support for typed-binding-pattern"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "56bd1e972dc688a0b5d499baccdffca9022c2282", "author": {"user": {"login": "m36dot", "name": "Saif Abdul Cassim"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/56bd1e972dc688a0b5d499baccdffca9022c2282", "committedDate": "2020-05-12T17:19:26Z", "message": "Added recovery for typed-binding-pattern"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6f59c9f816e9fa721fef006bf10b6b26e97da170", "author": {"user": {"login": "m36dot", "name": "Saif Abdul Cassim"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6f59c9f816e9fa721fef006bf10b6b26e97da170", "committedDate": "2020-05-13T08:53:09Z", "message": "Add resume parsing"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "71eb8f94adbfec3f9c29bcafb0e02f2a266f4ad1", "author": {"user": {"login": "m36dot", "name": "Saif Abdul Cassim"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/71eb8f94adbfec3f9c29bcafb0e02f2a266f4ad1", "committedDate": "2020-05-13T09:33:04Z", "message": "Fix Typo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "88cc559fa4f9d22e8a943e6a2ef87d2b9e5d6aa8", "author": {"user": {"login": "m36dot", "name": "Saif Abdul Cassim"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/88cc559fa4f9d22e8a943e6a2ef87d2b9e5d6aa8", "committedDate": "2020-05-13T14:28:52Z", "message": "Add list-binding-pattern support"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fe25e580795f35d55553f029534baf4882072c7c", "author": {"user": {"login": "m36dot", "name": "Saif Abdul Cassim"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/fe25e580795f35d55553f029534baf4882072c7c", "committedDate": "2020-05-13T14:58:41Z", "message": "Fix merge conflict"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "63733194a4124cf50a82d89d2b7ade9eee64bcd4", "author": {"user": {"login": "m36dot", "name": "Saif Abdul Cassim"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/63733194a4124cf50a82d89d2b7ade9eee64bcd4", "committedDate": "2020-05-14T04:16:21Z", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into listbindingexp"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDExNDU3Njk0", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214#pullrequestreview-411457694", "createdAt": "2020-05-14T04:32:39Z", "commit": {"oid": "fe25e580795f35d55553f029534baf4882072c7c"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwNDozMjozOVrOGVLtvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwNDozMjozOVrOGVLtvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg2NTIxNQ==", "bodyText": "It is not correct to create typed-binding-patterns here. Reason is, this is a generic method to parse type-descs.\nBut typed-binding-patterns are not supported for all places where a type is supported.\ne.g: type-cast, func-return, type-parameter, etc. there are many places where a type-desc can appear without a binding pattern.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214#discussion_r424865215", "createdAt": "2020-05-14T04:32:39Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -1983,7 +1991,10 @@ private STNode parseComplexTypeDescriptor(STNode typeDesc, ParserRuleContext con\n                 return parseComplexTypeDescriptor(parseOptionalTypeDescriptor(typeDesc), context);\n             // If next token after a type descriptor is <code>[</code> then it is an array type descriptor\n             case OPEN_BRACKET_TOKEN:\n-                return parseComplexTypeDescriptor(parseArrayTypeDescriptor(typeDesc), context);\n+                if (isListBindingPattern()) { // return typed binding attern if we find a list-b-p\n+                    return STNodeFactory.createTypedBindingPatternNode(typeDesc, parseListBindingPattern());\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe25e580795f35d55553f029534baf4882072c7c"}, "originalPosition": 22}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "618f1f7d5204ea788b44153e2d5aec97ed2beea3", "author": {"user": {"login": "m36dot", "name": "Saif Abdul Cassim"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/618f1f7d5204ea788b44153e2d5aec97ed2beea3", "committedDate": "2020-05-14T05:15:02Z", "message": "Reformat Code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e34a683aa5e4e692a407bf1469c8914c1315e699", "author": {"user": {"login": "m36dot", "name": "Saif Abdul Cassim"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e34a683aa5e4e692a407bf1469c8914c1315e699", "committedDate": "2020-05-14T05:18:43Z", "message": "renamed test in foreach stmt"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6995e32701d8894f7a74cc8d69680510bcfcfdd7", "author": {"user": {"login": "m36dot", "name": "Saif Abdul Cassim"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6995e32701d8894f7a74cc8d69680510bcfcfdd7", "committedDate": "2020-05-14T09:23:24Z", "message": "Refactor list-binding-expression parse"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "280874e4491d522863ac72c86522d8fed0402444", "author": {"user": {"login": "m36dot", "name": "Saif Abdul Cassim"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/280874e4491d522863ac72c86522d8fed0402444", "committedDate": "2020-05-14T14:06:33Z", "message": "Fix recovery"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3adbd8eab0b39e274dff1276bde5cc407efca857", "author": {"user": {"login": "m36dot", "name": "Saif Abdul Cassim"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3adbd8eab0b39e274dff1276bde5cc407efca857", "committedDate": "2020-05-18T08:20:18Z", "message": "Fix issue with invalid token at end of list-b-p"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "27867203e27735a96efea6c4a86933b0326a60cf", "author": {"user": {"login": "m36dot", "name": "Saif Abdul Cassim"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/27867203e27735a96efea6c4a86933b0326a60cf", "committedDate": "2020-05-18T11:17:04Z", "message": "fix infinite loop LBP"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "040c18c881978c8c8f6ddb73a9bbdb1946efdfc0", "author": {"user": {"login": "m36dot", "name": "Saif Abdul Cassim"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/040c18c881978c8c8f6ddb73a9bbdb1946efdfc0", "committedDate": "2020-05-18T12:07:04Z", "message": "Merge branch 'treegenfix' into listbindingexp"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0e1d5994f3adf89a684d1d1f04dc32e4da40a034", "author": {"user": {"login": "m36dot", "name": "Saif Abdul Cassim"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/0e1d5994f3adf89a684d1d1f04dc32e4da40a034", "committedDate": "2020-05-18T17:14:45Z", "message": "Add type array desc and listbinding expression parsing"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0MDYwMTE3", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214#pullrequestreview-414060117", "createdAt": "2020-05-19T02:32:55Z", "commit": {"oid": "0e1d5994f3adf89a684d1d1f04dc32e4da40a034"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwMjozMjo1NlrOGXNuKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwMzo1MjowNlrOGXO7YA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5NTI0MQ==", "bodyText": "Need a proper name for the flag.\nAlso, can it be a boolean instead of int?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214#discussion_r426995241", "createdAt": "2020-05-19T02:32:56Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -1953,18 +1951,26 @@ private STNode parseReturnsKeyword() {\n      *\n      * @return Parsed node\n      */\n-    private STNode parseTypeDescriptor(ParserRuleContext context) {\n+    private STNode parseTypeDescriptor(ParserRuleContext context, int flag) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e1d5994f3adf89a684d1d1f04dc32e4da40a034"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5NjAyOQ==", "bodyText": "Can we please use the same pattern as in other places? If there is some issue, we should fix that, rather than changing this.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214#discussion_r426996029", "createdAt": "2020-05-19T02:35:42Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -8423,4 +8434,337 @@ private STNode parseParenthesisedTypeDesc() {\n         STNode closeParen = parseCloseParenthesis();\n         return STNodeFactory.createParenthesisedTypeDescriptorNode(openParen, typedesc, closeParen);\n     }\n+\n+    /**\n+     * Parse binding-patterns.\n+     *\n+     * binding-pattern :=\n+     *   capture-binding-pattern\n+     *    | wildcard-binding-pattern\n+     *    | list-binding-pattern\n+     *    | mapping-binding-pattern\n+     *    | functional-binding-pattern\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     * wildcard-binding-pattern := _\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *    binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ] \n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     * rest-binding-pattern := ... variable-name\n+     * functional-binding-pattern := functionally-constructible-type-reference ( arg-list-binding-pattern )\n+     * arg-list-binding-pattern :=\n+     *    positional-arg-binding-patterns [, other-arg-binding-patterns]\n+     *    | other-arg-binding-patterns\n+     * positional-arg-binding-patterns := positional-arg-binding-pattern (, positional-arg-binding-pattern)*\n+     * positional-arg-binding-pattern := binding-pattern\n+     * other-arg-binding-patterns :=\n+     *    named-arg-binding-patterns [, rest-binding-pattern]\n+     *    | [rest-binding-pattern]\n+     * named-arg-binding-patterns := named-arg-binding-pattern (, named-arg-binding-pattern)*\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n+     *\n+     * @return binding-pattern node\n+     */\n+    private STNode parseBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case OPEN_BRACKET_TOKEN:\n+                return parseListBindingPattern();\n+            case IDENTIFIER_TOKEN:\n+                return parseCaptureBindingPattern();\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse capture-binding-pattern.\n+     *\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     *\n+     * @return capture-binding-pattern node\n+     */\n+    private STNode parseCaptureBindingPattern() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case IDENTIFIER_TOKEN:\n+                STNode varName = parseVariableName();\n+                return STNodeFactory.createCaptureBindingPatternNode(varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.CAPTURE_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-patterns.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return list-binding-pattern node\n+     */\n+    private STNode parseListBindingPattern() {\n+        startContext(ParserRuleContext.LIST_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBracket = parseOpenBracket();\n+\n+        STNode listBindingPatternContent = parselistBindingPatternContent();\n+        bindingPatterns.add(listBindingPatternContent);\n+\n+        //parsing the main chunck of list-binding-pattern\n+        STToken token = getNextLBPToken(); // get next valid token\n+        STNode comma = null;\n+        while (!isEndOfListBindingPattern(token.kind) &&\n+                listBindingPatternContent.kind != SyntaxKind.REST_BINDING_PATTERN) {\n+            comma = parseComma();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e1d5994f3adf89a684d1d1f04dc32e4da40a034"}, "originalPosition": 244}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5Njg5Mw==", "bodyText": "Do we need all these?\nYou are terminating the loop if a rest-binding pattern is reached. So wouldn't  checking listBindingPatternContent after the loop be sufficient?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214#discussion_r426996893", "createdAt": "2020-05-19T02:38:48Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -8423,4 +8434,337 @@ private STNode parseParenthesisedTypeDesc() {\n         STNode closeParen = parseCloseParenthesis();\n         return STNodeFactory.createParenthesisedTypeDescriptorNode(openParen, typedesc, closeParen);\n     }\n+\n+    /**\n+     * Parse binding-patterns.\n+     *\n+     * binding-pattern :=\n+     *   capture-binding-pattern\n+     *    | wildcard-binding-pattern\n+     *    | list-binding-pattern\n+     *    | mapping-binding-pattern\n+     *    | functional-binding-pattern\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     * wildcard-binding-pattern := _\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *    binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ] \n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     * rest-binding-pattern := ... variable-name\n+     * functional-binding-pattern := functionally-constructible-type-reference ( arg-list-binding-pattern )\n+     * arg-list-binding-pattern :=\n+     *    positional-arg-binding-patterns [, other-arg-binding-patterns]\n+     *    | other-arg-binding-patterns\n+     * positional-arg-binding-patterns := positional-arg-binding-pattern (, positional-arg-binding-pattern)*\n+     * positional-arg-binding-pattern := binding-pattern\n+     * other-arg-binding-patterns :=\n+     *    named-arg-binding-patterns [, rest-binding-pattern]\n+     *    | [rest-binding-pattern]\n+     * named-arg-binding-patterns := named-arg-binding-pattern (, named-arg-binding-pattern)*\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n+     *\n+     * @return binding-pattern node\n+     */\n+    private STNode parseBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case OPEN_BRACKET_TOKEN:\n+                return parseListBindingPattern();\n+            case IDENTIFIER_TOKEN:\n+                return parseCaptureBindingPattern();\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse capture-binding-pattern.\n+     *\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     *\n+     * @return capture-binding-pattern node\n+     */\n+    private STNode parseCaptureBindingPattern() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case IDENTIFIER_TOKEN:\n+                STNode varName = parseVariableName();\n+                return STNodeFactory.createCaptureBindingPatternNode(varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.CAPTURE_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-patterns.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return list-binding-pattern node\n+     */\n+    private STNode parseListBindingPattern() {\n+        startContext(ParserRuleContext.LIST_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBracket = parseOpenBracket();\n+\n+        STNode listBindingPatternContent = parselistBindingPatternContent();\n+        bindingPatterns.add(listBindingPatternContent);\n+\n+        //parsing the main chunck of list-binding-pattern\n+        STToken token = getNextLBPToken(); // get next valid token\n+        STNode comma = null;\n+        while (!isEndOfListBindingPattern(token.kind) &&\n+                listBindingPatternContent.kind != SyntaxKind.REST_BINDING_PATTERN) {\n+            comma = parseComma();\n+            bindingPatterns.add(comma);\n+            listBindingPatternContent = parselistBindingPatternContent();\n+            bindingPatterns.add(listBindingPatternContent);\n+            token = getNextLBPToken();\n+        }\n+        STNode closeBracket = parseCloseBracket();\n+\n+        //seperating out the restbindingpattern\n+        STNode restBindingPattern = STNodeFactory.createEmptyNode();\n+        int lastIndex = bindingPatterns.size() - 1;\n+        STNode lastItem = bindingPatterns.get(lastIndex);\n+        if (lastItem.kind == SyntaxKind.REST_BINDING_PATTERN) {\n+            restBindingPattern = bindingPatterns.remove(lastIndex);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e1d5994f3adf89a684d1d1f04dc32e4da40a034"}, "originalPosition": 258}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5NzA5Ng==", "bodyText": "Shall we rename this to listBindingPatternMember", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214#discussion_r426997096", "createdAt": "2020-05-19T02:39:37Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -8423,4 +8434,337 @@ private STNode parseParenthesisedTypeDesc() {\n         STNode closeParen = parseCloseParenthesis();\n         return STNodeFactory.createParenthesisedTypeDescriptorNode(openParen, typedesc, closeParen);\n     }\n+\n+    /**\n+     * Parse binding-patterns.\n+     *\n+     * binding-pattern :=\n+     *   capture-binding-pattern\n+     *    | wildcard-binding-pattern\n+     *    | list-binding-pattern\n+     *    | mapping-binding-pattern\n+     *    | functional-binding-pattern\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     * wildcard-binding-pattern := _\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *    binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ] \n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     * rest-binding-pattern := ... variable-name\n+     * functional-binding-pattern := functionally-constructible-type-reference ( arg-list-binding-pattern )\n+     * arg-list-binding-pattern :=\n+     *    positional-arg-binding-patterns [, other-arg-binding-patterns]\n+     *    | other-arg-binding-patterns\n+     * positional-arg-binding-patterns := positional-arg-binding-pattern (, positional-arg-binding-pattern)*\n+     * positional-arg-binding-pattern := binding-pattern\n+     * other-arg-binding-patterns :=\n+     *    named-arg-binding-patterns [, rest-binding-pattern]\n+     *    | [rest-binding-pattern]\n+     * named-arg-binding-patterns := named-arg-binding-pattern (, named-arg-binding-pattern)*\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n+     *\n+     * @return binding-pattern node\n+     */\n+    private STNode parseBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case OPEN_BRACKET_TOKEN:\n+                return parseListBindingPattern();\n+            case IDENTIFIER_TOKEN:\n+                return parseCaptureBindingPattern();\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse capture-binding-pattern.\n+     *\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     *\n+     * @return capture-binding-pattern node\n+     */\n+    private STNode parseCaptureBindingPattern() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case IDENTIFIER_TOKEN:\n+                STNode varName = parseVariableName();\n+                return STNodeFactory.createCaptureBindingPatternNode(varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.CAPTURE_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-patterns.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return list-binding-pattern node\n+     */\n+    private STNode parseListBindingPattern() {\n+        startContext(ParserRuleContext.LIST_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBracket = parseOpenBracket();\n+\n+        STNode listBindingPatternContent = parselistBindingPatternContent();\n+        bindingPatterns.add(listBindingPatternContent);\n+\n+        //parsing the main chunck of list-binding-pattern\n+        STToken token = getNextLBPToken(); // get next valid token\n+        STNode comma = null;\n+        while (!isEndOfListBindingPattern(token.kind) &&\n+                listBindingPatternContent.kind != SyntaxKind.REST_BINDING_PATTERN) {\n+            comma = parseComma();\n+            bindingPatterns.add(comma);\n+            listBindingPatternContent = parselistBindingPatternContent();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e1d5994f3adf89a684d1d1f04dc32e4da40a034"}, "originalPosition": 246}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5NzQwOQ==", "bodyText": "I don't think we should do this. Can't we  simply use peek()?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214#discussion_r426997409", "createdAt": "2020-05-19T02:40:45Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -8423,4 +8434,337 @@ private STNode parseParenthesisedTypeDesc() {\n         STNode closeParen = parseCloseParenthesis();\n         return STNodeFactory.createParenthesisedTypeDescriptorNode(openParen, typedesc, closeParen);\n     }\n+\n+    /**\n+     * Parse binding-patterns.\n+     *\n+     * binding-pattern :=\n+     *   capture-binding-pattern\n+     *    | wildcard-binding-pattern\n+     *    | list-binding-pattern\n+     *    | mapping-binding-pattern\n+     *    | functional-binding-pattern\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     * wildcard-binding-pattern := _\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *    binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ] \n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     * rest-binding-pattern := ... variable-name\n+     * functional-binding-pattern := functionally-constructible-type-reference ( arg-list-binding-pattern )\n+     * arg-list-binding-pattern :=\n+     *    positional-arg-binding-patterns [, other-arg-binding-patterns]\n+     *    | other-arg-binding-patterns\n+     * positional-arg-binding-patterns := positional-arg-binding-pattern (, positional-arg-binding-pattern)*\n+     * positional-arg-binding-pattern := binding-pattern\n+     * other-arg-binding-patterns :=\n+     *    named-arg-binding-patterns [, rest-binding-pattern]\n+     *    | [rest-binding-pattern]\n+     * named-arg-binding-patterns := named-arg-binding-pattern (, named-arg-binding-pattern)*\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n+     *\n+     * @return binding-pattern node\n+     */\n+    private STNode parseBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case OPEN_BRACKET_TOKEN:\n+                return parseListBindingPattern();\n+            case IDENTIFIER_TOKEN:\n+                return parseCaptureBindingPattern();\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse capture-binding-pattern.\n+     *\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     *\n+     * @return capture-binding-pattern node\n+     */\n+    private STNode parseCaptureBindingPattern() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case IDENTIFIER_TOKEN:\n+                STNode varName = parseVariableName();\n+                return STNodeFactory.createCaptureBindingPatternNode(varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.CAPTURE_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-patterns.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return list-binding-pattern node\n+     */\n+    private STNode parseListBindingPattern() {\n+        startContext(ParserRuleContext.LIST_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBracket = parseOpenBracket();\n+\n+        STNode listBindingPatternContent = parselistBindingPatternContent();\n+        bindingPatterns.add(listBindingPatternContent);\n+\n+        //parsing the main chunck of list-binding-pattern\n+        STToken token = getNextLBPToken(); // get next valid token\n+        STNode comma = null;\n+        while (!isEndOfListBindingPattern(token.kind) &&\n+                listBindingPatternContent.kind != SyntaxKind.REST_BINDING_PATTERN) {\n+            comma = parseComma();\n+            bindingPatterns.add(comma);\n+            listBindingPatternContent = parselistBindingPatternContent();\n+            bindingPatterns.add(listBindingPatternContent);\n+            token = getNextLBPToken();\n+        }\n+        STNode closeBracket = parseCloseBracket();\n+\n+        //seperating out the restbindingpattern\n+        STNode restBindingPattern = STNodeFactory.createEmptyNode();\n+        int lastIndex = bindingPatterns.size() - 1;\n+        STNode lastItem = bindingPatterns.get(lastIndex);\n+        if (lastItem.kind == SyntaxKind.REST_BINDING_PATTERN) {\n+            restBindingPattern = bindingPatterns.remove(lastIndex);\n+        }\n+\n+\n+        STNode bindingPatternsNode = STNodeFactory.createNodeList(bindingPatterns);\n+        endContext();\n+        return STNodeFactory.createListBindingPatternNode(openBracket,\n+                                                    bindingPatternsNode,\n+                                                    restBindingPattern,\n+                                                    closeBracket);\n+    }\n+\n+    private STToken getNextLBPToken() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e1d5994f3adf89a684d1d1f04dc32e4da40a034"}, "originalPosition": 269}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5Nzg4Nw==", "bodyText": "Let's replace LPB with ListBindingPattern. Otherwise any new reader will have a hard time figuring out what it means", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214#discussion_r426997887", "createdAt": "2020-05-19T02:42:47Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -8423,4 +8434,337 @@ private STNode parseParenthesisedTypeDesc() {\n         STNode closeParen = parseCloseParenthesis();\n         return STNodeFactory.createParenthesisedTypeDescriptorNode(openParen, typedesc, closeParen);\n     }\n+\n+    /**\n+     * Parse binding-patterns.\n+     *\n+     * binding-pattern :=\n+     *   capture-binding-pattern\n+     *    | wildcard-binding-pattern\n+     *    | list-binding-pattern\n+     *    | mapping-binding-pattern\n+     *    | functional-binding-pattern\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     * wildcard-binding-pattern := _\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *    binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ] \n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     * rest-binding-pattern := ... variable-name\n+     * functional-binding-pattern := functionally-constructible-type-reference ( arg-list-binding-pattern )\n+     * arg-list-binding-pattern :=\n+     *    positional-arg-binding-patterns [, other-arg-binding-patterns]\n+     *    | other-arg-binding-patterns\n+     * positional-arg-binding-patterns := positional-arg-binding-pattern (, positional-arg-binding-pattern)*\n+     * positional-arg-binding-pattern := binding-pattern\n+     * other-arg-binding-patterns :=\n+     *    named-arg-binding-patterns [, rest-binding-pattern]\n+     *    | [rest-binding-pattern]\n+     * named-arg-binding-patterns := named-arg-binding-pattern (, named-arg-binding-pattern)*\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n+     *\n+     * @return binding-pattern node\n+     */\n+    private STNode parseBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case OPEN_BRACKET_TOKEN:\n+                return parseListBindingPattern();\n+            case IDENTIFIER_TOKEN:\n+                return parseCaptureBindingPattern();\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse capture-binding-pattern.\n+     *\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     *\n+     * @return capture-binding-pattern node\n+     */\n+    private STNode parseCaptureBindingPattern() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case IDENTIFIER_TOKEN:\n+                STNode varName = parseVariableName();\n+                return STNodeFactory.createCaptureBindingPatternNode(varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.CAPTURE_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-patterns.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return list-binding-pattern node\n+     */\n+    private STNode parseListBindingPattern() {\n+        startContext(ParserRuleContext.LIST_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBracket = parseOpenBracket();\n+\n+        STNode listBindingPatternContent = parselistBindingPatternContent();\n+        bindingPatterns.add(listBindingPatternContent);\n+\n+        //parsing the main chunck of list-binding-pattern\n+        STToken token = getNextLBPToken(); // get next valid token\n+        STNode comma = null;\n+        while (!isEndOfListBindingPattern(token.kind) &&\n+                listBindingPatternContent.kind != SyntaxKind.REST_BINDING_PATTERN) {\n+            comma = parseComma();\n+            bindingPatterns.add(comma);\n+            listBindingPatternContent = parselistBindingPatternContent();\n+            bindingPatterns.add(listBindingPatternContent);\n+            token = getNextLBPToken();\n+        }\n+        STNode closeBracket = parseCloseBracket();\n+\n+        //seperating out the restbindingpattern\n+        STNode restBindingPattern = STNodeFactory.createEmptyNode();\n+        int lastIndex = bindingPatterns.size() - 1;\n+        STNode lastItem = bindingPatterns.get(lastIndex);\n+        if (lastItem.kind == SyntaxKind.REST_BINDING_PATTERN) {\n+            restBindingPattern = bindingPatterns.remove(lastIndex);\n+        }\n+\n+\n+        STNode bindingPatternsNode = STNodeFactory.createNodeList(bindingPatterns);\n+        endContext();\n+        return STNodeFactory.createListBindingPatternNode(openBracket,\n+                                                    bindingPatternsNode,\n+                                                    restBindingPattern,\n+                                                    closeBracket);\n+    }\n+\n+    private STToken getNextLBPToken() {\n+        STToken token = peek();\n+\n+        if (isEndOfListBindingPattern(token.kind)) {\n+            return token;\n+        }\n+\n+        switch (token.kind) {\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+            case IDENTIFIER_TOKEN:\n+            case ELLIPSIS_TOKEN:\n+            case OPEN_BRACKET_TOKEN:\n+            case COMMA_TOKEN:\n+                return token;\n+            default:\n+                consume(); // use the invalid token\n+                this.errorHandler.reportInvalidNode(token,\n+                        \"invalid Token in list-binding-pattern\");\n+                return getNextLBPToken();\n+        }\n+    }\n+\n+    private boolean isEndOfListBindingPattern(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case IN_KEYWORD:\n+            case CLOSE_BRACKET_TOKEN:\n+            case EOF_TOKEN:\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+                return true;\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    /**\n+     * Parse rest-binding-pattern.\n+     *\n+     * rest-binding-pattern := ... variable-name\n+     *\n+     * @return rest-binding-pattern node\n+     */\n+    private STNode parseRestBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case ELLIPSIS_TOKEN:\n+                startContext(ParserRuleContext.REST_BINDING_PATTERN);\n+                STNode ellipsis = parseEllipsis();\n+                STNode varName = parseVariableName();\n+                endContext();\n+                return STNodeFactory.createRestBindingPatternNode(ellipsis, varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.REST_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-pattern entry.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return rest-binding-pattern node\n+     */\n+    private STNode parselistBindingPatternContent() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+                return consume();\n+            case ELLIPSIS_TOKEN:\n+                return parseRestBindingPattern();\n+            default:\n+                return parseBindingPattern();\n+        }\n+    }\n+\n+    /**\n+     * Parse Typed-binding-pattern.\n+     *\n+     * <code>typed-binding-pattern := inferable-type-descriptor binding-pattern</code>\n+     * <code>inferable-type-descriptor := type-descriptor | var</code>\n+     *\n+     * @return Fork statement\n+     */\n+    private STNode parseTypedBindingPattern() {\n+        startContext(ParserRuleContext.TYPED_BINDING_PATTERN);\n+        STNode typeDesc = parseTypeDescriptor(ParserRuleContext.TYPE_DESC_IN_TYPE_BINDING_PATTERN, 1);\n+\n+        STNode bindingPattern = null;\n+        if (peek().kind == SyntaxKind.OPEN_BRACKET_TOKEN) {\n+            STNode[] parsed = parseArrayTypeDescOrLBP(typeDesc);\n+            typeDesc = parsed[0];\n+            bindingPattern = parsed[1];\n+        } else {\n+            bindingPattern = parseBindingPattern();\n+        }\n+\n+        endContext();\n+        return STNodeFactory.createTypedBindingPatternNode(typeDesc, bindingPattern);\n+    }\n+\n+    private STNode[] parseArrayTypeDescOrLBP(STNode typeDesc) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e1d5994f3adf89a684d1d1f04dc32e4da40a034"}, "originalPosition": 380}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5ODA3MA==", "bodyText": "Don't need to initialize", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214#discussion_r426998070", "createdAt": "2020-05-19T02:43:30Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -8423,4 +8434,337 @@ private STNode parseParenthesisedTypeDesc() {\n         STNode closeParen = parseCloseParenthesis();\n         return STNodeFactory.createParenthesisedTypeDescriptorNode(openParen, typedesc, closeParen);\n     }\n+\n+    /**\n+     * Parse binding-patterns.\n+     *\n+     * binding-pattern :=\n+     *   capture-binding-pattern\n+     *    | wildcard-binding-pattern\n+     *    | list-binding-pattern\n+     *    | mapping-binding-pattern\n+     *    | functional-binding-pattern\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     * wildcard-binding-pattern := _\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *    binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ] \n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     * rest-binding-pattern := ... variable-name\n+     * functional-binding-pattern := functionally-constructible-type-reference ( arg-list-binding-pattern )\n+     * arg-list-binding-pattern :=\n+     *    positional-arg-binding-patterns [, other-arg-binding-patterns]\n+     *    | other-arg-binding-patterns\n+     * positional-arg-binding-patterns := positional-arg-binding-pattern (, positional-arg-binding-pattern)*\n+     * positional-arg-binding-pattern := binding-pattern\n+     * other-arg-binding-patterns :=\n+     *    named-arg-binding-patterns [, rest-binding-pattern]\n+     *    | [rest-binding-pattern]\n+     * named-arg-binding-patterns := named-arg-binding-pattern (, named-arg-binding-pattern)*\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n+     *\n+     * @return binding-pattern node\n+     */\n+    private STNode parseBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case OPEN_BRACKET_TOKEN:\n+                return parseListBindingPattern();\n+            case IDENTIFIER_TOKEN:\n+                return parseCaptureBindingPattern();\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse capture-binding-pattern.\n+     *\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     *\n+     * @return capture-binding-pattern node\n+     */\n+    private STNode parseCaptureBindingPattern() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case IDENTIFIER_TOKEN:\n+                STNode varName = parseVariableName();\n+                return STNodeFactory.createCaptureBindingPatternNode(varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.CAPTURE_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-patterns.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return list-binding-pattern node\n+     */\n+    private STNode parseListBindingPattern() {\n+        startContext(ParserRuleContext.LIST_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBracket = parseOpenBracket();\n+\n+        STNode listBindingPatternContent = parselistBindingPatternContent();\n+        bindingPatterns.add(listBindingPatternContent);\n+\n+        //parsing the main chunck of list-binding-pattern\n+        STToken token = getNextLBPToken(); // get next valid token\n+        STNode comma = null;\n+        while (!isEndOfListBindingPattern(token.kind) &&\n+                listBindingPatternContent.kind != SyntaxKind.REST_BINDING_PATTERN) {\n+            comma = parseComma();\n+            bindingPatterns.add(comma);\n+            listBindingPatternContent = parselistBindingPatternContent();\n+            bindingPatterns.add(listBindingPatternContent);\n+            token = getNextLBPToken();\n+        }\n+        STNode closeBracket = parseCloseBracket();\n+\n+        //seperating out the restbindingpattern\n+        STNode restBindingPattern = STNodeFactory.createEmptyNode();\n+        int lastIndex = bindingPatterns.size() - 1;\n+        STNode lastItem = bindingPatterns.get(lastIndex);\n+        if (lastItem.kind == SyntaxKind.REST_BINDING_PATTERN) {\n+            restBindingPattern = bindingPatterns.remove(lastIndex);\n+        }\n+\n+\n+        STNode bindingPatternsNode = STNodeFactory.createNodeList(bindingPatterns);\n+        endContext();\n+        return STNodeFactory.createListBindingPatternNode(openBracket,\n+                                                    bindingPatternsNode,\n+                                                    restBindingPattern,\n+                                                    closeBracket);\n+    }\n+\n+    private STToken getNextLBPToken() {\n+        STToken token = peek();\n+\n+        if (isEndOfListBindingPattern(token.kind)) {\n+            return token;\n+        }\n+\n+        switch (token.kind) {\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+            case IDENTIFIER_TOKEN:\n+            case ELLIPSIS_TOKEN:\n+            case OPEN_BRACKET_TOKEN:\n+            case COMMA_TOKEN:\n+                return token;\n+            default:\n+                consume(); // use the invalid token\n+                this.errorHandler.reportInvalidNode(token,\n+                        \"invalid Token in list-binding-pattern\");\n+                return getNextLBPToken();\n+        }\n+    }\n+\n+    private boolean isEndOfListBindingPattern(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case IN_KEYWORD:\n+            case CLOSE_BRACKET_TOKEN:\n+            case EOF_TOKEN:\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+                return true;\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    /**\n+     * Parse rest-binding-pattern.\n+     *\n+     * rest-binding-pattern := ... variable-name\n+     *\n+     * @return rest-binding-pattern node\n+     */\n+    private STNode parseRestBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case ELLIPSIS_TOKEN:\n+                startContext(ParserRuleContext.REST_BINDING_PATTERN);\n+                STNode ellipsis = parseEllipsis();\n+                STNode varName = parseVariableName();\n+                endContext();\n+                return STNodeFactory.createRestBindingPatternNode(ellipsis, varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.REST_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-pattern entry.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return rest-binding-pattern node\n+     */\n+    private STNode parselistBindingPatternContent() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+                return consume();\n+            case ELLIPSIS_TOKEN:\n+                return parseRestBindingPattern();\n+            default:\n+                return parseBindingPattern();\n+        }\n+    }\n+\n+    /**\n+     * Parse Typed-binding-pattern.\n+     *\n+     * <code>typed-binding-pattern := inferable-type-descriptor binding-pattern</code>\n+     * <code>inferable-type-descriptor := type-descriptor | var</code>\n+     *\n+     * @return Fork statement\n+     */\n+    private STNode parseTypedBindingPattern() {\n+        startContext(ParserRuleContext.TYPED_BINDING_PATTERN);\n+        STNode typeDesc = parseTypeDescriptor(ParserRuleContext.TYPE_DESC_IN_TYPE_BINDING_PATTERN, 1);\n+\n+        STNode bindingPattern = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e1d5994f3adf89a684d1d1f04dc32e4da40a034"}, "originalPosition": 367}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAwODQ4MQ==", "bodyText": "Without returning an array of STNode, can we create the final typed-binding-pattern here and return?\nSame for below cases as well", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214#discussion_r427008481", "createdAt": "2020-05-19T03:26:11Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -8423,4 +8434,337 @@ private STNode parseParenthesisedTypeDesc() {\n         STNode closeParen = parseCloseParenthesis();\n         return STNodeFactory.createParenthesisedTypeDescriptorNode(openParen, typedesc, closeParen);\n     }\n+\n+    /**\n+     * Parse binding-patterns.\n+     *\n+     * binding-pattern :=\n+     *   capture-binding-pattern\n+     *    | wildcard-binding-pattern\n+     *    | list-binding-pattern\n+     *    | mapping-binding-pattern\n+     *    | functional-binding-pattern\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     * wildcard-binding-pattern := _\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *    binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ] \n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     * rest-binding-pattern := ... variable-name\n+     * functional-binding-pattern := functionally-constructible-type-reference ( arg-list-binding-pattern )\n+     * arg-list-binding-pattern :=\n+     *    positional-arg-binding-patterns [, other-arg-binding-patterns]\n+     *    | other-arg-binding-patterns\n+     * positional-arg-binding-patterns := positional-arg-binding-pattern (, positional-arg-binding-pattern)*\n+     * positional-arg-binding-pattern := binding-pattern\n+     * other-arg-binding-patterns :=\n+     *    named-arg-binding-patterns [, rest-binding-pattern]\n+     *    | [rest-binding-pattern]\n+     * named-arg-binding-patterns := named-arg-binding-pattern (, named-arg-binding-pattern)*\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n+     *\n+     * @return binding-pattern node\n+     */\n+    private STNode parseBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case OPEN_BRACKET_TOKEN:\n+                return parseListBindingPattern();\n+            case IDENTIFIER_TOKEN:\n+                return parseCaptureBindingPattern();\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse capture-binding-pattern.\n+     *\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     *\n+     * @return capture-binding-pattern node\n+     */\n+    private STNode parseCaptureBindingPattern() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case IDENTIFIER_TOKEN:\n+                STNode varName = parseVariableName();\n+                return STNodeFactory.createCaptureBindingPatternNode(varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.CAPTURE_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-patterns.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return list-binding-pattern node\n+     */\n+    private STNode parseListBindingPattern() {\n+        startContext(ParserRuleContext.LIST_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBracket = parseOpenBracket();\n+\n+        STNode listBindingPatternContent = parselistBindingPatternContent();\n+        bindingPatterns.add(listBindingPatternContent);\n+\n+        //parsing the main chunck of list-binding-pattern\n+        STToken token = getNextLBPToken(); // get next valid token\n+        STNode comma = null;\n+        while (!isEndOfListBindingPattern(token.kind) &&\n+                listBindingPatternContent.kind != SyntaxKind.REST_BINDING_PATTERN) {\n+            comma = parseComma();\n+            bindingPatterns.add(comma);\n+            listBindingPatternContent = parselistBindingPatternContent();\n+            bindingPatterns.add(listBindingPatternContent);\n+            token = getNextLBPToken();\n+        }\n+        STNode closeBracket = parseCloseBracket();\n+\n+        //seperating out the restbindingpattern\n+        STNode restBindingPattern = STNodeFactory.createEmptyNode();\n+        int lastIndex = bindingPatterns.size() - 1;\n+        STNode lastItem = bindingPatterns.get(lastIndex);\n+        if (lastItem.kind == SyntaxKind.REST_BINDING_PATTERN) {\n+            restBindingPattern = bindingPatterns.remove(lastIndex);\n+        }\n+\n+\n+        STNode bindingPatternsNode = STNodeFactory.createNodeList(bindingPatterns);\n+        endContext();\n+        return STNodeFactory.createListBindingPatternNode(openBracket,\n+                                                    bindingPatternsNode,\n+                                                    restBindingPattern,\n+                                                    closeBracket);\n+    }\n+\n+    private STToken getNextLBPToken() {\n+        STToken token = peek();\n+\n+        if (isEndOfListBindingPattern(token.kind)) {\n+            return token;\n+        }\n+\n+        switch (token.kind) {\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+            case IDENTIFIER_TOKEN:\n+            case ELLIPSIS_TOKEN:\n+            case OPEN_BRACKET_TOKEN:\n+            case COMMA_TOKEN:\n+                return token;\n+            default:\n+                consume(); // use the invalid token\n+                this.errorHandler.reportInvalidNode(token,\n+                        \"invalid Token in list-binding-pattern\");\n+                return getNextLBPToken();\n+        }\n+    }\n+\n+    private boolean isEndOfListBindingPattern(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case IN_KEYWORD:\n+            case CLOSE_BRACKET_TOKEN:\n+            case EOF_TOKEN:\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+                return true;\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    /**\n+     * Parse rest-binding-pattern.\n+     *\n+     * rest-binding-pattern := ... variable-name\n+     *\n+     * @return rest-binding-pattern node\n+     */\n+    private STNode parseRestBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case ELLIPSIS_TOKEN:\n+                startContext(ParserRuleContext.REST_BINDING_PATTERN);\n+                STNode ellipsis = parseEllipsis();\n+                STNode varName = parseVariableName();\n+                endContext();\n+                return STNodeFactory.createRestBindingPatternNode(ellipsis, varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.REST_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-pattern entry.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return rest-binding-pattern node\n+     */\n+    private STNode parselistBindingPatternContent() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+                return consume();\n+            case ELLIPSIS_TOKEN:\n+                return parseRestBindingPattern();\n+            default:\n+                return parseBindingPattern();\n+        }\n+    }\n+\n+    /**\n+     * Parse Typed-binding-pattern.\n+     *\n+     * <code>typed-binding-pattern := inferable-type-descriptor binding-pattern</code>\n+     * <code>inferable-type-descriptor := type-descriptor | var</code>\n+     *\n+     * @return Fork statement\n+     */\n+    private STNode parseTypedBindingPattern() {\n+        startContext(ParserRuleContext.TYPED_BINDING_PATTERN);\n+        STNode typeDesc = parseTypeDescriptor(ParserRuleContext.TYPE_DESC_IN_TYPE_BINDING_PATTERN, 1);\n+\n+        STNode bindingPattern = null;\n+        if (peek().kind == SyntaxKind.OPEN_BRACKET_TOKEN) {\n+            STNode[] parsed = parseArrayTypeDescOrLBP(typeDesc);\n+            typeDesc = parsed[0];\n+            bindingPattern = parsed[1];\n+        } else {\n+            bindingPattern = parseBindingPattern();\n+        }\n+\n+        endContext();\n+        return STNodeFactory.createTypedBindingPatternNode(typeDesc, bindingPattern);\n+    }\n+\n+    private STNode[] parseArrayTypeDescOrLBP(STNode typeDesc) {\n+\n+        STNode arrayDescOrBLP = parseListBindingPattern();\n+\n+        if (isLBPDefinitively(arrayDescOrBLP)) { // ambiguous means T[a]\n+            return new STNode[]{typeDesc, cleanLBP(arrayDescOrBLP)};", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e1d5994f3adf89a684d1d1f04dc32e4da40a034"}, "originalPosition": 385}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAwOTA2Mw==", "bodyText": "lets have a better name for the second parameter. (also should start with lower case)", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214#discussion_r427009063", "createdAt": "2020-05-19T03:28:48Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -8423,4 +8434,337 @@ private STNode parseParenthesisedTypeDesc() {\n         STNode closeParen = parseCloseParenthesis();\n         return STNodeFactory.createParenthesisedTypeDescriptorNode(openParen, typedesc, closeParen);\n     }\n+\n+    /**\n+     * Parse binding-patterns.\n+     *\n+     * binding-pattern :=\n+     *   capture-binding-pattern\n+     *    | wildcard-binding-pattern\n+     *    | list-binding-pattern\n+     *    | mapping-binding-pattern\n+     *    | functional-binding-pattern\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     * wildcard-binding-pattern := _\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *    binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ] \n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     * rest-binding-pattern := ... variable-name\n+     * functional-binding-pattern := functionally-constructible-type-reference ( arg-list-binding-pattern )\n+     * arg-list-binding-pattern :=\n+     *    positional-arg-binding-patterns [, other-arg-binding-patterns]\n+     *    | other-arg-binding-patterns\n+     * positional-arg-binding-patterns := positional-arg-binding-pattern (, positional-arg-binding-pattern)*\n+     * positional-arg-binding-pattern := binding-pattern\n+     * other-arg-binding-patterns :=\n+     *    named-arg-binding-patterns [, rest-binding-pattern]\n+     *    | [rest-binding-pattern]\n+     * named-arg-binding-patterns := named-arg-binding-pattern (, named-arg-binding-pattern)*\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n+     *\n+     * @return binding-pattern node\n+     */\n+    private STNode parseBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case OPEN_BRACKET_TOKEN:\n+                return parseListBindingPattern();\n+            case IDENTIFIER_TOKEN:\n+                return parseCaptureBindingPattern();\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse capture-binding-pattern.\n+     *\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     *\n+     * @return capture-binding-pattern node\n+     */\n+    private STNode parseCaptureBindingPattern() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case IDENTIFIER_TOKEN:\n+                STNode varName = parseVariableName();\n+                return STNodeFactory.createCaptureBindingPatternNode(varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.CAPTURE_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-patterns.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return list-binding-pattern node\n+     */\n+    private STNode parseListBindingPattern() {\n+        startContext(ParserRuleContext.LIST_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBracket = parseOpenBracket();\n+\n+        STNode listBindingPatternContent = parselistBindingPatternContent();\n+        bindingPatterns.add(listBindingPatternContent);\n+\n+        //parsing the main chunck of list-binding-pattern\n+        STToken token = getNextLBPToken(); // get next valid token\n+        STNode comma = null;\n+        while (!isEndOfListBindingPattern(token.kind) &&\n+                listBindingPatternContent.kind != SyntaxKind.REST_BINDING_PATTERN) {\n+            comma = parseComma();\n+            bindingPatterns.add(comma);\n+            listBindingPatternContent = parselistBindingPatternContent();\n+            bindingPatterns.add(listBindingPatternContent);\n+            token = getNextLBPToken();\n+        }\n+        STNode closeBracket = parseCloseBracket();\n+\n+        //seperating out the restbindingpattern\n+        STNode restBindingPattern = STNodeFactory.createEmptyNode();\n+        int lastIndex = bindingPatterns.size() - 1;\n+        STNode lastItem = bindingPatterns.get(lastIndex);\n+        if (lastItem.kind == SyntaxKind.REST_BINDING_PATTERN) {\n+            restBindingPattern = bindingPatterns.remove(lastIndex);\n+        }\n+\n+\n+        STNode bindingPatternsNode = STNodeFactory.createNodeList(bindingPatterns);\n+        endContext();\n+        return STNodeFactory.createListBindingPatternNode(openBracket,\n+                                                    bindingPatternsNode,\n+                                                    restBindingPattern,\n+                                                    closeBracket);\n+    }\n+\n+    private STToken getNextLBPToken() {\n+        STToken token = peek();\n+\n+        if (isEndOfListBindingPattern(token.kind)) {\n+            return token;\n+        }\n+\n+        switch (token.kind) {\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+            case IDENTIFIER_TOKEN:\n+            case ELLIPSIS_TOKEN:\n+            case OPEN_BRACKET_TOKEN:\n+            case COMMA_TOKEN:\n+                return token;\n+            default:\n+                consume(); // use the invalid token\n+                this.errorHandler.reportInvalidNode(token,\n+                        \"invalid Token in list-binding-pattern\");\n+                return getNextLBPToken();\n+        }\n+    }\n+\n+    private boolean isEndOfListBindingPattern(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case IN_KEYWORD:\n+            case CLOSE_BRACKET_TOKEN:\n+            case EOF_TOKEN:\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+                return true;\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    /**\n+     * Parse rest-binding-pattern.\n+     *\n+     * rest-binding-pattern := ... variable-name\n+     *\n+     * @return rest-binding-pattern node\n+     */\n+    private STNode parseRestBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case ELLIPSIS_TOKEN:\n+                startContext(ParserRuleContext.REST_BINDING_PATTERN);\n+                STNode ellipsis = parseEllipsis();\n+                STNode varName = parseVariableName();\n+                endContext();\n+                return STNodeFactory.createRestBindingPatternNode(ellipsis, varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.REST_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-pattern entry.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return rest-binding-pattern node\n+     */\n+    private STNode parselistBindingPatternContent() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+                return consume();\n+            case ELLIPSIS_TOKEN:\n+                return parseRestBindingPattern();\n+            default:\n+                return parseBindingPattern();\n+        }\n+    }\n+\n+    /**\n+     * Parse Typed-binding-pattern.\n+     *\n+     * <code>typed-binding-pattern := inferable-type-descriptor binding-pattern</code>\n+     * <code>inferable-type-descriptor := type-descriptor | var</code>\n+     *\n+     * @return Fork statement\n+     */\n+    private STNode parseTypedBindingPattern() {\n+        startContext(ParserRuleContext.TYPED_BINDING_PATTERN);\n+        STNode typeDesc = parseTypeDescriptor(ParserRuleContext.TYPE_DESC_IN_TYPE_BINDING_PATTERN, 1);\n+\n+        STNode bindingPattern = null;\n+        if (peek().kind == SyntaxKind.OPEN_BRACKET_TOKEN) {\n+            STNode[] parsed = parseArrayTypeDescOrLBP(typeDesc);\n+            typeDesc = parsed[0];\n+            bindingPattern = parsed[1];\n+        } else {\n+            bindingPattern = parseBindingPattern();\n+        }\n+\n+        endContext();\n+        return STNodeFactory.createTypedBindingPatternNode(typeDesc, bindingPattern);\n+    }\n+\n+    private STNode[] parseArrayTypeDescOrLBP(STNode typeDesc) {\n+\n+        STNode arrayDescOrBLP = parseListBindingPattern();\n+\n+        if (isLBPDefinitively(arrayDescOrBLP)) { // ambiguous means T[a]\n+            return new STNode[]{typeDesc, cleanLBP(arrayDescOrBLP)};\n+        } else {\n+            if (isFollowTypedBindingPattern(peek().kind)) {\n+                return new STNode[]{typeDesc, cleanLBP(arrayDescOrBLP)};\n+            } else {\n+                typeDesc = mergeTypeDescAndLBP(typeDesc, arrayDescOrBLP);\n+                if (peek().kind == SyntaxKind.OPEN_BRACKET_TOKEN) {\n+                    //this means arrayDescOrBLP is a array type desc\n+                    return parseArrayTypeDescOrLBP(typeDesc);\n+                } else {\n+                    return new STNode[]{typeDesc, parseBindingPattern()};\n+                }\n+            }\n+        }\n+    }\n+\n+    private STNode mergeTypeDescAndLBP(STNode typeDesc, STNode LBP) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e1d5994f3adf89a684d1d1f04dc32e4da40a034"}, "originalPosition": 401}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAwOTcyMQ==", "bodyText": "Don't need 'else', since you are returning inside 'if'", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214#discussion_r427009721", "createdAt": "2020-05-19T03:31:14Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -8423,4 +8434,337 @@ private STNode parseParenthesisedTypeDesc() {\n         STNode closeParen = parseCloseParenthesis();\n         return STNodeFactory.createParenthesisedTypeDescriptorNode(openParen, typedesc, closeParen);\n     }\n+\n+    /**\n+     * Parse binding-patterns.\n+     *\n+     * binding-pattern :=\n+     *   capture-binding-pattern\n+     *    | wildcard-binding-pattern\n+     *    | list-binding-pattern\n+     *    | mapping-binding-pattern\n+     *    | functional-binding-pattern\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     * wildcard-binding-pattern := _\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *    binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ] \n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     * rest-binding-pattern := ... variable-name\n+     * functional-binding-pattern := functionally-constructible-type-reference ( arg-list-binding-pattern )\n+     * arg-list-binding-pattern :=\n+     *    positional-arg-binding-patterns [, other-arg-binding-patterns]\n+     *    | other-arg-binding-patterns\n+     * positional-arg-binding-patterns := positional-arg-binding-pattern (, positional-arg-binding-pattern)*\n+     * positional-arg-binding-pattern := binding-pattern\n+     * other-arg-binding-patterns :=\n+     *    named-arg-binding-patterns [, rest-binding-pattern]\n+     *    | [rest-binding-pattern]\n+     * named-arg-binding-patterns := named-arg-binding-pattern (, named-arg-binding-pattern)*\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n+     *\n+     * @return binding-pattern node\n+     */\n+    private STNode parseBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case OPEN_BRACKET_TOKEN:\n+                return parseListBindingPattern();\n+            case IDENTIFIER_TOKEN:\n+                return parseCaptureBindingPattern();\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse capture-binding-pattern.\n+     *\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     *\n+     * @return capture-binding-pattern node\n+     */\n+    private STNode parseCaptureBindingPattern() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case IDENTIFIER_TOKEN:\n+                STNode varName = parseVariableName();\n+                return STNodeFactory.createCaptureBindingPatternNode(varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.CAPTURE_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-patterns.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return list-binding-pattern node\n+     */\n+    private STNode parseListBindingPattern() {\n+        startContext(ParserRuleContext.LIST_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBracket = parseOpenBracket();\n+\n+        STNode listBindingPatternContent = parselistBindingPatternContent();\n+        bindingPatterns.add(listBindingPatternContent);\n+\n+        //parsing the main chunck of list-binding-pattern\n+        STToken token = getNextLBPToken(); // get next valid token\n+        STNode comma = null;\n+        while (!isEndOfListBindingPattern(token.kind) &&\n+                listBindingPatternContent.kind != SyntaxKind.REST_BINDING_PATTERN) {\n+            comma = parseComma();\n+            bindingPatterns.add(comma);\n+            listBindingPatternContent = parselistBindingPatternContent();\n+            bindingPatterns.add(listBindingPatternContent);\n+            token = getNextLBPToken();\n+        }\n+        STNode closeBracket = parseCloseBracket();\n+\n+        //seperating out the restbindingpattern\n+        STNode restBindingPattern = STNodeFactory.createEmptyNode();\n+        int lastIndex = bindingPatterns.size() - 1;\n+        STNode lastItem = bindingPatterns.get(lastIndex);\n+        if (lastItem.kind == SyntaxKind.REST_BINDING_PATTERN) {\n+            restBindingPattern = bindingPatterns.remove(lastIndex);\n+        }\n+\n+\n+        STNode bindingPatternsNode = STNodeFactory.createNodeList(bindingPatterns);\n+        endContext();\n+        return STNodeFactory.createListBindingPatternNode(openBracket,\n+                                                    bindingPatternsNode,\n+                                                    restBindingPattern,\n+                                                    closeBracket);\n+    }\n+\n+    private STToken getNextLBPToken() {\n+        STToken token = peek();\n+\n+        if (isEndOfListBindingPattern(token.kind)) {\n+            return token;\n+        }\n+\n+        switch (token.kind) {\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+            case IDENTIFIER_TOKEN:\n+            case ELLIPSIS_TOKEN:\n+            case OPEN_BRACKET_TOKEN:\n+            case COMMA_TOKEN:\n+                return token;\n+            default:\n+                consume(); // use the invalid token\n+                this.errorHandler.reportInvalidNode(token,\n+                        \"invalid Token in list-binding-pattern\");\n+                return getNextLBPToken();\n+        }\n+    }\n+\n+    private boolean isEndOfListBindingPattern(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case IN_KEYWORD:\n+            case CLOSE_BRACKET_TOKEN:\n+            case EOF_TOKEN:\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+                return true;\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    /**\n+     * Parse rest-binding-pattern.\n+     *\n+     * rest-binding-pattern := ... variable-name\n+     *\n+     * @return rest-binding-pattern node\n+     */\n+    private STNode parseRestBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case ELLIPSIS_TOKEN:\n+                startContext(ParserRuleContext.REST_BINDING_PATTERN);\n+                STNode ellipsis = parseEllipsis();\n+                STNode varName = parseVariableName();\n+                endContext();\n+                return STNodeFactory.createRestBindingPatternNode(ellipsis, varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.REST_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-pattern entry.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return rest-binding-pattern node\n+     */\n+    private STNode parselistBindingPatternContent() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+                return consume();\n+            case ELLIPSIS_TOKEN:\n+                return parseRestBindingPattern();\n+            default:\n+                return parseBindingPattern();\n+        }\n+    }\n+\n+    /**\n+     * Parse Typed-binding-pattern.\n+     *\n+     * <code>typed-binding-pattern := inferable-type-descriptor binding-pattern</code>\n+     * <code>inferable-type-descriptor := type-descriptor | var</code>\n+     *\n+     * @return Fork statement\n+     */\n+    private STNode parseTypedBindingPattern() {\n+        startContext(ParserRuleContext.TYPED_BINDING_PATTERN);\n+        STNode typeDesc = parseTypeDescriptor(ParserRuleContext.TYPE_DESC_IN_TYPE_BINDING_PATTERN, 1);\n+\n+        STNode bindingPattern = null;\n+        if (peek().kind == SyntaxKind.OPEN_BRACKET_TOKEN) {\n+            STNode[] parsed = parseArrayTypeDescOrLBP(typeDesc);\n+            typeDesc = parsed[0];\n+            bindingPattern = parsed[1];\n+        } else {\n+            bindingPattern = parseBindingPattern();\n+        }\n+\n+        endContext();\n+        return STNodeFactory.createTypedBindingPatternNode(typeDesc, bindingPattern);\n+    }\n+\n+    private STNode[] parseArrayTypeDescOrLBP(STNode typeDesc) {\n+\n+        STNode arrayDescOrBLP = parseListBindingPattern();\n+\n+        if (isLBPDefinitively(arrayDescOrBLP)) { // ambiguous means T[a]\n+            return new STNode[]{typeDesc, cleanLBP(arrayDescOrBLP)};\n+        } else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e1d5994f3adf89a684d1d1f04dc32e4da40a034"}, "originalPosition": 386}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAwOTkyMA==", "bodyText": "wrong param name", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214#discussion_r427009920", "createdAt": "2020-05-19T03:32:00Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -8423,4 +8434,337 @@ private STNode parseParenthesisedTypeDesc() {\n         STNode closeParen = parseCloseParenthesis();\n         return STNodeFactory.createParenthesisedTypeDescriptorNode(openParen, typedesc, closeParen);\n     }\n+\n+    /**\n+     * Parse binding-patterns.\n+     *\n+     * binding-pattern :=\n+     *   capture-binding-pattern\n+     *    | wildcard-binding-pattern\n+     *    | list-binding-pattern\n+     *    | mapping-binding-pattern\n+     *    | functional-binding-pattern\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     * wildcard-binding-pattern := _\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *    binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ] \n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     * rest-binding-pattern := ... variable-name\n+     * functional-binding-pattern := functionally-constructible-type-reference ( arg-list-binding-pattern )\n+     * arg-list-binding-pattern :=\n+     *    positional-arg-binding-patterns [, other-arg-binding-patterns]\n+     *    | other-arg-binding-patterns\n+     * positional-arg-binding-patterns := positional-arg-binding-pattern (, positional-arg-binding-pattern)*\n+     * positional-arg-binding-pattern := binding-pattern\n+     * other-arg-binding-patterns :=\n+     *    named-arg-binding-patterns [, rest-binding-pattern]\n+     *    | [rest-binding-pattern]\n+     * named-arg-binding-patterns := named-arg-binding-pattern (, named-arg-binding-pattern)*\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n+     *\n+     * @return binding-pattern node\n+     */\n+    private STNode parseBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case OPEN_BRACKET_TOKEN:\n+                return parseListBindingPattern();\n+            case IDENTIFIER_TOKEN:\n+                return parseCaptureBindingPattern();\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse capture-binding-pattern.\n+     *\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     *\n+     * @return capture-binding-pattern node\n+     */\n+    private STNode parseCaptureBindingPattern() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case IDENTIFIER_TOKEN:\n+                STNode varName = parseVariableName();\n+                return STNodeFactory.createCaptureBindingPatternNode(varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.CAPTURE_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-patterns.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return list-binding-pattern node\n+     */\n+    private STNode parseListBindingPattern() {\n+        startContext(ParserRuleContext.LIST_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBracket = parseOpenBracket();\n+\n+        STNode listBindingPatternContent = parselistBindingPatternContent();\n+        bindingPatterns.add(listBindingPatternContent);\n+\n+        //parsing the main chunck of list-binding-pattern\n+        STToken token = getNextLBPToken(); // get next valid token\n+        STNode comma = null;\n+        while (!isEndOfListBindingPattern(token.kind) &&\n+                listBindingPatternContent.kind != SyntaxKind.REST_BINDING_PATTERN) {\n+            comma = parseComma();\n+            bindingPatterns.add(comma);\n+            listBindingPatternContent = parselistBindingPatternContent();\n+            bindingPatterns.add(listBindingPatternContent);\n+            token = getNextLBPToken();\n+        }\n+        STNode closeBracket = parseCloseBracket();\n+\n+        //seperating out the restbindingpattern\n+        STNode restBindingPattern = STNodeFactory.createEmptyNode();\n+        int lastIndex = bindingPatterns.size() - 1;\n+        STNode lastItem = bindingPatterns.get(lastIndex);\n+        if (lastItem.kind == SyntaxKind.REST_BINDING_PATTERN) {\n+            restBindingPattern = bindingPatterns.remove(lastIndex);\n+        }\n+\n+\n+        STNode bindingPatternsNode = STNodeFactory.createNodeList(bindingPatterns);\n+        endContext();\n+        return STNodeFactory.createListBindingPatternNode(openBracket,\n+                                                    bindingPatternsNode,\n+                                                    restBindingPattern,\n+                                                    closeBracket);\n+    }\n+\n+    private STToken getNextLBPToken() {\n+        STToken token = peek();\n+\n+        if (isEndOfListBindingPattern(token.kind)) {\n+            return token;\n+        }\n+\n+        switch (token.kind) {\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+            case IDENTIFIER_TOKEN:\n+            case ELLIPSIS_TOKEN:\n+            case OPEN_BRACKET_TOKEN:\n+            case COMMA_TOKEN:\n+                return token;\n+            default:\n+                consume(); // use the invalid token\n+                this.errorHandler.reportInvalidNode(token,\n+                        \"invalid Token in list-binding-pattern\");\n+                return getNextLBPToken();\n+        }\n+    }\n+\n+    private boolean isEndOfListBindingPattern(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case IN_KEYWORD:\n+            case CLOSE_BRACKET_TOKEN:\n+            case EOF_TOKEN:\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+                return true;\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    /**\n+     * Parse rest-binding-pattern.\n+     *\n+     * rest-binding-pattern := ... variable-name\n+     *\n+     * @return rest-binding-pattern node\n+     */\n+    private STNode parseRestBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case ELLIPSIS_TOKEN:\n+                startContext(ParserRuleContext.REST_BINDING_PATTERN);\n+                STNode ellipsis = parseEllipsis();\n+                STNode varName = parseVariableName();\n+                endContext();\n+                return STNodeFactory.createRestBindingPatternNode(ellipsis, varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.REST_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-pattern entry.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return rest-binding-pattern node\n+     */\n+    private STNode parselistBindingPatternContent() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+                return consume();\n+            case ELLIPSIS_TOKEN:\n+                return parseRestBindingPattern();\n+            default:\n+                return parseBindingPattern();\n+        }\n+    }\n+\n+    /**\n+     * Parse Typed-binding-pattern.\n+     *\n+     * <code>typed-binding-pattern := inferable-type-descriptor binding-pattern</code>\n+     * <code>inferable-type-descriptor := type-descriptor | var</code>\n+     *\n+     * @return Fork statement\n+     */\n+    private STNode parseTypedBindingPattern() {\n+        startContext(ParserRuleContext.TYPED_BINDING_PATTERN);\n+        STNode typeDesc = parseTypeDescriptor(ParserRuleContext.TYPE_DESC_IN_TYPE_BINDING_PATTERN, 1);\n+\n+        STNode bindingPattern = null;\n+        if (peek().kind == SyntaxKind.OPEN_BRACKET_TOKEN) {\n+            STNode[] parsed = parseArrayTypeDescOrLBP(typeDesc);\n+            typeDesc = parsed[0];\n+            bindingPattern = parsed[1];\n+        } else {\n+            bindingPattern = parseBindingPattern();\n+        }\n+\n+        endContext();\n+        return STNodeFactory.createTypedBindingPatternNode(typeDesc, bindingPattern);\n+    }\n+\n+    private STNode[] parseArrayTypeDescOrLBP(STNode typeDesc) {\n+\n+        STNode arrayDescOrBLP = parseListBindingPattern();\n+\n+        if (isLBPDefinitively(arrayDescOrBLP)) { // ambiguous means T[a]\n+            return new STNode[]{typeDesc, cleanLBP(arrayDescOrBLP)};\n+        } else {\n+            if (isFollowTypedBindingPattern(peek().kind)) {\n+                return new STNode[]{typeDesc, cleanLBP(arrayDescOrBLP)};\n+            } else {\n+                typeDesc = mergeTypeDescAndLBP(typeDesc, arrayDescOrBLP);\n+                if (peek().kind == SyntaxKind.OPEN_BRACKET_TOKEN) {\n+                    //this means arrayDescOrBLP is a array type desc\n+                    return parseArrayTypeDescOrLBP(typeDesc);\n+                } else {\n+                    return new STNode[]{typeDesc, parseBindingPattern()};\n+                }\n+            }\n+        }\n+    }\n+\n+    private STNode mergeTypeDescAndLBP(STNode typeDesc, STNode LBP) {\n+        STListBindingPatternNode lbp = (STListBindingPatternNode) LBP;\n+        STNodeList childArray = (STNodeList)lbp.bindingPatterns;\n+        STNode child = childArray.childInBucket(0);\n+        if (child.kind == SyntaxKind.CAPTURE_BINDING_PATTERN) {\n+            child = ((STCaptureBindingPatternNode)child).variableName;\n+        }\n+        return STNodeFactory.createIndexedExpressionNode(typeDesc, lbp.openBracket,\n+                child,\n+                lbp.closeBracket);\n+    }\n+\n+    private STNode cleanLBP(STNode arrayDescOrBLP) {\n+        STListBindingPatternNode lbp = (STListBindingPatternNode) arrayDescOrBLP;\n+        STNodeList childArray = (STNodeList)lbp.bindingPatterns;\n+        int numberOfChildren = childArray.bucketCount();\n+\n+        ArrayList<STNode> cleanedChildren = new ArrayList<>();\n+        STNode child = null;\n+        for (int i =0; i<numberOfChildren;i++) {\n+            child = childArray.childInBucket(i);\n+            switch (child.kind) {\n+                case DECIMAL_INTEGER_LITERAL:\n+                case HEX_INTEGER_LITERAL:\n+                case ASTERISK_TOKEN:\n+                    this.errorHandler.reportInvalidNode(null,\n+                            \"invalid Node \" + child.kind + \" in list-binding-pattern\");\n+                    cleanedChildren.add(STNodeFactory.createMissingToken(SyntaxKind.IDENTIFIER_TOKEN));\n+                    break;\n+                default:\n+                    cleanedChildren.add(child);\n+                    break;\n+            }\n+        }\n+\n+        return STNodeFactory.createListBindingPatternNode(lbp.openBracket,\n+                STNodeFactory.createNodeList(cleanedChildren),\n+                lbp.restBindingPattern,\n+                lbp.closeBracket);\n+    }\n+\n+    private boolean isLBPDefinitively(STNode arrayDescOrBLP) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e1d5994f3adf89a684d1d1f04dc32e4da40a034"}, "originalPosition": 442}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAxNTAwOA==", "bodyText": "what happens for something like: a[b][c] = 5 where in[][] a = []; ?\nThis is an assignment with member access.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214#discussion_r427015008", "createdAt": "2020-05-19T03:52:06Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -8423,4 +8434,337 @@ private STNode parseParenthesisedTypeDesc() {\n         STNode closeParen = parseCloseParenthesis();\n         return STNodeFactory.createParenthesisedTypeDescriptorNode(openParen, typedesc, closeParen);\n     }\n+\n+    /**\n+     * Parse binding-patterns.\n+     *\n+     * binding-pattern :=\n+     *   capture-binding-pattern\n+     *    | wildcard-binding-pattern\n+     *    | list-binding-pattern\n+     *    | mapping-binding-pattern\n+     *    | functional-binding-pattern\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     * wildcard-binding-pattern := _\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *    binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ] \n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     * rest-binding-pattern := ... variable-name\n+     * functional-binding-pattern := functionally-constructible-type-reference ( arg-list-binding-pattern )\n+     * arg-list-binding-pattern :=\n+     *    positional-arg-binding-patterns [, other-arg-binding-patterns]\n+     *    | other-arg-binding-patterns\n+     * positional-arg-binding-patterns := positional-arg-binding-pattern (, positional-arg-binding-pattern)*\n+     * positional-arg-binding-pattern := binding-pattern\n+     * other-arg-binding-patterns :=\n+     *    named-arg-binding-patterns [, rest-binding-pattern]\n+     *    | [rest-binding-pattern]\n+     * named-arg-binding-patterns := named-arg-binding-pattern (, named-arg-binding-pattern)*\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n+     *\n+     * @return binding-pattern node\n+     */\n+    private STNode parseBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case OPEN_BRACKET_TOKEN:\n+                return parseListBindingPattern();\n+            case IDENTIFIER_TOKEN:\n+                return parseCaptureBindingPattern();\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse capture-binding-pattern.\n+     *\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     *\n+     * @return capture-binding-pattern node\n+     */\n+    private STNode parseCaptureBindingPattern() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case IDENTIFIER_TOKEN:\n+                STNode varName = parseVariableName();\n+                return STNodeFactory.createCaptureBindingPatternNode(varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.CAPTURE_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-patterns.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return list-binding-pattern node\n+     */\n+    private STNode parseListBindingPattern() {\n+        startContext(ParserRuleContext.LIST_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBracket = parseOpenBracket();\n+\n+        STNode listBindingPatternContent = parselistBindingPatternContent();\n+        bindingPatterns.add(listBindingPatternContent);\n+\n+        //parsing the main chunck of list-binding-pattern\n+        STToken token = getNextLBPToken(); // get next valid token\n+        STNode comma = null;\n+        while (!isEndOfListBindingPattern(token.kind) &&\n+                listBindingPatternContent.kind != SyntaxKind.REST_BINDING_PATTERN) {\n+            comma = parseComma();\n+            bindingPatterns.add(comma);\n+            listBindingPatternContent = parselistBindingPatternContent();\n+            bindingPatterns.add(listBindingPatternContent);\n+            token = getNextLBPToken();\n+        }\n+        STNode closeBracket = parseCloseBracket();\n+\n+        //seperating out the restbindingpattern\n+        STNode restBindingPattern = STNodeFactory.createEmptyNode();\n+        int lastIndex = bindingPatterns.size() - 1;\n+        STNode lastItem = bindingPatterns.get(lastIndex);\n+        if (lastItem.kind == SyntaxKind.REST_BINDING_PATTERN) {\n+            restBindingPattern = bindingPatterns.remove(lastIndex);\n+        }\n+\n+\n+        STNode bindingPatternsNode = STNodeFactory.createNodeList(bindingPatterns);\n+        endContext();\n+        return STNodeFactory.createListBindingPatternNode(openBracket,\n+                                                    bindingPatternsNode,\n+                                                    restBindingPattern,\n+                                                    closeBracket);\n+    }\n+\n+    private STToken getNextLBPToken() {\n+        STToken token = peek();\n+\n+        if (isEndOfListBindingPattern(token.kind)) {\n+            return token;\n+        }\n+\n+        switch (token.kind) {\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+            case IDENTIFIER_TOKEN:\n+            case ELLIPSIS_TOKEN:\n+            case OPEN_BRACKET_TOKEN:\n+            case COMMA_TOKEN:\n+                return token;\n+            default:\n+                consume(); // use the invalid token\n+                this.errorHandler.reportInvalidNode(token,\n+                        \"invalid Token in list-binding-pattern\");\n+                return getNextLBPToken();\n+        }\n+    }\n+\n+    private boolean isEndOfListBindingPattern(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case IN_KEYWORD:\n+            case CLOSE_BRACKET_TOKEN:\n+            case EOF_TOKEN:\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+                return true;\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    /**\n+     * Parse rest-binding-pattern.\n+     *\n+     * rest-binding-pattern := ... variable-name\n+     *\n+     * @return rest-binding-pattern node\n+     */\n+    private STNode parseRestBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case ELLIPSIS_TOKEN:\n+                startContext(ParserRuleContext.REST_BINDING_PATTERN);\n+                STNode ellipsis = parseEllipsis();\n+                STNode varName = parseVariableName();\n+                endContext();\n+                return STNodeFactory.createRestBindingPatternNode(ellipsis, varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.REST_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-pattern entry.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return rest-binding-pattern node\n+     */\n+    private STNode parselistBindingPatternContent() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+                return consume();\n+            case ELLIPSIS_TOKEN:\n+                return parseRestBindingPattern();\n+            default:\n+                return parseBindingPattern();\n+        }\n+    }\n+\n+    /**\n+     * Parse Typed-binding-pattern.\n+     *\n+     * <code>typed-binding-pattern := inferable-type-descriptor binding-pattern</code>\n+     * <code>inferable-type-descriptor := type-descriptor | var</code>\n+     *\n+     * @return Fork statement\n+     */\n+    private STNode parseTypedBindingPattern() {\n+        startContext(ParserRuleContext.TYPED_BINDING_PATTERN);\n+        STNode typeDesc = parseTypeDescriptor(ParserRuleContext.TYPE_DESC_IN_TYPE_BINDING_PATTERN, 1);\n+\n+        STNode bindingPattern = null;\n+        if (peek().kind == SyntaxKind.OPEN_BRACKET_TOKEN) {\n+            STNode[] parsed = parseArrayTypeDescOrLBP(typeDesc);\n+            typeDesc = parsed[0];\n+            bindingPattern = parsed[1];\n+        } else {\n+            bindingPattern = parseBindingPattern();\n+        }\n+\n+        endContext();\n+        return STNodeFactory.createTypedBindingPatternNode(typeDesc, bindingPattern);\n+    }\n+\n+    private STNode[] parseArrayTypeDescOrLBP(STNode typeDesc) {\n+\n+        STNode arrayDescOrBLP = parseListBindingPattern();\n+\n+        if (isLBPDefinitively(arrayDescOrBLP)) { // ambiguous means T[a]\n+            return new STNode[]{typeDesc, cleanLBP(arrayDescOrBLP)};\n+        } else {\n+            if (isFollowTypedBindingPattern(peek().kind)) {\n+                return new STNode[]{typeDesc, cleanLBP(arrayDescOrBLP)};\n+            } else {\n+                typeDesc = mergeTypeDescAndLBP(typeDesc, arrayDescOrBLP);\n+                if (peek().kind == SyntaxKind.OPEN_BRACKET_TOKEN) {\n+                    //this means arrayDescOrBLP is a array type desc\n+                    return parseArrayTypeDescOrLBP(typeDesc);\n+                } else {\n+                    return new STNode[]{typeDesc, parseBindingPattern()};\n+                }\n+            }\n+        }\n+    }\n+\n+    private STNode mergeTypeDescAndLBP(STNode typeDesc, STNode LBP) {\n+        STListBindingPatternNode lbp = (STListBindingPatternNode) LBP;\n+        STNodeList childArray = (STNodeList)lbp.bindingPatterns;\n+        STNode child = childArray.childInBucket(0);\n+        if (child.kind == SyntaxKind.CAPTURE_BINDING_PATTERN) {\n+            child = ((STCaptureBindingPatternNode)child).variableName;\n+        }\n+        return STNodeFactory.createIndexedExpressionNode(typeDesc, lbp.openBracket,\n+                child,\n+                lbp.closeBracket);\n+    }\n+\n+    private STNode cleanLBP(STNode arrayDescOrBLP) {\n+        STListBindingPatternNode lbp = (STListBindingPatternNode) arrayDescOrBLP;\n+        STNodeList childArray = (STNodeList)lbp.bindingPatterns;\n+        int numberOfChildren = childArray.bucketCount();\n+\n+        ArrayList<STNode> cleanedChildren = new ArrayList<>();\n+        STNode child = null;\n+        for (int i =0; i<numberOfChildren;i++) {\n+            child = childArray.childInBucket(i);\n+            switch (child.kind) {\n+                case DECIMAL_INTEGER_LITERAL:\n+                case HEX_INTEGER_LITERAL:\n+                case ASTERISK_TOKEN:\n+                    this.errorHandler.reportInvalidNode(null,\n+                            \"invalid Node \" + child.kind + \" in list-binding-pattern\");\n+                    cleanedChildren.add(STNodeFactory.createMissingToken(SyntaxKind.IDENTIFIER_TOKEN));\n+                    break;\n+                default:\n+                    cleanedChildren.add(child);\n+                    break;\n+            }\n+        }\n+\n+        return STNodeFactory.createListBindingPatternNode(lbp.openBracket,\n+                STNodeFactory.createNodeList(cleanedChildren),\n+                lbp.restBindingPattern,\n+                lbp.closeBracket);\n+    }\n+\n+    private boolean isLBPDefinitively(STNode arrayDescOrBLP) {\n+        STListBindingPatternNode lbp = (STListBindingPatternNode) arrayDescOrBLP;\n+        STNodeList childArray = (STNodeList)lbp.bindingPatterns;\n+        int numberOfChildren = childArray.bucketCount();\n+\n+        if (lbp.restBindingPattern != null) {\n+            return true;\n+        }\n+\n+        if (numberOfChildren ==1 ) {\n+            STNode child = childArray.childInBucket(0);\n+            switch (child.kind) {\n+                case DECIMAL_INTEGER_LITERAL:\n+                case HEX_INTEGER_LITERAL:\n+                case ASTERISK_TOKEN:\n+                case CAPTURE_BINDING_PATTERN:\n+                    return false;\n+                default: // cases like [ and {\n+                    return true;\n+            }\n+        } else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e1d5994f3adf89a684d1d1f04dc32e4da40a034"}, "originalPosition": 462}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e8c7613c2603559c2478a3ccd61151d3593f9282", "author": {"user": {"login": "m36dot", "name": "Saif Abdul Cassim"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e8c7613c2603559c2478a3ccd61151d3593f9282", "committedDate": "2020-05-19T07:22:59Z", "message": "Refactor Code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a8da3de833d2c37c457a677d7d7738536b3b005f", "author": {"user": {"login": "m36dot", "name": "Saif Abdul Cassim"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a8da3de833d2c37c457a677d7d7738536b3b005f", "committedDate": "2020-05-19T07:53:47Z", "message": "Fix checkstyle issue"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a39a345646e917a504271e5b8534b7a4f76d51a5", "author": {"user": {"login": "m36dot", "name": "Saif Abdul Cassim"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a39a345646e917a504271e5b8534b7a4f76d51a5", "committedDate": "2020-05-19T08:43:56Z", "message": "Fix merge conflict"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ec0194d19cb63c5625e12d2e801076bf078fc873", "author": {"user": {"login": "m36dot", "name": "Saif Abdul Cassim"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/ec0194d19cb63c5625e12d2e801076bf078fc873", "committedDate": "2020-05-19T09:14:20Z", "message": "Fix infinite loop with the right pattern"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0Mjg2NjI5", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214#pullrequestreview-414286629", "createdAt": "2020-05-19T09:55:08Z", "commit": {"oid": "ec0194d19cb63c5625e12d2e801076bf078fc873"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwOTo1NTowOFrOGXY2JQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwOTo1NTozM1rOGXY3Dw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE3NzUwOQ==", "bodyText": "Should create the createEmptyNode inside else block of the below 'if'", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214#discussion_r427177509", "createdAt": "2020-05-19T09:55:08Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -9343,4 +9375,340 @@ private STNode parseIntersectionTypeDescriptor(STNode leftTypeDesc, ParserRuleCo\n         STNode rightTypeDesc = parseTypeDescriptor(context);\n         return STNodeFactory.createIntersectionTypeDescriptorNode(leftTypeDesc, bitwiseAndToken, rightTypeDesc);\n     }\n+\n+    /**\n+     * Parse binding-patterns.\n+     *\n+     * binding-pattern :=\n+     *   capture-binding-pattern\n+     *    | wildcard-binding-pattern\n+     *    | list-binding-pattern\n+     *    | mapping-binding-pattern\n+     *    | functional-binding-pattern\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     * wildcard-binding-pattern := _\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *    binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ] \n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     * rest-binding-pattern := ... variable-name\n+     * functional-binding-pattern := functionally-constructible-type-reference ( arg-list-binding-pattern )\n+     * arg-list-binding-pattern :=\n+     *    positional-arg-binding-patterns [, other-arg-binding-patterns]\n+     *    | other-arg-binding-patterns\n+     * positional-arg-binding-patterns := positional-arg-binding-pattern (, positional-arg-binding-pattern)*\n+     * positional-arg-binding-pattern := binding-pattern\n+     * other-arg-binding-patterns :=\n+     *    named-arg-binding-patterns [, rest-binding-pattern]\n+     *    | [rest-binding-pattern]\n+     * named-arg-binding-patterns := named-arg-binding-pattern (, named-arg-binding-pattern)*\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n+     *\n+     * @return binding-pattern node\n+     */\n+    private STNode parseBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case OPEN_BRACKET_TOKEN:\n+                return parseListBindingPattern();\n+            case IDENTIFIER_TOKEN:\n+                return parseCaptureBindingPattern();\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse capture-binding-pattern.\n+     *\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     *\n+     * @return capture-binding-pattern node\n+     */\n+    private STNode parseCaptureBindingPattern() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case IDENTIFIER_TOKEN:\n+                STNode varName = parseVariableName();\n+                return STNodeFactory.createCaptureBindingPatternNode(varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.CAPTURE_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-patterns.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return list-binding-pattern node\n+     */\n+    private STNode parseListBindingPattern() {\n+        startContext(ParserRuleContext.LIST_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBracket = parseOpenBracket();\n+\n+        STNode listBindingPatternMember = parselistBindingPatternMember();\n+        bindingPatterns.add(listBindingPatternMember);\n+\n+        //parsing the main chunck of list-binding-pattern\n+        STToken token = peek(); // get next valid token\n+        STNode listBindingPatternRhs = null;\n+        while (!isEndOfListBindingPattern(token.kind) &&\n+                listBindingPatternMember.kind != SyntaxKind.REST_BINDING_PATTERN) {\n+            listBindingPatternRhs = parseListBindingpatternRhs(token.kind);\n+            if (listBindingPatternRhs == null) {\n+                break;\n+            }\n+            bindingPatterns.add(listBindingPatternRhs);\n+            listBindingPatternMember = parselistBindingPatternMember();\n+            bindingPatterns.add(listBindingPatternMember);\n+            token = peek();\n+        }\n+        STNode closeBracket = parseCloseBracket();\n+\n+        //seperating out the restbindingpattern\n+        STNode restBindingPattern = STNodeFactory.createEmptyNode();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec0194d19cb63c5625e12d2e801076bf078fc873"}, "originalPosition": 261}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE3Nzc0Mw==", "bodyText": "wrong context.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214#discussion_r427177743", "createdAt": "2020-05-19T09:55:33Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -9343,4 +9375,340 @@ private STNode parseIntersectionTypeDescriptor(STNode leftTypeDesc, ParserRuleCo\n         STNode rightTypeDesc = parseTypeDescriptor(context);\n         return STNodeFactory.createIntersectionTypeDescriptorNode(leftTypeDesc, bitwiseAndToken, rightTypeDesc);\n     }\n+\n+    /**\n+     * Parse binding-patterns.\n+     *\n+     * binding-pattern :=\n+     *   capture-binding-pattern\n+     *    | wildcard-binding-pattern\n+     *    | list-binding-pattern\n+     *    | mapping-binding-pattern\n+     *    | functional-binding-pattern\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     * wildcard-binding-pattern := _\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *    binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ] \n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     * rest-binding-pattern := ... variable-name\n+     * functional-binding-pattern := functionally-constructible-type-reference ( arg-list-binding-pattern )\n+     * arg-list-binding-pattern :=\n+     *    positional-arg-binding-patterns [, other-arg-binding-patterns]\n+     *    | other-arg-binding-patterns\n+     * positional-arg-binding-patterns := positional-arg-binding-pattern (, positional-arg-binding-pattern)*\n+     * positional-arg-binding-pattern := binding-pattern\n+     * other-arg-binding-patterns :=\n+     *    named-arg-binding-patterns [, rest-binding-pattern]\n+     *    | [rest-binding-pattern]\n+     * named-arg-binding-patterns := named-arg-binding-pattern (, named-arg-binding-pattern)*\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n+     *\n+     * @return binding-pattern node\n+     */\n+    private STNode parseBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case OPEN_BRACKET_TOKEN:\n+                return parseListBindingPattern();\n+            case IDENTIFIER_TOKEN:\n+                return parseCaptureBindingPattern();\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse capture-binding-pattern.\n+     *\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     *\n+     * @return capture-binding-pattern node\n+     */\n+    private STNode parseCaptureBindingPattern() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case IDENTIFIER_TOKEN:\n+                STNode varName = parseVariableName();\n+                return STNodeFactory.createCaptureBindingPatternNode(varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.CAPTURE_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-patterns.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return list-binding-pattern node\n+     */\n+    private STNode parseListBindingPattern() {\n+        startContext(ParserRuleContext.LIST_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBracket = parseOpenBracket();\n+\n+        STNode listBindingPatternMember = parselistBindingPatternMember();\n+        bindingPatterns.add(listBindingPatternMember);\n+\n+        //parsing the main chunck of list-binding-pattern\n+        STToken token = peek(); // get next valid token\n+        STNode listBindingPatternRhs = null;\n+        while (!isEndOfListBindingPattern(token.kind) &&\n+                listBindingPatternMember.kind != SyntaxKind.REST_BINDING_PATTERN) {\n+            listBindingPatternRhs = parseListBindingpatternRhs(token.kind);\n+            if (listBindingPatternRhs == null) {\n+                break;\n+            }\n+            bindingPatterns.add(listBindingPatternRhs);\n+            listBindingPatternMember = parselistBindingPatternMember();\n+            bindingPatterns.add(listBindingPatternMember);\n+            token = peek();\n+        }\n+        STNode closeBracket = parseCloseBracket();\n+\n+        //seperating out the restbindingpattern\n+        STNode restBindingPattern = STNodeFactory.createEmptyNode();\n+        if (listBindingPatternMember.kind == SyntaxKind.REST_BINDING_PATTERN) {\n+            restBindingPattern = bindingPatterns.remove(bindingPatterns.size() - 1);\n+        }\n+\n+        STNode bindingPatternsNode = STNodeFactory.createNodeList(bindingPatterns);\n+        endContext();\n+        return STNodeFactory.createListBindingPatternNode(openBracket,\n+                                                    bindingPatternsNode,\n+                                                    restBindingPattern,\n+                                                    closeBracket);\n+    }\n+\n+    private STNode parseListBindingpatternRhs() {\n+        return parseListBindingpatternRhs(peek().kind);\n+    }\n+\n+    private STNode parseListBindingpatternRhs(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case COMMA_TOKEN:\n+                return parseComma();\n+            case CLOSE_BRACKET_TOKEN:\n+                return null;\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.TYPE_DESC_IN_TUPLE_RHS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec0194d19cb63c5625e12d2e801076bf078fc873"}, "originalPosition": 285}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "86b3868076bb1f535f392b0160046ac64a83811d", "author": {"user": {"login": "m36dot", "name": "Saif Abdul Cassim"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/86b3868076bb1f535f392b0160046ac64a83811d", "committedDate": "2020-05-19T10:26:39Z", "message": "Fix typo"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0MzAzMTA1", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214#pullrequestreview-414303105", "createdAt": "2020-05-19T10:16:36Z", "commit": {"oid": "ec0194d19cb63c5625e12d2e801076bf078fc873"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxMDoxNjozN1rOGXZodw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxMDozNDo1NlrOGXaPTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE5MDM5MQ==", "bodyText": "body of this if block is same as above. can we merge the two?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214#discussion_r427190391", "createdAt": "2020-05-19T10:16:37Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -9343,4 +9375,340 @@ private STNode parseIntersectionTypeDescriptor(STNode leftTypeDesc, ParserRuleCo\n         STNode rightTypeDesc = parseTypeDescriptor(context);\n         return STNodeFactory.createIntersectionTypeDescriptorNode(leftTypeDesc, bitwiseAndToken, rightTypeDesc);\n     }\n+\n+    /**\n+     * Parse binding-patterns.\n+     *\n+     * binding-pattern :=\n+     *   capture-binding-pattern\n+     *    | wildcard-binding-pattern\n+     *    | list-binding-pattern\n+     *    | mapping-binding-pattern\n+     *    | functional-binding-pattern\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     * wildcard-binding-pattern := _\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *    binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ] \n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     * rest-binding-pattern := ... variable-name\n+     * functional-binding-pattern := functionally-constructible-type-reference ( arg-list-binding-pattern )\n+     * arg-list-binding-pattern :=\n+     *    positional-arg-binding-patterns [, other-arg-binding-patterns]\n+     *    | other-arg-binding-patterns\n+     * positional-arg-binding-patterns := positional-arg-binding-pattern (, positional-arg-binding-pattern)*\n+     * positional-arg-binding-pattern := binding-pattern\n+     * other-arg-binding-patterns :=\n+     *    named-arg-binding-patterns [, rest-binding-pattern]\n+     *    | [rest-binding-pattern]\n+     * named-arg-binding-patterns := named-arg-binding-pattern (, named-arg-binding-pattern)*\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n+     *\n+     * @return binding-pattern node\n+     */\n+    private STNode parseBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case OPEN_BRACKET_TOKEN:\n+                return parseListBindingPattern();\n+            case IDENTIFIER_TOKEN:\n+                return parseCaptureBindingPattern();\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse capture-binding-pattern.\n+     *\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     *\n+     * @return capture-binding-pattern node\n+     */\n+    private STNode parseCaptureBindingPattern() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case IDENTIFIER_TOKEN:\n+                STNode varName = parseVariableName();\n+                return STNodeFactory.createCaptureBindingPatternNode(varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.CAPTURE_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-patterns.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return list-binding-pattern node\n+     */\n+    private STNode parseListBindingPattern() {\n+        startContext(ParserRuleContext.LIST_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBracket = parseOpenBracket();\n+\n+        STNode listBindingPatternMember = parselistBindingPatternMember();\n+        bindingPatterns.add(listBindingPatternMember);\n+\n+        //parsing the main chunck of list-binding-pattern\n+        STToken token = peek(); // get next valid token\n+        STNode listBindingPatternRhs = null;\n+        while (!isEndOfListBindingPattern(token.kind) &&\n+                listBindingPatternMember.kind != SyntaxKind.REST_BINDING_PATTERN) {\n+            listBindingPatternRhs = parseListBindingpatternRhs(token.kind);\n+            if (listBindingPatternRhs == null) {\n+                break;\n+            }\n+            bindingPatterns.add(listBindingPatternRhs);\n+            listBindingPatternMember = parselistBindingPatternMember();\n+            bindingPatterns.add(listBindingPatternMember);\n+            token = peek();\n+        }\n+        STNode closeBracket = parseCloseBracket();\n+\n+        //seperating out the restbindingpattern\n+        STNode restBindingPattern = STNodeFactory.createEmptyNode();\n+        if (listBindingPatternMember.kind == SyntaxKind.REST_BINDING_PATTERN) {\n+            restBindingPattern = bindingPatterns.remove(bindingPatterns.size() - 1);\n+        }\n+\n+        STNode bindingPatternsNode = STNodeFactory.createNodeList(bindingPatterns);\n+        endContext();\n+        return STNodeFactory.createListBindingPatternNode(openBracket,\n+                                                    bindingPatternsNode,\n+                                                    restBindingPattern,\n+                                                    closeBracket);\n+    }\n+\n+    private STNode parseListBindingpatternRhs() {\n+        return parseListBindingpatternRhs(peek().kind);\n+    }\n+\n+    private STNode parseListBindingpatternRhs(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case COMMA_TOKEN:\n+                return parseComma();\n+            case CLOSE_BRACKET_TOKEN:\n+                return null;\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.TYPE_DESC_IN_TUPLE_RHS);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseListBindingpatternRhs(solution.tokenKind);\n+        }\n+    }\n+\n+    private boolean isEndOfListBindingPattern(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case IN_KEYWORD:\n+            case CLOSE_BRACKET_TOKEN:\n+            case EOF_TOKEN:\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+                return true;\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    /**\n+     * Parse rest-binding-pattern.\n+     *\n+     * rest-binding-pattern := ... variable-name\n+     *\n+     * @return rest-binding-pattern node\n+     */\n+    private STNode parseRestBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case ELLIPSIS_TOKEN:\n+                startContext(ParserRuleContext.REST_BINDING_PATTERN);\n+                STNode ellipsis = parseEllipsis();\n+                STNode varName = parseVariableName();\n+                endContext();\n+                return STNodeFactory.createRestBindingPatternNode(ellipsis, varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.REST_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-pattern entry.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return rest-binding-pattern node\n+     */\n+    private STNode parselistBindingPatternMember() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+                return consume();\n+            case ELLIPSIS_TOKEN:\n+                return parseRestBindingPattern();\n+            default:\n+                return parseBindingPattern();\n+        }\n+    }\n+\n+    /**\n+     * Parse Typed-binding-pattern.\n+     *\n+     * <code>typed-binding-pattern := inferable-type-descriptor binding-pattern</code>\n+     * <code>inferable-type-descriptor := type-descriptor | var</code>\n+     *\n+     * @return Fork statement\n+     */\n+    private STNode parseTypedBindingPattern() {\n+        startContext(ParserRuleContext.TYPED_BINDING_PATTERN);\n+        STNode typeDesc = parseTypeDescriptor(ParserRuleContext.TYPE_DESC_IN_TYPE_BINDING_PATTERN, true);\n+\n+        STNode bindingPattern = null;\n+        if (peek().kind == SyntaxKind.OPEN_BRACKET_TOKEN) {\n+            STNode typedBindingPattern = parseArrayTypeDescOrListBindingPattern(typeDesc);\n+            endContext();\n+            return typedBindingPattern;\n+        }\n+        bindingPattern = parseBindingPattern();\n+\n+        endContext();\n+        return STNodeFactory.createTypedBindingPatternNode(typeDesc, bindingPattern);\n+    }\n+\n+    private STNode parseArrayTypeDescOrListBindingPattern(STNode typeDesc) {\n+\n+        STNode arrayDescOrListBindingPattern = parseListBindingPattern();\n+\n+        if (isListBindingPatternDefinitively(arrayDescOrListBindingPattern)) { // ambiguous means T[a]\n+            return STNodeFactory.createTypedBindingPatternNode(typeDesc,\n+                    cleanListBindingPattern(arrayDescOrListBindingPattern));\n+        }\n+\n+        if (isFollowTypedBindingPattern(peek().kind)) {\n+            return STNodeFactory.createTypedBindingPatternNode(typeDesc,\n+                    cleanListBindingPattern(arrayDescOrListBindingPattern));\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec0194d19cb63c5625e12d2e801076bf078fc873"}, "originalPosition": 396}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE5MTU1MA==", "bodyText": "Can you add a comment mentioning what are we checking here, and why we need that?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214#discussion_r427191550", "createdAt": "2020-05-19T10:18:40Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -9343,4 +9375,340 @@ private STNode parseIntersectionTypeDescriptor(STNode leftTypeDesc, ParserRuleCo\n         STNode rightTypeDesc = parseTypeDescriptor(context);\n         return STNodeFactory.createIntersectionTypeDescriptorNode(leftTypeDesc, bitwiseAndToken, rightTypeDesc);\n     }\n+\n+    /**\n+     * Parse binding-patterns.\n+     *\n+     * binding-pattern :=\n+     *   capture-binding-pattern\n+     *    | wildcard-binding-pattern\n+     *    | list-binding-pattern\n+     *    | mapping-binding-pattern\n+     *    | functional-binding-pattern\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     * wildcard-binding-pattern := _\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *    binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ] \n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     * rest-binding-pattern := ... variable-name\n+     * functional-binding-pattern := functionally-constructible-type-reference ( arg-list-binding-pattern )\n+     * arg-list-binding-pattern :=\n+     *    positional-arg-binding-patterns [, other-arg-binding-patterns]\n+     *    | other-arg-binding-patterns\n+     * positional-arg-binding-patterns := positional-arg-binding-pattern (, positional-arg-binding-pattern)*\n+     * positional-arg-binding-pattern := binding-pattern\n+     * other-arg-binding-patterns :=\n+     *    named-arg-binding-patterns [, rest-binding-pattern]\n+     *    | [rest-binding-pattern]\n+     * named-arg-binding-patterns := named-arg-binding-pattern (, named-arg-binding-pattern)*\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n+     *\n+     * @return binding-pattern node\n+     */\n+    private STNode parseBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case OPEN_BRACKET_TOKEN:\n+                return parseListBindingPattern();\n+            case IDENTIFIER_TOKEN:\n+                return parseCaptureBindingPattern();\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse capture-binding-pattern.\n+     *\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     *\n+     * @return capture-binding-pattern node\n+     */\n+    private STNode parseCaptureBindingPattern() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case IDENTIFIER_TOKEN:\n+                STNode varName = parseVariableName();\n+                return STNodeFactory.createCaptureBindingPatternNode(varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.CAPTURE_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-patterns.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return list-binding-pattern node\n+     */\n+    private STNode parseListBindingPattern() {\n+        startContext(ParserRuleContext.LIST_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBracket = parseOpenBracket();\n+\n+        STNode listBindingPatternMember = parselistBindingPatternMember();\n+        bindingPatterns.add(listBindingPatternMember);\n+\n+        //parsing the main chunck of list-binding-pattern\n+        STToken token = peek(); // get next valid token\n+        STNode listBindingPatternRhs = null;\n+        while (!isEndOfListBindingPattern(token.kind) &&\n+                listBindingPatternMember.kind != SyntaxKind.REST_BINDING_PATTERN) {\n+            listBindingPatternRhs = parseListBindingpatternRhs(token.kind);\n+            if (listBindingPatternRhs == null) {\n+                break;\n+            }\n+            bindingPatterns.add(listBindingPatternRhs);\n+            listBindingPatternMember = parselistBindingPatternMember();\n+            bindingPatterns.add(listBindingPatternMember);\n+            token = peek();\n+        }\n+        STNode closeBracket = parseCloseBracket();\n+\n+        //seperating out the restbindingpattern\n+        STNode restBindingPattern = STNodeFactory.createEmptyNode();\n+        if (listBindingPatternMember.kind == SyntaxKind.REST_BINDING_PATTERN) {\n+            restBindingPattern = bindingPatterns.remove(bindingPatterns.size() - 1);\n+        }\n+\n+        STNode bindingPatternsNode = STNodeFactory.createNodeList(bindingPatterns);\n+        endContext();\n+        return STNodeFactory.createListBindingPatternNode(openBracket,\n+                                                    bindingPatternsNode,\n+                                                    restBindingPattern,\n+                                                    closeBracket);\n+    }\n+\n+    private STNode parseListBindingpatternRhs() {\n+        return parseListBindingpatternRhs(peek().kind);\n+    }\n+\n+    private STNode parseListBindingpatternRhs(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case COMMA_TOKEN:\n+                return parseComma();\n+            case CLOSE_BRACKET_TOKEN:\n+                return null;\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.TYPE_DESC_IN_TUPLE_RHS);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseListBindingpatternRhs(solution.tokenKind);\n+        }\n+    }\n+\n+    private boolean isEndOfListBindingPattern(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case IN_KEYWORD:\n+            case CLOSE_BRACKET_TOKEN:\n+            case EOF_TOKEN:\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+                return true;\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    /**\n+     * Parse rest-binding-pattern.\n+     *\n+     * rest-binding-pattern := ... variable-name\n+     *\n+     * @return rest-binding-pattern node\n+     */\n+    private STNode parseRestBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case ELLIPSIS_TOKEN:\n+                startContext(ParserRuleContext.REST_BINDING_PATTERN);\n+                STNode ellipsis = parseEllipsis();\n+                STNode varName = parseVariableName();\n+                endContext();\n+                return STNodeFactory.createRestBindingPatternNode(ellipsis, varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.REST_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-pattern entry.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return rest-binding-pattern node\n+     */\n+    private STNode parselistBindingPatternMember() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+                return consume();\n+            case ELLIPSIS_TOKEN:\n+                return parseRestBindingPattern();\n+            default:\n+                return parseBindingPattern();\n+        }\n+    }\n+\n+    /**\n+     * Parse Typed-binding-pattern.\n+     *\n+     * <code>typed-binding-pattern := inferable-type-descriptor binding-pattern</code>\n+     * <code>inferable-type-descriptor := type-descriptor | var</code>\n+     *\n+     * @return Fork statement\n+     */\n+    private STNode parseTypedBindingPattern() {\n+        startContext(ParserRuleContext.TYPED_BINDING_PATTERN);\n+        STNode typeDesc = parseTypeDescriptor(ParserRuleContext.TYPE_DESC_IN_TYPE_BINDING_PATTERN, true);\n+\n+        STNode bindingPattern = null;\n+        if (peek().kind == SyntaxKind.OPEN_BRACKET_TOKEN) {\n+            STNode typedBindingPattern = parseArrayTypeDescOrListBindingPattern(typeDesc);\n+            endContext();\n+            return typedBindingPattern;\n+        }\n+        bindingPattern = parseBindingPattern();\n+\n+        endContext();\n+        return STNodeFactory.createTypedBindingPatternNode(typeDesc, bindingPattern);\n+    }\n+\n+    private STNode parseArrayTypeDescOrListBindingPattern(STNode typeDesc) {\n+\n+        STNode arrayDescOrListBindingPattern = parseListBindingPattern();\n+\n+        if (isListBindingPatternDefinitively(arrayDescOrListBindingPattern)) { // ambiguous means T[a]\n+            return STNodeFactory.createTypedBindingPatternNode(typeDesc,\n+                    cleanListBindingPattern(arrayDescOrListBindingPattern));\n+        }\n+\n+        if (isFollowTypedBindingPattern(peek().kind)) {\n+            return STNodeFactory.createTypedBindingPatternNode(typeDesc,\n+                    cleanListBindingPattern(arrayDescOrListBindingPattern));\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE5MDM5MQ=="}, "originalCommit": {"oid": "ec0194d19cb63c5625e12d2e801076bf078fc873"}, "originalPosition": 396}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE5MTg5OQ==", "bodyText": "Extra new lines", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214#discussion_r427191899", "createdAt": "2020-05-19T10:19:19Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -9343,4 +9375,340 @@ private STNode parseIntersectionTypeDescriptor(STNode leftTypeDesc, ParserRuleCo\n         STNode rightTypeDesc = parseTypeDescriptor(context);\n         return STNodeFactory.createIntersectionTypeDescriptorNode(leftTypeDesc, bitwiseAndToken, rightTypeDesc);\n     }\n+\n+    /**\n+     * Parse binding-patterns.\n+     *\n+     * binding-pattern :=\n+     *   capture-binding-pattern\n+     *    | wildcard-binding-pattern\n+     *    | list-binding-pattern\n+     *    | mapping-binding-pattern\n+     *    | functional-binding-pattern\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     * wildcard-binding-pattern := _\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *    binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ] \n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     * rest-binding-pattern := ... variable-name\n+     * functional-binding-pattern := functionally-constructible-type-reference ( arg-list-binding-pattern )\n+     * arg-list-binding-pattern :=\n+     *    positional-arg-binding-patterns [, other-arg-binding-patterns]\n+     *    | other-arg-binding-patterns\n+     * positional-arg-binding-patterns := positional-arg-binding-pattern (, positional-arg-binding-pattern)*\n+     * positional-arg-binding-pattern := binding-pattern\n+     * other-arg-binding-patterns :=\n+     *    named-arg-binding-patterns [, rest-binding-pattern]\n+     *    | [rest-binding-pattern]\n+     * named-arg-binding-patterns := named-arg-binding-pattern (, named-arg-binding-pattern)*\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n+     *\n+     * @return binding-pattern node\n+     */\n+    private STNode parseBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case OPEN_BRACKET_TOKEN:\n+                return parseListBindingPattern();\n+            case IDENTIFIER_TOKEN:\n+                return parseCaptureBindingPattern();\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse capture-binding-pattern.\n+     *\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     *\n+     * @return capture-binding-pattern node\n+     */\n+    private STNode parseCaptureBindingPattern() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case IDENTIFIER_TOKEN:\n+                STNode varName = parseVariableName();\n+                return STNodeFactory.createCaptureBindingPatternNode(varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.CAPTURE_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-patterns.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return list-binding-pattern node\n+     */\n+    private STNode parseListBindingPattern() {\n+        startContext(ParserRuleContext.LIST_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBracket = parseOpenBracket();\n+\n+        STNode listBindingPatternMember = parselistBindingPatternMember();\n+        bindingPatterns.add(listBindingPatternMember);\n+\n+        //parsing the main chunck of list-binding-pattern\n+        STToken token = peek(); // get next valid token\n+        STNode listBindingPatternRhs = null;\n+        while (!isEndOfListBindingPattern(token.kind) &&\n+                listBindingPatternMember.kind != SyntaxKind.REST_BINDING_PATTERN) {\n+            listBindingPatternRhs = parseListBindingpatternRhs(token.kind);\n+            if (listBindingPatternRhs == null) {\n+                break;\n+            }\n+            bindingPatterns.add(listBindingPatternRhs);\n+            listBindingPatternMember = parselistBindingPatternMember();\n+            bindingPatterns.add(listBindingPatternMember);\n+            token = peek();\n+        }\n+        STNode closeBracket = parseCloseBracket();\n+\n+        //seperating out the restbindingpattern\n+        STNode restBindingPattern = STNodeFactory.createEmptyNode();\n+        if (listBindingPatternMember.kind == SyntaxKind.REST_BINDING_PATTERN) {\n+            restBindingPattern = bindingPatterns.remove(bindingPatterns.size() - 1);\n+        }\n+\n+        STNode bindingPatternsNode = STNodeFactory.createNodeList(bindingPatterns);\n+        endContext();\n+        return STNodeFactory.createListBindingPatternNode(openBracket,\n+                                                    bindingPatternsNode,\n+                                                    restBindingPattern,\n+                                                    closeBracket);\n+    }\n+\n+    private STNode parseListBindingpatternRhs() {\n+        return parseListBindingpatternRhs(peek().kind);\n+    }\n+\n+    private STNode parseListBindingpatternRhs(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case COMMA_TOKEN:\n+                return parseComma();\n+            case CLOSE_BRACKET_TOKEN:\n+                return null;\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.TYPE_DESC_IN_TUPLE_RHS);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseListBindingpatternRhs(solution.tokenKind);\n+        }\n+    }\n+\n+    private boolean isEndOfListBindingPattern(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case IN_KEYWORD:\n+            case CLOSE_BRACKET_TOKEN:\n+            case EOF_TOKEN:\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+                return true;\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    /**\n+     * Parse rest-binding-pattern.\n+     *\n+     * rest-binding-pattern := ... variable-name\n+     *\n+     * @return rest-binding-pattern node\n+     */\n+    private STNode parseRestBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case ELLIPSIS_TOKEN:\n+                startContext(ParserRuleContext.REST_BINDING_PATTERN);\n+                STNode ellipsis = parseEllipsis();\n+                STNode varName = parseVariableName();\n+                endContext();\n+                return STNodeFactory.createRestBindingPatternNode(ellipsis, varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.REST_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-pattern entry.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return rest-binding-pattern node\n+     */\n+    private STNode parselistBindingPatternMember() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+                return consume();\n+            case ELLIPSIS_TOKEN:\n+                return parseRestBindingPattern();\n+            default:\n+                return parseBindingPattern();\n+        }\n+    }\n+\n+    /**\n+     * Parse Typed-binding-pattern.\n+     *\n+     * <code>typed-binding-pattern := inferable-type-descriptor binding-pattern</code>\n+     * <code>inferable-type-descriptor := type-descriptor | var</code>\n+     *\n+     * @return Fork statement\n+     */\n+    private STNode parseTypedBindingPattern() {\n+        startContext(ParserRuleContext.TYPED_BINDING_PATTERN);\n+        STNode typeDesc = parseTypeDescriptor(ParserRuleContext.TYPE_DESC_IN_TYPE_BINDING_PATTERN, true);\n+\n+        STNode bindingPattern = null;\n+        if (peek().kind == SyntaxKind.OPEN_BRACKET_TOKEN) {\n+            STNode typedBindingPattern = parseArrayTypeDescOrListBindingPattern(typeDesc);\n+            endContext();\n+            return typedBindingPattern;\n+        }\n+        bindingPattern = parseBindingPattern();\n+\n+        endContext();\n+        return STNodeFactory.createTypedBindingPatternNode(typeDesc, bindingPattern);\n+    }\n+\n+    private STNode parseArrayTypeDescOrListBindingPattern(STNode typeDesc) {\n+\n+        STNode arrayDescOrListBindingPattern = parseListBindingPattern();\n+\n+        if (isListBindingPatternDefinitively(arrayDescOrListBindingPattern)) { // ambiguous means T[a]\n+            return STNodeFactory.createTypedBindingPatternNode(typeDesc,\n+                    cleanListBindingPattern(arrayDescOrListBindingPattern));\n+        }\n+\n+        if (isFollowTypedBindingPattern(peek().kind)) {\n+            return STNodeFactory.createTypedBindingPatternNode(typeDesc,\n+                    cleanListBindingPattern(arrayDescOrListBindingPattern));\n+        }\n+\n+        typeDesc = mergeTypeDescAndListBindingPattern(typeDesc, arrayDescOrListBindingPattern);\n+        if (peek().kind == SyntaxKind.OPEN_BRACKET_TOKEN) {\n+            //this means arrayDescOrBLP is a array type desc\n+            return parseArrayTypeDescOrListBindingPattern(typeDesc);\n+        } else {\n+            return STNodeFactory.createTypedBindingPatternNode(typeDesc,\n+                    parseBindingPattern());\n+        }\n+\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec0194d19cb63c5625e12d2e801076bf078fc873"}, "originalPosition": 407}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE5ODI1NA==", "bodyText": "I think its safe to do the reverse of this.\ni.e: if the only-child is captured-binding-patterns, then return true.\nThat way we don't have to update this method, when we add new binding patterns.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214#discussion_r427198254", "createdAt": "2020-05-19T10:31:00Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -9343,4 +9375,342 @@ private STNode parseIntersectionTypeDescriptor(STNode leftTypeDesc, ParserRuleCo\n         STNode rightTypeDesc = parseTypeDescriptor(context);\n         return STNodeFactory.createIntersectionTypeDescriptorNode(leftTypeDesc, bitwiseAndToken, rightTypeDesc);\n     }\n+\n+    /**\n+     * Parse binding-patterns.\n+     *\n+     * binding-pattern :=\n+     *   capture-binding-pattern\n+     *    | wildcard-binding-pattern\n+     *    | list-binding-pattern\n+     *    | mapping-binding-pattern\n+     *    | functional-binding-pattern\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     * wildcard-binding-pattern := _\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *    binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ] \n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     * rest-binding-pattern := ... variable-name\n+     * functional-binding-pattern := functionally-constructible-type-reference ( arg-list-binding-pattern )\n+     * arg-list-binding-pattern :=\n+     *    positional-arg-binding-patterns [, other-arg-binding-patterns]\n+     *    | other-arg-binding-patterns\n+     * positional-arg-binding-patterns := positional-arg-binding-pattern (, positional-arg-binding-pattern)*\n+     * positional-arg-binding-pattern := binding-pattern\n+     * other-arg-binding-patterns :=\n+     *    named-arg-binding-patterns [, rest-binding-pattern]\n+     *    | [rest-binding-pattern]\n+     * named-arg-binding-patterns := named-arg-binding-pattern (, named-arg-binding-pattern)*\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n+     *\n+     * @return binding-pattern node\n+     */\n+    private STNode parseBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case OPEN_BRACKET_TOKEN:\n+                return parseListBindingPattern();\n+            case IDENTIFIER_TOKEN:\n+                return parseCaptureBindingPattern();\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse capture-binding-pattern.\n+     *\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     *\n+     * @return capture-binding-pattern node\n+     */\n+    private STNode parseCaptureBindingPattern() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case IDENTIFIER_TOKEN:\n+                STNode varName = parseVariableName();\n+                return STNodeFactory.createCaptureBindingPatternNode(varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.CAPTURE_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-patterns.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return list-binding-pattern node\n+     */\n+    private STNode parseListBindingPattern() {\n+        startContext(ParserRuleContext.LIST_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBracket = parseOpenBracket();\n+\n+        STNode listBindingPatternMember = parselistBindingPatternMember();\n+        bindingPatterns.add(listBindingPatternMember);\n+\n+        //parsing the main chunck of list-binding-pattern\n+        STToken token = peek(); // get next valid token\n+        STNode listBindingPatternRhs = null;\n+        while (!isEndOfListBindingPattern(token.kind) &&\n+                listBindingPatternMember.kind != SyntaxKind.REST_BINDING_PATTERN) {\n+            listBindingPatternRhs = parseListBindingpatternRhs(token.kind);\n+            if (listBindingPatternRhs == null) {\n+                break;\n+            }\n+            bindingPatterns.add(listBindingPatternRhs);\n+            listBindingPatternMember = parselistBindingPatternMember();\n+            bindingPatterns.add(listBindingPatternMember);\n+            token = peek();\n+        }\n+        STNode closeBracket = parseCloseBracket();\n+\n+        //seperating out the restbindingpattern\n+        STNode restBindingPattern = null;\n+        if (listBindingPatternMember.kind == SyntaxKind.REST_BINDING_PATTERN) {\n+            restBindingPattern = bindingPatterns.remove(bindingPatterns.size() - 1);\n+        } else {\n+            restBindingPattern = STNodeFactory.createEmptyNode();\n+        }\n+\n+        STNode bindingPatternsNode = STNodeFactory.createNodeList(bindingPatterns);\n+        endContext();\n+        return STNodeFactory.createListBindingPatternNode(openBracket,\n+                                                    bindingPatternsNode,\n+                                                    restBindingPattern,\n+                                                    closeBracket);\n+    }\n+\n+    private STNode parseListBindingpatternRhs() {\n+        return parseListBindingpatternRhs(peek().kind);\n+    }\n+\n+    private STNode parseListBindingpatternRhs(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case COMMA_TOKEN:\n+                return parseComma();\n+            case CLOSE_BRACKET_TOKEN:\n+                return null;\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.LIST_BINDING_PATTERN_END_OR_CONTINUE);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseListBindingpatternRhs(solution.tokenKind);\n+        }\n+    }\n+\n+    private boolean isEndOfListBindingPattern(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case IN_KEYWORD:\n+            case CLOSE_BRACKET_TOKEN:\n+            case EOF_TOKEN:\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+                return true;\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    /**\n+     * Parse rest-binding-pattern.\n+     *\n+     * rest-binding-pattern := ... variable-name\n+     *\n+     * @return rest-binding-pattern node\n+     */\n+    private STNode parseRestBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case ELLIPSIS_TOKEN:\n+                startContext(ParserRuleContext.REST_BINDING_PATTERN);\n+                STNode ellipsis = parseEllipsis();\n+                STNode varName = parseVariableName();\n+                endContext();\n+                return STNodeFactory.createRestBindingPatternNode(ellipsis, varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.REST_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-pattern entry.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return rest-binding-pattern node\n+     */\n+    private STNode parselistBindingPatternMember() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+                return consume();\n+            case ELLIPSIS_TOKEN:\n+                return parseRestBindingPattern();\n+            default:\n+                return parseBindingPattern();\n+        }\n+    }\n+\n+    /**\n+     * Parse Typed-binding-pattern.\n+     *\n+     * <code>typed-binding-pattern := inferable-type-descriptor binding-pattern</code>\n+     * <code>inferable-type-descriptor := type-descriptor | var</code>\n+     *\n+     * @return Fork statement\n+     */\n+    private STNode parseTypedBindingPattern() {\n+        startContext(ParserRuleContext.TYPED_BINDING_PATTERN);\n+        STNode typeDesc = parseTypeDescriptor(ParserRuleContext.TYPE_DESC_IN_TYPE_BINDING_PATTERN, true);\n+\n+        STNode bindingPattern = null;\n+        if (peek().kind == SyntaxKind.OPEN_BRACKET_TOKEN) {\n+            STNode typedBindingPattern = parseArrayTypeDescOrListBindingPattern(typeDesc);\n+            endContext();\n+            return typedBindingPattern;\n+        }\n+        bindingPattern = parseBindingPattern();\n+\n+        endContext();\n+        return STNodeFactory.createTypedBindingPatternNode(typeDesc, bindingPattern);\n+    }\n+\n+    private STNode parseArrayTypeDescOrListBindingPattern(STNode typeDesc) {\n+\n+        STNode arrayDescOrListBindingPattern = parseListBindingPattern();\n+\n+        if (isListBindingPatternDefinitively(arrayDescOrListBindingPattern)) { // ambiguous means T[a]\n+            return STNodeFactory.createTypedBindingPatternNode(typeDesc,\n+                    cleanListBindingPattern(arrayDescOrListBindingPattern));\n+        }\n+\n+        if (isFollowTypedBindingPattern(peek().kind)) {\n+            return STNodeFactory.createTypedBindingPatternNode(typeDesc,\n+                    cleanListBindingPattern(arrayDescOrListBindingPattern));\n+        }\n+\n+        typeDesc = mergeTypeDescAndListBindingPattern(typeDesc, arrayDescOrListBindingPattern);\n+        if (peek().kind == SyntaxKind.OPEN_BRACKET_TOKEN) {\n+            //this means arrayDescOrBLP is a array type desc\n+            return parseArrayTypeDescOrListBindingPattern(typeDesc);\n+        } else {\n+            return STNodeFactory.createTypedBindingPatternNode(typeDesc,\n+                    parseBindingPattern());\n+        }\n+\n+\n+    }\n+\n+    private STNode mergeTypeDescAndListBindingPattern(STNode typeDesc,\n+                                                      STNode bindingPattern) {\n+        STListBindingPatternNode listBindingPattern = (STListBindingPatternNode) bindingPattern;\n+        STNodeList childArray = (STNodeList) listBindingPattern.bindingPatterns;\n+        STNode child = childArray.childInBucket(0);\n+        if (child.kind == SyntaxKind.CAPTURE_BINDING_PATTERN) {\n+            child = ((STCaptureBindingPatternNode) child).variableName;\n+        }\n+        return STNodeFactory.createIndexedExpressionNode(typeDesc, listBindingPattern.openBracket,\n+                child,\n+                listBindingPattern.closeBracket);\n+    }\n+\n+    private STNode cleanListBindingPattern(STNode bindingPattern) {\n+        STListBindingPatternNode listBindingPattern = (STListBindingPatternNode) bindingPattern;\n+        STNodeList childArray = (STNodeList) listBindingPattern.bindingPatterns;\n+        int numberOfChildren = childArray.bucketCount();\n+\n+        ArrayList<STNode> cleanedChildren = new ArrayList<>();\n+        STNode child = null;\n+        for (int i = 0; i < numberOfChildren; i++) {\n+            child = childArray.childInBucket(i);\n+            switch (child.kind) {\n+                case DECIMAL_INTEGER_LITERAL:\n+                case HEX_INTEGER_LITERAL:\n+                case ASTERISK_TOKEN:\n+                    this.errorHandler.reportInvalidNode(null,\n+                            \"invalid Node \" + child.kind + \" in list-binding-pattern\");\n+                    cleanedChildren.add(STNodeFactory.createMissingToken(SyntaxKind.IDENTIFIER_TOKEN));\n+                    break;\n+                default:\n+                    cleanedChildren.add(child);\n+                    break;\n+            }\n+        }\n+\n+        return STNodeFactory.createListBindingPatternNode(listBindingPattern.openBracket,\n+                STNodeFactory.createNodeList(cleanedChildren),\n+                listBindingPattern.restBindingPattern,\n+                listBindingPattern.closeBracket);\n+    }\n+\n+    private boolean isListBindingPatternDefinitively(STNode bindingPattern) {\n+        STListBindingPatternNode listBindingPattern = (STListBindingPatternNode) bindingPattern;\n+        STNodeList childArray = (STNodeList) listBindingPattern.bindingPatterns;\n+        int numberOfChildren = childArray.bucketCount();\n+\n+        if (listBindingPattern.restBindingPattern != null) {\n+            return true;\n+        }\n+\n+        if (numberOfChildren == 1) {\n+            STNode child = childArray.childInBucket(0);\n+            switch (child.kind) {\n+                case LIST_BINDING_PATTERN:\n+                case REST_BINDING_PATTERN:\n+                    return true;\n+                default: // cases like [ and {\n+                    return false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86b3868076bb1f535f392b0160046ac64a83811d"}, "originalPosition": 470}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzIwMDMzMw==", "bodyText": "Regardless whether its a valid child or an invalid child, we need to keep it. That is required to regenerate the source-code using the syntax tree.\nSo we can simply rename this method as \"validateListBindingPattern\", and only log an error for invalid children, but let them stay.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214#discussion_r427200333", "createdAt": "2020-05-19T10:34:56Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -9343,4 +9375,342 @@ private STNode parseIntersectionTypeDescriptor(STNode leftTypeDesc, ParserRuleCo\n         STNode rightTypeDesc = parseTypeDescriptor(context);\n         return STNodeFactory.createIntersectionTypeDescriptorNode(leftTypeDesc, bitwiseAndToken, rightTypeDesc);\n     }\n+\n+    /**\n+     * Parse binding-patterns.\n+     *\n+     * binding-pattern :=\n+     *   capture-binding-pattern\n+     *    | wildcard-binding-pattern\n+     *    | list-binding-pattern\n+     *    | mapping-binding-pattern\n+     *    | functional-binding-pattern\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     * wildcard-binding-pattern := _\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *    binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ] \n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     * rest-binding-pattern := ... variable-name\n+     * functional-binding-pattern := functionally-constructible-type-reference ( arg-list-binding-pattern )\n+     * arg-list-binding-pattern :=\n+     *    positional-arg-binding-patterns [, other-arg-binding-patterns]\n+     *    | other-arg-binding-patterns\n+     * positional-arg-binding-patterns := positional-arg-binding-pattern (, positional-arg-binding-pattern)*\n+     * positional-arg-binding-pattern := binding-pattern\n+     * other-arg-binding-patterns :=\n+     *    named-arg-binding-patterns [, rest-binding-pattern]\n+     *    | [rest-binding-pattern]\n+     * named-arg-binding-patterns := named-arg-binding-pattern (, named-arg-binding-pattern)*\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n+     *\n+     * @return binding-pattern node\n+     */\n+    private STNode parseBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case OPEN_BRACKET_TOKEN:\n+                return parseListBindingPattern();\n+            case IDENTIFIER_TOKEN:\n+                return parseCaptureBindingPattern();\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse capture-binding-pattern.\n+     *\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     *\n+     * @return capture-binding-pattern node\n+     */\n+    private STNode parseCaptureBindingPattern() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case IDENTIFIER_TOKEN:\n+                STNode varName = parseVariableName();\n+                return STNodeFactory.createCaptureBindingPatternNode(varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.CAPTURE_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-patterns.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return list-binding-pattern node\n+     */\n+    private STNode parseListBindingPattern() {\n+        startContext(ParserRuleContext.LIST_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBracket = parseOpenBracket();\n+\n+        STNode listBindingPatternMember = parselistBindingPatternMember();\n+        bindingPatterns.add(listBindingPatternMember);\n+\n+        //parsing the main chunck of list-binding-pattern\n+        STToken token = peek(); // get next valid token\n+        STNode listBindingPatternRhs = null;\n+        while (!isEndOfListBindingPattern(token.kind) &&\n+                listBindingPatternMember.kind != SyntaxKind.REST_BINDING_PATTERN) {\n+            listBindingPatternRhs = parseListBindingpatternRhs(token.kind);\n+            if (listBindingPatternRhs == null) {\n+                break;\n+            }\n+            bindingPatterns.add(listBindingPatternRhs);\n+            listBindingPatternMember = parselistBindingPatternMember();\n+            bindingPatterns.add(listBindingPatternMember);\n+            token = peek();\n+        }\n+        STNode closeBracket = parseCloseBracket();\n+\n+        //seperating out the restbindingpattern\n+        STNode restBindingPattern = null;\n+        if (listBindingPatternMember.kind == SyntaxKind.REST_BINDING_PATTERN) {\n+            restBindingPattern = bindingPatterns.remove(bindingPatterns.size() - 1);\n+        } else {\n+            restBindingPattern = STNodeFactory.createEmptyNode();\n+        }\n+\n+        STNode bindingPatternsNode = STNodeFactory.createNodeList(bindingPatterns);\n+        endContext();\n+        return STNodeFactory.createListBindingPatternNode(openBracket,\n+                                                    bindingPatternsNode,\n+                                                    restBindingPattern,\n+                                                    closeBracket);\n+    }\n+\n+    private STNode parseListBindingpatternRhs() {\n+        return parseListBindingpatternRhs(peek().kind);\n+    }\n+\n+    private STNode parseListBindingpatternRhs(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case COMMA_TOKEN:\n+                return parseComma();\n+            case CLOSE_BRACKET_TOKEN:\n+                return null;\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.LIST_BINDING_PATTERN_END_OR_CONTINUE);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseListBindingpatternRhs(solution.tokenKind);\n+        }\n+    }\n+\n+    private boolean isEndOfListBindingPattern(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case IN_KEYWORD:\n+            case CLOSE_BRACKET_TOKEN:\n+            case EOF_TOKEN:\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+                return true;\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    /**\n+     * Parse rest-binding-pattern.\n+     *\n+     * rest-binding-pattern := ... variable-name\n+     *\n+     * @return rest-binding-pattern node\n+     */\n+    private STNode parseRestBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case ELLIPSIS_TOKEN:\n+                startContext(ParserRuleContext.REST_BINDING_PATTERN);\n+                STNode ellipsis = parseEllipsis();\n+                STNode varName = parseVariableName();\n+                endContext();\n+                return STNodeFactory.createRestBindingPatternNode(ellipsis, varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.REST_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-pattern entry.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return rest-binding-pattern node\n+     */\n+    private STNode parselistBindingPatternMember() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+                return consume();\n+            case ELLIPSIS_TOKEN:\n+                return parseRestBindingPattern();\n+            default:\n+                return parseBindingPattern();\n+        }\n+    }\n+\n+    /**\n+     * Parse Typed-binding-pattern.\n+     *\n+     * <code>typed-binding-pattern := inferable-type-descriptor binding-pattern</code>\n+     * <code>inferable-type-descriptor := type-descriptor | var</code>\n+     *\n+     * @return Fork statement\n+     */\n+    private STNode parseTypedBindingPattern() {\n+        startContext(ParserRuleContext.TYPED_BINDING_PATTERN);\n+        STNode typeDesc = parseTypeDescriptor(ParserRuleContext.TYPE_DESC_IN_TYPE_BINDING_PATTERN, true);\n+\n+        STNode bindingPattern = null;\n+        if (peek().kind == SyntaxKind.OPEN_BRACKET_TOKEN) {\n+            STNode typedBindingPattern = parseArrayTypeDescOrListBindingPattern(typeDesc);\n+            endContext();\n+            return typedBindingPattern;\n+        }\n+        bindingPattern = parseBindingPattern();\n+\n+        endContext();\n+        return STNodeFactory.createTypedBindingPatternNode(typeDesc, bindingPattern);\n+    }\n+\n+    private STNode parseArrayTypeDescOrListBindingPattern(STNode typeDesc) {\n+\n+        STNode arrayDescOrListBindingPattern = parseListBindingPattern();\n+\n+        if (isListBindingPatternDefinitively(arrayDescOrListBindingPattern)) { // ambiguous means T[a]\n+            return STNodeFactory.createTypedBindingPatternNode(typeDesc,\n+                    cleanListBindingPattern(arrayDescOrListBindingPattern));\n+        }\n+\n+        if (isFollowTypedBindingPattern(peek().kind)) {\n+            return STNodeFactory.createTypedBindingPatternNode(typeDesc,\n+                    cleanListBindingPattern(arrayDescOrListBindingPattern));\n+        }\n+\n+        typeDesc = mergeTypeDescAndListBindingPattern(typeDesc, arrayDescOrListBindingPattern);\n+        if (peek().kind == SyntaxKind.OPEN_BRACKET_TOKEN) {\n+            //this means arrayDescOrBLP is a array type desc\n+            return parseArrayTypeDescOrListBindingPattern(typeDesc);\n+        } else {\n+            return STNodeFactory.createTypedBindingPatternNode(typeDesc,\n+                    parseBindingPattern());\n+        }\n+\n+\n+    }\n+\n+    private STNode mergeTypeDescAndListBindingPattern(STNode typeDesc,\n+                                                      STNode bindingPattern) {\n+        STListBindingPatternNode listBindingPattern = (STListBindingPatternNode) bindingPattern;\n+        STNodeList childArray = (STNodeList) listBindingPattern.bindingPatterns;\n+        STNode child = childArray.childInBucket(0);\n+        if (child.kind == SyntaxKind.CAPTURE_BINDING_PATTERN) {\n+            child = ((STCaptureBindingPatternNode) child).variableName;\n+        }\n+        return STNodeFactory.createIndexedExpressionNode(typeDesc, listBindingPattern.openBracket,\n+                child,\n+                listBindingPattern.closeBracket);\n+    }\n+\n+    private STNode cleanListBindingPattern(STNode bindingPattern) {\n+        STListBindingPatternNode listBindingPattern = (STListBindingPatternNode) bindingPattern;\n+        STNodeList childArray = (STNodeList) listBindingPattern.bindingPatterns;\n+        int numberOfChildren = childArray.bucketCount();\n+\n+        ArrayList<STNode> cleanedChildren = new ArrayList<>();\n+        STNode child = null;\n+        for (int i = 0; i < numberOfChildren; i++) {\n+            child = childArray.childInBucket(i);\n+            switch (child.kind) {\n+                case DECIMAL_INTEGER_LITERAL:\n+                case HEX_INTEGER_LITERAL:\n+                case ASTERISK_TOKEN:\n+                    this.errorHandler.reportInvalidNode(null,\n+                            \"invalid Node \" + child.kind + \" in list-binding-pattern\");\n+                    cleanedChildren.add(STNodeFactory.createMissingToken(SyntaxKind.IDENTIFIER_TOKEN));\n+                    break;\n+                default:\n+                    cleanedChildren.add(child);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86b3868076bb1f535f392b0160046ac64a83811d"}, "originalPosition": 443}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0MzIxNTAy", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214#pullrequestreview-414321502", "createdAt": "2020-05-19T10:43:30Z", "commit": {"oid": "86b3868076bb1f535f392b0160046ac64a83811d"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0MzM3NDE5", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214#pullrequestreview-414337419", "createdAt": "2020-05-19T11:07:04Z", "commit": {"oid": "86b3868076bb1f535f392b0160046ac64a83811d"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxMTowNzowNFrOGXbSfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxMTowNzo1NFrOGXbUTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzIxNzUzMg==", "bodyText": "Should be TypeDescriptorNode", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214#discussion_r427217532", "createdAt": "2020-05-19T11:07:04Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-treegen/src/main/resources/syntax_tree_descriptor.json", "diffHunk": "@@ -2848,6 +2844,78 @@\n                     \"type\": \"Token\"\n                 }\n             ]\n+        },\n+        {\n+            \"name\": \"TypedBindingPatternNode\",\n+            \"base\": \"Node\",\n+            \"kind\": \"TYPED_BINDING_PATTERN\",\n+            \"attributes\": [\n+                {\n+                    \"name\": \"typeDescriptor\",\n+                    \"type\": \"Node\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86b3868076bb1f535f392b0160046ac64a83811d"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzIxNzc5NQ==", "bodyText": "SimpleNameReferenceNode", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214#discussion_r427217795", "createdAt": "2020-05-19T11:07:32Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-treegen/src/main/resources/syntax_tree_descriptor.json", "diffHunk": "@@ -2848,6 +2844,78 @@\n                     \"type\": \"Token\"\n                 }\n             ]\n+        },\n+        {\n+            \"name\": \"TypedBindingPatternNode\",\n+            \"base\": \"Node\",\n+            \"kind\": \"TYPED_BINDING_PATTERN\",\n+            \"attributes\": [\n+                {\n+                    \"name\": \"typeDescriptor\",\n+                    \"type\": \"Node\"\n+                },\n+                {\n+                    \"name\": \"bindingPattern\",\n+                    \"type\": \"BindingPatternNode\"\n+                }\n+            ]\n+        },\n+        {\n+            \"name\": \"BindingPatternNode\",\n+            \"base\": \"Node\",\n+            \"isAbstract\": true\n+        },\n+        {\n+            \"name\": \"CaptureBindingPatternNode\",\n+            \"base\": \"BindingPatternNode\",\n+            \"kind\": \"CAPTURE_BINDING_PATTERN\",\n+            \"attributes\": [\n+                {\n+                    \"name\": \"variableName\",\n+                    \"type\": \"Token\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86b3868076bb1f535f392b0160046ac64a83811d"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzIxNzk5OQ==", "bodyText": "SimpleNameReferenceNode", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214#discussion_r427217999", "createdAt": "2020-05-19T11:07:54Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-treegen/src/main/resources/syntax_tree_descriptor.json", "diffHunk": "@@ -2848,6 +2844,78 @@\n                     \"type\": \"Token\"\n                 }\n             ]\n+        },\n+        {\n+            \"name\": \"TypedBindingPatternNode\",\n+            \"base\": \"Node\",\n+            \"kind\": \"TYPED_BINDING_PATTERN\",\n+            \"attributes\": [\n+                {\n+                    \"name\": \"typeDescriptor\",\n+                    \"type\": \"Node\"\n+                },\n+                {\n+                    \"name\": \"bindingPattern\",\n+                    \"type\": \"BindingPatternNode\"\n+                }\n+            ]\n+        },\n+        {\n+            \"name\": \"BindingPatternNode\",\n+            \"base\": \"Node\",\n+            \"isAbstract\": true\n+        },\n+        {\n+            \"name\": \"CaptureBindingPatternNode\",\n+            \"base\": \"BindingPatternNode\",\n+            \"kind\": \"CAPTURE_BINDING_PATTERN\",\n+            \"attributes\": [\n+                {\n+                    \"name\": \"variableName\",\n+                    \"type\": \"Token\",\n+                    \"isOptional\": true\n+                }\n+            ]\n+        },\n+        {\n+            \"name\": \"ListBindingPatternNode\",\n+            \"base\": \"BindingPatternNode\",\n+            \"kind\": \"LIST_BINDING_PATTERN\",\n+            \"attributes\": [\n+                {\n+                    \"name\": \"openBracket\",\n+                    \"type\": \"Token\"\n+                },\n+                {\n+                    \"name\": \"bindingPatterns\",\n+                    \"type\": \"BindingPatternNode\",\n+                    \"occurrences\": \"MULTIPLE_SEPARATED\"\n+                },\n+                {\n+                    \"name\": \"restBindingPattern\",\n+                    \"type\": \"RestBindingPatternNode\",\n+                    \"isOptional\": true\n+                },\n+                {\n+                    \"name\": \"closeBracket\",\n+                    \"type\": \"Token\"\n+                }\n+            ]\n+        },\n+        {\n+            \"name\": \"RestBindingPatternNode\",\n+            \"base\": \"Node\",\n+            \"kind\": \"REST_BINDING_PATTERN\",\n+            \"attributes\": [\n+                {\n+                    \"name\": \"ellipsisToken\",\n+                    \"type\": \"Token\"\n+                },\n+                {\n+                    \"name\": \"variableName\",\n+                    \"type\": \"Token\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86b3868076bb1f535f392b0160046ac64a83811d"}, "originalPosition": 88}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6b08cbe92377b1bc413ff4a170865b8e9dbf3274", "author": {"user": {"login": "m36dot", "name": "Saif Abdul Cassim"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6b08cbe92377b1bc413ff4a170865b8e9dbf3274", "committedDate": "2020-05-19T11:28:15Z", "message": "Refactor Code"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0NDYzNTUy", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214#pullrequestreview-414463552", "createdAt": "2020-05-19T13:48:07Z", "commit": {"oid": "6b08cbe92377b1bc413ff4a170865b8e9dbf3274"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxMzo0ODowN1rOGXhTnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxMzo0ODowN1rOGXhTnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzMxNjEyNw==", "bodyText": "Is this optional?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214#discussion_r427316127", "createdAt": "2020-05-19T13:48:07Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-treegen/src/main/resources/syntax_tree_descriptor.json", "diffHunk": "@@ -2848,6 +2844,78 @@\n                     \"type\": \"Token\"\n                 }\n             ]\n+        },\n+        {\n+            \"name\": \"TypedBindingPatternNode\",\n+            \"base\": \"Node\",\n+            \"kind\": \"TYPED_BINDING_PATTERN\",\n+            \"attributes\": [\n+                {\n+                    \"name\": \"typeDescriptor\",\n+                    \"type\": \"TypeDescriptorNode\"\n+                },\n+                {\n+                    \"name\": \"bindingPattern\",\n+                    \"type\": \"BindingPatternNode\"\n+                }\n+            ]\n+        },\n+        {\n+            \"name\": \"BindingPatternNode\",\n+            \"base\": \"Node\",\n+            \"isAbstract\": true\n+        },\n+        {\n+            \"name\": \"CaptureBindingPatternNode\",\n+            \"base\": \"BindingPatternNode\",\n+            \"kind\": \"CAPTURE_BINDING_PATTERN\",\n+            \"attributes\": [\n+                {\n+                    \"name\": \"variableName\",\n+                    \"type\": \"SimpleNameReferenceNode\",\n+                    \"isOptional\": true", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b08cbe92377b1bc413ff4a170865b8e9dbf3274"}, "originalPosition": 48}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3316, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}