{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcyODU4NzQ0", "number": 20937, "title": "Support inferring types for mapping constructor expressions", "bodyText": "Purpose\n$title.\nType is inferred as follows:\npublic function main() {\n    any a1 = {one: 1, two: 2};     // map<any>\n    anydata a2 = {one: 1, two: \"two\"}; // map<anydata>\n}\npublic function main() {\n    var a1 = {one: 1, two: 2};     // map<int>\n    var a2 = {one: 1, two: \"two\"}; // map<int|string>\n}\nThis PR also introduces support to infer a record type for a mapping constructor expression in specific scenarios (e.g., select-clause for now).\ntype Person record {|\n   string firstName;\n   string lastName;\n   int age;\n|};\n\nPerson p1 = {firstName: \"Alex\", lastName: \"George\", age: 23};\nPerson p2 = {firstName: \"Ranjan\", lastName: \"Fonseka\", age: 30};\nPerson p3 = {firstName: \"John\", lastName: \"David\", age: 33};\n\npublic function main() {\n    Person[] personList = [p1, p2, p3];\n    string s = \"x\";\n\n    var outputList =\n            from var person in personList\n            select {\n                   fn: person.firstName,\n                   \"ln\": person.lastName,\n                   [s]: 1\n            };\n}\nType is inferred as the record record {| string fn; string ln; int...; |}[] here.\nFixes #17186\nFixes #20828\nFixes #20737\nCheck List\n\n Read the Contributing Guide\n Updated Change Log\n Checked Tooling Support (#)\n Added necessary tests\n\n Unit Tests\n Spec Conformance Tests\n Integration Tests\n Ballerina By Example Tests\n\n\n Increased Test Coverage\n Added necessary documentation\n\n API documentation\n Module documentation in Module.md files\n Ballerina By Examples", "createdAt": "2020-02-09T18:31:53Z", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20937", "merged": true, "mergeCommit": {"oid": "fc9a9b572a5a2e1a9d67c6a2ba355b658200e689"}, "closed": true, "closedAt": "2020-02-13T05:09:52Z", "author": {"login": "MaryamZi"}, "timelineItems": {"totalCount": 22, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb_HpdtgH2gAyMzcyODU4NzQ0OmU4NGI1NDNhMWNkMDY3YzYyZjI3YWU0YTkyMTUwNDg2MzI2YjAxNmY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcDzzIqAFqTM1Nzk1NzEwMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "e84b543a1cd067c62f27ae4a92150486326b016f", "author": {"user": {"login": "MaryamZi", "name": "Maryam Ziyad"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e84b543a1cd067c62f27ae4a92150486326b016f", "committedDate": "2020-01-29T15:26:47Z", "message": "Extract representative broad type identification to a separate method"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "77b85118a7f5568f945a60a35f6c7e1a8ffb1aae", "author": {"user": {"login": "MaryamZi", "name": "Maryam Ziyad"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/77b85118a7f5568f945a60a35f6c7e1a8ffb1aae", "committedDate": "2020-01-30T06:24:37Z", "message": "Allow mapping constr usage with any/anydata"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e9b65cde9e98b16780ac0b3e2e21980bcb218323", "author": {"user": {"login": "MaryamZi", "name": "Maryam Ziyad"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e9b65cde9e98b16780ac0b3e2e21980bcb218323", "committedDate": "2020-01-30T17:13:11Z", "message": "Allow using var with a mapping constructor expr"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "87db3e2cfc1b56272876f625b83ff9b74241d62d", "author": {"user": {"login": "MaryamZi", "name": "Maryam Ziyad"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/87db3e2cfc1b56272876f625b83ff9b74241d62d", "committedDate": "2020-01-31T04:18:40Z", "message": "Fix issue in ambiguous map type identification and add tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0248da141ead7f73845b31810f9dd845021e11cf", "author": {"user": {"login": "MaryamZi", "name": "Maryam Ziyad"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/0248da141ead7f73845b31810f9dd845021e11cf", "committedDate": "2020-02-02T16:23:35Z", "message": "Implement record type inf. logic for mapping-constr-expr"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3d4c6f3ebac242644e85ad1e34ae0f81545fe560", "author": {"user": {"login": "MaryamZi", "name": "Maryam Ziyad"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3d4c6f3ebac242644e85ad1e34ae0f81545fe560", "committedDate": "2020-02-04T16:31:20Z", "message": "Merge branch 'fix-map-constr-inferring' of https://github.com/MaryamZi/ballerina into fix-mapping-constr-type-inferring"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b76536476ee4352aeca8f9e6226bfb37d33c518c", "author": {"user": {"login": "MaryamZi", "name": "Maryam Ziyad"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b76536476ee4352aeca8f9e6226bfb37d33c518c", "committedDate": "2020-02-05T05:43:35Z", "message": "Move out type def creation logic to a separate class"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7d4a0df24f546acb7417446ae54253ecd8261a83", "author": {"user": {"login": "MaryamZi", "name": "Maryam Ziyad"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7d4a0df24f546acb7417446ae54253ecd8261a83", "committedDate": "2020-02-05T09:12:59Z", "message": "Fix literal keys not being considered for closed rec union compatability"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "39cfb65b7c7601c7258e8e8633666226bb075d87", "author": {"user": {"login": "MaryamZi", "name": "Maryam Ziyad"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/39cfb65b7c7601c7258e8e8633666226bb075d87", "committedDate": "2020-02-05T09:57:44Z", "message": "Merge branch 'fix-map-constr-inferring' of https://github.com/MaryamZi/ballerina into fix-mapping-constr-type-inferring"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ba43028a10d30490bf660eb08bdff1cb1cdeff04", "author": {"user": {"login": "MaryamZi", "name": "Maryam Ziyad"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/ba43028a10d30490bf660eb08bdff1cb1cdeff04", "committedDate": "2020-02-05T11:20:57Z", "message": "Merge branch 'fix-map-constr-inferring' of https://github.com/MaryamZi/ballerina into fix-mapping-constr-type-inferring"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9af86478a4d21521e60f6a85933fccf2c9d63e27", "author": {"user": {"login": "MaryamZi", "name": "Maryam Ziyad"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/9af86478a4d21521e60f6a85933fccf2c9d63e27", "committedDate": "2020-02-07T16:25:26Z", "message": "Merge branch 'master' of https://github.com/ballerina-lang/ballerina into fix-mapping-constr-type-inferring"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "42f86b2ff25154f0652650d45f7007b98a735b1c", "author": {"user": {"login": "MaryamZi", "name": "Maryam Ziyad"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/42f86b2ff25154f0652650d45f7007b98a735b1c", "committedDate": "2020-02-10T08:53:13Z", "message": "Avoid duplicate logs when inferring type for invalid mapping-constr"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fe628eb8b2f79c8f7c92e2fd5b240ed59e87497a", "author": {"user": {"login": "MaryamZi", "name": "Maryam Ziyad"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/fe628eb8b2f79c8f7c92e2fd5b240ed59e87497a", "committedDate": "2020-02-11T04:03:52Z", "message": "Merge branch 'master' of https://github.com/ballerina-lang/ballerina into fix-mapping-constr-type-inferring"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ad653c8a288a83240f30156e1f6d4b9f2c53a9a6", "author": {"user": {"login": "MaryamZi", "name": "Maryam Ziyad"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/ad653c8a288a83240f30156e1f6d4b9f2c53a9a6", "committedDate": "2020-02-11T11:29:01Z", "message": "Support inferring a record type in a select clause"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e8d51735533e08cc409d90dfba2711316c5f104b", "author": {"user": {"login": "MaryamZi", "name": "Maryam Ziyad"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e8d51735533e08cc409d90dfba2711316c5f104b", "committedDate": "2020-02-11T11:14:41Z", "message": "Support inferring a record type in a select clause"}, "afterCommit": {"oid": "ad653c8a288a83240f30156e1f6d4b9f2c53a9a6", "author": {"user": {"login": "MaryamZi", "name": "Maryam Ziyad"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/ad653c8a288a83240f30156e1f6d4b9f2c53a9a6", "committedDate": "2020-02-11T11:29:01Z", "message": "Support inferring a record type in a select clause"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU3MTgzNTQ4", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20937#pullrequestreview-357183548", "createdAt": "2020-02-12T04:32:50Z", "commit": {"oid": "ad653c8a288a83240f30156e1f6d4b9f2c53a9a6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwNDozMjo1MFrOFohgWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwNDozMjo1MFrOFohgWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODAzNjMxNA==", "bodyText": "Maybe a function name like addTypeDefinition is more suitable here?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20937#discussion_r378036314", "createdAt": "2020-02-12T04:32:50Z", "author": {"login": "KRVPerera"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/util/TypeDefBuilderHelper.java", "diffHunk": "@@ -0,0 +1,158 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.wso2.ballerinalang.compiler.util;\n+\n+import org.ballerinalang.model.TreeBuilder;\n+import org.ballerinalang.model.elements.Flag;\n+import org.ballerinalang.model.elements.PackageID;\n+import org.wso2.ballerinalang.compiler.desugar.ASTBuilderUtil;\n+import org.wso2.ballerinalang.compiler.semantics.analyzer.TaintAnalyzer;\n+import org.wso2.ballerinalang.compiler.semantics.model.Scope;\n+import org.wso2.ballerinalang.compiler.semantics.model.SymbolEnv;\n+import org.wso2.ballerinalang.compiler.semantics.model.SymbolTable;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BAttachedFunction;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BInvokableTypeSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BRecordTypeSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BTypeSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BVarSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.SymTag;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.Symbols;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.TaintRecord;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BField;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BInvokableType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BRecordType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BType;\n+import org.wso2.ballerinalang.compiler.tree.BLangFunction;\n+import org.wso2.ballerinalang.compiler.tree.BLangSimpleVariable;\n+import org.wso2.ballerinalang.compiler.tree.BLangTypeDefinition;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangRecordTypeNode;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangStructureTypeNode;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangType;\n+import org.wso2.ballerinalang.compiler.util.diagnotic.DiagnosticPos;\n+import org.wso2.ballerinalang.util.Flags;\n+\n+import java.util.ArrayList;\n+import java.util.EnumSet;\n+import java.util.HashMap;\n+import java.util.List;\n+\n+/**\n+ * Helper class with util methods to create type definitions.\n+ *\n+ * @since 1.2.0\n+ */\n+public class TypeDefBuilderHelper {\n+\n+    public static BLangRecordTypeNode createRecordTypeNode(BRecordType recordType, PackageID packageID,\n+                                                           SymbolTable symTable, DiagnosticPos pos) {\n+        List<BLangSimpleVariable> fieldList = new ArrayList<>();\n+        for (BField field : recordType.fields) {\n+            BVarSymbol symbol = field.symbol;\n+            if (symbol == null) {\n+                symbol = new BVarSymbol(Flags.PUBLIC, field.name, packageID, symTable.pureType, null);\n+            }\n+\n+            BLangSimpleVariable fieldVar = ASTBuilderUtil.createVariable(field.pos, symbol.name.value, field.type,\n+                                                                         null, symbol);\n+            fieldList.add(fieldVar);\n+        }\n+        return createRecordTypeNode(fieldList, recordType, pos);\n+    }\n+\n+    public static BLangRecordTypeNode createRecordTypeNode(List<BLangSimpleVariable> typeDefFields,\n+                                                           BRecordType recordType, DiagnosticPos pos) {\n+        BLangRecordTypeNode recordTypeNode = (BLangRecordTypeNode) TreeBuilder.createRecordTypeNode();\n+        recordTypeNode.type = recordType;\n+        recordTypeNode.fields = typeDefFields;\n+        recordTypeNode.symbol = recordType.tsymbol;\n+        recordTypeNode.pos = pos;\n+\n+        return recordTypeNode;\n+    }\n+\n+    public static BLangFunction createInitFunctionForRecordType(BLangRecordTypeNode recordTypeNode, SymbolEnv env,\n+                                                                Names names, SymbolTable symTable) {\n+        BLangFunction initFunction = createInitFunctionForStructureType(recordTypeNode, env,\n+                                                                        Names.INIT_FUNCTION_SUFFIX, names, symTable);\n+        BRecordTypeSymbol recordSymbol = ((BRecordTypeSymbol) recordTypeNode.type.tsymbol);\n+        recordSymbol.initializerFunc = new BAttachedFunction(initFunction.symbol.name, initFunction.symbol,\n+                                                             (BInvokableType) initFunction.type);\n+        recordTypeNode.initFunction = initFunction;\n+        recordSymbol.scope.define(recordSymbol.initializerFunc.symbol.name, recordSymbol.initializerFunc.symbol);\n+        return initFunction;\n+    }\n+\n+    public static BLangFunction createInitFunctionForStructureType(BLangStructureTypeNode structureTypeNode,\n+                                                                   SymbolEnv env, Name suffix, Names names,\n+                                                                   SymbolTable symTable) {\n+        String structTypeName = structureTypeNode.type.tsymbol.name.value;\n+        BLangFunction initFunction = ASTBuilderUtil\n+                .createInitFunctionWithNilReturn(structureTypeNode.pos, structTypeName, suffix);\n+\n+        // Create the receiver and add receiver details to the node\n+        initFunction.receiver = ASTBuilderUtil.createReceiver(structureTypeNode.pos, structureTypeNode.type);\n+        BVarSymbol receiverSymbol = new BVarSymbol(Flags.asMask(EnumSet.noneOf(Flag.class)),\n+                                                   names.fromIdNode(initFunction.receiver.name),\n+                                                   env.enclPkg.symbol.pkgID, structureTypeNode.type, null);\n+        initFunction.receiver.symbol = receiverSymbol;\n+        initFunction.attachedFunction = true;\n+        initFunction.flagSet.add(Flag.ATTACHED);\n+\n+        // Create the function type\n+        initFunction.type = new BInvokableType(new ArrayList<>(), symTable.nilType, null);\n+\n+        // Create the function symbol\n+        Name funcSymbolName = names.fromString(Symbols.getAttachedFuncSymbolName(structTypeName, suffix.value));\n+        initFunction.symbol = Symbols\n+                .createFunctionSymbol(Flags.asMask(initFunction.flagSet), funcSymbolName, env.enclPkg.symbol.pkgID,\n+                                      initFunction.type, structureTypeNode.symbol, initFunction.body != null);\n+        initFunction.symbol.scope = new Scope(initFunction.symbol);\n+        initFunction.symbol.scope.define(receiverSymbol.name, receiverSymbol);\n+        initFunction.symbol.receiverSymbol = receiverSymbol;\n+        initFunction.name = ASTBuilderUtil.createIdentifier(structureTypeNode.pos, funcSymbolName.value);\n+\n+        // Create the function type symbol\n+        BInvokableTypeSymbol tsymbol = Symbols.createInvokableTypeSymbol(SymTag.FUNCTION_TYPE,\n+                                                                         initFunction.symbol.flags,\n+                                                                         env.enclPkg.packageID, initFunction.type,\n+                                                                         initFunction.symbol);\n+        tsymbol.params = initFunction.symbol.params;\n+        tsymbol.restParam = initFunction.symbol.restParam;\n+        tsymbol.returnType = initFunction.symbol.retType;\n+        initFunction.type.tsymbol = tsymbol;\n+\n+        receiverSymbol.owner = initFunction.symbol;\n+\n+        // Add return type as nil to the symbol\n+        initFunction.symbol.retType = symTable.nilType;\n+\n+        // Set the taint information to the constructed init function\n+        initFunction.symbol.taintTable = new HashMap<>();\n+        TaintRecord taintRecord = new TaintRecord(TaintRecord.TaintedStatus.UNTAINTED, new ArrayList<>());\n+        initFunction.symbol.taintTable.put(TaintAnalyzer.ALL_UNTAINTED_TABLE_ENTRY_INDEX, taintRecord);\n+\n+        return initFunction;\n+    }\n+\n+    public static void createTypeDefinition(BType type, BTypeSymbol symbol, BLangType typeNode, SymbolEnv env) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad653c8a288a83240f30156e1f6d4b9f2c53a9a6"}, "originalPosition": 151}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU3MTg5ODc5", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20937#pullrequestreview-357189879", "createdAt": "2020-02-12T05:00:03Z", "commit": {"oid": "ad653c8a288a83240f30156e1f6d4b9f2c53a9a6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwNTowMDowNFrOFoh0Nw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwNTowMDowNFrOFoh0Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA0MTM5OQ==", "bodyText": "Looking at the algorithm I think instead of an array list this could be HashSet. Feel like we are iterating over possibleTypes several times for searching. For loop and contains.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20937#discussion_r378041399", "createdAt": "2020-02-12T05:00:04Z", "author": {"login": "KRVPerera"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -1004,31 +1000,66 @@ private void reportMissingRecordFieldDiagnostics(List<RecordLiteralNode.RecordFi\n         if (bType.tag == TypeTags.UNION) {\n             Set<BType> expTypes = ((BUnionType) bType).getMemberTypes();\n \n-            List<BType> possibleTypes =\n-                    expTypes.stream()\n-                            .filter(type -> type.tag == TypeTags.MAP ||\n-                                    (type.tag == TypeTags.RECORD &&\n-                                            (!((BRecordType) type).sealed ||\n-                                                    isCompatibleClosedRecordLiteral((BRecordType) type,\n-                                                            recordLiteral))))\n-                            .collect(Collectors.toList());\n+            List<BType> possibleTypes = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad653c8a288a83240f30156e1f6d4b9f2c53a9a6"}, "originalPosition": 140}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU3MTkyMTg5", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20937#pullrequestreview-357192189", "createdAt": "2020-02-12T05:09:59Z", "commit": {"oid": "ad653c8a288a83240f30156e1f6d4b9f2c53a9a6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwNTowOTo1OVrOFoh7Yw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwNTowOTo1OVrOFoh7Yw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA0MzIzNQ==", "bodyText": "Should the second loop start from the t1+1 item to reduce duplicate isAssignable calls?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20937#discussion_r378043235", "createdAt": "2020-02-12T05:09:59Z", "author": {"login": "KRVPerera"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -4766,4 +4807,141 @@ private boolean isConst(BLangExpression expression) {\n     private Name getCurrentCompUnit(BLangNode node) {\n         return names.fromString(node.pos.getSource().getCompilationUnitName());\n     }\n+\n+    private BType getRepresentativeBroadType(List<BLangExpression> exprs) {\n+        LinkedHashSet<BType> narrowTypes = new LinkedHashSet<>();\n+        LinkedHashSet<BType> broadTypesSet = new LinkedHashSet<>();\n+        BType[] inferredTypes = checkExprList(exprs, env);\n+        for (BType type : inferredTypes) {\n+            if (type.tag == TypeTags.SEMANTIC_ERROR) {\n+                return type;\n+            }\n+\n+            if (narrowTypes.stream().noneMatch(nType -> types.isSameType(type, nType))) {\n+                narrowTypes.add(type);\n+            }\n+        }\n+        BType broadType;\n+        for (BType t1 : narrowTypes) {\n+            broadType = t1;\n+            for (BType t2 : narrowTypes) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad653c8a288a83240f30156e1f6d4b9f2c53a9a6"}, "originalPosition": 319}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU3MTk0MzUy", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20937#pullrequestreview-357194352", "createdAt": "2020-02-12T05:18:54Z", "commit": {"oid": "ad653c8a288a83240f30156e1f6d4b9f2c53a9a6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwNToxODo1NVrOFoiBwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwNToxODo1NVrOFoiBwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA0NDg2Ng==", "bodyText": "Can we combine this for loop with below double for loops? Something like\ntypes.isSameType(t1, t2) --> continue:;\nt1.tag == TypeTags.SEMANTIC_ERROR) --> continue;\nt2.tag == TypeTags.SEMANTIC_ERROR --> continue;", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20937#discussion_r378044866", "createdAt": "2020-02-12T05:18:55Z", "author": {"login": "KRVPerera"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -4766,4 +4807,141 @@ private boolean isConst(BLangExpression expression) {\n     private Name getCurrentCompUnit(BLangNode node) {\n         return names.fromString(node.pos.getSource().getCompilationUnitName());\n     }\n+\n+    private BType getRepresentativeBroadType(List<BLangExpression> exprs) {\n+        LinkedHashSet<BType> narrowTypes = new LinkedHashSet<>();\n+        LinkedHashSet<BType> broadTypesSet = new LinkedHashSet<>();\n+        BType[] inferredTypes = checkExprList(exprs, env);\n+        for (BType type : inferredTypes) {\n+            if (type.tag == TypeTags.SEMANTIC_ERROR) {\n+                return type;\n+            }\n+\n+            if (narrowTypes.stream().noneMatch(nType -> types.isSameType(type, nType))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad653c8a288a83240f30156e1f6d4b9f2c53a9a6"}, "originalPosition": 312}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a393f3692ab87e349d7e175c20d970085e7b029a", "author": {"user": {"login": "MaryamZi", "name": "Maryam Ziyad"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a393f3692ab87e349d7e175c20d970085e7b029a", "committedDate": "2020-02-12T09:11:32Z", "message": "Address review suggestions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ddbbe63c79182ad2ebb8bc31f2cee8e28c2b0125", "author": {"user": {"login": "MaryamZi", "name": "Maryam Ziyad"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/ddbbe63c79182ad2ebb8bc31f2cee8e28c2b0125", "committedDate": "2020-02-12T17:36:44Z", "message": "Refactor broad type extraction method and add a map test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU3OTU3MTAy", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20937#pullrequestreview-357957102", "createdAt": "2020-02-13T05:08:52Z", "commit": {"oid": "ddbbe63c79182ad2ebb8bc31f2cee8e28c2b0125"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4202, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}