{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU5MDc3Njk0", "number": 25049, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNjoxMzo0NFrOEXSHvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwOTo0NDoyMVrOEXjZ9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyODQ5NTk2OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/optimizer/BIROptimizer.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNjoxMzo0NFrOG-_MSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwNTo1ODozOFrOG_S1QQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODcwMDIzNA==", "bodyText": "isn't it better to use \"this.variableOptimizer\" here? I always find it to be readable within a constructor", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25049#discussion_r468700234", "createdAt": "2020-08-11T16:13:44Z", "author": {"login": "Kishanthan"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/optimizer/BIROptimizer.java", "diffHunk": "@@ -67,6 +68,7 @@ private BIROptimizer(CompilerContext context) {\n         this.rhsTempVarOptimizer = new RHSTempVarOptimizer();\n         this.lhsTempVarOptimizer = new LHSTempVarOptimizer();\n         this.lockOptimizer = new BIRLockOptimizer();\n+        variableOptimizer = new BirVariableOptimizer();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27e27c9de233b7b1f91174c772e02b851ee40241"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODkzODU2Ng==", "bodyText": "For me it does not add more clarity(only more code) because already the IDE colors the global parameters differently so it is not at all hard to differentiate. I use this sparingly and only when needed.\nI think it is a personal preference if it is not enforced. (https://stackoverflow.com/questions/5944382/is-it-clearer-to-always-use-this-or-only-when-necessary)", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25049#discussion_r468938566", "createdAt": "2020-08-12T00:32:27Z", "author": {"login": "riyafa"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/optimizer/BIROptimizer.java", "diffHunk": "@@ -67,6 +68,7 @@ private BIROptimizer(CompilerContext context) {\n         this.rhsTempVarOptimizer = new RHSTempVarOptimizer();\n         this.lhsTempVarOptimizer = new LHSTempVarOptimizer();\n         this.lockOptimizer = new BIRLockOptimizer();\n+        variableOptimizer = new BirVariableOptimizer();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODcwMDIzNA=="}, "originalCommit": {"oid": "27e27c9de233b7b1f91174c772e02b851ee40241"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODk5MjIwNg==", "bodyText": "However, if you look at the code above, we have followed a practice. The code you have added follows another practice. Isn't better to follow one single practice throughout?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25049#discussion_r468992206", "createdAt": "2020-08-12T04:03:47Z", "author": {"login": "Kishanthan"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/optimizer/BIROptimizer.java", "diffHunk": "@@ -67,6 +68,7 @@ private BIROptimizer(CompilerContext context) {\n         this.rhsTempVarOptimizer = new RHSTempVarOptimizer();\n         this.lhsTempVarOptimizer = new LHSTempVarOptimizer();\n         this.lockOptimizer = new BIRLockOptimizer();\n+        variableOptimizer = new BirVariableOptimizer();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODcwMDIzNA=="}, "originalCommit": {"oid": "27e27c9de233b7b1f91174c772e02b851ee40241"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTAxOTM2Nw==", "bodyText": "ack", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25049#discussion_r469019367", "createdAt": "2020-08-12T05:50:01Z", "author": {"login": "riyafa"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/optimizer/BIROptimizer.java", "diffHunk": "@@ -67,6 +68,7 @@ private BIROptimizer(CompilerContext context) {\n         this.rhsTempVarOptimizer = new RHSTempVarOptimizer();\n         this.lhsTempVarOptimizer = new LHSTempVarOptimizer();\n         this.lockOptimizer = new BIRLockOptimizer();\n+        variableOptimizer = new BirVariableOptimizer();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODcwMDIzNA=="}, "originalCommit": {"oid": "27e27c9de233b7b1f91174c772e02b851ee40241"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTAyMjAxNw==", "bodyText": "I would prefer without this for all \ud83d\ude42", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25049#discussion_r469022017", "createdAt": "2020-08-12T05:58:38Z", "author": {"login": "riyafa"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/optimizer/BIROptimizer.java", "diffHunk": "@@ -67,6 +68,7 @@ private BIROptimizer(CompilerContext context) {\n         this.rhsTempVarOptimizer = new RHSTempVarOptimizer();\n         this.lhsTempVarOptimizer = new LHSTempVarOptimizer();\n         this.lockOptimizer = new BIRLockOptimizer();\n+        variableOptimizer = new BirVariableOptimizer();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODcwMDIzNA=="}, "originalCommit": {"oid": "27e27c9de233b7b1f91174c772e02b851ee40241"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMDM4NTEzOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/optimizer/BirVariableOptimizer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwNDoxMDozOVrOG_RG2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwNDoxMDozOVrOG_RG2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODk5Mzc1NQ==", "bodyText": "shall we first return if lhsOp is null ?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25049#discussion_r468993755", "createdAt": "2020-08-12T04:10:39Z", "author": {"login": "Kishanthan"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/optimizer/BirVariableOptimizer.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+\n+package org.wso2.ballerinalang.compiler.bir.optimizer;\n+\n+import org.wso2.ballerinalang.compiler.bir.model.BIRAbstractInstruction;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode;\n+import org.wso2.ballerinalang.compiler.bir.model.BIROperand;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRTerminator;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRVisitor;\n+import org.wso2.ballerinalang.compiler.bir.model.InstructionKind;\n+import org.wso2.ballerinalang.compiler.bir.model.VarKind;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BType;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Optimize variables by reusing temporary variables of the same type.\n+ *\n+ * @since 1.2.1\n+ */\n+public class BirVariableOptimizer extends BIRVisitor {\n+    public void optimizeNode(BIRNode node) {\n+        node.accept(this);\n+    }\n+\n+    @Override\n+    public void visit(BIRNode.BIRPackage birPackage) {\n+        birPackage.typeDefs.forEach(tDef -> tDef.accept(this));\n+        birPackage.functions.forEach(func -> func.accept(this));\n+    }\n+\n+    @Override\n+    public void visit(BIRNode.BIRTypeDefinition birTypeDefinition) {\n+        birTypeDefinition.attachedFuncs.forEach(func -> func.accept(this));\n+    }\n+\n+    @Override\n+    public void visit(BIRNode.BIRFunction birFunction) {\n+        ControlFlowGraph graph = new ControlFlowGraph(birFunction);\n+        LivenessAnalyzer analyzer = new LivenessAnalyzer(graph.getNodes());\n+        Map<BIRAbstractInstruction, Set<BIRNode.BIRVariableDcl>> liveOuts = analyzer.getInstructionLiveOuts();\n+        List<BIRNode.BIRVariableDcl> unusedVars = new ArrayList<>();\n+        reuseVars(liveOuts, unusedVars, birFunction);\n+        unusedVars.forEach(var -> birFunction.localVars.remove(var));\n+    }\n+\n+    private void reuseVars(Map<BIRAbstractInstruction, Set<BIRNode.BIRVariableDcl>> liveOuts,\n+                           List<BIRNode.BIRVariableDcl> unusedVars, BIRNode.BIRFunction birFunction) {\n+        List<BIRAbstractInstruction> instructionList = getInstructionList(birFunction);\n+        Map<BType, LinkedList<BIRNode.BIRVariableDcl>> freeVars = new HashMap<>();\n+        for (int i = 0; i < instructionList.size(); i++) {\n+            if (instructionList.get(i).getKind() == InstructionKind.XML_SEQ_STORE) {\n+                continue;\n+            }\n+            tryToReuseFromFreeVars(liveOuts, freeVars, instructionList, i, unusedVars);\n+            checkForFreeVars(freeVars, liveOuts, instructionList.get(i));\n+        }\n+    }\n+\n+    private void checkForFreeVars(Map<BType, LinkedList<BIRNode.BIRVariableDcl>> freeVars,\n+                                  Map<BIRAbstractInstruction, Set<BIRNode.BIRVariableDcl>> liveOuts,\n+                                  BIRAbstractInstruction instruction) {\n+        for (BIROperand operand : instruction.getRhsOperands()) {\n+            BType type = operand.variableDcl.type;\n+            if (operand.variableDcl.kind == VarKind.TEMP && !liveOuts.get(instruction).contains(operand.variableDcl)) {\n+                if (!freeVars.containsKey(type)) {\n+                    freeVars.put(type, new LinkedList<>());\n+                }\n+                LinkedList<BIRNode.BIRVariableDcl> ls = freeVars.get(type);\n+                ls.add(operand.variableDcl);\n+            }\n+        }\n+    }\n+\n+    private void tryToReuseFromFreeVars(Map<BIRAbstractInstruction, Set<BIRNode.BIRVariableDcl>> liveOuts,\n+                                        Map<BType, LinkedList<BIRNode.BIRVariableDcl>> freeVars,\n+                                        List<BIRAbstractInstruction> instructionList, int idx,\n+                                        List<BIRNode.BIRVariableDcl> unusedVars) {\n+        BIRAbstractInstruction instruction = instructionList.get(idx);\n+        if (instruction.lhsOp != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27e27c9de233b7b1f91174c772e02b851ee40241"}, "originalPosition": 101}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMDM4NjA1OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/optimizer/BirVariableOptimizer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwNDoxMToyNVrOG_RHbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwNDoxMToyNVrOG_RHbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODk5MzkwMQ==", "bodyText": "and same here, shall we retunr if defLs is null or empty?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25049#discussion_r468993901", "createdAt": "2020-08-12T04:11:25Z", "author": {"login": "Kishanthan"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/optimizer/BirVariableOptimizer.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+\n+package org.wso2.ballerinalang.compiler.bir.optimizer;\n+\n+import org.wso2.ballerinalang.compiler.bir.model.BIRAbstractInstruction;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode;\n+import org.wso2.ballerinalang.compiler.bir.model.BIROperand;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRTerminator;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRVisitor;\n+import org.wso2.ballerinalang.compiler.bir.model.InstructionKind;\n+import org.wso2.ballerinalang.compiler.bir.model.VarKind;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BType;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Optimize variables by reusing temporary variables of the same type.\n+ *\n+ * @since 1.2.1\n+ */\n+public class BirVariableOptimizer extends BIRVisitor {\n+    public void optimizeNode(BIRNode node) {\n+        node.accept(this);\n+    }\n+\n+    @Override\n+    public void visit(BIRNode.BIRPackage birPackage) {\n+        birPackage.typeDefs.forEach(tDef -> tDef.accept(this));\n+        birPackage.functions.forEach(func -> func.accept(this));\n+    }\n+\n+    @Override\n+    public void visit(BIRNode.BIRTypeDefinition birTypeDefinition) {\n+        birTypeDefinition.attachedFuncs.forEach(func -> func.accept(this));\n+    }\n+\n+    @Override\n+    public void visit(BIRNode.BIRFunction birFunction) {\n+        ControlFlowGraph graph = new ControlFlowGraph(birFunction);\n+        LivenessAnalyzer analyzer = new LivenessAnalyzer(graph.getNodes());\n+        Map<BIRAbstractInstruction, Set<BIRNode.BIRVariableDcl>> liveOuts = analyzer.getInstructionLiveOuts();\n+        List<BIRNode.BIRVariableDcl> unusedVars = new ArrayList<>();\n+        reuseVars(liveOuts, unusedVars, birFunction);\n+        unusedVars.forEach(var -> birFunction.localVars.remove(var));\n+    }\n+\n+    private void reuseVars(Map<BIRAbstractInstruction, Set<BIRNode.BIRVariableDcl>> liveOuts,\n+                           List<BIRNode.BIRVariableDcl> unusedVars, BIRNode.BIRFunction birFunction) {\n+        List<BIRAbstractInstruction> instructionList = getInstructionList(birFunction);\n+        Map<BType, LinkedList<BIRNode.BIRVariableDcl>> freeVars = new HashMap<>();\n+        for (int i = 0; i < instructionList.size(); i++) {\n+            if (instructionList.get(i).getKind() == InstructionKind.XML_SEQ_STORE) {\n+                continue;\n+            }\n+            tryToReuseFromFreeVars(liveOuts, freeVars, instructionList, i, unusedVars);\n+            checkForFreeVars(freeVars, liveOuts, instructionList.get(i));\n+        }\n+    }\n+\n+    private void checkForFreeVars(Map<BType, LinkedList<BIRNode.BIRVariableDcl>> freeVars,\n+                                  Map<BIRAbstractInstruction, Set<BIRNode.BIRVariableDcl>> liveOuts,\n+                                  BIRAbstractInstruction instruction) {\n+        for (BIROperand operand : instruction.getRhsOperands()) {\n+            BType type = operand.variableDcl.type;\n+            if (operand.variableDcl.kind == VarKind.TEMP && !liveOuts.get(instruction).contains(operand.variableDcl)) {\n+                if (!freeVars.containsKey(type)) {\n+                    freeVars.put(type, new LinkedList<>());\n+                }\n+                LinkedList<BIRNode.BIRVariableDcl> ls = freeVars.get(type);\n+                ls.add(operand.variableDcl);\n+            }\n+        }\n+    }\n+\n+    private void tryToReuseFromFreeVars(Map<BIRAbstractInstruction, Set<BIRNode.BIRVariableDcl>> liveOuts,\n+                                        Map<BType, LinkedList<BIRNode.BIRVariableDcl>> freeVars,\n+                                        List<BIRAbstractInstruction> instructionList, int idx,\n+                                        List<BIRNode.BIRVariableDcl> unusedVars) {\n+        BIRAbstractInstruction instruction = instructionList.get(idx);\n+        if (instruction.lhsOp != null) {\n+            BType type = instruction.lhsOp.variableDcl.type;\n+            LinkedList<BIRNode.BIRVariableDcl> defLs = freeVars.get(type);\n+            if (defLs != null && !defLs.isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27e27c9de233b7b1f91174c772e02b851ee40241"}, "originalPosition": 104}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMDM5NDMwOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/optimizer/BirVariableOptimizer.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwNDoxNjowMlrOG_RMEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwNTo1NzoyMlrOG_SztA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODk5NTA4OQ==", "bodyText": "what is idx here?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25049#discussion_r468995089", "createdAt": "2020-08-12T04:16:02Z", "author": {"login": "Kishanthan"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/optimizer/BirVariableOptimizer.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+\n+package org.wso2.ballerinalang.compiler.bir.optimizer;\n+\n+import org.wso2.ballerinalang.compiler.bir.model.BIRAbstractInstruction;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode;\n+import org.wso2.ballerinalang.compiler.bir.model.BIROperand;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRTerminator;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRVisitor;\n+import org.wso2.ballerinalang.compiler.bir.model.InstructionKind;\n+import org.wso2.ballerinalang.compiler.bir.model.VarKind;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BType;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Optimize variables by reusing temporary variables of the same type.\n+ *\n+ * @since 1.2.1\n+ */\n+public class BirVariableOptimizer extends BIRVisitor {\n+    public void optimizeNode(BIRNode node) {\n+        node.accept(this);\n+    }\n+\n+    @Override\n+    public void visit(BIRNode.BIRPackage birPackage) {\n+        birPackage.typeDefs.forEach(tDef -> tDef.accept(this));\n+        birPackage.functions.forEach(func -> func.accept(this));\n+    }\n+\n+    @Override\n+    public void visit(BIRNode.BIRTypeDefinition birTypeDefinition) {\n+        birTypeDefinition.attachedFuncs.forEach(func -> func.accept(this));\n+    }\n+\n+    @Override\n+    public void visit(BIRNode.BIRFunction birFunction) {\n+        ControlFlowGraph graph = new ControlFlowGraph(birFunction);\n+        LivenessAnalyzer analyzer = new LivenessAnalyzer(graph.getNodes());\n+        Map<BIRAbstractInstruction, Set<BIRNode.BIRVariableDcl>> liveOuts = analyzer.getInstructionLiveOuts();\n+        List<BIRNode.BIRVariableDcl> unusedVars = new ArrayList<>();\n+        reuseVars(liveOuts, unusedVars, birFunction);\n+        unusedVars.forEach(var -> birFunction.localVars.remove(var));\n+    }\n+\n+    private void reuseVars(Map<BIRAbstractInstruction, Set<BIRNode.BIRVariableDcl>> liveOuts,\n+                           List<BIRNode.BIRVariableDcl> unusedVars, BIRNode.BIRFunction birFunction) {\n+        List<BIRAbstractInstruction> instructionList = getInstructionList(birFunction);\n+        Map<BType, LinkedList<BIRNode.BIRVariableDcl>> freeVars = new HashMap<>();\n+        for (int i = 0; i < instructionList.size(); i++) {\n+            if (instructionList.get(i).getKind() == InstructionKind.XML_SEQ_STORE) {\n+                continue;\n+            }\n+            tryToReuseFromFreeVars(liveOuts, freeVars, instructionList, i, unusedVars);\n+            checkForFreeVars(freeVars, liveOuts, instructionList.get(i));\n+        }\n+    }\n+\n+    private void checkForFreeVars(Map<BType, LinkedList<BIRNode.BIRVariableDcl>> freeVars,\n+                                  Map<BIRAbstractInstruction, Set<BIRNode.BIRVariableDcl>> liveOuts,\n+                                  BIRAbstractInstruction instruction) {\n+        for (BIROperand operand : instruction.getRhsOperands()) {\n+            BType type = operand.variableDcl.type;\n+            if (operand.variableDcl.kind == VarKind.TEMP && !liveOuts.get(instruction).contains(operand.variableDcl)) {\n+                if (!freeVars.containsKey(type)) {\n+                    freeVars.put(type, new LinkedList<>());\n+                }\n+                LinkedList<BIRNode.BIRVariableDcl> ls = freeVars.get(type);\n+                ls.add(operand.variableDcl);\n+            }\n+        }\n+    }\n+\n+    private void tryToReuseFromFreeVars(Map<BIRAbstractInstruction, Set<BIRNode.BIRVariableDcl>> liveOuts,\n+                                        Map<BType, LinkedList<BIRNode.BIRVariableDcl>> freeVars,\n+                                        List<BIRAbstractInstruction> instructionList, int idx,\n+                                        List<BIRNode.BIRVariableDcl> unusedVars) {\n+        BIRAbstractInstruction instruction = instructionList.get(idx);\n+        if (instruction.lhsOp != null) {\n+            BType type = instruction.lhsOp.variableDcl.type;\n+            LinkedList<BIRNode.BIRVariableDcl> defLs = freeVars.get(type);\n+            if (defLs != null && !defLs.isEmpty()) {\n+                BIRNode.BIRVariableDcl newLhsOp = defLs.peek();\n+                BIRNode.BIRVariableDcl oldLhsOp = (instruction).lhsOp.variableDcl;\n+                if (oldLhsOp.kind == VarKind.TEMP && !checkVarUse(instruction, oldLhsOp)) {\n+                    defLs.remove();\n+                    unusedVars.add(oldLhsOp);\n+                    replaceOldOp(instructionList, idx, oldLhsOp, newLhsOp, liveOuts);\n+                    instruction.lhsOp.variableDcl = newLhsOp;\n+                }\n+            }\n+\n+        }\n+    }\n+\n+    private void replaceOldOp(List<BIRAbstractInstruction> ls, int idx, BIRNode.BIRVariableDcl oldLhsOp,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27e27c9de233b7b1f91174c772e02b851ee40241"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODk5NTIxNg==", "bodyText": "and we should use proper name for \"ls\" here.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25049#discussion_r468995216", "createdAt": "2020-08-12T04:16:42Z", "author": {"login": "Kishanthan"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/optimizer/BirVariableOptimizer.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+\n+package org.wso2.ballerinalang.compiler.bir.optimizer;\n+\n+import org.wso2.ballerinalang.compiler.bir.model.BIRAbstractInstruction;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode;\n+import org.wso2.ballerinalang.compiler.bir.model.BIROperand;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRTerminator;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRVisitor;\n+import org.wso2.ballerinalang.compiler.bir.model.InstructionKind;\n+import org.wso2.ballerinalang.compiler.bir.model.VarKind;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BType;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Optimize variables by reusing temporary variables of the same type.\n+ *\n+ * @since 1.2.1\n+ */\n+public class BirVariableOptimizer extends BIRVisitor {\n+    public void optimizeNode(BIRNode node) {\n+        node.accept(this);\n+    }\n+\n+    @Override\n+    public void visit(BIRNode.BIRPackage birPackage) {\n+        birPackage.typeDefs.forEach(tDef -> tDef.accept(this));\n+        birPackage.functions.forEach(func -> func.accept(this));\n+    }\n+\n+    @Override\n+    public void visit(BIRNode.BIRTypeDefinition birTypeDefinition) {\n+        birTypeDefinition.attachedFuncs.forEach(func -> func.accept(this));\n+    }\n+\n+    @Override\n+    public void visit(BIRNode.BIRFunction birFunction) {\n+        ControlFlowGraph graph = new ControlFlowGraph(birFunction);\n+        LivenessAnalyzer analyzer = new LivenessAnalyzer(graph.getNodes());\n+        Map<BIRAbstractInstruction, Set<BIRNode.BIRVariableDcl>> liveOuts = analyzer.getInstructionLiveOuts();\n+        List<BIRNode.BIRVariableDcl> unusedVars = new ArrayList<>();\n+        reuseVars(liveOuts, unusedVars, birFunction);\n+        unusedVars.forEach(var -> birFunction.localVars.remove(var));\n+    }\n+\n+    private void reuseVars(Map<BIRAbstractInstruction, Set<BIRNode.BIRVariableDcl>> liveOuts,\n+                           List<BIRNode.BIRVariableDcl> unusedVars, BIRNode.BIRFunction birFunction) {\n+        List<BIRAbstractInstruction> instructionList = getInstructionList(birFunction);\n+        Map<BType, LinkedList<BIRNode.BIRVariableDcl>> freeVars = new HashMap<>();\n+        for (int i = 0; i < instructionList.size(); i++) {\n+            if (instructionList.get(i).getKind() == InstructionKind.XML_SEQ_STORE) {\n+                continue;\n+            }\n+            tryToReuseFromFreeVars(liveOuts, freeVars, instructionList, i, unusedVars);\n+            checkForFreeVars(freeVars, liveOuts, instructionList.get(i));\n+        }\n+    }\n+\n+    private void checkForFreeVars(Map<BType, LinkedList<BIRNode.BIRVariableDcl>> freeVars,\n+                                  Map<BIRAbstractInstruction, Set<BIRNode.BIRVariableDcl>> liveOuts,\n+                                  BIRAbstractInstruction instruction) {\n+        for (BIROperand operand : instruction.getRhsOperands()) {\n+            BType type = operand.variableDcl.type;\n+            if (operand.variableDcl.kind == VarKind.TEMP && !liveOuts.get(instruction).contains(operand.variableDcl)) {\n+                if (!freeVars.containsKey(type)) {\n+                    freeVars.put(type, new LinkedList<>());\n+                }\n+                LinkedList<BIRNode.BIRVariableDcl> ls = freeVars.get(type);\n+                ls.add(operand.variableDcl);\n+            }\n+        }\n+    }\n+\n+    private void tryToReuseFromFreeVars(Map<BIRAbstractInstruction, Set<BIRNode.BIRVariableDcl>> liveOuts,\n+                                        Map<BType, LinkedList<BIRNode.BIRVariableDcl>> freeVars,\n+                                        List<BIRAbstractInstruction> instructionList, int idx,\n+                                        List<BIRNode.BIRVariableDcl> unusedVars) {\n+        BIRAbstractInstruction instruction = instructionList.get(idx);\n+        if (instruction.lhsOp != null) {\n+            BType type = instruction.lhsOp.variableDcl.type;\n+            LinkedList<BIRNode.BIRVariableDcl> defLs = freeVars.get(type);\n+            if (defLs != null && !defLs.isEmpty()) {\n+                BIRNode.BIRVariableDcl newLhsOp = defLs.peek();\n+                BIRNode.BIRVariableDcl oldLhsOp = (instruction).lhsOp.variableDcl;\n+                if (oldLhsOp.kind == VarKind.TEMP && !checkVarUse(instruction, oldLhsOp)) {\n+                    defLs.remove();\n+                    unusedVars.add(oldLhsOp);\n+                    replaceOldOp(instructionList, idx, oldLhsOp, newLhsOp, liveOuts);\n+                    instruction.lhsOp.variableDcl = newLhsOp;\n+                }\n+            }\n+\n+        }\n+    }\n+\n+    private void replaceOldOp(List<BIRAbstractInstruction> ls, int idx, BIRNode.BIRVariableDcl oldLhsOp,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODk5NTA4OQ=="}, "originalCommit": {"oid": "27e27c9de233b7b1f91174c772e02b851ee40241"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTAyMTYyMA==", "bodyText": "idx is the index, I have renamed if unclear", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25049#discussion_r469021620", "createdAt": "2020-08-12T05:57:22Z", "author": {"login": "riyafa"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/optimizer/BirVariableOptimizer.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+\n+package org.wso2.ballerinalang.compiler.bir.optimizer;\n+\n+import org.wso2.ballerinalang.compiler.bir.model.BIRAbstractInstruction;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode;\n+import org.wso2.ballerinalang.compiler.bir.model.BIROperand;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRTerminator;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRVisitor;\n+import org.wso2.ballerinalang.compiler.bir.model.InstructionKind;\n+import org.wso2.ballerinalang.compiler.bir.model.VarKind;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BType;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Optimize variables by reusing temporary variables of the same type.\n+ *\n+ * @since 1.2.1\n+ */\n+public class BirVariableOptimizer extends BIRVisitor {\n+    public void optimizeNode(BIRNode node) {\n+        node.accept(this);\n+    }\n+\n+    @Override\n+    public void visit(BIRNode.BIRPackage birPackage) {\n+        birPackage.typeDefs.forEach(tDef -> tDef.accept(this));\n+        birPackage.functions.forEach(func -> func.accept(this));\n+    }\n+\n+    @Override\n+    public void visit(BIRNode.BIRTypeDefinition birTypeDefinition) {\n+        birTypeDefinition.attachedFuncs.forEach(func -> func.accept(this));\n+    }\n+\n+    @Override\n+    public void visit(BIRNode.BIRFunction birFunction) {\n+        ControlFlowGraph graph = new ControlFlowGraph(birFunction);\n+        LivenessAnalyzer analyzer = new LivenessAnalyzer(graph.getNodes());\n+        Map<BIRAbstractInstruction, Set<BIRNode.BIRVariableDcl>> liveOuts = analyzer.getInstructionLiveOuts();\n+        List<BIRNode.BIRVariableDcl> unusedVars = new ArrayList<>();\n+        reuseVars(liveOuts, unusedVars, birFunction);\n+        unusedVars.forEach(var -> birFunction.localVars.remove(var));\n+    }\n+\n+    private void reuseVars(Map<BIRAbstractInstruction, Set<BIRNode.BIRVariableDcl>> liveOuts,\n+                           List<BIRNode.BIRVariableDcl> unusedVars, BIRNode.BIRFunction birFunction) {\n+        List<BIRAbstractInstruction> instructionList = getInstructionList(birFunction);\n+        Map<BType, LinkedList<BIRNode.BIRVariableDcl>> freeVars = new HashMap<>();\n+        for (int i = 0; i < instructionList.size(); i++) {\n+            if (instructionList.get(i).getKind() == InstructionKind.XML_SEQ_STORE) {\n+                continue;\n+            }\n+            tryToReuseFromFreeVars(liveOuts, freeVars, instructionList, i, unusedVars);\n+            checkForFreeVars(freeVars, liveOuts, instructionList.get(i));\n+        }\n+    }\n+\n+    private void checkForFreeVars(Map<BType, LinkedList<BIRNode.BIRVariableDcl>> freeVars,\n+                                  Map<BIRAbstractInstruction, Set<BIRNode.BIRVariableDcl>> liveOuts,\n+                                  BIRAbstractInstruction instruction) {\n+        for (BIROperand operand : instruction.getRhsOperands()) {\n+            BType type = operand.variableDcl.type;\n+            if (operand.variableDcl.kind == VarKind.TEMP && !liveOuts.get(instruction).contains(operand.variableDcl)) {\n+                if (!freeVars.containsKey(type)) {\n+                    freeVars.put(type, new LinkedList<>());\n+                }\n+                LinkedList<BIRNode.BIRVariableDcl> ls = freeVars.get(type);\n+                ls.add(operand.variableDcl);\n+            }\n+        }\n+    }\n+\n+    private void tryToReuseFromFreeVars(Map<BIRAbstractInstruction, Set<BIRNode.BIRVariableDcl>> liveOuts,\n+                                        Map<BType, LinkedList<BIRNode.BIRVariableDcl>> freeVars,\n+                                        List<BIRAbstractInstruction> instructionList, int idx,\n+                                        List<BIRNode.BIRVariableDcl> unusedVars) {\n+        BIRAbstractInstruction instruction = instructionList.get(idx);\n+        if (instruction.lhsOp != null) {\n+            BType type = instruction.lhsOp.variableDcl.type;\n+            LinkedList<BIRNode.BIRVariableDcl> defLs = freeVars.get(type);\n+            if (defLs != null && !defLs.isEmpty()) {\n+                BIRNode.BIRVariableDcl newLhsOp = defLs.peek();\n+                BIRNode.BIRVariableDcl oldLhsOp = (instruction).lhsOp.variableDcl;\n+                if (oldLhsOp.kind == VarKind.TEMP && !checkVarUse(instruction, oldLhsOp)) {\n+                    defLs.remove();\n+                    unusedVars.add(oldLhsOp);\n+                    replaceOldOp(instructionList, idx, oldLhsOp, newLhsOp, liveOuts);\n+                    instruction.lhsOp.variableDcl = newLhsOp;\n+                }\n+            }\n+\n+        }\n+    }\n+\n+    private void replaceOldOp(List<BIRAbstractInstruction> ls, int idx, BIRNode.BIRVariableDcl oldLhsOp,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODk5NTA4OQ=="}, "originalCommit": {"oid": "27e27c9de233b7b1f91174c772e02b851ee40241"}, "originalPosition": 118}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMDU4NTQ4OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/optimizer/BirVariableOptimizer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwNjowMjo0N1rOG_S6wQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwNjowMjo0N1rOG_S6wQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTAyMzQyNQ==", "bodyText": "can we reverse this if and continue the loop?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25049#discussion_r469023425", "createdAt": "2020-08-12T06:02:47Z", "author": {"login": "Kishanthan"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/optimizer/BirVariableOptimizer.java", "diffHunk": "@@ -0,0 +1,239 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+\n+package org.wso2.ballerinalang.compiler.bir.optimizer;\n+\n+import org.wso2.ballerinalang.compiler.bir.model.BIRAbstractInstruction;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode;\n+import org.wso2.ballerinalang.compiler.bir.model.BIROperand;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRTerminator;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRVisitor;\n+import org.wso2.ballerinalang.compiler.bir.model.InstructionKind;\n+import org.wso2.ballerinalang.compiler.bir.model.VarKind;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BType;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Optimize variables by reusing temporary variables of the same type.\n+ *\n+ * @since 1.2.1\n+ */\n+public class BirVariableOptimizer extends BIRVisitor {\n+    public void optimizeNode(BIRNode node) {\n+        node.accept(this);\n+    }\n+\n+    @Override\n+    public void visit(BIRNode.BIRPackage birPackage) {\n+        birPackage.typeDefs.forEach(tDef -> tDef.accept(this));\n+        birPackage.functions.forEach(func -> func.accept(this));\n+    }\n+\n+    @Override\n+    public void visit(BIRNode.BIRTypeDefinition birTypeDefinition) {\n+        birTypeDefinition.attachedFuncs.forEach(func -> func.accept(this));\n+    }\n+\n+    @Override\n+    public void visit(BIRNode.BIRFunction birFunction) {\n+        ControlFlowGraph graph = new ControlFlowGraph(birFunction);\n+        LivenessAnalyzer analyzer = new LivenessAnalyzer(graph.getNodes());\n+        Map<BIRAbstractInstruction, Set<BIRNode.BIRVariableDcl>> liveOuts = analyzer.getInstructionLiveOuts();\n+        List<BIRNode.BIRVariableDcl> unusedVars = new ArrayList<>();\n+        reuseVars(liveOuts, unusedVars, birFunction);\n+        unusedVars.forEach(var -> birFunction.localVars.remove(var));\n+    }\n+\n+    private void reuseVars(Map<BIRAbstractInstruction, Set<BIRNode.BIRVariableDcl>> liveOuts,\n+                           List<BIRNode.BIRVariableDcl> unusedVars, BIRNode.BIRFunction birFunction) {\n+        List<BIRAbstractInstruction> instructionList = getInstructionList(birFunction);\n+        Map<BType, LinkedList<BIRNode.BIRVariableDcl>> freeVars = new HashMap<>();\n+        for (int i = 0; i < instructionList.size(); i++) {\n+            if (instructionList.get(i).getKind() == InstructionKind.XML_SEQ_STORE) {\n+                continue;\n+            }\n+            tryToReuseFromFreeVars(liveOuts, freeVars, instructionList, i, unusedVars);\n+            checkForFreeVars(freeVars, liveOuts, instructionList.get(i));\n+        }\n+    }\n+\n+    private void checkForFreeVars(Map<BType, LinkedList<BIRNode.BIRVariableDcl>> freeVars,\n+                                  Map<BIRAbstractInstruction, Set<BIRNode.BIRVariableDcl>> liveOuts,\n+                                  BIRAbstractInstruction instruction) {\n+        for (BIROperand operand : instruction.getRhsOperands()) {\n+            BType type = operand.variableDcl.type;\n+            if (operand.variableDcl.kind == VarKind.TEMP && !liveOuts.get(instruction).contains(operand.variableDcl)) {\n+                if (!freeVars.containsKey(type)) {\n+                    freeVars.put(type, new LinkedList<>());\n+                }\n+                LinkedList<BIRNode.BIRVariableDcl> ls = freeVars.get(type);\n+                ls.add(operand.variableDcl);\n+            }\n+        }\n+    }\n+\n+    private void tryToReuseFromFreeVars(Map<BIRAbstractInstruction, Set<BIRNode.BIRVariableDcl>> liveOuts,\n+                                        Map<BType, LinkedList<BIRNode.BIRVariableDcl>> freeVars,\n+                                        List<BIRAbstractInstruction> instructionList, int index,\n+                                        List<BIRNode.BIRVariableDcl> unusedVars) {\n+        BIRAbstractInstruction instruction = instructionList.get(index);\n+        if (instruction.lhsOp == null) {\n+            return;\n+        }\n+        BType type = instruction.lhsOp.variableDcl.type;\n+        LinkedList<BIRNode.BIRVariableDcl> defLs = freeVars.get(type);\n+        if (defLs == null || defLs.isEmpty()) {\n+            return;\n+        }\n+        BIRNode.BIRVariableDcl newLhsOp = defLs.peek();\n+        BIRNode.BIRVariableDcl oldLhsOp = (instruction).lhsOp.variableDcl;\n+        if (oldLhsOp.kind == VarKind.TEMP && !checkVarUse(instruction, oldLhsOp)) {\n+            defLs.remove();\n+            unusedVars.add(oldLhsOp);\n+            replaceOldOp(instructionList, index, oldLhsOp, newLhsOp, liveOuts);\n+            instruction.lhsOp.variableDcl = newLhsOp;\n+        }\n+    }\n+\n+    private void replaceOldOp(List<BIRAbstractInstruction> instructionList, int index, BIRNode.BIRVariableDcl oldLhsOp,\n+                              BIRNode.BIRVariableDcl newLhsOp,\n+                              Map<BIRAbstractInstruction, Set<BIRNode.BIRVariableDcl>> liveOuts) {\n+        for (int i = index + 1; i < instructionList.size(); i++) {\n+            BIRAbstractInstruction instruction = instructionList.get(i);\n+            boolean changed = false;\n+            BIROperand[] operands = instruction.getRhsOperands();\n+            for (BIROperand operand : operands) {\n+                if (operand.variableDcl == oldLhsOp) {\n+                    operand.variableDcl = newLhsOp;\n+                    changed = true;\n+                }\n+            }\n+\n+            if (changed) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0007f770fd5eec0eb3243a7b1320ff0080af6ff9"}, "originalPosition": 133}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMTA1NzkwOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/optimizer/ControlFlowGraph.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwODozNDowNVrOG_XYlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwODozNDowNVrOG_XYlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA5NjU5Nw==", "bodyText": "lets remove the version tag for now.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25049#discussion_r469096597", "createdAt": "2020-08-12T08:34:05Z", "author": {"login": "Kishanthan"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/optimizer/ControlFlowGraph.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+\n+package org.wso2.ballerinalang.compiler.bir.optimizer;\n+\n+import org.wso2.ballerinalang.compiler.bir.model.BIRAbstractInstruction;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRTerminator;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * The control flow graph that gets created from the bir.\n+ *\n+ * @since 2.0.0", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5c0a58c751665ad385ded28316766ceb7cb4ede"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMTMyNzkwOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/optimizer/BirVariableOptimizer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwOTo0NDoyMVrOG_Z8Lw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwOTo0NDoyMVrOG_Z8Lw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEzODQ3OQ==", "bodyText": "remove this version tag too", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25049#discussion_r469138479", "createdAt": "2020-08-12T09:44:21Z", "author": {"login": "Kishanthan"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/optimizer/BirVariableOptimizer.java", "diffHunk": "@@ -0,0 +1,240 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+\n+package org.wso2.ballerinalang.compiler.bir.optimizer;\n+\n+import org.wso2.ballerinalang.compiler.bir.model.BIRAbstractInstruction;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode;\n+import org.wso2.ballerinalang.compiler.bir.model.BIROperand;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRTerminator;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRVisitor;\n+import org.wso2.ballerinalang.compiler.bir.model.InstructionKind;\n+import org.wso2.ballerinalang.compiler.bir.model.VarKind;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BType;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Optimize variables by reusing temporary variables of the same type.\n+ *\n+ * @since 1.2.1", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5c0a58c751665ad385ded28316766ceb7cb4ede"}, "originalPosition": 40}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 319, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}