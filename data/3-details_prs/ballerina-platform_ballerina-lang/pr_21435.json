{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgyODY4ODI3", "number": 21435, "title": "jBallerina Compiler Backend Rewrite", "bodyText": "Purpose\n$subject.\nApproach\n\nDescribe how you are implementing the solutions along with the design details.\n\nSamples\n\nProvide high-level details about the samples related to this feature.\n\nRemarks\n\nList any other known issues, related PRs, TODO items, or any other notes related to the PR.\n\nCheck List\n\n Read the Contributing Guide\n Updated Change Log\n Checked Tooling Support (#)\n Added necessary tests\n\n Unit Tests\n Spec Conformance Tests\n Integration Tests\n Ballerina By Example Tests\n\n\n Increased Test Coverage\n Added necessary documentation\n\n API documentation\n Module documentation in Module.md files\n Ballerina By Examples", "createdAt": "2020-03-03T10:33:44Z", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21435", "merged": true, "mergeCommit": {"oid": "d0b0e8ae39fad043428ed03e693db0e53297fddb"}, "closed": true, "closedAt": "2020-03-04T15:17:57Z", "author": {"login": "Kishanthan"}, "timelineItems": {"totalCount": 256, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcJu0PvAH2gAyMzgyODY4ODI3Ojk3ODZkOGIzMWM1MzI5OGVjZTE4MDA1MWEzNzE2YjQ2OTE5NjVkNTI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcKYdnuAFqTM2ODg2MzI5Mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "9786d8b31c53298ece180051a3716b4691965d52", "author": {"user": {"login": "warunalakshitha", "name": "Waruna Lakshitha"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/9786d8b31c53298ece180051a3716b4691965d52", "committedDate": "2020-03-02T14:44:06Z", "message": "Merge pull request #21411 from Kishanthan/jbal-with-latest-master\n\nUse a seperate classloader for interop validation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6e9551c5a39b650d4e684aeb7b88ebee5e5ac85c", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6e9551c5a39b650d4e684aeb7b88ebee5e5ac85c", "committedDate": "2020-03-02T15:18:53Z", "message": "Merge pull request #21412 from warunalakshitha/jbal_rewrite\n\nFix code gen error tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cfc4da1aa7595bbeb46bd33e28544db1045be3bf", "author": {"user": {"login": "manuranga", "name": "manuranga perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/cfc4da1aa7595bbeb46bd33e28544db1045be3bf", "committedDate": "2020-03-03T05:09:32Z", "message": "Merge branch 'jbal-be-rewrite' of github.com:ballerina-platform/ballerina-lang into jbal-be-rewrite"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9a2733b6db433061d5ff2e720e320880057cb8a3", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/9a2733b6db433061d5ff2e720e320880057cb8a3", "committedDate": "2020-03-03T06:00:26Z", "message": "Skip non entry modules being desugared for jInterop validation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "65d88352670c81e82539ed721173a93cee904a8a", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/65d88352670c81e82539ed721173a93cee904a8a", "committedDate": "2020-03-03T06:01:06Z", "message": "Use a random port to avoid conflicts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "261d6cc5bd920f381a0d414b86ddad0814445c0b", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/261d6cc5bd920f381a0d414b86ddad0814445c0b", "committedDate": "2020-03-03T06:01:48Z", "message": "Merge pull request #21419 from manuranga/jbal-be-rewrite\n\nJbal be rewrite"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f696800b271e453549871a7a40ea901446eb5223", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f696800b271e453549871a7a40ea901446eb5223", "committedDate": "2020-03-03T06:02:09Z", "message": "Merge branch 'jbal-be-rewrite' of https://github.com/ballerina-platform/ballerina-lang into jbal-with-latest-master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "973abbea9d8b08c46a4c445b2afa960d872ec6e0", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/973abbea9d8b08c46a4c445b2afa960d872ec6e0", "committedDate": "2020-03-03T06:16:09Z", "message": "Fix compilation issue"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "be1291a09631b265171ef63edeeb6c97a3241b5f", "author": {"user": {"login": "warunalakshitha", "name": "Waruna Lakshitha"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/be1291a09631b265171ef63edeeb6c97a3241b5f", "committedDate": "2020-03-03T06:18:07Z", "message": "Merge pull request #21424 from Kishanthan/jbal-with-latest-master\n\nSkip non entry modules being desugared for jInterop validation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "759fd0ef149296a59b7d15f94967c4fb49543e27", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/759fd0ef149296a59b7d15f94967c4fb49543e27", "committedDate": "2020-03-03T06:29:04Z", "message": "Disable failing tests on jBallerina"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3c485aac3792e23a8ac476ce19e030dd20058205", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3c485aac3792e23a8ac476ce19e030dd20058205", "committedDate": "2020-03-03T06:29:22Z", "message": "Merge branch 'jbal-be-rewrite' of https://github.com/ballerina-platform/ballerina-lang into jbal-with-latest-master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "afd579efc8ccc5167b13ec2803b13347645cbc2c", "author": {"user": {"login": "manuranga", "name": "manuranga perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/afd579efc8ccc5167b13ec2803b13347645cbc2c", "committedDate": "2020-03-03T06:32:01Z", "message": "Merge pull request #21425 from Kishanthan/jbal-with-latest-master\n\nDisable failing tests on jBallerina"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "19412bbd07a89650331b8a6c111d3cd23618a67b", "author": {"user": {"login": "manuranga", "name": "manuranga perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/19412bbd07a89650331b8a6c111d3cd23618a67b", "committedDate": "2020-03-03T06:35:11Z", "message": "Fix check styles issues"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8188a46e3512d598645faf44e6458b72e9afed92", "author": {"user": {"login": "manuranga", "name": "manuranga perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/8188a46e3512d598645faf44e6458b72e9afed92", "committedDate": "2020-03-03T06:38:46Z", "message": "Merge branch 'jbal-be-rewrite' of github.com:ballerina-platform/ballerina-lang into jbal-be-rewrite"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "122dfe87b011569768627a27c068eff51886cada", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/122dfe87b011569768627a27c068eff51886cada", "committedDate": "2020-03-03T06:39:27Z", "message": "Merge pull request #21427 from manuranga/jbal-be-rewrite\n\nFix check styles issues"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "de7674bffa639cf83eaf6fe87a74baf2bcd1399a", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/de7674bffa639cf83eaf6fe87a74baf2bcd1399a", "committedDate": "2020-03-03T06:58:09Z", "message": "Fix checkstyle issues in unit tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ead11d1d646b38566c090d3acfd6de37a5274f60", "author": {"user": {"login": "manuranga", "name": "manuranga perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/ead11d1d646b38566c090d3acfd6de37a5274f60", "committedDate": "2020-03-03T07:02:17Z", "message": "Merge pull request #21429 from Kishanthan/jbal-with-latest-master\n\nFix checkstyle issues in unit tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7a736b6079a0b5d67dd613fea16519608d3d522d", "author": {"user": {"login": "manuranga", "name": "manuranga perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7a736b6079a0b5d67dd613fea16519608d3d522d", "committedDate": "2020-03-03T08:17:28Z", "message": "Move bstring test to a separate module"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "acaf69fe5daad2ad8f6d2e8ac8fee565e131d216", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/acaf69fe5daad2ad8f6d2e8ac8fee565e131d216", "committedDate": "2020-03-03T09:50:14Z", "message": "Disable failing integration tests on jBallerina"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9ba4aa5f0887b57f6b56e6a10f11715c6d0dfd56", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/9ba4aa5f0887b57f6b56e6a10f11715c6d0dfd56", "committedDate": "2020-03-03T09:50:30Z", "message": "Merge branch 'jbal-be-rewrite' of https://github.com/ballerina-platform/ballerina-lang into jbal-with-latest-master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "06d3daf55813f2d979e6b5448bf90874718f0754", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/06d3daf55813f2d979e6b5448bf90874718f0754", "committedDate": "2020-03-03T10:19:55Z", "message": "Disable failing integration tests on jBallerina"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b3a77ff10e0c6fb2a65a230906ecd2017e3fb204", "author": {"user": {"login": "warunalakshitha", "name": "Waruna Lakshitha"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b3a77ff10e0c6fb2a65a230906ecd2017e3fb204", "committedDate": "2020-03-03T10:20:58Z", "message": "Merge pull request #21432 from Kishanthan/jbal-with-latest-master\n\nDisable failing integration tests on jBallerina"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4f339dbfa4f2cbca9766c7bb39957f9e20e46256", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/4f339dbfa4f2cbca9766c7bb39957f9e20e46256", "committedDate": "2020-03-03T10:27:45Z", "message": "Merge with master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "52083b7c0fe1b51022749456d1bc72c724dcde58", "author": {"user": {"login": "manuranga", "name": "manuranga perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/52083b7c0fe1b51022749456d1bc72c724dcde58", "committedDate": "2020-03-03T10:32:56Z", "message": "Merge pull request #21434 from Kishanthan/jbal-with-latest-master\n\nMerge with master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aa4eb2a34acfd004952b2ed641ed1264507c6c65", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/aa4eb2a34acfd004952b2ed641ed1264507c6c65", "committedDate": "2020-03-03T11:15:46Z", "message": "Disable testerina failing tests on jBallerina"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9631e7c2ee446d64402430535229680315e8cbe6", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/9631e7c2ee446d64402430535229680315e8cbe6", "committedDate": "2020-03-03T11:18:08Z", "message": "Disable testerina failing tests on jBallerina"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c1f551d024a3ed2f8497cee8b7f05a8e955a4527", "author": {"user": {"login": "warunalakshitha", "name": "Waruna Lakshitha"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c1f551d024a3ed2f8497cee8b7f05a8e955a4527", "committedDate": "2020-03-03T11:19:07Z", "message": "Merge pull request #21437 from Kishanthan/jbal-with-latest-master\n\nDisable testerina failing tests on jBallerina"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a99a796a7980891b8c1124c03efc0db5aac2adac", "author": {"user": {"login": "manuranga", "name": "manuranga perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a99a796a7980891b8c1124c03efc0db5aac2adac", "committedDate": "2020-03-03T11:27:33Z", "message": "Pass interop class path via gradle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "96e943d52cb9ad90db7eafe20bb3f2d049137239", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/96e943d52cb9ad90db7eafe20bb3f2d049137239", "committedDate": "2020-03-03T11:33:51Z", "message": "Merge pull request #21438 from manuranga/jbal-be-rewrite\n\nJbal gradle build changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bcb8b2442ec8f3bd7d81ece846bf6ede2315d379", "author": {"user": {"login": "manuranga", "name": "manuranga perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/bcb8b2442ec8f3bd7d81ece846bf6ede2315d379", "committedDate": "2020-03-03T11:43:16Z", "message": "Fix class not found issue in interop"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9f0193f0dd120be0a4b3b45fcfbbbc054c66c945", "author": {"user": {"login": "manuranga", "name": "manuranga perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/9f0193f0dd120be0a4b3b45fcfbbbc054c66c945", "committedDate": "2020-03-03T11:44:51Z", "message": "Fix style issue"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e65ce40cd32ef5aed79376dbf3923069dbf15eaf", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e65ce40cd32ef5aed79376dbf3923069dbf15eaf", "committedDate": "2020-03-03T11:50:00Z", "message": "Merge pull request #21444 from manuranga/jbal-be-rewrite\n\nFix build issues"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0b988000f3d2eaa2fdfb3840881da3e4167b09bd", "author": {"user": {"login": "manuranga", "name": "manuranga perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/0b988000f3d2eaa2fdfb3840881da3e4167b09bd", "committedDate": "2020-03-03T11:52:32Z", "message": "Fix style issue"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3fe3a2bb853044f89191ad1ee6d66e3da918fe26", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3fe3a2bb853044f89191ad1ee6d66e3da918fe26", "committedDate": "2020-03-03T11:54:33Z", "message": "Merge pull request #21445 from manuranga/jbal-be-rewrite\n\nFix style issue"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "56e3c340757fd61942217b9f8db5c93d8c1cccaa", "author": {"user": {"login": "manuranga", "name": "manuranga perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/56e3c340757fd61942217b9f8db5c93d8c1cccaa", "committedDate": "2020-03-03T12:10:12Z", "message": "Fix interop class not found"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "06ce3bfbc111df05434e26079b1fbabc654f74da", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/06ce3bfbc111df05434e26079b1fbabc654f74da", "committedDate": "2020-03-03T12:11:41Z", "message": "Merge pull request #21446 from manuranga/jbal-be-rewrite\n\nFix interop class not found"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0b9b149af2d45627ff1c64d0fa7a6d63532c5a8c", "author": {"user": {"login": "manuranga", "name": "manuranga perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/0b9b149af2d45627ff1c64d0fa7a6d63532c5a8c", "committedDate": "2020-03-03T12:42:27Z", "message": "Change the class loader in tests to system class loader"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1e037301f42357d603f104e14589b6e11e32951d", "author": {"user": {"login": "manuranga", "name": "manuranga perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1e037301f42357d603f104e14589b6e11e32951d", "committedDate": "2020-03-03T12:52:44Z", "message": "Fix spotbug reported issue"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "82df207efdc85acd9646a1aae1461f7d1f7bbc5f", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/82df207efdc85acd9646a1aae1461f7d1f7bbc5f", "committedDate": "2020-03-03T12:54:24Z", "message": "Merge pull request #21447 from manuranga/jbal-be-rewrite\n\nChange the class loader in tests to system class loader"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY3OTc5NTk1", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21435#pullrequestreview-367979595", "createdAt": "2020-03-03T13:33:50Z", "commit": {"oid": "82df207efdc85acd9646a1aae1461f7d1f7bbc5f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxMzozMzo1MVrOFxF3GA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxMzozMzo1MVrOFxF3GA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzAyMDU2OA==", "bodyText": "Shall we add a new line in all places?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            package org.wso2.ballerinalang.compiler.bir;\n          \n          \n            \n            \n          \n          \n            \n            package org.wso2.ballerinalang.compiler.bir;", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21435#discussion_r387020568", "createdAt": "2020-03-03T13:33:51Z", "author": {"login": "riyafa"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/BackendDriver.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.wso2.ballerinalang.compiler.bir;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82df207efdc85acd9646a1aae1461f7d1f7bbc5f"}, "originalPosition": 18}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4NDg5MTkx", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21435#pullrequestreview-368489191", "createdAt": "2020-03-04T03:51:47Z", "commit": {"oid": "82df207efdc85acd9646a1aae1461f7d1f7bbc5f"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwMzo1MTo0N1rOFxfOOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwMzo1Njo1NVrOFxfSWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQzNjA4OQ==", "bodyText": "Why don't  we use a switch statement here?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21435#discussion_r387436089", "createdAt": "2020-03-04T03:51:47Z", "author": {"login": "riyafa"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/codegen/JvmCastGen.java", "diffHunk": "@@ -0,0 +1,1096 @@\n+/*\n+ *  Copyright (c) 2018, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.wso2.ballerinalang.compiler.bir.codegen;\n+\n+import org.ballerinalang.compiler.BLangCompilerException;\n+import org.objectweb.asm.Label;\n+import org.objectweb.asm.MethodVisitor;\n+import org.wso2.ballerinalang.compiler.bir.codegen.JvmMethodGen.BalToJVMIndexMap;\n+import org.wso2.ballerinalang.compiler.bir.codegen.interop.JType;\n+import org.wso2.ballerinalang.compiler.bir.codegen.interop.JTypeTags;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRVariableDcl;\n+import org.wso2.ballerinalang.compiler.bir.model.VarKind;\n+import org.wso2.ballerinalang.compiler.bir.model.VarScope;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BFiniteType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BMapType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BUnionType;\n+import org.wso2.ballerinalang.compiler.util.Name;\n+import org.wso2.ballerinalang.compiler.util.TypeTags;\n+\n+import static org.objectweb.asm.Opcodes.ALOAD;\n+import static org.objectweb.asm.Opcodes.ASTORE;\n+import static org.objectweb.asm.Opcodes.CHECKCAST;\n+import static org.objectweb.asm.Opcodes.D2F;\n+import static org.objectweb.asm.Opcodes.D2I;\n+import static org.objectweb.asm.Opcodes.D2L;\n+import static org.objectweb.asm.Opcodes.DUP;\n+import static org.objectweb.asm.Opcodes.F2D;\n+import static org.objectweb.asm.Opcodes.I2B;\n+import static org.objectweb.asm.Opcodes.I2C;\n+import static org.objectweb.asm.Opcodes.I2D;\n+import static org.objectweb.asm.Opcodes.I2F;\n+import static org.objectweb.asm.Opcodes.I2L;\n+import static org.objectweb.asm.Opcodes.I2S;\n+import static org.objectweb.asm.Opcodes.IFNE;\n+import static org.objectweb.asm.Opcodes.IFNULL;\n+import static org.objectweb.asm.Opcodes.INSTANCEOF;\n+import static org.objectweb.asm.Opcodes.INVOKEINTERFACE;\n+import static org.objectweb.asm.Opcodes.INVOKESPECIAL;\n+import static org.objectweb.asm.Opcodes.INVOKESTATIC;\n+import static org.objectweb.asm.Opcodes.INVOKEVIRTUAL;\n+import static org.objectweb.asm.Opcodes.L2D;\n+import static org.objectweb.asm.Opcodes.L2F;\n+import static org.objectweb.asm.Opcodes.L2I;\n+import static org.objectweb.asm.Opcodes.NEW;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.ARRAY_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BHANDLE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BOOLEAN_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BTYPE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.DECIMAL_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.DOUBLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.ERROR_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.FUNCTION_POINTER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.FUTURE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.HANDLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.INT_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.LONG_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.MAP_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.NUMBER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.OBJECT;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.OBJECT_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.REF_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.SIMPLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STREAM_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STRING_UTILS;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STRING_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TABLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TYPEDESC_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TYPE_CHECKER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TYPE_CONVERTER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.XML_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmInstructionGen.B_STRING_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmInstructionGen.I_STRING_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmInstructionGen.addBoxInsn;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmLabelGen.LabelGenerator;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmPackageGen.symbolTable;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmTypeGen.loadType;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.interop.InteropMethodGen.getSignatureForJType;\n+\n+/**\n+ * Check cast methods generation for JVM bytecode generation.\n+ *\n+ * @since 1.2.0\n+ */\n+public class JvmCastGen {\n+\n+    static void generatePlatformCheckCast(MethodVisitor mv, BalToJVMIndexMap indexMap, BType sourceType,\n+                                          BType targetType) {\n+\n+        if (sourceType.tag == JTypeTags.JTYPE) {\n+            // If a target type is bir type, then we can guarantee source type is a jvm type, hence the cast\n+            generateJToBCheckCast(mv, indexMap, (JType) sourceType, targetType);\n+        } else {\n+            // else target type is jvm and source type is bir\n+            generateBToJCheckCast(mv, sourceType, (JType) targetType);\n+        }\n+    }\n+\n+    public static void generateBToJCheckCast(MethodVisitor mv, BType sourceType, JType targetType) {\n+\n+        if (targetType.jTag == JTypeTags.JBYTE) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82df207efdc85acd9646a1aae1461f7d1f7bbc5f"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQzNjc0MA==", "bodyText": "Shall we use switch statement?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21435#discussion_r387436740", "createdAt": "2020-03-04T03:54:56Z", "author": {"login": "riyafa"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/codegen/JvmCastGen.java", "diffHunk": "@@ -0,0 +1,1096 @@\n+/*\n+ *  Copyright (c) 2018, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.wso2.ballerinalang.compiler.bir.codegen;\n+\n+import org.ballerinalang.compiler.BLangCompilerException;\n+import org.objectweb.asm.Label;\n+import org.objectweb.asm.MethodVisitor;\n+import org.wso2.ballerinalang.compiler.bir.codegen.JvmMethodGen.BalToJVMIndexMap;\n+import org.wso2.ballerinalang.compiler.bir.codegen.interop.JType;\n+import org.wso2.ballerinalang.compiler.bir.codegen.interop.JTypeTags;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRVariableDcl;\n+import org.wso2.ballerinalang.compiler.bir.model.VarKind;\n+import org.wso2.ballerinalang.compiler.bir.model.VarScope;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BFiniteType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BMapType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BUnionType;\n+import org.wso2.ballerinalang.compiler.util.Name;\n+import org.wso2.ballerinalang.compiler.util.TypeTags;\n+\n+import static org.objectweb.asm.Opcodes.ALOAD;\n+import static org.objectweb.asm.Opcodes.ASTORE;\n+import static org.objectweb.asm.Opcodes.CHECKCAST;\n+import static org.objectweb.asm.Opcodes.D2F;\n+import static org.objectweb.asm.Opcodes.D2I;\n+import static org.objectweb.asm.Opcodes.D2L;\n+import static org.objectweb.asm.Opcodes.DUP;\n+import static org.objectweb.asm.Opcodes.F2D;\n+import static org.objectweb.asm.Opcodes.I2B;\n+import static org.objectweb.asm.Opcodes.I2C;\n+import static org.objectweb.asm.Opcodes.I2D;\n+import static org.objectweb.asm.Opcodes.I2F;\n+import static org.objectweb.asm.Opcodes.I2L;\n+import static org.objectweb.asm.Opcodes.I2S;\n+import static org.objectweb.asm.Opcodes.IFNE;\n+import static org.objectweb.asm.Opcodes.IFNULL;\n+import static org.objectweb.asm.Opcodes.INSTANCEOF;\n+import static org.objectweb.asm.Opcodes.INVOKEINTERFACE;\n+import static org.objectweb.asm.Opcodes.INVOKESPECIAL;\n+import static org.objectweb.asm.Opcodes.INVOKESTATIC;\n+import static org.objectweb.asm.Opcodes.INVOKEVIRTUAL;\n+import static org.objectweb.asm.Opcodes.L2D;\n+import static org.objectweb.asm.Opcodes.L2F;\n+import static org.objectweb.asm.Opcodes.L2I;\n+import static org.objectweb.asm.Opcodes.NEW;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.ARRAY_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BHANDLE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BOOLEAN_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BTYPE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.DECIMAL_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.DOUBLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.ERROR_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.FUNCTION_POINTER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.FUTURE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.HANDLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.INT_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.LONG_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.MAP_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.NUMBER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.OBJECT;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.OBJECT_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.REF_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.SIMPLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STREAM_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STRING_UTILS;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STRING_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TABLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TYPEDESC_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TYPE_CHECKER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TYPE_CONVERTER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.XML_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmInstructionGen.B_STRING_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmInstructionGen.I_STRING_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmInstructionGen.addBoxInsn;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmLabelGen.LabelGenerator;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmPackageGen.symbolTable;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmTypeGen.loadType;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.interop.InteropMethodGen.getSignatureForJType;\n+\n+/**\n+ * Check cast methods generation for JVM bytecode generation.\n+ *\n+ * @since 1.2.0\n+ */\n+public class JvmCastGen {\n+\n+    static void generatePlatformCheckCast(MethodVisitor mv, BalToJVMIndexMap indexMap, BType sourceType,\n+                                          BType targetType) {\n+\n+        if (sourceType.tag == JTypeTags.JTYPE) {\n+            // If a target type is bir type, then we can guarantee source type is a jvm type, hence the cast\n+            generateJToBCheckCast(mv, indexMap, (JType) sourceType, targetType);\n+        } else {\n+            // else target type is jvm and source type is bir\n+            generateBToJCheckCast(mv, sourceType, (JType) targetType);\n+        }\n+    }\n+\n+    public static void generateBToJCheckCast(MethodVisitor mv, BType sourceType, JType targetType) {\n+\n+        if (targetType.jTag == JTypeTags.JBYTE) {\n+            generateCheckCastBToJByte(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JCHAR) {\n+            generateCheckCastBToJChar(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JSHORT) {\n+            generateCheckCastBToJShort(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JINT) {\n+            generateCheckCastBToJInt(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JLONG) {\n+            generateCheckCastBToJLong(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JFLOAT) {\n+            generateCheckCastBToJFloat(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JDOUBLE) {\n+            generateCheckCastBToJDouble(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JREF) {\n+            if (((JType.JRefType) targetType).typeValue.equals(B_STRING_VALUE)) {\n+                generateCheckCastBToJString(mv, sourceType);\n+            } else {\n+                generateCheckCastBToJRef(mv, sourceType, targetType);\n+            }\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JARRAY) {\n+            generateCheckCastBToJRef(mv, sourceType, targetType);\n+            return;\n+        } else {\n+            throw new BLangCompilerException(String.format(\"Casting is not supported from '%s' to 'java %s'\",\n+                    sourceType, targetType));\n+        }\n+    }\n+\n+    private static void generateCheckCastBToJString(MethodVisitor mv, BType sourceType) {\n+\n+        if (sourceType.tag == TypeTags.STRING) {\n+            mv.visitMethodInsn(INVOKESTATIC, STRING_UTILS, \"fromString\",\n+                    String.format(\"(L%s;)L%s;\", STRING_VALUE, B_STRING_VALUE), false);\n+        } else {\n+            throw new BLangCompilerException(String.format(\"Casting is not supported from '%s' to 'java byte'\",\n+                    sourceType));\n+        }\n+    }\n+\n+    private static void generateCheckCastBToJByte(MethodVisitor mv, BType sourceType) {\n+\n+        if (sourceType.tag == TypeTags.BYTE) {\n+            // do nothing\n+        } else if (sourceType.tag == TypeTags.INT) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82df207efdc85acd9646a1aae1461f7d1f7bbc5f"}, "originalPosition": 168}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQzNjg3OQ==", "bodyText": "Shall we use a constant for hardcoded method name?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21435#discussion_r387436879", "createdAt": "2020-03-04T03:55:32Z", "author": {"login": "riyafa"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/codegen/JvmCastGen.java", "diffHunk": "@@ -0,0 +1,1096 @@\n+/*\n+ *  Copyright (c) 2018, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.wso2.ballerinalang.compiler.bir.codegen;\n+\n+import org.ballerinalang.compiler.BLangCompilerException;\n+import org.objectweb.asm.Label;\n+import org.objectweb.asm.MethodVisitor;\n+import org.wso2.ballerinalang.compiler.bir.codegen.JvmMethodGen.BalToJVMIndexMap;\n+import org.wso2.ballerinalang.compiler.bir.codegen.interop.JType;\n+import org.wso2.ballerinalang.compiler.bir.codegen.interop.JTypeTags;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRVariableDcl;\n+import org.wso2.ballerinalang.compiler.bir.model.VarKind;\n+import org.wso2.ballerinalang.compiler.bir.model.VarScope;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BFiniteType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BMapType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BUnionType;\n+import org.wso2.ballerinalang.compiler.util.Name;\n+import org.wso2.ballerinalang.compiler.util.TypeTags;\n+\n+import static org.objectweb.asm.Opcodes.ALOAD;\n+import static org.objectweb.asm.Opcodes.ASTORE;\n+import static org.objectweb.asm.Opcodes.CHECKCAST;\n+import static org.objectweb.asm.Opcodes.D2F;\n+import static org.objectweb.asm.Opcodes.D2I;\n+import static org.objectweb.asm.Opcodes.D2L;\n+import static org.objectweb.asm.Opcodes.DUP;\n+import static org.objectweb.asm.Opcodes.F2D;\n+import static org.objectweb.asm.Opcodes.I2B;\n+import static org.objectweb.asm.Opcodes.I2C;\n+import static org.objectweb.asm.Opcodes.I2D;\n+import static org.objectweb.asm.Opcodes.I2F;\n+import static org.objectweb.asm.Opcodes.I2L;\n+import static org.objectweb.asm.Opcodes.I2S;\n+import static org.objectweb.asm.Opcodes.IFNE;\n+import static org.objectweb.asm.Opcodes.IFNULL;\n+import static org.objectweb.asm.Opcodes.INSTANCEOF;\n+import static org.objectweb.asm.Opcodes.INVOKEINTERFACE;\n+import static org.objectweb.asm.Opcodes.INVOKESPECIAL;\n+import static org.objectweb.asm.Opcodes.INVOKESTATIC;\n+import static org.objectweb.asm.Opcodes.INVOKEVIRTUAL;\n+import static org.objectweb.asm.Opcodes.L2D;\n+import static org.objectweb.asm.Opcodes.L2F;\n+import static org.objectweb.asm.Opcodes.L2I;\n+import static org.objectweb.asm.Opcodes.NEW;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.ARRAY_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BHANDLE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BOOLEAN_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BTYPE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.DECIMAL_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.DOUBLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.ERROR_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.FUNCTION_POINTER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.FUTURE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.HANDLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.INT_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.LONG_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.MAP_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.NUMBER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.OBJECT;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.OBJECT_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.REF_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.SIMPLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STREAM_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STRING_UTILS;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STRING_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TABLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TYPEDESC_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TYPE_CHECKER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TYPE_CONVERTER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.XML_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmInstructionGen.B_STRING_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmInstructionGen.I_STRING_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmInstructionGen.addBoxInsn;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmLabelGen.LabelGenerator;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmPackageGen.symbolTable;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmTypeGen.loadType;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.interop.InteropMethodGen.getSignatureForJType;\n+\n+/**\n+ * Check cast methods generation for JVM bytecode generation.\n+ *\n+ * @since 1.2.0\n+ */\n+public class JvmCastGen {\n+\n+    static void generatePlatformCheckCast(MethodVisitor mv, BalToJVMIndexMap indexMap, BType sourceType,\n+                                          BType targetType) {\n+\n+        if (sourceType.tag == JTypeTags.JTYPE) {\n+            // If a target type is bir type, then we can guarantee source type is a jvm type, hence the cast\n+            generateJToBCheckCast(mv, indexMap, (JType) sourceType, targetType);\n+        } else {\n+            // else target type is jvm and source type is bir\n+            generateBToJCheckCast(mv, sourceType, (JType) targetType);\n+        }\n+    }\n+\n+    public static void generateBToJCheckCast(MethodVisitor mv, BType sourceType, JType targetType) {\n+\n+        if (targetType.jTag == JTypeTags.JBYTE) {\n+            generateCheckCastBToJByte(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JCHAR) {\n+            generateCheckCastBToJChar(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JSHORT) {\n+            generateCheckCastBToJShort(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JINT) {\n+            generateCheckCastBToJInt(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JLONG) {\n+            generateCheckCastBToJLong(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JFLOAT) {\n+            generateCheckCastBToJFloat(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JDOUBLE) {\n+            generateCheckCastBToJDouble(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JREF) {\n+            if (((JType.JRefType) targetType).typeValue.equals(B_STRING_VALUE)) {\n+                generateCheckCastBToJString(mv, sourceType);\n+            } else {\n+                generateCheckCastBToJRef(mv, sourceType, targetType);\n+            }\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JARRAY) {\n+            generateCheckCastBToJRef(mv, sourceType, targetType);\n+            return;\n+        } else {\n+            throw new BLangCompilerException(String.format(\"Casting is not supported from '%s' to 'java %s'\",\n+                    sourceType, targetType));\n+        }\n+    }\n+\n+    private static void generateCheckCastBToJString(MethodVisitor mv, BType sourceType) {\n+\n+        if (sourceType.tag == TypeTags.STRING) {\n+            mv.visitMethodInsn(INVOKESTATIC, STRING_UTILS, \"fromString\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82df207efdc85acd9646a1aae1461f7d1f7bbc5f"}, "originalPosition": 156}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQzNzAxNA==", "bodyText": "Shall we use switch statements in all places instead of if-else-if statements?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21435#discussion_r387437014", "createdAt": "2020-03-04T03:56:11Z", "author": {"login": "riyafa"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/codegen/JvmCastGen.java", "diffHunk": "@@ -0,0 +1,1096 @@\n+/*\n+ *  Copyright (c) 2018, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.wso2.ballerinalang.compiler.bir.codegen;\n+\n+import org.ballerinalang.compiler.BLangCompilerException;\n+import org.objectweb.asm.Label;\n+import org.objectweb.asm.MethodVisitor;\n+import org.wso2.ballerinalang.compiler.bir.codegen.JvmMethodGen.BalToJVMIndexMap;\n+import org.wso2.ballerinalang.compiler.bir.codegen.interop.JType;\n+import org.wso2.ballerinalang.compiler.bir.codegen.interop.JTypeTags;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRVariableDcl;\n+import org.wso2.ballerinalang.compiler.bir.model.VarKind;\n+import org.wso2.ballerinalang.compiler.bir.model.VarScope;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BFiniteType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BMapType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BUnionType;\n+import org.wso2.ballerinalang.compiler.util.Name;\n+import org.wso2.ballerinalang.compiler.util.TypeTags;\n+\n+import static org.objectweb.asm.Opcodes.ALOAD;\n+import static org.objectweb.asm.Opcodes.ASTORE;\n+import static org.objectweb.asm.Opcodes.CHECKCAST;\n+import static org.objectweb.asm.Opcodes.D2F;\n+import static org.objectweb.asm.Opcodes.D2I;\n+import static org.objectweb.asm.Opcodes.D2L;\n+import static org.objectweb.asm.Opcodes.DUP;\n+import static org.objectweb.asm.Opcodes.F2D;\n+import static org.objectweb.asm.Opcodes.I2B;\n+import static org.objectweb.asm.Opcodes.I2C;\n+import static org.objectweb.asm.Opcodes.I2D;\n+import static org.objectweb.asm.Opcodes.I2F;\n+import static org.objectweb.asm.Opcodes.I2L;\n+import static org.objectweb.asm.Opcodes.I2S;\n+import static org.objectweb.asm.Opcodes.IFNE;\n+import static org.objectweb.asm.Opcodes.IFNULL;\n+import static org.objectweb.asm.Opcodes.INSTANCEOF;\n+import static org.objectweb.asm.Opcodes.INVOKEINTERFACE;\n+import static org.objectweb.asm.Opcodes.INVOKESPECIAL;\n+import static org.objectweb.asm.Opcodes.INVOKESTATIC;\n+import static org.objectweb.asm.Opcodes.INVOKEVIRTUAL;\n+import static org.objectweb.asm.Opcodes.L2D;\n+import static org.objectweb.asm.Opcodes.L2F;\n+import static org.objectweb.asm.Opcodes.L2I;\n+import static org.objectweb.asm.Opcodes.NEW;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.ARRAY_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BHANDLE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BOOLEAN_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BTYPE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.DECIMAL_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.DOUBLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.ERROR_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.FUNCTION_POINTER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.FUTURE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.HANDLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.INT_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.LONG_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.MAP_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.NUMBER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.OBJECT;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.OBJECT_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.REF_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.SIMPLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STREAM_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STRING_UTILS;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STRING_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TABLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TYPEDESC_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TYPE_CHECKER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TYPE_CONVERTER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.XML_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmInstructionGen.B_STRING_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmInstructionGen.I_STRING_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmInstructionGen.addBoxInsn;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmLabelGen.LabelGenerator;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmPackageGen.symbolTable;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmTypeGen.loadType;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.interop.InteropMethodGen.getSignatureForJType;\n+\n+/**\n+ * Check cast methods generation for JVM bytecode generation.\n+ *\n+ * @since 1.2.0\n+ */\n+public class JvmCastGen {\n+\n+    static void generatePlatformCheckCast(MethodVisitor mv, BalToJVMIndexMap indexMap, BType sourceType,\n+                                          BType targetType) {\n+\n+        if (sourceType.tag == JTypeTags.JTYPE) {\n+            // If a target type is bir type, then we can guarantee source type is a jvm type, hence the cast\n+            generateJToBCheckCast(mv, indexMap, (JType) sourceType, targetType);\n+        } else {\n+            // else target type is jvm and source type is bir\n+            generateBToJCheckCast(mv, sourceType, (JType) targetType);\n+        }\n+    }\n+\n+    public static void generateBToJCheckCast(MethodVisitor mv, BType sourceType, JType targetType) {\n+\n+        if (targetType.jTag == JTypeTags.JBYTE) {\n+            generateCheckCastBToJByte(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JCHAR) {\n+            generateCheckCastBToJChar(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JSHORT) {\n+            generateCheckCastBToJShort(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JINT) {\n+            generateCheckCastBToJInt(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JLONG) {\n+            generateCheckCastBToJLong(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JFLOAT) {\n+            generateCheckCastBToJFloat(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JDOUBLE) {\n+            generateCheckCastBToJDouble(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JREF) {\n+            if (((JType.JRefType) targetType).typeValue.equals(B_STRING_VALUE)) {\n+                generateCheckCastBToJString(mv, sourceType);\n+            } else {\n+                generateCheckCastBToJRef(mv, sourceType, targetType);\n+            }\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JARRAY) {\n+            generateCheckCastBToJRef(mv, sourceType, targetType);\n+            return;\n+        } else {\n+            throw new BLangCompilerException(String.format(\"Casting is not supported from '%s' to 'java %s'\",\n+                    sourceType, targetType));\n+        }\n+    }\n+\n+    private static void generateCheckCastBToJString(MethodVisitor mv, BType sourceType) {\n+\n+        if (sourceType.tag == TypeTags.STRING) {\n+            mv.visitMethodInsn(INVOKESTATIC, STRING_UTILS, \"fromString\",\n+                    String.format(\"(L%s;)L%s;\", STRING_VALUE, B_STRING_VALUE), false);\n+        } else {\n+            throw new BLangCompilerException(String.format(\"Casting is not supported from '%s' to 'java byte'\",\n+                    sourceType));\n+        }\n+    }\n+\n+    private static void generateCheckCastBToJByte(MethodVisitor mv, BType sourceType) {\n+\n+        if (sourceType.tag == TypeTags.BYTE) {\n+            // do nothing\n+        } else if (sourceType.tag == TypeTags.INT) {\n+            mv.visitInsn(L2I);\n+            mv.visitInsn(I2B);\n+        } else if (sourceType.tag == TypeTags.FLOAT) {\n+            mv.visitInsn(D2I);\n+            mv.visitInsn(I2B);\n+        } else if (sourceType.tag == TypeTags.HANDLE) {\n+            mv.visitMethodInsn(INVOKEVIRTUAL, HANDLE_VALUE, \"getValue\", \"()Ljava/lang/Object;\", false);\n+        } else if (sourceType.tag == TypeTags.FINITE) {\n+            mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, \"anyToByte\", String.format(\"(L%s;)I\", OBJECT), false);\n+            mv.visitInsn(I2B);\n+        } else {\n+            throw new BLangCompilerException(String.format(\"Casting is not supported from '%s' to 'java byte'\",\n+                    sourceType));\n+        }\n+    }\n+\n+    private static void generateCheckCastBToJChar(MethodVisitor mv, BType sourceType) {\n+\n+        if (sourceType.tag == TypeTags.BYTE) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82df207efdc85acd9646a1aae1461f7d1f7bbc5f"}, "originalPosition": 187}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQzNzE0Nw==", "bodyText": "Shall we use constants for the hardcoded values in all places?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21435#discussion_r387437147", "createdAt": "2020-03-04T03:56:55Z", "author": {"login": "riyafa"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/codegen/JvmCastGen.java", "diffHunk": "@@ -0,0 +1,1096 @@\n+/*\n+ *  Copyright (c) 2018, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.wso2.ballerinalang.compiler.bir.codegen;\n+\n+import org.ballerinalang.compiler.BLangCompilerException;\n+import org.objectweb.asm.Label;\n+import org.objectweb.asm.MethodVisitor;\n+import org.wso2.ballerinalang.compiler.bir.codegen.JvmMethodGen.BalToJVMIndexMap;\n+import org.wso2.ballerinalang.compiler.bir.codegen.interop.JType;\n+import org.wso2.ballerinalang.compiler.bir.codegen.interop.JTypeTags;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRVariableDcl;\n+import org.wso2.ballerinalang.compiler.bir.model.VarKind;\n+import org.wso2.ballerinalang.compiler.bir.model.VarScope;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BFiniteType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BMapType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BUnionType;\n+import org.wso2.ballerinalang.compiler.util.Name;\n+import org.wso2.ballerinalang.compiler.util.TypeTags;\n+\n+import static org.objectweb.asm.Opcodes.ALOAD;\n+import static org.objectweb.asm.Opcodes.ASTORE;\n+import static org.objectweb.asm.Opcodes.CHECKCAST;\n+import static org.objectweb.asm.Opcodes.D2F;\n+import static org.objectweb.asm.Opcodes.D2I;\n+import static org.objectweb.asm.Opcodes.D2L;\n+import static org.objectweb.asm.Opcodes.DUP;\n+import static org.objectweb.asm.Opcodes.F2D;\n+import static org.objectweb.asm.Opcodes.I2B;\n+import static org.objectweb.asm.Opcodes.I2C;\n+import static org.objectweb.asm.Opcodes.I2D;\n+import static org.objectweb.asm.Opcodes.I2F;\n+import static org.objectweb.asm.Opcodes.I2L;\n+import static org.objectweb.asm.Opcodes.I2S;\n+import static org.objectweb.asm.Opcodes.IFNE;\n+import static org.objectweb.asm.Opcodes.IFNULL;\n+import static org.objectweb.asm.Opcodes.INSTANCEOF;\n+import static org.objectweb.asm.Opcodes.INVOKEINTERFACE;\n+import static org.objectweb.asm.Opcodes.INVOKESPECIAL;\n+import static org.objectweb.asm.Opcodes.INVOKESTATIC;\n+import static org.objectweb.asm.Opcodes.INVOKEVIRTUAL;\n+import static org.objectweb.asm.Opcodes.L2D;\n+import static org.objectweb.asm.Opcodes.L2F;\n+import static org.objectweb.asm.Opcodes.L2I;\n+import static org.objectweb.asm.Opcodes.NEW;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.ARRAY_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BHANDLE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BOOLEAN_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BTYPE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.DECIMAL_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.DOUBLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.ERROR_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.FUNCTION_POINTER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.FUTURE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.HANDLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.INT_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.LONG_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.MAP_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.NUMBER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.OBJECT;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.OBJECT_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.REF_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.SIMPLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STREAM_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STRING_UTILS;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STRING_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TABLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TYPEDESC_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TYPE_CHECKER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TYPE_CONVERTER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.XML_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmInstructionGen.B_STRING_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmInstructionGen.I_STRING_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmInstructionGen.addBoxInsn;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmLabelGen.LabelGenerator;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmPackageGen.symbolTable;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmTypeGen.loadType;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.interop.InteropMethodGen.getSignatureForJType;\n+\n+/**\n+ * Check cast methods generation for JVM bytecode generation.\n+ *\n+ * @since 1.2.0\n+ */\n+public class JvmCastGen {\n+\n+    static void generatePlatformCheckCast(MethodVisitor mv, BalToJVMIndexMap indexMap, BType sourceType,\n+                                          BType targetType) {\n+\n+        if (sourceType.tag == JTypeTags.JTYPE) {\n+            // If a target type is bir type, then we can guarantee source type is a jvm type, hence the cast\n+            generateJToBCheckCast(mv, indexMap, (JType) sourceType, targetType);\n+        } else {\n+            // else target type is jvm and source type is bir\n+            generateBToJCheckCast(mv, sourceType, (JType) targetType);\n+        }\n+    }\n+\n+    public static void generateBToJCheckCast(MethodVisitor mv, BType sourceType, JType targetType) {\n+\n+        if (targetType.jTag == JTypeTags.JBYTE) {\n+            generateCheckCastBToJByte(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JCHAR) {\n+            generateCheckCastBToJChar(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JSHORT) {\n+            generateCheckCastBToJShort(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JINT) {\n+            generateCheckCastBToJInt(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JLONG) {\n+            generateCheckCastBToJLong(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JFLOAT) {\n+            generateCheckCastBToJFloat(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JDOUBLE) {\n+            generateCheckCastBToJDouble(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JREF) {\n+            if (((JType.JRefType) targetType).typeValue.equals(B_STRING_VALUE)) {\n+                generateCheckCastBToJString(mv, sourceType);\n+            } else {\n+                generateCheckCastBToJRef(mv, sourceType, targetType);\n+            }\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JARRAY) {\n+            generateCheckCastBToJRef(mv, sourceType, targetType);\n+            return;\n+        } else {\n+            throw new BLangCompilerException(String.format(\"Casting is not supported from '%s' to 'java %s'\",\n+                    sourceType, targetType));\n+        }\n+    }\n+\n+    private static void generateCheckCastBToJString(MethodVisitor mv, BType sourceType) {\n+\n+        if (sourceType.tag == TypeTags.STRING) {\n+            mv.visitMethodInsn(INVOKESTATIC, STRING_UTILS, \"fromString\",\n+                    String.format(\"(L%s;)L%s;\", STRING_VALUE, B_STRING_VALUE), false);\n+        } else {\n+            throw new BLangCompilerException(String.format(\"Casting is not supported from '%s' to 'java byte'\",\n+                    sourceType));\n+        }\n+    }\n+\n+    private static void generateCheckCastBToJByte(MethodVisitor mv, BType sourceType) {\n+\n+        if (sourceType.tag == TypeTags.BYTE) {\n+            // do nothing\n+        } else if (sourceType.tag == TypeTags.INT) {\n+            mv.visitInsn(L2I);\n+            mv.visitInsn(I2B);\n+        } else if (sourceType.tag == TypeTags.FLOAT) {\n+            mv.visitInsn(D2I);\n+            mv.visitInsn(I2B);\n+        } else if (sourceType.tag == TypeTags.HANDLE) {\n+            mv.visitMethodInsn(INVOKEVIRTUAL, HANDLE_VALUE, \"getValue\", \"()Ljava/lang/Object;\", false);\n+        } else if (sourceType.tag == TypeTags.FINITE) {\n+            mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, \"anyToByte\", String.format(\"(L%s;)I\", OBJECT), false);\n+            mv.visitInsn(I2B);\n+        } else {\n+            throw new BLangCompilerException(String.format(\"Casting is not supported from '%s' to 'java byte'\",\n+                    sourceType));\n+        }\n+    }\n+\n+    private static void generateCheckCastBToJChar(MethodVisitor mv, BType sourceType) {\n+\n+        if (sourceType.tag == TypeTags.BYTE) {\n+            mv.visitInsn(I2C);\n+        } else if (sourceType.tag == TypeTags.INT) {\n+            mv.visitInsn(L2I);\n+            mv.visitInsn(I2C);\n+        } else if (sourceType.tag == TypeTags.FLOAT) {\n+            mv.visitInsn(D2I);\n+            mv.visitInsn(I2C);\n+        } else if (sourceType.tag == TypeTags.HANDLE) {\n+            mv.visitMethodInsn(INVOKEVIRTUAL, HANDLE_VALUE, \"getValue\", \"()Ljava/lang/Object;\", false);\n+        } else if (sourceType.tag == TypeTags.FINITE) {\n+            mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, \"anyToInt\", String.format(\"(L%s;)J\", OBJECT), false);\n+            mv.visitInsn(L2I);\n+            mv.visitInsn(I2C);\n+        } else {\n+            throw new BLangCompilerException(String.format(\"Casting is not supported from '%s' to 'java char'\",\n+                    sourceType));\n+        }\n+    }\n+\n+    private static void generateCheckCastBToJShort(MethodVisitor mv, BType sourceType) {\n+\n+        if (sourceType.tag == TypeTags.BYTE) {\n+            mv.visitInsn(I2S);\n+        } else if (sourceType.tag == TypeTags.INT) {\n+            mv.visitInsn(L2I);\n+            mv.visitInsn(I2S);\n+        } else if (sourceType.tag == TypeTags.FLOAT) {\n+            mv.visitInsn(D2I);\n+            mv.visitInsn(I2S);\n+        } else if (sourceType.tag == TypeTags.HANDLE) {\n+            mv.visitMethodInsn(INVOKEVIRTUAL, HANDLE_VALUE, \"getValue\", \"()Ljava/lang/Object;\", false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82df207efdc85acd9646a1aae1461f7d1f7bbc5f"}, "originalPosition": 218}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4NTA5MzUz", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21435#pullrequestreview-368509353", "createdAt": "2020-03-04T05:15:47Z", "commit": {"oid": "82df207efdc85acd9646a1aae1461f7d1f7bbc5f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwNToxNTo0OFrOFxgPSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwNToxNTo0OFrOFxgPSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ1Mjc0NQ==", "bodyText": "This add(0, is used in multiple places. A new reader might not know what 0 signifies. If we define a constant for 0 it would add clarity.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21435#discussion_r387452745", "createdAt": "2020-03-04T05:15:48Z", "author": {"login": "riyafa"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/BIRGen.java", "diffHunk": "@@ -460,6 +461,7 @@ public void visit(BLangFunction astFunc) {\n         // Special %0 location for storing return values\n         birFunc.returnVariable = new BIRVariableDcl(astFunc.pos, astFunc.symbol.type.getReturnType(),\n                 this.env.nextLocalVarId(names), VarScope.FUNCTION, VarKind.RETURN, null);\n+        birFunc.localVars.add(0, birFunc.returnVariable);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82df207efdc85acd9646a1aae1461f7d1f7bbc5f"}, "originalPosition": 41}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0e80a5ea0a350948f0a831379c9b4065a9880af4", "author": {"user": {"login": "manuranga", "name": "manuranga perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/0e80a5ea0a350948f0a831379c9b4065a9880af4", "committedDate": "2020-03-04T05:29:12Z", "message": "Fix running negative tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7f47c0b36610a862ac0075dd9a94414ac64312d7", "author": {"user": {"login": "manuranga", "name": "manuranga perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7f47c0b36610a862ac0075dd9a94414ac64312d7", "committedDate": "2020-03-04T05:29:57Z", "message": "Disable failing negative tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "61278aae53e5eb07f5237248f3df59698c95b47d", "author": {"user": {"login": "manuranga", "name": "manuranga perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/61278aae53e5eb07f5237248f3df59698c95b47d", "committedDate": "2020-03-04T05:33:54Z", "message": "Force rerun gradle tasks to override cache temporally"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7ae8882b91090620aef93185c5118660a8317389", "author": {"user": {"login": "manuranga", "name": "manuranga perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7ae8882b91090620aef93185c5118660a8317389", "committedDate": "2020-03-04T05:35:01Z", "message": "Merge remote-tracking branch 'origin/jbal-be-rewrite' into jbal-be-rewrite"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4NTEyNDUx", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21435#pullrequestreview-368512451", "createdAt": "2020-03-04T05:27:24Z", "commit": {"oid": "82df207efdc85acd9646a1aae1461f7d1f7bbc5f"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwNToyNzoyNFrOFxgZFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwNTo0Mzo0MFrOFxgnjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ1NTI1Mw==", "bodyText": "Shall we remove commented out code in all places before merging?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21435#discussion_r387455253", "createdAt": "2020-03-04T05:27:24Z", "author": {"login": "riyafa"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/codegen/JvmCastGen.java", "diffHunk": "@@ -0,0 +1,1096 @@\n+/*\n+ *  Copyright (c) 2018, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.wso2.ballerinalang.compiler.bir.codegen;\n+\n+import org.ballerinalang.compiler.BLangCompilerException;\n+import org.objectweb.asm.Label;\n+import org.objectweb.asm.MethodVisitor;\n+import org.wso2.ballerinalang.compiler.bir.codegen.JvmMethodGen.BalToJVMIndexMap;\n+import org.wso2.ballerinalang.compiler.bir.codegen.interop.JType;\n+import org.wso2.ballerinalang.compiler.bir.codegen.interop.JTypeTags;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRVariableDcl;\n+import org.wso2.ballerinalang.compiler.bir.model.VarKind;\n+import org.wso2.ballerinalang.compiler.bir.model.VarScope;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BFiniteType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BMapType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BUnionType;\n+import org.wso2.ballerinalang.compiler.util.Name;\n+import org.wso2.ballerinalang.compiler.util.TypeTags;\n+\n+import static org.objectweb.asm.Opcodes.ALOAD;\n+import static org.objectweb.asm.Opcodes.ASTORE;\n+import static org.objectweb.asm.Opcodes.CHECKCAST;\n+import static org.objectweb.asm.Opcodes.D2F;\n+import static org.objectweb.asm.Opcodes.D2I;\n+import static org.objectweb.asm.Opcodes.D2L;\n+import static org.objectweb.asm.Opcodes.DUP;\n+import static org.objectweb.asm.Opcodes.F2D;\n+import static org.objectweb.asm.Opcodes.I2B;\n+import static org.objectweb.asm.Opcodes.I2C;\n+import static org.objectweb.asm.Opcodes.I2D;\n+import static org.objectweb.asm.Opcodes.I2F;\n+import static org.objectweb.asm.Opcodes.I2L;\n+import static org.objectweb.asm.Opcodes.I2S;\n+import static org.objectweb.asm.Opcodes.IFNE;\n+import static org.objectweb.asm.Opcodes.IFNULL;\n+import static org.objectweb.asm.Opcodes.INSTANCEOF;\n+import static org.objectweb.asm.Opcodes.INVOKEINTERFACE;\n+import static org.objectweb.asm.Opcodes.INVOKESPECIAL;\n+import static org.objectweb.asm.Opcodes.INVOKESTATIC;\n+import static org.objectweb.asm.Opcodes.INVOKEVIRTUAL;\n+import static org.objectweb.asm.Opcodes.L2D;\n+import static org.objectweb.asm.Opcodes.L2F;\n+import static org.objectweb.asm.Opcodes.L2I;\n+import static org.objectweb.asm.Opcodes.NEW;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.ARRAY_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BHANDLE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BOOLEAN_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BTYPE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.DECIMAL_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.DOUBLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.ERROR_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.FUNCTION_POINTER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.FUTURE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.HANDLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.INT_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.LONG_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.MAP_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.NUMBER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.OBJECT;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.OBJECT_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.REF_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.SIMPLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STREAM_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STRING_UTILS;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STRING_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TABLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TYPEDESC_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TYPE_CHECKER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TYPE_CONVERTER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.XML_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmInstructionGen.B_STRING_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmInstructionGen.I_STRING_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmInstructionGen.addBoxInsn;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmLabelGen.LabelGenerator;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmPackageGen.symbolTable;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmTypeGen.loadType;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.interop.InteropMethodGen.getSignatureForJType;\n+\n+/**\n+ * Check cast methods generation for JVM bytecode generation.\n+ *\n+ * @since 1.2.0\n+ */\n+public class JvmCastGen {\n+\n+    static void generatePlatformCheckCast(MethodVisitor mv, BalToJVMIndexMap indexMap, BType sourceType,\n+                                          BType targetType) {\n+\n+        if (sourceType.tag == JTypeTags.JTYPE) {\n+            // If a target type is bir type, then we can guarantee source type is a jvm type, hence the cast\n+            generateJToBCheckCast(mv, indexMap, (JType) sourceType, targetType);\n+        } else {\n+            // else target type is jvm and source type is bir\n+            generateBToJCheckCast(mv, sourceType, (JType) targetType);\n+        }\n+    }\n+\n+    public static void generateBToJCheckCast(MethodVisitor mv, BType sourceType, JType targetType) {\n+\n+        if (targetType.jTag == JTypeTags.JBYTE) {\n+            generateCheckCastBToJByte(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JCHAR) {\n+            generateCheckCastBToJChar(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JSHORT) {\n+            generateCheckCastBToJShort(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JINT) {\n+            generateCheckCastBToJInt(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JLONG) {\n+            generateCheckCastBToJLong(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JFLOAT) {\n+            generateCheckCastBToJFloat(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JDOUBLE) {\n+            generateCheckCastBToJDouble(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JREF) {\n+            if (((JType.JRefType) targetType).typeValue.equals(B_STRING_VALUE)) {\n+                generateCheckCastBToJString(mv, sourceType);\n+            } else {\n+                generateCheckCastBToJRef(mv, sourceType, targetType);\n+            }\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JARRAY) {\n+            generateCheckCastBToJRef(mv, sourceType, targetType);\n+            return;\n+        } else {\n+            throw new BLangCompilerException(String.format(\"Casting is not supported from '%s' to 'java %s'\",\n+                    sourceType, targetType));\n+        }\n+    }\n+\n+    private static void generateCheckCastBToJString(MethodVisitor mv, BType sourceType) {\n+\n+        if (sourceType.tag == TypeTags.STRING) {\n+            mv.visitMethodInsn(INVOKESTATIC, STRING_UTILS, \"fromString\",\n+                    String.format(\"(L%s;)L%s;\", STRING_VALUE, B_STRING_VALUE), false);\n+        } else {\n+            throw new BLangCompilerException(String.format(\"Casting is not supported from '%s' to 'java byte'\",\n+                    sourceType));\n+        }\n+    }\n+\n+    private static void generateCheckCastBToJByte(MethodVisitor mv, BType sourceType) {\n+\n+        if (sourceType.tag == TypeTags.BYTE) {\n+            // do nothing\n+        } else if (sourceType.tag == TypeTags.INT) {\n+            mv.visitInsn(L2I);\n+            mv.visitInsn(I2B);\n+        } else if (sourceType.tag == TypeTags.FLOAT) {\n+            mv.visitInsn(D2I);\n+            mv.visitInsn(I2B);\n+        } else if (sourceType.tag == TypeTags.HANDLE) {\n+            mv.visitMethodInsn(INVOKEVIRTUAL, HANDLE_VALUE, \"getValue\", \"()Ljava/lang/Object;\", false);\n+        } else if (sourceType.tag == TypeTags.FINITE) {\n+            mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, \"anyToByte\", String.format(\"(L%s;)I\", OBJECT), false);\n+            mv.visitInsn(I2B);\n+        } else {\n+            throw new BLangCompilerException(String.format(\"Casting is not supported from '%s' to 'java byte'\",\n+                    sourceType));\n+        }\n+    }\n+\n+    private static void generateCheckCastBToJChar(MethodVisitor mv, BType sourceType) {\n+\n+        if (sourceType.tag == TypeTags.BYTE) {\n+            mv.visitInsn(I2C);\n+        } else if (sourceType.tag == TypeTags.INT) {\n+            mv.visitInsn(L2I);\n+            mv.visitInsn(I2C);\n+        } else if (sourceType.tag == TypeTags.FLOAT) {\n+            mv.visitInsn(D2I);\n+            mv.visitInsn(I2C);\n+        } else if (sourceType.tag == TypeTags.HANDLE) {\n+            mv.visitMethodInsn(INVOKEVIRTUAL, HANDLE_VALUE, \"getValue\", \"()Ljava/lang/Object;\", false);\n+        } else if (sourceType.tag == TypeTags.FINITE) {\n+            mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, \"anyToInt\", String.format(\"(L%s;)J\", OBJECT), false);\n+            mv.visitInsn(L2I);\n+            mv.visitInsn(I2C);\n+        } else {\n+            throw new BLangCompilerException(String.format(\"Casting is not supported from '%s' to 'java char'\",\n+                    sourceType));\n+        }\n+    }\n+\n+    private static void generateCheckCastBToJShort(MethodVisitor mv, BType sourceType) {\n+\n+        if (sourceType.tag == TypeTags.BYTE) {\n+            mv.visitInsn(I2S);\n+        } else if (sourceType.tag == TypeTags.INT) {\n+            mv.visitInsn(L2I);\n+            mv.visitInsn(I2S);\n+        } else if (sourceType.tag == TypeTags.FLOAT) {\n+            mv.visitInsn(D2I);\n+            mv.visitInsn(I2S);\n+        } else if (sourceType.tag == TypeTags.HANDLE) {\n+            mv.visitMethodInsn(INVOKEVIRTUAL, HANDLE_VALUE, \"getValue\", \"()Ljava/lang/Object;\", false);\n+        } else if (sourceType.tag == TypeTags.FINITE) {\n+            mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, \"anyToInt\", String.format(\"(L%s;)J\", OBJECT), false);\n+            mv.visitInsn(L2I);\n+            mv.visitInsn(I2S);\n+        } else {\n+            throw new BLangCompilerException(String.format(\"Casting is not supported from '%s' to 'java short'\",\n+                    sourceType));\n+        }\n+    }\n+\n+    private static void generateCheckCastBToJInt(MethodVisitor mv, BType sourceType) {\n+\n+        if (sourceType.tag == TypeTags.BYTE) {\n+            // do nothing\n+        } else if (sourceType.tag == TypeTags.INT) {\n+            mv.visitInsn(L2I);\n+        } else if (sourceType.tag == TypeTags.FLOAT) {\n+            mv.visitInsn(D2I);\n+        } else if (sourceType.tag == TypeTags.HANDLE) {\n+            mv.visitMethodInsn(INVOKEVIRTUAL, HANDLE_VALUE, \"getValue\", \"()Ljava/lang/Object;\", false);\n+        } else if (sourceType.tag == TypeTags.FINITE) {\n+            mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, \"anyToInt\", String.format(\"(L%s;)J\", OBJECT), false);\n+            mv.visitInsn(L2I);\n+        } else {\n+            throw new BLangCompilerException(String.format(\"Casting is not supported from '%s' to 'java int'\",\n+                    sourceType));\n+        }\n+    }\n+\n+    private static void generateCheckCastBToJLong(MethodVisitor mv, BType sourceType) {\n+\n+        if (sourceType.tag == TypeTags.BYTE) {\n+            mv.visitInsn(I2L);\n+        } else if (sourceType.tag == TypeTags.INT) {\n+            // do nothing\n+        } else if (sourceType.tag == TypeTags.FLOAT) {\n+            mv.visitInsn(D2L);\n+        } else if (sourceType.tag == TypeTags.HANDLE) {\n+            mv.visitMethodInsn(INVOKEVIRTUAL, HANDLE_VALUE, \"getValue\", \"()Ljava/lang/Object;\", false);\n+        } else if (sourceType.tag == TypeTags.FINITE) {\n+            mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, \"anyToInt\", String.format(\"(L%s;)J\", OBJECT), false);\n+        } else {\n+            throw new BLangCompilerException(String.format(\"Casting is not supported from '%s' to 'java long'\",\n+                    sourceType));\n+        }\n+    }\n+\n+    private static void generateCheckCastBToJFloat(MethodVisitor mv, BType sourceType) {\n+\n+        if (sourceType.tag == TypeTags.BYTE) {\n+            mv.visitInsn(I2F);\n+        } else if (sourceType.tag == TypeTags.INT) {\n+            mv.visitInsn(L2F);\n+        } else if (sourceType.tag == TypeTags.FLOAT) {\n+            mv.visitInsn(D2F);\n+        } else if (sourceType.tag == TypeTags.HANDLE) {\n+            mv.visitMethodInsn(INVOKEVIRTUAL, HANDLE_VALUE, \"getValue\", \"()Ljava/lang/Object;\", false);\n+        } else if (sourceType.tag == TypeTags.FINITE) {\n+            mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, \"anyToFloat\", String.format(\"(L%s;)D\", OBJECT), false);\n+            mv.visitInsn(D2F);\n+        } else {\n+            throw new BLangCompilerException(String.format(\"Casting is not supported from '%s' to 'java float'\",\n+                    sourceType));\n+        }\n+    }\n+\n+    private static void generateCheckCastBToJDouble(MethodVisitor mv, BType sourceType) {\n+\n+        if (sourceType.tag == TypeTags.BYTE) {\n+            mv.visitInsn(I2D);\n+        } else if (sourceType.tag == TypeTags.INT) {\n+            mv.visitInsn(L2D);\n+        } else if (sourceType.tag == TypeTags.FLOAT) {\n+            // do nothing\n+        } else if (sourceType.tag == TypeTags.HANDLE) {\n+            mv.visitMethodInsn(INVOKEVIRTUAL, HANDLE_VALUE, \"getValue\", \"()Ljava/lang/Object;\", false);\n+        } else if (sourceType.tag == TypeTags.FINITE) {\n+            mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, \"anyToFloat\", String.format(\"(L%s;)D\", OBJECT), false);\n+        } else {\n+            throw new BLangCompilerException(String.format(\"Casting is not supported from '%s' to 'java double'\",\n+                    sourceType));\n+        }\n+    }\n+\n+    private static void generateCheckCastBToJRef(MethodVisitor mv, BType sourceType, JType targetType) {\n+\n+        if (sourceType.tag == TypeTags.HANDLE) {\n+            if (targetType.jTag == JTypeTags.JREF) {\n+                JType.JRefType jRefType = (JType.JRefType) targetType;\n+                if (jRefType.typeValue.equals(HANDLE_VALUE) || jRefType.typeValue.equals(BHANDLE)) {\n+                    // do nothing\n+                    return;\n+                }\n+            }\n+            mv.visitMethodInsn(INVOKEVIRTUAL, HANDLE_VALUE, \"getValue\", \"()Ljava/lang/Object;\", false);\n+            String sig = getSignatureForJType(targetType);\n+            mv.visitTypeInsn(CHECKCAST, sig);\n+        } else if (sourceType.tag == TypeTags.DECIMAL) {\n+            // do nothing\n+            return;\n+        } else {\n+            if (targetType.jTag == JTypeTags.JREF) {\n+                addBoxInsn(mv, sourceType);\n+                mv.visitTypeInsn(CHECKCAST, ((JType.JRefType) targetType).typeValue);\n+            } else {\n+                throw new BLangCompilerException(String.format(\"Casting is not supported from '%s' to '%s'\",\n+                        sourceType, targetType));\n+            }\n+        }\n+    }\n+\n+    private static void generateJToBCheckCast(MethodVisitor mv, BalToJVMIndexMap indexMap, JType sourceType,\n+                                              BType targetType) {\n+\n+        if (targetType.tag == TypeTags.INT) {\n+            generateCheckCastJToBInt(mv, sourceType);\n+            return;\n+        } else if (targetType.tag == TypeTags.FLOAT) {\n+            generateCheckCastJToBFloat(mv, sourceType);\n+            return;\n+        } else if (targetType.tag == TypeTags.STRING) {\n+            generateCheckCastJToBString(mv, sourceType);\n+            return;\n+        } else if (targetType.tag == TypeTags.DECIMAL) {\n+            generateCheckCastJToBDecimal(mv, sourceType);\n+            return;\n+        } else if (targetType.tag == TypeTags.BOOLEAN) {\n+            generateCheckCastJToBBoolean(mv, sourceType);\n+            return;\n+        } else if (targetType.tag == TypeTags.BYTE) {\n+            generateCheckCastJToBByte(mv, sourceType);\n+            return;\n+        } else if (targetType.tag == TypeTags.NIL) {\n+            // Do nothing\n+            return;\n+        } else {\n+            if (targetType.tag == TypeTags.UNION) {\n+                generateCheckCastJToBUnionType(mv, indexMap, sourceType, (BUnionType) targetType);\n+            } else if (targetType.tag == TypeTags.ANYDATA) {\n+                generateCheckCastJToBAnyData(mv, indexMap, sourceType);\n+            } else if (targetType.tag == TypeTags.HANDLE) {\n+                generateJCastToBHandle(mv, sourceType);\n+            } else if (targetType.tag == TypeTags.ANY) {\n+                generateJCastToBAny(mv, indexMap, sourceType, targetType);\n+            } else if (targetType.tag == TypeTags.JSON) {\n+                generateCheckCastJToBJSON(mv, indexMap, sourceType);\n+            } else if (targetType.tag == TypeTags.FINITE) {\n+                generateCheckCastJToBFiniteType(mv, indexMap, sourceType, targetType);\n+                // TODO fix below properly - rajith\n+                //} else if (sourceType is bir:BXMLType && targetType is bir:BMapType) {\n+                //    generateXMLToAttributesMap(mv, sourceType);\n+                //    return;\n+                //} else if (targetType is bir:BFiniteType) {\n+                //    generateCheckCastToFiniteType(mv, sourceType, targetType);\n+                //    return;\n+                //} else if (sourceType is bir:BRecordType && (targetType is bir:BMapType && targetType.constraint\n+                // is bir:BTypeAny)) {\n+                //    // do nothing", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82df207efdc85acd9646a1aae1461f7d1f7bbc5f"}, "originalPosition": 376}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ1ODI2NA==", "bodyText": "Shall we fix these strange comments?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21435#discussion_r387458264", "createdAt": "2020-03-04T05:40:37Z", "author": {"login": "riyafa"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/codegen/JvmInstructionGen.java", "diffHunk": "@@ -0,0 +1,1698 @@\n+/*\n+ *  Copyright (c) 2018, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.wso2.ballerinalang.compiler.bir.codegen;\n+\n+import org.ballerinalang.compiler.BLangCompilerException;\n+import org.ballerinalang.model.elements.PackageID;\n+import org.objectweb.asm.Handle;\n+import org.objectweb.asm.Label;\n+import org.objectweb.asm.MethodVisitor;\n+import org.objectweb.asm.Opcodes;\n+import org.objectweb.asm.Type;\n+import org.wso2.ballerinalang.compiler.bir.codegen.interop.JInsKind;\n+import org.wso2.ballerinalang.compiler.bir.codegen.interop.JType;\n+import org.wso2.ballerinalang.compiler.bir.codegen.interop.JTypeTags;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRGlobalVariableDcl;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRPackage;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRVariableDcl;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLProcIns;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.UnaryOP;\n+import org.wso2.ballerinalang.compiler.bir.model.BIROperand;\n+import org.wso2.ballerinalang.compiler.bir.model.InstructionKind;\n+import org.wso2.ballerinalang.compiler.bir.model.VarKind;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BArrayType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BJSONType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BObjectType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BServiceType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BType;\n+import org.wso2.ballerinalang.compiler.util.TypeTags;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.objectweb.asm.Opcodes.ACONST_NULL;\n+import static org.objectweb.asm.Opcodes.ALOAD;\n+import static org.objectweb.asm.Opcodes.ASTORE;\n+import static org.objectweb.asm.Opcodes.BIPUSH;\n+import static org.objectweb.asm.Opcodes.CHECKCAST;\n+import static org.objectweb.asm.Opcodes.DADD;\n+import static org.objectweb.asm.Opcodes.DCMPL;\n+import static org.objectweb.asm.Opcodes.DDIV;\n+import static org.objectweb.asm.Opcodes.DLOAD;\n+import static org.objectweb.asm.Opcodes.DMUL;\n+import static org.objectweb.asm.Opcodes.DNEG;\n+import static org.objectweb.asm.Opcodes.DREM;\n+import static org.objectweb.asm.Opcodes.DSTORE;\n+import static org.objectweb.asm.Opcodes.DSUB;\n+import static org.objectweb.asm.Opcodes.DUP;\n+import static org.objectweb.asm.Opcodes.FLOAD;\n+import static org.objectweb.asm.Opcodes.FSTORE;\n+import static org.objectweb.asm.Opcodes.GETSTATIC;\n+import static org.objectweb.asm.Opcodes.GOTO;\n+import static org.objectweb.asm.Opcodes.I2B;\n+import static org.objectweb.asm.Opcodes.I2L;\n+import static org.objectweb.asm.Opcodes.IADD;\n+import static org.objectweb.asm.Opcodes.IAND;\n+import static org.objectweb.asm.Opcodes.IASTORE;\n+import static org.objectweb.asm.Opcodes.ICONST_0;\n+import static org.objectweb.asm.Opcodes.ICONST_1;\n+import static org.objectweb.asm.Opcodes.IFEQ;\n+import static org.objectweb.asm.Opcodes.IFGE;\n+import static org.objectweb.asm.Opcodes.IFGT;\n+import static org.objectweb.asm.Opcodes.IFLE;\n+import static org.objectweb.asm.Opcodes.IFLT;\n+import static org.objectweb.asm.Opcodes.IFNE;\n+import static org.objectweb.asm.Opcodes.IF_ICMPEQ;\n+import static org.objectweb.asm.Opcodes.IF_ICMPGE;\n+import static org.objectweb.asm.Opcodes.IF_ICMPGT;\n+import static org.objectweb.asm.Opcodes.IF_ICMPLE;\n+import static org.objectweb.asm.Opcodes.IF_ICMPLT;\n+import static org.objectweb.asm.Opcodes.IF_ICMPNE;\n+import static org.objectweb.asm.Opcodes.ILOAD;\n+import static org.objectweb.asm.Opcodes.INEG;\n+import static org.objectweb.asm.Opcodes.INVOKEINTERFACE;\n+import static org.objectweb.asm.Opcodes.INVOKESPECIAL;\n+import static org.objectweb.asm.Opcodes.INVOKESTATIC;\n+import static org.objectweb.asm.Opcodes.INVOKEVIRTUAL;\n+import static org.objectweb.asm.Opcodes.IOR;\n+import static org.objectweb.asm.Opcodes.ISHL;\n+import static org.objectweb.asm.Opcodes.ISHR;\n+import static org.objectweb.asm.Opcodes.ISTORE;\n+import static org.objectweb.asm.Opcodes.IUSHR;\n+import static org.objectweb.asm.Opcodes.IXOR;\n+import static org.objectweb.asm.Opcodes.L2I;\n+import static org.objectweb.asm.Opcodes.LADD;\n+import static org.objectweb.asm.Opcodes.LAND;\n+import static org.objectweb.asm.Opcodes.LCMP;\n+import static org.objectweb.asm.Opcodes.LLOAD;\n+import static org.objectweb.asm.Opcodes.LMUL;\n+import static org.objectweb.asm.Opcodes.LNEG;\n+import static org.objectweb.asm.Opcodes.LOR;\n+import static org.objectweb.asm.Opcodes.LSHL;\n+import static org.objectweb.asm.Opcodes.LSHR;\n+import static org.objectweb.asm.Opcodes.LSTORE;\n+import static org.objectweb.asm.Opcodes.LSUB;\n+import static org.objectweb.asm.Opcodes.LUSHR;\n+import static org.objectweb.asm.Opcodes.LXOR;\n+import static org.objectweb.asm.Opcodes.NEW;\n+import static org.objectweb.asm.Opcodes.NEWARRAY;\n+import static org.objectweb.asm.Opcodes.PUTSTATIC;\n+import static org.objectweb.asm.Opcodes.SWAP;\n+import static org.objectweb.asm.Opcodes.T_INT;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmCastGen.generateCast;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmCastGen.generateCheckCast;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmCastGen.generateCheckCastToByte;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmCastGen.generatePlatformCheckCast;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmCastGen.getTargetClass;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.ANNOTATION_MAP_NAME;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.ANNOTATION_UTILS;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.ARRAY_TYPE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.ARRAY_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.ARRAY_VALUE_IMPL;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BTYPE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BXML_QNAME;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.DECIMAL_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.ERROR_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.FUNCTION;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.FUNCTION_POINTER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.JSON_UTILS;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.LONG_STREAM;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.MAP_UTILS;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.MAP_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.MAP_VALUE_IMPL;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.MATH_UTILS;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.MODULE_INIT_CLASS_NAME;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.OBJECT;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.OBJECT_TYPE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.OBJECT_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STRAND;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STRING_UTILS;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STRING_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TABLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TUPLE_TYPE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TUPLE_VALUE_IMPL;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TYPEDESC_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TYPE_CHECKER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.XML_FACTORY;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.XML_QNAME;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.XML_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmMethodGen.BalToJVMIndexMap;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmPackageGen.currentClass;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmPackageGen.getPackageName;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmPackageGen.lambdaIndex;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmPackageGen.lambdas;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmPackageGen.lookupGlobalVarClassName;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmPackageGen.lookupTypeDef;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmPackageGen.symbolTable;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmTerminatorGen.TerminatorGenerator.toNameString;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmTypeGen.duplicateServiceTypeWithAnnots;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmTypeGen.getTypeDesc;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmTypeGen.loadExternalType;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmTypeGen.loadType;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmValueGen.getTypeValueClassName;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.interop.InteropMethodGen.JCast;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.interop.InteropMethodGen.JInstruction;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.BinaryOp;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.ConstantLoad;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.FPLoad;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.FieldAccess;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.IsLike;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.Move;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewArray;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewError;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewInstance;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewStringXMLQName;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewStructure;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewTable;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewTypeDesc;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLComment;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLElement;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLQName;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLText;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.TypeCast;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.TypeTest;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.XMLAccess;\n+\n+/**\n+ * BIR instructions to JVM byte code generation related methods.\n+ *\n+ * @since 1.2.0\n+ */\n+public class JvmInstructionGen {\n+\n+    public static final String I_STRING_VALUE = \"org/ballerinalang/jvm/values/StringValue\";\n+    public static final String B_STRING_VALUE = \"org/ballerinalang/jvm/values/api/BString\";\n+    public static final String BMP_STRING_VALUE = \"org/ballerinalang/jvm/values/BmpStringValue\";\n+    public static final String NON_BMP_STRING_VALUE = \"org/ballerinalang/jvm/values/NonBmpStringValue\";\n+    public static final boolean IS_BSTRING = (System.getProperty(\"ballerina.bstring\") != null &&\n+            !\"\".equals(System.getProperty(\"ballerina.bstring\")));\n+    public static final String BSTRING_VALUE = IS_BSTRING ? I_STRING_VALUE : STRING_VALUE;\n+\n+    static void addBoxInsn(MethodVisitor mv, @Nilable BType bType) {\n+\n+        if (bType == null) {\n+            return;\n+        } else {\n+            generateCast(mv, bType, symbolTable.anyType, false);\n+        }\n+    }\n+\n+    public static void addUnboxInsn(MethodVisitor mv, @Nilable BType bType, boolean useBString /* = false */) {\n+\n+        if (bType == null) {\n+            return;\n+        } else {\n+            generateCast(mv, symbolTable.anyType, bType, useBString);\n+        }\n+    }\n+\n+    static void addJUnboxInsn(MethodVisitor mv, @Nilable JType jType) {\n+\n+        if (jType == null) {\n+            return;\n+        } else if (jType.jTag == JTypeTags.JBYTE) {\n+            mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, \"anyToJByte\", String.format(\"(L%s;)B\", OBJECT), false);\n+        } else if (jType.jTag == JTypeTags.JCHAR) {\n+            mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, \"anyToJChar\", String.format(\"(L%s;)C\", OBJECT), false);\n+        } else if (jType.jTag == JTypeTags.JSHORT) {\n+            mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, \"anyToJShort\", String.format(\"(L%s;)S\", OBJECT), false);\n+        } else if (jType.jTag == JTypeTags.JINT) {\n+            mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, \"anyToJInt\", String.format(\"(L%s;)I\", OBJECT), false);\n+        } else if (jType.jTag == JTypeTags.JLONG) {\n+            mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, \"anyToJLong\", String.format(\"(L%s;)J\", OBJECT), false);\n+        } else if (jType.jTag == JTypeTags.JFLOAT) {\n+            mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, \"anyToJFloat\", String.format(\"(L%s;)F\", OBJECT), false);\n+        } else if (jType.jTag == JTypeTags.JDOUBLE) {\n+            mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, \"anyToJDouble\", String.format(\"(L%s;)D\", OBJECT), false);\n+        } else if (jType.jTag == JTypeTags.JBOOLEAN) {\n+            mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, \"anyToJBoolean\", String.format(\"(L%s;)Z\", OBJECT), false);\n+        } else if (jType.jTag == JTypeTags.JREF) {\n+            mv.visitTypeInsn(CHECKCAST, ((JType.JRefType) jType).typeValue);\n+            //} else {\n+            //    error err = error(io:sprintf(\"Unboxing is not supported for '%s'\", bType));\n+            //    panic err;\n+        }\n+    }\n+\n+    public static void generateVarLoad(MethodVisitor mv, BIRVariableDcl varDcl, String currentPackageName,\n+                                       int valueIndex) {\n+\n+        BType bType = varDcl.type;\n+\n+        if (varDcl.kind == VarKind.GLOBAL) {\n+            BIRGlobalVariableDcl globalVar = (BIRGlobalVariableDcl) varDcl;\n+            PackageID modId = globalVar.pkgId;\n+            String moduleName = getPackageName(modId.orgName, modId.name);\n+\n+            String varName = varDcl.name.value;\n+            String className = lookupGlobalVarClassName(moduleName, varName);\n+\n+            String typeSig = getTypeDesc(bType, false);\n+            mv.visitFieldInsn(GETSTATIC, className, varName, typeSig);\n+            return;\n+        } else if (varDcl.kind == VarKind.SELF) {\n+            mv.visitVarInsn(ALOAD, 0);\n+            return;\n+        } else if (varDcl.kind == VarKind.CONSTANT) {\n+            String varName = varDcl.name.value;\n+            PackageID moduleId = ((BIRGlobalVariableDcl) varDcl).pkgId;\n+            String pkgName = getPackageName(moduleId.orgName, moduleId.name);\n+            String className = lookupGlobalVarClassName(pkgName, varName);\n+            String typeSig = getTypeDesc(bType, false);\n+            mv.visitFieldInsn(GETSTATIC, className, varName, typeSig);\n+            return;\n+        }\n+\n+        if (bType.tag == TypeTags.INT) {\n+            mv.visitVarInsn(LLOAD, valueIndex);\n+        } else if (bType.tag == TypeTags.BYTE) {\n+            mv.visitVarInsn(ILOAD, valueIndex);\n+            mv.visitInsn(I2B);\n+            mv.visitMethodInsn(INVOKESTATIC, \"java/lang/Byte\", \"toUnsignedInt\", \"(B)I\", false);\n+        } else if (bType.tag == TypeTags.FLOAT) {\n+            mv.visitVarInsn(DLOAD, valueIndex);\n+        } else if (bType.tag == TypeTags.BOOLEAN) {\n+            mv.visitVarInsn(ILOAD, valueIndex);\n+        } else if (bType.tag == TypeTags.ARRAY ||\n+                bType.tag == TypeTags.STRING ||\n+                bType.tag == TypeTags.MAP ||\n+                bType.tag == TypeTags.TABLE ||\n+                bType.tag == TypeTags.STREAM ||\n+                bType.tag == TypeTags.ANY ||\n+                bType.tag == TypeTags.ANYDATA ||\n+                bType.tag == TypeTags.NIL ||\n+                bType.tag == TypeTags.UNION ||\n+                bType.tag == TypeTags.TUPLE ||\n+                bType.tag == TypeTags.RECORD ||\n+                bType.tag == TypeTags.ERROR ||\n+                bType.tag == TypeTags.JSON ||\n+                bType.tag == TypeTags.FUTURE ||\n+                bType.tag == TypeTags.OBJECT ||\n+                bType.tag == TypeTags.SERVICE ||\n+                bType.tag == TypeTags.DECIMAL ||\n+                bType.tag == TypeTags.XML ||\n+                bType.tag == TypeTags.INVOKABLE ||\n+                bType.tag == TypeTags.FINITE ||\n+                bType.tag == TypeTags.HANDLE ||\n+                bType.tag == TypeTags.TYPEDESC) {\n+            mv.visitVarInsn(ALOAD, valueIndex);\n+        } else if (bType.tag == JTypeTags.JTYPE) {\n+            generateJVarLoad(mv, (JType) bType, currentPackageName, valueIndex);\n+        } else {\n+            throw new BLangCompilerException(\"JVM generation is not supported for type \" + String.format(\"%s\", bType));\n+        }\n+    }\n+\n+    private static void generateJVarLoad(MethodVisitor mv, JType jType, String currentPackageName, int valueIndex) {\n+\n+        if (jType.jTag == JTypeTags.JBYTE) {\n+            mv.visitVarInsn(ILOAD, valueIndex);\n+        } else if (jType.jTag == JTypeTags.JCHAR) {\n+            mv.visitVarInsn(ILOAD, valueIndex);\n+        } else if (jType.jTag == JTypeTags.JSHORT) {\n+            mv.visitVarInsn(ILOAD, valueIndex);\n+        } else if (jType.jTag == JTypeTags.JINT) {\n+            mv.visitVarInsn(ILOAD, valueIndex);\n+        } else if (jType.jTag == JTypeTags.JLONG) {\n+            mv.visitVarInsn(LLOAD, valueIndex);\n+        } else if (jType.jTag == JTypeTags.JFLOAT) {\n+            mv.visitVarInsn(FLOAD, valueIndex);\n+        } else if (jType.jTag == JTypeTags.JDOUBLE) {\n+            mv.visitVarInsn(DLOAD, valueIndex);\n+        } else if (jType.jTag == JTypeTags.JBOOLEAN) {\n+            mv.visitVarInsn(ILOAD, valueIndex);\n+        } else if (jType.jTag == JTypeTags.JARRAY ||\n+                jType.jTag == JTypeTags.JREF) {\n+            mv.visitVarInsn(ALOAD, valueIndex);\n+        } else {\n+            throw new BLangCompilerException(\"JVM generation is not supported for type \" + String.format(\"%s\", jType));\n+        }\n+    }\n+\n+    public static void generateVarStore(MethodVisitor mv, BIRVariableDcl varDcl, String currentPackageName,\n+                                        int valueIndex) {\n+\n+        BType bType = varDcl.type;\n+\n+        if (varDcl.kind == VarKind.GLOBAL) {\n+            String varName = varDcl.name.value;\n+            String className = lookupGlobalVarClassName(currentPackageName, varName);\n+            String typeSig = getTypeDesc(bType, false);\n+            mv.visitFieldInsn(PUTSTATIC, className, varName, typeSig);\n+            return;\n+        } else if (varDcl.kind == VarKind.CONSTANT) {\n+            String varName = varDcl.name.value;\n+            PackageID moduleId = ((BIRGlobalVariableDcl) varDcl).pkgId;\n+            String pkgName = getPackageName(moduleId.orgName, moduleId.name);\n+            String className = lookupGlobalVarClassName(pkgName, varName);\n+            String typeSig = getTypeDesc(bType, false);\n+            mv.visitFieldInsn(PUTSTATIC, className, varName, typeSig);\n+            return;\n+        }\n+\n+        if (bType.tag == TypeTags.INT) {\n+            mv.visitVarInsn(LSTORE, valueIndex);\n+        } else if (bType.tag == TypeTags.BYTE) {\n+            mv.visitVarInsn(ISTORE, valueIndex);\n+        } else if (bType.tag == TypeTags.FLOAT) {\n+            mv.visitVarInsn(DSTORE, valueIndex);\n+        } else if (bType.tag == TypeTags.BOOLEAN) {\n+            mv.visitVarInsn(ISTORE, valueIndex);\n+        } else if (bType.tag == TypeTags.ARRAY ||\n+                bType.tag == TypeTags.STRING ||\n+                bType.tag == TypeTags.MAP ||\n+                bType.tag == TypeTags.TABLE ||\n+                bType.tag == TypeTags.STREAM ||\n+                bType.tag == TypeTags.ANY ||\n+                bType.tag == TypeTags.ANYDATA ||\n+                bType.tag == TypeTags.NIL ||\n+                bType.tag == TypeTags.UNION ||\n+                bType.tag == TypeTags.TUPLE ||\n+                bType.tag == TypeTags.DECIMAL ||\n+                bType.tag == TypeTags.RECORD ||\n+                bType.tag == TypeTags.ERROR ||\n+                bType.tag == TypeTags.JSON ||\n+                bType.tag == TypeTags.FUTURE ||\n+                bType.tag == TypeTags.OBJECT ||\n+                bType.tag == TypeTags.SERVICE ||\n+                bType.tag == TypeTags.XML ||\n+                bType.tag == TypeTags.INVOKABLE ||\n+                bType.tag == TypeTags.FINITE ||\n+                bType.tag == TypeTags.HANDLE ||\n+                bType.tag == TypeTags.TYPEDESC) {\n+            mv.visitVarInsn(ASTORE, valueIndex);\n+        } else if (bType.tag == JTypeTags.JTYPE) {\n+            generateJVarStore(mv, (JType) bType, currentPackageName, valueIndex);\n+        } else {\n+            throw new BLangCompilerException(\"JVM generation is not supported for type \" + String.format(\"%s\", bType));\n+        }\n+    }\n+\n+    private static void generateJVarStore(MethodVisitor mv, JType jType, String currentPackageName, int valueIndex) {\n+\n+        if (jType.jTag == JTypeTags.JBYTE) {\n+            mv.visitVarInsn(ISTORE, valueIndex);\n+        } else if (jType.jTag == JTypeTags.JCHAR) {\n+            mv.visitVarInsn(ISTORE, valueIndex);\n+        } else if (jType.jTag == JTypeTags.JSHORT) {\n+            mv.visitVarInsn(ISTORE, valueIndex);\n+        } else if (jType.jTag == JTypeTags.JINT) {\n+            mv.visitVarInsn(ISTORE, valueIndex);\n+        } else if (jType.jTag == JTypeTags.JLONG) {\n+            mv.visitVarInsn(LSTORE, valueIndex);\n+        } else if (jType.jTag == JTypeTags.JFLOAT) {\n+            mv.visitVarInsn(FSTORE, valueIndex);\n+        } else if (jType.jTag == JTypeTags.JDOUBLE) {\n+            mv.visitVarInsn(DSTORE, valueIndex);\n+        } else if (jType.jTag == JTypeTags.JBOOLEAN) {\n+            mv.visitVarInsn(ISTORE, valueIndex);\n+        } else if (jType.jTag == JTypeTags.JARRAY ||\n+                jType.jTag == JTypeTags.JREF) {\n+            mv.visitVarInsn(ASTORE, valueIndex);\n+        } else {\n+            throw new BLangCompilerException(\"JVM generation is not supported for type \" + String.format(\"%s\", jType));\n+        }\n+    }\n+\n+    /**\n+     * Instruction generator helper class to hold its enclosing pkg and index map.\n+     *\n+     * @since 1.2.0\n+     */\n+    public static class InstructionGenerator {\n+\n+        MethodVisitor mv;\n+        BalToJVMIndexMap indexMap;\n+        String currentPackageName;\n+        BIRPackage currentPackage;\n+\n+        public InstructionGenerator(MethodVisitor mv, BalToJVMIndexMap indexMap, BIRPackage currentPackage) {\n+\n+            this.mv = mv;\n+            this.indexMap = indexMap;\n+            this.currentPackage = currentPackage;\n+            this.currentPackageName = getPackageName(currentPackage.org.value, currentPackage.name.value);\n+        }\n+\n+        void generatePlatformIns(JInstruction ins) {\n+\n+            if (ins.jKind == JInsKind.JCAST) {\n+                JCast castIns = (JCast) ins;\n+                BType targetType = castIns.targetType;\n+                this.loadVar(castIns.rhsOp.variableDcl);\n+                generatePlatformCheckCast(this.mv, this.indexMap, castIns.rhsOp.variableDcl.type, targetType);\n+                this.storeToVar(castIns.lhsOp.variableDcl);\n+            }\n+        }\n+\n+        void generateMoveIns(Move moveIns) {\n+\n+            this.loadVar(moveIns.rhsOp.variableDcl);\n+            this.storeToVar(moveIns.lhsOp.variableDcl);\n+        }\n+\n+        void generateBinaryOpIns(BinaryOp binaryIns) {\n+\n+            InstructionKind insKind = binaryIns.kind;\n+            switch (insKind) {\n+                case ADD:\n+                    this.generateAddIns(binaryIns);\n+                    break;\n+                case SUB:\n+                    this.generateSubIns(binaryIns);\n+                    break;\n+                case MUL:\n+                    this.generateMulIns(binaryIns);\n+                    break;\n+                case DIV:\n+                    this.generateDivIns(binaryIns);\n+                    break;\n+                case MOD:\n+                    this.generateRemIns(binaryIns);\n+                    break;\n+                case EQUAL:\n+                    this.generateEqualIns(binaryIns);\n+                    break;\n+                case NOT_EQUAL:\n+                    this.generateNotEqualIns(binaryIns);\n+                    break;\n+                case GREATER_THAN:\n+                    this.generateGreaterThanIns(binaryIns);\n+                    break;\n+                case GREATER_EQUAL:\n+                    this.generateGreaterEqualIns(binaryIns);\n+                    break;\n+                case LESS_THAN:\n+                    this.generateLessThanIns(binaryIns);\n+                    break;\n+                case LESS_EQUAL:\n+                    this.generateLessEqualIns(binaryIns);\n+                    break;\n+                case REF_EQUAL:\n+                    this.generateRefEqualIns(binaryIns);\n+                    break;\n+                case REF_NOT_EQUAL:\n+                    this.generateRefNotEqualIns(binaryIns);\n+                    break;\n+                case CLOSED_RANGE:\n+                    this.generateClosedRangeIns(binaryIns);\n+                    break;\n+                case HALF_OPEN_RANGE:\n+                    this.generateClosedRangeIns(binaryIns);\n+                    break;\n+                case ANNOT_ACCESS:\n+                    this.generateAnnotAccessIns(binaryIns);\n+                    break;\n+                case BITWISE_AND:\n+                    this.generateBitwiseAndIns(binaryIns);\n+                    break;\n+                case BITWISE_OR:\n+                    this.generateBitwiseOrIns(binaryIns);\n+                    break;\n+                case BITWISE_XOR:\n+                    this.generateBitwiseXorIns(binaryIns);\n+                    break;\n+                case BITWISE_LEFT_SHIFT:\n+                    this.generateBitwiseLeftShiftIns(binaryIns);\n+                    break;\n+                case BITWISE_RIGHT_SHIFT:\n+                    this.generateBitwiseRightShiftIns(binaryIns);\n+                    break;\n+                case BITWISE_UNSIGNED_RIGHT_SHIFT:\n+                    this.generateBitwiseUnsignedRightShiftIns(binaryIns);\n+                    break;\n+                default:\n+                    throw new BLangCompilerException(\"JVM generation is not supported for instruction kind : \" +\n+                            String.format(\"%s\", insKind));\n+            }\n+        }\n+\n+        void generateBinaryRhsAndLhsLoad(BinaryOp binaryIns) {\n+\n+            this.loadVar(binaryIns.rhsOp1.variableDcl);\n+            this.loadVar(binaryIns.rhsOp2.variableDcl);\n+        }\n+\n+        private void generateLessThanIns(BinaryOp binaryIns) {\n+\n+            this.generateBinaryCompareIns(binaryIns, IFLT);\n+        }\n+\n+        private void generateGreaterThanIns(BinaryOp binaryIns) {\n+\n+            this.generateBinaryCompareIns(binaryIns, IFGT);\n+        }\n+\n+        private void generateLessEqualIns(BinaryOp binaryIns) {\n+\n+            this.generateBinaryCompareIns(binaryIns, IFLE);\n+\n+        }\n+\n+        private void generateGreaterEqualIns(BinaryOp binaryIns) {\n+\n+            this.generateBinaryCompareIns(binaryIns, IFGE);\n+        }\n+\n+        private void generateBinaryCompareIns(BinaryOp binaryIns, int opcode) {\n+\n+            if (opcode != IFLT && opcode != IFGT && opcode != IFLE && opcode != IFGE) {\n+                throw new BLangCompilerException(String.format(\"Unsupported opcode '%s' for binary operator.\", opcode));\n+            }\n+\n+            this.generateBinaryRhsAndLhsLoad(binaryIns);\n+            Label label1 = new Label();\n+            Label label2 = new Label();\n+\n+            BType lhsOpType = binaryIns.rhsOp1.variableDcl.type;\n+            BType rhsOpType = binaryIns.rhsOp2.variableDcl.type;\n+\n+            if (lhsOpType.tag == TypeTags.INT && rhsOpType.tag == TypeTags.INT) {\n+                this.mv.visitInsn(LCMP);\n+                this.mv.visitJumpInsn(opcode, label1);\n+            } else if (lhsOpType.tag == TypeTags.BYTE && rhsOpType.tag == TypeTags.BYTE) {\n+                if (opcode == IFLT) {\n+                    this.mv.visitJumpInsn(IF_ICMPLT, label1);\n+                } else if (opcode != IFGT) {\n+                    this.mv.visitJumpInsn(IF_ICMPGT, label1);\n+                } else if (opcode != IFLE) {\n+                    this.mv.visitJumpInsn(IF_ICMPLE, label1);\n+                } else if (opcode == IFGE) {\n+                    this.mv.visitJumpInsn(IF_ICMPGE, label1);\n+                }\n+            } else if (lhsOpType.tag == TypeTags.FLOAT && rhsOpType.tag == TypeTags.FLOAT) {\n+                this.mv.visitInsn(DCMPL);\n+                this.mv.visitJumpInsn(opcode, label1);\n+            } else if (lhsOpType.tag == TypeTags.DECIMAL && rhsOpType.tag == TypeTags.DECIMAL) {\n+                String compareFuncName = this.getDecimalCompareFuncName(opcode);\n+                this.mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, compareFuncName,\n+                        String.format(\"(L%s;L%s;)Z\", DECIMAL_VALUE, DECIMAL_VALUE), false);\n+                this.storeToVar(binaryIns.lhsOp.variableDcl);\n+                return;\n+            }\n+\n+            this.mv.visitInsn(ICONST_0);\n+            this.mv.visitJumpInsn(GOTO, label2);\n+\n+            this.mv.visitLabel(label1);\n+            this.mv.visitInsn(ICONST_1);\n+\n+            this.mv.visitLabel(label2);\n+            this.storeToVar(binaryIns.lhsOp.variableDcl);\n+        }\n+\n+        private String getDecimalCompareFuncName(int opcode) {\n+\n+            if (opcode == IFGT) {\n+                return \"checkDecimalGreaterThan\";\n+            } else if (opcode == IFGE) {\n+                return \"checkDecimalGreaterThanOrEqual\";\n+            } else if (opcode == IFLT) {\n+                return \"checkDecimalLessThan\";\n+            } else if (opcode == IFLE) {\n+                return \"checkDecimalLessThanOrEqual\";\n+            } else {\n+                throw new BLangCompilerException(String.format(\"Opcode: '%s' is not a comparison opcode.\", opcode));\n+            }\n+        }\n+\n+        void generateEqualIns(BinaryOp binaryIns) {\n+\n+            this.generateBinaryRhsAndLhsLoad(binaryIns);\n+\n+            Label label1 = new Label();\n+            Label label2 = new Label();\n+\n+            BType lhsOpType = binaryIns.rhsOp1.variableDcl.type;\n+            BType rhsOpType = binaryIns.rhsOp2.variableDcl.type;\n+\n+            if (lhsOpType.tag == TypeTags.INT && rhsOpType.tag == TypeTags.INT) {\n+                this.mv.visitInsn(LCMP);\n+                this.mv.visitJumpInsn(IFNE, label1);\n+            } else if (lhsOpType.tag == TypeTags.BYTE && rhsOpType.tag == TypeTags.BYTE) {\n+                this.mv.visitJumpInsn(IF_ICMPNE, label1);\n+            } else if (lhsOpType.tag == TypeTags.FLOAT && rhsOpType.tag == TypeTags.FLOAT) {\n+                this.mv.visitInsn(DCMPL);\n+                this.mv.visitJumpInsn(IFNE, label1);\n+            } else if (lhsOpType.tag == TypeTags.BOOLEAN && rhsOpType.tag == TypeTags.BOOLEAN) {\n+                this.mv.visitJumpInsn(IF_ICMPNE, label1);\n+            } else if (lhsOpType.tag == TypeTags.DECIMAL && rhsOpType.tag == TypeTags.DECIMAL) {\n+                this.mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, \"checkDecimalEqual\",\n+                        String.format(\"(L%s;L%s;)Z\", DECIMAL_VALUE, DECIMAL_VALUE), false);\n+                this.storeToVar(binaryIns.lhsOp.variableDcl);\n+                return;\n+            } else {\n+                this.mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, \"isEqual\",\n+                        String.format(\"(L%s;L%s;)Z\", OBJECT, OBJECT), false);\n+                this.storeToVar(binaryIns.lhsOp.variableDcl);\n+                return;\n+            }\n+\n+            this.mv.visitInsn(ICONST_1);\n+            this.mv.visitJumpInsn(GOTO, label2);\n+\n+            this.mv.visitLabel(label1);\n+            this.mv.visitInsn(ICONST_0);\n+\n+            this.mv.visitLabel(label2);\n+            this.storeToVar(binaryIns.lhsOp.variableDcl);\n+        }\n+\n+        void generateNotEqualIns(BinaryOp binaryIns) {\n+\n+            this.generateBinaryRhsAndLhsLoad(binaryIns);\n+\n+            Label label1 = new Label();\n+            Label label2 = new Label();\n+\n+            // It is assumed that both operands are of same type\n+            BType lhsOpType = binaryIns.rhsOp1.variableDcl.type;\n+            BType rhsOpType = binaryIns.rhsOp2.variableDcl.type;\n+            if (lhsOpType.tag == TypeTags.INT && rhsOpType.tag == TypeTags.INT) {\n+                this.mv.visitInsn(LCMP);\n+                this.mv.visitJumpInsn(IFEQ, label1);\n+            } else if (lhsOpType.tag == TypeTags.BYTE && rhsOpType.tag == TypeTags.BYTE) {\n+                this.mv.visitJumpInsn(IF_ICMPEQ, label1);\n+            } else if (lhsOpType.tag == TypeTags.FLOAT && rhsOpType.tag == TypeTags.FLOAT) {\n+                this.mv.visitInsn(DCMPL);\n+                this.mv.visitJumpInsn(IFEQ, label1);\n+            } else if (lhsOpType.tag == TypeTags.BOOLEAN && rhsOpType.tag == TypeTags.BOOLEAN) {\n+                this.mv.visitJumpInsn(IF_ICMPEQ, label1);\n+            } else if (lhsOpType.tag == TypeTags.DECIMAL && rhsOpType.tag == TypeTags.DECIMAL) {\n+                this.mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, \"checkDecimalEqual\",\n+                        String.format(\"(L%s;L%s;)Z\", DECIMAL_VALUE, DECIMAL_VALUE), false);\n+                this.mv.visitJumpInsn(IFNE, label1);\n+            } else {\n+                this.mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, \"isEqual\",\n+                        String.format(\"(L%s;L%s;)Z\", OBJECT, OBJECT), false);\n+                this.mv.visitJumpInsn(IFNE, label1);\n+            }\n+\n+            this.mv.visitInsn(ICONST_1);\n+            this.mv.visitJumpInsn(GOTO, label2);\n+\n+            this.mv.visitLabel(label1);\n+            this.mv.visitInsn(ICONST_0);\n+\n+            this.mv.visitLabel(label2);\n+            this.storeToVar(binaryIns.lhsOp.variableDcl);\n+        }\n+\n+        void generateRefEqualIns(BinaryOp binaryIns) {\n+\n+            this.generateBinaryRhsAndLhsLoad(binaryIns);\n+\n+            Label label1 = new Label();\n+            Label label2 = new Label();\n+\n+            BType lhsOpType = binaryIns.rhsOp1.variableDcl.type;\n+            BType rhsOpType = binaryIns.rhsOp2.variableDcl.type;\n+            if (lhsOpType.tag == TypeTags.INT && rhsOpType.tag == TypeTags.INT) {\n+                this.mv.visitInsn(LCMP);\n+                this.mv.visitJumpInsn(IFNE, label1);\n+            } else if (lhsOpType.tag == TypeTags.BYTE && rhsOpType.tag == TypeTags.BYTE) {\n+                this.mv.visitJumpInsn(IF_ICMPNE, label1);\n+            } else if (lhsOpType.tag == TypeTags.FLOAT && rhsOpType.tag == TypeTags.FLOAT) {\n+                this.mv.visitInsn(DCMPL);\n+                this.mv.visitJumpInsn(IFNE, label1);\n+            } else if (lhsOpType.tag == TypeTags.BOOLEAN && rhsOpType.tag == TypeTags.BOOLEAN) {\n+                this.mv.visitJumpInsn(IF_ICMPNE, label1);\n+            } else {\n+                this.mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, \"isReferenceEqual\",\n+                        String.format(\"(L%s;L%s;)Z\", OBJECT, OBJECT), false);\n+                this.storeToVar(binaryIns.lhsOp.variableDcl);\n+                return;\n+            }\n+\n+            this.mv.visitInsn(ICONST_1);\n+            this.mv.visitJumpInsn(GOTO, label2);\n+\n+            this.mv.visitLabel(label1);\n+            this.mv.visitInsn(ICONST_0);\n+\n+            this.mv.visitLabel(label2);\n+            this.storeToVar(binaryIns.lhsOp.variableDcl);\n+        }\n+\n+        void generateRefNotEqualIns(BinaryOp binaryIns) {\n+\n+            this.generateBinaryRhsAndLhsLoad(binaryIns);\n+\n+            Label label1 = new Label();\n+            Label label2 = new Label();\n+\n+            // It is assumed that both operands are of same type\n+            BType lhsOpType = binaryIns.rhsOp1.variableDcl.type;\n+            BType rhsOpType = binaryIns.rhsOp2.variableDcl.type;\n+            if (lhsOpType.tag == TypeTags.INT && rhsOpType.tag == TypeTags.INT) {\n+                this.mv.visitInsn(LCMP);\n+                this.mv.visitJumpInsn(IFEQ, label1);\n+            } else if (lhsOpType.tag == TypeTags.BYTE && rhsOpType.tag == TypeTags.BYTE) {\n+                this.mv.visitJumpInsn(IF_ICMPEQ, label1);\n+            } else if (lhsOpType.tag == TypeTags.FLOAT && rhsOpType.tag == TypeTags.FLOAT) {\n+                this.mv.visitInsn(DCMPL);\n+                this.mv.visitJumpInsn(IFEQ, label1);\n+            } else if (lhsOpType.tag == TypeTags.BOOLEAN && rhsOpType.tag == TypeTags.BOOLEAN) {\n+                this.mv.visitJumpInsn(IF_ICMPEQ, label1);\n+            } else {\n+                this.mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, \"isReferenceEqual\",\n+                        String.format(\"(L%s;L%s;)Z\", OBJECT, OBJECT), false);\n+                this.mv.visitJumpInsn(IFNE, label1);\n+            }\n+\n+            this.mv.visitInsn(ICONST_1);\n+            this.mv.visitJumpInsn(GOTO, label2);\n+\n+            this.mv.visitLabel(label1);\n+            this.mv.visitInsn(ICONST_0);\n+\n+            this.mv.visitLabel(label2);\n+            this.storeToVar(binaryIns.lhsOp.variableDcl);\n+        }\n+\n+        void generateClosedRangeIns(BinaryOp binaryIns) {\n+\n+            this.mv.visitTypeInsn(NEW, ARRAY_VALUE_IMPL);\n+            this.mv.visitInsn(DUP);\n+            this.generateBinaryRhsAndLhsLoad(binaryIns);\n+            this.mv.visitMethodInsn(INVOKESTATIC, LONG_STREAM, \"rangeClosed\", String.format(\"(JJ)L%s;\", LONG_STREAM),\n+                    true);\n+            this.mv.visitMethodInsn(INVOKEINTERFACE, LONG_STREAM, \"toArray\", \"()[J\", true);\n+            this.mv.visitMethodInsn(INVOKESPECIAL, ARRAY_VALUE_IMPL, \"<init>\", \"([J)V\", false);\n+            this.storeToVar(binaryIns.lhsOp.variableDcl);\n+        }\n+\n+        void generateAnnotAccessIns(BinaryOp binaryIns) {\n+\n+            this.loadVar(binaryIns.rhsOp1.variableDcl);\n+            this.loadVar(binaryIns.rhsOp2.variableDcl);\n+            this.mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, \"getAnnotValue\",\n+                    String.format(\"(L%s;L%s;)L%s;\", TYPEDESC_VALUE, STRING_VALUE, OBJECT), false);\n+\n+            BType targetType = binaryIns.lhsOp.variableDcl.type;\n+            addUnboxInsn(this.mv, targetType, false);\n+            this.storeToVar(binaryIns.lhsOp.variableDcl);\n+        }\n+\n+        void generateAddIns(BinaryOp binaryIns) {\n+\n+            BType bType = binaryIns.lhsOp.variableDcl.type;\n+            this.generateBinaryRhsAndLhsLoad(binaryIns);\n+            if (bType.tag == TypeTags.INT) {\n+                this.mv.visitInsn(LADD);\n+            } else if (bType.tag == TypeTags.BYTE) {\n+                this.mv.visitInsn(IADD);\n+            } else if (bType.tag == TypeTags.STRING) {\n+                if (IS_BSTRING) {\n+                    this.mv.visitMethodInsn(INVOKEINTERFACE, BSTRING_VALUE, \"concat\",\n+                            String.format(\"(L%s;)L%s;\", BSTRING_VALUE, BSTRING_VALUE), true);\n+                } else {\n+                    this.mv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/String\", \"concat\",\n+                            String.format(\"(L%s;)L%s;\", STRING_VALUE, STRING_VALUE), false);\n+                }\n+            } else if (bType.tag == TypeTags.DECIMAL) {\n+                this.mv.visitMethodInsn(INVOKEVIRTUAL, DECIMAL_VALUE, \"add\",\n+                        String.format(\"(L%s;)L%s;\", DECIMAL_VALUE, DECIMAL_VALUE), false);\n+            } else if (bType.tag == TypeTags.FLOAT) {\n+                this.mv.visitInsn(DADD);\n+            } else if (bType.tag == TypeTags.XML) {\n+                this.mv.visitMethodInsn(INVOKESTATIC, XML_FACTORY, \"concatenate\",\n+                        String.format(\"(L%s;L%s;)L%s;\", XML_VALUE, XML_VALUE, XML_VALUE), false);\n+            } else {\n+                throw new BLangCompilerException(\"JVM generation is not supported for type \" +\n+                        String.format(\"%s\", binaryIns.lhsOp.variableDcl.type));\n+            }\n+\n+            this.storeToVar(binaryIns.lhsOp.variableDcl);\n+        }\n+\n+        void generateSubIns(BinaryOp binaryIns) {\n+\n+            BType bType = binaryIns.lhsOp.variableDcl.type;\n+            this.generateBinaryRhsAndLhsLoad(binaryIns);\n+            if (bType.tag == TypeTags.INT) {\n+                this.mv.visitInsn(LSUB);\n+            } else if (bType.tag == TypeTags.FLOAT) {\n+                this.mv.visitInsn(DSUB);\n+            } else if (bType.tag == TypeTags.DECIMAL) {\n+                this.mv.visitMethodInsn(INVOKEVIRTUAL, DECIMAL_VALUE, \"subtract\",\n+                        String.format(\"(L%s;)L%s;\", DECIMAL_VALUE, DECIMAL_VALUE), false);\n+            } else {\n+                throw new BLangCompilerException(\"JVM generation is not supported for type \" +\n+                        String.format(\"%s\", binaryIns.lhsOp.variableDcl.type));\n+            }\n+            this.storeToVar(binaryIns.lhsOp.variableDcl);\n+        }\n+\n+        void generateDivIns(BinaryOp binaryIns) {\n+\n+            BType bType = binaryIns.lhsOp.variableDcl.type;\n+            this.generateBinaryRhsAndLhsLoad(binaryIns);\n+            if (bType.tag == TypeTags.INT) {\n+                this.mv.visitMethodInsn(INVOKESTATIC, MATH_UTILS, \"divide\", \"(JJ)J\", false);\n+            } else if (bType.tag == TypeTags.FLOAT) {\n+                this.mv.visitInsn(DDIV);\n+            } else if (bType.tag == TypeTags.DECIMAL) {\n+                this.mv.visitMethodInsn(INVOKEVIRTUAL, DECIMAL_VALUE, \"divide\",\n+                        String.format(\"(L%s;)L%s;\", DECIMAL_VALUE, DECIMAL_VALUE), false);\n+            } else {\n+                throw new BLangCompilerException(\"JVM generation is not supported for type \" +\n+                        String.format(\"%s\", binaryIns.lhsOp.variableDcl.type));\n+            }\n+            this.storeToVar(binaryIns.lhsOp.variableDcl);\n+        }\n+\n+        void generateMulIns(BinaryOp binaryIns) {\n+\n+            BType bType = binaryIns.lhsOp.variableDcl.type;\n+            this.generateBinaryRhsAndLhsLoad(binaryIns);\n+            if (bType.tag == TypeTags.INT) {\n+                this.mv.visitInsn(LMUL);\n+            } else if (bType.tag == TypeTags.FLOAT) {\n+                this.mv.visitInsn(DMUL);\n+            } else if (bType.tag == TypeTags.DECIMAL) {\n+                this.mv.visitMethodInsn(INVOKEVIRTUAL, DECIMAL_VALUE, \"multiply\",\n+                        String.format(\"(L%s;)L%s;\", DECIMAL_VALUE, DECIMAL_VALUE), false);\n+            } else {\n+                throw new BLangCompilerException(\"JVM generation is not supported for type \" +\n+                        String.format(\"%s\", binaryIns.lhsOp.variableDcl.type));\n+            }\n+            this.storeToVar(binaryIns.lhsOp.variableDcl);\n+        }\n+\n+        void generateRemIns(BinaryOp binaryIns) {\n+\n+            BType bType = binaryIns.lhsOp.variableDcl.type;\n+            this.generateBinaryRhsAndLhsLoad(binaryIns);\n+            if (bType.tag == TypeTags.INT) {\n+                this.mv.visitMethodInsn(INVOKESTATIC, MATH_UTILS, \"remainder\", \"(JJ)J\", false);\n+            } else if (bType.tag == TypeTags.FLOAT) {\n+                this.mv.visitInsn(DREM);\n+            } else if (bType.tag == TypeTags.DECIMAL) {\n+                this.mv.visitMethodInsn(INVOKEVIRTUAL, DECIMAL_VALUE, \"remainder\",\n+                        String.format(\"(L%s;)L%s;\", DECIMAL_VALUE, DECIMAL_VALUE), false);\n+            } else {\n+                throw new BLangCompilerException(\"JVM generation is not supported for type \" +\n+                        String.format(\"%s\", binaryIns.lhsOp.variableDcl.type));\n+            }\n+            this.storeToVar(binaryIns.lhsOp.variableDcl);\n+        }\n+\n+        void generateBitwiseAndIns(BinaryOp binaryIns) {\n+\n+            BType opType1 = binaryIns.rhsOp1.variableDcl.type;\n+            BType opType2 = binaryIns.rhsOp2.variableDcl.type;\n+\n+            if (opType1.tag == TypeTags.INT && opType2.tag == TypeTags.INT) {\n+                this.loadVar(binaryIns.rhsOp1.variableDcl);\n+                this.loadVar(binaryIns.rhsOp2.variableDcl);\n+                this.mv.visitInsn(LAND);\n+            } else {\n+                this.loadVar(binaryIns.rhsOp1.variableDcl);\n+                generateCheckCastToByte(this.mv, opType1);\n+\n+                this.loadVar(binaryIns.rhsOp2.variableDcl);\n+                generateCheckCastToByte(this.mv, opType2);\n+\n+                this.mv.visitInsn(IAND);\n+            }\n+            this.storeToVar(binaryIns.lhsOp.variableDcl);\n+        }\n+\n+        void generateBitwiseOrIns(BinaryOp binaryIns) {\n+\n+            this.loadVar(binaryIns.rhsOp1.variableDcl);\n+            this.loadVar(binaryIns.rhsOp2.variableDcl);\n+\n+            BType opType = binaryIns.rhsOp1.variableDcl.type;\n+            if (opType.tag == TypeTags.INT) {\n+                this.mv.visitInsn(LOR);\n+            } else {\n+                this.mv.visitInsn(IOR);\n+            }\n+            this.storeToVar(binaryIns.lhsOp.variableDcl);\n+        }\n+\n+        void generateBitwiseXorIns(BinaryOp binaryIns) {\n+\n+            this.loadVar(binaryIns.rhsOp1.variableDcl);\n+            this.loadVar(binaryIns.rhsOp2.variableDcl);\n+\n+            BType opType = binaryIns.rhsOp1.variableDcl.type;\n+            if (opType.tag == TypeTags.INT) {\n+                this.mv.visitInsn(LXOR);\n+            } else {\n+                this.mv.visitInsn(IXOR);\n+            }\n+            this.storeToVar(binaryIns.lhsOp.variableDcl);\n+        }\n+\n+        void generateBitwiseLeftShiftIns(BinaryOp binaryIns) {\n+\n+            this.loadVar(binaryIns.rhsOp1.variableDcl);\n+            this.loadVar(binaryIns.rhsOp2.variableDcl);\n+\n+            BType secondOpType = binaryIns.rhsOp2.variableDcl.type;\n+            if (secondOpType.tag == TypeTags.INT) {\n+                this.mv.visitInsn(L2I);\n+            }\n+\n+            BType firstOpType = binaryIns.rhsOp1.variableDcl.type;\n+            if (firstOpType.tag == TypeTags.INT) {\n+                this.mv.visitInsn(LSHL);\n+            } else {\n+                this.mv.visitInsn(ISHL);\n+                this.mv.visitInsn(I2L);\n+            }\n+\n+            this.storeToVar(binaryIns.lhsOp.variableDcl);\n+        }\n+\n+        void generateBitwiseRightShiftIns(BinaryOp binaryIns) {\n+\n+            this.loadVar(binaryIns.rhsOp1.variableDcl);\n+            this.loadVar(binaryIns.rhsOp2.variableDcl);\n+\n+            BType secondOpType = binaryIns.rhsOp2.variableDcl.type;\n+            if (secondOpType.tag == TypeTags.INT) {\n+                this.mv.visitInsn(L2I);\n+            }\n+\n+            BType firstOpType = binaryIns.rhsOp1.variableDcl.type;\n+            if (firstOpType.tag == TypeTags.INT) {\n+                this.mv.visitInsn(LSHR);\n+            } else {\n+                this.mv.visitInsn(ISHR);\n+            }\n+\n+            this.storeToVar(binaryIns.lhsOp.variableDcl);\n+        }\n+\n+        void generateBitwiseUnsignedRightShiftIns(BinaryOp binaryIns) {\n+\n+            this.loadVar(binaryIns.rhsOp1.variableDcl);\n+            this.loadVar(binaryIns.rhsOp2.variableDcl);\n+\n+            BType secondOpType = binaryIns.rhsOp2.variableDcl.type;\n+            if (secondOpType.tag == TypeTags.INT) {\n+                this.mv.visitInsn(L2I);\n+            }\n+\n+            BType firstOpType = binaryIns.rhsOp1.variableDcl.type;\n+            if (firstOpType.tag == TypeTags.INT) {\n+                this.mv.visitInsn(LUSHR);\n+            } else {\n+                this.mv.visitInsn(IUSHR);\n+            }\n+\n+            this.storeToVar(binaryIns.lhsOp.variableDcl);\n+        }\n+\n+        int getJVMIndexOfVarRef(BIRVariableDcl varDcl) {\n+\n+            return this.indexMap.getIndex(varDcl);\n+        }\n+\n+        void generateMapNewIns(NewStructure mapNewIns, int localVarOffset) {\n+\n+            BType typeOfMapNewIns = mapNewIns.type;\n+            String className = MAP_VALUE_IMPL;\n+\n+            if (typeOfMapNewIns.tag == TypeTags.RECORD) {\n+                if (mapNewIns.isExternalDef) {\n+                    className = getTypeValueClassName(mapNewIns.externalPackageId, toNameString(typeOfMapNewIns));\n+                } else {\n+                    className = getTypeValueClassName(this.currentPackage, toNameString(typeOfMapNewIns));\n+                }\n+\n+                this.mv.visitTypeInsn(NEW, className);\n+                this.mv.visitInsn(DUP);\n+                this.mv.visitInsn(DUP);\n+                if (mapNewIns.isExternalDef) {\n+                    loadExternalType(this.mv, mapNewIns.externalPackageId, mapNewIns.recordName);\n+                } else {\n+                    loadType(this.mv, mapNewIns.type);\n+                }\n+                this.mv.visitMethodInsn(INVOKESPECIAL, className, \"<init>\", String.format(\"(L%s;)V\", BTYPE), false);\n+\n+                // Invoke the init-function of this type.\n+                this.mv.visitVarInsn(ALOAD, localVarOffset);\n+                this.mv.visitInsn(SWAP);\n+                this.mv.visitMethodInsn(INVOKESTATIC, className, \"$init\",\n+                        String.format(\"(L%s;L%s;)V\", STRAND, MAP_VALUE), false);\n+            } else {\n+                this.mv.visitTypeInsn(NEW, className);\n+                this.mv.visitInsn(DUP);\n+                loadType(this.mv, mapNewIns.type);\n+                this.mv.visitMethodInsn(INVOKESPECIAL, className, \"<init>\", String.format(\"(L%s;)V\", BTYPE), false);\n+            }\n+            this.storeToVar(mapNewIns.lhsOp.variableDcl);\n+        }\n+\n+        void generateTableNewIns(NewTable tableNewIns) {\n+\n+            this.mv.visitTypeInsn(NEW, TABLE_VALUE);\n+            this.mv.visitInsn(DUP);\n+            loadType(this.mv, tableNewIns.type);\n+            this.loadVar(tableNewIns.keyColOp.variableDcl);\n+            this.loadVar(tableNewIns.dataOp.variableDcl);\n+            this.mv.visitMethodInsn(INVOKESPECIAL, TABLE_VALUE, \"<init>\", String.format(\"(L%s;L%s;L%s;)V\", BTYPE,\n+                    ARRAY_VALUE, ARRAY_VALUE), false);\n+            this.storeToVar(tableNewIns.lhsOp.variableDcl);\n+        }\n+\n+        void generateMapStoreIns(FieldAccess mapStoreIns) {\n+            // visit map_ref\n+            this.loadVar(mapStoreIns.lhsOp.variableDcl);\n+            BType varRefType = mapStoreIns.lhsOp.variableDcl.type;\n+\n+            // visit key_expr\n+            this.loadVar(mapStoreIns.keyOp.variableDcl);\n+\n+            // visit value_expr\n+            BType valueType = mapStoreIns.rhsOp.variableDcl.type;\n+            this.loadVar(mapStoreIns.rhsOp.variableDcl);\n+            addBoxInsn(this.mv, valueType);\n+\n+            if (varRefType.tag == TypeTags.JSON) {\n+                this.mv.visitMethodInsn(INVOKESTATIC, JSON_UTILS, \"setElement\",\n+                        String.format(\"(L%s;L%s;L%s;)V\", OBJECT, STRING_VALUE, OBJECT), false);\n+            } else {\n+                this.mv.visitMethodInsn(INVOKESTATIC, MAP_UTILS, \"handleMapStore\",\n+                        String.format(\"(L%s;L%s;L%s;)V\", MAP_VALUE, STRING_VALUE, OBJECT),\n+                        false);\n+            }\n+        }\n+\n+        void generateMapLoadIns(FieldAccess mapLoadIns) {\n+            // visit map_ref\n+            this.loadVar(mapLoadIns.rhsOp.variableDcl);\n+            BType varRefType = mapLoadIns.rhsOp.variableDcl.type;\n+            addUnboxInsn(this.mv, varRefType, false);\n+\n+            // visit key_expr\n+            this.loadVar(mapLoadIns.keyOp.variableDcl);\n+\n+            if (varRefType.tag == TypeTags.JSON) {\n+                if (mapLoadIns.optionalFieldAccess) {\n+                    this.mv.visitTypeInsn(CHECKCAST, STRING_VALUE);\n+                    this.mv.visitMethodInsn(INVOKESTATIC, JSON_UTILS, \"getElementOrNil\",\n+                            String.format(\"(L%s;L%s;)L%s;\", OBJECT, STRING_VALUE, OBJECT), false);\n+                } else {\n+                    this.mv.visitTypeInsn(CHECKCAST, STRING_VALUE);\n+                    this.mv.visitMethodInsn(INVOKESTATIC, JSON_UTILS, \"getElement\",\n+                            String.format(\"(L%s;L%s;)L%s;\", OBJECT, STRING_VALUE, OBJECT), false);\n+                }\n+            } else {\n+                if (mapLoadIns.fillingRead) {\n+                    this.mv.visitMethodInsn(INVOKEINTERFACE, MAP_VALUE, \"fillAndGet\",\n+                            String.format(\"(L%s;)L%s;\", OBJECT, OBJECT), true);\n+                } else {\n+                    this.mv.visitMethodInsn(INVOKEINTERFACE, MAP_VALUE, \"get\",\n+                            String.format(\"(L%s;)L%s;\", OBJECT, OBJECT), true);\n+                }\n+            }\n+\n+            // store in the target reg\n+            BType targetType = mapLoadIns.lhsOp.variableDcl.type;\n+            addUnboxInsn(this.mv, targetType, false);\n+            this.storeToVar(mapLoadIns.lhsOp.variableDcl);\n+        }\n+\n+        void generateObjectLoadIns(FieldAccess objectLoadIns) {\n+            // visit object_ref\n+            this.loadVar(objectLoadIns.rhsOp.variableDcl);\n+            BType varRefType = objectLoadIns.rhsOp.variableDcl.type;\n+\n+            // visit key_expr\n+            this.loadVar(objectLoadIns.keyOp.variableDcl);\n+\n+            // invoke get() method, and unbox if needed\n+            this.mv.visitMethodInsn(INVOKEINTERFACE, OBJECT_VALUE, \"get\",\n+                    String.format(\"(L%s;)L%s;\", STRING_VALUE, OBJECT), true);\n+            BType targetType = objectLoadIns.lhsOp.variableDcl.type;\n+            addUnboxInsn(this.mv, targetType, false);\n+\n+            // store in the target reg\n+            this.storeToVar(objectLoadIns.lhsOp.variableDcl);\n+        }\n+\n+        void generateObjectStoreIns(FieldAccess objectStoreIns, boolean useBString) {\n+            // visit object_ref\n+            this.loadVar(objectStoreIns.lhsOp.variableDcl);\n+            BType varRefType = objectStoreIns.lhsOp.variableDcl.type;\n+\n+            // visit key_expr\n+            this.loadVar(objectStoreIns.keyOp.variableDcl);\n+\n+            // visit value_expr\n+            BType valueType = objectStoreIns.rhsOp.variableDcl.type;\n+            this.loadVar(objectStoreIns.rhsOp.variableDcl);\n+            addBoxInsn(this.mv, valueType);\n+\n+            // invoke set() method\n+            this.mv.visitMethodInsn(INVOKEINTERFACE, OBJECT_VALUE, \"set\",\n+                    String.format(\"(L%s;L%s;)V\", useBString ? I_STRING_VALUE : STRING_VALUE, OBJECT), true);\n+        }\n+\n+        void generateStringLoadIns(FieldAccess stringLoadIns) {\n+            // visit the string\n+            this.loadVar(stringLoadIns.rhsOp.variableDcl);\n+\n+            // visit the key expr\n+            this.loadVar(stringLoadIns.keyOp.variableDcl);\n+\n+            // invoke the `getStringAt()` method\n+            this.mv.visitMethodInsn(INVOKESTATIC, STRING_UTILS, \"getStringAt\",\n+                    String.format(\"(L%s;J)L%s;\", STRING_VALUE, STRING_VALUE), false);\n+\n+            // store in the target reg\n+            this.storeToVar(stringLoadIns.lhsOp.variableDcl);\n+        }\n+\n+        //    # Generate a new instance of an array value\n+//    #\n+//    # + inst - the new array instruction\n+        void generateArrayNewIns(NewArray inst) {\n+\n+            if (inst.type.tag == TypeTags.ARRAY) {\n+                this.mv.visitTypeInsn(NEW, ARRAY_VALUE_IMPL);\n+                this.mv.visitInsn(DUP);\n+                loadType(this.mv, inst.type);\n+                this.loadVar(inst.sizeOp.variableDcl);\n+                this.mv.visitMethodInsn(INVOKESPECIAL, ARRAY_VALUE_IMPL, \"<init>\",\n+                        String.format(\"(L%s;J)V\", ARRAY_TYPE), false);\n+                this.storeToVar(inst.lhsOp.variableDcl);\n+            } else {\n+                this.mv.visitTypeInsn(NEW, TUPLE_VALUE_IMPL);\n+                this.mv.visitInsn(DUP);\n+                loadType(this.mv, inst.type);\n+                this.loadVar(inst.sizeOp.variableDcl);\n+                this.mv.visitMethodInsn(INVOKESPECIAL, TUPLE_VALUE_IMPL, \"<init>\",\n+                        String.format(\"(L%s;J)V\", TUPLE_TYPE), false);\n+                this.storeToVar(inst.lhsOp.variableDcl);\n+            }\n+        }\n+\n+        //    # Generate adding a new value to an array\n+//    #\n+//    # + inst - array store instruction", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82df207efdc85acd9646a1aae1461f7d1f7bbc5f"}, "originalPosition": 1214}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ1ODk1Nw==", "bodyText": "We really need switch statements.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21435#discussion_r387458957", "createdAt": "2020-03-04T05:43:40Z", "author": {"login": "riyafa"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/codegen/JvmMethodGen.java", "diffHunk": "@@ -0,0 +1,2928 @@\n+/*\n+ *  Copyright (c) 2018, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.wso2.ballerinalang.compiler.bir.codegen;\n+\n+import org.ballerinalang.compiler.BLangCompilerException;\n+import org.ballerinalang.model.elements.PackageID;\n+import org.objectweb.asm.ClassWriter;\n+import org.objectweb.asm.FieldVisitor;\n+import org.objectweb.asm.Label;\n+import org.objectweb.asm.MethodVisitor;\n+import org.wso2.ballerinalang.compiler.bir.codegen.JvmErrorGen.ErrorHandlerGenerator;\n+import org.wso2.ballerinalang.compiler.bir.codegen.JvmInstructionGen.InstructionGenerator;\n+import org.wso2.ballerinalang.compiler.bir.codegen.JvmLabelGen.LabelGenerator;\n+import org.wso2.ballerinalang.compiler.bir.codegen.JvmTerminatorGen.TerminatorGenerator;\n+import org.wso2.ballerinalang.compiler.bir.codegen.interop.JType;\n+import org.wso2.ballerinalang.compiler.bir.codegen.interop.JTypeTags;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRInstruction;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRAnnotationArrayValue;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRAnnotationAttachment;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRAnnotationLiteralValue;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRAnnotationRecordValue;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRAnnotationValue;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRBasicBlock;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRFunction;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRFunctionParameter;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRPackage;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRTypeDefinition;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRVariableDcl;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.BinaryOp;\n+import org.wso2.ballerinalang.compiler.bir.model.BIROperand;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRTerminator;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRTerminator.AsyncCall;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRTerminator.GOTO;\n+import org.wso2.ballerinalang.compiler.bir.model.InstructionKind;\n+import org.wso2.ballerinalang.compiler.bir.model.VarKind;\n+import org.wso2.ballerinalang.compiler.bir.model.VarScope;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BInvokableSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BPackageSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BField;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BFutureType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BInvokableType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BNilType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BObjectType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BServiceType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BUnionType;\n+import org.wso2.ballerinalang.compiler.util.Name;\n+import org.wso2.ballerinalang.compiler.util.TypeTags;\n+import org.wso2.ballerinalang.compiler.util.diagnotic.DiagnosticPos;\n+import org.wso2.ballerinalang.util.Flags;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.objectweb.asm.ClassWriter.COMPUTE_FRAMES;\n+import static org.objectweb.asm.Opcodes.AALOAD;\n+import static org.objectweb.asm.Opcodes.AASTORE;\n+import static org.objectweb.asm.Opcodes.ACC_PUBLIC;\n+import static org.objectweb.asm.Opcodes.ACC_STATIC;\n+import static org.objectweb.asm.Opcodes.ACC_SUPER;\n+import static org.objectweb.asm.Opcodes.ACONST_NULL;\n+import static org.objectweb.asm.Opcodes.ALOAD;\n+import static org.objectweb.asm.Opcodes.ANEWARRAY;\n+import static org.objectweb.asm.Opcodes.ARETURN;\n+import static org.objectweb.asm.Opcodes.ASTORE;\n+import static org.objectweb.asm.Opcodes.ATHROW;\n+import static org.objectweb.asm.Opcodes.BIPUSH;\n+import static org.objectweb.asm.Opcodes.CHECKCAST;\n+import static org.objectweb.asm.Opcodes.DCONST_0;\n+import static org.objectweb.asm.Opcodes.DLOAD;\n+import static org.objectweb.asm.Opcodes.DSTORE;\n+import static org.objectweb.asm.Opcodes.DUP;\n+import static org.objectweb.asm.Opcodes.DUP_X1;\n+import static org.objectweb.asm.Opcodes.FCONST_0;\n+import static org.objectweb.asm.Opcodes.FLOAD;\n+import static org.objectweb.asm.Opcodes.FSTORE;\n+import static org.objectweb.asm.Opcodes.GETFIELD;\n+import static org.objectweb.asm.Opcodes.GETSTATIC;\n+import static org.objectweb.asm.Opcodes.GOTO;\n+import static org.objectweb.asm.Opcodes.IADD;\n+import static org.objectweb.asm.Opcodes.ICONST_0;\n+import static org.objectweb.asm.Opcodes.ICONST_1;\n+import static org.objectweb.asm.Opcodes.IFEQ;\n+import static org.objectweb.asm.Opcodes.IFGT;\n+import static org.objectweb.asm.Opcodes.IFNE;\n+import static org.objectweb.asm.Opcodes.IFNULL;\n+import static org.objectweb.asm.Opcodes.ILOAD;\n+import static org.objectweb.asm.Opcodes.INVOKEINTERFACE;\n+import static org.objectweb.asm.Opcodes.INVOKESPECIAL;\n+import static org.objectweb.asm.Opcodes.INVOKESTATIC;\n+import static org.objectweb.asm.Opcodes.INVOKEVIRTUAL;\n+import static org.objectweb.asm.Opcodes.ISTORE;\n+import static org.objectweb.asm.Opcodes.ISUB;\n+import static org.objectweb.asm.Opcodes.L2I;\n+import static org.objectweb.asm.Opcodes.LCONST_0;\n+import static org.objectweb.asm.Opcodes.LLOAD;\n+import static org.objectweb.asm.Opcodes.LSTORE;\n+import static org.objectweb.asm.Opcodes.NEW;\n+import static org.objectweb.asm.Opcodes.POP;\n+import static org.objectweb.asm.Opcodes.PUTFIELD;\n+import static org.objectweb.asm.Opcodes.RETURN;\n+import static org.objectweb.asm.Opcodes.SIPUSH;\n+import static org.objectweb.asm.Opcodes.V1_8;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.ANNOTATION_MAP_NAME;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.ANNOTATION_UTILS;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.ARGUMENT_PARSER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.ARRAY_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BALLERINA;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BAL_ERRORS;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BAL_EXTENSION;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BOOLEAN_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BTYPE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BUILT_IN_PACKAGE_NAME;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.CHANNEL_DETAILS;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.COMPATIBILITY_CHECKER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.CURRENT_MODULE_INIT;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.DECIMAL_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.DEFAULTABLE_ARGS_ANOT_FIELD;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.DEFAULTABLE_ARGS_ANOT_NAME;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.DOUBLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.ERROR_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.FUNCTION;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.FUNCTION_POINTER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.FUTURE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.HANDLE_RETURNED_ERROR_METHOD;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.HANDLE_STOP_PANIC_METHOD;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.HANDLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.INT_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.JAVA_PACKAGE_SEPERATOR;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.JAVA_RUNTIME;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.JAVA_THREAD;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.LAUNCH_UTILS;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.LONG_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.MAP_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.MODULE_INIT;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.MODULE_INIT_CLASS_NAME;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.MODULE_START;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.MODULE_STOP;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.OBJECT;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.OBJECT_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.PANIC_FIELD;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.RUNTIME_UTILS;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.SCHEDULER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.SCHEDULER_START_METHOD;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.SCHEDULE_FUNCTION_METHOD;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STRAND;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STREAM_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STRING_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TABLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.THROWABLE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TYPEDESC_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.VALUE_CREATOR;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.WINDOWS_PATH_SEPERATOR;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.XML_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmInstructionGen.BSTRING_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmInstructionGen.IS_BSTRING;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmInstructionGen.I_STRING_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmInstructionGen.InstructionGenerator.visitInvokeDyn;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmInstructionGen.addBoxInsn;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmInstructionGen.addUnboxInsn;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmObservabilityGen.emitReportErrorInvocation;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmObservabilityGen.emitStartObservationInvocation;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmObservabilityGen.emitStopObservationInvocation;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmObservabilityGen.getFullQualifiedRemoteFunctionName;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmPackageGen.JavaClass;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmPackageGen.birFunctionMap;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmPackageGen.currentClass;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmPackageGen.getFunctionWrapper;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmPackageGen.getModuleLevelClassName;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmPackageGen.getPackageName;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmPackageGen.lookupGlobalVarClassName;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmPackageGen.packageToModuleId;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmPackageGen.symbolTable;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmTerminatorGen.TerminatorGenerator.toNameString;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmTerminatorGen.cleanupObjectTypeName;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmTerminatorGen.isExternStaticFunctionCall;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmTerminatorGen.loadChannelDetails;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmTypeGen.loadExternalOrLocalType;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmTypeGen.loadType;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmTypeGen.typeOwnerClass;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.interop.ExternalMethodGen.genJMethodForBExternalFunc;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.interop.ExternalMethodGen.isBallerinaBuiltinModule;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.interop.InteropMethodGen.JInstruction;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.interop.InteropMethodGen.getJTypeSignature;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.interop.InteropMethodGen.getSignatureForJType;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.ConstantLoad;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.FPLoad;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.FieldAccess;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.IsLike;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.Move;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewArray;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewError;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewInstance;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewStringXMLQName;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewStructure;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewTable;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewTypeDesc;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLComment;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLElement;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLProcIns;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLQName;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLText;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.TypeCast;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.TypeTest;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.UnaryOP;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.XMLAccess;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRTerminator.Branch;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRTerminator.Call;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRTerminator.Return;\n+\n+/**\n+ * BIR function to JVM byte code generation class.\n+ *\n+ * @since 1.2.0\n+ */\n+public class JvmMethodGen {\n+\n+    private static List<String> generatedInitFuncs = new ArrayList<>();\n+    public static int nextId = -1;\n+    public static int nextVarId = -1;\n+\n+    private static final FunctionParamComparator FUNCTION_PARAM_COMPARATOR = new FunctionParamComparator();\n+    static BUnionType errorOrNilType;\n+\n+    static void generateMethod(BIRFunction birFunc,\n+                               ClassWriter cw,\n+                               BIRPackage birModule,\n+                               @Nilable BType attachedType /* = () */,\n+                               boolean isService /* = false */,\n+                               String serviceName /* = \"\" */) {\n+\n+        if (isExternFunc(birFunc)) {\n+            genJMethodForBExternalFunc(birFunc, cw, birModule, attachedType);\n+        } else {\n+            genJMethodForBFunc(birFunc, cw, birModule, isService, serviceName, attachedType);\n+        }\n+    }\n+\n+    public static void genJMethodForBFunc(BIRFunction func,\n+                                          ClassWriter cw,\n+                                          BIRPackage module,\n+                                          boolean isService,\n+                                          String serviceName,\n+                                          @Nilable BType attachedType /* = () */) {\n+\n+        String currentPackageName = getPackageName(module.org.value, module.name.value);\n+        BalToJVMIndexMap indexMap = new BalToJVMIndexMap();\n+        String funcName = cleanupFunctionName(func.name.value);\n+        boolean useBString = IS_BSTRING;\n+        int returnVarRefIndex = -1;\n+\n+        BIRVariableDcl strandVar = new BIRVariableDcl(symbolTable.stringType, new Name(\"strand\"),\n+                VarScope.FUNCTION, VarKind.ARG);\n+        int ignoreStrandVarIndex = indexMap.getIndex(strandVar);\n+\n+        // generate method desc\n+        String desc = getMethodDesc(func.type.paramTypes, func.type.retType, null, false, useBString);\n+        int access = ACC_PUBLIC;\n+        int localVarOffset;\n+        if (attachedType != null) {\n+            localVarOffset = 1;\n+\n+            // add the self as the first local var\n+            // TODO: find a better way\n+            BIRVariableDcl selfVar = new BIRVariableDcl(symbolTable.anyType, new Name(\"self\"),\n+                    VarScope.FUNCTION, VarKind.ARG);\n+            int ignoreSelfVarIndex = indexMap.getIndex(selfVar);\n+        } else {\n+            localVarOffset = 0;\n+            access += ACC_STATIC;\n+        }\n+\n+        MethodVisitor mv = cw.visitMethod(access, funcName, desc, null, null);\n+        InstructionGenerator instGen = new InstructionGenerator(mv, indexMap, module);\n+        ErrorHandlerGenerator errorGen = new ErrorHandlerGenerator(mv, indexMap, currentPackageName);\n+        LabelGenerator labelGen = new LabelGenerator();\n+\n+        mv.visitCode();\n+\n+        @Nilable Label tryStart = null;\n+        boolean isObserved = false;\n+        boolean isWorker = (func.flags & Flags.WORKER) == Flags.WORKER;\n+        boolean isRemote = (func.flags & Flags.REMOTE) == Flags.REMOTE;\n+        if ((isService || isRemote || isWorker) && !\"__init\".equals(funcName) && !\"$__init$\".equals(funcName)) {\n+            // create try catch block to start and stop observability.\n+            isObserved = true;\n+            tryStart = labelGen.getLabel(\"try-start\");\n+            mv.visitLabel(tryStart);\n+        }\n+\n+        Label methodStartLabel = new Label();\n+        mv.visitLabel(methodStartLabel);\n+\n+        // generate method body\n+        int k = 1;\n+\n+        // set channel details to strand.\n+        // these channel info is required to notify datachannels, when there is a panic\n+        // we cannot set this during strand creation, because function call do not have this info.\n+        if (func.workerChannels.length > 0) {\n+            mv.visitVarInsn(ALOAD, localVarOffset);\n+            loadChannelDetails(mv, Arrays.asList(func.workerChannels));\n+            mv.visitMethodInsn(INVOKEVIRTUAL, STRAND, \"updateChannelDetails\",\n+                    String.format(\"([L%s;)V\", CHANNEL_DETAILS), false);\n+        }\n+\n+        // panic if this strand is cancelled\n+        checkStrandCancelled(mv, localVarOffset);\n+\n+        func.localVars.sort(FUNCTION_PARAM_COMPARATOR);\n+\n+        @Nilable List<BIRVariableDcl> localVars = func.localVars;\n+        while (k < localVars.size()) {\n+            BIRVariableDcl localVar = getVariableDcl(localVars.get(k));\n+            int index = indexMap.getIndex(localVar);\n+            if (localVar.kind != VarKind.ARG) {\n+                BType bType = localVar.type;\n+                genDefaultValue(mv, bType, index);\n+            }\n+            k += 1;\n+        }\n+\n+        BIRVariableDcl varDcl = getVariableDcl(localVars.get(0));\n+        returnVarRefIndex = indexMap.getIndex(varDcl);\n+        BType returnType = func.type.retType;\n+        genDefaultValue(mv, returnType, returnVarRefIndex);\n+\n+        BIRVariableDcl stateVar = new BIRVariableDcl(symbolTable.stringType, //should  be javaInt\n+                new Name(\"state\"), null, VarKind.TEMP);\n+        int stateVarIndex = indexMap.getIndex(stateVar);\n+        mv.visitInsn(ICONST_0);\n+        mv.visitVarInsn(ISTORE, stateVarIndex);\n+\n+        mv.visitVarInsn(ALOAD, localVarOffset);\n+        mv.visitFieldInsn(GETFIELD, \"org/ballerinalang/jvm/scheduling/Strand\", \"resumeIndex\", \"I\");\n+        Label resumeLable = labelGen.getLabel(funcName + \"resume\");\n+        mv.visitJumpInsn(IFGT, resumeLable);\n+\n+        Label varinitLable = labelGen.getLabel(funcName + \"varinit\");\n+        mv.visitLabel(varinitLable);\n+\n+        // uncomment to test yield\n+        // mv.visitFieldInsn(GETSTATIC, className, \"i\", \"I\");\n+        // mv.visitInsn(ICONST_1);\n+        // mv.visitInsn(IADD);\n+        // mv.visitFieldInsn(PUTSTATIC, className, \"i\", \"I\");\n+\n+        // process basic blocks\n+        @Nilable List<BIRBasicBlock> basicBlocks = func.basicBlocks;\n+\n+        List<Label> lables = new ArrayList<>();\n+        List<Integer> states = new ArrayList<>();\n+\n+        int i = 0;\n+        int caseIndex = 0;\n+        while (i < basicBlocks.size()) {\n+            BIRBasicBlock bb = getBasicBlock(basicBlocks.get(i));\n+            if (i == 0) {\n+                lables.add(caseIndex, labelGen.getLabel(funcName + bb.id.value));\n+                states.add(caseIndex, caseIndex);\n+                caseIndex += 1;\n+            }\n+            lables.add(caseIndex, labelGen.getLabel(funcName + bb.id.value + \"beforeTerm\"));\n+            states.add(caseIndex, caseIndex);\n+            caseIndex += 1;\n+            i = i + 1;\n+        }\n+\n+        TerminatorGenerator termGen = new TerminatorGenerator(mv, indexMap, labelGen, errorGen, module);\n+\n+        // uncomment to test yield\n+        // mv.visitFieldInsn(GETSTATIC, className, \"i\", \"I\");\n+        // mv.visitIntInsn(BIPUSH, 100);\n+        // jvm:Label l0 = labelGen.getLabel(funcName + \"l0\");\n+        // mv.visitJumpInsn(IF_ICMPNE, l0);\n+        // mv.visitVarInsn(ALOAD, 0);\n+        // mv.visitInsn(ICONST_1);\n+        // mv.visitFieldInsn(PUTFIELD, \"org/ballerinalang/jvm/scheduling/Strand\", \"yield\", \"Z\");\n+        // termGen.genReturnTerm({kind:\"RETURN\"}, returnVarRefIndex, func);\n+        // mv.visitLabel(l0);\n+\n+        mv.visitVarInsn(ILOAD, stateVarIndex);\n+        Label yieldLable = labelGen.getLabel(funcName + \"yield\");\n+        mv.visitLookupSwitchInsn(yieldLable, toIntArray(states), lables.toArray(new Label[0]));\n+\n+        generateBasicBlocks(mv, basicBlocks, labelGen, errorGen, instGen, termGen, func, returnVarRefIndex,\n+                stateVarIndex, localVarOffset, false, module, currentPackageName, attachedType, isObserved, isService,\n+                serviceName, useBString);\n+\n+        String frameName = getFrameClassName(currentPackageName, funcName, attachedType);\n+        mv.visitLabel(resumeLable);\n+        mv.visitVarInsn(ALOAD, localVarOffset);\n+        mv.visitFieldInsn(GETFIELD, \"org/ballerinalang/jvm/scheduling/Strand\", \"frames\", \"[Ljava/lang/Object;\");\n+        mv.visitVarInsn(ALOAD, localVarOffset);\n+        mv.visitInsn(DUP);\n+        mv.visitFieldInsn(GETFIELD, \"org/ballerinalang/jvm/scheduling/Strand\", \"resumeIndex\", \"I\");\n+        mv.visitInsn(ICONST_1);\n+        mv.visitInsn(ISUB);\n+        mv.visitInsn(DUP_X1);\n+        mv.visitFieldInsn(PUTFIELD, \"org/ballerinalang/jvm/scheduling/Strand\", \"resumeIndex\", \"I\");\n+        mv.visitInsn(AALOAD);\n+        mv.visitTypeInsn(CHECKCAST, frameName);\n+\n+        generateFrameClassFieldLoad(localVars, mv, indexMap, frameName, useBString);\n+        mv.visitFieldInsn(GETFIELD, frameName, \"state\", \"I\");\n+        mv.visitVarInsn(ISTORE, stateVarIndex);\n+        mv.visitJumpInsn(GOTO, varinitLable);\n+\n+        mv.visitLabel(yieldLable);\n+        mv.visitTypeInsn(NEW, frameName);\n+        mv.visitInsn(DUP);\n+        mv.visitMethodInsn(INVOKESPECIAL, frameName, \"<init>\", \"()V\", false);\n+\n+        generateFrameClassFieldUpdate(localVars, mv, indexMap, frameName, useBString);\n+\n+        mv.visitInsn(DUP);\n+        mv.visitVarInsn(ILOAD, stateVarIndex);\n+        mv.visitFieldInsn(PUTFIELD, frameName, \"state\", \"I\");\n+\n+        BIRVariableDcl frameVar = new BIRVariableDcl(symbolTable.stringType, new Name(\"frame\"), null, VarKind.TEMP);\n+        int frameVarIndex = indexMap.getIndex(frameVar);\n+        mv.visitVarInsn(ASTORE, frameVarIndex);\n+\n+        mv.visitVarInsn(ALOAD, localVarOffset);\n+        mv.visitFieldInsn(GETFIELD, \"org/ballerinalang/jvm/scheduling/Strand\", \"frames\", \"[Ljava/lang/Object;\");\n+        mv.visitVarInsn(ALOAD, localVarOffset);\n+        mv.visitInsn(DUP);\n+        mv.visitFieldInsn(GETFIELD, \"org/ballerinalang/jvm/scheduling/Strand\", \"resumeIndex\", \"I\");\n+        mv.visitInsn(DUP_X1);\n+        mv.visitInsn(ICONST_1);\n+        mv.visitInsn(IADD);\n+        mv.visitFieldInsn(PUTFIELD, \"org/ballerinalang/jvm/scheduling/Strand\", \"resumeIndex\", \"I\");\n+        mv.visitVarInsn(ALOAD, frameVarIndex);\n+        mv.visitInsn(AASTORE);\n+\n+        Label methodEndLabel = new Label();\n+        // generate the try catch finally to stop observing if an error occurs.\n+        if (isObserved) {\n+            Label tryEnd = labelGen.getLabel(\"try-end\");\n+            Label tryCatch = labelGen.getLabel(\"try-handler\");\n+            // visitTryCatchBlock visited at the end since order of the error table matters.\n+            mv.visitTryCatchBlock((Label) tryStart, tryEnd, tryCatch, ERROR_VALUE);\n+            Label tryFinally = labelGen.getLabel(\"try-finally\");\n+            mv.visitTryCatchBlock((Label) tryStart, tryEnd, tryFinally, null);\n+            Label tryCatchFinally = labelGen.getLabel(\"try-catch-finally\");\n+            mv.visitTryCatchBlock(tryCatch, tryCatchFinally, tryFinally, null);\n+\n+            BIRVariableDcl catchVarDcl = new BIRVariableDcl(symbolTable.anyType, new Name(\"$_catch_$\"),\n+                    VarScope.FUNCTION, VarKind.ARG);\n+            int catchVarIndex = indexMap.getIndex(catchVarDcl);\n+            BIRVariableDcl throwableVarDcl = new BIRVariableDcl(symbolTable.anyType, new Name(\"$_throwable_$\"),\n+                    VarScope.FUNCTION, VarKind.ARG);\n+            int throwableVarIndex = indexMap.getIndex(throwableVarDcl);\n+\n+            // Try-To-Finally\n+            mv.visitLabel(tryEnd);\n+            // emitStopObservationInvocation(mv, localVarOffset);\n+            Label tryBlock1 = labelGen.getLabel(\"try-block-1\");\n+            mv.visitLabel(tryBlock1);\n+            mv.visitJumpInsn(GOTO, methodEndLabel);\n+\n+            // Catch Block\n+            mv.visitLabel(tryCatch);\n+            mv.visitVarInsn(ASTORE, catchVarIndex);\n+            Label tryBlock2 = labelGen.getLabel(\"try-block-2\");\n+            mv.visitLabel(tryBlock2);\n+            emitReportErrorInvocation(mv, localVarOffset, catchVarIndex);\n+            mv.visitLabel(tryCatchFinally);\n+            emitStopObservationInvocation(mv, localVarOffset);\n+            Label tryBlock3 = labelGen.getLabel(\"try-block-3\");\n+            mv.visitLabel(tryBlock3);\n+            // re-throw caught error value\n+            mv.visitVarInsn(ALOAD, catchVarIndex);\n+            mv.visitInsn(ATHROW);\n+\n+            // Finally Block\n+            mv.visitLabel(tryFinally);\n+            mv.visitVarInsn(ASTORE, throwableVarIndex);\n+            emitStopObservationInvocation(mv, localVarOffset);\n+            Label tryBlock4 = labelGen.getLabel(\"try-block-4\");\n+            mv.visitLabel(tryBlock4);\n+            mv.visitVarInsn(ALOAD, throwableVarIndex);\n+            mv.visitInsn(ATHROW);\n+        }\n+        mv.visitLabel(methodEndLabel);\n+        termGen.genReturnTerm(new Return(null), returnVarRefIndex, func, false, -1);\n+\n+        // Create Local Variable Table\n+        k = localVarOffset;\n+        // Add strand variable to LVT\n+        mv.visitLocalVariable(\"__strand\", String.format(\"L%s;\", STRAND), null, methodStartLabel, methodEndLabel,\n+                localVarOffset);\n+        while (k < localVars.size()) {\n+            BIRVariableDcl localVar = getVariableDcl(localVars.get(k));\n+            Label startLabel = methodStartLabel;\n+            Label endLabel = methodEndLabel;\n+            boolean tmpBoolParam = localVar.type.tag == TypeTags.BOOLEAN && localVar.name.value.startsWith(\"%syn\");\n+            if (!tmpBoolParam && (localVar.kind == VarKind.LOCAL || localVar.kind == VarKind.ARG)) {\n+                // local vars have visible range information\n+                if (localVar.kind == VarKind.LOCAL) {\n+//                    String startBBID = localVar.startBB.id.value;\n+//                    String endBBID = localVar.endBB.id.value;\n+                    int insOffset = localVar.insOffset;\n+                    if (localVar.startBB != null) {\n+                        startLabel = labelGen.getLabel(funcName + localVar.startBB.id.value + \"ins\" + insOffset);\n+                    }\n+                    if (localVar.endBB != null) {\n+                        endLabel = labelGen.getLabel(funcName + localVar.endBB.id.value + \"beforeTerm\");\n+                    }\n+                }\n+                String metaVarName = localVar.name.value;\n+                if (!\"\".equals(metaVarName) &&\n+                        // filter out compiler added vars\n+                        !((metaVarName.startsWith(\"$\") && metaVarName.endsWith(\"$\"))\n+                                || (metaVarName.startsWith(\"$$\") && metaVarName.endsWith(\"$$\"))\n+                                || metaVarName.startsWith(\"_$$_\"))) {\n+                    mv.visitLocalVariable(metaVarName, getJVMTypeSign(localVar.type), null,\n+                            startLabel, endLabel, indexMap.getIndex(localVar));\n+                }\n+            }\n+            k = k + 1;\n+        }\n+\n+        mv.visitMaxs(0, 0);\n+        mv.visitEnd();\n+    }\n+\n+    private static int[] toIntArray(List<Integer> states) {\n+\n+        int[] ints = new int[states.size()];\n+        for (int i = 0; i < states.size(); i++) {\n+            ints[i] = states.get(i);\n+        }\n+        return ints;\n+    }\n+\n+    private static void generateFrameClassFieldLoad(List<BIRVariableDcl> localVars, MethodVisitor mv,\n+                                                    BalToJVMIndexMap indexMap, String frameName, boolean useBString) {\n+\n+        int k = 0;\n+        while (k < localVars.size()) {\n+            BIRVariableDcl localVar = getVariableDcl(localVars.get(k));\n+            int index = indexMap.getIndex(localVar);\n+            BType bType = localVar.type;\n+            mv.visitInsn(DUP);\n+\n+            if (bType.tag == TypeTags.INT) {\n+                mv.visitFieldInsn(GETFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"), \"J\");\n+                mv.visitVarInsn(LSTORE, index);\n+            } else if (bType.tag == TypeTags.BYTE) {\n+                mv.visitFieldInsn(GETFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"), \"I\");\n+                mv.visitVarInsn(ISTORE, index);\n+            } else if (bType.tag == TypeTags.FLOAT) {\n+                mv.visitFieldInsn(GETFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"), \"D\");\n+                mv.visitVarInsn(DSTORE, index);\n+            } else if (bType.tag == TypeTags.STRING) {\n+                mv.visitFieldInsn(GETFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"),\n+                        String.format(\"L%s;\", useBString ? I_STRING_VALUE : STRING_VALUE));\n+                mv.visitVarInsn(ASTORE, index);\n+            } else if (bType.tag == TypeTags.DECIMAL) {\n+                mv.visitFieldInsn(GETFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"),\n+                        String.format(\"L%s;\", DECIMAL_VALUE));\n+                mv.visitVarInsn(ASTORE, index);\n+            } else if (bType.tag == TypeTags.BOOLEAN) {\n+                mv.visitFieldInsn(GETFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"), \"Z\");\n+                mv.visitVarInsn(ISTORE, index);\n+            } else if (bType.tag == TypeTags.MAP || bType.tag == TypeTags.RECORD) {\n+                mv.visitFieldInsn(GETFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"),\n+                        String.format(\"L%s;\", MAP_VALUE));\n+                mv.visitVarInsn(ASTORE, index);\n+            } else if (bType.tag == TypeTags.TABLE) {\n+                mv.visitFieldInsn(GETFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"),\n+                        String.format(\"L%s;\", TABLE_VALUE));\n+                mv.visitVarInsn(ASTORE, index);\n+            } else if (bType.tag == TypeTags.STREAM) {\n+                mv.visitFieldInsn(GETFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"),\n+                        String.format(\"L%s;\", STREAM_VALUE));\n+                mv.visitVarInsn(ASTORE, index);\n+            } else if (bType.tag == TypeTags.ARRAY ||\n+                    bType.tag == TypeTags.TUPLE) {\n+                mv.visitFieldInsn(GETFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"),\n+                        String.format(\"L%s;\", ARRAY_VALUE));\n+                mv.visitVarInsn(ASTORE, index);\n+            } else if (bType.tag == TypeTags.OBJECT || bType.tag == TypeTags.SERVICE) {\n+                mv.visitFieldInsn(GETFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"),\n+                        String.format(\"L%s;\", OBJECT_VALUE));\n+                mv.visitVarInsn(ASTORE, index);\n+            } else if (bType.tag == TypeTags.ERROR) {\n+                mv.visitFieldInsn(GETFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"),\n+                        String.format(\"L%s;\", ERROR_VALUE));\n+                mv.visitVarInsn(ASTORE, index);\n+            } else if (bType.tag == TypeTags.FUTURE) {\n+                mv.visitFieldInsn(GETFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"),\n+                        String.format(\"L%s;\", FUTURE_VALUE));\n+                mv.visitVarInsn(ASTORE, index);\n+            } else if (bType.tag == TypeTags.INVOKABLE) {\n+                mv.visitFieldInsn(GETFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"),\n+                        String.format(\"L%s;\", FUNCTION_POINTER));\n+                mv.visitVarInsn(ASTORE, index);\n+            } else if (bType.tag == TypeTags.TYPEDESC) {\n+                mv.visitFieldInsn(GETFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"),\n+                        String.format(\"L%s;\", TYPEDESC_VALUE));\n+                mv.visitVarInsn(ASTORE, index);\n+            } else if (bType.tag == TypeTags.NIL ||\n+                    bType.tag == TypeTags.ANY ||\n+                    bType.tag == TypeTags.ANYDATA ||\n+                    bType.tag == TypeTags.UNION ||\n+                    bType.tag == TypeTags.JSON ||\n+                    bType.tag == TypeTags.FINITE) {\n+                mv.visitFieldInsn(GETFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"),\n+                        String.format(\"L%s;\", OBJECT));\n+                mv.visitVarInsn(ASTORE, index);\n+            } else if (bType.tag == TypeTags.XML) {\n+                mv.visitFieldInsn(GETFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"),\n+                        String.format(\"L%s;\", XML_VALUE));\n+                mv.visitVarInsn(ASTORE, index);\n+            } else if (bType.tag == TypeTags.HANDLE) {\n+                mv.visitFieldInsn(GETFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"),\n+                        String.format(\"L%s;\", HANDLE_VALUE));\n+                mv.visitVarInsn(ASTORE, index);\n+            } else if (bType.tag == JTypeTags.JTYPE) {\n+                generateFrameClassJFieldLoad(localVar, mv, index, frameName);\n+            } else {\n+                throw new BLangCompilerException(\"JVM generation is not supported for type \" +\n+                        String.format(\"%s\", bType));\n+            }\n+            k = k + 1;\n+        }\n+\n+    }\n+\n+    private static void generateFrameClassJFieldLoad(BIRVariableDcl localVar, MethodVisitor mv,\n+                                                     int index, String frameName) {\n+\n+        JType jType = (JType) localVar.type;\n+\n+        if (jType.jTag == JTypeTags.JBYTE) {\n+            mv.visitFieldInsn(GETFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"), \"I\");\n+            mv.visitVarInsn(ISTORE, index);\n+        } else if (jType.jTag == JTypeTags.JCHAR) {\n+            mv.visitFieldInsn(GETFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"), \"I\");\n+            mv.visitVarInsn(ISTORE, index);\n+        } else if (jType.jTag == JTypeTags.JSHORT) {\n+            mv.visitFieldInsn(GETFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"), \"I\");\n+            mv.visitVarInsn(ISTORE, index);\n+        } else if (jType.jTag == JTypeTags.JINT) {\n+            mv.visitFieldInsn(GETFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"), \"I\");\n+            mv.visitVarInsn(ISTORE, index);\n+        } else if (jType.jTag == JTypeTags.JLONG) {\n+            mv.visitFieldInsn(GETFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"), \"J\");\n+            mv.visitVarInsn(LSTORE, index);\n+        } else if (jType.jTag == JTypeTags.JFLOAT) {\n+            mv.visitFieldInsn(GETFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"), \"F\");\n+            mv.visitVarInsn(FSTORE, index);\n+        } else if (jType.jTag == JTypeTags.JDOUBLE) {\n+            mv.visitFieldInsn(GETFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"), \"D\");\n+            mv.visitVarInsn(DSTORE, index);\n+        } else if (jType.jTag == JTypeTags.JBOOLEAN) {\n+            mv.visitFieldInsn(GETFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"), \"Z\");\n+            mv.visitVarInsn(ISTORE, index);\n+        } else if (jType.jTag == JTypeTags.JARRAY ||\n+                jType.jTag == JTypeTags.JREF) {\n+            mv.visitFieldInsn(GETFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"), getJTypeSignature(jType));\n+            mv.visitVarInsn(ASTORE, index);\n+        } else {\n+            throw new BLangCompilerException(\"JVM generation is not supported for type \" + String.format(\"%s\", jType));\n+        }\n+\n+    }\n+\n+    private static void generateFrameClassFieldUpdate(@Nilable List<BIRVariableDcl> localVars, MethodVisitor mv,\n+                                                      BalToJVMIndexMap indexMap, String frameName, boolean useBString) {\n+\n+        int k = 0;\n+        while (k < localVars.size()) {\n+            BIRVariableDcl localVar = getVariableDcl(localVars.get(k));\n+            int index = indexMap.getIndex(localVar);\n+            mv.visitInsn(DUP);\n+\n+            BType bType = localVar.type;\n+            if (bType.tag == TypeTags.INT) {\n+                mv.visitVarInsn(LLOAD, index);\n+                mv.visitFieldInsn(PUTFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"), \"J\");\n+            } else if (bType.tag == TypeTags.BYTE) {\n+                mv.visitVarInsn(ILOAD, index);\n+                mv.visitFieldInsn(PUTFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"), \"I\");\n+            } else if (bType.tag == TypeTags.FLOAT) {\n+                mv.visitVarInsn(DLOAD, index);\n+                mv.visitFieldInsn(PUTFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"), \"D\");\n+            } else if (bType.tag == TypeTags.STRING) {\n+                mv.visitVarInsn(ALOAD, index);\n+                mv.visitFieldInsn(PUTFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"),\n+                        String.format(\"L%s;\", useBString ? I_STRING_VALUE : STRING_VALUE));\n+            } else if (bType.tag == TypeTags.DECIMAL) {\n+                mv.visitVarInsn(ALOAD, index);\n+                mv.visitFieldInsn(PUTFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"),\n+                        String.format(\"L%s;\", DECIMAL_VALUE));\n+            } else if (bType.tag == TypeTags.BOOLEAN) {\n+                mv.visitVarInsn(ILOAD, index);\n+                mv.visitFieldInsn(PUTFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"), \"Z\");\n+            } else if (bType.tag == TypeTags.MAP ||\n+                    bType.tag == TypeTags.RECORD) {\n+                mv.visitVarInsn(ALOAD, index);\n+                mv.visitFieldInsn(PUTFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"),\n+                        String.format(\"L%s;\", MAP_VALUE));\n+            } else if (bType.tag == TypeTags.TABLE) {\n+                mv.visitVarInsn(ALOAD, index);\n+                mv.visitFieldInsn(PUTFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"),\n+                        String.format(\"L%s;\", TABLE_VALUE));\n+            } else if (bType.tag == TypeTags.STREAM) {\n+                mv.visitVarInsn(ALOAD, index);\n+                mv.visitFieldInsn(PUTFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"),\n+                        String.format(\"L%s;\", STREAM_VALUE));\n+            } else if (bType.tag == TypeTags.ARRAY ||\n+                    bType.tag == TypeTags.TUPLE) {\n+                mv.visitVarInsn(ALOAD, index);\n+                mv.visitFieldInsn(PUTFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"),\n+                        String.format(\"L%s;\", ARRAY_VALUE));\n+            } else if (bType.tag == TypeTags.ERROR) {\n+                mv.visitVarInsn(ALOAD, index);\n+                mv.visitFieldInsn(PUTFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"),\n+                        String.format(\"L%s;\", ERROR_VALUE));\n+            } else if (bType.tag == TypeTags.FUTURE) {\n+                mv.visitVarInsn(ALOAD, index);\n+                mv.visitFieldInsn(PUTFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"),\n+                        String.format(\"L%s;\", FUTURE_VALUE));\n+            } else if (bType.tag == TypeTags.TYPEDESC) {\n+                mv.visitVarInsn(ALOAD, index);\n+                mv.visitTypeInsn(CHECKCAST, TYPEDESC_VALUE);\n+                mv.visitFieldInsn(PUTFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"),\n+                        String.format(\"L%s;\", TYPEDESC_VALUE));\n+            } else if (bType.tag == TypeTags.OBJECT || bType.tag == TypeTags.SERVICE) {\n+                mv.visitVarInsn(ALOAD, index);\n+                mv.visitFieldInsn(PUTFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"),\n+                        String.format(\"L%s;\", OBJECT_VALUE));\n+            } else if (bType.tag == TypeTags.INVOKABLE) {\n+                mv.visitVarInsn(ALOAD, index);\n+                mv.visitFieldInsn(PUTFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"),\n+                        String.format(\"L%s;\", FUNCTION_POINTER));\n+            } else if (bType.tag == TypeTags.NIL ||\n+                    bType.tag == TypeTags.ANY ||\n+                    bType.tag == TypeTags.ANYDATA ||\n+                    bType.tag == TypeTags.UNION ||\n+                    bType.tag == TypeTags.JSON ||\n+                    bType.tag == TypeTags.FINITE) {\n+                mv.visitVarInsn(ALOAD, index);\n+                mv.visitFieldInsn(PUTFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"),\n+                        String.format(\"L%s;\", OBJECT));\n+            } else if (bType.tag == TypeTags.XML) {\n+                mv.visitVarInsn(ALOAD, index);\n+                mv.visitFieldInsn(PUTFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"),\n+                        String.format(\"L%s;\", XML_VALUE));\n+            } else if (bType.tag == TypeTags.HANDLE) {\n+                mv.visitVarInsn(ALOAD, index);\n+                mv.visitFieldInsn(PUTFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"),\n+                        String.format(\"L%s;\", HANDLE_VALUE));\n+            } else if (bType.tag == JTypeTags.JTYPE) {\n+                generateFrameClassJFieldUpdate(localVar, mv, index, frameName);\n+            } else {\n+                throw new BLangCompilerException(\"JVM generation is not supported for type \" +\n+                        String.format(\"%s\", bType));\n+            }\n+            k = k + 1;\n+        }\n+    }\n+\n+    private static void generateFrameClassJFieldUpdate(BIRVariableDcl localVar, MethodVisitor mv,\n+                                                       int index, String frameName) {\n+\n+        JType jType = (JType) localVar.type;\n+        if (jType.jTag == JTypeTags.JBYTE) {\n+            mv.visitVarInsn(ILOAD, index);\n+            mv.visitFieldInsn(PUTFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"), \"B\");\n+        } else if (jType.jTag == JTypeTags.JCHAR) {\n+            mv.visitVarInsn(ILOAD, index);\n+            mv.visitFieldInsn(PUTFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"), \"C\");\n+        } else if (jType.jTag == JTypeTags.JSHORT) {\n+            mv.visitVarInsn(ILOAD, index);\n+            mv.visitFieldInsn(PUTFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"), \"S\");\n+        } else if (jType.jTag == JTypeTags.JINT) {\n+            mv.visitVarInsn(ILOAD, index);\n+            mv.visitFieldInsn(PUTFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"), \"I\");\n+        } else if (jType.jTag == JTypeTags.JLONG) {\n+            mv.visitVarInsn(LLOAD, index);\n+            mv.visitFieldInsn(PUTFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"), \"J\");\n+        } else if (jType.jTag == JTypeTags.JFLOAT) {\n+            mv.visitVarInsn(FLOAD, index);\n+            mv.visitFieldInsn(PUTFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"), \"F\");\n+        } else if (jType.jTag == JTypeTags.JDOUBLE) {\n+            mv.visitVarInsn(DLOAD, index);\n+            mv.visitFieldInsn(PUTFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"), \"D\");\n+        } else if (jType.jTag == JTypeTags.JBOOLEAN) {\n+            mv.visitVarInsn(ILOAD, index);\n+            mv.visitFieldInsn(PUTFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"), \"Z\");\n+        } else if (jType.jTag == JTypeTags.JARRAY || jType.jTag == JTypeTags.JREF) {\n+            String classSig = getJTypeSignature(jType);\n+            String className = getSignatureForJType(jType);\n+            mv.visitVarInsn(ALOAD, index);\n+            mv.visitTypeInsn(CHECKCAST, className);\n+            mv.visitFieldInsn(PUTFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"), classSig);\n+        } else {\n+            throw new BLangCompilerException(\"JVM generation is not supported for type \" + String.format(\"%s\", jType));\n+        }\n+    }\n+\n+    private static String getJVMTypeSign(BType bType) {\n+\n+        String jvmType = \"\";\n+        if (bType.tag == TypeTags.INT) {\n+            jvmType = \"J\";\n+        } else if (bType.tag == TypeTags.BYTE) {\n+            jvmType = \"I\";\n+        } else if (bType.tag == TypeTags.FLOAT) {\n+            jvmType = \"D\";\n+        } else if (bType.tag == TypeTags.BOOLEAN) {\n+            jvmType = \"Z\";\n+        } else if (bType.tag == TypeTags.STRING) {\n+            jvmType = String.format(\"L%s;\", STRING_VALUE);\n+        } else if (bType.tag == TypeTags.DECIMAL) {\n+            jvmType = String.format(\"L%s;\", DECIMAL_VALUE);\n+        } else if (bType.tag == TypeTags.MAP || bType.tag == TypeTags.RECORD) {\n+            jvmType = String.format(\"L%s;\", MAP_VALUE);\n+        } else if (bType.tag == TypeTags.TABLE) {\n+            jvmType = String.format(\"L%s;\", TABLE_VALUE);\n+        } else if (bType.tag == TypeTags.STREAM) {\n+            jvmType = String.format(\"L%s;\", STREAM_VALUE);\n+        } else if (bType.tag == TypeTags.ARRAY ||\n+                bType.tag == TypeTags.TUPLE) {\n+            jvmType = String.format(\"L%s;\", ARRAY_VALUE);\n+        } else if (bType.tag == TypeTags.OBJECT || bType.tag == TypeTags.SERVICE) {\n+            jvmType = String.format(\"L%s;\", OBJECT_VALUE);\n+        } else if (bType.tag == TypeTags.ERROR) {\n+            jvmType = String.format(\"L%s;\", ERROR_VALUE);\n+        } else if (bType.tag == TypeTags.FUTURE) {\n+            jvmType = String.format(\"L%s;\", FUTURE_VALUE);\n+        } else if (bType.tag == TypeTags.INVOKABLE) {\n+            jvmType = String.format(\"L%s;\", FUNCTION_POINTER);\n+        } else if (bType.tag == TypeTags.HANDLE) {\n+            jvmType = String.format(\"L%s;\", HANDLE_VALUE);\n+        } else if (bType.tag == TypeTags.TYPEDESC) {\n+            jvmType = String.format(\"L%s;\", TYPEDESC_VALUE);\n+        } else if (bType.tag == TypeTags.NIL\n+                || bType.tag == TypeTags.ANY\n+                || bType.tag == TypeTags.ANYDATA\n+                || bType.tag == TypeTags.UNION\n+                || bType.tag == TypeTags.JSON\n+                || bType.tag == TypeTags.FINITE) {\n+            jvmType = String.format(\"L%s;\", OBJECT);\n+        } else if (bType.tag == JTypeTags.JTYPE) {\n+            jvmType = getJTypeSignature((JType) bType);\n+        } else if (bType.tag == TypeTags.XML) {\n+            jvmType = String.format(\"L%s;\", XML_VALUE);\n+        } else {\n+            throw new BLangCompilerException(\"JVM code generation is not supported for type \" +\n+                    String.format(\"%s\", bType));\n+        }\n+        return jvmType;\n+    }\n+\n+    public static void generateBasicBlocks(MethodVisitor mv, @Nilable List<BIRBasicBlock> basicBlocks,\n+                                           LabelGenerator labelGen, ErrorHandlerGenerator errorGen,\n+                                           InstructionGenerator instGen, TerminatorGenerator termGen,\n+                                           BIRFunction func, int returnVarRefIndex, int stateVarIndex,\n+                                           int localVarOffset, boolean isArg, BIRPackage module,\n+                                           String currentPackageName, @Nilable BType attachedType,\n+                                           boolean isObserved /* = false */,\n+                                           boolean isService /* = false */, String serviceName /* = \"\" */,\n+                                           boolean useBString /* = false */) {\n+\n+        int j = 0;\n+        String funcName = cleanupFunctionName(func.name.value);\n+\n+        int caseIndex = 0;\n+\n+        while (j < basicBlocks.size()) {\n+            BIRBasicBlock bb = getBasicBlock(basicBlocks.get(j));\n+            String currentBBName = String.format(\"%s\", bb.id.value);\n+\n+            // create jvm label\n+            Label bbLabel = labelGen.getLabel(funcName + bb.id.value);\n+            mv.visitLabel(bbLabel);\n+            if (j == 0 && !isArg) {\n+                // SIPUSH range is (-32768 to 32767) so if the state index goes beyond that, need to use visitLdcInsn\n+                mv.visitIntInsn(SIPUSH, caseIndex);\n+                mv.visitVarInsn(ISTORE, stateVarIndex);\n+                caseIndex += 1;\n+            }\n+\n+            String serviceOrConnectorName = serviceName;\n+            if (isObserved && j == 0) {\n+                String observationStartMethod = isService ? \"startResourceObservation\" : \"startCallableObservation\";\n+                if (!isService && attachedType != null && attachedType.tag == TypeTags.OBJECT) {\n+                    // add module org and module name to remote spans.\n+                    BObjectType attachedTypeObj = (BObjectType) attachedType;\n+                    serviceOrConnectorName = getFullQualifiedRemoteFunctionName(\n+                            attachedTypeObj.tsymbol.pkgID.orgName.value,\n+                            attachedTypeObj.tsymbol.pkgID.name.value, serviceName);\n+                }\n+                emitStartObservationInvocation(mv, localVarOffset, serviceOrConnectorName, funcName,\n+                        observationStartMethod);\n+            }\n+\n+            // generate instructions\n+            int m = 0;\n+            int insCount = bb.instructions.size();\n+\n+            InstructionKind insKind;\n+            while (m < insCount) {\n+                Label insLabel = labelGen.getLabel(funcName + bb.id.value + \"ins\" + m);\n+                mv.visitLabel(insLabel);\n+                @Nilable BIRInstruction inst = bb.instructions.get(m);\n+                if (inst == null) {\n+                    continue;\n+                } else {\n+                    insKind = inst.getKind();\n+                    generateDiagnosticPos(((BIRNode) inst).pos, mv);\n+                }\n+\n+                if (inst instanceof BinaryOp) {\n+                    instGen.generateBinaryOpIns((BinaryOp) inst);\n+                } else {\n+                    switch (insKind) {\n+                        case MOVE:\n+                            instGen.generateMoveIns((Move) inst);\n+                            break;\n+                        case CONST_LOAD:\n+                            instGen.generateConstantLoadIns((ConstantLoad) inst, useBString);\n+                            break;\n+                        case NEW_STRUCTURE:\n+                            instGen.generateMapNewIns((NewStructure) inst, localVarOffset);\n+                            break;\n+                        case NEW_INSTANCE:\n+                            instGen.generateObjectNewIns((NewInstance) inst, localVarOffset);\n+                            break;\n+                        case MAP_STORE:\n+                            instGen.generateMapStoreIns((FieldAccess) inst);\n+                            break;\n+                        case NEW_ARRAY:\n+                            instGen.generateArrayNewIns((NewArray) inst);\n+                            break;\n+                        case ARRAY_STORE:\n+                            instGen.generateArrayStoreIns((FieldAccess) inst);\n+                            break;\n+                        case MAP_LOAD:\n+                            instGen.generateMapLoadIns((FieldAccess) inst);\n+                            break;\n+                        case ARRAY_LOAD:\n+                            instGen.generateArrayValueLoad((FieldAccess) inst);\n+                            break;\n+                        case NEW_ERROR:\n+                            instGen.generateNewErrorIns((NewError) inst);\n+                            break;\n+                        case TYPE_CAST:\n+                            instGen.generateCastIns((TypeCast) inst);\n+                            break;\n+                        case IS_LIKE:\n+                            instGen.generateIsLikeIns((IsLike) inst);\n+                            break;\n+                        case TYPE_TEST:\n+                            instGen.generateTypeTestIns((TypeTest) inst);\n+                            break;\n+                        case OBJECT_STORE:\n+                            instGen.generateObjectStoreIns((FieldAccess) inst, useBString);\n+                            break;\n+                        case OBJECT_LOAD:\n+                            instGen.generateObjectLoadIns((FieldAccess) inst);\n+                            break;\n+                        case NEW_XML_ELEMENT:\n+                            instGen.generateNewXMLElementIns((NewXMLElement) inst);\n+                            break;\n+                        case NEW_XML_TEXT:\n+                            instGen.generateNewXMLTextIns((NewXMLText) inst);\n+                            break;\n+                        case NEW_XML_COMMENT:\n+                            instGen.generateNewXMLCommentIns((NewXMLComment) inst);\n+                            break;\n+                        case NEW_XML_PI:\n+                            instGen.generateNewXMLProcIns((NewXMLProcIns) inst);\n+                            break;\n+                        case NEW_XML_QNAME:\n+                            instGen.generateNewXMLQNameIns((NewXMLQName) inst);\n+                            break;\n+                        case NEW_STRING_XML_QNAME:\n+                            instGen.generateNewStringXMLQNameIns((NewStringXMLQName) inst);\n+                            break;\n+                        case XML_SEQ_STORE:\n+                            instGen.generateXMLStoreIns((XMLAccess) inst);\n+                            break;\n+                        case XML_SEQ_LOAD:\n+                            instGen.generateXMLLoadIns((FieldAccess) inst);\n+                            break;\n+                        case XML_LOAD:\n+                            instGen.generateXMLLoadIns((FieldAccess) inst);\n+                            break;\n+                        case XML_LOAD_ALL:\n+                            instGen.generateXMLLoadAllIns((XMLAccess) inst);\n+                            break;\n+                        case XML_ATTRIBUTE_STORE:\n+                            instGen.generateXMLAttrStoreIns((FieldAccess) inst);\n+                            break;\n+                        case XML_ATTRIBUTE_LOAD:\n+                            instGen.generateXMLAttrLoadIns((FieldAccess) inst);\n+                            break;\n+                        case FP_LOAD:\n+                            instGen.generateFPLoadIns((FPLoad) inst);\n+                            break;\n+                        case STRING_LOAD:\n+                            instGen.generateStringLoadIns((FieldAccess) inst);\n+                            break;\n+                        case NEW_TABLE:\n+                            instGen.generateTableNewIns((NewTable) inst);\n+                            break;\n+                        case TYPEOF:\n+                            instGen.generateTypeofIns((UnaryOP) inst);\n+                            break;\n+                        case NOT:\n+                            instGen.generateNotIns((UnaryOP) inst);\n+                            break;\n+                        case NEW_TYPEDESC:\n+                            instGen.generateNewTypedescIns((NewTypeDesc) inst);\n+                            break;\n+                        case NEGATE:\n+                            instGen.generateNegateIns((UnaryOP) inst);\n+                            break;\n+                        case PLATFORM:\n+                            instGen.generatePlatformIns((JInstruction) inst);\n+                            break;\n+                        default:\n+                            throw new BLangCompilerException(\"JVM generation is not supported for operation \" +\n+                                    String.format(\"%s\", inst));\n+                    }\n+                }\n+                m += 1;\n+            }\n+\n+            Label bbEndLable = labelGen.getLabel(funcName + bb.id.value + \"beforeTerm\");\n+            mv.visitLabel(bbEndLable);\n+\n+            BIRTerminator terminator = bb.terminator;\n+            if (!isArg) {\n+                // SIPUSH range is (-32768 to 32767) so if the state index goes beyond that, need to use visitLdcInsn\n+                mv.visitIntInsn(SIPUSH, caseIndex);\n+                mv.visitVarInsn(ISTORE, stateVarIndex);\n+                caseIndex += 1;\n+            }\n+\n+            // process terminator\n+            boolean isTerminatorTrapped = false;\n+            if (!isArg || (isArg && !(terminator instanceof Return))) {\n+                generateDiagnosticPos(terminator.pos, mv);\n+                if (isModuleInitFunction(module, func) && terminator instanceof Return) {\n+                    generateAnnotLoad(mv, module.typeDefs, getPackageName(module.org.value, module.name.value));\n+                }\n+                termGen.genTerminator(terminator, func, funcName, localVarOffset, returnVarRefIndex, attachedType,\n+                        isObserved);\n+            }\n+\n+            errorGen.generateTryCatch(func, funcName, bb, instGen, termGen, labelGen);\n+\n+            BIRBasicBlock thenBB = terminator.thenBB;\n+            if (thenBB instanceof BIRBasicBlock) {\n+                genYieldCheck(mv, termGen.labelGen, thenBB, funcName, localVarOffset);\n+            }\n+            j += 1;\n+        }\n+    }\n+\n+    private static void genYieldCheck(MethodVisitor mv, LabelGenerator labelGen, BIRBasicBlock thenBB, String funcName,\n+                                      int localVarOffset) {\n+\n+        mv.visitVarInsn(ALOAD, localVarOffset);\n+        mv.visitMethodInsn(INVOKEVIRTUAL, STRAND, \"isYielded\", \"()Z\", false);\n+        Label yieldLabel = labelGen.getLabel(funcName + \"yield\");\n+        mv.visitJumpInsn(IFNE, yieldLabel);\n+\n+        // goto thenBB\n+        Label gotoLabel = labelGen.getLabel(funcName + thenBB.id.value);\n+        mv.visitJumpInsn(GOTO, gotoLabel);\n+    }\n+\n+    static void generateLambdaMethod(BIRInstruction ins, ClassWriter cw, String lambdaName) {\n+\n+        @Nilable BType lhsType;\n+        String orgName;\n+        String moduleName;\n+        String funcName;\n+        int paramIndex = 1;\n+        boolean isVirtual = false;\n+        InstructionKind kind = ins.getKind();\n+        if (kind == InstructionKind.ASYNC_CALL) {\n+            AsyncCall asyncIns = (AsyncCall) ins;\n+            isVirtual = asyncIns.isVirtual;\n+            lhsType = asyncIns.lhsOp != null ? asyncIns.lhsOp.variableDcl.type : null;\n+            orgName = asyncIns.calleePkg.orgName.value;\n+            moduleName = asyncIns.calleePkg.name.value;\n+            funcName = asyncIns.name.getValue();\n+        } else if (kind == InstructionKind.FP_LOAD) {\n+            FPLoad fpIns = (FPLoad) ins;\n+            lhsType = fpIns.lhsOp.variableDcl.type;\n+            orgName = fpIns.pkgId.orgName.value;\n+            moduleName = fpIns.pkgId.name.value;\n+            funcName = fpIns.funcName.getValue();\n+        } else {\n+            throw new BLangCompilerException(\"JVM lambda method generation is not supported for instruction \" +\n+                    String.format(\"%s\", ins));\n+        }\n+\n+        boolean isExternFunction = isExternStaticFunctionCall(ins);\n+        boolean isBuiltinModule = isBallerinaBuiltinModule(orgName, moduleName);\n+\n+        BType returnType = new BNilType();\n+        if (lhsType.tag == TypeTags.FUTURE) {\n+            returnType = ((BFutureType) lhsType).constraint;\n+        } else if (ins instanceof FPLoad) {\n+            returnType = ((FPLoad) ins).retType;\n+            if (returnType.tag == TypeTags.INVOKABLE) {\n+                returnType = ((BInvokableType) returnType).retType;\n+            }\n+        } else {\n+            throw new BLangCompilerException(\"JVM generation is not supported for async return type \" +\n+                    String.format(\"%s\", lhsType));\n+        }\n+\n+        int closureMapsCount = 0;\n+        if (kind == InstructionKind.FP_LOAD) {\n+            closureMapsCount = ((FPLoad) ins).closureMaps.size();\n+        }\n+        String closureMapsDesc = getMapValueDesc(closureMapsCount);\n+\n+        MethodVisitor mv;\n+        mv = cw.visitMethod(ACC_PUBLIC + ACC_STATIC, cleanupFunctionName(lambdaName),\n+                String.format(\"(%s[L%s;)L%s;\", closureMapsDesc, OBJECT, OBJECT), null, null);\n+\n+        mv.visitCode();\n+        // load strand as first arg\n+        // strand and other args are in a object[] param. This param comes after closure maps.\n+        // hence the closureMapsCount is equal to the array's param index.\n+        mv.visitVarInsn(ALOAD, closureMapsCount);\n+        mv.visitInsn(ICONST_0);\n+        mv.visitInsn(AALOAD);\n+        mv.visitTypeInsn(CHECKCAST, STRAND);\n+\n+        if (isExternFunction) {\n+            Label blockedOnExternLabel = new Label();\n+\n+            mv.visitInsn(DUP);\n+\n+            mv.visitMethodInsn(INVOKEVIRTUAL, STRAND, \"isBlockedOnExtern\", \"()Z\", false);\n+            mv.visitJumpInsn(IFEQ, blockedOnExternLabel);\n+\n+            mv.visitInsn(DUP);\n+            mv.visitInsn(ICONST_0);\n+            mv.visitFieldInsn(PUTFIELD, STRAND, \"blockedOnExtern\", \"Z\");\n+\n+            mv.visitInsn(DUP);\n+            mv.visitFieldInsn(GETFIELD, STRAND, \"returnValue\", \"Ljava/lang/Object;\");\n+            mv.visitInsn(ARETURN);\n+\n+            mv.visitLabel(blockedOnExternLabel);\n+        }\n+        @Nilable List<BType> paramBTypes = new ArrayList<>();\n+\n+        if (kind == InstructionKind.ASYNC_CALL) {\n+            AsyncCall asyncIns = (AsyncCall) ins;\n+            @Nilable List<BIROperand> paramTypes = asyncIns.args;\n+            if (isVirtual) {\n+                genLoadDataForObjectAttachedLambdas(asyncIns, mv, closureMapsCount, paramTypes, isBuiltinModule);\n+                int paramTypeIndex = 1;\n+                paramIndex = 2;\n+                while (paramTypeIndex < paramTypes.size()) {\n+                    generateObjectArgs(mv, paramIndex);\n+                    paramTypeIndex += 1;\n+                    paramIndex += 1;\n+                    if (!isBuiltinModule) {\n+                        generateObjectArgs(mv, paramIndex);\n+                        paramIndex += 1;\n+               ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82df207efdc85acd9646a1aae1461f7d1f7bbc5f"}, "originalPosition": 1451}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "58faa6a198cd02edc9d1caff261bab161f142d46", "author": {"user": {"login": "manuranga", "name": "manuranga perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/58faa6a198cd02edc9d1caff261bab161f142d46", "committedDate": "2020-03-04T06:03:08Z", "message": "Disable failing negative tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4cbd7c6e6975054bfba2f394b2f26c79f7860760", "author": {"user": {"login": "manuranga", "name": "manuranga perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/4cbd7c6e6975054bfba2f394b2f26c79f7860760", "committedDate": "2020-03-04T08:02:26Z", "message": "Disable gradle pre-running assemble\n\nsee https://github.com/travis-ci/travis-ci/issues/8667"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "88e5a152a4cefd9ab787de4230813c1ff1f31fbb", "author": {"user": {"login": "warunalakshitha", "name": "Waruna Lakshitha"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/88e5a152a4cefd9ab787de4230813c1ff1f31fbb", "committedDate": "2020-03-04T09:10:51Z", "message": "Disable balopath test temporary"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "09fb153d30fe9707da93adcdfbf9bd1c7cf8784f", "author": {"user": {"login": "warunalakshitha", "name": "Waruna Lakshitha"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/09fb153d30fe9707da93adcdfbf9bd1c7cf8784f", "committedDate": "2020-03-04T09:34:32Z", "message": "Disable testBaloPathCase2 testcase"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "800b24ef066a76dc8c536b503d94f0cbd0dced14", "author": {"user": {"login": "manuranga", "name": "manuranga perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/800b24ef066a76dc8c536b503d94f0cbd0dced14", "committedDate": "2020-03-04T09:38:17Z", "message": "Merge pull request #21473 from warunalakshitha/disable_tests\n\nDisable balo path test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cad8d24bc398e669b8a88fefdf824557d4e17a12", "author": {"user": {"login": "manuranga", "name": "manuranga perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/cad8d24bc398e669b8a88fefdf824557d4e17a12", "committedDate": "2020-03-04T12:37:25Z", "message": "Disable cache for integration test travis build"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a68378a72ad595f9af92c7f3909845e296ba2d0b", "author": {"user": {"login": "manuranga", "name": "manuranga perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a68378a72ad595f9af92c7f3909845e296ba2d0b", "committedDate": "2020-03-04T13:20:39Z", "message": "Disable gradle pre-running assemble for integration test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4ODYxODgx", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21435#pullrequestreview-368861881", "createdAt": "2020-03-04T15:13:53Z", "commit": {"oid": "a68378a72ad595f9af92c7f3909845e296ba2d0b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4ODYzMjkz", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21435#pullrequestreview-368863293", "createdAt": "2020-03-04T15:15:24Z", "commit": {"oid": "a68378a72ad595f9af92c7f3909845e296ba2d0b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1fb1689213dc2cc962eadad4bb58f3fbdce99ea0", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1fb1689213dc2cc962eadad4bb58f3fbdce99ea0", "committedDate": "2020-02-27T06:53:39Z", "message": "Merge pull request #21318 from manuranga/jbal-be-rewrite\n\nFix duplicate stop methods issue"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9899f57c32c6c53ba874c2883bd4d391239dc425", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/9899f57c32c6c53ba874c2883bd4d391239dc425", "committedDate": "2020-02-27T09:58:17Z", "message": "Fix missing bitwise operation instruction case"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "832b3985448c119f3f289d8bfb83b38661456de4", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/832b3985448c119f3f289d8bfb83b38661456de4", "committedDate": "2020-02-27T09:58:43Z", "message": "Use tSymbol to get name and flag values"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bdf5465521cb02b3f30e51ffacbda3ee748a9bab", "author": {"user": {"login": "manuranga", "name": "manuranga perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/bdf5465521cb02b3f30e51ffacbda3ee748a9bab", "committedDate": "2020-02-27T10:01:56Z", "message": "Merge pull request #21330 from Kishanthan/jbal-merge-master\n\nUse tSymbol to get name and flag values"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b3eb593287d03cd987db7783c849b59c8ccae6eb", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b3eb593287d03cd987db7783c849b59c8ccae6eb", "committedDate": "2020-02-27T10:41:22Z", "message": "Fix lambda function lookup using symbols"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2ce613652e658e2e659bc50c2905981b8976bf17", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2ce613652e658e2e659bc50c2905981b8976bf17", "committedDate": "2020-02-27T10:41:44Z", "message": "Merge branch 'jbal-be-rewrite' of https://github.com/ballerina-platform/ballerina-lang into jbal-merge-master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6455d5a1eb2c9fc8d00b7ed1a9273987754928e7", "author": {"user": {"login": "manuranga", "name": "manuranga perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6455d5a1eb2c9fc8d00b7ed1a9273987754928e7", "committedDate": "2020-02-27T11:35:48Z", "message": "Fix InherentTypeViolation bug"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8de29baa98d712b230a61fd3a275f9fa7c30f101", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/8de29baa98d712b230a61fd3a275f9fa7c30f101", "committedDate": "2020-02-27T11:38:41Z", "message": "Merge pull request #21333 from manuranga/jbal-be-rewrite\n\nFix InherentTypeViolation bug"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9a0f60295ee5f86fb71aeb7bb23f9ab1235e64b1", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/9a0f60295ee5f86fb71aeb7bb23f9ab1235e64b1", "committedDate": "2020-02-27T11:39:07Z", "message": "Merge branch 'jbal-be-rewrite' of https://github.com/ballerina-platform/ballerina-lang into jbal-merge-master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "89e9bcba320546135ada3a9af9fda56aaff49c21", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/89e9bcba320546135ada3a9af9fda56aaff49c21", "committedDate": "2020-02-27T14:12:44Z", "message": "Clean jar cache prior to each balo creation run"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fa756e084066815874ba07a90ab8f1cf6fefa40f", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/fa756e084066815874ba07a90ab8f1cf6fefa40f", "committedDate": "2020-02-27T14:13:16Z", "message": "Use correct flag value for attach fns"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "53449827b8bf492b4d1ba0d39f95e58e16d9536b", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/53449827b8bf492b4d1ba0d39f95e58e16d9536b", "committedDate": "2020-02-27T14:14:18Z", "message": "Preserve insertion order and build recursive imports"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "360319f8000f4e2e9459e73ce8bc2021256a387c", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/360319f8000f4e2e9459e73ce8bc2021256a387c", "committedDate": "2020-02-27T14:14:43Z", "message": "Remove unused imports"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4392e76fff0ab8f9106658d317226e61df64f4c7", "author": {"user": {"login": "manuranga", "name": "manuranga perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/4392e76fff0ab8f9106658d317226e61df64f4c7", "committedDate": "2020-02-27T14:21:31Z", "message": "Merge pull request #21332 from Kishanthan/jbal-merge-master\n\nFix lambda function lookup using symbols"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "37925b86300a12b924231bd5cd40047ae47b2ebc", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/37925b86300a12b924231bd5cd40047ae47b2ebc", "committedDate": "2020-02-28T05:27:24Z", "message": "Fixes related to global var lookup and null type name"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b6ba652fcfad33c6f701e7892ab291dc6e879a7e", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b6ba652fcfad33c6f701e7892ab291dc6e879a7e", "committedDate": "2020-02-28T05:27:56Z", "message": "Merge branch 'jbal-be-rewrite' of https://github.com/ballerina-platform/ballerina-lang into jbal-merge-master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "193389ed96f2d1e29a656e80ebd97e1fd2910312", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/193389ed96f2d1e29a656e80ebd97e1fd2910312", "committedDate": "2020-02-28T05:29:57Z", "message": "Remove unused import"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "627169c0a1352cfa19902f47cecb5669e587b400", "author": {"user": {"login": "manuranga", "name": "manuranga perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/627169c0a1352cfa19902f47cecb5669e587b400", "committedDate": "2020-02-28T05:33:36Z", "message": "Merge pull request #21342 from Kishanthan/jbal-merge-master\n\nFixes related to global var lookup and null type name"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f69aa660140b4c0ff21f6b576426cf8ef92f93e9", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f69aa660140b4c0ff21f6b576426cf8ef92f93e9", "committedDate": "2020-02-28T08:06:35Z", "message": "Skip desugaring imported same project modules"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "86cfbc4f6176a9b2204aae43232a072a81ca2051", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/86cfbc4f6176a9b2204aae43232a072a81ca2051", "committedDate": "2020-02-28T08:07:01Z", "message": "Merge branch 'jbal-be-rewrite' of https://github.com/ballerina-platform/ballerina-lang into jbal-merge-master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "02ffd79c675792de9e727cc21a260fc86bc2c93d", "author": {"user": {"login": "SupunS", "name": "Supun Setunga"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/02ffd79c675792de9e727cc21a260fc86bc2c93d", "committedDate": "2020-02-28T08:36:28Z", "message": "Fix object/record type flags"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6891824c9ee6517386591cd79ea77b1bf20ce8d0", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6891824c9ee6517386591cd79ea77b1bf20ce8d0", "committedDate": "2020-02-28T08:40:49Z", "message": "Merge pull request #21348 from SupunS/jbal-be-rewrite\n\nFix object/record type flags"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fa1432f8f050cd1b5f8e642ec509c4b52a4009b3", "author": {"user": {"login": "SupunS", "name": "Supun Setunga"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/fa1432f8f050cd1b5f8e642ec509c4b52a4009b3", "committedDate": "2020-02-28T09:33:42Z", "message": "Fix visitMaxs in ArrayFillTest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "30cabafa5682b53cbb35b31831eebe97f527acb7", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/30cabafa5682b53cbb35b31831eebe97f527acb7", "committedDate": "2020-02-28T09:49:58Z", "message": "Merge pull request #21351 from SupunS/jbal-be-rewrite\n\nFix visitMaxs in ArrayFillTest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2aa01a590a7b962716ebac3a7ba180c8be533bd1", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2aa01a590a7b962716ebac3a7ba180c8be533bd1", "committedDate": "2020-02-28T09:56:05Z", "message": "Merge branch 'jbal-be-rewrite' of https://github.com/ballerina-platform/ballerina-lang into jbal-merge-master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4e7756b6babf544b9335e07e6d1f3380412e69ad", "author": {"user": {"login": "SupunS", "name": "Supun Setunga"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/4e7756b6babf544b9335e07e6d1f3380412e69ad", "committedDate": "2020-02-28T10:08:40Z", "message": "Fix decimal finitie type"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2a9033e46a5ce55ad8a104f0fe96930520216b00", "author": {"user": {"login": "SupunS", "name": "Supun Setunga"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2a9033e46a5ce55ad8a104f0fe96930520216b00", "committedDate": "2020-02-28T10:08:53Z", "message": "Merge branch 'jbal-be-rewrite' of https://github.com/ballerina-platform/ballerina-lang into jbal-be-rewrite"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "51463b20389be601264176479b19f155695eb7c7", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/51463b20389be601264176479b19f155695eb7c7", "committedDate": "2020-02-28T10:11:38Z", "message": "Clean jar cache dir before test run"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0bf554ed2acd5053cf9ecb54319668ea3310b2d7", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/0bf554ed2acd5053cf9ecb54319668ea3310b2d7", "committedDate": "2020-02-28T10:16:22Z", "message": "Merge pull request #21356 from SupunS/jbal-be-rewrite\n\nFix decimal finite type"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "54514326cfdf6d7b7aec5c0cb18bf4b31a0e6392", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/54514326cfdf6d7b7aec5c0cb18bf4b31a0e6392", "committedDate": "2020-02-28T10:19:17Z", "message": "Merge branch 'jbal-be-rewrite' of https://github.com/ballerina-platform/ballerina-lang into jbal-merge-master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a21988dba40b835c9efc60ae29a44e6359b25fc4", "author": {"user": {"login": "manuranga", "name": "manuranga perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a21988dba40b835c9efc60ae29a44e6359b25fc4", "committedDate": "2020-02-28T10:38:43Z", "message": "Merge pull request #21355 from Kishanthan/jbal-merge-master\n\nSkip desugaring imported same project modules"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bd67c81a2061b9040e547c29e975d4fce019af26", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/bd67c81a2061b9040e547c29e975d4fce019af26", "committedDate": "2020-02-28T10:58:13Z", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into jbal-with-latest-master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f1dd18c82fe9f82baa4c516f9d02f43a2d0226ce", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f1dd18c82fe9f82baa4c516f9d02f43a2d0226ce", "committedDate": "2020-02-28T11:39:43Z", "message": "Fix compilation issues with lock changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b183c45674c3074c103deba446049da9ed4e0a5e", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b183c45674c3074c103deba446049da9ed4e0a5e", "committedDate": "2020-02-28T11:55:23Z", "message": "Fix compilation issues with BIR emitter"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9e765a61692631d241dab03abf6f8b46c71b6415", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/9e765a61692631d241dab03abf6f8b46c71b6415", "committedDate": "2020-02-28T11:55:46Z", "message": "Merge branch 'jbal-be-rewrite' of https://github.com/ballerina-platform/ballerina-lang into jbal-with-latest-master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0e62a6d210b0b7c944fdbf417e2eabca0f608424", "author": {"user": {"login": "manuranga", "name": "manuranga perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/0e62a6d210b0b7c944fdbf417e2eabca0f608424", "committedDate": "2020-02-28T12:17:42Z", "message": "Merge pull request #21358 from Kishanthan/jbal-with-latest-master\n\nMerge jbal-rewrite-be with master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1155903e425124a9fe6af2868cb161faf00de723", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1155903e425124a9fe6af2868cb161faf00de723", "committedDate": "2020-02-28T13:17:35Z", "message": "Add compiled module cache to avoid recompilation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e75d6e0d1ba15a007e88496e0805afee53e5f091", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e75d6e0d1ba15a007e88496e0805afee53e5f091", "committedDate": "2020-02-28T13:17:57Z", "message": "Merge branch 'jbal-be-rewrite' of https://github.com/ballerina-platform/ballerina-lang into jbal-with-latest-master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cd215549b135dba5a7ac6cce707351db37588727", "author": {"user": {"login": "SupunS", "name": "Supun Setunga"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/cd215549b135dba5a7ac6cce707351db37588727", "committedDate": "2020-02-29T04:14:48Z", "message": "Merge pull request #21359 from Kishanthan/jbal-with-latest-master\n\nAdd compiled module cache to avoid recompilation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6f201568ef6c2f14c1189a356ab8306e5c72d0c4", "author": {"user": {"login": "SupunS", "name": "Supun Setunga"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6f201568ef6c2f14c1189a356ab8306e5c72d0c4", "committedDate": "2020-02-29T05:48:44Z", "message": "Fix module stop function lambda generation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "93e9bfc09e6273b38fd93b2c01d4fabff9960102", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/93e9bfc09e6273b38fd93b2c01d4fabff9960102", "committedDate": "2020-02-29T06:05:54Z", "message": "Merge pull request #21361 from SupunS/jbal-be-rewrite\n\nFix module stop function lambda generation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "61683ae83dfedc5321cb2454b941cc352e3f659e", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/61683ae83dfedc5321cb2454b941cc352e3f659e", "committedDate": "2020-02-29T06:10:35Z", "message": "Ondemand cleaning of cache dir for balo tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9d539f02945e90fcf1160d63717b3c19052c5c07", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/9d539f02945e90fcf1160d63717b3c19052c5c07", "committedDate": "2020-02-29T06:10:51Z", "message": "Merge branch 'jbal-be-rewrite' of https://github.com/ballerina-platform/ballerina-lang into jbal-with-latest-master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1d2a56aaf556bcbd9a5d39d94ee888963e647d8f", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1d2a56aaf556bcbd9a5d39d94ee888963e647d8f", "committedDate": "2020-02-29T07:16:53Z", "message": "Move create balo logic inside test cases"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "54bbe6d3cd71a623e047b2cf65b2a320ffb1219c", "author": {"user": {"login": "SupunS", "name": "Supun Setunga"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/54bbe6d3cd71a623e047b2cf65b2a320ffb1219c", "committedDate": "2020-02-29T08:14:47Z", "message": "FIx compiler backend error logging"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b441e0ab27041ce0308d0e8f23770d3f07b9e868", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b441e0ab27041ce0308d0e8f23770d3f07b9e868", "committedDate": "2020-02-29T08:24:47Z", "message": "Merge pull request #21363 from SupunS/jbal-be-rewrite\n\nFix compiler backend error logging"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cdcfa87a5f43611dbb38be4b88e2ee9418c5fcd9", "author": {"user": {"login": "SupunS", "name": "Supun Setunga"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/cdcfa87a5f43611dbb38be4b88e2ee9418c5fcd9", "committedDate": "2020-02-29T08:25:56Z", "message": "Merge pull request #21362 from Kishanthan/jbal-with-latest-master\n\nOndemand cleaning of cache dir for balo tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "da6af5302c360188825f5cefd6e3ee72c404b811", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/da6af5302c360188825f5cefd6e3ee72c404b811", "committedDate": "2020-02-29T08:33:28Z", "message": "Use correct types with casting"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "66dece05f93e2854e88a7767ba48f02452e6eaa5", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/66dece05f93e2854e88a7767ba48f02452e6eaa5", "committedDate": "2020-02-29T08:33:54Z", "message": "Clean cache directory for balo test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "14b4c8e0e8552124146b3d249b2482dffc8651a2", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/14b4c8e0e8552124146b3d249b2482dffc8651a2", "committedDate": "2020-02-29T08:34:05Z", "message": "Merge branch 'jbal-be-rewrite' of https://github.com/ballerina-platform/ballerina-lang into jbal-with-latest-master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6b8a08b031a509fa603a58890bb0555f474a9331", "author": {"user": {"login": "SupunS", "name": "Supun Setunga"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6b8a08b031a509fa603a58890bb0555f474a9331", "committedDate": "2020-02-29T08:47:11Z", "message": "Catch only on-compiler errors"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3661057bc8b5d356818ace6767afef3c05519f48", "author": {"user": {"login": "SupunS", "name": "Supun Setunga"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3661057bc8b5d356818ace6767afef3c05519f48", "committedDate": "2020-02-29T08:50:58Z", "message": "Merge pull request #21365 from Kishanthan/jbal-with-latest-master\n\nUse correct types with casting"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dddaf421850c1037c220acbd94ff294d163e57b9", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/dddaf421850c1037c220acbd94ff294d163e57b9", "committedDate": "2020-02-29T08:54:03Z", "message": "Merge pull request #21366 from SupunS/jbal-be-rewrite\n\nCatch only non-compiler errors"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2c9ec4c56d945f426a2b3c784ae298c6ec396c9a", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2c9ec4c56d945f426a2b3c784ae298c6ec396c9a", "committedDate": "2020-02-29T09:08:58Z", "message": "Use type instance from symbol table"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5684015f663ca5cfd5c2cf5789792a30251998a8", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/5684015f663ca5cfd5c2cf5789792a30251998a8", "committedDate": "2020-02-29T09:09:39Z", "message": "Merge branch 'jbal-be-rewrite' of https://github.com/ballerina-platform/ballerina-lang into jbal-with-latest-master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "30a347b5b416b18ae192c5f78d65e277d314761c", "author": {"user": {"login": "SupunS", "name": "Supun Setunga"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/30a347b5b416b18ae192c5f78d65e277d314761c", "committedDate": "2020-02-29T09:20:49Z", "message": "Fix xml test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "300aa9bd811b1b1efb4650314faf96254d60c26e", "author": {"user": {"login": "SupunS", "name": "Supun Setunga"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/300aa9bd811b1b1efb4650314faf96254d60c26e", "committedDate": "2020-02-29T09:21:09Z", "message": "Merge branch 'jbal-be-rewrite' of https://github.com/ballerina-platform/ballerina-lang into jbal-be-rewrite"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4690e662ba0ab1f6919cfbadc9516dc921cee7f6", "author": {"user": {"login": "manuranga", "name": "manuranga perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/4690e662ba0ab1f6919cfbadc9516dc921cee7f6", "committedDate": "2020-02-29T09:27:38Z", "message": "Change the build to use ported java backend"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "93d4eae9c8a8d12bde3497f3c530efe9be433ccc", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/93d4eae9c8a8d12bde3497f3c530efe9be433ccc", "committedDate": "2020-02-29T09:27:43Z", "message": "Merge pull request #21368 from SupunS/jbal-be-rewrite\n\nFix xml test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "671b66c3c275296f887cb4f9f49e9e59800fcc72", "author": {"user": {"login": "SupunS", "name": "Supun Setunga"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/671b66c3c275296f887cb4f9f49e9e59800fcc72", "committedDate": "2020-02-29T09:27:54Z", "message": "Merge pull request #21367 from Kishanthan/jbal-with-latest-master\n\nUse type instance from symbol table"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5b6224735d5607e363653bde17dffdefc1955147", "author": {"user": {"login": "manuranga", "name": "manuranga perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/5b6224735d5607e363653bde17dffdefc1955147", "committedDate": "2020-02-29T09:30:35Z", "message": "Merge remote-tracking branch 'origin/jbal-be-rewrite' into jbal-be-rewrite\n\n# Conflicts:\n#\tcompiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/codegen/JvmMethodGen.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "411d1ee6c0d49b1b833e526d1294a28c90819e0d", "author": {"user": {"login": "SupunS", "name": "Supun Setunga"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/411d1ee6c0d49b1b833e526d1294a28c90819e0d", "committedDate": "2020-02-29T09:44:24Z", "message": "Fix future type"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2dfdfdf72960844824fa75ffe64f0a86f720dad9", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2dfdfdf72960844824fa75ffe64f0a86f720dad9", "committedDate": "2020-02-29T09:51:37Z", "message": "Merge pull request #21364 from manuranga/jbal-be-rewrite\n\nChange the build to use ported java backend"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9efaab431b2511b84777c8fb00bda4035762b8a5", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/9efaab431b2511b84777c8fb00bda4035762b8a5", "committedDate": "2020-02-29T09:52:03Z", "message": "Merge pull request #21370 from SupunS/jbal-be-rewrite\n\nFix future type"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "78b96edd3d402916afd6cfda9c0d03d3585ddd83", "author": {"user": {"login": "manuranga", "name": "manuranga perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/78b96edd3d402916afd6cfda9c0d03d3585ddd83", "committedDate": "2020-02-29T10:40:23Z", "message": "Fix calling main function with rest param"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "26b0f024ecc655935980ec6948f35181c42aacc7", "author": {"user": {"login": "manuranga", "name": "manuranga perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/26b0f024ecc655935980ec6948f35181c42aacc7", "committedDate": "2020-02-29T10:43:36Z", "message": "Merge pull request #21372 from manuranga/jbal-be-rewrite\n\nFix calling main function with rest param"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "058039e8aa664fd2015c104028c4b5b3b8412b76", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/058039e8aa664fd2015c104028c4b5b3b8412b76", "committedDate": "2020-02-29T10:51:17Z", "message": "Migrate stream related codegen changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "70b57901e71c269298e787c24824b23c8c6b0ff5", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/70b57901e71c269298e787c24824b23c8c6b0ff5", "committedDate": "2020-02-29T10:51:38Z", "message": "Merge branch 'jbal-be-rewrite' of https://github.com/ballerina-platform/ballerina-lang into jbal-with-latest-master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6495a3ac1ff5d7f17455b213faadaa3f0e60595c", "author": {"user": {"login": "manuranga", "name": "manuranga perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6495a3ac1ff5d7f17455b213faadaa3f0e60595c", "committedDate": "2020-02-29T10:55:30Z", "message": "Merge pull request #21373 from Kishanthan/jbal-with-latest-master\n\nMigrate stream related codegen changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c6628c85add03f3784ec4905d5b41027adea0ced", "author": {"user": {"login": "warunalakshitha", "name": "Waruna Lakshitha"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c6628c85add03f3784ec4905d5b41027adea0ced", "committedDate": "2020-02-29T16:11:58Z", "message": "Fix interop unit tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b38296a24e0bd297fdddb0da0779d538985d695d", "author": {"user": {"login": "warunalakshitha", "name": "Waruna Lakshitha"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b38296a24e0bd297fdddb0da0779d538985d695d", "committedDate": "2020-02-29T17:33:12Z", "message": "Merge branch jbal-be-rewrite"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7ab477adfef86253a6bd2b28e80d7b331fdc5d32", "author": {"user": {"login": "warunalakshitha", "name": "Waruna Lakshitha"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7ab477adfef86253a6bd2b28e80d7b331fdc5d32", "committedDate": "2020-02-29T18:27:46Z", "message": "Fix java interop reftype tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a2b1310717ecc66cf1f30328c5724bbbffe64f72", "author": {"user": {"login": "manuranga", "name": "manuranga perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a2b1310717ecc66cf1f30328c5724bbbffe64f72", "committedDate": "2020-03-01T06:49:33Z", "message": "Merge pull request #21377 from warunalakshitha/jbal_rewrite\n\nFix java interop unit tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a5f1006ef7b90d9ba22587695929ae03fc44a30a", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a5f1006ef7b90d9ba22587695929ae03fc44a30a", "committedDate": "2020-03-01T07:44:51Z", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into jbal-with-latest-master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d9c01cb2eb2f547bce44d9c167baf6e0e59f20d7", "author": {"user": {"login": "manuranga", "name": "manuranga perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/d9c01cb2eb2f547bce44d9c167baf6e0e59f20d7", "committedDate": "2020-03-01T08:04:47Z", "message": "Merge pull request #21379 from Kishanthan/jbal-with-latest-master\n\nMerge with master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7cc2d4cffdaec4b6e814ade1a888e88456035785", "author": {"user": {"login": "manuranga", "name": "manuranga perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7cc2d4cffdaec4b6e814ade1a888e88456035785", "committedDate": "2020-03-01T08:15:52Z", "message": "Fix interop validation class not found issue"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "87e92a6433080050ecce85c11a7789812f2a4fb5", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/87e92a6433080050ecce85c11a7789812f2a4fb5", "committedDate": "2020-03-01T08:27:47Z", "message": "Merge pull request #21380 from manuranga/jbal-be-rewrite\n\nFix interop validation class not found issue"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "54b5b6451b3ed22f8b448fa1c2ae6d5337c7182c", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/54b5b6451b3ed22f8b448fa1c2ae6d5337c7182c", "committedDate": "2020-03-01T18:42:25Z", "message": "Fix checkstyle and code quality issues"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "034715b7a881290c0f5e5131bacc9287be951111", "author": {"user": {"login": "manuranga", "name": "manuranga perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/034715b7a881290c0f5e5131bacc9287be951111", "committedDate": "2020-03-02T05:41:39Z", "message": "Merge pull request #21384 from Kishanthan/jbal-with-latest-master\n\nFix checkstyle and code quality issues"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d2fd9553df062c8f3f385d8f3e2e5c2312bc7c05", "author": {"user": {"login": "manuranga", "name": "manuranga perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/d2fd9553df062c8f3f385d8f3e2e5c2312bc7c05", "committedDate": "2020-03-02T06:23:35Z", "message": "Remove variable shadowing fixing interop cast issue"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8b15a5099fea53aa2fc469603e84b14dbf861f68", "author": {"user": {"login": "manuranga", "name": "manuranga perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/8b15a5099fea53aa2fc469603e84b14dbf861f68", "committedDate": "2020-03-02T06:26:23Z", "message": "Merge remote-tracking branch 'origin/jbal-be-rewrite' into jbal-be-rewrite\n\n# Conflicts:\n#\tcompiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/codegen/interop/ExternalMethodGen.java\n#\tcompiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/codegen/interop/InteropMethodGen.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "51096f9463adcb9fe190b3aa113649ffeaafeb5a", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/51096f9463adcb9fe190b3aa113649ffeaafeb5a", "committedDate": "2020-03-02T06:30:53Z", "message": "Merge pull request #21392 from manuranga/jbal-be-rewrite\n\nRemove variable shadowing fixing interop cast issue"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b2fc0d6d43b5b9b3c95e44bee84b4a015b4ec387", "author": {"user": {"login": "manuranga", "name": "manuranga perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b2fc0d6d43b5b9b3c95e44bee84b4a015b4ec387", "committedDate": "2020-03-02T07:47:53Z", "message": "Fix build dependency issue"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bc6679ff9669d139626d67c1b4f2bcd520b547a0", "author": {"user": {"login": "manuranga", "name": "manuranga perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/bc6679ff9669d139626d67c1b4f2bcd520b547a0", "committedDate": "2020-03-02T07:48:07Z", "message": "Fix style issue"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eb5b074769d1ff67f1f05a6e4fcaa5cc6f2738fa", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/eb5b074769d1ff67f1f05a6e4fcaa5cc6f2738fa", "committedDate": "2020-03-02T07:50:12Z", "message": "Merge pull request #21394 from manuranga/jbal-be-rewrite\n\nFix build issues"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0a657c6132f80a69aa337203106fb45729a057ea", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/0a657c6132f80a69aa337203106fb45729a057ea", "committedDate": "2020-03-02T07:55:05Z", "message": "Exclude spotbugs warnings for codegen pkg and fix checkstyle issues"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7fa1897a16f9a81ddb14fa62599353931cb79bae", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7fa1897a16f9a81ddb14fa62599353931cb79bae", "committedDate": "2020-03-02T07:55:20Z", "message": "Merge branch 'jbal-be-rewrite' of https://github.com/ballerina-platform/ballerina-lang into jbal-with-latest-master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a73e1afd5e815d31cb2c8c52011a14d4451b6bf8", "author": {"user": {"login": "manuranga", "name": "manuranga perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a73e1afd5e815d31cb2c8c52011a14d4451b6bf8", "committedDate": "2020-03-02T08:01:28Z", "message": "Merge pull request #21395 from Kishanthan/jbal-with-latest-master\n\nExclude spotbugs warnings for codegen pkg and fix checkstyle issues"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7be3aa6a675c013652cd2e38915b4944e75ff57e", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7be3aa6a675c013652cd2e38915b4944e75ff57e", "committedDate": "2020-03-02T08:21:35Z", "message": "Exclude BIR emit pkg"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "656c7be20d1024580cf1fce16b57be2520ec765f", "author": {"user": {"login": "manuranga", "name": "manuranga perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/656c7be20d1024580cf1fce16b57be2520ec765f", "committedDate": "2020-03-02T08:25:28Z", "message": "Merge pull request #21397 from Kishanthan/jbal-with-latest-master\n\nExclude BIR emit pkg"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8310062768790c40f724972bafa3469267161daf", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/8310062768790c40f724972bafa3469267161daf", "committedDate": "2020-03-02T08:44:23Z", "message": "Clean CreateJarTask class for spotbugs issue"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2c6a383ee4741c2f56e5e232bd105b2f025830f3", "author": {"user": {"login": "manuranga", "name": "manuranga perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2c6a383ee4741c2f56e5e232bd105b2f025830f3", "committedDate": "2020-03-02T09:17:12Z", "message": "Merge pull request #21399 from Kishanthan/jbal-with-latest-master\n\nClean CreateJarTask class for spotbugs issue"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "be616a2ac3a17cdb0ebfe6ee03383ce1d0ef3bd4", "author": {"user": {"login": "warunalakshitha", "name": "Waruna Lakshitha"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/be616a2ac3a17cdb0ebfe6ee03383ce1d0ef3bd4", "committedDate": "2020-03-02T12:43:58Z", "message": "Fix interop compile errors"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5b7a8ccb6352f536abfe6f0c9a692847f1f8b75d", "author": {"user": {"login": "warunalakshitha", "name": "Waruna Lakshitha"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/5b7a8ccb6352f536abfe6f0c9a692847f1f8b75d", "committedDate": "2020-03-02T12:44:46Z", "message": "Refactor interop negative tests to use diagnostics"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c1bc7e435014f68ac5a2a2f13e6e11a223275a79", "author": {"user": {"login": "warunalakshitha", "name": "Waruna Lakshitha"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c1bc7e435014f68ac5a2a2f13e6e11a223275a79", "committedDate": "2020-03-02T13:05:28Z", "message": "Merge branch jbal-be-rewrite"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ebc69b0d0fe77f80c9db601d5ec6c6d4c7ba6b71", "author": {"user": {"login": "manuranga", "name": "manuranga perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/ebc69b0d0fe77f80c9db601d5ec6c6d4c7ba6b71", "committedDate": "2020-03-02T13:07:59Z", "message": "Merge remote-tracking branch 'origin/master' into jbal-be-rewrite\n\n# Conflicts:\n#\tcli/ballerina-packerina/src/main/java/org/ballerinalang/packerina/cmd/TestCommand.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6fcb38034688bf09f6cba1915be13517750913d2", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6fcb38034688bf09f6cba1915be13517750913d2", "committedDate": "2020-03-02T13:37:20Z", "message": "Use a seperate classloader for interop validation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0eb14756b3f0a286ed90caa4ccb98fb6ae2527d4", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/0eb14756b3f0a286ed90caa4ccb98fb6ae2527d4", "committedDate": "2020-03-02T13:38:22Z", "message": "Merge pull request #21408 from warunalakshitha/jbal_rewrite\n\nFix interop Negative Tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e8e97637df9355155dfabe8d5e4c1da41a1e2a0a", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e8e97637df9355155dfabe8d5e4c1da41a1e2a0a", "committedDate": "2020-03-02T13:39:52Z", "message": "Merge with remote"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "39fb957b2d0b8a7ea7def2ba44e6acd1fc754b5b", "author": {"user": {"login": "warunalakshitha", "name": "Waruna Lakshitha"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/39fb957b2d0b8a7ea7def2ba44e6acd1fc754b5b", "committedDate": "2020-03-02T13:52:51Z", "message": "Fix code gen error tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6088c3e84c6e4f89569a7d33e4ebde6514b64159", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6088c3e84c6e4f89569a7d33e4ebde6514b64159", "committedDate": "2020-02-12T05:56:02Z", "message": "Migrate JvmTerminatorGen and fix compilation errors"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "21d338facc9a1dafbf7fe7fb39dc4315ab92f9e0", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/21d338facc9a1dafbf7fe7fb39dc4315ab92f9e0", "committedDate": "2020-02-12T06:25:50Z", "message": "Use correct BFutureType"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d3c92839bf260f6096410614263ff209fbbde713", "author": {"user": {"login": "manuranga", "name": "manuranga perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/d3c92839bf260f6096410614263ff209fbbde713", "committedDate": "2020-02-12T06:26:30Z", "message": "Merge pull request #21007 from Kishanthan/jbal-be-rewrite\n\nMigrate JvmTerminatorGen and fix compilation errors"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "42d2350fa4b0727dd8cf766c2705c34734dc8b76", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/42d2350fa4b0727dd8cf766c2705c34734dc8b76", "committedDate": "2020-02-12T06:56:30Z", "message": "Remove BIRVarRef class and use BIROperand instead"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c77a1833336c0d00078f725e3ea05720052191b1", "author": {"user": {"login": "manuranga", "name": "manuranga perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c77a1833336c0d00078f725e3ea05720052191b1", "committedDate": "2020-02-12T08:15:57Z", "message": "Merge pull request #21014 from Kishanthan/jbal-be-rewrite\n\nRemove BIRVarRef class and use BIROperand instead"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "18d039ff5129ee6d2c74a34be0bcc7b701d2051c", "author": {"user": {"login": "manuranga", "name": "manuranga perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/18d039ff5129ee6d2c74a34be0bcc7b701d2051c", "committedDate": "2020-02-12T09:07:57Z", "message": "Migrate JvmInstructionGen to java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f4340c2e4a1793acd339ab51ba80373ee39776e0", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f4340c2e4a1793acd339ab51ba80373ee39776e0", "committedDate": "2020-02-12T09:11:05Z", "message": "Migrate JvmPackageGen and fix compilation errors"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f09c688784732df1577259a8ace9544904485fe5", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f09c688784732df1577259a8ace9544904485fe5", "committedDate": "2020-02-12T09:11:27Z", "message": "Merge branch 'jbal-be-rewrite' of https://github.com/ballerina-platform/ballerina-lang into jbal-be-rewrite"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "95e2bcc767c94d6b7620a9e66d06b0356c94206f", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/95e2bcc767c94d6b7620a9e66d06b0356c94206f", "committedDate": "2020-02-12T09:13:54Z", "message": "Merge with upstream"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5e36d2f2ff5c57880c5290be82964f0d1ecc485c", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/5e36d2f2ff5c57880c5290be82964f0d1ecc485c", "committedDate": "2020-02-12T09:18:14Z", "message": "Fix compilation errors with addJUnboxInsn method"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bf76bf3d9a52b592733fd17b52b55cd79b849f64", "author": {"user": {"login": "manuranga", "name": "manuranga perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/bf76bf3d9a52b592733fd17b52b55cd79b849f64", "committedDate": "2020-02-12T09:19:37Z", "message": "Merge pull request #21022 from Kishanthan/jbal-be-rewrite\n\nMigrate JvmPackageGen and fix compilation errors"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "059a5d21b0f0c2d115add37afa9dbd8c4dd32da5", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/059a5d21b0f0c2d115add37afa9dbd8c4dd32da5", "committedDate": "2020-02-12T09:22:59Z", "message": "Migrate JvmObservabilityGen, JvmLabelGen and fix compilation errors"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1695fc32ce33cac29c6c0078615b3a42ea49c2d9", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1695fc32ce33cac29c6c0078615b3a42ea49c2d9", "committedDate": "2020-02-12T09:24:30Z", "message": "Update java docs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2a21af0668722bce28a3d27cfa45abdb04e0cecf", "author": {"user": {"login": "manuranga", "name": "manuranga perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2a21af0668722bce28a3d27cfa45abdb04e0cecf", "committedDate": "2020-02-12T09:25:56Z", "message": "Merge pull request #21023 from Kishanthan/jbal-be-rewrite\n\nMigrate JvmObservabilityGen, JvmLabelGen and fix compilation errors"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "05af2608360da5b7df8fd4442f88694b6bf954f0", "author": {"user": {"login": "manuranga", "name": "manuranga perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/05af2608360da5b7df8fd4442f88694b6bf954f0", "committedDate": "2020-02-14T07:48:18Z", "message": "Migrate JvmMethodGen to java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "984d668fe4fa98ec4dced1a305328732d0dddcc2", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/984d668fe4fa98ec4dced1a305328732d0dddcc2", "committedDate": "2020-02-14T08:06:49Z", "message": "Migrate interop gen related classes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2ba6e84953620d2f9435e42560c146ba3b319596", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2ba6e84953620d2f9435e42560c146ba3b319596", "committedDate": "2020-02-14T08:07:44Z", "message": "Merge pull request #21077 from manuranga/jbal-be-rewrite\n\nMigrate JvmMethodGen to java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "adb6a6aab24d6324714b047de88a2a15681a27d4", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/adb6a6aab24d6324714b047de88a2a15681a27d4", "committedDate": "2020-02-14T09:35:17Z", "message": "Fix merge conlficts and compilation errors"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d78720298be9070cb122f9936e59899217a49107", "author": {"user": {"login": "manuranga", "name": "manuranga perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/d78720298be9070cb122f9936e59899217a49107", "committedDate": "2020-02-14T09:46:35Z", "message": "Merge pull request #21087 from Kishanthan/jbal-be-rewrite\n\nMigrate interop gen related classes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f0e863cadd089a136acdde30e5827ff3e91d588a", "author": {"user": {"login": "manuranga", "name": "manuranga perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f0e863cadd089a136acdde30e5827ff3e91d588a", "committedDate": "2020-02-17T09:48:46Z", "message": "Fix runtime bugs to get migrated backend working for empty function"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4d2a10d0a1a0eb1bc7f18474480e7b2a8306a46e", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/4d2a10d0a1a0eb1bc7f18474480e7b2a8306a46e", "committedDate": "2020-02-17T09:56:23Z", "message": "Fix genJFieldForInteropField compilation errors"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "51b26f097b827473489296db3b13fe56c861e82a", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/51b26f097b827473489296db3b13fe56c861e82a", "committedDate": "2020-02-17T09:57:23Z", "message": "Merge pull request #21115 from manuranga/jbal-be-rewrite\n\nFix runtime bugs to get migrated backend working for empty function"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "057c8837c8098f0949220c46563f60ade911c8e0", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/057c8837c8098f0949220c46563f60ade911c8e0", "committedDate": "2020-02-17T11:56:00Z", "message": "Fix InteropMethodGen compilation errors and conflicts with upstream"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ea3b4a36cb4f4f5740f552be1978395bc18497d3", "author": {"user": {"login": "manuranga", "name": "manuranga perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/ea3b4a36cb4f4f5740f552be1978395bc18497d3", "committedDate": "2020-02-17T12:40:55Z", "message": "Merge pull request #21121 from Kishanthan/jbal-be-rewrite\n\nFix InteropMethodGen compilation errors and conflicts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "962434437872ae662a2dc16c3b11841deb52b527", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/962434437872ae662a2dc16c3b11841deb52b527", "committedDate": "2020-02-17T13:17:47Z", "message": "Clean JInteropFieldValidator logic"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3cda3d33aedbdacbf75f8bf2a0aa7c1baba025bd", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3cda3d33aedbdacbf75f8bf2a0aa7c1baba025bd", "committedDate": "2020-02-17T13:18:08Z", "message": "Merge branch 'jbal-be-rewrite' of https://github.com/ballerina-platform/ballerina-lang into jbal-be-rewrite"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "61c3be6fd9e4845ad8568050cd8f7a9c410dcf6e", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/61c3be6fd9e4845ad8568050cd8f7a9c410dcf6e", "committedDate": "2020-02-17T13:49:03Z", "message": "Use BackendDriver with test source compilation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3efa0112665c68192b7e84f6ac1865d6d97d48b4", "author": {"user": {"login": "manuranga", "name": "manuranga perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3efa0112665c68192b7e84f6ac1865d6d97d48b4", "committedDate": "2020-02-18T05:50:53Z", "message": "Merge pull request #21124 from Kishanthan/jbal-be-rewrite\n\nClean JInteropFieldValidator and Use BackendDriver for test source compilation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f4fd5e24b6141185d33488436f03af49c98d30ce", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f4fd5e24b6141185d33488436f03af49c98d30ce", "committedDate": "2020-02-18T09:54:42Z", "message": "Cleanup jvm interop gen related classes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0ef125d4662dbbdf1e73191e383d144a3113285d", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/0ef125d4662dbbdf1e73191e383d144a3113285d", "committedDate": "2020-02-18T09:55:03Z", "message": "Merge branch 'jbal-be-rewrite' of https://github.com/ballerina-platform/ballerina-lang into jbal-be-rewrite"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ca2b9ecdbf8414013e1f9e80014363b2d1194e57", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/ca2b9ecdbf8414013e1f9e80014363b2d1194e57", "committedDate": "2020-02-18T10:06:54Z", "message": "Fix casting issue and clean unused vars"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a54254080e5293f8d72c7a3d8b7faa7115fdd412", "author": {"user": {"login": "manuranga", "name": "manuranga perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a54254080e5293f8d72c7a3d8b7faa7115fdd412", "committedDate": "2020-02-18T10:11:48Z", "message": "Merge pull request #21136 from Kishanthan/jbal-be-rewrite\n\nCleanup jvm interop gen related classes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0013449bbbf00342dbbd373414b497a0f9d039de", "author": {"user": {"login": "manuranga", "name": "manuranga perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/0013449bbbf00342dbbd373414b497a0f9d039de", "committedDate": "2020-02-18T11:16:51Z", "message": "Fix visitMax issue for empty function codegen"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3f0cecdf78082e397f94ef511a3d0444d314526f", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3f0cecdf78082e397f94ef511a3d0444d314526f", "committedDate": "2020-02-18T11:20:39Z", "message": "Merge pull request #21138 from manuranga/jbal-be-rewrite\n\nFix visitMax issue for empty function codegen"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ca82a0f0480014197ca70bf8031998dd3bb6dfb2", "author": {"user": {"login": "manuranga", "name": "manuranga perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/ca82a0f0480014197ca70bf8031998dd3bb6dfb2", "committedDate": "2020-02-18T11:36:03Z", "message": "Use symbol to lookup java method names"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6aeae4539841a31cd0c592db89892942b2d58c43", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6aeae4539841a31cd0c592db89892942b2d58c43", "committedDate": "2020-02-18T11:40:51Z", "message": "Merge pull request #21139 from manuranga/jbal-be-rewrite\n\nUse symbol to lookup java method names"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d84982938d4a2be8b2f1c4cbeb9bbb04b498bfc7", "author": {"user": {"login": "manuranga", "name": "manuranga perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/d84982938d4a2be8b2f1c4cbeb9bbb04b498bfc7", "committedDate": "2020-02-18T14:11:16Z", "message": "Fix visit max from opt-prams gen"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "409cfdc2a1da5d14ed7f996c46ba3ccfad56fd95", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/409cfdc2a1da5d14ed7f996c46ba3ccfad56fd95", "committedDate": "2020-02-19T04:06:35Z", "message": "Merge pull request #21140 from manuranga/jbal-be-rewrite\n\nFix visit max from opt-prams gen"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c69288be9bd379e92aacb5d7171487de50cdfbd7", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c69288be9bd379e92aacb5d7171487de50cdfbd7", "committedDate": "2020-02-19T05:56:24Z", "message": "Clean and format code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "390c3db7efdad7a2c04e20b4cce4c13d4854b88a", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/390c3db7efdad7a2c04e20b4cce4c13d4854b88a", "committedDate": "2020-02-19T07:35:53Z", "message": "Make obvious static methods private"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "93c50a694bfe0f9cb5d505fe23f55511d6538d1c", "author": {"user": {"login": "manuranga", "name": "manuranga perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/93c50a694bfe0f9cb5d505fe23f55511d6538d1c", "committedDate": "2020-02-19T08:27:49Z", "message": "Fix issue when calling functions with args"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1ee43ca792aa3116a0acf6820a2db60032661cad", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1ee43ca792aa3116a0acf6820a2db60032661cad", "committedDate": "2020-02-19T09:02:01Z", "message": "Merge pull request #21148 from manuranga/jbal-be-rewrite\n\nFix issue when calling functions with args"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6c972af5f7a4c85e6abb50d2ea58871b6b142715", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6c972af5f7a4c85e6abb50d2ea58871b6b142715", "committedDate": "2020-02-19T09:02:56Z", "message": "Fix moduleInit return variable missing issue"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0ef43a8f686f14fe263221a58a8e88174bde9324", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/0ef43a8f686f14fe263221a58a8e88174bde9324", "committedDate": "2020-02-19T09:07:00Z", "message": "Merge with upstream and fix conflicts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3e78dfac344c175ae579e3aed688b7ca345a65c4", "author": {"user": {"login": "manuranga", "name": "manuranga perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3e78dfac344c175ae579e3aed688b7ca345a65c4", "committedDate": "2020-02-19T09:11:04Z", "message": "Merge pull request #21149 from Kishanthan/jbal-be-rewrite\n\nFix moduleInit return variable missing issue"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f345258733f4cc6c3b5e735c4e9cbfaa8433c834", "author": {"user": {"login": "manuranga", "name": "manuranga perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f345258733f4cc6c3b5e735c4e9cbfaa8433c834", "committedDate": "2020-02-19T10:38:59Z", "message": "Re-fix calling imported functions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3caf9b70a0f223c4388798cda71dc1d69d6f6ff7", "author": {"user": {"login": "manuranga", "name": "manuranga perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3caf9b70a0f223c4388798cda71dc1d69d6f6ff7", "committedDate": "2020-02-19T10:39:26Z", "message": "Fix parms missing in local var list"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5c1b93e33554e3758b9fb6b450d73dccf5bb3edb", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/5c1b93e33554e3758b9fb6b450d73dccf5bb3edb", "committedDate": "2020-02-19T10:45:10Z", "message": "Merge pull request #21156 from manuranga/jbal-be-rewrite\n\nFix parms missing in local var list and calling imported functions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9cf344c9ba9fd4ef3516bb41d753243a28679ce0", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/9cf344c9ba9fd4ef3516bb41d753243a28679ce0", "committedDate": "2020-02-19T11:57:03Z", "message": "Clean BalToJVMIndexMap class"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "05c8eb19322150fcdeb6482ca722fac4434ba236", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/05c8eb19322150fcdeb6482ca722fac4434ba236", "committedDate": "2020-02-19T11:57:56Z", "message": "Remove adding syn boolean arg to bvmParamTypes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "36ba2d7a5c9fb93fa9df065cf8a16f3b7587daac", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/36ba2d7a5c9fb93fa9df065cf8a16f3b7587daac", "committedDate": "2020-02-20T05:32:28Z", "message": "Add extended ASM ClassWriter to codegen pkg"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "02f4837090ac7e89f9a8fe7bae5fa40e9a6ab81c", "author": {"user": {"login": "manuranga", "name": "manuranga perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/02f4837090ac7e89f9a8fe7bae5fa40e9a6ab81c", "committedDate": "2020-02-20T05:37:36Z", "message": "Merge pull request #21168 from Kishanthan/jbal-be-rewrite\n\nAdd extended ASM ClassWriter to codegen pkg"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "44370872f4a159034c24762d8a3688f06adf2761", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/44370872f4a159034c24762d8a3688f06adf2761", "committedDate": "2020-02-20T06:56:44Z", "message": "Enable passing test cases"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b190bed11761fa0cd80896581f5b5ed7e4197cfc", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b190bed11761fa0cd80896581f5b5ed7e4197cfc", "committedDate": "2020-02-20T06:57:29Z", "message": "Fix float type constant load issue"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a6e516ff29903256af159337763c4f8a2f43e47c", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a6e516ff29903256af159337763c4f8a2f43e47c", "committedDate": "2020-02-20T06:57:46Z", "message": "Add missing eof lines"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5b5d5be5b4f40fa5eeb3e60687860a9f1b4ea5d1", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/5b5d5be5b4f40fa5eeb3e60687860a9f1b4ea5d1", "committedDate": "2020-02-20T06:57:55Z", "message": "Merge branch 'jbal-be-rewrite' of https://github.com/ballerina-platform/ballerina-lang into jbal-be-rewrite"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "889d78d9cac2facf728ef6425cb1a5887de0784b", "author": {"user": {"login": "manuranga", "name": "manuranga perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/889d78d9cac2facf728ef6425cb1a5887de0784b", "committedDate": "2020-02-20T07:21:26Z", "message": "Fix type name being null"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "030e26c8fb087a834f751c1e320e16c7224ef0bd", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/030e26c8fb087a834f751c1e320e16c7224ef0bd", "committedDate": "2020-02-20T08:27:21Z", "message": "Add missing LESS_EQUAL instruction"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "887130be226b5fff5f9c18142cbef55b67790d79", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/887130be226b5fff5f9c18142cbef55b67790d79", "committedDate": "2020-02-20T08:28:36Z", "message": "Merge pull request #21177 from manuranga/jbal-be-rewrite\n\nFix type name being null"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e06980dc179ffadd2b9da874910bd2cde37a0270", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e06980dc179ffadd2b9da874910bd2cde37a0270", "committedDate": "2020-02-20T08:28:46Z", "message": "Merge branch 'jbal-be-rewrite' of https://github.com/ballerina-platform/ballerina-lang into jbal-be-rewrite"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6ffe8c01b36b7533a547795f9129d075f45e95f4", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6ffe8c01b36b7533a547795f9129d075f45e95f4", "committedDate": "2020-02-20T09:40:40Z", "message": "Use correct object type name"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "19d6d9f63e04109ad60276130d6194c42bba2b1f", "author": {"user": {"login": "manuranga", "name": "manuranga perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/19d6d9f63e04109ad60276130d6194c42bba2b1f", "committedDate": "2020-02-20T10:12:09Z", "message": "Fix record init"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "26469e319000905ccc47071d9e64b5e371ef0ff0", "author": {"user": {"login": "manuranga", "name": "manuranga perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/26469e319000905ccc47071d9e64b5e371ef0ff0", "committedDate": "2020-02-20T10:31:40Z", "message": "Merge branch 'jbal-be-rewrite' of github.com:ballerina-platform/ballerina-lang into jbal-be-rewrite"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "95f25a3ecae9b26f5277f75d7f861971d8b5dddd", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/95f25a3ecae9b26f5277f75d7f861971d8b5dddd", "committedDate": "2020-02-21T06:00:05Z", "message": "Use instanceof for BServiceType to avoid conflicts with BObjectType"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9517dfc3aa36683a59bdfb629cb3ecd95c89eace", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/9517dfc3aa36683a59bdfb629cb3ecd95c89eace", "committedDate": "2020-02-21T06:00:43Z", "message": "Enable all unit tests in testng.xml"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0262851afd1b1cfcc64071c404ed1cf8741bc8dd", "author": {"user": {"login": "manuranga", "name": "manuranga perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/0262851afd1b1cfcc64071c404ed1cf8741bc8dd", "committedDate": "2020-02-21T06:05:00Z", "message": "Merge pull request #21176 from Kishanthan/jbal-be-rewrite\n\nFix float type constant load issue"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "873521a14cf195b11c33c6290ffab434ec03a2ae", "author": {"user": {"login": "manuranga", "name": "manuranga perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/873521a14cf195b11c33c6290ffab434ec03a2ae", "committedDate": "2020-02-21T06:08:05Z", "message": "Merge branch 'jbal-be-rewrite' of github.com:ballerina-platform/ballerina-lang into jbal-be-rewrite"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f12d237d1cd1459e069c54aac6cddac84dc913e2", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f12d237d1cd1459e069c54aac6cddac84dc913e2", "committedDate": "2020-02-21T06:10:49Z", "message": "Merge pull request #21191 from manuranga/jbal-be-rewrite\n\nFix record init"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e2ab2a3c51ef3e852b3095b96693012f431193c8", "author": {"user": {"login": "manuranga", "name": "manuranga perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e2ab2a3c51ef3e852b3095b96693012f431193c8", "committedDate": "2020-02-21T09:08:14Z", "message": "Fix record value put"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eb833495eb05ee75d15fbd8baf4c087d79730819", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/eb833495eb05ee75d15fbd8baf4c087d79730819", "committedDate": "2020-02-21T09:10:42Z", "message": "Merge pull request #21195 from manuranga/jbal-be-rewrite\n\nFix record value put"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "adac4b947e7701830968226844b18695ca7582e1", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/adac4b947e7701830968226844b18695ca7582e1", "committedDate": "2020-02-21T09:51:10Z", "message": "Merge with master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "af9d4e1b4f15cd08ff561ccbc850559a38604bbc", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/af9d4e1b4f15cd08ff561ccbc850559a38604bbc", "committedDate": "2020-02-21T09:57:51Z", "message": "Code cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2586d49c75845f2b32c88acdb9d978fe60a8f732", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2586d49c75845f2b32c88acdb9d978fe60a8f732", "committedDate": "2020-02-21T10:00:15Z", "message": "Use same testng file from master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c01a82d53e42de7975911abf810eec399eb37ede", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c01a82d53e42de7975911abf810eec399eb37ede", "committedDate": "2020-02-21T10:00:49Z", "message": "Merge branch 'jbal-be-rewrite' of https://github.com/ballerina-platform/ballerina-lang into jbal-merge-master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e595bb0773cee69a0a7b1a55780cfd518e06bf5f", "author": {"user": {"login": "manuranga", "name": "manuranga perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e595bb0773cee69a0a7b1a55780cfd518e06bf5f", "committedDate": "2020-02-24T12:19:18Z", "message": "Fix byte const load"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1764beb454abb3c7927279f01ff427e34b807888", "author": {"user": {"login": "manuranga", "name": "manuranga perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1764beb454abb3c7927279f01ff427e34b807888", "committedDate": "2020-02-24T12:20:00Z", "message": "Make unit tests reset after each compilation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "27fa2c6d6addb5b8524cb804f7e31df1ca52e501", "author": {"user": {"login": "manuranga", "name": "manuranga perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/27fa2c6d6addb5b8524cb804f7e31df1ca52e501", "committedDate": "2020-02-24T12:49:01Z", "message": "Fix error in test exception printing"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0cb4f5f9f333633d571957748cd3a19206fbae7f", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/0cb4f5f9f333633d571957748cd3a19206fbae7f", "committedDate": "2020-02-25T04:31:22Z", "message": "Merge pull request #21219 from manuranga/jbal-be-rewrite\n\nbackend migration fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c8daaa593a52d247d5e422d7105589ab21ce1bc2", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c8daaa593a52d247d5e422d7105589ab21ce1bc2", "committedDate": "2020-02-25T04:38:34Z", "message": "Merge branch 'jbal-be-rewrite' of https://github.com/ballerina-platform/ballerina-lang into jbal-merge-master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "93d54a60d12b3840546483b7701da622b7d859d0", "author": {"user": {"login": "manuranga", "name": "manuranga perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/93d54a60d12b3840546483b7701da622b7d859d0", "committedDate": "2020-02-25T08:51:12Z", "message": "Fix imported type object creation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c6b924acac284aef6ecef535dfb1b73dc6aa24a1", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c6b924acac284aef6ecef535dfb1b73dc6aa24a1", "committedDate": "2020-02-25T08:53:45Z", "message": "Merge pull request #21229 from manuranga/jbal-be-rewrite\n\nFix imported type object creation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3744c2bbe5f9e2f2788469d2a402045aeb79eb5e", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3744c2bbe5f9e2f2788469d2a402045aeb79eb5e", "committedDate": "2020-02-25T08:54:19Z", "message": "Merge branch 'jbal-be-rewrite' of https://github.com/ballerina-platform/ballerina-lang into jbal-merge-master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4c5542f61b593c4cd893b30f4d451cb443180e91", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/4c5542f61b593c4cd893b30f4d451cb443180e91", "committedDate": "2020-02-25T12:24:10Z", "message": "Add pkg import codegen logic"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "13b33837522834d09234c6859da3154698405bfa", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/13b33837522834d09234c6859da3154698405bfa", "committedDate": "2020-02-25T12:24:52Z", "message": "Add generating code for imports in test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d948d0d710dd9df6c79f48bc5ece5c368c5811d6", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/d948d0d710dd9df6c79f48bc5ece5c368c5811d6", "committedDate": "2020-02-25T12:25:09Z", "message": "Remove empty line"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "17a900ed4720ab4e923272b7907b20afcb7b225c", "author": {"user": {"login": "manuranga", "name": "manuranga perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/17a900ed4720ab4e923272b7907b20afcb7b225c", "committedDate": "2020-02-25T12:45:36Z", "message": "Merge pull request #21241 from Kishanthan/jbal-merge-master\n\nAdd pkg import codegen logic and synch up with master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2058ae6dedaf20242126f4998df0b8903219c740", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2058ae6dedaf20242126f4998df0b8903219c740", "committedDate": "2020-02-26T05:59:46Z", "message": "Reorder adding argument to local var"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "82b2aebc1f8dd564d643fdea00a23d2688c8e510", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/82b2aebc1f8dd564d643fdea00a23d2688c8e510", "committedDate": "2020-02-26T06:01:00Z", "message": "Fixes related to using correct local var and srevice type check"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "99398de8cc357830d968f021797e7b29383277b3", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/99398de8cc357830d968f021797e7b29383277b3", "committedDate": "2020-02-26T06:01:16Z", "message": "Merge branch 'jbal-be-rewrite' of https://github.com/ballerina-platform/ballerina-lang into jbal-merge-master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c02d84d5eba3972ebeb856771eec2f49cdb6d495", "author": {"user": {"login": "manuranga", "name": "manuranga perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c02d84d5eba3972ebeb856771eec2f49cdb6d495", "committedDate": "2020-02-26T06:25:37Z", "message": "Merge pull request #21254 from Kishanthan/jbal-merge-master\n\nFixes related to using correct local var and srevice type check"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8d2f53103ecf353d62656bd6505a746d1db9dd1b", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/8d2f53103ecf353d62656bd6505a746d1db9dd1b", "committedDate": "2020-02-26T09:19:51Z", "message": "Add function param sorting logic"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2cb99d1794db9e5dca65906e9b7e3ea84c4f2542", "author": {"user": {"login": "manuranga", "name": "manuranga perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2cb99d1794db9e5dca65906e9b7e3ea84c4f2542", "committedDate": "2020-02-26T09:43:00Z", "message": "Fix constants code gen (#21269)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "30018f9045f4281db9271253886271b0ef6e911e", "author": {"user": {"login": "manuranga", "name": "manuranga perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/30018f9045f4281db9271253886271b0ef6e911e", "committedDate": "2020-02-27T06:05:20Z", "message": "Fix transaction import code gen"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d3f724163061cafb2c6e1398d6812739b375a1f6", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/d3f724163061cafb2c6e1398d6812739b375a1f6", "committedDate": "2020-02-27T06:14:10Z", "message": "Fix finite type loac constant value issue"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8272eff95a4e74af8452ffe37be61f2b56baedb9", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/8272eff95a4e74af8452ffe37be61f2b56baedb9", "committedDate": "2020-02-27T06:15:01Z", "message": "Include imported standalone modules jars to jar cache"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "57d73774039fc01967552f1ed87346f752e1b295", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/57d73774039fc01967552f1ed87346f752e1b295", "committedDate": "2020-02-27T06:15:18Z", "message": "Merge branch 'jbal-be-rewrite' of https://github.com/ballerina-platform/ballerina-lang into jbal-merge-master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2360f6dd539b38c59d30738adbe591bc825e6b8a", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2360f6dd539b38c59d30738adbe591bc825e6b8a", "committedDate": "2020-02-27T06:22:20Z", "message": "Merge pull request #21312 from manuranga/jbal-be-rewrite\n\nFix transaction import code gen"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "86d08e1fcf1d131fbe01c40644f618f8f183f72d", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/86d08e1fcf1d131fbe01c40644f618f8f183f72d", "committedDate": "2020-02-27T06:25:05Z", "message": "Merge branch 'jbal-be-rewrite' of https://github.com/ballerina-platform/ballerina-lang into jbal-merge-master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b5f32f68d8ff90abb650e0abf93e119e15059110", "author": {"user": {"login": "manuranga", "name": "manuranga perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b5f32f68d8ff90abb650e0abf93e119e15059110", "committedDate": "2020-02-27T06:42:51Z", "message": "Fix duplicate stop methods issue"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8dcd4e32f2f3d625c10fa94354d7eaea7a3003e5", "author": {"user": {"login": "manuranga", "name": "manuranga perera"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/8dcd4e32f2f3d625c10fa94354d7eaea7a3003e5", "committedDate": "2020-02-27T06:51:31Z", "message": "Merge pull request #21316 from Kishanthan/jbal-merge-master\n\nAdd function param sorting logic and many other fixes"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4108, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}