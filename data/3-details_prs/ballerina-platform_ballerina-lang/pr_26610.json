{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTEwMjg5MTg3", "number": 26610, "title": "Add isolated module variable declaration parsing support", "bodyText": "Purpose\nAdd parsing support for isolated module variable declaration\nFixes #26068\nApproach\nN/A\nSamples\nN/A\nRemarks\nAmbiguity Resolution (for object type and function type)\ncase I\n// First isolated keyword is belong to the module variable declaration\n// where as second isolated keyword is belong to the type descriptor\nisolated isolated object { } a = b;\ncase II\n// Isolated keyword is belong to the module variable declaration\nisolated object { } a = b;\ncase III\n// Since following is a non initialized module variable declaration, \n// isolated keyword is belong to the type descriptor\nisolated object { } a;\nCheck List\n\n Read the Contributing Guide\n Updated Change Log\n Checked Tooling Support (#)\n Added necessary tests\n\n Unit Tests\n Spec Conformance Tests\n Integration Tests\n Ballerina By Example Tests\n\n\n Increased Test Coverage\n Added necessary documentation\n\n API documentation\n Module documentation in Module.md files\n Ballerina By Examples", "createdAt": "2020-10-26T20:30:27Z", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26610", "merged": true, "mergeCommit": {"oid": "ddbffb39e7017161bab346317173c5df2238c947"}, "closed": true, "closedAt": "2020-11-04T06:08:03Z", "author": {"login": "lochana-chathura"}, "timelineItems": {"totalCount": 19, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdVXBQZAH2gAyNTEwMjg5MTg3OjYwMTQzZjA0ZDIyZTZlOTUwMDRjM2YxZDQ2OGFjMWNhYTExZDNmYzY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdZHeVwgFqTUyMzA2NDcxOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "60143f04d22e6e95004c3f1d468ac1caa11d3fc6", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/60143f04d22e6e95004c3f1d468ac1caa11d3fc6", "committedDate": "2020-10-23T13:58:50Z", "message": "Modify syntax tree and test cases"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "66f2b172de2621dcaf4ee954a3db621b86e9b143", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/66f2b172de2621dcaf4ee954a3db621b86e9b143", "committedDate": "2020-10-26T20:06:32Z", "message": "Add isolated module var declaration parsing support"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "150f92609a578d651bd8c0503ed0fe1b636d5f8c", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/150f92609a578d651bd8c0503ed0fe1b636d5f8c", "committedDate": "2020-10-27T10:01:53Z", "message": "Refactor parser qualifier validation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d527a6166714d0202e28f1b9b456e8d67f9f98ed", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/d527a6166714d0202e28f1b9b456e8d67f9f98ed", "committedDate": "2020-10-27T10:15:19Z", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into isolated-module-var\n\n\u0001 Conflicts:\n\u0001\tcompiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/parser/BLangNodeTransformer.java\n\u0001\tmisc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/FormattingTreeModifier.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f757890e5566f67857fe6e01007b45fd2a4326fb", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f757890e5566f67857fe6e01007b45fd2a4326fb", "committedDate": "2020-10-27T11:12:45Z", "message": "Revert auto formatting changes when merging"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "00bd03d44814aa909cbb1f89ce1c1cac14e89778", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/00bd03d44814aa909cbb1f89ce1c1cac14e89778", "committedDate": "2020-10-27T14:18:40Z", "message": "Fix few parsing issues"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a51c0896c4418c154dc264b5c2b1354fca6755fc", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a51c0896c4418c154dc264b5c2b1354fca6755fc", "committedDate": "2020-10-27T15:53:56Z", "message": "Fix isolated object unit tests"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "866638d743b67703a81a3ff1995f6a1a96fe6d57", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/866638d743b67703a81a3ff1995f6a1a96fe6d57", "committedDate": "2020-10-27T14:19:54Z", "message": "Fix testIsolatedObjectIsolationNegative test"}, "afterCommit": {"oid": "a51c0896c4418c154dc264b5c2b1354fca6755fc", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a51c0896c4418c154dc264b5c2b1354fca6755fc", "committedDate": "2020-10-27T15:53:56Z", "message": "Fix isolated object unit tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE5NTE0NzM1", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26610#pullrequestreview-519514735", "createdAt": "2020-10-29T10:14:37Z", "commit": {"oid": "a51c0896c4418c154dc264b5c2b1354fca6755fc"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxMDoxNDozN1rOHqU_bA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwNDoxNzoyNVrOHr11UQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDE0NjE1Ng==", "bodyText": "Since this method do both get+remove from the list, shall we call it extractVarDeclQualifiers()?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26610#discussion_r514146156", "createdAt": "2020-10-29T10:14:37Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -828,23 +822,72 @@ private STNode parseTopLevelNode(STNode metadata, STNode publicQualifier, List<S\n                     // If the solution is {@link Action#KEEP}, that means next immediate token is\n                     // at the correct place, but some token after that is not. There only one such\n                     // cases here, which is the `case IDENTIFIER_TOKEN`. So accept it, and continue.\n-                    reportInvalidQualifierList(qualifiers);\n-                    return parseModuleVarDecl(metadata, publicQualifier);\n+                    reportInvalidQualifier(publicQualifier);\n+                    return parseModuleVarDecl(metadata, qualifiers);\n                 }\n \n                 return parseTopLevelNode(metadata, publicQualifier, qualifiers);\n         }\n     }\n \n-    private STNode parseModuleVarDecl(STNode metadata, STNode qualifier) {\n-        List<STNode> topLevelQualifiers = new ArrayList<>();\n-        return parseModuleVarDecl(metadata, qualifier, topLevelQualifiers);\n+    private STNode parseModuleVarDecl(STNode metadata) {\n+        List<STNode> emptyList = new ArrayList<>();\n+        return parseVariableDecl(metadata, emptyList, emptyList, true);\n     }\n \n-    private STNode parseModuleVarDecl(STNode metadata, STNode qualifier, List<STNode> qualifiers) {\n-        reportInvalidQualifier(qualifier);\n-        STNode finalKeyword = STNodeFactory.createEmptyNode();\n-        return parseVariableDecl(metadata, finalKeyword, qualifiers, true);\n+    /**\n+     * <p>\n+     * Parse module variable declaration.\n+     * </p>\n+     *\n+     * <code>\n+     * module-var-decl := module-init-var-decl | module-no-init-var-decl\n+     * <br/><br/>\n+     * module-init-var-decl := metadata isolated-final-quals typed-binding-pattern = expression ;\n+     * <br/><br/>\n+     * module-no-init-var-decl := metadata [final] type-descriptor variable-name ;\n+     * <br/><br/>\n+     * isolated-final-quals := (final | isolated-qual)*\n+     * </code>\n+     *\n+     * @param metadata           Preceding metadata\n+     * @param topLevelQualifiers Preceding top level qualifiers\n+     * @return Parsed node\n+     */\n+    private STNode parseModuleVarDecl(STNode metadata, List<STNode> topLevelQualifiers) {\n+        List<STNode> varDeclQuals = getVarDeclQualifiers(topLevelQualifiers);\n+        return parseVariableDecl(metadata, varDeclQuals, topLevelQualifiers, true);\n+    }\n+\n+    private List<STNode> getVarDeclQualifiers(List<STNode> qualifiers) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a51c0896c4418c154dc264b5c2b1354fca6755fc"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDE1MDUzOQ==", "bodyText": "Why do we need to remove this?\nI feel handling duplicate qualifiers in one place would be cleaner.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26610#discussion_r514150539", "createdAt": "2020-10-29T10:21:55Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -942,43 +982,32 @@ private boolean isObjectMemberQualifier(SyntaxKind tokenKind) {\n     private void parseTopLevelQualifiers(List<STNode> qualifiers) {\n         while (isTopLevelQualifier(peek().kind)) {\n             STToken qualifier = consume();\n-            if (isNodeWithSyntaxKindInList(qualifiers, qualifier.kind)) {\n-                updateLastNodeInListOrAddInvalidNodeToNextToken(qualifiers, qualifier,\n-                        DiagnosticErrorCode.ERROR_DUPLICATE_QUALIFIER, qualifier.text());\n-            } else {\n-                qualifiers.add(qualifier);\n-            }\n+            qualifiers.add(qualifier);\n         }\n     }\n \n     private void parseTypeDescQualifiers(List<STNode> qualifiers) {\n         while (isTypeDescQualifier(peek().kind)) {\n             STToken qualifier = consume();\n-            if (isNodeWithSyntaxKindInList(qualifiers, qualifier.kind)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a51c0896c4418c154dc264b5c2b1354fca6755fc"}, "originalPosition": 238}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDE1MjY1NA==", "bodyText": "Can we send all qualifiers in a single list?\nThen we don't have to do the null checks either in the downstream code", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26610#discussion_r514152654", "createdAt": "2020-10-29T10:25:40Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -991,73 +1020,66 @@ private STNode parseFuncDefinition(STNode metadata, boolean isObjectMember, STNo\n      * function-type-descriptor := `function` function-signature\n      * </code>\n      *\n-     * @param context Parsing context\n      * @param metadata Preceding metadata\n+     * @param visibilityQualifier\n      * @param qualifiers Preceding visibility qualifier\n      * @param isObjectMember Whether object member or not\n      * @param isObjectTypeDesc Whether object type or not\n      * @return Parsed node\n      */\n-    private STNode parseFuncDefOrFuncTypeDesc(ParserRuleContext context, STNode metadata, List<STNode> qualifiers,\n+    private STNode parseFuncDefOrFuncTypeDesc(STNode metadata, STNode visibilityQualifier, List<STNode> qualifiers,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a51c0896c4418c154dc264b5c2b1354fca6755fc"}, "originalPosition": 287}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDE1NDY5Ng==", "bodyText": "Better to rename isNodeWithSyntaxKindInList to isDuplicateQualifier", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26610#discussion_r514154696", "createdAt": "2020-10-29T10:29:08Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -991,73 +1020,66 @@ private STNode parseFuncDefinition(STNode metadata, boolean isObjectMember, STNo\n      * function-type-descriptor := `function` function-signature\n      * </code>\n      *\n-     * @param context Parsing context\n      * @param metadata Preceding metadata\n+     * @param visibilityQualifier\n      * @param qualifiers Preceding visibility qualifier\n      * @param isObjectMember Whether object member or not\n      * @param isObjectTypeDesc Whether object type or not\n      * @return Parsed node\n      */\n-    private STNode parseFuncDefOrFuncTypeDesc(ParserRuleContext context, STNode metadata, List<STNode> qualifiers,\n+    private STNode parseFuncDefOrFuncTypeDesc(STNode metadata, STNode visibilityQualifier, List<STNode> qualifiers,\n                                               boolean isObjectMember, boolean isObjectTypeDesc) {\n-        STNode qualifierList;\n-        // TODO: remove validation at this level when syncing to service-typing branch\n-        if (context == ParserRuleContext.TOP_LEVEL_FUNC_DEF_OR_FUNC_TYPE_DESC) {\n-            qualifierList = createFuncDefNodeList(qualifiers);\n-        } else {\n-            qualifierList = createMethodQualNodeList(qualifiers);\n-        }\n-        return parseFuncDefOrFuncTypeDesc(metadata, qualifierList, isObjectMember, isObjectTypeDesc);\n+        startContext(ParserRuleContext.FUNC_DEF_OR_FUNC_TYPE);\n+        STNode functionKeyword = parseFunctionKeyword();\n+        STNode funcDefOrType = parseFunctionKeywordRhs(metadata, visibilityQualifier, qualifiers, functionKeyword,\n+                isObjectMember, isObjectTypeDesc);\n+        return funcDefOrType;\n     }\n \n     private STNode createFuncDefNodeList(List<STNode> qualifierList) {\n         // This method is temporary. Will be removed when syncing to service-typing branch\n         // Validate qualifiers and create a STNodeList\n-        for (int i = 0; i < qualifierList.size();) {\n+        List<STNode> validatedList = new ArrayList<>();\n+\n+        for (int i = 0; i < qualifierList.size(); i++) {\n             STNode qualifier = qualifierList.get(i);\n-            if (isValidFuncDefQualifier(qualifier.kind)) {\n-                i++;\n-                continue;\n-            }\n+            int nextIndex = i + 1;\n \n-            qualifierList.remove(i);\n-            if (qualifierList.size() == i) {\n-                addInvalidNodeToNextToken(qualifier, DiagnosticErrorCode.ERROR_QUALIFIER_NOT_ALLOWED,\n-                        ((STToken) qualifier).text());\n-            } else {\n-                STNode nextQual = qualifierList.remove(i);\n-                nextQual = SyntaxErrors.cloneWithLeadingInvalidNodeMinutiae(nextQual, qualifier,\n+            if (isNodeWithSyntaxKindInList(validatedList, qualifier.kind)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a51c0896c4418c154dc264b5c2b1354fca6755fc"}, "originalPosition": 325}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTcyNjI3NA==", "bodyText": "Theres a qualifier validation at the start of this function. Can we handle this also in the same block?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26610#discussion_r515726274", "createdAt": "2020-11-02T03:41:47Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -1197,72 +1207,78 @@ private STNode parseReturnTypeDescRhs(STNode metadata, STNode functionKeyword, S\n         // Function definition cannot have missing param-names. So validate it.\n         funcSignature = validateAndGetFuncParams((STFunctionSignatureNode) funcSignature);\n \n-        STNode funcDef = createFuncDefOrMethodDecl(metadata, functionKeyword, name, funcSignature, qualifiers,\n+        // TODO: remove following block when syncing to service-typing branch\n+        if (visibilityQualifier != null) {\n+            qualifiers.add(0, visibilityQualifier);\n+        }\n+        STNode qualifierNodeList;\n+        if (isObjectMember) {\n+            qualifierNodeList = createMethodQualNodeList(qualifiers);\n+        } else {\n+            qualifierNodeList = createFuncDefNodeList(qualifiers);\n+        }\n+\n+        STNode funcDef = createFuncDefOrMethodDecl(metadata, functionKeyword, name, funcSignature, qualifierNodeList,\n                 isObjectMember, isObjectTypeDesc);\n         endContext();\n         return funcDef;\n     }\n \n-    private STNode parseVarDeclWithFunctionType(STNode functionKeyword, STNode funcSignature, STNode qualifiers,\n-                                                STNode metadata, boolean isObjectMember, boolean isObjectTypeDesc) {\n-        STNodeList qualifierList = (STNodeList) qualifiers;\n-        STNode visibilityQualifier = STNodeFactory.createEmptyNode();\n+    private STNode parseVarDeclWithFunctionType(STNode metadata, STNode visibilityQualifier, List<STNode> qualifiers,\n+                                                STNode functionKeyword, STNode funcSignature, boolean isObjectMember,\n+                                                boolean isObjectTypeDesc) {\n+        List<STNode> isolatedFinalQualifiers = new ArrayList<>();\n+        if (!isObjectMember) {\n+            isolatedFinalQualifiers = getVarDeclQualifiers(qualifiers);\n+        }\n+\n         List<STNode> validatedQualifierList = new ArrayList<>();\n \n         // qualifiers are only allowed in the following cases for func type desc.\n         // isolated and transactional qualifiers are allowed.\n         // public, private and remote qualifiers are allowed in object field.\n-        for (int position = 0; position < qualifierList.size(); position++) {\n-            STNode qualifier = qualifierList.get(position);\n+        for (int position = 0; position < qualifiers.size(); position++) {\n+            STNode qualifier = qualifiers.get(position);\n \n             if (qualifier.kind == SyntaxKind.ISOLATED_KEYWORD || qualifier.kind == SyntaxKind.TRANSACTIONAL_KEYWORD) {\n                 validatedQualifierList.add(qualifier);\n                 continue;\n             }\n \n-            if (isObjectMember) {\n-                if (isVisibilityQualifier(qualifier)) {\n-                    // public or private qualifier allowed in object field.\n-                    visibilityQualifier = qualifier;\n-                    continue;\n-                } else if (qualifier.kind == SyntaxKind.REMOTE_KEYWORD) {\n-                    validatedQualifierList.add(qualifier);\n-                    continue;\n-                }\n-            }\n-\n             functionKeyword = SyntaxErrors.cloneWithLeadingInvalidNodeMinutiae(functionKeyword, qualifier,\n                     DiagnosticErrorCode.ERROR_QUALIFIER_NOT_ALLOWED, ((STToken) qualifier).text());\n         }\n \n-        qualifiers = STNodeFactory.createNodeList(validatedQualifierList);\n-        STNode typeDesc = STNodeFactory.createFunctionTypeDescriptorNode(qualifiers, functionKeyword,\n+        STNode qualifierNodeList = STNodeFactory.createNodeList(validatedQualifierList);\n+        STNode typeDesc = STNodeFactory.createFunctionTypeDescriptorNode(qualifierNodeList, functionKeyword,\n                 funcSignature);\n \n         // Check if it is a complex type desc starting with function type.\n         typeDesc = parseComplexTypeDescriptor(typeDesc,\n                 ParserRuleContext.TOP_LEVEL_FUNC_DEF_OR_FUNC_TYPE_DESC, false);\n \n         if (isObjectMember) {\n-            STNode readonlyQualifier = STNodeFactory.createEmptyNode();\n+            STNode finalQualifier = STNodeFactory.createEmptyNode();\n             STNode fieldName = parseVariableName();\n-            return parseObjectFieldRhs(metadata, visibilityQualifier, readonlyQualifier, typeDesc, fieldName,\n+            return parseObjectFieldRhs(metadata, visibilityQualifier, finalQualifier, typeDesc, fieldName,\n                     isObjectTypeDesc);\n         }\n \n+        if (visibilityQualifier != null) {\n+            // Visibility qualifier is not allowed in the variable declaration\n+            STToken invalidQualifier = (STToken) visibilityQualifier;\n+            if (isolatedFinalQualifiers.isEmpty()) {\n+                typeDesc = SyntaxErrors.cloneWithLeadingInvalidNodeMinutiae(typeDesc, invalidQualifier,\n+                        DiagnosticErrorCode.ERROR_QUALIFIER_NOT_ALLOWED, invalidQualifier.text());\n+            } else {\n+                updateFirstNodeInListWithInvalidNode(isolatedFinalQualifiers, invalidQualifier,\n+                        DiagnosticErrorCode.ERROR_QUALIFIER_NOT_ALLOWED, invalidQualifier.text());\n+            }\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a51c0896c4418c154dc264b5c2b1354fca6755fc"}, "originalPosition": 570}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTcyNzE0MA==", "bodyText": "I feel this check should be moved to createFuncDefOrMethodDecl  method.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26610#discussion_r515727140", "createdAt": "2020-11-02T03:46:43Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -1197,72 +1207,78 @@ private STNode parseReturnTypeDescRhs(STNode metadata, STNode functionKeyword, S\n         // Function definition cannot have missing param-names. So validate it.\n         funcSignature = validateAndGetFuncParams((STFunctionSignatureNode) funcSignature);\n \n-        STNode funcDef = createFuncDefOrMethodDecl(metadata, functionKeyword, name, funcSignature, qualifiers,\n+        // TODO: remove following block when syncing to service-typing branch\n+        if (visibilityQualifier != null) {\n+            qualifiers.add(0, visibilityQualifier);\n+        }\n+        STNode qualifierNodeList;\n+        if (isObjectMember) {\n+            qualifierNodeList = createMethodQualNodeList(qualifiers);\n+        } else {\n+            qualifierNodeList = createFuncDefNodeList(qualifiers);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a51c0896c4418c154dc264b5c2b1354fca6755fc"}, "originalPosition": 491}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTcyODIxNA==", "bodyText": "This is a semantic validation. We don't need to handle that in the parser.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26610#discussion_r515728214", "createdAt": "2020-11-02T03:52:31Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -3553,26 +3563,139 @@ private STNode parseVarDeclRhs(STNode metadata, STNode finalKeyword, STNode type\n                     expr = parseActionOrExpression();\n                 }\n                 semicolon = parseSemicolon();\n+                hasVarInit = true;\n                 break;\n             case SEMICOLON_TOKEN:\n                 assign = STNodeFactory.createEmptyNode();\n                 expr = STNodeFactory.createEmptyNode();\n                 semicolon = parseSemicolon();\n                 break;\n             default:\n-                recover(nextToken, ParserRuleContext.VAR_DECL_STMT_RHS, metadata, finalKeyword, typedBindingPattern,\n-                        isModuleVar);\n-                return parseVarDeclRhs(metadata, finalKeyword, typedBindingPattern, isModuleVar);\n+                recover(nextToken, ParserRuleContext.VAR_DECL_STMT_RHS, metadata, isolatedFinalQualifiers,\n+                        typedBindingPattern, isModuleVar);\n+                return parseVarDeclRhs(metadata, isolatedFinalQualifiers, typedBindingPattern, isModuleVar);\n         }\n \n         endContext();\n         if (isModuleVar) {\n-            return STNodeFactory.createModuleVariableDeclarationNode(metadata, finalKeyword, typedBindingPattern,\n-                    assign, expr, semicolon);\n+            if (hasVarInit || isolatedFinalQualifiers.isEmpty()) {\n+                STNode isolatedFinalQualifierNode = STNodeFactory.createNodeList(isolatedFinalQualifiers);\n+                return STNodeFactory.createModuleVariableDeclarationNode(metadata, isolatedFinalQualifierNode,\n+                        typedBindingPattern, assign, expr, semicolon);\n+            }\n+\n+            // Only final qualifier is allowed for non initialized module var declaration", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a51c0896c4418c154dc264b5c2b1354fca6755fc"}, "originalPosition": 806}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTcyODgxNg==", "bodyText": "This method has become a bit too large. Shall we extract everything inside if (isModuleVar) {...} to a separate method?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26610#discussion_r515728816", "createdAt": "2020-11-02T03:55:41Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -3553,26 +3563,139 @@ private STNode parseVarDeclRhs(STNode metadata, STNode finalKeyword, STNode type\n                     expr = parseActionOrExpression();\n                 }\n                 semicolon = parseSemicolon();\n+                hasVarInit = true;\n                 break;\n             case SEMICOLON_TOKEN:\n                 assign = STNodeFactory.createEmptyNode();\n                 expr = STNodeFactory.createEmptyNode();\n                 semicolon = parseSemicolon();\n                 break;\n             default:\n-                recover(nextToken, ParserRuleContext.VAR_DECL_STMT_RHS, metadata, finalKeyword, typedBindingPattern,\n-                        isModuleVar);\n-                return parseVarDeclRhs(metadata, finalKeyword, typedBindingPattern, isModuleVar);\n+                recover(nextToken, ParserRuleContext.VAR_DECL_STMT_RHS, metadata, isolatedFinalQualifiers,\n+                        typedBindingPattern, isModuleVar);\n+                return parseVarDeclRhs(metadata, isolatedFinalQualifiers, typedBindingPattern, isModuleVar);\n         }\n \n         endContext();\n         if (isModuleVar) {\n-            return STNodeFactory.createModuleVariableDeclarationNode(metadata, finalKeyword, typedBindingPattern,\n-                    assign, expr, semicolon);\n+            if (hasVarInit || isolatedFinalQualifiers.isEmpty()) {\n+                STNode isolatedFinalQualifierNode = STNodeFactory.createNodeList(isolatedFinalQualifiers);\n+                return STNodeFactory.createModuleVariableDeclarationNode(metadata, isolatedFinalQualifierNode,\n+                        typedBindingPattern, assign, expr, semicolon);\n+            }\n+\n+            // Only final qualifier is allowed for non initialized module var declaration\n+\n+            // If type descriptor in the binding pattern is either object or function type\n+            // and qualifier list has isolated qualifier as the last token,\n+            // that isolated qualifier should be part of the type.\n+            STNode lastQualifier = isolatedFinalQualifiers.get(isolatedFinalQualifiers.size() - 1);\n+            if (lastQualifier.kind == SyntaxKind.ISOLATED_KEYWORD) {\n+                lastQualifier = isolatedFinalQualifiers.remove(isolatedFinalQualifiers.size() - 1);\n+                typedBindingPattern =\n+                        modifyTypedBindingPatternWithMissingQualifier(typedBindingPattern, lastQualifier);\n+            }\n+\n+            // Now the list can have only following possibilities\n+            // empty, final, isolated final\n+            if (!isolatedFinalQualifiers.isEmpty() &&\n+                    isNodeWithSyntaxKindInList(isolatedFinalQualifiers, SyntaxKind.ISOLATED_KEYWORD)) {\n+                STNode invalidIsolatedToken = isolatedFinalQualifiers.remove(0);\n+                updateFirstNodeInListWithInvalidNode(isolatedFinalQualifiers, invalidIsolatedToken,\n+                        DiagnosticErrorCode.ERROR_QUALIFIER_NOT_ALLOWED, ((STToken) invalidIsolatedToken).text());\n+            }\n+\n+            STNode isolatedFinalQualifierNode = STNodeFactory.createNodeList(isolatedFinalQualifiers);\n+            return STNodeFactory.createModuleVariableDeclarationNode(metadata, isolatedFinalQualifierNode,\n+                    typedBindingPattern, assign, expr, semicolon);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a51c0896c4418c154dc264b5c2b1354fca6755fc"}, "originalPosition": 830}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTczMDg0Mw==", "bodyText": "Duplicate qualifier validation should happen in a single place IMO", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26610#discussion_r515730843", "createdAt": "2020-11-02T04:06:13Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -3553,26 +3563,139 @@ private STNode parseVarDeclRhs(STNode metadata, STNode finalKeyword, STNode type\n                     expr = parseActionOrExpression();\n                 }\n                 semicolon = parseSemicolon();\n+                hasVarInit = true;\n                 break;\n             case SEMICOLON_TOKEN:\n                 assign = STNodeFactory.createEmptyNode();\n                 expr = STNodeFactory.createEmptyNode();\n                 semicolon = parseSemicolon();\n                 break;\n             default:\n-                recover(nextToken, ParserRuleContext.VAR_DECL_STMT_RHS, metadata, finalKeyword, typedBindingPattern,\n-                        isModuleVar);\n-                return parseVarDeclRhs(metadata, finalKeyword, typedBindingPattern, isModuleVar);\n+                recover(nextToken, ParserRuleContext.VAR_DECL_STMT_RHS, metadata, isolatedFinalQualifiers,\n+                        typedBindingPattern, isModuleVar);\n+                return parseVarDeclRhs(metadata, isolatedFinalQualifiers, typedBindingPattern, isModuleVar);\n         }\n \n         endContext();\n         if (isModuleVar) {\n-            return STNodeFactory.createModuleVariableDeclarationNode(metadata, finalKeyword, typedBindingPattern,\n-                    assign, expr, semicolon);\n+            if (hasVarInit || isolatedFinalQualifiers.isEmpty()) {\n+                STNode isolatedFinalQualifierNode = STNodeFactory.createNodeList(isolatedFinalQualifiers);\n+                return STNodeFactory.createModuleVariableDeclarationNode(metadata, isolatedFinalQualifierNode,\n+                        typedBindingPattern, assign, expr, semicolon);\n+            }\n+\n+            // Only final qualifier is allowed for non initialized module var declaration\n+\n+            // If type descriptor in the binding pattern is either object or function type\n+            // and qualifier list has isolated qualifier as the last token,\n+            // that isolated qualifier should be part of the type.\n+            STNode lastQualifier = isolatedFinalQualifiers.get(isolatedFinalQualifiers.size() - 1);\n+            if (lastQualifier.kind == SyntaxKind.ISOLATED_KEYWORD) {\n+                lastQualifier = isolatedFinalQualifiers.remove(isolatedFinalQualifiers.size() - 1);\n+                typedBindingPattern =\n+                        modifyTypedBindingPatternWithMissingQualifier(typedBindingPattern, lastQualifier);\n+            }\n+\n+            // Now the list can have only following possibilities\n+            // empty, final, isolated final\n+            if (!isolatedFinalQualifiers.isEmpty() &&\n+                    isNodeWithSyntaxKindInList(isolatedFinalQualifiers, SyntaxKind.ISOLATED_KEYWORD)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a51c0896c4418c154dc264b5c2b1354fca6755fc"}, "originalPosition": 821}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTczMTA3Mw==", "bodyText": "Method name modifyTypedBindingPatternWithMissingQualifier suggests you are updating the node with a missing qualifier, but here the qualifier is isolated", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26610#discussion_r515731073", "createdAt": "2020-11-02T04:07:43Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -3553,26 +3563,139 @@ private STNode parseVarDeclRhs(STNode metadata, STNode finalKeyword, STNode type\n                     expr = parseActionOrExpression();\n                 }\n                 semicolon = parseSemicolon();\n+                hasVarInit = true;\n                 break;\n             case SEMICOLON_TOKEN:\n                 assign = STNodeFactory.createEmptyNode();\n                 expr = STNodeFactory.createEmptyNode();\n                 semicolon = parseSemicolon();\n                 break;\n             default:\n-                recover(nextToken, ParserRuleContext.VAR_DECL_STMT_RHS, metadata, finalKeyword, typedBindingPattern,\n-                        isModuleVar);\n-                return parseVarDeclRhs(metadata, finalKeyword, typedBindingPattern, isModuleVar);\n+                recover(nextToken, ParserRuleContext.VAR_DECL_STMT_RHS, metadata, isolatedFinalQualifiers,\n+                        typedBindingPattern, isModuleVar);\n+                return parseVarDeclRhs(metadata, isolatedFinalQualifiers, typedBindingPattern, isModuleVar);\n         }\n \n         endContext();\n         if (isModuleVar) {\n-            return STNodeFactory.createModuleVariableDeclarationNode(metadata, finalKeyword, typedBindingPattern,\n-                    assign, expr, semicolon);\n+            if (hasVarInit || isolatedFinalQualifiers.isEmpty()) {\n+                STNode isolatedFinalQualifierNode = STNodeFactory.createNodeList(isolatedFinalQualifiers);\n+                return STNodeFactory.createModuleVariableDeclarationNode(metadata, isolatedFinalQualifierNode,\n+                        typedBindingPattern, assign, expr, semicolon);\n+            }\n+\n+            // Only final qualifier is allowed for non initialized module var declaration\n+\n+            // If type descriptor in the binding pattern is either object or function type\n+            // and qualifier list has isolated qualifier as the last token,\n+            // that isolated qualifier should be part of the type.\n+            STNode lastQualifier = isolatedFinalQualifiers.get(isolatedFinalQualifiers.size() - 1);\n+            if (lastQualifier.kind == SyntaxKind.ISOLATED_KEYWORD) {\n+                lastQualifier = isolatedFinalQualifiers.remove(isolatedFinalQualifiers.size() - 1);\n+                typedBindingPattern =\n+                        modifyTypedBindingPatternWithMissingQualifier(typedBindingPattern, lastQualifier);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a51c0896c4418c154dc264b5c2b1354fca6755fc"}, "originalPosition": 815}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTczMTQ4Ng==", "bodyText": "Qualifier extraction part is common to this and the method above this one. Can extract to a common method.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26610#discussion_r515731486", "createdAt": "2020-11-02T04:10:03Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -3553,26 +3563,139 @@ private STNode parseVarDeclRhs(STNode metadata, STNode finalKeyword, STNode type\n                     expr = parseActionOrExpression();\n                 }\n                 semicolon = parseSemicolon();\n+                hasVarInit = true;\n                 break;\n             case SEMICOLON_TOKEN:\n                 assign = STNodeFactory.createEmptyNode();\n                 expr = STNodeFactory.createEmptyNode();\n                 semicolon = parseSemicolon();\n                 break;\n             default:\n-                recover(nextToken, ParserRuleContext.VAR_DECL_STMT_RHS, metadata, finalKeyword, typedBindingPattern,\n-                        isModuleVar);\n-                return parseVarDeclRhs(metadata, finalKeyword, typedBindingPattern, isModuleVar);\n+                recover(nextToken, ParserRuleContext.VAR_DECL_STMT_RHS, metadata, isolatedFinalQualifiers,\n+                        typedBindingPattern, isModuleVar);\n+                return parseVarDeclRhs(metadata, isolatedFinalQualifiers, typedBindingPattern, isModuleVar);\n         }\n \n         endContext();\n         if (isModuleVar) {\n-            return STNodeFactory.createModuleVariableDeclarationNode(metadata, finalKeyword, typedBindingPattern,\n-                    assign, expr, semicolon);\n+            if (hasVarInit || isolatedFinalQualifiers.isEmpty()) {\n+                STNode isolatedFinalQualifierNode = STNodeFactory.createNodeList(isolatedFinalQualifiers);\n+                return STNodeFactory.createModuleVariableDeclarationNode(metadata, isolatedFinalQualifierNode,\n+                        typedBindingPattern, assign, expr, semicolon);\n+            }\n+\n+            // Only final qualifier is allowed for non initialized module var declaration\n+\n+            // If type descriptor in the binding pattern is either object or function type\n+            // and qualifier list has isolated qualifier as the last token,\n+            // that isolated qualifier should be part of the type.\n+            STNode lastQualifier = isolatedFinalQualifiers.get(isolatedFinalQualifiers.size() - 1);\n+            if (lastQualifier.kind == SyntaxKind.ISOLATED_KEYWORD) {\n+                lastQualifier = isolatedFinalQualifiers.remove(isolatedFinalQualifiers.size() - 1);\n+                typedBindingPattern =\n+                        modifyTypedBindingPatternWithMissingQualifier(typedBindingPattern, lastQualifier);\n+            }\n+\n+            // Now the list can have only following possibilities\n+            // empty, final, isolated final\n+            if (!isolatedFinalQualifiers.isEmpty() &&\n+                    isNodeWithSyntaxKindInList(isolatedFinalQualifiers, SyntaxKind.ISOLATED_KEYWORD)) {\n+                STNode invalidIsolatedToken = isolatedFinalQualifiers.remove(0);\n+                updateFirstNodeInListWithInvalidNode(isolatedFinalQualifiers, invalidIsolatedToken,\n+                        DiagnosticErrorCode.ERROR_QUALIFIER_NOT_ALLOWED, ((STToken) invalidIsolatedToken).text());\n+            }\n+\n+            STNode isolatedFinalQualifierNode = STNodeFactory.createNodeList(isolatedFinalQualifiers);\n+            return STNodeFactory.createModuleVariableDeclarationNode(metadata, isolatedFinalQualifierNode,\n+                    typedBindingPattern, assign, expr, semicolon);\n+        }\n+\n+        STNode finalKeyword;\n+        if (isolatedFinalQualifiers.isEmpty()) {\n+            finalKeyword = STNodeFactory.createEmptyNode();\n+        } else {\n+            finalKeyword = isolatedFinalQualifiers.get(0);\n         }\n         assert metadata.kind == SyntaxKind.LIST; // Annotations only\n-        return STNodeFactory.createVariableDeclarationNode(metadata, finalKeyword, typedBindingPattern, assign, expr,\n-                semicolon);\n+        return STNodeFactory.createVariableDeclarationNode(metadata, finalKeyword, typedBindingPattern, assign,\n+                expr, semicolon);\n+    }\n+\n+    private STNode modifyTypedBindingPatternWithMissingQualifier(STNode typedBindingPattern, STNode isolatedQualifier) {\n+        STTypedBindingPatternNode typedBindingPatternNode = (STTypedBindingPatternNode) typedBindingPattern;\n+        STNode typeDescriptor = typedBindingPatternNode.typeDescriptor;\n+        STNode bindingPattern = typedBindingPatternNode.bindingPattern;\n+        switch (typeDescriptor.kind) {\n+            case OBJECT_TYPE_DESC:\n+                typeDescriptor = modifyObjectTypeDescWithIsolatedQualifier(typeDescriptor, isolatedQualifier);\n+                break;\n+            case FUNCTION_TYPE_DESC:\n+                typeDescriptor = modifyFuncTypeDescWithIsolatedQualifier(typeDescriptor, isolatedQualifier);\n+                break;\n+            default:\n+                typeDescriptor = SyntaxErrors.cloneWithLeadingInvalidNodeMinutiae(typeDescriptor, isolatedQualifier);\n+        }\n+\n+        return STNodeFactory.createTypedBindingPatternNode(typeDescriptor, bindingPattern);\n+    }\n+\n+    /**\n+     * Add isolated qualifier to object type descriptor and modify the node.\n+     *\n+     * @param objectTypeDesc  Object type descriptor node to be modified\n+     * @param isolatedKeyword Isolated keyword to be made an object type qualifier\n+     * @return Modified node\n+     */\n+    private STNode modifyObjectTypeDescWithIsolatedQualifier(STNode objectTypeDesc, STNode isolatedKeyword) {\n+        List<STNode> newQualifierList = new ArrayList<>();\n+        newQualifierList.add(isolatedKeyword);\n+\n+        STObjectTypeDescriptorNode objectTypeDescriptorNode = (STObjectTypeDescriptorNode) objectTypeDesc;\n+        STNodeList qualifierList = (STNodeList) objectTypeDescriptorNode.objectTypeQualifiers;\n+\n+        for (int i = 0; i < qualifierList.size(); i++) {\n+            STNode qualifier = qualifierList.get(i);\n+            if (qualifier.kind == SyntaxKind.ISOLATED_KEYWORD) {\n+                updateLastNodeInListWithInvalidNode(newQualifierList, qualifier,\n+                        DiagnosticErrorCode.ERROR_DUPLICATE_QUALIFIER, ((STToken) qualifier).text());\n+            } else {\n+                newQualifierList.add(qualifier);\n+            }\n+        }\n+\n+        STNode newObjectTypeQualifiers = STNodeFactory.createNodeList(newQualifierList);\n+        return objectTypeDescriptorNode.modify(newObjectTypeQualifiers, objectTypeDescriptorNode.objectKeyword,\n+                objectTypeDescriptorNode.openBrace, objectTypeDescriptorNode.members,\n+                objectTypeDescriptorNode.closeBrace);\n+    }\n+\n+    /**\n+     * Add isolated qualifier to function type descriptor and modify the node.\n+     *\n+     * @param funcTypeDesc  Function type descriptor node to be modified\n+     * @param isolatedKeyword Isolated keyword to be made an object type qualifier\n+     * @return Modified node\n+     */\n+    private STNode modifyFuncTypeDescWithIsolatedQualifier(STNode funcTypeDesc, STNode isolatedKeyword) {\n+        List<STNode> newQualifierList = new ArrayList<>();\n+        newQualifierList.add(isolatedKeyword);\n+\n+        STFunctionTypeDescriptorNode funcTypeDescriptorNode = (STFunctionTypeDescriptorNode) funcTypeDesc;\n+        STNodeList qualifierList = (STNodeList) funcTypeDescriptorNode.qualifierList;\n+\n+        for (int i = 0; i < qualifierList.size(); i++) {\n+            STNode qualifier = qualifierList.get(i);\n+            if (qualifier.kind == SyntaxKind.ISOLATED_KEYWORD) {\n+                updateLastNodeInListWithInvalidNode(newQualifierList, qualifier,\n+                        DiagnosticErrorCode.ERROR_DUPLICATE_QUALIFIER, ((STToken) qualifier).text());\n+            } else {\n+                newQualifierList.add(qualifier);\n+            }\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a51c0896c4418c154dc264b5c2b1354fca6755fc"}, "originalPosition": 915}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTczMjM1Ng==", "bodyText": "Do we need to remove this? Can we use get() to retrieve and then set() to replace the original item?\nRemove is a very expensive operation. It shifts all the trailing items by one. Lets try to minimize the usage of remove() in all the places", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26610#discussion_r515732356", "createdAt": "2020-11-02T04:14:48Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/AbstractParser.java", "diffHunk": "@@ -226,12 +226,29 @@ protected void updateFirstNodeInListWithInvalidNode(List<STNode> nodeList,\n                                                         STNode invalidParam,\n                                                         DiagnosticCode diagnosticCode,\n                                                         Object... args) {\n-        STNode firstNode = nodeList.remove(0);\n-        STNode newNode = SyntaxErrors.cloneWithLeadingInvalidNodeMinutiae(firstNode, invalidParam);\n+        updateANodeInListWithInvalidNode(nodeList, 0, invalidParam, diagnosticCode, args);\n+    }\n+\n+    /**\n+     * Clones the a node in list with the invalid node as leading minutiae and update the list.\n+     *\n+     * @param nodeList       node list to be updated\n+     * @param indexOfTheNode index of the node in list to be updated\n+     * @param invalidParam   the invalid node to be attached to the first node in list as minutiae\n+     * @param diagnosticCode diagnostic code related to the invalid node\n+     * @param args           additional arguments used in diagnostic message\n+     */\n+    protected void updateANodeInListWithInvalidNode(List<STNode> nodeList,\n+                                                    int indexOfTheNode,\n+                                                    STNode invalidParam,\n+                                                    DiagnosticCode diagnosticCode,\n+                                                    Object... args) {\n+        STNode node = nodeList.remove(indexOfTheNode);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a51c0896c4418c154dc264b5c2b1354fca6755fc"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTczMjgxNw==", "bodyText": "Variable name is misleading. Lets rename it to qualifiers", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26610#discussion_r515732817", "createdAt": "2020-11-02T04:17:25Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -15435,7 +15570,7 @@ private STNode bracedListMemberStartsWithReadonly(STNode readonlyKeyword) {\n                         ParserRuleContext.TYPE_DESC_IN_TYPE_BINDING_PATTERN, true);\n                 endContext();\n                 STNode annots = STNodeFactory.createEmptyNodeList();\n-                STNode finalKeyword = STNodeFactory.createEmptyNode();\n+                List<STNode> finalKeyword = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a51c0896c4418c154dc264b5c2b1354fca6755fc"}, "originalPosition": 1107}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0a636283c0f6501e812a16ef4701ebda32e74b46", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/0a636283c0f6501e812a16ef4701ebda32e74b46", "committedDate": "2020-11-02T12:48:26Z", "message": "Add review changes"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2e9c4f65d4a045092bae3ad9e3f565790df57a19", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2e9c4f65d4a045092bae3ad9e3f565790df57a19", "committedDate": "2020-11-02T10:06:42Z", "message": "Add review changes"}, "afterCommit": {"oid": "0a636283c0f6501e812a16ef4701ebda32e74b46", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/0a636283c0f6501e812a16ef4701ebda32e74b46", "committedDate": "2020-11-02T12:48:26Z", "message": "Add review changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3b3a889d1adbe14c3050992557bf44e84d456066", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3b3a889d1adbe14c3050992557bf44e84d456066", "committedDate": "2020-11-02T13:24:41Z", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into isolated-module-var"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c4222c6e2b35a0ada8b40ef649b2727e4eec2024", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c4222c6e2b35a0ada8b40ef649b2727e4eec2024", "committedDate": "2020-11-02T15:58:57Z", "message": "Fix IsolationAnalysisTest unit test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4ab7f75eed4f9f227b9d491b7ffd09217050b343", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/4ab7f75eed4f9f227b9d491b7ffd09217050b343", "committedDate": "2020-11-03T05:05:20Z", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into isolated-module-var"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5eff72f8b8f0322fa900413e4c37494202cc91b2", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/5eff72f8b8f0322fa900413e4c37494202cc91b2", "committedDate": "2020-11-03T05:38:53Z", "message": "Add second tier review suggestions"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "186c584e38a90b5fd2cec549d541663e4fabecd1", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/186c584e38a90b5fd2cec549d541663e4fabecd1", "committedDate": "2020-11-03T04:47:57Z", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into isolated-module-var"}, "afterCommit": {"oid": "5eff72f8b8f0322fa900413e4c37494202cc91b2", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/5eff72f8b8f0322fa900413e4c37494202cc91b2", "committedDate": "2020-11-03T05:38:53Z", "message": "Add second tier review suggestions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "387273e8c981ca065b1baf210ea01d96550fca63", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/387273e8c981ca065b1baf210ea01d96550fca63", "committedDate": "2020-11-03T09:50:55Z", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into isolated-module-var\n\n\u0001 Conflicts:\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerina/compiler/syntax/tree/ModuleVariableDeclarationNode.java\n\u0001\tmisc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/FormattingTreeModifier.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e3cc5b0b1dda74b254dcec2e48a834dfc9b47462", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e3cc5b0b1dda74b254dcec2e48a834dfc9b47462", "committedDate": "2020-11-03T09:59:41Z", "message": "Regenerate syntax tree and fix FormattingTreeModifier"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzMDY0NzE5", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26610#pullrequestreview-523064719", "createdAt": "2020-11-04T06:07:49Z", "commit": {"oid": "e3cc5b0b1dda74b254dcec2e48a834dfc9b47462"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4286, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}