{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE1ODg2MzMw", "number": 26770, "title": "Enable Intersection of error types", "bodyText": "Purpose\n\nWith this you can intersect error types to get a new error.\n\nFixes #24403\nApproach\n\nIf error intersection is identified in the defineTypeNode phase, collect these to a list.\ndefineFields method was done before defineErrorDetails to collect record field information for error detail intersection.\nafter defineFields is run, a new method will iterate through all the collected error intersections.\ncalculate the detail type of error intersection at the Types class.\nDefine symbols for the new type in the symbol enter\n\nSamples\n type Detail record {\n     string detail;\n };\n\n type AdvancedDetail record {\n     string advancedDetail;\n };\n\n type AdditionalDetail record {\n     string additionalDetail;\n };\n\n type OldError error<Detail>;\n\n type DistinctError error<AdvancedDetail>;\n\n type AdditionalError error<AdditionalDetail>;\n\n type IntersectionError DistinctError & OldError;\n\n type AdditionalIntersectionError DistinctError & OldError & AdditionalError;\n\nRemarks\nCheck List\n\n Read the Contributing Guide\n Updated Change Log\n Checked Tooling Support (#)\n Added necessary tests\n\n Unit Tests\n Spec Conformance Tests\n Integration Tests\n Ballerina By Example Tests\n\n\n Increased Test Coverage\n Added necessary documentation\n\n API documentation\n Module documentation in Module.md files\n Ballerina By Examples", "createdAt": "2020-11-05T08:31:30Z", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770", "merged": true, "mergeCommit": {"oid": "3a391510b6349d41438a2f1a4604329a54a107a2"}, "closed": true, "closedAt": "2021-01-08T11:43:56Z", "author": {"login": "dulvinw"}, "timelineItems": {"totalCount": 63, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdZeT-rgBqjM5NjEyMDU4NDc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABduHPQWgFqTU2NDE5OTQ0MA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3d99ac96c3c017426cb5b3c8e798f92792475df6", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3d99ac96c3c017426cb5b3c8e798f92792475df6", "committedDate": "2020-11-05T08:22:53Z", "message": "Add support for intersection of intersectionTypes\n\nLooping through multiple types to analyze if anything other than error type is present. If so log an error.\nIf type is valid, generate a potential intersection type using the previous intersection type and current error type.\nContinue this for all the types available in the intersection."}, "afterCommit": {"oid": "203d3d82376d11317765ce358c8b8c483977bca9", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/203d3d82376d11317765ce358c8b8c483977bca9", "committedDate": "2020-11-05T08:43:56Z", "message": "Add support for intersection of intersectionTypes\n\nLooping through multiple types to analyze if anything other than error type is present. If so log an error.\nIf type is valid, generate a potential intersection type using the previous intersection type and current error type.\nContinue this for all the types available in the intersection."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "203d3d82376d11317765ce358c8b8c483977bca9", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/203d3d82376d11317765ce358c8b8c483977bca9", "committedDate": "2020-11-05T08:43:56Z", "message": "Add support for intersection of intersectionTypes\n\nLooping through multiple types to analyze if anything other than error type is present. If so log an error.\nIf type is valid, generate a potential intersection type using the previous intersection type and current error type.\nContinue this for all the types available in the intersection."}, "afterCommit": {"oid": "4827b7a5e8d2fb3bedeaf9dd47ff8cf495b94652", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/4827b7a5e8d2fb3bedeaf9dd47ff8cf495b94652", "committedDate": "2020-11-07T16:22:27Z", "message": "Add support for distinct types\n\nCapture type ids of intersecting errors and populate them to a TypeId set.\nUse all the set of primary and secondary TypeIDs as secondary TypeIDs of the new intersection error type"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "10eada52fbe07d579a0542c6e0255d24fffe2f3f", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/10eada52fbe07d579a0542c6e0255d24fffe2f3f", "committedDate": "2020-11-07T17:04:02Z", "message": "Add support for errors with `BMapType` as detail type.\n\nSkipping since the resulting `BRecordType` is unsealed and has `anydata` as rest type."}, "afterCommit": {"oid": "4b743aa23518101d1c59b9a7baf5e8ef2538590b", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/4b743aa23518101d1c59b9a7baf5e8ef2538590b", "committedDate": "2020-11-07T17:05:32Z", "message": "Add support for errors with `BMapType` as detail type.\n\nSkipping since the resulting `BRecordType` is unsealed and has `anydata` as rest type."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4b743aa23518101d1c59b9a7baf5e8ef2538590b", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/4b743aa23518101d1c59b9a7baf5e8ef2538590b", "committedDate": "2020-11-07T17:05:32Z", "message": "Add support for errors with `BMapType` as detail type.\n\nSkipping since the resulting `BRecordType` is unsealed and has `anydata` as rest type."}, "afterCommit": {"oid": "95a9886b728d1b513e119e5458fd48005f986fd4", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/95a9886b728d1b513e119e5458fd48005f986fd4", "committedDate": "2020-11-10T19:31:48Z", "message": "Add support for map and map intersection\n\nRefactored the code to generify the getTypeIntersection method. It now supports `record & record` `record & map` and `map & map`. Earlier `record & record` for error detail was done in a method which was directly called from the method which creates the error intersection."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "95a9886b728d1b513e119e5458fd48005f986fd4", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/95a9886b728d1b513e119e5458fd48005f986fd4", "committedDate": "2020-11-10T19:31:48Z", "message": "Add support for map and map intersection\n\nRefactored the code to generify the getTypeIntersection method. It now supports `record & record` `record & map` and `map & map`. Earlier `record & record` for error detail was done in a method which was directly called from the method which creates the error intersection."}, "afterCommit": {"oid": "7aa2a1561579e350d7c8e6427ccff2dcb1366954", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7aa2a1561579e350d7c8e6427ccff2dcb1366954", "committedDate": "2020-11-10T19:32:11Z", "message": "Add support for map and map intersection\n\nRefactored the code to generify the getTypeIntersection method. It now supports `record & record` `record & map` and `map & map`. Earlier `record & record` for error detail was done in a method which was directly called from the method which creates the error intersection."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI3OTA0NDMx", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#pullrequestreview-527904431", "createdAt": "2020-11-11T06:49:01Z", "commit": {"oid": "7aa2a1561579e350d7c8e6427ccff2dcb1366954"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwNjo0OTowMVrOHxAWOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwNzowNjo0M1rOHxA8dA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTE0Nzk2MQ==", "bodyText": "The compiler crashes here for\ntype Detail record {\n    string x;\n};\n\ntype DetailTwo record {\n    string x;\n    string y;\n};\n\ntype ErrorOne error<Detail>;\n\ntype ErrorTwo error<DetailTwo>;\n\ntype IntersectionError ErrorOne & ErrorTwo;\n\npublic function main() {\n    var err = IntersectionError(\"message\", x = \"x\", y = \"y\");\n}", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#discussion_r521147961", "createdAt": "2020-11-11T06:49:01Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/SymbolEnter.java", "diffHunk": "@@ -397,6 +404,171 @@ private void defineConstructs(BLangPackage pkgNode, SymbolEnv pkgEnv) {\n                 .forEach(varSymbol -> varSymbol.tag = SymTag.ENDPOINT);\n     }\n \n+    private void defineErrorIntersection(SymbolEnv env) {\n+        for (BLangNode typeDescriptor : this.errorIntersectionTypes) {\n+            BLangTypeDefinition typeDefinition = (BLangTypeDefinition) typeDescriptor;\n+\n+            boolean isDistinctType = isDistinctFlagPresent(typeDefinition);\n+            boolean isPublicType = typeDefinition.flagSet.contains(Flag.PUBLIC);\n+            Set<BTypeIdSet.BTypeId> secondaryTypeIds = new HashSet<>();\n+\n+            BLangIntersectionTypeNode intersectionTypeNode = (BLangIntersectionTypeNode) typeDefinition.typeNode;\n+            List<BLangType> constituentTypes = intersectionTypeNode.constituentTypeNodes;\n+\n+            BLangType bLangTypeOne = constituentTypes.get(0);\n+            BType typeOne = symResolver.resolveTypeNode(bLangTypeOne, env);\n+            if (typeOne.tag != TypeTags.ERROR && typeOne.tag != TypeTags.READONLY) {\n+                // TODO: log error for intersection type with other types.\n+                continue;\n+            }\n+\n+            BLangType bLangTypeTwo = constituentTypes.get(1);\n+            BType typeTwo = symResolver.resolveTypeNode(bLangTypeTwo, env);\n+            if (typeTwo.tag != TypeTags.ERROR && typeTwo.tag != TypeTags.READONLY) {\n+                // TODO: log error for intersection type with other types.\n+                continue;\n+            }\n+\n+            // Collecting typeIds.\n+            if (typeOne.tag != TypeTags.READONLY) {\n+                populateSecondaryTypeIdSet(secondaryTypeIds, (BErrorType) typeOne);\n+            }\n+            if (typeTwo.tag != TypeTags.READONLY) {\n+                populateSecondaryTypeIdSet(secondaryTypeIds, (BErrorType) typeTwo);\n+            }\n+\n+            BType potentialIntersectionType = types.getTypeIntersection(typeOne, typeTwo);\n+\n+            boolean isValidIntersection = true;\n+            for (int i = 2; i < constituentTypes.size(); i++) {\n+                BLangType bLangType = constituentTypes.get(i);\n+                BType bType = symResolver.resolveTypeNode(bLangType, env);\n+\n+                if (bType.getKind() != TypeKind.ERROR && typeTwo.tag != TypeTags.READONLY) {\n+                    // TODO: Log error for invalid intersection\n+                    isValidIntersection = false;\n+                    break;\n+                }\n+\n+                if (bType.tag != TypeTags.READONLY) {\n+                    populateSecondaryTypeIdSet(secondaryTypeIds, (BErrorType) bType);\n+                }\n+\n+                potentialIntersectionType = types.getTypeIntersection(potentialIntersectionType, bType);\n+                if (potentialIntersectionType == symTable.semanticError) {\n+                    // TODO: Log invalid intersection\n+                    isValidIntersection = false;\n+                    break;\n+                }\n+            }\n+\n+            if (!isValidIntersection) {\n+                continue;\n+            }\n+\n+            if (isDistinctType) {\n+                ((BErrorType) potentialIntersectionType).typeIdSet = BTypeIdSet.from(\n+                        potentialIntersectionType.tsymbol.pkgID, typeDefinition.name.value, isPublicType,\n+                        secondaryTypeIds);\n+            }\n+\n+            LinkedHashSet<BType> constituentBTypes = new LinkedHashSet<>() {{\n+                add(typeOne);\n+                add(typeTwo);\n+            }};\n+            BIntersectionType intersectionType = definePotentialIntersectionType((BErrorType) potentialIntersectionType,\n+                                                                                 typeDefinition, constituentBTypes);\n+            typeDefinition.symbol = intersectionType.tsymbol;\n+            typeDefinition.typeNode.type = intersectionType;\n+        }\n+    }\n+\n+    private void populateSecondaryTypeIdSet(Set<BTypeIdSet.BTypeId> secondaryTypeIds, BErrorType typeOne) {\n+        secondaryTypeIds.addAll(typeOne.typeIdSet.primary);\n+        secondaryTypeIds.addAll(typeOne.typeIdSet.secondary);\n+    }\n+\n+    private BIntersectionType definePotentialIntersectionType(BErrorType potentialIntersectionType,\n+                                                              BLangTypeDefinition typeDefinition,\n+                                                              LinkedHashSet<BType> constituentBTypes) {\n+\n+        BSymbol owner = potentialIntersectionType.tsymbol.owner;\n+        PackageID pkgId = potentialIntersectionType.tsymbol.pkgID;\n+        SymbolEnv pkgEnv = symTable.pkgEnvMap.get(owner);\n+\n+        BLangTypeDefinition detailTypeDef = defineErrorDetailRecord((BRecordType) potentialIntersectionType.detailType,\n+                                                                    typeDefinition.pos, pkgEnv);\n+        defineErrorType(potentialIntersectionType, detailTypeDef, pkgEnv, typeDefinition);\n+        return defineErrorIntersectionType(potentialIntersectionType, typeDefinition, constituentBTypes, pkgId, owner,\n+                                           pkgEnv);\n+    }\n+\n+    private BLangTypeDefinition defineErrorDetailRecord(BRecordType detailRecord, Location pos, SymbolEnv env) {\n+        // TODO: need to support map intersection.\n+        BRecordTypeSymbol detailRecordSymbol = (BRecordTypeSymbol) detailRecord.tsymbol;\n+        detailRecordSymbol.scope.define(names.fromString(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7aa2a1561579e350d7c8e6427ccff2dcb1366954"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTE1NjA4Nw==", "bodyText": "Any specific reason to check kind instead of tag here?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#discussion_r521156087", "createdAt": "2020-11-11T07:01:53Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/SymbolEnter.java", "diffHunk": "@@ -397,6 +406,170 @@ private void defineConstructs(BLangPackage pkgNode, SymbolEnv pkgEnv) {\n                 .forEach(varSymbol -> varSymbol.tag = SymTag.ENDPOINT);\n     }\n \n+    private void defineErrorIntersection(SymbolEnv env) {\n+        for (BLangNode typeDescriptor : this.errorIntersectionTypes) {\n+            BLangTypeDefinition typeDefinition = (BLangTypeDefinition) typeDescriptor;\n+\n+            boolean isDistinctType = isDistinctFlagPresent(typeDefinition);\n+            boolean isPublicType = typeDefinition.flagSet.contains(Flag.PUBLIC);\n+            Set<BTypeIdSet.BTypeId> secondaryTypeIds = new HashSet<>();\n+\n+            BLangIntersectionTypeNode intersectionTypeNode = (BLangIntersectionTypeNode) typeDefinition.typeNode;\n+            List<BLangType> constituentTypes = intersectionTypeNode.constituentTypeNodes;\n+\n+            BLangType bLangTypeOne = constituentTypes.get(0);\n+            BType typeOne = symResolver.resolveTypeNode(bLangTypeOne, env);\n+            if (typeOne.tag != TypeTags.ERROR && typeOne.tag != TypeTags.READONLY) {\n+                dlog.error(bLangTypeOne.pos, INVALID_ERROR_INTERSECTION, bLangTypeOne);\n+                continue;\n+            }\n+\n+            BLangType bLangTypeTwo = constituentTypes.get(1);\n+            BType typeTwo = symResolver.resolveTypeNode(bLangTypeTwo, env);\n+            if (typeTwo.tag != TypeTags.ERROR && typeTwo.tag != TypeTags.READONLY) {\n+                dlog.error(bLangTypeTwo.pos, INVALID_ERROR_INTERSECTION, bLangTypeTwo);\n+                continue;\n+            }\n+\n+            // Collecting typeIds.\n+            if (typeOne.tag != TypeTags.READONLY) {\n+                populateSecondaryTypeIdSet(secondaryTypeIds, (BErrorType) typeOne);\n+            }\n+            if (typeTwo.tag != TypeTags.READONLY) {\n+                populateSecondaryTypeIdSet(secondaryTypeIds, (BErrorType) typeTwo);\n+            }\n+\n+            BType potentialIntersectionType = types.getTypeIntersection(typeOne, typeTwo);\n+\n+            boolean isValidIntersection = true;\n+            for (int i = 2; i < constituentTypes.size(); i++) {\n+                BLangType bLangType = constituentTypes.get(i);\n+                BType bType = symResolver.resolveTypeNode(bLangType, env);\n+\n+                if (bType.getKind() != TypeKind.ERROR && typeTwo.tag != TypeTags.READONLY) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10014b1a8708eeb074e7e82463fb840ab008faf6"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTE1Nzc0OA==", "bodyText": "In this case, is it actually potential if we get to this point?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#discussion_r521157748", "createdAt": "2020-11-11T07:06:43Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/SymbolEnter.java", "diffHunk": "@@ -397,6 +406,170 @@ private void defineConstructs(BLangPackage pkgNode, SymbolEnv pkgEnv) {\n                 .forEach(varSymbol -> varSymbol.tag = SymTag.ENDPOINT);\n     }\n \n+    private void defineErrorIntersection(SymbolEnv env) {\n+        for (BLangNode typeDescriptor : this.errorIntersectionTypes) {\n+            BLangTypeDefinition typeDefinition = (BLangTypeDefinition) typeDescriptor;\n+\n+            boolean isDistinctType = isDistinctFlagPresent(typeDefinition);\n+            boolean isPublicType = typeDefinition.flagSet.contains(Flag.PUBLIC);\n+            Set<BTypeIdSet.BTypeId> secondaryTypeIds = new HashSet<>();\n+\n+            BLangIntersectionTypeNode intersectionTypeNode = (BLangIntersectionTypeNode) typeDefinition.typeNode;\n+            List<BLangType> constituentTypes = intersectionTypeNode.constituentTypeNodes;\n+\n+            BLangType bLangTypeOne = constituentTypes.get(0);\n+            BType typeOne = symResolver.resolveTypeNode(bLangTypeOne, env);\n+            if (typeOne.tag != TypeTags.ERROR && typeOne.tag != TypeTags.READONLY) {\n+                dlog.error(bLangTypeOne.pos, INVALID_ERROR_INTERSECTION, bLangTypeOne);\n+                continue;\n+            }\n+\n+            BLangType bLangTypeTwo = constituentTypes.get(1);\n+            BType typeTwo = symResolver.resolveTypeNode(bLangTypeTwo, env);\n+            if (typeTwo.tag != TypeTags.ERROR && typeTwo.tag != TypeTags.READONLY) {\n+                dlog.error(bLangTypeTwo.pos, INVALID_ERROR_INTERSECTION, bLangTypeTwo);\n+                continue;\n+            }\n+\n+            // Collecting typeIds.\n+            if (typeOne.tag != TypeTags.READONLY) {\n+                populateSecondaryTypeIdSet(secondaryTypeIds, (BErrorType) typeOne);\n+            }\n+            if (typeTwo.tag != TypeTags.READONLY) {\n+                populateSecondaryTypeIdSet(secondaryTypeIds, (BErrorType) typeTwo);\n+            }\n+\n+            BType potentialIntersectionType = types.getTypeIntersection(typeOne, typeTwo);\n+\n+            boolean isValidIntersection = true;\n+            for (int i = 2; i < constituentTypes.size(); i++) {\n+                BLangType bLangType = constituentTypes.get(i);\n+                BType bType = symResolver.resolveTypeNode(bLangType, env);\n+\n+                if (bType.getKind() != TypeKind.ERROR && typeTwo.tag != TypeTags.READONLY) {\n+                    dlog.error(bLangType.pos, INVALID_ERROR_INTERSECTION, bLangType);\n+                    isValidIntersection = false;\n+                    break;\n+                }\n+\n+                if (bType.tag != TypeTags.READONLY) {\n+                    populateSecondaryTypeIdSet(secondaryTypeIds, (BErrorType) bType);\n+                }\n+\n+                potentialIntersectionType = types.getTypeIntersection(potentialIntersectionType, bType);\n+                if (potentialIntersectionType == symTable.semanticError) {\n+                    dlog.error(typeDefinition.typeNode.pos, INVALID_INTERSECTION_TYPE, typeDefinition.typeNode);\n+                    isValidIntersection = false;\n+                    break;\n+                }\n+            }\n+\n+            if (!isValidIntersection) {\n+                continue;\n+            }\n+\n+            if (isDistinctType) {\n+                ((BErrorType) potentialIntersectionType).typeIdSet = BTypeIdSet.from(\n+                        potentialIntersectionType.tsymbol.pkgID, typeDefinition.name.value, isPublicType,\n+                        secondaryTypeIds);\n+            }\n+\n+            LinkedHashSet<BType> constituentBTypes = new LinkedHashSet<>() {{\n+                add(typeOne);\n+                add(typeTwo);\n+            }};\n+            BIntersectionType intersectionType = definePotentialIntersectionType((BErrorType) potentialIntersectionType,\n+                                                                                 typeDefinition, constituentBTypes);\n+            typeDefinition.symbol = intersectionType.tsymbol;\n+            typeDefinition.typeNode.type = intersectionType;\n+        }\n+    }\n+\n+    private void populateSecondaryTypeIdSet(Set<BTypeIdSet.BTypeId> secondaryTypeIds, BErrorType typeOne) {\n+        secondaryTypeIds.addAll(typeOne.typeIdSet.primary);\n+        secondaryTypeIds.addAll(typeOne.typeIdSet.secondary);\n+    }\n+\n+    private BIntersectionType definePotentialIntersectionType(BErrorType potentialIntersectionType,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10014b1a8708eeb074e7e82463fb840ab008faf6"}, "originalPosition": 148}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI3OTE5ODMw", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#pullrequestreview-527919830", "createdAt": "2020-11-11T07:23:45Z", "commit": {"oid": "10014b1a8708eeb074e7e82463fb840ab008faf6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwNzoyMzo0NVrOHxBUrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwNzoyMzo0NVrOHxBUrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTE2Mzk0OQ==", "bodyText": "Crashes when potentialIntersectionType is symTable.semanticError due to one error type being invalid.\ntype Detail record {| // closed, invalid\n    string x;\n|};\n\ntype DetailTwo record {\n    string y;\n};\n\ntype ErrorOne error<Detail>;\n\ntype ErrorTwo error<DetailTwo>;\n\ntype IntersectionError ErrorOne & ErrorTwo;\n[2020-11-11 12:52:48,270] SEVERE {b7a.log.crash} - class org.wso2.ballerinalang.compiler.semantics.model.types.BType cannot be cast to class org.wso2.ballerinalang.compiler.semantics.model.types.BErrorType (org.wso2.ballerinalang.compiler.semantics.model.types.BType and org.wso2.ballerinalang.compiler.semantics.model.types.BErrorType are in unnamed module of loader 'app') \njava.lang.ClassCastException: class org.wso2.ballerinalang.compiler.semantics.model.types.BType cannot be cast to class org.wso2.ballerinalang.compiler.semantics.model.types.BErrorType (org.wso2.ballerinalang.compiler.semantics.model.types.BType and org.wso2.ballerinalang.compiler.semantics.model.types.BErrorType are in unnamed module of loader 'app')\n\tat org.wso2.ballerinalang.compiler.semantics.analyzer.SymbolEnter.defineErrorIntersection(SymbolEnter.java:479)\n\tat org.wso2.ballerinalang.compiler.semantics.analyzer.SymbolEnter.defineConstructs(SymbolEnter.java:373)\n\tat org.wso2.ballerinalang.compiler.semantics.analyzer.SymbolEnter.visit(SymbolEnter.java:287)\n\tat org.wso2.ballerinalang.compiler.tree.BLangPackage.accept(BLangPackage.java:163)\n\tat org.wso2.ballerinalang.compiler.semantics.analyzer.SymbolEnter.defineNode(SymbolEnter.java:249)\n\tat org.wso2.ballerinalang.compiler.semantics.analyzer.SymbolEnter.definePackage(SymbolEnter.java:242)\n\tat org.wso2.ballerinalang.compiler.PackageLoader.define(PackageLoader.java:464)\n\tat org.wso2.ballerinalang.compiler.PackageLoader.loadEntryPackage(PackageLoader.java:375)\n\tat org.wso2.ballerinalang.compiler.Compiler.compilePackages(Compiler.java:166)\n\tat org.wso2.ballerinalang.compiler.Compiler.compilePackage(Compiler.java:221)\n\tat org.wso2.ballerinalang.compiler.Compiler.compile(Compiler.java:101)\n\tat org.wso2.ballerinalang.compiler.Compiler.build(Compiler.java:109)\n\tat org.ballerinalang.packerina.task.CompileTask.execute(CompileTask.java:55)\n\tat org.ballerinalang.packerina.TaskExecutor.executeTasks(TaskExecutor.java:38)\n\tat org.ballerinalang.packerina.cmd.RunCommand.execute(RunCommand.java:297)\n\tat java.base/java.util.Optional.ifPresent(Optional.java:183)\n\tat org.ballerinalang.tool.Main.main(Main.java:57)", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#discussion_r521163949", "createdAt": "2020-11-11T07:23:45Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/SymbolEnter.java", "diffHunk": "@@ -397,6 +406,170 @@ private void defineConstructs(BLangPackage pkgNode, SymbolEnv pkgEnv) {\n                 .forEach(varSymbol -> varSymbol.tag = SymTag.ENDPOINT);\n     }\n \n+    private void defineErrorIntersection(SymbolEnv env) {\n+        for (BLangNode typeDescriptor : this.errorIntersectionTypes) {\n+            BLangTypeDefinition typeDefinition = (BLangTypeDefinition) typeDescriptor;\n+\n+            boolean isDistinctType = isDistinctFlagPresent(typeDefinition);\n+            boolean isPublicType = typeDefinition.flagSet.contains(Flag.PUBLIC);\n+            Set<BTypeIdSet.BTypeId> secondaryTypeIds = new HashSet<>();\n+\n+            BLangIntersectionTypeNode intersectionTypeNode = (BLangIntersectionTypeNode) typeDefinition.typeNode;\n+            List<BLangType> constituentTypes = intersectionTypeNode.constituentTypeNodes;\n+\n+            BLangType bLangTypeOne = constituentTypes.get(0);\n+            BType typeOne = symResolver.resolveTypeNode(bLangTypeOne, env);\n+            if (typeOne.tag != TypeTags.ERROR && typeOne.tag != TypeTags.READONLY) {\n+                dlog.error(bLangTypeOne.pos, INVALID_ERROR_INTERSECTION, bLangTypeOne);\n+                continue;\n+            }\n+\n+            BLangType bLangTypeTwo = constituentTypes.get(1);\n+            BType typeTwo = symResolver.resolveTypeNode(bLangTypeTwo, env);\n+            if (typeTwo.tag != TypeTags.ERROR && typeTwo.tag != TypeTags.READONLY) {\n+                dlog.error(bLangTypeTwo.pos, INVALID_ERROR_INTERSECTION, bLangTypeTwo);\n+                continue;\n+            }\n+\n+            // Collecting typeIds.\n+            if (typeOne.tag != TypeTags.READONLY) {\n+                populateSecondaryTypeIdSet(secondaryTypeIds, (BErrorType) typeOne);\n+            }\n+            if (typeTwo.tag != TypeTags.READONLY) {\n+                populateSecondaryTypeIdSet(secondaryTypeIds, (BErrorType) typeTwo);\n+            }\n+\n+            BType potentialIntersectionType = types.getTypeIntersection(typeOne, typeTwo);\n+\n+            boolean isValidIntersection = true;\n+            for (int i = 2; i < constituentTypes.size(); i++) {\n+                BLangType bLangType = constituentTypes.get(i);\n+                BType bType = symResolver.resolveTypeNode(bLangType, env);\n+\n+                if (bType.getKind() != TypeKind.ERROR && typeTwo.tag != TypeTags.READONLY) {\n+                    dlog.error(bLangType.pos, INVALID_ERROR_INTERSECTION, bLangType);\n+                    isValidIntersection = false;\n+                    break;\n+                }\n+\n+                if (bType.tag != TypeTags.READONLY) {\n+                    populateSecondaryTypeIdSet(secondaryTypeIds, (BErrorType) bType);\n+                }\n+\n+                potentialIntersectionType = types.getTypeIntersection(potentialIntersectionType, bType);\n+                if (potentialIntersectionType == symTable.semanticError) {\n+                    dlog.error(typeDefinition.typeNode.pos, INVALID_INTERSECTION_TYPE, typeDefinition.typeNode);\n+                    isValidIntersection = false;\n+                    break;\n+                }\n+            }\n+\n+            if (!isValidIntersection) {\n+                continue;\n+            }\n+\n+            if (isDistinctType) {\n+                ((BErrorType) potentialIntersectionType).typeIdSet = BTypeIdSet.from(\n+                        potentialIntersectionType.tsymbol.pkgID, typeDefinition.name.value, isPublicType,\n+                        secondaryTypeIds);\n+            }\n+\n+            LinkedHashSet<BType> constituentBTypes = new LinkedHashSet<>() {{\n+                add(typeOne);\n+                add(typeTwo);\n+            }};\n+            BIntersectionType intersectionType = definePotentialIntersectionType((BErrorType) potentialIntersectionType,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10014b1a8708eeb074e7e82463fb840ab008faf6"}, "originalPosition": 136}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI3OTUzODg4", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#pullrequestreview-527953888", "createdAt": "2020-11-11T08:21:18Z", "commit": {"oid": "10014b1a8708eeb074e7e82463fb840ab008faf6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwODoyMToxOFrOHxC4QQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwODoyMToxOFrOHxC4QQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTE4OTQ0MQ==", "bodyText": "Don't we have to validate/fix types for already specified fields with the same name?\nLeads to issues like #26770 (comment)\nand\ntype Detail record {\n    string x;\n};\n\ntype DetailTwo record {|\n    int x?;\n    string...;\n|};\n\ntype ErrorOne error<Detail>;\n\ntype ErrorTwo error<DetailTwo>;\n\ntype IntersectionError ErrorOne & ErrorTwo;\n\npublic function main() {\n    var err1 = IntersectionError(\"message\", x = \"x\"); // invalid arg type in error detail field 'x', expected 'int', found 'string'\n    var err2 = IntersectionError(\"message\", x = 1); // works\n}", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#discussion_r521189441", "createdAt": "2020-11-11T08:21:18Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -3129,6 +3168,131 @@ BType getTypeIntersection(BType lhsType, BType rhsType) {\n         }\n     }\n \n+    private BType getIntersectionForErrorTypes(BType lhsType, BType rhsType) {\n+\n+        BType detailTypeOne = ((BErrorType) lhsType).detailType;\n+        BType detailTypeTwo = ((BErrorType) rhsType).detailType;\n+\n+        if (isSealedRecord(detailTypeOne) || isSealedRecord(detailTypeTwo)) {\n+            return symTable.semanticError;\n+        }\n+\n+        SymbolEnv prevEnv = this.env;\n+        this.env = symTable.pkgEnvMap.get(lhsType.tsymbol.owner);\n+\n+        BType detailIntersectionType = getTypeIntersection(detailTypeOne, detailTypeTwo);\n+        if (detailIntersectionType == symTable.semanticError) {\n+            return symTable.semanticError;\n+        }\n+\n+        BErrorType intersectionErrorType = createErrorType(lhsType, rhsType, detailIntersectionType);\n+        this.env = prevEnv;\n+\n+        return intersectionErrorType;\n+    }\n+\n+    private BType createRecordIntersection(BType recordTypeOne, BType recordTypeTwo) {\n+\n+        BRecordType recordType = createAnonymousRecord();\n+\n+        populateRecordFields(recordType, recordTypeOne);\n+        populateRecordFields(recordType, recordTypeTwo);\n+\n+        recordType.restFieldType = getTypeIntersection(((BRecordType) recordTypeOne).restFieldType,\n+                                                       ((BRecordType) recordTypeTwo).restFieldType);\n+\n+        if (recordType.restFieldType == symTable.semanticError) {\n+            return symTable.semanticError;\n+        }\n+\n+        return recordType;\n+    }\n+\n+    private BRecordType createAnonymousRecord() {\n+        EnumSet<Flag> flags = EnumSet.of(Flag.PUBLIC, Flag.ANONYMOUS);\n+        BRecordTypeSymbol recordSymbol = Symbols.createRecordSymbol(Flags.asMask(flags), Names.EMPTY,\n+                                                                                this.env.enclPkg.packageID, null,\n+                                                                                this.env.scope.owner, null, VIRTUAL);\n+        recordSymbol.name = names.fromString(\n+                anonymousModelHelper.getNextAnonymousTypeKey(this.env.enclPkg.packageID));\n+        BInvokableType bInvokableType = new BInvokableType(new ArrayList<>(), symTable.nilType, null);\n+        BInvokableSymbol initFuncSymbol = Symbols.createFunctionSymbol(\n+                Flags.PUBLIC, Names.EMPTY, this.env.enclPkg.symbol.pkgID, bInvokableType, this.env.scope.owner, false,\n+                symTable.builtinPos, VIRTUAL);\n+        initFuncSymbol.retType = symTable.nilType;\n+        recordSymbol.initializerFunc = new BAttachedFunction(Names.INIT_FUNCTION_SUFFIX, initFuncSymbol,\n+                                                                         bInvokableType, symTable.builtinPos);\n+        recordSymbol.scope = new Scope(recordSymbol);\n+\n+        BRecordType recordType = new BRecordType(recordSymbol);\n+        recordType.tsymbol = recordSymbol;\n+        recordSymbol.type = recordType;\n+\n+        return recordType;\n+    }\n+\n+    private BType createRecordAndMapIntersection(BType type, BType mapType) {\n+        BRecordType intersectionRecord = createAnonymousRecord();\n+        populateRecordFields(intersectionRecord, type);\n+        intersectionRecord.restFieldType = getRestFieldIntersectionType(type, (BMapType) mapType);\n+\n+        if (intersectionRecord.restFieldType == symTable.semanticError) {\n+            return symTable.semanticError;\n+        }\n+\n+        return intersectionRecord;\n+    }\n+\n+    private BType getRestFieldIntersectionType(BType type, BMapType mapType) {\n+        if (type.tag == TypeTags.RECORD) {\n+            return getTypeIntersection(((BRecordType) type).restFieldType, mapType.constraint);\n+        } else {\n+            return getTypeIntersection(((BMapType) type).constraint, mapType.constraint);\n+        }\n+    }\n+\n+    private BErrorType createErrorType(BType lhsType, BType rhsType, BType detailType) {\n+        BErrorTypeSymbol errorTypeSymbol = Symbols.createErrorSymbol(lhsType.flags, Names.EMPTY,\n+                                                                     this.env.enclPkg.symbol.pkgID, null,\n+                                                                     this.env.scope.owner, null, VIRTUAL);\n+        errorTypeSymbol.flags |= rhsType.flags;\n+        BErrorType errorType = new BErrorType(errorTypeSymbol, detailType);\n+        errorType.flags |= errorTypeSymbol.flags;\n+        errorTypeSymbol.type = errorType;\n+        symResolver.markParameterizedType(errorType, detailType);\n+        errorType.typeIdSet = BTypeIdSet.emptySet();\n+\n+        return errorType;\n+    }\n+\n+    private void populateRecordFields(BRecordType recordType, BType originalType) {\n+        BTypeSymbol intersectionRecordSymbol = recordType.tsymbol;\n+        // If the detail type is BMapType simply ignore since the resulting detail type has `anydata` as rest type.\n+        if (originalType.getKind() != TypeKind.RECORD) {\n+            return;\n+        }\n+        BRecordType originalRecordType = (BRecordType) originalType;\n+        LinkedHashMap<String, BField> fields = new LinkedHashMap<>();\n+        for (BField origField : originalRecordType.fields.values()) {\n+            org.wso2.ballerinalang.compiler.util.Name origFieldName = origField.name;\n+            BType recordFieldType = origField.type;\n+            BVarSymbol recordFieldSymbol = new BVarSymbol(origField.symbol.flags, origFieldName,\n+                                                          this.env.enclPkg.packageID, recordFieldType,\n+                                                          intersectionRecordSymbol, origField.pos, SOURCE);\n+            if (recordFieldType.tag == TypeTags.INVOKABLE && recordFieldType.tsymbol != null) {\n+                BInvokableTypeSymbol tsymbol = (BInvokableTypeSymbol) recordFieldType.tsymbol;\n+                BInvokableSymbol invokableSymbol = (BInvokableSymbol) recordFieldSymbol;\n+                invokableSymbol.params = tsymbol.params;\n+                invokableSymbol.restParam = tsymbol.restParam;\n+                invokableSymbol.retType = tsymbol.returnType;\n+                invokableSymbol.flags = tsymbol.flags;\n+            }\n+            String nameString = origFieldName.value;\n+            fields.put(nameString, new BField(origFieldName, null, recordFieldSymbol));\n+        }\n+        recordType.fields.putAll(fields);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10014b1a8708eeb074e7e82463fb840ab008faf6"}, "originalPosition": 238}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI4MTY4NjIx", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#pullrequestreview-528168621", "createdAt": "2020-11-11T13:26:05Z", "commit": {"oid": "10014b1a8708eeb074e7e82463fb840ab008faf6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxMzoyNjowNVrOHxNDOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxMzoyNjowNVrOHxNDOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTM1NjA5MQ==", "bodyText": "Given that Types.java is like a stateless util class I'm not sure if we should maintain the env like this.\nRaised the same in @KavinduZoysa's PR too - https://github.com/ballerina-platform/ballerina-lang/pull/26144/files#r520295821.\nI think we'll have to refactor getTypeIntersection to accept env too.\nAlso, regarding the RHS here, IMO getting the env of lhsType.tsymbol.owner won't quite be the correct approach if lhsType is from an imported module, right? Shouldn't it always be the current module?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#discussion_r521356091", "createdAt": "2020-11-11T13:26:05Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -3129,6 +3168,131 @@ BType getTypeIntersection(BType lhsType, BType rhsType) {\n         }\n     }\n \n+    private BType getIntersectionForErrorTypes(BType lhsType, BType rhsType) {\n+\n+        BType detailTypeOne = ((BErrorType) lhsType).detailType;\n+        BType detailTypeTwo = ((BErrorType) rhsType).detailType;\n+\n+        if (isSealedRecord(detailTypeOne) || isSealedRecord(detailTypeTwo)) {\n+            return symTable.semanticError;\n+        }\n+\n+        SymbolEnv prevEnv = this.env;\n+        this.env = symTable.pkgEnvMap.get(lhsType.tsymbol.owner);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10014b1a8708eeb074e7e82463fb840ab008faf6"}, "originalPosition": 126}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "db022282d489fefa8806ec6edbd7ec629577ae66", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/db022282d489fefa8806ec6edbd7ec629577ae66", "committedDate": "2020-11-11T17:03:17Z", "message": "Add tests"}, "afterCommit": {"oid": "60e4a6cc7608d133e22a106c152f0a3f4458b076", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/60e4a6cc7608d133e22a106c152f0a3f4458b076", "committedDate": "2020-11-11T17:18:52Z", "message": "Add tests"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "60e4a6cc7608d133e22a106c152f0a3f4458b076", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/60e4a6cc7608d133e22a106c152f0a3f4458b076", "committedDate": "2020-11-11T17:18:52Z", "message": "Add tests"}, "afterCommit": {"oid": "1d6bfcf7949f557094616fdaf12489d4c4af2715", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1d6bfcf7949f557094616fdaf12489d4c4af2715", "committedDate": "2020-11-11T18:24:08Z", "message": "Add tests"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1806039b5c3bd44d7ad06d28f335fa514a3feacb", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1806039b5c3bd44d7ad06d28f335fa514a3feacb", "committedDate": "2020-11-11T18:42:46Z", "message": "Refactor `getTypeIntersection`\n\nRefactored the `getTypeIntersection` method to accept the package env as a parameter.\nThis was done since the Types class was a stateless class and having a state variable such as env was violating this. Hence we had to modify the method to accept the environment as a parameter."}, "afterCommit": {"oid": "b73ba5cf64fb89f545ffbe48d4286495bbc0890b", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b73ba5cf64fb89f545ffbe48d4286495bbc0890b", "committedDate": "2020-11-11T18:51:58Z", "message": "Refactor `getTypeIntersection`\n\nRefactored the `getTypeIntersection` method to accept the package env as a parameter.\nThis was done since the Types class was a stateless class and having a state variable such as env was violating this. Hence we had to modify the method to accept the environment as a parameter."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMwOTQwMDUw", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#pullrequestreview-530940050", "createdAt": "2020-11-16T06:19:51Z", "commit": {"oid": "b73ba5cf64fb89f545ffbe48d4286495bbc0890b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwNjoxOTo1MVrOHzpdMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwNjoxOTo1MVrOHzpdMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzkxODY0Mg==", "bodyText": "Is this method name correct? IMO, under this condition we cannot call createRecordAndMapIntersection, we need to call another method to get the intersection between two maps. WDYT?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#discussion_r523918642", "createdAt": "2020-11-16T06:19:51Z", "author": {"login": "KavinduZoysa"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -3109,6 +3124,31 @@ BType getTypeIntersection(BType lhsType, BType rhsType) {\n                 }\n             } else if (type.tag == TypeTags.NULL_SET) {\n                 return type;\n+            } else if (type.tag == TypeTags.ERROR && lhsType.tag == TypeTags.ERROR) {\n+                BType intersectionType = getIntersectionForErrorTypes(lhsType, type, pkgEnv);\n+                if (intersectionType != symTable.semanticError) {\n+                    return intersectionType;\n+                }\n+            } else if (type.tag == TypeTags.RECORD && lhsType.tag == TypeTags.RECORD) {\n+                BType intersectionType = createRecordIntersection(lhsType, type, pkgEnv);\n+                if (intersectionType != symTable.semanticError) {\n+                    return intersectionType;\n+                }\n+            } else if (type.tag == TypeTags.MAP && lhsType.tag == TypeTags.RECORD) {\n+                BType intersectionType = createRecordAndMapIntersection(lhsType, type, pkgEnv);\n+                if (intersectionType != symTable.semanticError) {\n+                    return intersectionType;\n+                }\n+            } else if (type.tag == TypeTags.RECORD && lhsType.tag == TypeTags.MAP) {\n+                BType intersectionType = createRecordAndMapIntersection(type, lhsType, pkgEnv);\n+                if (intersectionType != symTable.semanticError) {\n+                    return intersectionType;\n+                }\n+            } else if (type.tag == TypeTags.MAP && lhsType.tag == TypeTags.MAP) {\n+                BType intersectionType = createRecordAndMapIntersection(type, lhsType, pkgEnv);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b73ba5cf64fb89f545ffbe48d4286495bbc0890b"}, "originalPosition": 130}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b73ba5cf64fb89f545ffbe48d4286495bbc0890b", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b73ba5cf64fb89f545ffbe48d4286495bbc0890b", "committedDate": "2020-11-11T18:51:58Z", "message": "Refactor `getTypeIntersection`\n\nRefactored the `getTypeIntersection` method to accept the package env as a parameter.\nThis was done since the Types class was a stateless class and having a state variable such as env was violating this. Hence we had to modify the method to accept the environment as a parameter."}, "afterCommit": {"oid": "7090f7b80f57772b9560abd7a94188af12219aa4", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7090f7b80f57772b9560abd7a94188af12219aa4", "committedDate": "2020-11-16T17:26:55Z", "message": "Fix int long conversion of flags after master change"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7090f7b80f57772b9560abd7a94188af12219aa4", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7090f7b80f57772b9560abd7a94188af12219aa4", "committedDate": "2020-11-16T17:26:55Z", "message": "Fix int long conversion of flags after master change"}, "afterCommit": {"oid": "7bed1610dae0471055e6439c86b0117d7dc3aa35", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7bed1610dae0471055e6439c86b0117d7dc3aa35", "committedDate": "2020-11-20T10:57:39Z", "message": "Sync with master\n\nMoved the new error type to `DiagnosticErrorCode`"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7bed1610dae0471055e6439c86b0117d7dc3aa35", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7bed1610dae0471055e6439c86b0117d7dc3aa35", "committedDate": "2020-11-20T10:57:39Z", "message": "Sync with master\n\nMoved the new error type to `DiagnosticErrorCode`"}, "afterCommit": {"oid": "dd25fdc25f1530a37fa4495ba1a09ff8093b9384", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/dd25fdc25f1530a37fa4495ba1a09ff8093b9384", "committedDate": "2020-11-20T11:05:26Z", "message": "Sync with master\n\nMoved the new error type to `DiagnosticErrorCode`"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "dd25fdc25f1530a37fa4495ba1a09ff8093b9384", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/dd25fdc25f1530a37fa4495ba1a09ff8093b9384", "committedDate": "2020-11-20T11:05:26Z", "message": "Sync with master\n\nMoved the new error type to `DiagnosticErrorCode`"}, "afterCommit": {"oid": "8f901207cf02c454972a63eae82c3831ca403106", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/8f901207cf02c454972a63eae82c3831ca403106", "committedDate": "2020-11-20T11:12:26Z", "message": "Sync with master\n\nMoved the new error type to `DiagnosticErrorCode`"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8f901207cf02c454972a63eae82c3831ca403106", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/8f901207cf02c454972a63eae82c3831ca403106", "committedDate": "2020-11-20T11:12:26Z", "message": "Sync with master\n\nMoved the new error type to `DiagnosticErrorCode`"}, "afterCommit": {"oid": "cca340d89bf2a4bcf1e9e09f867ff0ee54ba0ee9", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/cca340d89bf2a4bcf1e9e09f867ff0ee54ba0ee9", "committedDate": "2020-11-23T04:00:56Z", "message": "Sync with master\n\nMoved the new error type to `DiagnosticErrorCode`"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM5OTU2MjE1", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#pullrequestreview-539956215", "createdAt": "2020-11-27T12:49:41Z", "commit": {"oid": "cca340d89bf2a4bcf1e9e09f867ff0ee54ba0ee9"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxMjo0OTo0MVrOH69S9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxNDoxMjoyNFrOH6_yKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTU4MzczNQ==", "bodyText": "Wouldn't passing the current env work? Please check other usage too.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#discussion_r531583735", "createdAt": "2020-11-27T12:49:41Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/SemanticAnalyzer.java", "diffHunk": "@@ -2449,7 +2449,8 @@ public void visit(BLangListMatchPattern listMatchPattern) {\n             matchPatternType.restType = restType;\n         }\n \n-        listMatchPattern.type = types.resolvePatternTypeFromMatchExpr(listMatchExpr, matchPatternType);\n+        SymbolEnv pkgEnv = symTable.pkgEnvMap.get(env.enclPkg.symbol);\n+        listMatchPattern.type = types.resolvePatternTypeFromMatchExpr(listMatchExpr, matchPatternType, pkgEnv);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cca340d89bf2a4bcf1e9e09f867ff0ee54ba0ee9"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTYxNzYzNg==", "bodyText": "Would this approach with in-line type-descriptors? Shouldn't we define these errors in the relevant scope, instead of making them module-level type definitions?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#discussion_r531617636", "createdAt": "2020-11-27T13:58:48Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/SymbolEnter.java", "diffHunk": "@@ -407,6 +416,200 @@ private void defineConstructs(BLangPackage pkgNode, SymbolEnv pkgEnv) {\n                 .forEach(varSymbol -> varSymbol.tag = SymTag.ENDPOINT);\n     }\n \n+    private void defineErrorIntersection(SymbolEnv env) {\n+        for (BLangNode typeDescriptor : this.errorIntersectionTypes) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cca340d89bf2a4bcf1e9e09f867ff0ee54ba0ee9"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTYyMTcyOQ==", "bodyText": "Isn't adding this check a bit contradictory with the method name? Should we rename the method to be more generic?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#discussion_r531621729", "createdAt": "2020-11-27T14:06:56Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/SymbolEnter.java", "diffHunk": "@@ -2119,8 +2330,10 @@ private void validateReadOnlyIntersectionTypeDefinitions(List<BLangTypeDefinitio\n                     if (constituentType == symTable.readonlyType) {\n                         continue;\n                     }\n+                    // If constituent type is error, we have already validated error intersections.\n+                    if (!types.isSelectivelyImmutableType(constituentType, true, true)\n+                            && constituentType.tag != TypeTags.ERROR) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cca340d89bf2a4bcf1e9e09f867ff0ee54ba0ee9"}, "originalPosition": 289}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTYyMjgzNQ==", "bodyText": "When can these become null? I'm not sure if we should add these checks here, we should probably not call this if a type is null.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#discussion_r531622835", "createdAt": "2020-11-27T14:09:10Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -228,6 +238,9 @@ public boolean isSameType(BType source, BType target) {\n     }\n \n     private boolean isSameType(BType source, BType target, Set<TypePair> unresolvedTypes) {\n+        if (source == null || target == null) {\n+            return false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cca340d89bf2a4bcf1e9e09f867ff0ee54ba0ee9"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTYyMzI2NQ==", "bodyText": "Missing the licence header in the bal files.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#discussion_r531623265", "createdAt": "2020-11-27T14:10:00Z", "author": {"login": "MaryamZi"}, "path": "tests/jballerina-unit-test/src/test/resources/test-src/types/intersection/error_intersection_type.bal", "diffHunk": "@@ -0,0 +1,76 @@\n+// Detail types", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cca340d89bf2a4bcf1e9e09f867ff0ee54ba0ee9"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTYyMzk0OA==", "bodyText": "Do we have tests for scenarios that can cause this error?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#discussion_r531623948", "createdAt": "2020-11-27T14:11:23Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/resources/compiler.properties", "diffHunk": "@@ -153,6 +153,9 @@ error.invalid.readonly.object.type=\\\n error.invalid.readonly.mapping.field=\\\n   invalid ''readonly'' mapping field ''{0}'': ''{1}'' can never be ''readonly''\n \n+error.invalid.error.intersection=\\\n+  invalid type in error intersection definition ''{0}''", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cca340d89bf2a4bcf1e9e09f867ff0ee54ba0ee9"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTYyNDQ5MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    } else if (isAssignable(origField.type, overlappingField.type)) {\n          \n          \n            \n                        return origField.type;\n          \n          \n            \n                    } else {\n          \n          \n            \n                        return symTable.semanticError;\n          \n          \n            \n                    }\n          \n          \n            \n                    } \n          \n          \n            \n                    \n          \n          \n            \n                    if (isAssignable(origField.type, overlappingField.type)) {\n          \n          \n            \n                        return origField.type;\n          \n          \n            \n                    }\n          \n          \n            \n                    return symTable.semanticError;", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#discussion_r531624490", "createdAt": "2020-11-27T14:12:24Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -3142,6 +3182,161 @@ BType getTypeIntersection(BType lhsType, BType rhsType) {\n         }\n     }\n \n+    private BType getIntersectionForErrorTypes(BType lhsType, BType rhsType, SymbolEnv env) {\n+\n+        BType detailTypeOne = ((BErrorType) lhsType).detailType;\n+        BType detailTypeTwo = ((BErrorType) rhsType).detailType;\n+\n+        if (isSealedRecord(detailTypeOne) || isSealedRecord(detailTypeTwo)) {\n+            return symTable.semanticError;\n+        }\n+\n+        BType detailIntersectionType = getTypeIntersection(detailTypeOne, detailTypeTwo, env);\n+        if (detailIntersectionType == symTable.semanticError) {\n+            return symTable.semanticError;\n+        }\n+\n+        BErrorType intersectionErrorType = createErrorType(lhsType, rhsType, detailIntersectionType, env);\n+\n+        return intersectionErrorType;\n+    }\n+\n+    private BType createRecordIntersection(BType recordTypeOne, BType recordTypeTwo, SymbolEnv env) {\n+\n+        BRecordType recordType = createAnonymousRecord(env);\n+\n+        if (!populateRecordFields(recordType, recordTypeOne, env) ||\n+                !populateRecordFields(recordType, recordTypeTwo, env)) {\n+            return symTable.semanticError;\n+        }\n+\n+        recordType.restFieldType = getTypeIntersection(((BRecordType) recordTypeOne).restFieldType,\n+                                                       ((BRecordType) recordTypeTwo).restFieldType, env);\n+\n+        if (recordType.restFieldType == symTable.semanticError) {\n+            return symTable.semanticError;\n+        }\n+\n+        return recordType;\n+    }\n+\n+    private BRecordType createAnonymousRecord(SymbolEnv env) {\n+        EnumSet<Flag> flags = EnumSet.of(Flag.PUBLIC, Flag.ANONYMOUS);\n+        BRecordTypeSymbol recordSymbol = Symbols.createRecordSymbol(Flags.asMask(flags), Names.EMPTY,\n+                                                                                env.enclPkg.packageID, null,\n+                                                                                env.scope.owner, null, VIRTUAL);\n+        recordSymbol.name = names.fromString(\n+                anonymousModelHelper.getNextAnonymousTypeKey(env.enclPkg.packageID));\n+        BInvokableType bInvokableType = new BInvokableType(new ArrayList<>(), symTable.nilType, null);\n+        BInvokableSymbol initFuncSymbol = Symbols.createFunctionSymbol(\n+                Flags.PUBLIC, Names.EMPTY, env.enclPkg.symbol.pkgID, bInvokableType, env.scope.owner, false,\n+                symTable.builtinPos, VIRTUAL);\n+        initFuncSymbol.retType = symTable.nilType;\n+        recordSymbol.initializerFunc = new BAttachedFunction(Names.INIT_FUNCTION_SUFFIX, initFuncSymbol,\n+                                                                         bInvokableType, symTable.builtinPos);\n+        recordSymbol.scope = new Scope(recordSymbol);\n+\n+        BRecordType recordType = new BRecordType(recordSymbol);\n+        recordType.tsymbol = recordSymbol;\n+        recordSymbol.type = recordType;\n+\n+        return recordType;\n+    }\n+\n+    private BType createRecordAndMapIntersection(BType type, BType mapType, SymbolEnv env) {\n+        BRecordType intersectionRecord = createAnonymousRecord(env);\n+        if (!populateRecordFields(intersectionRecord, type, env)) {\n+            return symTable.semanticError;\n+        }\n+        intersectionRecord.restFieldType = getRestFieldIntersectionType(type, (BMapType) mapType, env);\n+\n+        if (intersectionRecord.restFieldType == symTable.semanticError) {\n+            return symTable.semanticError;\n+        }\n+\n+        return intersectionRecord;\n+    }\n+\n+    private BType getRestFieldIntersectionType(BType type, BMapType mapType, SymbolEnv env) {\n+        if (type.tag == TypeTags.RECORD) {\n+            return getTypeIntersection(((BRecordType) type).restFieldType, mapType.constraint, env);\n+        } else {\n+            return getTypeIntersection(((BMapType) type).constraint, mapType.constraint, env);\n+        }\n+    }\n+\n+    private BErrorType createErrorType(BType lhsType, BType rhsType, BType detailType, SymbolEnv env) {\n+        BErrorType errorType = createErrorType(detailType, lhsType.flags, env);\n+        errorType.tsymbol.flags |= rhsType.flags;\n+\n+        return errorType;\n+    }\n+\n+    public BErrorType createErrorType(BType detailType, long flags, SymbolEnv env) {\n+        BErrorTypeSymbol errorTypeSymbol = Symbols.createErrorSymbol(flags, Names.EMPTY,\n+                                                                     env.enclPkg.symbol.pkgID, null,\n+                                                                     env.scope.owner, null, VIRTUAL);\n+        BErrorType errorType = new BErrorType(errorTypeSymbol, detailType);\n+        errorType.flags |= errorTypeSymbol.flags;\n+        errorTypeSymbol.type = errorType;\n+        symResolver.markParameterizedType(errorType, detailType);\n+        errorType.typeIdSet = BTypeIdSet.emptySet();\n+\n+        return errorType;\n+    }\n+\n+    private boolean populateRecordFields(BRecordType recordType, BType originalType, SymbolEnv env) {\n+        BTypeSymbol intersectionRecordSymbol = recordType.tsymbol;\n+        // If the detail type is BMapType simply ignore since the resulting detail type has `anydata` as rest type.\n+        if (originalType.getKind() != TypeKind.RECORD) {\n+            return true;\n+        }\n+        BRecordType originalRecordType = (BRecordType) originalType;\n+        LinkedHashMap<String, BField> fields = new LinkedHashMap<>();\n+        for (BField origField : originalRecordType.fields.values()) {\n+            org.wso2.ballerinalang.compiler.util.Name origFieldName = origField.name;\n+            String nameString = origFieldName.value;\n+\n+            BType recordFieldType = validateOverlappingFields(recordType, origField);\n+            if (recordFieldType == symTable.semanticError) {\n+                return false;\n+            }\n+\n+            BVarSymbol recordFieldSymbol = new BVarSymbol(origField.symbol.flags, origFieldName,\n+                                                          env.enclPkg.packageID, recordFieldType,\n+                                                          intersectionRecordSymbol, origField.pos, SOURCE);\n+            if (recordFieldType.tag == TypeTags.INVOKABLE && recordFieldType.tsymbol != null) {\n+                BInvokableTypeSymbol tsymbol = (BInvokableTypeSymbol) recordFieldType.tsymbol;\n+                BInvokableSymbol invokableSymbol = (BInvokableSymbol) recordFieldSymbol;\n+                invokableSymbol.params = tsymbol.params;\n+                invokableSymbol.restParam = tsymbol.restParam;\n+                invokableSymbol.retType = tsymbol.returnType;\n+                invokableSymbol.flags = tsymbol.flags;\n+            }\n+\n+\n+            fields.put(nameString, new BField(origFieldName, null, recordFieldSymbol));\n+        }\n+        recordType.fields.putAll(fields);\n+\n+        return true;\n+    }\n+\n+    private BType validateOverlappingFields(BRecordType recordType, BField origField) {\n+        BField overlappingField = recordType.fields.get(origField.name.value);\n+        if (overlappingField == null) {\n+            return origField.type;\n+        }\n+\n+        if (isAssignable(overlappingField.type, origField.type)) {\n+            return overlappingField.type;\n+        } else if (isAssignable(origField.type, overlappingField.type)) {\n+            return origField.type;\n+        } else {\n+            return symTable.semanticError;\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cca340d89bf2a4bcf1e9e09f867ff0ee54ba0ee9"}, "originalPosition": 293}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "aaf325ee3e97594a90a53a976c48a79d7c7be713", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/aaf325ee3e97594a90a53a976c48a79d7c7be713", "committedDate": "2020-12-14T14:49:00Z", "message": "Update compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\n\nCo-authored-by: Maryam Ziyad <maryamziyadm@gmail.com>"}, "afterCommit": {"oid": "288a33a16b0c50a12e3a58cbbf474fbfd21b5cdd", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/288a33a16b0c50a12e3a58cbbf474fbfd21b5cdd", "committedDate": "2020-12-14T15:01:46Z", "message": "Update compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\n\nCo-authored-by: Maryam Ziyad <maryamziyadm@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "288a33a16b0c50a12e3a58cbbf474fbfd21b5cdd", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/288a33a16b0c50a12e3a58cbbf474fbfd21b5cdd", "committedDate": "2020-12-14T15:01:46Z", "message": "Update compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\n\nCo-authored-by: Maryam Ziyad <maryamziyadm@gmail.com>"}, "afterCommit": {"oid": "bded6e540a9f2e23028ec8b8c60dc50e8ecb75ae", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/bded6e540a9f2e23028ec8b8c60dc50e8ecb75ae", "committedDate": "2020-12-14T15:03:21Z", "message": "Update compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\n\nCo-authored-by: Maryam Ziyad <maryamziyadm@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "bded6e540a9f2e23028ec8b8c60dc50e8ecb75ae", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/bded6e540a9f2e23028ec8b8c60dc50e8ecb75ae", "committedDate": "2020-12-14T15:03:21Z", "message": "Update compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\n\nCo-authored-by: Maryam Ziyad <maryamziyadm@gmail.com>"}, "afterCommit": {"oid": "9735dbefda63a381e9919c5b0bfd058a28a141e8", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/9735dbefda63a381e9919c5b0bfd058a28a141e8", "committedDate": "2020-12-14T15:09:24Z", "message": "Update compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\n\nCo-authored-by: Maryam Ziyad <maryamziyadm@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9735dbefda63a381e9919c5b0bfd058a28a141e8", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/9735dbefda63a381e9919c5b0bfd058a28a141e8", "committedDate": "2020-12-14T15:09:24Z", "message": "Update compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\n\nCo-authored-by: Maryam Ziyad <maryamziyadm@gmail.com>"}, "afterCommit": {"oid": "f6e2dfbe2c41de8018a7233ab72046eb4b4d3936", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f6e2dfbe2c41de8018a7233ab72046eb4b4d3936", "committedDate": "2020-12-14T15:23:09Z", "message": "Update compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\n\nCo-authored-by: Maryam Ziyad <maryamziyadm@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f6e2dfbe2c41de8018a7233ab72046eb4b4d3936", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f6e2dfbe2c41de8018a7233ab72046eb4b4d3936", "committedDate": "2020-12-14T15:23:09Z", "message": "Update compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\n\nCo-authored-by: Maryam Ziyad <maryamziyadm@gmail.com>"}, "afterCommit": {"oid": "071fa0d59f258f80051c572190ab71b24ab6d78e", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/071fa0d59f258f80051c572190ab71b24ab6d78e", "committedDate": "2020-12-14T16:00:21Z", "message": "Update compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\n\nCo-authored-by: Maryam Ziyad <maryamziyadm@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7a162c21d0991ce869bf67e7a204b876c34451da", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7a162c21d0991ce869bf67e7a204b876c34451da", "committedDate": "2020-12-17T12:02:05Z", "message": "Add new checks for map and record intersection\n\nWhen intersecting a map and a record, now the checks are validating each field with the constraint of the map.\nIf a field is optional and the intersection is an error, we skip that for the generated type.\nIn case it's not optional the intersection is a semantic error."}, "afterCommit": {"oid": "dd99d7089a9a42b733053c02baf8949b71e4b372", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/dd99d7089a9a42b733053c02baf8949b71e4b372", "committedDate": "2020-12-18T08:00:10Z", "message": "Add new checks for map and record intersection\n\nWhen intersecting a map and a record, now the checks are validating each field with the constraint of the map.\nIf a field is optional and the intersection is an error, we skip that for the generated type.\nIn case it's not optional the intersection is a semantic error."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "dd99d7089a9a42b733053c02baf8949b71e4b372", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/dd99d7089a9a42b733053c02baf8949b71e4b372", "committedDate": "2020-12-18T08:00:10Z", "message": "Add new checks for map and record intersection\n\nWhen intersecting a map and a record, now the checks are validating each field with the constraint of the map.\nIf a field is optional and the intersection is an error, we skip that for the generated type.\nIn case it's not optional the intersection is a semantic error."}, "afterCommit": {"oid": "ae011cf75d4ec75832f28fc6eb7d3d1ae74b483b", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/ae011cf75d4ec75832f28fc6eb7d3d1ae74b483b", "committedDate": "2020-12-21T05:58:31Z", "message": "Add new checks for map and record intersection\n\nWhen intersecting a map and a record, now the checks are validating each field with the constraint of the map.\nIf a field is optional and the intersection is an error, we skip that for the generated type.\nIn case it's not optional the intersection is a semantic error."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6a1ba444b49bc060213d6a5948e540205d1f65df", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6a1ba444b49bc060213d6a5948e540205d1f65df", "committedDate": "2021-01-05T14:23:54Z", "message": "Capture error intersections\n\nCapture error intersections to be analyzed after defining nodes.\nChanged the order of defineField and defineError so that the fields of records would be defined and then those could be used to calculate the error intersection. Then only defining errorDetails."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c1a636c6b1e1f073ea1e6e6fc8872b10c5c47f0c", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c1a636c6b1e1f073ea1e6e6fc8872b10c5c47f0c", "committedDate": "2021-01-05T14:23:54Z", "message": "Create detail type for record intersection\n\nCreate detail type for record intersection is completed in this commit.\nThe symbols are not defined in the types. Need to define symbols"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7c179d7db9a8058b06742de1f583cf969b357a47", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7c179d7db9a8058b06742de1f583cf969b357a47", "committedDate": "2021-01-05T14:23:54Z", "message": "Define new anonymous Types\n\nDefine symbols for detail record and error type.\nCreate type definition for detail record.\nCreate type definition for error type.\nTwo new methods were added to TypeDefBuilderHelper to create a BLangErrorType and to create an Identifier."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "37b940a79990959d052bef2f3bf5db30c93e8cea", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/37b940a79990959d052bef2f3bf5db30c93e8cea", "committedDate": "2021-01-05T14:23:54Z", "message": "Create intersection type\n\nDefine methods in SymbolEnter to create a new intersection type. Changed the name of the BLangErrorType to the name of the intersection type. Defined the record, error and intersection symbols."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6dba2f82667ace8dff32d38b31369542baffa066", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6dba2f82667ace8dff32d38b31369542baffa066", "committedDate": "2021-01-05T14:23:54Z", "message": "Add support for intersection of intersectionTypes\n\nLooping through multiple types to analyze if anything other than error type is present. If so log an error.\nIf type is valid, generate a potential intersection type using the previous intersection type and current error type.\nContinue this for all the types available in the intersection."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0d31276a9ed0bbd9fbc2119b4af97b8f97f08789", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/0d31276a9ed0bbd9fbc2119b4af97b8f97f08789", "committedDate": "2021-01-05T14:23:54Z", "message": "Add support for distinct types\n\nCapture type ids of intersecting errors and populate them to a TypeId set.\nUse all the set of primary and secondary TypeIDs as secondary TypeIDs of the new intersection error type"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "239cf48985b3cde010952983b4ba38e4c9fe7975", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/239cf48985b3cde010952983b4ba38e4c9fe7975", "committedDate": "2021-01-05T14:23:54Z", "message": "Add support for errors with `BMapType` as detail type.\n\nSkipping since the resulting `BRecordType` is unsealed and has `anydata` as rest type."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9eccd9fe5a4894299255ba8a1bab70704549f969", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/9eccd9fe5a4894299255ba8a1bab70704549f969", "committedDate": "2021-01-05T14:23:54Z", "message": "Add support for map and map intersection\n\nRefactored the code to generify the getTypeIntersection method. It now supports `record & record` `record & map` and `map & map`. Earlier `record & record` for error detail was done in a method which was directly called from the method which creates the error intersection."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c38445df1b7f9a3c811022a0d50b787ea2281409", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c38445df1b7f9a3c811022a0d50b787ea2281409", "committedDate": "2021-01-05T14:23:54Z", "message": "Define errors\n\nNew error is defined for when a constituent node is not of the error or readonly type when found in a error intersection.\nUsed the same invalid error intersection when `Types` returns a semanticError."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4e615882f8b1281ba967152264ba84114e73ffb5", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/4e615882f8b1281ba967152264ba84114e73ffb5", "committedDate": "2021-01-05T14:23:54Z", "message": "Fix intersection type being already existing type error.\n\nCheck if `getTypeIntersection` returns a compared error. If so keep a flag.\nIf a pre existing error is received, do not create a type definition, instead create a `BLangUserDefinedTypeNode`\nand use it for the error type definition.\nAdded tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b3b9b9c0e20bb0dd6117812eaf859ad4cc18d357", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b3b9b9c0e20bb0dd6117812eaf859ad4cc18d357", "committedDate": "2021-01-05T14:23:55Z", "message": "Add review suggestions\n\nUsed `TypeTag` instead of `getKind()`"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "11a2d8e09cb6eb8f6b862a01ed3f7e944b9b1fec", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/11a2d8e09cb6eb8f6b862a01ed3f7e944b9b1fec", "committedDate": "2021-01-05T14:23:55Z", "message": "Add tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c99e0cd4c494cad5953b86286a1e0a48d38dc041", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c99e0cd4c494cad5953b86286a1e0a48d38dc041", "committedDate": "2021-01-05T14:23:55Z", "message": "Refactor `getTypeIntersection`\n\nRefactored the `getTypeIntersection` method to accept the package env as a parameter.\nThis was done since the Types class was a stateless class and having a state variable such as env was violating this. Hence we had to modify the method to accept the environment as a parameter."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ba920b93d710a1d1c62b441b3ecdefb5b350f7ea", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/ba920b93d710a1d1c62b441b3ecdefb5b350f7ea", "committedDate": "2021-01-05T14:23:55Z", "message": "Fix int long conversion of flags after master change"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "abef5a49a90fb280cc12f7bf9f55795b94d3bad3", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/abef5a49a90fb280cc12f7bf9f55795b94d3bad3", "committedDate": "2021-01-05T14:24:35Z", "message": "Sync with master\n\nMoved the new error type to `DiagnosticErrorCode`"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a30d526411ea9bf711577af42bf23828824e369a", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a30d526411ea9bf711577af42bf23828824e369a", "committedDate": "2021-01-05T14:24:35Z", "message": "Fix SymbolEnter\n\nFixed an issue where inline intersection type descriptors were not captured."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "333aaf8ea9fd63c5794304741fc1b863d06a8acf", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/333aaf8ea9fd63c5794304741fc1b863d06a8acf", "committedDate": "2021-01-05T14:24:36Z", "message": "Restructure SymbolEnter\n\nRestructured SymbolEnter to calculate error intersection more generically using SymbolResolver"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cd06c43d9093d44bd3f5a91258757892aab1022a", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/cd06c43d9093d44bd3f5a91258757892aab1022a", "committedDate": "2021-01-05T14:24:36Z", "message": "Update compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\n\nCo-authored-by: Maryam Ziyad <maryamziyadm@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ae95a020bde7449ad6a9778c818de558e17d1ff7", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/ae95a020bde7449ad6a9778c818de558e17d1ff7", "committedDate": "2021-01-05T13:52:34Z", "message": "Update DiagnosticErrorCode.java"}, "afterCommit": {"oid": "e7a8a5c44737c0d06b8d95ecaa071238f4737e49", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e7a8a5c44737c0d06b8d95ecaa071238f4737e49", "committedDate": "2021-01-05T14:24:36Z", "message": "Add new checks for map and record intersection\n\nWhen intersecting a map and a record, now the checks are validating each field with the constraint of the map.\nIf a field is optional and the intersection is an error, we skip that for the generated type.\nIn case it's not optional the intersection is a semantic error."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "12caaadf90d031ab01b8ae5c4fcc3463c765037c", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/12caaadf90d031ab01b8ae5c4fcc3463c765037c", "committedDate": "2021-01-05T18:19:00Z", "message": "Add new checks for map and record intersection\n\nWhen intersecting a map and a record, now the checks are validating each field with the constraint of the map.\nIf a field is optional and the intersection is an error, we skip that for the generated type.\nIn case it's not optional the intersection is a semantic error."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e7a8a5c44737c0d06b8d95ecaa071238f4737e49", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e7a8a5c44737c0d06b8d95ecaa071238f4737e49", "committedDate": "2021-01-05T14:24:36Z", "message": "Add new checks for map and record intersection\n\nWhen intersecting a map and a record, now the checks are validating each field with the constraint of the map.\nIf a field is optional and the intersection is an error, we skip that for the generated type.\nIn case it's not optional the intersection is a semantic error."}, "afterCommit": {"oid": "12caaadf90d031ab01b8ae5c4fcc3463c765037c", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/12caaadf90d031ab01b8ae5c4fcc3463c765037c", "committedDate": "2021-01-05T18:19:00Z", "message": "Add new checks for map and record intersection\n\nWhen intersecting a map and a record, now the checks are validating each field with the constraint of the map.\nIf a field is optional and the intersection is an error, we skip that for the generated type.\nIn case it's not optional the intersection is a semantic error."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8a2d376d4cf14cdfdc5a1864d3e749ccc7a0b6b7", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/8a2d376d4cf14cdfdc5a1864d3e749ccc7a0b6b7", "committedDate": "2021-01-06T04:26:22Z", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into intersection-error-type"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYyMzE5Njc1", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#pullrequestreview-562319675", "createdAt": "2021-01-06T04:35:43Z", "commit": {"oid": "8a2d376d4cf14cdfdc5a1864d3e749ccc7a0b6b7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQwNDozNTo0M1rOIOxoBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQwNDozNTo0M1rOIOxoBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM2NDAzNg==", "bodyText": "Extra new line", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#discussion_r552364036", "createdAt": "2021-01-06T04:35:43Z", "author": {"login": "rdhananjaya"}, "path": "compiler/ballerina-lang/src/main/java/org/ballerinalang/util/diagnostic/DiagnosticErrorCode.java", "diffHunk": "@@ -660,6 +660,7 @@\n     SERVICE_LITERAL_REQUIRED_BY_LISTENER(\"BCE3973\", \"service.path.literal.required.by.listener\"),\n     SERVICE_ABSOLUTE_PATH_REQUIRED_BY_LISTENER(\"BCE3974\", \"service.absolute.path.required.by.listener\"),\n     MULTIPLE_RECEIVE_ACTION_NOT_YET_SUPPORTED(\"BCE3975\", \"multiple.receive.action.not.yet.supported\"),\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a2d376d4cf14cdfdc5a1864d3e749ccc7a0b6b7"}, "originalPosition": 4}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9f4685f2a1e77e3030c00d8b66d7fc6e43223d04", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/9f4685f2a1e77e3030c00d8b66d7fc6e43223d04", "committedDate": "2021-01-06T04:37:22Z", "message": "Fix typo in DiagnosticErrorCode"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYyMzI0OTgx", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#pullrequestreview-562324981", "createdAt": "2021-01-06T04:55:59Z", "commit": {"oid": "9f4685f2a1e77e3030c00d8b66d7fc6e43223d04"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQwNDo1NzoxNFrOIOx8ng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQwNDo1NzoxNFrOIOx8ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM2OTMxMA==", "bodyText": "Shall we add a comment explaining this", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#discussion_r552369310", "createdAt": "2021-01-06T04:57:14Z", "author": {"login": "rdhananjaya"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/SymbolEnter.java", "diffHunk": "@@ -1969,6 +2058,9 @@ private void addTopLevelNode(BLangPackage pkgNode, TopLevelNode node) {\n \n     private void defineErrorDetails(List<BLangTypeDefinition> typeDefNodes, SymbolEnv pkgEnv) {\n         for (BLangTypeDefinition typeDef : typeDefNodes) {\n+            if (typeDef.symbol == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f4685f2a1e77e3030c00d8b66d7fc6e43223d04"}, "originalPosition": 180}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYyMzQwNzIw", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#pullrequestreview-562340720", "createdAt": "2021-01-06T05:50:33Z", "commit": {"oid": "9f4685f2a1e77e3030c00d8b66d7fc6e43223d04"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQwNTo1MDozM1rOIOyyQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQwNTo1MDozM1rOIOyyQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM4MzA0Mw==", "bodyText": "can we use this \n  \n    \n      ballerina-lang/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/ASTBuilderUtil.java\n    \n    \n         Line 704\n      in\n      1ce30c6\n    \n    \n    \n    \n\n        \n          \n           public static BLangIdentifier createIdentifier(Location pos, String value) {", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#discussion_r552383043", "createdAt": "2021-01-06T05:50:33Z", "author": {"login": "rdhananjaya"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/util/TypeDefBuilderHelper.java", "diffHunk": "@@ -215,4 +218,29 @@ public static BLangClassDefinition createClassDef(Location pos, BObjectTypeSymbo\n \n         return classDefNode;\n     }\n+\n+    public static BLangErrorType createBLangErrorType(Location pos, BType detailType, String name) {\n+        BLangErrorType errorType = (BLangErrorType) TreeBuilder.createErrorTypeNode();\n+        BLangUserDefinedType userDefinedTypeNode = (BLangUserDefinedType) TreeBuilder.createUserDefinedTypeNode();\n+        userDefinedTypeNode.pos = pos;\n+        userDefinedTypeNode.pkgAlias = (BLangIdentifier) TreeBuilder.createIdentifierNode();\n+        userDefinedTypeNode.typeName = createIdentifier(pos, name);\n+        userDefinedTypeNode.type = detailType;\n+        errorType.detailType = userDefinedTypeNode;\n+\n+        return errorType;\n+    }\n+\n+    private static BLangIdentifier createIdentifier(Location pos, String value) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f4685f2a1e77e3030c00d8b66d7fc6e43223d04"}, "originalPosition": 32}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6b48b989a6e89db776f6a4f4e04cf1a146ee9662", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6b48b989a6e89db776f6a4f4e04cf1a146ee9662", "committedDate": "2021-01-06T07:15:35Z", "message": "Remove redundant checks"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0dc061f4e467003f6597c5721c3c100fdc9447e0", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/0dc061f4e467003f6597c5721c3c100fdc9447e0", "committedDate": "2021-01-06T05:43:04Z", "message": "Remove redundant checks"}, "afterCommit": {"oid": "6b48b989a6e89db776f6a4f4e04cf1a146ee9662", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6b48b989a6e89db776f6a4f4e04cf1a146ee9662", "committedDate": "2021-01-06T07:15:35Z", "message": "Remove redundant checks"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2a5d85985eb0e5f9ee381ab0f1dcc5b94babc7ea", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2a5d85985eb0e5f9ee381ab0f1dcc5b94babc7ea", "committedDate": "2021-01-06T11:37:17Z", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into intersection-error-type"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a13ccacbf4b858b2c11ccd35304adaef0d224e1e", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a13ccacbf4b858b2c11ccd35304adaef0d224e1e", "committedDate": "2021-01-07T04:39:28Z", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into intersection-error-type\n\n# Conflicts:\n#\tcompiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/SymbolEnter.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9800d6df336b8a4c2d82d712f02f825b32ddfdee", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/9800d6df336b8a4c2d82d712f02f825b32ddfdee", "committedDate": "2021-01-08T06:59:01Z", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into intersection-error-type\n\n# Conflicts:\n#\tcompiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/SymbolEnter.java\n#\tcompiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "612b5b6d1927b22b1ba602f10d9ccee82779b839", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/612b5b6d1927b22b1ba602f10d9ccee82779b839", "committedDate": "2021-01-08T07:04:44Z", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into intersection-error-type"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d8a122cf73dfbd63eb0fdbf70e44b13444939b9a", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/d8a122cf73dfbd63eb0fdbf70e44b13444939b9a", "committedDate": "2021-01-08T06:59:12Z", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into intersection-error-type"}, "afterCommit": {"oid": "612b5b6d1927b22b1ba602f10d9ccee82779b839", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/612b5b6d1927b22b1ba602f10d9ccee82779b839", "committedDate": "2021-01-08T07:04:44Z", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into intersection-error-type"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f13fca974dc6abb2c7a5e56295752883c6a7dd40", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f13fca974dc6abb2c7a5e56295752883c6a7dd40", "committedDate": "2021-01-08T08:31:31Z", "message": "Add tests for distinct error types\n\nThis commit adds testcases to test the new distinct type created by intersecting two errors."}, "afterCommit": {"oid": "c02333a494a4b35b471f66d3298761f48e3a6618", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c02333a494a4b35b471f66d3298761f48e3a6618", "committedDate": "2021-01-08T08:42:03Z", "message": "Add tests for distinct error types\n\nThis commit adds testcases to test the new distinct type created by intersecting two errors."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "23338fc8b5c97459aba261608c305777090bd850", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/23338fc8b5c97459aba261608c305777090bd850", "committedDate": "2021-01-08T09:47:37Z", "message": "Add tests for distinct error types\n\nThis commit adds testcases to test the new distinct type created by intersecting two errors."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c02333a494a4b35b471f66d3298761f48e3a6618", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c02333a494a4b35b471f66d3298761f48e3a6618", "committedDate": "2021-01-08T08:42:03Z", "message": "Add tests for distinct error types\n\nThis commit adds testcases to test the new distinct type created by intersecting two errors."}, "afterCommit": {"oid": "23338fc8b5c97459aba261608c305777090bd850", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/23338fc8b5c97459aba261608c305777090bd850", "committedDate": "2021-01-08T09:47:37Z", "message": "Add tests for distinct error types\n\nThis commit adds testcases to test the new distinct type created by intersecting two errors."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY0MTk5NDQw", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#pullrequestreview-564199440", "createdAt": "2021-01-08T11:43:45Z", "commit": {"oid": "23338fc8b5c97459aba261608c305777090bd850"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4975, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}