{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE3NDA0ODIw", "number": 23214, "reviewThreads": {"totalCount": 23, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwNDozMjozOVrOD8UZmQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxMzo0ODowN1rOD9zpTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NTc1Mzg1OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwNDozMjozOVrOGVLtvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwNDozODoxN1rOGVLyqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg2NTIxNQ==", "bodyText": "It is not correct to create typed-binding-patterns here. Reason is, this is a generic method to parse type-descs.\nBut typed-binding-patterns are not supported for all places where a type is supported.\ne.g: type-cast, func-return, type-parameter, etc. there are many places where a type-desc can appear without a binding pattern.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214#discussion_r424865215", "createdAt": "2020-05-14T04:32:39Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -1983,7 +1991,10 @@ private STNode parseComplexTypeDescriptor(STNode typeDesc, ParserRuleContext con\n                 return parseComplexTypeDescriptor(parseOptionalTypeDescriptor(typeDesc), context);\n             // If next token after a type descriptor is <code>[</code> then it is an array type descriptor\n             case OPEN_BRACKET_TOKEN:\n-                return parseComplexTypeDescriptor(parseArrayTypeDescriptor(typeDesc), context);\n+                if (isListBindingPattern()) { // return typed binding attern if we find a list-b-p\n+                    return STNodeFactory.createTypedBindingPatternNode(typeDesc, parseListBindingPattern());\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe25e580795f35d55553f029534baf4882072c7c"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg2NjQ3NA==", "bodyText": "hmmm, that makes sense. Fixed", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214#discussion_r424866474", "createdAt": "2020-05-14T04:38:17Z", "author": {"login": "m36dot"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -1983,7 +1991,10 @@ private STNode parseComplexTypeDescriptor(STNode typeDesc, ParserRuleContext con\n                 return parseComplexTypeDescriptor(parseOptionalTypeDescriptor(typeDesc), context);\n             // If next token after a type descriptor is <code>[</code> then it is an array type descriptor\n             case OPEN_BRACKET_TOKEN:\n-                return parseComplexTypeDescriptor(parseArrayTypeDescriptor(typeDesc), context);\n+                if (isListBindingPattern()) { // return typed binding attern if we find a list-b-p\n+                    return STNodeFactory.createTypedBindingPatternNode(typeDesc, parseListBindingPattern());\n+                }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg2NTIxNQ=="}, "originalCommit": {"oid": "fe25e580795f35d55553f029534baf4882072c7c"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1OTM0OTYyOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwMjozMjo1NlrOGXNuKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwMjozMjo1NlrOGXNuKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5NTI0MQ==", "bodyText": "Need a proper name for the flag.\nAlso, can it be a boolean instead of int?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214#discussion_r426995241", "createdAt": "2020-05-19T02:32:56Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -1953,18 +1951,26 @@ private STNode parseReturnsKeyword() {\n      *\n      * @return Parsed node\n      */\n-    private STNode parseTypeDescriptor(ParserRuleContext context) {\n+    private STNode parseTypeDescriptor(ParserRuleContext context, int flag) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e1d5994f3adf89a684d1d1f04dc32e4da40a034"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1OTM1NDg4OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwMjozNTo0MlrOGXNxPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwMjozNTo0MlrOGXNxPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5NjAyOQ==", "bodyText": "Can we please use the same pattern as in other places? If there is some issue, we should fix that, rather than changing this.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214#discussion_r426996029", "createdAt": "2020-05-19T02:35:42Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -8423,4 +8434,337 @@ private STNode parseParenthesisedTypeDesc() {\n         STNode closeParen = parseCloseParenthesis();\n         return STNodeFactory.createParenthesisedTypeDescriptorNode(openParen, typedesc, closeParen);\n     }\n+\n+    /**\n+     * Parse binding-patterns.\n+     *\n+     * binding-pattern :=\n+     *   capture-binding-pattern\n+     *    | wildcard-binding-pattern\n+     *    | list-binding-pattern\n+     *    | mapping-binding-pattern\n+     *    | functional-binding-pattern\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     * wildcard-binding-pattern := _\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *    binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ] \n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     * rest-binding-pattern := ... variable-name\n+     * functional-binding-pattern := functionally-constructible-type-reference ( arg-list-binding-pattern )\n+     * arg-list-binding-pattern :=\n+     *    positional-arg-binding-patterns [, other-arg-binding-patterns]\n+     *    | other-arg-binding-patterns\n+     * positional-arg-binding-patterns := positional-arg-binding-pattern (, positional-arg-binding-pattern)*\n+     * positional-arg-binding-pattern := binding-pattern\n+     * other-arg-binding-patterns :=\n+     *    named-arg-binding-patterns [, rest-binding-pattern]\n+     *    | [rest-binding-pattern]\n+     * named-arg-binding-patterns := named-arg-binding-pattern (, named-arg-binding-pattern)*\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n+     *\n+     * @return binding-pattern node\n+     */\n+    private STNode parseBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case OPEN_BRACKET_TOKEN:\n+                return parseListBindingPattern();\n+            case IDENTIFIER_TOKEN:\n+                return parseCaptureBindingPattern();\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse capture-binding-pattern.\n+     *\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     *\n+     * @return capture-binding-pattern node\n+     */\n+    private STNode parseCaptureBindingPattern() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case IDENTIFIER_TOKEN:\n+                STNode varName = parseVariableName();\n+                return STNodeFactory.createCaptureBindingPatternNode(varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.CAPTURE_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-patterns.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return list-binding-pattern node\n+     */\n+    private STNode parseListBindingPattern() {\n+        startContext(ParserRuleContext.LIST_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBracket = parseOpenBracket();\n+\n+        STNode listBindingPatternContent = parselistBindingPatternContent();\n+        bindingPatterns.add(listBindingPatternContent);\n+\n+        //parsing the main chunck of list-binding-pattern\n+        STToken token = getNextLBPToken(); // get next valid token\n+        STNode comma = null;\n+        while (!isEndOfListBindingPattern(token.kind) &&\n+                listBindingPatternContent.kind != SyntaxKind.REST_BINDING_PATTERN) {\n+            comma = parseComma();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e1d5994f3adf89a684d1d1f04dc32e4da40a034"}, "originalPosition": 244}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1OTM2MDQ0OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwMjozODo0OFrOGXN0nQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwMjozODo0OFrOGXN0nQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5Njg5Mw==", "bodyText": "Do we need all these?\nYou are terminating the loop if a rest-binding pattern is reached. So wouldn't  checking listBindingPatternContent after the loop be sufficient?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214#discussion_r426996893", "createdAt": "2020-05-19T02:38:48Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -8423,4 +8434,337 @@ private STNode parseParenthesisedTypeDesc() {\n         STNode closeParen = parseCloseParenthesis();\n         return STNodeFactory.createParenthesisedTypeDescriptorNode(openParen, typedesc, closeParen);\n     }\n+\n+    /**\n+     * Parse binding-patterns.\n+     *\n+     * binding-pattern :=\n+     *   capture-binding-pattern\n+     *    | wildcard-binding-pattern\n+     *    | list-binding-pattern\n+     *    | mapping-binding-pattern\n+     *    | functional-binding-pattern\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     * wildcard-binding-pattern := _\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *    binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ] \n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     * rest-binding-pattern := ... variable-name\n+     * functional-binding-pattern := functionally-constructible-type-reference ( arg-list-binding-pattern )\n+     * arg-list-binding-pattern :=\n+     *    positional-arg-binding-patterns [, other-arg-binding-patterns]\n+     *    | other-arg-binding-patterns\n+     * positional-arg-binding-patterns := positional-arg-binding-pattern (, positional-arg-binding-pattern)*\n+     * positional-arg-binding-pattern := binding-pattern\n+     * other-arg-binding-patterns :=\n+     *    named-arg-binding-patterns [, rest-binding-pattern]\n+     *    | [rest-binding-pattern]\n+     * named-arg-binding-patterns := named-arg-binding-pattern (, named-arg-binding-pattern)*\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n+     *\n+     * @return binding-pattern node\n+     */\n+    private STNode parseBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case OPEN_BRACKET_TOKEN:\n+                return parseListBindingPattern();\n+            case IDENTIFIER_TOKEN:\n+                return parseCaptureBindingPattern();\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse capture-binding-pattern.\n+     *\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     *\n+     * @return capture-binding-pattern node\n+     */\n+    private STNode parseCaptureBindingPattern() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case IDENTIFIER_TOKEN:\n+                STNode varName = parseVariableName();\n+                return STNodeFactory.createCaptureBindingPatternNode(varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.CAPTURE_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-patterns.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return list-binding-pattern node\n+     */\n+    private STNode parseListBindingPattern() {\n+        startContext(ParserRuleContext.LIST_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBracket = parseOpenBracket();\n+\n+        STNode listBindingPatternContent = parselistBindingPatternContent();\n+        bindingPatterns.add(listBindingPatternContent);\n+\n+        //parsing the main chunck of list-binding-pattern\n+        STToken token = getNextLBPToken(); // get next valid token\n+        STNode comma = null;\n+        while (!isEndOfListBindingPattern(token.kind) &&\n+                listBindingPatternContent.kind != SyntaxKind.REST_BINDING_PATTERN) {\n+            comma = parseComma();\n+            bindingPatterns.add(comma);\n+            listBindingPatternContent = parselistBindingPatternContent();\n+            bindingPatterns.add(listBindingPatternContent);\n+            token = getNextLBPToken();\n+        }\n+        STNode closeBracket = parseCloseBracket();\n+\n+        //seperating out the restbindingpattern\n+        STNode restBindingPattern = STNodeFactory.createEmptyNode();\n+        int lastIndex = bindingPatterns.size() - 1;\n+        STNode lastItem = bindingPatterns.get(lastIndex);\n+        if (lastItem.kind == SyntaxKind.REST_BINDING_PATTERN) {\n+            restBindingPattern = bindingPatterns.remove(lastIndex);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e1d5994f3adf89a684d1d1f04dc32e4da40a034"}, "originalPosition": 258}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1OTM2MTgzOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwMjozOTozN1rOGXN1aA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwMjozOTozN1rOGXN1aA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5NzA5Ng==", "bodyText": "Shall we rename this to listBindingPatternMember", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214#discussion_r426997096", "createdAt": "2020-05-19T02:39:37Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -8423,4 +8434,337 @@ private STNode parseParenthesisedTypeDesc() {\n         STNode closeParen = parseCloseParenthesis();\n         return STNodeFactory.createParenthesisedTypeDescriptorNode(openParen, typedesc, closeParen);\n     }\n+\n+    /**\n+     * Parse binding-patterns.\n+     *\n+     * binding-pattern :=\n+     *   capture-binding-pattern\n+     *    | wildcard-binding-pattern\n+     *    | list-binding-pattern\n+     *    | mapping-binding-pattern\n+     *    | functional-binding-pattern\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     * wildcard-binding-pattern := _\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *    binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ] \n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     * rest-binding-pattern := ... variable-name\n+     * functional-binding-pattern := functionally-constructible-type-reference ( arg-list-binding-pattern )\n+     * arg-list-binding-pattern :=\n+     *    positional-arg-binding-patterns [, other-arg-binding-patterns]\n+     *    | other-arg-binding-patterns\n+     * positional-arg-binding-patterns := positional-arg-binding-pattern (, positional-arg-binding-pattern)*\n+     * positional-arg-binding-pattern := binding-pattern\n+     * other-arg-binding-patterns :=\n+     *    named-arg-binding-patterns [, rest-binding-pattern]\n+     *    | [rest-binding-pattern]\n+     * named-arg-binding-patterns := named-arg-binding-pattern (, named-arg-binding-pattern)*\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n+     *\n+     * @return binding-pattern node\n+     */\n+    private STNode parseBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case OPEN_BRACKET_TOKEN:\n+                return parseListBindingPattern();\n+            case IDENTIFIER_TOKEN:\n+                return parseCaptureBindingPattern();\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse capture-binding-pattern.\n+     *\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     *\n+     * @return capture-binding-pattern node\n+     */\n+    private STNode parseCaptureBindingPattern() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case IDENTIFIER_TOKEN:\n+                STNode varName = parseVariableName();\n+                return STNodeFactory.createCaptureBindingPatternNode(varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.CAPTURE_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-patterns.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return list-binding-pattern node\n+     */\n+    private STNode parseListBindingPattern() {\n+        startContext(ParserRuleContext.LIST_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBracket = parseOpenBracket();\n+\n+        STNode listBindingPatternContent = parselistBindingPatternContent();\n+        bindingPatterns.add(listBindingPatternContent);\n+\n+        //parsing the main chunck of list-binding-pattern\n+        STToken token = getNextLBPToken(); // get next valid token\n+        STNode comma = null;\n+        while (!isEndOfListBindingPattern(token.kind) &&\n+                listBindingPatternContent.kind != SyntaxKind.REST_BINDING_PATTERN) {\n+            comma = parseComma();\n+            bindingPatterns.add(comma);\n+            listBindingPatternContent = parselistBindingPatternContent();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e1d5994f3adf89a684d1d1f04dc32e4da40a034"}, "originalPosition": 246}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1OTM2Mzg0OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwMjo0MDo0NVrOGXN2oQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwMjo0MDo0NVrOGXN2oQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5NzQwOQ==", "bodyText": "I don't think we should do this. Can't we  simply use peek()?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214#discussion_r426997409", "createdAt": "2020-05-19T02:40:45Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -8423,4 +8434,337 @@ private STNode parseParenthesisedTypeDesc() {\n         STNode closeParen = parseCloseParenthesis();\n         return STNodeFactory.createParenthesisedTypeDescriptorNode(openParen, typedesc, closeParen);\n     }\n+\n+    /**\n+     * Parse binding-patterns.\n+     *\n+     * binding-pattern :=\n+     *   capture-binding-pattern\n+     *    | wildcard-binding-pattern\n+     *    | list-binding-pattern\n+     *    | mapping-binding-pattern\n+     *    | functional-binding-pattern\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     * wildcard-binding-pattern := _\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *    binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ] \n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     * rest-binding-pattern := ... variable-name\n+     * functional-binding-pattern := functionally-constructible-type-reference ( arg-list-binding-pattern )\n+     * arg-list-binding-pattern :=\n+     *    positional-arg-binding-patterns [, other-arg-binding-patterns]\n+     *    | other-arg-binding-patterns\n+     * positional-arg-binding-patterns := positional-arg-binding-pattern (, positional-arg-binding-pattern)*\n+     * positional-arg-binding-pattern := binding-pattern\n+     * other-arg-binding-patterns :=\n+     *    named-arg-binding-patterns [, rest-binding-pattern]\n+     *    | [rest-binding-pattern]\n+     * named-arg-binding-patterns := named-arg-binding-pattern (, named-arg-binding-pattern)*\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n+     *\n+     * @return binding-pattern node\n+     */\n+    private STNode parseBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case OPEN_BRACKET_TOKEN:\n+                return parseListBindingPattern();\n+            case IDENTIFIER_TOKEN:\n+                return parseCaptureBindingPattern();\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse capture-binding-pattern.\n+     *\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     *\n+     * @return capture-binding-pattern node\n+     */\n+    private STNode parseCaptureBindingPattern() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case IDENTIFIER_TOKEN:\n+                STNode varName = parseVariableName();\n+                return STNodeFactory.createCaptureBindingPatternNode(varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.CAPTURE_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-patterns.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return list-binding-pattern node\n+     */\n+    private STNode parseListBindingPattern() {\n+        startContext(ParserRuleContext.LIST_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBracket = parseOpenBracket();\n+\n+        STNode listBindingPatternContent = parselistBindingPatternContent();\n+        bindingPatterns.add(listBindingPatternContent);\n+\n+        //parsing the main chunck of list-binding-pattern\n+        STToken token = getNextLBPToken(); // get next valid token\n+        STNode comma = null;\n+        while (!isEndOfListBindingPattern(token.kind) &&\n+                listBindingPatternContent.kind != SyntaxKind.REST_BINDING_PATTERN) {\n+            comma = parseComma();\n+            bindingPatterns.add(comma);\n+            listBindingPatternContent = parselistBindingPatternContent();\n+            bindingPatterns.add(listBindingPatternContent);\n+            token = getNextLBPToken();\n+        }\n+        STNode closeBracket = parseCloseBracket();\n+\n+        //seperating out the restbindingpattern\n+        STNode restBindingPattern = STNodeFactory.createEmptyNode();\n+        int lastIndex = bindingPatterns.size() - 1;\n+        STNode lastItem = bindingPatterns.get(lastIndex);\n+        if (lastItem.kind == SyntaxKind.REST_BINDING_PATTERN) {\n+            restBindingPattern = bindingPatterns.remove(lastIndex);\n+        }\n+\n+\n+        STNode bindingPatternsNode = STNodeFactory.createNodeList(bindingPatterns);\n+        endContext();\n+        return STNodeFactory.createListBindingPatternNode(openBracket,\n+                                                    bindingPatternsNode,\n+                                                    restBindingPattern,\n+                                                    closeBracket);\n+    }\n+\n+    private STToken getNextLBPToken() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e1d5994f3adf89a684d1d1f04dc32e4da40a034"}, "originalPosition": 269}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1OTM2NjY4OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwMjo0Mjo0N1rOGXN4fw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwMjo0Mjo0N1rOGXN4fw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5Nzg4Nw==", "bodyText": "Let's replace LPB with ListBindingPattern. Otherwise any new reader will have a hard time figuring out what it means", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214#discussion_r426997887", "createdAt": "2020-05-19T02:42:47Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -8423,4 +8434,337 @@ private STNode parseParenthesisedTypeDesc() {\n         STNode closeParen = parseCloseParenthesis();\n         return STNodeFactory.createParenthesisedTypeDescriptorNode(openParen, typedesc, closeParen);\n     }\n+\n+    /**\n+     * Parse binding-patterns.\n+     *\n+     * binding-pattern :=\n+     *   capture-binding-pattern\n+     *    | wildcard-binding-pattern\n+     *    | list-binding-pattern\n+     *    | mapping-binding-pattern\n+     *    | functional-binding-pattern\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     * wildcard-binding-pattern := _\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *    binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ] \n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     * rest-binding-pattern := ... variable-name\n+     * functional-binding-pattern := functionally-constructible-type-reference ( arg-list-binding-pattern )\n+     * arg-list-binding-pattern :=\n+     *    positional-arg-binding-patterns [, other-arg-binding-patterns]\n+     *    | other-arg-binding-patterns\n+     * positional-arg-binding-patterns := positional-arg-binding-pattern (, positional-arg-binding-pattern)*\n+     * positional-arg-binding-pattern := binding-pattern\n+     * other-arg-binding-patterns :=\n+     *    named-arg-binding-patterns [, rest-binding-pattern]\n+     *    | [rest-binding-pattern]\n+     * named-arg-binding-patterns := named-arg-binding-pattern (, named-arg-binding-pattern)*\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n+     *\n+     * @return binding-pattern node\n+     */\n+    private STNode parseBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case OPEN_BRACKET_TOKEN:\n+                return parseListBindingPattern();\n+            case IDENTIFIER_TOKEN:\n+                return parseCaptureBindingPattern();\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse capture-binding-pattern.\n+     *\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     *\n+     * @return capture-binding-pattern node\n+     */\n+    private STNode parseCaptureBindingPattern() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case IDENTIFIER_TOKEN:\n+                STNode varName = parseVariableName();\n+                return STNodeFactory.createCaptureBindingPatternNode(varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.CAPTURE_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-patterns.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return list-binding-pattern node\n+     */\n+    private STNode parseListBindingPattern() {\n+        startContext(ParserRuleContext.LIST_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBracket = parseOpenBracket();\n+\n+        STNode listBindingPatternContent = parselistBindingPatternContent();\n+        bindingPatterns.add(listBindingPatternContent);\n+\n+        //parsing the main chunck of list-binding-pattern\n+        STToken token = getNextLBPToken(); // get next valid token\n+        STNode comma = null;\n+        while (!isEndOfListBindingPattern(token.kind) &&\n+                listBindingPatternContent.kind != SyntaxKind.REST_BINDING_PATTERN) {\n+            comma = parseComma();\n+            bindingPatterns.add(comma);\n+            listBindingPatternContent = parselistBindingPatternContent();\n+            bindingPatterns.add(listBindingPatternContent);\n+            token = getNextLBPToken();\n+        }\n+        STNode closeBracket = parseCloseBracket();\n+\n+        //seperating out the restbindingpattern\n+        STNode restBindingPattern = STNodeFactory.createEmptyNode();\n+        int lastIndex = bindingPatterns.size() - 1;\n+        STNode lastItem = bindingPatterns.get(lastIndex);\n+        if (lastItem.kind == SyntaxKind.REST_BINDING_PATTERN) {\n+            restBindingPattern = bindingPatterns.remove(lastIndex);\n+        }\n+\n+\n+        STNode bindingPatternsNode = STNodeFactory.createNodeList(bindingPatterns);\n+        endContext();\n+        return STNodeFactory.createListBindingPatternNode(openBracket,\n+                                                    bindingPatternsNode,\n+                                                    restBindingPattern,\n+                                                    closeBracket);\n+    }\n+\n+    private STToken getNextLBPToken() {\n+        STToken token = peek();\n+\n+        if (isEndOfListBindingPattern(token.kind)) {\n+            return token;\n+        }\n+\n+        switch (token.kind) {\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+            case IDENTIFIER_TOKEN:\n+            case ELLIPSIS_TOKEN:\n+            case OPEN_BRACKET_TOKEN:\n+            case COMMA_TOKEN:\n+                return token;\n+            default:\n+                consume(); // use the invalid token\n+                this.errorHandler.reportInvalidNode(token,\n+                        \"invalid Token in list-binding-pattern\");\n+                return getNextLBPToken();\n+        }\n+    }\n+\n+    private boolean isEndOfListBindingPattern(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case IN_KEYWORD:\n+            case CLOSE_BRACKET_TOKEN:\n+            case EOF_TOKEN:\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+                return true;\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    /**\n+     * Parse rest-binding-pattern.\n+     *\n+     * rest-binding-pattern := ... variable-name\n+     *\n+     * @return rest-binding-pattern node\n+     */\n+    private STNode parseRestBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case ELLIPSIS_TOKEN:\n+                startContext(ParserRuleContext.REST_BINDING_PATTERN);\n+                STNode ellipsis = parseEllipsis();\n+                STNode varName = parseVariableName();\n+                endContext();\n+                return STNodeFactory.createRestBindingPatternNode(ellipsis, varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.REST_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-pattern entry.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return rest-binding-pattern node\n+     */\n+    private STNode parselistBindingPatternContent() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+                return consume();\n+            case ELLIPSIS_TOKEN:\n+                return parseRestBindingPattern();\n+            default:\n+                return parseBindingPattern();\n+        }\n+    }\n+\n+    /**\n+     * Parse Typed-binding-pattern.\n+     *\n+     * <code>typed-binding-pattern := inferable-type-descriptor binding-pattern</code>\n+     * <code>inferable-type-descriptor := type-descriptor | var</code>\n+     *\n+     * @return Fork statement\n+     */\n+    private STNode parseTypedBindingPattern() {\n+        startContext(ParserRuleContext.TYPED_BINDING_PATTERN);\n+        STNode typeDesc = parseTypeDescriptor(ParserRuleContext.TYPE_DESC_IN_TYPE_BINDING_PATTERN, 1);\n+\n+        STNode bindingPattern = null;\n+        if (peek().kind == SyntaxKind.OPEN_BRACKET_TOKEN) {\n+            STNode[] parsed = parseArrayTypeDescOrLBP(typeDesc);\n+            typeDesc = parsed[0];\n+            bindingPattern = parsed[1];\n+        } else {\n+            bindingPattern = parseBindingPattern();\n+        }\n+\n+        endContext();\n+        return STNodeFactory.createTypedBindingPatternNode(typeDesc, bindingPattern);\n+    }\n+\n+    private STNode[] parseArrayTypeDescOrLBP(STNode typeDesc) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e1d5994f3adf89a684d1d1f04dc32e4da40a034"}, "originalPosition": 380}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1OTM2Nzc5OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwMjo0MzozMFrOGXN5Ng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwMjo0MzozMFrOGXN5Ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5ODA3MA==", "bodyText": "Don't need to initialize", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214#discussion_r426998070", "createdAt": "2020-05-19T02:43:30Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -8423,4 +8434,337 @@ private STNode parseParenthesisedTypeDesc() {\n         STNode closeParen = parseCloseParenthesis();\n         return STNodeFactory.createParenthesisedTypeDescriptorNode(openParen, typedesc, closeParen);\n     }\n+\n+    /**\n+     * Parse binding-patterns.\n+     *\n+     * binding-pattern :=\n+     *   capture-binding-pattern\n+     *    | wildcard-binding-pattern\n+     *    | list-binding-pattern\n+     *    | mapping-binding-pattern\n+     *    | functional-binding-pattern\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     * wildcard-binding-pattern := _\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *    binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ] \n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     * rest-binding-pattern := ... variable-name\n+     * functional-binding-pattern := functionally-constructible-type-reference ( arg-list-binding-pattern )\n+     * arg-list-binding-pattern :=\n+     *    positional-arg-binding-patterns [, other-arg-binding-patterns]\n+     *    | other-arg-binding-patterns\n+     * positional-arg-binding-patterns := positional-arg-binding-pattern (, positional-arg-binding-pattern)*\n+     * positional-arg-binding-pattern := binding-pattern\n+     * other-arg-binding-patterns :=\n+     *    named-arg-binding-patterns [, rest-binding-pattern]\n+     *    | [rest-binding-pattern]\n+     * named-arg-binding-patterns := named-arg-binding-pattern (, named-arg-binding-pattern)*\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n+     *\n+     * @return binding-pattern node\n+     */\n+    private STNode parseBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case OPEN_BRACKET_TOKEN:\n+                return parseListBindingPattern();\n+            case IDENTIFIER_TOKEN:\n+                return parseCaptureBindingPattern();\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse capture-binding-pattern.\n+     *\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     *\n+     * @return capture-binding-pattern node\n+     */\n+    private STNode parseCaptureBindingPattern() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case IDENTIFIER_TOKEN:\n+                STNode varName = parseVariableName();\n+                return STNodeFactory.createCaptureBindingPatternNode(varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.CAPTURE_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-patterns.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return list-binding-pattern node\n+     */\n+    private STNode parseListBindingPattern() {\n+        startContext(ParserRuleContext.LIST_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBracket = parseOpenBracket();\n+\n+        STNode listBindingPatternContent = parselistBindingPatternContent();\n+        bindingPatterns.add(listBindingPatternContent);\n+\n+        //parsing the main chunck of list-binding-pattern\n+        STToken token = getNextLBPToken(); // get next valid token\n+        STNode comma = null;\n+        while (!isEndOfListBindingPattern(token.kind) &&\n+                listBindingPatternContent.kind != SyntaxKind.REST_BINDING_PATTERN) {\n+            comma = parseComma();\n+            bindingPatterns.add(comma);\n+            listBindingPatternContent = parselistBindingPatternContent();\n+            bindingPatterns.add(listBindingPatternContent);\n+            token = getNextLBPToken();\n+        }\n+        STNode closeBracket = parseCloseBracket();\n+\n+        //seperating out the restbindingpattern\n+        STNode restBindingPattern = STNodeFactory.createEmptyNode();\n+        int lastIndex = bindingPatterns.size() - 1;\n+        STNode lastItem = bindingPatterns.get(lastIndex);\n+        if (lastItem.kind == SyntaxKind.REST_BINDING_PATTERN) {\n+            restBindingPattern = bindingPatterns.remove(lastIndex);\n+        }\n+\n+\n+        STNode bindingPatternsNode = STNodeFactory.createNodeList(bindingPatterns);\n+        endContext();\n+        return STNodeFactory.createListBindingPatternNode(openBracket,\n+                                                    bindingPatternsNode,\n+                                                    restBindingPattern,\n+                                                    closeBracket);\n+    }\n+\n+    private STToken getNextLBPToken() {\n+        STToken token = peek();\n+\n+        if (isEndOfListBindingPattern(token.kind)) {\n+            return token;\n+        }\n+\n+        switch (token.kind) {\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+            case IDENTIFIER_TOKEN:\n+            case ELLIPSIS_TOKEN:\n+            case OPEN_BRACKET_TOKEN:\n+            case COMMA_TOKEN:\n+                return token;\n+            default:\n+                consume(); // use the invalid token\n+                this.errorHandler.reportInvalidNode(token,\n+                        \"invalid Token in list-binding-pattern\");\n+                return getNextLBPToken();\n+        }\n+    }\n+\n+    private boolean isEndOfListBindingPattern(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case IN_KEYWORD:\n+            case CLOSE_BRACKET_TOKEN:\n+            case EOF_TOKEN:\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+                return true;\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    /**\n+     * Parse rest-binding-pattern.\n+     *\n+     * rest-binding-pattern := ... variable-name\n+     *\n+     * @return rest-binding-pattern node\n+     */\n+    private STNode parseRestBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case ELLIPSIS_TOKEN:\n+                startContext(ParserRuleContext.REST_BINDING_PATTERN);\n+                STNode ellipsis = parseEllipsis();\n+                STNode varName = parseVariableName();\n+                endContext();\n+                return STNodeFactory.createRestBindingPatternNode(ellipsis, varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.REST_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-pattern entry.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return rest-binding-pattern node\n+     */\n+    private STNode parselistBindingPatternContent() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+                return consume();\n+            case ELLIPSIS_TOKEN:\n+                return parseRestBindingPattern();\n+            default:\n+                return parseBindingPattern();\n+        }\n+    }\n+\n+    /**\n+     * Parse Typed-binding-pattern.\n+     *\n+     * <code>typed-binding-pattern := inferable-type-descriptor binding-pattern</code>\n+     * <code>inferable-type-descriptor := type-descriptor | var</code>\n+     *\n+     * @return Fork statement\n+     */\n+    private STNode parseTypedBindingPattern() {\n+        startContext(ParserRuleContext.TYPED_BINDING_PATTERN);\n+        STNode typeDesc = parseTypeDescriptor(ParserRuleContext.TYPE_DESC_IN_TYPE_BINDING_PATTERN, 1);\n+\n+        STNode bindingPattern = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e1d5994f3adf89a684d1d1f04dc32e4da40a034"}, "originalPosition": 367}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1OTQzMzg1OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwMzoyNjoxMVrOGXOh4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwMzoyNjoxMVrOGXOh4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAwODQ4MQ==", "bodyText": "Without returning an array of STNode, can we create the final typed-binding-pattern here and return?\nSame for below cases as well", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214#discussion_r427008481", "createdAt": "2020-05-19T03:26:11Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -8423,4 +8434,337 @@ private STNode parseParenthesisedTypeDesc() {\n         STNode closeParen = parseCloseParenthesis();\n         return STNodeFactory.createParenthesisedTypeDescriptorNode(openParen, typedesc, closeParen);\n     }\n+\n+    /**\n+     * Parse binding-patterns.\n+     *\n+     * binding-pattern :=\n+     *   capture-binding-pattern\n+     *    | wildcard-binding-pattern\n+     *    | list-binding-pattern\n+     *    | mapping-binding-pattern\n+     *    | functional-binding-pattern\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     * wildcard-binding-pattern := _\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *    binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ] \n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     * rest-binding-pattern := ... variable-name\n+     * functional-binding-pattern := functionally-constructible-type-reference ( arg-list-binding-pattern )\n+     * arg-list-binding-pattern :=\n+     *    positional-arg-binding-patterns [, other-arg-binding-patterns]\n+     *    | other-arg-binding-patterns\n+     * positional-arg-binding-patterns := positional-arg-binding-pattern (, positional-arg-binding-pattern)*\n+     * positional-arg-binding-pattern := binding-pattern\n+     * other-arg-binding-patterns :=\n+     *    named-arg-binding-patterns [, rest-binding-pattern]\n+     *    | [rest-binding-pattern]\n+     * named-arg-binding-patterns := named-arg-binding-pattern (, named-arg-binding-pattern)*\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n+     *\n+     * @return binding-pattern node\n+     */\n+    private STNode parseBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case OPEN_BRACKET_TOKEN:\n+                return parseListBindingPattern();\n+            case IDENTIFIER_TOKEN:\n+                return parseCaptureBindingPattern();\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse capture-binding-pattern.\n+     *\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     *\n+     * @return capture-binding-pattern node\n+     */\n+    private STNode parseCaptureBindingPattern() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case IDENTIFIER_TOKEN:\n+                STNode varName = parseVariableName();\n+                return STNodeFactory.createCaptureBindingPatternNode(varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.CAPTURE_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-patterns.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return list-binding-pattern node\n+     */\n+    private STNode parseListBindingPattern() {\n+        startContext(ParserRuleContext.LIST_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBracket = parseOpenBracket();\n+\n+        STNode listBindingPatternContent = parselistBindingPatternContent();\n+        bindingPatterns.add(listBindingPatternContent);\n+\n+        //parsing the main chunck of list-binding-pattern\n+        STToken token = getNextLBPToken(); // get next valid token\n+        STNode comma = null;\n+        while (!isEndOfListBindingPattern(token.kind) &&\n+                listBindingPatternContent.kind != SyntaxKind.REST_BINDING_PATTERN) {\n+            comma = parseComma();\n+            bindingPatterns.add(comma);\n+            listBindingPatternContent = parselistBindingPatternContent();\n+            bindingPatterns.add(listBindingPatternContent);\n+            token = getNextLBPToken();\n+        }\n+        STNode closeBracket = parseCloseBracket();\n+\n+        //seperating out the restbindingpattern\n+        STNode restBindingPattern = STNodeFactory.createEmptyNode();\n+        int lastIndex = bindingPatterns.size() - 1;\n+        STNode lastItem = bindingPatterns.get(lastIndex);\n+        if (lastItem.kind == SyntaxKind.REST_BINDING_PATTERN) {\n+            restBindingPattern = bindingPatterns.remove(lastIndex);\n+        }\n+\n+\n+        STNode bindingPatternsNode = STNodeFactory.createNodeList(bindingPatterns);\n+        endContext();\n+        return STNodeFactory.createListBindingPatternNode(openBracket,\n+                                                    bindingPatternsNode,\n+                                                    restBindingPattern,\n+                                                    closeBracket);\n+    }\n+\n+    private STToken getNextLBPToken() {\n+        STToken token = peek();\n+\n+        if (isEndOfListBindingPattern(token.kind)) {\n+            return token;\n+        }\n+\n+        switch (token.kind) {\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+            case IDENTIFIER_TOKEN:\n+            case ELLIPSIS_TOKEN:\n+            case OPEN_BRACKET_TOKEN:\n+            case COMMA_TOKEN:\n+                return token;\n+            default:\n+                consume(); // use the invalid token\n+                this.errorHandler.reportInvalidNode(token,\n+                        \"invalid Token in list-binding-pattern\");\n+                return getNextLBPToken();\n+        }\n+    }\n+\n+    private boolean isEndOfListBindingPattern(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case IN_KEYWORD:\n+            case CLOSE_BRACKET_TOKEN:\n+            case EOF_TOKEN:\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+                return true;\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    /**\n+     * Parse rest-binding-pattern.\n+     *\n+     * rest-binding-pattern := ... variable-name\n+     *\n+     * @return rest-binding-pattern node\n+     */\n+    private STNode parseRestBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case ELLIPSIS_TOKEN:\n+                startContext(ParserRuleContext.REST_BINDING_PATTERN);\n+                STNode ellipsis = parseEllipsis();\n+                STNode varName = parseVariableName();\n+                endContext();\n+                return STNodeFactory.createRestBindingPatternNode(ellipsis, varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.REST_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-pattern entry.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return rest-binding-pattern node\n+     */\n+    private STNode parselistBindingPatternContent() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+                return consume();\n+            case ELLIPSIS_TOKEN:\n+                return parseRestBindingPattern();\n+            default:\n+                return parseBindingPattern();\n+        }\n+    }\n+\n+    /**\n+     * Parse Typed-binding-pattern.\n+     *\n+     * <code>typed-binding-pattern := inferable-type-descriptor binding-pattern</code>\n+     * <code>inferable-type-descriptor := type-descriptor | var</code>\n+     *\n+     * @return Fork statement\n+     */\n+    private STNode parseTypedBindingPattern() {\n+        startContext(ParserRuleContext.TYPED_BINDING_PATTERN);\n+        STNode typeDesc = parseTypeDescriptor(ParserRuleContext.TYPE_DESC_IN_TYPE_BINDING_PATTERN, 1);\n+\n+        STNode bindingPattern = null;\n+        if (peek().kind == SyntaxKind.OPEN_BRACKET_TOKEN) {\n+            STNode[] parsed = parseArrayTypeDescOrLBP(typeDesc);\n+            typeDesc = parsed[0];\n+            bindingPattern = parsed[1];\n+        } else {\n+            bindingPattern = parseBindingPattern();\n+        }\n+\n+        endContext();\n+        return STNodeFactory.createTypedBindingPatternNode(typeDesc, bindingPattern);\n+    }\n+\n+    private STNode[] parseArrayTypeDescOrLBP(STNode typeDesc) {\n+\n+        STNode arrayDescOrBLP = parseListBindingPattern();\n+\n+        if (isLBPDefinitively(arrayDescOrBLP)) { // ambiguous means T[a]\n+            return new STNode[]{typeDesc, cleanLBP(arrayDescOrBLP)};", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e1d5994f3adf89a684d1d1f04dc32e4da40a034"}, "originalPosition": 385}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1OTQzNzUyOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwMzoyODo0OFrOGXOkJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwMzoyODo0OFrOGXOkJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAwOTA2Mw==", "bodyText": "lets have a better name for the second parameter. (also should start with lower case)", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214#discussion_r427009063", "createdAt": "2020-05-19T03:28:48Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -8423,4 +8434,337 @@ private STNode parseParenthesisedTypeDesc() {\n         STNode closeParen = parseCloseParenthesis();\n         return STNodeFactory.createParenthesisedTypeDescriptorNode(openParen, typedesc, closeParen);\n     }\n+\n+    /**\n+     * Parse binding-patterns.\n+     *\n+     * binding-pattern :=\n+     *   capture-binding-pattern\n+     *    | wildcard-binding-pattern\n+     *    | list-binding-pattern\n+     *    | mapping-binding-pattern\n+     *    | functional-binding-pattern\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     * wildcard-binding-pattern := _\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *    binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ] \n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     * rest-binding-pattern := ... variable-name\n+     * functional-binding-pattern := functionally-constructible-type-reference ( arg-list-binding-pattern )\n+     * arg-list-binding-pattern :=\n+     *    positional-arg-binding-patterns [, other-arg-binding-patterns]\n+     *    | other-arg-binding-patterns\n+     * positional-arg-binding-patterns := positional-arg-binding-pattern (, positional-arg-binding-pattern)*\n+     * positional-arg-binding-pattern := binding-pattern\n+     * other-arg-binding-patterns :=\n+     *    named-arg-binding-patterns [, rest-binding-pattern]\n+     *    | [rest-binding-pattern]\n+     * named-arg-binding-patterns := named-arg-binding-pattern (, named-arg-binding-pattern)*\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n+     *\n+     * @return binding-pattern node\n+     */\n+    private STNode parseBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case OPEN_BRACKET_TOKEN:\n+                return parseListBindingPattern();\n+            case IDENTIFIER_TOKEN:\n+                return parseCaptureBindingPattern();\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse capture-binding-pattern.\n+     *\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     *\n+     * @return capture-binding-pattern node\n+     */\n+    private STNode parseCaptureBindingPattern() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case IDENTIFIER_TOKEN:\n+                STNode varName = parseVariableName();\n+                return STNodeFactory.createCaptureBindingPatternNode(varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.CAPTURE_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-patterns.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return list-binding-pattern node\n+     */\n+    private STNode parseListBindingPattern() {\n+        startContext(ParserRuleContext.LIST_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBracket = parseOpenBracket();\n+\n+        STNode listBindingPatternContent = parselistBindingPatternContent();\n+        bindingPatterns.add(listBindingPatternContent);\n+\n+        //parsing the main chunck of list-binding-pattern\n+        STToken token = getNextLBPToken(); // get next valid token\n+        STNode comma = null;\n+        while (!isEndOfListBindingPattern(token.kind) &&\n+                listBindingPatternContent.kind != SyntaxKind.REST_BINDING_PATTERN) {\n+            comma = parseComma();\n+            bindingPatterns.add(comma);\n+            listBindingPatternContent = parselistBindingPatternContent();\n+            bindingPatterns.add(listBindingPatternContent);\n+            token = getNextLBPToken();\n+        }\n+        STNode closeBracket = parseCloseBracket();\n+\n+        //seperating out the restbindingpattern\n+        STNode restBindingPattern = STNodeFactory.createEmptyNode();\n+        int lastIndex = bindingPatterns.size() - 1;\n+        STNode lastItem = bindingPatterns.get(lastIndex);\n+        if (lastItem.kind == SyntaxKind.REST_BINDING_PATTERN) {\n+            restBindingPattern = bindingPatterns.remove(lastIndex);\n+        }\n+\n+\n+        STNode bindingPatternsNode = STNodeFactory.createNodeList(bindingPatterns);\n+        endContext();\n+        return STNodeFactory.createListBindingPatternNode(openBracket,\n+                                                    bindingPatternsNode,\n+                                                    restBindingPattern,\n+                                                    closeBracket);\n+    }\n+\n+    private STToken getNextLBPToken() {\n+        STToken token = peek();\n+\n+        if (isEndOfListBindingPattern(token.kind)) {\n+            return token;\n+        }\n+\n+        switch (token.kind) {\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+            case IDENTIFIER_TOKEN:\n+            case ELLIPSIS_TOKEN:\n+            case OPEN_BRACKET_TOKEN:\n+            case COMMA_TOKEN:\n+                return token;\n+            default:\n+                consume(); // use the invalid token\n+                this.errorHandler.reportInvalidNode(token,\n+                        \"invalid Token in list-binding-pattern\");\n+                return getNextLBPToken();\n+        }\n+    }\n+\n+    private boolean isEndOfListBindingPattern(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case IN_KEYWORD:\n+            case CLOSE_BRACKET_TOKEN:\n+            case EOF_TOKEN:\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+                return true;\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    /**\n+     * Parse rest-binding-pattern.\n+     *\n+     * rest-binding-pattern := ... variable-name\n+     *\n+     * @return rest-binding-pattern node\n+     */\n+    private STNode parseRestBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case ELLIPSIS_TOKEN:\n+                startContext(ParserRuleContext.REST_BINDING_PATTERN);\n+                STNode ellipsis = parseEllipsis();\n+                STNode varName = parseVariableName();\n+                endContext();\n+                return STNodeFactory.createRestBindingPatternNode(ellipsis, varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.REST_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-pattern entry.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return rest-binding-pattern node\n+     */\n+    private STNode parselistBindingPatternContent() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+                return consume();\n+            case ELLIPSIS_TOKEN:\n+                return parseRestBindingPattern();\n+            default:\n+                return parseBindingPattern();\n+        }\n+    }\n+\n+    /**\n+     * Parse Typed-binding-pattern.\n+     *\n+     * <code>typed-binding-pattern := inferable-type-descriptor binding-pattern</code>\n+     * <code>inferable-type-descriptor := type-descriptor | var</code>\n+     *\n+     * @return Fork statement\n+     */\n+    private STNode parseTypedBindingPattern() {\n+        startContext(ParserRuleContext.TYPED_BINDING_PATTERN);\n+        STNode typeDesc = parseTypeDescriptor(ParserRuleContext.TYPE_DESC_IN_TYPE_BINDING_PATTERN, 1);\n+\n+        STNode bindingPattern = null;\n+        if (peek().kind == SyntaxKind.OPEN_BRACKET_TOKEN) {\n+            STNode[] parsed = parseArrayTypeDescOrLBP(typeDesc);\n+            typeDesc = parsed[0];\n+            bindingPattern = parsed[1];\n+        } else {\n+            bindingPattern = parseBindingPattern();\n+        }\n+\n+        endContext();\n+        return STNodeFactory.createTypedBindingPatternNode(typeDesc, bindingPattern);\n+    }\n+\n+    private STNode[] parseArrayTypeDescOrLBP(STNode typeDesc) {\n+\n+        STNode arrayDescOrBLP = parseListBindingPattern();\n+\n+        if (isLBPDefinitively(arrayDescOrBLP)) { // ambiguous means T[a]\n+            return new STNode[]{typeDesc, cleanLBP(arrayDescOrBLP)};\n+        } else {\n+            if (isFollowTypedBindingPattern(peek().kind)) {\n+                return new STNode[]{typeDesc, cleanLBP(arrayDescOrBLP)};\n+            } else {\n+                typeDesc = mergeTypeDescAndLBP(typeDesc, arrayDescOrBLP);\n+                if (peek().kind == SyntaxKind.OPEN_BRACKET_TOKEN) {\n+                    //this means arrayDescOrBLP is a array type desc\n+                    return parseArrayTypeDescOrLBP(typeDesc);\n+                } else {\n+                    return new STNode[]{typeDesc, parseBindingPattern()};\n+                }\n+            }\n+        }\n+    }\n+\n+    private STNode mergeTypeDescAndLBP(STNode typeDesc, STNode LBP) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e1d5994f3adf89a684d1d1f04dc32e4da40a034"}, "originalPosition": 401}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1OTQ0MjA2OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwMzozMToxNFrOGXOmuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwMzozMToxNFrOGXOmuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAwOTcyMQ==", "bodyText": "Don't need 'else', since you are returning inside 'if'", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214#discussion_r427009721", "createdAt": "2020-05-19T03:31:14Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -8423,4 +8434,337 @@ private STNode parseParenthesisedTypeDesc() {\n         STNode closeParen = parseCloseParenthesis();\n         return STNodeFactory.createParenthesisedTypeDescriptorNode(openParen, typedesc, closeParen);\n     }\n+\n+    /**\n+     * Parse binding-patterns.\n+     *\n+     * binding-pattern :=\n+     *   capture-binding-pattern\n+     *    | wildcard-binding-pattern\n+     *    | list-binding-pattern\n+     *    | mapping-binding-pattern\n+     *    | functional-binding-pattern\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     * wildcard-binding-pattern := _\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *    binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ] \n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     * rest-binding-pattern := ... variable-name\n+     * functional-binding-pattern := functionally-constructible-type-reference ( arg-list-binding-pattern )\n+     * arg-list-binding-pattern :=\n+     *    positional-arg-binding-patterns [, other-arg-binding-patterns]\n+     *    | other-arg-binding-patterns\n+     * positional-arg-binding-patterns := positional-arg-binding-pattern (, positional-arg-binding-pattern)*\n+     * positional-arg-binding-pattern := binding-pattern\n+     * other-arg-binding-patterns :=\n+     *    named-arg-binding-patterns [, rest-binding-pattern]\n+     *    | [rest-binding-pattern]\n+     * named-arg-binding-patterns := named-arg-binding-pattern (, named-arg-binding-pattern)*\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n+     *\n+     * @return binding-pattern node\n+     */\n+    private STNode parseBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case OPEN_BRACKET_TOKEN:\n+                return parseListBindingPattern();\n+            case IDENTIFIER_TOKEN:\n+                return parseCaptureBindingPattern();\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse capture-binding-pattern.\n+     *\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     *\n+     * @return capture-binding-pattern node\n+     */\n+    private STNode parseCaptureBindingPattern() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case IDENTIFIER_TOKEN:\n+                STNode varName = parseVariableName();\n+                return STNodeFactory.createCaptureBindingPatternNode(varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.CAPTURE_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-patterns.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return list-binding-pattern node\n+     */\n+    private STNode parseListBindingPattern() {\n+        startContext(ParserRuleContext.LIST_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBracket = parseOpenBracket();\n+\n+        STNode listBindingPatternContent = parselistBindingPatternContent();\n+        bindingPatterns.add(listBindingPatternContent);\n+\n+        //parsing the main chunck of list-binding-pattern\n+        STToken token = getNextLBPToken(); // get next valid token\n+        STNode comma = null;\n+        while (!isEndOfListBindingPattern(token.kind) &&\n+                listBindingPatternContent.kind != SyntaxKind.REST_BINDING_PATTERN) {\n+            comma = parseComma();\n+            bindingPatterns.add(comma);\n+            listBindingPatternContent = parselistBindingPatternContent();\n+            bindingPatterns.add(listBindingPatternContent);\n+            token = getNextLBPToken();\n+        }\n+        STNode closeBracket = parseCloseBracket();\n+\n+        //seperating out the restbindingpattern\n+        STNode restBindingPattern = STNodeFactory.createEmptyNode();\n+        int lastIndex = bindingPatterns.size() - 1;\n+        STNode lastItem = bindingPatterns.get(lastIndex);\n+        if (lastItem.kind == SyntaxKind.REST_BINDING_PATTERN) {\n+            restBindingPattern = bindingPatterns.remove(lastIndex);\n+        }\n+\n+\n+        STNode bindingPatternsNode = STNodeFactory.createNodeList(bindingPatterns);\n+        endContext();\n+        return STNodeFactory.createListBindingPatternNode(openBracket,\n+                                                    bindingPatternsNode,\n+                                                    restBindingPattern,\n+                                                    closeBracket);\n+    }\n+\n+    private STToken getNextLBPToken() {\n+        STToken token = peek();\n+\n+        if (isEndOfListBindingPattern(token.kind)) {\n+            return token;\n+        }\n+\n+        switch (token.kind) {\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+            case IDENTIFIER_TOKEN:\n+            case ELLIPSIS_TOKEN:\n+            case OPEN_BRACKET_TOKEN:\n+            case COMMA_TOKEN:\n+                return token;\n+            default:\n+                consume(); // use the invalid token\n+                this.errorHandler.reportInvalidNode(token,\n+                        \"invalid Token in list-binding-pattern\");\n+                return getNextLBPToken();\n+        }\n+    }\n+\n+    private boolean isEndOfListBindingPattern(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case IN_KEYWORD:\n+            case CLOSE_BRACKET_TOKEN:\n+            case EOF_TOKEN:\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+                return true;\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    /**\n+     * Parse rest-binding-pattern.\n+     *\n+     * rest-binding-pattern := ... variable-name\n+     *\n+     * @return rest-binding-pattern node\n+     */\n+    private STNode parseRestBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case ELLIPSIS_TOKEN:\n+                startContext(ParserRuleContext.REST_BINDING_PATTERN);\n+                STNode ellipsis = parseEllipsis();\n+                STNode varName = parseVariableName();\n+                endContext();\n+                return STNodeFactory.createRestBindingPatternNode(ellipsis, varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.REST_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-pattern entry.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return rest-binding-pattern node\n+     */\n+    private STNode parselistBindingPatternContent() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+                return consume();\n+            case ELLIPSIS_TOKEN:\n+                return parseRestBindingPattern();\n+            default:\n+                return parseBindingPattern();\n+        }\n+    }\n+\n+    /**\n+     * Parse Typed-binding-pattern.\n+     *\n+     * <code>typed-binding-pattern := inferable-type-descriptor binding-pattern</code>\n+     * <code>inferable-type-descriptor := type-descriptor | var</code>\n+     *\n+     * @return Fork statement\n+     */\n+    private STNode parseTypedBindingPattern() {\n+        startContext(ParserRuleContext.TYPED_BINDING_PATTERN);\n+        STNode typeDesc = parseTypeDescriptor(ParserRuleContext.TYPE_DESC_IN_TYPE_BINDING_PATTERN, 1);\n+\n+        STNode bindingPattern = null;\n+        if (peek().kind == SyntaxKind.OPEN_BRACKET_TOKEN) {\n+            STNode[] parsed = parseArrayTypeDescOrLBP(typeDesc);\n+            typeDesc = parsed[0];\n+            bindingPattern = parsed[1];\n+        } else {\n+            bindingPattern = parseBindingPattern();\n+        }\n+\n+        endContext();\n+        return STNodeFactory.createTypedBindingPatternNode(typeDesc, bindingPattern);\n+    }\n+\n+    private STNode[] parseArrayTypeDescOrLBP(STNode typeDesc) {\n+\n+        STNode arrayDescOrBLP = parseListBindingPattern();\n+\n+        if (isLBPDefinitively(arrayDescOrBLP)) { // ambiguous means T[a]\n+            return new STNode[]{typeDesc, cleanLBP(arrayDescOrBLP)};\n+        } else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e1d5994f3adf89a684d1d1f04dc32e4da40a034"}, "originalPosition": 386}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1OTQ0MzQ3OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwMzozMjowMFrOGXOngA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwMzozMjowMFrOGXOngA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAwOTkyMA==", "bodyText": "wrong param name", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214#discussion_r427009920", "createdAt": "2020-05-19T03:32:00Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -8423,4 +8434,337 @@ private STNode parseParenthesisedTypeDesc() {\n         STNode closeParen = parseCloseParenthesis();\n         return STNodeFactory.createParenthesisedTypeDescriptorNode(openParen, typedesc, closeParen);\n     }\n+\n+    /**\n+     * Parse binding-patterns.\n+     *\n+     * binding-pattern :=\n+     *   capture-binding-pattern\n+     *    | wildcard-binding-pattern\n+     *    | list-binding-pattern\n+     *    | mapping-binding-pattern\n+     *    | functional-binding-pattern\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     * wildcard-binding-pattern := _\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *    binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ] \n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     * rest-binding-pattern := ... variable-name\n+     * functional-binding-pattern := functionally-constructible-type-reference ( arg-list-binding-pattern )\n+     * arg-list-binding-pattern :=\n+     *    positional-arg-binding-patterns [, other-arg-binding-patterns]\n+     *    | other-arg-binding-patterns\n+     * positional-arg-binding-patterns := positional-arg-binding-pattern (, positional-arg-binding-pattern)*\n+     * positional-arg-binding-pattern := binding-pattern\n+     * other-arg-binding-patterns :=\n+     *    named-arg-binding-patterns [, rest-binding-pattern]\n+     *    | [rest-binding-pattern]\n+     * named-arg-binding-patterns := named-arg-binding-pattern (, named-arg-binding-pattern)*\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n+     *\n+     * @return binding-pattern node\n+     */\n+    private STNode parseBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case OPEN_BRACKET_TOKEN:\n+                return parseListBindingPattern();\n+            case IDENTIFIER_TOKEN:\n+                return parseCaptureBindingPattern();\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse capture-binding-pattern.\n+     *\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     *\n+     * @return capture-binding-pattern node\n+     */\n+    private STNode parseCaptureBindingPattern() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case IDENTIFIER_TOKEN:\n+                STNode varName = parseVariableName();\n+                return STNodeFactory.createCaptureBindingPatternNode(varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.CAPTURE_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-patterns.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return list-binding-pattern node\n+     */\n+    private STNode parseListBindingPattern() {\n+        startContext(ParserRuleContext.LIST_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBracket = parseOpenBracket();\n+\n+        STNode listBindingPatternContent = parselistBindingPatternContent();\n+        bindingPatterns.add(listBindingPatternContent);\n+\n+        //parsing the main chunck of list-binding-pattern\n+        STToken token = getNextLBPToken(); // get next valid token\n+        STNode comma = null;\n+        while (!isEndOfListBindingPattern(token.kind) &&\n+                listBindingPatternContent.kind != SyntaxKind.REST_BINDING_PATTERN) {\n+            comma = parseComma();\n+            bindingPatterns.add(comma);\n+            listBindingPatternContent = parselistBindingPatternContent();\n+            bindingPatterns.add(listBindingPatternContent);\n+            token = getNextLBPToken();\n+        }\n+        STNode closeBracket = parseCloseBracket();\n+\n+        //seperating out the restbindingpattern\n+        STNode restBindingPattern = STNodeFactory.createEmptyNode();\n+        int lastIndex = bindingPatterns.size() - 1;\n+        STNode lastItem = bindingPatterns.get(lastIndex);\n+        if (lastItem.kind == SyntaxKind.REST_BINDING_PATTERN) {\n+            restBindingPattern = bindingPatterns.remove(lastIndex);\n+        }\n+\n+\n+        STNode bindingPatternsNode = STNodeFactory.createNodeList(bindingPatterns);\n+        endContext();\n+        return STNodeFactory.createListBindingPatternNode(openBracket,\n+                                                    bindingPatternsNode,\n+                                                    restBindingPattern,\n+                                                    closeBracket);\n+    }\n+\n+    private STToken getNextLBPToken() {\n+        STToken token = peek();\n+\n+        if (isEndOfListBindingPattern(token.kind)) {\n+            return token;\n+        }\n+\n+        switch (token.kind) {\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+            case IDENTIFIER_TOKEN:\n+            case ELLIPSIS_TOKEN:\n+            case OPEN_BRACKET_TOKEN:\n+            case COMMA_TOKEN:\n+                return token;\n+            default:\n+                consume(); // use the invalid token\n+                this.errorHandler.reportInvalidNode(token,\n+                        \"invalid Token in list-binding-pattern\");\n+                return getNextLBPToken();\n+        }\n+    }\n+\n+    private boolean isEndOfListBindingPattern(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case IN_KEYWORD:\n+            case CLOSE_BRACKET_TOKEN:\n+            case EOF_TOKEN:\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+                return true;\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    /**\n+     * Parse rest-binding-pattern.\n+     *\n+     * rest-binding-pattern := ... variable-name\n+     *\n+     * @return rest-binding-pattern node\n+     */\n+    private STNode parseRestBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case ELLIPSIS_TOKEN:\n+                startContext(ParserRuleContext.REST_BINDING_PATTERN);\n+                STNode ellipsis = parseEllipsis();\n+                STNode varName = parseVariableName();\n+                endContext();\n+                return STNodeFactory.createRestBindingPatternNode(ellipsis, varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.REST_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-pattern entry.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return rest-binding-pattern node\n+     */\n+    private STNode parselistBindingPatternContent() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+                return consume();\n+            case ELLIPSIS_TOKEN:\n+                return parseRestBindingPattern();\n+            default:\n+                return parseBindingPattern();\n+        }\n+    }\n+\n+    /**\n+     * Parse Typed-binding-pattern.\n+     *\n+     * <code>typed-binding-pattern := inferable-type-descriptor binding-pattern</code>\n+     * <code>inferable-type-descriptor := type-descriptor | var</code>\n+     *\n+     * @return Fork statement\n+     */\n+    private STNode parseTypedBindingPattern() {\n+        startContext(ParserRuleContext.TYPED_BINDING_PATTERN);\n+        STNode typeDesc = parseTypeDescriptor(ParserRuleContext.TYPE_DESC_IN_TYPE_BINDING_PATTERN, 1);\n+\n+        STNode bindingPattern = null;\n+        if (peek().kind == SyntaxKind.OPEN_BRACKET_TOKEN) {\n+            STNode[] parsed = parseArrayTypeDescOrLBP(typeDesc);\n+            typeDesc = parsed[0];\n+            bindingPattern = parsed[1];\n+        } else {\n+            bindingPattern = parseBindingPattern();\n+        }\n+\n+        endContext();\n+        return STNodeFactory.createTypedBindingPatternNode(typeDesc, bindingPattern);\n+    }\n+\n+    private STNode[] parseArrayTypeDescOrLBP(STNode typeDesc) {\n+\n+        STNode arrayDescOrBLP = parseListBindingPattern();\n+\n+        if (isLBPDefinitively(arrayDescOrBLP)) { // ambiguous means T[a]\n+            return new STNode[]{typeDesc, cleanLBP(arrayDescOrBLP)};\n+        } else {\n+            if (isFollowTypedBindingPattern(peek().kind)) {\n+                return new STNode[]{typeDesc, cleanLBP(arrayDescOrBLP)};\n+            } else {\n+                typeDesc = mergeTypeDescAndLBP(typeDesc, arrayDescOrBLP);\n+                if (peek().kind == SyntaxKind.OPEN_BRACKET_TOKEN) {\n+                    //this means arrayDescOrBLP is a array type desc\n+                    return parseArrayTypeDescOrLBP(typeDesc);\n+                } else {\n+                    return new STNode[]{typeDesc, parseBindingPattern()};\n+                }\n+            }\n+        }\n+    }\n+\n+    private STNode mergeTypeDescAndLBP(STNode typeDesc, STNode LBP) {\n+        STListBindingPatternNode lbp = (STListBindingPatternNode) LBP;\n+        STNodeList childArray = (STNodeList)lbp.bindingPatterns;\n+        STNode child = childArray.childInBucket(0);\n+        if (child.kind == SyntaxKind.CAPTURE_BINDING_PATTERN) {\n+            child = ((STCaptureBindingPatternNode)child).variableName;\n+        }\n+        return STNodeFactory.createIndexedExpressionNode(typeDesc, lbp.openBracket,\n+                child,\n+                lbp.closeBracket);\n+    }\n+\n+    private STNode cleanLBP(STNode arrayDescOrBLP) {\n+        STListBindingPatternNode lbp = (STListBindingPatternNode) arrayDescOrBLP;\n+        STNodeList childArray = (STNodeList)lbp.bindingPatterns;\n+        int numberOfChildren = childArray.bucketCount();\n+\n+        ArrayList<STNode> cleanedChildren = new ArrayList<>();\n+        STNode child = null;\n+        for (int i =0; i<numberOfChildren;i++) {\n+            child = childArray.childInBucket(i);\n+            switch (child.kind) {\n+                case DECIMAL_INTEGER_LITERAL:\n+                case HEX_INTEGER_LITERAL:\n+                case ASTERISK_TOKEN:\n+                    this.errorHandler.reportInvalidNode(null,\n+                            \"invalid Node \" + child.kind + \" in list-binding-pattern\");\n+                    cleanedChildren.add(STNodeFactory.createMissingToken(SyntaxKind.IDENTIFIER_TOKEN));\n+                    break;\n+                default:\n+                    cleanedChildren.add(child);\n+                    break;\n+            }\n+        }\n+\n+        return STNodeFactory.createListBindingPatternNode(lbp.openBracket,\n+                STNodeFactory.createNodeList(cleanedChildren),\n+                lbp.restBindingPattern,\n+                lbp.closeBracket);\n+    }\n+\n+    private boolean isLBPDefinitively(STNode arrayDescOrBLP) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e1d5994f3adf89a684d1d1f04dc32e4da40a034"}, "originalPosition": 442}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1OTQ3ODI2OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwMzo1MjowNlrOGXO7YA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwNjozNjo1MFrOGXRyQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAxNTAwOA==", "bodyText": "what happens for something like: a[b][c] = 5 where in[][] a = []; ?\nThis is an assignment with member access.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214#discussion_r427015008", "createdAt": "2020-05-19T03:52:06Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -8423,4 +8434,337 @@ private STNode parseParenthesisedTypeDesc() {\n         STNode closeParen = parseCloseParenthesis();\n         return STNodeFactory.createParenthesisedTypeDescriptorNode(openParen, typedesc, closeParen);\n     }\n+\n+    /**\n+     * Parse binding-patterns.\n+     *\n+     * binding-pattern :=\n+     *   capture-binding-pattern\n+     *    | wildcard-binding-pattern\n+     *    | list-binding-pattern\n+     *    | mapping-binding-pattern\n+     *    | functional-binding-pattern\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     * wildcard-binding-pattern := _\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *    binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ] \n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     * rest-binding-pattern := ... variable-name\n+     * functional-binding-pattern := functionally-constructible-type-reference ( arg-list-binding-pattern )\n+     * arg-list-binding-pattern :=\n+     *    positional-arg-binding-patterns [, other-arg-binding-patterns]\n+     *    | other-arg-binding-patterns\n+     * positional-arg-binding-patterns := positional-arg-binding-pattern (, positional-arg-binding-pattern)*\n+     * positional-arg-binding-pattern := binding-pattern\n+     * other-arg-binding-patterns :=\n+     *    named-arg-binding-patterns [, rest-binding-pattern]\n+     *    | [rest-binding-pattern]\n+     * named-arg-binding-patterns := named-arg-binding-pattern (, named-arg-binding-pattern)*\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n+     *\n+     * @return binding-pattern node\n+     */\n+    private STNode parseBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case OPEN_BRACKET_TOKEN:\n+                return parseListBindingPattern();\n+            case IDENTIFIER_TOKEN:\n+                return parseCaptureBindingPattern();\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse capture-binding-pattern.\n+     *\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     *\n+     * @return capture-binding-pattern node\n+     */\n+    private STNode parseCaptureBindingPattern() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case IDENTIFIER_TOKEN:\n+                STNode varName = parseVariableName();\n+                return STNodeFactory.createCaptureBindingPatternNode(varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.CAPTURE_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-patterns.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return list-binding-pattern node\n+     */\n+    private STNode parseListBindingPattern() {\n+        startContext(ParserRuleContext.LIST_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBracket = parseOpenBracket();\n+\n+        STNode listBindingPatternContent = parselistBindingPatternContent();\n+        bindingPatterns.add(listBindingPatternContent);\n+\n+        //parsing the main chunck of list-binding-pattern\n+        STToken token = getNextLBPToken(); // get next valid token\n+        STNode comma = null;\n+        while (!isEndOfListBindingPattern(token.kind) &&\n+                listBindingPatternContent.kind != SyntaxKind.REST_BINDING_PATTERN) {\n+            comma = parseComma();\n+            bindingPatterns.add(comma);\n+            listBindingPatternContent = parselistBindingPatternContent();\n+            bindingPatterns.add(listBindingPatternContent);\n+            token = getNextLBPToken();\n+        }\n+        STNode closeBracket = parseCloseBracket();\n+\n+        //seperating out the restbindingpattern\n+        STNode restBindingPattern = STNodeFactory.createEmptyNode();\n+        int lastIndex = bindingPatterns.size() - 1;\n+        STNode lastItem = bindingPatterns.get(lastIndex);\n+        if (lastItem.kind == SyntaxKind.REST_BINDING_PATTERN) {\n+            restBindingPattern = bindingPatterns.remove(lastIndex);\n+        }\n+\n+\n+        STNode bindingPatternsNode = STNodeFactory.createNodeList(bindingPatterns);\n+        endContext();\n+        return STNodeFactory.createListBindingPatternNode(openBracket,\n+                                                    bindingPatternsNode,\n+                                                    restBindingPattern,\n+                                                    closeBracket);\n+    }\n+\n+    private STToken getNextLBPToken() {\n+        STToken token = peek();\n+\n+        if (isEndOfListBindingPattern(token.kind)) {\n+            return token;\n+        }\n+\n+        switch (token.kind) {\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+            case IDENTIFIER_TOKEN:\n+            case ELLIPSIS_TOKEN:\n+            case OPEN_BRACKET_TOKEN:\n+            case COMMA_TOKEN:\n+                return token;\n+            default:\n+                consume(); // use the invalid token\n+                this.errorHandler.reportInvalidNode(token,\n+                        \"invalid Token in list-binding-pattern\");\n+                return getNextLBPToken();\n+        }\n+    }\n+\n+    private boolean isEndOfListBindingPattern(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case IN_KEYWORD:\n+            case CLOSE_BRACKET_TOKEN:\n+            case EOF_TOKEN:\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+                return true;\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    /**\n+     * Parse rest-binding-pattern.\n+     *\n+     * rest-binding-pattern := ... variable-name\n+     *\n+     * @return rest-binding-pattern node\n+     */\n+    private STNode parseRestBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case ELLIPSIS_TOKEN:\n+                startContext(ParserRuleContext.REST_BINDING_PATTERN);\n+                STNode ellipsis = parseEllipsis();\n+                STNode varName = parseVariableName();\n+                endContext();\n+                return STNodeFactory.createRestBindingPatternNode(ellipsis, varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.REST_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-pattern entry.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return rest-binding-pattern node\n+     */\n+    private STNode parselistBindingPatternContent() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+                return consume();\n+            case ELLIPSIS_TOKEN:\n+                return parseRestBindingPattern();\n+            default:\n+                return parseBindingPattern();\n+        }\n+    }\n+\n+    /**\n+     * Parse Typed-binding-pattern.\n+     *\n+     * <code>typed-binding-pattern := inferable-type-descriptor binding-pattern</code>\n+     * <code>inferable-type-descriptor := type-descriptor | var</code>\n+     *\n+     * @return Fork statement\n+     */\n+    private STNode parseTypedBindingPattern() {\n+        startContext(ParserRuleContext.TYPED_BINDING_PATTERN);\n+        STNode typeDesc = parseTypeDescriptor(ParserRuleContext.TYPE_DESC_IN_TYPE_BINDING_PATTERN, 1);\n+\n+        STNode bindingPattern = null;\n+        if (peek().kind == SyntaxKind.OPEN_BRACKET_TOKEN) {\n+            STNode[] parsed = parseArrayTypeDescOrLBP(typeDesc);\n+            typeDesc = parsed[0];\n+            bindingPattern = parsed[1];\n+        } else {\n+            bindingPattern = parseBindingPattern();\n+        }\n+\n+        endContext();\n+        return STNodeFactory.createTypedBindingPatternNode(typeDesc, bindingPattern);\n+    }\n+\n+    private STNode[] parseArrayTypeDescOrLBP(STNode typeDesc) {\n+\n+        STNode arrayDescOrBLP = parseListBindingPattern();\n+\n+        if (isLBPDefinitively(arrayDescOrBLP)) { // ambiguous means T[a]\n+            return new STNode[]{typeDesc, cleanLBP(arrayDescOrBLP)};\n+        } else {\n+            if (isFollowTypedBindingPattern(peek().kind)) {\n+                return new STNode[]{typeDesc, cleanLBP(arrayDescOrBLP)};\n+            } else {\n+                typeDesc = mergeTypeDescAndLBP(typeDesc, arrayDescOrBLP);\n+                if (peek().kind == SyntaxKind.OPEN_BRACKET_TOKEN) {\n+                    //this means arrayDescOrBLP is a array type desc\n+                    return parseArrayTypeDescOrLBP(typeDesc);\n+                } else {\n+                    return new STNode[]{typeDesc, parseBindingPattern()};\n+                }\n+            }\n+        }\n+    }\n+\n+    private STNode mergeTypeDescAndLBP(STNode typeDesc, STNode LBP) {\n+        STListBindingPatternNode lbp = (STListBindingPatternNode) LBP;\n+        STNodeList childArray = (STNodeList)lbp.bindingPatterns;\n+        STNode child = childArray.childInBucket(0);\n+        if (child.kind == SyntaxKind.CAPTURE_BINDING_PATTERN) {\n+            child = ((STCaptureBindingPatternNode)child).variableName;\n+        }\n+        return STNodeFactory.createIndexedExpressionNode(typeDesc, lbp.openBracket,\n+                child,\n+                lbp.closeBracket);\n+    }\n+\n+    private STNode cleanLBP(STNode arrayDescOrBLP) {\n+        STListBindingPatternNode lbp = (STListBindingPatternNode) arrayDescOrBLP;\n+        STNodeList childArray = (STNodeList)lbp.bindingPatterns;\n+        int numberOfChildren = childArray.bucketCount();\n+\n+        ArrayList<STNode> cleanedChildren = new ArrayList<>();\n+        STNode child = null;\n+        for (int i =0; i<numberOfChildren;i++) {\n+            child = childArray.childInBucket(i);\n+            switch (child.kind) {\n+                case DECIMAL_INTEGER_LITERAL:\n+                case HEX_INTEGER_LITERAL:\n+                case ASTERISK_TOKEN:\n+                    this.errorHandler.reportInvalidNode(null,\n+                            \"invalid Node \" + child.kind + \" in list-binding-pattern\");\n+                    cleanedChildren.add(STNodeFactory.createMissingToken(SyntaxKind.IDENTIFIER_TOKEN));\n+                    break;\n+                default:\n+                    cleanedChildren.add(child);\n+                    break;\n+            }\n+        }\n+\n+        return STNodeFactory.createListBindingPatternNode(lbp.openBracket,\n+                STNodeFactory.createNodeList(cleanedChildren),\n+                lbp.restBindingPattern,\n+                lbp.closeBracket);\n+    }\n+\n+    private boolean isLBPDefinitively(STNode arrayDescOrBLP) {\n+        STListBindingPatternNode lbp = (STListBindingPatternNode) arrayDescOrBLP;\n+        STNodeList childArray = (STNodeList)lbp.bindingPatterns;\n+        int numberOfChildren = childArray.bucketCount();\n+\n+        if (lbp.restBindingPattern != null) {\n+            return true;\n+        }\n+\n+        if (numberOfChildren ==1 ) {\n+            STNode child = childArray.childInBucket(0);\n+            switch (child.kind) {\n+                case DECIMAL_INTEGER_LITERAL:\n+                case HEX_INTEGER_LITERAL:\n+                case ASTERISK_TOKEN:\n+                case CAPTURE_BINDING_PATTERN:\n+                    return false;\n+                default: // cases like [ and {\n+                    return true;\n+            }\n+        } else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e1d5994f3adf89a684d1d1f04dc32e4da40a034"}, "originalPosition": 462}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA2MTgyNg==", "bodyText": "the only time we have to solve this problem is to decide between array type desc and list-b-p in typed binding patterns; if there are no typed binding patterns then it proceeds like usual(like it did before our code).", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214#discussion_r427061826", "createdAt": "2020-05-19T06:36:50Z", "author": {"login": "m36dot"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -8423,4 +8434,337 @@ private STNode parseParenthesisedTypeDesc() {\n         STNode closeParen = parseCloseParenthesis();\n         return STNodeFactory.createParenthesisedTypeDescriptorNode(openParen, typedesc, closeParen);\n     }\n+\n+    /**\n+     * Parse binding-patterns.\n+     *\n+     * binding-pattern :=\n+     *   capture-binding-pattern\n+     *    | wildcard-binding-pattern\n+     *    | list-binding-pattern\n+     *    | mapping-binding-pattern\n+     *    | functional-binding-pattern\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     * wildcard-binding-pattern := _\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *    binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ] \n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     * rest-binding-pattern := ... variable-name\n+     * functional-binding-pattern := functionally-constructible-type-reference ( arg-list-binding-pattern )\n+     * arg-list-binding-pattern :=\n+     *    positional-arg-binding-patterns [, other-arg-binding-patterns]\n+     *    | other-arg-binding-patterns\n+     * positional-arg-binding-patterns := positional-arg-binding-pattern (, positional-arg-binding-pattern)*\n+     * positional-arg-binding-pattern := binding-pattern\n+     * other-arg-binding-patterns :=\n+     *    named-arg-binding-patterns [, rest-binding-pattern]\n+     *    | [rest-binding-pattern]\n+     * named-arg-binding-patterns := named-arg-binding-pattern (, named-arg-binding-pattern)*\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n+     *\n+     * @return binding-pattern node\n+     */\n+    private STNode parseBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case OPEN_BRACKET_TOKEN:\n+                return parseListBindingPattern();\n+            case IDENTIFIER_TOKEN:\n+                return parseCaptureBindingPattern();\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse capture-binding-pattern.\n+     *\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     *\n+     * @return capture-binding-pattern node\n+     */\n+    private STNode parseCaptureBindingPattern() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case IDENTIFIER_TOKEN:\n+                STNode varName = parseVariableName();\n+                return STNodeFactory.createCaptureBindingPatternNode(varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.CAPTURE_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-patterns.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return list-binding-pattern node\n+     */\n+    private STNode parseListBindingPattern() {\n+        startContext(ParserRuleContext.LIST_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBracket = parseOpenBracket();\n+\n+        STNode listBindingPatternContent = parselistBindingPatternContent();\n+        bindingPatterns.add(listBindingPatternContent);\n+\n+        //parsing the main chunck of list-binding-pattern\n+        STToken token = getNextLBPToken(); // get next valid token\n+        STNode comma = null;\n+        while (!isEndOfListBindingPattern(token.kind) &&\n+                listBindingPatternContent.kind != SyntaxKind.REST_BINDING_PATTERN) {\n+            comma = parseComma();\n+            bindingPatterns.add(comma);\n+            listBindingPatternContent = parselistBindingPatternContent();\n+            bindingPatterns.add(listBindingPatternContent);\n+            token = getNextLBPToken();\n+        }\n+        STNode closeBracket = parseCloseBracket();\n+\n+        //seperating out the restbindingpattern\n+        STNode restBindingPattern = STNodeFactory.createEmptyNode();\n+        int lastIndex = bindingPatterns.size() - 1;\n+        STNode lastItem = bindingPatterns.get(lastIndex);\n+        if (lastItem.kind == SyntaxKind.REST_BINDING_PATTERN) {\n+            restBindingPattern = bindingPatterns.remove(lastIndex);\n+        }\n+\n+\n+        STNode bindingPatternsNode = STNodeFactory.createNodeList(bindingPatterns);\n+        endContext();\n+        return STNodeFactory.createListBindingPatternNode(openBracket,\n+                                                    bindingPatternsNode,\n+                                                    restBindingPattern,\n+                                                    closeBracket);\n+    }\n+\n+    private STToken getNextLBPToken() {\n+        STToken token = peek();\n+\n+        if (isEndOfListBindingPattern(token.kind)) {\n+            return token;\n+        }\n+\n+        switch (token.kind) {\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+            case IDENTIFIER_TOKEN:\n+            case ELLIPSIS_TOKEN:\n+            case OPEN_BRACKET_TOKEN:\n+            case COMMA_TOKEN:\n+                return token;\n+            default:\n+                consume(); // use the invalid token\n+                this.errorHandler.reportInvalidNode(token,\n+                        \"invalid Token in list-binding-pattern\");\n+                return getNextLBPToken();\n+        }\n+    }\n+\n+    private boolean isEndOfListBindingPattern(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case IN_KEYWORD:\n+            case CLOSE_BRACKET_TOKEN:\n+            case EOF_TOKEN:\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+                return true;\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    /**\n+     * Parse rest-binding-pattern.\n+     *\n+     * rest-binding-pattern := ... variable-name\n+     *\n+     * @return rest-binding-pattern node\n+     */\n+    private STNode parseRestBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case ELLIPSIS_TOKEN:\n+                startContext(ParserRuleContext.REST_BINDING_PATTERN);\n+                STNode ellipsis = parseEllipsis();\n+                STNode varName = parseVariableName();\n+                endContext();\n+                return STNodeFactory.createRestBindingPatternNode(ellipsis, varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.REST_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-pattern entry.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return rest-binding-pattern node\n+     */\n+    private STNode parselistBindingPatternContent() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+                return consume();\n+            case ELLIPSIS_TOKEN:\n+                return parseRestBindingPattern();\n+            default:\n+                return parseBindingPattern();\n+        }\n+    }\n+\n+    /**\n+     * Parse Typed-binding-pattern.\n+     *\n+     * <code>typed-binding-pattern := inferable-type-descriptor binding-pattern</code>\n+     * <code>inferable-type-descriptor := type-descriptor | var</code>\n+     *\n+     * @return Fork statement\n+     */\n+    private STNode parseTypedBindingPattern() {\n+        startContext(ParserRuleContext.TYPED_BINDING_PATTERN);\n+        STNode typeDesc = parseTypeDescriptor(ParserRuleContext.TYPE_DESC_IN_TYPE_BINDING_PATTERN, 1);\n+\n+        STNode bindingPattern = null;\n+        if (peek().kind == SyntaxKind.OPEN_BRACKET_TOKEN) {\n+            STNode[] parsed = parseArrayTypeDescOrLBP(typeDesc);\n+            typeDesc = parsed[0];\n+            bindingPattern = parsed[1];\n+        } else {\n+            bindingPattern = parseBindingPattern();\n+        }\n+\n+        endContext();\n+        return STNodeFactory.createTypedBindingPatternNode(typeDesc, bindingPattern);\n+    }\n+\n+    private STNode[] parseArrayTypeDescOrLBP(STNode typeDesc) {\n+\n+        STNode arrayDescOrBLP = parseListBindingPattern();\n+\n+        if (isLBPDefinitively(arrayDescOrBLP)) { // ambiguous means T[a]\n+            return new STNode[]{typeDesc, cleanLBP(arrayDescOrBLP)};\n+        } else {\n+            if (isFollowTypedBindingPattern(peek().kind)) {\n+                return new STNode[]{typeDesc, cleanLBP(arrayDescOrBLP)};\n+            } else {\n+                typeDesc = mergeTypeDescAndLBP(typeDesc, arrayDescOrBLP);\n+                if (peek().kind == SyntaxKind.OPEN_BRACKET_TOKEN) {\n+                    //this means arrayDescOrBLP is a array type desc\n+                    return parseArrayTypeDescOrLBP(typeDesc);\n+                } else {\n+                    return new STNode[]{typeDesc, parseBindingPattern()};\n+                }\n+            }\n+        }\n+    }\n+\n+    private STNode mergeTypeDescAndLBP(STNode typeDesc, STNode LBP) {\n+        STListBindingPatternNode lbp = (STListBindingPatternNode) LBP;\n+        STNodeList childArray = (STNodeList)lbp.bindingPatterns;\n+        STNode child = childArray.childInBucket(0);\n+        if (child.kind == SyntaxKind.CAPTURE_BINDING_PATTERN) {\n+            child = ((STCaptureBindingPatternNode)child).variableName;\n+        }\n+        return STNodeFactory.createIndexedExpressionNode(typeDesc, lbp.openBracket,\n+                child,\n+                lbp.closeBracket);\n+    }\n+\n+    private STNode cleanLBP(STNode arrayDescOrBLP) {\n+        STListBindingPatternNode lbp = (STListBindingPatternNode) arrayDescOrBLP;\n+        STNodeList childArray = (STNodeList)lbp.bindingPatterns;\n+        int numberOfChildren = childArray.bucketCount();\n+\n+        ArrayList<STNode> cleanedChildren = new ArrayList<>();\n+        STNode child = null;\n+        for (int i =0; i<numberOfChildren;i++) {\n+            child = childArray.childInBucket(i);\n+            switch (child.kind) {\n+                case DECIMAL_INTEGER_LITERAL:\n+                case HEX_INTEGER_LITERAL:\n+                case ASTERISK_TOKEN:\n+                    this.errorHandler.reportInvalidNode(null,\n+                            \"invalid Node \" + child.kind + \" in list-binding-pattern\");\n+                    cleanedChildren.add(STNodeFactory.createMissingToken(SyntaxKind.IDENTIFIER_TOKEN));\n+                    break;\n+                default:\n+                    cleanedChildren.add(child);\n+                    break;\n+            }\n+        }\n+\n+        return STNodeFactory.createListBindingPatternNode(lbp.openBracket,\n+                STNodeFactory.createNodeList(cleanedChildren),\n+                lbp.restBindingPattern,\n+                lbp.closeBracket);\n+    }\n+\n+    private boolean isLBPDefinitively(STNode arrayDescOrBLP) {\n+        STListBindingPatternNode lbp = (STListBindingPatternNode) arrayDescOrBLP;\n+        STNodeList childArray = (STNodeList)lbp.bindingPatterns;\n+        int numberOfChildren = childArray.bucketCount();\n+\n+        if (lbp.restBindingPattern != null) {\n+            return true;\n+        }\n+\n+        if (numberOfChildren ==1 ) {\n+            STNode child = childArray.childInBucket(0);\n+            switch (child.kind) {\n+                case DECIMAL_INTEGER_LITERAL:\n+                case HEX_INTEGER_LITERAL:\n+                case ASTERISK_TOKEN:\n+                case CAPTURE_BINDING_PATTERN:\n+                    return false;\n+                default: // cases like [ and {\n+                    return true;\n+            }\n+        } else {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAxNTAwOA=="}, "originalCommit": {"oid": "0e1d5994f3adf89a684d1d1f04dc32e4da40a034"}, "originalPosition": 462}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MDQ5NjU2OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwOTo1NTowOFrOGXY2JQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxMDoxODoyNVrOGXZsew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE3NzUwOQ==", "bodyText": "Should create the createEmptyNode inside else block of the below 'if'", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214#discussion_r427177509", "createdAt": "2020-05-19T09:55:08Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -9343,4 +9375,340 @@ private STNode parseIntersectionTypeDescriptor(STNode leftTypeDesc, ParserRuleCo\n         STNode rightTypeDesc = parseTypeDescriptor(context);\n         return STNodeFactory.createIntersectionTypeDescriptorNode(leftTypeDesc, bitwiseAndToken, rightTypeDesc);\n     }\n+\n+    /**\n+     * Parse binding-patterns.\n+     *\n+     * binding-pattern :=\n+     *   capture-binding-pattern\n+     *    | wildcard-binding-pattern\n+     *    | list-binding-pattern\n+     *    | mapping-binding-pattern\n+     *    | functional-binding-pattern\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     * wildcard-binding-pattern := _\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *    binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ] \n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     * rest-binding-pattern := ... variable-name\n+     * functional-binding-pattern := functionally-constructible-type-reference ( arg-list-binding-pattern )\n+     * arg-list-binding-pattern :=\n+     *    positional-arg-binding-patterns [, other-arg-binding-patterns]\n+     *    | other-arg-binding-patterns\n+     * positional-arg-binding-patterns := positional-arg-binding-pattern (, positional-arg-binding-pattern)*\n+     * positional-arg-binding-pattern := binding-pattern\n+     * other-arg-binding-patterns :=\n+     *    named-arg-binding-patterns [, rest-binding-pattern]\n+     *    | [rest-binding-pattern]\n+     * named-arg-binding-patterns := named-arg-binding-pattern (, named-arg-binding-pattern)*\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n+     *\n+     * @return binding-pattern node\n+     */\n+    private STNode parseBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case OPEN_BRACKET_TOKEN:\n+                return parseListBindingPattern();\n+            case IDENTIFIER_TOKEN:\n+                return parseCaptureBindingPattern();\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse capture-binding-pattern.\n+     *\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     *\n+     * @return capture-binding-pattern node\n+     */\n+    private STNode parseCaptureBindingPattern() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case IDENTIFIER_TOKEN:\n+                STNode varName = parseVariableName();\n+                return STNodeFactory.createCaptureBindingPatternNode(varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.CAPTURE_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-patterns.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return list-binding-pattern node\n+     */\n+    private STNode parseListBindingPattern() {\n+        startContext(ParserRuleContext.LIST_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBracket = parseOpenBracket();\n+\n+        STNode listBindingPatternMember = parselistBindingPatternMember();\n+        bindingPatterns.add(listBindingPatternMember);\n+\n+        //parsing the main chunck of list-binding-pattern\n+        STToken token = peek(); // get next valid token\n+        STNode listBindingPatternRhs = null;\n+        while (!isEndOfListBindingPattern(token.kind) &&\n+                listBindingPatternMember.kind != SyntaxKind.REST_BINDING_PATTERN) {\n+            listBindingPatternRhs = parseListBindingpatternRhs(token.kind);\n+            if (listBindingPatternRhs == null) {\n+                break;\n+            }\n+            bindingPatterns.add(listBindingPatternRhs);\n+            listBindingPatternMember = parselistBindingPatternMember();\n+            bindingPatterns.add(listBindingPatternMember);\n+            token = peek();\n+        }\n+        STNode closeBracket = parseCloseBracket();\n+\n+        //seperating out the restbindingpattern\n+        STNode restBindingPattern = STNodeFactory.createEmptyNode();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec0194d19cb63c5625e12d2e801076bf078fc873"}, "originalPosition": 261}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE5MTQxOQ==", "bodyText": "ok", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214#discussion_r427191419", "createdAt": "2020-05-19T10:18:25Z", "author": {"login": "m36dot"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -9343,4 +9375,340 @@ private STNode parseIntersectionTypeDescriptor(STNode leftTypeDesc, ParserRuleCo\n         STNode rightTypeDesc = parseTypeDescriptor(context);\n         return STNodeFactory.createIntersectionTypeDescriptorNode(leftTypeDesc, bitwiseAndToken, rightTypeDesc);\n     }\n+\n+    /**\n+     * Parse binding-patterns.\n+     *\n+     * binding-pattern :=\n+     *   capture-binding-pattern\n+     *    | wildcard-binding-pattern\n+     *    | list-binding-pattern\n+     *    | mapping-binding-pattern\n+     *    | functional-binding-pattern\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     * wildcard-binding-pattern := _\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *    binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ] \n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     * rest-binding-pattern := ... variable-name\n+     * functional-binding-pattern := functionally-constructible-type-reference ( arg-list-binding-pattern )\n+     * arg-list-binding-pattern :=\n+     *    positional-arg-binding-patterns [, other-arg-binding-patterns]\n+     *    | other-arg-binding-patterns\n+     * positional-arg-binding-patterns := positional-arg-binding-pattern (, positional-arg-binding-pattern)*\n+     * positional-arg-binding-pattern := binding-pattern\n+     * other-arg-binding-patterns :=\n+     *    named-arg-binding-patterns [, rest-binding-pattern]\n+     *    | [rest-binding-pattern]\n+     * named-arg-binding-patterns := named-arg-binding-pattern (, named-arg-binding-pattern)*\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n+     *\n+     * @return binding-pattern node\n+     */\n+    private STNode parseBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case OPEN_BRACKET_TOKEN:\n+                return parseListBindingPattern();\n+            case IDENTIFIER_TOKEN:\n+                return parseCaptureBindingPattern();\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse capture-binding-pattern.\n+     *\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     *\n+     * @return capture-binding-pattern node\n+     */\n+    private STNode parseCaptureBindingPattern() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case IDENTIFIER_TOKEN:\n+                STNode varName = parseVariableName();\n+                return STNodeFactory.createCaptureBindingPatternNode(varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.CAPTURE_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-patterns.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return list-binding-pattern node\n+     */\n+    private STNode parseListBindingPattern() {\n+        startContext(ParserRuleContext.LIST_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBracket = parseOpenBracket();\n+\n+        STNode listBindingPatternMember = parselistBindingPatternMember();\n+        bindingPatterns.add(listBindingPatternMember);\n+\n+        //parsing the main chunck of list-binding-pattern\n+        STToken token = peek(); // get next valid token\n+        STNode listBindingPatternRhs = null;\n+        while (!isEndOfListBindingPattern(token.kind) &&\n+                listBindingPatternMember.kind != SyntaxKind.REST_BINDING_PATTERN) {\n+            listBindingPatternRhs = parseListBindingpatternRhs(token.kind);\n+            if (listBindingPatternRhs == null) {\n+                break;\n+            }\n+            bindingPatterns.add(listBindingPatternRhs);\n+            listBindingPatternMember = parselistBindingPatternMember();\n+            bindingPatterns.add(listBindingPatternMember);\n+            token = peek();\n+        }\n+        STNode closeBracket = parseCloseBracket();\n+\n+        //seperating out the restbindingpattern\n+        STNode restBindingPattern = STNodeFactory.createEmptyNode();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE3NzUwOQ=="}, "originalCommit": {"oid": "ec0194d19cb63c5625e12d2e801076bf078fc873"}, "originalPosition": 261}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MDQ5ODA3OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwOTo1NTozM1rOGXY3Dw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxMDoxODozNVrOGXZs3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE3Nzc0Mw==", "bodyText": "wrong context.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214#discussion_r427177743", "createdAt": "2020-05-19T09:55:33Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -9343,4 +9375,340 @@ private STNode parseIntersectionTypeDescriptor(STNode leftTypeDesc, ParserRuleCo\n         STNode rightTypeDesc = parseTypeDescriptor(context);\n         return STNodeFactory.createIntersectionTypeDescriptorNode(leftTypeDesc, bitwiseAndToken, rightTypeDesc);\n     }\n+\n+    /**\n+     * Parse binding-patterns.\n+     *\n+     * binding-pattern :=\n+     *   capture-binding-pattern\n+     *    | wildcard-binding-pattern\n+     *    | list-binding-pattern\n+     *    | mapping-binding-pattern\n+     *    | functional-binding-pattern\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     * wildcard-binding-pattern := _\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *    binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ] \n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     * rest-binding-pattern := ... variable-name\n+     * functional-binding-pattern := functionally-constructible-type-reference ( arg-list-binding-pattern )\n+     * arg-list-binding-pattern :=\n+     *    positional-arg-binding-patterns [, other-arg-binding-patterns]\n+     *    | other-arg-binding-patterns\n+     * positional-arg-binding-patterns := positional-arg-binding-pattern (, positional-arg-binding-pattern)*\n+     * positional-arg-binding-pattern := binding-pattern\n+     * other-arg-binding-patterns :=\n+     *    named-arg-binding-patterns [, rest-binding-pattern]\n+     *    | [rest-binding-pattern]\n+     * named-arg-binding-patterns := named-arg-binding-pattern (, named-arg-binding-pattern)*\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n+     *\n+     * @return binding-pattern node\n+     */\n+    private STNode parseBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case OPEN_BRACKET_TOKEN:\n+                return parseListBindingPattern();\n+            case IDENTIFIER_TOKEN:\n+                return parseCaptureBindingPattern();\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse capture-binding-pattern.\n+     *\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     *\n+     * @return capture-binding-pattern node\n+     */\n+    private STNode parseCaptureBindingPattern() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case IDENTIFIER_TOKEN:\n+                STNode varName = parseVariableName();\n+                return STNodeFactory.createCaptureBindingPatternNode(varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.CAPTURE_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-patterns.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return list-binding-pattern node\n+     */\n+    private STNode parseListBindingPattern() {\n+        startContext(ParserRuleContext.LIST_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBracket = parseOpenBracket();\n+\n+        STNode listBindingPatternMember = parselistBindingPatternMember();\n+        bindingPatterns.add(listBindingPatternMember);\n+\n+        //parsing the main chunck of list-binding-pattern\n+        STToken token = peek(); // get next valid token\n+        STNode listBindingPatternRhs = null;\n+        while (!isEndOfListBindingPattern(token.kind) &&\n+                listBindingPatternMember.kind != SyntaxKind.REST_BINDING_PATTERN) {\n+            listBindingPatternRhs = parseListBindingpatternRhs(token.kind);\n+            if (listBindingPatternRhs == null) {\n+                break;\n+            }\n+            bindingPatterns.add(listBindingPatternRhs);\n+            listBindingPatternMember = parselistBindingPatternMember();\n+            bindingPatterns.add(listBindingPatternMember);\n+            token = peek();\n+        }\n+        STNode closeBracket = parseCloseBracket();\n+\n+        //seperating out the restbindingpattern\n+        STNode restBindingPattern = STNodeFactory.createEmptyNode();\n+        if (listBindingPatternMember.kind == SyntaxKind.REST_BINDING_PATTERN) {\n+            restBindingPattern = bindingPatterns.remove(bindingPatterns.size() - 1);\n+        }\n+\n+        STNode bindingPatternsNode = STNodeFactory.createNodeList(bindingPatterns);\n+        endContext();\n+        return STNodeFactory.createListBindingPatternNode(openBracket,\n+                                                    bindingPatternsNode,\n+                                                    restBindingPattern,\n+                                                    closeBracket);\n+    }\n+\n+    private STNode parseListBindingpatternRhs() {\n+        return parseListBindingpatternRhs(peek().kind);\n+    }\n+\n+    private STNode parseListBindingpatternRhs(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case COMMA_TOKEN:\n+                return parseComma();\n+            case CLOSE_BRACKET_TOKEN:\n+                return null;\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.TYPE_DESC_IN_TUPLE_RHS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec0194d19cb63c5625e12d2e801076bf078fc873"}, "originalPosition": 285}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE5MTUxNg==", "bodyText": "sorry didnt notice", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214#discussion_r427191516", "createdAt": "2020-05-19T10:18:35Z", "author": {"login": "m36dot"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -9343,4 +9375,340 @@ private STNode parseIntersectionTypeDescriptor(STNode leftTypeDesc, ParserRuleCo\n         STNode rightTypeDesc = parseTypeDescriptor(context);\n         return STNodeFactory.createIntersectionTypeDescriptorNode(leftTypeDesc, bitwiseAndToken, rightTypeDesc);\n     }\n+\n+    /**\n+     * Parse binding-patterns.\n+     *\n+     * binding-pattern :=\n+     *   capture-binding-pattern\n+     *    | wildcard-binding-pattern\n+     *    | list-binding-pattern\n+     *    | mapping-binding-pattern\n+     *    | functional-binding-pattern\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     * wildcard-binding-pattern := _\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *    binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ] \n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     * rest-binding-pattern := ... variable-name\n+     * functional-binding-pattern := functionally-constructible-type-reference ( arg-list-binding-pattern )\n+     * arg-list-binding-pattern :=\n+     *    positional-arg-binding-patterns [, other-arg-binding-patterns]\n+     *    | other-arg-binding-patterns\n+     * positional-arg-binding-patterns := positional-arg-binding-pattern (, positional-arg-binding-pattern)*\n+     * positional-arg-binding-pattern := binding-pattern\n+     * other-arg-binding-patterns :=\n+     *    named-arg-binding-patterns [, rest-binding-pattern]\n+     *    | [rest-binding-pattern]\n+     * named-arg-binding-patterns := named-arg-binding-pattern (, named-arg-binding-pattern)*\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n+     *\n+     * @return binding-pattern node\n+     */\n+    private STNode parseBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case OPEN_BRACKET_TOKEN:\n+                return parseListBindingPattern();\n+            case IDENTIFIER_TOKEN:\n+                return parseCaptureBindingPattern();\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse capture-binding-pattern.\n+     *\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     *\n+     * @return capture-binding-pattern node\n+     */\n+    private STNode parseCaptureBindingPattern() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case IDENTIFIER_TOKEN:\n+                STNode varName = parseVariableName();\n+                return STNodeFactory.createCaptureBindingPatternNode(varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.CAPTURE_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-patterns.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return list-binding-pattern node\n+     */\n+    private STNode parseListBindingPattern() {\n+        startContext(ParserRuleContext.LIST_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBracket = parseOpenBracket();\n+\n+        STNode listBindingPatternMember = parselistBindingPatternMember();\n+        bindingPatterns.add(listBindingPatternMember);\n+\n+        //parsing the main chunck of list-binding-pattern\n+        STToken token = peek(); // get next valid token\n+        STNode listBindingPatternRhs = null;\n+        while (!isEndOfListBindingPattern(token.kind) &&\n+                listBindingPatternMember.kind != SyntaxKind.REST_BINDING_PATTERN) {\n+            listBindingPatternRhs = parseListBindingpatternRhs(token.kind);\n+            if (listBindingPatternRhs == null) {\n+                break;\n+            }\n+            bindingPatterns.add(listBindingPatternRhs);\n+            listBindingPatternMember = parselistBindingPatternMember();\n+            bindingPatterns.add(listBindingPatternMember);\n+            token = peek();\n+        }\n+        STNode closeBracket = parseCloseBracket();\n+\n+        //seperating out the restbindingpattern\n+        STNode restBindingPattern = STNodeFactory.createEmptyNode();\n+        if (listBindingPatternMember.kind == SyntaxKind.REST_BINDING_PATTERN) {\n+            restBindingPattern = bindingPatterns.remove(bindingPatterns.size() - 1);\n+        }\n+\n+        STNode bindingPatternsNode = STNodeFactory.createNodeList(bindingPatterns);\n+        endContext();\n+        return STNodeFactory.createListBindingPatternNode(openBracket,\n+                                                    bindingPatternsNode,\n+                                                    restBindingPattern,\n+                                                    closeBracket);\n+    }\n+\n+    private STNode parseListBindingpatternRhs() {\n+        return parseListBindingpatternRhs(peek().kind);\n+    }\n+\n+    private STNode parseListBindingpatternRhs(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case COMMA_TOKEN:\n+                return parseComma();\n+            case CLOSE_BRACKET_TOKEN:\n+                return null;\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.TYPE_DESC_IN_TUPLE_RHS);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE3Nzc0Mw=="}, "originalCommit": {"oid": "ec0194d19cb63c5625e12d2e801076bf078fc873"}, "originalPosition": 285}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MDU3NzY2OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxMDoxNjozN1rOGXZodw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxMDoxODo0MFrOGXZs_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE5MDM5MQ==", "bodyText": "body of this if block is same as above. can we merge the two?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214#discussion_r427190391", "createdAt": "2020-05-19T10:16:37Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -9343,4 +9375,340 @@ private STNode parseIntersectionTypeDescriptor(STNode leftTypeDesc, ParserRuleCo\n         STNode rightTypeDesc = parseTypeDescriptor(context);\n         return STNodeFactory.createIntersectionTypeDescriptorNode(leftTypeDesc, bitwiseAndToken, rightTypeDesc);\n     }\n+\n+    /**\n+     * Parse binding-patterns.\n+     *\n+     * binding-pattern :=\n+     *   capture-binding-pattern\n+     *    | wildcard-binding-pattern\n+     *    | list-binding-pattern\n+     *    | mapping-binding-pattern\n+     *    | functional-binding-pattern\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     * wildcard-binding-pattern := _\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *    binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ] \n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     * rest-binding-pattern := ... variable-name\n+     * functional-binding-pattern := functionally-constructible-type-reference ( arg-list-binding-pattern )\n+     * arg-list-binding-pattern :=\n+     *    positional-arg-binding-patterns [, other-arg-binding-patterns]\n+     *    | other-arg-binding-patterns\n+     * positional-arg-binding-patterns := positional-arg-binding-pattern (, positional-arg-binding-pattern)*\n+     * positional-arg-binding-pattern := binding-pattern\n+     * other-arg-binding-patterns :=\n+     *    named-arg-binding-patterns [, rest-binding-pattern]\n+     *    | [rest-binding-pattern]\n+     * named-arg-binding-patterns := named-arg-binding-pattern (, named-arg-binding-pattern)*\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n+     *\n+     * @return binding-pattern node\n+     */\n+    private STNode parseBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case OPEN_BRACKET_TOKEN:\n+                return parseListBindingPattern();\n+            case IDENTIFIER_TOKEN:\n+                return parseCaptureBindingPattern();\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse capture-binding-pattern.\n+     *\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     *\n+     * @return capture-binding-pattern node\n+     */\n+    private STNode parseCaptureBindingPattern() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case IDENTIFIER_TOKEN:\n+                STNode varName = parseVariableName();\n+                return STNodeFactory.createCaptureBindingPatternNode(varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.CAPTURE_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-patterns.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return list-binding-pattern node\n+     */\n+    private STNode parseListBindingPattern() {\n+        startContext(ParserRuleContext.LIST_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBracket = parseOpenBracket();\n+\n+        STNode listBindingPatternMember = parselistBindingPatternMember();\n+        bindingPatterns.add(listBindingPatternMember);\n+\n+        //parsing the main chunck of list-binding-pattern\n+        STToken token = peek(); // get next valid token\n+        STNode listBindingPatternRhs = null;\n+        while (!isEndOfListBindingPattern(token.kind) &&\n+                listBindingPatternMember.kind != SyntaxKind.REST_BINDING_PATTERN) {\n+            listBindingPatternRhs = parseListBindingpatternRhs(token.kind);\n+            if (listBindingPatternRhs == null) {\n+                break;\n+            }\n+            bindingPatterns.add(listBindingPatternRhs);\n+            listBindingPatternMember = parselistBindingPatternMember();\n+            bindingPatterns.add(listBindingPatternMember);\n+            token = peek();\n+        }\n+        STNode closeBracket = parseCloseBracket();\n+\n+        //seperating out the restbindingpattern\n+        STNode restBindingPattern = STNodeFactory.createEmptyNode();\n+        if (listBindingPatternMember.kind == SyntaxKind.REST_BINDING_PATTERN) {\n+            restBindingPattern = bindingPatterns.remove(bindingPatterns.size() - 1);\n+        }\n+\n+        STNode bindingPatternsNode = STNodeFactory.createNodeList(bindingPatterns);\n+        endContext();\n+        return STNodeFactory.createListBindingPatternNode(openBracket,\n+                                                    bindingPatternsNode,\n+                                                    restBindingPattern,\n+                                                    closeBracket);\n+    }\n+\n+    private STNode parseListBindingpatternRhs() {\n+        return parseListBindingpatternRhs(peek().kind);\n+    }\n+\n+    private STNode parseListBindingpatternRhs(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case COMMA_TOKEN:\n+                return parseComma();\n+            case CLOSE_BRACKET_TOKEN:\n+                return null;\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.TYPE_DESC_IN_TUPLE_RHS);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseListBindingpatternRhs(solution.tokenKind);\n+        }\n+    }\n+\n+    private boolean isEndOfListBindingPattern(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case IN_KEYWORD:\n+            case CLOSE_BRACKET_TOKEN:\n+            case EOF_TOKEN:\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+                return true;\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    /**\n+     * Parse rest-binding-pattern.\n+     *\n+     * rest-binding-pattern := ... variable-name\n+     *\n+     * @return rest-binding-pattern node\n+     */\n+    private STNode parseRestBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case ELLIPSIS_TOKEN:\n+                startContext(ParserRuleContext.REST_BINDING_PATTERN);\n+                STNode ellipsis = parseEllipsis();\n+                STNode varName = parseVariableName();\n+                endContext();\n+                return STNodeFactory.createRestBindingPatternNode(ellipsis, varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.REST_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-pattern entry.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return rest-binding-pattern node\n+     */\n+    private STNode parselistBindingPatternMember() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+                return consume();\n+            case ELLIPSIS_TOKEN:\n+                return parseRestBindingPattern();\n+            default:\n+                return parseBindingPattern();\n+        }\n+    }\n+\n+    /**\n+     * Parse Typed-binding-pattern.\n+     *\n+     * <code>typed-binding-pattern := inferable-type-descriptor binding-pattern</code>\n+     * <code>inferable-type-descriptor := type-descriptor | var</code>\n+     *\n+     * @return Fork statement\n+     */\n+    private STNode parseTypedBindingPattern() {\n+        startContext(ParserRuleContext.TYPED_BINDING_PATTERN);\n+        STNode typeDesc = parseTypeDescriptor(ParserRuleContext.TYPE_DESC_IN_TYPE_BINDING_PATTERN, true);\n+\n+        STNode bindingPattern = null;\n+        if (peek().kind == SyntaxKind.OPEN_BRACKET_TOKEN) {\n+            STNode typedBindingPattern = parseArrayTypeDescOrListBindingPattern(typeDesc);\n+            endContext();\n+            return typedBindingPattern;\n+        }\n+        bindingPattern = parseBindingPattern();\n+\n+        endContext();\n+        return STNodeFactory.createTypedBindingPatternNode(typeDesc, bindingPattern);\n+    }\n+\n+    private STNode parseArrayTypeDescOrListBindingPattern(STNode typeDesc) {\n+\n+        STNode arrayDescOrListBindingPattern = parseListBindingPattern();\n+\n+        if (isListBindingPatternDefinitively(arrayDescOrListBindingPattern)) { // ambiguous means T[a]\n+            return STNodeFactory.createTypedBindingPatternNode(typeDesc,\n+                    cleanListBindingPattern(arrayDescOrListBindingPattern));\n+        }\n+\n+        if (isFollowTypedBindingPattern(peek().kind)) {\n+            return STNodeFactory.createTypedBindingPatternNode(typeDesc,\n+                    cleanListBindingPattern(arrayDescOrListBindingPattern));\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec0194d19cb63c5625e12d2e801076bf078fc873"}, "originalPosition": 396}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE5MTU1MA==", "bodyText": "Can you add a comment mentioning what are we checking here, and why we need that?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214#discussion_r427191550", "createdAt": "2020-05-19T10:18:40Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -9343,4 +9375,340 @@ private STNode parseIntersectionTypeDescriptor(STNode leftTypeDesc, ParserRuleCo\n         STNode rightTypeDesc = parseTypeDescriptor(context);\n         return STNodeFactory.createIntersectionTypeDescriptorNode(leftTypeDesc, bitwiseAndToken, rightTypeDesc);\n     }\n+\n+    /**\n+     * Parse binding-patterns.\n+     *\n+     * binding-pattern :=\n+     *   capture-binding-pattern\n+     *    | wildcard-binding-pattern\n+     *    | list-binding-pattern\n+     *    | mapping-binding-pattern\n+     *    | functional-binding-pattern\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     * wildcard-binding-pattern := _\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *    binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ] \n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     * rest-binding-pattern := ... variable-name\n+     * functional-binding-pattern := functionally-constructible-type-reference ( arg-list-binding-pattern )\n+     * arg-list-binding-pattern :=\n+     *    positional-arg-binding-patterns [, other-arg-binding-patterns]\n+     *    | other-arg-binding-patterns\n+     * positional-arg-binding-patterns := positional-arg-binding-pattern (, positional-arg-binding-pattern)*\n+     * positional-arg-binding-pattern := binding-pattern\n+     * other-arg-binding-patterns :=\n+     *    named-arg-binding-patterns [, rest-binding-pattern]\n+     *    | [rest-binding-pattern]\n+     * named-arg-binding-patterns := named-arg-binding-pattern (, named-arg-binding-pattern)*\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n+     *\n+     * @return binding-pattern node\n+     */\n+    private STNode parseBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case OPEN_BRACKET_TOKEN:\n+                return parseListBindingPattern();\n+            case IDENTIFIER_TOKEN:\n+                return parseCaptureBindingPattern();\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse capture-binding-pattern.\n+     *\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     *\n+     * @return capture-binding-pattern node\n+     */\n+    private STNode parseCaptureBindingPattern() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case IDENTIFIER_TOKEN:\n+                STNode varName = parseVariableName();\n+                return STNodeFactory.createCaptureBindingPatternNode(varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.CAPTURE_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-patterns.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return list-binding-pattern node\n+     */\n+    private STNode parseListBindingPattern() {\n+        startContext(ParserRuleContext.LIST_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBracket = parseOpenBracket();\n+\n+        STNode listBindingPatternMember = parselistBindingPatternMember();\n+        bindingPatterns.add(listBindingPatternMember);\n+\n+        //parsing the main chunck of list-binding-pattern\n+        STToken token = peek(); // get next valid token\n+        STNode listBindingPatternRhs = null;\n+        while (!isEndOfListBindingPattern(token.kind) &&\n+                listBindingPatternMember.kind != SyntaxKind.REST_BINDING_PATTERN) {\n+            listBindingPatternRhs = parseListBindingpatternRhs(token.kind);\n+            if (listBindingPatternRhs == null) {\n+                break;\n+            }\n+            bindingPatterns.add(listBindingPatternRhs);\n+            listBindingPatternMember = parselistBindingPatternMember();\n+            bindingPatterns.add(listBindingPatternMember);\n+            token = peek();\n+        }\n+        STNode closeBracket = parseCloseBracket();\n+\n+        //seperating out the restbindingpattern\n+        STNode restBindingPattern = STNodeFactory.createEmptyNode();\n+        if (listBindingPatternMember.kind == SyntaxKind.REST_BINDING_PATTERN) {\n+            restBindingPattern = bindingPatterns.remove(bindingPatterns.size() - 1);\n+        }\n+\n+        STNode bindingPatternsNode = STNodeFactory.createNodeList(bindingPatterns);\n+        endContext();\n+        return STNodeFactory.createListBindingPatternNode(openBracket,\n+                                                    bindingPatternsNode,\n+                                                    restBindingPattern,\n+                                                    closeBracket);\n+    }\n+\n+    private STNode parseListBindingpatternRhs() {\n+        return parseListBindingpatternRhs(peek().kind);\n+    }\n+\n+    private STNode parseListBindingpatternRhs(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case COMMA_TOKEN:\n+                return parseComma();\n+            case CLOSE_BRACKET_TOKEN:\n+                return null;\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.TYPE_DESC_IN_TUPLE_RHS);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseListBindingpatternRhs(solution.tokenKind);\n+        }\n+    }\n+\n+    private boolean isEndOfListBindingPattern(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case IN_KEYWORD:\n+            case CLOSE_BRACKET_TOKEN:\n+            case EOF_TOKEN:\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+                return true;\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    /**\n+     * Parse rest-binding-pattern.\n+     *\n+     * rest-binding-pattern := ... variable-name\n+     *\n+     * @return rest-binding-pattern node\n+     */\n+    private STNode parseRestBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case ELLIPSIS_TOKEN:\n+                startContext(ParserRuleContext.REST_BINDING_PATTERN);\n+                STNode ellipsis = parseEllipsis();\n+                STNode varName = parseVariableName();\n+                endContext();\n+                return STNodeFactory.createRestBindingPatternNode(ellipsis, varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.REST_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-pattern entry.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return rest-binding-pattern node\n+     */\n+    private STNode parselistBindingPatternMember() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+                return consume();\n+            case ELLIPSIS_TOKEN:\n+                return parseRestBindingPattern();\n+            default:\n+                return parseBindingPattern();\n+        }\n+    }\n+\n+    /**\n+     * Parse Typed-binding-pattern.\n+     *\n+     * <code>typed-binding-pattern := inferable-type-descriptor binding-pattern</code>\n+     * <code>inferable-type-descriptor := type-descriptor | var</code>\n+     *\n+     * @return Fork statement\n+     */\n+    private STNode parseTypedBindingPattern() {\n+        startContext(ParserRuleContext.TYPED_BINDING_PATTERN);\n+        STNode typeDesc = parseTypeDescriptor(ParserRuleContext.TYPE_DESC_IN_TYPE_BINDING_PATTERN, true);\n+\n+        STNode bindingPattern = null;\n+        if (peek().kind == SyntaxKind.OPEN_BRACKET_TOKEN) {\n+            STNode typedBindingPattern = parseArrayTypeDescOrListBindingPattern(typeDesc);\n+            endContext();\n+            return typedBindingPattern;\n+        }\n+        bindingPattern = parseBindingPattern();\n+\n+        endContext();\n+        return STNodeFactory.createTypedBindingPatternNode(typeDesc, bindingPattern);\n+    }\n+\n+    private STNode parseArrayTypeDescOrListBindingPattern(STNode typeDesc) {\n+\n+        STNode arrayDescOrListBindingPattern = parseListBindingPattern();\n+\n+        if (isListBindingPatternDefinitively(arrayDescOrListBindingPattern)) { // ambiguous means T[a]\n+            return STNodeFactory.createTypedBindingPatternNode(typeDesc,\n+                    cleanListBindingPattern(arrayDescOrListBindingPattern));\n+        }\n+\n+        if (isFollowTypedBindingPattern(peek().kind)) {\n+            return STNodeFactory.createTypedBindingPatternNode(typeDesc,\n+                    cleanListBindingPattern(arrayDescOrListBindingPattern));\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE5MDM5MQ=="}, "originalCommit": {"oid": "ec0194d19cb63c5625e12d2e801076bf078fc873"}, "originalPosition": 396}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MDU4NzI3OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxMDoxOToxOVrOGXZuWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxMDoxOToxOVrOGXZuWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE5MTg5OQ==", "bodyText": "Extra new lines", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214#discussion_r427191899", "createdAt": "2020-05-19T10:19:19Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -9343,4 +9375,340 @@ private STNode parseIntersectionTypeDescriptor(STNode leftTypeDesc, ParserRuleCo\n         STNode rightTypeDesc = parseTypeDescriptor(context);\n         return STNodeFactory.createIntersectionTypeDescriptorNode(leftTypeDesc, bitwiseAndToken, rightTypeDesc);\n     }\n+\n+    /**\n+     * Parse binding-patterns.\n+     *\n+     * binding-pattern :=\n+     *   capture-binding-pattern\n+     *    | wildcard-binding-pattern\n+     *    | list-binding-pattern\n+     *    | mapping-binding-pattern\n+     *    | functional-binding-pattern\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     * wildcard-binding-pattern := _\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *    binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ] \n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     * rest-binding-pattern := ... variable-name\n+     * functional-binding-pattern := functionally-constructible-type-reference ( arg-list-binding-pattern )\n+     * arg-list-binding-pattern :=\n+     *    positional-arg-binding-patterns [, other-arg-binding-patterns]\n+     *    | other-arg-binding-patterns\n+     * positional-arg-binding-patterns := positional-arg-binding-pattern (, positional-arg-binding-pattern)*\n+     * positional-arg-binding-pattern := binding-pattern\n+     * other-arg-binding-patterns :=\n+     *    named-arg-binding-patterns [, rest-binding-pattern]\n+     *    | [rest-binding-pattern]\n+     * named-arg-binding-patterns := named-arg-binding-pattern (, named-arg-binding-pattern)*\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n+     *\n+     * @return binding-pattern node\n+     */\n+    private STNode parseBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case OPEN_BRACKET_TOKEN:\n+                return parseListBindingPattern();\n+            case IDENTIFIER_TOKEN:\n+                return parseCaptureBindingPattern();\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse capture-binding-pattern.\n+     *\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     *\n+     * @return capture-binding-pattern node\n+     */\n+    private STNode parseCaptureBindingPattern() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case IDENTIFIER_TOKEN:\n+                STNode varName = parseVariableName();\n+                return STNodeFactory.createCaptureBindingPatternNode(varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.CAPTURE_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-patterns.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return list-binding-pattern node\n+     */\n+    private STNode parseListBindingPattern() {\n+        startContext(ParserRuleContext.LIST_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBracket = parseOpenBracket();\n+\n+        STNode listBindingPatternMember = parselistBindingPatternMember();\n+        bindingPatterns.add(listBindingPatternMember);\n+\n+        //parsing the main chunck of list-binding-pattern\n+        STToken token = peek(); // get next valid token\n+        STNode listBindingPatternRhs = null;\n+        while (!isEndOfListBindingPattern(token.kind) &&\n+                listBindingPatternMember.kind != SyntaxKind.REST_BINDING_PATTERN) {\n+            listBindingPatternRhs = parseListBindingpatternRhs(token.kind);\n+            if (listBindingPatternRhs == null) {\n+                break;\n+            }\n+            bindingPatterns.add(listBindingPatternRhs);\n+            listBindingPatternMember = parselistBindingPatternMember();\n+            bindingPatterns.add(listBindingPatternMember);\n+            token = peek();\n+        }\n+        STNode closeBracket = parseCloseBracket();\n+\n+        //seperating out the restbindingpattern\n+        STNode restBindingPattern = STNodeFactory.createEmptyNode();\n+        if (listBindingPatternMember.kind == SyntaxKind.REST_BINDING_PATTERN) {\n+            restBindingPattern = bindingPatterns.remove(bindingPatterns.size() - 1);\n+        }\n+\n+        STNode bindingPatternsNode = STNodeFactory.createNodeList(bindingPatterns);\n+        endContext();\n+        return STNodeFactory.createListBindingPatternNode(openBracket,\n+                                                    bindingPatternsNode,\n+                                                    restBindingPattern,\n+                                                    closeBracket);\n+    }\n+\n+    private STNode parseListBindingpatternRhs() {\n+        return parseListBindingpatternRhs(peek().kind);\n+    }\n+\n+    private STNode parseListBindingpatternRhs(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case COMMA_TOKEN:\n+                return parseComma();\n+            case CLOSE_BRACKET_TOKEN:\n+                return null;\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.TYPE_DESC_IN_TUPLE_RHS);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseListBindingpatternRhs(solution.tokenKind);\n+        }\n+    }\n+\n+    private boolean isEndOfListBindingPattern(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case IN_KEYWORD:\n+            case CLOSE_BRACKET_TOKEN:\n+            case EOF_TOKEN:\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+                return true;\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    /**\n+     * Parse rest-binding-pattern.\n+     *\n+     * rest-binding-pattern := ... variable-name\n+     *\n+     * @return rest-binding-pattern node\n+     */\n+    private STNode parseRestBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case ELLIPSIS_TOKEN:\n+                startContext(ParserRuleContext.REST_BINDING_PATTERN);\n+                STNode ellipsis = parseEllipsis();\n+                STNode varName = parseVariableName();\n+                endContext();\n+                return STNodeFactory.createRestBindingPatternNode(ellipsis, varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.REST_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-pattern entry.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return rest-binding-pattern node\n+     */\n+    private STNode parselistBindingPatternMember() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+                return consume();\n+            case ELLIPSIS_TOKEN:\n+                return parseRestBindingPattern();\n+            default:\n+                return parseBindingPattern();\n+        }\n+    }\n+\n+    /**\n+     * Parse Typed-binding-pattern.\n+     *\n+     * <code>typed-binding-pattern := inferable-type-descriptor binding-pattern</code>\n+     * <code>inferable-type-descriptor := type-descriptor | var</code>\n+     *\n+     * @return Fork statement\n+     */\n+    private STNode parseTypedBindingPattern() {\n+        startContext(ParserRuleContext.TYPED_BINDING_PATTERN);\n+        STNode typeDesc = parseTypeDescriptor(ParserRuleContext.TYPE_DESC_IN_TYPE_BINDING_PATTERN, true);\n+\n+        STNode bindingPattern = null;\n+        if (peek().kind == SyntaxKind.OPEN_BRACKET_TOKEN) {\n+            STNode typedBindingPattern = parseArrayTypeDescOrListBindingPattern(typeDesc);\n+            endContext();\n+            return typedBindingPattern;\n+        }\n+        bindingPattern = parseBindingPattern();\n+\n+        endContext();\n+        return STNodeFactory.createTypedBindingPatternNode(typeDesc, bindingPattern);\n+    }\n+\n+    private STNode parseArrayTypeDescOrListBindingPattern(STNode typeDesc) {\n+\n+        STNode arrayDescOrListBindingPattern = parseListBindingPattern();\n+\n+        if (isListBindingPatternDefinitively(arrayDescOrListBindingPattern)) { // ambiguous means T[a]\n+            return STNodeFactory.createTypedBindingPatternNode(typeDesc,\n+                    cleanListBindingPattern(arrayDescOrListBindingPattern));\n+        }\n+\n+        if (isFollowTypedBindingPattern(peek().kind)) {\n+            return STNodeFactory.createTypedBindingPatternNode(typeDesc,\n+                    cleanListBindingPattern(arrayDescOrListBindingPattern));\n+        }\n+\n+        typeDesc = mergeTypeDescAndListBindingPattern(typeDesc, arrayDescOrListBindingPattern);\n+        if (peek().kind == SyntaxKind.OPEN_BRACKET_TOKEN) {\n+            //this means arrayDescOrBLP is a array type desc\n+            return parseArrayTypeDescOrListBindingPattern(typeDesc);\n+        } else {\n+            return STNodeFactory.createTypedBindingPatternNode(typeDesc,\n+                    parseBindingPattern());\n+        }\n+\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec0194d19cb63c5625e12d2e801076bf078fc873"}, "originalPosition": 407}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MDYyNjY3OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxMDozMTowMFrOGXaHLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxMDo0OToyOVrOGXassg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE5ODI1NA==", "bodyText": "I think its safe to do the reverse of this.\ni.e: if the only-child is captured-binding-patterns, then return true.\nThat way we don't have to update this method, when we add new binding patterns.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214#discussion_r427198254", "createdAt": "2020-05-19T10:31:00Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -9343,4 +9375,342 @@ private STNode parseIntersectionTypeDescriptor(STNode leftTypeDesc, ParserRuleCo\n         STNode rightTypeDesc = parseTypeDescriptor(context);\n         return STNodeFactory.createIntersectionTypeDescriptorNode(leftTypeDesc, bitwiseAndToken, rightTypeDesc);\n     }\n+\n+    /**\n+     * Parse binding-patterns.\n+     *\n+     * binding-pattern :=\n+     *   capture-binding-pattern\n+     *    | wildcard-binding-pattern\n+     *    | list-binding-pattern\n+     *    | mapping-binding-pattern\n+     *    | functional-binding-pattern\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     * wildcard-binding-pattern := _\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *    binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ] \n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     * rest-binding-pattern := ... variable-name\n+     * functional-binding-pattern := functionally-constructible-type-reference ( arg-list-binding-pattern )\n+     * arg-list-binding-pattern :=\n+     *    positional-arg-binding-patterns [, other-arg-binding-patterns]\n+     *    | other-arg-binding-patterns\n+     * positional-arg-binding-patterns := positional-arg-binding-pattern (, positional-arg-binding-pattern)*\n+     * positional-arg-binding-pattern := binding-pattern\n+     * other-arg-binding-patterns :=\n+     *    named-arg-binding-patterns [, rest-binding-pattern]\n+     *    | [rest-binding-pattern]\n+     * named-arg-binding-patterns := named-arg-binding-pattern (, named-arg-binding-pattern)*\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n+     *\n+     * @return binding-pattern node\n+     */\n+    private STNode parseBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case OPEN_BRACKET_TOKEN:\n+                return parseListBindingPattern();\n+            case IDENTIFIER_TOKEN:\n+                return parseCaptureBindingPattern();\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse capture-binding-pattern.\n+     *\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     *\n+     * @return capture-binding-pattern node\n+     */\n+    private STNode parseCaptureBindingPattern() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case IDENTIFIER_TOKEN:\n+                STNode varName = parseVariableName();\n+                return STNodeFactory.createCaptureBindingPatternNode(varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.CAPTURE_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-patterns.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return list-binding-pattern node\n+     */\n+    private STNode parseListBindingPattern() {\n+        startContext(ParserRuleContext.LIST_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBracket = parseOpenBracket();\n+\n+        STNode listBindingPatternMember = parselistBindingPatternMember();\n+        bindingPatterns.add(listBindingPatternMember);\n+\n+        //parsing the main chunck of list-binding-pattern\n+        STToken token = peek(); // get next valid token\n+        STNode listBindingPatternRhs = null;\n+        while (!isEndOfListBindingPattern(token.kind) &&\n+                listBindingPatternMember.kind != SyntaxKind.REST_BINDING_PATTERN) {\n+            listBindingPatternRhs = parseListBindingpatternRhs(token.kind);\n+            if (listBindingPatternRhs == null) {\n+                break;\n+            }\n+            bindingPatterns.add(listBindingPatternRhs);\n+            listBindingPatternMember = parselistBindingPatternMember();\n+            bindingPatterns.add(listBindingPatternMember);\n+            token = peek();\n+        }\n+        STNode closeBracket = parseCloseBracket();\n+\n+        //seperating out the restbindingpattern\n+        STNode restBindingPattern = null;\n+        if (listBindingPatternMember.kind == SyntaxKind.REST_BINDING_PATTERN) {\n+            restBindingPattern = bindingPatterns.remove(bindingPatterns.size() - 1);\n+        } else {\n+            restBindingPattern = STNodeFactory.createEmptyNode();\n+        }\n+\n+        STNode bindingPatternsNode = STNodeFactory.createNodeList(bindingPatterns);\n+        endContext();\n+        return STNodeFactory.createListBindingPatternNode(openBracket,\n+                                                    bindingPatternsNode,\n+                                                    restBindingPattern,\n+                                                    closeBracket);\n+    }\n+\n+    private STNode parseListBindingpatternRhs() {\n+        return parseListBindingpatternRhs(peek().kind);\n+    }\n+\n+    private STNode parseListBindingpatternRhs(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case COMMA_TOKEN:\n+                return parseComma();\n+            case CLOSE_BRACKET_TOKEN:\n+                return null;\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.LIST_BINDING_PATTERN_END_OR_CONTINUE);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseListBindingpatternRhs(solution.tokenKind);\n+        }\n+    }\n+\n+    private boolean isEndOfListBindingPattern(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case IN_KEYWORD:\n+            case CLOSE_BRACKET_TOKEN:\n+            case EOF_TOKEN:\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+                return true;\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    /**\n+     * Parse rest-binding-pattern.\n+     *\n+     * rest-binding-pattern := ... variable-name\n+     *\n+     * @return rest-binding-pattern node\n+     */\n+    private STNode parseRestBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case ELLIPSIS_TOKEN:\n+                startContext(ParserRuleContext.REST_BINDING_PATTERN);\n+                STNode ellipsis = parseEllipsis();\n+                STNode varName = parseVariableName();\n+                endContext();\n+                return STNodeFactory.createRestBindingPatternNode(ellipsis, varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.REST_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-pattern entry.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return rest-binding-pattern node\n+     */\n+    private STNode parselistBindingPatternMember() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+                return consume();\n+            case ELLIPSIS_TOKEN:\n+                return parseRestBindingPattern();\n+            default:\n+                return parseBindingPattern();\n+        }\n+    }\n+\n+    /**\n+     * Parse Typed-binding-pattern.\n+     *\n+     * <code>typed-binding-pattern := inferable-type-descriptor binding-pattern</code>\n+     * <code>inferable-type-descriptor := type-descriptor | var</code>\n+     *\n+     * @return Fork statement\n+     */\n+    private STNode parseTypedBindingPattern() {\n+        startContext(ParserRuleContext.TYPED_BINDING_PATTERN);\n+        STNode typeDesc = parseTypeDescriptor(ParserRuleContext.TYPE_DESC_IN_TYPE_BINDING_PATTERN, true);\n+\n+        STNode bindingPattern = null;\n+        if (peek().kind == SyntaxKind.OPEN_BRACKET_TOKEN) {\n+            STNode typedBindingPattern = parseArrayTypeDescOrListBindingPattern(typeDesc);\n+            endContext();\n+            return typedBindingPattern;\n+        }\n+        bindingPattern = parseBindingPattern();\n+\n+        endContext();\n+        return STNodeFactory.createTypedBindingPatternNode(typeDesc, bindingPattern);\n+    }\n+\n+    private STNode parseArrayTypeDescOrListBindingPattern(STNode typeDesc) {\n+\n+        STNode arrayDescOrListBindingPattern = parseListBindingPattern();\n+\n+        if (isListBindingPatternDefinitively(arrayDescOrListBindingPattern)) { // ambiguous means T[a]\n+            return STNodeFactory.createTypedBindingPatternNode(typeDesc,\n+                    cleanListBindingPattern(arrayDescOrListBindingPattern));\n+        }\n+\n+        if (isFollowTypedBindingPattern(peek().kind)) {\n+            return STNodeFactory.createTypedBindingPatternNode(typeDesc,\n+                    cleanListBindingPattern(arrayDescOrListBindingPattern));\n+        }\n+\n+        typeDesc = mergeTypeDescAndListBindingPattern(typeDesc, arrayDescOrListBindingPattern);\n+        if (peek().kind == SyntaxKind.OPEN_BRACKET_TOKEN) {\n+            //this means arrayDescOrBLP is a array type desc\n+            return parseArrayTypeDescOrListBindingPattern(typeDesc);\n+        } else {\n+            return STNodeFactory.createTypedBindingPatternNode(typeDesc,\n+                    parseBindingPattern());\n+        }\n+\n+\n+    }\n+\n+    private STNode mergeTypeDescAndListBindingPattern(STNode typeDesc,\n+                                                      STNode bindingPattern) {\n+        STListBindingPatternNode listBindingPattern = (STListBindingPatternNode) bindingPattern;\n+        STNodeList childArray = (STNodeList) listBindingPattern.bindingPatterns;\n+        STNode child = childArray.childInBucket(0);\n+        if (child.kind == SyntaxKind.CAPTURE_BINDING_PATTERN) {\n+            child = ((STCaptureBindingPatternNode) child).variableName;\n+        }\n+        return STNodeFactory.createIndexedExpressionNode(typeDesc, listBindingPattern.openBracket,\n+                child,\n+                listBindingPattern.closeBracket);\n+    }\n+\n+    private STNode cleanListBindingPattern(STNode bindingPattern) {\n+        STListBindingPatternNode listBindingPattern = (STListBindingPatternNode) bindingPattern;\n+        STNodeList childArray = (STNodeList) listBindingPattern.bindingPatterns;\n+        int numberOfChildren = childArray.bucketCount();\n+\n+        ArrayList<STNode> cleanedChildren = new ArrayList<>();\n+        STNode child = null;\n+        for (int i = 0; i < numberOfChildren; i++) {\n+            child = childArray.childInBucket(i);\n+            switch (child.kind) {\n+                case DECIMAL_INTEGER_LITERAL:\n+                case HEX_INTEGER_LITERAL:\n+                case ASTERISK_TOKEN:\n+                    this.errorHandler.reportInvalidNode(null,\n+                            \"invalid Node \" + child.kind + \" in list-binding-pattern\");\n+                    cleanedChildren.add(STNodeFactory.createMissingToken(SyntaxKind.IDENTIFIER_TOKEN));\n+                    break;\n+                default:\n+                    cleanedChildren.add(child);\n+                    break;\n+            }\n+        }\n+\n+        return STNodeFactory.createListBindingPatternNode(listBindingPattern.openBracket,\n+                STNodeFactory.createNodeList(cleanedChildren),\n+                listBindingPattern.restBindingPattern,\n+                listBindingPattern.closeBracket);\n+    }\n+\n+    private boolean isListBindingPatternDefinitively(STNode bindingPattern) {\n+        STListBindingPatternNode listBindingPattern = (STListBindingPatternNode) bindingPattern;\n+        STNodeList childArray = (STNodeList) listBindingPattern.bindingPatterns;\n+        int numberOfChildren = childArray.bucketCount();\n+\n+        if (listBindingPattern.restBindingPattern != null) {\n+            return true;\n+        }\n+\n+        if (numberOfChildren == 1) {\n+            STNode child = childArray.childInBucket(0);\n+            switch (child.kind) {\n+                case LIST_BINDING_PATTERN:\n+                case REST_BINDING_PATTERN:\n+                    return true;\n+                default: // cases like [ and {\n+                    return false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86b3868076bb1f535f392b0160046ac64a83811d"}, "originalPosition": 470}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzIwNzg1OA==", "bodyText": "sure", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214#discussion_r427207858", "createdAt": "2020-05-19T10:49:29Z", "author": {"login": "m36dot"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -9343,4 +9375,342 @@ private STNode parseIntersectionTypeDescriptor(STNode leftTypeDesc, ParserRuleCo\n         STNode rightTypeDesc = parseTypeDescriptor(context);\n         return STNodeFactory.createIntersectionTypeDescriptorNode(leftTypeDesc, bitwiseAndToken, rightTypeDesc);\n     }\n+\n+    /**\n+     * Parse binding-patterns.\n+     *\n+     * binding-pattern :=\n+     *   capture-binding-pattern\n+     *    | wildcard-binding-pattern\n+     *    | list-binding-pattern\n+     *    | mapping-binding-pattern\n+     *    | functional-binding-pattern\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     * wildcard-binding-pattern := _\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *    binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ] \n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     * rest-binding-pattern := ... variable-name\n+     * functional-binding-pattern := functionally-constructible-type-reference ( arg-list-binding-pattern )\n+     * arg-list-binding-pattern :=\n+     *    positional-arg-binding-patterns [, other-arg-binding-patterns]\n+     *    | other-arg-binding-patterns\n+     * positional-arg-binding-patterns := positional-arg-binding-pattern (, positional-arg-binding-pattern)*\n+     * positional-arg-binding-pattern := binding-pattern\n+     * other-arg-binding-patterns :=\n+     *    named-arg-binding-patterns [, rest-binding-pattern]\n+     *    | [rest-binding-pattern]\n+     * named-arg-binding-patterns := named-arg-binding-pattern (, named-arg-binding-pattern)*\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n+     *\n+     * @return binding-pattern node\n+     */\n+    private STNode parseBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case OPEN_BRACKET_TOKEN:\n+                return parseListBindingPattern();\n+            case IDENTIFIER_TOKEN:\n+                return parseCaptureBindingPattern();\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse capture-binding-pattern.\n+     *\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     *\n+     * @return capture-binding-pattern node\n+     */\n+    private STNode parseCaptureBindingPattern() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case IDENTIFIER_TOKEN:\n+                STNode varName = parseVariableName();\n+                return STNodeFactory.createCaptureBindingPatternNode(varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.CAPTURE_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-patterns.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return list-binding-pattern node\n+     */\n+    private STNode parseListBindingPattern() {\n+        startContext(ParserRuleContext.LIST_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBracket = parseOpenBracket();\n+\n+        STNode listBindingPatternMember = parselistBindingPatternMember();\n+        bindingPatterns.add(listBindingPatternMember);\n+\n+        //parsing the main chunck of list-binding-pattern\n+        STToken token = peek(); // get next valid token\n+        STNode listBindingPatternRhs = null;\n+        while (!isEndOfListBindingPattern(token.kind) &&\n+                listBindingPatternMember.kind != SyntaxKind.REST_BINDING_PATTERN) {\n+            listBindingPatternRhs = parseListBindingpatternRhs(token.kind);\n+            if (listBindingPatternRhs == null) {\n+                break;\n+            }\n+            bindingPatterns.add(listBindingPatternRhs);\n+            listBindingPatternMember = parselistBindingPatternMember();\n+            bindingPatterns.add(listBindingPatternMember);\n+            token = peek();\n+        }\n+        STNode closeBracket = parseCloseBracket();\n+\n+        //seperating out the restbindingpattern\n+        STNode restBindingPattern = null;\n+        if (listBindingPatternMember.kind == SyntaxKind.REST_BINDING_PATTERN) {\n+            restBindingPattern = bindingPatterns.remove(bindingPatterns.size() - 1);\n+        } else {\n+            restBindingPattern = STNodeFactory.createEmptyNode();\n+        }\n+\n+        STNode bindingPatternsNode = STNodeFactory.createNodeList(bindingPatterns);\n+        endContext();\n+        return STNodeFactory.createListBindingPatternNode(openBracket,\n+                                                    bindingPatternsNode,\n+                                                    restBindingPattern,\n+                                                    closeBracket);\n+    }\n+\n+    private STNode parseListBindingpatternRhs() {\n+        return parseListBindingpatternRhs(peek().kind);\n+    }\n+\n+    private STNode parseListBindingpatternRhs(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case COMMA_TOKEN:\n+                return parseComma();\n+            case CLOSE_BRACKET_TOKEN:\n+                return null;\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.LIST_BINDING_PATTERN_END_OR_CONTINUE);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseListBindingpatternRhs(solution.tokenKind);\n+        }\n+    }\n+\n+    private boolean isEndOfListBindingPattern(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case IN_KEYWORD:\n+            case CLOSE_BRACKET_TOKEN:\n+            case EOF_TOKEN:\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+                return true;\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    /**\n+     * Parse rest-binding-pattern.\n+     *\n+     * rest-binding-pattern := ... variable-name\n+     *\n+     * @return rest-binding-pattern node\n+     */\n+    private STNode parseRestBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case ELLIPSIS_TOKEN:\n+                startContext(ParserRuleContext.REST_BINDING_PATTERN);\n+                STNode ellipsis = parseEllipsis();\n+                STNode varName = parseVariableName();\n+                endContext();\n+                return STNodeFactory.createRestBindingPatternNode(ellipsis, varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.REST_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-pattern entry.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return rest-binding-pattern node\n+     */\n+    private STNode parselistBindingPatternMember() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+                return consume();\n+            case ELLIPSIS_TOKEN:\n+                return parseRestBindingPattern();\n+            default:\n+                return parseBindingPattern();\n+        }\n+    }\n+\n+    /**\n+     * Parse Typed-binding-pattern.\n+     *\n+     * <code>typed-binding-pattern := inferable-type-descriptor binding-pattern</code>\n+     * <code>inferable-type-descriptor := type-descriptor | var</code>\n+     *\n+     * @return Fork statement\n+     */\n+    private STNode parseTypedBindingPattern() {\n+        startContext(ParserRuleContext.TYPED_BINDING_PATTERN);\n+        STNode typeDesc = parseTypeDescriptor(ParserRuleContext.TYPE_DESC_IN_TYPE_BINDING_PATTERN, true);\n+\n+        STNode bindingPattern = null;\n+        if (peek().kind == SyntaxKind.OPEN_BRACKET_TOKEN) {\n+            STNode typedBindingPattern = parseArrayTypeDescOrListBindingPattern(typeDesc);\n+            endContext();\n+            return typedBindingPattern;\n+        }\n+        bindingPattern = parseBindingPattern();\n+\n+        endContext();\n+        return STNodeFactory.createTypedBindingPatternNode(typeDesc, bindingPattern);\n+    }\n+\n+    private STNode parseArrayTypeDescOrListBindingPattern(STNode typeDesc) {\n+\n+        STNode arrayDescOrListBindingPattern = parseListBindingPattern();\n+\n+        if (isListBindingPatternDefinitively(arrayDescOrListBindingPattern)) { // ambiguous means T[a]\n+            return STNodeFactory.createTypedBindingPatternNode(typeDesc,\n+                    cleanListBindingPattern(arrayDescOrListBindingPattern));\n+        }\n+\n+        if (isFollowTypedBindingPattern(peek().kind)) {\n+            return STNodeFactory.createTypedBindingPatternNode(typeDesc,\n+                    cleanListBindingPattern(arrayDescOrListBindingPattern));\n+        }\n+\n+        typeDesc = mergeTypeDescAndListBindingPattern(typeDesc, arrayDescOrListBindingPattern);\n+        if (peek().kind == SyntaxKind.OPEN_BRACKET_TOKEN) {\n+            //this means arrayDescOrBLP is a array type desc\n+            return parseArrayTypeDescOrListBindingPattern(typeDesc);\n+        } else {\n+            return STNodeFactory.createTypedBindingPatternNode(typeDesc,\n+                    parseBindingPattern());\n+        }\n+\n+\n+    }\n+\n+    private STNode mergeTypeDescAndListBindingPattern(STNode typeDesc,\n+                                                      STNode bindingPattern) {\n+        STListBindingPatternNode listBindingPattern = (STListBindingPatternNode) bindingPattern;\n+        STNodeList childArray = (STNodeList) listBindingPattern.bindingPatterns;\n+        STNode child = childArray.childInBucket(0);\n+        if (child.kind == SyntaxKind.CAPTURE_BINDING_PATTERN) {\n+            child = ((STCaptureBindingPatternNode) child).variableName;\n+        }\n+        return STNodeFactory.createIndexedExpressionNode(typeDesc, listBindingPattern.openBracket,\n+                child,\n+                listBindingPattern.closeBracket);\n+    }\n+\n+    private STNode cleanListBindingPattern(STNode bindingPattern) {\n+        STListBindingPatternNode listBindingPattern = (STListBindingPatternNode) bindingPattern;\n+        STNodeList childArray = (STNodeList) listBindingPattern.bindingPatterns;\n+        int numberOfChildren = childArray.bucketCount();\n+\n+        ArrayList<STNode> cleanedChildren = new ArrayList<>();\n+        STNode child = null;\n+        for (int i = 0; i < numberOfChildren; i++) {\n+            child = childArray.childInBucket(i);\n+            switch (child.kind) {\n+                case DECIMAL_INTEGER_LITERAL:\n+                case HEX_INTEGER_LITERAL:\n+                case ASTERISK_TOKEN:\n+                    this.errorHandler.reportInvalidNode(null,\n+                            \"invalid Node \" + child.kind + \" in list-binding-pattern\");\n+                    cleanedChildren.add(STNodeFactory.createMissingToken(SyntaxKind.IDENTIFIER_TOKEN));\n+                    break;\n+                default:\n+                    cleanedChildren.add(child);\n+                    break;\n+            }\n+        }\n+\n+        return STNodeFactory.createListBindingPatternNode(listBindingPattern.openBracket,\n+                STNodeFactory.createNodeList(cleanedChildren),\n+                listBindingPattern.restBindingPattern,\n+                listBindingPattern.closeBracket);\n+    }\n+\n+    private boolean isListBindingPatternDefinitively(STNode bindingPattern) {\n+        STListBindingPatternNode listBindingPattern = (STListBindingPatternNode) bindingPattern;\n+        STNodeList childArray = (STNodeList) listBindingPattern.bindingPatterns;\n+        int numberOfChildren = childArray.bucketCount();\n+\n+        if (listBindingPattern.restBindingPattern != null) {\n+            return true;\n+        }\n+\n+        if (numberOfChildren == 1) {\n+            STNode child = childArray.childInBucket(0);\n+            switch (child.kind) {\n+                case LIST_BINDING_PATTERN:\n+                case REST_BINDING_PATTERN:\n+                    return true;\n+                default: // cases like [ and {\n+                    return false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE5ODI1NA=="}, "originalCommit": {"oid": "86b3868076bb1f535f392b0160046ac64a83811d"}, "originalPosition": 470}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MDYzOTc0OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxMDozNDo1NlrOGXaPTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxMDozNDo1NlrOGXaPTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzIwMDMzMw==", "bodyText": "Regardless whether its a valid child or an invalid child, we need to keep it. That is required to regenerate the source-code using the syntax tree.\nSo we can simply rename this method as \"validateListBindingPattern\", and only log an error for invalid children, but let them stay.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214#discussion_r427200333", "createdAt": "2020-05-19T10:34:56Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -9343,4 +9375,342 @@ private STNode parseIntersectionTypeDescriptor(STNode leftTypeDesc, ParserRuleCo\n         STNode rightTypeDesc = parseTypeDescriptor(context);\n         return STNodeFactory.createIntersectionTypeDescriptorNode(leftTypeDesc, bitwiseAndToken, rightTypeDesc);\n     }\n+\n+    /**\n+     * Parse binding-patterns.\n+     *\n+     * binding-pattern :=\n+     *   capture-binding-pattern\n+     *    | wildcard-binding-pattern\n+     *    | list-binding-pattern\n+     *    | mapping-binding-pattern\n+     *    | functional-binding-pattern\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     * wildcard-binding-pattern := _\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *    binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ] \n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     * rest-binding-pattern := ... variable-name\n+     * functional-binding-pattern := functionally-constructible-type-reference ( arg-list-binding-pattern )\n+     * arg-list-binding-pattern :=\n+     *    positional-arg-binding-patterns [, other-arg-binding-patterns]\n+     *    | other-arg-binding-patterns\n+     * positional-arg-binding-patterns := positional-arg-binding-pattern (, positional-arg-binding-pattern)*\n+     * positional-arg-binding-pattern := binding-pattern\n+     * other-arg-binding-patterns :=\n+     *    named-arg-binding-patterns [, rest-binding-pattern]\n+     *    | [rest-binding-pattern]\n+     * named-arg-binding-patterns := named-arg-binding-pattern (, named-arg-binding-pattern)*\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n+     *\n+     * @return binding-pattern node\n+     */\n+    private STNode parseBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case OPEN_BRACKET_TOKEN:\n+                return parseListBindingPattern();\n+            case IDENTIFIER_TOKEN:\n+                return parseCaptureBindingPattern();\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse capture-binding-pattern.\n+     *\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     *\n+     * @return capture-binding-pattern node\n+     */\n+    private STNode parseCaptureBindingPattern() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case IDENTIFIER_TOKEN:\n+                STNode varName = parseVariableName();\n+                return STNodeFactory.createCaptureBindingPatternNode(varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.CAPTURE_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-patterns.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return list-binding-pattern node\n+     */\n+    private STNode parseListBindingPattern() {\n+        startContext(ParserRuleContext.LIST_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBracket = parseOpenBracket();\n+\n+        STNode listBindingPatternMember = parselistBindingPatternMember();\n+        bindingPatterns.add(listBindingPatternMember);\n+\n+        //parsing the main chunck of list-binding-pattern\n+        STToken token = peek(); // get next valid token\n+        STNode listBindingPatternRhs = null;\n+        while (!isEndOfListBindingPattern(token.kind) &&\n+                listBindingPatternMember.kind != SyntaxKind.REST_BINDING_PATTERN) {\n+            listBindingPatternRhs = parseListBindingpatternRhs(token.kind);\n+            if (listBindingPatternRhs == null) {\n+                break;\n+            }\n+            bindingPatterns.add(listBindingPatternRhs);\n+            listBindingPatternMember = parselistBindingPatternMember();\n+            bindingPatterns.add(listBindingPatternMember);\n+            token = peek();\n+        }\n+        STNode closeBracket = parseCloseBracket();\n+\n+        //seperating out the restbindingpattern\n+        STNode restBindingPattern = null;\n+        if (listBindingPatternMember.kind == SyntaxKind.REST_BINDING_PATTERN) {\n+            restBindingPattern = bindingPatterns.remove(bindingPatterns.size() - 1);\n+        } else {\n+            restBindingPattern = STNodeFactory.createEmptyNode();\n+        }\n+\n+        STNode bindingPatternsNode = STNodeFactory.createNodeList(bindingPatterns);\n+        endContext();\n+        return STNodeFactory.createListBindingPatternNode(openBracket,\n+                                                    bindingPatternsNode,\n+                                                    restBindingPattern,\n+                                                    closeBracket);\n+    }\n+\n+    private STNode parseListBindingpatternRhs() {\n+        return parseListBindingpatternRhs(peek().kind);\n+    }\n+\n+    private STNode parseListBindingpatternRhs(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case COMMA_TOKEN:\n+                return parseComma();\n+            case CLOSE_BRACKET_TOKEN:\n+                return null;\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.LIST_BINDING_PATTERN_END_OR_CONTINUE);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseListBindingpatternRhs(solution.tokenKind);\n+        }\n+    }\n+\n+    private boolean isEndOfListBindingPattern(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case IN_KEYWORD:\n+            case CLOSE_BRACKET_TOKEN:\n+            case EOF_TOKEN:\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+                return true;\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    /**\n+     * Parse rest-binding-pattern.\n+     *\n+     * rest-binding-pattern := ... variable-name\n+     *\n+     * @return rest-binding-pattern node\n+     */\n+    private STNode parseRestBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case ELLIPSIS_TOKEN:\n+                startContext(ParserRuleContext.REST_BINDING_PATTERN);\n+                STNode ellipsis = parseEllipsis();\n+                STNode varName = parseVariableName();\n+                endContext();\n+                return STNodeFactory.createRestBindingPatternNode(ellipsis, varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.REST_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-pattern entry.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return rest-binding-pattern node\n+     */\n+    private STNode parselistBindingPatternMember() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+                return consume();\n+            case ELLIPSIS_TOKEN:\n+                return parseRestBindingPattern();\n+            default:\n+                return parseBindingPattern();\n+        }\n+    }\n+\n+    /**\n+     * Parse Typed-binding-pattern.\n+     *\n+     * <code>typed-binding-pattern := inferable-type-descriptor binding-pattern</code>\n+     * <code>inferable-type-descriptor := type-descriptor | var</code>\n+     *\n+     * @return Fork statement\n+     */\n+    private STNode parseTypedBindingPattern() {\n+        startContext(ParserRuleContext.TYPED_BINDING_PATTERN);\n+        STNode typeDesc = parseTypeDescriptor(ParserRuleContext.TYPE_DESC_IN_TYPE_BINDING_PATTERN, true);\n+\n+        STNode bindingPattern = null;\n+        if (peek().kind == SyntaxKind.OPEN_BRACKET_TOKEN) {\n+            STNode typedBindingPattern = parseArrayTypeDescOrListBindingPattern(typeDesc);\n+            endContext();\n+            return typedBindingPattern;\n+        }\n+        bindingPattern = parseBindingPattern();\n+\n+        endContext();\n+        return STNodeFactory.createTypedBindingPatternNode(typeDesc, bindingPattern);\n+    }\n+\n+    private STNode parseArrayTypeDescOrListBindingPattern(STNode typeDesc) {\n+\n+        STNode arrayDescOrListBindingPattern = parseListBindingPattern();\n+\n+        if (isListBindingPatternDefinitively(arrayDescOrListBindingPattern)) { // ambiguous means T[a]\n+            return STNodeFactory.createTypedBindingPatternNode(typeDesc,\n+                    cleanListBindingPattern(arrayDescOrListBindingPattern));\n+        }\n+\n+        if (isFollowTypedBindingPattern(peek().kind)) {\n+            return STNodeFactory.createTypedBindingPatternNode(typeDesc,\n+                    cleanListBindingPattern(arrayDescOrListBindingPattern));\n+        }\n+\n+        typeDesc = mergeTypeDescAndListBindingPattern(typeDesc, arrayDescOrListBindingPattern);\n+        if (peek().kind == SyntaxKind.OPEN_BRACKET_TOKEN) {\n+            //this means arrayDescOrBLP is a array type desc\n+            return parseArrayTypeDescOrListBindingPattern(typeDesc);\n+        } else {\n+            return STNodeFactory.createTypedBindingPatternNode(typeDesc,\n+                    parseBindingPattern());\n+        }\n+\n+\n+    }\n+\n+    private STNode mergeTypeDescAndListBindingPattern(STNode typeDesc,\n+                                                      STNode bindingPattern) {\n+        STListBindingPatternNode listBindingPattern = (STListBindingPatternNode) bindingPattern;\n+        STNodeList childArray = (STNodeList) listBindingPattern.bindingPatterns;\n+        STNode child = childArray.childInBucket(0);\n+        if (child.kind == SyntaxKind.CAPTURE_BINDING_PATTERN) {\n+            child = ((STCaptureBindingPatternNode) child).variableName;\n+        }\n+        return STNodeFactory.createIndexedExpressionNode(typeDesc, listBindingPattern.openBracket,\n+                child,\n+                listBindingPattern.closeBracket);\n+    }\n+\n+    private STNode cleanListBindingPattern(STNode bindingPattern) {\n+        STListBindingPatternNode listBindingPattern = (STListBindingPatternNode) bindingPattern;\n+        STNodeList childArray = (STNodeList) listBindingPattern.bindingPatterns;\n+        int numberOfChildren = childArray.bucketCount();\n+\n+        ArrayList<STNode> cleanedChildren = new ArrayList<>();\n+        STNode child = null;\n+        for (int i = 0; i < numberOfChildren; i++) {\n+            child = childArray.childInBucket(i);\n+            switch (child.kind) {\n+                case DECIMAL_INTEGER_LITERAL:\n+                case HEX_INTEGER_LITERAL:\n+                case ASTERISK_TOKEN:\n+                    this.errorHandler.reportInvalidNode(null,\n+                            \"invalid Node \" + child.kind + \" in list-binding-pattern\");\n+                    cleanedChildren.add(STNodeFactory.createMissingToken(SyntaxKind.IDENTIFIER_TOKEN));\n+                    break;\n+                default:\n+                    cleanedChildren.add(child);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86b3868076bb1f535f392b0160046ac64a83811d"}, "originalPosition": 443}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MDc0NzA5OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-treegen/src/main/resources/syntax_tree_descriptor.json", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxMTowNzowNFrOGXbSfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxMTowNzowNFrOGXbSfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzIxNzUzMg==", "bodyText": "Should be TypeDescriptorNode", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214#discussion_r427217532", "createdAt": "2020-05-19T11:07:04Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-treegen/src/main/resources/syntax_tree_descriptor.json", "diffHunk": "@@ -2848,6 +2844,78 @@\n                     \"type\": \"Token\"\n                 }\n             ]\n+        },\n+        {\n+            \"name\": \"TypedBindingPatternNode\",\n+            \"base\": \"Node\",\n+            \"kind\": \"TYPED_BINDING_PATTERN\",\n+            \"attributes\": [\n+                {\n+                    \"name\": \"typeDescriptor\",\n+                    \"type\": \"Node\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86b3868076bb1f535f392b0160046ac64a83811d"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MDc0ODc1OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-treegen/src/main/resources/syntax_tree_descriptor.json", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxMTowNzozMlrOGXbTgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxMTowNzozMlrOGXbTgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzIxNzc5NQ==", "bodyText": "SimpleNameReferenceNode", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214#discussion_r427217795", "createdAt": "2020-05-19T11:07:32Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-treegen/src/main/resources/syntax_tree_descriptor.json", "diffHunk": "@@ -2848,6 +2844,78 @@\n                     \"type\": \"Token\"\n                 }\n             ]\n+        },\n+        {\n+            \"name\": \"TypedBindingPatternNode\",\n+            \"base\": \"Node\",\n+            \"kind\": \"TYPED_BINDING_PATTERN\",\n+            \"attributes\": [\n+                {\n+                    \"name\": \"typeDescriptor\",\n+                    \"type\": \"Node\"\n+                },\n+                {\n+                    \"name\": \"bindingPattern\",\n+                    \"type\": \"BindingPatternNode\"\n+                }\n+            ]\n+        },\n+        {\n+            \"name\": \"BindingPatternNode\",\n+            \"base\": \"Node\",\n+            \"isAbstract\": true\n+        },\n+        {\n+            \"name\": \"CaptureBindingPatternNode\",\n+            \"base\": \"BindingPatternNode\",\n+            \"kind\": \"CAPTURE_BINDING_PATTERN\",\n+            \"attributes\": [\n+                {\n+                    \"name\": \"variableName\",\n+                    \"type\": \"Token\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86b3868076bb1f535f392b0160046ac64a83811d"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MDc1MDEzOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-treegen/src/main/resources/syntax_tree_descriptor.json", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxMTowNzo1NFrOGXbUTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxMTowNzo1NFrOGXbUTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzIxNzk5OQ==", "bodyText": "SimpleNameReferenceNode", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214#discussion_r427217999", "createdAt": "2020-05-19T11:07:54Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-treegen/src/main/resources/syntax_tree_descriptor.json", "diffHunk": "@@ -2848,6 +2844,78 @@\n                     \"type\": \"Token\"\n                 }\n             ]\n+        },\n+        {\n+            \"name\": \"TypedBindingPatternNode\",\n+            \"base\": \"Node\",\n+            \"kind\": \"TYPED_BINDING_PATTERN\",\n+            \"attributes\": [\n+                {\n+                    \"name\": \"typeDescriptor\",\n+                    \"type\": \"Node\"\n+                },\n+                {\n+                    \"name\": \"bindingPattern\",\n+                    \"type\": \"BindingPatternNode\"\n+                }\n+            ]\n+        },\n+        {\n+            \"name\": \"BindingPatternNode\",\n+            \"base\": \"Node\",\n+            \"isAbstract\": true\n+        },\n+        {\n+            \"name\": \"CaptureBindingPatternNode\",\n+            \"base\": \"BindingPatternNode\",\n+            \"kind\": \"CAPTURE_BINDING_PATTERN\",\n+            \"attributes\": [\n+                {\n+                    \"name\": \"variableName\",\n+                    \"type\": \"Token\",\n+                    \"isOptional\": true\n+                }\n+            ]\n+        },\n+        {\n+            \"name\": \"ListBindingPatternNode\",\n+            \"base\": \"BindingPatternNode\",\n+            \"kind\": \"LIST_BINDING_PATTERN\",\n+            \"attributes\": [\n+                {\n+                    \"name\": \"openBracket\",\n+                    \"type\": \"Token\"\n+                },\n+                {\n+                    \"name\": \"bindingPatterns\",\n+                    \"type\": \"BindingPatternNode\",\n+                    \"occurrences\": \"MULTIPLE_SEPARATED\"\n+                },\n+                {\n+                    \"name\": \"restBindingPattern\",\n+                    \"type\": \"RestBindingPatternNode\",\n+                    \"isOptional\": true\n+                },\n+                {\n+                    \"name\": \"closeBracket\",\n+                    \"type\": \"Token\"\n+                }\n+            ]\n+        },\n+        {\n+            \"name\": \"RestBindingPatternNode\",\n+            \"base\": \"Node\",\n+            \"kind\": \"REST_BINDING_PATTERN\",\n+            \"attributes\": [\n+                {\n+                    \"name\": \"ellipsisToken\",\n+                    \"type\": \"Token\"\n+                },\n+                {\n+                    \"name\": \"variableName\",\n+                    \"type\": \"Token\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86b3868076bb1f535f392b0160046ac64a83811d"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MTM1ODg3OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-treegen/src/main/resources/syntax_tree_descriptor.json", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxMzo0ODowN1rOGXhTnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxMzo0ODowN1rOGXhTnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzMxNjEyNw==", "bodyText": "Is this optional?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214#discussion_r427316127", "createdAt": "2020-05-19T13:48:07Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-treegen/src/main/resources/syntax_tree_descriptor.json", "diffHunk": "@@ -2848,6 +2844,78 @@\n                     \"type\": \"Token\"\n                 }\n             ]\n+        },\n+        {\n+            \"name\": \"TypedBindingPatternNode\",\n+            \"base\": \"Node\",\n+            \"kind\": \"TYPED_BINDING_PATTERN\",\n+            \"attributes\": [\n+                {\n+                    \"name\": \"typeDescriptor\",\n+                    \"type\": \"TypeDescriptorNode\"\n+                },\n+                {\n+                    \"name\": \"bindingPattern\",\n+                    \"type\": \"BindingPatternNode\"\n+                }\n+            ]\n+        },\n+        {\n+            \"name\": \"BindingPatternNode\",\n+            \"base\": \"Node\",\n+            \"isAbstract\": true\n+        },\n+        {\n+            \"name\": \"CaptureBindingPatternNode\",\n+            \"base\": \"BindingPatternNode\",\n+            \"kind\": \"CAPTURE_BINDING_PATTERN\",\n+            \"attributes\": [\n+                {\n+                    \"name\": \"variableName\",\n+                    \"type\": \"SimpleNameReferenceNode\",\n+                    \"isOptional\": true", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b08cbe92377b1bc413ff4a170865b8e9dbf3274"}, "originalPosition": 48}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3647, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}