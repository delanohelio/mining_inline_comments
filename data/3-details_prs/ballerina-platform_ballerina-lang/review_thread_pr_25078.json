{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDYwMDIzNTUx", "number": 25078, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxMToxNjo1N1rOEUBW9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxMTowODowOVrOEWv36Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5NDI5MjM2OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxMToxNjo1N1rOG6E_Zw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQwNTowMTo1NlrOG7RLEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzU1MjM1OQ==", "bodyText": "If the token is neither transactional or function, we'll have to add recovery here", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25078#discussion_r463552359", "createdAt": "2020-07-31T11:16:57Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -1460,28 +1461,21 @@ private STNode parseFuncDefinition(STNode metadata, boolean isObjectMethod, STNo\n      * </code>\n      *\n      * @param metadata Metadata\n-     * @param visibilityQualifier Visibility qualifier\n+     * @param qualifiers qualifier list\n      * @return Parsed node\n      */\n-    private STNode parseFuncDefOrFuncTypeDesc(STNode metadata, boolean isObjectMethod, STNode... qualifiers) {\n-        parseTransactionalQUalifier(qualifiers);\n+    private STNode parseFuncDefOrFuncTypeDesc(STNode metadata, boolean isObjectMethod, List<STNode> qualifiers) {\n+        if (peek().kind == SyntaxKind.TRANSACTIONAL_KEYWORD) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0869d6cad732a43b0e575c28afd4bf7ee3b720f0"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzU5NzA1MQ==", "bodyText": "Yes, will add", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25078#discussion_r463597051", "createdAt": "2020-07-31T13:02:04Z", "author": {"login": "rdulmina"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -1460,28 +1461,21 @@ private STNode parseFuncDefinition(STNode metadata, boolean isObjectMethod, STNo\n      * </code>\n      *\n      * @param metadata Metadata\n-     * @param visibilityQualifier Visibility qualifier\n+     * @param qualifiers qualifier list\n      * @return Parsed node\n      */\n-    private STNode parseFuncDefOrFuncTypeDesc(STNode metadata, boolean isObjectMethod, STNode... qualifiers) {\n-        parseTransactionalQUalifier(qualifiers);\n+    private STNode parseFuncDefOrFuncTypeDesc(STNode metadata, boolean isObjectMethod, List<STNode> qualifiers) {\n+        if (peek().kind == SyntaxKind.TRANSACTIONAL_KEYWORD) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzU1MjM1OQ=="}, "originalCommit": {"oid": "0869d6cad732a43b0e575c28afd4bf7ee3b720f0"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDgwMDUyOA==", "bodyText": "Added.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25078#discussion_r464800528", "createdAt": "2020-08-04T05:01:56Z", "author": {"login": "rdulmina"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -1460,28 +1461,21 @@ private STNode parseFuncDefinition(STNode metadata, boolean isObjectMethod, STNo\n      * </code>\n      *\n      * @param metadata Metadata\n-     * @param visibilityQualifier Visibility qualifier\n+     * @param qualifiers qualifier list\n      * @return Parsed node\n      */\n-    private STNode parseFuncDefOrFuncTypeDesc(STNode metadata, boolean isObjectMethod, STNode... qualifiers) {\n-        parseTransactionalQUalifier(qualifiers);\n+    private STNode parseFuncDefOrFuncTypeDesc(STNode metadata, boolean isObjectMethod, List<STNode> qualifiers) {\n+        if (peek().kind == SyntaxKind.TRANSACTIONAL_KEYWORD) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzU1MjM1OQ=="}, "originalCommit": {"oid": "0869d6cad732a43b0e575c28afd4bf7ee3b720f0"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyMTk1MzYwOnYy", "diffSide": "RIGHT", "path": "misc/testerina/modules/testerina-core/src/main/ballerina/Ballerina.toml", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQwNToyNzo1MVrOG-Bvww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQwNTo0MzozM1rOG-B8uQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzY5MzUwNw==", "bodyText": "Do we need this change?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25078#discussion_r467693507", "createdAt": "2020-08-10T05:27:51Z", "author": {"login": "lochana-chathura"}, "path": "misc/testerina/modules/testerina-core/src/main/ballerina/Ballerina.toml", "diffHunk": "@@ -8,5 +8,5 @@ target = \"java8\"\n     [[platform.libraries]]\n         artifactId = \"mock\"\n         version = \"0.0.0\"\n-        path = \"./lib/testerina-core-2.0.0-Preview2.jar\"\n+        path = \"./lib/testerina-core-2.0.0-Preview3-SNAPSHOT.jar\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bcff57f0f4ca24023848b210da3fbe9dbd129869"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzY5NjgyNQ==", "bodyText": "We don't need that. Thanx for mentioning.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25078#discussion_r467696825", "createdAt": "2020-08-10T05:43:33Z", "author": {"login": "rdulmina"}, "path": "misc/testerina/modules/testerina-core/src/main/ballerina/Ballerina.toml", "diffHunk": "@@ -8,5 +8,5 @@ target = \"java8\"\n     [[platform.libraries]]\n         artifactId = \"mock\"\n         version = \"0.0.0\"\n-        path = \"./lib/testerina-core-2.0.0-Preview2.jar\"\n+        path = \"./lib/testerina-core-2.0.0-Preview3-SNAPSHOT.jar\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzY5MzUwNw=="}, "originalCommit": {"oid": "bcff57f0f4ca24023848b210da3fbe9dbd129869"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyMTk1NDg0OnYy", "diffSide": "RIGHT", "path": "tests/jballerina-unit-test/ballerina-internal.log.1", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQwNToyODo1NFrOG-Bwbw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQwNTo0ODoyM1rOG-CA7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzY5MzY3OQ==", "bodyText": "this file also?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25078#discussion_r467693679", "createdAt": "2020-08-10T05:28:54Z", "author": {"login": "lochana-chathura"}, "path": "tests/jballerina-unit-test/ballerina-internal.log.1", "diffHunk": "@@ -0,0 +1,720 @@\n+[2020-08-07 12:25:46,714] SEVERE {b7a.log.crash} - ballerina/lang_annotations/1_0_0/___init ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bcff57f0f4ca24023848b210da3fbe9dbd129869"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzY5NzkwMA==", "bodyText": "thanx", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25078#discussion_r467697900", "createdAt": "2020-08-10T05:48:23Z", "author": {"login": "rdulmina"}, "path": "tests/jballerina-unit-test/ballerina-internal.log.1", "diffHunk": "@@ -0,0 +1,720 @@\n+[2020-08-07 12:25:46,714] SEVERE {b7a.log.crash} - ballerina/lang_annotations/1_0_0/___init ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzY5MzY3OQ=="}, "originalCommit": {"oid": "bcff57f0f4ca24023848b210da3fbe9dbd129869"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyMTk1ODQ4OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQwNTozMDo1MVrOG-ByRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQwNjo1NDowM1rOG-DIfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzY5NDE1MQ==", "bodyText": "these qualifiers are always optional right? Do we need to go to the recovery?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25078#discussion_r467694151", "createdAt": "2020-08-10T05:30:51Z", "author": {"login": "lochana-chathura"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -5636,6 +5662,97 @@ private STNode parseObjectMethodOrField(SyntaxKind nextTokenKind, SyntaxKind nex\n         return parseObjectMethodOrField(solution.tokenKind, nextTokenKind, metadata, visibilityQualifier);\n     }\n \n+    /**\n+     * Parse function qualifiers.\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseFunctionQualifiers(ParserRuleContext context, List<STNode> qualifierList) {\n+        STToken nextToken = peek();\n+        return parseFunctionQualifiers(nextToken.kind, context, qualifierList);\n+    }\n+\n+    private STNode parseFunctionQualifiers(SyntaxKind tokenKind, ParserRuleContext context,\n+                                               List<STNode> qualifierList) {\n+        while (!isEndOfFunctionQualifiers(tokenKind)) {\n+            STNode qualifier;\n+            switch (tokenKind) {\n+                case REMOTE_KEYWORD:\n+                    qualifier = parseRemoteKeyword();\n+                    break;\n+                case TRANSACTIONAL_KEYWORD:\n+                    qualifier = parseTransactionalKeyword();\n+                    break;\n+                case RESOURCE_KEYWORD:\n+                    qualifier = parseResourceKeyword();\n+                    break;\n+                default:\n+                    Solution solution = recover(peek(), context, context, qualifierList);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bcff57f0f4ca24023848b210da3fbe9dbd129869"}, "originalPosition": 272}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzY5ODg0Nw==", "bodyText": "Yes there can be invalid tokens before qualifier or missing function keyword. Those things will recover here.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25078#discussion_r467698847", "createdAt": "2020-08-10T05:52:29Z", "author": {"login": "rdulmina"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -5636,6 +5662,97 @@ private STNode parseObjectMethodOrField(SyntaxKind nextTokenKind, SyntaxKind nex\n         return parseObjectMethodOrField(solution.tokenKind, nextTokenKind, metadata, visibilityQualifier);\n     }\n \n+    /**\n+     * Parse function qualifiers.\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseFunctionQualifiers(ParserRuleContext context, List<STNode> qualifierList) {\n+        STToken nextToken = peek();\n+        return parseFunctionQualifiers(nextToken.kind, context, qualifierList);\n+    }\n+\n+    private STNode parseFunctionQualifiers(SyntaxKind tokenKind, ParserRuleContext context,\n+                                               List<STNode> qualifierList) {\n+        while (!isEndOfFunctionQualifiers(tokenKind)) {\n+            STNode qualifier;\n+            switch (tokenKind) {\n+                case REMOTE_KEYWORD:\n+                    qualifier = parseRemoteKeyword();\n+                    break;\n+                case TRANSACTIONAL_KEYWORD:\n+                    qualifier = parseTransactionalKeyword();\n+                    break;\n+                case RESOURCE_KEYWORD:\n+                    qualifier = parseResourceKeyword();\n+                    break;\n+                default:\n+                    Solution solution = recover(peek(), context, context, qualifierList);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzY5NDE1MQ=="}, "originalCommit": {"oid": "bcff57f0f4ca24023848b210da3fbe9dbd129869"}, "originalPosition": 272}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzcwOTAyNQ==", "bodyText": "I see. btw In case there's a missing function key we only skip the while loop. And do the qualifier validation again.\nThis will be a problem, specially when there's an error in the qualifier.\ne.g  For transactional  transactional <missing function>, updateLastNodeInListWithInvalidNode will call twice for same error ryt?\nI think we can simply return if the solution.kind is function keyword. WDYT?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25078#discussion_r467709025", "createdAt": "2020-08-10T06:31:22Z", "author": {"login": "lochana-chathura"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -5636,6 +5662,97 @@ private STNode parseObjectMethodOrField(SyntaxKind nextTokenKind, SyntaxKind nex\n         return parseObjectMethodOrField(solution.tokenKind, nextTokenKind, metadata, visibilityQualifier);\n     }\n \n+    /**\n+     * Parse function qualifiers.\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseFunctionQualifiers(ParserRuleContext context, List<STNode> qualifierList) {\n+        STToken nextToken = peek();\n+        return parseFunctionQualifiers(nextToken.kind, context, qualifierList);\n+    }\n+\n+    private STNode parseFunctionQualifiers(SyntaxKind tokenKind, ParserRuleContext context,\n+                                               List<STNode> qualifierList) {\n+        while (!isEndOfFunctionQualifiers(tokenKind)) {\n+            STNode qualifier;\n+            switch (tokenKind) {\n+                case REMOTE_KEYWORD:\n+                    qualifier = parseRemoteKeyword();\n+                    break;\n+                case TRANSACTIONAL_KEYWORD:\n+                    qualifier = parseTransactionalKeyword();\n+                    break;\n+                case RESOURCE_KEYWORD:\n+                    qualifier = parseResourceKeyword();\n+                    break;\n+                default:\n+                    Solution solution = recover(peek(), context, context, qualifierList);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzY5NDE1MQ=="}, "originalCommit": {"oid": "bcff57f0f4ca24023848b210da3fbe9dbd129869"}, "originalPosition": 272}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzcxNjIyMA==", "bodyText": "Validation is inside the while loop, so we do simply return if the function keyword recovered.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25078#discussion_r467716220", "createdAt": "2020-08-10T06:54:03Z", "author": {"login": "rdulmina"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -5636,6 +5662,97 @@ private STNode parseObjectMethodOrField(SyntaxKind nextTokenKind, SyntaxKind nex\n         return parseObjectMethodOrField(solution.tokenKind, nextTokenKind, metadata, visibilityQualifier);\n     }\n \n+    /**\n+     * Parse function qualifiers.\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseFunctionQualifiers(ParserRuleContext context, List<STNode> qualifierList) {\n+        STToken nextToken = peek();\n+        return parseFunctionQualifiers(nextToken.kind, context, qualifierList);\n+    }\n+\n+    private STNode parseFunctionQualifiers(SyntaxKind tokenKind, ParserRuleContext context,\n+                                               List<STNode> qualifierList) {\n+        while (!isEndOfFunctionQualifiers(tokenKind)) {\n+            STNode qualifier;\n+            switch (tokenKind) {\n+                case REMOTE_KEYWORD:\n+                    qualifier = parseRemoteKeyword();\n+                    break;\n+                case TRANSACTIONAL_KEYWORD:\n+                    qualifier = parseTransactionalKeyword();\n+                    break;\n+                case RESOURCE_KEYWORD:\n+                    qualifier = parseResourceKeyword();\n+                    break;\n+                default:\n+                    Solution solution = recover(peek(), context, context, qualifierList);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzY5NDE1MQ=="}, "originalCommit": {"oid": "bcff57f0f4ca24023848b210da3fbe9dbd129869"}, "originalPosition": 272}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyMTk2NjMxOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQwNTozNTozMVrOG-B2eA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQwNTo1NDoxNVrOG-CGMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzY5NTIyNA==", "bodyText": "what if the function keyword missing? we'll end up in an infinite loop right as function keyword is not handled inside parseFunctionQualifiers?\nI think we may check for REMOTE, TRANSACTIONAL, RESOURCE keywords and else return true. WDYT?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25078#discussion_r467695224", "createdAt": "2020-08-10T05:35:31Z", "author": {"login": "lochana-chathura"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -5636,6 +5662,97 @@ private STNode parseObjectMethodOrField(SyntaxKind nextTokenKind, SyntaxKind nex\n         return parseObjectMethodOrField(solution.tokenKind, nextTokenKind, metadata, visibilityQualifier);\n     }\n \n+    /**\n+     * Parse function qualifiers.\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseFunctionQualifiers(ParserRuleContext context, List<STNode> qualifierList) {\n+        STToken nextToken = peek();\n+        return parseFunctionQualifiers(nextToken.kind, context, qualifierList);\n+    }\n+\n+    private STNode parseFunctionQualifiers(SyntaxKind tokenKind, ParserRuleContext context,\n+                                               List<STNode> qualifierList) {\n+        while (!isEndOfFunctionQualifiers(tokenKind)) {\n+            STNode qualifier;\n+            switch (tokenKind) {\n+                case REMOTE_KEYWORD:\n+                    qualifier = parseRemoteKeyword();\n+                    break;\n+                case TRANSACTIONAL_KEYWORD:\n+                    qualifier = parseTransactionalKeyword();\n+                    break;\n+                case RESOURCE_KEYWORD:\n+                    qualifier = parseResourceKeyword();\n+                    break;\n+                default:\n+                    Solution solution = recover(peek(), context, context, qualifierList);\n+\n+                    // If the parser recovered by inserting a token, then try to re-parse the same\n+                    // rule with the inserted token. This is done to pick the correct branch\n+                    // to continue the parsing.\n+                    if (solution.action == Action.REMOVE) {\n+                        return solution.recoveredNode;\n+                    }\n+\n+                    return parseFunctionQualifiers(solution.tokenKind, context, qualifierList);\n+            }\n+\n+            DiagnosticCode diagnosticCode = validateFunctionQualifier(qualifier, context, qualifierList);\n+            if (diagnosticCode != null) {\n+                // If the qualifier list is empty add invalid node as minutiae to the next token.\n+                if (qualifierList.size() == 0) {\n+                    addInvalidNodeToNextToken(qualifier, diagnosticCode, qualifier.toString().trim());\n+                } else {\n+                    //If the qualifier list is not empty add invalid node to the last node in the list.\n+                    updateLastNodeInListWithInvalidNode(qualifierList, qualifier, diagnosticCode);\n+                }\n+            } else {\n+                qualifierList.add(qualifier);\n+            }\n+            tokenKind = peek().kind;\n+        }\n+        return STNodeFactory.createNodeList(qualifierList);\n+    }\n+\n+    private boolean isEndOfFunctionQualifiers(SyntaxKind tokenKind) {\n+        switch (tokenKind) {\n+            case FUNCTION_KEYWORD:\n+            case EOF_TOKEN:\n+                return true;\n+            default:\n+                return false;\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bcff57f0f4ca24023848b210da3fbe9dbd129869"}, "originalPosition": 308}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzY5OTI0OQ==", "bodyText": "Missing function keyword will recover inside the recovery of parseFunctionQualifiers() method.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25078#discussion_r467699249", "createdAt": "2020-08-10T05:54:15Z", "author": {"login": "rdulmina"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -5636,6 +5662,97 @@ private STNode parseObjectMethodOrField(SyntaxKind nextTokenKind, SyntaxKind nex\n         return parseObjectMethodOrField(solution.tokenKind, nextTokenKind, metadata, visibilityQualifier);\n     }\n \n+    /**\n+     * Parse function qualifiers.\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseFunctionQualifiers(ParserRuleContext context, List<STNode> qualifierList) {\n+        STToken nextToken = peek();\n+        return parseFunctionQualifiers(nextToken.kind, context, qualifierList);\n+    }\n+\n+    private STNode parseFunctionQualifiers(SyntaxKind tokenKind, ParserRuleContext context,\n+                                               List<STNode> qualifierList) {\n+        while (!isEndOfFunctionQualifiers(tokenKind)) {\n+            STNode qualifier;\n+            switch (tokenKind) {\n+                case REMOTE_KEYWORD:\n+                    qualifier = parseRemoteKeyword();\n+                    break;\n+                case TRANSACTIONAL_KEYWORD:\n+                    qualifier = parseTransactionalKeyword();\n+                    break;\n+                case RESOURCE_KEYWORD:\n+                    qualifier = parseResourceKeyword();\n+                    break;\n+                default:\n+                    Solution solution = recover(peek(), context, context, qualifierList);\n+\n+                    // If the parser recovered by inserting a token, then try to re-parse the same\n+                    // rule with the inserted token. This is done to pick the correct branch\n+                    // to continue the parsing.\n+                    if (solution.action == Action.REMOVE) {\n+                        return solution.recoveredNode;\n+                    }\n+\n+                    return parseFunctionQualifiers(solution.tokenKind, context, qualifierList);\n+            }\n+\n+            DiagnosticCode diagnosticCode = validateFunctionQualifier(qualifier, context, qualifierList);\n+            if (diagnosticCode != null) {\n+                // If the qualifier list is empty add invalid node as minutiae to the next token.\n+                if (qualifierList.size() == 0) {\n+                    addInvalidNodeToNextToken(qualifier, diagnosticCode, qualifier.toString().trim());\n+                } else {\n+                    //If the qualifier list is not empty add invalid node to the last node in the list.\n+                    updateLastNodeInListWithInvalidNode(qualifierList, qualifier, diagnosticCode);\n+                }\n+            } else {\n+                qualifierList.add(qualifier);\n+            }\n+            tokenKind = peek().kind;\n+        }\n+        return STNodeFactory.createNodeList(qualifierList);\n+    }\n+\n+    private boolean isEndOfFunctionQualifiers(SyntaxKind tokenKind) {\n+        switch (tokenKind) {\n+            case FUNCTION_KEYWORD:\n+            case EOF_TOKEN:\n+                return true;\n+            default:\n+                return false;\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzY5NTIyNA=="}, "originalCommit": {"oid": "bcff57f0f4ca24023848b210da3fbe9dbd129869"}, "originalPosition": 308}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyMTk2ODU3OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/test/resources/declarations/object-type-def/object_type_def_source_41.bal", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQwNTozNzoxMFrOG-B3rg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQwNTozNzoxMFrOG-B3rg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzY5NTUzNA==", "bodyText": "add a new line :)", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25078#discussion_r467695534", "createdAt": "2020-08-10T05:37:10Z", "author": {"login": "lochana-chathura"}, "path": "compiler/ballerina-parser/src/test/resources/declarations/object-type-def/object_type_def_source_41.bal", "diffHunk": "@@ -0,0 +1,14 @@\n+type foo object {\n+     remote transactional function foo(){\n+\n+     }\n+     remote function foo0(){\n+\n+     }\n+     transactional function foo1() {\n+\n+     }\n+     function foo2() {\n+\n+     }\n+};", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bcff57f0f4ca24023848b210da3fbe9dbd129869"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyMTk3ODkzOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQwNTo0NDoxMFrOG-B9Rw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQwNjo1NDo1N1rOG-DJvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzY5Njk2Nw==", "bodyText": "Shall we also modify return parseObjectMember(solution.tokenKind); beneath. Otherwise we'll be re-parsing with the wrong method I think.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25078#discussion_r467696967", "createdAt": "2020-08-10T05:44:10Z", "author": {"login": "lochana-chathura"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -5550,19 +5573,19 @@ private STNode parseObjectMember(SyntaxKind nextTokenKind, STNode metadata) {\n                 member = parseObjectMethodOrField(metadata, visibilityQualifier);\n                 break;\n             case REMOTE_KEYWORD:\n-                member = parseObjectMethodOrField(metadata, STNodeFactory.createEmptyNode());\n-                break;\n             case FUNCTION_KEYWORD:\n             case TRANSACTIONAL_KEYWORD:\n-                member = parseObjectMethod(metadata, STNodeFactory.createEmptyNode(), STNodeFactory.createEmptyNode());\n+            case RESOURCE_KEYWORD: // resource qualifier is not allowed but let it pass here and validate in\n+                // parseFunctionQualifiers method\n+                member = parseObjectMethod(metadata, new ArrayList<>());\n                 break;\n             default:\n                 if (isTypeStartingToken(nextTokenKind)) {\n                     member = parseObjectField(metadata, STNodeFactory.createEmptyNode());\n                     break;\n                 }\n \n-                Solution solution = recover(peek(), ParserRuleContext.OBJECT_MEMBER_WITHOUT_METADATA);\n+                Solution solution = recover(peek(), ParserRuleContext.OBJECT_MEMBER_WITHOUT_METADATA, metadata);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bcff57f0f4ca24023848b210da3fbe9dbd129869"}, "originalPosition": 217}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzcwMDg4NQ==", "bodyText": "U mean to rename the functions?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25078#discussion_r467700885", "createdAt": "2020-08-10T06:01:29Z", "author": {"login": "rdulmina"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -5550,19 +5573,19 @@ private STNode parseObjectMember(SyntaxKind nextTokenKind, STNode metadata) {\n                 member = parseObjectMethodOrField(metadata, visibilityQualifier);\n                 break;\n             case REMOTE_KEYWORD:\n-                member = parseObjectMethodOrField(metadata, STNodeFactory.createEmptyNode());\n-                break;\n             case FUNCTION_KEYWORD:\n             case TRANSACTIONAL_KEYWORD:\n-                member = parseObjectMethod(metadata, STNodeFactory.createEmptyNode(), STNodeFactory.createEmptyNode());\n+            case RESOURCE_KEYWORD: // resource qualifier is not allowed but let it pass here and validate in\n+                // parseFunctionQualifiers method\n+                member = parseObjectMethod(metadata, new ArrayList<>());\n                 break;\n             default:\n                 if (isTypeStartingToken(nextTokenKind)) {\n                     member = parseObjectField(metadata, STNodeFactory.createEmptyNode());\n                     break;\n                 }\n \n-                Solution solution = recover(peek(), ParserRuleContext.OBJECT_MEMBER_WITHOUT_METADATA);\n+                Solution solution = recover(peek(), ParserRuleContext.OBJECT_MEMBER_WITHOUT_METADATA, metadata);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzY5Njk2Nw=="}, "originalCommit": {"oid": "bcff57f0f4ca24023848b210da3fbe9dbd129869"}, "originalPosition": 217}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzcwMTk2OA==", "bodyText": "renamed the functions", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25078#discussion_r467701968", "createdAt": "2020-08-10T06:06:12Z", "author": {"login": "rdulmina"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -5550,19 +5573,19 @@ private STNode parseObjectMember(SyntaxKind nextTokenKind, STNode metadata) {\n                 member = parseObjectMethodOrField(metadata, visibilityQualifier);\n                 break;\n             case REMOTE_KEYWORD:\n-                member = parseObjectMethodOrField(metadata, STNodeFactory.createEmptyNode());\n-                break;\n             case FUNCTION_KEYWORD:\n             case TRANSACTIONAL_KEYWORD:\n-                member = parseObjectMethod(metadata, STNodeFactory.createEmptyNode(), STNodeFactory.createEmptyNode());\n+            case RESOURCE_KEYWORD: // resource qualifier is not allowed but let it pass here and validate in\n+                // parseFunctionQualifiers method\n+                member = parseObjectMethod(metadata, new ArrayList<>());\n                 break;\n             default:\n                 if (isTypeStartingToken(nextTokenKind)) {\n                     member = parseObjectField(metadata, STNodeFactory.createEmptyNode());\n                     break;\n                 }\n \n-                Solution solution = recover(peek(), ParserRuleContext.OBJECT_MEMBER_WITHOUT_METADATA);\n+                Solution solution = recover(peek(), ParserRuleContext.OBJECT_MEMBER_WITHOUT_METADATA, metadata);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzY5Njk2Nw=="}, "originalCommit": {"oid": "bcff57f0f4ca24023848b210da3fbe9dbd129869"}, "originalPosition": 217}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzcwOTc1OQ==", "bodyText": "not exactly the renaming of method. Earlier we had called the wrong overloaded method (with missing metadata arg) :)", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25078#discussion_r467709759", "createdAt": "2020-08-10T06:33:59Z", "author": {"login": "lochana-chathura"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -5550,19 +5573,19 @@ private STNode parseObjectMember(SyntaxKind nextTokenKind, STNode metadata) {\n                 member = parseObjectMethodOrField(metadata, visibilityQualifier);\n                 break;\n             case REMOTE_KEYWORD:\n-                member = parseObjectMethodOrField(metadata, STNodeFactory.createEmptyNode());\n-                break;\n             case FUNCTION_KEYWORD:\n             case TRANSACTIONAL_KEYWORD:\n-                member = parseObjectMethod(metadata, STNodeFactory.createEmptyNode(), STNodeFactory.createEmptyNode());\n+            case RESOURCE_KEYWORD: // resource qualifier is not allowed but let it pass here and validate in\n+                // parseFunctionQualifiers method\n+                member = parseObjectMethod(metadata, new ArrayList<>());\n                 break;\n             default:\n                 if (isTypeStartingToken(nextTokenKind)) {\n                     member = parseObjectField(metadata, STNodeFactory.createEmptyNode());\n                     break;\n                 }\n \n-                Solution solution = recover(peek(), ParserRuleContext.OBJECT_MEMBER_WITHOUT_METADATA);\n+                Solution solution = recover(peek(), ParserRuleContext.OBJECT_MEMBER_WITHOUT_METADATA, metadata);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzY5Njk2Nw=="}, "originalCommit": {"oid": "bcff57f0f4ca24023848b210da3fbe9dbd129869"}, "originalPosition": 217}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzcxNjU0MQ==", "bodyText": "Yes, thanx for mentioning I have changed that.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25078#discussion_r467716541", "createdAt": "2020-08-10T06:54:57Z", "author": {"login": "rdulmina"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -5550,19 +5573,19 @@ private STNode parseObjectMember(SyntaxKind nextTokenKind, STNode metadata) {\n                 member = parseObjectMethodOrField(metadata, visibilityQualifier);\n                 break;\n             case REMOTE_KEYWORD:\n-                member = parseObjectMethodOrField(metadata, STNodeFactory.createEmptyNode());\n-                break;\n             case FUNCTION_KEYWORD:\n             case TRANSACTIONAL_KEYWORD:\n-                member = parseObjectMethod(metadata, STNodeFactory.createEmptyNode(), STNodeFactory.createEmptyNode());\n+            case RESOURCE_KEYWORD: // resource qualifier is not allowed but let it pass here and validate in\n+                // parseFunctionQualifiers method\n+                member = parseObjectMethod(metadata, new ArrayList<>());\n                 break;\n             default:\n                 if (isTypeStartingToken(nextTokenKind)) {\n                     member = parseObjectField(metadata, STNodeFactory.createEmptyNode());\n                     break;\n                 }\n \n-                Solution solution = recover(peek(), ParserRuleContext.OBJECT_MEMBER_WITHOUT_METADATA);\n+                Solution solution = recover(peek(), ParserRuleContext.OBJECT_MEMBER_WITHOUT_METADATA, metadata);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzY5Njk2Nw=="}, "originalCommit": {"oid": "bcff57f0f4ca24023848b210da3fbe9dbd129869"}, "originalPosition": 217}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyMjg4NDg5OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxMTowODowOVrOG-KNVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxNDozODo1NFrOG-RbWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzgzMjE0OA==", "bodyText": "Can returning immediately be a problem?\neg:\ntransactional xyz resource function foo() {\n}\nHere xyz is an invalid token. After recovering from it, shouldn't the loop continue?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25078#discussion_r467832148", "createdAt": "2020-08-10T11:08:09Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -5636,6 +5662,97 @@ private STNode parseObjectMethodOrField(SyntaxKind nextTokenKind, SyntaxKind nex\n         return parseObjectMethodOrField(solution.tokenKind, nextTokenKind, metadata, visibilityQualifier);\n     }\n \n+    /**\n+     * Parse function qualifiers.\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseFunctionQualifiers(ParserRuleContext context, List<STNode> qualifierList) {\n+        STToken nextToken = peek();\n+        return parseFunctionQualifiers(nextToken.kind, context, qualifierList);\n+    }\n+\n+    private STNode parseFunctionQualifiers(SyntaxKind tokenKind, ParserRuleContext context,\n+                                               List<STNode> qualifierList) {\n+        while (!isEndOfFunctionQualifiers(tokenKind)) {\n+            STNode qualifier;\n+            switch (tokenKind) {\n+                case REMOTE_KEYWORD:\n+                    qualifier = parseRemoteKeyword();\n+                    break;\n+                case TRANSACTIONAL_KEYWORD:\n+                    qualifier = parseTransactionalKeyword();\n+                    break;\n+                case RESOURCE_KEYWORD:\n+                    qualifier = parseResourceKeyword();\n+                    break;\n+                default:\n+                    Solution solution = recover(peek(), context, context, qualifierList);\n+\n+                    // If the parser recovered by inserting a token, then try to re-parse the same\n+                    // rule with the inserted token. This is done to pick the correct branch\n+                    // to continue the parsing.\n+                    if (solution.action == Action.REMOVE) {\n+                        return solution.recoveredNode;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "99ff7c5dd1c976ded47baf6e68a67c978b5e5ac5"}, "originalPosition": 291}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzg1OTE5Mw==", "bodyText": "No, In the case of invalid token after recovery it goes to resume parsing. Then it parses the rest of the qualifiers and return here so we return immediately right?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25078#discussion_r467859193", "createdAt": "2020-08-10T12:08:41Z", "author": {"login": "rdulmina"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -5636,6 +5662,97 @@ private STNode parseObjectMethodOrField(SyntaxKind nextTokenKind, SyntaxKind nex\n         return parseObjectMethodOrField(solution.tokenKind, nextTokenKind, metadata, visibilityQualifier);\n     }\n \n+    /**\n+     * Parse function qualifiers.\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseFunctionQualifiers(ParserRuleContext context, List<STNode> qualifierList) {\n+        STToken nextToken = peek();\n+        return parseFunctionQualifiers(nextToken.kind, context, qualifierList);\n+    }\n+\n+    private STNode parseFunctionQualifiers(SyntaxKind tokenKind, ParserRuleContext context,\n+                                               List<STNode> qualifierList) {\n+        while (!isEndOfFunctionQualifiers(tokenKind)) {\n+            STNode qualifier;\n+            switch (tokenKind) {\n+                case REMOTE_KEYWORD:\n+                    qualifier = parseRemoteKeyword();\n+                    break;\n+                case TRANSACTIONAL_KEYWORD:\n+                    qualifier = parseTransactionalKeyword();\n+                    break;\n+                case RESOURCE_KEYWORD:\n+                    qualifier = parseResourceKeyword();\n+                    break;\n+                default:\n+                    Solution solution = recover(peek(), context, context, qualifierList);\n+\n+                    // If the parser recovered by inserting a token, then try to re-parse the same\n+                    // rule with the inserted token. This is done to pick the correct branch\n+                    // to continue the parsing.\n+                    if (solution.action == Action.REMOVE) {\n+                        return solution.recoveredNode;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzgzMjE0OA=="}, "originalCommit": {"oid": "99ff7c5dd1c976ded47baf6e68a67c978b5e5ac5"}, "originalPosition": 291}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzkwNDkzOQ==", "bodyText": "ah ok. Have any tests covering that?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25078#discussion_r467904939", "createdAt": "2020-08-10T13:31:38Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -5636,6 +5662,97 @@ private STNode parseObjectMethodOrField(SyntaxKind nextTokenKind, SyntaxKind nex\n         return parseObjectMethodOrField(solution.tokenKind, nextTokenKind, metadata, visibilityQualifier);\n     }\n \n+    /**\n+     * Parse function qualifiers.\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseFunctionQualifiers(ParserRuleContext context, List<STNode> qualifierList) {\n+        STToken nextToken = peek();\n+        return parseFunctionQualifiers(nextToken.kind, context, qualifierList);\n+    }\n+\n+    private STNode parseFunctionQualifiers(SyntaxKind tokenKind, ParserRuleContext context,\n+                                               List<STNode> qualifierList) {\n+        while (!isEndOfFunctionQualifiers(tokenKind)) {\n+            STNode qualifier;\n+            switch (tokenKind) {\n+                case REMOTE_KEYWORD:\n+                    qualifier = parseRemoteKeyword();\n+                    break;\n+                case TRANSACTIONAL_KEYWORD:\n+                    qualifier = parseTransactionalKeyword();\n+                    break;\n+                case RESOURCE_KEYWORD:\n+                    qualifier = parseResourceKeyword();\n+                    break;\n+                default:\n+                    Solution solution = recover(peek(), context, context, qualifierList);\n+\n+                    // If the parser recovered by inserting a token, then try to re-parse the same\n+                    // rule with the inserted token. This is done to pick the correct branch\n+                    // to continue the parsing.\n+                    if (solution.action == Action.REMOVE) {\n+                        return solution.recoveredNode;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzgzMjE0OA=="}, "originalCommit": {"oid": "99ff7c5dd1c976ded47baf6e68a67c978b5e5ac5"}, "originalPosition": 291}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzk1MDQyNA==", "bodyText": "Yes already added recovery test cases for fuction-def, object-method and service resource method. Those tests contains your example as well.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25078#discussion_r467950424", "createdAt": "2020-08-10T14:38:54Z", "author": {"login": "rdulmina"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -5636,6 +5662,97 @@ private STNode parseObjectMethodOrField(SyntaxKind nextTokenKind, SyntaxKind nex\n         return parseObjectMethodOrField(solution.tokenKind, nextTokenKind, metadata, visibilityQualifier);\n     }\n \n+    /**\n+     * Parse function qualifiers.\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseFunctionQualifiers(ParserRuleContext context, List<STNode> qualifierList) {\n+        STToken nextToken = peek();\n+        return parseFunctionQualifiers(nextToken.kind, context, qualifierList);\n+    }\n+\n+    private STNode parseFunctionQualifiers(SyntaxKind tokenKind, ParserRuleContext context,\n+                                               List<STNode> qualifierList) {\n+        while (!isEndOfFunctionQualifiers(tokenKind)) {\n+            STNode qualifier;\n+            switch (tokenKind) {\n+                case REMOTE_KEYWORD:\n+                    qualifier = parseRemoteKeyword();\n+                    break;\n+                case TRANSACTIONAL_KEYWORD:\n+                    qualifier = parseTransactionalKeyword();\n+                    break;\n+                case RESOURCE_KEYWORD:\n+                    qualifier = parseResourceKeyword();\n+                    break;\n+                default:\n+                    Solution solution = recover(peek(), context, context, qualifierList);\n+\n+                    // If the parser recovered by inserting a token, then try to re-parse the same\n+                    // rule with the inserted token. This is done to pick the correct branch\n+                    // to continue the parsing.\n+                    if (solution.action == Action.REMOVE) {\n+                        return solution.recoveredNode;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzgzMjE0OA=="}, "originalCommit": {"oid": "99ff7c5dd1c976ded47baf6e68a67c978b5e5ac5"}, "originalPosition": 291}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 323, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}