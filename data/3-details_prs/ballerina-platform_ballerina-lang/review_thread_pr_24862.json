{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU0Mjc4Mzcz", "number": 24862, "reviewThreads": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxMToyNTo1MVrOERycFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxNzo1NDozM1rOEZl4dQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3MDg3NjM2OnYy", "diffSide": "RIGHT", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeChecker.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxMToyNTo1MVrOG2r7SA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxODowODozNVrOHQozPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk5NTk3Ng==", "bodyText": "I think HashSet is a better choice if we are searching in the unresolvedTypes.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24862#discussion_r459995976", "createdAt": "2020-07-24T11:25:51Z", "author": {"login": "KRVPerera"}, "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeChecker.java", "diffHunk": "@@ -975,6 +1070,137 @@ private static boolean checkIsRecordType(BType sourceType, BRecordType targetTyp\n         return true;\n     }\n \n+    private static boolean checkRecordBelongsToAnydataType(MapValue sourceVal, BRecordType recordType,\n+                                                           List<TypePair> unresolvedTypes) {\n+        BType targetType = BTypes.typeAnydata;\n+        TypePair pair = new TypePair(recordType, targetType);\n+        if (unresolvedTypes.contains(pair)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89d22eb7f7e942abf06ad82febb4cb33835d0cdd"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY0ODE5Mw==", "bodyText": "This is passed on to checkIsType and in general we seem to be using lists in checkIsType and checkIsLikeType. Shall we do this change separately? Can you please create an issue with the suggestion?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24862#discussion_r460648193", "createdAt": "2020-07-27T05:03:49Z", "author": {"login": "MaryamZi"}, "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeChecker.java", "diffHunk": "@@ -975,6 +1070,137 @@ private static boolean checkIsRecordType(BType sourceType, BRecordType targetTyp\n         return true;\n     }\n \n+    private static boolean checkRecordBelongsToAnydataType(MapValue sourceVal, BRecordType recordType,\n+                                                           List<TypePair> unresolvedTypes) {\n+        BType targetType = BTypes.typeAnydata;\n+        TypePair pair = new TypePair(recordType, targetType);\n+        if (unresolvedTypes.contains(pair)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk5NTk3Ng=="}, "originalCommit": {"oid": "89d22eb7f7e942abf06ad82febb4cb33835d0cdd"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzIwNzc0MA==", "bodyText": "Issue: #25293", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24862#discussion_r487207740", "createdAt": "2020-09-11T18:08:35Z", "author": {"login": "KRVPerera"}, "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeChecker.java", "diffHunk": "@@ -975,6 +1070,137 @@ private static boolean checkIsRecordType(BType sourceType, BRecordType targetTyp\n         return true;\n     }\n \n+    private static boolean checkRecordBelongsToAnydataType(MapValue sourceVal, BRecordType recordType,\n+                                                           List<TypePair> unresolvedTypes) {\n+        BType targetType = BTypes.typeAnydata;\n+        TypePair pair = new TypePair(recordType, targetType);\n+        if (unresolvedTypes.contains(pair)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk5NTk3Ng=="}, "originalCommit": {"oid": "89d22eb7f7e942abf06ad82febb4cb33835d0cdd"}, "originalPosition": 133}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMTc5NTM1OnYy", "diffSide": "RIGHT", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeChecker.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQwNjo1MTo0MFrOG8li6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QwODo0NjowNVrOG9Rx4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjE4Mjg4OQ==", "bodyText": "What's the reason to call checkIslikeType() for readonly fields and checkIsType() for non-readonly fields?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24862#discussion_r466182889", "createdAt": "2020-08-06T06:51:40Z", "author": {"login": "pubudu91"}, "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeChecker.java", "diffHunk": "@@ -741,6 +796,46 @@ private static boolean checkIsMapType(BType sourceType, BMapType targetType, Lis\n         }\n     }\n \n+    private static boolean checkIsMapType(Object sourceVal, BType sourceType, BMapType targetType,\n+                                          List<TypePair> unresolvedTypes) {\n+        BType targetConstrainedType = targetType.getConstrainedType();\n+        switch (sourceType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+                return checkConstraints(((BMapType) sourceType).getConstrainedType(), targetConstrainedType,\n+                                        unresolvedTypes);\n+            case TypeTags.RECORD_TYPE_TAG:\n+                MapValue sourceMapValue = (MapValue) sourceVal;\n+                BRecordType recType = (BRecordType) sourceType;\n+\n+                for (BField field : recType.getFields().values()) {\n+                    if (!Flags.isFlagOn(field.flags, Flags.READONLY)) {\n+                        if (!checkIsType(field.type, targetConstrainedType, unresolvedTypes)) {\n+                            return false;\n+                        }\n+                        continue;\n+                    }\n+\n+                    BString name = StringUtils.fromString(field.name);\n+\n+                    if (Flags.isFlagOn(field.flags, Flags.OPTIONAL) && !sourceMapValue.containsKey(name)) {\n+                        continue;\n+                    }\n+\n+                    if (!checkIsLikeType(sourceMapValue.get(name), targetConstrainedType)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d6cb14f2973c5216909bf7c103ce6aea71befc12"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjkwNzYxNg==", "bodyText": "A readonly field cannot be updated, and whatever the value that was initially set is guaranteed to be immutable.\nFor an immutable value, is type is the same as is like type (as though the \"inherent type\" changed).\nSo if there is a readonly field, we know that it can never change (the reference or the value). So if the value specified for that field looks like the target type it would mean that it belongs to the target type.\nThis is similar to how we call check-is-like-type when check-is-type is used with immutable values.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24862#discussion_r466907616", "createdAt": "2020-08-07T08:46:05Z", "author": {"login": "MaryamZi"}, "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeChecker.java", "diffHunk": "@@ -741,6 +796,46 @@ private static boolean checkIsMapType(BType sourceType, BMapType targetType, Lis\n         }\n     }\n \n+    private static boolean checkIsMapType(Object sourceVal, BType sourceType, BMapType targetType,\n+                                          List<TypePair> unresolvedTypes) {\n+        BType targetConstrainedType = targetType.getConstrainedType();\n+        switch (sourceType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+                return checkConstraints(((BMapType) sourceType).getConstrainedType(), targetConstrainedType,\n+                                        unresolvedTypes);\n+            case TypeTags.RECORD_TYPE_TAG:\n+                MapValue sourceMapValue = (MapValue) sourceVal;\n+                BRecordType recType = (BRecordType) sourceType;\n+\n+                for (BField field : recType.getFields().values()) {\n+                    if (!Flags.isFlagOn(field.flags, Flags.READONLY)) {\n+                        if (!checkIsType(field.type, targetConstrainedType, unresolvedTypes)) {\n+                            return false;\n+                        }\n+                        continue;\n+                    }\n+\n+                    BString name = StringUtils.fromString(field.name);\n+\n+                    if (Flags.isFlagOn(field.flags, Flags.OPTIONAL) && !sourceMapValue.containsKey(name)) {\n+                        continue;\n+                    }\n+\n+                    if (!checkIsLikeType(sourceMapValue.get(name), targetConstrainedType)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjE4Mjg4OQ=="}, "originalCommit": {"oid": "d6cb14f2973c5216909bf7c103ce6aea71befc12"}, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMjgzMTkwOnYy", "diffSide": "RIGHT", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeChecker.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxMTozMDozNFrOG8vlOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwNjozODowMVrOG-qSYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjM0NzMyMw==", "bodyText": "We should consider the org name too right? Not sure whether the version should be considered though", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24862#discussion_r466347323", "createdAt": "2020-08-06T11:30:34Z", "author": {"login": "pubudu91"}, "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeChecker.java", "diffHunk": "@@ -1132,26 +1363,70 @@ private static boolean checkObjectEquivalency(BType sourceType, BObjectType targ\n             return false;\n         }\n \n+\n+        String targetTypeModule = Optional.ofNullable(targetType.getPackage()).map(BPackage::getName).orElse(\"\");\n+        String sourceTypeModule = Optional.ofNullable(sourceObjectType.getPackage()).map(BPackage::getName).orElse(\"\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d6cb14f2973c5216909bf7c103ce6aea71befc12"}, "originalPosition": 281}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzY3MDUwNQ==", "bodyText": "We should consider all 3 right? Two different versions of the same module can be considered as two different modules IMO, when considering visibility regions.\nWill fix, thanks.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24862#discussion_r467670505", "createdAt": "2020-08-10T03:10:48Z", "author": {"login": "MaryamZi"}, "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeChecker.java", "diffHunk": "@@ -1132,26 +1363,70 @@ private static boolean checkObjectEquivalency(BType sourceType, BObjectType targ\n             return false;\n         }\n \n+\n+        String targetTypeModule = Optional.ofNullable(targetType.getPackage()).map(BPackage::getName).orElse(\"\");\n+        String sourceTypeModule = Optional.ofNullable(sourceObjectType.getPackage()).map(BPackage::getName).orElse(\"\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjM0NzMyMw=="}, "originalCommit": {"oid": "d6cb14f2973c5216909bf7c103ce6aea71befc12"}, "originalPosition": 281}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODM1NzczMQ==", "bodyText": "Came across #25199 when trying to fix this. Both fixed in 8d23769.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24862#discussion_r468357731", "createdAt": "2020-08-11T06:38:01Z", "author": {"login": "MaryamZi"}, "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeChecker.java", "diffHunk": "@@ -1132,26 +1363,70 @@ private static boolean checkObjectEquivalency(BType sourceType, BObjectType targ\n             return false;\n         }\n \n+\n+        String targetTypeModule = Optional.ofNullable(targetType.getPackage()).map(BPackage::getName).orElse(\"\");\n+        String sourceTypeModule = Optional.ofNullable(sourceObjectType.getPackage()).map(BPackage::getName).orElse(\"\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjM0NzMyMw=="}, "originalCommit": {"oid": "d6cb14f2973c5216909bf7c103ce6aea71befc12"}, "originalPosition": 281}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNjkzMzAwOnYy", "diffSide": "RIGHT", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeChecker.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwOTo0MDozMFrOG-wPjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwOTo0MDozMFrOG-wPjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQ1NTMxMA==", "bodyText": "targetTypeTag ? as you have already acquired it", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24862#discussion_r468455310", "createdAt": "2020-08-11T09:40:30Z", "author": {"login": "Kishanthan"}, "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeChecker.java", "diffHunk": "@@ -641,6 +642,60 @@ public static boolean checkIsType(BType sourceType, BType targetType, List<TypeP\n         }\n     }\n \n+    private static boolean checkIsType(Object sourceVal, BType sourceType, BType targetType,\n+                                      List<TypePair> unresolvedTypes) {\n+        int sourceTypeTag = sourceType.getTag();\n+        int targetTypeTag = targetType.getTag();\n+\n+        if (sourceTypeTag != TypeTags.RECORD_TYPE_TAG && sourceTypeTag != TypeTags.OBJECT_TYPE_TAG) {\n+            return checkIsType(sourceType, targetType);\n+        }\n+\n+        if (targetType.getTag() == TypeTags.INTERSECTION_TAG) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d23769ed66098c9697e620d5714559780588b0d"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNjk0NDA2OnYy", "diffSide": "RIGHT", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeChecker.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwOTo0MzozOVrOG-wWeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwOTo0MzozOVrOG-wWeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQ1NzA4MA==", "bodyText": "this flag can move within the if body? as it is used only there.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24862#discussion_r468457080", "createdAt": "2020-08-11T09:43:39Z", "author": {"login": "Kishanthan"}, "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeChecker.java", "diffHunk": "@@ -975,6 +1070,137 @@ private static boolean checkIsRecordType(BType sourceType, BRecordType targetTyp\n         return true;\n     }\n \n+    private static boolean checkRecordBelongsToAnydataType(MapValue sourceVal, BRecordType recordType,\n+                                                           List<TypePair> unresolvedTypes) {\n+        BType targetType = BTypes.typeAnydata;\n+        TypePair pair = new TypePair(recordType, targetType);\n+        if (unresolvedTypes.contains(pair)) {\n+            return true;\n+        }\n+        unresolvedTypes.add(pair);\n+\n+        Map<String, BField> fields = recordType.getFields();\n+\n+        for (BField field : fields.values()) {\n+            String fieldName = field.getFieldName();\n+\n+            boolean optionalField = Flags.isFlagOn(field.flags, Flags.OPTIONAL);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d23769ed66098c9697e620d5714559780588b0d"}, "originalPosition": 143}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNjk0NTE4OnYy", "diffSide": "RIGHT", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeChecker.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwOTo0Mzo1OVrOG-wXLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwOTo0Mzo1OVrOG-wXLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQ1NzI2Mw==", "bodyText": "merge these two ifs", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24862#discussion_r468457263", "createdAt": "2020-08-11T09:43:59Z", "author": {"login": "Kishanthan"}, "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeChecker.java", "diffHunk": "@@ -975,6 +1070,137 @@ private static boolean checkIsRecordType(BType sourceType, BRecordType targetTyp\n         return true;\n     }\n \n+    private static boolean checkRecordBelongsToAnydataType(MapValue sourceVal, BRecordType recordType,\n+                                                           List<TypePair> unresolvedTypes) {\n+        BType targetType = BTypes.typeAnydata;\n+        TypePair pair = new TypePair(recordType, targetType);\n+        if (unresolvedTypes.contains(pair)) {\n+            return true;\n+        }\n+        unresolvedTypes.add(pair);\n+\n+        Map<String, BField> fields = recordType.getFields();\n+\n+        for (BField field : fields.values()) {\n+            String fieldName = field.getFieldName();\n+\n+            boolean optionalField = Flags.isFlagOn(field.flags, Flags.OPTIONAL);\n+\n+            if (Flags.isFlagOn(field.flags, Flags.READONLY)) {\n+                BString fieldNameBString = StringUtils.fromString(fieldName);\n+\n+                if (optionalField) {\n+                    if (!sourceVal.containsKey(fieldNameBString)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d23769ed66098c9697e620d5714559780588b0d"}, "originalPosition": 149}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNjk1MjY4OnYy", "diffSide": "RIGHT", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeChecker.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwOTo0NTo1NVrOG-wbrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwOTo0NTo1NVrOG-wbrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQ1ODQxMg==", "bodyText": "nested ifs. can it be merged?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24862#discussion_r468458412", "createdAt": "2020-08-11T09:45:55Z", "author": {"login": "Kishanthan"}, "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeChecker.java", "diffHunk": "@@ -975,6 +1070,137 @@ private static boolean checkIsRecordType(BType sourceType, BRecordType targetTyp\n         return true;\n     }\n \n+    private static boolean checkRecordBelongsToAnydataType(MapValue sourceVal, BRecordType recordType,\n+                                                           List<TypePair> unresolvedTypes) {\n+        BType targetType = BTypes.typeAnydata;\n+        TypePair pair = new TypePair(recordType, targetType);\n+        if (unresolvedTypes.contains(pair)) {\n+            return true;\n+        }\n+        unresolvedTypes.add(pair);\n+\n+        Map<String, BField> fields = recordType.getFields();\n+\n+        for (BField field : fields.values()) {\n+            String fieldName = field.getFieldName();\n+\n+            boolean optionalField = Flags.isFlagOn(field.flags, Flags.OPTIONAL);\n+\n+            if (Flags.isFlagOn(field.flags, Flags.READONLY)) {\n+                BString fieldNameBString = StringUtils.fromString(fieldName);\n+\n+                if (optionalField) {\n+                    if (!sourceVal.containsKey(fieldNameBString)) {\n+                        continue;\n+                    }\n+                }\n+\n+                if (!checkIsLikeType(sourceVal.get(fieldNameBString), targetType)) {\n+                    return false;\n+                }\n+            } else {\n+                if (!checkIsType(field.type, targetType, unresolvedTypes)) {\n+                    return false;\n+                }\n+            }\n+        }\n+\n+        if (recordType.sealed) {\n+            return true;\n+        }\n+\n+        return checkIsType(recordType.restFieldType, targetType, unresolvedTypes);\n+    }\n+\n+    private static boolean checkIsRecordType(Object sourceVal, BType sourceType, BRecordType targetType,\n+                                             List<TypePair> unresolvedTypes) {\n+        if (sourceType.getTag() != TypeTags.RECORD_TYPE_TAG) {\n+            return false;\n+        }\n+\n+        TypePair pair = new TypePair(sourceType, targetType);\n+        if (unresolvedTypes.contains(pair)) {\n+            return true;\n+        }\n+        unresolvedTypes.add(pair);\n+\n+        BRecordType sourceRecordType = (BRecordType) sourceType;\n+        if (targetType.sealed && !sourceRecordType.sealed) {\n+            return false;\n+        }\n+\n+        if (!sourceRecordType.sealed &&\n+                !checkIsType(sourceRecordType.restFieldType, targetType.restFieldType, unresolvedTypes)) {\n+            return false;\n+        }\n+\n+        MapValue sourceRecordValue = (MapValue) sourceVal;\n+\n+        Map<String, BField> sourceFields = sourceRecordType.getFields();\n+        Set<String> targetFieldNames = targetType.getFields().keySet();\n+\n+        for (BField targetField : targetType.getFields().values()) {\n+            String fieldName = targetField.getFieldName();\n+            BField sourceField = sourceFields.get(fieldName);\n+\n+            if (sourceField == null) {\n+                return false;\n+            }\n+\n+            if (hasIncompatibleReadOnlyFlags(targetField, sourceField)) {\n+                return false;\n+            }\n+\n+            boolean optionalTargetField = Flags.isFlagOn(targetField.flags, Flags.OPTIONAL);\n+            boolean optionalSourceField = Flags.isFlagOn(sourceField.flags, Flags.OPTIONAL);\n+\n+            if (Flags.isFlagOn(sourceField.flags, Flags.READONLY)) {\n+                BString fieldNameBString = StringUtils.fromString(fieldName);\n+\n+                if (optionalSourceField) {\n+                    if (!sourceRecordValue.containsKey(fieldNameBString)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d23769ed66098c9697e620d5714559780588b0d"}, "originalPosition": 217}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNjk3NTQzOnYy", "diffSide": "RIGHT", "path": "tests/jballerina-unit-test/src/test/resources/test-src/balo/test_projects/test_project_two/Ballerina.toml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwOTo1MjowOVrOG-wpxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwOTo1MjowOVrOG-wpxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQ2MjAyMg==", "bodyText": "EOF line?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24862#discussion_r468462022", "createdAt": "2020-08-11T09:52:09Z", "author": {"login": "Kishanthan"}, "path": "tests/jballerina-unit-test/src/test/resources/test-src/balo/test_projects/test_project_two/Ballerina.toml", "diffHunk": "@@ -0,0 +1,5 @@\n+[project]\n+org-name= \"testorgtwo\"\n+version= \"2.0.0\"\n+\n+[dependencies]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d23769ed66098c9697e620d5714559780588b0d"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MjcwMTA0OnYy", "diffSide": "RIGHT", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeChecker.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxNzo1MzoyNlrOHCfq7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQwMzowOToxOVrOHCu-NQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM3ODA5NQ==", "bodyText": "why we need another checkIsType method ? whats the purpose of this newly added method?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24862#discussion_r472378095", "createdAt": "2020-08-18T17:53:26Z", "author": {"login": "Kishanthan"}, "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeChecker.java", "diffHunk": "@@ -641,6 +642,60 @@ public static boolean checkIsType(BType sourceType, BType targetType, List<TypeP\n         }\n     }\n \n+    private static boolean checkIsType(Object sourceVal, BType sourceType, BType targetType,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3325b4cf811e9986121a0f5c112fb5f3d93e229d"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjU5MDIwNA==", "bodyText": "The current checkIsType method is based solely on the source and target types. We check checkIsLikeType only if the entire source value is immutable.\nBut now with readonly fields, even though the entire source value is not immutable, due to the presence of readonly fields, an is check that fails for types, may pass for values.\nFor example, from the sample in the description:\nimport ballerina/io;\n\nconst HUNDRED = 100;\n\ntype Foo record {\n    HUNDRED i;\n};\n\ntype Bar record {\n    readonly string|int i;\n};\n\npublic function main() {\n    Bar b1 = {i: 123};\n    io:println(<any> b1 is Foo); // prints `false`\n\n    Bar b2 = {i: 100};\n    io:println(<any> b2 is Foo); // prints `true` now, since the `i` field of `b2` is and will continue to be `100`\n}\nHere if we just use the current checkIsType with Bar and Foo, it will evaluate to false, since the source has string|int as the type for i, while the target has HUNDRED as the type.\nBut since the i field in the source is a readonly field, we know that the value for this field cannot change, so we look at the actual value to see if it belongs to the target type. So, in the case of b1, where i is 123, it is still not a match, but for b2 since i is 100, and it can never change, the is check evaluates to true.\nWill add a comment too.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24862#discussion_r472590204", "createdAt": "2020-08-19T01:56:53Z", "author": {"login": "MaryamZi"}, "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeChecker.java", "diffHunk": "@@ -641,6 +642,60 @@ public static boolean checkIsType(BType sourceType, BType targetType, List<TypeP\n         }\n     }\n \n+    private static boolean checkIsType(Object sourceVal, BType sourceType, BType targetType,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM3ODA5NQ=="}, "originalCommit": {"oid": "3325b4cf811e9986121a0f5c112fb5f3d93e229d"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjYyODc4OQ==", "bodyText": "Added a comment in 24985b7.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24862#discussion_r472628789", "createdAt": "2020-08-19T03:09:19Z", "author": {"login": "MaryamZi"}, "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeChecker.java", "diffHunk": "@@ -641,6 +642,60 @@ public static boolean checkIsType(BType sourceType, BType targetType, List<TypeP\n         }\n     }\n \n+    private static boolean checkIsType(Object sourceVal, BType sourceType, BType targetType,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM3ODA5NQ=="}, "originalCommit": {"oid": "3325b4cf811e9986121a0f5c112fb5f3d93e229d"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MjcwNTE3OnYy", "diffSide": "RIGHT", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeChecker.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxNzo1NDozM1rOHCftfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQwMzowODoyMVrOHCu76Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM3ODc0OQ==", "bodyText": "This case seems to have a big logic. shall we move it to a separate method for better readability?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24862#discussion_r472378749", "createdAt": "2020-08-18T17:54:33Z", "author": {"login": "Kishanthan"}, "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeChecker.java", "diffHunk": "@@ -741,6 +796,46 @@ private static boolean checkIsMapType(BType sourceType, BMapType targetType, Lis\n         }\n     }\n \n+    private static boolean checkIsMapType(Object sourceVal, BType sourceType, BMapType targetType,\n+                                          List<TypePair> unresolvedTypes) {\n+        BType targetConstrainedType = targetType.getConstrainedType();\n+        switch (sourceType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+                return checkConstraints(((BMapType) sourceType).getConstrainedType(), targetConstrainedType,\n+                                        unresolvedTypes);\n+            case TypeTags.RECORD_TYPE_TAG:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3325b4cf811e9986121a0f5c112fb5f3d93e229d"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjYyODIwMQ==", "bodyText": "Done in 24985b7.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24862#discussion_r472628201", "createdAt": "2020-08-19T03:08:21Z", "author": {"login": "MaryamZi"}, "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeChecker.java", "diffHunk": "@@ -741,6 +796,46 @@ private static boolean checkIsMapType(BType sourceType, BMapType targetType, Lis\n         }\n     }\n \n+    private static boolean checkIsMapType(Object sourceVal, BType sourceType, BMapType targetType,\n+                                          List<TypePair> unresolvedTypes) {\n+        BType targetConstrainedType = targetType.getConstrainedType();\n+        switch (sourceType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+                return checkConstraints(((BMapType) sourceType).getConstrainedType(), targetConstrainedType,\n+                                        unresolvedTypes);\n+            case TypeTags.RECORD_TYPE_TAG:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM3ODc0OQ=="}, "originalCommit": {"oid": "3325b4cf811e9986121a0f5c112fb5f3d93e229d"}, "originalPosition": 89}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 417, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}