{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE3Nzc1OTg1", "number": 26827, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQwNToxNTozNlrOE4ABzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQwNToxNTozNlrOE4ABzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3MTU2MTc1OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQwNToxNTozNlrOHxq21w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxMjowMzo1NVrOHx3wvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTg0NDQzOQ==", "bodyText": "We need to restrict positional argument after named arg right? ie what if (namedArg, possitionalArg) ? I think we can use hasPositionalArg boolean for this with a better name like allowPositionalArg", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26827#discussion_r521844439", "createdAt": "2020-11-12T05:15:36Z", "author": {"login": "rdulmina"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -4832,15 +4843,107 @@ private STNode parseFuncCall(STNode identifier) {\n      * Parse error constructor expression.\n      * </p>\n      * <code>\n-     * error-constructor-expr := error ( arg-list )\n+     * error-constructor-expr := error [error-type-reference] ( error-arg-list )\n+     * error-arg-list := positional-arg [, positional-arg] (, named-arg)*\n      * </code>\n      *\n      * @return Error constructor expression\n      */\n     private STNode parseErrorConstructorExpr() {\n+        startContext(ParserRuleContext.ERROR_CONSTRUCTOR);\n         STNode errorKeyword = parseErrorKeyword();\n-        errorKeyword = createBuiltinSimpleNameReference(errorKeyword);\n-        return parseFuncCall(errorKeyword);\n+        STNode typeReference = parseErrorTypeReference(errorKeyword, ParserRuleContext.ERROR_CONSTRUCTOR_RHS);\n+        STNode openParen = parseOpenParenthesis(ParserRuleContext.ARG_LIST_OPEN_PAREN);\n+        return parseErrorConstructorExpr(errorKeyword, typeReference, openParen);\n+    }\n+\n+    private STNode parseErrorTypeReference(STNode errorKeyword, ParserRuleContext context) {\n+        STToken nextToken = peek();\n+        switch (nextToken.kind) {\n+            case IDENTIFIER_TOKEN:\n+                return parseTypeReference();\n+            case OPEN_PAREN_TOKEN:\n+                return STNodeFactory.createEmptyNode();\n+            default:\n+                recover(nextToken, context, errorKeyword);\n+                return parseErrorTypeReference(errorKeyword, context);\n+        }\n+    }\n+\n+    private STNode parseErrorConstructorExpr(STNode errorKeyword, STNode typeReference, STNode openParen) {\n+        STNode functionArgs = parseArgsList();\n+        STNode errorArgs = getErrorArgList(functionArgs);\n+        STNode closeParen = parseCloseParenthesis(ParserRuleContext.ARG_LIST_CLOSE_PAREN);\n+        endContext();\n+\n+        openParen = cloneWithDiagnosticIfListEmpty(errorArgs, openParen,\n+                DiagnosticErrorCode.ERROR_MISSING_POSITIONAL_ARG_IN_ERROR_CONSTRUCTOR);\n+        return STNodeFactory.createErrorConstructorExpressionNode(errorKeyword, typeReference, openParen, errorArgs,\n+                closeParen);\n+    }\n+\n+    /**\n+     * Validate function args and return error arg node list.\n+     *\n+     * @param functionArgs function args to be validated\n+     * @return Error arg list\n+     */\n+    private STNode getErrorArgList(STNode functionArgs) {\n+        STNodeList argList = (STNodeList) functionArgs;\n+        if (argList.isEmpty()) {\n+            return argList;\n+        }\n+\n+        List<STNode> errorArgList = new ArrayList<>();\n+        // Validate first arg\n+        STNode arg = argList.get(0);\n+        switch (arg.kind) {\n+            case POSITIONAL_ARG:\n+                errorArgList.add(arg);\n+                break;\n+            case NAMED_ARG:\n+                arg = SyntaxErrors.addDiagnostic(arg,\n+                        DiagnosticErrorCode.ERROR_MISSING_POSITIONAL_ARG_IN_ERROR_CONSTRUCTOR);\n+                errorArgList.add(arg);\n+                break;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "162f5810effddf210fdfd98f7a9e15d33e2958da"}, "originalPosition": 235}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA1NTE0Mg==", "bodyText": "What we do here is validating function args. That order validation is already done when parsing function args.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26827#discussion_r522055142", "createdAt": "2020-11-12T12:02:31Z", "author": {"login": "lochana-chathura"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -4832,15 +4843,107 @@ private STNode parseFuncCall(STNode identifier) {\n      * Parse error constructor expression.\n      * </p>\n      * <code>\n-     * error-constructor-expr := error ( arg-list )\n+     * error-constructor-expr := error [error-type-reference] ( error-arg-list )\n+     * error-arg-list := positional-arg [, positional-arg] (, named-arg)*\n      * </code>\n      *\n      * @return Error constructor expression\n      */\n     private STNode parseErrorConstructorExpr() {\n+        startContext(ParserRuleContext.ERROR_CONSTRUCTOR);\n         STNode errorKeyword = parseErrorKeyword();\n-        errorKeyword = createBuiltinSimpleNameReference(errorKeyword);\n-        return parseFuncCall(errorKeyword);\n+        STNode typeReference = parseErrorTypeReference(errorKeyword, ParserRuleContext.ERROR_CONSTRUCTOR_RHS);\n+        STNode openParen = parseOpenParenthesis(ParserRuleContext.ARG_LIST_OPEN_PAREN);\n+        return parseErrorConstructorExpr(errorKeyword, typeReference, openParen);\n+    }\n+\n+    private STNode parseErrorTypeReference(STNode errorKeyword, ParserRuleContext context) {\n+        STToken nextToken = peek();\n+        switch (nextToken.kind) {\n+            case IDENTIFIER_TOKEN:\n+                return parseTypeReference();\n+            case OPEN_PAREN_TOKEN:\n+                return STNodeFactory.createEmptyNode();\n+            default:\n+                recover(nextToken, context, errorKeyword);\n+                return parseErrorTypeReference(errorKeyword, context);\n+        }\n+    }\n+\n+    private STNode parseErrorConstructorExpr(STNode errorKeyword, STNode typeReference, STNode openParen) {\n+        STNode functionArgs = parseArgsList();\n+        STNode errorArgs = getErrorArgList(functionArgs);\n+        STNode closeParen = parseCloseParenthesis(ParserRuleContext.ARG_LIST_CLOSE_PAREN);\n+        endContext();\n+\n+        openParen = cloneWithDiagnosticIfListEmpty(errorArgs, openParen,\n+                DiagnosticErrorCode.ERROR_MISSING_POSITIONAL_ARG_IN_ERROR_CONSTRUCTOR);\n+        return STNodeFactory.createErrorConstructorExpressionNode(errorKeyword, typeReference, openParen, errorArgs,\n+                closeParen);\n+    }\n+\n+    /**\n+     * Validate function args and return error arg node list.\n+     *\n+     * @param functionArgs function args to be validated\n+     * @return Error arg list\n+     */\n+    private STNode getErrorArgList(STNode functionArgs) {\n+        STNodeList argList = (STNodeList) functionArgs;\n+        if (argList.isEmpty()) {\n+            return argList;\n+        }\n+\n+        List<STNode> errorArgList = new ArrayList<>();\n+        // Validate first arg\n+        STNode arg = argList.get(0);\n+        switch (arg.kind) {\n+            case POSITIONAL_ARG:\n+                errorArgList.add(arg);\n+                break;\n+            case NAMED_ARG:\n+                arg = SyntaxErrors.addDiagnostic(arg,\n+                        DiagnosticErrorCode.ERROR_MISSING_POSITIONAL_ARG_IN_ERROR_CONSTRUCTOR);\n+                errorArgList.add(arg);\n+                break;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTg0NDQzOQ=="}, "originalCommit": {"oid": "162f5810effddf210fdfd98f7a9e15d33e2958da"}, "originalPosition": 235}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA1NTg3MQ==", "bodyText": "ah cool.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26827#discussion_r522055871", "createdAt": "2020-11-12T12:03:55Z", "author": {"login": "rdulmina"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -4832,15 +4843,107 @@ private STNode parseFuncCall(STNode identifier) {\n      * Parse error constructor expression.\n      * </p>\n      * <code>\n-     * error-constructor-expr := error ( arg-list )\n+     * error-constructor-expr := error [error-type-reference] ( error-arg-list )\n+     * error-arg-list := positional-arg [, positional-arg] (, named-arg)*\n      * </code>\n      *\n      * @return Error constructor expression\n      */\n     private STNode parseErrorConstructorExpr() {\n+        startContext(ParserRuleContext.ERROR_CONSTRUCTOR);\n         STNode errorKeyword = parseErrorKeyword();\n-        errorKeyword = createBuiltinSimpleNameReference(errorKeyword);\n-        return parseFuncCall(errorKeyword);\n+        STNode typeReference = parseErrorTypeReference(errorKeyword, ParserRuleContext.ERROR_CONSTRUCTOR_RHS);\n+        STNode openParen = parseOpenParenthesis(ParserRuleContext.ARG_LIST_OPEN_PAREN);\n+        return parseErrorConstructorExpr(errorKeyword, typeReference, openParen);\n+    }\n+\n+    private STNode parseErrorTypeReference(STNode errorKeyword, ParserRuleContext context) {\n+        STToken nextToken = peek();\n+        switch (nextToken.kind) {\n+            case IDENTIFIER_TOKEN:\n+                return parseTypeReference();\n+            case OPEN_PAREN_TOKEN:\n+                return STNodeFactory.createEmptyNode();\n+            default:\n+                recover(nextToken, context, errorKeyword);\n+                return parseErrorTypeReference(errorKeyword, context);\n+        }\n+    }\n+\n+    private STNode parseErrorConstructorExpr(STNode errorKeyword, STNode typeReference, STNode openParen) {\n+        STNode functionArgs = parseArgsList();\n+        STNode errorArgs = getErrorArgList(functionArgs);\n+        STNode closeParen = parseCloseParenthesis(ParserRuleContext.ARG_LIST_CLOSE_PAREN);\n+        endContext();\n+\n+        openParen = cloneWithDiagnosticIfListEmpty(errorArgs, openParen,\n+                DiagnosticErrorCode.ERROR_MISSING_POSITIONAL_ARG_IN_ERROR_CONSTRUCTOR);\n+        return STNodeFactory.createErrorConstructorExpressionNode(errorKeyword, typeReference, openParen, errorArgs,\n+                closeParen);\n+    }\n+\n+    /**\n+     * Validate function args and return error arg node list.\n+     *\n+     * @param functionArgs function args to be validated\n+     * @return Error arg list\n+     */\n+    private STNode getErrorArgList(STNode functionArgs) {\n+        STNodeList argList = (STNodeList) functionArgs;\n+        if (argList.isEmpty()) {\n+            return argList;\n+        }\n+\n+        List<STNode> errorArgList = new ArrayList<>();\n+        // Validate first arg\n+        STNode arg = argList.get(0);\n+        switch (arg.kind) {\n+            case POSITIONAL_ARG:\n+                errorArgList.add(arg);\n+                break;\n+            case NAMED_ARG:\n+                arg = SyntaxErrors.addDiagnostic(arg,\n+                        DiagnosticErrorCode.ERROR_MISSING_POSITIONAL_ARG_IN_ERROR_CONSTRUCTOR);\n+                errorArgList.add(arg);\n+                break;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTg0NDQzOQ=="}, "originalCommit": {"oid": "162f5810effddf210fdfd98f7a9e15d33e2958da"}, "originalPosition": 235}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3134, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}