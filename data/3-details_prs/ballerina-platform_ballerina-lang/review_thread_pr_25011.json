{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU4MzA4ODY0", "number": 25011, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxMDowOTozOVrOETL-aQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxMDowOTozOVrOETL-aQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4NTU0NjAxOnYy", "diffSide": "RIGHT", "path": "langlib/lang.query/src/main/ballerina/src/lang.query/types.bal", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxMDowOTozOVrOG4xyMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxMDowOTozOVrOG4xyMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE4OTEwNw==", "bodyText": "The code is not properly formatted. Check all the places.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25011#discussion_r462189107", "createdAt": "2020-07-29T10:09:39Z", "author": {"login": "anupama-pathirage"}, "path": "langlib/lang.query/src/main/ballerina/src/lang.query/types.bal", "diffHunk": "@@ -572,3 +575,167 @@ public type _LimitFunction object {\n         }\n     }\n };\n+\n+type StreamOrderBy object {\n+    public string[] sortFields;\n+    public boolean[] sortTypes;\n+\n+    function init(string[] sortFields, boolean[] sortTypes) {\n+        self.sortFields = sortFields;\n+        self.sortTypes = sortTypes;\n+    }\n+\n+    public function topDownMergeSort(@tainted Type[] events) returns @tainted Type[]{\n+        int index = 0;\n+        int n = events.length();\n+        Type[] b = [];\n+        while (index < n) {\n+            b[index] = events[index];\n+            index += 1;\n+        }\n+        self.topDownSplitMerge(b, 0, n, events);\n+        return events;\n+    }\n+\n+    function topDownSplitMerge(@tainted Type[] b, int iBegin, int iEnd, @tainted Type[] a) {\n+        if (iEnd - iBegin < 2) {\n+            return;\n+        }\n+        int iMiddle = (iEnd + iBegin) / 2;\n+        self.topDownSplitMerge(a, iBegin, iMiddle, b);\n+        self.topDownSplitMerge(a, iMiddle, iEnd, b);\n+        self.topDownMerge(b, iBegin, iMiddle, iEnd, a);\n+    }\n+\n+    function topDownMerge(@tainted Type[] a, int iBegin, int iMiddle, int iEnd, @tainted Type[] b) {\n+        int i = iBegin;\n+        int j = iMiddle;\n+\n+        int k = iBegin;\n+        while (k < iEnd) {\n+            if (i < iMiddle && (j >= iEnd || self.sortFunc(a[i], a[j], 0) < 0)) {\n+                b[k] = a[i];\n+                i = i + 1;\n+            } else {\n+                b[k] = a[j];\n+                j = j + 1;\n+            }\n+            k += 1;\n+        }\n+    }\n+\n+    function sortFunc(Type x, Type y, int fieldIndex) returns @tainted int {\n+        map<anydata> xMapValue = <map<anydata>>x;\n+        map<anydata> yMapValue = <map<anydata>>y;\n+\n+        var xFieldValue = xMapValue.get(self.sortFields[fieldIndex]);\n+        var yFieldValue = yMapValue.get(self.sortFields[fieldIndex]);\n+\n+        if (xFieldValue is ()) {\n+            if (yFieldValue is ()) {\n+                return 0;\n+            } else {\n+                return 1;\n+            }\n+        } else if (yFieldValue is ()) {\n+            return -1;\n+        } else if (xFieldValue is (int|float|decimal)) {\n+            if (yFieldValue is (int|float|decimal)) {\n+                int c;\n+                if (self.sortTypes[fieldIndex]) {\n+                    c = self.numberSort(xFieldValue, yFieldValue);\n+                } else {\n+                    c = self.numberSort(yFieldValue, xFieldValue);\n+                }\n+                return self.callNextSortFunc(x, y, c, fieldIndex + 1);\n+            } else {\n+                panic error(\"Inconsistent order field value\",\n+                message = self.sortFields[fieldIndex] + \" order field contain non-numeric values\");\n+            }\n+        } else if (xFieldValue is string) {\n+            if (yFieldValue is string) {\n+                int c;\n+                if (self.sortTypes[fieldIndex]) {\n+                    c = self.stringSort(xFieldValue, yFieldValue);\n+                } else {\n+                    c = self.stringSort(yFieldValue, xFieldValue);\n+                }\n+                return self.callNextSortFunc(x, y, c, fieldIndex + 1);\n+            } else {\n+                panic error(\"Inconsistent order field value\",\n+                message = self.sortFields[fieldIndex] + \" order field contain non-string type values\");\n+            }\n+        } else if (xFieldValue is boolean) {\n+            if (yFieldValue is boolean) {\n+                int c;\n+                if (self.sortTypes[fieldIndex]) {\n+                    c = self.booleanSort(xFieldValue, yFieldValue);\n+                } else {\n+                    c = self.booleanSort(yFieldValue, xFieldValue);\n+                }\n+                return self.callNextSortFunc(x, y, c, fieldIndex + 1);\n+            } else {\n+                  panic error(\"Inconsistent order field value\",\n+                  message = self.sortFields[fieldIndex] + \" order field contain non-boolean type values\");\n+            }\n+        } else {\n+            panic error(\"Unable to perform order by\",\n+            message = self.sortFields[fieldIndex] + \" field type incorrect\");\n+        }\n+    }\n+\n+    public function numberSort(int|float|decimal val1, int|float|decimal val2) returns int {\n+        if (val1 is int) {\n+            if (val2 is int) {\n+                return val1 - val2;\n+            } else if (val2 is float) {\n+                return <float>val1 < val2 ? -1 : <float>val1 == val2 ? 0 : 1;\n+            } else {\n+                return <decimal>val1 < val2 ? -1 : <decimal>val1 == val2 ? 0 : 1;\n+            }\n+        } else if (val1 is float) {\n+            if (val2 is int) {\n+                return val1 < <float>val2 ? -1 : val1 == <float>val2 ? 0 : 1;\n+            } else if (val2 is float){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dcb5205a9ebc9610a3cd91593c22dfd6d9f8c49b"}, "originalPosition": 359}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 302, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}