{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE0NjI0MTMx", "number": 23146, "title": "Implement the new-expr for the incremental parser.", "bodyText": "Purpose\n\n$title\n\nFixes #22998\nCheck List\n\n[x ] Read the Contributing Guide\n Updated Change Log\n Checked Tooling Support (#)\n Added necessary tests\n\n Unit Tests\n Spec Conformance Tests\n Integration Tests\n Ballerina By Example Tests\n\n\n Increased Test Coverage\n Added necessary documentation\n\n API documentation\n Module documentation in Module.md files\n Ballerina By Examples", "createdAt": "2020-05-07T11:25:32Z", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146", "merged": true, "mergeCommit": {"oid": "3492d786ce65afb8aca915ffeb2508b1256d97c3"}, "closed": true, "closedAt": "2020-05-13T04:00:59Z", "author": {"login": "dulvinw"}, "timelineItems": {"totalCount": 20, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABce7gfjAH2gAyNDE0NjI0MTMxOjQ5NTk5YTUyYjQzMzliZTEzYmNlZDkxMGU1N2M5YjhmNTQ3MDA0Mjk=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcgwwx9gFqTQxMDU3MTcxMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "49599a52b4339be13bced910e57c9b8f54700429", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/49599a52b4339be13bced910e57c9b8f54700429", "committedDate": "2020-05-07T11:23:42Z", "message": "new-expr implementation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8ae4c6e850b7ecb589b3f16e8966ac7109266ee3", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/8ae4c6e850b7ecb589b3f16e8966ac7109266ee3", "committedDate": "2020-05-07T11:28:18Z", "message": "Refactor BallerinaParser.java"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA3NDU0ODE4", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146#pullrequestreview-407454818", "createdAt": "2020-05-07T13:10:29Z", "commit": {"oid": "8ae4c6e850b7ecb589b3f16e8966ac7109266ee3"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QxMzoxMDozMFrOGR9wSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QxMzozNjo1MFrOGR-4HQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQ5MDc2Mg==", "bodyText": "if none of the above, should it be treated as simply new?\ni.e.: foo(new);,  where function foo(T x) {...}", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146#discussion_r421490762", "createdAt": "2020-05-07T13:10:30Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -3172,6 +3180,127 @@ private STNode parseActionOrExpressionInLhs(SyntaxKind nextTokenKind, STNode lhs\n         return parseExpressionRhs(nextTokenKind, DEFAULT_OP_PRECEDENCE, lhsExpr, false, true);\n     }\n \n+    /**\n+     * <p>\n+     * Parse a new expression.\n+     * </p>\n+     * <code>\n+     *  new-expr := explicit-new-expr | implicit-new-expr\n+     *  explicit-new-expr := new type-descriptor ( arg-list )\n+     *  implicit-new-expr := new [( arg-list )]\n+     * </code>\n+     *\n+     * @return Parsed NewExpression node.\n+     */\n+    private STNode parseNewExpression() {\n+        startContext(ParserRuleContext.NEW_EXPRESSION);\n+        STNode newKeyword = parseNewKeyword();\n+        STNode newExpression = parseNewExpression(newKeyword);\n+        endContext();\n+        return newExpression;\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse `new` keyword.\n+     * </p>\n+     *\n+     * @return Parsed NEW_KEYWORD Token.\n+     */\n+    private STNode parseNewKeyword() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.NEW_KEYWORD) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(token, ParserRuleContext.NEW_KEYWORD);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    private STNode parseNewExpression(STNode newKeyword) {\n+        STNode token = peek();\n+        return parseNewExpression(token.kind, newKeyword);\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse an implicit or explicit expression.\n+     * </p>\n+     * @param kind next token kind.\n+     * @param newKeyword parsed node for `new` keyword.\n+     * @return Parsed new-expression node.\n+     */\n+    private STNode parseNewExpression(SyntaxKind kind, STNode newKeyword) {\n+        switch (kind) {\n+            case OPEN_PAREN_TOKEN:\n+                return parseImplicitNewExpression(newKeyword);\n+            case SEMICOLON_TOKEN:\n+                return STNodeFactory.createImplicitNewExpression(newKeyword, STNodeFactory.createEmptyNode());\n+            case IDENTIFIER_TOKEN:\n+            case OBJECT_KEYWORD:\n+                // TODO: Support `stream` keyword once introduced\n+                return parseExplicitNewExpression(newKeyword);\n+            default:\n+                Solution sol = recover(peek(), ParserRuleContext.NEW_EXPRESSION, newKeyword);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ae4c6e850b7ecb589b3f16e8966ac7109266ee3"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQ5MzE1NQ==", "bodyText": "Need to validate whether this is a object-type-desc or a type-reference", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146#discussion_r421493155", "createdAt": "2020-05-07T13:14:13Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -3172,6 +3180,127 @@ private STNode parseActionOrExpressionInLhs(SyntaxKind nextTokenKind, STNode lhs\n         return parseExpressionRhs(nextTokenKind, DEFAULT_OP_PRECEDENCE, lhsExpr, false, true);\n     }\n \n+    /**\n+     * <p>\n+     * Parse a new expression.\n+     * </p>\n+     * <code>\n+     *  new-expr := explicit-new-expr | implicit-new-expr\n+     *  explicit-new-expr := new type-descriptor ( arg-list )\n+     *  implicit-new-expr := new [( arg-list )]\n+     * </code>\n+     *\n+     * @return Parsed NewExpression node.\n+     */\n+    private STNode parseNewExpression() {\n+        startContext(ParserRuleContext.NEW_EXPRESSION);\n+        STNode newKeyword = parseNewKeyword();\n+        STNode newExpression = parseNewExpression(newKeyword);\n+        endContext();\n+        return newExpression;\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse `new` keyword.\n+     * </p>\n+     *\n+     * @return Parsed NEW_KEYWORD Token.\n+     */\n+    private STNode parseNewKeyword() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.NEW_KEYWORD) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(token, ParserRuleContext.NEW_KEYWORD);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    private STNode parseNewExpression(STNode newKeyword) {\n+        STNode token = peek();\n+        return parseNewExpression(token.kind, newKeyword);\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse an implicit or explicit expression.\n+     * </p>\n+     * @param kind next token kind.\n+     * @param newKeyword parsed node for `new` keyword.\n+     * @return Parsed new-expression node.\n+     */\n+    private STNode parseNewExpression(SyntaxKind kind, STNode newKeyword) {\n+        switch (kind) {\n+            case OPEN_PAREN_TOKEN:\n+                return parseImplicitNewExpression(newKeyword);\n+            case SEMICOLON_TOKEN:\n+                return STNodeFactory.createImplicitNewExpression(newKeyword, STNodeFactory.createEmptyNode());\n+            case IDENTIFIER_TOKEN:\n+            case OBJECT_KEYWORD:\n+                // TODO: Support `stream` keyword once introduced\n+                return parseExplicitNewExpression(newKeyword);\n+            default:\n+                Solution sol = recover(peek(), ParserRuleContext.NEW_EXPRESSION, newKeyword);\n+                return parseNewExpression(sol.recoveredNode.kind, newKeyword);\n+        }\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse an Explicit New expression.\n+     * </p>\n+     * <code>\n+     *  explicit-new-expr := new type-descriptor ( arg-list )\n+     * </code>\n+     *\n+     * @param newKeyword Parsed `new` keyword.\n+     * @return the Parsed Explicit New Expression.\n+     */\n+    private STNode parseExplicitNewExpression(STNode newKeyword) {\n+        startContext(ParserRuleContext.EXPLICIT_NEW_RHS);\n+        STNode typeDescriptor = parseTypeDescriptor();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ae4c6e850b7ecb589b3f16e8966ac7109266ee3"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQ5NTg0MQ==", "bodyText": "unused method?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146#discussion_r421495841", "createdAt": "2020-05-07T13:18:07Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -3172,6 +3180,127 @@ private STNode parseActionOrExpressionInLhs(SyntaxKind nextTokenKind, STNode lhs\n         return parseExpressionRhs(nextTokenKind, DEFAULT_OP_PRECEDENCE, lhsExpr, false, true);\n     }\n \n+    /**\n+     * <p>\n+     * Parse a new expression.\n+     * </p>\n+     * <code>\n+     *  new-expr := explicit-new-expr | implicit-new-expr\n+     *  explicit-new-expr := new type-descriptor ( arg-list )\n+     *  implicit-new-expr := new [( arg-list )]\n+     * </code>\n+     *\n+     * @return Parsed NewExpression node.\n+     */\n+    private STNode parseNewExpression() {\n+        startContext(ParserRuleContext.NEW_EXPRESSION);\n+        STNode newKeyword = parseNewKeyword();\n+        STNode newExpression = parseNewExpression(newKeyword);\n+        endContext();\n+        return newExpression;\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse `new` keyword.\n+     * </p>\n+     *\n+     * @return Parsed NEW_KEYWORD Token.\n+     */\n+    private STNode parseNewKeyword() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.NEW_KEYWORD) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(token, ParserRuleContext.NEW_KEYWORD);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    private STNode parseNewExpression(STNode newKeyword) {\n+        STNode token = peek();\n+        return parseNewExpression(token.kind, newKeyword);\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse an implicit or explicit expression.\n+     * </p>\n+     * @param kind next token kind.\n+     * @param newKeyword parsed node for `new` keyword.\n+     * @return Parsed new-expression node.\n+     */\n+    private STNode parseNewExpression(SyntaxKind kind, STNode newKeyword) {\n+        switch (kind) {\n+            case OPEN_PAREN_TOKEN:\n+                return parseImplicitNewExpression(newKeyword);\n+            case SEMICOLON_TOKEN:\n+                return STNodeFactory.createImplicitNewExpression(newKeyword, STNodeFactory.createEmptyNode());\n+            case IDENTIFIER_TOKEN:\n+            case OBJECT_KEYWORD:\n+                // TODO: Support `stream` keyword once introduced\n+                return parseExplicitNewExpression(newKeyword);\n+            default:\n+                Solution sol = recover(peek(), ParserRuleContext.NEW_EXPRESSION, newKeyword);\n+                return parseNewExpression(sol.recoveredNode.kind, newKeyword);\n+        }\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse an Explicit New expression.\n+     * </p>\n+     * <code>\n+     *  explicit-new-expr := new type-descriptor ( arg-list )\n+     * </code>\n+     *\n+     * @param newKeyword Parsed `new` keyword.\n+     * @return the Parsed Explicit New Expression.\n+     */\n+    private STNode parseExplicitNewExpression(STNode newKeyword) {\n+        startContext(ParserRuleContext.EXPLICIT_NEW_RHS);\n+        STNode typeDescriptor = parseTypeDescriptor();\n+        STNode parenthesizedArgsList = parseParenthesizedArgList();\n+        endContext();\n+\n+        return STNodeFactory.createExplicitNewExpression(newKeyword, typeDescriptor, parenthesizedArgsList);\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse an <code>implicit-new-expr</code> with arguments.\n+     * </p>\n+     *\n+     * @param newKeyword Parsed `new` keyword.\n+     * @return Parsed implicit-new-expr.\n+     */\n+    private STNode parseImplicitNewExpression(STNode newKeyword) {\n+        STNode implicitNewArgList = parseParenthesizedArgList();\n+\n+        return STNodeFactory.createImplicitNewExpression(newKeyword, implicitNewArgList);\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse the parenthesized argument list for a <code>new-expr</code>.\n+     * </p>\n+     *\n+     * @return Parsed parenthesized rhs of <code>new-expr</code>.\n+     */\n+    private STNode parseParenthesizedArgList() {\n+        startContext(ParserRuleContext.NEW_RHS);\n+        STNode openParan = parseOpenParenthesis();\n+        STNode arguments = parseArgsList();\n+        STNode closeParan = parseCloseParenthesis();\n+        endContext();\n+\n+        return STNodeFactory.createParenthesizedArgList(openParan, arguments, closeParan);\n+    }\n+\n+    private STNode parseActionOrExpressionInLhs(STNode lhsExpr) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ae4c6e850b7ecb589b3f16e8966ac7109266ee3"}, "originalPosition": 152}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQ5NTk5NA==", "bodyText": "extra newline", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146#discussion_r421495994", "createdAt": "2020-05-07T13:18:21Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -3172,6 +3180,127 @@ private STNode parseActionOrExpressionInLhs(SyntaxKind nextTokenKind, STNode lhs\n         return parseExpressionRhs(nextTokenKind, DEFAULT_OP_PRECEDENCE, lhsExpr, false, true);\n     }\n \n+    /**\n+     * <p>\n+     * Parse a new expression.\n+     * </p>\n+     * <code>\n+     *  new-expr := explicit-new-expr | implicit-new-expr\n+     *  explicit-new-expr := new type-descriptor ( arg-list )\n+     *  implicit-new-expr := new [( arg-list )]\n+     * </code>\n+     *\n+     * @return Parsed NewExpression node.\n+     */\n+    private STNode parseNewExpression() {\n+        startContext(ParserRuleContext.NEW_EXPRESSION);\n+        STNode newKeyword = parseNewKeyword();\n+        STNode newExpression = parseNewExpression(newKeyword);\n+        endContext();\n+        return newExpression;\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse `new` keyword.\n+     * </p>\n+     *\n+     * @return Parsed NEW_KEYWORD Token.\n+     */\n+    private STNode parseNewKeyword() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.NEW_KEYWORD) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(token, ParserRuleContext.NEW_KEYWORD);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    private STNode parseNewExpression(STNode newKeyword) {\n+        STNode token = peek();\n+        return parseNewExpression(token.kind, newKeyword);\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse an implicit or explicit expression.\n+     * </p>\n+     * @param kind next token kind.\n+     * @param newKeyword parsed node for `new` keyword.\n+     * @return Parsed new-expression node.\n+     */\n+    private STNode parseNewExpression(SyntaxKind kind, STNode newKeyword) {\n+        switch (kind) {\n+            case OPEN_PAREN_TOKEN:\n+                return parseImplicitNewExpression(newKeyword);\n+            case SEMICOLON_TOKEN:\n+                return STNodeFactory.createImplicitNewExpression(newKeyword, STNodeFactory.createEmptyNode());\n+            case IDENTIFIER_TOKEN:\n+            case OBJECT_KEYWORD:\n+                // TODO: Support `stream` keyword once introduced\n+                return parseExplicitNewExpression(newKeyword);\n+            default:\n+                Solution sol = recover(peek(), ParserRuleContext.NEW_EXPRESSION, newKeyword);\n+                return parseNewExpression(sol.recoveredNode.kind, newKeyword);\n+        }\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse an Explicit New expression.\n+     * </p>\n+     * <code>\n+     *  explicit-new-expr := new type-descriptor ( arg-list )\n+     * </code>\n+     *\n+     * @param newKeyword Parsed `new` keyword.\n+     * @return the Parsed Explicit New Expression.\n+     */\n+    private STNode parseExplicitNewExpression(STNode newKeyword) {\n+        startContext(ParserRuleContext.EXPLICIT_NEW_RHS);\n+        STNode typeDescriptor = parseTypeDescriptor();\n+        STNode parenthesizedArgsList = parseParenthesizedArgList();\n+        endContext();\n+\n+        return STNodeFactory.createExplicitNewExpression(newKeyword, typeDescriptor, parenthesizedArgsList);\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse an <code>implicit-new-expr</code> with arguments.\n+     * </p>\n+     *\n+     * @param newKeyword Parsed `new` keyword.\n+     * @return Parsed implicit-new-expr.\n+     */\n+    private STNode parseImplicitNewExpression(STNode newKeyword) {\n+        STNode implicitNewArgList = parseParenthesizedArgList();\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ae4c6e850b7ecb589b3f16e8966ac7109266ee3"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTUwMDkyMA==", "bodyText": "Need to add NEW_KEYWORD to the EXPRESSION_START array. Otherwise, if theres an error before the new, expression, then error handler will not know to treat new as a expression.\ni.e: Check something like: T x  new(); where the equal sign is missing before new expression.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146#discussion_r421500920", "createdAt": "2020-05-07T13:25:15Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -1020,6 +1023,8 @@ protected Result seekMatch(ParserRuleContext currentCtx, int lookahead, int curr\n                 case STRING_KEYWORD:\n                     hasMatch = nextToken.kind == SyntaxKind.XML_KEYWORD;\n                     break;\n+                case NEW_EXPRESSION:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ae4c6e850b7ecb589b3f16e8966ac7109266ee3"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTUwMzUxNQ==", "bodyText": "You are starting a context for NEW_RHS and EXPLICIT_NEW_RHS here, but its never ended.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146#discussion_r421503515", "createdAt": "2020-05-07T13:28:53Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -1343,6 +1350,8 @@ protected ParserRuleContext getNextRule(ParserRuleContext currentCtx, int nextLo\n             case KEY_SPECIFIER:\n             case ERROR_TYPE_DESCRIPTOR:\n             case LET_VAR_DECL:\n+            case NEW_RHS:\n+            case EXPLICIT_NEW_RHS:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ae4c6e850b7ecb589b3f16e8966ac7109266ee3"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTUwNjIwOA==", "bodyText": "Shall we have a different name instead of NEW_RHS. When we say new-rhs, what comes to mind is all possible alternatives after new keyword. i.e: (open-paren | identifier | expr-rhs)", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146#discussion_r421506208", "createdAt": "2020-05-07T13:32:41Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -3172,6 +3180,127 @@ private STNode parseActionOrExpressionInLhs(SyntaxKind nextTokenKind, STNode lhs\n         return parseExpressionRhs(nextTokenKind, DEFAULT_OP_PRECEDENCE, lhsExpr, false, true);\n     }\n \n+    /**\n+     * <p>\n+     * Parse a new expression.\n+     * </p>\n+     * <code>\n+     *  new-expr := explicit-new-expr | implicit-new-expr\n+     *  explicit-new-expr := new type-descriptor ( arg-list )\n+     *  implicit-new-expr := new [( arg-list )]\n+     * </code>\n+     *\n+     * @return Parsed NewExpression node.\n+     */\n+    private STNode parseNewExpression() {\n+        startContext(ParserRuleContext.NEW_EXPRESSION);\n+        STNode newKeyword = parseNewKeyword();\n+        STNode newExpression = parseNewExpression(newKeyword);\n+        endContext();\n+        return newExpression;\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse `new` keyword.\n+     * </p>\n+     *\n+     * @return Parsed NEW_KEYWORD Token.\n+     */\n+    private STNode parseNewKeyword() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.NEW_KEYWORD) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(token, ParserRuleContext.NEW_KEYWORD);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    private STNode parseNewExpression(STNode newKeyword) {\n+        STNode token = peek();\n+        return parseNewExpression(token.kind, newKeyword);\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse an implicit or explicit expression.\n+     * </p>\n+     * @param kind next token kind.\n+     * @param newKeyword parsed node for `new` keyword.\n+     * @return Parsed new-expression node.\n+     */\n+    private STNode parseNewExpression(SyntaxKind kind, STNode newKeyword) {\n+        switch (kind) {\n+            case OPEN_PAREN_TOKEN:\n+                return parseImplicitNewExpression(newKeyword);\n+            case SEMICOLON_TOKEN:\n+                return STNodeFactory.createImplicitNewExpression(newKeyword, STNodeFactory.createEmptyNode());\n+            case IDENTIFIER_TOKEN:\n+            case OBJECT_KEYWORD:\n+                // TODO: Support `stream` keyword once introduced\n+                return parseExplicitNewExpression(newKeyword);\n+            default:\n+                Solution sol = recover(peek(), ParserRuleContext.NEW_EXPRESSION, newKeyword);\n+                return parseNewExpression(sol.recoveredNode.kind, newKeyword);\n+        }\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse an Explicit New expression.\n+     * </p>\n+     * <code>\n+     *  explicit-new-expr := new type-descriptor ( arg-list )\n+     * </code>\n+     *\n+     * @param newKeyword Parsed `new` keyword.\n+     * @return the Parsed Explicit New Expression.\n+     */\n+    private STNode parseExplicitNewExpression(STNode newKeyword) {\n+        startContext(ParserRuleContext.EXPLICIT_NEW_RHS);\n+        STNode typeDescriptor = parseTypeDescriptor();\n+        STNode parenthesizedArgsList = parseParenthesizedArgList();\n+        endContext();\n+\n+        return STNodeFactory.createExplicitNewExpression(newKeyword, typeDescriptor, parenthesizedArgsList);\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse an <code>implicit-new-expr</code> with arguments.\n+     * </p>\n+     *\n+     * @param newKeyword Parsed `new` keyword.\n+     * @return Parsed implicit-new-expr.\n+     */\n+    private STNode parseImplicitNewExpression(STNode newKeyword) {\n+        STNode implicitNewArgList = parseParenthesizedArgList();\n+\n+        return STNodeFactory.createImplicitNewExpression(newKeyword, implicitNewArgList);\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse the parenthesized argument list for a <code>new-expr</code>.\n+     * </p>\n+     *\n+     * @return Parsed parenthesized rhs of <code>new-expr</code>.\n+     */\n+    private STNode parseParenthesizedArgList() {\n+        startContext(ParserRuleContext.NEW_RHS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ae4c6e850b7ecb589b3f16e8966ac7109266ee3"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTUwOTE0OQ==", "bodyText": "btw, IMO this context not NEW_EXPRESSION, its more like NEW_KEYWORD_RHS", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146#discussion_r421509149", "createdAt": "2020-05-07T13:36:50Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -3172,6 +3180,127 @@ private STNode parseActionOrExpressionInLhs(SyntaxKind nextTokenKind, STNode lhs\n         return parseExpressionRhs(nextTokenKind, DEFAULT_OP_PRECEDENCE, lhsExpr, false, true);\n     }\n \n+    /**\n+     * <p>\n+     * Parse a new expression.\n+     * </p>\n+     * <code>\n+     *  new-expr := explicit-new-expr | implicit-new-expr\n+     *  explicit-new-expr := new type-descriptor ( arg-list )\n+     *  implicit-new-expr := new [( arg-list )]\n+     * </code>\n+     *\n+     * @return Parsed NewExpression node.\n+     */\n+    private STNode parseNewExpression() {\n+        startContext(ParserRuleContext.NEW_EXPRESSION);\n+        STNode newKeyword = parseNewKeyword();\n+        STNode newExpression = parseNewExpression(newKeyword);\n+        endContext();\n+        return newExpression;\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse `new` keyword.\n+     * </p>\n+     *\n+     * @return Parsed NEW_KEYWORD Token.\n+     */\n+    private STNode parseNewKeyword() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.NEW_KEYWORD) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(token, ParserRuleContext.NEW_KEYWORD);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    private STNode parseNewExpression(STNode newKeyword) {\n+        STNode token = peek();\n+        return parseNewExpression(token.kind, newKeyword);\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse an implicit or explicit expression.\n+     * </p>\n+     * @param kind next token kind.\n+     * @param newKeyword parsed node for `new` keyword.\n+     * @return Parsed new-expression node.\n+     */\n+    private STNode parseNewExpression(SyntaxKind kind, STNode newKeyword) {\n+        switch (kind) {\n+            case OPEN_PAREN_TOKEN:\n+                return parseImplicitNewExpression(newKeyword);\n+            case SEMICOLON_TOKEN:\n+                return STNodeFactory.createImplicitNewExpression(newKeyword, STNodeFactory.createEmptyNode());\n+            case IDENTIFIER_TOKEN:\n+            case OBJECT_KEYWORD:\n+                // TODO: Support `stream` keyword once introduced\n+                return parseExplicitNewExpression(newKeyword);\n+            default:\n+                Solution sol = recover(peek(), ParserRuleContext.NEW_EXPRESSION, newKeyword);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQ5MDc2Mg=="}, "originalCommit": {"oid": "8ae4c6e850b7ecb589b3f16e8966ac7109266ee3"}, "originalPosition": 96}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "07c06fd6383897a3e52cca4bea15067bc9d33505", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/07c06fd6383897a3e52cca4bea15067bc9d33505", "committedDate": "2020-05-09T16:50:23Z", "message": "Fix Review Suggestions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e5fd17021244dafa29b6bc66c1fde9792106b9e8", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e5fd17021244dafa29b6bc66c1fde9792106b9e8", "committedDate": "2020-05-09T16:55:49Z", "message": "Merge branch 'incremental-parser' of https://github.com/ballerina-platform/ballerina-lang into new-expression-22998-new\n\n# Conflicts:\n#\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1a29b54a855c8e9ca7ff445fcb71ce32ae9ed91c", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1a29b54a855c8e9ca7ff445fcb71ce32ae9ed91c", "committedDate": "2020-05-10T12:40:59Z", "message": "Add checkstyle fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7ab53170f6245d10381885dcd6f178f10225ff73", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7ab53170f6245d10381885dcd6f178f10225ff73", "committedDate": "2020-05-10T18:27:02Z", "message": "Add missing files"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0a286f14702de4d4aa582d47618bbce2160758d8", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/0a286f14702de4d4aa582d47618bbce2160758d8", "committedDate": "2020-05-10T18:19:55Z", "message": "Add missing files"}, "afterCommit": {"oid": "7ab53170f6245d10381885dcd6f178f10225ff73", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7ab53170f6245d10381885dcd6f178f10225ff73", "committedDate": "2020-05-10T18:27:02Z", "message": "Add missing files"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2c7aaee5e2f5a88c95eb004ad8905463af37e771", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2c7aaee5e2f5a88c95eb004ad8905463af37e771", "committedDate": "2020-05-12T10:06:53Z", "message": "Add node transformer and tests."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "58934e8bdc63ac5e2e1794f0b5c02f478b690b16", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/58934e8bdc63ac5e2e1794f0b5c02f478b690b16", "committedDate": "2020-05-12T10:13:59Z", "message": "Fix test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "44aa7e514ec19518c839fe28e2fecc4a25150bc3", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/44aa7e514ec19518c839fe28e2fecc4a25150bc3", "committedDate": "2020-05-12T10:22:27Z", "message": "Merge branch 'incremental-parser' of https://github.com/ballerina-platform/ballerina-lang into new-expression-22998-new"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b1ad40b44afb4c5792127e96ed5ef1706147ab95", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b1ad40b44afb4c5792127e96ed5ef1706147ab95", "committedDate": "2020-05-12T11:47:59Z", "message": "Fix Tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5e8aad69b94e8bc3dd3b15a8d862d785bd3b86b6", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/5e8aad69b94e8bc3dd3b15a8d862d785bd3b86b6", "committedDate": "2020-05-12T11:49:51Z", "message": "Merge branch 'incremental-parser' of https://github.com/ballerina-platform/ballerina-lang into new-expression-22998-new"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fbd75bf691e8e0b2af223fb4a004cbdb38232f7f", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/fbd75bf691e8e0b2af223fb4a004cbdb38232f7f", "committedDate": "2020-05-12T12:20:20Z", "message": "Fix Checkstyle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7fefff93efc037821b671f5ac9b72118bdcfcfce", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7fefff93efc037821b671f5ac9b72118bdcfcfce", "committedDate": "2020-05-12T12:22:52Z", "message": "Merge branch 'incremental-parser' of https://github.com/ballerina-platform/ballerina-lang into new-expression-22998-new"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA5OTgyMzI2", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146#pullrequestreview-409982326", "createdAt": "2020-05-12T12:19:31Z", "commit": {"oid": "5e8aad69b94e8bc3dd3b15a8d862d785bd3b86b6"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxMjoxOTozMVrOGUD1SQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxMjozNDowMVrOGUEW9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY4NzQ5Nw==", "bodyText": "Lets create an issue for this", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146#discussion_r423687497", "createdAt": "2020-05-12T12:19:31Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -3481,6 +3489,116 @@ private STNode parseActionOrExpressionInLhs(SyntaxKind nextTokenKind, STNode lhs\n         return parseExpressionRhs(nextTokenKind, DEFAULT_OP_PRECEDENCE, lhsExpr, false, true);\n     }\n \n+    /**\n+     * <p>\n+     * Parse a new expression.\n+     * </p>\n+     * <code>\n+     *  new-expr := explicit-new-expr | implicit-new-expr\n+     *  explicit-new-expr := new type-descriptor ( arg-list )\n+     *  implicit-new-expr := new [( arg-list )]\n+     * </code>\n+     *\n+     * @return Parsed NewExpression node.\n+     */\n+    private STNode parseNewExpression() {\n+        STNode newKeyword = parseNewKeyword();\n+        return parseNewKeywordRhs(newKeyword);\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse `new` keyword.\n+     * </p>\n+     *\n+     * @return Parsed NEW_KEYWORD Token.\n+     */\n+    private STNode parseNewKeyword() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.NEW_KEYWORD) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(token, ParserRuleContext.NEW_KEYWORD);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    private STNode parseNewKeywordRhs(STNode newKeyword) {\n+        STNode token = peek();\n+        return parseNewKeywordRhs(token.kind, newKeyword);\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse an implicit or explicit expression.\n+     * </p>\n+     * @param kind next token kind.\n+     * @param newKeyword parsed node for `new` keyword.\n+     * @return Parsed new-expression node.\n+     */\n+    private STNode parseNewKeywordRhs(SyntaxKind kind, STNode newKeyword) {\n+        switch (kind) {\n+            case OPEN_PAREN_TOKEN:\n+                return parseImplicitNewRhs(newKeyword);\n+            case SEMICOLON_TOKEN:\n+                break;\n+            case IDENTIFIER_TOKEN:\n+            case OBJECT_KEYWORD:\n+                // TODO: Support `stream` keyword once introduced", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e8aad69b94e8bc3dd3b15a8d862d785bd3b86b6"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY4ODUzMw==", "bodyText": "Shall we rename EXPLICIT_NEW_RHS to TYPE_DESC_IN_NEW_EXPR, to be aligned with the convention we used in other places?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146#discussion_r423688533", "createdAt": "2020-05-12T12:21:21Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -3481,6 +3489,116 @@ private STNode parseActionOrExpressionInLhs(SyntaxKind nextTokenKind, STNode lhs\n         return parseExpressionRhs(nextTokenKind, DEFAULT_OP_PRECEDENCE, lhsExpr, false, true);\n     }\n \n+    /**\n+     * <p>\n+     * Parse a new expression.\n+     * </p>\n+     * <code>\n+     *  new-expr := explicit-new-expr | implicit-new-expr\n+     *  explicit-new-expr := new type-descriptor ( arg-list )\n+     *  implicit-new-expr := new [( arg-list )]\n+     * </code>\n+     *\n+     * @return Parsed NewExpression node.\n+     */\n+    private STNode parseNewExpression() {\n+        STNode newKeyword = parseNewKeyword();\n+        return parseNewKeywordRhs(newKeyword);\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse `new` keyword.\n+     * </p>\n+     *\n+     * @return Parsed NEW_KEYWORD Token.\n+     */\n+    private STNode parseNewKeyword() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.NEW_KEYWORD) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(token, ParserRuleContext.NEW_KEYWORD);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    private STNode parseNewKeywordRhs(STNode newKeyword) {\n+        STNode token = peek();\n+        return parseNewKeywordRhs(token.kind, newKeyword);\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse an implicit or explicit expression.\n+     * </p>\n+     * @param kind next token kind.\n+     * @param newKeyword parsed node for `new` keyword.\n+     * @return Parsed new-expression node.\n+     */\n+    private STNode parseNewKeywordRhs(SyntaxKind kind, STNode newKeyword) {\n+        switch (kind) {\n+            case OPEN_PAREN_TOKEN:\n+                return parseImplicitNewRhs(newKeyword);\n+            case SEMICOLON_TOKEN:\n+                break;\n+            case IDENTIFIER_TOKEN:\n+            case OBJECT_KEYWORD:\n+                // TODO: Support `stream` keyword once introduced\n+                return parseExplicitNewRhs(newKeyword);\n+            default:\n+                break;\n+        }\n+\n+        return STNodeFactory.createImplicitNewExpression(newKeyword, STNodeFactory.createEmptyNode());\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse an Explicit New expression.\n+     * </p>\n+     * <code>\n+     *  explicit-new-expr := new type-descriptor ( arg-list )\n+     * </code>\n+     *\n+     * @param newKeyword Parsed `new` keyword.\n+     * @return the Parsed Explicit New Expression.\n+     */\n+    private STNode parseExplicitNewRhs(STNode newKeyword) {\n+        STNode typeDescriptor = parseTypeDescriptor(ParserRuleContext.EXPLICIT_NEW_RHS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e8aad69b94e8bc3dd3b15a8d862d785bd3b86b6"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY5MTI5OA==", "bodyText": "I don't think we need it here.\nThis should be added to all the places where other TYPE_DESC_IN_** contexts are added.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146#discussion_r423691298", "createdAt": "2020-05-12T12:25:57Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -1920,6 +1933,7 @@ protected ParserRuleContext getNextRule(ParserRuleContext currentCtx, int nextLo\n             case ARG_LIST_START:\n                 return ParserRuleContext.ARG_LIST;\n             case ARG_LIST_END:\n+            case EXPLICIT_NEW_RHS:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fefff93efc037821b671f5ac9b72118bdcfcfce"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY5MTY1MA==", "bodyText": "Same as above", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146#discussion_r423691650", "createdAt": "2020-05-12T12:26:33Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -2390,6 +2404,8 @@ private ParserRuleContext getNextRuleForCloseBrace(int nextLookahead) {\n             case INTERPOLATION:\n                 endContext();\n                 return ParserRuleContext.TEMPLATE_MEMBER;\n+            case EXPLICIT_NEW_RHS:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fefff93efc037821b671f5ac9b72118bdcfcfce"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY5MjAzOA==", "bodyText": "better to rename NEW_EXPR  --> NEW_KEYWORD_RHS", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146#discussion_r423692038", "createdAt": "2020-05-12T12:27:14Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -323,6 +323,10 @@\n             { ParserRuleContext.END_OF_TYPE_DESC, ParserRuleContext.ARRAY_TYPE_DESCRIPTOR,\n                     ParserRuleContext.OPTIONAL_TYPE_DESCRIPTOR, ParserRuleContext.PIPE };\n \n+    private static final ParserRuleContext[] NEW_EXPR =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fefff93efc037821b671f5ac9b72118bdcfcfce"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY5NDE2MQ==", "bodyText": "This Should be ARG_LIST_START. Its also matches against the ( , but it handles the arg-contexts", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146#discussion_r423694161", "createdAt": "2020-05-12T12:30:39Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -2390,6 +2404,8 @@ private ParserRuleContext getNextRuleForCloseBrace(int nextLookahead) {\n             case INTERPOLATION:\n                 endContext();\n                 return ParserRuleContext.TEMPLATE_MEMBER;\n+            case EXPLICIT_NEW_RHS:\n+                return ParserRuleContext.OPEN_PARENTHESIS;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fefff93efc037821b671f5ac9b72118bdcfcfce"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY5NTM3Ng==", "bodyText": "type should be TypeDescriptorNode", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146#discussion_r423695376", "createdAt": "2020-05-12T12:32:43Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-treegen/src/main/resources/syntax_tree_descriptor.json", "diffHunk": "@@ -2438,6 +2438,66 @@\n                     \"type\": \"Token\"\n                 }\n             ]\n+        },\n+        {\n+            \"name\": \"NewExpression\",\n+            \"base\": \"ExpressionNode\",\n+            \"isAbstract\": true\n+        },\n+        {\n+            \"name\": \"ExplicitNewExpression\",\n+            \"base\": \"NewExpression\",\n+            \"kind\": \"EXPLICIT_NEW\",\n+            \"attributes\": [\n+                {\n+                    \"name\": \"NewKeyword\",\n+                    \"type\": \"Token\"\n+                },\n+                {\n+                    \"name\": \"TypeDescriptor\",\n+                    \"type\": \"Node\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fefff93efc037821b671f5ac9b72118bdcfcfce"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY5NTc0MA==", "bodyText": "EXPLICIT_NEW_EXPRESSION", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146#discussion_r423695740", "createdAt": "2020-05-12T12:33:23Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-treegen/src/main/resources/syntax_tree_descriptor.json", "diffHunk": "@@ -2438,6 +2438,66 @@\n                     \"type\": \"Token\"\n                 }\n             ]\n+        },\n+        {\n+            \"name\": \"NewExpression\",\n+            \"base\": \"ExpressionNode\",\n+            \"isAbstract\": true\n+        },\n+        {\n+            \"name\": \"ExplicitNewExpression\",\n+            \"base\": \"NewExpression\",\n+            \"kind\": \"EXPLICIT_NEW\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fefff93efc037821b671f5ac9b72118bdcfcfce"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY5NjExOA==", "bodyText": "all nodes-names must end with ...Node", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146#discussion_r423696118", "createdAt": "2020-05-12T12:34:01Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-treegen/src/main/resources/syntax_tree_descriptor.json", "diffHunk": "@@ -2438,6 +2438,66 @@\n                     \"type\": \"Token\"\n                 }\n             ]\n+        },\n+        {\n+            \"name\": \"NewExpression\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fefff93efc037821b671f5ac9b72118bdcfcfce"}, "originalPosition": 6}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "99ceaabf2695c475fe63b7f29f2d2815a1464159", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/99ceaabf2695c475fe63b7f29f2d2815a1464159", "committedDate": "2020-05-12T15:02:48Z", "message": "Merge branch 'incremental-parser' of https://github.com/ballerina-platform/ballerina-lang into new-expression-22998-new"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "052e7ee9b5acaa6900bffd7bb15720b0cb367abd", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/052e7ee9b5acaa6900bffd7bb15720b0cb367abd", "committedDate": "2020-05-12T15:54:50Z", "message": "Fix review suggestions"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "401f175556a615f1359fa66cab24125e992ca87e", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/401f175556a615f1359fa66cab24125e992ca87e", "committedDate": "2020-05-12T15:42:12Z", "message": "Fix review suggestions"}, "afterCommit": {"oid": "052e7ee9b5acaa6900bffd7bb15720b0cb367abd", "author": {"user": {"login": "dulvinw", "name": "Dulvin Witharane"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/052e7ee9b5acaa6900bffd7bb15720b0cb367abd", "committedDate": "2020-05-12T15:54:50Z", "message": "Fix review suggestions"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEwNTcxNzEz", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146#pullrequestreview-410571713", "createdAt": "2020-05-13T04:00:23Z", "commit": {"oid": "052e7ee9b5acaa6900bffd7bb15720b0cb367abd"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3407, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}