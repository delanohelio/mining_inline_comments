{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE1ODg2MzMw", "number": 26770, "reviewThreads": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwNjo0OTowMVrOE3k4EQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQwNTo1MDozM1rOFLjsOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2NzExMzEzOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/SymbolEnter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwNjo0OTowMVrOHxAWOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxNjozMjo0M1rOHxU0pA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTE0Nzk2MQ==", "bodyText": "The compiler crashes here for\ntype Detail record {\n    string x;\n};\n\ntype DetailTwo record {\n    string x;\n    string y;\n};\n\ntype ErrorOne error<Detail>;\n\ntype ErrorTwo error<DetailTwo>;\n\ntype IntersectionError ErrorOne & ErrorTwo;\n\npublic function main() {\n    var err = IntersectionError(\"message\", x = \"x\", y = \"y\");\n}", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#discussion_r521147961", "createdAt": "2020-11-11T06:49:01Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/SymbolEnter.java", "diffHunk": "@@ -397,6 +404,171 @@ private void defineConstructs(BLangPackage pkgNode, SymbolEnv pkgEnv) {\n                 .forEach(varSymbol -> varSymbol.tag = SymTag.ENDPOINT);\n     }\n \n+    private void defineErrorIntersection(SymbolEnv env) {\n+        for (BLangNode typeDescriptor : this.errorIntersectionTypes) {\n+            BLangTypeDefinition typeDefinition = (BLangTypeDefinition) typeDescriptor;\n+\n+            boolean isDistinctType = isDistinctFlagPresent(typeDefinition);\n+            boolean isPublicType = typeDefinition.flagSet.contains(Flag.PUBLIC);\n+            Set<BTypeIdSet.BTypeId> secondaryTypeIds = new HashSet<>();\n+\n+            BLangIntersectionTypeNode intersectionTypeNode = (BLangIntersectionTypeNode) typeDefinition.typeNode;\n+            List<BLangType> constituentTypes = intersectionTypeNode.constituentTypeNodes;\n+\n+            BLangType bLangTypeOne = constituentTypes.get(0);\n+            BType typeOne = symResolver.resolveTypeNode(bLangTypeOne, env);\n+            if (typeOne.tag != TypeTags.ERROR && typeOne.tag != TypeTags.READONLY) {\n+                // TODO: log error for intersection type with other types.\n+                continue;\n+            }\n+\n+            BLangType bLangTypeTwo = constituentTypes.get(1);\n+            BType typeTwo = symResolver.resolveTypeNode(bLangTypeTwo, env);\n+            if (typeTwo.tag != TypeTags.ERROR && typeTwo.tag != TypeTags.READONLY) {\n+                // TODO: log error for intersection type with other types.\n+                continue;\n+            }\n+\n+            // Collecting typeIds.\n+            if (typeOne.tag != TypeTags.READONLY) {\n+                populateSecondaryTypeIdSet(secondaryTypeIds, (BErrorType) typeOne);\n+            }\n+            if (typeTwo.tag != TypeTags.READONLY) {\n+                populateSecondaryTypeIdSet(secondaryTypeIds, (BErrorType) typeTwo);\n+            }\n+\n+            BType potentialIntersectionType = types.getTypeIntersection(typeOne, typeTwo);\n+\n+            boolean isValidIntersection = true;\n+            for (int i = 2; i < constituentTypes.size(); i++) {\n+                BLangType bLangType = constituentTypes.get(i);\n+                BType bType = symResolver.resolveTypeNode(bLangType, env);\n+\n+                if (bType.getKind() != TypeKind.ERROR && typeTwo.tag != TypeTags.READONLY) {\n+                    // TODO: Log error for invalid intersection\n+                    isValidIntersection = false;\n+                    break;\n+                }\n+\n+                if (bType.tag != TypeTags.READONLY) {\n+                    populateSecondaryTypeIdSet(secondaryTypeIds, (BErrorType) bType);\n+                }\n+\n+                potentialIntersectionType = types.getTypeIntersection(potentialIntersectionType, bType);\n+                if (potentialIntersectionType == symTable.semanticError) {\n+                    // TODO: Log invalid intersection\n+                    isValidIntersection = false;\n+                    break;\n+                }\n+            }\n+\n+            if (!isValidIntersection) {\n+                continue;\n+            }\n+\n+            if (isDistinctType) {\n+                ((BErrorType) potentialIntersectionType).typeIdSet = BTypeIdSet.from(\n+                        potentialIntersectionType.tsymbol.pkgID, typeDefinition.name.value, isPublicType,\n+                        secondaryTypeIds);\n+            }\n+\n+            LinkedHashSet<BType> constituentBTypes = new LinkedHashSet<>() {{\n+                add(typeOne);\n+                add(typeTwo);\n+            }};\n+            BIntersectionType intersectionType = definePotentialIntersectionType((BErrorType) potentialIntersectionType,\n+                                                                                 typeDefinition, constituentBTypes);\n+            typeDefinition.symbol = intersectionType.tsymbol;\n+            typeDefinition.typeNode.type = intersectionType;\n+        }\n+    }\n+\n+    private void populateSecondaryTypeIdSet(Set<BTypeIdSet.BTypeId> secondaryTypeIds, BErrorType typeOne) {\n+        secondaryTypeIds.addAll(typeOne.typeIdSet.primary);\n+        secondaryTypeIds.addAll(typeOne.typeIdSet.secondary);\n+    }\n+\n+    private BIntersectionType definePotentialIntersectionType(BErrorType potentialIntersectionType,\n+                                                              BLangTypeDefinition typeDefinition,\n+                                                              LinkedHashSet<BType> constituentBTypes) {\n+\n+        BSymbol owner = potentialIntersectionType.tsymbol.owner;\n+        PackageID pkgId = potentialIntersectionType.tsymbol.pkgID;\n+        SymbolEnv pkgEnv = symTable.pkgEnvMap.get(owner);\n+\n+        BLangTypeDefinition detailTypeDef = defineErrorDetailRecord((BRecordType) potentialIntersectionType.detailType,\n+                                                                    typeDefinition.pos, pkgEnv);\n+        defineErrorType(potentialIntersectionType, detailTypeDef, pkgEnv, typeDefinition);\n+        return defineErrorIntersectionType(potentialIntersectionType, typeDefinition, constituentBTypes, pkgId, owner,\n+                                           pkgEnv);\n+    }\n+\n+    private BLangTypeDefinition defineErrorDetailRecord(BRecordType detailRecord, Location pos, SymbolEnv env) {\n+        // TODO: need to support map intersection.\n+        BRecordTypeSymbol detailRecordSymbol = (BRecordTypeSymbol) detailRecord.tsymbol;\n+        detailRecordSymbol.scope.define(names.fromString(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7aa2a1561579e350d7c8e6427ccff2dcb1366954"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ4MzQyOA==", "bodyText": "Fixed", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#discussion_r521483428", "createdAt": "2020-11-11T16:32:43Z", "author": {"login": "dulvinw"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/SymbolEnter.java", "diffHunk": "@@ -397,6 +404,171 @@ private void defineConstructs(BLangPackage pkgNode, SymbolEnv pkgEnv) {\n                 .forEach(varSymbol -> varSymbol.tag = SymTag.ENDPOINT);\n     }\n \n+    private void defineErrorIntersection(SymbolEnv env) {\n+        for (BLangNode typeDescriptor : this.errorIntersectionTypes) {\n+            BLangTypeDefinition typeDefinition = (BLangTypeDefinition) typeDescriptor;\n+\n+            boolean isDistinctType = isDistinctFlagPresent(typeDefinition);\n+            boolean isPublicType = typeDefinition.flagSet.contains(Flag.PUBLIC);\n+            Set<BTypeIdSet.BTypeId> secondaryTypeIds = new HashSet<>();\n+\n+            BLangIntersectionTypeNode intersectionTypeNode = (BLangIntersectionTypeNode) typeDefinition.typeNode;\n+            List<BLangType> constituentTypes = intersectionTypeNode.constituentTypeNodes;\n+\n+            BLangType bLangTypeOne = constituentTypes.get(0);\n+            BType typeOne = symResolver.resolveTypeNode(bLangTypeOne, env);\n+            if (typeOne.tag != TypeTags.ERROR && typeOne.tag != TypeTags.READONLY) {\n+                // TODO: log error for intersection type with other types.\n+                continue;\n+            }\n+\n+            BLangType bLangTypeTwo = constituentTypes.get(1);\n+            BType typeTwo = symResolver.resolveTypeNode(bLangTypeTwo, env);\n+            if (typeTwo.tag != TypeTags.ERROR && typeTwo.tag != TypeTags.READONLY) {\n+                // TODO: log error for intersection type with other types.\n+                continue;\n+            }\n+\n+            // Collecting typeIds.\n+            if (typeOne.tag != TypeTags.READONLY) {\n+                populateSecondaryTypeIdSet(secondaryTypeIds, (BErrorType) typeOne);\n+            }\n+            if (typeTwo.tag != TypeTags.READONLY) {\n+                populateSecondaryTypeIdSet(secondaryTypeIds, (BErrorType) typeTwo);\n+            }\n+\n+            BType potentialIntersectionType = types.getTypeIntersection(typeOne, typeTwo);\n+\n+            boolean isValidIntersection = true;\n+            for (int i = 2; i < constituentTypes.size(); i++) {\n+                BLangType bLangType = constituentTypes.get(i);\n+                BType bType = symResolver.resolveTypeNode(bLangType, env);\n+\n+                if (bType.getKind() != TypeKind.ERROR && typeTwo.tag != TypeTags.READONLY) {\n+                    // TODO: Log error for invalid intersection\n+                    isValidIntersection = false;\n+                    break;\n+                }\n+\n+                if (bType.tag != TypeTags.READONLY) {\n+                    populateSecondaryTypeIdSet(secondaryTypeIds, (BErrorType) bType);\n+                }\n+\n+                potentialIntersectionType = types.getTypeIntersection(potentialIntersectionType, bType);\n+                if (potentialIntersectionType == symTable.semanticError) {\n+                    // TODO: Log invalid intersection\n+                    isValidIntersection = false;\n+                    break;\n+                }\n+            }\n+\n+            if (!isValidIntersection) {\n+                continue;\n+            }\n+\n+            if (isDistinctType) {\n+                ((BErrorType) potentialIntersectionType).typeIdSet = BTypeIdSet.from(\n+                        potentialIntersectionType.tsymbol.pkgID, typeDefinition.name.value, isPublicType,\n+                        secondaryTypeIds);\n+            }\n+\n+            LinkedHashSet<BType> constituentBTypes = new LinkedHashSet<>() {{\n+                add(typeOne);\n+                add(typeTwo);\n+            }};\n+            BIntersectionType intersectionType = definePotentialIntersectionType((BErrorType) potentialIntersectionType,\n+                                                                                 typeDefinition, constituentBTypes);\n+            typeDefinition.symbol = intersectionType.tsymbol;\n+            typeDefinition.typeNode.type = intersectionType;\n+        }\n+    }\n+\n+    private void populateSecondaryTypeIdSet(Set<BTypeIdSet.BTypeId> secondaryTypeIds, BErrorType typeOne) {\n+        secondaryTypeIds.addAll(typeOne.typeIdSet.primary);\n+        secondaryTypeIds.addAll(typeOne.typeIdSet.secondary);\n+    }\n+\n+    private BIntersectionType definePotentialIntersectionType(BErrorType potentialIntersectionType,\n+                                                              BLangTypeDefinition typeDefinition,\n+                                                              LinkedHashSet<BType> constituentBTypes) {\n+\n+        BSymbol owner = potentialIntersectionType.tsymbol.owner;\n+        PackageID pkgId = potentialIntersectionType.tsymbol.pkgID;\n+        SymbolEnv pkgEnv = symTable.pkgEnvMap.get(owner);\n+\n+        BLangTypeDefinition detailTypeDef = defineErrorDetailRecord((BRecordType) potentialIntersectionType.detailType,\n+                                                                    typeDefinition.pos, pkgEnv);\n+        defineErrorType(potentialIntersectionType, detailTypeDef, pkgEnv, typeDefinition);\n+        return defineErrorIntersectionType(potentialIntersectionType, typeDefinition, constituentBTypes, pkgId, owner,\n+                                           pkgEnv);\n+    }\n+\n+    private BLangTypeDefinition defineErrorDetailRecord(BRecordType detailRecord, Location pos, SymbolEnv env) {\n+        // TODO: need to support map intersection.\n+        BRecordTypeSymbol detailRecordSymbol = (BRecordTypeSymbol) detailRecord.tsymbol;\n+        detailRecordSymbol.scope.define(names.fromString(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTE0Nzk2MQ=="}, "originalCommit": {"oid": "7aa2a1561579e350d7c8e6427ccff2dcb1366954"}, "originalPosition": 157}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2NzE2MjgzOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/SymbolEnter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwNzowMTo1M1rOHxA19w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxNjozNjo0OFrOHxVBkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTE1NjA4Nw==", "bodyText": "Any specific reason to check kind instead of tag here?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#discussion_r521156087", "createdAt": "2020-11-11T07:01:53Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/SymbolEnter.java", "diffHunk": "@@ -397,6 +406,170 @@ private void defineConstructs(BLangPackage pkgNode, SymbolEnv pkgEnv) {\n                 .forEach(varSymbol -> varSymbol.tag = SymTag.ENDPOINT);\n     }\n \n+    private void defineErrorIntersection(SymbolEnv env) {\n+        for (BLangNode typeDescriptor : this.errorIntersectionTypes) {\n+            BLangTypeDefinition typeDefinition = (BLangTypeDefinition) typeDescriptor;\n+\n+            boolean isDistinctType = isDistinctFlagPresent(typeDefinition);\n+            boolean isPublicType = typeDefinition.flagSet.contains(Flag.PUBLIC);\n+            Set<BTypeIdSet.BTypeId> secondaryTypeIds = new HashSet<>();\n+\n+            BLangIntersectionTypeNode intersectionTypeNode = (BLangIntersectionTypeNode) typeDefinition.typeNode;\n+            List<BLangType> constituentTypes = intersectionTypeNode.constituentTypeNodes;\n+\n+            BLangType bLangTypeOne = constituentTypes.get(0);\n+            BType typeOne = symResolver.resolveTypeNode(bLangTypeOne, env);\n+            if (typeOne.tag != TypeTags.ERROR && typeOne.tag != TypeTags.READONLY) {\n+                dlog.error(bLangTypeOne.pos, INVALID_ERROR_INTERSECTION, bLangTypeOne);\n+                continue;\n+            }\n+\n+            BLangType bLangTypeTwo = constituentTypes.get(1);\n+            BType typeTwo = symResolver.resolveTypeNode(bLangTypeTwo, env);\n+            if (typeTwo.tag != TypeTags.ERROR && typeTwo.tag != TypeTags.READONLY) {\n+                dlog.error(bLangTypeTwo.pos, INVALID_ERROR_INTERSECTION, bLangTypeTwo);\n+                continue;\n+            }\n+\n+            // Collecting typeIds.\n+            if (typeOne.tag != TypeTags.READONLY) {\n+                populateSecondaryTypeIdSet(secondaryTypeIds, (BErrorType) typeOne);\n+            }\n+            if (typeTwo.tag != TypeTags.READONLY) {\n+                populateSecondaryTypeIdSet(secondaryTypeIds, (BErrorType) typeTwo);\n+            }\n+\n+            BType potentialIntersectionType = types.getTypeIntersection(typeOne, typeTwo);\n+\n+            boolean isValidIntersection = true;\n+            for (int i = 2; i < constituentTypes.size(); i++) {\n+                BLangType bLangType = constituentTypes.get(i);\n+                BType bType = symResolver.resolveTypeNode(bLangType, env);\n+\n+                if (bType.getKind() != TypeKind.ERROR && typeTwo.tag != TypeTags.READONLY) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10014b1a8708eeb074e7e82463fb840ab008faf6"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ4NjczOA==", "bodyText": "Fixed", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#discussion_r521486738", "createdAt": "2020-11-11T16:36:48Z", "author": {"login": "dulvinw"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/SymbolEnter.java", "diffHunk": "@@ -397,6 +406,170 @@ private void defineConstructs(BLangPackage pkgNode, SymbolEnv pkgEnv) {\n                 .forEach(varSymbol -> varSymbol.tag = SymTag.ENDPOINT);\n     }\n \n+    private void defineErrorIntersection(SymbolEnv env) {\n+        for (BLangNode typeDescriptor : this.errorIntersectionTypes) {\n+            BLangTypeDefinition typeDefinition = (BLangTypeDefinition) typeDescriptor;\n+\n+            boolean isDistinctType = isDistinctFlagPresent(typeDefinition);\n+            boolean isPublicType = typeDefinition.flagSet.contains(Flag.PUBLIC);\n+            Set<BTypeIdSet.BTypeId> secondaryTypeIds = new HashSet<>();\n+\n+            BLangIntersectionTypeNode intersectionTypeNode = (BLangIntersectionTypeNode) typeDefinition.typeNode;\n+            List<BLangType> constituentTypes = intersectionTypeNode.constituentTypeNodes;\n+\n+            BLangType bLangTypeOne = constituentTypes.get(0);\n+            BType typeOne = symResolver.resolveTypeNode(bLangTypeOne, env);\n+            if (typeOne.tag != TypeTags.ERROR && typeOne.tag != TypeTags.READONLY) {\n+                dlog.error(bLangTypeOne.pos, INVALID_ERROR_INTERSECTION, bLangTypeOne);\n+                continue;\n+            }\n+\n+            BLangType bLangTypeTwo = constituentTypes.get(1);\n+            BType typeTwo = symResolver.resolveTypeNode(bLangTypeTwo, env);\n+            if (typeTwo.tag != TypeTags.ERROR && typeTwo.tag != TypeTags.READONLY) {\n+                dlog.error(bLangTypeTwo.pos, INVALID_ERROR_INTERSECTION, bLangTypeTwo);\n+                continue;\n+            }\n+\n+            // Collecting typeIds.\n+            if (typeOne.tag != TypeTags.READONLY) {\n+                populateSecondaryTypeIdSet(secondaryTypeIds, (BErrorType) typeOne);\n+            }\n+            if (typeTwo.tag != TypeTags.READONLY) {\n+                populateSecondaryTypeIdSet(secondaryTypeIds, (BErrorType) typeTwo);\n+            }\n+\n+            BType potentialIntersectionType = types.getTypeIntersection(typeOne, typeTwo);\n+\n+            boolean isValidIntersection = true;\n+            for (int i = 2; i < constituentTypes.size(); i++) {\n+                BLangType bLangType = constituentTypes.get(i);\n+                BType bType = symResolver.resolveTypeNode(bLangType, env);\n+\n+                if (bType.getKind() != TypeKind.ERROR && typeTwo.tag != TypeTags.READONLY) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTE1NjA4Nw=="}, "originalCommit": {"oid": "10014b1a8708eeb074e7e82463fb840ab008faf6"}, "originalPosition": 104}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2NzE3NDI4OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/SymbolEnter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwNzowNjo0M1rOHxA8dA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxNjozNDo1MlrOHxU8eQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTE1Nzc0OA==", "bodyText": "In this case, is it actually potential if we get to this point?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#discussion_r521157748", "createdAt": "2020-11-11T07:06:43Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/SymbolEnter.java", "diffHunk": "@@ -397,6 +406,170 @@ private void defineConstructs(BLangPackage pkgNode, SymbolEnv pkgEnv) {\n                 .forEach(varSymbol -> varSymbol.tag = SymTag.ENDPOINT);\n     }\n \n+    private void defineErrorIntersection(SymbolEnv env) {\n+        for (BLangNode typeDescriptor : this.errorIntersectionTypes) {\n+            BLangTypeDefinition typeDefinition = (BLangTypeDefinition) typeDescriptor;\n+\n+            boolean isDistinctType = isDistinctFlagPresent(typeDefinition);\n+            boolean isPublicType = typeDefinition.flagSet.contains(Flag.PUBLIC);\n+            Set<BTypeIdSet.BTypeId> secondaryTypeIds = new HashSet<>();\n+\n+            BLangIntersectionTypeNode intersectionTypeNode = (BLangIntersectionTypeNode) typeDefinition.typeNode;\n+            List<BLangType> constituentTypes = intersectionTypeNode.constituentTypeNodes;\n+\n+            BLangType bLangTypeOne = constituentTypes.get(0);\n+            BType typeOne = symResolver.resolveTypeNode(bLangTypeOne, env);\n+            if (typeOne.tag != TypeTags.ERROR && typeOne.tag != TypeTags.READONLY) {\n+                dlog.error(bLangTypeOne.pos, INVALID_ERROR_INTERSECTION, bLangTypeOne);\n+                continue;\n+            }\n+\n+            BLangType bLangTypeTwo = constituentTypes.get(1);\n+            BType typeTwo = symResolver.resolveTypeNode(bLangTypeTwo, env);\n+            if (typeTwo.tag != TypeTags.ERROR && typeTwo.tag != TypeTags.READONLY) {\n+                dlog.error(bLangTypeTwo.pos, INVALID_ERROR_INTERSECTION, bLangTypeTwo);\n+                continue;\n+            }\n+\n+            // Collecting typeIds.\n+            if (typeOne.tag != TypeTags.READONLY) {\n+                populateSecondaryTypeIdSet(secondaryTypeIds, (BErrorType) typeOne);\n+            }\n+            if (typeTwo.tag != TypeTags.READONLY) {\n+                populateSecondaryTypeIdSet(secondaryTypeIds, (BErrorType) typeTwo);\n+            }\n+\n+            BType potentialIntersectionType = types.getTypeIntersection(typeOne, typeTwo);\n+\n+            boolean isValidIntersection = true;\n+            for (int i = 2; i < constituentTypes.size(); i++) {\n+                BLangType bLangType = constituentTypes.get(i);\n+                BType bType = symResolver.resolveTypeNode(bLangType, env);\n+\n+                if (bType.getKind() != TypeKind.ERROR && typeTwo.tag != TypeTags.READONLY) {\n+                    dlog.error(bLangType.pos, INVALID_ERROR_INTERSECTION, bLangType);\n+                    isValidIntersection = false;\n+                    break;\n+                }\n+\n+                if (bType.tag != TypeTags.READONLY) {\n+                    populateSecondaryTypeIdSet(secondaryTypeIds, (BErrorType) bType);\n+                }\n+\n+                potentialIntersectionType = types.getTypeIntersection(potentialIntersectionType, bType);\n+                if (potentialIntersectionType == symTable.semanticError) {\n+                    dlog.error(typeDefinition.typeNode.pos, INVALID_INTERSECTION_TYPE, typeDefinition.typeNode);\n+                    isValidIntersection = false;\n+                    break;\n+                }\n+            }\n+\n+            if (!isValidIntersection) {\n+                continue;\n+            }\n+\n+            if (isDistinctType) {\n+                ((BErrorType) potentialIntersectionType).typeIdSet = BTypeIdSet.from(\n+                        potentialIntersectionType.tsymbol.pkgID, typeDefinition.name.value, isPublicType,\n+                        secondaryTypeIds);\n+            }\n+\n+            LinkedHashSet<BType> constituentBTypes = new LinkedHashSet<>() {{\n+                add(typeOne);\n+                add(typeTwo);\n+            }};\n+            BIntersectionType intersectionType = definePotentialIntersectionType((BErrorType) potentialIntersectionType,\n+                                                                                 typeDefinition, constituentBTypes);\n+            typeDefinition.symbol = intersectionType.tsymbol;\n+            typeDefinition.typeNode.type = intersectionType;\n+        }\n+    }\n+\n+    private void populateSecondaryTypeIdSet(Set<BTypeIdSet.BTypeId> secondaryTypeIds, BErrorType typeOne) {\n+        secondaryTypeIds.addAll(typeOne.typeIdSet.primary);\n+        secondaryTypeIds.addAll(typeOne.typeIdSet.secondary);\n+    }\n+\n+    private BIntersectionType definePotentialIntersectionType(BErrorType potentialIntersectionType,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10014b1a8708eeb074e7e82463fb840ab008faf6"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ4NTQzMw==", "bodyText": "fixed", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#discussion_r521485433", "createdAt": "2020-11-11T16:34:52Z", "author": {"login": "dulvinw"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/SymbolEnter.java", "diffHunk": "@@ -397,6 +406,170 @@ private void defineConstructs(BLangPackage pkgNode, SymbolEnv pkgEnv) {\n                 .forEach(varSymbol -> varSymbol.tag = SymTag.ENDPOINT);\n     }\n \n+    private void defineErrorIntersection(SymbolEnv env) {\n+        for (BLangNode typeDescriptor : this.errorIntersectionTypes) {\n+            BLangTypeDefinition typeDefinition = (BLangTypeDefinition) typeDescriptor;\n+\n+            boolean isDistinctType = isDistinctFlagPresent(typeDefinition);\n+            boolean isPublicType = typeDefinition.flagSet.contains(Flag.PUBLIC);\n+            Set<BTypeIdSet.BTypeId> secondaryTypeIds = new HashSet<>();\n+\n+            BLangIntersectionTypeNode intersectionTypeNode = (BLangIntersectionTypeNode) typeDefinition.typeNode;\n+            List<BLangType> constituentTypes = intersectionTypeNode.constituentTypeNodes;\n+\n+            BLangType bLangTypeOne = constituentTypes.get(0);\n+            BType typeOne = symResolver.resolveTypeNode(bLangTypeOne, env);\n+            if (typeOne.tag != TypeTags.ERROR && typeOne.tag != TypeTags.READONLY) {\n+                dlog.error(bLangTypeOne.pos, INVALID_ERROR_INTERSECTION, bLangTypeOne);\n+                continue;\n+            }\n+\n+            BLangType bLangTypeTwo = constituentTypes.get(1);\n+            BType typeTwo = symResolver.resolveTypeNode(bLangTypeTwo, env);\n+            if (typeTwo.tag != TypeTags.ERROR && typeTwo.tag != TypeTags.READONLY) {\n+                dlog.error(bLangTypeTwo.pos, INVALID_ERROR_INTERSECTION, bLangTypeTwo);\n+                continue;\n+            }\n+\n+            // Collecting typeIds.\n+            if (typeOne.tag != TypeTags.READONLY) {\n+                populateSecondaryTypeIdSet(secondaryTypeIds, (BErrorType) typeOne);\n+            }\n+            if (typeTwo.tag != TypeTags.READONLY) {\n+                populateSecondaryTypeIdSet(secondaryTypeIds, (BErrorType) typeTwo);\n+            }\n+\n+            BType potentialIntersectionType = types.getTypeIntersection(typeOne, typeTwo);\n+\n+            boolean isValidIntersection = true;\n+            for (int i = 2; i < constituentTypes.size(); i++) {\n+                BLangType bLangType = constituentTypes.get(i);\n+                BType bType = symResolver.resolveTypeNode(bLangType, env);\n+\n+                if (bType.getKind() != TypeKind.ERROR && typeTwo.tag != TypeTags.READONLY) {\n+                    dlog.error(bLangType.pos, INVALID_ERROR_INTERSECTION, bLangType);\n+                    isValidIntersection = false;\n+                    break;\n+                }\n+\n+                if (bType.tag != TypeTags.READONLY) {\n+                    populateSecondaryTypeIdSet(secondaryTypeIds, (BErrorType) bType);\n+                }\n+\n+                potentialIntersectionType = types.getTypeIntersection(potentialIntersectionType, bType);\n+                if (potentialIntersectionType == symTable.semanticError) {\n+                    dlog.error(typeDefinition.typeNode.pos, INVALID_INTERSECTION_TYPE, typeDefinition.typeNode);\n+                    isValidIntersection = false;\n+                    break;\n+                }\n+            }\n+\n+            if (!isValidIntersection) {\n+                continue;\n+            }\n+\n+            if (isDistinctType) {\n+                ((BErrorType) potentialIntersectionType).typeIdSet = BTypeIdSet.from(\n+                        potentialIntersectionType.tsymbol.pkgID, typeDefinition.name.value, isPublicType,\n+                        secondaryTypeIds);\n+            }\n+\n+            LinkedHashSet<BType> constituentBTypes = new LinkedHashSet<>() {{\n+                add(typeOne);\n+                add(typeTwo);\n+            }};\n+            BIntersectionType intersectionType = definePotentialIntersectionType((BErrorType) potentialIntersectionType,\n+                                                                                 typeDefinition, constituentBTypes);\n+            typeDefinition.symbol = intersectionType.tsymbol;\n+            typeDefinition.typeNode.type = intersectionType;\n+        }\n+    }\n+\n+    private void populateSecondaryTypeIdSet(Set<BTypeIdSet.BTypeId> secondaryTypeIds, BErrorType typeOne) {\n+        secondaryTypeIds.addAll(typeOne.typeIdSet.primary);\n+        secondaryTypeIds.addAll(typeOne.typeIdSet.secondary);\n+    }\n+\n+    private BIntersectionType definePotentialIntersectionType(BErrorType potentialIntersectionType,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTE1Nzc0OA=="}, "originalCommit": {"oid": "10014b1a8708eeb074e7e82463fb840ab008faf6"}, "originalPosition": 148}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2NzIxNTQzOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/SymbolEnter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwNzoyMzo0NVrOHxBUrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxNjozMzo0OFrOHxU5CA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTE2Mzk0OQ==", "bodyText": "Crashes when potentialIntersectionType is symTable.semanticError due to one error type being invalid.\ntype Detail record {| // closed, invalid\n    string x;\n|};\n\ntype DetailTwo record {\n    string y;\n};\n\ntype ErrorOne error<Detail>;\n\ntype ErrorTwo error<DetailTwo>;\n\ntype IntersectionError ErrorOne & ErrorTwo;\n[2020-11-11 12:52:48,270] SEVERE {b7a.log.crash} - class org.wso2.ballerinalang.compiler.semantics.model.types.BType cannot be cast to class org.wso2.ballerinalang.compiler.semantics.model.types.BErrorType (org.wso2.ballerinalang.compiler.semantics.model.types.BType and org.wso2.ballerinalang.compiler.semantics.model.types.BErrorType are in unnamed module of loader 'app') \njava.lang.ClassCastException: class org.wso2.ballerinalang.compiler.semantics.model.types.BType cannot be cast to class org.wso2.ballerinalang.compiler.semantics.model.types.BErrorType (org.wso2.ballerinalang.compiler.semantics.model.types.BType and org.wso2.ballerinalang.compiler.semantics.model.types.BErrorType are in unnamed module of loader 'app')\n\tat org.wso2.ballerinalang.compiler.semantics.analyzer.SymbolEnter.defineErrorIntersection(SymbolEnter.java:479)\n\tat org.wso2.ballerinalang.compiler.semantics.analyzer.SymbolEnter.defineConstructs(SymbolEnter.java:373)\n\tat org.wso2.ballerinalang.compiler.semantics.analyzer.SymbolEnter.visit(SymbolEnter.java:287)\n\tat org.wso2.ballerinalang.compiler.tree.BLangPackage.accept(BLangPackage.java:163)\n\tat org.wso2.ballerinalang.compiler.semantics.analyzer.SymbolEnter.defineNode(SymbolEnter.java:249)\n\tat org.wso2.ballerinalang.compiler.semantics.analyzer.SymbolEnter.definePackage(SymbolEnter.java:242)\n\tat org.wso2.ballerinalang.compiler.PackageLoader.define(PackageLoader.java:464)\n\tat org.wso2.ballerinalang.compiler.PackageLoader.loadEntryPackage(PackageLoader.java:375)\n\tat org.wso2.ballerinalang.compiler.Compiler.compilePackages(Compiler.java:166)\n\tat org.wso2.ballerinalang.compiler.Compiler.compilePackage(Compiler.java:221)\n\tat org.wso2.ballerinalang.compiler.Compiler.compile(Compiler.java:101)\n\tat org.wso2.ballerinalang.compiler.Compiler.build(Compiler.java:109)\n\tat org.ballerinalang.packerina.task.CompileTask.execute(CompileTask.java:55)\n\tat org.ballerinalang.packerina.TaskExecutor.executeTasks(TaskExecutor.java:38)\n\tat org.ballerinalang.packerina.cmd.RunCommand.execute(RunCommand.java:297)\n\tat java.base/java.util.Optional.ifPresent(Optional.java:183)\n\tat org.ballerinalang.tool.Main.main(Main.java:57)", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#discussion_r521163949", "createdAt": "2020-11-11T07:23:45Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/SymbolEnter.java", "diffHunk": "@@ -397,6 +406,170 @@ private void defineConstructs(BLangPackage pkgNode, SymbolEnv pkgEnv) {\n                 .forEach(varSymbol -> varSymbol.tag = SymTag.ENDPOINT);\n     }\n \n+    private void defineErrorIntersection(SymbolEnv env) {\n+        for (BLangNode typeDescriptor : this.errorIntersectionTypes) {\n+            BLangTypeDefinition typeDefinition = (BLangTypeDefinition) typeDescriptor;\n+\n+            boolean isDistinctType = isDistinctFlagPresent(typeDefinition);\n+            boolean isPublicType = typeDefinition.flagSet.contains(Flag.PUBLIC);\n+            Set<BTypeIdSet.BTypeId> secondaryTypeIds = new HashSet<>();\n+\n+            BLangIntersectionTypeNode intersectionTypeNode = (BLangIntersectionTypeNode) typeDefinition.typeNode;\n+            List<BLangType> constituentTypes = intersectionTypeNode.constituentTypeNodes;\n+\n+            BLangType bLangTypeOne = constituentTypes.get(0);\n+            BType typeOne = symResolver.resolveTypeNode(bLangTypeOne, env);\n+            if (typeOne.tag != TypeTags.ERROR && typeOne.tag != TypeTags.READONLY) {\n+                dlog.error(bLangTypeOne.pos, INVALID_ERROR_INTERSECTION, bLangTypeOne);\n+                continue;\n+            }\n+\n+            BLangType bLangTypeTwo = constituentTypes.get(1);\n+            BType typeTwo = symResolver.resolveTypeNode(bLangTypeTwo, env);\n+            if (typeTwo.tag != TypeTags.ERROR && typeTwo.tag != TypeTags.READONLY) {\n+                dlog.error(bLangTypeTwo.pos, INVALID_ERROR_INTERSECTION, bLangTypeTwo);\n+                continue;\n+            }\n+\n+            // Collecting typeIds.\n+            if (typeOne.tag != TypeTags.READONLY) {\n+                populateSecondaryTypeIdSet(secondaryTypeIds, (BErrorType) typeOne);\n+            }\n+            if (typeTwo.tag != TypeTags.READONLY) {\n+                populateSecondaryTypeIdSet(secondaryTypeIds, (BErrorType) typeTwo);\n+            }\n+\n+            BType potentialIntersectionType = types.getTypeIntersection(typeOne, typeTwo);\n+\n+            boolean isValidIntersection = true;\n+            for (int i = 2; i < constituentTypes.size(); i++) {\n+                BLangType bLangType = constituentTypes.get(i);\n+                BType bType = symResolver.resolveTypeNode(bLangType, env);\n+\n+                if (bType.getKind() != TypeKind.ERROR && typeTwo.tag != TypeTags.READONLY) {\n+                    dlog.error(bLangType.pos, INVALID_ERROR_INTERSECTION, bLangType);\n+                    isValidIntersection = false;\n+                    break;\n+                }\n+\n+                if (bType.tag != TypeTags.READONLY) {\n+                    populateSecondaryTypeIdSet(secondaryTypeIds, (BErrorType) bType);\n+                }\n+\n+                potentialIntersectionType = types.getTypeIntersection(potentialIntersectionType, bType);\n+                if (potentialIntersectionType == symTable.semanticError) {\n+                    dlog.error(typeDefinition.typeNode.pos, INVALID_INTERSECTION_TYPE, typeDefinition.typeNode);\n+                    isValidIntersection = false;\n+                    break;\n+                }\n+            }\n+\n+            if (!isValidIntersection) {\n+                continue;\n+            }\n+\n+            if (isDistinctType) {\n+                ((BErrorType) potentialIntersectionType).typeIdSet = BTypeIdSet.from(\n+                        potentialIntersectionType.tsymbol.pkgID, typeDefinition.name.value, isPublicType,\n+                        secondaryTypeIds);\n+            }\n+\n+            LinkedHashSet<BType> constituentBTypes = new LinkedHashSet<>() {{\n+                add(typeOne);\n+                add(typeTwo);\n+            }};\n+            BIntersectionType intersectionType = definePotentialIntersectionType((BErrorType) potentialIntersectionType,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10014b1a8708eeb074e7e82463fb840ab008faf6"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ4NDU1Mg==", "bodyText": "Fixed", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#discussion_r521484552", "createdAt": "2020-11-11T16:33:48Z", "author": {"login": "dulvinw"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/SymbolEnter.java", "diffHunk": "@@ -397,6 +406,170 @@ private void defineConstructs(BLangPackage pkgNode, SymbolEnv pkgEnv) {\n                 .forEach(varSymbol -> varSymbol.tag = SymTag.ENDPOINT);\n     }\n \n+    private void defineErrorIntersection(SymbolEnv env) {\n+        for (BLangNode typeDescriptor : this.errorIntersectionTypes) {\n+            BLangTypeDefinition typeDefinition = (BLangTypeDefinition) typeDescriptor;\n+\n+            boolean isDistinctType = isDistinctFlagPresent(typeDefinition);\n+            boolean isPublicType = typeDefinition.flagSet.contains(Flag.PUBLIC);\n+            Set<BTypeIdSet.BTypeId> secondaryTypeIds = new HashSet<>();\n+\n+            BLangIntersectionTypeNode intersectionTypeNode = (BLangIntersectionTypeNode) typeDefinition.typeNode;\n+            List<BLangType> constituentTypes = intersectionTypeNode.constituentTypeNodes;\n+\n+            BLangType bLangTypeOne = constituentTypes.get(0);\n+            BType typeOne = symResolver.resolveTypeNode(bLangTypeOne, env);\n+            if (typeOne.tag != TypeTags.ERROR && typeOne.tag != TypeTags.READONLY) {\n+                dlog.error(bLangTypeOne.pos, INVALID_ERROR_INTERSECTION, bLangTypeOne);\n+                continue;\n+            }\n+\n+            BLangType bLangTypeTwo = constituentTypes.get(1);\n+            BType typeTwo = symResolver.resolveTypeNode(bLangTypeTwo, env);\n+            if (typeTwo.tag != TypeTags.ERROR && typeTwo.tag != TypeTags.READONLY) {\n+                dlog.error(bLangTypeTwo.pos, INVALID_ERROR_INTERSECTION, bLangTypeTwo);\n+                continue;\n+            }\n+\n+            // Collecting typeIds.\n+            if (typeOne.tag != TypeTags.READONLY) {\n+                populateSecondaryTypeIdSet(secondaryTypeIds, (BErrorType) typeOne);\n+            }\n+            if (typeTwo.tag != TypeTags.READONLY) {\n+                populateSecondaryTypeIdSet(secondaryTypeIds, (BErrorType) typeTwo);\n+            }\n+\n+            BType potentialIntersectionType = types.getTypeIntersection(typeOne, typeTwo);\n+\n+            boolean isValidIntersection = true;\n+            for (int i = 2; i < constituentTypes.size(); i++) {\n+                BLangType bLangType = constituentTypes.get(i);\n+                BType bType = symResolver.resolveTypeNode(bLangType, env);\n+\n+                if (bType.getKind() != TypeKind.ERROR && typeTwo.tag != TypeTags.READONLY) {\n+                    dlog.error(bLangType.pos, INVALID_ERROR_INTERSECTION, bLangType);\n+                    isValidIntersection = false;\n+                    break;\n+                }\n+\n+                if (bType.tag != TypeTags.READONLY) {\n+                    populateSecondaryTypeIdSet(secondaryTypeIds, (BErrorType) bType);\n+                }\n+\n+                potentialIntersectionType = types.getTypeIntersection(potentialIntersectionType, bType);\n+                if (potentialIntersectionType == symTable.semanticError) {\n+                    dlog.error(typeDefinition.typeNode.pos, INVALID_INTERSECTION_TYPE, typeDefinition.typeNode);\n+                    isValidIntersection = false;\n+                    break;\n+                }\n+            }\n+\n+            if (!isValidIntersection) {\n+                continue;\n+            }\n+\n+            if (isDistinctType) {\n+                ((BErrorType) potentialIntersectionType).typeIdSet = BTypeIdSet.from(\n+                        potentialIntersectionType.tsymbol.pkgID, typeDefinition.name.value, isPublicType,\n+                        secondaryTypeIds);\n+            }\n+\n+            LinkedHashSet<BType> constituentBTypes = new LinkedHashSet<>() {{\n+                add(typeOne);\n+                add(typeTwo);\n+            }};\n+            BIntersectionType intersectionType = definePotentialIntersectionType((BErrorType) potentialIntersectionType,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTE2Mzk0OQ=="}, "originalCommit": {"oid": "10014b1a8708eeb074e7e82463fb840ab008faf6"}, "originalPosition": 136}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2NzM4MjIzOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwODoyMToxOFrOHxC4QQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxNjozNDoyOFrOHxU7cw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTE4OTQ0MQ==", "bodyText": "Don't we have to validate/fix types for already specified fields with the same name?\nLeads to issues like #26770 (comment)\nand\ntype Detail record {\n    string x;\n};\n\ntype DetailTwo record {|\n    int x?;\n    string...;\n|};\n\ntype ErrorOne error<Detail>;\n\ntype ErrorTwo error<DetailTwo>;\n\ntype IntersectionError ErrorOne & ErrorTwo;\n\npublic function main() {\n    var err1 = IntersectionError(\"message\", x = \"x\"); // invalid arg type in error detail field 'x', expected 'int', found 'string'\n    var err2 = IntersectionError(\"message\", x = 1); // works\n}", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#discussion_r521189441", "createdAt": "2020-11-11T08:21:18Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -3129,6 +3168,131 @@ BType getTypeIntersection(BType lhsType, BType rhsType) {\n         }\n     }\n \n+    private BType getIntersectionForErrorTypes(BType lhsType, BType rhsType) {\n+\n+        BType detailTypeOne = ((BErrorType) lhsType).detailType;\n+        BType detailTypeTwo = ((BErrorType) rhsType).detailType;\n+\n+        if (isSealedRecord(detailTypeOne) || isSealedRecord(detailTypeTwo)) {\n+            return symTable.semanticError;\n+        }\n+\n+        SymbolEnv prevEnv = this.env;\n+        this.env = symTable.pkgEnvMap.get(lhsType.tsymbol.owner);\n+\n+        BType detailIntersectionType = getTypeIntersection(detailTypeOne, detailTypeTwo);\n+        if (detailIntersectionType == symTable.semanticError) {\n+            return symTable.semanticError;\n+        }\n+\n+        BErrorType intersectionErrorType = createErrorType(lhsType, rhsType, detailIntersectionType);\n+        this.env = prevEnv;\n+\n+        return intersectionErrorType;\n+    }\n+\n+    private BType createRecordIntersection(BType recordTypeOne, BType recordTypeTwo) {\n+\n+        BRecordType recordType = createAnonymousRecord();\n+\n+        populateRecordFields(recordType, recordTypeOne);\n+        populateRecordFields(recordType, recordTypeTwo);\n+\n+        recordType.restFieldType = getTypeIntersection(((BRecordType) recordTypeOne).restFieldType,\n+                                                       ((BRecordType) recordTypeTwo).restFieldType);\n+\n+        if (recordType.restFieldType == symTable.semanticError) {\n+            return symTable.semanticError;\n+        }\n+\n+        return recordType;\n+    }\n+\n+    private BRecordType createAnonymousRecord() {\n+        EnumSet<Flag> flags = EnumSet.of(Flag.PUBLIC, Flag.ANONYMOUS);\n+        BRecordTypeSymbol recordSymbol = Symbols.createRecordSymbol(Flags.asMask(flags), Names.EMPTY,\n+                                                                                this.env.enclPkg.packageID, null,\n+                                                                                this.env.scope.owner, null, VIRTUAL);\n+        recordSymbol.name = names.fromString(\n+                anonymousModelHelper.getNextAnonymousTypeKey(this.env.enclPkg.packageID));\n+        BInvokableType bInvokableType = new BInvokableType(new ArrayList<>(), symTable.nilType, null);\n+        BInvokableSymbol initFuncSymbol = Symbols.createFunctionSymbol(\n+                Flags.PUBLIC, Names.EMPTY, this.env.enclPkg.symbol.pkgID, bInvokableType, this.env.scope.owner, false,\n+                symTable.builtinPos, VIRTUAL);\n+        initFuncSymbol.retType = symTable.nilType;\n+        recordSymbol.initializerFunc = new BAttachedFunction(Names.INIT_FUNCTION_SUFFIX, initFuncSymbol,\n+                                                                         bInvokableType, symTable.builtinPos);\n+        recordSymbol.scope = new Scope(recordSymbol);\n+\n+        BRecordType recordType = new BRecordType(recordSymbol);\n+        recordType.tsymbol = recordSymbol;\n+        recordSymbol.type = recordType;\n+\n+        return recordType;\n+    }\n+\n+    private BType createRecordAndMapIntersection(BType type, BType mapType) {\n+        BRecordType intersectionRecord = createAnonymousRecord();\n+        populateRecordFields(intersectionRecord, type);\n+        intersectionRecord.restFieldType = getRestFieldIntersectionType(type, (BMapType) mapType);\n+\n+        if (intersectionRecord.restFieldType == symTable.semanticError) {\n+            return symTable.semanticError;\n+        }\n+\n+        return intersectionRecord;\n+    }\n+\n+    private BType getRestFieldIntersectionType(BType type, BMapType mapType) {\n+        if (type.tag == TypeTags.RECORD) {\n+            return getTypeIntersection(((BRecordType) type).restFieldType, mapType.constraint);\n+        } else {\n+            return getTypeIntersection(((BMapType) type).constraint, mapType.constraint);\n+        }\n+    }\n+\n+    private BErrorType createErrorType(BType lhsType, BType rhsType, BType detailType) {\n+        BErrorTypeSymbol errorTypeSymbol = Symbols.createErrorSymbol(lhsType.flags, Names.EMPTY,\n+                                                                     this.env.enclPkg.symbol.pkgID, null,\n+                                                                     this.env.scope.owner, null, VIRTUAL);\n+        errorTypeSymbol.flags |= rhsType.flags;\n+        BErrorType errorType = new BErrorType(errorTypeSymbol, detailType);\n+        errorType.flags |= errorTypeSymbol.flags;\n+        errorTypeSymbol.type = errorType;\n+        symResolver.markParameterizedType(errorType, detailType);\n+        errorType.typeIdSet = BTypeIdSet.emptySet();\n+\n+        return errorType;\n+    }\n+\n+    private void populateRecordFields(BRecordType recordType, BType originalType) {\n+        BTypeSymbol intersectionRecordSymbol = recordType.tsymbol;\n+        // If the detail type is BMapType simply ignore since the resulting detail type has `anydata` as rest type.\n+        if (originalType.getKind() != TypeKind.RECORD) {\n+            return;\n+        }\n+        BRecordType originalRecordType = (BRecordType) originalType;\n+        LinkedHashMap<String, BField> fields = new LinkedHashMap<>();\n+        for (BField origField : originalRecordType.fields.values()) {\n+            org.wso2.ballerinalang.compiler.util.Name origFieldName = origField.name;\n+            BType recordFieldType = origField.type;\n+            BVarSymbol recordFieldSymbol = new BVarSymbol(origField.symbol.flags, origFieldName,\n+                                                          this.env.enclPkg.packageID, recordFieldType,\n+                                                          intersectionRecordSymbol, origField.pos, SOURCE);\n+            if (recordFieldType.tag == TypeTags.INVOKABLE && recordFieldType.tsymbol != null) {\n+                BInvokableTypeSymbol tsymbol = (BInvokableTypeSymbol) recordFieldType.tsymbol;\n+                BInvokableSymbol invokableSymbol = (BInvokableSymbol) recordFieldSymbol;\n+                invokableSymbol.params = tsymbol.params;\n+                invokableSymbol.restParam = tsymbol.restParam;\n+                invokableSymbol.retType = tsymbol.returnType;\n+                invokableSymbol.flags = tsymbol.flags;\n+            }\n+            String nameString = origFieldName.value;\n+            fields.put(nameString, new BField(origFieldName, null, recordFieldSymbol));\n+        }\n+        recordType.fields.putAll(fields);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10014b1a8708eeb074e7e82463fb840ab008faf6"}, "originalPosition": 238}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTIyMTYzNA==", "bodyText": "I think I should do an additional check to handle this situation. And it should be an invalid intersection in that case right?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#discussion_r521221634", "createdAt": "2020-11-11T09:20:05Z", "author": {"login": "dulvinw"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -3129,6 +3168,131 @@ BType getTypeIntersection(BType lhsType, BType rhsType) {\n         }\n     }\n \n+    private BType getIntersectionForErrorTypes(BType lhsType, BType rhsType) {\n+\n+        BType detailTypeOne = ((BErrorType) lhsType).detailType;\n+        BType detailTypeTwo = ((BErrorType) rhsType).detailType;\n+\n+        if (isSealedRecord(detailTypeOne) || isSealedRecord(detailTypeTwo)) {\n+            return symTable.semanticError;\n+        }\n+\n+        SymbolEnv prevEnv = this.env;\n+        this.env = symTable.pkgEnvMap.get(lhsType.tsymbol.owner);\n+\n+        BType detailIntersectionType = getTypeIntersection(detailTypeOne, detailTypeTwo);\n+        if (detailIntersectionType == symTable.semanticError) {\n+            return symTable.semanticError;\n+        }\n+\n+        BErrorType intersectionErrorType = createErrorType(lhsType, rhsType, detailIntersectionType);\n+        this.env = prevEnv;\n+\n+        return intersectionErrorType;\n+    }\n+\n+    private BType createRecordIntersection(BType recordTypeOne, BType recordTypeTwo) {\n+\n+        BRecordType recordType = createAnonymousRecord();\n+\n+        populateRecordFields(recordType, recordTypeOne);\n+        populateRecordFields(recordType, recordTypeTwo);\n+\n+        recordType.restFieldType = getTypeIntersection(((BRecordType) recordTypeOne).restFieldType,\n+                                                       ((BRecordType) recordTypeTwo).restFieldType);\n+\n+        if (recordType.restFieldType == symTable.semanticError) {\n+            return symTable.semanticError;\n+        }\n+\n+        return recordType;\n+    }\n+\n+    private BRecordType createAnonymousRecord() {\n+        EnumSet<Flag> flags = EnumSet.of(Flag.PUBLIC, Flag.ANONYMOUS);\n+        BRecordTypeSymbol recordSymbol = Symbols.createRecordSymbol(Flags.asMask(flags), Names.EMPTY,\n+                                                                                this.env.enclPkg.packageID, null,\n+                                                                                this.env.scope.owner, null, VIRTUAL);\n+        recordSymbol.name = names.fromString(\n+                anonymousModelHelper.getNextAnonymousTypeKey(this.env.enclPkg.packageID));\n+        BInvokableType bInvokableType = new BInvokableType(new ArrayList<>(), symTable.nilType, null);\n+        BInvokableSymbol initFuncSymbol = Symbols.createFunctionSymbol(\n+                Flags.PUBLIC, Names.EMPTY, this.env.enclPkg.symbol.pkgID, bInvokableType, this.env.scope.owner, false,\n+                symTable.builtinPos, VIRTUAL);\n+        initFuncSymbol.retType = symTable.nilType;\n+        recordSymbol.initializerFunc = new BAttachedFunction(Names.INIT_FUNCTION_SUFFIX, initFuncSymbol,\n+                                                                         bInvokableType, symTable.builtinPos);\n+        recordSymbol.scope = new Scope(recordSymbol);\n+\n+        BRecordType recordType = new BRecordType(recordSymbol);\n+        recordType.tsymbol = recordSymbol;\n+        recordSymbol.type = recordType;\n+\n+        return recordType;\n+    }\n+\n+    private BType createRecordAndMapIntersection(BType type, BType mapType) {\n+        BRecordType intersectionRecord = createAnonymousRecord();\n+        populateRecordFields(intersectionRecord, type);\n+        intersectionRecord.restFieldType = getRestFieldIntersectionType(type, (BMapType) mapType);\n+\n+        if (intersectionRecord.restFieldType == symTable.semanticError) {\n+            return symTable.semanticError;\n+        }\n+\n+        return intersectionRecord;\n+    }\n+\n+    private BType getRestFieldIntersectionType(BType type, BMapType mapType) {\n+        if (type.tag == TypeTags.RECORD) {\n+            return getTypeIntersection(((BRecordType) type).restFieldType, mapType.constraint);\n+        } else {\n+            return getTypeIntersection(((BMapType) type).constraint, mapType.constraint);\n+        }\n+    }\n+\n+    private BErrorType createErrorType(BType lhsType, BType rhsType, BType detailType) {\n+        BErrorTypeSymbol errorTypeSymbol = Symbols.createErrorSymbol(lhsType.flags, Names.EMPTY,\n+                                                                     this.env.enclPkg.symbol.pkgID, null,\n+                                                                     this.env.scope.owner, null, VIRTUAL);\n+        errorTypeSymbol.flags |= rhsType.flags;\n+        BErrorType errorType = new BErrorType(errorTypeSymbol, detailType);\n+        errorType.flags |= errorTypeSymbol.flags;\n+        errorTypeSymbol.type = errorType;\n+        symResolver.markParameterizedType(errorType, detailType);\n+        errorType.typeIdSet = BTypeIdSet.emptySet();\n+\n+        return errorType;\n+    }\n+\n+    private void populateRecordFields(BRecordType recordType, BType originalType) {\n+        BTypeSymbol intersectionRecordSymbol = recordType.tsymbol;\n+        // If the detail type is BMapType simply ignore since the resulting detail type has `anydata` as rest type.\n+        if (originalType.getKind() != TypeKind.RECORD) {\n+            return;\n+        }\n+        BRecordType originalRecordType = (BRecordType) originalType;\n+        LinkedHashMap<String, BField> fields = new LinkedHashMap<>();\n+        for (BField origField : originalRecordType.fields.values()) {\n+            org.wso2.ballerinalang.compiler.util.Name origFieldName = origField.name;\n+            BType recordFieldType = origField.type;\n+            BVarSymbol recordFieldSymbol = new BVarSymbol(origField.symbol.flags, origFieldName,\n+                                                          this.env.enclPkg.packageID, recordFieldType,\n+                                                          intersectionRecordSymbol, origField.pos, SOURCE);\n+            if (recordFieldType.tag == TypeTags.INVOKABLE && recordFieldType.tsymbol != null) {\n+                BInvokableTypeSymbol tsymbol = (BInvokableTypeSymbol) recordFieldType.tsymbol;\n+                BInvokableSymbol invokableSymbol = (BInvokableSymbol) recordFieldSymbol;\n+                invokableSymbol.params = tsymbol.params;\n+                invokableSymbol.restParam = tsymbol.restParam;\n+                invokableSymbol.retType = tsymbol.returnType;\n+                invokableSymbol.flags = tsymbol.flags;\n+            }\n+            String nameString = origFieldName.value;\n+            fields.put(nameString, new BField(origFieldName, null, recordFieldSymbol));\n+        }\n+        recordType.fields.putAll(fields);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTE4OTQ0MQ=="}, "originalCommit": {"oid": "10014b1a8708eeb074e7e82463fb840ab008faf6"}, "originalPosition": 238}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTM3Mjg4NA==", "bodyText": "Yeah, it's invalid.\nI think if the field is there we should check for the intersection between the already present type and this new type, and\n\nmake it an error if there is no intersection\nif there is an intersection - set the intersection type as the field type", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#discussion_r521372884", "createdAt": "2020-11-11T13:53:41Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -3129,6 +3168,131 @@ BType getTypeIntersection(BType lhsType, BType rhsType) {\n         }\n     }\n \n+    private BType getIntersectionForErrorTypes(BType lhsType, BType rhsType) {\n+\n+        BType detailTypeOne = ((BErrorType) lhsType).detailType;\n+        BType detailTypeTwo = ((BErrorType) rhsType).detailType;\n+\n+        if (isSealedRecord(detailTypeOne) || isSealedRecord(detailTypeTwo)) {\n+            return symTable.semanticError;\n+        }\n+\n+        SymbolEnv prevEnv = this.env;\n+        this.env = symTable.pkgEnvMap.get(lhsType.tsymbol.owner);\n+\n+        BType detailIntersectionType = getTypeIntersection(detailTypeOne, detailTypeTwo);\n+        if (detailIntersectionType == symTable.semanticError) {\n+            return symTable.semanticError;\n+        }\n+\n+        BErrorType intersectionErrorType = createErrorType(lhsType, rhsType, detailIntersectionType);\n+        this.env = prevEnv;\n+\n+        return intersectionErrorType;\n+    }\n+\n+    private BType createRecordIntersection(BType recordTypeOne, BType recordTypeTwo) {\n+\n+        BRecordType recordType = createAnonymousRecord();\n+\n+        populateRecordFields(recordType, recordTypeOne);\n+        populateRecordFields(recordType, recordTypeTwo);\n+\n+        recordType.restFieldType = getTypeIntersection(((BRecordType) recordTypeOne).restFieldType,\n+                                                       ((BRecordType) recordTypeTwo).restFieldType);\n+\n+        if (recordType.restFieldType == symTable.semanticError) {\n+            return symTable.semanticError;\n+        }\n+\n+        return recordType;\n+    }\n+\n+    private BRecordType createAnonymousRecord() {\n+        EnumSet<Flag> flags = EnumSet.of(Flag.PUBLIC, Flag.ANONYMOUS);\n+        BRecordTypeSymbol recordSymbol = Symbols.createRecordSymbol(Flags.asMask(flags), Names.EMPTY,\n+                                                                                this.env.enclPkg.packageID, null,\n+                                                                                this.env.scope.owner, null, VIRTUAL);\n+        recordSymbol.name = names.fromString(\n+                anonymousModelHelper.getNextAnonymousTypeKey(this.env.enclPkg.packageID));\n+        BInvokableType bInvokableType = new BInvokableType(new ArrayList<>(), symTable.nilType, null);\n+        BInvokableSymbol initFuncSymbol = Symbols.createFunctionSymbol(\n+                Flags.PUBLIC, Names.EMPTY, this.env.enclPkg.symbol.pkgID, bInvokableType, this.env.scope.owner, false,\n+                symTable.builtinPos, VIRTUAL);\n+        initFuncSymbol.retType = symTable.nilType;\n+        recordSymbol.initializerFunc = new BAttachedFunction(Names.INIT_FUNCTION_SUFFIX, initFuncSymbol,\n+                                                                         bInvokableType, symTable.builtinPos);\n+        recordSymbol.scope = new Scope(recordSymbol);\n+\n+        BRecordType recordType = new BRecordType(recordSymbol);\n+        recordType.tsymbol = recordSymbol;\n+        recordSymbol.type = recordType;\n+\n+        return recordType;\n+    }\n+\n+    private BType createRecordAndMapIntersection(BType type, BType mapType) {\n+        BRecordType intersectionRecord = createAnonymousRecord();\n+        populateRecordFields(intersectionRecord, type);\n+        intersectionRecord.restFieldType = getRestFieldIntersectionType(type, (BMapType) mapType);\n+\n+        if (intersectionRecord.restFieldType == symTable.semanticError) {\n+            return symTable.semanticError;\n+        }\n+\n+        return intersectionRecord;\n+    }\n+\n+    private BType getRestFieldIntersectionType(BType type, BMapType mapType) {\n+        if (type.tag == TypeTags.RECORD) {\n+            return getTypeIntersection(((BRecordType) type).restFieldType, mapType.constraint);\n+        } else {\n+            return getTypeIntersection(((BMapType) type).constraint, mapType.constraint);\n+        }\n+    }\n+\n+    private BErrorType createErrorType(BType lhsType, BType rhsType, BType detailType) {\n+        BErrorTypeSymbol errorTypeSymbol = Symbols.createErrorSymbol(lhsType.flags, Names.EMPTY,\n+                                                                     this.env.enclPkg.symbol.pkgID, null,\n+                                                                     this.env.scope.owner, null, VIRTUAL);\n+        errorTypeSymbol.flags |= rhsType.flags;\n+        BErrorType errorType = new BErrorType(errorTypeSymbol, detailType);\n+        errorType.flags |= errorTypeSymbol.flags;\n+        errorTypeSymbol.type = errorType;\n+        symResolver.markParameterizedType(errorType, detailType);\n+        errorType.typeIdSet = BTypeIdSet.emptySet();\n+\n+        return errorType;\n+    }\n+\n+    private void populateRecordFields(BRecordType recordType, BType originalType) {\n+        BTypeSymbol intersectionRecordSymbol = recordType.tsymbol;\n+        // If the detail type is BMapType simply ignore since the resulting detail type has `anydata` as rest type.\n+        if (originalType.getKind() != TypeKind.RECORD) {\n+            return;\n+        }\n+        BRecordType originalRecordType = (BRecordType) originalType;\n+        LinkedHashMap<String, BField> fields = new LinkedHashMap<>();\n+        for (BField origField : originalRecordType.fields.values()) {\n+            org.wso2.ballerinalang.compiler.util.Name origFieldName = origField.name;\n+            BType recordFieldType = origField.type;\n+            BVarSymbol recordFieldSymbol = new BVarSymbol(origField.symbol.flags, origFieldName,\n+                                                          this.env.enclPkg.packageID, recordFieldType,\n+                                                          intersectionRecordSymbol, origField.pos, SOURCE);\n+            if (recordFieldType.tag == TypeTags.INVOKABLE && recordFieldType.tsymbol != null) {\n+                BInvokableTypeSymbol tsymbol = (BInvokableTypeSymbol) recordFieldType.tsymbol;\n+                BInvokableSymbol invokableSymbol = (BInvokableSymbol) recordFieldSymbol;\n+                invokableSymbol.params = tsymbol.params;\n+                invokableSymbol.restParam = tsymbol.restParam;\n+                invokableSymbol.retType = tsymbol.returnType;\n+                invokableSymbol.flags = tsymbol.flags;\n+            }\n+            String nameString = origFieldName.value;\n+            fields.put(nameString, new BField(origFieldName, null, recordFieldSymbol));\n+        }\n+        recordType.fields.putAll(fields);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTE4OTQ0MQ=="}, "originalCommit": {"oid": "10014b1a8708eeb074e7e82463fb840ab008faf6"}, "originalPosition": 238}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ4NTE3MQ==", "bodyText": "Fixed", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#discussion_r521485171", "createdAt": "2020-11-11T16:34:28Z", "author": {"login": "dulvinw"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -3129,6 +3168,131 @@ BType getTypeIntersection(BType lhsType, BType rhsType) {\n         }\n     }\n \n+    private BType getIntersectionForErrorTypes(BType lhsType, BType rhsType) {\n+\n+        BType detailTypeOne = ((BErrorType) lhsType).detailType;\n+        BType detailTypeTwo = ((BErrorType) rhsType).detailType;\n+\n+        if (isSealedRecord(detailTypeOne) || isSealedRecord(detailTypeTwo)) {\n+            return symTable.semanticError;\n+        }\n+\n+        SymbolEnv prevEnv = this.env;\n+        this.env = symTable.pkgEnvMap.get(lhsType.tsymbol.owner);\n+\n+        BType detailIntersectionType = getTypeIntersection(detailTypeOne, detailTypeTwo);\n+        if (detailIntersectionType == symTable.semanticError) {\n+            return symTable.semanticError;\n+        }\n+\n+        BErrorType intersectionErrorType = createErrorType(lhsType, rhsType, detailIntersectionType);\n+        this.env = prevEnv;\n+\n+        return intersectionErrorType;\n+    }\n+\n+    private BType createRecordIntersection(BType recordTypeOne, BType recordTypeTwo) {\n+\n+        BRecordType recordType = createAnonymousRecord();\n+\n+        populateRecordFields(recordType, recordTypeOne);\n+        populateRecordFields(recordType, recordTypeTwo);\n+\n+        recordType.restFieldType = getTypeIntersection(((BRecordType) recordTypeOne).restFieldType,\n+                                                       ((BRecordType) recordTypeTwo).restFieldType);\n+\n+        if (recordType.restFieldType == symTable.semanticError) {\n+            return symTable.semanticError;\n+        }\n+\n+        return recordType;\n+    }\n+\n+    private BRecordType createAnonymousRecord() {\n+        EnumSet<Flag> flags = EnumSet.of(Flag.PUBLIC, Flag.ANONYMOUS);\n+        BRecordTypeSymbol recordSymbol = Symbols.createRecordSymbol(Flags.asMask(flags), Names.EMPTY,\n+                                                                                this.env.enclPkg.packageID, null,\n+                                                                                this.env.scope.owner, null, VIRTUAL);\n+        recordSymbol.name = names.fromString(\n+                anonymousModelHelper.getNextAnonymousTypeKey(this.env.enclPkg.packageID));\n+        BInvokableType bInvokableType = new BInvokableType(new ArrayList<>(), symTable.nilType, null);\n+        BInvokableSymbol initFuncSymbol = Symbols.createFunctionSymbol(\n+                Flags.PUBLIC, Names.EMPTY, this.env.enclPkg.symbol.pkgID, bInvokableType, this.env.scope.owner, false,\n+                symTable.builtinPos, VIRTUAL);\n+        initFuncSymbol.retType = symTable.nilType;\n+        recordSymbol.initializerFunc = new BAttachedFunction(Names.INIT_FUNCTION_SUFFIX, initFuncSymbol,\n+                                                                         bInvokableType, symTable.builtinPos);\n+        recordSymbol.scope = new Scope(recordSymbol);\n+\n+        BRecordType recordType = new BRecordType(recordSymbol);\n+        recordType.tsymbol = recordSymbol;\n+        recordSymbol.type = recordType;\n+\n+        return recordType;\n+    }\n+\n+    private BType createRecordAndMapIntersection(BType type, BType mapType) {\n+        BRecordType intersectionRecord = createAnonymousRecord();\n+        populateRecordFields(intersectionRecord, type);\n+        intersectionRecord.restFieldType = getRestFieldIntersectionType(type, (BMapType) mapType);\n+\n+        if (intersectionRecord.restFieldType == symTable.semanticError) {\n+            return symTable.semanticError;\n+        }\n+\n+        return intersectionRecord;\n+    }\n+\n+    private BType getRestFieldIntersectionType(BType type, BMapType mapType) {\n+        if (type.tag == TypeTags.RECORD) {\n+            return getTypeIntersection(((BRecordType) type).restFieldType, mapType.constraint);\n+        } else {\n+            return getTypeIntersection(((BMapType) type).constraint, mapType.constraint);\n+        }\n+    }\n+\n+    private BErrorType createErrorType(BType lhsType, BType rhsType, BType detailType) {\n+        BErrorTypeSymbol errorTypeSymbol = Symbols.createErrorSymbol(lhsType.flags, Names.EMPTY,\n+                                                                     this.env.enclPkg.symbol.pkgID, null,\n+                                                                     this.env.scope.owner, null, VIRTUAL);\n+        errorTypeSymbol.flags |= rhsType.flags;\n+        BErrorType errorType = new BErrorType(errorTypeSymbol, detailType);\n+        errorType.flags |= errorTypeSymbol.flags;\n+        errorTypeSymbol.type = errorType;\n+        symResolver.markParameterizedType(errorType, detailType);\n+        errorType.typeIdSet = BTypeIdSet.emptySet();\n+\n+        return errorType;\n+    }\n+\n+    private void populateRecordFields(BRecordType recordType, BType originalType) {\n+        BTypeSymbol intersectionRecordSymbol = recordType.tsymbol;\n+        // If the detail type is BMapType simply ignore since the resulting detail type has `anydata` as rest type.\n+        if (originalType.getKind() != TypeKind.RECORD) {\n+            return;\n+        }\n+        BRecordType originalRecordType = (BRecordType) originalType;\n+        LinkedHashMap<String, BField> fields = new LinkedHashMap<>();\n+        for (BField origField : originalRecordType.fields.values()) {\n+            org.wso2.ballerinalang.compiler.util.Name origFieldName = origField.name;\n+            BType recordFieldType = origField.type;\n+            BVarSymbol recordFieldSymbol = new BVarSymbol(origField.symbol.flags, origFieldName,\n+                                                          this.env.enclPkg.packageID, recordFieldType,\n+                                                          intersectionRecordSymbol, origField.pos, SOURCE);\n+            if (recordFieldType.tag == TypeTags.INVOKABLE && recordFieldType.tsymbol != null) {\n+                BInvokableTypeSymbol tsymbol = (BInvokableTypeSymbol) recordFieldType.tsymbol;\n+                BInvokableSymbol invokableSymbol = (BInvokableSymbol) recordFieldSymbol;\n+                invokableSymbol.params = tsymbol.params;\n+                invokableSymbol.restParam = tsymbol.restParam;\n+                invokableSymbol.retType = tsymbol.returnType;\n+                invokableSymbol.flags = tsymbol.flags;\n+            }\n+            String nameString = origFieldName.value;\n+            fields.put(nameString, new BField(origFieldName, null, recordFieldSymbol));\n+        }\n+        recordType.fields.putAll(fields);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTE4OTQ0MQ=="}, "originalCommit": {"oid": "10014b1a8708eeb074e7e82463fb840ab008faf6"}, "originalPosition": 238}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2ODQ0OTIwOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxMzoyNjowNVrOHxNDOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxODo0MzowMFrOHxZxfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTM1NjA5MQ==", "bodyText": "Given that Types.java is like a stateless util class I'm not sure if we should maintain the env like this.\nRaised the same in @KavinduZoysa's PR too - https://github.com/ballerina-platform/ballerina-lang/pull/26144/files#r520295821.\nI think we'll have to refactor getTypeIntersection to accept env too.\nAlso, regarding the RHS here, IMO getting the env of lhsType.tsymbol.owner won't quite be the correct approach if lhsType is from an imported module, right? Shouldn't it always be the current module?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#discussion_r521356091", "createdAt": "2020-11-11T13:26:05Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -3129,6 +3168,131 @@ BType getTypeIntersection(BType lhsType, BType rhsType) {\n         }\n     }\n \n+    private BType getIntersectionForErrorTypes(BType lhsType, BType rhsType) {\n+\n+        BType detailTypeOne = ((BErrorType) lhsType).detailType;\n+        BType detailTypeTwo = ((BErrorType) rhsType).detailType;\n+\n+        if (isSealedRecord(detailTypeOne) || isSealedRecord(detailTypeTwo)) {\n+            return symTable.semanticError;\n+        }\n+\n+        SymbolEnv prevEnv = this.env;\n+        this.env = symTable.pkgEnvMap.get(lhsType.tsymbol.owner);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10014b1a8708eeb074e7e82463fb840ab008faf6"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ1NzYwOA==", "bodyText": "I think you're correct regarding imported modules issue. If we refactor getTypeIntersection it wouldn't be an issue. Would overloading getTypeIntersection work? WDYT?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#discussion_r521457608", "createdAt": "2020-11-11T15:56:20Z", "author": {"login": "dulvinw"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -3129,6 +3168,131 @@ BType getTypeIntersection(BType lhsType, BType rhsType) {\n         }\n     }\n \n+    private BType getIntersectionForErrorTypes(BType lhsType, BType rhsType) {\n+\n+        BType detailTypeOne = ((BErrorType) lhsType).detailType;\n+        BType detailTypeTwo = ((BErrorType) rhsType).detailType;\n+\n+        if (isSealedRecord(detailTypeOne) || isSealedRecord(detailTypeTwo)) {\n+            return symTable.semanticError;\n+        }\n+\n+        SymbolEnv prevEnv = this.env;\n+        this.env = symTable.pkgEnvMap.get(lhsType.tsymbol.owner);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTM1NjA5MQ=="}, "originalCommit": {"oid": "10014b1a8708eeb074e7e82463fb840ab008faf6"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ2MjQ5NA==", "bodyText": "With this change, we would be allowing intersections that were not previously allowed, right? e.g., record and map intersections. This would mean that in other places like type narrowing in the type guard also we will be allowing these intersections. So it is possible that we would need the env even then.\nMentioned a similar scenario in https://github.com/ballerina-platform/ballerina-lang/pull/26144/files#r521415590.\nUnless there are some specific cases where we know we wouldn't need the env (and can pass null), I think we should mandate passing the env.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#discussion_r521462494", "createdAt": "2020-11-11T16:03:33Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -3129,6 +3168,131 @@ BType getTypeIntersection(BType lhsType, BType rhsType) {\n         }\n     }\n \n+    private BType getIntersectionForErrorTypes(BType lhsType, BType rhsType) {\n+\n+        BType detailTypeOne = ((BErrorType) lhsType).detailType;\n+        BType detailTypeTwo = ((BErrorType) rhsType).detailType;\n+\n+        if (isSealedRecord(detailTypeOne) || isSealedRecord(detailTypeTwo)) {\n+            return symTable.semanticError;\n+        }\n+\n+        SymbolEnv prevEnv = this.env;\n+        this.env = symTable.pkgEnvMap.get(lhsType.tsymbol.owner);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTM1NjA5MQ=="}, "originalCommit": {"oid": "10014b1a8708eeb074e7e82463fb840ab008faf6"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTUwNjI1MA==", "bodyText": "Cool. Will go through the usages and figure out what I can do. Thanks for your input :)", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#discussion_r521506250", "createdAt": "2020-11-11T17:05:57Z", "author": {"login": "dulvinw"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -3129,6 +3168,131 @@ BType getTypeIntersection(BType lhsType, BType rhsType) {\n         }\n     }\n \n+    private BType getIntersectionForErrorTypes(BType lhsType, BType rhsType) {\n+\n+        BType detailTypeOne = ((BErrorType) lhsType).detailType;\n+        BType detailTypeTwo = ((BErrorType) rhsType).detailType;\n+\n+        if (isSealedRecord(detailTypeOne) || isSealedRecord(detailTypeTwo)) {\n+            return symTable.semanticError;\n+        }\n+\n+        SymbolEnv prevEnv = this.env;\n+        this.env = symTable.pkgEnvMap.get(lhsType.tsymbol.owner);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTM1NjA5MQ=="}, "originalCommit": {"oid": "10014b1a8708eeb074e7e82463fb840ab008faf6"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTU2NDU0MQ==", "bodyText": "Fixed", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#discussion_r521564541", "createdAt": "2020-11-11T18:43:00Z", "author": {"login": "dulvinw"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -3129,6 +3168,131 @@ BType getTypeIntersection(BType lhsType, BType rhsType) {\n         }\n     }\n \n+    private BType getIntersectionForErrorTypes(BType lhsType, BType rhsType) {\n+\n+        BType detailTypeOne = ((BErrorType) lhsType).detailType;\n+        BType detailTypeTwo = ((BErrorType) rhsType).detailType;\n+\n+        if (isSealedRecord(detailTypeOne) || isSealedRecord(detailTypeTwo)) {\n+            return symTable.semanticError;\n+        }\n+\n+        SymbolEnv prevEnv = this.env;\n+        this.env = symTable.pkgEnvMap.get(lhsType.tsymbol.owner);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTM1NjA5MQ=="}, "originalCommit": {"oid": "10014b1a8708eeb074e7e82463fb840ab008faf6"}, "originalPosition": 126}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4NTAxMDcyOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwNjoxOTo1MVrOHzpdMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQwOToxMDoyN1rOH2TSVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzkxODY0Mg==", "bodyText": "Is this method name correct? IMO, under this condition we cannot call createRecordAndMapIntersection, we need to call another method to get the intersection between two maps. WDYT?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#discussion_r523918642", "createdAt": "2020-11-16T06:19:51Z", "author": {"login": "KavinduZoysa"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -3109,6 +3124,31 @@ BType getTypeIntersection(BType lhsType, BType rhsType) {\n                 }\n             } else if (type.tag == TypeTags.NULL_SET) {\n                 return type;\n+            } else if (type.tag == TypeTags.ERROR && lhsType.tag == TypeTags.ERROR) {\n+                BType intersectionType = getIntersectionForErrorTypes(lhsType, type, pkgEnv);\n+                if (intersectionType != symTable.semanticError) {\n+                    return intersectionType;\n+                }\n+            } else if (type.tag == TypeTags.RECORD && lhsType.tag == TypeTags.RECORD) {\n+                BType intersectionType = createRecordIntersection(lhsType, type, pkgEnv);\n+                if (intersectionType != symTable.semanticError) {\n+                    return intersectionType;\n+                }\n+            } else if (type.tag == TypeTags.MAP && lhsType.tag == TypeTags.RECORD) {\n+                BType intersectionType = createRecordAndMapIntersection(lhsType, type, pkgEnv);\n+                if (intersectionType != symTable.semanticError) {\n+                    return intersectionType;\n+                }\n+            } else if (type.tag == TypeTags.RECORD && lhsType.tag == TypeTags.MAP) {\n+                BType intersectionType = createRecordAndMapIntersection(type, lhsType, pkgEnv);\n+                if (intersectionType != symTable.semanticError) {\n+                    return intersectionType;\n+                }\n+            } else if (type.tag == TypeTags.MAP && lhsType.tag == TypeTags.MAP) {\n+                BType intersectionType = createRecordAndMapIntersection(type, lhsType, pkgEnv);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b73ba5cf64fb89f545ffbe48d4286495bbc0890b"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjcwMTE0Mw==", "bodyText": "The idea was to create a same method to get the interesctions of records, as well as maps. I too feel this is kinda confusing. I'll check how I can improve this.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#discussion_r526701143", "createdAt": "2020-11-19T09:10:27Z", "author": {"login": "dulvinw"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -3109,6 +3124,31 @@ BType getTypeIntersection(BType lhsType, BType rhsType) {\n                 }\n             } else if (type.tag == TypeTags.NULL_SET) {\n                 return type;\n+            } else if (type.tag == TypeTags.ERROR && lhsType.tag == TypeTags.ERROR) {\n+                BType intersectionType = getIntersectionForErrorTypes(lhsType, type, pkgEnv);\n+                if (intersectionType != symTable.semanticError) {\n+                    return intersectionType;\n+                }\n+            } else if (type.tag == TypeTags.RECORD && lhsType.tag == TypeTags.RECORD) {\n+                BType intersectionType = createRecordIntersection(lhsType, type, pkgEnv);\n+                if (intersectionType != symTable.semanticError) {\n+                    return intersectionType;\n+                }\n+            } else if (type.tag == TypeTags.MAP && lhsType.tag == TypeTags.RECORD) {\n+                BType intersectionType = createRecordAndMapIntersection(lhsType, type, pkgEnv);\n+                if (intersectionType != symTable.semanticError) {\n+                    return intersectionType;\n+                }\n+            } else if (type.tag == TypeTags.RECORD && lhsType.tag == TypeTags.MAP) {\n+                BType intersectionType = createRecordAndMapIntersection(type, lhsType, pkgEnv);\n+                if (intersectionType != symTable.semanticError) {\n+                    return intersectionType;\n+                }\n+            } else if (type.tag == TypeTags.MAP && lhsType.tag == TypeTags.MAP) {\n+                BType intersectionType = createRecordAndMapIntersection(type, lhsType, pkgEnv);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzkxODY0Mg=="}, "originalCommit": {"oid": "b73ba5cf64fb89f545ffbe48d4286495bbc0890b"}, "originalPosition": 130}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzNDMxNDUwOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/SemanticAnalyzer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxMjo0OTo0MVrOH69S9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxMjo0OTo0MVrOH69S9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTU4MzczNQ==", "bodyText": "Wouldn't passing the current env work? Please check other usage too.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#discussion_r531583735", "createdAt": "2020-11-27T12:49:41Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/SemanticAnalyzer.java", "diffHunk": "@@ -2449,7 +2449,8 @@ public void visit(BLangListMatchPattern listMatchPattern) {\n             matchPatternType.restType = restType;\n         }\n \n-        listMatchPattern.type = types.resolvePatternTypeFromMatchExpr(listMatchExpr, matchPatternType);\n+        SymbolEnv pkgEnv = symTable.pkgEnvMap.get(env.enclPkg.symbol);\n+        listMatchPattern.type = types.resolvePatternTypeFromMatchExpr(listMatchExpr, matchPatternType, pkgEnv);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cca340d89bf2a4bcf1e9e09f867ff0ee54ba0ee9"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzNDUzNTU0OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/SymbolEnter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxMzo1ODo0OFrOH6_XZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxMzo1ODo0OFrOH6_XZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTYxNzYzNg==", "bodyText": "Would this approach with in-line type-descriptors? Shouldn't we define these errors in the relevant scope, instead of making them module-level type definitions?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#discussion_r531617636", "createdAt": "2020-11-27T13:58:48Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/SymbolEnter.java", "diffHunk": "@@ -407,6 +416,200 @@ private void defineConstructs(BLangPackage pkgNode, SymbolEnv pkgEnv) {\n                 .forEach(varSymbol -> varSymbol.tag = SymTag.ENDPOINT);\n     }\n \n+    private void defineErrorIntersection(SymbolEnv env) {\n+        for (BLangNode typeDescriptor : this.errorIntersectionTypes) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cca340d89bf2a4bcf1e9e09f867ff0ee54ba0ee9"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzNDU2MTk3OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/SymbolEnter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxNDowNjo1NlrOH6_nYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxNDowNjo1NlrOH6_nYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTYyMTcyOQ==", "bodyText": "Isn't adding this check a bit contradictory with the method name? Should we rename the method to be more generic?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#discussion_r531621729", "createdAt": "2020-11-27T14:06:56Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/SymbolEnter.java", "diffHunk": "@@ -2119,8 +2330,10 @@ private void validateReadOnlyIntersectionTypeDefinitions(List<BLangTypeDefinitio\n                     if (constituentType == symTable.readonlyType) {\n                         continue;\n                     }\n+                    // If constituent type is error, we have already validated error intersections.\n+                    if (!types.isSelectivelyImmutableType(constituentType, true, true)\n+                            && constituentType.tag != TypeTags.ERROR) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cca340d89bf2a4bcf1e9e09f867ff0ee54ba0ee9"}, "originalPosition": 289}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzNDU2ODc2OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxNDowOToxMFrOH6_rsw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxNDowOToxMFrOH6_rsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTYyMjgzNQ==", "bodyText": "When can these become null? I'm not sure if we should add these checks here, we should probably not call this if a type is null.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#discussion_r531622835", "createdAt": "2020-11-27T14:09:10Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -228,6 +238,9 @@ public boolean isSameType(BType source, BType target) {\n     }\n \n     private boolean isSameType(BType source, BType target, Set<TypePair> unresolvedTypes) {\n+        if (source == null || target == null) {\n+            return false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cca340d89bf2a4bcf1e9e09f867ff0ee54ba0ee9"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzNDU3MTQ1OnYy", "diffSide": "RIGHT", "path": "tests/jballerina-unit-test/src/test/resources/test-src/types/intersection/error_intersection_type.bal", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxNDoxMDowMFrOH6_tYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxNDoxMDowMFrOH6_tYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTYyMzI2NQ==", "bodyText": "Missing the licence header in the bal files.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#discussion_r531623265", "createdAt": "2020-11-27T14:10:00Z", "author": {"login": "MaryamZi"}, "path": "tests/jballerina-unit-test/src/test/resources/test-src/types/intersection/error_intersection_type.bal", "diffHunk": "@@ -0,0 +1,76 @@\n+// Detail types", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cca340d89bf2a4bcf1e9e09f867ff0ee54ba0ee9"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzNDU3NjEwOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/resources/compiler.properties", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxNDoxMToyM1rOH6_wDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxNDoxMToyM1rOH6_wDA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTYyMzk0OA==", "bodyText": "Do we have tests for scenarios that can cause this error?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#discussion_r531623948", "createdAt": "2020-11-27T14:11:23Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/resources/compiler.properties", "diffHunk": "@@ -153,6 +153,9 @@ error.invalid.readonly.object.type=\\\n error.invalid.readonly.mapping.field=\\\n   invalid ''readonly'' mapping field ''{0}'': ''{1}'' can never be ''readonly''\n \n+error.invalid.error.intersection=\\\n+  invalid type in error intersection definition ''{0}''", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cca340d89bf2a4bcf1e9e09f867ff0ee54ba0ee9"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzNDU3OTc2OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxNDoxMjoyNFrOH6_yKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxNDoxMjoyNFrOH6_yKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTYyNDQ5MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    } else if (isAssignable(origField.type, overlappingField.type)) {\n          \n          \n            \n                        return origField.type;\n          \n          \n            \n                    } else {\n          \n          \n            \n                        return symTable.semanticError;\n          \n          \n            \n                    }\n          \n          \n            \n                    } \n          \n          \n            \n                    \n          \n          \n            \n                    if (isAssignable(origField.type, overlappingField.type)) {\n          \n          \n            \n                        return origField.type;\n          \n          \n            \n                    }\n          \n          \n            \n                    return symTable.semanticError;", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#discussion_r531624490", "createdAt": "2020-11-27T14:12:24Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -3142,6 +3182,161 @@ BType getTypeIntersection(BType lhsType, BType rhsType) {\n         }\n     }\n \n+    private BType getIntersectionForErrorTypes(BType lhsType, BType rhsType, SymbolEnv env) {\n+\n+        BType detailTypeOne = ((BErrorType) lhsType).detailType;\n+        BType detailTypeTwo = ((BErrorType) rhsType).detailType;\n+\n+        if (isSealedRecord(detailTypeOne) || isSealedRecord(detailTypeTwo)) {\n+            return symTable.semanticError;\n+        }\n+\n+        BType detailIntersectionType = getTypeIntersection(detailTypeOne, detailTypeTwo, env);\n+        if (detailIntersectionType == symTable.semanticError) {\n+            return symTable.semanticError;\n+        }\n+\n+        BErrorType intersectionErrorType = createErrorType(lhsType, rhsType, detailIntersectionType, env);\n+\n+        return intersectionErrorType;\n+    }\n+\n+    private BType createRecordIntersection(BType recordTypeOne, BType recordTypeTwo, SymbolEnv env) {\n+\n+        BRecordType recordType = createAnonymousRecord(env);\n+\n+        if (!populateRecordFields(recordType, recordTypeOne, env) ||\n+                !populateRecordFields(recordType, recordTypeTwo, env)) {\n+            return symTable.semanticError;\n+        }\n+\n+        recordType.restFieldType = getTypeIntersection(((BRecordType) recordTypeOne).restFieldType,\n+                                                       ((BRecordType) recordTypeTwo).restFieldType, env);\n+\n+        if (recordType.restFieldType == symTable.semanticError) {\n+            return symTable.semanticError;\n+        }\n+\n+        return recordType;\n+    }\n+\n+    private BRecordType createAnonymousRecord(SymbolEnv env) {\n+        EnumSet<Flag> flags = EnumSet.of(Flag.PUBLIC, Flag.ANONYMOUS);\n+        BRecordTypeSymbol recordSymbol = Symbols.createRecordSymbol(Flags.asMask(flags), Names.EMPTY,\n+                                                                                env.enclPkg.packageID, null,\n+                                                                                env.scope.owner, null, VIRTUAL);\n+        recordSymbol.name = names.fromString(\n+                anonymousModelHelper.getNextAnonymousTypeKey(env.enclPkg.packageID));\n+        BInvokableType bInvokableType = new BInvokableType(new ArrayList<>(), symTable.nilType, null);\n+        BInvokableSymbol initFuncSymbol = Symbols.createFunctionSymbol(\n+                Flags.PUBLIC, Names.EMPTY, env.enclPkg.symbol.pkgID, bInvokableType, env.scope.owner, false,\n+                symTable.builtinPos, VIRTUAL);\n+        initFuncSymbol.retType = symTable.nilType;\n+        recordSymbol.initializerFunc = new BAttachedFunction(Names.INIT_FUNCTION_SUFFIX, initFuncSymbol,\n+                                                                         bInvokableType, symTable.builtinPos);\n+        recordSymbol.scope = new Scope(recordSymbol);\n+\n+        BRecordType recordType = new BRecordType(recordSymbol);\n+        recordType.tsymbol = recordSymbol;\n+        recordSymbol.type = recordType;\n+\n+        return recordType;\n+    }\n+\n+    private BType createRecordAndMapIntersection(BType type, BType mapType, SymbolEnv env) {\n+        BRecordType intersectionRecord = createAnonymousRecord(env);\n+        if (!populateRecordFields(intersectionRecord, type, env)) {\n+            return symTable.semanticError;\n+        }\n+        intersectionRecord.restFieldType = getRestFieldIntersectionType(type, (BMapType) mapType, env);\n+\n+        if (intersectionRecord.restFieldType == symTable.semanticError) {\n+            return symTable.semanticError;\n+        }\n+\n+        return intersectionRecord;\n+    }\n+\n+    private BType getRestFieldIntersectionType(BType type, BMapType mapType, SymbolEnv env) {\n+        if (type.tag == TypeTags.RECORD) {\n+            return getTypeIntersection(((BRecordType) type).restFieldType, mapType.constraint, env);\n+        } else {\n+            return getTypeIntersection(((BMapType) type).constraint, mapType.constraint, env);\n+        }\n+    }\n+\n+    private BErrorType createErrorType(BType lhsType, BType rhsType, BType detailType, SymbolEnv env) {\n+        BErrorType errorType = createErrorType(detailType, lhsType.flags, env);\n+        errorType.tsymbol.flags |= rhsType.flags;\n+\n+        return errorType;\n+    }\n+\n+    public BErrorType createErrorType(BType detailType, long flags, SymbolEnv env) {\n+        BErrorTypeSymbol errorTypeSymbol = Symbols.createErrorSymbol(flags, Names.EMPTY,\n+                                                                     env.enclPkg.symbol.pkgID, null,\n+                                                                     env.scope.owner, null, VIRTUAL);\n+        BErrorType errorType = new BErrorType(errorTypeSymbol, detailType);\n+        errorType.flags |= errorTypeSymbol.flags;\n+        errorTypeSymbol.type = errorType;\n+        symResolver.markParameterizedType(errorType, detailType);\n+        errorType.typeIdSet = BTypeIdSet.emptySet();\n+\n+        return errorType;\n+    }\n+\n+    private boolean populateRecordFields(BRecordType recordType, BType originalType, SymbolEnv env) {\n+        BTypeSymbol intersectionRecordSymbol = recordType.tsymbol;\n+        // If the detail type is BMapType simply ignore since the resulting detail type has `anydata` as rest type.\n+        if (originalType.getKind() != TypeKind.RECORD) {\n+            return true;\n+        }\n+        BRecordType originalRecordType = (BRecordType) originalType;\n+        LinkedHashMap<String, BField> fields = new LinkedHashMap<>();\n+        for (BField origField : originalRecordType.fields.values()) {\n+            org.wso2.ballerinalang.compiler.util.Name origFieldName = origField.name;\n+            String nameString = origFieldName.value;\n+\n+            BType recordFieldType = validateOverlappingFields(recordType, origField);\n+            if (recordFieldType == symTable.semanticError) {\n+                return false;\n+            }\n+\n+            BVarSymbol recordFieldSymbol = new BVarSymbol(origField.symbol.flags, origFieldName,\n+                                                          env.enclPkg.packageID, recordFieldType,\n+                                                          intersectionRecordSymbol, origField.pos, SOURCE);\n+            if (recordFieldType.tag == TypeTags.INVOKABLE && recordFieldType.tsymbol != null) {\n+                BInvokableTypeSymbol tsymbol = (BInvokableTypeSymbol) recordFieldType.tsymbol;\n+                BInvokableSymbol invokableSymbol = (BInvokableSymbol) recordFieldSymbol;\n+                invokableSymbol.params = tsymbol.params;\n+                invokableSymbol.restParam = tsymbol.restParam;\n+                invokableSymbol.retType = tsymbol.returnType;\n+                invokableSymbol.flags = tsymbol.flags;\n+            }\n+\n+\n+            fields.put(nameString, new BField(origFieldName, null, recordFieldSymbol));\n+        }\n+        recordType.fields.putAll(fields);\n+\n+        return true;\n+    }\n+\n+    private BType validateOverlappingFields(BRecordType recordType, BField origField) {\n+        BField overlappingField = recordType.fields.get(origField.name.value);\n+        if (overlappingField == null) {\n+            return origField.type;\n+        }\n+\n+        if (isAssignable(overlappingField.type, origField.type)) {\n+            return overlappingField.type;\n+        } else if (isAssignable(origField.type, overlappingField.type)) {\n+            return origField.type;\n+        } else {\n+            return symTable.semanticError;\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cca340d89bf2a4bcf1e9e09f867ff0ee54ba0ee9"}, "originalPosition": 293}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NjUwMjcwOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/ballerinalang/util/diagnostic/DiagnosticErrorCode.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQwNDozNTo0M1rOIOxoBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQwNDozNzo0NVrOIOxqGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM2NDAzNg==", "bodyText": "Extra new line", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#discussion_r552364036", "createdAt": "2021-01-06T04:35:43Z", "author": {"login": "rdhananjaya"}, "path": "compiler/ballerina-lang/src/main/java/org/ballerinalang/util/diagnostic/DiagnosticErrorCode.java", "diffHunk": "@@ -660,6 +660,7 @@\n     SERVICE_LITERAL_REQUIRED_BY_LISTENER(\"BCE3973\", \"service.path.literal.required.by.listener\"),\n     SERVICE_ABSOLUTE_PATH_REQUIRED_BY_LISTENER(\"BCE3974\", \"service.absolute.path.required.by.listener\"),\n     MULTIPLE_RECEIVE_ACTION_NOT_YET_SUPPORTED(\"BCE3975\", \"multiple.receive.action.not.yet.supported\"),\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a2d376d4cf14cdfdc5a1864d3e749ccc7a0b6b7"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM2NDU2OQ==", "bodyText": "Fixed", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#discussion_r552364569", "createdAt": "2021-01-06T04:37:45Z", "author": {"login": "dulvinw"}, "path": "compiler/ballerina-lang/src/main/java/org/ballerinalang/util/diagnostic/DiagnosticErrorCode.java", "diffHunk": "@@ -660,6 +660,7 @@\n     SERVICE_LITERAL_REQUIRED_BY_LISTENER(\"BCE3973\", \"service.path.literal.required.by.listener\"),\n     SERVICE_ABSOLUTE_PATH_REQUIRED_BY_LISTENER(\"BCE3974\", \"service.absolute.path.required.by.listener\"),\n     MULTIPLE_RECEIVE_ACTION_NOT_YET_SUPPORTED(\"BCE3975\", \"multiple.receive.action.not.yet.supported\"),\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM2NDAzNg=="}, "originalCommit": {"oid": "8a2d376d4cf14cdfdc5a1864d3e749ccc7a0b6b7"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NjUzOTkxOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/SymbolEnter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQwNDo1NzoxNFrOIOx8ng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQwNDo1NzoxNFrOIOx8ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM2OTMxMA==", "bodyText": "Shall we add a comment explaining this", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#discussion_r552369310", "createdAt": "2021-01-06T04:57:14Z", "author": {"login": "rdhananjaya"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/SymbolEnter.java", "diffHunk": "@@ -1969,6 +2058,9 @@ private void addTopLevelNode(BLangPackage pkgNode, TopLevelNode node) {\n \n     private void defineErrorDetails(List<BLangTypeDefinition> typeDefNodes, SymbolEnv pkgEnv) {\n         for (BLangTypeDefinition typeDef : typeDefNodes) {\n+            if (typeDef.symbol == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f4685f2a1e77e3030c00d8b66d7fc6e43223d04"}, "originalPosition": 180}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NjYzNDE3OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/util/TypeDefBuilderHelper.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQwNTo1MDozM1rOIOyyQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQwNzoxNjowMFrOIO0QXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM4MzA0Mw==", "bodyText": "can we use this \n  \n    \n      ballerina-lang/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/ASTBuilderUtil.java\n    \n    \n         Line 704\n      in\n      1ce30c6\n    \n    \n    \n    \n\n        \n          \n           public static BLangIdentifier createIdentifier(Location pos, String value) {", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#discussion_r552383043", "createdAt": "2021-01-06T05:50:33Z", "author": {"login": "rdhananjaya"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/util/TypeDefBuilderHelper.java", "diffHunk": "@@ -215,4 +218,29 @@ public static BLangClassDefinition createClassDef(Location pos, BObjectTypeSymbo\n \n         return classDefNode;\n     }\n+\n+    public static BLangErrorType createBLangErrorType(Location pos, BType detailType, String name) {\n+        BLangErrorType errorType = (BLangErrorType) TreeBuilder.createErrorTypeNode();\n+        BLangUserDefinedType userDefinedTypeNode = (BLangUserDefinedType) TreeBuilder.createUserDefinedTypeNode();\n+        userDefinedTypeNode.pos = pos;\n+        userDefinedTypeNode.pkgAlias = (BLangIdentifier) TreeBuilder.createIdentifierNode();\n+        userDefinedTypeNode.typeName = createIdentifier(pos, name);\n+        userDefinedTypeNode.type = detailType;\n+        errorType.detailType = userDefinedTypeNode;\n+\n+        return errorType;\n+    }\n+\n+    private static BLangIdentifier createIdentifier(Location pos, String value) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f4685f2a1e77e3030c00d8b66d7fc6e43223d04"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQwNzEzNA==", "bodyText": "Fixed", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#discussion_r552407134", "createdAt": "2021-01-06T07:16:00Z", "author": {"login": "dulvinw"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/util/TypeDefBuilderHelper.java", "diffHunk": "@@ -215,4 +218,29 @@ public static BLangClassDefinition createClassDef(Location pos, BObjectTypeSymbo\n \n         return classDefNode;\n     }\n+\n+    public static BLangErrorType createBLangErrorType(Location pos, BType detailType, String name) {\n+        BLangErrorType errorType = (BLangErrorType) TreeBuilder.createErrorTypeNode();\n+        BLangUserDefinedType userDefinedTypeNode = (BLangUserDefinedType) TreeBuilder.createUserDefinedTypeNode();\n+        userDefinedTypeNode.pos = pos;\n+        userDefinedTypeNode.pkgAlias = (BLangIdentifier) TreeBuilder.createIdentifierNode();\n+        userDefinedTypeNode.typeName = createIdentifier(pos, name);\n+        userDefinedTypeNode.type = detailType;\n+        errorType.detailType = userDefinedTypeNode;\n+\n+        return errorType;\n+    }\n+\n+    private static BLangIdentifier createIdentifier(Location pos, String value) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM4MzA0Mw=="}, "originalCommit": {"oid": "9f4685f2a1e77e3030c00d8b66d7fc6e43223d04"}, "originalPosition": 32}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3080, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}