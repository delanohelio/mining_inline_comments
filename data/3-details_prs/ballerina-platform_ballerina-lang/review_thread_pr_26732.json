{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE1MTI3MDk1", "number": 26732, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxMTo1Nzo0MVrOE2DwBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxMTo1Nzo0MVrOE2DwBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MTIwMDA0OnYy", "diffSide": "RIGHT", "path": "misc/tracing-extensions/modules/ballerina-choreo-extension/src/main/java/org/ballerinalang/observe/trace/extension/choreo/ChoreoJaegerReporter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxMTo1Nzo0MVrOHurTfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxMjozMTozOVrOHusRXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODcwNjA0Nw==", "bodyText": "I think it's better if we make this a WARN log since it's technically not an error. Shall we change the log to indicate that the buffer is full and we dropped the spans (including the count) ?\nAlso shall we move this inside the swappedTraceSpans.size() > SPAN_LIST_BOUND if condition ? That way the log will be only printed if the traces are dropped. (we can move the spanCount variable declaration inside too then)", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26732#discussion_r518706047", "createdAt": "2020-11-06T11:57:41Z", "author": {"login": "nadundesilva"}, "path": "misc/tracing-extensions/modules/ballerina-choreo-extension/src/main/java/org/ballerinalang/observe/trace/extension/choreo/ChoreoJaegerReporter.java", "diffHunk": "@@ -129,31 +132,50 @@ private void append(JaegerSpan jaegerSpan) {\n \n         @Override\n         public void run() {\n-            ChoreoTraceSpan[] spansToBeSent;\n+            List<ChoreoTraceSpan> swappedTraceSpans;\n+\n             synchronized (this) {\n                 if (traceSpans.size() > 0) {\n-                    spansToBeSent = traceSpans.toArray(new ChoreoTraceSpan[0]);\n-                    traceSpans.clear();\n+                    swappedTraceSpans = traceSpans;\n+                    traceSpans = new ArrayList<>();\n                 } else {\n-                    spansToBeSent = new ChoreoTraceSpan[0];\n+                    swappedTraceSpans = Collections.emptyList();\n                 }\n             }\n-            if (spansToBeSent.length > 0) {\n+            if (swappedTraceSpans.size() > 0) {\n                 if (!Objects.isNull(choreoClient)) {\n                     try {\n-                        choreoClient.publishTraceSpans(spansToBeSent);\n+                        choreoClient.publishTraceSpans(swappedTraceSpans);\n                     } catch (Throwable t) {\n                         synchronized (this) {\n-                            traceSpans.addAll(Arrays.asList(spansToBeSent));\n+                            int spanCount = 0;\n+                            if (swappedTraceSpans.size() > SPAN_LIST_BOUND) {\n+                                Random random = new Random();\n+                                // Remove 10% of the SPAN_LIST_BOUND\n+                                while (spanCount < SPANS_TO_REMOVE) {\n+                                    if (swappedTraceSpans.size() > 0) {\n+                                        int randomSpanPos = random.nextInt(swappedTraceSpans.size());\n+                                        long traceID = swappedTraceSpans.get(randomSpanPos).getTraceId();\n+                                        for (int j = 0; j < swappedTraceSpans.size(); j++) {\n+                                            if (swappedTraceSpans.get(j).getTraceId() == traceID) {\n+                                                swappedTraceSpans.remove(j);\n+                                                // Reduce the count as well since the size of the arrayList shrink\n+                                                j--;\n+                                                spanCount++;\n+                                            }\n+                                        }\n+                                    }\n+                                }\n+                            }\n+\n+                            traceSpans.addAll(swappedTraceSpans);\n+                            LOGGER.error(\"dropped \" + spanCount + \" spans\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d860861af944bab38db4a3fc71b94b4e92fe0b2"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODcyMTg4NA==", "bodyText": "LOGGER has only the debug, info and error methods, Therefore i will use a info log as LOGGER.info(\"span buffer is full : \" + \"dropped \" + spanCount + \"spans\");", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26732#discussion_r518721884", "createdAt": "2020-11-06T12:31:39Z", "author": {"login": "sachiniSam"}, "path": "misc/tracing-extensions/modules/ballerina-choreo-extension/src/main/java/org/ballerinalang/observe/trace/extension/choreo/ChoreoJaegerReporter.java", "diffHunk": "@@ -129,31 +132,50 @@ private void append(JaegerSpan jaegerSpan) {\n \n         @Override\n         public void run() {\n-            ChoreoTraceSpan[] spansToBeSent;\n+            List<ChoreoTraceSpan> swappedTraceSpans;\n+\n             synchronized (this) {\n                 if (traceSpans.size() > 0) {\n-                    spansToBeSent = traceSpans.toArray(new ChoreoTraceSpan[0]);\n-                    traceSpans.clear();\n+                    swappedTraceSpans = traceSpans;\n+                    traceSpans = new ArrayList<>();\n                 } else {\n-                    spansToBeSent = new ChoreoTraceSpan[0];\n+                    swappedTraceSpans = Collections.emptyList();\n                 }\n             }\n-            if (spansToBeSent.length > 0) {\n+            if (swappedTraceSpans.size() > 0) {\n                 if (!Objects.isNull(choreoClient)) {\n                     try {\n-                        choreoClient.publishTraceSpans(spansToBeSent);\n+                        choreoClient.publishTraceSpans(swappedTraceSpans);\n                     } catch (Throwable t) {\n                         synchronized (this) {\n-                            traceSpans.addAll(Arrays.asList(spansToBeSent));\n+                            int spanCount = 0;\n+                            if (swappedTraceSpans.size() > SPAN_LIST_BOUND) {\n+                                Random random = new Random();\n+                                // Remove 10% of the SPAN_LIST_BOUND\n+                                while (spanCount < SPANS_TO_REMOVE) {\n+                                    if (swappedTraceSpans.size() > 0) {\n+                                        int randomSpanPos = random.nextInt(swappedTraceSpans.size());\n+                                        long traceID = swappedTraceSpans.get(randomSpanPos).getTraceId();\n+                                        for (int j = 0; j < swappedTraceSpans.size(); j++) {\n+                                            if (swappedTraceSpans.get(j).getTraceId() == traceID) {\n+                                                swappedTraceSpans.remove(j);\n+                                                // Reduce the count as well since the size of the arrayList shrink\n+                                                j--;\n+                                                spanCount++;\n+                                            }\n+                                        }\n+                                    }\n+                                }\n+                            }\n+\n+                            traceSpans.addAll(swappedTraceSpans);\n+                            LOGGER.error(\"dropped \" + spanCount + \" spans\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODcwNjA0Nw=="}, "originalCommit": {"oid": "6d860861af944bab38db4a3fc71b94b4e92fe0b2"}, "originalPosition": 80}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3188, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}