{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAwNzI1MzMw", "number": 22519, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwNzozMDowOFrODyy6KQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwNjoyNToyNVrODzkJWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NTg5NDgxOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwNzozMDowOFrOGHC_Mw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxMzo0OToxOFrOGHOwgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA0MjE2Mw==", "bodyText": "Can this be null here, if the mapping constructor contains the field?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22519#discussion_r410042163", "createdAt": "2020-04-17T07:30:08Z", "author": {"login": "pubudu91"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -1054,22 +1054,107 @@ private boolean validateSpecifiedFields(BLangRecordLiteral mappingConstructor, B\n         return isFieldsValid;\n     }\n \n-    private boolean validateRequiredFields(BRecordType type, List<RecordLiteralNode.RecordField> specifiedFields,\n-                                           DiagnosticPos pos) {\n+    private boolean validateRequiredAndReadonlyFields(BRecordType type,\n+                                                      List<RecordLiteralNode.RecordField> specifiedFields,\n+                                                      DiagnosticPos pos) {\n         HashSet<String> specFieldNames = getFieldNames(specifiedFields);\n         boolean hasAllRequiredFields = true;\n+        boolean hasValidReadonlyFields = true;\n \n         for (BField field : type.fields) {\n-            // Check if `field` is explicitly assigned a value in the record literal\n-            // If a required field is missing, it's a compile error\n-            if (!specFieldNames.contains(field.name.value) && Symbols.isFlagOn(field.symbol.flags, Flags.REQUIRED)) {\n+            String fieldName = field.name.value;\n+            BType fieldType = symTable.semanticError;\n+            DiagnosticPos fieldPos;\n+\n+            if (specFieldNames.contains(fieldName)) {\n+                RecordLiteralNode.RecordField recordField = getRecordFieldByName(specifiedFields, fieldName);\n+                if (recordField == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65d005938b9b5885b1eb65b2fa751fca956b2b96"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDIzNTAwOQ==", "bodyText": "Yeah not in this context, I've removed the null check.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22519#discussion_r410235009", "createdAt": "2020-04-17T13:49:18Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -1054,22 +1054,107 @@ private boolean validateSpecifiedFields(BLangRecordLiteral mappingConstructor, B\n         return isFieldsValid;\n     }\n \n-    private boolean validateRequiredFields(BRecordType type, List<RecordLiteralNode.RecordField> specifiedFields,\n-                                           DiagnosticPos pos) {\n+    private boolean validateRequiredAndReadonlyFields(BRecordType type,\n+                                                      List<RecordLiteralNode.RecordField> specifiedFields,\n+                                                      DiagnosticPos pos) {\n         HashSet<String> specFieldNames = getFieldNames(specifiedFields);\n         boolean hasAllRequiredFields = true;\n+        boolean hasValidReadonlyFields = true;\n \n         for (BField field : type.fields) {\n-            // Check if `field` is explicitly assigned a value in the record literal\n-            // If a required field is missing, it's a compile error\n-            if (!specFieldNames.contains(field.name.value) && Symbols.isFlagOn(field.symbol.flags, Flags.REQUIRED)) {\n+            String fieldName = field.name.value;\n+            BType fieldType = symTable.semanticError;\n+            DiagnosticPos fieldPos;\n+\n+            if (specFieldNames.contains(fieldName)) {\n+                RecordLiteralNode.RecordField recordField = getRecordFieldByName(specifiedFields, fieldName);\n+                if (recordField == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA0MjE2Mw=="}, "originalCommit": {"oid": "65d005938b9b5885b1eb65b2fa751fca956b2b96"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NTkwOTkzOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwNzozNToyMlrOGHDItQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxMzo1ODowM1rOGHPHwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA0NDU5Nw==", "bodyText": "Isn't this part duplicate of the logic in getRecordFieldByName()? Do we need to do the same here, after calling that method? Should be able to directly take the type of the spread field right?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22519#discussion_r410044597", "createdAt": "2020-04-17T07:35:22Z", "author": {"login": "pubudu91"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -1054,22 +1054,107 @@ private boolean validateSpecifiedFields(BLangRecordLiteral mappingConstructor, B\n         return isFieldsValid;\n     }\n \n-    private boolean validateRequiredFields(BRecordType type, List<RecordLiteralNode.RecordField> specifiedFields,\n-                                           DiagnosticPos pos) {\n+    private boolean validateRequiredAndReadonlyFields(BRecordType type,\n+                                                      List<RecordLiteralNode.RecordField> specifiedFields,\n+                                                      DiagnosticPos pos) {\n         HashSet<String> specFieldNames = getFieldNames(specifiedFields);\n         boolean hasAllRequiredFields = true;\n+        boolean hasValidReadonlyFields = true;\n \n         for (BField field : type.fields) {\n-            // Check if `field` is explicitly assigned a value in the record literal\n-            // If a required field is missing, it's a compile error\n-            if (!specFieldNames.contains(field.name.value) && Symbols.isFlagOn(field.symbol.flags, Flags.REQUIRED)) {\n+            String fieldName = field.name.value;\n+            BType fieldType = symTable.semanticError;\n+            DiagnosticPos fieldPos;\n+\n+            if (specFieldNames.contains(fieldName)) {\n+                RecordLiteralNode.RecordField recordField = getRecordFieldByName(specifiedFields, fieldName);\n+                if (recordField == null) {\n+                    continue;\n+                }\n+\n+                switch (recordField.getKind()) {\n+                    case RECORD_LITERAL_KEY_VALUE:\n+                        BLangRecordKeyValueField keyValueField = (BLangRecordKeyValueField) recordField;\n+                        fieldType = keyValueField.type;\n+                        fieldPos = keyValueField.valueExpr.pos;\n+                        break;\n+                    case SIMPLE_VARIABLE_REF:\n+                        BLangRecordLiteral.BLangRecordVarNameField varNameField =\n+                                (BLangRecordLiteral.BLangRecordVarNameField) recordField;\n+                        fieldType = varNameField.type;\n+                        fieldPos = varNameField.pos;\n+                        break;\n+                    default:\n+                        BLangRecordLiteral.BLangRecordSpreadOperatorField spreadOpField =\n+                                (BLangRecordLiteral.BLangRecordSpreadOperatorField) recordField;\n+                        BRecordType recordType = (BRecordType) spreadOpField.expr.type;\n+\n+                        for (BField bField : recordType.fields) {\n+                            if (fieldName.equals(bField.name.value)) {\n+                                fieldType = bField.type;\n+                                break;\n+                            }\n+                        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65d005938b9b5885b1eb65b2fa751fca956b2b96"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDI0MDk2MQ==", "bodyText": "Yeah, noticed the duplication, but the issue was that we basically needed the type and pos, and for key-value and variable name fields we can retrieve a RecordField and get the type and pos from it. But for a spread-field the type is from a BField and the pos is still from the spread field.\nI've refactored this a bit with an inner class.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22519#discussion_r410240961", "createdAt": "2020-04-17T13:58:03Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -1054,22 +1054,107 @@ private boolean validateSpecifiedFields(BLangRecordLiteral mappingConstructor, B\n         return isFieldsValid;\n     }\n \n-    private boolean validateRequiredFields(BRecordType type, List<RecordLiteralNode.RecordField> specifiedFields,\n-                                           DiagnosticPos pos) {\n+    private boolean validateRequiredAndReadonlyFields(BRecordType type,\n+                                                      List<RecordLiteralNode.RecordField> specifiedFields,\n+                                                      DiagnosticPos pos) {\n         HashSet<String> specFieldNames = getFieldNames(specifiedFields);\n         boolean hasAllRequiredFields = true;\n+        boolean hasValidReadonlyFields = true;\n \n         for (BField field : type.fields) {\n-            // Check if `field` is explicitly assigned a value in the record literal\n-            // If a required field is missing, it's a compile error\n-            if (!specFieldNames.contains(field.name.value) && Symbols.isFlagOn(field.symbol.flags, Flags.REQUIRED)) {\n+            String fieldName = field.name.value;\n+            BType fieldType = symTable.semanticError;\n+            DiagnosticPos fieldPos;\n+\n+            if (specFieldNames.contains(fieldName)) {\n+                RecordLiteralNode.RecordField recordField = getRecordFieldByName(specifiedFields, fieldName);\n+                if (recordField == null) {\n+                    continue;\n+                }\n+\n+                switch (recordField.getKind()) {\n+                    case RECORD_LITERAL_KEY_VALUE:\n+                        BLangRecordKeyValueField keyValueField = (BLangRecordKeyValueField) recordField;\n+                        fieldType = keyValueField.type;\n+                        fieldPos = keyValueField.valueExpr.pos;\n+                        break;\n+                    case SIMPLE_VARIABLE_REF:\n+                        BLangRecordLiteral.BLangRecordVarNameField varNameField =\n+                                (BLangRecordLiteral.BLangRecordVarNameField) recordField;\n+                        fieldType = varNameField.type;\n+                        fieldPos = varNameField.pos;\n+                        break;\n+                    default:\n+                        BLangRecordLiteral.BLangRecordSpreadOperatorField spreadOpField =\n+                                (BLangRecordLiteral.BLangRecordSpreadOperatorField) recordField;\n+                        BRecordType recordType = (BRecordType) spreadOpField.expr.type;\n+\n+                        for (BField bField : recordType.fields) {\n+                            if (fieldName.equals(bField.name.value)) {\n+                                fieldType = bField.type;\n+                                break;\n+                            }\n+                        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA0NDU5Nw=="}, "originalCommit": {"oid": "65d005938b9b5885b1eb65b2fa751fca956b2b96"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NjAyOTI4OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/resources/compiler.properties", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwODoxMzozN1rOGHET5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxMzo0ODo0M1rOGHOvQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA2Mzg0Nw==", "bodyText": "Shouldn't this be a colon?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22519#discussion_r410063847", "createdAt": "2020-04-17T08:13:37Z", "author": {"login": "pubudu91"}, "path": "compiler/ballerina-lang/src/main/resources/compiler.properties", "diffHunk": "@@ -347,6 +347,9 @@ error.invalid.record.rest.descriptor=\\\n error.missing.required.record.field=\\\n   missing non-defaultable required record field ''{0}''\n \n+error.invalid.field.for.readonly.record.field=\\\n+  invalid field; ''readonly'' field expected for ''{0}''", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65d005938b9b5885b1eb65b2fa751fca956b2b96"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDIzNDY5MA==", "bodyText": "Fixed, but we seem to have used a mix of : and ; in error messages.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22519#discussion_r410234690", "createdAt": "2020-04-17T13:48:43Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/resources/compiler.properties", "diffHunk": "@@ -347,6 +347,9 @@ error.invalid.record.rest.descriptor=\\\n error.missing.required.record.field=\\\n   missing non-defaultable required record field ''{0}''\n \n+error.invalid.field.for.readonly.record.field=\\\n+  invalid field; ''readonly'' field expected for ''{0}''", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA2Mzg0Nw=="}, "originalCommit": {"oid": "65d005938b9b5885b1eb65b2fa751fca956b2b96"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1Mzk2MTg2OnYy", "diffSide": "RIGHT", "path": "tests/jballerina-unit-test/src/test/resources/test-src/record/readonly_record_fields.bal", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwNjoyNToyNVrOGIE95Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwNzozNjoyMFrOGIHJkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTEyMzE3Mw==", "bodyText": "Need to clarify this behavior. Student.name is a readonly field, So sd.name assignment can panic at runtime.\nWe have similar behavior on the inherent type violation. So this is OK IMO.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22519#discussion_r411123173", "createdAt": "2020-04-20T06:25:25Z", "author": {"login": "hasithaa"}, "path": "tests/jballerina-unit-test/src/test/resources/test-src/record/readonly_record_fields.bal", "diffHunk": "@@ -0,0 +1,159 @@\n+// Copyright (c) 2020 WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+//\n+// WSO2 Inc. licenses this file to you under the Apache License,\n+// Version 2.0 (the \"License\"); you may not use this file except\n+// in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+const INHERENT_TYPE_VIOLATION_REASON = \"{ballerina/lang.map}InherentTypeViolation\";\n+\n+function testReadonlyRecordFields() {\n+    testRecordWithSimpleReadonlyFields();\n+    testInvalidRecordSimpleReadonlyFieldUpdate();\n+    testValidUpdateOfPossiblyReadonlyFieldInUnion();\n+    testInvalidUpdateOfPossiblyReadonlyFieldInUnion();\n+}\n+\n+type Student record {\n+    readonly string name;\n+    readonly int id?;\n+};\n+\n+function testRecordWithSimpleReadonlyFields() {\n+    Student st = {\n+        name: \"Maryam\"\n+    };\n+    assertEquality(\"Maryam\", st.name);\n+    assertEquality((), st?.id);\n+\n+    st.id = 1234; // Valid since first update.\n+    assertEquality(\"Maryam\", st.name);\n+    assertEquality(1234, st?.id);\n+}\n+\n+function testInvalidRecordSimpleReadonlyFieldUpdate() {\n+    Student st1 = {\n+        name: \"Maryam\"\n+    };\n+    st1.id = 1234; // Valid since first update.\n+\n+    // Invalid updates.\n+    var fn1 = function () {\n+        record {} rec = st1;\n+        string str = \"name\";\n+        rec[str] = \"Jo\";\n+    };\n+    error? res = trap fn1();\n+    assertTrue(res is error);\n+\n+    error err = <error> res;\n+    assertEquality(INHERENT_TYPE_VIOLATION_REASON, err.reason());\n+    assertEquality(\"cannot update 'readonly' field 'name' in record of type 'Student'\", err.detail()?.message);\n+\n+    var fn2 = function () {\n+        st1.id = 4567;\n+    };\n+    res = trap fn2();\n+    assertTrue(res is error);\n+\n+    err = <error> res;\n+    assertEquality(INHERENT_TYPE_VIOLATION_REASON, err.reason());\n+    assertEquality(\"cannot update 'readonly' field 'id' in record of type 'Student'\", err.detail()?.message);\n+}\n+\n+type Employee record {\n+    readonly Details details;\n+    string department;\n+};\n+\n+type ReadonlyName record {\n+    readonly string name;\n+};\n+\n+type Details record {\n+    string name;\n+    int id;\n+};\n+\n+function testValidUpdateOfPossiblyReadonlyFieldInUnion() {\n+    Details d = {\n+        name: \"Jo\",\n+        id: 1234\n+    };\n+\n+    Student|Details sd = d;\n+    sd.name = \"May\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e29cf50fd91c09818a2e7603860606def0a5a90c"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTE1ODkyOA==", "bodyText": "Created ballerina-platform/ballerina-spec#495 to clarify.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22519#discussion_r411158928", "createdAt": "2020-04-20T07:36:20Z", "author": {"login": "MaryamZi"}, "path": "tests/jballerina-unit-test/src/test/resources/test-src/record/readonly_record_fields.bal", "diffHunk": "@@ -0,0 +1,159 @@\n+// Copyright (c) 2020 WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+//\n+// WSO2 Inc. licenses this file to you under the Apache License,\n+// Version 2.0 (the \"License\"); you may not use this file except\n+// in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+const INHERENT_TYPE_VIOLATION_REASON = \"{ballerina/lang.map}InherentTypeViolation\";\n+\n+function testReadonlyRecordFields() {\n+    testRecordWithSimpleReadonlyFields();\n+    testInvalidRecordSimpleReadonlyFieldUpdate();\n+    testValidUpdateOfPossiblyReadonlyFieldInUnion();\n+    testInvalidUpdateOfPossiblyReadonlyFieldInUnion();\n+}\n+\n+type Student record {\n+    readonly string name;\n+    readonly int id?;\n+};\n+\n+function testRecordWithSimpleReadonlyFields() {\n+    Student st = {\n+        name: \"Maryam\"\n+    };\n+    assertEquality(\"Maryam\", st.name);\n+    assertEquality((), st?.id);\n+\n+    st.id = 1234; // Valid since first update.\n+    assertEquality(\"Maryam\", st.name);\n+    assertEquality(1234, st?.id);\n+}\n+\n+function testInvalidRecordSimpleReadonlyFieldUpdate() {\n+    Student st1 = {\n+        name: \"Maryam\"\n+    };\n+    st1.id = 1234; // Valid since first update.\n+\n+    // Invalid updates.\n+    var fn1 = function () {\n+        record {} rec = st1;\n+        string str = \"name\";\n+        rec[str] = \"Jo\";\n+    };\n+    error? res = trap fn1();\n+    assertTrue(res is error);\n+\n+    error err = <error> res;\n+    assertEquality(INHERENT_TYPE_VIOLATION_REASON, err.reason());\n+    assertEquality(\"cannot update 'readonly' field 'name' in record of type 'Student'\", err.detail()?.message);\n+\n+    var fn2 = function () {\n+        st1.id = 4567;\n+    };\n+    res = trap fn2();\n+    assertTrue(res is error);\n+\n+    err = <error> res;\n+    assertEquality(INHERENT_TYPE_VIOLATION_REASON, err.reason());\n+    assertEquality(\"cannot update 'readonly' field 'id' in record of type 'Student'\", err.detail()?.message);\n+}\n+\n+type Employee record {\n+    readonly Details details;\n+    string department;\n+};\n+\n+type ReadonlyName record {\n+    readonly string name;\n+};\n+\n+type Details record {\n+    string name;\n+    int id;\n+};\n+\n+function testValidUpdateOfPossiblyReadonlyFieldInUnion() {\n+    Details d = {\n+        name: \"Jo\",\n+        id: 1234\n+    };\n+\n+    Student|Details sd = d;\n+    sd.name = \"May\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTEyMzE3Mw=="}, "originalCommit": {"oid": "e29cf50fd91c09818a2e7603860606def0a5a90c"}, "originalPosition": 94}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3966, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}