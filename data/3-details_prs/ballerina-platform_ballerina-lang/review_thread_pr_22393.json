{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk2ODg1Nzcw", "number": 22393, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxMDo1NjowNlrODtew1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxMDo1ODo1OFrODte0TA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5MDE2NTMyOnYy", "diffSide": "RIGHT", "path": "misc/ballerina-bindgen/src/main/java/org/ballerinalang/bindgen/command/BindingsGenerator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxMDo1NjowNlrOF-7XSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxMjo0NTozN1rOF--4Ew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTUyODY0OA==", "bodyText": "If you use temp variable to hold the outputPath var and set its values to userDir if null, then we get remove duplicate codes.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22393#discussion_r401528648", "createdAt": "2020-04-01T10:56:06Z", "author": {"login": "warunalakshitha"}, "path": "misc/ballerina-bindgen/src/main/java/org/ballerinalang/bindgen/command/BindingsGenerator.java", "diffHunk": "@@ -56,90 +58,121 @@\n  */\n public class BindingsGenerator {\n \n-    private String outputPath;\n     private Path modulePath;\n     private Path dependenciesPath;\n+    private Path utilsDirPath;\n+    private String outputPath;\n     private Set<String> classPaths = new HashSet<>();\n     private Set<String> classNames = new HashSet<>();\n+    private static boolean directJavaClass = true;\n     private static final PrintStream errStream = System.err;\n     private static final PrintStream outStream = System.out;\n     private static Path userDir = Paths.get(System.getProperty(USER_DIR));\n \n-    public static boolean directJavaClass = true;\n-    public static Set<String> allClasses = new HashSet<>();\n-    public static Set<String> classListForLooping = new HashSet<>();\n-    public static Set<String> allJavaClasses = new HashSet<>();\n-    public static Set<String> failedClassGens = new HashSet<>();\n+    private static Set<String> allClasses = new HashSet<>();\n+    private static Set<String> classListForLooping = new HashSet<>();\n+    private static Set<String> allJavaClasses = new HashSet<>();\n+    private static Map<String, String> failedClassGens = new HashMap<>();\n \n     void generateJavaBindings() throws BindgenException {\n \n-        ClassLoader classLoader;\n-        try {\n-            if (!this.classPaths.isEmpty()) {\n-                classLoader = getClassLoader(this.classPaths, this.getClass().getClassLoader());\n-            } else {\n-                classLoader = this.getClass().getClassLoader();\n-            }\n-        } catch (BindgenException e) {\n-            throw new BindgenException(\"Error while loading the classpaths.\", e);\n-        }\n+        ClassLoader classLoader = setClassLoader();\n         if (classLoader != null) {\n-            if (this.outputPath == null) {\n-                this.modulePath = Paths.get(userDir.toString(), BALLERINA_BINDINGS_DIR);\n-                this.dependenciesPath = Paths.get(userDir.toString(), BALLERINA_BINDINGS_DIR, DEPENDENCIES_DIR_NAME);\n-            } else {\n-                this.modulePath = Paths.get(outputPath, BALLERINA_BINDINGS_DIR);\n-                this.dependenciesPath = Paths.get(outputPath, BALLERINA_BINDINGS_DIR, DEPENDENCIES_DIR_NAME);\n-            }\n-            outStream.println(\"Generating bindings for: \");\n-            String modulePathString = modulePath.toString();\n-            String utilsDirPath = Paths.get(modulePathString, DEPENDENCIES_DIR_NAME, UTILS_DIR).toString();\n+            setDirectoryPaths();\n+\n+            // Generate bindings for directly specified Java classes.\n+            outStream.println(\"\\nGenerating bindings for: \");\n             generateBindings(classNames, classLoader, modulePath);\n \n+            // Generate bindings for dependent Java classes.\n             if (!classListForLooping.isEmpty()) {\n                 outStream.println(\"\\nGenerating dependency bindings for: \");\n+                setDependentJavaClass();\n             }\n-            createDirectory(dependenciesPath.toString());\n-            directJavaClass = false;\n             while (!classListForLooping.isEmpty()) {\n                 Set<String> newSet = new HashSet<>(classListForLooping);\n                 newSet.removeAll(classNames);\n+                List<String> existingBindings = getExistingBindings(newSet, modulePath.toFile());\n+                newSet.removeAll(existingBindings);\n                 allJavaClasses.addAll(newSet);\n                 classListForLooping.clear();\n                 generateBindings(newSet, classLoader, dependenciesPath);\n             }\n-            createDirectory(utilsDirPath);\n-            writeOutputFile(null, DEFAULT_TEMPLATE_DIR, JOBJECT_TEMPLATE_NAME,\n-                    Paths.get(utilsDirPath, JOBJECT_FILE_NAME).toString(), false);\n-            writeOutputFile(null, DEFAULT_TEMPLATE_DIR, ARRAY_UTILS_TEMPLATE_NAME,\n-                    Paths.get(utilsDirPath, ARRAY_UTILS_FILE_NAME).toString(), false);\n-\n-            Path constantsPath = Paths.get(utilsDirPath, CONSTANTS_FILE_NAME);\n-            Set<String> names = new HashSet<>(allClasses);\n-            if (constantsPath.toFile().exists()) {\n-                getUpdatedConstantsList(constantsPath, names);\n-                notifyExistingDependencies(classNames, dependenciesPath.toFile());\n-            }\n-            writeOutputFile(names, DEFAULT_TEMPLATE_DIR, CONSTANTS_TEMPLATE_NAME, constantsPath.toString(), true);\n \n+            // Generate the required util files.\n+            generateUtilFiles();\n+\n+            // Handle failed binding generations.\n             if (failedClassGens != null) {\n-                errStream.print(\"\\n\");\n-                for (String className : failedClassGens) {\n-                    if (classNames.contains(className)) {\n-                        errStream.println(\"Bindings for '\" + className + \"' class could not be generated.\");\n-                    }\n-                    String simpleClassName = className.substring(className.lastIndexOf('.') + 1);\n-                    writeOutputFile(className, DEFAULT_TEMPLATE_DIR, EMPTY_OBJECT_TEMPLATE_NAME,\n-                            Paths.get(modulePathString, DEPENDENCIES_DIR_NAME,\n-                                    simpleClassName + BAL_EXTENSION).toString(), false);\n-                }\n+                handleFailedClassGens();\n             }\n-            if (classLoader instanceof URLClassLoader) {\n-                try {\n-                    ((URLClassLoader) classLoader).close();\n-                } catch (IOException ignored) {\n-                }\n+        }\n+    }\n+\n+    private ClassLoader setClassLoader() throws BindgenException {\n+\n+        ClassLoader classLoader;\n+        try {\n+            if (!this.classPaths.isEmpty()) {\n+                classLoader = getClassLoader(this.classPaths, this.getClass().getClassLoader());\n+            } else {\n+                outStream.println(\"No classpaths were detected.\");\n+                classLoader = this.getClass().getClassLoader();\n+            }\n+        } catch (BindgenException e) {\n+            throw new BindgenException(\"Error while loading the classpaths.\", e);\n+        }\n+        return classLoader;\n+    }\n+\n+    private void setDirectoryPaths() {\n+\n+        if (outputPath == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "54f9a85d0c3ba8fb7b1a2d1fbf7925b59c3cfcb2"}, "originalPosition": 171}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTU4NjE5NQ==", "bodyText": "Simplified the code with a temp variable.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22393#discussion_r401586195", "createdAt": "2020-04-01T12:45:37Z", "author": {"login": "IrushiL"}, "path": "misc/ballerina-bindgen/src/main/java/org/ballerinalang/bindgen/command/BindingsGenerator.java", "diffHunk": "@@ -56,90 +58,121 @@\n  */\n public class BindingsGenerator {\n \n-    private String outputPath;\n     private Path modulePath;\n     private Path dependenciesPath;\n+    private Path utilsDirPath;\n+    private String outputPath;\n     private Set<String> classPaths = new HashSet<>();\n     private Set<String> classNames = new HashSet<>();\n+    private static boolean directJavaClass = true;\n     private static final PrintStream errStream = System.err;\n     private static final PrintStream outStream = System.out;\n     private static Path userDir = Paths.get(System.getProperty(USER_DIR));\n \n-    public static boolean directJavaClass = true;\n-    public static Set<String> allClasses = new HashSet<>();\n-    public static Set<String> classListForLooping = new HashSet<>();\n-    public static Set<String> allJavaClasses = new HashSet<>();\n-    public static Set<String> failedClassGens = new HashSet<>();\n+    private static Set<String> allClasses = new HashSet<>();\n+    private static Set<String> classListForLooping = new HashSet<>();\n+    private static Set<String> allJavaClasses = new HashSet<>();\n+    private static Map<String, String> failedClassGens = new HashMap<>();\n \n     void generateJavaBindings() throws BindgenException {\n \n-        ClassLoader classLoader;\n-        try {\n-            if (!this.classPaths.isEmpty()) {\n-                classLoader = getClassLoader(this.classPaths, this.getClass().getClassLoader());\n-            } else {\n-                classLoader = this.getClass().getClassLoader();\n-            }\n-        } catch (BindgenException e) {\n-            throw new BindgenException(\"Error while loading the classpaths.\", e);\n-        }\n+        ClassLoader classLoader = setClassLoader();\n         if (classLoader != null) {\n-            if (this.outputPath == null) {\n-                this.modulePath = Paths.get(userDir.toString(), BALLERINA_BINDINGS_DIR);\n-                this.dependenciesPath = Paths.get(userDir.toString(), BALLERINA_BINDINGS_DIR, DEPENDENCIES_DIR_NAME);\n-            } else {\n-                this.modulePath = Paths.get(outputPath, BALLERINA_BINDINGS_DIR);\n-                this.dependenciesPath = Paths.get(outputPath, BALLERINA_BINDINGS_DIR, DEPENDENCIES_DIR_NAME);\n-            }\n-            outStream.println(\"Generating bindings for: \");\n-            String modulePathString = modulePath.toString();\n-            String utilsDirPath = Paths.get(modulePathString, DEPENDENCIES_DIR_NAME, UTILS_DIR).toString();\n+            setDirectoryPaths();\n+\n+            // Generate bindings for directly specified Java classes.\n+            outStream.println(\"\\nGenerating bindings for: \");\n             generateBindings(classNames, classLoader, modulePath);\n \n+            // Generate bindings for dependent Java classes.\n             if (!classListForLooping.isEmpty()) {\n                 outStream.println(\"\\nGenerating dependency bindings for: \");\n+                setDependentJavaClass();\n             }\n-            createDirectory(dependenciesPath.toString());\n-            directJavaClass = false;\n             while (!classListForLooping.isEmpty()) {\n                 Set<String> newSet = new HashSet<>(classListForLooping);\n                 newSet.removeAll(classNames);\n+                List<String> existingBindings = getExistingBindings(newSet, modulePath.toFile());\n+                newSet.removeAll(existingBindings);\n                 allJavaClasses.addAll(newSet);\n                 classListForLooping.clear();\n                 generateBindings(newSet, classLoader, dependenciesPath);\n             }\n-            createDirectory(utilsDirPath);\n-            writeOutputFile(null, DEFAULT_TEMPLATE_DIR, JOBJECT_TEMPLATE_NAME,\n-                    Paths.get(utilsDirPath, JOBJECT_FILE_NAME).toString(), false);\n-            writeOutputFile(null, DEFAULT_TEMPLATE_DIR, ARRAY_UTILS_TEMPLATE_NAME,\n-                    Paths.get(utilsDirPath, ARRAY_UTILS_FILE_NAME).toString(), false);\n-\n-            Path constantsPath = Paths.get(utilsDirPath, CONSTANTS_FILE_NAME);\n-            Set<String> names = new HashSet<>(allClasses);\n-            if (constantsPath.toFile().exists()) {\n-                getUpdatedConstantsList(constantsPath, names);\n-                notifyExistingDependencies(classNames, dependenciesPath.toFile());\n-            }\n-            writeOutputFile(names, DEFAULT_TEMPLATE_DIR, CONSTANTS_TEMPLATE_NAME, constantsPath.toString(), true);\n \n+            // Generate the required util files.\n+            generateUtilFiles();\n+\n+            // Handle failed binding generations.\n             if (failedClassGens != null) {\n-                errStream.print(\"\\n\");\n-                for (String className : failedClassGens) {\n-                    if (classNames.contains(className)) {\n-                        errStream.println(\"Bindings for '\" + className + \"' class could not be generated.\");\n-                    }\n-                    String simpleClassName = className.substring(className.lastIndexOf('.') + 1);\n-                    writeOutputFile(className, DEFAULT_TEMPLATE_DIR, EMPTY_OBJECT_TEMPLATE_NAME,\n-                            Paths.get(modulePathString, DEPENDENCIES_DIR_NAME,\n-                                    simpleClassName + BAL_EXTENSION).toString(), false);\n-                }\n+                handleFailedClassGens();\n             }\n-            if (classLoader instanceof URLClassLoader) {\n-                try {\n-                    ((URLClassLoader) classLoader).close();\n-                } catch (IOException ignored) {\n-                }\n+        }\n+    }\n+\n+    private ClassLoader setClassLoader() throws BindgenException {\n+\n+        ClassLoader classLoader;\n+        try {\n+            if (!this.classPaths.isEmpty()) {\n+                classLoader = getClassLoader(this.classPaths, this.getClass().getClassLoader());\n+            } else {\n+                outStream.println(\"No classpaths were detected.\");\n+                classLoader = this.getClass().getClassLoader();\n+            }\n+        } catch (BindgenException e) {\n+            throw new BindgenException(\"Error while loading the classpaths.\", e);\n+        }\n+        return classLoader;\n+    }\n+\n+    private void setDirectoryPaths() {\n+\n+        if (outputPath == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTUyODY0OA=="}, "originalCommit": {"oid": "54f9a85d0c3ba8fb7b1a2d1fbf7925b59c3cfcb2"}, "originalPosition": 171}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5MDE3NDIwOnYy", "diffSide": "RIGHT", "path": "misc/ballerina-bindgen/src/main/java/org/ballerinalang/bindgen/model/JParameter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxMDo1ODo1OFrOF-7c8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxMjo0NTo1MlrOF--4uA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTUzMDA5Ng==", "bodyText": "extra new line. You also can remove the extra new lines after each method signature as well.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22393#discussion_r401530096", "createdAt": "2020-04-01T10:58:58Z", "author": {"login": "warunalakshitha"}, "path": "misc/ballerina-bindgen/src/main/java/org/ballerinalang/bindgen/model/JParameter.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.bindgen.model;\n+\n+import java.lang.reflect.Parameter;\n+\n+import static org.ballerinalang.bindgen.command.BindingsGenerator.getAllJavaClasses;\n+import static org.ballerinalang.bindgen.command.BindingsGenerator.setClassListForLooping;\n+import static org.ballerinalang.bindgen.utils.BindgenConstants.BALLERINA_STRING;\n+import static org.ballerinalang.bindgen.utils.BindgenConstants.BALLERINA_STRING_ARRAY;\n+import static org.ballerinalang.bindgen.utils.BindgenUtils.getBallerinaHandleType;\n+import static org.ballerinalang.bindgen.utils.BindgenUtils.getBallerinaParamType;\n+import static org.ballerinalang.bindgen.utils.BindgenUtils.getPrimitiveArrayType;\n+\n+/**\n+ * Class for storing specific parameter details of a Java method used for Ballerina bridge code generation.\n+ */\n+public class JParameter {\n+\n+    private String type;\n+    private String externalType;\n+    private String shortTypeName;\n+    private String componentType;\n+    private String fieldName;\n+\n+    private Boolean isObj = false;\n+    private Boolean hasNext = true;\n+    private Boolean isString = false;\n+    private Boolean isObjArray = false;\n+    private Boolean isPrimitiveArray = false;\n+\n+    JParameter(Class parameterClass) {\n+\n+        type = parameterClass.getName();\n+        shortTypeName = getBallerinaParamType(parameterClass);\n+\n+        if (!parameterClass.isPrimitive()) {\n+            isObj = true;\n+        }\n+        if (parameterClass.equals(String.class)) {\n+            isString = true;\n+            shortTypeName = BALLERINA_STRING;\n+        } else if (parameterClass.equals(String[].class)) {\n+            isString = true;\n+            shortTypeName = BALLERINA_STRING_ARRAY;\n+        } else {\n+            if (!parameterClass.isPrimitive()) {\n+                if (parameterClass.isArray()) {\n+                    setArrayAttributes(parameterClass);\n+                } else {\n+                    String paramType = parameterClass.getName();\n+                    if (!getAllJavaClasses().contains(paramType)) {\n+                        setClassListForLooping(paramType);\n+                    }\n+                }\n+            }\n+        }\n+        externalType = getBallerinaHandleType(parameterClass);\n+        fieldName = \"arg\";\n+    }\n+\n+    JParameter(Parameter parameter) {\n+\n+        this(parameter.getType());\n+        fieldName = parameter.getName();\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "54f9a85d0c3ba8fb7b1a2d1fbf7925b59c3cfcb2"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTU4NjM2MA==", "bodyText": "Done.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22393#discussion_r401586360", "createdAt": "2020-04-01T12:45:52Z", "author": {"login": "IrushiL"}, "path": "misc/ballerina-bindgen/src/main/java/org/ballerinalang/bindgen/model/JParameter.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.bindgen.model;\n+\n+import java.lang.reflect.Parameter;\n+\n+import static org.ballerinalang.bindgen.command.BindingsGenerator.getAllJavaClasses;\n+import static org.ballerinalang.bindgen.command.BindingsGenerator.setClassListForLooping;\n+import static org.ballerinalang.bindgen.utils.BindgenConstants.BALLERINA_STRING;\n+import static org.ballerinalang.bindgen.utils.BindgenConstants.BALLERINA_STRING_ARRAY;\n+import static org.ballerinalang.bindgen.utils.BindgenUtils.getBallerinaHandleType;\n+import static org.ballerinalang.bindgen.utils.BindgenUtils.getBallerinaParamType;\n+import static org.ballerinalang.bindgen.utils.BindgenUtils.getPrimitiveArrayType;\n+\n+/**\n+ * Class for storing specific parameter details of a Java method used for Ballerina bridge code generation.\n+ */\n+public class JParameter {\n+\n+    private String type;\n+    private String externalType;\n+    private String shortTypeName;\n+    private String componentType;\n+    private String fieldName;\n+\n+    private Boolean isObj = false;\n+    private Boolean hasNext = true;\n+    private Boolean isString = false;\n+    private Boolean isObjArray = false;\n+    private Boolean isPrimitiveArray = false;\n+\n+    JParameter(Class parameterClass) {\n+\n+        type = parameterClass.getName();\n+        shortTypeName = getBallerinaParamType(parameterClass);\n+\n+        if (!parameterClass.isPrimitive()) {\n+            isObj = true;\n+        }\n+        if (parameterClass.equals(String.class)) {\n+            isString = true;\n+            shortTypeName = BALLERINA_STRING;\n+        } else if (parameterClass.equals(String[].class)) {\n+            isString = true;\n+            shortTypeName = BALLERINA_STRING_ARRAY;\n+        } else {\n+            if (!parameterClass.isPrimitive()) {\n+                if (parameterClass.isArray()) {\n+                    setArrayAttributes(parameterClass);\n+                } else {\n+                    String paramType = parameterClass.getName();\n+                    if (!getAllJavaClasses().contains(paramType)) {\n+                        setClassListForLooping(paramType);\n+                    }\n+                }\n+            }\n+        }\n+        externalType = getBallerinaHandleType(parameterClass);\n+        fieldName = \"arg\";\n+    }\n+\n+    JParameter(Parameter parameter) {\n+\n+        this(parameter.getType());\n+        fieldName = parameter.getName();\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTUzMDA5Ng=="}, "originalCommit": {"oid": "54f9a85d0c3ba8fb7b1a2d1fbf7925b59c3cfcb2"}, "originalPosition": 81}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4496, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}