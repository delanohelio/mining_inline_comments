{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE2Njc1MTMx", "number": 23180, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxMjo1Njo0NFrOD7oxAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxMzoxMTowMlrOD7pIPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzODYwNDgzOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxMjo1Njo0NFrOGUFN9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxMjo1Njo0NFrOGUFN9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzcxMDE5Nw==", "bodyText": "I think we don't need a context for this one. parseTypeDescriptor  inside parseTypeParameter() does that.\nUnlike in L#8069, for this one TYPE_DESC_IN_ANGLE_BRACKETS is OK, since the table-type ends after this.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23180#discussion_r423710197", "createdAt": "2020-05-12T12:56:44Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -8047,7 +8052,105 @@ private STNode parseBacktickToken(ParserRuleContext ctx) {\n     }\n \n     /**\n-     * Parse function type descriptor.\n+     * Parse table type descriptor.\n+     * <p>\n+     * table-type-descriptor := table row-type-parameter [key-constraint]\n+     * row-type-parameter := type-parameter\n+     * key-constraint := key-specifier | key-type-constraint\n+     * key-specifier := key ( [ field-name (, field-name)* ] )\n+     * key-type-constraint := key type-parameter\n+     * </p>\n+     *\n+     * @return Parsed table type desc node\n+     */\n+    private STNode parseTableTypeDescriptor() {\n+        startContext(ParserRuleContext.TABLE_TYPE_DESCRIPTOR);\n+        STNode tableKeywordToken = parseTableKeyword();\n+        STNode typeParameterNode = parseTypeParameter();\n+        STNode keyConstraintNode;\n+        STToken nextToken = peek();\n+        if (nextToken.kind == SyntaxKind.KEY_KEYWORD) {\n+            STNode keyKeywordToken = parseKeyKeyword();\n+            keyConstraintNode = parseKeyConstraint(keyKeywordToken);\n+        } else {\n+            keyConstraintNode = STNodeFactory.createEmptyNode();\n+        }\n+\n+        endContext();\n+        return STNodeFactory.createTableTypeDescriptorNode(tableKeywordToken, typeParameterNode, keyConstraintNode);\n+    }\n+\n+    /** Parse key constraint.\n+     * <p> key-constraint := key-specifier | key-type-constraint</p>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseKeyConstraint(STNode keyKeywordToken) {\n+        return parseKeyConstraint(peek().kind, keyKeywordToken);\n+    }\n+\n+    private STNode parseKeyConstraint(SyntaxKind nextTokenKind, STNode keyKeywordToken) {\n+        switch (nextTokenKind) {\n+            case OPEN_PAREN_TOKEN:\n+                return parseKeySpecifier(keyKeywordToken);\n+            case LT_TOKEN:\n+                return parseKeyTypeConstraint(keyKeywordToken);\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.KEY_CONSTRAINTS_RHS, keyKeywordToken);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+                return parseKeyConstraint(solution.tokenKind, keyKeywordToken);\n+        }\n+    }\n+\n+    /**\n+     * Parse key specifier given parsed key keyword token.\n+     * <p>\n+     * <code>key-specifier := key ( [ field-name (, field-name)* ] )</code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseKeySpecifier(STNode keyKeywordToken) {\n+        startContext(ParserRuleContext.KEY_SPECIFIER);\n+        STNode openParenToken = parseOpenParenthesis();\n+        STNode fieldNamesNode = parseFieldNames();\n+        STNode closeParenToken = parseCloseParenthesis();\n+        endContext();\n+        return STNodeFactory.createKeySpecifierNode(keyKeywordToken, openParenToken, fieldNamesNode, closeParenToken);\n+    }\n+\n+    /**\n+     * Parse type parameter node.\n+     * <p>type-parameter := < type-descriptor > </p>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseTypeParameter() {\n+        STNode ltToken = parseLTToken();\n+        STNode typeNode = parseTypeDescriptor(ParserRuleContext.TYPE_DESC_IN_ANGLE_BRACKETS);\n+        STNode gtToken = parseGTToken();\n+        return STNodeFactory.createTypeParameterNode(ltToken, typeNode, gtToken);\n+    }\n+\n+    /**\n+     * Parse key type constraint.\n+     * <p>key-type-constraint := key type-parameter</p>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseKeyTypeConstraint(STNode keyKeywordToken) {\n+        startContext(ParserRuleContext.KEY_TYPE_CONSTRAINT_RHS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "699bb0c5d04ce7da8cb1a0d82a79d7e07b79dbca"}, "originalPosition": 123}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzODYxNTI0OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxMjo1OTowOFrOGUFUeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxMjo1OTowOFrOGUFUeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzcxMTg2NA==", "bodyText": "We may have to give a different context to the parseTypeParameter method. Inside that method, by default, a TYPE_DESC_IN_ANGLE_BRACKETS is started. (Lemme call it FOO for now)\nThe problem with TYPE_DESC_IN_ANGLE_BRACKETS is, it assumes the immediate > is the end of the type desc. But for table, it is not the end.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23180#discussion_r423711864", "createdAt": "2020-05-12T12:59:08Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -8047,7 +8052,105 @@ private STNode parseBacktickToken(ParserRuleContext ctx) {\n     }\n \n     /**\n-     * Parse function type descriptor.\n+     * Parse table type descriptor.\n+     * <p>\n+     * table-type-descriptor := table row-type-parameter [key-constraint]\n+     * row-type-parameter := type-parameter\n+     * key-constraint := key-specifier | key-type-constraint\n+     * key-specifier := key ( [ field-name (, field-name)* ] )\n+     * key-type-constraint := key type-parameter\n+     * </p>\n+     *\n+     * @return Parsed table type desc node\n+     */\n+    private STNode parseTableTypeDescriptor() {\n+        startContext(ParserRuleContext.TABLE_TYPE_DESCRIPTOR);\n+        STNode tableKeywordToken = parseTableKeyword();\n+        STNode typeParameterNode = parseTypeParameter();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "699bb0c5d04ce7da8cb1a0d82a79d7e07b79dbca"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzODY1Njk3OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxMzowOToyNVrOGUFvbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxMzowOToyNVrOGUFvbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzcxODc2NQ==", "bodyText": "An alternative way is to give an alias to < as use it here. For example say row-type-param-start as the next context.\nThen inside the getNextRule() method, for the row-type-param-start, we can give the FOO (which i mentioned earlier) as the next-rule.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23180#discussion_r423718765", "createdAt": "2020-05-12T13:09:25Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -1857,10 +1873,18 @@ protected ParserRuleContext getNextRule(ParserRuleContext currentCtx, int nextLo\n             case TABLE_CONSTRUCTOR:\n                 return ParserRuleContext.TABLE_KEYWORD;\n             case TABLE_KEYWORD:\n+                parentCtx = getParentContext();\n+                if (parentCtx == ParserRuleContext.TABLE_TYPE_DESCRIPTOR) {\n+                    return ParserRuleContext.LT;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "699bb0c5d04ce7da8cb1a0d82a79d7e07b79dbca"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzODY2NDI5OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxMzoxMTowMlrOGUF0Bg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxMzoxMTowMlrOGUF0Bg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzcxOTk0Mg==", "bodyText": "Similar to LT, if we can give an alias to >, we can avoid the complication inside getNextRuleForGt", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23180#discussion_r423719942", "createdAt": "2020-05-12T13:11:02Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -2206,6 +2221,8 @@ private ParserRuleContext getNextRuleForTypeDescriptor() {\n                 return ParserRuleContext.VARIABLE_NAME;\n             case ANNOTATION_DECL:\n                 return ParserRuleContext.IDENTIFIER;\n+            case KEY_TYPE_CONSTRAINT_RHS:\n+                return ParserRuleContext.GT;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "699bb0c5d04ce7da8cb1a0d82a79d7e07b79dbca"}, "originalPosition": 157}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3640, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}