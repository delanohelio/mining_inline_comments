{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDgyNTcxNzE0", "number": 25678, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwNzoxMjoyNVrOEhiX9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwNzoxMjoyNVrOEhiX9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNjAxNjUzOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwNzoxMjoyNVrOHO5tuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwOTowNzo1M1rOHO-CwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4NzcwNQ==", "bodyText": "Don't we need to recover here?\nWhat if theres an additional token (say a public keyword) before the on keyword?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25678#discussion_r485387705", "createdAt": "2020-09-09T07:12:25Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -9504,17 +9501,35 @@ private STNode parseJoinClause(boolean isRhsExpr) {\n     /**\n      * Parse on clause.\n      * <p>\n-     * <code>on clause := on expression</code>\n+     * <code>on clause := `on` expression `equals` expression</code>\n      *\n      * @return On clause node\n      */\n     private STNode parseOnClause(boolean isRhsExpr) {\n+        STToken nextToken = peek();\n+        if (isQueryClauseStartToken(nextToken.kind)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69b8313b8b44227606c61dc2e9fabf14890087c9"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM5Mzg0NA==", "bodyText": "shouldn't that extra token be recovered as invalid in parseOnKeyword() beneath?\n(note that at this point we don't have alternative paths.  path should go through on-keyword)", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25678#discussion_r485393844", "createdAt": "2020-09-09T07:24:16Z", "author": {"login": "lochana-chathura"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -9504,17 +9501,35 @@ private STNode parseJoinClause(boolean isRhsExpr) {\n     /**\n      * Parse on clause.\n      * <p>\n-     * <code>on clause := on expression</code>\n+     * <code>on clause := `on` expression `equals` expression</code>\n      *\n      * @return On clause node\n      */\n     private STNode parseOnClause(boolean isRhsExpr) {\n+        STToken nextToken = peek();\n+        if (isQueryClauseStartToken(nextToken.kind)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4NzcwNQ=="}, "originalCommit": {"oid": "69b8313b8b44227606c61dc2e9fabf14890087c9"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQyNTM0MA==", "bodyText": "ah this is inverted. Sorry, my question should be inverted too :)\nWhat if theres an additional token before an actual query-clause starting token?\ne.g:\nfrom var person in personList\nouter join Department dept in deptList\n// missing on clause\nsomeExtraToken select {\n    fname : person.fname,\n    lname : person.lname,\n    dept : dept.name\n};\nwill it keep the 'select' query as is?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25678#discussion_r485425340", "createdAt": "2020-09-09T08:18:15Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -9504,17 +9501,35 @@ private STNode parseJoinClause(boolean isRhsExpr) {\n     /**\n      * Parse on clause.\n      * <p>\n-     * <code>on clause := on expression</code>\n+     * <code>on clause := `on` expression `equals` expression</code>\n      *\n      * @return On clause node\n      */\n     private STNode parseOnClause(boolean isRhsExpr) {\n+        STToken nextToken = peek();\n+        if (isQueryClauseStartToken(nextToken.kind)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4NzcwNQ=="}, "originalCommit": {"oid": "69b8313b8b44227606c61dc2e9fabf14890087c9"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQzODg4OA==", "bodyText": "var a = from var person in personList\nouter join Department dept in deptList\n MISSING[+]// missing on clause\nsomeExtraToken  MISSING[on] MISSING[] MISSING[equals] MISSING[]select {\n    fname : person.fname,\n    lname : person.lname,\n    dept : dept.name\n};\n\nAbove is the recovery if that extra token is an identifier.  if it is publicrecovery is pretty bad yet it is a valid syntax.\nvar a = from var person in personList\nouter join Department dept in deptList\n MISSING[on] MISSING[<-]// missing on clause\n INVALID[public]  INVALID[select] {\n    fname : person MISSING[,] INVALID[.]fname,\n    lname : person MISSING[,] INVALID[.]lname,\n    dept : dept MISSING[}].name\n MISSING[equals] MISSING[] MISSING[select] MISSING[] INVALID[}];\n\nIf we are going to handle when there's a  non-identifier token before the beginning of next clause in absence of join-on-condition it is like we are making join-on-condition optional in the error handler. As we don't allow that non-identifier to be part of join-on-condition. I think if there are extra tokens they should be allowed to be a part of join-on-condition recovery.\nWDYT?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25678#discussion_r485438888", "createdAt": "2020-09-09T08:39:22Z", "author": {"login": "lochana-chathura"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -9504,17 +9501,35 @@ private STNode parseJoinClause(boolean isRhsExpr) {\n     /**\n      * Parse on clause.\n      * <p>\n-     * <code>on clause := on expression</code>\n+     * <code>on clause := `on` expression `equals` expression</code>\n      *\n      * @return On clause node\n      */\n     private STNode parseOnClause(boolean isRhsExpr) {\n+        STToken nextToken = peek();\n+        if (isQueryClauseStartToken(nextToken.kind)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4NzcwNQ=="}, "originalCommit": {"oid": "69b8313b8b44227606c61dc2e9fabf14890087c9"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQ0ODU5NA==", "bodyText": "We can do something like this in the error handler though. before parsing on-clause as next rule, we check if the next lookahead token is one of query starting tokens and if and only if, we skip join-on-condition path in the error handler. I feel that way recovery logic is consistence with parsing logic.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25678#discussion_r485448594", "createdAt": "2020-09-09T08:53:08Z", "author": {"login": "lochana-chathura"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -9504,17 +9501,35 @@ private STNode parseJoinClause(boolean isRhsExpr) {\n     /**\n      * Parse on clause.\n      * <p>\n-     * <code>on clause := on expression</code>\n+     * <code>on clause := `on` expression `equals` expression</code>\n      *\n      * @return On clause node\n      */\n     private STNode parseOnClause(boolean isRhsExpr) {\n+        STToken nextToken = peek();\n+        if (isQueryClauseStartToken(nextToken.kind)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4NzcwNQ=="}, "originalCommit": {"oid": "69b8313b8b44227606c61dc2e9fabf14890087c9"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQ1ODYyNQ==", "bodyText": "hmm, I feel which ever option we take, there will be consequences.\nWe can go ahead with the current approach, and can revisit if it becomes an actual issue.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25678#discussion_r485458625", "createdAt": "2020-09-09T09:07:53Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -9504,17 +9501,35 @@ private STNode parseJoinClause(boolean isRhsExpr) {\n     /**\n      * Parse on clause.\n      * <p>\n-     * <code>on clause := on expression</code>\n+     * <code>on clause := `on` expression `equals` expression</code>\n      *\n      * @return On clause node\n      */\n     private STNode parseOnClause(boolean isRhsExpr) {\n+        STToken nextToken = peek();\n+        if (isQueryClauseStartToken(nextToken.kind)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4NzcwNQ=="}, "originalCommit": {"oid": "69b8313b8b44227606c61dc2e9fabf14890087c9"}, "originalPosition": 119}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 51, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}