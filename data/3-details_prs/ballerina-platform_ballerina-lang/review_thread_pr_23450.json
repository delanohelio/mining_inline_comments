{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIyMDczODUy", "number": 23450, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QxMjoxMjo1OVrOD_IQLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QxMjoxMzoxNFrOD_IQPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NTIyMDkyOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QxMjoxMjo1OVrOGZpFKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QxMjoxMjo1OVrOGZpFKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU0MDY1MQ==", "bodyText": "Can say parseEnumMemberEnd", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23450#discussion_r429540651", "createdAt": "2020-05-23T12:12:59Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -10857,4 +10866,164 @@ private STNode parseConditionalExpression(STNode lhsExpr) {\n         STNode endExpr = parseExpression(OperatorPrecedence.ELVIS_CONDITIONAL, true, false);\n         return STNodeFactory.createConditionalExpressionNode(lhsExpr, questionMark, middleExpr, colon, endExpr);\n     }\n+\n+    /**\n+     * Parse enum declaration.\n+     * <p>\n+     * module-enum-decl :=\n+     *  metadata\n+     *  [public] enum identifier { enum-member (, enum-member)* }\n+     * enum-member := metadata identifier [= const-expr]\n+     * </p>\n+     * @param metadata\n+     * @param qualifier\n+     *\n+     * @return Parsed enum node.\n+     */\n+    private STNode parseEnumDeclaration(STNode metadata, STNode qualifier) {\n+        startContext(ParserRuleContext.MODULE_ENUM_DECLARATION);\n+        STNode enumKeywordToken = parseEnumKeyword();\n+        STNode identifier = parseIdentifier(ParserRuleContext.MODULE_ENUM_NAME);\n+        STNode openBraceToken = parseOpenBrace();\n+        STNode enumMemberList = parseEnumMemberList();\n+        STNode closeBraceToken = parseCloseBrace();\n+\n+        endContext();\n+        return STNodeFactory.createEnumDeclarationNode(metadata, qualifier, enumKeywordToken, identifier,\n+                openBraceToken, enumMemberList, closeBraceToken);\n+    }\n+\n+    /**\n+     * Parse enum member list.\n+     * <p>enum-member := metadata identifier [= const-expr]</p>\n+     *\n+     * @return enum member list node.\n+     */\n+    private STNode parseEnumMemberList() {\n+        startContext(ParserRuleContext.ENUM_MEMBER_LIST);\n+        List<STNode> enumMemberList = new ArrayList<>();\n+        STToken nextToken = peek();\n+\n+        // Report an empty enum member list\n+        if (nextToken.kind == SyntaxKind.CLOSE_BRACE_TOKEN) {\n+            this.errorHandler.reportMissingTokenError(\"enum member list cannot be empty\");\n+            return STNodeFactory.createNodeList(new ArrayList<>());\n+        }\n+\n+        // Parse first enum member, that has no leading comma\n+        STNode enumMember = parseEnumMember();\n+\n+        // Parse the remaining enum members\n+        nextToken = peek();\n+        STNode enumMemberRhs;\n+        while (nextToken.kind != SyntaxKind.CLOSE_BRACE_TOKEN) {\n+            enumMemberRhs = parseEnumMemberRhs(nextToken.kind);\n+            if (enumMemberRhs == null) {\n+                break;\n+            }\n+            enumMemberList.add(enumMember);\n+            enumMemberList.add(enumMemberRhs);\n+            enumMember = parseEnumMember();\n+            nextToken = peek();\n+        }\n+\n+        enumMemberList.add(enumMember);\n+\n+        endContext();\n+        return STNodeFactory.createNodeList(enumMemberList);\n+    }\n+\n+    /**\n+     * Parse enum member.\n+     * <p>enum-member := metadata identifier [= const-expr]</p>\n+     *\n+     * @return Parsed enum member node.\n+     */\n+    private STNode parseEnumMember() {\n+        STToken nextToken = peek();\n+        STNode metadata;\n+        switch (nextToken.kind) {\n+            case DOCUMENTATION_LINE:\n+            case AT_TOKEN:\n+                metadata = parseMetaData(nextToken.kind);\n+                break;\n+            default:\n+                metadata = STNodeFactory.createEmptyNode();\n+        }\n+\n+        STNode identifierNode = parseIdentifier(ParserRuleContext.ENUM_MEMBER_NAME);\n+        return parseEnumMemberInternalRhs(metadata, identifierNode);\n+    }\n+\n+    private STNode parseEnumMemberInternalRhs(STNode metadata, STNode identifierNode) {\n+        return parseEnumMemberInternalRhs(metadata, identifierNode, peek().kind);\n+    }\n+\n+    private STNode parseEnumMemberInternalRhs(STNode metadata, STNode identifierNode, SyntaxKind nextToken) {\n+        STNode equalToken, constExprNode;\n+        switch (nextToken) {\n+            case EQUAL_TOKEN:\n+                equalToken = parseAssignOp();\n+                constExprNode = parseExpression();\n+                break;\n+            case COMMA_TOKEN:\n+            case CLOSE_BRACE_TOKEN:\n+                equalToken = STNodeFactory.createEmptyNode();\n+                constExprNode = STNodeFactory.createEmptyNode();\n+                break;\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.ENUM_MEMBER_INTERNAL_RHS, metadata,\n+                        identifierNode);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseEnumMemberInternalRhs(metadata, identifierNode, solution.tokenKind);\n+        }\n+\n+        return STNodeFactory.createEnumMemberNode(metadata, identifierNode, equalToken, constExprNode);\n+    }\n+\n+    private STNode parseEnumMemberRhs() {\n+        return parseEnumMemberRhs(peek().kind);\n+    }\n+\n+    private STNode parseEnumMemberRhs(SyntaxKind nextTokenKind) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "126f69cb7996d944324fa820a43b45288ae77074"}, "originalPosition": 170}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NTIyMTEwOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QxMjoxMzoxNFrOGZpFQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QxMjoxNDowN1rOGZpFYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU0MDY3Mw==", "bodyText": "can say parseEnumMemberRhs", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23450#discussion_r429540673", "createdAt": "2020-05-23T12:13:14Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -10857,4 +10866,164 @@ private STNode parseConditionalExpression(STNode lhsExpr) {\n         STNode endExpr = parseExpression(OperatorPrecedence.ELVIS_CONDITIONAL, true, false);\n         return STNodeFactory.createConditionalExpressionNode(lhsExpr, questionMark, middleExpr, colon, endExpr);\n     }\n+\n+    /**\n+     * Parse enum declaration.\n+     * <p>\n+     * module-enum-decl :=\n+     *  metadata\n+     *  [public] enum identifier { enum-member (, enum-member)* }\n+     * enum-member := metadata identifier [= const-expr]\n+     * </p>\n+     * @param metadata\n+     * @param qualifier\n+     *\n+     * @return Parsed enum node.\n+     */\n+    private STNode parseEnumDeclaration(STNode metadata, STNode qualifier) {\n+        startContext(ParserRuleContext.MODULE_ENUM_DECLARATION);\n+        STNode enumKeywordToken = parseEnumKeyword();\n+        STNode identifier = parseIdentifier(ParserRuleContext.MODULE_ENUM_NAME);\n+        STNode openBraceToken = parseOpenBrace();\n+        STNode enumMemberList = parseEnumMemberList();\n+        STNode closeBraceToken = parseCloseBrace();\n+\n+        endContext();\n+        return STNodeFactory.createEnumDeclarationNode(metadata, qualifier, enumKeywordToken, identifier,\n+                openBraceToken, enumMemberList, closeBraceToken);\n+    }\n+\n+    /**\n+     * Parse enum member list.\n+     * <p>enum-member := metadata identifier [= const-expr]</p>\n+     *\n+     * @return enum member list node.\n+     */\n+    private STNode parseEnumMemberList() {\n+        startContext(ParserRuleContext.ENUM_MEMBER_LIST);\n+        List<STNode> enumMemberList = new ArrayList<>();\n+        STToken nextToken = peek();\n+\n+        // Report an empty enum member list\n+        if (nextToken.kind == SyntaxKind.CLOSE_BRACE_TOKEN) {\n+            this.errorHandler.reportMissingTokenError(\"enum member list cannot be empty\");\n+            return STNodeFactory.createNodeList(new ArrayList<>());\n+        }\n+\n+        // Parse first enum member, that has no leading comma\n+        STNode enumMember = parseEnumMember();\n+\n+        // Parse the remaining enum members\n+        nextToken = peek();\n+        STNode enumMemberRhs;\n+        while (nextToken.kind != SyntaxKind.CLOSE_BRACE_TOKEN) {\n+            enumMemberRhs = parseEnumMemberRhs(nextToken.kind);\n+            if (enumMemberRhs == null) {\n+                break;\n+            }\n+            enumMemberList.add(enumMember);\n+            enumMemberList.add(enumMemberRhs);\n+            enumMember = parseEnumMember();\n+            nextToken = peek();\n+        }\n+\n+        enumMemberList.add(enumMember);\n+\n+        endContext();\n+        return STNodeFactory.createNodeList(enumMemberList);\n+    }\n+\n+    /**\n+     * Parse enum member.\n+     * <p>enum-member := metadata identifier [= const-expr]</p>\n+     *\n+     * @return Parsed enum member node.\n+     */\n+    private STNode parseEnumMember() {\n+        STToken nextToken = peek();\n+        STNode metadata;\n+        switch (nextToken.kind) {\n+            case DOCUMENTATION_LINE:\n+            case AT_TOKEN:\n+                metadata = parseMetaData(nextToken.kind);\n+                break;\n+            default:\n+                metadata = STNodeFactory.createEmptyNode();\n+        }\n+\n+        STNode identifierNode = parseIdentifier(ParserRuleContext.ENUM_MEMBER_NAME);\n+        return parseEnumMemberInternalRhs(metadata, identifierNode);\n+    }\n+\n+    private STNode parseEnumMemberInternalRhs(STNode metadata, STNode identifierNode) {\n+        return parseEnumMemberInternalRhs(metadata, identifierNode, peek().kind);\n+    }\n+\n+    private STNode parseEnumMemberInternalRhs(STNode metadata, STNode identifierNode, SyntaxKind nextToken) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "126f69cb7996d944324fa820a43b45288ae77074"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU0MDcwNA==", "bodyText": "Let's have the SyntaxKind nextToken as the first param. Thats the pattern we have followed elsewhere...", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23450#discussion_r429540704", "createdAt": "2020-05-23T12:14:07Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -10857,4 +10866,164 @@ private STNode parseConditionalExpression(STNode lhsExpr) {\n         STNode endExpr = parseExpression(OperatorPrecedence.ELVIS_CONDITIONAL, true, false);\n         return STNodeFactory.createConditionalExpressionNode(lhsExpr, questionMark, middleExpr, colon, endExpr);\n     }\n+\n+    /**\n+     * Parse enum declaration.\n+     * <p>\n+     * module-enum-decl :=\n+     *  metadata\n+     *  [public] enum identifier { enum-member (, enum-member)* }\n+     * enum-member := metadata identifier [= const-expr]\n+     * </p>\n+     * @param metadata\n+     * @param qualifier\n+     *\n+     * @return Parsed enum node.\n+     */\n+    private STNode parseEnumDeclaration(STNode metadata, STNode qualifier) {\n+        startContext(ParserRuleContext.MODULE_ENUM_DECLARATION);\n+        STNode enumKeywordToken = parseEnumKeyword();\n+        STNode identifier = parseIdentifier(ParserRuleContext.MODULE_ENUM_NAME);\n+        STNode openBraceToken = parseOpenBrace();\n+        STNode enumMemberList = parseEnumMemberList();\n+        STNode closeBraceToken = parseCloseBrace();\n+\n+        endContext();\n+        return STNodeFactory.createEnumDeclarationNode(metadata, qualifier, enumKeywordToken, identifier,\n+                openBraceToken, enumMemberList, closeBraceToken);\n+    }\n+\n+    /**\n+     * Parse enum member list.\n+     * <p>enum-member := metadata identifier [= const-expr]</p>\n+     *\n+     * @return enum member list node.\n+     */\n+    private STNode parseEnumMemberList() {\n+        startContext(ParserRuleContext.ENUM_MEMBER_LIST);\n+        List<STNode> enumMemberList = new ArrayList<>();\n+        STToken nextToken = peek();\n+\n+        // Report an empty enum member list\n+        if (nextToken.kind == SyntaxKind.CLOSE_BRACE_TOKEN) {\n+            this.errorHandler.reportMissingTokenError(\"enum member list cannot be empty\");\n+            return STNodeFactory.createNodeList(new ArrayList<>());\n+        }\n+\n+        // Parse first enum member, that has no leading comma\n+        STNode enumMember = parseEnumMember();\n+\n+        // Parse the remaining enum members\n+        nextToken = peek();\n+        STNode enumMemberRhs;\n+        while (nextToken.kind != SyntaxKind.CLOSE_BRACE_TOKEN) {\n+            enumMemberRhs = parseEnumMemberRhs(nextToken.kind);\n+            if (enumMemberRhs == null) {\n+                break;\n+            }\n+            enumMemberList.add(enumMember);\n+            enumMemberList.add(enumMemberRhs);\n+            enumMember = parseEnumMember();\n+            nextToken = peek();\n+        }\n+\n+        enumMemberList.add(enumMember);\n+\n+        endContext();\n+        return STNodeFactory.createNodeList(enumMemberList);\n+    }\n+\n+    /**\n+     * Parse enum member.\n+     * <p>enum-member := metadata identifier [= const-expr]</p>\n+     *\n+     * @return Parsed enum member node.\n+     */\n+    private STNode parseEnumMember() {\n+        STToken nextToken = peek();\n+        STNode metadata;\n+        switch (nextToken.kind) {\n+            case DOCUMENTATION_LINE:\n+            case AT_TOKEN:\n+                metadata = parseMetaData(nextToken.kind);\n+                break;\n+            default:\n+                metadata = STNodeFactory.createEmptyNode();\n+        }\n+\n+        STNode identifierNode = parseIdentifier(ParserRuleContext.ENUM_MEMBER_NAME);\n+        return parseEnumMemberInternalRhs(metadata, identifierNode);\n+    }\n+\n+    private STNode parseEnumMemberInternalRhs(STNode metadata, STNode identifierNode) {\n+        return parseEnumMemberInternalRhs(metadata, identifierNode, peek().kind);\n+    }\n+\n+    private STNode parseEnumMemberInternalRhs(STNode metadata, STNode identifierNode, SyntaxKind nextToken) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU0MDY3Mw=="}, "originalCommit": {"oid": "126f69cb7996d944324fa820a43b45288ae77074"}, "originalPosition": 137}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3589, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}