{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDcwNzUwNjUx", "number": 25351, "title": "Add back writing instructions to BIR binary", "bodyText": "Purpose\nAdd nballerina changes in #25005 to master\nCheck List\n\n Read the Contributing Guide\n Updated Change Log\n Checked Tooling Support (#)\n Added necessary tests\n\n Unit Tests\n Spec Conformance Tests\n Integration Tests\n Ballerina By Example Tests\n\n\n Increased Test Coverage\n Added necessary documentation\n\n API documentation\n Module documentation in Module.md files\n Ballerina By Examples", "createdAt": "2020-08-20T08:24:50Z", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25351", "merged": true, "mergeCommit": {"oid": "7f2c88c2b9b60f3663806ac71470a20e222505a9"}, "closed": true, "closedAt": "2020-08-31T07:56:32Z", "author": {"login": "warunalakshitha"}, "timelineItems": {"totalCount": 19, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdAr1JMAH2gAyNDcwNzUwNjUxOmIxNTc0NDExMzRjMWUwOTE5ODIzNjI4YWE3NDRlNDk3MDNjNjY3ZTk=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdENwCVAFqTQ3ODM4MzkzNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "b157441134c1e0919823628aa744e49703c667e9", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b157441134c1e0919823628aa744e49703c667e9", "committedDate": "2020-08-20T08:21:12Z", "message": "Revert \"Merge pull request #22622 from Kishanthan/fix-22513\"\n\nThis reverts commit 0df85689656bca782d23589b60865c648bbc0f40, reversing\nchanges made to 1e4650ad7763559229716110d66bf541d4adf66e."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "998d383ae33545b1f20a25a231a53be8caad684a", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/998d383ae33545b1f20a25a231a53be8caad684a", "committedDate": "2020-08-20T08:21:23Z", "message": "Add NewTable write instruction logic"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "13e44a8ac324a62d50331ecbab6b761f7d710640", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/13e44a8ac324a62d50331ecbab6b761f7d710640", "committedDate": "2020-08-20T08:22:29Z", "message": "Remove commented out code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fe80e9a74ef67bdebf445f608adeb67f34871944", "author": {"user": {"login": "warunalakshitha", "name": "Waruna Lakshitha"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/fe80e9a74ef67bdebf445f608adeb67f34871944", "committedDate": "2020-08-20T08:44:55Z", "message": "Bump bir version to 53"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6fc3de447ec3361b9ab93c473a6610544ffe80f8", "author": {"user": {"login": "warunalakshitha", "name": "Waruna Lakshitha"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6fc3de447ec3361b9ab93c473a6610544ffe80f8", "committedDate": "2020-08-25T07:33:17Z", "message": "Merge master branch"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc0MzA0Mzcx", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25351#pullrequestreview-474304371", "createdAt": "2020-08-25T09:30:56Z", "commit": {"oid": "6fc3de447ec3361b9ab93c473a6610544ffe80f8"}, "state": "COMMENTED", "comments": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQwOTozMDo1N1rOHGPzBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQwOTo0NTowM1rOHGQU-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMxMjMyNg==", "bodyText": "Shall we remove Todo and commented out code", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25351#discussion_r476312326", "createdAt": "2020-08-25T09:30:57Z", "author": {"login": "riyafa"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/BIRPackageSymbolEnter.java", "diffHunk": "@@ -178,10 +184,14 @@ private BPackageSymbol definePackage(PackageID packageId, RepoHierarchy packageR\n             BPackageSymbol pkgSymbol = definePackage(dataInStream);\n             this.env = prevEnv;\n             return pkgSymbol;\n-        } catch (Throwable e) {\n+        } catch (IOException e) {\n             // TODO dlog.error();\n+            throw new BLangCompilerException(e.getMessage(), e);\n+            //            return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6fc3de447ec3361b9ab93c473a6610544ffe80f8"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMxMjc2Mg==", "bodyText": "Same here shall we remove Todo and commented out code?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25351#discussion_r476312762", "createdAt": "2020-08-25T09:31:41Z", "author": {"login": "riyafa"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/BIRPackageSymbolEnter.java", "diffHunk": "@@ -178,10 +184,14 @@ private BPackageSymbol definePackage(PackageID packageId, RepoHierarchy packageR\n             BPackageSymbol pkgSymbol = definePackage(dataInStream);\n             this.env = prevEnv;\n             return pkgSymbol;\n-        } catch (Throwable e) {\n+        } catch (IOException e) {\n             // TODO dlog.error();\n+            throw new BLangCompilerException(e.getMessage(), e);\n+            //            return null;\n+        } catch (Throwable e) {\n             // TODO format error\n             throw new BLangCompilerException(e.getMessage(), e);\n+            //            return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6fc3de447ec3361b9ab93c473a6610544ffe80f8"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMxMzUyMw==", "bodyText": "Shall we create an issue to track the Todo also indicating what could be a possible better way so that it can be fixed in the future?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25351#discussion_r476313523", "createdAt": "2020-08-25T09:32:56Z", "author": {"login": "riyafa"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/BIRPackageSymbolEnter.java", "diffHunk": "@@ -378,10 +402,22 @@ private void defineFunction(DataInputStream dataInStream) throws IOException {\n \n         defineMarkDownDocAttachment(invokableSymbol, readDocBytes(dataInStream));\n \n+        dataInStream.skip(dataInStream.readLong()); // read and skip method body\n+\n         scopeToDefine.define(invokableSymbol.name, invokableSymbol);\n     }\n \n+    private void skipPosition(DataInputStream dataInStream) throws IOException {\n+        // TODO find a better way to skip this", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6fc3de447ec3361b9ab93c473a6610544ffe80f8"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMxMzg4OQ==", "bodyText": "can't we use a for loop to readInt 5 times instead of repeating code?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25351#discussion_r476313889", "createdAt": "2020-08-25T09:33:32Z", "author": {"login": "riyafa"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/BIRPackageSymbolEnter.java", "diffHunk": "@@ -378,10 +402,22 @@ private void defineFunction(DataInputStream dataInStream) throws IOException {\n \n         defineMarkDownDocAttachment(invokableSymbol, readDocBytes(dataInStream));\n \n+        dataInStream.skip(dataInStream.readLong()); // read and skip method body\n+\n         scopeToDefine.define(invokableSymbol.name, invokableSymbol);\n     }\n \n+    private void skipPosition(DataInputStream dataInStream) throws IOException {\n+        // TODO find a better way to skip this\n+        dataInStream.readInt();\n+        dataInStream.readInt();\n+        dataInStream.readInt();\n+        dataInStream.readInt();\n+        dataInStream.readInt();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6fc3de447ec3361b9ab93c473a6610544ffe80f8"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMxNDY3OQ==", "bodyText": "If this constant is to be used outside of this class wouldn't it be better to move it to a relevant Contants class instead of making in public?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25351#discussion_r476314679", "createdAt": "2020-08-25T09:34:45Z", "author": {"login": "riyafa"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/BIRPackageSymbolEnter.java", "diffHunk": "@@ -849,18 +889,18 @@ private PackageID createPackageID(String orgName, String pkgName, String pkgVers\n     }\n \n     private class BIRTypeReader {\n-        static final int SERVICE_TYPE_TAG = 51;\n+        public static final int SERVICE_TYPE_TAG = 51;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6fc3de447ec3361b9ab93c473a6610544ffe80f8"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMxNjM1OA==", "bodyText": "we can combine this with the above line", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25351#discussion_r476316358", "createdAt": "2020-08-25T09:37:21Z", "author": {"login": "riyafa"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/writer/BIRBinaryWriter.java", "diffHunk": "@@ -324,4 +426,59 @@ private int addByteCPEntry(int value) {\n     private void writeType(ByteBuf buf, BType type) {\n         buf.writeInt(cp.addShapeCPEntry(type));\n     }\n+\n+    void writeAnnotAttachments(ByteBuf buff,\n+                                       BIRInstructionWriter insWriter,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6fc3de447ec3361b9ab93c473a6610544ffe80f8"}, "originalPosition": 290}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMxNzI5MQ==", "bodyText": "shall we create an issue to track the todo indicating how to properly use the operand here?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25351#discussion_r476317291", "createdAt": "2020-08-25T09:39:02Z", "author": {"login": "riyafa"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/writer/BIRInstructionWriter.java", "diffHunk": "@@ -0,0 +1,606 @@\n+/*\n+ *  Copyright (c) 2018, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.wso2.ballerinalang.compiler.bir.writer;\n+\n+import io.netty.buffer.ByteBuf;\n+import org.ballerinalang.compiler.BLangCompilerException;\n+import org.ballerinalang.model.elements.PackageID;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRBasicBlock;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRGlobalVariableDcl;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewArray;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewStringXMLQName;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewStructure;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewTypeDesc;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLComment;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLElement;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLProcIns;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLQName;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLText;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.XMLAccess;\n+import org.wso2.ballerinalang.compiler.bir.model.BIROperand;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRTerminator;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRVisitor;\n+import org.wso2.ballerinalang.compiler.bir.model.InstructionKind;\n+import org.wso2.ballerinalang.compiler.bir.model.VarKind;\n+import org.wso2.ballerinalang.compiler.bir.writer.CPEntry.ByteCPEntry;\n+import org.wso2.ballerinalang.compiler.bir.writer.CPEntry.FloatCPEntry;\n+import org.wso2.ballerinalang.compiler.bir.writer.CPEntry.IntegerCPEntry;\n+import org.wso2.ballerinalang.compiler.bir.writer.CPEntry.StringCPEntry;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BType;\n+import org.wso2.ballerinalang.compiler.util.TypeTags;\n+import org.wso2.ballerinalang.compiler.util.diagnotic.DiagnosticPos;\n+\n+import java.util.List;\n+\n+/**\n+ * Responsible for serializing BIR instructions and operands.\n+ *\n+ * @since 0.980.0\n+ */\n+public class BIRInstructionWriter extends BIRVisitor {\n+    private ByteBuf buf;\n+    private BIRTypeWriter typeWriter;\n+    private ConstantPool cp;\n+    private BIRBinaryWriter binaryWriter;\n+\n+    public BIRInstructionWriter(ByteBuf buf, BIRTypeWriter typeWriter, ConstantPool cp,\n+                                BIRBinaryWriter birBinaryWriter) {\n+        this.buf = buf;\n+        this.typeWriter = typeWriter;\n+        this.binaryWriter = birBinaryWriter;\n+        this.cp = cp;\n+    }\n+\n+    public void writeBBs(List<BIRBasicBlock> bbList) {\n+        buf.writeInt(bbList.size());\n+        bbList.forEach(bb -> bb.accept(this));\n+    }\n+\n+    public void visit(BIRBasicBlock birBasicBlock) {\n+        //Name of the basic block\n+        addCpAndWriteString(birBasicBlock.id.value);\n+        // Number of instructions\n+        // Adding the terminator instruction as well.\n+        buf.writeInt(birBasicBlock.instructions.size() + 1);\n+            birBasicBlock.instructions.forEach(instruction -> instruction.accept(this));\n+        if (birBasicBlock.terminator == null) {\n+            throw new BLangCompilerException(\"Basic block without a terminator : \" + birBasicBlock.id);\n+        }\n+        birBasicBlock.terminator.accept(this);\n+    }\n+\n+    public void writeErrorTable(List<BIRNode.BIRErrorEntry> errorEntries) {\n+        buf.writeInt(errorEntries.size());\n+        errorEntries.forEach(birErrorEntry -> birErrorEntry.accept(this));\n+    }\n+\n+    public void visit(BIRNode.BIRErrorEntry errorEntry) {\n+        addCpAndWriteString(errorEntry.trapBB.id.value);\n+        addCpAndWriteString(errorEntry.endBB.id.value);\n+        errorEntry.errorOp.accept(this);\n+        addCpAndWriteString(errorEntry.targetBB.id.value);\n+    }\n+\n+    // Terminating instructions\n+\n+    public void visit(BIRTerminator.GOTO birGoto) {\n+        writePosition(birGoto.pos);\n+        buf.writeByte(birGoto.kind.getValue());\n+        addCpAndWriteString(birGoto.targetBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.Lock lock) {\n+        writePosition(lock.pos);\n+        buf.writeByte(lock.kind.getValue());\n+\n+        addCpAndWriteString(lock.lockedBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.FieldLock lock) {\n+        writePosition(lock.pos);\n+        buf.writeByte(lock.kind.getValue());\n+        // TODO properly use operand instead of variablDcl.name here", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6fc3de447ec3361b9ab93c473a6610544ffe80f8"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMxNzc3NQ==", "bodyText": "Shall we create an issue about why it should return an integer to make sure it is fixed?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25351#discussion_r476317775", "createdAt": "2020-08-25T09:39:51Z", "author": {"login": "riyafa"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/writer/BIRInstructionWriter.java", "diffHunk": "@@ -0,0 +1,606 @@\n+/*\n+ *  Copyright (c) 2018, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.wso2.ballerinalang.compiler.bir.writer;\n+\n+import io.netty.buffer.ByteBuf;\n+import org.ballerinalang.compiler.BLangCompilerException;\n+import org.ballerinalang.model.elements.PackageID;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRBasicBlock;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRGlobalVariableDcl;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewArray;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewStringXMLQName;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewStructure;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewTypeDesc;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLComment;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLElement;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLProcIns;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLQName;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLText;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.XMLAccess;\n+import org.wso2.ballerinalang.compiler.bir.model.BIROperand;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRTerminator;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRVisitor;\n+import org.wso2.ballerinalang.compiler.bir.model.InstructionKind;\n+import org.wso2.ballerinalang.compiler.bir.model.VarKind;\n+import org.wso2.ballerinalang.compiler.bir.writer.CPEntry.ByteCPEntry;\n+import org.wso2.ballerinalang.compiler.bir.writer.CPEntry.FloatCPEntry;\n+import org.wso2.ballerinalang.compiler.bir.writer.CPEntry.IntegerCPEntry;\n+import org.wso2.ballerinalang.compiler.bir.writer.CPEntry.StringCPEntry;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BType;\n+import org.wso2.ballerinalang.compiler.util.TypeTags;\n+import org.wso2.ballerinalang.compiler.util.diagnotic.DiagnosticPos;\n+\n+import java.util.List;\n+\n+/**\n+ * Responsible for serializing BIR instructions and operands.\n+ *\n+ * @since 0.980.0\n+ */\n+public class BIRInstructionWriter extends BIRVisitor {\n+    private ByteBuf buf;\n+    private BIRTypeWriter typeWriter;\n+    private ConstantPool cp;\n+    private BIRBinaryWriter binaryWriter;\n+\n+    public BIRInstructionWriter(ByteBuf buf, BIRTypeWriter typeWriter, ConstantPool cp,\n+                                BIRBinaryWriter birBinaryWriter) {\n+        this.buf = buf;\n+        this.typeWriter = typeWriter;\n+        this.binaryWriter = birBinaryWriter;\n+        this.cp = cp;\n+    }\n+\n+    public void writeBBs(List<BIRBasicBlock> bbList) {\n+        buf.writeInt(bbList.size());\n+        bbList.forEach(bb -> bb.accept(this));\n+    }\n+\n+    public void visit(BIRBasicBlock birBasicBlock) {\n+        //Name of the basic block\n+        addCpAndWriteString(birBasicBlock.id.value);\n+        // Number of instructions\n+        // Adding the terminator instruction as well.\n+        buf.writeInt(birBasicBlock.instructions.size() + 1);\n+            birBasicBlock.instructions.forEach(instruction -> instruction.accept(this));\n+        if (birBasicBlock.terminator == null) {\n+            throw new BLangCompilerException(\"Basic block without a terminator : \" + birBasicBlock.id);\n+        }\n+        birBasicBlock.terminator.accept(this);\n+    }\n+\n+    public void writeErrorTable(List<BIRNode.BIRErrorEntry> errorEntries) {\n+        buf.writeInt(errorEntries.size());\n+        errorEntries.forEach(birErrorEntry -> birErrorEntry.accept(this));\n+    }\n+\n+    public void visit(BIRNode.BIRErrorEntry errorEntry) {\n+        addCpAndWriteString(errorEntry.trapBB.id.value);\n+        addCpAndWriteString(errorEntry.endBB.id.value);\n+        errorEntry.errorOp.accept(this);\n+        addCpAndWriteString(errorEntry.targetBB.id.value);\n+    }\n+\n+    // Terminating instructions\n+\n+    public void visit(BIRTerminator.GOTO birGoto) {\n+        writePosition(birGoto.pos);\n+        buf.writeByte(birGoto.kind.getValue());\n+        addCpAndWriteString(birGoto.targetBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.Lock lock) {\n+        writePosition(lock.pos);\n+        buf.writeByte(lock.kind.getValue());\n+\n+        addCpAndWriteString(lock.lockedBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.FieldLock lock) {\n+        writePosition(lock.pos);\n+        buf.writeByte(lock.kind.getValue());\n+        // TODO properly use operand instead of variablDcl.name here\n+        addCpAndWriteString(lock.localVar.variableDcl.name.value);\n+        addCpAndWriteString(lock.field);\n+        addCpAndWriteString(lock.lockedBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.Unlock unlock) {\n+        writePosition(unlock.pos);\n+        buf.writeByte(unlock.kind.getValue());\n+        addCpAndWriteString(unlock.unlockBB.id.value);\n+    }\n+\n+\n+    public void visit(BIRTerminator.Return birReturn) {\n+        writePosition(birReturn.pos);\n+        buf.writeByte(birReturn.kind.getValue());\n+    }\n+\n+    public void visit(BIRTerminator.Branch birBranch) {\n+        writePosition(birBranch.pos);\n+        buf.writeByte(birBranch.kind.getValue());\n+        birBranch.op.accept(this);\n+        // true:BB\n+        addCpAndWriteString(birBranch.trueBB.id.value);\n+        // false:BB\n+        addCpAndWriteString(birBranch.falseBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.Wait waitEntry) {\n+        writePosition(waitEntry.pos);\n+        buf.writeByte(waitEntry.kind.getValue());\n+        buf.writeInt(waitEntry.exprList.size());\n+        for (BIROperand expr : waitEntry.exprList) {\n+            expr.accept(this);\n+        }\n+        waitEntry.lhsOp.accept(this);\n+        addCpAndWriteString(waitEntry.thenBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.Flush entry) {\n+        writePosition(entry.pos);\n+        buf.writeByte(entry.kind.getValue());\n+        buf.writeInt(entry.channels.length);\n+        for (BIRNode.ChannelDetails detail : entry.channels) {\n+            addCpAndWriteString(detail.name);\n+            buf.writeBoolean(detail.channelInSameStrand);\n+            buf.writeBoolean(detail.send);\n+        }\n+        entry.lhsOp.accept(this);\n+        addCpAndWriteString(entry.thenBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.WorkerReceive entry) {\n+        writePosition(entry.pos);\n+        buf.writeByte((entry.kind.getValue()));\n+        buf.writeInt(addStringCPEntry(entry.workerName.getValue()));\n+        entry.lhsOp.accept(this);\n+        buf.writeBoolean(entry.isSameStrand);\n+        addCpAndWriteString(entry.thenBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.WorkerSend entry) {\n+        writePosition(entry.pos);\n+        buf.writeByte((entry.kind.getValue()));\n+        buf.writeInt(addStringCPEntry(entry.channel.getValue()));\n+        entry.data.accept(this);\n+        buf.writeBoolean(entry.isSameStrand);\n+        buf.writeBoolean(entry.isSync);\n+        if (entry.isSync) {\n+            entry.lhsOp.accept(this);\n+        }\n+        addCpAndWriteString(entry.thenBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.WaitAll waitAll) {\n+        writePosition(waitAll.pos);\n+        buf.writeByte((waitAll.kind.getValue()));\n+        waitAll.lhsOp.accept(this);\n+        buf.writeInt(waitAll.keys.size());\n+        waitAll.keys.forEach(key -> buf.writeInt(addStringCPEntry(key)));\n+        waitAll.valueExprs.forEach(val -> val.accept(this));\n+        addCpAndWriteString(waitAll.thenBB.id.value);\n+    }\n+\n+    // Non-terminating instructions\n+\n+    @Override\n+    public void visit(BIRNonTerminator.NewTable newTable) {\n+        writePosition(newTable.pos);\n+        writeType(newTable.type);\n+        newTable.lhsOp.accept(this);\n+        newTable.keyColOp.accept(this);\n+        newTable.dataOp.accept(this);\n+    }\n+\n+\n+    public void visit(BIRNonTerminator.Move birMove) {\n+        writePosition(birMove.pos);\n+        buf.writeByte(birMove.kind.getValue());\n+        birMove.rhsOp.accept(this);\n+        birMove.lhsOp.accept(this);\n+    }\n+\n+    public void visit(BIRTerminator.Call birCall) {\n+        writePosition(birCall.pos);\n+        buf.writeByte(birCall.kind.getValue());\n+        PackageID calleePkg = birCall.calleePkg;\n+        int pkgIndex = addPkgCPEntry(calleePkg);\n+        buf.writeBoolean(birCall.isVirtual);\n+        buf.writeInt(pkgIndex);\n+        buf.writeInt(addStringCPEntry(birCall.name.getValue()));\n+        buf.writeInt(birCall.args.size());\n+        for (BIROperand arg : birCall.args) {\n+            arg.accept(this);\n+        }\n+        if (birCall.lhsOp != null) {\n+            buf.writeByte(1);\n+            birCall.lhsOp.accept(this);\n+        } else {\n+            buf.writeByte(0);\n+        }\n+        addCpAndWriteString(birCall.thenBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.AsyncCall birAsyncCall) {\n+        writePosition(birAsyncCall.pos);\n+        buf.writeByte(birAsyncCall.kind.getValue());\n+        PackageID calleePkg = birAsyncCall.calleePkg;\n+        int pkgIndex = addPkgCPEntry(calleePkg);\n+        buf.writeBoolean(birAsyncCall.isVirtual);\n+        buf.writeInt(pkgIndex);\n+        buf.writeInt(addStringCPEntry(birAsyncCall.name.getValue()));\n+        buf.writeInt(birAsyncCall.args.size());\n+        for (BIROperand arg : birAsyncCall.args) {\n+            arg.accept(this);\n+        }\n+        if (birAsyncCall.lhsOp != null) {\n+            buf.writeByte(1);\n+            birAsyncCall.lhsOp.accept(this);\n+        } else {\n+            buf.writeByte(0);\n+        }\n+\n+        binaryWriter.writeAnnotAttachments(buf, this, birAsyncCall.annotAttachments);\n+        addCpAndWriteString(birAsyncCall.thenBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.FPCall fpCall) {\n+        writePosition(fpCall.pos);\n+        buf.writeByte(fpCall.kind.getValue());\n+        fpCall.fp.accept(this);\n+        buf.writeInt(fpCall.args.size());\n+        for (BIROperand arg : fpCall.args) {\n+            arg.accept(this);\n+        }\n+        if (fpCall.lhsOp != null) {\n+            buf.writeByte(1);\n+            fpCall.lhsOp.accept(this);\n+        } else {\n+            buf.writeByte(0);\n+        }\n+        buf.writeBoolean(fpCall.isAsync);\n+        addCpAndWriteString(fpCall.thenBB.id.value);\n+    }\n+\n+    public void visit(BIRNonTerminator.BinaryOp birBinaryOp) {\n+        writePosition(birBinaryOp.pos);\n+        buf.writeByte(birBinaryOp.kind.getValue());\n+        birBinaryOp.rhsOp1.accept(this);\n+        birBinaryOp.rhsOp2.accept(this);\n+        birBinaryOp.lhsOp.accept(this);\n+    }\n+\n+    public void visit(BIRNonTerminator.UnaryOP birUnaryOp) {\n+        writePosition(birUnaryOp.pos);\n+        buf.writeByte(birUnaryOp.kind.getValue());\n+        birUnaryOp.rhsOp.accept(this);\n+        birUnaryOp.lhsOp.accept(this);\n+    }\n+\n+    public void visit(BIRNonTerminator.ConstantLoad birConstantLoad) {\n+        writePosition(birConstantLoad.pos);\n+        buf.writeByte(birConstantLoad.kind.getValue());\n+        writeType(birConstantLoad.type);\n+        birConstantLoad.lhsOp.accept(this);\n+\n+        BType type = birConstantLoad.type;\n+        switch (type.tag) {\n+            case TypeTags.INT:\n+            case TypeTags.SIGNED32_INT:\n+            case TypeTags.SIGNED16_INT:\n+            case TypeTags.SIGNED8_INT:\n+            case TypeTags.UNSIGNED32_INT:\n+            case TypeTags.UNSIGNED16_INT:\n+            case TypeTags.UNSIGNED8_INT:\n+                buf.writeInt(cp.addCPEntry(new IntegerCPEntry((Long) birConstantLoad.value)));\n+                break;\n+            case TypeTags.BYTE:\n+                // TODO: birConstantLoad.value should return an Integer. This is a temporary fix", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6fc3de447ec3361b9ab93c473a6610544ffe80f8"}, "originalPosition": 317}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMxODIxNw==", "bodyText": "Shall we track via an issue?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25351#discussion_r476318217", "createdAt": "2020-08-25T09:40:30Z", "author": {"login": "riyafa"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/writer/BIRInstructionWriter.java", "diffHunk": "@@ -0,0 +1,606 @@\n+/*\n+ *  Copyright (c) 2018, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.wso2.ballerinalang.compiler.bir.writer;\n+\n+import io.netty.buffer.ByteBuf;\n+import org.ballerinalang.compiler.BLangCompilerException;\n+import org.ballerinalang.model.elements.PackageID;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRBasicBlock;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRGlobalVariableDcl;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewArray;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewStringXMLQName;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewStructure;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewTypeDesc;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLComment;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLElement;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLProcIns;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLQName;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLText;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.XMLAccess;\n+import org.wso2.ballerinalang.compiler.bir.model.BIROperand;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRTerminator;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRVisitor;\n+import org.wso2.ballerinalang.compiler.bir.model.InstructionKind;\n+import org.wso2.ballerinalang.compiler.bir.model.VarKind;\n+import org.wso2.ballerinalang.compiler.bir.writer.CPEntry.ByteCPEntry;\n+import org.wso2.ballerinalang.compiler.bir.writer.CPEntry.FloatCPEntry;\n+import org.wso2.ballerinalang.compiler.bir.writer.CPEntry.IntegerCPEntry;\n+import org.wso2.ballerinalang.compiler.bir.writer.CPEntry.StringCPEntry;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BType;\n+import org.wso2.ballerinalang.compiler.util.TypeTags;\n+import org.wso2.ballerinalang.compiler.util.diagnotic.DiagnosticPos;\n+\n+import java.util.List;\n+\n+/**\n+ * Responsible for serializing BIR instructions and operands.\n+ *\n+ * @since 0.980.0\n+ */\n+public class BIRInstructionWriter extends BIRVisitor {\n+    private ByteBuf buf;\n+    private BIRTypeWriter typeWriter;\n+    private ConstantPool cp;\n+    private BIRBinaryWriter binaryWriter;\n+\n+    public BIRInstructionWriter(ByteBuf buf, BIRTypeWriter typeWriter, ConstantPool cp,\n+                                BIRBinaryWriter birBinaryWriter) {\n+        this.buf = buf;\n+        this.typeWriter = typeWriter;\n+        this.binaryWriter = birBinaryWriter;\n+        this.cp = cp;\n+    }\n+\n+    public void writeBBs(List<BIRBasicBlock> bbList) {\n+        buf.writeInt(bbList.size());\n+        bbList.forEach(bb -> bb.accept(this));\n+    }\n+\n+    public void visit(BIRBasicBlock birBasicBlock) {\n+        //Name of the basic block\n+        addCpAndWriteString(birBasicBlock.id.value);\n+        // Number of instructions\n+        // Adding the terminator instruction as well.\n+        buf.writeInt(birBasicBlock.instructions.size() + 1);\n+            birBasicBlock.instructions.forEach(instruction -> instruction.accept(this));\n+        if (birBasicBlock.terminator == null) {\n+            throw new BLangCompilerException(\"Basic block without a terminator : \" + birBasicBlock.id);\n+        }\n+        birBasicBlock.terminator.accept(this);\n+    }\n+\n+    public void writeErrorTable(List<BIRNode.BIRErrorEntry> errorEntries) {\n+        buf.writeInt(errorEntries.size());\n+        errorEntries.forEach(birErrorEntry -> birErrorEntry.accept(this));\n+    }\n+\n+    public void visit(BIRNode.BIRErrorEntry errorEntry) {\n+        addCpAndWriteString(errorEntry.trapBB.id.value);\n+        addCpAndWriteString(errorEntry.endBB.id.value);\n+        errorEntry.errorOp.accept(this);\n+        addCpAndWriteString(errorEntry.targetBB.id.value);\n+    }\n+\n+    // Terminating instructions\n+\n+    public void visit(BIRTerminator.GOTO birGoto) {\n+        writePosition(birGoto.pos);\n+        buf.writeByte(birGoto.kind.getValue());\n+        addCpAndWriteString(birGoto.targetBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.Lock lock) {\n+        writePosition(lock.pos);\n+        buf.writeByte(lock.kind.getValue());\n+\n+        addCpAndWriteString(lock.lockedBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.FieldLock lock) {\n+        writePosition(lock.pos);\n+        buf.writeByte(lock.kind.getValue());\n+        // TODO properly use operand instead of variablDcl.name here\n+        addCpAndWriteString(lock.localVar.variableDcl.name.value);\n+        addCpAndWriteString(lock.field);\n+        addCpAndWriteString(lock.lockedBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.Unlock unlock) {\n+        writePosition(unlock.pos);\n+        buf.writeByte(unlock.kind.getValue());\n+        addCpAndWriteString(unlock.unlockBB.id.value);\n+    }\n+\n+\n+    public void visit(BIRTerminator.Return birReturn) {\n+        writePosition(birReturn.pos);\n+        buf.writeByte(birReturn.kind.getValue());\n+    }\n+\n+    public void visit(BIRTerminator.Branch birBranch) {\n+        writePosition(birBranch.pos);\n+        buf.writeByte(birBranch.kind.getValue());\n+        birBranch.op.accept(this);\n+        // true:BB\n+        addCpAndWriteString(birBranch.trueBB.id.value);\n+        // false:BB\n+        addCpAndWriteString(birBranch.falseBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.Wait waitEntry) {\n+        writePosition(waitEntry.pos);\n+        buf.writeByte(waitEntry.kind.getValue());\n+        buf.writeInt(waitEntry.exprList.size());\n+        for (BIROperand expr : waitEntry.exprList) {\n+            expr.accept(this);\n+        }\n+        waitEntry.lhsOp.accept(this);\n+        addCpAndWriteString(waitEntry.thenBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.Flush entry) {\n+        writePosition(entry.pos);\n+        buf.writeByte(entry.kind.getValue());\n+        buf.writeInt(entry.channels.length);\n+        for (BIRNode.ChannelDetails detail : entry.channels) {\n+            addCpAndWriteString(detail.name);\n+            buf.writeBoolean(detail.channelInSameStrand);\n+            buf.writeBoolean(detail.send);\n+        }\n+        entry.lhsOp.accept(this);\n+        addCpAndWriteString(entry.thenBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.WorkerReceive entry) {\n+        writePosition(entry.pos);\n+        buf.writeByte((entry.kind.getValue()));\n+        buf.writeInt(addStringCPEntry(entry.workerName.getValue()));\n+        entry.lhsOp.accept(this);\n+        buf.writeBoolean(entry.isSameStrand);\n+        addCpAndWriteString(entry.thenBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.WorkerSend entry) {\n+        writePosition(entry.pos);\n+        buf.writeByte((entry.kind.getValue()));\n+        buf.writeInt(addStringCPEntry(entry.channel.getValue()));\n+        entry.data.accept(this);\n+        buf.writeBoolean(entry.isSameStrand);\n+        buf.writeBoolean(entry.isSync);\n+        if (entry.isSync) {\n+            entry.lhsOp.accept(this);\n+        }\n+        addCpAndWriteString(entry.thenBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.WaitAll waitAll) {\n+        writePosition(waitAll.pos);\n+        buf.writeByte((waitAll.kind.getValue()));\n+        waitAll.lhsOp.accept(this);\n+        buf.writeInt(waitAll.keys.size());\n+        waitAll.keys.forEach(key -> buf.writeInt(addStringCPEntry(key)));\n+        waitAll.valueExprs.forEach(val -> val.accept(this));\n+        addCpAndWriteString(waitAll.thenBB.id.value);\n+    }\n+\n+    // Non-terminating instructions\n+\n+    @Override\n+    public void visit(BIRNonTerminator.NewTable newTable) {\n+        writePosition(newTable.pos);\n+        writeType(newTable.type);\n+        newTable.lhsOp.accept(this);\n+        newTable.keyColOp.accept(this);\n+        newTable.dataOp.accept(this);\n+    }\n+\n+\n+    public void visit(BIRNonTerminator.Move birMove) {\n+        writePosition(birMove.pos);\n+        buf.writeByte(birMove.kind.getValue());\n+        birMove.rhsOp.accept(this);\n+        birMove.lhsOp.accept(this);\n+    }\n+\n+    public void visit(BIRTerminator.Call birCall) {\n+        writePosition(birCall.pos);\n+        buf.writeByte(birCall.kind.getValue());\n+        PackageID calleePkg = birCall.calleePkg;\n+        int pkgIndex = addPkgCPEntry(calleePkg);\n+        buf.writeBoolean(birCall.isVirtual);\n+        buf.writeInt(pkgIndex);\n+        buf.writeInt(addStringCPEntry(birCall.name.getValue()));\n+        buf.writeInt(birCall.args.size());\n+        for (BIROperand arg : birCall.args) {\n+            arg.accept(this);\n+        }\n+        if (birCall.lhsOp != null) {\n+            buf.writeByte(1);\n+            birCall.lhsOp.accept(this);\n+        } else {\n+            buf.writeByte(0);\n+        }\n+        addCpAndWriteString(birCall.thenBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.AsyncCall birAsyncCall) {\n+        writePosition(birAsyncCall.pos);\n+        buf.writeByte(birAsyncCall.kind.getValue());\n+        PackageID calleePkg = birAsyncCall.calleePkg;\n+        int pkgIndex = addPkgCPEntry(calleePkg);\n+        buf.writeBoolean(birAsyncCall.isVirtual);\n+        buf.writeInt(pkgIndex);\n+        buf.writeInt(addStringCPEntry(birAsyncCall.name.getValue()));\n+        buf.writeInt(birAsyncCall.args.size());\n+        for (BIROperand arg : birAsyncCall.args) {\n+            arg.accept(this);\n+        }\n+        if (birAsyncCall.lhsOp != null) {\n+            buf.writeByte(1);\n+            birAsyncCall.lhsOp.accept(this);\n+        } else {\n+            buf.writeByte(0);\n+        }\n+\n+        binaryWriter.writeAnnotAttachments(buf, this, birAsyncCall.annotAttachments);\n+        addCpAndWriteString(birAsyncCall.thenBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.FPCall fpCall) {\n+        writePosition(fpCall.pos);\n+        buf.writeByte(fpCall.kind.getValue());\n+        fpCall.fp.accept(this);\n+        buf.writeInt(fpCall.args.size());\n+        for (BIROperand arg : fpCall.args) {\n+            arg.accept(this);\n+        }\n+        if (fpCall.lhsOp != null) {\n+            buf.writeByte(1);\n+            fpCall.lhsOp.accept(this);\n+        } else {\n+            buf.writeByte(0);\n+        }\n+        buf.writeBoolean(fpCall.isAsync);\n+        addCpAndWriteString(fpCall.thenBB.id.value);\n+    }\n+\n+    public void visit(BIRNonTerminator.BinaryOp birBinaryOp) {\n+        writePosition(birBinaryOp.pos);\n+        buf.writeByte(birBinaryOp.kind.getValue());\n+        birBinaryOp.rhsOp1.accept(this);\n+        birBinaryOp.rhsOp2.accept(this);\n+        birBinaryOp.lhsOp.accept(this);\n+    }\n+\n+    public void visit(BIRNonTerminator.UnaryOP birUnaryOp) {\n+        writePosition(birUnaryOp.pos);\n+        buf.writeByte(birUnaryOp.kind.getValue());\n+        birUnaryOp.rhsOp.accept(this);\n+        birUnaryOp.lhsOp.accept(this);\n+    }\n+\n+    public void visit(BIRNonTerminator.ConstantLoad birConstantLoad) {\n+        writePosition(birConstantLoad.pos);\n+        buf.writeByte(birConstantLoad.kind.getValue());\n+        writeType(birConstantLoad.type);\n+        birConstantLoad.lhsOp.accept(this);\n+\n+        BType type = birConstantLoad.type;\n+        switch (type.tag) {\n+            case TypeTags.INT:\n+            case TypeTags.SIGNED32_INT:\n+            case TypeTags.SIGNED16_INT:\n+            case TypeTags.SIGNED8_INT:\n+            case TypeTags.UNSIGNED32_INT:\n+            case TypeTags.UNSIGNED16_INT:\n+            case TypeTags.UNSIGNED8_INT:\n+                buf.writeInt(cp.addCPEntry(new IntegerCPEntry((Long) birConstantLoad.value)));\n+                break;\n+            case TypeTags.BYTE:\n+                // TODO: birConstantLoad.value should return an Integer. This is a temporary fix\n+                int byteValue = ((Number) birConstantLoad.value).intValue();\n+                buf.writeInt(cp.addCPEntry(new ByteCPEntry(byteValue)));\n+                break;\n+            case TypeTags.BOOLEAN:\n+                // Not adding to constant pool as it increases the size (bit vs integer)\n+                buf.writeBoolean((Boolean) birConstantLoad.value);\n+                break;\n+            case TypeTags.STRING:\n+            case TypeTags.CHAR_STRING:\n+            case TypeTags.DECIMAL:\n+                buf.writeInt(cp.addCPEntry(new StringCPEntry(birConstantLoad.value.toString())));\n+                break;\n+            case TypeTags.FLOAT:\n+                double value = birConstantLoad.value instanceof Double ? (double) birConstantLoad.value\n+                        : Double.parseDouble((String) birConstantLoad.value);\n+                buf.writeInt(cp.addCPEntry(new FloatCPEntry(value)));\n+                break;\n+            case TypeTags.NIL:\n+                break;\n+            default:\n+                throw new IllegalStateException(\"unsupported constant type: \" + type);\n+        }\n+    }\n+\n+    public void visit(NewStructure birNewStructure) {\n+        writePosition(birNewStructure.pos);\n+        buf.writeByte(birNewStructure.kind.getValue());\n+        birNewStructure.rhsOp.accept(this);\n+        birNewStructure.lhsOp.accept(this);\n+    }\n+\n+    public void visit(BIRNonTerminator.NewInstance newInstance) {\n+        writePosition(newInstance.pos);\n+        buf.writeByte(newInstance.kind.getValue());\n+        buf.writeBoolean(newInstance.isExternalDef);\n+        if (newInstance.isExternalDef) {\n+            assert newInstance.externalPackageId != null;\n+            buf.writeInt(addPkgCPEntry(newInstance.externalPackageId));\n+            buf.writeInt(addStringCPEntry(newInstance.objectName));\n+        } else {\n+            buf.writeInt(newInstance.def.index);\n+        }\n+        newInstance.lhsOp.accept(this);\n+    }\n+\n+    public void visit(NewArray birNewArray) {\n+        writePosition(birNewArray.pos);\n+        buf.writeByte(birNewArray.kind.getValue());\n+        writeType(birNewArray.type);\n+        birNewArray.lhsOp.accept(this);\n+        birNewArray.sizeOp.accept(this);\n+    }\n+\n+    public void visit(BIRNonTerminator.FieldAccess birFieldAccess) {\n+        writePosition(birFieldAccess.pos);\n+        buf.writeByte(birFieldAccess.kind.getValue());\n+        if (birFieldAccess.kind == InstructionKind.MAP_LOAD || birFieldAccess.kind == InstructionKind.ARRAY_LOAD) {\n+            buf.writeBoolean(birFieldAccess.optionalFieldAccess);\n+            buf.writeBoolean(birFieldAccess.fillingRead);\n+        }\n+        birFieldAccess.lhsOp.accept(this);\n+        birFieldAccess.keyOp.accept(this);\n+        birFieldAccess.rhsOp.accept(this);\n+    }\n+\n+    public void visit(BIRNonTerminator.TypeCast birTypeCast) {\n+        writePosition(birTypeCast.pos);\n+        buf.writeByte(birTypeCast.kind.getValue());\n+        birTypeCast.lhsOp.accept(this);\n+        birTypeCast.rhsOp.accept(this);\n+        writeType(birTypeCast.type);\n+        buf.writeBoolean(birTypeCast.checkTypes);\n+    }\n+\n+    public void visit(BIRNonTerminator.IsLike birIsLike) {\n+        writePosition(birIsLike.pos);\n+        buf.writeByte(birIsLike.kind.getValue());\n+        writeType(birIsLike.type);\n+        birIsLike.lhsOp.accept(this);\n+        birIsLike.rhsOp.accept(this);\n+    }\n+\n+    public void visit(BIRNonTerminator.TypeTest birTypeTest) {\n+        writePosition(birTypeTest.pos);\n+        buf.writeByte(birTypeTest.kind.getValue());\n+        writeType(birTypeTest.type);\n+        birTypeTest.lhsOp.accept(this);\n+        birTypeTest.rhsOp.accept(this);\n+    }\n+\n+    // Operands\n+    public void visit(BIROperand birOperand) {\n+        if (birOperand.variableDcl.ignoreVariable) {\n+            buf.writeBoolean(true);\n+            writeType(birOperand.variableDcl.type);\n+            return;\n+        }\n+\n+        buf.writeBoolean(false);\n+        buf.writeByte(birOperand.variableDcl.kind.getValue());\n+        buf.writeByte(birOperand.variableDcl.scope.getValue());\n+\n+        // TODO use the integer index of the variable.\n+        addCpAndWriteString(birOperand.variableDcl.name.value);\n+\n+        if (birOperand.variableDcl.kind == VarKind.GLOBAL || birOperand.variableDcl.kind == VarKind.CONSTANT) {\n+            int pkgIndex = addPkgCPEntry(((BIRGlobalVariableDcl) birOperand.variableDcl).pkgId);\n+            buf.writeInt(pkgIndex);\n+\n+            writeType(birOperand.variableDcl.type);\n+        }\n+    }\n+\n+    public void visit(BIRNonTerminator.NewError birNewError) {\n+        writePosition(birNewError.pos);\n+        buf.writeByte(birNewError.kind.getValue());\n+        writeType(birNewError.type);\n+        birNewError.lhsOp.accept(this);\n+        birNewError.messageOp.accept(this);\n+        birNewError.causeOp.accept(this);\n+        birNewError.detailOp.accept(this);\n+    }\n+\n+    public void visit(BIRNonTerminator.FPLoad fpLoad) {\n+        writePosition(fpLoad.pos);\n+        buf.writeByte(fpLoad.kind.getValue());\n+        fpLoad.lhsOp.accept(this);\n+\n+        PackageID pkgId = fpLoad.pkgId;\n+        int pkgIndex = addPkgCPEntry(pkgId);\n+        buf.writeInt(pkgIndex);\n+        buf.writeInt(addStringCPEntry(fpLoad.funcName.getValue()));\n+        writeType(fpLoad.retType);\n+\n+        buf.writeInt(fpLoad.closureMaps.size());\n+        for (BIROperand op : fpLoad.closureMaps) {\n+            op.accept(this);\n+        }\n+\n+        buf.writeInt(fpLoad.params.size());\n+        fpLoad.params.forEach(param -> {\n+            buf.writeByte(param.kind.getValue());\n+            writeType(param.type);\n+            buf.writeInt(addStringCPEntry(param.name.value));\n+        });\n+\n+    }\n+\n+    public void visit(BIRTerminator.Panic birPanic) {\n+        writePosition(birPanic.pos);\n+        buf.writeByte(birPanic.kind.getValue());\n+        birPanic.errorOp.accept(this);\n+    }\n+\n+    @Override\n+    public void visit(NewXMLElement newXMLElement) {\n+        writePosition(newXMLElement.pos);\n+        buf.writeByte(newXMLElement.kind.getValue());\n+        newXMLElement.lhsOp.accept(this);\n+        newXMLElement.startTagOp.accept(this);\n+        newXMLElement.defaultNsURIOp.accept(this);\n+    }\n+\n+    @Override\n+    public void visit(NewXMLText newXMLText) {\n+        writePosition(newXMLText.pos);\n+        buf.writeByte(newXMLText.kind.getValue());\n+        newXMLText.lhsOp.accept(this);\n+        newXMLText.textOp.accept(this);\n+    }\n+\n+    @Override\n+    public void visit(NewXMLQName newXMLQName) {\n+        writePosition(newXMLQName.pos);\n+        buf.writeByte(newXMLQName.kind.getValue());\n+        newXMLQName.lhsOp.accept(this);\n+        newXMLQName.localnameOp.accept(this);\n+        newXMLQName.nsURIOp.accept(this);\n+        newXMLQName.prefixOp.accept(this);\n+    }\n+\n+    @Override\n+    public void visit(NewStringXMLQName newStringXMLQName) {\n+        writePosition(newStringXMLQName.pos);\n+        buf.writeByte(newStringXMLQName.kind.getValue());\n+        newStringXMLQName.lhsOp.accept(this);\n+        newStringXMLQName.stringQNameOP.accept(this);\n+    }\n+\n+    @Override\n+    public void visit(XMLAccess xmlAccess) {\n+        writePosition(xmlAccess.pos);\n+        buf.writeByte(xmlAccess.kind.getValue());\n+        xmlAccess.lhsOp.accept(this);\n+        xmlAccess.rhsOp.accept(this);\n+    }\n+\n+    @Override\n+    public void visit(NewXMLComment newXMLComment) {\n+        writePosition(newXMLComment.pos);\n+        buf.writeByte(newXMLComment.kind.getValue());\n+        newXMLComment.lhsOp.accept(this);\n+        newXMLComment.textOp.accept(this);\n+    }\n+\n+    @Override\n+    public void visit(NewXMLProcIns newXMLProcIns) {\n+        writePosition(newXMLProcIns.pos);\n+        buf.writeByte(newXMLProcIns.kind.getValue());\n+        newXMLProcIns.lhsOp.accept(this);\n+        newXMLProcIns.dataOp.accept(this);\n+        newXMLProcIns.targetOp.accept(this);\n+    }\n+\n+    @Override\n+    public void visit(NewTypeDesc newTypeDesc) {\n+        writePosition(newTypeDesc.pos);\n+        buf.writeByte(newTypeDesc.kind.getValue());\n+        newTypeDesc.lhsOp.accept(this);\n+        writeType(newTypeDesc.type);\n+    }\n+\n+    // Positions\n+    // TODO Refactor duplicate methods", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6fc3de447ec3361b9ab93c473a6610544ffe80f8"}, "originalPosition": 541}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMxODQ4NQ==", "bodyText": "I think we can remove this comment", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25351#discussion_r476318485", "createdAt": "2020-08-25T09:40:53Z", "author": {"login": "riyafa"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/writer/BIRInstructionWriter.java", "diffHunk": "@@ -0,0 +1,606 @@\n+/*\n+ *  Copyright (c) 2018, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.wso2.ballerinalang.compiler.bir.writer;\n+\n+import io.netty.buffer.ByteBuf;\n+import org.ballerinalang.compiler.BLangCompilerException;\n+import org.ballerinalang.model.elements.PackageID;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRBasicBlock;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRGlobalVariableDcl;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewArray;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewStringXMLQName;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewStructure;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewTypeDesc;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLComment;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLElement;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLProcIns;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLQName;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLText;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.XMLAccess;\n+import org.wso2.ballerinalang.compiler.bir.model.BIROperand;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRTerminator;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRVisitor;\n+import org.wso2.ballerinalang.compiler.bir.model.InstructionKind;\n+import org.wso2.ballerinalang.compiler.bir.model.VarKind;\n+import org.wso2.ballerinalang.compiler.bir.writer.CPEntry.ByteCPEntry;\n+import org.wso2.ballerinalang.compiler.bir.writer.CPEntry.FloatCPEntry;\n+import org.wso2.ballerinalang.compiler.bir.writer.CPEntry.IntegerCPEntry;\n+import org.wso2.ballerinalang.compiler.bir.writer.CPEntry.StringCPEntry;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BType;\n+import org.wso2.ballerinalang.compiler.util.TypeTags;\n+import org.wso2.ballerinalang.compiler.util.diagnotic.DiagnosticPos;\n+\n+import java.util.List;\n+\n+/**\n+ * Responsible for serializing BIR instructions and operands.\n+ *\n+ * @since 0.980.0\n+ */\n+public class BIRInstructionWriter extends BIRVisitor {\n+    private ByteBuf buf;\n+    private BIRTypeWriter typeWriter;\n+    private ConstantPool cp;\n+    private BIRBinaryWriter binaryWriter;\n+\n+    public BIRInstructionWriter(ByteBuf buf, BIRTypeWriter typeWriter, ConstantPool cp,\n+                                BIRBinaryWriter birBinaryWriter) {\n+        this.buf = buf;\n+        this.typeWriter = typeWriter;\n+        this.binaryWriter = birBinaryWriter;\n+        this.cp = cp;\n+    }\n+\n+    public void writeBBs(List<BIRBasicBlock> bbList) {\n+        buf.writeInt(bbList.size());\n+        bbList.forEach(bb -> bb.accept(this));\n+    }\n+\n+    public void visit(BIRBasicBlock birBasicBlock) {\n+        //Name of the basic block\n+        addCpAndWriteString(birBasicBlock.id.value);\n+        // Number of instructions\n+        // Adding the terminator instruction as well.\n+        buf.writeInt(birBasicBlock.instructions.size() + 1);\n+            birBasicBlock.instructions.forEach(instruction -> instruction.accept(this));\n+        if (birBasicBlock.terminator == null) {\n+            throw new BLangCompilerException(\"Basic block without a terminator : \" + birBasicBlock.id);\n+        }\n+        birBasicBlock.terminator.accept(this);\n+    }\n+\n+    public void writeErrorTable(List<BIRNode.BIRErrorEntry> errorEntries) {\n+        buf.writeInt(errorEntries.size());\n+        errorEntries.forEach(birErrorEntry -> birErrorEntry.accept(this));\n+    }\n+\n+    public void visit(BIRNode.BIRErrorEntry errorEntry) {\n+        addCpAndWriteString(errorEntry.trapBB.id.value);\n+        addCpAndWriteString(errorEntry.endBB.id.value);\n+        errorEntry.errorOp.accept(this);\n+        addCpAndWriteString(errorEntry.targetBB.id.value);\n+    }\n+\n+    // Terminating instructions\n+\n+    public void visit(BIRTerminator.GOTO birGoto) {\n+        writePosition(birGoto.pos);\n+        buf.writeByte(birGoto.kind.getValue());\n+        addCpAndWriteString(birGoto.targetBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.Lock lock) {\n+        writePosition(lock.pos);\n+        buf.writeByte(lock.kind.getValue());\n+\n+        addCpAndWriteString(lock.lockedBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.FieldLock lock) {\n+        writePosition(lock.pos);\n+        buf.writeByte(lock.kind.getValue());\n+        // TODO properly use operand instead of variablDcl.name here\n+        addCpAndWriteString(lock.localVar.variableDcl.name.value);\n+        addCpAndWriteString(lock.field);\n+        addCpAndWriteString(lock.lockedBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.Unlock unlock) {\n+        writePosition(unlock.pos);\n+        buf.writeByte(unlock.kind.getValue());\n+        addCpAndWriteString(unlock.unlockBB.id.value);\n+    }\n+\n+\n+    public void visit(BIRTerminator.Return birReturn) {\n+        writePosition(birReturn.pos);\n+        buf.writeByte(birReturn.kind.getValue());\n+    }\n+\n+    public void visit(BIRTerminator.Branch birBranch) {\n+        writePosition(birBranch.pos);\n+        buf.writeByte(birBranch.kind.getValue());\n+        birBranch.op.accept(this);\n+        // true:BB\n+        addCpAndWriteString(birBranch.trueBB.id.value);\n+        // false:BB\n+        addCpAndWriteString(birBranch.falseBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.Wait waitEntry) {\n+        writePosition(waitEntry.pos);\n+        buf.writeByte(waitEntry.kind.getValue());\n+        buf.writeInt(waitEntry.exprList.size());\n+        for (BIROperand expr : waitEntry.exprList) {\n+            expr.accept(this);\n+        }\n+        waitEntry.lhsOp.accept(this);\n+        addCpAndWriteString(waitEntry.thenBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.Flush entry) {\n+        writePosition(entry.pos);\n+        buf.writeByte(entry.kind.getValue());\n+        buf.writeInt(entry.channels.length);\n+        for (BIRNode.ChannelDetails detail : entry.channels) {\n+            addCpAndWriteString(detail.name);\n+            buf.writeBoolean(detail.channelInSameStrand);\n+            buf.writeBoolean(detail.send);\n+        }\n+        entry.lhsOp.accept(this);\n+        addCpAndWriteString(entry.thenBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.WorkerReceive entry) {\n+        writePosition(entry.pos);\n+        buf.writeByte((entry.kind.getValue()));\n+        buf.writeInt(addStringCPEntry(entry.workerName.getValue()));\n+        entry.lhsOp.accept(this);\n+        buf.writeBoolean(entry.isSameStrand);\n+        addCpAndWriteString(entry.thenBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.WorkerSend entry) {\n+        writePosition(entry.pos);\n+        buf.writeByte((entry.kind.getValue()));\n+        buf.writeInt(addStringCPEntry(entry.channel.getValue()));\n+        entry.data.accept(this);\n+        buf.writeBoolean(entry.isSameStrand);\n+        buf.writeBoolean(entry.isSync);\n+        if (entry.isSync) {\n+            entry.lhsOp.accept(this);\n+        }\n+        addCpAndWriteString(entry.thenBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.WaitAll waitAll) {\n+        writePosition(waitAll.pos);\n+        buf.writeByte((waitAll.kind.getValue()));\n+        waitAll.lhsOp.accept(this);\n+        buf.writeInt(waitAll.keys.size());\n+        waitAll.keys.forEach(key -> buf.writeInt(addStringCPEntry(key)));\n+        waitAll.valueExprs.forEach(val -> val.accept(this));\n+        addCpAndWriteString(waitAll.thenBB.id.value);\n+    }\n+\n+    // Non-terminating instructions\n+\n+    @Override\n+    public void visit(BIRNonTerminator.NewTable newTable) {\n+        writePosition(newTable.pos);\n+        writeType(newTable.type);\n+        newTable.lhsOp.accept(this);\n+        newTable.keyColOp.accept(this);\n+        newTable.dataOp.accept(this);\n+    }\n+\n+\n+    public void visit(BIRNonTerminator.Move birMove) {\n+        writePosition(birMove.pos);\n+        buf.writeByte(birMove.kind.getValue());\n+        birMove.rhsOp.accept(this);\n+        birMove.lhsOp.accept(this);\n+    }\n+\n+    public void visit(BIRTerminator.Call birCall) {\n+        writePosition(birCall.pos);\n+        buf.writeByte(birCall.kind.getValue());\n+        PackageID calleePkg = birCall.calleePkg;\n+        int pkgIndex = addPkgCPEntry(calleePkg);\n+        buf.writeBoolean(birCall.isVirtual);\n+        buf.writeInt(pkgIndex);\n+        buf.writeInt(addStringCPEntry(birCall.name.getValue()));\n+        buf.writeInt(birCall.args.size());\n+        for (BIROperand arg : birCall.args) {\n+            arg.accept(this);\n+        }\n+        if (birCall.lhsOp != null) {\n+            buf.writeByte(1);\n+            birCall.lhsOp.accept(this);\n+        } else {\n+            buf.writeByte(0);\n+        }\n+        addCpAndWriteString(birCall.thenBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.AsyncCall birAsyncCall) {\n+        writePosition(birAsyncCall.pos);\n+        buf.writeByte(birAsyncCall.kind.getValue());\n+        PackageID calleePkg = birAsyncCall.calleePkg;\n+        int pkgIndex = addPkgCPEntry(calleePkg);\n+        buf.writeBoolean(birAsyncCall.isVirtual);\n+        buf.writeInt(pkgIndex);\n+        buf.writeInt(addStringCPEntry(birAsyncCall.name.getValue()));\n+        buf.writeInt(birAsyncCall.args.size());\n+        for (BIROperand arg : birAsyncCall.args) {\n+            arg.accept(this);\n+        }\n+        if (birAsyncCall.lhsOp != null) {\n+            buf.writeByte(1);\n+            birAsyncCall.lhsOp.accept(this);\n+        } else {\n+            buf.writeByte(0);\n+        }\n+\n+        binaryWriter.writeAnnotAttachments(buf, this, birAsyncCall.annotAttachments);\n+        addCpAndWriteString(birAsyncCall.thenBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.FPCall fpCall) {\n+        writePosition(fpCall.pos);\n+        buf.writeByte(fpCall.kind.getValue());\n+        fpCall.fp.accept(this);\n+        buf.writeInt(fpCall.args.size());\n+        for (BIROperand arg : fpCall.args) {\n+            arg.accept(this);\n+        }\n+        if (fpCall.lhsOp != null) {\n+            buf.writeByte(1);\n+            fpCall.lhsOp.accept(this);\n+        } else {\n+            buf.writeByte(0);\n+        }\n+        buf.writeBoolean(fpCall.isAsync);\n+        addCpAndWriteString(fpCall.thenBB.id.value);\n+    }\n+\n+    public void visit(BIRNonTerminator.BinaryOp birBinaryOp) {\n+        writePosition(birBinaryOp.pos);\n+        buf.writeByte(birBinaryOp.kind.getValue());\n+        birBinaryOp.rhsOp1.accept(this);\n+        birBinaryOp.rhsOp2.accept(this);\n+        birBinaryOp.lhsOp.accept(this);\n+    }\n+\n+    public void visit(BIRNonTerminator.UnaryOP birUnaryOp) {\n+        writePosition(birUnaryOp.pos);\n+        buf.writeByte(birUnaryOp.kind.getValue());\n+        birUnaryOp.rhsOp.accept(this);\n+        birUnaryOp.lhsOp.accept(this);\n+    }\n+\n+    public void visit(BIRNonTerminator.ConstantLoad birConstantLoad) {\n+        writePosition(birConstantLoad.pos);\n+        buf.writeByte(birConstantLoad.kind.getValue());\n+        writeType(birConstantLoad.type);\n+        birConstantLoad.lhsOp.accept(this);\n+\n+        BType type = birConstantLoad.type;\n+        switch (type.tag) {\n+            case TypeTags.INT:\n+            case TypeTags.SIGNED32_INT:\n+            case TypeTags.SIGNED16_INT:\n+            case TypeTags.SIGNED8_INT:\n+            case TypeTags.UNSIGNED32_INT:\n+            case TypeTags.UNSIGNED16_INT:\n+            case TypeTags.UNSIGNED8_INT:\n+                buf.writeInt(cp.addCPEntry(new IntegerCPEntry((Long) birConstantLoad.value)));\n+                break;\n+            case TypeTags.BYTE:\n+                // TODO: birConstantLoad.value should return an Integer. This is a temporary fix\n+                int byteValue = ((Number) birConstantLoad.value).intValue();\n+                buf.writeInt(cp.addCPEntry(new ByteCPEntry(byteValue)));\n+                break;\n+            case TypeTags.BOOLEAN:\n+                // Not adding to constant pool as it increases the size (bit vs integer)\n+                buf.writeBoolean((Boolean) birConstantLoad.value);\n+                break;\n+            case TypeTags.STRING:\n+            case TypeTags.CHAR_STRING:\n+            case TypeTags.DECIMAL:\n+                buf.writeInt(cp.addCPEntry(new StringCPEntry(birConstantLoad.value.toString())));\n+                break;\n+            case TypeTags.FLOAT:\n+                double value = birConstantLoad.value instanceof Double ? (double) birConstantLoad.value\n+                        : Double.parseDouble((String) birConstantLoad.value);\n+                buf.writeInt(cp.addCPEntry(new FloatCPEntry(value)));\n+                break;\n+            case TypeTags.NIL:\n+                break;\n+            default:\n+                throw new IllegalStateException(\"unsupported constant type: \" + type);\n+        }\n+    }\n+\n+    public void visit(NewStructure birNewStructure) {\n+        writePosition(birNewStructure.pos);\n+        buf.writeByte(birNewStructure.kind.getValue());\n+        birNewStructure.rhsOp.accept(this);\n+        birNewStructure.lhsOp.accept(this);\n+    }\n+\n+    public void visit(BIRNonTerminator.NewInstance newInstance) {\n+        writePosition(newInstance.pos);\n+        buf.writeByte(newInstance.kind.getValue());\n+        buf.writeBoolean(newInstance.isExternalDef);\n+        if (newInstance.isExternalDef) {\n+            assert newInstance.externalPackageId != null;\n+            buf.writeInt(addPkgCPEntry(newInstance.externalPackageId));\n+            buf.writeInt(addStringCPEntry(newInstance.objectName));\n+        } else {\n+            buf.writeInt(newInstance.def.index);\n+        }\n+        newInstance.lhsOp.accept(this);\n+    }\n+\n+    public void visit(NewArray birNewArray) {\n+        writePosition(birNewArray.pos);\n+        buf.writeByte(birNewArray.kind.getValue());\n+        writeType(birNewArray.type);\n+        birNewArray.lhsOp.accept(this);\n+        birNewArray.sizeOp.accept(this);\n+    }\n+\n+    public void visit(BIRNonTerminator.FieldAccess birFieldAccess) {\n+        writePosition(birFieldAccess.pos);\n+        buf.writeByte(birFieldAccess.kind.getValue());\n+        if (birFieldAccess.kind == InstructionKind.MAP_LOAD || birFieldAccess.kind == InstructionKind.ARRAY_LOAD) {\n+            buf.writeBoolean(birFieldAccess.optionalFieldAccess);\n+            buf.writeBoolean(birFieldAccess.fillingRead);\n+        }\n+        birFieldAccess.lhsOp.accept(this);\n+        birFieldAccess.keyOp.accept(this);\n+        birFieldAccess.rhsOp.accept(this);\n+    }\n+\n+    public void visit(BIRNonTerminator.TypeCast birTypeCast) {\n+        writePosition(birTypeCast.pos);\n+        buf.writeByte(birTypeCast.kind.getValue());\n+        birTypeCast.lhsOp.accept(this);\n+        birTypeCast.rhsOp.accept(this);\n+        writeType(birTypeCast.type);\n+        buf.writeBoolean(birTypeCast.checkTypes);\n+    }\n+\n+    public void visit(BIRNonTerminator.IsLike birIsLike) {\n+        writePosition(birIsLike.pos);\n+        buf.writeByte(birIsLike.kind.getValue());\n+        writeType(birIsLike.type);\n+        birIsLike.lhsOp.accept(this);\n+        birIsLike.rhsOp.accept(this);\n+    }\n+\n+    public void visit(BIRNonTerminator.TypeTest birTypeTest) {\n+        writePosition(birTypeTest.pos);\n+        buf.writeByte(birTypeTest.kind.getValue());\n+        writeType(birTypeTest.type);\n+        birTypeTest.lhsOp.accept(this);\n+        birTypeTest.rhsOp.accept(this);\n+    }\n+\n+    // Operands\n+    public void visit(BIROperand birOperand) {\n+        if (birOperand.variableDcl.ignoreVariable) {\n+            buf.writeBoolean(true);\n+            writeType(birOperand.variableDcl.type);\n+            return;\n+        }\n+\n+        buf.writeBoolean(false);\n+        buf.writeByte(birOperand.variableDcl.kind.getValue());\n+        buf.writeByte(birOperand.variableDcl.scope.getValue());\n+\n+        // TODO use the integer index of the variable.\n+        addCpAndWriteString(birOperand.variableDcl.name.value);\n+\n+        if (birOperand.variableDcl.kind == VarKind.GLOBAL || birOperand.variableDcl.kind == VarKind.CONSTANT) {\n+            int pkgIndex = addPkgCPEntry(((BIRGlobalVariableDcl) birOperand.variableDcl).pkgId);\n+            buf.writeInt(pkgIndex);\n+\n+            writeType(birOperand.variableDcl.type);\n+        }\n+    }\n+\n+    public void visit(BIRNonTerminator.NewError birNewError) {\n+        writePosition(birNewError.pos);\n+        buf.writeByte(birNewError.kind.getValue());\n+        writeType(birNewError.type);\n+        birNewError.lhsOp.accept(this);\n+        birNewError.messageOp.accept(this);\n+        birNewError.causeOp.accept(this);\n+        birNewError.detailOp.accept(this);\n+    }\n+\n+    public void visit(BIRNonTerminator.FPLoad fpLoad) {\n+        writePosition(fpLoad.pos);\n+        buf.writeByte(fpLoad.kind.getValue());\n+        fpLoad.lhsOp.accept(this);\n+\n+        PackageID pkgId = fpLoad.pkgId;\n+        int pkgIndex = addPkgCPEntry(pkgId);\n+        buf.writeInt(pkgIndex);\n+        buf.writeInt(addStringCPEntry(fpLoad.funcName.getValue()));\n+        writeType(fpLoad.retType);\n+\n+        buf.writeInt(fpLoad.closureMaps.size());\n+        for (BIROperand op : fpLoad.closureMaps) {\n+            op.accept(this);\n+        }\n+\n+        buf.writeInt(fpLoad.params.size());\n+        fpLoad.params.forEach(param -> {\n+            buf.writeByte(param.kind.getValue());\n+            writeType(param.type);\n+            buf.writeInt(addStringCPEntry(param.name.value));\n+        });\n+\n+    }\n+\n+    public void visit(BIRTerminator.Panic birPanic) {\n+        writePosition(birPanic.pos);\n+        buf.writeByte(birPanic.kind.getValue());\n+        birPanic.errorOp.accept(this);\n+    }\n+\n+    @Override\n+    public void visit(NewXMLElement newXMLElement) {\n+        writePosition(newXMLElement.pos);\n+        buf.writeByte(newXMLElement.kind.getValue());\n+        newXMLElement.lhsOp.accept(this);\n+        newXMLElement.startTagOp.accept(this);\n+        newXMLElement.defaultNsURIOp.accept(this);\n+    }\n+\n+    @Override\n+    public void visit(NewXMLText newXMLText) {\n+        writePosition(newXMLText.pos);\n+        buf.writeByte(newXMLText.kind.getValue());\n+        newXMLText.lhsOp.accept(this);\n+        newXMLText.textOp.accept(this);\n+    }\n+\n+    @Override\n+    public void visit(NewXMLQName newXMLQName) {\n+        writePosition(newXMLQName.pos);\n+        buf.writeByte(newXMLQName.kind.getValue());\n+        newXMLQName.lhsOp.accept(this);\n+        newXMLQName.localnameOp.accept(this);\n+        newXMLQName.nsURIOp.accept(this);\n+        newXMLQName.prefixOp.accept(this);\n+    }\n+\n+    @Override\n+    public void visit(NewStringXMLQName newStringXMLQName) {\n+        writePosition(newStringXMLQName.pos);\n+        buf.writeByte(newStringXMLQName.kind.getValue());\n+        newStringXMLQName.lhsOp.accept(this);\n+        newStringXMLQName.stringQNameOP.accept(this);\n+    }\n+\n+    @Override\n+    public void visit(XMLAccess xmlAccess) {\n+        writePosition(xmlAccess.pos);\n+        buf.writeByte(xmlAccess.kind.getValue());\n+        xmlAccess.lhsOp.accept(this);\n+        xmlAccess.rhsOp.accept(this);\n+    }\n+\n+    @Override\n+    public void visit(NewXMLComment newXMLComment) {\n+        writePosition(newXMLComment.pos);\n+        buf.writeByte(newXMLComment.kind.getValue());\n+        newXMLComment.lhsOp.accept(this);\n+        newXMLComment.textOp.accept(this);\n+    }\n+\n+    @Override\n+    public void visit(NewXMLProcIns newXMLProcIns) {\n+        writePosition(newXMLProcIns.pos);\n+        buf.writeByte(newXMLProcIns.kind.getValue());\n+        newXMLProcIns.lhsOp.accept(this);\n+        newXMLProcIns.dataOp.accept(this);\n+        newXMLProcIns.targetOp.accept(this);\n+    }\n+\n+    @Override\n+    public void visit(NewTypeDesc newTypeDesc) {\n+        writePosition(newTypeDesc.pos);\n+        buf.writeByte(newTypeDesc.kind.getValue());\n+        newTypeDesc.lhsOp.accept(this);\n+        writeType(newTypeDesc.type);\n+    }\n+\n+    // Positions\n+    // TODO Refactor duplicate methods\n+    void writePosition(DiagnosticPos pos) {\n+        int sLine = Integer.MIN_VALUE;\n+        int eLine = Integer.MIN_VALUE;\n+        int sCol = Integer.MIN_VALUE;\n+        int eCol = Integer.MIN_VALUE;\n+        String sourceFileName = \"\";\n+        if (pos != null) {\n+            sLine = pos.sLine;\n+            eLine = pos.eLine;\n+            sCol = pos.sCol;\n+            eCol = pos.eCol;\n+            if (pos.src != null) {\n+                sourceFileName = pos.src.cUnitName;\n+            }\n+        }\n+        buf.writeInt(sLine);\n+        buf.writeInt(eLine);\n+        buf.writeInt(sCol);\n+        buf.writeInt(eCol);\n+        buf.writeInt(addStringCPEntry(sourceFileName));\n+    }\n+\n+    void writePosition(ByteBuf buf, DiagnosticPos pos) {\n+        int sLine = Integer.MIN_VALUE;\n+        int eLine = Integer.MIN_VALUE;\n+        int sCol = Integer.MIN_VALUE;\n+        int eCol = Integer.MIN_VALUE;\n+        String sourceFileName = \"\";\n+        if (pos != null) {\n+            sLine = pos.sLine;\n+            eLine = pos.eLine;\n+            sCol = pos.sCol;\n+            eCol = pos.eCol;\n+            if (pos.src != null) {\n+                sourceFileName = pos.src.cUnitName;\n+            }\n+        }\n+        buf.writeInt(sLine);\n+        buf.writeInt(eLine);\n+        buf.writeInt(sCol);\n+        buf.writeInt(eCol);\n+        buf.writeInt(addStringCPEntry(sourceFileName));\n+    }\n+\n+    int addPkgCPEntry(PackageID packageID) {\n+        int orgCPIndex = addStringCPEntry(packageID.orgName.value);\n+        int nameCPIndex = addStringCPEntry(packageID.name.value);\n+        int versionCPIndex = addStringCPEntry(packageID.version.value);\n+        return cp.addCPEntry(new CPEntry.PackageCPEntry(orgCPIndex, nameCPIndex, versionCPIndex));\n+    }\n+\n+    // private methods", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6fc3de447ec3361b9ab93c473a6610544ffe80f8"}, "originalPosition": 593}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMxODc1Nw==", "bodyText": "Is this a new class?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25351#discussion_r476318757", "createdAt": "2020-08-25T09:41:18Z", "author": {"login": "riyafa"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/writer/BIRInstructionWriter.java", "diffHunk": "@@ -0,0 +1,606 @@\n+/*\n+ *  Copyright (c) 2018, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6fc3de447ec3361b9ab93c473a6610544ffe80f8"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMyMDQzMg==", "bodyText": "Since we have buf.writeByte(1); and buf.writeByte(0); in multiple places wouldn't it be nice to have constants for 1 and 0 indicating what they mean in this context? If that makes sense \ud83d\ude42", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25351#discussion_r476320432", "createdAt": "2020-08-25T09:44:04Z", "author": {"login": "riyafa"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/writer/BIRInstructionWriter.java", "diffHunk": "@@ -0,0 +1,606 @@\n+/*\n+ *  Copyright (c) 2018, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.wso2.ballerinalang.compiler.bir.writer;\n+\n+import io.netty.buffer.ByteBuf;\n+import org.ballerinalang.compiler.BLangCompilerException;\n+import org.ballerinalang.model.elements.PackageID;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRBasicBlock;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRGlobalVariableDcl;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewArray;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewStringXMLQName;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewStructure;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewTypeDesc;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLComment;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLElement;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLProcIns;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLQName;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLText;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.XMLAccess;\n+import org.wso2.ballerinalang.compiler.bir.model.BIROperand;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRTerminator;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRVisitor;\n+import org.wso2.ballerinalang.compiler.bir.model.InstructionKind;\n+import org.wso2.ballerinalang.compiler.bir.model.VarKind;\n+import org.wso2.ballerinalang.compiler.bir.writer.CPEntry.ByteCPEntry;\n+import org.wso2.ballerinalang.compiler.bir.writer.CPEntry.FloatCPEntry;\n+import org.wso2.ballerinalang.compiler.bir.writer.CPEntry.IntegerCPEntry;\n+import org.wso2.ballerinalang.compiler.bir.writer.CPEntry.StringCPEntry;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BType;\n+import org.wso2.ballerinalang.compiler.util.TypeTags;\n+import org.wso2.ballerinalang.compiler.util.diagnotic.DiagnosticPos;\n+\n+import java.util.List;\n+\n+/**\n+ * Responsible for serializing BIR instructions and operands.\n+ *\n+ * @since 0.980.0\n+ */\n+public class BIRInstructionWriter extends BIRVisitor {\n+    private ByteBuf buf;\n+    private BIRTypeWriter typeWriter;\n+    private ConstantPool cp;\n+    private BIRBinaryWriter binaryWriter;\n+\n+    public BIRInstructionWriter(ByteBuf buf, BIRTypeWriter typeWriter, ConstantPool cp,\n+                                BIRBinaryWriter birBinaryWriter) {\n+        this.buf = buf;\n+        this.typeWriter = typeWriter;\n+        this.binaryWriter = birBinaryWriter;\n+        this.cp = cp;\n+    }\n+\n+    public void writeBBs(List<BIRBasicBlock> bbList) {\n+        buf.writeInt(bbList.size());\n+        bbList.forEach(bb -> bb.accept(this));\n+    }\n+\n+    public void visit(BIRBasicBlock birBasicBlock) {\n+        //Name of the basic block\n+        addCpAndWriteString(birBasicBlock.id.value);\n+        // Number of instructions\n+        // Adding the terminator instruction as well.\n+        buf.writeInt(birBasicBlock.instructions.size() + 1);\n+            birBasicBlock.instructions.forEach(instruction -> instruction.accept(this));\n+        if (birBasicBlock.terminator == null) {\n+            throw new BLangCompilerException(\"Basic block without a terminator : \" + birBasicBlock.id);\n+        }\n+        birBasicBlock.terminator.accept(this);\n+    }\n+\n+    public void writeErrorTable(List<BIRNode.BIRErrorEntry> errorEntries) {\n+        buf.writeInt(errorEntries.size());\n+        errorEntries.forEach(birErrorEntry -> birErrorEntry.accept(this));\n+    }\n+\n+    public void visit(BIRNode.BIRErrorEntry errorEntry) {\n+        addCpAndWriteString(errorEntry.trapBB.id.value);\n+        addCpAndWriteString(errorEntry.endBB.id.value);\n+        errorEntry.errorOp.accept(this);\n+        addCpAndWriteString(errorEntry.targetBB.id.value);\n+    }\n+\n+    // Terminating instructions\n+\n+    public void visit(BIRTerminator.GOTO birGoto) {\n+        writePosition(birGoto.pos);\n+        buf.writeByte(birGoto.kind.getValue());\n+        addCpAndWriteString(birGoto.targetBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.Lock lock) {\n+        writePosition(lock.pos);\n+        buf.writeByte(lock.kind.getValue());\n+\n+        addCpAndWriteString(lock.lockedBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.FieldLock lock) {\n+        writePosition(lock.pos);\n+        buf.writeByte(lock.kind.getValue());\n+        // TODO properly use operand instead of variablDcl.name here\n+        addCpAndWriteString(lock.localVar.variableDcl.name.value);\n+        addCpAndWriteString(lock.field);\n+        addCpAndWriteString(lock.lockedBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.Unlock unlock) {\n+        writePosition(unlock.pos);\n+        buf.writeByte(unlock.kind.getValue());\n+        addCpAndWriteString(unlock.unlockBB.id.value);\n+    }\n+\n+\n+    public void visit(BIRTerminator.Return birReturn) {\n+        writePosition(birReturn.pos);\n+        buf.writeByte(birReturn.kind.getValue());\n+    }\n+\n+    public void visit(BIRTerminator.Branch birBranch) {\n+        writePosition(birBranch.pos);\n+        buf.writeByte(birBranch.kind.getValue());\n+        birBranch.op.accept(this);\n+        // true:BB\n+        addCpAndWriteString(birBranch.trueBB.id.value);\n+        // false:BB\n+        addCpAndWriteString(birBranch.falseBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.Wait waitEntry) {\n+        writePosition(waitEntry.pos);\n+        buf.writeByte(waitEntry.kind.getValue());\n+        buf.writeInt(waitEntry.exprList.size());\n+        for (BIROperand expr : waitEntry.exprList) {\n+            expr.accept(this);\n+        }\n+        waitEntry.lhsOp.accept(this);\n+        addCpAndWriteString(waitEntry.thenBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.Flush entry) {\n+        writePosition(entry.pos);\n+        buf.writeByte(entry.kind.getValue());\n+        buf.writeInt(entry.channels.length);\n+        for (BIRNode.ChannelDetails detail : entry.channels) {\n+            addCpAndWriteString(detail.name);\n+            buf.writeBoolean(detail.channelInSameStrand);\n+            buf.writeBoolean(detail.send);\n+        }\n+        entry.lhsOp.accept(this);\n+        addCpAndWriteString(entry.thenBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.WorkerReceive entry) {\n+        writePosition(entry.pos);\n+        buf.writeByte((entry.kind.getValue()));\n+        buf.writeInt(addStringCPEntry(entry.workerName.getValue()));\n+        entry.lhsOp.accept(this);\n+        buf.writeBoolean(entry.isSameStrand);\n+        addCpAndWriteString(entry.thenBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.WorkerSend entry) {\n+        writePosition(entry.pos);\n+        buf.writeByte((entry.kind.getValue()));\n+        buf.writeInt(addStringCPEntry(entry.channel.getValue()));\n+        entry.data.accept(this);\n+        buf.writeBoolean(entry.isSameStrand);\n+        buf.writeBoolean(entry.isSync);\n+        if (entry.isSync) {\n+            entry.lhsOp.accept(this);\n+        }\n+        addCpAndWriteString(entry.thenBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.WaitAll waitAll) {\n+        writePosition(waitAll.pos);\n+        buf.writeByte((waitAll.kind.getValue()));\n+        waitAll.lhsOp.accept(this);\n+        buf.writeInt(waitAll.keys.size());\n+        waitAll.keys.forEach(key -> buf.writeInt(addStringCPEntry(key)));\n+        waitAll.valueExprs.forEach(val -> val.accept(this));\n+        addCpAndWriteString(waitAll.thenBB.id.value);\n+    }\n+\n+    // Non-terminating instructions\n+\n+    @Override\n+    public void visit(BIRNonTerminator.NewTable newTable) {\n+        writePosition(newTable.pos);\n+        writeType(newTable.type);\n+        newTable.lhsOp.accept(this);\n+        newTable.keyColOp.accept(this);\n+        newTable.dataOp.accept(this);\n+    }\n+\n+\n+    public void visit(BIRNonTerminator.Move birMove) {\n+        writePosition(birMove.pos);\n+        buf.writeByte(birMove.kind.getValue());\n+        birMove.rhsOp.accept(this);\n+        birMove.lhsOp.accept(this);\n+    }\n+\n+    public void visit(BIRTerminator.Call birCall) {\n+        writePosition(birCall.pos);\n+        buf.writeByte(birCall.kind.getValue());\n+        PackageID calleePkg = birCall.calleePkg;\n+        int pkgIndex = addPkgCPEntry(calleePkg);\n+        buf.writeBoolean(birCall.isVirtual);\n+        buf.writeInt(pkgIndex);\n+        buf.writeInt(addStringCPEntry(birCall.name.getValue()));\n+        buf.writeInt(birCall.args.size());\n+        for (BIROperand arg : birCall.args) {\n+            arg.accept(this);\n+        }\n+        if (birCall.lhsOp != null) {\n+            buf.writeByte(1);\n+            birCall.lhsOp.accept(this);\n+        } else {\n+            buf.writeByte(0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6fc3de447ec3361b9ab93c473a6610544ffe80f8"}, "originalPosition": 238}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMyMTAxNw==", "bodyText": "Shall we create issues for Todos so they will be fixed later?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25351#discussion_r476321017", "createdAt": "2020-08-25T09:45:03Z", "author": {"login": "riyafa"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/writer/BIRInstructionWriter.java", "diffHunk": "@@ -0,0 +1,606 @@\n+/*\n+ *  Copyright (c) 2018, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.wso2.ballerinalang.compiler.bir.writer;\n+\n+import io.netty.buffer.ByteBuf;\n+import org.ballerinalang.compiler.BLangCompilerException;\n+import org.ballerinalang.model.elements.PackageID;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRBasicBlock;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRGlobalVariableDcl;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewArray;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewStringXMLQName;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewStructure;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewTypeDesc;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLComment;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLElement;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLProcIns;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLQName;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLText;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.XMLAccess;\n+import org.wso2.ballerinalang.compiler.bir.model.BIROperand;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRTerminator;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRVisitor;\n+import org.wso2.ballerinalang.compiler.bir.model.InstructionKind;\n+import org.wso2.ballerinalang.compiler.bir.model.VarKind;\n+import org.wso2.ballerinalang.compiler.bir.writer.CPEntry.ByteCPEntry;\n+import org.wso2.ballerinalang.compiler.bir.writer.CPEntry.FloatCPEntry;\n+import org.wso2.ballerinalang.compiler.bir.writer.CPEntry.IntegerCPEntry;\n+import org.wso2.ballerinalang.compiler.bir.writer.CPEntry.StringCPEntry;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BType;\n+import org.wso2.ballerinalang.compiler.util.TypeTags;\n+import org.wso2.ballerinalang.compiler.util.diagnotic.DiagnosticPos;\n+\n+import java.util.List;\n+\n+/**\n+ * Responsible for serializing BIR instructions and operands.\n+ *\n+ * @since 0.980.0\n+ */\n+public class BIRInstructionWriter extends BIRVisitor {\n+    private ByteBuf buf;\n+    private BIRTypeWriter typeWriter;\n+    private ConstantPool cp;\n+    private BIRBinaryWriter binaryWriter;\n+\n+    public BIRInstructionWriter(ByteBuf buf, BIRTypeWriter typeWriter, ConstantPool cp,\n+                                BIRBinaryWriter birBinaryWriter) {\n+        this.buf = buf;\n+        this.typeWriter = typeWriter;\n+        this.binaryWriter = birBinaryWriter;\n+        this.cp = cp;\n+    }\n+\n+    public void writeBBs(List<BIRBasicBlock> bbList) {\n+        buf.writeInt(bbList.size());\n+        bbList.forEach(bb -> bb.accept(this));\n+    }\n+\n+    public void visit(BIRBasicBlock birBasicBlock) {\n+        //Name of the basic block\n+        addCpAndWriteString(birBasicBlock.id.value);\n+        // Number of instructions\n+        // Adding the terminator instruction as well.\n+        buf.writeInt(birBasicBlock.instructions.size() + 1);\n+            birBasicBlock.instructions.forEach(instruction -> instruction.accept(this));\n+        if (birBasicBlock.terminator == null) {\n+            throw new BLangCompilerException(\"Basic block without a terminator : \" + birBasicBlock.id);\n+        }\n+        birBasicBlock.terminator.accept(this);\n+    }\n+\n+    public void writeErrorTable(List<BIRNode.BIRErrorEntry> errorEntries) {\n+        buf.writeInt(errorEntries.size());\n+        errorEntries.forEach(birErrorEntry -> birErrorEntry.accept(this));\n+    }\n+\n+    public void visit(BIRNode.BIRErrorEntry errorEntry) {\n+        addCpAndWriteString(errorEntry.trapBB.id.value);\n+        addCpAndWriteString(errorEntry.endBB.id.value);\n+        errorEntry.errorOp.accept(this);\n+        addCpAndWriteString(errorEntry.targetBB.id.value);\n+    }\n+\n+    // Terminating instructions\n+\n+    public void visit(BIRTerminator.GOTO birGoto) {\n+        writePosition(birGoto.pos);\n+        buf.writeByte(birGoto.kind.getValue());\n+        addCpAndWriteString(birGoto.targetBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.Lock lock) {\n+        writePosition(lock.pos);\n+        buf.writeByte(lock.kind.getValue());\n+\n+        addCpAndWriteString(lock.lockedBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.FieldLock lock) {\n+        writePosition(lock.pos);\n+        buf.writeByte(lock.kind.getValue());\n+        // TODO properly use operand instead of variablDcl.name here\n+        addCpAndWriteString(lock.localVar.variableDcl.name.value);\n+        addCpAndWriteString(lock.field);\n+        addCpAndWriteString(lock.lockedBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.Unlock unlock) {\n+        writePosition(unlock.pos);\n+        buf.writeByte(unlock.kind.getValue());\n+        addCpAndWriteString(unlock.unlockBB.id.value);\n+    }\n+\n+\n+    public void visit(BIRTerminator.Return birReturn) {\n+        writePosition(birReturn.pos);\n+        buf.writeByte(birReturn.kind.getValue());\n+    }\n+\n+    public void visit(BIRTerminator.Branch birBranch) {\n+        writePosition(birBranch.pos);\n+        buf.writeByte(birBranch.kind.getValue());\n+        birBranch.op.accept(this);\n+        // true:BB\n+        addCpAndWriteString(birBranch.trueBB.id.value);\n+        // false:BB\n+        addCpAndWriteString(birBranch.falseBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.Wait waitEntry) {\n+        writePosition(waitEntry.pos);\n+        buf.writeByte(waitEntry.kind.getValue());\n+        buf.writeInt(waitEntry.exprList.size());\n+        for (BIROperand expr : waitEntry.exprList) {\n+            expr.accept(this);\n+        }\n+        waitEntry.lhsOp.accept(this);\n+        addCpAndWriteString(waitEntry.thenBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.Flush entry) {\n+        writePosition(entry.pos);\n+        buf.writeByte(entry.kind.getValue());\n+        buf.writeInt(entry.channels.length);\n+        for (BIRNode.ChannelDetails detail : entry.channels) {\n+            addCpAndWriteString(detail.name);\n+            buf.writeBoolean(detail.channelInSameStrand);\n+            buf.writeBoolean(detail.send);\n+        }\n+        entry.lhsOp.accept(this);\n+        addCpAndWriteString(entry.thenBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.WorkerReceive entry) {\n+        writePosition(entry.pos);\n+        buf.writeByte((entry.kind.getValue()));\n+        buf.writeInt(addStringCPEntry(entry.workerName.getValue()));\n+        entry.lhsOp.accept(this);\n+        buf.writeBoolean(entry.isSameStrand);\n+        addCpAndWriteString(entry.thenBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.WorkerSend entry) {\n+        writePosition(entry.pos);\n+        buf.writeByte((entry.kind.getValue()));\n+        buf.writeInt(addStringCPEntry(entry.channel.getValue()));\n+        entry.data.accept(this);\n+        buf.writeBoolean(entry.isSameStrand);\n+        buf.writeBoolean(entry.isSync);\n+        if (entry.isSync) {\n+            entry.lhsOp.accept(this);\n+        }\n+        addCpAndWriteString(entry.thenBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.WaitAll waitAll) {\n+        writePosition(waitAll.pos);\n+        buf.writeByte((waitAll.kind.getValue()));\n+        waitAll.lhsOp.accept(this);\n+        buf.writeInt(waitAll.keys.size());\n+        waitAll.keys.forEach(key -> buf.writeInt(addStringCPEntry(key)));\n+        waitAll.valueExprs.forEach(val -> val.accept(this));\n+        addCpAndWriteString(waitAll.thenBB.id.value);\n+    }\n+\n+    // Non-terminating instructions\n+\n+    @Override\n+    public void visit(BIRNonTerminator.NewTable newTable) {\n+        writePosition(newTable.pos);\n+        writeType(newTable.type);\n+        newTable.lhsOp.accept(this);\n+        newTable.keyColOp.accept(this);\n+        newTable.dataOp.accept(this);\n+    }\n+\n+\n+    public void visit(BIRNonTerminator.Move birMove) {\n+        writePosition(birMove.pos);\n+        buf.writeByte(birMove.kind.getValue());\n+        birMove.rhsOp.accept(this);\n+        birMove.lhsOp.accept(this);\n+    }\n+\n+    public void visit(BIRTerminator.Call birCall) {\n+        writePosition(birCall.pos);\n+        buf.writeByte(birCall.kind.getValue());\n+        PackageID calleePkg = birCall.calleePkg;\n+        int pkgIndex = addPkgCPEntry(calleePkg);\n+        buf.writeBoolean(birCall.isVirtual);\n+        buf.writeInt(pkgIndex);\n+        buf.writeInt(addStringCPEntry(birCall.name.getValue()));\n+        buf.writeInt(birCall.args.size());\n+        for (BIROperand arg : birCall.args) {\n+            arg.accept(this);\n+        }\n+        if (birCall.lhsOp != null) {\n+            buf.writeByte(1);\n+            birCall.lhsOp.accept(this);\n+        } else {\n+            buf.writeByte(0);\n+        }\n+        addCpAndWriteString(birCall.thenBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.AsyncCall birAsyncCall) {\n+        writePosition(birAsyncCall.pos);\n+        buf.writeByte(birAsyncCall.kind.getValue());\n+        PackageID calleePkg = birAsyncCall.calleePkg;\n+        int pkgIndex = addPkgCPEntry(calleePkg);\n+        buf.writeBoolean(birAsyncCall.isVirtual);\n+        buf.writeInt(pkgIndex);\n+        buf.writeInt(addStringCPEntry(birAsyncCall.name.getValue()));\n+        buf.writeInt(birAsyncCall.args.size());\n+        for (BIROperand arg : birAsyncCall.args) {\n+            arg.accept(this);\n+        }\n+        if (birAsyncCall.lhsOp != null) {\n+            buf.writeByte(1);\n+            birAsyncCall.lhsOp.accept(this);\n+        } else {\n+            buf.writeByte(0);\n+        }\n+\n+        binaryWriter.writeAnnotAttachments(buf, this, birAsyncCall.annotAttachments);\n+        addCpAndWriteString(birAsyncCall.thenBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.FPCall fpCall) {\n+        writePosition(fpCall.pos);\n+        buf.writeByte(fpCall.kind.getValue());\n+        fpCall.fp.accept(this);\n+        buf.writeInt(fpCall.args.size());\n+        for (BIROperand arg : fpCall.args) {\n+            arg.accept(this);\n+        }\n+        if (fpCall.lhsOp != null) {\n+            buf.writeByte(1);\n+            fpCall.lhsOp.accept(this);\n+        } else {\n+            buf.writeByte(0);\n+        }\n+        buf.writeBoolean(fpCall.isAsync);\n+        addCpAndWriteString(fpCall.thenBB.id.value);\n+    }\n+\n+    public void visit(BIRNonTerminator.BinaryOp birBinaryOp) {\n+        writePosition(birBinaryOp.pos);\n+        buf.writeByte(birBinaryOp.kind.getValue());\n+        birBinaryOp.rhsOp1.accept(this);\n+        birBinaryOp.rhsOp2.accept(this);\n+        birBinaryOp.lhsOp.accept(this);\n+    }\n+\n+    public void visit(BIRNonTerminator.UnaryOP birUnaryOp) {\n+        writePosition(birUnaryOp.pos);\n+        buf.writeByte(birUnaryOp.kind.getValue());\n+        birUnaryOp.rhsOp.accept(this);\n+        birUnaryOp.lhsOp.accept(this);\n+    }\n+\n+    public void visit(BIRNonTerminator.ConstantLoad birConstantLoad) {\n+        writePosition(birConstantLoad.pos);\n+        buf.writeByte(birConstantLoad.kind.getValue());\n+        writeType(birConstantLoad.type);\n+        birConstantLoad.lhsOp.accept(this);\n+\n+        BType type = birConstantLoad.type;\n+        switch (type.tag) {\n+            case TypeTags.INT:\n+            case TypeTags.SIGNED32_INT:\n+            case TypeTags.SIGNED16_INT:\n+            case TypeTags.SIGNED8_INT:\n+            case TypeTags.UNSIGNED32_INT:\n+            case TypeTags.UNSIGNED16_INT:\n+            case TypeTags.UNSIGNED8_INT:\n+                buf.writeInt(cp.addCPEntry(new IntegerCPEntry((Long) birConstantLoad.value)));\n+                break;\n+            case TypeTags.BYTE:\n+                // TODO: birConstantLoad.value should return an Integer. This is a temporary fix\n+                int byteValue = ((Number) birConstantLoad.value).intValue();\n+                buf.writeInt(cp.addCPEntry(new ByteCPEntry(byteValue)));\n+                break;\n+            case TypeTags.BOOLEAN:\n+                // Not adding to constant pool as it increases the size (bit vs integer)\n+                buf.writeBoolean((Boolean) birConstantLoad.value);\n+                break;\n+            case TypeTags.STRING:\n+            case TypeTags.CHAR_STRING:\n+            case TypeTags.DECIMAL:\n+                buf.writeInt(cp.addCPEntry(new StringCPEntry(birConstantLoad.value.toString())));\n+                break;\n+            case TypeTags.FLOAT:\n+                double value = birConstantLoad.value instanceof Double ? (double) birConstantLoad.value\n+                        : Double.parseDouble((String) birConstantLoad.value);\n+                buf.writeInt(cp.addCPEntry(new FloatCPEntry(value)));\n+                break;\n+            case TypeTags.NIL:\n+                break;\n+            default:\n+                throw new IllegalStateException(\"unsupported constant type: \" + type);\n+        }\n+    }\n+\n+    public void visit(NewStructure birNewStructure) {\n+        writePosition(birNewStructure.pos);\n+        buf.writeByte(birNewStructure.kind.getValue());\n+        birNewStructure.rhsOp.accept(this);\n+        birNewStructure.lhsOp.accept(this);\n+    }\n+\n+    public void visit(BIRNonTerminator.NewInstance newInstance) {\n+        writePosition(newInstance.pos);\n+        buf.writeByte(newInstance.kind.getValue());\n+        buf.writeBoolean(newInstance.isExternalDef);\n+        if (newInstance.isExternalDef) {\n+            assert newInstance.externalPackageId != null;\n+            buf.writeInt(addPkgCPEntry(newInstance.externalPackageId));\n+            buf.writeInt(addStringCPEntry(newInstance.objectName));\n+        } else {\n+            buf.writeInt(newInstance.def.index);\n+        }\n+        newInstance.lhsOp.accept(this);\n+    }\n+\n+    public void visit(NewArray birNewArray) {\n+        writePosition(birNewArray.pos);\n+        buf.writeByte(birNewArray.kind.getValue());\n+        writeType(birNewArray.type);\n+        birNewArray.lhsOp.accept(this);\n+        birNewArray.sizeOp.accept(this);\n+    }\n+\n+    public void visit(BIRNonTerminator.FieldAccess birFieldAccess) {\n+        writePosition(birFieldAccess.pos);\n+        buf.writeByte(birFieldAccess.kind.getValue());\n+        if (birFieldAccess.kind == InstructionKind.MAP_LOAD || birFieldAccess.kind == InstructionKind.ARRAY_LOAD) {\n+            buf.writeBoolean(birFieldAccess.optionalFieldAccess);\n+            buf.writeBoolean(birFieldAccess.fillingRead);\n+        }\n+        birFieldAccess.lhsOp.accept(this);\n+        birFieldAccess.keyOp.accept(this);\n+        birFieldAccess.rhsOp.accept(this);\n+    }\n+\n+    public void visit(BIRNonTerminator.TypeCast birTypeCast) {\n+        writePosition(birTypeCast.pos);\n+        buf.writeByte(birTypeCast.kind.getValue());\n+        birTypeCast.lhsOp.accept(this);\n+        birTypeCast.rhsOp.accept(this);\n+        writeType(birTypeCast.type);\n+        buf.writeBoolean(birTypeCast.checkTypes);\n+    }\n+\n+    public void visit(BIRNonTerminator.IsLike birIsLike) {\n+        writePosition(birIsLike.pos);\n+        buf.writeByte(birIsLike.kind.getValue());\n+        writeType(birIsLike.type);\n+        birIsLike.lhsOp.accept(this);\n+        birIsLike.rhsOp.accept(this);\n+    }\n+\n+    public void visit(BIRNonTerminator.TypeTest birTypeTest) {\n+        writePosition(birTypeTest.pos);\n+        buf.writeByte(birTypeTest.kind.getValue());\n+        writeType(birTypeTest.type);\n+        birTypeTest.lhsOp.accept(this);\n+        birTypeTest.rhsOp.accept(this);\n+    }\n+\n+    // Operands\n+    public void visit(BIROperand birOperand) {\n+        if (birOperand.variableDcl.ignoreVariable) {\n+            buf.writeBoolean(true);\n+            writeType(birOperand.variableDcl.type);\n+            return;\n+        }\n+\n+        buf.writeBoolean(false);\n+        buf.writeByte(birOperand.variableDcl.kind.getValue());\n+        buf.writeByte(birOperand.variableDcl.scope.getValue());\n+\n+        // TODO use the integer index of the variable.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6fc3de447ec3361b9ab93c473a6610544ffe80f8"}, "originalPosition": 420}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "46639394b946bb5ad6c123916ec8bf1013f0c92b", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/46639394b946bb5ad6c123916ec8bf1013f0c92b", "committedDate": "2020-08-26T11:07:36Z", "message": "Add function body with basic blocks and instructions\n\nUpdating the ksy file with BIR basic block and instruction models."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "24d8a372b83f922eb16e4edf5d5ceb494f4adf40", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/24d8a372b83f922eb16e4edf5d5ceb494f4adf40", "committedDate": "2020-08-26T11:08:01Z", "message": "Update BIR spec with error_table and woker_channel details"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "78097e0824967f6b240c214b969115f167feacba", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/78097e0824967f6b240c214b969115f167feacba", "committedDate": "2020-08-26T11:08:13Z", "message": "Add instruction_call structure to BIR spec"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0199cbcfacca35cb0177519e47f0796dbb050350", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/0199cbcfacca35cb0177519e47f0796dbb050350", "committedDate": "2020-08-26T11:08:37Z", "message": "Refactor BIR instruction writer\n\nWith this change the instructions will be written in a consistent\nmanner as forst position and then the kind value."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "98a9030d160a7242b902a35cb286163a2b084d1d", "author": {"user": {"login": "warunalakshitha", "name": "Waruna Lakshitha"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/98a9030d160a7242b902a35cb286163a2b084d1d", "committedDate": "2020-08-26T12:17:36Z", "message": "Address code review suggestions"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a7e2c7089ad06c310e6516b523edc73c1fc34b0c", "author": {"user": {"login": "warunalakshitha", "name": "Waruna Lakshitha"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a7e2c7089ad06c310e6516b523edc73c1fc34b0c", "committedDate": "2020-08-26T11:46:34Z", "message": "Address code review suggestions"}, "afterCommit": {"oid": "98a9030d160a7242b902a35cb286163a2b084d1d", "author": {"user": {"login": "warunalakshitha", "name": "Waruna Lakshitha"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/98a9030d160a7242b902a35cb286163a2b084d1d", "committedDate": "2020-08-26T12:17:36Z", "message": "Address code review suggestions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a29f5093829b120fcb2340779cf147da5ddf17e0", "author": {"user": {"login": "warunalakshitha", "name": "Waruna Lakshitha"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a29f5093829b120fcb2340779cf147da5ddf17e0", "committedDate": "2020-08-27T11:29:16Z", "message": "Remove bir.ksy file"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2NzMzMTk2", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25351#pullrequestreview-476733196", "createdAt": "2020-08-27T13:43:02Z", "commit": {"oid": "a29f5093829b120fcb2340779cf147da5ddf17e0"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMzo0MzowMlrOHIQ-8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMzo0NTowNFrOHIRErQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODQyODkxNA==", "bodyText": "Shall we have the method after the call to maintain vertical ordering?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25351#discussion_r478428914", "createdAt": "2020-08-27T13:43:02Z", "author": {"login": "riyafa"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/BIRPackageSymbolEnter.java", "diffHunk": "@@ -378,10 +398,19 @@ private void defineFunction(DataInputStream dataInStream) throws IOException {\n \n         defineMarkDownDocAttachment(invokableSymbol, readDocBytes(dataInStream));\n \n+        dataInStream.skip(dataInStream.readLong()); // read and skip method body\n+\n         scopeToDefine.define(invokableSymbol.name, invokableSymbol);\n     }\n \n+    private void skipPosition(DataInputStream dataInStream) throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a29f5093829b120fcb2340779cf147da5ddf17e0"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODQyOTQ0MA==", "bodyText": "Is this a dangling comment?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25351#discussion_r478429440", "createdAt": "2020-08-27T13:43:47Z", "author": {"login": "riyafa"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/writer/BIRBinaryWriter.java", "diffHunk": "@@ -196,7 +226,75 @@ private void writeFunction(ByteBuf buf, BIRNode.BIRFunction birFunction) {\n \n         writeTaintTable(buf, birFunction.taintTable);\n \n-        DocAttachmentWriter.writeMarkdownDocAttachment(buf, birFunction.markdownDocAttachment, cp);\n+        typeWriter.writeMarkdownDocAttachment(buf, birFunction.markdownDocAttachment);\n+\n+        ByteBuf birbuf = Unpooled.buffer();\n+        BIRInstructionWriter funcInsWriter = new BIRInstructionWriter(birbuf, cp, this);\n+\n+        // Arg count\n+        birbuf.writeInt(birFunction.argsCount);\n+        // Local variables", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a29f5093829b120fcb2340779cf147da5ddf17e0"}, "originalPosition": 172}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODQzMDM4MQ==", "bodyText": "Is this really conctant? \ud83d\ude42", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25351#discussion_r478430381", "createdAt": "2020-08-27T13:45:04Z", "author": {"login": "riyafa"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/writer/BIRBinaryWriter.java", "diffHunk": "@@ -233,27 +333,29 @@ private void writeAnnotation(ByteBuf buf, BIRNode.BIRAnnotation birAnnotation) {\n         }\n \n         writeType(buf, birAnnotation.annotationType);\n-        DocAttachmentWriter.writeMarkdownDocAttachment(buf, birAnnotation.markdownDocAttachment, cp);\n+        typeWriter.writeMarkdownDocAttachment(buf, birAnnotation.markdownDocAttachment);\n     }\n \n     private void writeConstants(ByteBuf buf, List<BIRNode.BIRConstant> birConstList) {\n+        BIRTypeWriter constTypeWriter = new BIRTypeWriter(buf, cp);\n         buf.writeInt(birConstList.size());\n-        birConstList.forEach(constant -> writeConstant(buf, constant));\n+        birConstList.forEach(constant -> writeConstant(buf, constTypeWriter, constant));\n     }\n \n-    private void writeConstant(ByteBuf buf, BIRNode.BIRConstant birConstant) {\n+    private void writeConstant(ByteBuf buf, BIRTypeWriter typeWriter, BIRNode.BIRConstant birConstant) {\n         // Annotation name CP Index\n         buf.writeInt(addStringCPEntry(birConstant.name.value));\n         buf.writeInt(birConstant.flags);\n \n-        DocAttachmentWriter.writeMarkdownDocAttachment(buf, birConstant.markdownDocAttachment, cp);\n+        typeWriter.writeMarkdownDocAttachment(buf, birConstant.markdownDocAttachment);\n \n         writeType(buf, birConstant.type);\n \n-        // write the length of the constant value, so that it can be skipped.\n+        // write the length of the conctant value, so that it can be skipped.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a29f5093829b120fcb2340779cf147da5ddf17e0"}, "originalPosition": 282}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d2bf6808e33e363946961010150ed4a9aab02b0c", "author": {"user": {"login": "warunalakshitha", "name": "Waruna Lakshitha"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/d2bf6808e33e363946961010150ed4a9aab02b0c", "committedDate": "2020-08-28T08:18:58Z", "message": "Address review suggestions"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c89ce894e142cad754f8682c4d1adb69421ddb53", "author": {"user": {"login": "warunalakshitha", "name": "Waruna Lakshitha"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c89ce894e142cad754f8682c4d1adb69421ddb53", "committedDate": "2020-08-28T07:22:57Z", "message": "Address review suggestions"}, "afterCommit": {"oid": "d2bf6808e33e363946961010150ed4a9aab02b0c", "author": {"user": {"login": "warunalakshitha", "name": "Waruna Lakshitha"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/d2bf6808e33e363946961010150ed4a9aab02b0c", "committedDate": "2020-08-28T08:18:58Z", "message": "Address review suggestions"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc3NTg1MTA4", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25351#pullrequestreview-477585108", "createdAt": "2020-08-28T09:31:40Z", "commit": {"oid": "d2bf6808e33e363946961010150ed4a9aab02b0c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwOTozMTo0MVrOHI1SKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwOTozMTo0MVrOHI1SKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTAyMzY1OA==", "bodyText": "We can call the skipPosition method here if we pass it a parameter. skipPosition(dataInStream, 4); we can add a comment above the call if it makes sense", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25351#discussion_r479023658", "createdAt": "2020-08-28T09:31:41Z", "author": {"login": "riyafa"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/BIRPackageSymbolEnter.java", "diffHunk": "@@ -330,9 +340,15 @@ private void defineImportPackage(DataInputStream dataInStream) throws IOExceptio\n     }\n \n     private void defineFunction(DataInputStream dataInStream) throws IOException {\n+        dataInStream.readInt(); // skip line start\n+        dataInStream.readInt(); // skip line end\n+        dataInStream.readInt(); // skip col start\n+        dataInStream.readInt(); // skip col end", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2bf6808e33e363946961010150ed4a9aab02b0c"}, "originalPosition": 86}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c5b20a5409ea8922185efcbb6a91f96ab210287e", "author": {"user": {"login": "warunalakshitha", "name": "Waruna Lakshitha"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c5b20a5409ea8922185efcbb6a91f96ab210287e", "committedDate": "2020-08-31T06:57:00Z", "message": "Refactor skip position logic"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc4MzgzOTM1", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25351#pullrequestreview-478383935", "createdAt": "2020-08-31T07:34:10Z", "commit": {"oid": "c5b20a5409ea8922185efcbb6a91f96ab210287e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4895, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}