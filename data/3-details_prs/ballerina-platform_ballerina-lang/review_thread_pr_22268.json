{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk0NjYzODE3", "number": 22268, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNDo0NzozNFrODwBvqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNDo0ODo0NVrODwBxzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNjg2ODI3OnYy", "diffSide": "RIGHT", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/AnnotationUtils.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNDo0NzozNFrOGCywZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQwNTowMjowM1rOGDJrdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU4MTkyNg==", "bodyText": "inverse if condition here", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22268#discussion_r405581926", "createdAt": "2020-04-08T14:47:34Z", "author": {"login": "Kishanthan"}, "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/AnnotationUtils.java", "diffHunk": "@@ -62,11 +63,40 @@ public static void processAnnotations(MapValue globalAnnotMap, BType bType) {\n         }\n     }\n \n+    /**\n+     * Method to retrieve annotations of the type from the global annotation map and set it to the type.\n+     *\n+     * @param globalAnnotMap The global annotation map\n+     * @param bType          The type for which annotations need to be set\n+     */\n+    public static void processAnnotations_bstring(MapValue globalAnnotMap, BType bType) {\n+        if (!(bType instanceof AnnotatableType)) {\n+            return;\n+        }\n+\n+        AnnotatableType type = (AnnotatableType) bType;\n+        BString annotationKey = StringUtils.fromString(type.getAnnotationKey());\n+        if (globalAnnotMap.containsKey(annotationKey)) {\n+            type.setAnnotations_bstring((MapValue<BString, Object>) globalAnnotMap.get(annotationKey));\n+        }\n+\n+        if (type.getTag() == TypeTags.OBJECT_TYPE_TAG) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc14140fc5423f7e760f6bff238c840859df192d"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTYzMzMyMQ==", "bodyText": "What do you mean by inverse? Am I to use != check?\nThis is a copy of the previous function to make it work with bstring", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22268#discussion_r405633321", "createdAt": "2020-04-08T15:56:54Z", "author": {"login": "riyafa"}, "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/AnnotationUtils.java", "diffHunk": "@@ -62,11 +63,40 @@ public static void processAnnotations(MapValue globalAnnotMap, BType bType) {\n         }\n     }\n \n+    /**\n+     * Method to retrieve annotations of the type from the global annotation map and set it to the type.\n+     *\n+     * @param globalAnnotMap The global annotation map\n+     * @param bType          The type for which annotations need to be set\n+     */\n+    public static void processAnnotations_bstring(MapValue globalAnnotMap, BType bType) {\n+        if (!(bType instanceof AnnotatableType)) {\n+            return;\n+        }\n+\n+        AnnotatableType type = (AnnotatableType) bType;\n+        BString annotationKey = StringUtils.fromString(type.getAnnotationKey());\n+        if (globalAnnotMap.containsKey(annotationKey)) {\n+            type.setAnnotations_bstring((MapValue<BString, Object>) globalAnnotMap.get(annotationKey));\n+        }\n+\n+        if (type.getTag() == TypeTags.OBJECT_TYPE_TAG) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU4MTkyNg=="}, "originalCommit": {"oid": "bc14140fc5423f7e760f6bff238c840859df192d"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTk1NzQ5Mw==", "bodyText": "Can we write like the below ? Will it be more readable with less indentation?\nif (type.getTag() != TypeTags.OBJECT_TYPE_TAG) { \n    return;\n}\n\nBObjectType objectType = (BObjectType) type;\nfor (AttachedFunction attachedFunction : objectType.getAttachedFunctions()) {\n    annotationKey = StringUtils.fromString(attachedFunction.getAnnotationKey());\n    if (!globalAnnotMap.containsKey(annotationKey)) {\n        continue;\n    }\n    attachedFunction.setAnnotations_bstring((MapValue<BString, Object>)\n            globalAnnotMap.get(annotationKey));\n    }\n}", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22268#discussion_r405957493", "createdAt": "2020-04-09T05:02:03Z", "author": {"login": "Kishanthan"}, "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/AnnotationUtils.java", "diffHunk": "@@ -62,11 +63,40 @@ public static void processAnnotations(MapValue globalAnnotMap, BType bType) {\n         }\n     }\n \n+    /**\n+     * Method to retrieve annotations of the type from the global annotation map and set it to the type.\n+     *\n+     * @param globalAnnotMap The global annotation map\n+     * @param bType          The type for which annotations need to be set\n+     */\n+    public static void processAnnotations_bstring(MapValue globalAnnotMap, BType bType) {\n+        if (!(bType instanceof AnnotatableType)) {\n+            return;\n+        }\n+\n+        AnnotatableType type = (AnnotatableType) bType;\n+        BString annotationKey = StringUtils.fromString(type.getAnnotationKey());\n+        if (globalAnnotMap.containsKey(annotationKey)) {\n+            type.setAnnotations_bstring((MapValue<BString, Object>) globalAnnotMap.get(annotationKey));\n+        }\n+\n+        if (type.getTag() == TypeTags.OBJECT_TYPE_TAG) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU4MTkyNg=="}, "originalCommit": {"oid": "bc14140fc5423f7e760f6bff238c840859df192d"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNjg3MDk3OnYy", "diffSide": "RIGHT", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeConverter.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNDo0ODowN1rOGCyyHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQwNTowNDo0MlrOGDJuEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU4MjM2NQ==", "bodyText": "inverse if condition here", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22268#discussion_r405582365", "createdAt": "2020-04-08T14:48:07Z", "author": {"login": "Kishanthan"}, "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeConverter.java", "diffHunk": "@@ -262,6 +331,57 @@ static boolean isConvertibleToFloatingPointTypes(Object value) {\n         return convertibleTypes;\n     }\n \n+    private static boolean isConvertibleToRecordType_bstring(Object sourceValue, BRecordType targetType,\n+                                                             List<TypeValuePair> unresolvedValues) {\n+        if (!(sourceValue instanceof MapValueImpl)) {\n+            return false;\n+        }\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(sourceValue, targetType);\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            return true;\n+        }\n+        unresolvedValues.add(typeValuePair);\n+\n+        Map<String, BType> targetFieldTypes = new HashMap<>();\n+        BType restFieldType = targetType.restFieldType;\n+\n+        for (BField field : targetType.getFields().values()) {\n+            targetFieldTypes.put(field.getFieldName(), field.type);\n+        }\n+\n+        MapValueImpl sourceMapValueImpl = (MapValueImpl) sourceValue;\n+        for (Map.Entry targetTypeEntry : targetFieldTypes.entrySet()) {\n+            String fieldName = targetTypeEntry.getKey().toString();\n+\n+            if (!sourceMapValueImpl.containsKey(StringUtils.fromString(fieldName))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc14140fc5423f7e760f6bff238c840859df192d"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTYzODIwMw==", "bodyText": "I inverted the condition, but this is also a copy of an existing function for bstring changes", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22268#discussion_r405638203", "createdAt": "2020-04-08T16:03:51Z", "author": {"login": "riyafa"}, "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeConverter.java", "diffHunk": "@@ -262,6 +331,57 @@ static boolean isConvertibleToFloatingPointTypes(Object value) {\n         return convertibleTypes;\n     }\n \n+    private static boolean isConvertibleToRecordType_bstring(Object sourceValue, BRecordType targetType,\n+                                                             List<TypeValuePair> unresolvedValues) {\n+        if (!(sourceValue instanceof MapValueImpl)) {\n+            return false;\n+        }\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(sourceValue, targetType);\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            return true;\n+        }\n+        unresolvedValues.add(typeValuePair);\n+\n+        Map<String, BType> targetFieldTypes = new HashMap<>();\n+        BType restFieldType = targetType.restFieldType;\n+\n+        for (BField field : targetType.getFields().values()) {\n+            targetFieldTypes.put(field.getFieldName(), field.type);\n+        }\n+\n+        MapValueImpl sourceMapValueImpl = (MapValueImpl) sourceValue;\n+        for (Map.Entry targetTypeEntry : targetFieldTypes.entrySet()) {\n+            String fieldName = targetTypeEntry.getKey().toString();\n+\n+            if (!sourceMapValueImpl.containsKey(StringUtils.fromString(fieldName))) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU4MjM2NQ=="}, "originalCommit": {"oid": "bc14140fc5423f7e760f6bff238c840859df192d"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTk1ODE2MA==", "bodyText": "ack", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22268#discussion_r405958160", "createdAt": "2020-04-09T05:04:42Z", "author": {"login": "Kishanthan"}, "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeConverter.java", "diffHunk": "@@ -262,6 +331,57 @@ static boolean isConvertibleToFloatingPointTypes(Object value) {\n         return convertibleTypes;\n     }\n \n+    private static boolean isConvertibleToRecordType_bstring(Object sourceValue, BRecordType targetType,\n+                                                             List<TypeValuePair> unresolvedValues) {\n+        if (!(sourceValue instanceof MapValueImpl)) {\n+            return false;\n+        }\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(sourceValue, targetType);\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            return true;\n+        }\n+        unresolvedValues.add(typeValuePair);\n+\n+        Map<String, BType> targetFieldTypes = new HashMap<>();\n+        BType restFieldType = targetType.restFieldType;\n+\n+        for (BField field : targetType.getFields().values()) {\n+            targetFieldTypes.put(field.getFieldName(), field.type);\n+        }\n+\n+        MapValueImpl sourceMapValueImpl = (MapValueImpl) sourceValue;\n+        for (Map.Entry targetTypeEntry : targetFieldTypes.entrySet()) {\n+            String fieldName = targetTypeEntry.getKey().toString();\n+\n+            if (!sourceMapValueImpl.containsKey(StringUtils.fromString(fieldName))) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU4MjM2NQ=="}, "originalCommit": {"oid": "bc14140fc5423f7e760f6bff238c840859df192d"}, "originalPosition": 114}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNjg3Mzc0OnYy", "diffSide": "RIGHT", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeConverter.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNDo0ODo0NVrOGCyz3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQwNTowMjo1OVrOGDJsTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU4MjgxMg==", "bodyText": "these two conditions can be merged", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22268#discussion_r405582812", "createdAt": "2020-04-08T14:48:45Z", "author": {"login": "Kishanthan"}, "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeConverter.java", "diffHunk": "@@ -262,6 +331,57 @@ static boolean isConvertibleToFloatingPointTypes(Object value) {\n         return convertibleTypes;\n     }\n \n+    private static boolean isConvertibleToRecordType_bstring(Object sourceValue, BRecordType targetType,\n+                                                             List<TypeValuePair> unresolvedValues) {\n+        if (!(sourceValue instanceof MapValueImpl)) {\n+            return false;\n+        }\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(sourceValue, targetType);\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            return true;\n+        }\n+        unresolvedValues.add(typeValuePair);\n+\n+        Map<String, BType> targetFieldTypes = new HashMap<>();\n+        BType restFieldType = targetType.restFieldType;\n+\n+        for (BField field : targetType.getFields().values()) {\n+            targetFieldTypes.put(field.getFieldName(), field.type);\n+        }\n+\n+        MapValueImpl sourceMapValueImpl = (MapValueImpl) sourceValue;\n+        for (Map.Entry targetTypeEntry : targetFieldTypes.entrySet()) {\n+            String fieldName = targetTypeEntry.getKey().toString();\n+\n+            if (!sourceMapValueImpl.containsKey(StringUtils.fromString(fieldName))) {\n+                BField targetField = targetType.getFields().get(fieldName);\n+                if (Flags.isFlagOn(targetField.flags, Flags.REQUIRED)) {\n+                    return false;\n+                }\n+            }\n+        }\n+\n+        for (Object object : sourceMapValueImpl.entrySet()) {\n+            Map.Entry valueEntry = (Map.Entry) object;\n+            String fieldName = valueEntry.getKey().toString();\n+\n+            if (targetFieldTypes.containsKey(fieldName)) {\n+                if (getConvertibleTypes(valueEntry.getValue(), targetFieldTypes.get(fieldName),\n+                                        unresolvedValues).size() != 1) {\n+                    return false;\n+                }\n+            } else if (!targetType.sealed) {\n+                if (getConvertibleTypes(valueEntry.getValue(), restFieldType, unresolvedValues).size() != 1) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc14140fc5423f7e760f6bff238c840859df192d"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTYzNjQ4OA==", "bodyText": "I don't think they can be merged because of the else statement for\nif (!targetType.sealed) {\nNote this is also a copy of the previous existing function for bstring changes", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22268#discussion_r405636488", "createdAt": "2020-04-08T16:01:26Z", "author": {"login": "riyafa"}, "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeConverter.java", "diffHunk": "@@ -262,6 +331,57 @@ static boolean isConvertibleToFloatingPointTypes(Object value) {\n         return convertibleTypes;\n     }\n \n+    private static boolean isConvertibleToRecordType_bstring(Object sourceValue, BRecordType targetType,\n+                                                             List<TypeValuePair> unresolvedValues) {\n+        if (!(sourceValue instanceof MapValueImpl)) {\n+            return false;\n+        }\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(sourceValue, targetType);\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            return true;\n+        }\n+        unresolvedValues.add(typeValuePair);\n+\n+        Map<String, BType> targetFieldTypes = new HashMap<>();\n+        BType restFieldType = targetType.restFieldType;\n+\n+        for (BField field : targetType.getFields().values()) {\n+            targetFieldTypes.put(field.getFieldName(), field.type);\n+        }\n+\n+        MapValueImpl sourceMapValueImpl = (MapValueImpl) sourceValue;\n+        for (Map.Entry targetTypeEntry : targetFieldTypes.entrySet()) {\n+            String fieldName = targetTypeEntry.getKey().toString();\n+\n+            if (!sourceMapValueImpl.containsKey(StringUtils.fromString(fieldName))) {\n+                BField targetField = targetType.getFields().get(fieldName);\n+                if (Flags.isFlagOn(targetField.flags, Flags.REQUIRED)) {\n+                    return false;\n+                }\n+            }\n+        }\n+\n+        for (Object object : sourceMapValueImpl.entrySet()) {\n+            Map.Entry valueEntry = (Map.Entry) object;\n+            String fieldName = valueEntry.getKey().toString();\n+\n+            if (targetFieldTypes.containsKey(fieldName)) {\n+                if (getConvertibleTypes(valueEntry.getValue(), targetFieldTypes.get(fieldName),\n+                                        unresolvedValues).size() != 1) {\n+                    return false;\n+                }\n+            } else if (!targetType.sealed) {\n+                if (getConvertibleTypes(valueEntry.getValue(), restFieldType, unresolvedValues).size() != 1) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU4MjgxMg=="}, "originalCommit": {"oid": "bc14140fc5423f7e760f6bff238c840859df192d"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTk1NzcxMA==", "bodyText": "ack", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22268#discussion_r405957710", "createdAt": "2020-04-09T05:02:59Z", "author": {"login": "Kishanthan"}, "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeConverter.java", "diffHunk": "@@ -262,6 +331,57 @@ static boolean isConvertibleToFloatingPointTypes(Object value) {\n         return convertibleTypes;\n     }\n \n+    private static boolean isConvertibleToRecordType_bstring(Object sourceValue, BRecordType targetType,\n+                                                             List<TypeValuePair> unresolvedValues) {\n+        if (!(sourceValue instanceof MapValueImpl)) {\n+            return false;\n+        }\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(sourceValue, targetType);\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            return true;\n+        }\n+        unresolvedValues.add(typeValuePair);\n+\n+        Map<String, BType> targetFieldTypes = new HashMap<>();\n+        BType restFieldType = targetType.restFieldType;\n+\n+        for (BField field : targetType.getFields().values()) {\n+            targetFieldTypes.put(field.getFieldName(), field.type);\n+        }\n+\n+        MapValueImpl sourceMapValueImpl = (MapValueImpl) sourceValue;\n+        for (Map.Entry targetTypeEntry : targetFieldTypes.entrySet()) {\n+            String fieldName = targetTypeEntry.getKey().toString();\n+\n+            if (!sourceMapValueImpl.containsKey(StringUtils.fromString(fieldName))) {\n+                BField targetField = targetType.getFields().get(fieldName);\n+                if (Flags.isFlagOn(targetField.flags, Flags.REQUIRED)) {\n+                    return false;\n+                }\n+            }\n+        }\n+\n+        for (Object object : sourceMapValueImpl.entrySet()) {\n+            Map.Entry valueEntry = (Map.Entry) object;\n+            String fieldName = valueEntry.getKey().toString();\n+\n+            if (targetFieldTypes.containsKey(fieldName)) {\n+                if (getConvertibleTypes(valueEntry.getValue(), targetFieldTypes.get(fieldName),\n+                                        unresolvedValues).size() != 1) {\n+                    return false;\n+                }\n+            } else if (!targetType.sealed) {\n+                if (getConvertibleTypes(valueEntry.getValue(), restFieldType, unresolvedValues).size() != 1) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU4MjgxMg=="}, "originalCommit": {"oid": "bc14140fc5423f7e760f6bff238c840859df192d"}, "originalPosition": 132}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4602, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}