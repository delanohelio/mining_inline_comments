{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE2ODg1MTI5", "number": 26805, "title": "Implement API for getting the lang lib functions allowed by method call expr", "bodyText": "Purpose\nThis PR adds the lang lib functions which can be called using a method call expression to the relevant types. An API is provided to then retrieve a list of its associated lang lib functions.\nFix #25929\nFix #26392\nRemarks\nThis is to be merged after PR #26758\nCheck List\n\n Read the Contributing Guide\n Updated Change Log\n Checked Tooling Support (#)\n Added necessary tests\n\n Unit Tests\n Spec Conformance Tests\n Integration Tests\n Ballerina By Example Tests\n\n\n Increased Test Coverage\n Added necessary documentation\n\n API documentation\n Module documentation in Module.md files\n Ballerina By Examples", "createdAt": "2020-11-06T17:31:53Z", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26805", "merged": true, "mergeCommit": {"oid": "e6d69b2150d220aae233277f295f5b435bea9456"}, "closed": true, "closedAt": "2020-11-10T10:16:21Z", "author": {"login": "pubudu91"}, "timelineItems": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdZ749EgBqjM5Njg1NjY5MDc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdbGncLAFqTUyNzA1MDczOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9ddbee17863cda4060a3907d1fa7212302a9a234", "author": {"user": {"login": "pubudu91", "name": "Pubudu Fernando"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/9ddbee17863cda4060a3907d1fa7212302a9a234", "committedDate": "2020-11-06T17:28:49Z", "message": "Add test cases for lang lib methods"}, "afterCommit": {"oid": "b27c6b6f05c2d99e8331ed10c57b1f057932edad", "author": {"user": {"login": "pubudu91", "name": "Pubudu Fernando"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b27c6b6f05c2d99e8331ed10c57b1f057932edad", "committedDate": "2020-11-06T19:11:23Z", "message": "Fix lang server tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI1ODkzNzIx", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26805#pullrequestreview-525893721", "createdAt": "2020-11-09T02:53:39Z", "commit": {"oid": "b27c6b6f05c2d99e8331ed10c57b1f057932edad"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQwMjo1MzozOVrOHvdZ8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQwMjo1ODoyMlrOHvdeQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTUyNjg5Ng==", "bodyText": "Lang libs are looped twice, here and at L#80. Can we do it in a single loop?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26805#discussion_r519526896", "createdAt": "2020-11-09T02:53:39Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-lang/src/main/java/io/ballerina/compiler/api/impl/LangLibrary.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.ballerina.compiler.api.impl;\n+\n+import io.ballerina.compiler.api.symbols.FunctionSymbol;\n+import io.ballerina.compiler.api.symbols.TypeDescKind;\n+import org.ballerinalang.model.elements.PackageID;\n+import org.ballerinalang.model.symbols.SymbolKind;\n+import org.wso2.ballerinalang.compiler.semantics.model.Scope;\n+import org.wso2.ballerinalang.compiler.semantics.model.SymbolEnv;\n+import org.wso2.ballerinalang.compiler.semantics.model.SymbolTable;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BInvokableSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BPackageSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.Symbols;\n+import org.wso2.ballerinalang.compiler.util.CompilerContext;\n+import org.wso2.ballerinalang.compiler.util.Name;\n+import org.wso2.ballerinalang.compiler.util.Names;\n+import org.wso2.ballerinalang.util.Flags;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.ARRAY;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.BOOLEAN;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.DECIMAL;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.ERROR;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.FLOAT;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.FUTURE;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.INT;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.MAP;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.OBJECT;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.STREAM;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.STRING;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.TABLE;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.TYPEDESC;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.XML;\n+\n+\n+/**\n+ * A class to hold the lang library function info required for types.\n+ *\n+ * @since 2.0.0\n+ */\n+public class LangLibrary {\n+\n+    private static final CompilerContext.Key<LangLibrary> LANG_LIB_KEY = new CompilerContext.Key<>();\n+    private static final String LANG_VALUE = \"value\";\n+\n+    private final Map<String, Map<String, BInvokableSymbol>> langLibMethods;\n+    private final Map<String, List<FunctionSymbol>> wrappedLangLibMethods;\n+    private final SymbolFactory symbolFactory;\n+\n+    private LangLibrary(CompilerContext context) {\n+        context.put(LANG_LIB_KEY, this);\n+\n+        symbolFactory = SymbolFactory.getInstance(context);\n+        SymbolTable symbolTable = SymbolTable.getInstance(context);\n+        Map<String, BPackageSymbol> langLibs = new HashMap<>();\n+        wrappedLangLibMethods = new HashMap<>();\n+\n+        for (Map.Entry<BPackageSymbol, SymbolEnv> entry : symbolTable.pkgEnvMap.entrySet()) {\n+            BPackageSymbol module = entry.getKey();\n+            PackageID moduleID = module.pkgID;\n+\n+            if (Names.BALLERINA_ORG.equals(moduleID.orgName) &&\n+                    (moduleID.nameComps.size() == 2 && Names.LANG.equals(moduleID.nameComps.get(0)))) {\n+                langLibs.put(moduleID.nameComps.get(1).value, module);\n+            }\n+        }\n+\n+        langLibMethods = getLangLibMethods(langLibs);\n+    }\n+\n+    public static LangLibrary getInstance(CompilerContext context) {\n+        LangLibrary langLib = context.get(LANG_LIB_KEY);\n+        if (langLib == null) {\n+            langLib = new LangLibrary(context);\n+        }\n+\n+        return langLib;\n+    }\n+\n+    /**\n+     * Given a type descriptor kind, return the list of lang library functions that can be called using a method call\n+     * expr, on an expression of that type.\n+     *\n+     * @param typeDescKind A type descriptor kind\n+     * @return The associated list of lang library functions\n+     */\n+    public List<FunctionSymbol> getMethods(TypeDescKind typeDescKind) {\n+        String langLibName = getAssociatedLangLibName(typeDescKind);\n+\n+        if (wrappedLangLibMethods.containsKey(langLibName)) {\n+            return wrappedLangLibMethods.get(langLibName);\n+        }\n+\n+        Map<String, BInvokableSymbol> methods = langLibMethods.get(langLibName);\n+\n+        List<FunctionSymbol> wrappedMethods = new ArrayList<>();\n+        wrappedLangLibMethods.put(langLibName, wrappedMethods);\n+        populateMethodList(wrappedMethods, methods);\n+\n+        // Add the common functions in lang.value to types which have an associated lang library.\n+        if (!LANG_VALUE.equals(langLibName)) {\n+            populateMethodList(wrappedMethods, langLibMethods.get(LANG_VALUE));\n+        }\n+\n+        return wrappedMethods;\n+    }\n+\n+    // Private Methods\n+\n+    private void populateMethodList(List<FunctionSymbol> list, Map<String, BInvokableSymbol> langLib) {\n+        for (Map.Entry<String, BInvokableSymbol> entry : langLib.entrySet()) {\n+            FunctionSymbol method = symbolFactory.createFunctionSymbol(entry.getValue(), entry.getKey());\n+            list.add(method);\n+        }\n+    }\n+\n+    private String getAssociatedLangLibName(TypeDescKind typeDescKind) {\n+        switch (typeDescKind) {\n+            case INT:\n+            case BYTE:\n+                return INT.getName();\n+            case FLOAT:\n+                return FLOAT.getName();\n+            case DECIMAL:\n+                return DECIMAL.getName();\n+            case STRING:\n+                return STRING.getName();\n+            case BOOLEAN:\n+                return BOOLEAN.getName();\n+            case ARRAY:\n+            case TUPLE:\n+                return ARRAY.getName();\n+            case STREAM:\n+                return STREAM.getName();\n+            case OBJECT:\n+                return OBJECT.getName();\n+            case RECORD:\n+            case MAP:\n+                return MAP.getName();\n+            case ERROR:\n+                return ERROR.getName();\n+            case FUTURE:\n+                return FUTURE.getName();\n+            case TYPEDESC:\n+                return TYPEDESC.getName();\n+            case XML:\n+                return XML.getName();\n+            case TABLE:\n+                return TABLE.getName();\n+            default:\n+                return \"value\";\n+        }\n+    }\n+\n+    private static Map<String, Map<String, BInvokableSymbol>> getLangLibMethods(Map<String, BPackageSymbol> langLibs) {\n+        Map<String, Map<String, BInvokableSymbol>> langLibMethods = new HashMap<>();\n+\n+        for (Map.Entry<String, BPackageSymbol> entry : langLibs.entrySet()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b27c6b6f05c2d99e8331ed10c57b1f057932edad"}, "originalPosition": 180}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTUyNzQ2NA==", "bodyText": "Can there be symbols in the lang.value module without the LANG_LIB flag?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26805#discussion_r519527464", "createdAt": "2020-11-09T02:55:53Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-lang/src/main/java/io/ballerina/compiler/api/impl/LangLibrary.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.ballerina.compiler.api.impl;\n+\n+import io.ballerina.compiler.api.symbols.FunctionSymbol;\n+import io.ballerina.compiler.api.symbols.TypeDescKind;\n+import org.ballerinalang.model.elements.PackageID;\n+import org.ballerinalang.model.symbols.SymbolKind;\n+import org.wso2.ballerinalang.compiler.semantics.model.Scope;\n+import org.wso2.ballerinalang.compiler.semantics.model.SymbolEnv;\n+import org.wso2.ballerinalang.compiler.semantics.model.SymbolTable;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BInvokableSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BPackageSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.Symbols;\n+import org.wso2.ballerinalang.compiler.util.CompilerContext;\n+import org.wso2.ballerinalang.compiler.util.Name;\n+import org.wso2.ballerinalang.compiler.util.Names;\n+import org.wso2.ballerinalang.util.Flags;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.ARRAY;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.BOOLEAN;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.DECIMAL;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.ERROR;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.FLOAT;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.FUTURE;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.INT;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.MAP;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.OBJECT;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.STREAM;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.STRING;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.TABLE;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.TYPEDESC;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.XML;\n+\n+\n+/**\n+ * A class to hold the lang library function info required for types.\n+ *\n+ * @since 2.0.0\n+ */\n+public class LangLibrary {\n+\n+    private static final CompilerContext.Key<LangLibrary> LANG_LIB_KEY = new CompilerContext.Key<>();\n+    private static final String LANG_VALUE = \"value\";\n+\n+    private final Map<String, Map<String, BInvokableSymbol>> langLibMethods;\n+    private final Map<String, List<FunctionSymbol>> wrappedLangLibMethods;\n+    private final SymbolFactory symbolFactory;\n+\n+    private LangLibrary(CompilerContext context) {\n+        context.put(LANG_LIB_KEY, this);\n+\n+        symbolFactory = SymbolFactory.getInstance(context);\n+        SymbolTable symbolTable = SymbolTable.getInstance(context);\n+        Map<String, BPackageSymbol> langLibs = new HashMap<>();\n+        wrappedLangLibMethods = new HashMap<>();\n+\n+        for (Map.Entry<BPackageSymbol, SymbolEnv> entry : symbolTable.pkgEnvMap.entrySet()) {\n+            BPackageSymbol module = entry.getKey();\n+            PackageID moduleID = module.pkgID;\n+\n+            if (Names.BALLERINA_ORG.equals(moduleID.orgName) &&\n+                    (moduleID.nameComps.size() == 2 && Names.LANG.equals(moduleID.nameComps.get(0)))) {\n+                langLibs.put(moduleID.nameComps.get(1).value, module);\n+            }\n+        }\n+\n+        langLibMethods = getLangLibMethods(langLibs);\n+    }\n+\n+    public static LangLibrary getInstance(CompilerContext context) {\n+        LangLibrary langLib = context.get(LANG_LIB_KEY);\n+        if (langLib == null) {\n+            langLib = new LangLibrary(context);\n+        }\n+\n+        return langLib;\n+    }\n+\n+    /**\n+     * Given a type descriptor kind, return the list of lang library functions that can be called using a method call\n+     * expr, on an expression of that type.\n+     *\n+     * @param typeDescKind A type descriptor kind\n+     * @return The associated list of lang library functions\n+     */\n+    public List<FunctionSymbol> getMethods(TypeDescKind typeDescKind) {\n+        String langLibName = getAssociatedLangLibName(typeDescKind);\n+\n+        if (wrappedLangLibMethods.containsKey(langLibName)) {\n+            return wrappedLangLibMethods.get(langLibName);\n+        }\n+\n+        Map<String, BInvokableSymbol> methods = langLibMethods.get(langLibName);\n+\n+        List<FunctionSymbol> wrappedMethods = new ArrayList<>();\n+        wrappedLangLibMethods.put(langLibName, wrappedMethods);\n+        populateMethodList(wrappedMethods, methods);\n+\n+        // Add the common functions in lang.value to types which have an associated lang library.\n+        if (!LANG_VALUE.equals(langLibName)) {\n+            populateMethodList(wrappedMethods, langLibMethods.get(LANG_VALUE));\n+        }\n+\n+        return wrappedMethods;\n+    }\n+\n+    // Private Methods\n+\n+    private void populateMethodList(List<FunctionSymbol> list, Map<String, BInvokableSymbol> langLib) {\n+        for (Map.Entry<String, BInvokableSymbol> entry : langLib.entrySet()) {\n+            FunctionSymbol method = symbolFactory.createFunctionSymbol(entry.getValue(), entry.getKey());\n+            list.add(method);\n+        }\n+    }\n+\n+    private String getAssociatedLangLibName(TypeDescKind typeDescKind) {\n+        switch (typeDescKind) {\n+            case INT:\n+            case BYTE:\n+                return INT.getName();\n+            case FLOAT:\n+                return FLOAT.getName();\n+            case DECIMAL:\n+                return DECIMAL.getName();\n+            case STRING:\n+                return STRING.getName();\n+            case BOOLEAN:\n+                return BOOLEAN.getName();\n+            case ARRAY:\n+            case TUPLE:\n+                return ARRAY.getName();\n+            case STREAM:\n+                return STREAM.getName();\n+            case OBJECT:\n+                return OBJECT.getName();\n+            case RECORD:\n+            case MAP:\n+                return MAP.getName();\n+            case ERROR:\n+                return ERROR.getName();\n+            case FUTURE:\n+                return FUTURE.getName();\n+            case TYPEDESC:\n+                return TYPEDESC.getName();\n+            case XML:\n+                return XML.getName();\n+            case TABLE:\n+                return TABLE.getName();\n+            default:\n+                return \"value\";\n+        }\n+    }\n+\n+    private static Map<String, Map<String, BInvokableSymbol>> getLangLibMethods(Map<String, BPackageSymbol> langLibs) {\n+        Map<String, Map<String, BInvokableSymbol>> langLibMethods = new HashMap<>();\n+\n+        for (Map.Entry<String, BPackageSymbol> entry : langLibs.entrySet()) {\n+            String key = entry.getKey();\n+            BPackageSymbol value = entry.getValue();\n+\n+            Map<String, BInvokableSymbol> methods = new HashMap<>();\n+\n+            for (Map.Entry<Name, Scope.ScopeEntry> nameScopeEntry : value.scope.entries.entrySet()) {\n+                BSymbol symbol = nameScopeEntry.getValue().symbol;\n+\n+                if (symbol.kind != SymbolKind.FUNCTION) {\n+                    continue;\n+                }\n+\n+                BInvokableSymbol invSymbol = (BInvokableSymbol) symbol;\n+\n+                if (Symbols.isFlagOn(invSymbol.flags, Flags.PUBLIC) && !invSymbol.params.isEmpty() &&\n+                        key.compareToIgnoreCase(invSymbol.params.get(0).type.getKind().name()) == 0) {\n+                    methods.put(invSymbol.name.value, invSymbol);\n+                }\n+            }\n+\n+            langLibMethods.put(key, methods);\n+        }\n+\n+        populateLangValueLibrary(langLibs, langLibMethods);\n+        return langLibMethods;\n+    }\n+\n+    private static void populateLangValueLibrary(Map<String, BPackageSymbol> langLibs,\n+                                                 Map<String, Map<String, BInvokableSymbol>> langLibMethods) {\n+        BPackageSymbol langValue = langLibs.get(LANG_VALUE);\n+        Map<String, BInvokableSymbol> methods = new HashMap<>();\n+\n+        for (Map.Entry<Name, Scope.ScopeEntry> nameScopeEntry : langValue.scope.entries.entrySet()) {\n+            BSymbol symbol = nameScopeEntry.getValue().symbol;\n+\n+            if (symbol.kind != SymbolKind.FUNCTION || !Symbols.isFlagOn(symbol.flags, Flags.LANG_LIB)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b27c6b6f05c2d99e8331ed10c57b1f057932edad"}, "originalPosition": 216}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTUyODAwMw==", "bodyText": "Can rename:\nkey -> pkgName\nvalue to pkgSymbol", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26805#discussion_r519528003", "createdAt": "2020-11-09T02:58:22Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-lang/src/main/java/io/ballerina/compiler/api/impl/LangLibrary.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.ballerina.compiler.api.impl;\n+\n+import io.ballerina.compiler.api.symbols.FunctionSymbol;\n+import io.ballerina.compiler.api.symbols.TypeDescKind;\n+import org.ballerinalang.model.elements.PackageID;\n+import org.ballerinalang.model.symbols.SymbolKind;\n+import org.wso2.ballerinalang.compiler.semantics.model.Scope;\n+import org.wso2.ballerinalang.compiler.semantics.model.SymbolEnv;\n+import org.wso2.ballerinalang.compiler.semantics.model.SymbolTable;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BInvokableSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BPackageSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.Symbols;\n+import org.wso2.ballerinalang.compiler.util.CompilerContext;\n+import org.wso2.ballerinalang.compiler.util.Name;\n+import org.wso2.ballerinalang.compiler.util.Names;\n+import org.wso2.ballerinalang.util.Flags;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.ARRAY;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.BOOLEAN;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.DECIMAL;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.ERROR;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.FLOAT;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.FUTURE;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.INT;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.MAP;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.OBJECT;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.STREAM;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.STRING;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.TABLE;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.TYPEDESC;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.XML;\n+\n+\n+/**\n+ * A class to hold the lang library function info required for types.\n+ *\n+ * @since 2.0.0\n+ */\n+public class LangLibrary {\n+\n+    private static final CompilerContext.Key<LangLibrary> LANG_LIB_KEY = new CompilerContext.Key<>();\n+    private static final String LANG_VALUE = \"value\";\n+\n+    private final Map<String, Map<String, BInvokableSymbol>> langLibMethods;\n+    private final Map<String, List<FunctionSymbol>> wrappedLangLibMethods;\n+    private final SymbolFactory symbolFactory;\n+\n+    private LangLibrary(CompilerContext context) {\n+        context.put(LANG_LIB_KEY, this);\n+\n+        symbolFactory = SymbolFactory.getInstance(context);\n+        SymbolTable symbolTable = SymbolTable.getInstance(context);\n+        Map<String, BPackageSymbol> langLibs = new HashMap<>();\n+        wrappedLangLibMethods = new HashMap<>();\n+\n+        for (Map.Entry<BPackageSymbol, SymbolEnv> entry : symbolTable.pkgEnvMap.entrySet()) {\n+            BPackageSymbol module = entry.getKey();\n+            PackageID moduleID = module.pkgID;\n+\n+            if (Names.BALLERINA_ORG.equals(moduleID.orgName) &&\n+                    (moduleID.nameComps.size() == 2 && Names.LANG.equals(moduleID.nameComps.get(0)))) {\n+                langLibs.put(moduleID.nameComps.get(1).value, module);\n+            }\n+        }\n+\n+        langLibMethods = getLangLibMethods(langLibs);\n+    }\n+\n+    public static LangLibrary getInstance(CompilerContext context) {\n+        LangLibrary langLib = context.get(LANG_LIB_KEY);\n+        if (langLib == null) {\n+            langLib = new LangLibrary(context);\n+        }\n+\n+        return langLib;\n+    }\n+\n+    /**\n+     * Given a type descriptor kind, return the list of lang library functions that can be called using a method call\n+     * expr, on an expression of that type.\n+     *\n+     * @param typeDescKind A type descriptor kind\n+     * @return The associated list of lang library functions\n+     */\n+    public List<FunctionSymbol> getMethods(TypeDescKind typeDescKind) {\n+        String langLibName = getAssociatedLangLibName(typeDescKind);\n+\n+        if (wrappedLangLibMethods.containsKey(langLibName)) {\n+            return wrappedLangLibMethods.get(langLibName);\n+        }\n+\n+        Map<String, BInvokableSymbol> methods = langLibMethods.get(langLibName);\n+\n+        List<FunctionSymbol> wrappedMethods = new ArrayList<>();\n+        wrappedLangLibMethods.put(langLibName, wrappedMethods);\n+        populateMethodList(wrappedMethods, methods);\n+\n+        // Add the common functions in lang.value to types which have an associated lang library.\n+        if (!LANG_VALUE.equals(langLibName)) {\n+            populateMethodList(wrappedMethods, langLibMethods.get(LANG_VALUE));\n+        }\n+\n+        return wrappedMethods;\n+    }\n+\n+    // Private Methods\n+\n+    private void populateMethodList(List<FunctionSymbol> list, Map<String, BInvokableSymbol> langLib) {\n+        for (Map.Entry<String, BInvokableSymbol> entry : langLib.entrySet()) {\n+            FunctionSymbol method = symbolFactory.createFunctionSymbol(entry.getValue(), entry.getKey());\n+            list.add(method);\n+        }\n+    }\n+\n+    private String getAssociatedLangLibName(TypeDescKind typeDescKind) {\n+        switch (typeDescKind) {\n+            case INT:\n+            case BYTE:\n+                return INT.getName();\n+            case FLOAT:\n+                return FLOAT.getName();\n+            case DECIMAL:\n+                return DECIMAL.getName();\n+            case STRING:\n+                return STRING.getName();\n+            case BOOLEAN:\n+                return BOOLEAN.getName();\n+            case ARRAY:\n+            case TUPLE:\n+                return ARRAY.getName();\n+            case STREAM:\n+                return STREAM.getName();\n+            case OBJECT:\n+                return OBJECT.getName();\n+            case RECORD:\n+            case MAP:\n+                return MAP.getName();\n+            case ERROR:\n+                return ERROR.getName();\n+            case FUTURE:\n+                return FUTURE.getName();\n+            case TYPEDESC:\n+                return TYPEDESC.getName();\n+            case XML:\n+                return XML.getName();\n+            case TABLE:\n+                return TABLE.getName();\n+            default:\n+                return \"value\";\n+        }\n+    }\n+\n+    private static Map<String, Map<String, BInvokableSymbol>> getLangLibMethods(Map<String, BPackageSymbol> langLibs) {\n+        Map<String, Map<String, BInvokableSymbol>> langLibMethods = new HashMap<>();\n+\n+        for (Map.Entry<String, BPackageSymbol> entry : langLibs.entrySet()) {\n+            String key = entry.getKey();\n+            BPackageSymbol value = entry.getValue();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b27c6b6f05c2d99e8331ed10c57b1f057932edad"}, "originalPosition": 182}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI1ODk3NDI3", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26805#pullrequestreview-525897427", "createdAt": "2020-11-09T03:07:31Z", "commit": {"oid": "b27c6b6f05c2d99e8331ed10c57b1f057932edad"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQwMzowNzozMVrOHvdmIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQwMzoxNjo1OVrOHvduYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTUzMDAxNw==", "bodyText": "will the number of name components be 2 in future as well? What if we check for startsWith(\"lang.\")?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26805#discussion_r519530017", "createdAt": "2020-11-09T03:07:31Z", "author": {"login": "nadeeshaan"}, "path": "compiler/ballerina-lang/src/main/java/io/ballerina/compiler/api/impl/LangLibrary.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.ballerina.compiler.api.impl;\n+\n+import io.ballerina.compiler.api.symbols.FunctionSymbol;\n+import io.ballerina.compiler.api.symbols.TypeDescKind;\n+import org.ballerinalang.model.elements.PackageID;\n+import org.ballerinalang.model.symbols.SymbolKind;\n+import org.wso2.ballerinalang.compiler.semantics.model.Scope;\n+import org.wso2.ballerinalang.compiler.semantics.model.SymbolEnv;\n+import org.wso2.ballerinalang.compiler.semantics.model.SymbolTable;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BInvokableSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BPackageSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.Symbols;\n+import org.wso2.ballerinalang.compiler.util.CompilerContext;\n+import org.wso2.ballerinalang.compiler.util.Name;\n+import org.wso2.ballerinalang.compiler.util.Names;\n+import org.wso2.ballerinalang.util.Flags;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.ARRAY;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.BOOLEAN;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.DECIMAL;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.ERROR;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.FLOAT;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.FUTURE;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.INT;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.MAP;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.OBJECT;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.STREAM;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.STRING;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.TABLE;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.TYPEDESC;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.XML;\n+\n+\n+/**\n+ * A class to hold the lang library function info required for types.\n+ *\n+ * @since 2.0.0\n+ */\n+public class LangLibrary {\n+\n+    private static final CompilerContext.Key<LangLibrary> LANG_LIB_KEY = new CompilerContext.Key<>();\n+    private static final String LANG_VALUE = \"value\";\n+\n+    private final Map<String, Map<String, BInvokableSymbol>> langLibMethods;\n+    private final Map<String, List<FunctionSymbol>> wrappedLangLibMethods;\n+    private final SymbolFactory symbolFactory;\n+\n+    private LangLibrary(CompilerContext context) {\n+        context.put(LANG_LIB_KEY, this);\n+\n+        symbolFactory = SymbolFactory.getInstance(context);\n+        SymbolTable symbolTable = SymbolTable.getInstance(context);\n+        Map<String, BPackageSymbol> langLibs = new HashMap<>();\n+        wrappedLangLibMethods = new HashMap<>();\n+\n+        for (Map.Entry<BPackageSymbol, SymbolEnv> entry : symbolTable.pkgEnvMap.entrySet()) {\n+            BPackageSymbol module = entry.getKey();\n+            PackageID moduleID = module.pkgID;\n+\n+            if (Names.BALLERINA_ORG.equals(moduleID.orgName) &&\n+                    (moduleID.nameComps.size() == 2 && Names.LANG.equals(moduleID.nameComps.get(0)))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b27c6b6f05c2d99e8331ed10c57b1f057932edad"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTUzMjEyOA==", "bodyText": "We can simplify the cases and the returns here. What if get the common cases to the bottom where we can directly call getName() over the typeDescKind", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26805#discussion_r519532128", "createdAt": "2020-11-09T03:16:59Z", "author": {"login": "nadeeshaan"}, "path": "compiler/ballerina-lang/src/main/java/io/ballerina/compiler/api/impl/LangLibrary.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.ballerina.compiler.api.impl;\n+\n+import io.ballerina.compiler.api.symbols.FunctionSymbol;\n+import io.ballerina.compiler.api.symbols.TypeDescKind;\n+import org.ballerinalang.model.elements.PackageID;\n+import org.ballerinalang.model.symbols.SymbolKind;\n+import org.wso2.ballerinalang.compiler.semantics.model.Scope;\n+import org.wso2.ballerinalang.compiler.semantics.model.SymbolEnv;\n+import org.wso2.ballerinalang.compiler.semantics.model.SymbolTable;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BInvokableSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BPackageSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.Symbols;\n+import org.wso2.ballerinalang.compiler.util.CompilerContext;\n+import org.wso2.ballerinalang.compiler.util.Name;\n+import org.wso2.ballerinalang.compiler.util.Names;\n+import org.wso2.ballerinalang.util.Flags;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.ARRAY;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.BOOLEAN;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.DECIMAL;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.ERROR;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.FLOAT;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.FUTURE;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.INT;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.MAP;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.OBJECT;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.STREAM;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.STRING;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.TABLE;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.TYPEDESC;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.XML;\n+\n+\n+/**\n+ * A class to hold the lang library function info required for types.\n+ *\n+ * @since 2.0.0\n+ */\n+public class LangLibrary {\n+\n+    private static final CompilerContext.Key<LangLibrary> LANG_LIB_KEY = new CompilerContext.Key<>();\n+    private static final String LANG_VALUE = \"value\";\n+\n+    private final Map<String, Map<String, BInvokableSymbol>> langLibMethods;\n+    private final Map<String, List<FunctionSymbol>> wrappedLangLibMethods;\n+    private final SymbolFactory symbolFactory;\n+\n+    private LangLibrary(CompilerContext context) {\n+        context.put(LANG_LIB_KEY, this);\n+\n+        symbolFactory = SymbolFactory.getInstance(context);\n+        SymbolTable symbolTable = SymbolTable.getInstance(context);\n+        Map<String, BPackageSymbol> langLibs = new HashMap<>();\n+        wrappedLangLibMethods = new HashMap<>();\n+\n+        for (Map.Entry<BPackageSymbol, SymbolEnv> entry : symbolTable.pkgEnvMap.entrySet()) {\n+            BPackageSymbol module = entry.getKey();\n+            PackageID moduleID = module.pkgID;\n+\n+            if (Names.BALLERINA_ORG.equals(moduleID.orgName) &&\n+                    (moduleID.nameComps.size() == 2 && Names.LANG.equals(moduleID.nameComps.get(0)))) {\n+                langLibs.put(moduleID.nameComps.get(1).value, module);\n+            }\n+        }\n+\n+        langLibMethods = getLangLibMethods(langLibs);\n+    }\n+\n+    public static LangLibrary getInstance(CompilerContext context) {\n+        LangLibrary langLib = context.get(LANG_LIB_KEY);\n+        if (langLib == null) {\n+            langLib = new LangLibrary(context);\n+        }\n+\n+        return langLib;\n+    }\n+\n+    /**\n+     * Given a type descriptor kind, return the list of lang library functions that can be called using a method call\n+     * expr, on an expression of that type.\n+     *\n+     * @param typeDescKind A type descriptor kind\n+     * @return The associated list of lang library functions\n+     */\n+    public List<FunctionSymbol> getMethods(TypeDescKind typeDescKind) {\n+        String langLibName = getAssociatedLangLibName(typeDescKind);\n+\n+        if (wrappedLangLibMethods.containsKey(langLibName)) {\n+            return wrappedLangLibMethods.get(langLibName);\n+        }\n+\n+        Map<String, BInvokableSymbol> methods = langLibMethods.get(langLibName);\n+\n+        List<FunctionSymbol> wrappedMethods = new ArrayList<>();\n+        wrappedLangLibMethods.put(langLibName, wrappedMethods);\n+        populateMethodList(wrappedMethods, methods);\n+\n+        // Add the common functions in lang.value to types which have an associated lang library.\n+        if (!LANG_VALUE.equals(langLibName)) {\n+            populateMethodList(wrappedMethods, langLibMethods.get(LANG_VALUE));\n+        }\n+\n+        return wrappedMethods;\n+    }\n+\n+    // Private Methods\n+\n+    private void populateMethodList(List<FunctionSymbol> list, Map<String, BInvokableSymbol> langLib) {\n+        for (Map.Entry<String, BInvokableSymbol> entry : langLib.entrySet()) {\n+            FunctionSymbol method = symbolFactory.createFunctionSymbol(entry.getValue(), entry.getKey());\n+            list.add(method);\n+        }\n+    }\n+\n+    private String getAssociatedLangLibName(TypeDescKind typeDescKind) {\n+        switch (typeDescKind) {\n+            case INT:\n+            case BYTE:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b27c6b6f05c2d99e8331ed10c57b1f057932edad"}, "originalPosition": 142}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f5b1625eac71c75eb5c06bca83b385d02c24ec51", "author": {"user": {"login": "pubudu91", "name": "Pubudu Fernando"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f5b1625eac71c75eb5c06bca83b385d02c24ec51", "committedDate": "2020-11-09T10:12:04Z", "message": "Add an API for getting the lang lib methods given a type kind"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f91939214db57878bbd13eb90dbe809b255245be", "author": {"user": {"login": "pubudu91", "name": "Pubudu Fernando"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f91939214db57878bbd13eb90dbe809b255245be", "committedDate": "2020-11-09T10:12:08Z", "message": "Rename builtinMethods() -> langLibMethods()"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fe11d2efbeb473930c9fa1a614d9bff2bca10ac7", "author": {"user": {"login": "pubudu91", "name": "Pubudu Fernando"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/fe11d2efbeb473930c9fa1a614d9bff2bca10ac7", "committedDate": "2020-11-09T10:12:09Z", "message": "Implement langLibMethods() API"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "447813f1a18c202bf4519aa53608d9b529bf393b", "author": {"user": {"login": "pubudu91", "name": "Pubudu Fernando"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/447813f1a18c202bf4519aa53608d9b529bf393b", "committedDate": "2020-11-09T10:12:09Z", "message": "Add test cases for lang lib methods"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f56ed05804b9be2fb3bcf07120c419a541417c4c", "author": {"user": {"login": "pubudu91", "name": "Pubudu Fernando"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f56ed05804b9be2fb3bcf07120c419a541417c4c", "committedDate": "2020-11-09T10:12:09Z", "message": "Fix lang server tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a795a9d14349ad87e589f118e6b00569faf1c00a", "author": {"user": {"login": "pubudu91", "name": "Pubudu Fernando"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a795a9d14349ad87e589f118e6b00569faf1c00a", "committedDate": "2020-11-09T10:12:09Z", "message": "Refactor names and lang lib mapping logic"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0de9eb30e702edc7a766bca088ebfea0bc64b013", "author": {"user": {"login": "pubudu91", "name": "Pubudu Fernando"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/0de9eb30e702edc7a766bca088ebfea0bc64b013", "committedDate": "2020-11-09T11:57:17Z", "message": "Improve lang lib function extraction logic"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b27c6b6f05c2d99e8331ed10c57b1f057932edad", "author": {"user": {"login": "pubudu91", "name": "Pubudu Fernando"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b27c6b6f05c2d99e8331ed10c57b1f057932edad", "committedDate": "2020-11-06T19:11:23Z", "message": "Fix lang server tests"}, "afterCommit": {"oid": "0de9eb30e702edc7a766bca088ebfea0bc64b013", "author": {"user": {"login": "pubudu91", "name": "Pubudu Fernando"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/0de9eb30e702edc7a766bca088ebfea0bc64b013", "committedDate": "2020-11-09T11:57:17Z", "message": "Improve lang lib function extraction logic"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI3MDUwNzM5", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26805#pullrequestreview-527050739", "createdAt": "2020-11-10T10:15:42Z", "commit": {"oid": "0de9eb30e702edc7a766bca088ebfea0bc64b013"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4994, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}