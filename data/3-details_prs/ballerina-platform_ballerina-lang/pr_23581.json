{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI0NTY3NzQz", "number": 23581, "title": "Add xml navigate expression parsing", "bodyText": "Purpose\n\nAdd xml navigate expression support\n\nFixes #23542\nApproach\n\nN/A\n\nSamples\n\nN/A\n\nRemarks\n\nN/A\n\nCheck List\n\n Read the Contributing Guide\n Updated Change Log\n Checked Tooling Support (#)\n Added necessary tests\n\n Unit Tests\n Spec Conformance Tests\n Integration Tests\n Ballerina By Example Tests\n\n\n Increased Test Coverage\n Added necessary documentation\n\n API documentation\n Module documentation in Module.md files\n Ballerina By Examples", "createdAt": "2020-05-28T15:33:27Z", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23581", "merged": true, "mergeCommit": {"oid": "ebb5885219aad6212060a19d79d704f5d6be5855"}, "closed": true, "closedAt": "2020-06-03T02:40:46Z", "author": {"login": "lochana-chathura"}, "timelineItems": {"totalCount": 22, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABclph7ngH2gAyNDI0NTY3NzQzOjM0OTIzZGFmNjFlNzlhZDgzOTY5NjU1MjI2ZGE1Y2QzZWMyOTllZjU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcngNUHAFqTQyMzE4MDgwNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "34923daf61e79ad83969655226da5cd3ec299ef5", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/34923daf61e79ad83969655226da5cd3ec299ef5", "committedDate": "2020-05-28T08:24:27Z", "message": "Add xml filter expression parsing"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f45163e9fa568a4130f19f0c2be49ac44d225194", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f45163e9fa568a4130f19f0c2be49ac44d225194", "committedDate": "2020-05-28T08:25:40Z", "message": "Add xml filter syntax validation test cases"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "76dfb9a159cd93547a1dfede80e876bc191d00d4", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/76dfb9a159cd93547a1dfede80e876bc191d00d4", "committedDate": "2020-05-28T13:42:04Z", "message": "Add xml step expression parsing"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3201944e69e4d896b18781435d23def7f6eaf143", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3201944e69e4d896b18781435d23def7f6eaf143", "committedDate": "2020-05-28T13:43:43Z", "message": "Add xml filter syntax validation test cases"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2fafddc846bc83ee150b1b775050d159dab1b671", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2fafddc846bc83ee150b1b775050d159dab1b671", "committedDate": "2020-05-28T15:22:11Z", "message": "Refactor Code"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwNjMwMzA4", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23581#pullrequestreview-420630308", "createdAt": "2020-05-29T03:32:45Z", "commit": {"oid": "2fafddc846bc83ee150b1b775050d159dab1b671"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwMzozMjo0NlrOGcNqqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwMzozNjoyM1rOGcNtiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIzNzIyNg==", "bodyText": "Can we use parseMemberAccessExpr? Because it already handles the contexts as well, and I feel both grammar are the same:\nexpression xml-step-start [expression] is equivalent to both:\n\nexpression [expression] and\nexpression xml-step-start xml-step-extend\n\nSo we can simply return if its not .< and parseExpressionRhs will take care of the rest. wdyt?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23581#discussion_r432237226", "createdAt": "2020-05-29T03:32:46Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -12025,4 +12043,338 @@ private STNode parseByteArrayContent(SyntaxKind kind) {\n \n         return content;\n     }\n+\n+    /**\n+     * Parse xml filter expression.\n+     * <p>\n+     * <code>xml-filter-expr := expression .< xml-name-pattern ></code>\n+     *\n+     * @param lhsExpr Preceding expression of .< token\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLFilterExpression(STNode lhsExpr) {\n+        STNode xmlNamePatternChain = parseXMLFilterExpressionRhs();\n+        return STNodeFactory.createXMLFilterExpressionNode(lhsExpr, xmlNamePatternChain);\n+    }\n+\n+    /**\n+     * Parse xml filter expression rhs.\n+     * <p>\n+     * <code>filer-expression-rhs := .< xml-name-pattern ></code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLFilterExpressionRhs() {\n+        STNode dotLTToken = parseDotLTToken();\n+        return parseXMLNamePatternChain(dotLTToken);\n+    }\n+\n+    /**\n+     * Parse xml name pattern chain.\n+     * <p>\n+     * <code>\n+     * xml-name-pattern-chain := filer-expression-rhs | xml-element-children-step | xml-element-descendants-step\n+     * <br/>\n+     * filer-expression-rhs := .< xml-name-pattern >\n+     * <br/>\n+     * xml-element-children-step := /< xml-name-pattern >\n+     * <br/>\n+     * xml-element-descendants-step := /**\\/<xml-name-pattern >\n+     * </code>\n+     *\n+     * @param startToken Preceding token of xml name pattern\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLNamePatternChain(STNode startToken) {\n+        STNode xmlNamePattern = parseXMLNamePattern();\n+        STNode gtToken = parseGTToken();\n+        return STNodeFactory.createXMLNamePatternChainingNode(startToken, xmlNamePattern, gtToken);\n+    }\n+\n+    /**\n+     * Parse <code> .< </code> token.\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseDotLTToken() {\n+        STToken nextToken = peek();\n+        if (nextToken.kind == SyntaxKind.DOT_LT_TOKEN) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(nextToken, ParserRuleContext.DOT_LT_TOKEN);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse xml name pattern.\n+     * <p>\n+     * <code>xml-name-pattern := xml-atomic-name-pattern [| xml-atomic-name-pattern]*</code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLNamePattern() {\n+        List<STNode> xmlAtomicNamePatternList = new ArrayList<>();\n+        STToken nextToken = peek();\n+\n+        // Return an empty list\n+        if (isEndOfXMLNamePattern(nextToken.kind)) {\n+            this.errorHandler.reportMissingTokenError(\"missing xml atomic name pattern\");\n+            return STNodeFactory.createNodeList(xmlAtomicNamePatternList);\n+        }\n+\n+        // Parse first xml atomic name pattern, that has no leading pipe token\n+        STNode xmlAtomicNamePattern = parseXMLAtomicNamePattern();\n+        xmlAtomicNamePatternList.add(xmlAtomicNamePattern);\n+\n+        // Parse the remaining xml atomic name patterns\n+        nextToken = peek();\n+        STNode leadingPipe;\n+        while (!isEndOfXMLNamePattern(nextToken.kind)) {\n+            leadingPipe = parsePipeToken();\n+            xmlAtomicNamePatternList.add(leadingPipe);\n+            xmlAtomicNamePattern = parseXMLAtomicNamePattern();\n+            xmlAtomicNamePatternList.add(xmlAtomicNamePattern);\n+            nextToken = peek();\n+        }\n+\n+        return STNodeFactory.createNodeList(xmlAtomicNamePatternList);\n+    }\n+\n+    private boolean isEndOfXMLNamePattern(SyntaxKind tokenKind) {\n+        switch (tokenKind) {\n+            case IDENTIFIER_TOKEN:\n+            case ASTERISK_TOKEN:\n+            case COLON_TOKEN:\n+                return false;\n+            case GT_TOKEN:\n+            case EOF_TOKEN:\n+            case AT_TOKEN:\n+            case DOCUMENTATION_LINE:\n+            case CLOSE_BRACE_TOKEN:\n+            case SEMICOLON_TOKEN:\n+            case PUBLIC_KEYWORD:\n+            case PRIVATE_KEYWORD:\n+            case FUNCTION_KEYWORD:\n+            case RETURNS_KEYWORD:\n+            case SERVICE_KEYWORD:\n+            case TYPE_KEYWORD:\n+            case LISTENER_KEYWORD:\n+            case CONST_KEYWORD:\n+            case FINAL_KEYWORD:\n+            case RESOURCE_KEYWORD:\n+                return true;\n+            default:\n+                return isSimpleType(tokenKind);\n+        }\n+    }\n+\n+    /**\n+     * Parse xml atomic name pattern.\n+     * <p>\n+     * <code>\n+     * xml-atomic-name-pattern :=\n+     *   *\n+     *   | identifier\n+     *   | xml-namespace-prefix : identifier\n+     *   | xml-namespace-prefix : *\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLAtomicNamePattern() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.ASTERISK_TOKEN) {\n+            return consume();\n+        } else if (token.kind == SyntaxKind.IDENTIFIER_TOKEN) {\n+            STNode identifier = consume();\n+            return parseXMLAtomicNameIdentifier(identifier);\n+        }\n+        return STNodeFactory.createEmptyNode();\n+    }\n+\n+    private STNode parseXMLAtomicNameIdentifier(STNode identifier) {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.COLON_TOKEN) {\n+            STNode colon = consume();\n+            STToken nextToken = peek();\n+            if (nextToken.kind == SyntaxKind.IDENTIFIER_TOKEN || nextToken.kind == SyntaxKind.ASTERISK_TOKEN) {\n+                STToken endToken = consume();\n+                return STNodeFactory.createXMLAtomicNamePatternNode(identifier, colon, endToken);\n+            }\n+        }\n+        return STNodeFactory.createSimpleNameReferenceNode(identifier);\n+    }\n+\n+    /**\n+     * Parse xml step expression.\n+     * <p>\n+     * <code>xml-step-expr := expression xml-step-start xml-step-extend*</code>\n+     *\n+     * @param lhsExpr Preceding expression of /*, /<, or /**\\/< token\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLStepExpression(STNode lhsExpr) {\n+        STNode xmlStepStart = parseXMLStepStart();\n+        STNode xmlStepExtendList = parseXMLStepExtendList();\n+        return STNodeFactory.createXMLStepExpressionNode(lhsExpr, xmlStepStart, xmlStepExtendList);\n+    }\n+\n+    /**\n+     * Parse xml filter expression rhs.\n+     * <p>\n+     * <code>\n+     *  xml-step-start :=\n+     *      xml-all-children-step\n+     *      | xml-element-children-step\n+     *      | xml-element-descendants-step\n+     * <br/>\n+     * xml-all-children-step := /*\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLStepStart() {\n+        STToken token = peek();\n+        STNode startToken;\n+\n+        switch (token.kind) {\n+            case SLASH_ASTERISK_TOKEN:\n+                return consume();\n+            case DOUBLE_SLASH_DOUBLE_ASTERISK_LT_TOKEN:\n+                startToken = parseDoubleSlashDoubleAsteriskLTToken();\n+                break;\n+            case SLASH_LT_TOKEN:\n+            default:\n+                startToken = parseSlashLTToken();\n+                break;\n+        }\n+        return parseXMLNamePatternChain(startToken);\n+    }\n+\n+    /**\n+     * Parse <code> /< </code> token.\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseSlashLTToken() {\n+        STToken nextToken = peek();\n+        if (nextToken.kind == SyntaxKind.SLASH_LT_TOKEN) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(nextToken, ParserRuleContext.SLASH_LT_TOKEN);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse <code> /< </code> token.\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseDoubleSlashDoubleAsteriskLTToken() {\n+        STToken nextToken = peek();\n+        if (nextToken.kind == SyntaxKind.DOUBLE_SLASH_DOUBLE_ASTERISK_LT_TOKEN) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(nextToken, ParserRuleContext.DOUBLE_SLASH_DOUBLE_ASTERISK_LT_TOKEN);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse xml step extend list.\n+     * <p>\n+     * <code>xml-step-extend-list := xml-step-extend*</code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLStepExtendList() {\n+        List<STNode> xmlStepExtendList = new ArrayList<>();\n+        STToken nextToken = peek();\n+\n+        // Return an empty list\n+        if (isEndOfXMLStepExtend(nextToken.kind)) {\n+            return STNodeFactory.createNodeList(xmlStepExtendList);\n+        }\n+\n+        nextToken = peek();\n+        STNode xmlStepExtend;\n+        while (!isEndOfXMLNamePattern(nextToken.kind)) {\n+            xmlStepExtend = parseXMLStepExtend();\n+            xmlStepExtendList.add(xmlStepExtend);\n+            nextToken = peek();\n+        }\n+\n+        return STNodeFactory.createNodeList(xmlStepExtendList);\n+    }\n+\n+    private boolean isEndOfXMLStepExtend(SyntaxKind tokenKind) {\n+        switch (tokenKind) {\n+            case DOT_LT_TOKEN:\n+            case OPEN_BRACKET_TOKEN:\n+            case DOT_TOKEN:\n+                return false;\n+            default:\n+                return true;\n+        }\n+    }\n+\n+    /**\n+     * Parse xml step extend list.\n+     * <p>\n+     * <code>\n+     * xml-step-extend :=\n+     *    .< xml-name-pattern >\n+     *    | [ expression ]\n+     *    | . method-name ( arg-list )\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLStepExtend() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case DOT_LT_TOKEN:\n+                return parseXMLFilterExpressionRhs();\n+            case DOT_TOKEN:\n+                return parseMethodCallChain();\n+            // token kind is already validated in isEndOfXMLStepExtend and reach here.\n+            // therefore, a recover solution is not required for the default case.\n+            case OPEN_BRACKET_TOKEN:\n+            default:\n+                return parseOpenBracketExpressionChain();\n+\n+        }\n+    }\n+\n+    /**\n+     * Parse open bracket expression chain.\n+     * <p>\n+     * <code>open-bracket-expression-chain := `[` expression `]`</code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseOpenBracketExpressionChain() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2fafddc846bc83ee150b1b775050d159dab1b671"}, "originalPosition": 362}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIzNzk2Mw==", "bodyText": "Probably be able to simply let the parseExpressionRhs handles it, similar to above.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23581#discussion_r432237963", "createdAt": "2020-05-29T03:36:23Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -12025,4 +12043,338 @@ private STNode parseByteArrayContent(SyntaxKind kind) {\n \n         return content;\n     }\n+\n+    /**\n+     * Parse xml filter expression.\n+     * <p>\n+     * <code>xml-filter-expr := expression .< xml-name-pattern ></code>\n+     *\n+     * @param lhsExpr Preceding expression of .< token\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLFilterExpression(STNode lhsExpr) {\n+        STNode xmlNamePatternChain = parseXMLFilterExpressionRhs();\n+        return STNodeFactory.createXMLFilterExpressionNode(lhsExpr, xmlNamePatternChain);\n+    }\n+\n+    /**\n+     * Parse xml filter expression rhs.\n+     * <p>\n+     * <code>filer-expression-rhs := .< xml-name-pattern ></code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLFilterExpressionRhs() {\n+        STNode dotLTToken = parseDotLTToken();\n+        return parseXMLNamePatternChain(dotLTToken);\n+    }\n+\n+    /**\n+     * Parse xml name pattern chain.\n+     * <p>\n+     * <code>\n+     * xml-name-pattern-chain := filer-expression-rhs | xml-element-children-step | xml-element-descendants-step\n+     * <br/>\n+     * filer-expression-rhs := .< xml-name-pattern >\n+     * <br/>\n+     * xml-element-children-step := /< xml-name-pattern >\n+     * <br/>\n+     * xml-element-descendants-step := /**\\/<xml-name-pattern >\n+     * </code>\n+     *\n+     * @param startToken Preceding token of xml name pattern\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLNamePatternChain(STNode startToken) {\n+        STNode xmlNamePattern = parseXMLNamePattern();\n+        STNode gtToken = parseGTToken();\n+        return STNodeFactory.createXMLNamePatternChainingNode(startToken, xmlNamePattern, gtToken);\n+    }\n+\n+    /**\n+     * Parse <code> .< </code> token.\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseDotLTToken() {\n+        STToken nextToken = peek();\n+        if (nextToken.kind == SyntaxKind.DOT_LT_TOKEN) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(nextToken, ParserRuleContext.DOT_LT_TOKEN);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse xml name pattern.\n+     * <p>\n+     * <code>xml-name-pattern := xml-atomic-name-pattern [| xml-atomic-name-pattern]*</code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLNamePattern() {\n+        List<STNode> xmlAtomicNamePatternList = new ArrayList<>();\n+        STToken nextToken = peek();\n+\n+        // Return an empty list\n+        if (isEndOfXMLNamePattern(nextToken.kind)) {\n+            this.errorHandler.reportMissingTokenError(\"missing xml atomic name pattern\");\n+            return STNodeFactory.createNodeList(xmlAtomicNamePatternList);\n+        }\n+\n+        // Parse first xml atomic name pattern, that has no leading pipe token\n+        STNode xmlAtomicNamePattern = parseXMLAtomicNamePattern();\n+        xmlAtomicNamePatternList.add(xmlAtomicNamePattern);\n+\n+        // Parse the remaining xml atomic name patterns\n+        nextToken = peek();\n+        STNode leadingPipe;\n+        while (!isEndOfXMLNamePattern(nextToken.kind)) {\n+            leadingPipe = parsePipeToken();\n+            xmlAtomicNamePatternList.add(leadingPipe);\n+            xmlAtomicNamePattern = parseXMLAtomicNamePattern();\n+            xmlAtomicNamePatternList.add(xmlAtomicNamePattern);\n+            nextToken = peek();\n+        }\n+\n+        return STNodeFactory.createNodeList(xmlAtomicNamePatternList);\n+    }\n+\n+    private boolean isEndOfXMLNamePattern(SyntaxKind tokenKind) {\n+        switch (tokenKind) {\n+            case IDENTIFIER_TOKEN:\n+            case ASTERISK_TOKEN:\n+            case COLON_TOKEN:\n+                return false;\n+            case GT_TOKEN:\n+            case EOF_TOKEN:\n+            case AT_TOKEN:\n+            case DOCUMENTATION_LINE:\n+            case CLOSE_BRACE_TOKEN:\n+            case SEMICOLON_TOKEN:\n+            case PUBLIC_KEYWORD:\n+            case PRIVATE_KEYWORD:\n+            case FUNCTION_KEYWORD:\n+            case RETURNS_KEYWORD:\n+            case SERVICE_KEYWORD:\n+            case TYPE_KEYWORD:\n+            case LISTENER_KEYWORD:\n+            case CONST_KEYWORD:\n+            case FINAL_KEYWORD:\n+            case RESOURCE_KEYWORD:\n+                return true;\n+            default:\n+                return isSimpleType(tokenKind);\n+        }\n+    }\n+\n+    /**\n+     * Parse xml atomic name pattern.\n+     * <p>\n+     * <code>\n+     * xml-atomic-name-pattern :=\n+     *   *\n+     *   | identifier\n+     *   | xml-namespace-prefix : identifier\n+     *   | xml-namespace-prefix : *\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLAtomicNamePattern() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.ASTERISK_TOKEN) {\n+            return consume();\n+        } else if (token.kind == SyntaxKind.IDENTIFIER_TOKEN) {\n+            STNode identifier = consume();\n+            return parseXMLAtomicNameIdentifier(identifier);\n+        }\n+        return STNodeFactory.createEmptyNode();\n+    }\n+\n+    private STNode parseXMLAtomicNameIdentifier(STNode identifier) {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.COLON_TOKEN) {\n+            STNode colon = consume();\n+            STToken nextToken = peek();\n+            if (nextToken.kind == SyntaxKind.IDENTIFIER_TOKEN || nextToken.kind == SyntaxKind.ASTERISK_TOKEN) {\n+                STToken endToken = consume();\n+                return STNodeFactory.createXMLAtomicNamePatternNode(identifier, colon, endToken);\n+            }\n+        }\n+        return STNodeFactory.createSimpleNameReferenceNode(identifier);\n+    }\n+\n+    /**\n+     * Parse xml step expression.\n+     * <p>\n+     * <code>xml-step-expr := expression xml-step-start xml-step-extend*</code>\n+     *\n+     * @param lhsExpr Preceding expression of /*, /<, or /**\\/< token\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLStepExpression(STNode lhsExpr) {\n+        STNode xmlStepStart = parseXMLStepStart();\n+        STNode xmlStepExtendList = parseXMLStepExtendList();\n+        return STNodeFactory.createXMLStepExpressionNode(lhsExpr, xmlStepStart, xmlStepExtendList);\n+    }\n+\n+    /**\n+     * Parse xml filter expression rhs.\n+     * <p>\n+     * <code>\n+     *  xml-step-start :=\n+     *      xml-all-children-step\n+     *      | xml-element-children-step\n+     *      | xml-element-descendants-step\n+     * <br/>\n+     * xml-all-children-step := /*\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLStepStart() {\n+        STToken token = peek();\n+        STNode startToken;\n+\n+        switch (token.kind) {\n+            case SLASH_ASTERISK_TOKEN:\n+                return consume();\n+            case DOUBLE_SLASH_DOUBLE_ASTERISK_LT_TOKEN:\n+                startToken = parseDoubleSlashDoubleAsteriskLTToken();\n+                break;\n+            case SLASH_LT_TOKEN:\n+            default:\n+                startToken = parseSlashLTToken();\n+                break;\n+        }\n+        return parseXMLNamePatternChain(startToken);\n+    }\n+\n+    /**\n+     * Parse <code> /< </code> token.\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseSlashLTToken() {\n+        STToken nextToken = peek();\n+        if (nextToken.kind == SyntaxKind.SLASH_LT_TOKEN) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(nextToken, ParserRuleContext.SLASH_LT_TOKEN);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse <code> /< </code> token.\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseDoubleSlashDoubleAsteriskLTToken() {\n+        STToken nextToken = peek();\n+        if (nextToken.kind == SyntaxKind.DOUBLE_SLASH_DOUBLE_ASTERISK_LT_TOKEN) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(nextToken, ParserRuleContext.DOUBLE_SLASH_DOUBLE_ASTERISK_LT_TOKEN);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse xml step extend list.\n+     * <p>\n+     * <code>xml-step-extend-list := xml-step-extend*</code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLStepExtendList() {\n+        List<STNode> xmlStepExtendList = new ArrayList<>();\n+        STToken nextToken = peek();\n+\n+        // Return an empty list\n+        if (isEndOfXMLStepExtend(nextToken.kind)) {\n+            return STNodeFactory.createNodeList(xmlStepExtendList);\n+        }\n+\n+        nextToken = peek();\n+        STNode xmlStepExtend;\n+        while (!isEndOfXMLNamePattern(nextToken.kind)) {\n+            xmlStepExtend = parseXMLStepExtend();\n+            xmlStepExtendList.add(xmlStepExtend);\n+            nextToken = peek();\n+        }\n+\n+        return STNodeFactory.createNodeList(xmlStepExtendList);\n+    }\n+\n+    private boolean isEndOfXMLStepExtend(SyntaxKind tokenKind) {\n+        switch (tokenKind) {\n+            case DOT_LT_TOKEN:\n+            case OPEN_BRACKET_TOKEN:\n+            case DOT_TOKEN:\n+                return false;\n+            default:\n+                return true;\n+        }\n+    }\n+\n+    /**\n+     * Parse xml step extend list.\n+     * <p>\n+     * <code>\n+     * xml-step-extend :=\n+     *    .< xml-name-pattern >\n+     *    | [ expression ]\n+     *    | . method-name ( arg-list )\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLStepExtend() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case DOT_LT_TOKEN:\n+                return parseXMLFilterExpressionRhs();\n+            case DOT_TOKEN:\n+                return parseMethodCallChain();\n+            // token kind is already validated in isEndOfXMLStepExtend and reach here.\n+            // therefore, a recover solution is not required for the default case.\n+            case OPEN_BRACKET_TOKEN:\n+            default:\n+                return parseOpenBracketExpressionChain();\n+\n+        }\n+    }\n+\n+    /**\n+     * Parse open bracket expression chain.\n+     * <p>\n+     * <code>open-bracket-expression-chain := `[` expression `]`</code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseOpenBracketExpressionChain() {\n+        STNode openBracketToken = parseOpenBracket();\n+        STNode expression = parseExpression();\n+        STNode closeBracketToken = parseCloseBracket();\n+        return STNodeFactory.createOpenBracketExpressionChainingNode(openBracketToken, expression, closeBracketToken);\n+    }\n+\n+    /**\n+     * Parse method call chain.\n+     * <p>\n+     * <code>method-call-chain := `.` method-name `(` arg-list `)`</code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseMethodCallChain() {\n+        STNode dotToken = parseDotToken();\n+        STNode methodName = parseIdentifier(ParserRuleContext.FIELD_OR_FUNC_NAME);\n+        STNode openParen = parseOpenParenthesis(ParserRuleContext.ARG_LIST_START);\n+        STNode args = parseArgsList();\n+        STNode closeParen = parseCloseParenthesis();\n+        return STNodeFactory.createMethodCallChainingNode(dotToken, methodName, openParen, args, closeParen);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2fafddc846bc83ee150b1b775050d159dab1b671"}, "originalPosition": 382}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b66404743dd61d9e3e1f2f255c210ab92a0376ff", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b66404743dd61d9e3e1f2f255c210ab92a0376ff", "committedDate": "2020-05-29T05:45:51Z", "message": "Change xml-step-extend parsing"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwNzYxNzU1", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23581#pullrequestreview-420761755", "createdAt": "2020-05-29T08:41:45Z", "commit": {"oid": "b66404743dd61d9e3e1f2f255c210ab92a0376ff"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwODo0MTo0NVrOGcT_3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwODo0MzoxOVrOGcUDFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM0MDk1Ng==", "bodyText": "I think we don't need parseXMLStepExtendListmethod at all :)\nReason is .<, . and [ are already handled by parseExpressionRhs method. So xml-step-expression node always have only lhsExpr and xmlStepStart", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23581#discussion_r432340956", "createdAt": "2020-05-29T08:41:45Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -12025,4 +12043,307 @@ private STNode parseByteArrayContent(SyntaxKind kind) {\n \n         return content;\n     }\n+\n+    /**\n+     * Parse xml filter expression.\n+     * <p>\n+     * <code>xml-filter-expr := expression .< xml-name-pattern ></code>\n+     *\n+     * @param lhsExpr Preceding expression of .< token\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLFilterExpression(STNode lhsExpr) {\n+        STNode xmlNamePatternChain = parseXMLFilterExpressionRhs();\n+        return STNodeFactory.createXMLFilterExpressionNode(lhsExpr, xmlNamePatternChain);\n+    }\n+\n+    /**\n+     * Parse xml filter expression rhs.\n+     * <p>\n+     * <code>filer-expression-rhs := .< xml-name-pattern ></code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLFilterExpressionRhs() {\n+        STNode dotLTToken = parseDotLTToken();\n+        return parseXMLNamePatternChain(dotLTToken);\n+    }\n+\n+    /**\n+     * Parse xml name pattern chain.\n+     * <p>\n+     * <code>\n+     * xml-name-pattern-chain := filer-expression-rhs | xml-element-children-step | xml-element-descendants-step\n+     * <br/>\n+     * filer-expression-rhs := .< xml-name-pattern >\n+     * <br/>\n+     * xml-element-children-step := /< xml-name-pattern >\n+     * <br/>\n+     * xml-element-descendants-step := /**\\/<xml-name-pattern >\n+     * </code>\n+     *\n+     * @param startToken Preceding token of xml name pattern\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLNamePatternChain(STNode startToken) {\n+        STNode xmlNamePattern = parseXMLNamePattern();\n+        STNode gtToken = parseGTToken();\n+        return STNodeFactory.createXMLNamePatternChainingNode(startToken, xmlNamePattern, gtToken);\n+    }\n+\n+    /**\n+     * Parse <code> .< </code> token.\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseDotLTToken() {\n+        STToken nextToken = peek();\n+        if (nextToken.kind == SyntaxKind.DOT_LT_TOKEN) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(nextToken, ParserRuleContext.DOT_LT_TOKEN);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse xml name pattern.\n+     * <p>\n+     * <code>xml-name-pattern := xml-atomic-name-pattern [| xml-atomic-name-pattern]*</code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLNamePattern() {\n+        List<STNode> xmlAtomicNamePatternList = new ArrayList<>();\n+        STToken nextToken = peek();\n+\n+        // Return an empty list\n+        if (isEndOfXMLNamePattern(nextToken.kind)) {\n+            this.errorHandler.reportMissingTokenError(\"missing xml atomic name pattern\");\n+            return STNodeFactory.createNodeList(xmlAtomicNamePatternList);\n+        }\n+\n+        // Parse first xml atomic name pattern, that has no leading pipe token\n+        STNode xmlAtomicNamePattern = parseXMLAtomicNamePattern();\n+        xmlAtomicNamePatternList.add(xmlAtomicNamePattern);\n+\n+        // Parse the remaining xml atomic name patterns\n+        nextToken = peek();\n+        STNode leadingPipe;\n+        while (!isEndOfXMLNamePattern(nextToken.kind)) {\n+            leadingPipe = parsePipeToken();\n+            xmlAtomicNamePatternList.add(leadingPipe);\n+            xmlAtomicNamePattern = parseXMLAtomicNamePattern();\n+            xmlAtomicNamePatternList.add(xmlAtomicNamePattern);\n+            nextToken = peek();\n+        }\n+\n+        return STNodeFactory.createNodeList(xmlAtomicNamePatternList);\n+    }\n+\n+    private boolean isEndOfXMLNamePattern(SyntaxKind tokenKind) {\n+        switch (tokenKind) {\n+            case IDENTIFIER_TOKEN:\n+            case ASTERISK_TOKEN:\n+            case COLON_TOKEN:\n+                return false;\n+            case GT_TOKEN:\n+            case EOF_TOKEN:\n+            case AT_TOKEN:\n+            case DOCUMENTATION_LINE:\n+            case CLOSE_BRACE_TOKEN:\n+            case SEMICOLON_TOKEN:\n+            case PUBLIC_KEYWORD:\n+            case PRIVATE_KEYWORD:\n+            case FUNCTION_KEYWORD:\n+            case RETURNS_KEYWORD:\n+            case SERVICE_KEYWORD:\n+            case TYPE_KEYWORD:\n+            case LISTENER_KEYWORD:\n+            case CONST_KEYWORD:\n+            case FINAL_KEYWORD:\n+            case RESOURCE_KEYWORD:\n+                return true;\n+            default:\n+                return isSimpleType(tokenKind);\n+        }\n+    }\n+\n+    /**\n+     * Parse xml atomic name pattern.\n+     * <p>\n+     * <code>\n+     * xml-atomic-name-pattern :=\n+     *   *\n+     *   | identifier\n+     *   | xml-namespace-prefix : identifier\n+     *   | xml-namespace-prefix : *\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLAtomicNamePattern() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.ASTERISK_TOKEN) {\n+            return consume();\n+        } else if (token.kind == SyntaxKind.IDENTIFIER_TOKEN) {\n+            STNode identifier = consume();\n+            return parseXMLAtomicNameIdentifier(identifier);\n+        }\n+        return STNodeFactory.createEmptyNode();\n+    }\n+\n+    private STNode parseXMLAtomicNameIdentifier(STNode identifier) {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.COLON_TOKEN) {\n+            STNode colon = consume();\n+            STToken nextToken = peek();\n+            if (nextToken.kind == SyntaxKind.IDENTIFIER_TOKEN || nextToken.kind == SyntaxKind.ASTERISK_TOKEN) {\n+                STToken endToken = consume();\n+                return STNodeFactory.createXMLAtomicNamePatternNode(identifier, colon, endToken);\n+            }\n+        }\n+        return STNodeFactory.createSimpleNameReferenceNode(identifier);\n+    }\n+\n+    /**\n+     * Parse xml step expression.\n+     * <p>\n+     * <code>xml-step-expr := expression xml-step-start xml-step-extend*</code>\n+     *\n+     * @param lhsExpr Preceding expression of /*, /<, or /**\\/< token\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLStepExpression(STNode lhsExpr) {\n+        STNode xmlStepStart = parseXMLStepStart();\n+        STNode xmlStepExtendList = parseXMLStepExtendList();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b66404743dd61d9e3e1f2f255c210ab92a0376ff"}, "originalPosition": 232}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM0MTc4Mw==", "bodyText": "The problem here is, theres a grammar ambiguity.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23581#discussion_r432341783", "createdAt": "2020-05-29T08:43:19Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -12025,4 +12043,307 @@ private STNode parseByteArrayContent(SyntaxKind kind) {\n \n         return content;\n     }\n+\n+    /**\n+     * Parse xml filter expression.\n+     * <p>\n+     * <code>xml-filter-expr := expression .< xml-name-pattern ></code>\n+     *\n+     * @param lhsExpr Preceding expression of .< token\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLFilterExpression(STNode lhsExpr) {\n+        STNode xmlNamePatternChain = parseXMLFilterExpressionRhs();\n+        return STNodeFactory.createXMLFilterExpressionNode(lhsExpr, xmlNamePatternChain);\n+    }\n+\n+    /**\n+     * Parse xml filter expression rhs.\n+     * <p>\n+     * <code>filer-expression-rhs := .< xml-name-pattern ></code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLFilterExpressionRhs() {\n+        STNode dotLTToken = parseDotLTToken();\n+        return parseXMLNamePatternChain(dotLTToken);\n+    }\n+\n+    /**\n+     * Parse xml name pattern chain.\n+     * <p>\n+     * <code>\n+     * xml-name-pattern-chain := filer-expression-rhs | xml-element-children-step | xml-element-descendants-step\n+     * <br/>\n+     * filer-expression-rhs := .< xml-name-pattern >\n+     * <br/>\n+     * xml-element-children-step := /< xml-name-pattern >\n+     * <br/>\n+     * xml-element-descendants-step := /**\\/<xml-name-pattern >\n+     * </code>\n+     *\n+     * @param startToken Preceding token of xml name pattern\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLNamePatternChain(STNode startToken) {\n+        STNode xmlNamePattern = parseXMLNamePattern();\n+        STNode gtToken = parseGTToken();\n+        return STNodeFactory.createXMLNamePatternChainingNode(startToken, xmlNamePattern, gtToken);\n+    }\n+\n+    /**\n+     * Parse <code> .< </code> token.\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseDotLTToken() {\n+        STToken nextToken = peek();\n+        if (nextToken.kind == SyntaxKind.DOT_LT_TOKEN) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(nextToken, ParserRuleContext.DOT_LT_TOKEN);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse xml name pattern.\n+     * <p>\n+     * <code>xml-name-pattern := xml-atomic-name-pattern [| xml-atomic-name-pattern]*</code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLNamePattern() {\n+        List<STNode> xmlAtomicNamePatternList = new ArrayList<>();\n+        STToken nextToken = peek();\n+\n+        // Return an empty list\n+        if (isEndOfXMLNamePattern(nextToken.kind)) {\n+            this.errorHandler.reportMissingTokenError(\"missing xml atomic name pattern\");\n+            return STNodeFactory.createNodeList(xmlAtomicNamePatternList);\n+        }\n+\n+        // Parse first xml atomic name pattern, that has no leading pipe token\n+        STNode xmlAtomicNamePattern = parseXMLAtomicNamePattern();\n+        xmlAtomicNamePatternList.add(xmlAtomicNamePattern);\n+\n+        // Parse the remaining xml atomic name patterns\n+        nextToken = peek();\n+        STNode leadingPipe;\n+        while (!isEndOfXMLNamePattern(nextToken.kind)) {\n+            leadingPipe = parsePipeToken();\n+            xmlAtomicNamePatternList.add(leadingPipe);\n+            xmlAtomicNamePattern = parseXMLAtomicNamePattern();\n+            xmlAtomicNamePatternList.add(xmlAtomicNamePattern);\n+            nextToken = peek();\n+        }\n+\n+        return STNodeFactory.createNodeList(xmlAtomicNamePatternList);\n+    }\n+\n+    private boolean isEndOfXMLNamePattern(SyntaxKind tokenKind) {\n+        switch (tokenKind) {\n+            case IDENTIFIER_TOKEN:\n+            case ASTERISK_TOKEN:\n+            case COLON_TOKEN:\n+                return false;\n+            case GT_TOKEN:\n+            case EOF_TOKEN:\n+            case AT_TOKEN:\n+            case DOCUMENTATION_LINE:\n+            case CLOSE_BRACE_TOKEN:\n+            case SEMICOLON_TOKEN:\n+            case PUBLIC_KEYWORD:\n+            case PRIVATE_KEYWORD:\n+            case FUNCTION_KEYWORD:\n+            case RETURNS_KEYWORD:\n+            case SERVICE_KEYWORD:\n+            case TYPE_KEYWORD:\n+            case LISTENER_KEYWORD:\n+            case CONST_KEYWORD:\n+            case FINAL_KEYWORD:\n+            case RESOURCE_KEYWORD:\n+                return true;\n+            default:\n+                return isSimpleType(tokenKind);\n+        }\n+    }\n+\n+    /**\n+     * Parse xml atomic name pattern.\n+     * <p>\n+     * <code>\n+     * xml-atomic-name-pattern :=\n+     *   *\n+     *   | identifier\n+     *   | xml-namespace-prefix : identifier\n+     *   | xml-namespace-prefix : *\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLAtomicNamePattern() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.ASTERISK_TOKEN) {\n+            return consume();\n+        } else if (token.kind == SyntaxKind.IDENTIFIER_TOKEN) {\n+            STNode identifier = consume();\n+            return parseXMLAtomicNameIdentifier(identifier);\n+        }\n+        return STNodeFactory.createEmptyNode();\n+    }\n+\n+    private STNode parseXMLAtomicNameIdentifier(STNode identifier) {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.COLON_TOKEN) {\n+            STNode colon = consume();\n+            STToken nextToken = peek();\n+            if (nextToken.kind == SyntaxKind.IDENTIFIER_TOKEN || nextToken.kind == SyntaxKind.ASTERISK_TOKEN) {\n+                STToken endToken = consume();\n+                return STNodeFactory.createXMLAtomicNamePatternNode(identifier, colon, endToken);\n+            }\n+        }\n+        return STNodeFactory.createSimpleNameReferenceNode(identifier);\n+    }\n+\n+    /**\n+     * Parse xml step expression.\n+     * <p>\n+     * <code>xml-step-expr := expression xml-step-start xml-step-extend*</code>\n+     *\n+     * @param lhsExpr Preceding expression of /*, /<, or /**\\/< token\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLStepExpression(STNode lhsExpr) {\n+        STNode xmlStepStart = parseXMLStepStart();\n+        STNode xmlStepExtendList = parseXMLStepExtendList();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM0MDk1Ng=="}, "originalCommit": {"oid": "b66404743dd61d9e3e1f2f255c210ab92a0376ff"}, "originalPosition": 232}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1ec64e2beac6dadb41a248734614d397ca4c8384", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1ec64e2beac6dadb41a248734614d397ca4c8384", "committedDate": "2020-06-01T05:49:26Z", "message": "Change xml-step-expr pasring"}, "afterCommit": {"oid": "9c01f069e108ef6ae158daaed3cbfb385371606b", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/9c01f069e108ef6ae158daaed3cbfb385371606b", "committedDate": "2020-06-01T05:52:30Z", "message": "Change xml-step-expr parsing"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxNjE0MDE1", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23581#pullrequestreview-421614015", "createdAt": "2020-06-01T06:12:38Z", "commit": {"oid": "9c01f069e108ef6ae158daaed3cbfb385371606b"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQwNjoxMjozOFrOGc_zCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQwNjoxMjozOFrOGc_zCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzA1ODU3MA==", "bodyText": "Can lhsExpr be null?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23581#discussion_r433058570", "createdAt": "2020-06-01T06:12:38Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -4516,7 +4522,7 @@ private STNode parseExpressionRhs(SyntaxKind tokenKind, OperatorPrecedence curre\n             return lhsExpr;\n         }\n \n-        if (lhsExpr.kind == SyntaxKind.ASYNC_SEND_ACTION) {\n+        if (lhsExpr != null && lhsExpr.kind == SyntaxKind.ASYNC_SEND_ACTION) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c01f069e108ef6ae158daaed3cbfb385371606b"}, "originalPosition": 25}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3281d8cf188fc5e65108ede699bc6b36232a3b54", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3281d8cf188fc5e65108ede699bc6b36232a3b54", "committedDate": "2020-06-01T06:50:32Z", "message": "Change xml-step-expr parsing"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9c01f069e108ef6ae158daaed3cbfb385371606b", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/9c01f069e108ef6ae158daaed3cbfb385371606b", "committedDate": "2020-06-01T05:52:30Z", "message": "Change xml-step-expr parsing"}, "afterCommit": {"oid": "3281d8cf188fc5e65108ede699bc6b36232a3b54", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3281d8cf188fc5e65108ede699bc6b36232a3b54", "committedDate": "2020-06-01T06:50:32Z", "message": "Change xml-step-expr parsing"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8fb1a0c4b318d2388892ca5ed96af4a35bc96474", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/8fb1a0c4b318d2388892ca5ed96af4a35bc96474", "committedDate": "2020-06-02T06:14:53Z", "message": "Add error recovery"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2102ea80b5eb3d2ceb5fe0594a49cce1dfde5461", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2102ea80b5eb3d2ceb5fe0594a49cce1dfde5461", "committedDate": "2020-06-02T04:23:15Z", "message": "Add error recovery"}, "afterCommit": {"oid": "8fb1a0c4b318d2388892ca5ed96af4a35bc96474", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/8fb1a0c4b318d2388892ca5ed96af4a35bc96474", "committedDate": "2020-06-02T06:14:53Z", "message": "Add error recovery"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4a6ab66456ae38753ab25fe5947a023751ff5bde", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/4a6ab66456ae38753ab25fe5947a023751ff5bde", "committedDate": "2020-06-02T10:39:28Z", "message": "Fix error recovery"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d5b47727e19fd0c37b819d8cbe6d366f1a08f474", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/d5b47727e19fd0c37b819d8cbe6d366f1a08f474", "committedDate": "2020-06-02T11:00:31Z", "message": "Add recovery test cases"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5821c25336abac2b2495b0864a0eb7140f1141c7", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/5821c25336abac2b2495b0864a0eb7140f1141c7", "committedDate": "2020-06-02T11:35:15Z", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into xml-navigate-support\n\n\u0001 Conflicts:\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/diagnostics/DiagnosticErrorCode.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/AbstractParserErrorHandler.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a983b5be508678cce324d851ce9d38d07b64e9b2", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a983b5be508678cce324d851ce9d38d07b64e9b2", "committedDate": "2020-06-02T11:52:34Z", "message": "Fix merging issue"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a7777e528ff4a4e146a5a2c7e808fc68bc9971c9", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a7777e528ff4a4e146a5a2c7e808fc68bc9971c9", "committedDate": "2020-06-02T12:21:15Z", "message": "Remove OPEN_BRACKET_EXPRESSION_CHAIN, METHOD_CALL_CHAIN syntax kinds"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyNjQxNTkz", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23581#pullrequestreview-422641593", "createdAt": "2020-06-02T12:50:33Z", "commit": {"oid": "a7777e528ff4a4e146a5a2c7e808fc68bc9971c9"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMjo1MDozM1rOGdwE3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMzowMDo1NlrOGdwd-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg0OTU2NQ==", "bodyText": "Better to move starting and ending contexts inside the parseXMLAtomicNamePattern", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23581#discussion_r433849565", "createdAt": "2020-06-02T12:50:33Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -11100,6 +11124,266 @@ private STNode parseByteArrayContent(SyntaxKind kind) {\n         return content;\n     }\n \n+    /**\n+     * Parse xml filter expression.\n+     * <p>\n+     * <code>xml-filter-expr := expression .< xml-name-pattern ></code>\n+     *\n+     * @param lhsExpr Preceding expression of .< token\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLFilterExpression(STNode lhsExpr) {\n+        STNode xmlNamePatternChain = parseXMLFilterExpressionRhs();\n+        return STNodeFactory.createXMLFilterExpressionNode(lhsExpr, xmlNamePatternChain);\n+    }\n+\n+    /**\n+     * Parse xml filter expression rhs.\n+     * <p>\n+     * <code>filer-expression-rhs := .< xml-name-pattern ></code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLFilterExpressionRhs() {\n+        STNode dotLTToken = parseDotLTToken();\n+        return parseXMLNamePatternChain(dotLTToken);\n+    }\n+\n+    /**\n+     * Parse xml name pattern chain.\n+     * <p>\n+     * <code>\n+     * xml-name-pattern-chain := filer-expression-rhs | xml-element-children-step | xml-element-descendants-step\n+     * <br/>\n+     * filer-expression-rhs := .< xml-name-pattern >\n+     * <br/>\n+     * xml-element-children-step := /< xml-name-pattern >\n+     * <br/>\n+     * xml-element-descendants-step := /**\\/<xml-name-pattern >\n+     * </code>\n+     *\n+     * @param startToken Preceding token of xml name pattern\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLNamePatternChain(STNode startToken) {\n+        startContext(ParserRuleContext.XML_NAME_PATTERN);\n+        STNode xmlNamePattern = parseXMLNamePattern();\n+        STNode gtToken = parseGTToken();\n+        endContext();\n+        return STNodeFactory.createXMLNamePatternChainingNode(startToken, xmlNamePattern, gtToken);\n+    }\n+\n+    /**\n+     * Parse <code> .< </code> token.\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseDotLTToken() {\n+        STToken nextToken = peek();\n+        if (nextToken.kind == SyntaxKind.DOT_LT_TOKEN) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(nextToken, ParserRuleContext.DOT_LT_TOKEN);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse xml name pattern.\n+     * <p>\n+     * <code>xml-name-pattern := xml-atomic-name-pattern [| xml-atomic-name-pattern]*</code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLNamePattern() {\n+        List<STNode> xmlAtomicNamePatternList = new ArrayList<>();\n+        STToken nextToken = peek();\n+\n+        // Return an empty list\n+        if (isEndOfXMLNamePattern(nextToken.kind)) {\n+            this.errorHandler.reportMissingTokenError(\"missing xml atomic name pattern\");\n+            return STNodeFactory.createNodeList(xmlAtomicNamePatternList);\n+        }\n+\n+        // Parse first xml atomic name pattern, that has no leading pipe token\n+        startContext(ParserRuleContext.XML_ATOMIC_NAME_PATTERN);\n+        STNode xmlAtomicNamePattern = parseXMLAtomicNamePattern();\n+        endContext();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7777e528ff4a4e146a5a2c7e808fc68bc9971c9"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg1MTgzMA==", "bodyText": "Since the nextToken is used only at this place, can simply use peek() here itself. No need of a local variable..", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23581#discussion_r433851830", "createdAt": "2020-06-02T12:54:15Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -11100,6 +11124,266 @@ private STNode parseByteArrayContent(SyntaxKind kind) {\n         return content;\n     }\n \n+    /**\n+     * Parse xml filter expression.\n+     * <p>\n+     * <code>xml-filter-expr := expression .< xml-name-pattern ></code>\n+     *\n+     * @param lhsExpr Preceding expression of .< token\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLFilterExpression(STNode lhsExpr) {\n+        STNode xmlNamePatternChain = parseXMLFilterExpressionRhs();\n+        return STNodeFactory.createXMLFilterExpressionNode(lhsExpr, xmlNamePatternChain);\n+    }\n+\n+    /**\n+     * Parse xml filter expression rhs.\n+     * <p>\n+     * <code>filer-expression-rhs := .< xml-name-pattern ></code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLFilterExpressionRhs() {\n+        STNode dotLTToken = parseDotLTToken();\n+        return parseXMLNamePatternChain(dotLTToken);\n+    }\n+\n+    /**\n+     * Parse xml name pattern chain.\n+     * <p>\n+     * <code>\n+     * xml-name-pattern-chain := filer-expression-rhs | xml-element-children-step | xml-element-descendants-step\n+     * <br/>\n+     * filer-expression-rhs := .< xml-name-pattern >\n+     * <br/>\n+     * xml-element-children-step := /< xml-name-pattern >\n+     * <br/>\n+     * xml-element-descendants-step := /**\\/<xml-name-pattern >\n+     * </code>\n+     *\n+     * @param startToken Preceding token of xml name pattern\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLNamePatternChain(STNode startToken) {\n+        startContext(ParserRuleContext.XML_NAME_PATTERN);\n+        STNode xmlNamePattern = parseXMLNamePattern();\n+        STNode gtToken = parseGTToken();\n+        endContext();\n+        return STNodeFactory.createXMLNamePatternChainingNode(startToken, xmlNamePattern, gtToken);\n+    }\n+\n+    /**\n+     * Parse <code> .< </code> token.\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseDotLTToken() {\n+        STToken nextToken = peek();\n+        if (nextToken.kind == SyntaxKind.DOT_LT_TOKEN) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(nextToken, ParserRuleContext.DOT_LT_TOKEN);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse xml name pattern.\n+     * <p>\n+     * <code>xml-name-pattern := xml-atomic-name-pattern [| xml-atomic-name-pattern]*</code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLNamePattern() {\n+        List<STNode> xmlAtomicNamePatternList = new ArrayList<>();\n+        STToken nextToken = peek();\n+\n+        // Return an empty list\n+        if (isEndOfXMLNamePattern(nextToken.kind)) {\n+            this.errorHandler.reportMissingTokenError(\"missing xml atomic name pattern\");\n+            return STNodeFactory.createNodeList(xmlAtomicNamePatternList);\n+        }\n+\n+        // Parse first xml atomic name pattern, that has no leading pipe token\n+        startContext(ParserRuleContext.XML_ATOMIC_NAME_PATTERN);\n+        STNode xmlAtomicNamePattern = parseXMLAtomicNamePattern();\n+        endContext();\n+        xmlAtomicNamePatternList.add(xmlAtomicNamePattern);\n+\n+        // Parse the remaining xml atomic name patterns\n+        nextToken = peek();\n+        STNode leadingPipe;\n+        while (!isEndOfXMLNamePattern(nextToken.kind)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7777e528ff4a4e146a5a2c7e808fc68bc9971c9"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg1NDM4MQ==", "bodyText": "since getParentContext() is called more than once, better to move it to a local variable.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23581#discussion_r433854381", "createdAt": "2020-06-02T12:58:23Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -2246,6 +2324,8 @@ private ParserRuleContext getNextRuleInternal(ParserRuleContext currentCtx, int\n             case PIPE:\n                 if (getParentContext() == ParserRuleContext.ALTERNATE_WAIT_EXPRS) {\n                     return ParserRuleContext.EXPRESSION;\n+                } else if (getParentContext() == ParserRuleContext.XML_NAME_PATTERN) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7777e528ff4a4e146a5a2c7e808fc68bc9971c9"}, "originalPosition": 248}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg1NTgzOQ==", "bodyText": "how about simply prefix?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23581#discussion_r433855839", "createdAt": "2020-06-02T13:00:42Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-treegen/src/main/resources/syntax_tree_descriptor.json", "diffHunk": "@@ -3450,6 +3450,80 @@\n                     \"type\": \"Token\"\n                 }\n             ]\n+        },\n+        {\n+            \"name\": \"XMLNavigateExpressionNode\",\n+            \"base\": \"ExpressionNode\",\n+            \"isAbstract\": true\n+        },\n+        {\n+            \"name\": \"XMLFilterExpressionNode\",\n+            \"base\": \"XMLNavigateExpressionNode\",\n+            \"kind\": \"XML_FILTER_EXPRESSION\",\n+            \"attributes\": [\n+                {\n+                    \"name\": \"expression\",\n+                    \"type\": \"ExpressionNode\"\n+                },\n+                {\n+                    \"name\": \"xmlPatternChain\",\n+                    \"type\": \"XMLNamePatternChainingNode\"\n+                }\n+            ]\n+        },\n+        {\n+            \"name\": \"XMLStepExpressionNode\",\n+            \"base\": \"XMLNavigateExpressionNode\",\n+            \"kind\": \"XML_STEP_EXPRESSION\",\n+            \"attributes\": [\n+                {\n+                    \"name\": \"expression\",\n+                    \"type\": \"ExpressionNode\"\n+                },\n+                {\n+                    \"name\": \"xmlStepStart\",\n+                    \"type\": \"Node\"\n+                }\n+            ]\n+        },\n+        {\n+            \"name\": \"XMLNamePatternChainingNode\",\n+            \"base\": \"Node\",\n+            \"kind\": \"XML_NAME_PATTERN_CHAIN\",\n+            \"attributes\": [\n+                {\n+                    \"name\": \"startToken\",\n+                    \"type\": \"Token\"\n+                },\n+                {\n+                    \"name\": \"xmlNamePattern\",\n+                    \"type\": \"Node\",\n+                    \"occurrences\": \"MULTIPLE_SEPARATED\"\n+                },\n+                {\n+                    \"name\": \"gtToken\",\n+                    \"type\": \"Token\"\n+                }\n+            ]\n+        },\n+        {\n+            \"name\": \"XMLAtomicNamePatternNode\",\n+            \"base\": \"Node\",\n+            \"kind\": \"XML_ATOMIC_NAME_PATTERN\",\n+            \"attributes\": [\n+                {\n+                    \"name\": \"xmlNamespacePrefix\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7777e528ff4a4e146a5a2c7e808fc68bc9971c9"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg1NTk5Mw==", "bodyText": "can we say name?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23581#discussion_r433855993", "createdAt": "2020-06-02T13:00:56Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-treegen/src/main/resources/syntax_tree_descriptor.json", "diffHunk": "@@ -3450,6 +3450,80 @@\n                     \"type\": \"Token\"\n                 }\n             ]\n+        },\n+        {\n+            \"name\": \"XMLNavigateExpressionNode\",\n+            \"base\": \"ExpressionNode\",\n+            \"isAbstract\": true\n+        },\n+        {\n+            \"name\": \"XMLFilterExpressionNode\",\n+            \"base\": \"XMLNavigateExpressionNode\",\n+            \"kind\": \"XML_FILTER_EXPRESSION\",\n+            \"attributes\": [\n+                {\n+                    \"name\": \"expression\",\n+                    \"type\": \"ExpressionNode\"\n+                },\n+                {\n+                    \"name\": \"xmlPatternChain\",\n+                    \"type\": \"XMLNamePatternChainingNode\"\n+                }\n+            ]\n+        },\n+        {\n+            \"name\": \"XMLStepExpressionNode\",\n+            \"base\": \"XMLNavigateExpressionNode\",\n+            \"kind\": \"XML_STEP_EXPRESSION\",\n+            \"attributes\": [\n+                {\n+                    \"name\": \"expression\",\n+                    \"type\": \"ExpressionNode\"\n+                },\n+                {\n+                    \"name\": \"xmlStepStart\",\n+                    \"type\": \"Node\"\n+                }\n+            ]\n+        },\n+        {\n+            \"name\": \"XMLNamePatternChainingNode\",\n+            \"base\": \"Node\",\n+            \"kind\": \"XML_NAME_PATTERN_CHAIN\",\n+            \"attributes\": [\n+                {\n+                    \"name\": \"startToken\",\n+                    \"type\": \"Token\"\n+                },\n+                {\n+                    \"name\": \"xmlNamePattern\",\n+                    \"type\": \"Node\",\n+                    \"occurrences\": \"MULTIPLE_SEPARATED\"\n+                },\n+                {\n+                    \"name\": \"gtToken\",\n+                    \"type\": \"Token\"\n+                }\n+            ]\n+        },\n+        {\n+            \"name\": \"XMLAtomicNamePatternNode\",\n+            \"base\": \"Node\",\n+            \"kind\": \"XML_ATOMIC_NAME_PATTERN\",\n+            \"attributes\": [\n+                {\n+                    \"name\": \"xmlNamespacePrefix\",\n+                    \"type\": \"Token\"\n+                },\n+                {\n+                    \"name\": \"colon\",\n+                    \"type\": \"Token\"\n+                },\n+                {\n+                    \"name\": \"endToken\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7777e528ff4a4e146a5a2c7e808fc68bc9971c9"}, "originalPosition": 74}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b84f28db9832dc3ea85f95638d7cf25cb1120875", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b84f28db9832dc3ea85f95638d7cf25cb1120875", "committedDate": "2020-06-02T14:57:31Z", "message": "Refactor code"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzMTgwODA2", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23581#pullrequestreview-423180806", "createdAt": "2020-06-03T02:40:38Z", "commit": {"oid": "b84f28db9832dc3ea85f95638d7cf25cb1120875"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4465, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}