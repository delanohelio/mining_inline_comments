{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU4NjQwNjE3", "number": 25023, "title": "Port mocking feature to 1.2.x branch", "bodyText": "Purpose\nTo port the Function mocking feature from Master to 1.2.x branch\nFixes #24389\nApproach\n\nDescribe how you are implementing the solutions along with the design details.\n\nSamples\n\nProvide high-level details about the samples related to this feature.\n\nRemarks\n\nList any other known issues, related PRs, TODO items, or any other notes related to the PR.\n\nCheck List\n\n Read the Contributing Guide\n Updated Change Log\n Checked Tooling Support (#)\n Added necessary tests\n\n Unit Tests\n Spec Conformance Tests\n Integration Tests\n Ballerina By Example Tests\n\n\n Increased Test Coverage\n Added necessary documentation\n\n API documentation\n Module documentation in Module.md files\n Ballerina By Examples", "createdAt": "2020-07-29T19:31:08Z", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25023", "merged": true, "mergeCommit": {"oid": "21247cd736998b3118cd2ccbc6f149364adbf585"}, "closed": true, "closedAt": "2020-08-11T05:38:29Z", "author": {"login": "Ibaqu"}, "timelineItems": {"totalCount": 23, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc53rsQAFqTQ1ODA1ODQ3OQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABc9a_ueAFqTQ2Mzk1ODU2MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU4MDU4NDc5", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25023#pullrequestreview-458058479", "createdAt": "2020-07-30T04:12:16Z", "commit": {"oid": "a9e115b9f8140852d7ed77a994c178d451ef21c6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwNDoxMjoxNlrOG5SZxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwNDoxMjoxNlrOG5SZxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjcyMzUyNQ==", "bodyText": "We can remove this commented lines.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25023#discussion_r462723525", "createdAt": "2020-07-30T04:12:16Z", "author": {"login": "azinneera"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/MockDesugar.java", "diffHunk": "@@ -0,0 +1,459 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.wso2.ballerinalang.compiler.desugar;\n+\n+\n+import org.ballerinalang.model.TreeBuilder;\n+import org.ballerinalang.model.tree.IdentifierNode;\n+import org.wso2.ballerinalang.compiler.semantics.analyzer.SymbolResolver;\n+import org.wso2.ballerinalang.compiler.semantics.model.SymbolTable;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BInvokableSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BVarSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BInvokableType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BType;\n+import org.wso2.ballerinalang.compiler.tree.BLangFunction;\n+import org.wso2.ballerinalang.compiler.tree.BLangFunctionBody;\n+import org.wso2.ballerinalang.compiler.tree.BLangIdentifier;\n+import org.wso2.ballerinalang.compiler.tree.BLangImportPackage;\n+import org.wso2.ballerinalang.compiler.tree.BLangPackage;\n+import org.wso2.ballerinalang.compiler.tree.BLangSimpleVariable;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangExpression;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangFieldBasedAccess;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangInvocation;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangListConstructorExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangLiteral;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangSimpleVarRef;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangTypeConversionExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangVariableReference;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangAssignment;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangReturn;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangStatement;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangType;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangValueType;\n+import org.wso2.ballerinalang.compiler.util.CompilerContext;\n+import org.wso2.ballerinalang.compiler.util.FieldKind;\n+import org.wso2.ballerinalang.compiler.util.Name;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Class to generate Mock Functions.\n+ *\n+ * @since 2.0.0\n+ */\n+public class MockDesugar {\n+\n+    private static final CompilerContext.Key<MockDesugar> MOCK_DESUGAR_KEY = new CompilerContext.Key<>();\n+    private static final String MOCK_ANNOTATION_DELIMITER = \"#\";\n+    private final SymbolTable symTable;\n+    private final SymbolResolver symResolver;\n+    private BLangPackage bLangPackage;\n+    private BLangFunction originalFunction;\n+    private BInvokableSymbol importFunction;\n+    private String mockFnObjectName;\n+\n+    private MockDesugar(CompilerContext context) {\n+        context.put(MOCK_DESUGAR_KEY, this);\n+        this.symTable = SymbolTable.getInstance(context);\n+        this.symResolver = SymbolResolver.getInstance(context);\n+    }\n+\n+    public static MockDesugar getInstance(CompilerContext context) {\n+        MockDesugar desugar = context.get(MOCK_DESUGAR_KEY);\n+        if (desugar == null) {\n+            desugar = new MockDesugar(context);\n+        }\n+        return desugar;\n+    }\n+\n+    private static IdentifierNode createIdentifier(String value) {\n+        IdentifierNode node = TreeBuilder.createIdentifierNode();\n+        if (value != null) {\n+            node.setValue(value);\n+        }\n+        return node;\n+    }\n+\n+    public void generateMockFunctions(BLangPackage pkgNode) {\n+        // Set the BLangPackage\n+        this.bLangPackage = pkgNode;\n+\n+        // Get the Mock Function map from the pkgNode\n+        Map<String, String> mockFunctionMap = pkgNode.getTestablePkg().getMockFunctionNamesMap();\n+\n+        // Get the set of functions to generate\n+        Set<String> mockFunctionSet = mockFunctionMap.keySet();\n+\n+        for (String function : mockFunctionSet) {\n+            if (!function.contains(\"~\")) {\n+                pkgNode.getTestablePkg().functions.add(generateMockFunction(function));\n+            }\n+        }\n+    }\n+\n+    private BLangFunction generateMockFunction(String functionName) {\n+        // Set the current mock object\n+        this.mockFnObjectName = this.bLangPackage.getTestablePkg().getMockFunctionNamesMap().get(functionName);\n+\n+        // Reset both import and original functions\n+        this.importFunction = null;\n+        this.originalFunction = null;\n+\n+        // Function name is going to be 'ballerina/math:1.0.0 # absInt'\n+        String currentPackageId = this.bLangPackage.packageID.toString();\n+\n+\n+        // We need to identify if the function is part of the current package or imported package\n+        if (functionName.contains(currentPackageId)) {\n+            // Simply extract the name only and set it to function name\n+            functionName = functionName.substring(functionName.indexOf(MOCK_ANNOTATION_DELIMITER) + 1);\n+            this.originalFunction = getOriginalFunction(functionName);\n+        } else {\n+            // Extract the name and the package details\n+            String packageName = functionName.contains(\":\") ?\n+                    functionName.substring(functionName.indexOf('/') + 1, functionName.indexOf(':')) :\n+                    functionName.substring(functionName.indexOf('/') + 1,\n+                                           functionName.indexOf(MOCK_ANNOTATION_DELIMITER));\n+            functionName = functionName.substring(functionName.indexOf(MOCK_ANNOTATION_DELIMITER) + 1);\n+            this.importFunction = getImportFunction(functionName, packageName);\n+        }\n+\n+        // Set the function name to $MOCK_<functionName>\n+        functionName = \"$MOCK_\" + functionName;\n+\n+        // Create the Base function with the name\n+        BLangFunction generatedMock = ASTBuilderUtil.createFunction(bLangPackage.pos, functionName);\n+\n+        if (this.originalFunction != null || this.importFunction != null) {\n+            generatedMock.requiredParams = generateRequiredParams();        // Required Params\n+            generatedMock.restParam = generateRestParam();                  // Rest Param\n+            generatedMock.returnTypeNode = generateReturnTypeNode();        // Return Type Node\n+            generatedMock.body = generateBody();                            // Body\n+            generatedMock.type = generateSymbolInvokableType();             // Invokable Type\n+            generatedMock.symbol = generateSymbol(functionName);            // Invokable Symbol\n+        } else {\n+            throw new IllegalStateException(\"Mock Function and Function to Mock cannot be null\");\n+        }\n+\n+        return generatedMock;\n+    }\n+\n+    private BLangFunction getOriginalFunction(String functionName) {\n+        List<BLangFunction> functionList = bLangPackage.getFunctions();\n+        for (BLangFunction function : functionList) {\n+            if (function.getName().toString().equals(functionName)) {\n+                return function;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private BInvokableSymbol getImportFunction(String functionName, String packageName) {\n+        BInvokableSymbol bInvokableSymbol =\n+                getInvokableSymbol(functionName, packageName, this.bLangPackage.getImports());\n+\n+        if (bInvokableSymbol == null) {\n+            bInvokableSymbol =\n+                    getInvokableSymbol(functionName, packageName, this.bLangPackage.getTestablePkg().getImports());\n+        }\n+\n+        return bInvokableSymbol;\n+    }\n+\n+    private BInvokableSymbol getInvokableSymbol(String functionName,\n+                                                String packageName,\n+                                                List<BLangImportPackage> importList) {\n+        // Loop through each BLangImportPackage\n+        for (BLangImportPackage importPkg : importList) {\n+            // If the import package name matches\n+            if (importPkg.alias.getValue().equals(packageName)) {\n+                // return the function name defined in the package entry map\n+                return (BInvokableSymbol) importPkg.symbol.scope.entries.get(new Name(functionName)).symbol;\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    private List<BLangSimpleVariable> generateRequiredParams() {\n+        List<BLangSimpleVariable> requiredParams;\n+\n+        if (this.originalFunction == null) {\n+            requiredParams = generateImportRequiredParams();\n+        } else {\n+            requiredParams = this.originalFunction.requiredParams;\n+        }\n+\n+        return requiredParams;\n+    }\n+\n+    private List<BLangSimpleVariable> generateImportRequiredParams() {\n+        List<BLangSimpleVariable> bLangSimpleVariables = new ArrayList<>();\n+\n+        // Iterate through the params and generate the BLangSimpleVariable\n+        for (BVarSymbol bVarSymbol : this.importFunction.params) {\n+            BLangSimpleVariable bLangSimpleVariable =\n+                    ASTBuilderUtil.createVariable(bLangPackage.pos, bVarSymbol.name.getValue(),\n+                                                  bVarSymbol.type, null, bVarSymbol);\n+            bLangSimpleVariables.add(bLangSimpleVariable);\n+        }\n+\n+\n+        return bLangSimpleVariables;\n+    }\n+\n+    private BLangSimpleVariable generateRestParam() {\n+        BLangSimpleVariable bLangSimpleVariable = null;\n+\n+        if (this.importFunction != null) {\n+            BVarSymbol restParam = this.importFunction.restParam;\n+\n+            if (this.importFunction.restParam != null) {\n+                bLangSimpleVariable = ASTBuilderUtil.createVariable(bLangPackage.pos, restParam.name.getValue(),\n+                                                                    restParam.type, null, restParam);\n+                bLangSimpleVariable.typeNode = ASTBuilderUtil.createTypeNode(restParam.type);\n+            }\n+        }\n+\n+        return bLangSimpleVariable;\n+    }\n+\n+    private BLangType generateReturnTypeNode() {\n+        BLangType returnTypeNode;\n+\n+        if (this.originalFunction == null) {\n+            returnTypeNode = generateImportReturnTypeNode();\n+        } else {\n+            returnTypeNode = this.originalFunction.returnTypeNode;\n+        }\n+\n+        return returnTypeNode;\n+    }\n+\n+    private BLangType generateImportReturnTypeNode() {\n+        BLangValueType typeNode = (BLangValueType) TreeBuilder.createValueTypeNode();\n+        typeNode.pos = this.bLangPackage.pos;\n+        typeNode.typeKind = this.importFunction.retType.getKind();\n+        typeNode.type = this.importFunction.retType;\n+\n+        return typeNode;\n+    }\n+\n+    private BInvokableSymbol generateSymbol(String functionName) {\n+        BInvokableSymbol symbol = new BInvokableSymbol(\n+                820,\n+                0,\n+                new Name(functionName),\n+                bLangPackage.packageID,\n+                generateSymbolInvokableType(),\n+                bLangPackage.symbol\n+        );\n+\n+        return symbol;\n+    }\n+\n+    private BInvokableType generateSymbolInvokableType() {\n+        BInvokableType bInvokableType;\n+\n+        if (this.originalFunction == null && this.importFunction != null) {\n+            bInvokableType = (BInvokableType) this.importFunction.type;\n+        } else {\n+            bInvokableType = (BInvokableType) this.originalFunction.symbol.type;\n+        }\n+        return bInvokableType;\n+    }\n+\n+    private BLangFunctionBody generateBody() {\n+        BLangFunctionBody body = ASTBuilderUtil.createBlockFunctionBody(bLangPackage.pos, generateStatements());\n+        body.scope = bLangPackage.symbol.scope;\n+        return body;\n+    }\n+\n+    private List<BLangStatement> generateStatements() {\n+        // <MockFunctionObj>.functionToMock = (functionToMock);\n+        String functionToMockVal = (this.originalFunction == null) ?\n+                this.importFunction.name.toString() : this.originalFunction.name.toString();\n+        BLangAssignment bLangAssignment1 = ASTBuilderUtil.createAssignmentStmt(\n+                bLangPackage.pos,\n+                generateFieldBasedAccess(\"functionToMock\"),\n+                generateRHSExpr(functionToMockVal));\n+\n+        // <MockFunctionObj>.functionToMockPackage = (functionToMockPackage);  // ballerina/math/natives", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9e115b9f8140852d7ed77a994c178d451ef21c6"}, "originalPosition": 299}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU4MDU4NTc2", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25023#pullrequestreview-458058576", "createdAt": "2020-07-30T04:12:42Z", "commit": {"oid": "a9e115b9f8140852d7ed77a994c178d451ef21c6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwNDoxMjo0MlrOG5SaEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwNDoxMjo0MlrOG5SaEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjcyMzYwMw==", "bodyText": "Let's make the comments more descriptive.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25023#discussion_r462723603", "createdAt": "2020-07-30T04:12:42Z", "author": {"login": "azinneera"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/MockDesugar.java", "diffHunk": "@@ -0,0 +1,459 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.wso2.ballerinalang.compiler.desugar;\n+\n+\n+import org.ballerinalang.model.TreeBuilder;\n+import org.ballerinalang.model.tree.IdentifierNode;\n+import org.wso2.ballerinalang.compiler.semantics.analyzer.SymbolResolver;\n+import org.wso2.ballerinalang.compiler.semantics.model.SymbolTable;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BInvokableSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BVarSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BInvokableType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BType;\n+import org.wso2.ballerinalang.compiler.tree.BLangFunction;\n+import org.wso2.ballerinalang.compiler.tree.BLangFunctionBody;\n+import org.wso2.ballerinalang.compiler.tree.BLangIdentifier;\n+import org.wso2.ballerinalang.compiler.tree.BLangImportPackage;\n+import org.wso2.ballerinalang.compiler.tree.BLangPackage;\n+import org.wso2.ballerinalang.compiler.tree.BLangSimpleVariable;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangExpression;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangFieldBasedAccess;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangInvocation;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangListConstructorExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangLiteral;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangSimpleVarRef;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangTypeConversionExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangVariableReference;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangAssignment;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangReturn;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangStatement;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangType;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangValueType;\n+import org.wso2.ballerinalang.compiler.util.CompilerContext;\n+import org.wso2.ballerinalang.compiler.util.FieldKind;\n+import org.wso2.ballerinalang.compiler.util.Name;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Class to generate Mock Functions.\n+ *\n+ * @since 2.0.0\n+ */\n+public class MockDesugar {\n+\n+    private static final CompilerContext.Key<MockDesugar> MOCK_DESUGAR_KEY = new CompilerContext.Key<>();\n+    private static final String MOCK_ANNOTATION_DELIMITER = \"#\";\n+    private final SymbolTable symTable;\n+    private final SymbolResolver symResolver;\n+    private BLangPackage bLangPackage;\n+    private BLangFunction originalFunction;\n+    private BInvokableSymbol importFunction;\n+    private String mockFnObjectName;\n+\n+    private MockDesugar(CompilerContext context) {\n+        context.put(MOCK_DESUGAR_KEY, this);\n+        this.symTable = SymbolTable.getInstance(context);\n+        this.symResolver = SymbolResolver.getInstance(context);\n+    }\n+\n+    public static MockDesugar getInstance(CompilerContext context) {\n+        MockDesugar desugar = context.get(MOCK_DESUGAR_KEY);\n+        if (desugar == null) {\n+            desugar = new MockDesugar(context);\n+        }\n+        return desugar;\n+    }\n+\n+    private static IdentifierNode createIdentifier(String value) {\n+        IdentifierNode node = TreeBuilder.createIdentifierNode();\n+        if (value != null) {\n+            node.setValue(value);\n+        }\n+        return node;\n+    }\n+\n+    public void generateMockFunctions(BLangPackage pkgNode) {\n+        // Set the BLangPackage\n+        this.bLangPackage = pkgNode;\n+\n+        // Get the Mock Function map from the pkgNode\n+        Map<String, String> mockFunctionMap = pkgNode.getTestablePkg().getMockFunctionNamesMap();\n+\n+        // Get the set of functions to generate\n+        Set<String> mockFunctionSet = mockFunctionMap.keySet();\n+\n+        for (String function : mockFunctionSet) {\n+            if (!function.contains(\"~\")) {\n+                pkgNode.getTestablePkg().functions.add(generateMockFunction(function));\n+            }\n+        }\n+    }\n+\n+    private BLangFunction generateMockFunction(String functionName) {\n+        // Set the current mock object\n+        this.mockFnObjectName = this.bLangPackage.getTestablePkg().getMockFunctionNamesMap().get(functionName);\n+\n+        // Reset both import and original functions\n+        this.importFunction = null;\n+        this.originalFunction = null;\n+\n+        // Function name is going to be 'ballerina/math:1.0.0 # absInt'\n+        String currentPackageId = this.bLangPackage.packageID.toString();\n+\n+\n+        // We need to identify if the function is part of the current package or imported package\n+        if (functionName.contains(currentPackageId)) {\n+            // Simply extract the name only and set it to function name\n+            functionName = functionName.substring(functionName.indexOf(MOCK_ANNOTATION_DELIMITER) + 1);\n+            this.originalFunction = getOriginalFunction(functionName);\n+        } else {\n+            // Extract the name and the package details\n+            String packageName = functionName.contains(\":\") ?\n+                    functionName.substring(functionName.indexOf('/') + 1, functionName.indexOf(':')) :\n+                    functionName.substring(functionName.indexOf('/') + 1,\n+                                           functionName.indexOf(MOCK_ANNOTATION_DELIMITER));\n+            functionName = functionName.substring(functionName.indexOf(MOCK_ANNOTATION_DELIMITER) + 1);\n+            this.importFunction = getImportFunction(functionName, packageName);\n+        }\n+\n+        // Set the function name to $MOCK_<functionName>\n+        functionName = \"$MOCK_\" + functionName;\n+\n+        // Create the Base function with the name\n+        BLangFunction generatedMock = ASTBuilderUtil.createFunction(bLangPackage.pos, functionName);\n+\n+        if (this.originalFunction != null || this.importFunction != null) {\n+            generatedMock.requiredParams = generateRequiredParams();        // Required Params\n+            generatedMock.restParam = generateRestParam();                  // Rest Param\n+            generatedMock.returnTypeNode = generateReturnTypeNode();        // Return Type Node\n+            generatedMock.body = generateBody();                            // Body\n+            generatedMock.type = generateSymbolInvokableType();             // Invokable Type\n+            generatedMock.symbol = generateSymbol(functionName);            // Invokable Symbol\n+        } else {\n+            throw new IllegalStateException(\"Mock Function and Function to Mock cannot be null\");\n+        }\n+\n+        return generatedMock;\n+    }\n+\n+    private BLangFunction getOriginalFunction(String functionName) {\n+        List<BLangFunction> functionList = bLangPackage.getFunctions();\n+        for (BLangFunction function : functionList) {\n+            if (function.getName().toString().equals(functionName)) {\n+                return function;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private BInvokableSymbol getImportFunction(String functionName, String packageName) {\n+        BInvokableSymbol bInvokableSymbol =\n+                getInvokableSymbol(functionName, packageName, this.bLangPackage.getImports());\n+\n+        if (bInvokableSymbol == null) {\n+            bInvokableSymbol =\n+                    getInvokableSymbol(functionName, packageName, this.bLangPackage.getTestablePkg().getImports());\n+        }\n+\n+        return bInvokableSymbol;\n+    }\n+\n+    private BInvokableSymbol getInvokableSymbol(String functionName,\n+                                                String packageName,\n+                                                List<BLangImportPackage> importList) {\n+        // Loop through each BLangImportPackage\n+        for (BLangImportPackage importPkg : importList) {\n+            // If the import package name matches\n+            if (importPkg.alias.getValue().equals(packageName)) {\n+                // return the function name defined in the package entry map\n+                return (BInvokableSymbol) importPkg.symbol.scope.entries.get(new Name(functionName)).symbol;\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    private List<BLangSimpleVariable> generateRequiredParams() {\n+        List<BLangSimpleVariable> requiredParams;\n+\n+        if (this.originalFunction == null) {\n+            requiredParams = generateImportRequiredParams();\n+        } else {\n+            requiredParams = this.originalFunction.requiredParams;\n+        }\n+\n+        return requiredParams;\n+    }\n+\n+    private List<BLangSimpleVariable> generateImportRequiredParams() {\n+        List<BLangSimpleVariable> bLangSimpleVariables = new ArrayList<>();\n+\n+        // Iterate through the params and generate the BLangSimpleVariable\n+        for (BVarSymbol bVarSymbol : this.importFunction.params) {\n+            BLangSimpleVariable bLangSimpleVariable =\n+                    ASTBuilderUtil.createVariable(bLangPackage.pos, bVarSymbol.name.getValue(),\n+                                                  bVarSymbol.type, null, bVarSymbol);\n+            bLangSimpleVariables.add(bLangSimpleVariable);\n+        }\n+\n+\n+        return bLangSimpleVariables;\n+    }\n+\n+    private BLangSimpleVariable generateRestParam() {\n+        BLangSimpleVariable bLangSimpleVariable = null;\n+\n+        if (this.importFunction != null) {\n+            BVarSymbol restParam = this.importFunction.restParam;\n+\n+            if (this.importFunction.restParam != null) {\n+                bLangSimpleVariable = ASTBuilderUtil.createVariable(bLangPackage.pos, restParam.name.getValue(),\n+                                                                    restParam.type, null, restParam);\n+                bLangSimpleVariable.typeNode = ASTBuilderUtil.createTypeNode(restParam.type);\n+            }\n+        }\n+\n+        return bLangSimpleVariable;\n+    }\n+\n+    private BLangType generateReturnTypeNode() {\n+        BLangType returnTypeNode;\n+\n+        if (this.originalFunction == null) {\n+            returnTypeNode = generateImportReturnTypeNode();\n+        } else {\n+            returnTypeNode = this.originalFunction.returnTypeNode;\n+        }\n+\n+        return returnTypeNode;\n+    }\n+\n+    private BLangType generateImportReturnTypeNode() {\n+        BLangValueType typeNode = (BLangValueType) TreeBuilder.createValueTypeNode();\n+        typeNode.pos = this.bLangPackage.pos;\n+        typeNode.typeKind = this.importFunction.retType.getKind();\n+        typeNode.type = this.importFunction.retType;\n+\n+        return typeNode;\n+    }\n+\n+    private BInvokableSymbol generateSymbol(String functionName) {\n+        BInvokableSymbol symbol = new BInvokableSymbol(\n+                820,\n+                0,\n+                new Name(functionName),\n+                bLangPackage.packageID,\n+                generateSymbolInvokableType(),\n+                bLangPackage.symbol\n+        );\n+\n+        return symbol;\n+    }\n+\n+    private BInvokableType generateSymbolInvokableType() {\n+        BInvokableType bInvokableType;\n+\n+        if (this.originalFunction == null && this.importFunction != null) {\n+            bInvokableType = (BInvokableType) this.importFunction.type;\n+        } else {\n+            bInvokableType = (BInvokableType) this.originalFunction.symbol.type;\n+        }\n+        return bInvokableType;\n+    }\n+\n+    private BLangFunctionBody generateBody() {\n+        BLangFunctionBody body = ASTBuilderUtil.createBlockFunctionBody(bLangPackage.pos, generateStatements());\n+        body.scope = bLangPackage.symbol.scope;\n+        return body;\n+    }\n+\n+    private List<BLangStatement> generateStatements() {\n+        // <MockFunctionObj>.functionToMock = (functionToMock);\n+        String functionToMockVal = (this.originalFunction == null) ?\n+                this.importFunction.name.toString() : this.originalFunction.name.toString();\n+        BLangAssignment bLangAssignment1 = ASTBuilderUtil.createAssignmentStmt(\n+                bLangPackage.pos,\n+                generateFieldBasedAccess(\"functionToMock\"),\n+                generateRHSExpr(functionToMockVal));\n+\n+        // <MockFunctionObj>.functionToMockPackage = (functionToMockPackage);  // ballerina/math/natives\n+//        String functionToMockPackageVal = (this.originalFunction == null) ?\n+//                this.importFunction.pkgID.toString()\n+//                        + \"/\" + getFunctionSource(this.importFunction.source) :\n+//                this.originalFunction.symbol.pkgID.toString()\n+//                        + \"/\" + getFunctionSource(this.originalFunction.symbol.source);\n+//        BLangAssignment bLangAssignment2 = ASTBuilderUtil.createAssignmentStmt(\n+//                bLangPackage.pos,\n+//                generateFieldBasedAccess(\"functionToMockPackage\"),\n+//                generateRHSExpr(functionToMockPackageVal));\n+\n+        // BLangReturn Statement <retType> test:MockHandler(<MockFunctionObj>, [<args?>])\n+        BLangReturn blangReturn =\n+                ASTBuilderUtil.createReturnStmt(bLangPackage.pos, generateTypeConversionExpression());\n+\n+        List<BLangStatement> statements = new ArrayList<>();\n+\n+//        statements.add(bLangAssignment1);\n+//        statements.add(bLangAssignment2);\n+        statements.add(blangReturn);\n+\n+        return statements;\n+    }\n+\n+    private String getFunctionSource(String source) {\n+        return source.replaceAll(\".bal\", \"\");\n+    }\n+\n+    // <mockobj>.functionToMock =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9e115b9f8140852d7ed77a994c178d451ef21c6"}, "originalPosition": 327}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU4MDU5ODcy", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25023#pullrequestreview-458059872", "createdAt": "2020-07-30T04:17:46Z", "commit": {"oid": "a9e115b9f8140852d7ed77a994c178d451ef21c6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwNDoxNzo0NlrOG5Seng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwNDoxNzo0NlrOG5Seng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjcyNDc2Ng==", "bodyText": "Let's use the node Kind to check the condition.\ni.e. attachmentNode.getExpression().getKind() == NodeKind.RECORD_LITERAL_EXP", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25023#discussion_r462724766", "createdAt": "2020-07-30T04:17:46Z", "author": {"login": "azinneera"}, "path": "misc/testerina/modules/testerina-core/src/main/java/org/ballerinalang/testerina/core/TestAnnotationProcessor.java", "diffHunk": "@@ -319,86 +236,163 @@ public void process(FunctionNode functionNode, List<AnnotationAttachmentNode> an\n                 if (!shouldSkip.get()) {\n                     suite.addTests(test);\n                 }\n+            } else if (MOCK_ANNOTATION_NAME.equals(annotationName)) {\n+                String[] vals = new String[2];\n+                // TODO: when default values are supported in annotation struct we can remove this\n+                vals[0] = packageName;\n+                if (attachmentNode.getExpression() instanceof BLangRecordLiteral) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9e115b9f8140852d7ed77a994c178d451ef21c6"}, "originalPosition": 186}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU4MDYxMjE5", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25023#pullrequestreview-458061219", "createdAt": "2020-07-30T04:22:21Z", "commit": {"oid": "a9e115b9f8140852d7ed77a994c178d451ef21c6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwNDoyMjoyMVrOG5SjWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwNDoyMjoyMVrOG5SjWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjcyNTk3Ng==", "bodyText": "Let's move \"$MOCK_\" to constants", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25023#discussion_r462725976", "createdAt": "2020-07-30T04:22:21Z", "author": {"login": "azinneera"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/BIRGen.java", "diffHunk": "@@ -293,37 +294,48 @@ private void visitBuiltinFunctions(BLangPackage pkgNode, BLangFunction function)\n     }\n \n     private void replaceMockedFunctions(BIRPackage birPkg, Map<String, String> mockFunctionMap) {\n-        for (BIRFunction function : birPkg.functions) {\n-            List<BIRBasicBlock> functionBasicBlocks = function.basicBlocks;\n-            for (BIRBasicBlock functionBasicBlock : functionBasicBlocks) {\n-                BIRTerminator bbTerminator = functionBasicBlock.terminator;\n+        // Replace Mocked function calls in every function\n+        replaceFunctions(birPkg.functions, mockFunctionMap);\n+\n+        // Replace Mocked Function calls in every service\n+        if (birPkg.typeDefs.size() != 0) {\n+            for (BIRTypeDefinition typeDef : birPkg.typeDefs) {\n+                if (typeDef.type instanceof BServiceType) {\n+                    // Replace Mocked function calls in every service function\n+                    replaceFunctions(typeDef.attachedFuncs, mockFunctionMap);\n+                }\n+            }\n+        }\n+    }\n+\n+    private void replaceFunctions(List<BIRFunction> functionList, Map<String, String> mockFunctionMap) {\n+        // Loop through all defined BIRFunctions in functionList\n+        for (BIRFunction function : functionList) {\n+            List<BIRBasicBlock> basicBlocks = function.basicBlocks;\n+            for (BIRBasicBlock basicBlock : basicBlocks) {\n+                BIRTerminator bbTerminator = basicBlock.terminator;\n                 if (bbTerminator.kind.equals(InstructionKind.CALL)) {\n+                    //We get the callee and the name and generate 'calleepackage#name'\n                     BIRTerminator.Call callTerminator = (BIRTerminator.Call) bbTerminator;\n-                    String functionKey = null;\n-\n-                    // Generate the function key\n-                    if (callTerminator.isVirtual) {\n-                        // Function key for object methods\n-                        String objectPkg = callTerminator.args.get(0).variableDcl.type.toString();\n-                        functionKey = objectPkg + MOCK_ANNOTATION_DELIMITER + callTerminator.name.toString();\n-                    } else {\n-                        // Function key for normal functions\n-                        functionKey = callTerminator.calleePkg.toString() + MOCK_ANNOTATION_DELIMITER\n-                                + callTerminator.name.toString();\n-                    }\n \n-                    // Get the mock function from the Mock function map and replace where necessary\n-                    if (mockFunctionMap.get(functionKey) != null) {\n-                        String mockFunctionName = mockFunctionMap.get(functionKey);\n-                        callTerminator.name = new Name(mockFunctionName);\n-                        callTerminator.calleePkg = function.pos.src.pkgID;\n+                    String functionKey = callTerminator.calleePkg.toString() + MOCK_ANNOTATION_DELIMITER\n+                            + callTerminator.name.toString();\n \n-                        if (callTerminator.isVirtual) {\n-                            callTerminator.isVirtual = false;\n-                            callTerminator.args.remove(0);\n-                        }\n-                    }\n+                    String legacyKey = callTerminator.calleePkg.toString() + MOCK_FN_DELIMITER\n+                            + callTerminator.name.toString();\n \n+                    // If function in basic block exists in the MockFunctionMap\n+                    if (mockFunctionMap.containsKey(functionKey)) {\n+                        // Replace the function call with the equivalent $MOCK_ substitiute\n+                        String desugarFunction = \"$MOCK_\" + callTerminator.name.getValue();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9e115b9f8140852d7ed77a994c178d451ef21c6"}, "originalPosition": 80}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0a631d63269e796f6199bc986c228ca9faacf0a8", "author": {"user": {"login": "Ibaqu", "name": "Aquib Zulfikar"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/0a631d63269e796f6199bc986c228ca9faacf0a8", "committedDate": "2020-07-30T05:57:05Z", "message": "Address PR comments"}, "afterCommit": {"oid": "772ac4b68a63f9adc31e217391d3c7582e94b06b", "author": {"user": {"login": "Ibaqu", "name": "Aquib Zulfikar"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/772ac4b68a63f9adc31e217391d3c7582e94b06b", "committedDate": "2020-08-04T06:55:19Z", "message": "Address PR comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "772ac4b68a63f9adc31e217391d3c7582e94b06b", "author": {"user": {"login": "Ibaqu", "name": "Aquib Zulfikar"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/772ac4b68a63f9adc31e217391d3c7582e94b06b", "committedDate": "2020-08-04T06:55:19Z", "message": "Address PR comments"}, "afterCommit": {"oid": "c3f75e5abf0d0b2d301a72abb95e01b6fa4d957d", "author": {"user": {"login": "Ibaqu", "name": "Aquib Zulfikar"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c3f75e5abf0d0b2d301a72abb95e01b6fa4d957d", "committedDate": "2020-08-04T08:33:43Z", "message": "Address PR comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c3f75e5abf0d0b2d301a72abb95e01b6fa4d957d", "author": {"user": {"login": "Ibaqu", "name": "Aquib Zulfikar"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c3f75e5abf0d0b2d301a72abb95e01b6fa4d957d", "committedDate": "2020-08-04T08:33:43Z", "message": "Address PR comments"}, "afterCommit": {"oid": "e16ea32d68cac90da57ca1bb8f568e3b805fb9ec", "author": {"user": {"login": "Ibaqu", "name": "Aquib Zulfikar"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e16ea32d68cac90da57ca1bb8f568e3b805fb9ec", "committedDate": "2020-08-06T08:06:08Z", "message": "Address PR comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fd6536a922aac9523f20811ada94901091d7d78a", "author": {"user": {"login": "Ibaqu", "name": "Aquib Zulfikar"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/fd6536a922aac9523f20811ada94901091d7d78a", "committedDate": "2020-08-06T11:29:41Z", "message": "Add Testerina mocking functionality"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e1e44618f63264352f8f13786075fd49f9678a8d", "author": {"user": {"login": "Ibaqu", "name": "Aquib Zulfikar"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e1e44618f63264352f8f13786075fd49f9678a8d", "committedDate": "2020-08-06T11:29:41Z", "message": "Add Testerina mocking refactored classes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9b4225833c419e59efa55b75ea19400f5792d81c", "author": {"user": {"login": "Ibaqu", "name": "Aquib Zulfikar"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/9b4225833c419e59efa55b75ea19400f5792d81c", "committedDate": "2020-08-06T11:29:42Z", "message": "Address PR comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "688104c5f9ec8740642ba463bd4e6c7e8b360174", "author": {"user": {"login": "Ibaqu", "name": "Aquib Zulfikar"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/688104c5f9ec8740642ba463bd4e6c7e8b360174", "committedDate": "2020-08-06T11:28:31Z", "message": "Add function mocking runtime validation"}, "afterCommit": {"oid": "9058e9a8731bf2e4cdf23248746c4e11b0cb76d7", "author": {"user": {"login": "Ibaqu", "name": "Aquib Zulfikar"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/9058e9a8731bf2e4cdf23248746c4e11b0cb76d7", "committedDate": "2020-08-06T11:29:42Z", "message": "Add function mocking runtime validation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f1fcd0843de554c6118c7d6fbc1210183529e635", "author": {"user": {"login": "Ibaqu", "name": "Aquib Zulfikar"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f1fcd0843de554c6118c7d6fbc1210183529e635", "committedDate": "2020-08-06T11:37:47Z", "message": "Add function mocking runtime validation"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9058e9a8731bf2e4cdf23248746c4e11b0cb76d7", "author": {"user": {"login": "Ibaqu", "name": "Aquib Zulfikar"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/9058e9a8731bf2e4cdf23248746c4e11b0cb76d7", "committedDate": "2020-08-06T11:29:42Z", "message": "Add function mocking runtime validation"}, "afterCommit": {"oid": "f1fcd0843de554c6118c7d6fbc1210183529e635", "author": {"user": {"login": "Ibaqu", "name": "Aquib Zulfikar"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f1fcd0843de554c6118c7d6fbc1210183529e635", "committedDate": "2020-08-06T11:37:47Z", "message": "Add function mocking runtime validation"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYyNzMxMjM2", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25023#pullrequestreview-462731236", "createdAt": "2020-08-06T17:28:47Z", "commit": {"oid": "f1fcd0843de554c6118c7d6fbc1210183529e635"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNzoyODo0N1rOG89VSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNzoyODo0N1rOG89VSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU3MjYxOQ==", "bodyText": "Wrong version", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25023#discussion_r466572619", "createdAt": "2020-08-06T17:28:47Z", "author": {"login": "azinneera"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/MockDesugar.java", "diffHunk": "@@ -0,0 +1,523 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.wso2.ballerinalang.compiler.desugar;\n+\n+import org.ballerinalang.model.TreeBuilder;\n+import org.ballerinalang.model.tree.IdentifierNode;\n+import org.wso2.ballerinalang.compiler.semantics.analyzer.SymbolResolver;\n+import org.wso2.ballerinalang.compiler.semantics.model.SymbolTable;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BInvokableSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BVarSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BInvokableType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BType;\n+import org.wso2.ballerinalang.compiler.tree.BLangFunction;\n+import org.wso2.ballerinalang.compiler.tree.BLangFunctionBody;\n+import org.wso2.ballerinalang.compiler.tree.BLangIdentifier;\n+import org.wso2.ballerinalang.compiler.tree.BLangImportPackage;\n+import org.wso2.ballerinalang.compiler.tree.BLangPackage;\n+import org.wso2.ballerinalang.compiler.tree.BLangSimpleVariable;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangExpression;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangFieldBasedAccess;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangInvocation;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangLiteral;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangSimpleVarRef;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangTypeConversionExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangVariableReference;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangAssignment;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangReturn;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangStatement;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangType;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangValueType;\n+import org.wso2.ballerinalang.compiler.util.CompilerContext;\n+import org.wso2.ballerinalang.compiler.util.FieldKind;\n+import org.wso2.ballerinalang.compiler.util.Name;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Class to generate Mock Functions.\n+ *\n+ * @since 2.0.0", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1fcd0843de554c6118c7d6fbc1210183529e635"}, "originalPosition": 58}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYyNzMyNTc2", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25023#pullrequestreview-462732576", "createdAt": "2020-08-06T17:30:36Z", "commit": {"oid": "f1fcd0843de554c6118c7d6fbc1210183529e635"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNzozMDozNlrOG89ZhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNzozMDozNlrOG89ZhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU3MzcwMQ==", "bodyText": "\"/\" can be a constant.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25023#discussion_r466573701", "createdAt": "2020-08-06T17:30:36Z", "author": {"login": "azinneera"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/MockDesugar.java", "diffHunk": "@@ -0,0 +1,523 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.wso2.ballerinalang.compiler.desugar;\n+\n+import org.ballerinalang.model.TreeBuilder;\n+import org.ballerinalang.model.tree.IdentifierNode;\n+import org.wso2.ballerinalang.compiler.semantics.analyzer.SymbolResolver;\n+import org.wso2.ballerinalang.compiler.semantics.model.SymbolTable;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BInvokableSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BVarSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BInvokableType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BType;\n+import org.wso2.ballerinalang.compiler.tree.BLangFunction;\n+import org.wso2.ballerinalang.compiler.tree.BLangFunctionBody;\n+import org.wso2.ballerinalang.compiler.tree.BLangIdentifier;\n+import org.wso2.ballerinalang.compiler.tree.BLangImportPackage;\n+import org.wso2.ballerinalang.compiler.tree.BLangPackage;\n+import org.wso2.ballerinalang.compiler.tree.BLangSimpleVariable;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangExpression;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangFieldBasedAccess;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangInvocation;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangLiteral;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangSimpleVarRef;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangTypeConversionExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangVariableReference;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangAssignment;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangReturn;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangStatement;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangType;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangValueType;\n+import org.wso2.ballerinalang.compiler.util.CompilerContext;\n+import org.wso2.ballerinalang.compiler.util.FieldKind;\n+import org.wso2.ballerinalang.compiler.util.Name;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Class to generate Mock Functions.\n+ *\n+ * @since 2.0.0\n+ */\n+public class MockDesugar {\n+\n+    private static final CompilerContext.Key<MockDesugar> MOCK_DESUGAR_KEY = new CompilerContext.Key<>();\n+    private static final String MOCK_ANNOTATION_DELIMITER = \"#\";\n+    private static final String MOCK_PREFIX = \"$MOCK_\";\n+    private final SymbolTable symTable;\n+    private final SymbolResolver symResolver;\n+    private BLangPackage bLangPackage;\n+    private BLangFunction originalFunction;\n+    private BInvokableSymbol importFunction;\n+    private String mockFnObjectName;\n+\n+    private MockDesugar(CompilerContext context) {\n+        context.put(MOCK_DESUGAR_KEY, this);\n+        this.symTable = SymbolTable.getInstance(context);\n+        this.symResolver = SymbolResolver.getInstance(context);\n+    }\n+\n+    public static MockDesugar getInstance(CompilerContext context) {\n+        MockDesugar desugar = context.get(MOCK_DESUGAR_KEY);\n+        if (desugar == null) {\n+            desugar = new MockDesugar(context);\n+        }\n+        return desugar;\n+    }\n+\n+    private static IdentifierNode createIdentifier(String value) {\n+        IdentifierNode node = TreeBuilder.createIdentifierNode();\n+        if (value != null) {\n+            node.setValue(value);\n+        }\n+        return node;\n+    }\n+\n+    /**\n+     * Generates all the Mock Functions and adds them to the BLangPackage's TestablePkg function list.\n+     *\n+     * @param pkgNode BLangPackage\n+     */\n+    public void generateMockFunctions(BLangPackage pkgNode) {\n+        // Set the BLangPackage\n+        this.bLangPackage = pkgNode;\n+\n+        // Get the Mock Function map from the pkgNode\n+        Map<String, String> mockFunctionMap = pkgNode.getTestablePkg().getMockFunctionNamesMap();\n+\n+        // Get the set of functions to generate\n+        Set<String> mockFunctionSet = mockFunctionMap.keySet();\n+\n+        for (String function : mockFunctionSet) {\n+            if (!function.contains(\"~\")) {\n+                pkgNode.getTestablePkg().functions.add(generateMockFunction(function));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Generates a BLangFunction based on the function name provided.\n+     *\n+     * @param functionName Name of the function to generate the mock\n+     * @return Generated BLangFunction\n+     */\n+    private BLangFunction generateMockFunction(String functionName) {\n+        // Set the current mock object\n+        this.mockFnObjectName = this.bLangPackage.getTestablePkg().getMockFunctionNamesMap().get(functionName);\n+\n+        // Reset both import and original functions\n+        this.importFunction = null;\n+        this.originalFunction = null;\n+\n+        // Identify if function is part of current package or import package\n+        if (functionName.contains(this.bLangPackage.packageID.toString())) {\n+            // Simply extract the name only\n+            functionName = functionName.substring(functionName.indexOf(MOCK_ANNOTATION_DELIMITER) + 1);\n+            this.originalFunction = getOriginalFunction(functionName);\n+        } else {\n+            // Extract the name and the package details\n+            String packageName = (functionName.contains(\":\")) ?\n+                    functionName.substring(functionName.indexOf('/') + 1, functionName.indexOf(':')) :\n+                    functionName.substring(functionName.indexOf('/') + 1,\n+                                           functionName.indexOf(MOCK_ANNOTATION_DELIMITER));\n+            functionName = functionName.substring(functionName.indexOf(MOCK_ANNOTATION_DELIMITER) + 1);\n+            this.importFunction = getImportFunction(functionName, packageName);\n+        }\n+\n+        // Set the function name to $MOCK_<functionName>\n+        functionName = MOCK_PREFIX + functionName;\n+\n+        // Create the Base function with the name\n+        BLangFunction generatedMock = ASTBuilderUtil.createFunction(bLangPackage.pos, functionName);\n+\n+        if (this.originalFunction != null || this.importFunction != null) {\n+            generatedMock.requiredParams = generateRequiredParams();        // Required Params\n+            generatedMock.restParam = generateRestParam();                  // Rest Param\n+            generatedMock.returnTypeNode = generateReturnTypeNode();        // Return Type Node\n+            generatedMock.body = generateBody();                            // Body\n+            generatedMock.type = generateSymbolInvokableType();             // Invokable Type\n+            generatedMock.symbol = generateSymbol(functionName);            // Invokable Symbol\n+        } else {\n+            throw new IllegalStateException(\"Mock Function and Function to Mock cannot be null\");\n+        }\n+\n+        return generatedMock;\n+    }\n+\n+    private BLangFunction getOriginalFunction(String functionName) {\n+        List<BLangFunction> functionList = bLangPackage.getFunctions();\n+        for (BLangFunction function : functionList) {\n+            if (function.getName().toString().equals(functionName)) {\n+                return function;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private BInvokableSymbol getImportFunction(String functionName, String packageName) {\n+        BInvokableSymbol bInvokableSymbol =\n+                getInvokableSymbol(functionName, packageName, this.bLangPackage.getImports());\n+\n+        if (bInvokableSymbol == null) {\n+            bInvokableSymbol =\n+                    getInvokableSymbol(functionName, packageName, this.bLangPackage.getTestablePkg().getImports());\n+        }\n+\n+        return bInvokableSymbol;\n+    }\n+\n+    private BInvokableSymbol getInvokableSymbol(String functionName, String packageName,\n+                                                List<BLangImportPackage> importList) {\n+        // Loop through each BLangImportPackage\n+        for (BLangImportPackage importPkg : importList) {\n+            // If the import package name matches\n+            if (importPkg.alias.getValue().equals(packageName)) {\n+                // return the function name defined in the package entry map\n+                return (BInvokableSymbol) importPkg.symbol.scope.entries.get(new Name(functionName)).symbol;\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    private List<BLangSimpleVariable> generateRequiredParams() {\n+        List<BLangSimpleVariable> requiredParams;\n+\n+        if (this.originalFunction != null) {\n+            requiredParams = this.originalFunction.requiredParams;\n+        } else {\n+            requiredParams = generateImportRequiredParams();\n+        }\n+\n+        return requiredParams;\n+    }\n+\n+    private List<BLangSimpleVariable> generateImportRequiredParams() {\n+        List<BLangSimpleVariable> bLangSimpleVariables = new ArrayList<>();\n+\n+        // Iterate through the params and generate the BLangSimpleVariable\n+        for (BVarSymbol bVarSymbol : this.importFunction.params) {\n+            BLangSimpleVariable bLangSimpleVariable =\n+                    ASTBuilderUtil.createVariable(bLangPackage.pos, bVarSymbol.name.getValue(),\n+                                                  bVarSymbol.type, null, bVarSymbol);\n+            bLangSimpleVariables.add(bLangSimpleVariable);\n+        }\n+\n+        return bLangSimpleVariables;\n+    }\n+\n+    private BLangSimpleVariable generateRestParam() {\n+        BLangSimpleVariable bLangSimpleVariable = null;\n+\n+        if (this.importFunction != null) {\n+            if (this.importFunction.restParam != null) {\n+                bLangSimpleVariable =\n+                        ASTBuilderUtil.createVariable(bLangPackage.pos, this.importFunction.restParam.name.getValue(),\n+                                                      this.importFunction.restParam.type, null,\n+                                                      this.importFunction.restParam);\n+                bLangSimpleVariable.typeNode = ASTBuilderUtil.createTypeNode(this.importFunction.restParam.type);\n+            }\n+        } else {\n+            bLangSimpleVariable = this.originalFunction.restParam;\n+        }\n+\n+        return bLangSimpleVariable;\n+    }\n+\n+    private BLangType generateReturnTypeNode() {\n+        BLangType returnTypeNode;\n+\n+        if (this.originalFunction == null) {\n+            returnTypeNode = generateImportReturnTypeNode();\n+        } else {\n+            returnTypeNode = this.originalFunction.returnTypeNode;\n+        }\n+\n+        return returnTypeNode;\n+    }\n+\n+    private BLangType generateImportReturnTypeNode() {\n+        BLangValueType typeNode = (BLangValueType) TreeBuilder.createValueTypeNode();\n+        typeNode.pos = this.bLangPackage.pos;\n+        typeNode.typeKind = this.importFunction.retType.getKind();\n+        typeNode.type = this.importFunction.retType;\n+\n+        return typeNode;\n+    }\n+\n+    private BInvokableSymbol generateSymbol(String functionName) {\n+        BInvokableSymbol symbol = new BInvokableSymbol(\n+                820,\n+                0,\n+                new Name(functionName),\n+                bLangPackage.packageID,\n+                generateSymbolInvokableType(),\n+                bLangPackage.symbol\n+        );\n+\n+        return symbol;\n+    }\n+\n+    private BInvokableType generateSymbolInvokableType() {\n+        BInvokableType bInvokableType;\n+\n+        if (this.originalFunction == null && this.importFunction != null) {\n+            bInvokableType = (BInvokableType) this.importFunction.type;\n+        } else {\n+            bInvokableType = (BInvokableType) this.originalFunction.symbol.type;\n+        }\n+        return bInvokableType;\n+    }\n+\n+    private BLangFunctionBody generateBody() {\n+        BLangFunctionBody body = ASTBuilderUtil.createBlockFunctionBody(bLangPackage.pos, generateStatements());\n+        body.scope = bLangPackage.symbol.scope;\n+        return body;\n+    }\n+\n+    private List<BLangStatement> generateStatements() {\n+        // The following synthesizes the equivalent of : `<MockFunctionObj>.functionToMock = (functionToMock);`\n+        String functionToMockVal = (this.originalFunction == null) ?\n+                this.importFunction.name.toString() : this.originalFunction.name.toString();\n+        BLangAssignment bLangAssignment1 = ASTBuilderUtil.createAssignmentStmt(\n+                bLangPackage.pos,\n+                generateFieldBasedAccess(\"functionToMock\"),\n+                generateRHSExpr(functionToMockVal));\n+\n+        // <MockFunctionObj>.functionToMockPackage = (functionToMockPackage);  // ballerina/math/natives\n+        String functionToMockPackageVal = (this.originalFunction == null) ?\n+                this.importFunction.pkgID.orgName.toString()\n+                        + \"/\" + this.importFunction.pkgID.name.toString()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1fcd0843de554c6118c7d6fbc1210183529e635"}, "originalPosition": 308}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYyNzM2NjEy", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25023#pullrequestreview-462736612", "createdAt": "2020-08-06T17:36:01Z", "commit": {"oid": "f1fcd0843de554c6118c7d6fbc1210183529e635"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNzozNjowMVrOG89lYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNzozNjowMVrOG89lYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU3NjczOQ==", "bodyText": "Indentation issue", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25023#discussion_r466576739", "createdAt": "2020-08-06T17:36:01Z", "author": {"login": "azinneera"}, "path": "misc/testerina/modules/testerina-core/src/main/java/org/ballerinalang/testerina/core/TestAnnotationProcessor.java", "diffHunk": "@@ -256,7 +174,7 @@ public void process(FunctionNode functionNode, List<AnnotationAttachmentNode> an\n \n                         // Check if enable property is present in the annotation\n                         if (TEST_ENABLE_ANNOTATION_NAME.equals(name) && \"false\".equals(valueExpr\n-                                .toString())) {\n+                                                                                               .toString())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1fcd0843de554c6118c7d6fbc1210183529e635"}, "originalPosition": 167}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYyNzM4Mjg0", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25023#pullrequestreview-462738284", "createdAt": "2020-08-06T17:38:18Z", "commit": {"oid": "f1fcd0843de554c6118c7d6fbc1210183529e635"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNzozODoxOFrOG89q2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNzozODoxOFrOG89q2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU3ODEzNg==", "bodyText": "We should add javadocs to public functions", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25023#discussion_r466578136", "createdAt": "2020-08-06T17:38:18Z", "author": {"login": "azinneera"}, "path": "misc/testerina/modules/testerina-core/src/main/java/org/ballerinalang/testerina/natives/test/FunctionMock.java", "diffHunk": "@@ -0,0 +1,225 @@\n+package org.ballerinalang.testerina.natives.test;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.scheduling.Scheduler;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.values.AbstractObjectValue;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.ObjectValue;\n+import org.ballerinalang.jvm.values.connector.Executor;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Method;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarFile;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Class that contains inter-op function related to function mocking.\n+ */\n+public class FunctionMock {\n+\n+    public static ErrorValue thenReturn(ObjectValue caseObj) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1fcd0843de554c6118c7d6fbc1210183529e635"}, "originalPosition": 30}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYyNzQwMDEy", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25023#pullrequestreview-462740012", "createdAt": "2020-08-06T17:40:45Z", "commit": {"oid": "f1fcd0843de554c6118c7d6fbc1210183529e635"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNzo0MDo0NVrOG89wFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNzo0MDo0NVrOG89wFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU3OTQ3OA==", "bodyText": "Can't we utilize the classloader for getting the classname?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25023#discussion_r466579478", "createdAt": "2020-08-06T17:40:45Z", "author": {"login": "azinneera"}, "path": "misc/testerina/modules/testerina-core/src/main/java/org/ballerinalang/testerina/natives/test/FunctionMock.java", "diffHunk": "@@ -0,0 +1,225 @@\n+package org.ballerinalang.testerina.natives.test;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.scheduling.Scheduler;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.values.AbstractObjectValue;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.ObjectValue;\n+import org.ballerinalang.jvm.values.connector.Executor;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Method;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarFile;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Class that contains inter-op function related to function mocking.\n+ */\n+public class FunctionMock {\n+\n+    public static ErrorValue thenReturn(ObjectValue caseObj) {\n+        ObjectValue mockFunctionObj = caseObj.getObjectValue(\"mockFuncObj\");\n+        ArrayValue args = caseObj.getArrayValue(\"args\");\n+        Object returnVal = caseObj.get(\"returnValue\");\n+        MockRegistry.getInstance().registerCase(mockFunctionObj, null, args, returnVal);\n+        return null;\n+    }\n+\n+    public static Object mockHandler(ObjectValue mockFuncObj, Object... args) {\n+        List<String> caseIds = getCaseIds(mockFuncObj, args);\n+        String originalFunction =\n+                mockFuncObj.getStringValue(\"functionToMock\");\n+        String originalFunctionPackage =\n+                mockFuncObj.getStringValue(\"functionToMockPackage\");\n+        originalFunctionPackage = formatFunctionPackage(originalFunctionPackage);\n+        String version =\n+                mockFuncObj.getStringValue(\"packageVersion\");\n+        Object returnVal = null;\n+\n+        for (String caseId : caseIds) {\n+            if (MockRegistry.getInstance().hasCase(caseId)) {\n+                returnVal = MockRegistry.getInstance().getReturnValue(caseId);\n+                if (returnVal.toString().contains(MockConstants.FUNCTION_CALL_PLACEHOLDER)) {\n+                    return callFunction(originalFunction, originalFunctionPackage, returnVal.toString(), version, args);\n+                }\n+                break;\n+            }\n+        }\n+        if (returnVal == null) {\n+            String detail = \"no return value or action registered for function\";\n+            return BallerinaErrors.createError(MockConstants.FUNCTION_CALL_ERROR, detail);\n+        }\n+        return returnVal;\n+    }\n+\n+    private static Object callFunction(String originalFunction, String originalFunctionPackage, String returnVal,\n+                                       String version, Object... args) {\n+        int prefixPos = returnVal.indexOf(MockConstants.FUNCTION_CALL_PLACEHOLDER);\n+        String methodName = returnVal.substring(prefixPos + MockConstants.FUNCTION_CALL_PLACEHOLDER.length());\n+        Strand strand = Scheduler.getStrand();\n+\n+        String className;\n+        String orgName;\n+        String packageName;\n+\n+        // Set project info\n+        try {\n+            String[] projectInfo =\n+                    Thread.currentThread().getStackTrace()[4].getClassName().split(Pattern.quote(\".\"));\n+            orgName = projectInfo[0];\n+            packageName = projectInfo[1];\n+            className = \"tests.\" +\n+                    getClassName(methodName, orgName, packageName, version, originalFunction, originalFunctionPackage);\n+        } catch (IOException | ClassNotFoundException e) {\n+            return BallerinaErrors.createError(MockConstants.FUNCTION_CALL_ERROR, e.getMessage());\n+        }\n+\n+        List<Object> argsList = new ArrayList<>();\n+        for (Object arg : args) {\n+            argsList.add(arg);\n+        }\n+\n+        ClassLoader classLoader = FunctionMock.class.getClassLoader();\n+        return Executor.executeFunction(strand.scheduler, classLoader, orgName,\n+                                        packageName, className, methodName, argsList.toArray());\n+    }\n+\n+    private static String getClassName(String mockMethodName, String orgName, String packageName, String version,\n+                                       String originalMethodName, String originalPackageName)\n+            throws IOException, ClassNotFoundException {\n+        String jarName = orgName + \"-\" + packageName + \"-\" + version + \"-testable.jar\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1fcd0843de554c6118c7d6fbc1210183529e635"}, "originalPosition": 100}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYyNzQzNjU5", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25023#pullrequestreview-462743659", "createdAt": "2020-08-06T17:45:54Z", "commit": {"oid": "f1fcd0843de554c6118c7d6fbc1210183529e635"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNzo0NTo1NFrOG897LA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNzo0NTo1NFrOG897LA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU4MjMxNg==", "bodyText": "Shall we make the function names self explanatory, since there are two for function mocking?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25023#discussion_r466582316", "createdAt": "2020-08-06T17:45:54Z", "author": {"login": "azinneera"}, "path": "tests/testerina-integration-test/src/test/java/org/ballerinalang/testerina/test/MockTest.java", "diffHunk": "@@ -31,20 +31,45 @@\n \n     private BMainInstance balClient;\n     private String projectPath;\n+    private String projectPath2;\n \n     @BeforeClass\n     public void setup() throws BallerinaTestException {\n         balClient = new BMainInstance(balServer);\n         projectPath = mockProjectPath.toString();\n+        projectPath2 = mockProjectPath2.toString();\n     }\n \n     @Test\n-    public void testAssertTrue() throws BallerinaTestException {\n-        String msg = \"5 passing\";\n-        LogLeecher clientLeecher = new LogLeecher(msg);\n-        balClient.runMain(\"test\", new String[]{\"--all\"}, null,\n-                new String[]{}, new LogLeecher[]{clientLeecher}, projectPath);\n-        clientLeecher.waitForText(20000);\n+    public void testFunctionMocking() throws BallerinaTestException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1fcd0843de554c6118c7d6fbc1210183529e635"}, "originalPosition": 20}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYyNzQ0NjI5", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25023#pullrequestreview-462744629", "createdAt": "2020-08-06T17:47:19Z", "commit": {"oid": "f1fcd0843de554c6118c7d6fbc1210183529e635"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNzo0NzoxOVrOG89-Ng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNzo0NzoxOVrOG89-Ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU4MzA5NA==", "bodyText": "Do we need this commented code? There are commented blocks in a few bal files.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25023#discussion_r466583094", "createdAt": "2020-08-06T17:47:19Z", "author": {"login": "azinneera"}, "path": "tests/testerina-integration-test/src/test/resources/project-based-tests/mock-tests/src/Mock/tests/main_test.bal", "diffHunk": "@@ -1,91 +1,236 @@\n+// Copyright (c) 2020 WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+//\n+// WSO2 Inc. licenses this file to you under the Apache License,\n+// Version 2.0 (the \"License\"); you may not use this file except\n+// in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n import ballerina/test;\n-import SubtractModule;\n+import ballerina/io;\n import ballerina/math;\n+import Mock2;\n+\n+(any|error)[] outputs = [];\n+int counter = 0;\n \n //\n-// TEST CASES\n+// MOCK FUNCTION OBJECTS\n //\n \n-// Test Function mocking in Same module\n-@test:Config {}\n-function test_AddFunction() {\n-    int answer = 0;\n-    answer = intAdd(5, 3);\n-    test:assertEquals(answer, 2, \"Mocking did not take place\");\n+@test:Mock {\n+    functionName : \"intAdd\"\n }\n+test:MockFunction mock_intAdd = new();\n \n-// Test Function mocking in Different module\n-// Calling function directly\n-@test:Config {}\n-function test_SubtractFunction() {\n-    int answer = 0;\n-    answer = SubtractModule:intSubtract(5, 3);\n-    test:assertEquals(answer, 8, \"Mocking did not take place\");\n+@test:Mock {\n+    functionName : \"stringAdd\"\n }\n+test:MockFunction mock_stringAdd = new();\n \n-// Test Function mocking in Different module\n-// Calling function directly\n-@test:Config {}\n-function test_SubtractFunctionInSameModule() {\n-    int answer = 0;\n-    answer = intSubtract(5, 3);\n-    test:assertEquals(answer, 2, \"Mocking did take place, but mocked the wrong function\");\n+@test:Mock {\n+    functionName: \"floatAdd\"\n }\n+test:MockFunction mock_floatAdd = new();\n \n-// Test Function mocking for native functions\n-@test:Config {}\n-function test_MockNativeFunction() {\n-    float answer = 0;\n-    answer = math:sqrt(5);\n+@test:Mock {\n+    moduleName : \"ballerina/math\",\n+    functionName : \"absInt\"\n+}\n+test:MockFunction mock_absInt = new();\n \n-    test:assertEquals(answer, 125.0, \"Mocking did not take place\");\n+@test:Mock {\n+    moduleName : \"mock-tests/Mock2\",\n+    functionName : \"intAdd2\"\n }\n+test:MockFunction mock2_intAdd = new();\n \n-// Test Function mocking for Object methods\n-Person p1 = new (\"Jane\", \"Doe\");\n+@test:Mock {\n+    functionName : \"intAdd3\"\n+}\n+test:MockFunction mock_intAdd3 = new();\n \n-@test:Config {\n+@test:Mock {\n+    moduleName: \"ballerina/io\",\n+    functionName: \"print\"\n }\n-function test_MockObjectFunction() {\n-    test:assertEquals(p1.getFullName(), \"John Doe\", \"Mocking did not take place\");\n+test:MockFunction mock_print = new();\n+\n+//\n+//  MOCK FUNCTIONS\n+//\n+\n+public function mockIntAdd1(int x, int y) returns (int) {\n+    return x - y;\n }\n \n+public function mockIntAdd2(int a, int b) returns (int) {\n+    return a * b;\n+}\n+\n+public function mockIntAdd3(int a, int b) returns (float) {\n+    return 10.0;\n+}\n+\n+public function mockIntAdd4(int a) returns (int) {\n+    return a;\n+}\n+\n+public function mockIntAdd5((any|error)... args) returns (int) {\n+    int sum = 0;\n+\n+    foreach var arg in args {\n+        if (arg is int) {\n+            sum -= arg;\n+        }\n+    }\n+\n+    return  sum;\n+}\n+\n+//public function mockStringAdd(string str1) returns (string) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1fcd0843de554c6118c7d6fbc1210183529e635"}, "originalPosition": 132}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3da116294448ab20644c2f076feee27af78fd739", "author": {"user": {"login": "Ibaqu", "name": "Aquib Zulfikar"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3da116294448ab20644c2f076feee27af78fd739", "committedDate": "2020-08-06T19:28:00Z", "message": "Address PR comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzMDM5ODcw", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25023#pullrequestreview-463039870", "createdAt": "2020-08-07T05:18:50Z", "commit": {"oid": "3da116294448ab20644c2f076feee27af78fd739"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzOTU4NTYx", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25023#pullrequestreview-463958561", "createdAt": "2020-08-10T05:02:36Z", "commit": {"oid": "3da116294448ab20644c2f076feee27af78fd739"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4960, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}