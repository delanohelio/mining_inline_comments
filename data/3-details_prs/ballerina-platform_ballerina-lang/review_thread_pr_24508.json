{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQxODU4NjI3", "number": 24508, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxODowNDowM1rOELAU_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxODowNDoyNVrOELAVcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5OTc1MTY0OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/codegen/JvmCastGen.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxODowNDowM1rOGsYJZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxODowNDowM1rOGsYJZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE4NjE1MA==", "bodyText": "Shall we remove the commented code? We can add a Todo if needed about what to fix properly and remove the code. Anyone can see the code from git history right?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24508#discussion_r449186150", "createdAt": "2020-07-02T18:04:03Z", "author": {"login": "riyafa"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/codegen/JvmCastGen.java", "diffHunk": "@@ -310,122 +379,174 @@ private static void generateJToBCheckCast(MethodVisitor mv, BIRVarToJVMIndexMap\n \n         if (TypeTags.isIntegerTypeTag(targetType.tag)) {\n             generateCheckCastJToBInt(mv, sourceType);\n-        } else if (targetType.tag == TypeTags.FLOAT) {\n-            generateCheckCastJToBFloat(mv, sourceType);\n-        } else if (targetType.tag == TypeTags.DECIMAL) {\n-            generateCheckCastJToBDecimal(mv, sourceType);\n-        } else if (targetType.tag == TypeTags.BOOLEAN) {\n-            generateCheckCastJToBBoolean(mv, sourceType);\n-        } else if (targetType.tag == TypeTags.BYTE) {\n-            generateCheckCastJToBByte(mv, sourceType);\n-        } else if (targetType.tag == TypeTags.NIL || targetType.tag == TypeTags.NEVER) {\n-            // Do nothing\n-        } else {\n-            if (targetType.tag == TypeTags.UNION) {\n-                generateCheckCastJToBUnionType(mv, indexMap, sourceType, (BUnionType) targetType);\n-            } else if (targetType.tag == TypeTags.ANYDATA) {\n-                generateCheckCastJToBAnyData(mv, indexMap, sourceType);\n-            } else if (targetType.tag == TypeTags.HANDLE) {\n-                generateJCastToBHandle(mv, sourceType);\n-            } else if (targetType.tag == TypeTags.ANY) {\n-                generateJCastToBAny(mv, indexMap, sourceType, targetType);\n-            } else if (targetType.tag == TypeTags.JSON) {\n-                generateCheckCastJToBJSON(mv, indexMap, sourceType);\n-            } else if (targetType.tag == TypeTags.FINITE) {\n-                generateCheckCastJToBFiniteType(mv, indexMap, sourceType, targetType);\n-                // TODO fix below properly - rajith\n-                //} else if (sourceType is bir:BXMLType && targetType is bir:BMapType) {\n-                //    generateXMLToAttributesMap(mv, sourceType);\n-                //    return;\n-                //} else if (targetType is bir:BFiniteType) {\n-                //    generateCheckCastToFiniteType(mv, sourceType, targetType);\n-                //    return;\n-                //} else if (sourceType is bir:BRecordType && (targetType is bir:BMapType && targetType.constraint\n-                // is bir:BTypeAny)) {\n-                //    // do nothing\n-            }\n+            return;\n+        }\n \n-            checkCast(mv, targetType);\n-            String targetTypeClass = getTargetClass(targetType);\n-            if (targetTypeClass != null) {\n-                mv.visitTypeInsn(CHECKCAST, targetTypeClass);\n-            }\n+        switch (targetType.tag) {\n+            case TypeTags.FLOAT:\n+                generateCheckCastJToBFloat(mv, sourceType);\n+                break;\n+            case TypeTags.DECIMAL:\n+                generateCheckCastJToBDecimal(mv, sourceType);\n+                break;\n+            case TypeTags.BOOLEAN:\n+                generateCheckCastJToBBoolean(mv, sourceType);\n+                break;\n+            case TypeTags.BYTE:\n+                generateCheckCastJToBByte(mv, sourceType);\n+                break;\n+            case TypeTags.NIL:\n+            case TypeTags.NEVER:\n+                // Do nothing\n+                break;\n+            default:\n+                switch (targetType.tag) {\n+                    case TypeTags.UNION:\n+                        generateCheckCastJToBUnionType(mv, indexMap, sourceType, (BUnionType) targetType);\n+                        break;\n+                    case TypeTags.ANYDATA:\n+                        generateCheckCastJToBAnyData(mv, indexMap, sourceType);\n+                        break;\n+                    case TypeTags.HANDLE:\n+                        generateJCastToBHandle(mv, sourceType);\n+                        break;\n+                    case TypeTags.ANY:\n+                        generateJCastToBAny(mv, indexMap, sourceType, targetType);\n+                        break;\n+                    case TypeTags.JSON:\n+                        generateCheckCastJToBJSON(mv, indexMap, sourceType);\n+                        break;\n+                    case TypeTags.FINITE:\n+                        generateCheckCastJToBFiniteType(mv, indexMap, sourceType, targetType);\n+                        // TODO fix below properly - rajith\n+                        //} else if (sourceType is bir:BXMLType && targetType is bir:BMapType) {\n+                        //    generateXMLToAttributesMap(mv, sourceType);\n+                        //    return;\n+                        //} else if (targetType is bir:BFiniteType) {\n+                        //    generateCheckCastToFiniteType(mv, sourceType, targetType);\n+                        //    return;\n+                        //} else if (sourceType is bir:BRecordType && (targetType is bir:BMapType &&\n+                        // targetType.constraint\n+                        // is bir:BTypeAny)) {\n+                        //    // do nothing", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca9ab9ba06e4614fe16b9340155316da79893968"}, "originalPosition": 444}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5OTc1MjgwOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/codegen/JvmCastGen.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxODowNDoyNVrOGsYKGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxODowNDoyNVrOGsYKGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE4NjMyOA==", "bodyText": "Shall we remove commented code?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24508#discussion_r449186328", "createdAt": "2020-07-02T18:04:25Z", "author": {"login": "riyafa"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/codegen/JvmCastGen.java", "diffHunk": "@@ -310,122 +379,174 @@ private static void generateJToBCheckCast(MethodVisitor mv, BIRVarToJVMIndexMap\n \n         if (TypeTags.isIntegerTypeTag(targetType.tag)) {\n             generateCheckCastJToBInt(mv, sourceType);\n-        } else if (targetType.tag == TypeTags.FLOAT) {\n-            generateCheckCastJToBFloat(mv, sourceType);\n-        } else if (targetType.tag == TypeTags.DECIMAL) {\n-            generateCheckCastJToBDecimal(mv, sourceType);\n-        } else if (targetType.tag == TypeTags.BOOLEAN) {\n-            generateCheckCastJToBBoolean(mv, sourceType);\n-        } else if (targetType.tag == TypeTags.BYTE) {\n-            generateCheckCastJToBByte(mv, sourceType);\n-        } else if (targetType.tag == TypeTags.NIL || targetType.tag == TypeTags.NEVER) {\n-            // Do nothing\n-        } else {\n-            if (targetType.tag == TypeTags.UNION) {\n-                generateCheckCastJToBUnionType(mv, indexMap, sourceType, (BUnionType) targetType);\n-            } else if (targetType.tag == TypeTags.ANYDATA) {\n-                generateCheckCastJToBAnyData(mv, indexMap, sourceType);\n-            } else if (targetType.tag == TypeTags.HANDLE) {\n-                generateJCastToBHandle(mv, sourceType);\n-            } else if (targetType.tag == TypeTags.ANY) {\n-                generateJCastToBAny(mv, indexMap, sourceType, targetType);\n-            } else if (targetType.tag == TypeTags.JSON) {\n-                generateCheckCastJToBJSON(mv, indexMap, sourceType);\n-            } else if (targetType.tag == TypeTags.FINITE) {\n-                generateCheckCastJToBFiniteType(mv, indexMap, sourceType, targetType);\n-                // TODO fix below properly - rajith\n-                //} else if (sourceType is bir:BXMLType && targetType is bir:BMapType) {\n-                //    generateXMLToAttributesMap(mv, sourceType);\n-                //    return;\n-                //} else if (targetType is bir:BFiniteType) {\n-                //    generateCheckCastToFiniteType(mv, sourceType, targetType);\n-                //    return;\n-                //} else if (sourceType is bir:BRecordType && (targetType is bir:BMapType && targetType.constraint\n-                // is bir:BTypeAny)) {\n-                //    // do nothing\n-            }\n+            return;\n+        }\n \n-            checkCast(mv, targetType);\n-            String targetTypeClass = getTargetClass(targetType);\n-            if (targetTypeClass != null) {\n-                mv.visitTypeInsn(CHECKCAST, targetTypeClass);\n-            }\n+        switch (targetType.tag) {\n+            case TypeTags.FLOAT:\n+                generateCheckCastJToBFloat(mv, sourceType);\n+                break;\n+            case TypeTags.DECIMAL:\n+                generateCheckCastJToBDecimal(mv, sourceType);\n+                break;\n+            case TypeTags.BOOLEAN:\n+                generateCheckCastJToBBoolean(mv, sourceType);\n+                break;\n+            case TypeTags.BYTE:\n+                generateCheckCastJToBByte(mv, sourceType);\n+                break;\n+            case TypeTags.NIL:\n+            case TypeTags.NEVER:\n+                // Do nothing\n+                break;\n+            default:\n+                switch (targetType.tag) {\n+                    case TypeTags.UNION:\n+                        generateCheckCastJToBUnionType(mv, indexMap, sourceType, (BUnionType) targetType);\n+                        break;\n+                    case TypeTags.ANYDATA:\n+                        generateCheckCastJToBAnyData(mv, indexMap, sourceType);\n+                        break;\n+                    case TypeTags.HANDLE:\n+                        generateJCastToBHandle(mv, sourceType);\n+                        break;\n+                    case TypeTags.ANY:\n+                        generateJCastToBAny(mv, indexMap, sourceType, targetType);\n+                        break;\n+                    case TypeTags.JSON:\n+                        generateCheckCastJToBJSON(mv, indexMap, sourceType);\n+                        break;\n+                    case TypeTags.FINITE:\n+                        generateCheckCastJToBFiniteType(mv, indexMap, sourceType, targetType);\n+                        // TODO fix below properly - rajith\n+                        //} else if (sourceType is bir:BXMLType && targetType is bir:BMapType) {\n+                        //    generateXMLToAttributesMap(mv, sourceType);\n+                        //    return;\n+                        //} else if (targetType is bir:BFiniteType) {\n+                        //    generateCheckCastToFiniteType(mv, sourceType, targetType);\n+                        //    return;\n+                        //} else if (sourceType is bir:BRecordType && (targetType is bir:BMapType &&\n+                        // targetType.constraint\n+                        // is bir:BTypeAny)) {\n+                        //    // do nothing\n+                        break;\n+                }\n+\n+                checkCast(mv, targetType);\n+                String targetTypeClass = getTargetClass(targetType);\n+                if (targetTypeClass != null) {\n+                    mv.visitTypeInsn(CHECKCAST, targetTypeClass);\n+                }\n+                break;\n         }\n     }\n \n     private static void generateCheckCastJToBInt(MethodVisitor mv, JType sourceType) {\n \n-        if (sourceType.jTag == JTypeTags.JBYTE) {\n-            mv.visitInsn(I2B);\n-            mv.visitMethodInsn(INVOKESTATIC, \"java/lang/Byte\", \"toUnsignedInt\", \"(B)I\", false);\n-            mv.visitInsn(I2L);\n-        } else if (sourceType.jTag == JTypeTags.JCHAR) {\n-            mv.visitInsn(I2L);\n-        } else if (sourceType.jTag == JTypeTags.JSHORT) {\n-            mv.visitInsn(I2L);\n-        } else if (sourceType.jTag == JTypeTags.JINT) {\n-            mv.visitInsn(I2L);\n-        } else if (sourceType.jTag == JTypeTags.JLONG) {\n-            // do nothing\n-            // According to the spec doc, below two are not needed\n-            // } else if (sourceType is jvm:JFloat) {\n-            //     mv.visitMethodInsn(INVOKESTATIC, TYPE_CONVERTER, \"jFloatToBInt\", \"(F)J\", false);\n-            // } else if (sourceType is jvm:JDouble) {\n-            //     mv.visitMethodInsn(INVOKESTATIC, TYPE_CONVERTER, \"jDoubleToBInt\", \"(D)J\", false);\n-        } else if (sourceType.jTag == JTypeTags.JREF) {\n-            mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, \"anyToJLong\", String.format(\"(L%s;)J\", OBJECT), false);\n-        } else {\n-            throw new BLangCompilerException(String.format(\"Casting is not supported from '%s' to 'int'\", sourceType));\n+        switch (sourceType.jTag) {\n+            case JTypeTags.JBYTE:\n+                mv.visitInsn(I2B);\n+                mv.visitMethodInsn(INVOKESTATIC, \"java/lang/Byte\", \"toUnsignedInt\", \"(B)I\", false);\n+                mv.visitInsn(I2L);\n+                break;\n+            case JTypeTags.JCHAR:\n+                mv.visitInsn(I2L);\n+                break;\n+            case JTypeTags.JSHORT:\n+                mv.visitInsn(I2L);\n+                break;\n+            case JTypeTags.JINT:\n+                mv.visitInsn(I2L);\n+                break;\n+            case JTypeTags.JLONG:\n+                // do nothing\n+                // According to the spec doc, below two are not needed\n+                // } else if (sourceType is jvm:JFloat) {\n+                //     mv.visitMethodInsn(INVOKESTATIC, TYPE_CONVERTER, \"jFloatToBInt\", \"(F)J\", false);\n+                // } else if (sourceType is jvm:JDouble) {\n+                //     mv.visitMethodInsn(INVOKESTATIC, TYPE_CONVERTER, \"jDoubleToBInt\", \"(D)J\", false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca9ab9ba06e4614fe16b9340155316da79893968"}, "originalPosition": 501}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3305, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}