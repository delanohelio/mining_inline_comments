{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE2NjY4NzA2", "number": 23178, "title": "Add query expression parsing", "bodyText": "Purpose\n\nAdd query expression support\n\nFixes #23093\nApproach\n\nN/A\n\nSamples\n\nN/A\n\nRemarks\n\nN/A\n\nCheck List\n\n Read the Contributing Guide\n Updated Change Log\n Checked Tooling Support (#)\n Added necessary tests\n\n Unit Tests\n Spec Conformance Tests\n Integration Tests\n Ballerina By Example Tests\n\n\n Increased Test Coverage\n Added necessary documentation\n\n API documentation\n Module documentation in Module.md files\n Ballerina By Examples", "createdAt": "2020-05-12T11:38:19Z", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23178", "merged": true, "mergeCommit": {"oid": "de3ab9a81e69b1b908ddab63bd893f121b31017d"}, "closed": true, "closedAt": "2020-05-15T01:55:09Z", "author": {"login": "lochana-chathura"}, "timelineItems": {"totalCount": 30, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABceQvnZAH2gAyNDE2NjY4NzA2OjQxZjM5NmI5NTQ5ODU2ZjZiMWJlMWY2ZGQzNGIxNzRiMGY4MjRjMGY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABchQG-cgH2gAyNDE2NjY4NzA2OmI4OGQ0ZGM5ZDFkMjJhNThkNjkyMTcwMDY3MWRkMjQ5ZTNhOTQwZDg=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "41f396b9549856f6b1be1f6dd34b174b0f824c0f", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/41f396b9549856f6b1be1f6dd34b174b0f824c0f", "committedDate": "2020-05-05T09:34:18Z", "message": "Update syntax_tree_descriptor.json"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bee6d2ca5872c5c6434a891a0bef2041fa5266de", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/bee6d2ca5872c5c6434a891a0bef2041fa5266de", "committedDate": "2020-05-05T09:39:30Z", "message": "Generate tree"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0f06ca6267fe9b9267463b30d50603234f9014e5", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/0f06ca6267fe9b9267463b30d50603234f9014e5", "committedDate": "2020-05-06T03:46:09Z", "message": "Add query expression support"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5855abc13a03fcdc881be5abb1e8c5a0c1e5d95b", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/5855abc13a03fcdc881be5abb1e8c5a0c1e5d95b", "committedDate": "2020-05-06T07:39:51Z", "message": "Add syntax validation test cases"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "68663480ddcd2a3b5efa1b3848a749af546f4b7d", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/68663480ddcd2a3b5efa1b3848a749af546f4b7d", "committedDate": "2020-05-11T16:49:09Z", "message": "Refactor table constructor and query expression parsing"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "16f16ad58f050c8fff5f2b0d626f8a3c1df58afa", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/16f16ad58f050c8fff5f2b0d626f8a3c1df58afa", "committedDate": "2020-05-11T17:16:24Z", "message": "Add error recovery"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3445e41399deff2540c0be629c06cd80cfbd45be", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3445e41399deff2540c0be629c06cd80cfbd45be", "committedDate": "2020-05-11T17:27:20Z", "message": "Add error recovery test cases"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ca091501ebb22f7b8b166902a5c13e3afef11eb4", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/ca091501ebb22f7b8b166902a5c13e3afef11eb4", "committedDate": "2020-05-11T17:45:37Z", "message": "Fix check styles"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "50ef8e3f7d0c4d861e575ed04a1544e1d5089ef2", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/50ef8e3f7d0c4d861e575ed04a1544e1d5089ef2", "committedDate": "2020-05-12T05:37:52Z", "message": "Add more test cases for query expression"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "60fc594e277866e21e2094fc7ac41bfd8e76122a", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/60fc594e277866e21e2094fc7ac41bfd8e76122a", "committedDate": "2020-05-12T08:57:00Z", "message": "Merge branch 'incremental-parser' of https://github.com/ballerina-platform/ballerina-lang into query-expr-support\n\n\u0001 Conflicts:\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaLexer.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/LexerTerminals.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/ParserRuleContext.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/tree/STNodeFactory.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/syntax/tree/NodeFactory.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/syntax/tree/NodeTransformer.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/syntax/tree/NodeVisitor.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/syntax/tree/SyntaxKind.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/syntax/tree/TreeModifier.java\n\u0001\tcompiler/ballerina-parser/src/test/java/io/ballerinalang/compiler/parser/test/ParserTestUtils.java\n\u0001\tcompiler/ballerina-treegen/src/main/resources/syntax_tree_descriptor.json"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3e897455d8085236a1bb3fa30c3ff5fd408b6c0a", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3e897455d8085236a1bb3fa30c3ff5fd408b6c0a", "committedDate": "2020-05-12T09:02:17Z", "message": "Regenerate tree after merging"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a4249e56f01cdb4b5053444425a336689e281d90", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a4249e56f01cdb4b5053444425a336689e281d90", "committedDate": "2020-05-12T11:28:38Z", "message": "Initiate a context at the beginning of table constructor or query expr parsing"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ef17aa5d354e4a6398004a2e09cbfe5dfd57fe72", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/ef17aa5d354e4a6398004a2e09cbfe5dfd57fe72", "committedDate": "2020-05-12T12:29:38Z", "message": "Fix spaces"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f14dc7b3bd5a199c5440606c5d20bcd8c32cd3af", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f14dc7b3bd5a199c5440606c5d20bcd8c32cd3af", "committedDate": "2020-05-12T13:03:05Z", "message": "Merge branch 'incremental-parser' of https://github.com/ballerina-platform/ballerina-lang into query-expr-support\n\n\u0001 Conflicts:\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/ParserRuleContext.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/tree/STNodeFactory.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/syntax/tree/NodeFactory.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/syntax/tree/NodeTransformer.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/syntax/tree/NodeVisitor.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/syntax/tree/TreeModifier.java\n\u0001\tcompiler/ballerina-treegen/src/main/resources/syntax_tree_descriptor.json"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "07f85694db33c10a31405ba99c452119dfa33520", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/07f85694db33c10a31405ba99c452119dfa33520", "committedDate": "2020-05-12T13:33:36Z", "message": "Regenerate tree after merging"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e36e0403c39213b5761bcd15bea21abc38e8c087", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e36e0403c39213b5761bcd15bea21abc38e8c087", "committedDate": "2020-05-12T13:56:16Z", "message": "Fix indentation"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEwNTU1MzYy", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23178#pullrequestreview-410555362", "createdAt": "2020-05-13T03:00:33Z", "commit": {"oid": "e36e0403c39213b5761bcd15bea21abc38e8c087"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwMzowMDozM1rOGUf0pA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwMzozMzoxMFrOGUgRHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE0NjA4NA==", "bodyText": "We can extract the content inside the while loop to a method. That method simply parse and returns a clause. We have done a similar thing in the parseFollowUpArg() method.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23178#discussion_r424146084", "createdAt": "2020-05-13T03:00:33Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -8185,4 +8166,295 @@ private boolean isEndOfTypeList(SyntaxKind nextTokenKind) {\n     private STNode parseTupleRestTypeDesc() {\n         return STNodeFactory.createEmptyNode();\n     }\n+\n+    /**\n+     * Parse table constructor or query expression.\n+     * <p>\n+     * <code>\n+     * table-constructor-or-query-expr := table-constructor-expr | query-expr\n+     * <br/>\n+     * table-constructor-expr := table [key-specifier] [ [row-list] ]\n+     * <br/>\n+     * query-expr := [query-construct-type] query-pipeline select-clause\n+     * <br/>\n+     * query-construct-type := table key-specifier | stream\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+\n+    private STNode parseTableConstructorOrQuery() {\n+        startContext(ParserRuleContext.TABLE_CONSTRUCTOR_OR_QUERY_EXPRESSION);\n+        return parseTableConstructorOrQuery(peek().kind);\n+    }\n+\n+    private STNode parseTableConstructorOrQuery(SyntaxKind nextTokenKind) {\n+        STNode queryConstructType;\n+        switch (nextTokenKind) {\n+            case FROM_KEYWORD:\n+                queryConstructType = STNodeFactory.createEmptyNode();\n+                return parseQueryExprRhs(queryConstructType);\n+            case STREAM_KEYWORD:\n+                queryConstructType = parseStreamKeyword();\n+                return parseQueryExprRhs(queryConstructType);\n+            case TABLE_KEYWORD:\n+                STNode tableKeyword = parseTableKeyword();\n+                STNode keySpecifier = STNodeFactory.createEmptyNode();\n+                return parseTableConstructorOrQuery(tableKeyword, keySpecifier);\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.TABLE_CONSTRUCTOR_OR_QUERY_START);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseTableConstructorOrQuery(solution.tokenKind);\n+        }\n+\n+    }\n+\n+    private STNode parseTableConstructorOrQuery(STNode tableKeyword, STNode keySpecifier) {\n+        return parseTableConstructorOrQuery(peek().kind, tableKeyword, keySpecifier);\n+    }\n+\n+    private STNode parseTableConstructorOrQuery(SyntaxKind nextTokenKind, STNode tableKeyword, STNode keySpecifier) {\n+        switch (nextTokenKind) {\n+            case OPEN_BRACKET_TOKEN:\n+                return parseTableConstructorExprRhs(tableKeyword, keySpecifier);\n+            case KEY_KEYWORD:\n+                keySpecifier = parseKeySpecifier();\n+                return parseTableConstructorOrQueryRhs(peek().kind, tableKeyword, keySpecifier);\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.TABLE_KEYWORD_RHS, tableKeyword, keySpecifier);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseTableConstructorOrQuery(solution.tokenKind, tableKeyword, keySpecifier);\n+        }\n+    }\n+\n+    private STNode parseTableConstructorOrQueryRhs(STNode tableKeyword, STNode keySpecifier) {\n+        return parseTableConstructorOrQueryRhs(peek().kind, tableKeyword, keySpecifier);\n+    }\n+\n+    private STNode parseTableConstructorOrQueryRhs(SyntaxKind nextTokenKind, STNode tableKeyword, STNode keySpecifier) {\n+        switch (nextTokenKind) {\n+            case FROM_KEYWORD:\n+                return parseQueryExprRhs(parseQueryConstructType(tableKeyword, keySpecifier));\n+            case OPEN_BRACKET_TOKEN:\n+                return parseTableConstructorExprRhs(tableKeyword, keySpecifier);\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.TABLE_CONSTRUCTOR_OR_QUERY_RHS,\n+                    tableKeyword, keySpecifier);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseTableConstructorOrQueryRhs(solution.tokenKind, tableKeyword, keySpecifier);\n+        }\n+    }\n+\n+    /**\n+     * Parse query expression.\n+     * <code>query-expr-rhs := query-pipeline select-clause</code>\n+     *\n+     * @param queryConstructType queryConstructType that precedes this rhs\n+     * @return Parsed node\n+     */\n+    private STNode parseQueryExprRhs(STNode queryConstructType) {\n+        switchContext(ParserRuleContext.QUERY_EXPRESSION);\n+        STNode queryPipeline = parseQueryPipeline();\n+        STNode selectClause = parseSelectClause();;\n+        endContext();\n+        return STNodeFactory.createQueryExpressionNode(queryConstructType, queryPipeline, selectClause);\n+    }\n+\n+    /**\n+     * Parse query construct type.\n+     * <p>\n+     * <code>query-construct-type := table key-specifier</code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseQueryConstructType(STNode tableKeyword, STNode keySpecifier) {\n+        return STNodeFactory.createQueryConstructTypeNode(tableKeyword, keySpecifier);\n+    }\n+\n+    /**\n+     * Parse query pipeline.\n+     * <p>\n+     * <code>\n+     * query-pipeline := from-clause intermediate-clause*\n+     * <br/>\n+     * intermediate-clause := from-clause | where-clause | let-clause\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseQueryPipeline() {\n+        STNode fromClause = parseFromClause();\n+        List<STNode> clauses = new ArrayList<>();\n+        return parseQueryPipeline(fromClause, clauses);\n+    }\n+\n+    private STNode parseQueryPipeline(STNode fromClause, List<STNode> clauses) {\n+        return parseQueryPipeline(peek().kind, fromClause, clauses);\n+    }\n+    private STNode parseQueryPipeline(SyntaxKind nextTokenKind, STNode fromClause, List<STNode> clauses) {\n+        STNode clause;\n+\n+        while (true) {\n+            switch (nextTokenKind) {\n+                case FROM_KEYWORD:\n+                    clause = parseFromClause();\n+                    clauses.add(clause);\n+                    nextTokenKind = peek().kind;\n+                    continue;\n+                case WHERE_KEYWORD:\n+                    clause = parseWhereClause();\n+                    clauses.add(clause);\n+                    nextTokenKind = peek().kind;\n+                    continue;\n+                case LET_KEYWORD:\n+                    clause = parseLetClause();\n+                    clauses.add(clause);\n+                    nextTokenKind = peek().kind;\n+                    continue;\n+                case SELECT_KEYWORD:\n+                    break;\n+                default:\n+                    if (nextTokenKind == SyntaxKind.EOF_TOKEN) {\n+                        return parseQueryPipeline(SyntaxKind.SELECT_KEYWORD, fromClause, clauses);\n+                    }\n+\n+                    Solution solution = recover(peek(), ParserRuleContext.QUERY_EXPRESSION_RHS, fromClause, clauses);\n+\n+                    // If the parser recovered by inserting a token, then try to re-parse the same\n+                    // rule with the inserted token. This is done to pick the correct branch\n+                    // to continue the parsing.\n+                    if (solution.action == Action.REMOVE) {\n+                        return solution.recoveredNode;\n+                    }\n+\n+                    return parseQueryPipeline(solution.tokenKind, fromClause, clauses);\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e36e0403c39213b5761bcd15bea21abc38e8c087"}, "originalPosition": 443}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE0NzAwOQ==", "bodyText": "Extra semicolon", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23178#discussion_r424147009", "createdAt": "2020-05-13T03:04:21Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -8185,4 +8166,295 @@ private boolean isEndOfTypeList(SyntaxKind nextTokenKind) {\n     private STNode parseTupleRestTypeDesc() {\n         return STNodeFactory.createEmptyNode();\n     }\n+\n+    /**\n+     * Parse table constructor or query expression.\n+     * <p>\n+     * <code>\n+     * table-constructor-or-query-expr := table-constructor-expr | query-expr\n+     * <br/>\n+     * table-constructor-expr := table [key-specifier] [ [row-list] ]\n+     * <br/>\n+     * query-expr := [query-construct-type] query-pipeline select-clause\n+     * <br/>\n+     * query-construct-type := table key-specifier | stream\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+\n+    private STNode parseTableConstructorOrQuery() {\n+        startContext(ParserRuleContext.TABLE_CONSTRUCTOR_OR_QUERY_EXPRESSION);\n+        return parseTableConstructorOrQuery(peek().kind);\n+    }\n+\n+    private STNode parseTableConstructorOrQuery(SyntaxKind nextTokenKind) {\n+        STNode queryConstructType;\n+        switch (nextTokenKind) {\n+            case FROM_KEYWORD:\n+                queryConstructType = STNodeFactory.createEmptyNode();\n+                return parseQueryExprRhs(queryConstructType);\n+            case STREAM_KEYWORD:\n+                queryConstructType = parseStreamKeyword();\n+                return parseQueryExprRhs(queryConstructType);\n+            case TABLE_KEYWORD:\n+                STNode tableKeyword = parseTableKeyword();\n+                STNode keySpecifier = STNodeFactory.createEmptyNode();\n+                return parseTableConstructorOrQuery(tableKeyword, keySpecifier);\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.TABLE_CONSTRUCTOR_OR_QUERY_START);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseTableConstructorOrQuery(solution.tokenKind);\n+        }\n+\n+    }\n+\n+    private STNode parseTableConstructorOrQuery(STNode tableKeyword, STNode keySpecifier) {\n+        return parseTableConstructorOrQuery(peek().kind, tableKeyword, keySpecifier);\n+    }\n+\n+    private STNode parseTableConstructorOrQuery(SyntaxKind nextTokenKind, STNode tableKeyword, STNode keySpecifier) {\n+        switch (nextTokenKind) {\n+            case OPEN_BRACKET_TOKEN:\n+                return parseTableConstructorExprRhs(tableKeyword, keySpecifier);\n+            case KEY_KEYWORD:\n+                keySpecifier = parseKeySpecifier();\n+                return parseTableConstructorOrQueryRhs(peek().kind, tableKeyword, keySpecifier);\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.TABLE_KEYWORD_RHS, tableKeyword, keySpecifier);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseTableConstructorOrQuery(solution.tokenKind, tableKeyword, keySpecifier);\n+        }\n+    }\n+\n+    private STNode parseTableConstructorOrQueryRhs(STNode tableKeyword, STNode keySpecifier) {\n+        return parseTableConstructorOrQueryRhs(peek().kind, tableKeyword, keySpecifier);\n+    }\n+\n+    private STNode parseTableConstructorOrQueryRhs(SyntaxKind nextTokenKind, STNode tableKeyword, STNode keySpecifier) {\n+        switch (nextTokenKind) {\n+            case FROM_KEYWORD:\n+                return parseQueryExprRhs(parseQueryConstructType(tableKeyword, keySpecifier));\n+            case OPEN_BRACKET_TOKEN:\n+                return parseTableConstructorExprRhs(tableKeyword, keySpecifier);\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.TABLE_CONSTRUCTOR_OR_QUERY_RHS,\n+                    tableKeyword, keySpecifier);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseTableConstructorOrQueryRhs(solution.tokenKind, tableKeyword, keySpecifier);\n+        }\n+    }\n+\n+    /**\n+     * Parse query expression.\n+     * <code>query-expr-rhs := query-pipeline select-clause</code>\n+     *\n+     * @param queryConstructType queryConstructType that precedes this rhs\n+     * @return Parsed node\n+     */\n+    private STNode parseQueryExprRhs(STNode queryConstructType) {\n+        switchContext(ParserRuleContext.QUERY_EXPRESSION);\n+        STNode queryPipeline = parseQueryPipeline();\n+        STNode selectClause = parseSelectClause();;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e36e0403c39213b5761bcd15bea21abc38e8c087"}, "originalPosition": 370}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE0Nzc3NQ==", "bodyText": "This is a bit dangerous, as we may get stuck in an infinite loop. Better to do a while(!isEndOfExpression())", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23178#discussion_r424147775", "createdAt": "2020-05-13T03:07:47Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -8185,4 +8166,295 @@ private boolean isEndOfTypeList(SyntaxKind nextTokenKind) {\n     private STNode parseTupleRestTypeDesc() {\n         return STNodeFactory.createEmptyNode();\n     }\n+\n+    /**\n+     * Parse table constructor or query expression.\n+     * <p>\n+     * <code>\n+     * table-constructor-or-query-expr := table-constructor-expr | query-expr\n+     * <br/>\n+     * table-constructor-expr := table [key-specifier] [ [row-list] ]\n+     * <br/>\n+     * query-expr := [query-construct-type] query-pipeline select-clause\n+     * <br/>\n+     * query-construct-type := table key-specifier | stream\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+\n+    private STNode parseTableConstructorOrQuery() {\n+        startContext(ParserRuleContext.TABLE_CONSTRUCTOR_OR_QUERY_EXPRESSION);\n+        return parseTableConstructorOrQuery(peek().kind);\n+    }\n+\n+    private STNode parseTableConstructorOrQuery(SyntaxKind nextTokenKind) {\n+        STNode queryConstructType;\n+        switch (nextTokenKind) {\n+            case FROM_KEYWORD:\n+                queryConstructType = STNodeFactory.createEmptyNode();\n+                return parseQueryExprRhs(queryConstructType);\n+            case STREAM_KEYWORD:\n+                queryConstructType = parseStreamKeyword();\n+                return parseQueryExprRhs(queryConstructType);\n+            case TABLE_KEYWORD:\n+                STNode tableKeyword = parseTableKeyword();\n+                STNode keySpecifier = STNodeFactory.createEmptyNode();\n+                return parseTableConstructorOrQuery(tableKeyword, keySpecifier);\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.TABLE_CONSTRUCTOR_OR_QUERY_START);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseTableConstructorOrQuery(solution.tokenKind);\n+        }\n+\n+    }\n+\n+    private STNode parseTableConstructorOrQuery(STNode tableKeyword, STNode keySpecifier) {\n+        return parseTableConstructorOrQuery(peek().kind, tableKeyword, keySpecifier);\n+    }\n+\n+    private STNode parseTableConstructorOrQuery(SyntaxKind nextTokenKind, STNode tableKeyword, STNode keySpecifier) {\n+        switch (nextTokenKind) {\n+            case OPEN_BRACKET_TOKEN:\n+                return parseTableConstructorExprRhs(tableKeyword, keySpecifier);\n+            case KEY_KEYWORD:\n+                keySpecifier = parseKeySpecifier();\n+                return parseTableConstructorOrQueryRhs(peek().kind, tableKeyword, keySpecifier);\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.TABLE_KEYWORD_RHS, tableKeyword, keySpecifier);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseTableConstructorOrQuery(solution.tokenKind, tableKeyword, keySpecifier);\n+        }\n+    }\n+\n+    private STNode parseTableConstructorOrQueryRhs(STNode tableKeyword, STNode keySpecifier) {\n+        return parseTableConstructorOrQueryRhs(peek().kind, tableKeyword, keySpecifier);\n+    }\n+\n+    private STNode parseTableConstructorOrQueryRhs(SyntaxKind nextTokenKind, STNode tableKeyword, STNode keySpecifier) {\n+        switch (nextTokenKind) {\n+            case FROM_KEYWORD:\n+                return parseQueryExprRhs(parseQueryConstructType(tableKeyword, keySpecifier));\n+            case OPEN_BRACKET_TOKEN:\n+                return parseTableConstructorExprRhs(tableKeyword, keySpecifier);\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.TABLE_CONSTRUCTOR_OR_QUERY_RHS,\n+                    tableKeyword, keySpecifier);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseTableConstructorOrQueryRhs(solution.tokenKind, tableKeyword, keySpecifier);\n+        }\n+    }\n+\n+    /**\n+     * Parse query expression.\n+     * <code>query-expr-rhs := query-pipeline select-clause</code>\n+     *\n+     * @param queryConstructType queryConstructType that precedes this rhs\n+     * @return Parsed node\n+     */\n+    private STNode parseQueryExprRhs(STNode queryConstructType) {\n+        switchContext(ParserRuleContext.QUERY_EXPRESSION);\n+        STNode queryPipeline = parseQueryPipeline();\n+        STNode selectClause = parseSelectClause();;\n+        endContext();\n+        return STNodeFactory.createQueryExpressionNode(queryConstructType, queryPipeline, selectClause);\n+    }\n+\n+    /**\n+     * Parse query construct type.\n+     * <p>\n+     * <code>query-construct-type := table key-specifier</code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseQueryConstructType(STNode tableKeyword, STNode keySpecifier) {\n+        return STNodeFactory.createQueryConstructTypeNode(tableKeyword, keySpecifier);\n+    }\n+\n+    /**\n+     * Parse query pipeline.\n+     * <p>\n+     * <code>\n+     * query-pipeline := from-clause intermediate-clause*\n+     * <br/>\n+     * intermediate-clause := from-clause | where-clause | let-clause\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseQueryPipeline() {\n+        STNode fromClause = parseFromClause();\n+        List<STNode> clauses = new ArrayList<>();\n+        return parseQueryPipeline(fromClause, clauses);\n+    }\n+\n+    private STNode parseQueryPipeline(STNode fromClause, List<STNode> clauses) {\n+        return parseQueryPipeline(peek().kind, fromClause, clauses);\n+    }\n+    private STNode parseQueryPipeline(SyntaxKind nextTokenKind, STNode fromClause, List<STNode> clauses) {\n+        STNode clause;\n+\n+        while (true) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e36e0403c39213b5761bcd15bea21abc38e8c087"}, "originalPosition": 409}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE0ODE0Mg==", "bodyText": "We can see if there are more clauses after the select clause as well, and give an error.\nCan do the same thing as in parseQueryPipeline, but simply log and error.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23178#discussion_r424148142", "createdAt": "2020-05-13T03:09:22Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -8185,4 +8166,295 @@ private boolean isEndOfTypeList(SyntaxKind nextTokenKind) {\n     private STNode parseTupleRestTypeDesc() {\n         return STNodeFactory.createEmptyNode();\n     }\n+\n+    /**\n+     * Parse table constructor or query expression.\n+     * <p>\n+     * <code>\n+     * table-constructor-or-query-expr := table-constructor-expr | query-expr\n+     * <br/>\n+     * table-constructor-expr := table [key-specifier] [ [row-list] ]\n+     * <br/>\n+     * query-expr := [query-construct-type] query-pipeline select-clause\n+     * <br/>\n+     * query-construct-type := table key-specifier | stream\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+\n+    private STNode parseTableConstructorOrQuery() {\n+        startContext(ParserRuleContext.TABLE_CONSTRUCTOR_OR_QUERY_EXPRESSION);\n+        return parseTableConstructorOrQuery(peek().kind);\n+    }\n+\n+    private STNode parseTableConstructorOrQuery(SyntaxKind nextTokenKind) {\n+        STNode queryConstructType;\n+        switch (nextTokenKind) {\n+            case FROM_KEYWORD:\n+                queryConstructType = STNodeFactory.createEmptyNode();\n+                return parseQueryExprRhs(queryConstructType);\n+            case STREAM_KEYWORD:\n+                queryConstructType = parseStreamKeyword();\n+                return parseQueryExprRhs(queryConstructType);\n+            case TABLE_KEYWORD:\n+                STNode tableKeyword = parseTableKeyword();\n+                STNode keySpecifier = STNodeFactory.createEmptyNode();\n+                return parseTableConstructorOrQuery(tableKeyword, keySpecifier);\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.TABLE_CONSTRUCTOR_OR_QUERY_START);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseTableConstructorOrQuery(solution.tokenKind);\n+        }\n+\n+    }\n+\n+    private STNode parseTableConstructorOrQuery(STNode tableKeyword, STNode keySpecifier) {\n+        return parseTableConstructorOrQuery(peek().kind, tableKeyword, keySpecifier);\n+    }\n+\n+    private STNode parseTableConstructorOrQuery(SyntaxKind nextTokenKind, STNode tableKeyword, STNode keySpecifier) {\n+        switch (nextTokenKind) {\n+            case OPEN_BRACKET_TOKEN:\n+                return parseTableConstructorExprRhs(tableKeyword, keySpecifier);\n+            case KEY_KEYWORD:\n+                keySpecifier = parseKeySpecifier();\n+                return parseTableConstructorOrQueryRhs(peek().kind, tableKeyword, keySpecifier);\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.TABLE_KEYWORD_RHS, tableKeyword, keySpecifier);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseTableConstructorOrQuery(solution.tokenKind, tableKeyword, keySpecifier);\n+        }\n+    }\n+\n+    private STNode parseTableConstructorOrQueryRhs(STNode tableKeyword, STNode keySpecifier) {\n+        return parseTableConstructorOrQueryRhs(peek().kind, tableKeyword, keySpecifier);\n+    }\n+\n+    private STNode parseTableConstructorOrQueryRhs(SyntaxKind nextTokenKind, STNode tableKeyword, STNode keySpecifier) {\n+        switch (nextTokenKind) {\n+            case FROM_KEYWORD:\n+                return parseQueryExprRhs(parseQueryConstructType(tableKeyword, keySpecifier));\n+            case OPEN_BRACKET_TOKEN:\n+                return parseTableConstructorExprRhs(tableKeyword, keySpecifier);\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.TABLE_CONSTRUCTOR_OR_QUERY_RHS,\n+                    tableKeyword, keySpecifier);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseTableConstructorOrQueryRhs(solution.tokenKind, tableKeyword, keySpecifier);\n+        }\n+    }\n+\n+    /**\n+     * Parse query expression.\n+     * <code>query-expr-rhs := query-pipeline select-clause</code>\n+     *\n+     * @param queryConstructType queryConstructType that precedes this rhs\n+     * @return Parsed node\n+     */\n+    private STNode parseQueryExprRhs(STNode queryConstructType) {\n+        switchContext(ParserRuleContext.QUERY_EXPRESSION);\n+        STNode queryPipeline = parseQueryPipeline();\n+        STNode selectClause = parseSelectClause();;\n+        endContext();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e36e0403c39213b5761bcd15bea21abc38e8c087"}, "originalPosition": 371}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE0OTEzMQ==", "bodyText": "We don't need to create an empty key-specifier and pass it.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23178#discussion_r424149131", "createdAt": "2020-05-13T03:13:47Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -8185,4 +8166,295 @@ private boolean isEndOfTypeList(SyntaxKind nextTokenKind) {\n     private STNode parseTupleRestTypeDesc() {\n         return STNodeFactory.createEmptyNode();\n     }\n+\n+    /**\n+     * Parse table constructor or query expression.\n+     * <p>\n+     * <code>\n+     * table-constructor-or-query-expr := table-constructor-expr | query-expr\n+     * <br/>\n+     * table-constructor-expr := table [key-specifier] [ [row-list] ]\n+     * <br/>\n+     * query-expr := [query-construct-type] query-pipeline select-clause\n+     * <br/>\n+     * query-construct-type := table key-specifier | stream\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+\n+    private STNode parseTableConstructorOrQuery() {\n+        startContext(ParserRuleContext.TABLE_CONSTRUCTOR_OR_QUERY_EXPRESSION);\n+        return parseTableConstructorOrQuery(peek().kind);\n+    }\n+\n+    private STNode parseTableConstructorOrQuery(SyntaxKind nextTokenKind) {\n+        STNode queryConstructType;\n+        switch (nextTokenKind) {\n+            case FROM_KEYWORD:\n+                queryConstructType = STNodeFactory.createEmptyNode();\n+                return parseQueryExprRhs(queryConstructType);\n+            case STREAM_KEYWORD:\n+                queryConstructType = parseStreamKeyword();\n+                return parseQueryExprRhs(queryConstructType);\n+            case TABLE_KEYWORD:\n+                STNode tableKeyword = parseTableKeyword();\n+                STNode keySpecifier = STNodeFactory.createEmptyNode();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e36e0403c39213b5761bcd15bea21abc38e8c087"}, "originalPosition": 293}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE1MDk1NA==", "bodyText": "We can switch the context at the point where we give QUERY_EXPRESSION / TABLE_CONSTRUCTOR as the next rule.\nNot a big issue though, just thought it would be slightly clear for a reader.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23178#discussion_r424150954", "createdAt": "2020-05-13T03:22:00Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -1454,6 +1495,15 @@ protected ParserRuleContext getNextRule(ParserRuleContext currentCtx, int nextLo\n                 break;\n         }\n \n+        switch (currentCtx) {\n+            case TABLE_CONSTRUCTOR:\n+            case QUERY_EXPRESSION:\n+                switchContext(currentCtx);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e36e0403c39213b5761bcd15bea21abc38e8c087"}, "originalPosition": 152}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE1MjM5MQ==", "bodyText": "Shall we introduce a base node for all the clause nodes?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23178#discussion_r424152391", "createdAt": "2020-05-13T03:28:28Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-treegen/src/main/resources/syntax_tree_descriptor.json", "diffHunk": "@@ -2438,6 +2438,129 @@\n                     \"type\": \"Token\"\n                 }\n             ]\n+        },\n+        {\n+            \"name\": \"QueryConstructTypeNode\",\n+            \"base\": \"Node\",\n+            \"kind\": \"QUERY_CONSTRUCT_TYPE\",\n+            \"attributes\": [\n+                {\n+                    \"name\": \"tableKeyword\",\n+                    \"type\": \"Token\"\n+                },\n+                {\n+                    \"name\": \"KeySpecifier\",\n+                    \"type\": \"KeySpecifierNode\"\n+                }\n+            ]\n+        },\n+        {\n+            \"name\": \"FromClauseNode\",\n+            \"base\": \"Node\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e36e0403c39213b5761bcd15bea21abc38e8c087"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE1MzM3Mg==", "bodyText": "Can we end the context here, rather than in the respective child methods?\nSo that we can make sure the context is ended, no matter which branch it goes within the  parseTableConstructorOrQuery", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23178#discussion_r424153372", "createdAt": "2020-05-13T03:33:10Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -8185,4 +8166,295 @@ private boolean isEndOfTypeList(SyntaxKind nextTokenKind) {\n     private STNode parseTupleRestTypeDesc() {\n         return STNodeFactory.createEmptyNode();\n     }\n+\n+    /**\n+     * Parse table constructor or query expression.\n+     * <p>\n+     * <code>\n+     * table-constructor-or-query-expr := table-constructor-expr | query-expr\n+     * <br/>\n+     * table-constructor-expr := table [key-specifier] [ [row-list] ]\n+     * <br/>\n+     * query-expr := [query-construct-type] query-pipeline select-clause\n+     * <br/>\n+     * query-construct-type := table key-specifier | stream\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+\n+    private STNode parseTableConstructorOrQuery() {\n+        startContext(ParserRuleContext.TABLE_CONSTRUCTOR_OR_QUERY_EXPRESSION);\n+        return parseTableConstructorOrQuery(peek().kind);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e36e0403c39213b5761bcd15bea21abc38e8c087"}, "originalPosition": 279}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1ae65c6484ad858ff810bf06e971d8a9b03e6f44", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1ae65c6484ad858ff810bf06e971d8a9b03e6f44", "committedDate": "2020-05-13T05:47:13Z", "message": "Introduce a base node for all the clause nodes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0fe294c6e60e074381ccc567322e1429382953dc", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/0fe294c6e60e074381ccc567322e1429382953dc", "committedDate": "2020-05-13T18:21:57Z", "message": "Refactor query expression parsing"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4b66d60b6412e43b11239c4c01a5a9a7134d01cc", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/4b66d60b6412e43b11239c4c01a5a9a7134d01cc", "committedDate": "2020-05-14T07:02:26Z", "message": "Allow extra clauses to be passed and report error"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6376f2c715ebd33642e5355c4e74194f9639912e", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6376f2c715ebd33642e5355c4e74194f9639912e", "committedDate": "2020-05-14T07:02:58Z", "message": "Add test cases for extra clauses"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3cf9ccac5b4c1768e0e0f6f04fafcc2fbc5a04ff", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3cf9ccac5b4c1768e0e0f6f04fafcc2fbc5a04ff", "committedDate": "2020-05-14T11:35:18Z", "message": "Fix operator precedence for table constructor, query and let expressions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a2e9f4d50266a1a9dd7821fbd44c03a0154387dd", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a2e9f4d50266a1a9dd7821fbd44c03a0154387dd", "committedDate": "2020-05-14T11:35:57Z", "message": "Add operator precedence test cases"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1e4d2433368bad4fae241d5824bed0951c14f878", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1e4d2433368bad4fae241d5824bed0951c14f878", "committedDate": "2020-05-14T14:03:17Z", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into query-expr-support\n\n\u0001 Conflicts:\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaLexer.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/LexerTerminals.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/ParserRuleContext.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/tree/STNodeFactory.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/syntax/tree/NodeFactory.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/syntax/tree/NodeTransformer.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/syntax/tree/NodeVisitor.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/syntax/tree/SyntaxKind.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/syntax/tree/TreeModifier.java\n\u0001\tcompiler/ballerina-treegen/src/main/resources/syntax_tree_descriptor.json"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "66a343be2128fa6472169af7178fc8478cd2ca6f", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/66a343be2128fa6472169af7178fc8478cd2ca6f", "committedDate": "2020-05-14T14:41:13Z", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into query-expr-support"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f5cab218deb30646b008a3509e91d1016af69551", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f5cab218deb30646b008a3509e91d1016af69551", "committedDate": "2020-05-14T14:57:03Z", "message": "Regenerate tree after merging and fix merging issues"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDExODk5MjE1", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23178#pullrequestreview-411899215", "createdAt": "2020-05-14T15:05:00Z", "commit": {"oid": "f5cab218deb30646b008a3509e91d1016af69551"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxNTowNTowMVrOGVgs2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxNTowNTowMVrOGVgs2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTIwOTA0OQ==", "bodyText": "This was removed from table constructor tests as this is recovered as a query expression. Similar test case has been added under query expression test cases :)", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23178#discussion_r425209049", "createdAt": "2020-05-14T15:05:01Z", "author": {"login": "lochana-chathura"}, "path": "compiler/ballerina-parser/src/test/java/io/ballerinalang/compiler/parser/test/syntax/expressions/TableConstructorTest.java", "diffHunk": "@@ -117,9 +117,4 @@ public void testTableWithExtraToken() {\n         test(\"table foo key() [{k1:v1}]\", \"table-constructor/table_constructor_assert_24.json\");\n         test(\"table foo [{k1:v1}]\", \"table-constructor/table_constructor_assert_25.json\");\n     }\n-\n-    @Test\n-    public void testTableWithTwoKeySpecifiersWithExtraTokenInBetween() {\n-        test(\"table key(a) foo key(b) []\", \"table-constructor/table_constructor_assert_26.json\");\n-    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5cab218deb30646b008a3509e91d1016af69551"}, "originalPosition": 8}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDExOTQ4OTE4", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23178#pullrequestreview-411948918", "createdAt": "2020-05-14T15:56:54Z", "commit": {"oid": "f5cab218deb30646b008a3509e91d1016af69551"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxNTo1Njo1NFrOGVjEug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxNjowMDo1NFrOGVjQ_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTI0NzkzMA==", "bodyText": "As a safety measure, we can check whether the solution.tokenKind is an endOfIntermediateClause, and return null if so. That way we can avoid going to recovery infinitely. Returning null from this method can be treated as the end of intermediate clauses.\nWe can do that as an improvement though. This is more than good enough for now.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23178#discussion_r425247930", "createdAt": "2020-05-14T15:56:54Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -8423,4 +8409,338 @@ private STNode parseParenthesisedTypeDesc() {\n         STNode closeParen = parseCloseParenthesis();\n         return STNodeFactory.createParenthesisedTypeDescriptorNode(openParen, typedesc, closeParen);\n     }\n+\n+    /**\n+     * Parse table constructor or query expression.\n+     * <p>\n+     * <code>\n+     * table-constructor-or-query-expr := table-constructor-expr | query-expr\n+     * <br/>\n+     * table-constructor-expr := table [key-specifier] [ [row-list] ]\n+     * <br/>\n+     * query-expr := [query-construct-type] query-pipeline select-clause\n+     * <br/>\n+     * query-construct-type := table key-specifier | stream\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+\n+    private STNode parseTableConstructorOrQuery(boolean isRhsExpr) {\n+        startContext(ParserRuleContext.TABLE_CONSTRUCTOR_OR_QUERY_EXPRESSION);\n+        STNode tableOrQueryExpr = parseTableConstructorOrQuery(peek().kind, isRhsExpr);\n+        endContext();\n+        return tableOrQueryExpr;\n+    }\n+\n+    private STNode parseTableConstructorOrQuery(SyntaxKind nextTokenKind, boolean isRhsExpr) {\n+        STNode queryConstructType;\n+        switch (nextTokenKind) {\n+            case FROM_KEYWORD:\n+                queryConstructType = STNodeFactory.createEmptyNode();\n+                return parseQueryExprRhs(queryConstructType, isRhsExpr);\n+            case STREAM_KEYWORD:\n+                queryConstructType = parseStreamKeyword();\n+                return parseQueryExprRhs(queryConstructType, isRhsExpr);\n+            case TABLE_KEYWORD:\n+                STNode tableKeyword = parseTableKeyword();\n+                return parseTableConstructorOrQuery(tableKeyword, isRhsExpr);\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.TABLE_CONSTRUCTOR_OR_QUERY_START, isRhsExpr);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseTableConstructorOrQuery(solution.tokenKind, isRhsExpr);\n+        }\n+\n+    }\n+\n+    private STNode parseTableConstructorOrQuery(STNode tableKeyword, boolean isRhsExpr) {\n+        return parseTableConstructorOrQuery(peek().kind, tableKeyword, isRhsExpr);\n+    }\n+\n+    private STNode parseTableConstructorOrQuery(SyntaxKind nextTokenKind, STNode tableKeyword, boolean isRhsExpr) {\n+        STNode keySpecifier;\n+        switch (nextTokenKind) {\n+            case OPEN_BRACKET_TOKEN:\n+                keySpecifier = STNodeFactory.createEmptyNode();\n+                return parseTableConstructorExprRhs(tableKeyword, keySpecifier);\n+            case KEY_KEYWORD:\n+                keySpecifier = parseKeySpecifier();\n+                return parseTableConstructorOrQueryRhs(tableKeyword, keySpecifier, isRhsExpr);\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.TABLE_KEYWORD_RHS, tableKeyword, isRhsExpr);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseTableConstructorOrQuery(solution.tokenKind, tableKeyword, isRhsExpr);\n+        }\n+    }\n+\n+    private STNode parseTableConstructorOrQueryRhs(STNode tableKeyword, STNode keySpecifier, boolean isRhsExpr) {\n+        return parseTableConstructorOrQueryRhs(peek().kind, tableKeyword, keySpecifier, isRhsExpr);\n+    }\n+\n+    private STNode parseTableConstructorOrQueryRhs(SyntaxKind nextTokenKind, STNode tableKeyword, STNode keySpecifier,\n+                                                   boolean isRhsExpr) {\n+        switch (nextTokenKind) {\n+            case FROM_KEYWORD:\n+                return parseQueryExprRhs(parseQueryConstructType(tableKeyword, keySpecifier), isRhsExpr);\n+            case OPEN_BRACKET_TOKEN:\n+                return parseTableConstructorExprRhs(tableKeyword, keySpecifier);\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.TABLE_CONSTRUCTOR_OR_QUERY_RHS,\n+                        tableKeyword, keySpecifier, isRhsExpr);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseTableConstructorOrQueryRhs(solution.tokenKind, tableKeyword, keySpecifier, isRhsExpr);\n+        }\n+    }\n+\n+    /**\n+     * Parse query construct type.\n+     * <p>\n+     * <code>query-construct-type := table key-specifier</code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseQueryConstructType(STNode tableKeyword, STNode keySpecifier) {\n+        return STNodeFactory.createQueryConstructTypeNode(tableKeyword, keySpecifier);\n+    }\n+\n+    /**\n+     * Parse query expression.\n+     * <p>\n+     * <code>\n+     * query-expr-rhs := query-pipeline select-clause\n+     * <br/>\n+     * query-pipeline := from-clause intermediate-clause*\n+     * </code>\n+     *\n+     * @param queryConstructType queryConstructType that precedes this rhs\n+     * @return Parsed node\n+     */\n+    private STNode parseQueryExprRhs(STNode queryConstructType, boolean isRhsExpr) {\n+        switchContext(ParserRuleContext.QUERY_EXPRESSION);\n+        STNode fromClause = parseFromClause(isRhsExpr);\n+\n+        List<STNode> clauses = new ArrayList<>();\n+        boolean hasReachedSelectClause = false;\n+\n+        STNode intermediateClause;\n+        STNode selectClause = null;\n+\n+        while (!isEndOfIntermediateClause(peek().kind)) {\n+            intermediateClause = parseIntermediateClause(isRhsExpr);\n+\n+            if (!hasReachedSelectClause) {\n+                if (intermediateClause.kind == SyntaxKind.SELECT_CLAUSE) {\n+                    selectClause = intermediateClause;\n+                    hasReachedSelectClause = true;\n+                } else {\n+                    clauses.add(intermediateClause);\n+                }\n+            } else {\n+                // If there are more clauses after select clause they are ignored\n+                // TODO: In future we should store ignored nodes\n+                this.errorHandler.reportMissingTokenError(\"extra clauses after select clause\");\n+            }\n+        }\n+\n+        if (!hasReachedSelectClause) {\n+            selectClause = parseSelectClause(isRhsExpr);\n+        }\n+\n+        STNode intermediateClauses = STNodeFactory.createNodeList(clauses);\n+        STNode queryPipeline = STNodeFactory.createQueryPipelineNode(fromClause, intermediateClauses);\n+        return STNodeFactory.createQueryExpressionNode(queryConstructType, queryPipeline, selectClause);\n+    }\n+\n+    /**\n+     * Parse an intermediate clause.\n+     * <p>\n+     * <code>\n+     * intermediate-clause := from-clause | where-clause | let-clause\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseIntermediateClause(boolean isRhsExpr) {\n+        return parseIntermediateClause(peek().kind, isRhsExpr);\n+    }\n+\n+    private STNode parseIntermediateClause(SyntaxKind nextTokenKind, boolean isRhsExpr) {\n+        switch (nextTokenKind) {\n+            case FROM_KEYWORD:\n+                return parseFromClause(isRhsExpr);\n+            case WHERE_KEYWORD:\n+                return parseWhereClause(isRhsExpr);\n+            case LET_KEYWORD:\n+                return parseLetClause(isRhsExpr);\n+            case SELECT_KEYWORD:\n+                return parseSelectClause(isRhsExpr);\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.QUERY_EXPRESSION_RHS, isRhsExpr);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseIntermediateClause(solution.tokenKind, isRhsExpr);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5cab218deb30646b008a3509e91d1016af69551"}, "originalPosition": 456}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTI1MTA3MA==", "bodyText": "Do we need to add EXPRESSION_RHS as an option here?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23178#discussion_r425251070", "createdAt": "2020-05-14T16:00:54Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -333,6 +333,15 @@\n     private static final ParserRuleContext[] NEW_KEYWORD_RHS =\n             { ParserRuleContext.TYPE_DESC_IN_NEW_EXPR, ParserRuleContext.EXPRESSION_RHS };\n \n+    private static final ParserRuleContext[] TABLE_CONSTRUCTOR_OR_QUERY_START =\n+            { ParserRuleContext.TABLE_KEYWORD, ParserRuleContext.STREAM_KEYWORD, ParserRuleContext.QUERY_EXPRESSION };\n+\n+    private static final ParserRuleContext[] TABLE_CONSTRUCTOR_OR_QUERY_RHS =\n+            { ParserRuleContext.TABLE_CONSTRUCTOR, ParserRuleContext.QUERY_EXPRESSION };\n+\n+    private static final ParserRuleContext[] QUERY_EXPRESSION_RHS =\n+            { ParserRuleContext.SELECT_CLAUSE, ParserRuleContext.WHERE_CLAUSE, ParserRuleContext.FROM_CLAUSE,\n+                    ParserRuleContext.LET_CLAUSE };", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5cab218deb30646b008a3509e91d1016af69551"}, "originalPosition": 34}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3deac76c0f6c4db00a8e26cdff8da50634417b9a", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3deac76c0f6c4db00a8e26cdff8da50634417b9a", "committedDate": "2020-05-14T16:23:07Z", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into query-expr-support\n\n\u0001 Conflicts:\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaLexer.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/LexerTerminals.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/ParserRuleContext.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/tree/STNodeFactory.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/syntax/tree/NodeFactory.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/syntax/tree/NodeTransformer.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/syntax/tree/NodeVisitor.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/syntax/tree/TreeModifier.java\n\u0001\tcompiler/ballerina-parser/src/test/java/io/ballerinalang/compiler/parser/test/ParserTestUtils.java\n\u0001\tcompiler/ballerina-treegen/src/main/resources/syntax_tree_descriptor.json"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b88d4dc9d1d22a58d6921700671dd249e3a940d8", "author": {"user": {"login": "lochana-chathura", "name": null}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b88d4dc9d1d22a58d6921700671dd249e3a940d8", "committedDate": "2020-05-14T16:31:41Z", "message": "Regenerate tree after merging"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3417, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}