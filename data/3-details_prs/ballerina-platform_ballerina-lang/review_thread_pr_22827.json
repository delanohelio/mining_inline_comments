{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA3MDc0MzAx", "number": 22827, "reviewThreads": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwNjozNTowM1rOD0lbbw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QwNzoxODowOVrOD2hoyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2NDY1Nzc1OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaLexer.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwNjozNTowM1rOGJlrHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxODo0MzoxMVrOGKFgIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjcwNzYxNQ==", "bodyText": "I added retreat() method to the charReader.java which does exactly the opposite of advance() method. If it is not acceptable I can mange to do above without calling reader.retreat();. But that will add few more lines, if blocks and a new variables to the processNumericLiteral() and processDecimalFloatLiteral(); methods", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22827#discussion_r412707615", "createdAt": "2020-04-22T06:35:03Z", "author": {"login": "lochana-chathura"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaLexer.java", "diffHunk": "@@ -414,15 +414,19 @@ private STNode processEndOfLine() {\n     }\n \n     /**\n-     * Process dot or ellipsis token.\n+     * Process dot, ellipsis or decimal floating point token.\n      * \n-     * @return Dot or ellipsis token\n+     * @return Dot, ellipsis or decimal floating point token\n      */\n-    private STToken parseDotOrEllipsis() {\n+    private STToken processDot() {\n         if (reader.peek() == LexerTerminals.DOT && reader.peek(1) == LexerTerminals.DOT) {\n             reader.advance(2);\n             return getSyntaxToken(SyntaxKind.ELLIPSIS_TOKEN);\n         }\n+        if (this.mode != ParserMode.IMPORT && isDigit(reader.peek())) {\n+            reader.retreat();\n+            return processDecimalFloatLiteral();\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5fa0281c557d76d04d6a32063c64b2f8ee109ae"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgyNzE1NQ==", "bodyText": "I feel the lexer shouldn't reach here for floating-points.\nHere we start parsing a token from a dot. But a floating-point numeric can never start from a dot right?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22827#discussion_r412827155", "createdAt": "2020-04-22T09:34:29Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaLexer.java", "diffHunk": "@@ -414,15 +414,19 @@ private STNode processEndOfLine() {\n     }\n \n     /**\n-     * Process dot or ellipsis token.\n+     * Process dot, ellipsis or decimal floating point token.\n      * \n-     * @return Dot or ellipsis token\n+     * @return Dot, ellipsis or decimal floating point token\n      */\n-    private STToken parseDotOrEllipsis() {\n+    private STToken processDot() {\n         if (reader.peek() == LexerTerminals.DOT && reader.peek(1) == LexerTerminals.DOT) {\n             reader.advance(2);\n             return getSyntaxToken(SyntaxKind.ELLIPSIS_TOKEN);\n         }\n+        if (this.mode != ParserMode.IMPORT && isDigit(reader.peek())) {\n+            reader.retreat();\n+            return processDecimalFloatLiteral();\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjcwNzYxNQ=="}, "originalCommit": {"oid": "f5fa0281c557d76d04d6a32063c64b2f8ee109ae"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg1MTM0Nw==", "bodyText": "according to spec, DottedDecimalNumber := DecimalNumber . Digit*  | . Digit+ \nso starting from a . is possible right?. eg. .2", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22827#discussion_r412851347", "createdAt": "2020-04-22T10:09:22Z", "author": {"login": "lochana-chathura"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaLexer.java", "diffHunk": "@@ -414,15 +414,19 @@ private STNode processEndOfLine() {\n     }\n \n     /**\n-     * Process dot or ellipsis token.\n+     * Process dot, ellipsis or decimal floating point token.\n      * \n-     * @return Dot or ellipsis token\n+     * @return Dot, ellipsis or decimal floating point token\n      */\n-    private STToken parseDotOrEllipsis() {\n+    private STToken processDot() {\n         if (reader.peek() == LexerTerminals.DOT && reader.peek(1) == LexerTerminals.DOT) {\n             reader.advance(2);\n             return getSyntaxToken(SyntaxKind.ELLIPSIS_TOKEN);\n         }\n+        if (this.mode != ParserMode.IMPORT && isDigit(reader.peek())) {\n+            reader.retreat();\n+            return processDecimalFloatLiteral();\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjcwNzYxNQ=="}, "originalCommit": {"oid": "f5fa0281c557d76d04d6a32063c64b2f8ee109ae"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzIyOTA5MQ==", "bodyText": "Removed retreat() and refactored. :)", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22827#discussion_r413229091", "createdAt": "2020-04-22T18:43:11Z", "author": {"login": "lochana-chathura"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaLexer.java", "diffHunk": "@@ -414,15 +414,19 @@ private STNode processEndOfLine() {\n     }\n \n     /**\n-     * Process dot or ellipsis token.\n+     * Process dot, ellipsis or decimal floating point token.\n      * \n-     * @return Dot or ellipsis token\n+     * @return Dot, ellipsis or decimal floating point token\n      */\n-    private STToken parseDotOrEllipsis() {\n+    private STToken processDot() {\n         if (reader.peek() == LexerTerminals.DOT && reader.peek(1) == LexerTerminals.DOT) {\n             reader.advance(2);\n             return getSyntaxToken(SyntaxKind.ELLIPSIS_TOKEN);\n         }\n+        if (this.mode != ParserMode.IMPORT && isDigit(reader.peek())) {\n+            reader.retreat();\n+            return processDecimalFloatLiteral();\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjcwNzYxNQ=="}, "originalCommit": {"oid": "f5fa0281c557d76d04d6a32063c64b2f8ee109ae"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2NTQ0MjI0OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaLexer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwOTozMjoyNlrOGJs4tw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwOTozMjoyNlrOGJs4tw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgyNTc4Mw==", "bodyText": "lets use LexerTerminals.DOT everywhere posible", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22827#discussion_r412825783", "createdAt": "2020-04-22T09:32:26Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaLexer.java", "diffHunk": "@@ -543,9 +555,133 @@ private STToken processNumericLiteral(int startChar) {\n \n     /**\n      * <p>\n-     * Process and returns a hex integer literal.\n+     * Process and returns a decimal floating point literal.\n      * </p>\n      * <code>\n+     * DecimalFloatingPointNumber :=\n+     *    DecimalNumber Exponent [FloatingPointTypeSuffix]\n+     *    | DottedDecimalNumber [Exponent] [FloatingPointTypeSuffix]\n+     *    | DecimalNumber FloatingPointTypeSuffix\n+     * <br/>\n+     * DottedDecimalNumber := DecimalNumber . Digit* | . Digit+\n+     * <br/>\n+     * FloatingPointTypeSuffix := DecimalTypeSuffix | FloatTypeSuffix\n+     * <br/>\n+     * DecimalTypeSuffix := d | D\n+     * <br/>\n+     * FloatTypeSuffix :=  f | F\n+     * </code>\n+     *\n+     * @return The decimal floating point literal.\n+     */\n+    private STToken processDecimalFloatLiteral() {\n+        boolean exponent = false;\n+        boolean dot = false;\n+        int nextChar;\n+        while (true) {\n+            nextChar = peek();\n+            switch (nextChar) {\n+                case 'f':\n+                case 'F':\n+                case 'd':\n+                case 'D':\n+                    reader.advance();\n+                    break;\n+                case 'e':\n+                case 'E':\n+                    if (!exponent) { // Check whether an exponent has been passed previously\n+                        if (processExponent()) {\n+                            exponent = true;\n+                            continue;\n+                        }\n+                    }\n+\n+                    processInvalidToken();\n+                    return readToken();\n+                case '.':", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5fa0281c557d76d04d6a32063c64b2f8ee109ae"}, "originalPosition": 133}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2NTQ4NjEyOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaLexer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwOTo0MjoxNlrOGJtTMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwOTo0MjoxNlrOGJtTMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgzMjU2Mw==", "bodyText": "Lets rename:\nexponent -> hasExponent\ndot -> hasDot", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22827#discussion_r412832563", "createdAt": "2020-04-22T09:42:16Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaLexer.java", "diffHunk": "@@ -543,9 +555,133 @@ private STToken processNumericLiteral(int startChar) {\n \n     /**\n      * <p>\n-     * Process and returns a hex integer literal.\n+     * Process and returns a decimal floating point literal.\n      * </p>\n      * <code>\n+     * DecimalFloatingPointNumber :=\n+     *    DecimalNumber Exponent [FloatingPointTypeSuffix]\n+     *    | DottedDecimalNumber [Exponent] [FloatingPointTypeSuffix]\n+     *    | DecimalNumber FloatingPointTypeSuffix\n+     * <br/>\n+     * DottedDecimalNumber := DecimalNumber . Digit* | . Digit+\n+     * <br/>\n+     * FloatingPointTypeSuffix := DecimalTypeSuffix | FloatTypeSuffix\n+     * <br/>\n+     * DecimalTypeSuffix := d | D\n+     * <br/>\n+     * FloatTypeSuffix :=  f | F\n+     * </code>\n+     *\n+     * @return The decimal floating point literal.\n+     */\n+    private STToken processDecimalFloatLiteral() {\n+        boolean exponent = false;\n+        boolean dot = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5fa0281c557d76d04d6a32063c64b2f8ee109ae"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2NTU1NTMzOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaLexer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwOTo1Nzo0M1rOGJt9YQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxMDoxMTowMFrOGJug-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg0MzM2MQ==", "bodyText": "Can we avoid these if-conditions, and the flags?\nLooking at the grammar, there are three main components the decimalNumber,  the exponent, and the suffix. These always exists in order. For example: decimalNumber component always the first component. suffix always comes after the decimalNumber, and always before the suffix.\nSo, what I feel is, suppose we have three separate functions to process these three separate components, (say a(), b() and c() ) if we chain these three, then the complexity would be reduced.\nfor e.g: we start from a() and continue till we reach the exponent, and once we reach the exponent, call b(). But never return to a() and process again. Simply finish the processing and exit from b(). So a() never have to worry whether b() was successfully completed or not..", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22827#discussion_r412843361", "createdAt": "2020-04-22T09:57:43Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaLexer.java", "diffHunk": "@@ -543,9 +555,133 @@ private STToken processNumericLiteral(int startChar) {\n \n     /**\n      * <p>\n-     * Process and returns a hex integer literal.\n+     * Process and returns a decimal floating point literal.\n      * </p>\n      * <code>\n+     * DecimalFloatingPointNumber :=\n+     *    DecimalNumber Exponent [FloatingPointTypeSuffix]\n+     *    | DottedDecimalNumber [Exponent] [FloatingPointTypeSuffix]\n+     *    | DecimalNumber FloatingPointTypeSuffix\n+     * <br/>\n+     * DottedDecimalNumber := DecimalNumber . Digit* | . Digit+\n+     * <br/>\n+     * FloatingPointTypeSuffix := DecimalTypeSuffix | FloatTypeSuffix\n+     * <br/>\n+     * DecimalTypeSuffix := d | D\n+     * <br/>\n+     * FloatTypeSuffix :=  f | F\n+     * </code>\n+     *\n+     * @return The decimal floating point literal.\n+     */\n+    private STToken processDecimalFloatLiteral() {\n+        boolean exponent = false;\n+        boolean dot = false;\n+        int nextChar;\n+        while (true) {\n+            nextChar = peek();\n+            switch (nextChar) {\n+                case 'f':\n+                case 'F':\n+                case 'd':\n+                case 'D':\n+                    reader.advance();\n+                    break;\n+                case 'e':\n+                case 'E':\n+                    if (!exponent) { // Check whether an exponent has been passed previously\n+                        if (processExponent()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5fa0281c557d76d04d6a32063c64b2f8ee109ae"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg1MjQ3Mg==", "bodyText": "I'll do that change.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22827#discussion_r412852472", "createdAt": "2020-04-22T10:11:00Z", "author": {"login": "lochana-chathura"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaLexer.java", "diffHunk": "@@ -543,9 +555,133 @@ private STToken processNumericLiteral(int startChar) {\n \n     /**\n      * <p>\n-     * Process and returns a hex integer literal.\n+     * Process and returns a decimal floating point literal.\n      * </p>\n      * <code>\n+     * DecimalFloatingPointNumber :=\n+     *    DecimalNumber Exponent [FloatingPointTypeSuffix]\n+     *    | DottedDecimalNumber [Exponent] [FloatingPointTypeSuffix]\n+     *    | DecimalNumber FloatingPointTypeSuffix\n+     * <br/>\n+     * DottedDecimalNumber := DecimalNumber . Digit* | . Digit+\n+     * <br/>\n+     * FloatingPointTypeSuffix := DecimalTypeSuffix | FloatTypeSuffix\n+     * <br/>\n+     * DecimalTypeSuffix := d | D\n+     * <br/>\n+     * FloatTypeSuffix :=  f | F\n+     * </code>\n+     *\n+     * @return The decimal floating point literal.\n+     */\n+    private STToken processDecimalFloatLiteral() {\n+        boolean exponent = false;\n+        boolean dot = false;\n+        int nextChar;\n+        while (true) {\n+            nextChar = peek();\n+            switch (nextChar) {\n+                case 'f':\n+                case 'F':\n+                case 'd':\n+                case 'D':\n+                    reader.advance();\n+                    break;\n+                case 'e':\n+                case 'E':\n+                    if (!exponent) { // Check whether an exponent has been passed previously\n+                        if (processExponent()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg0MzM2MQ=="}, "originalCommit": {"oid": "f5fa0281c557d76d04d6a32063c64b2f8ee109ae"}, "originalPosition": 125}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4Mjc3NzMwOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaLexer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNlQxMjoxMToyMVrOGMDodw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNlQxMjoxMToyMVrOGMDodw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTI5NTYwNw==", "bodyText": "This code block looks like a duplicate of L#602-L#610. Can we use a single switch-case for both scenarios?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22827#discussion_r415295607", "createdAt": "2020-04-26T12:11:21Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaLexer.java", "diffHunk": "@@ -536,9 +547,162 @@ private STToken processNumericLiteral(int startChar) {\n \n     /**\n      * <p>\n-     * Process and returns a hex integer literal.\n+     * Process and returns a decimal floating point literal.\n+     * </p>\n+     * <code>\n+     * DecimalFloatingPointNumber :=\n+     *    DecimalNumber Exponent [FloatingPointTypeSuffix]\n+     *    | DottedDecimalNumber [Exponent] [FloatingPointTypeSuffix]\n+     *    | DecimalNumber FloatingPointTypeSuffix\n+     * <br/>\n+     * DottedDecimalNumber := DecimalNumber . Digit* | . Digit+\n+     * <br/>\n+     * FloatingPointTypeSuffix := DecimalTypeSuffix | FloatTypeSuffix\n+     * <br/>\n+     * DecimalTypeSuffix := d | D\n+     * <br/>\n+     * FloatTypeSuffix :=  f | F\n+     * </code>\n+     *\n+     * @param isDotStart Whether process starts from a dot\n+     * @return The decimal floating point literal.\n+     */\n+    private STToken processDecimalFloatLiteral(boolean isDotStart) {\n+        int nextChar = peek();\n+\n+        // Direct process to the dot switch case\n+        if (isDotStart) {\n+            nextChar = LexerTerminals.DOT;\n+        }\n+\n+        switch (nextChar) {\n+            case LexerTerminals.DOT:\n+                if (!isDotStart) { // Advance only if it is not already validated\n+                    reader.advance();\n+                }\n+                nextChar = peek();\n+                while (true) {\n+                    if (isDigit(nextChar)) {\n+                        reader.advance();\n+                        nextChar = peek();\n+                        continue;\n+                    }\n+                    break;\n+                }\n+                switch (nextChar) {\n+                    case 'e':\n+                    case 'E':\n+                        return processExponent(false);\n+                    case 'f':\n+                    case 'F':\n+                    case 'd':\n+                    case 'D':\n+                        return parseFloatingPointTypeSuffix();\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7124776e7ea1bce1cf4e3b355626dd3ee90bec11"}, "originalPosition": 142}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4Mjc4MTMyOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaLexer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNlQxMjoxMzo0OFrOGMDqSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNlQxMjoxMzo0OFrOGMDqSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTI5NjA3Mw==", "bodyText": "while(isDigit(nextChar))", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22827#discussion_r415296073", "createdAt": "2020-04-26T12:13:48Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaLexer.java", "diffHunk": "@@ -536,9 +547,162 @@ private STToken processNumericLiteral(int startChar) {\n \n     /**\n      * <p>\n-     * Process and returns a hex integer literal.\n+     * Process and returns a decimal floating point literal.\n+     * </p>\n+     * <code>\n+     * DecimalFloatingPointNumber :=\n+     *    DecimalNumber Exponent [FloatingPointTypeSuffix]\n+     *    | DottedDecimalNumber [Exponent] [FloatingPointTypeSuffix]\n+     *    | DecimalNumber FloatingPointTypeSuffix\n+     * <br/>\n+     * DottedDecimalNumber := DecimalNumber . Digit* | . Digit+\n+     * <br/>\n+     * FloatingPointTypeSuffix := DecimalTypeSuffix | FloatTypeSuffix\n+     * <br/>\n+     * DecimalTypeSuffix := d | D\n+     * <br/>\n+     * FloatTypeSuffix :=  f | F\n+     * </code>\n+     *\n+     * @param isDotStart Whether process starts from a dot\n+     * @return The decimal floating point literal.\n+     */\n+    private STToken processDecimalFloatLiteral(boolean isDotStart) {\n+        int nextChar = peek();\n+\n+        // Direct process to the dot switch case\n+        if (isDotStart) {\n+            nextChar = LexerTerminals.DOT;\n+        }\n+\n+        switch (nextChar) {\n+            case LexerTerminals.DOT:\n+                if (!isDotStart) { // Advance only if it is not already validated\n+                    reader.advance();\n+                }\n+                nextChar = peek();\n+                while (true) {\n+                    if (isDigit(nextChar)) {\n+                        reader.advance();\n+                        nextChar = peek();\n+                        continue;\n+                    }\n+                    break;\n+                }\n+                switch (nextChar) {\n+                    case 'e':\n+                    case 'E':\n+                        return processExponent(false);\n+                    case 'f':\n+                    case 'F':\n+                    case 'd':\n+                    case 'D':\n+                        return parseFloatingPointTypeSuffix();\n+                }\n+                break;\n+            case 'e':\n+            case 'E':\n+                return processExponent(false);\n+            case 'f':\n+            case 'F':\n+            case 'd':\n+            case 'D':\n+                return parseFloatingPointTypeSuffix();\n+        }\n+\n+        return getLiteral(SyntaxKind.DECIMAL_FLOATING_POINT_LITERAL);\n+    }\n+\n+    /**\n+     * <p>\n+     * Process an exponent or hex-exponent.\n+     * </p>\n+     * <code>\n+     * exponent := Exponent | HexExponent\n+     * <br/>\n+     * Exponent := ExponentIndicator [Sign] Digit+\n+     * <br/>\n+     * HexExponent := HexExponentIndicator [Sign] Digit+\n+     * <br/>\n+     * ExponentIndicator := e | E\n+     * <br/>\n+     * HexExponentIndicator := p | P\n+     * <br/>\n+     * Sign := + | -\n+     * <br/>\n+     * Digit := 0 .. 9\n+     * </code>\n+     *\n+     * @param isHex HexExponent or not\n+     * @return The decimal floating point literal.\n+     */\n+    private STToken processExponent(boolean isHex) {\n+        // Advance reader as exponent indicator is already validated\n+        reader.advance();\n+        int nextChar = peek();\n+\n+        // Capture if there is a sign\n+        if (nextChar == LexerTerminals.PLUS || nextChar == LexerTerminals.MINUS) {\n+            reader.advance();\n+            nextChar = peek();\n+        }\n+\n+        // Make sure at least one digit is present after the indicator\n+        if (!isDigit(nextChar)) {\n+            processInvalidToken();\n+            return readToken();\n+        }\n+\n+        while (true) {\n+            if (isDigit(nextChar)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7124776e7ea1bce1cf4e3b355626dd3ee90bec11"}, "originalPosition": 198}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4Mjc4MzgwOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaLexer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNlQxMjoxNToyNlrOGMDrfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNlQxMjoxNToyNlrOGMDrfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTI5NjM4Mw==", "bodyText": "Should we log an error here?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22827#discussion_r415296383", "createdAt": "2020-04-26T12:15:26Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaLexer.java", "diffHunk": "@@ -536,9 +547,162 @@ private STToken processNumericLiteral(int startChar) {\n \n     /**\n      * <p>\n-     * Process and returns a hex integer literal.\n+     * Process and returns a decimal floating point literal.\n+     * </p>\n+     * <code>\n+     * DecimalFloatingPointNumber :=\n+     *    DecimalNumber Exponent [FloatingPointTypeSuffix]\n+     *    | DottedDecimalNumber [Exponent] [FloatingPointTypeSuffix]\n+     *    | DecimalNumber FloatingPointTypeSuffix\n+     * <br/>\n+     * DottedDecimalNumber := DecimalNumber . Digit* | . Digit+\n+     * <br/>\n+     * FloatingPointTypeSuffix := DecimalTypeSuffix | FloatTypeSuffix\n+     * <br/>\n+     * DecimalTypeSuffix := d | D\n+     * <br/>\n+     * FloatTypeSuffix :=  f | F\n+     * </code>\n+     *\n+     * @param isDotStart Whether process starts from a dot\n+     * @return The decimal floating point literal.\n+     */\n+    private STToken processDecimalFloatLiteral(boolean isDotStart) {\n+        int nextChar = peek();\n+\n+        // Direct process to the dot switch case\n+        if (isDotStart) {\n+            nextChar = LexerTerminals.DOT;\n+        }\n+\n+        switch (nextChar) {\n+            case LexerTerminals.DOT:\n+                if (!isDotStart) { // Advance only if it is not already validated\n+                    reader.advance();\n+                }\n+                nextChar = peek();\n+                while (true) {\n+                    if (isDigit(nextChar)) {\n+                        reader.advance();\n+                        nextChar = peek();\n+                        continue;\n+                    }\n+                    break;\n+                }\n+                switch (nextChar) {\n+                    case 'e':\n+                    case 'E':\n+                        return processExponent(false);\n+                    case 'f':\n+                    case 'F':\n+                    case 'd':\n+                    case 'D':\n+                        return parseFloatingPointTypeSuffix();\n+                }\n+                break;\n+            case 'e':\n+            case 'E':\n+                return processExponent(false);\n+            case 'f':\n+            case 'F':\n+            case 'd':\n+            case 'D':\n+                return parseFloatingPointTypeSuffix();\n+        }\n+\n+        return getLiteral(SyntaxKind.DECIMAL_FLOATING_POINT_LITERAL);\n+    }\n+\n+    /**\n+     * <p>\n+     * Process an exponent or hex-exponent.\n+     * </p>\n+     * <code>\n+     * exponent := Exponent | HexExponent\n+     * <br/>\n+     * Exponent := ExponentIndicator [Sign] Digit+\n+     * <br/>\n+     * HexExponent := HexExponentIndicator [Sign] Digit+\n+     * <br/>\n+     * ExponentIndicator := e | E\n+     * <br/>\n+     * HexExponentIndicator := p | P\n+     * <br/>\n+     * Sign := + | -\n+     * <br/>\n+     * Digit := 0 .. 9\n+     * </code>\n+     *\n+     * @param isHex HexExponent or not\n+     * @return The decimal floating point literal.\n+     */\n+    private STToken processExponent(boolean isHex) {\n+        // Advance reader as exponent indicator is already validated\n+        reader.advance();\n+        int nextChar = peek();\n+\n+        // Capture if there is a sign\n+        if (nextChar == LexerTerminals.PLUS || nextChar == LexerTerminals.MINUS) {\n+            reader.advance();\n+            nextChar = peek();\n+        }\n+\n+        // Make sure at least one digit is present after the indicator\n+        if (!isDigit(nextChar)) {\n+            processInvalidToken();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7124776e7ea1bce1cf4e3b355626dd3ee90bec11"}, "originalPosition": 193}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4Mjc5Mzk2OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaLexer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNlQxMjoyMTowN1rOGMDwCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNlQxMjoyMTowN1rOGMDwCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTI5NzU0Ng==", "bodyText": "Add a comment saying that we wouldn't be reaching here, if the floating-point starts with a dot.\nOtherwise, anyone who will check this code later, might think this was a mistake :)", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22827#discussion_r415297546", "createdAt": "2020-04-26T12:21:07Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaLexer.java", "diffHunk": "@@ -494,24 +499,31 @@ private STToken processEqualOperator() {\n     private STToken processNumericLiteral(int startChar) {\n         int nextChar = peek();\n         if (isHexIndicator(startChar, nextChar)) {\n-            return processHexIntLiteral();\n+            return processHexLiteral();\n         }\n \n         int len = 1;\n         while (true) {\n             switch (nextChar) {\n-                case '.':\n+                case LexerTerminals.DOT:\n                 case 'e':\n                 case 'E':\n+                case 'f':\n+                case 'F':\n+                case 'd':\n+                case 'D':\n                     // In sem-var mode, only decimal integer literals are supported\n                     if (this.mode == ParserMode.IMPORT) {\n                         break;\n                     }\n \n-                    // TODO: handle float\n-                    reader.advance();\n-                    processInvalidToken();\n-                    return readToken();\n+                    // Integer part of the float cannot have a leading zero\n+                    if (startChar == '0' && len > 1) {\n+                        processInvalidToken();\n+                        return readToken();\n+                    }\n+\n+                    return processDecimalFloatLiteral(false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7124776e7ea1bce1cf4e3b355626dd3ee90bec11"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4MjgwOTk5OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaLexer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNlQxMjozMDozM1rOGMD3Sw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNlQxMjozNDoyMVrOGMD6pA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTI5OTQwMw==", "bodyText": "can we get rid of this isDotStart flag? Why does this method needs to know whether the numeric started with a dot?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22827#discussion_r415299403", "createdAt": "2020-04-26T12:30:33Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaLexer.java", "diffHunk": "@@ -536,9 +547,162 @@ private STToken processNumericLiteral(int startChar) {\n \n     /**\n      * <p>\n-     * Process and returns a hex integer literal.\n+     * Process and returns a decimal floating point literal.\n+     * </p>\n+     * <code>\n+     * DecimalFloatingPointNumber :=\n+     *    DecimalNumber Exponent [FloatingPointTypeSuffix]\n+     *    | DottedDecimalNumber [Exponent] [FloatingPointTypeSuffix]\n+     *    | DecimalNumber FloatingPointTypeSuffix\n+     * <br/>\n+     * DottedDecimalNumber := DecimalNumber . Digit* | . Digit+\n+     * <br/>\n+     * FloatingPointTypeSuffix := DecimalTypeSuffix | FloatTypeSuffix\n+     * <br/>\n+     * DecimalTypeSuffix := d | D\n+     * <br/>\n+     * FloatTypeSuffix :=  f | F\n+     * </code>\n+     *\n+     * @param isDotStart Whether process starts from a dot\n+     * @return The decimal floating point literal.\n+     */\n+    private STToken processDecimalFloatLiteral(boolean isDotStart) {\n+        int nextChar = peek();\n+\n+        // Direct process to the dot switch case\n+        if (isDotStart) {\n+            nextChar = LexerTerminals.DOT;\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7124776e7ea1bce1cf4e3b355626dd3ee90bec11"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTMwMDI2MA==", "bodyText": "What if this method always accepts the starting char as the input? Will that solve this complexity?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22827#discussion_r415300260", "createdAt": "2020-04-26T12:34:21Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaLexer.java", "diffHunk": "@@ -536,9 +547,162 @@ private STToken processNumericLiteral(int startChar) {\n \n     /**\n      * <p>\n-     * Process and returns a hex integer literal.\n+     * Process and returns a decimal floating point literal.\n+     * </p>\n+     * <code>\n+     * DecimalFloatingPointNumber :=\n+     *    DecimalNumber Exponent [FloatingPointTypeSuffix]\n+     *    | DottedDecimalNumber [Exponent] [FloatingPointTypeSuffix]\n+     *    | DecimalNumber FloatingPointTypeSuffix\n+     * <br/>\n+     * DottedDecimalNumber := DecimalNumber . Digit* | . Digit+\n+     * <br/>\n+     * FloatingPointTypeSuffix := DecimalTypeSuffix | FloatTypeSuffix\n+     * <br/>\n+     * DecimalTypeSuffix := d | D\n+     * <br/>\n+     * FloatTypeSuffix :=  f | F\n+     * </code>\n+     *\n+     * @param isDotStart Whether process starts from a dot\n+     * @return The decimal floating point literal.\n+     */\n+    private STToken processDecimalFloatLiteral(boolean isDotStart) {\n+        int nextChar = peek();\n+\n+        // Direct process to the dot switch case\n+        if (isDotStart) {\n+            nextChar = LexerTerminals.DOT;\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTI5OTQwMw=="}, "originalCommit": {"oid": "7124776e7ea1bce1cf4e3b355626dd3ee90bec11"}, "originalPosition": 117}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4MjgyNDIyOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaLexer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNlQxMjozODoxMVrOGMD9nA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNlQxMjozODoxMVrOGMD9nA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTMwMTAyMA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            while (true) {\n          \n          \n            \n                                if (isHexDigit(nextChar)) {\n          \n          \n            \n                            while (isHexDigit(nextChar)) {", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22827#discussion_r415301020", "createdAt": "2020-04-26T12:38:11Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaLexer.java", "diffHunk": "@@ -547,22 +711,64 @@ private STToken processNumericLiteral(int startChar) {\n      * <br/>\n      * HexDigit := Digit | a .. f | A .. F\n      * <br/>\n+     * HexFloatingPointLiteral := HexIndicator HexFloatingPointNumber\n+     * <br/>\n+     * HexFloatingPointNumber := HexNumber HexExponent | DottedHexNumber [HexExponent]\n+     * <br/>\n+     * DottedHexNumber := HexDigit+ . HexDigit* | . HexDigit+\n      * </code>\n-     * \n-     * @return\n+     *\n+     * @return The hex literal.\n      */\n-    private STToken processHexIntLiteral() {\n+    private STToken processHexLiteral() {\n         reader.advance();\n+\n+        // Make sure at least one hex-digit present if processing started from a dot\n+        if (peek() == LexerTerminals.DOT) {\n+            if (!isHexDigit(reader.peek(1))) {\n+                reader.advance();\n+                processInvalidToken();\n+                return readToken();\n+            }\n+        }\n+\n+        int nextChar;\n         while (isHexDigit(peek())) {\n             reader.advance();\n         }\n+        nextChar = peek();\n \n-        return getLiteral(SyntaxKind.HEX_INTEGER_LITERAL);\n+        switch (nextChar) {\n+            case LexerTerminals.DOT:\n+                reader.advance();\n+                nextChar = peek();\n+                while (true) {\n+                    if (isHexDigit(nextChar)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7124776e7ea1bce1cf4e3b355626dd3ee90bec11"}, "originalPosition": 290}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4NTAwODEwOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QwNzoxODowOVrOGMUVHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QwNzoxODowOVrOGMUVHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU2OTE4Mg==", "bodyText": "Saw a bug here. SIMPLE_NAME_REFERENCE added and fixed.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22827#discussion_r415569182", "createdAt": "2020-04-27T07:18:09Z", "author": {"login": "lochana-chathura"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -3047,6 +3051,7 @@ private boolean isValidLVExpr(STNode expression) {\n         switch (expression.kind) {\n             case IDENTIFIER_TOKEN:\n             case QUALIFIED_NAME_REFERENCE:\n+            case SIMPLE_NAME_REFERENCE:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0c057ffc4cad13fc885de020fd67f0d73f4a946d"}, "originalPosition": 15}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3752, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}