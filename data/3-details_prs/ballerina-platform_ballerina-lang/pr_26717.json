{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE0NjM3Njc1", "number": 26717, "title": "Initial Toml validator Implementation", "bodyText": "Purpose\nContains the initial Implementation of the Toml Validator. This validates the toml based on the given json schema.\nIn the initial version following features are supported.\n\n\nType Checking\n\nInteger - Minimum, Maximum\nString - pattern (regex)\n\n\n\nAdditionalProperties\n\n\nRelated Issues\nResolves #26716\nSamples\npublic class TestTomlValidator {\n    private static final PrintStream OUT = System.out;\n\n    public static void main(String [] args) throws IOException {\n        Path resourceDirectory = Paths.get(\"src\", \"test\", \"resources\", \"validator\", \"c2c-schema.json\");\n        TomlValidator validator = new TomlValidator(Schema.from(resourceDirectory));\n\n        Path sampleInput = Paths.get(\"src\", \"test\", \"resources\", \"validator\", \"sample.toml\");\n\n        Toml toml = Toml.read(sampleInput);\n        validator.validate(toml);\n\n        for (Diagnostic d: toml.diagnostics()) {\n            OUT.println(d);\n        }\n    }\n}\n\nParse and validate at the same time\n        Path resourceDirectory = Paths.get(\"src\", \"test\", \"schema.json\");\n        Path sampleInput = Paths.get(\"src\", \"test\", \"clean.toml\");\n\n        Toml toml = Toml.read(sampleInput, Schema.from(resourceDirectory));\n\n        for (Diagnostic d: toml.diagnostics()) {\n            OUT.println(d);\n        }\nSpecific feature based samples can be found in the test directory.\nBreaking API Changes\nList<TomlDiagnostic> getDiagnostics() -> List<Diagnostic> diagnostics() \nCheck List\n\n Read the Contributing Guide\n Updated Change Log\n Checked Tooling Support (#)\n Added necessary tests\n\n Unit Tests\n Spec Conformance Tests\n Integration Tests\n Ballerina By Example Tests\n\n\n Increased Test Coverage\n Added necessary documentation\n\n API documentation\n Module documentation in Module.md files\n Ballerina By Examples", "createdAt": "2020-11-03T10:32:59Z", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717", "merged": true, "mergeCommit": {"oid": "5b1a7b1da3897ad3505ae51a5ff481882668d50f"}, "closed": true, "closedAt": "2020-11-20T11:01:33Z", "author": {"login": "xlight05"}, "timelineItems": {"totalCount": 24, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdY2tdsgBqjM5NTIxODYxODI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdeVQyDAFqTUzNTMyNjQ2MA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f9ab48439730375c8ced4faa31abbf694adbf4be", "author": {"user": {"login": "xlight05", "name": "Anjana Supun"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f9ab48439730375c8ced4faa31abbf694adbf4be", "committedDate": "2020-11-03T10:20:49Z", "message": "Initial Impl of Toml Validator"}, "afterCommit": {"oid": "86c79f04b7d6cab034f17d955d3f729e24ad5170", "author": {"user": {"login": "xlight05", "name": "Anjana Supun"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/86c79f04b7d6cab034f17d955d3f729e24ad5170", "committedDate": "2020-11-03T10:35:30Z", "message": "Initial Impl of Toml Validator"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "86c79f04b7d6cab034f17d955d3f729e24ad5170", "author": {"user": {"login": "xlight05", "name": "Anjana Supun"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/86c79f04b7d6cab034f17d955d3f729e24ad5170", "committedDate": "2020-11-03T10:35:30Z", "message": "Initial Impl of Toml Validator"}, "afterCommit": {"oid": "3a0ebf5f973c60a7e17e18a84d2f96a3a5aeb830", "author": {"user": {"login": "xlight05", "name": "Anjana Supun"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3a0ebf5f973c60a7e17e18a84d2f96a3a5aeb830", "committedDate": "2020-11-03T10:40:39Z", "message": "Initial Impl of Toml Validator"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzMDM4Njcy", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#pullrequestreview-523038672", "createdAt": "2020-11-04T04:38:50Z", "commit": {"oid": "3a0ebf5f973c60a7e17e18a84d2f96a3a5aeb830"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwNDozODo1MFrOHtI4Bg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwNjo0MjoyN1rOHtK0Vg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzA5MzM4Mg==", "bodyText": "Licenses should come to the top.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#discussion_r517093382", "createdAt": "2020-11-04T04:38:50Z", "author": {"login": "anuruddhal"}, "path": "misc/toml-validator/src/main/java/io/ballerina/toml/validator/models/Schema.java", "diffHunk": "@@ -0,0 +1,97 @@\n+package io.ballerina.toml.validator.models;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a0ebf5f973c60a7e17e18a84d2f96a3a5aeb830"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzEyNTIwNg==", "bodyText": "Shall we add proper messages?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#discussion_r517125206", "createdAt": "2020-11-04T06:42:27Z", "author": {"login": "anuruddhal"}, "path": "misc/toml-validator/src/main/java/io/ballerina/toml/validator/models/Type.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.ballerina.toml.validator.models;\n+\n+import io.ballerina.toml.semantic.TomlType;\n+import io.ballerina.toml.semantic.ast.TomlKeyValueNode;\n+import io.ballerina.toml.semantic.ast.TomlLongValueNode;\n+import io.ballerina.toml.semantic.ast.TomlStringValueNode;\n+import io.ballerina.toml.semantic.ast.TomlValueNode;\n+import io.ballerina.toml.semantic.ast.TopLevelNode;\n+import io.ballerina.toml.semantic.diagnostics.TomlDiagnostic;\n+import io.ballerina.toml.semantic.diagnostics.TomlNodeLocation;\n+import io.ballerina.tools.diagnostics.DiagnosticInfo;\n+import io.ballerina.tools.diagnostics.DiagnosticSeverity;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Contains the validation logic related to Type checking and type related validations.\n+ *\n+ * @since 2.0.0\n+ */\n+public class Type implements Command {\n+\n+    private final Schema schema;\n+    private final TopLevelNode topLevelNode;\n+\n+    public Type(Schema schema, TopLevelNode topLevelNode) {\n+        this.schema = schema;\n+        this.topLevelNode = topLevelNode;\n+    }\n+\n+    @Override\n+    public List<TomlDiagnostic> apply() {\n+        List<TomlDiagnostic> diagnostics = new ArrayList<>();\n+\n+        if (topLevelNode == null) {\n+            return diagnostics;\n+        }\n+\n+        if (schema.getType().equals(\"object\")) {\n+            if (topLevelNode.kind() != TomlType.TABLE) {\n+                TomlDiagnostic diagnostic = getTomlDiagnostic(topLevelNode.location(), \"0000\", \"Message Here\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a0ebf5f973c60a7e17e18a84d2f96a3a5aeb830"}, "originalPosition": 61}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3a0ebf5f973c60a7e17e18a84d2f96a3a5aeb830", "author": {"user": {"login": "xlight05", "name": "Anjana Supun"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3a0ebf5f973c60a7e17e18a84d2f96a3a5aeb830", "committedDate": "2020-11-03T10:40:39Z", "message": "Initial Impl of Toml Validator"}, "afterCommit": {"oid": "01b68a4d57b003ff0ce1501f4cc5ee95ee4875f8", "author": {"user": {"login": "xlight05", "name": "Anjana Supun"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/01b68a4d57b003ff0ce1501f4cc5ee95ee4875f8", "committedDate": "2020-11-04T12:20:38Z", "message": "Initial Impl of Toml Validator"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "01b68a4d57b003ff0ce1501f4cc5ee95ee4875f8", "author": {"user": {"login": "xlight05", "name": "Anjana Supun"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/01b68a4d57b003ff0ce1501f4cc5ee95ee4875f8", "committedDate": "2020-11-04T12:20:38Z", "message": "Initial Impl of Toml Validator"}, "afterCommit": {"oid": "e2fc2e867d552ab8ec60249620fe4489c365a7fb", "author": {"user": {"login": "xlight05", "name": "Anjana Supun"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e2fc2e867d552ab8ec60249620fe4489c365a7fb", "committedDate": "2020-11-06T10:45:41Z", "message": "Make Toml object persist diagnostics"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e2fc2e867d552ab8ec60249620fe4489c365a7fb", "author": {"user": {"login": "xlight05", "name": "Anjana Supun"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e2fc2e867d552ab8ec60249620fe4489c365a7fb", "committedDate": "2020-11-06T10:45:41Z", "message": "Make Toml object persist diagnostics"}, "afterCommit": {"oid": "07e17551829888ef4642abaff6cc3d95c83bf1b8", "author": {"user": {"login": "xlight05", "name": "Anjana Supun"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/07e17551829888ef4642abaff6cc3d95c83bf1b8", "committedDate": "2020-11-10T10:58:02Z", "message": "Make Toml object persist diagnostics"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "07e17551829888ef4642abaff6cc3d95c83bf1b8", "author": {"user": {"login": "xlight05", "name": "Anjana Supun"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/07e17551829888ef4642abaff6cc3d95c83bf1b8", "committedDate": "2020-11-10T10:58:02Z", "message": "Make Toml object persist diagnostics"}, "afterCommit": {"oid": "735b35e4ad3f152d36632484187926ce0403c8cd", "author": {"user": {"login": "xlight05", "name": "Anjana Supun"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/735b35e4ad3f152d36632484187926ce0403c8cd", "committedDate": "2020-11-10T14:12:18Z", "message": "Fix diagnostic filename issue"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI4NzM0NjUz", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#pullrequestreview-528734653", "createdAt": "2020-11-12T04:01:44Z", "commit": {"oid": "735b35e4ad3f152d36632484187926ce0403c8cd"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI4NzMwMTU4", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#pullrequestreview-528730158", "createdAt": "2020-11-12T03:46:05Z", "commit": {"oid": "735b35e4ad3f152d36632484187926ce0403c8cd"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQwMzo0NjowNVrOHxo2og==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQwNDoxNzoxNFrOHxp7vQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTgxMTYxOA==", "bodyText": "Do we need this method?\nWe can use String content = new String(inputStream.readAllBytes(), StandardCharsets.UTF_8); to get the content from input stream", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#discussion_r521811618", "createdAt": "2020-11-12T03:46:05Z", "author": {"login": "SupunS"}, "path": "misc/toml-parser/src/main/java/io/ballerina/toml/api/Toml.java", "diffHunk": "@@ -82,45 +100,46 @@ public static Toml read(Path path) throws IOException {\n      * @throws IOException if file is not accessible\n      */\n     public static Toml read(InputStream inputStream) throws IOException {\n-        return read(new InputStreamReader(inputStream, StandardCharsets.UTF_8));\n+        return read(new InputStreamReader(inputStream, StandardCharsets.UTF_8), null);\n     }\n \n     /**\n      * Read TOML File using Reader.\n      *\n      * @param reader reader of the TOML file\n+     * @param filePath path of the TOML file\n      * @return TOML Object\n      * @throws IOException if file is not accessible\n      */\n-    public static Toml read(Reader reader) throws IOException {\n+    public static Toml read(Reader reader, String filePath) throws IOException {\n         BufferedReader bufferedReader = new BufferedReader(reader);\n         StringBuilder w = new StringBuilder();\n         for (String line = bufferedReader.readLine(); line != null; line = bufferedReader.readLine()) {\n             w.append(line).append('\\n');\n         }\n-        return read(w.toString());\n+        return read(w.toString(), filePath);\n     }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "735b35e4ad3f152d36632484187926ce0403c8cd"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTgxMzQxNw==", "bodyText": "We could use Files.readString(path)", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#discussion_r521813417", "createdAt": "2020-11-12T03:48:47Z", "author": {"login": "SupunS"}, "path": "misc/toml-parser/src/main/java/io/ballerina/toml/api/Toml.java", "diffHunk": "@@ -71,7 +84,12 @@ private Toml(TomlTableNode tomlTableNode) {\n      * @throws IOException if file is not accessible\n      */\n     public static Toml read(Path path) throws IOException {\n-        return read(Files.newBufferedReader(path));\n+        Path fileNamePath = path.getFileName();\n+        if (fileNamePath == null) {\n+            return null;\n+        }\n+        return read(Files.newBufferedReader(path),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "735b35e4ad3f152d36632484187926ce0403c8cd"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTgxNjEwNw==", "bodyText": "In getTable method, the condition in the if-clause is inverted. It's good to follow a single pattern in all places.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#discussion_r521816107", "createdAt": "2020-11-12T03:52:52Z", "author": {"login": "SupunS"}, "path": "misc/toml-parser/src/main/java/io/ballerina/toml/api/Toml.java", "diffHunk": "@@ -169,7 +188,7 @@ public Toml getTable(String key) {\n      */\n     public List<Toml> getTables(String key) {\n         TopLevelNode tableNode = rootNode.children().get(key);\n-        if (tableNode.kind() == TomlType.TABLE_ARRAY) {\n+        if (tableNode != null && tableNode.kind() == TomlType.TABLE_ARRAY) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "735b35e4ad3f152d36632484187926ce0403c8cd"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTgxNzU0NA==", "bodyText": "We can use a TreeSet with DiagnosticComparator to store diagnostics. Then we don't have to sort it every-time here.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#discussion_r521817544", "createdAt": "2020-11-12T03:54:57Z", "author": {"login": "SupunS"}, "path": "misc/toml-parser/src/main/java/io/ballerina/toml/api/Toml.java", "diffHunk": "@@ -181,7 +200,12 @@ public Toml getTable(String key) {\n         return null;\n     }\n \n-    public List<TomlDiagnostic> getDiagnostics() {\n-        return this.rootNode.diagnostics();\n+    public List<Diagnostic> getDiagnostics() {\n+        this.diagnostics.sort(new DiagnosticComparator());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "735b35e4ad3f152d36632484187926ce0403c8cd"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTgyMjAzMg==", "bodyText": "Shall we use the visitor pattern for validations? Each separate validator is a new visitor.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#discussion_r521822032", "createdAt": "2020-11-12T04:01:34Z", "author": {"login": "SupunS"}, "path": "misc/toml-validator/src/main/java/io/ballerina/toml/validator/models/Type.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.ballerina.toml.validator.models;\n+\n+import io.ballerina.toml.semantic.TomlType;\n+import io.ballerina.toml.semantic.ast.TomlKeyValueNode;\n+import io.ballerina.toml.semantic.ast.TomlLongValueNode;\n+import io.ballerina.toml.semantic.ast.TomlStringValueNode;\n+import io.ballerina.toml.semantic.ast.TomlValueNode;\n+import io.ballerina.toml.semantic.ast.TopLevelNode;\n+import io.ballerina.toml.semantic.diagnostics.TomlDiagnostic;\n+import io.ballerina.toml.semantic.diagnostics.TomlNodeLocation;\n+import io.ballerina.tools.diagnostics.Diagnostic;\n+import io.ballerina.tools.diagnostics.DiagnosticInfo;\n+import io.ballerina.tools.diagnostics.DiagnosticSeverity;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Contains the validation logic related to Type checking and type related validations.\n+ *\n+ * @since 2.0.0\n+ */\n+public class Type implements Command {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "735b35e4ad3f152d36632484187926ce0403c8cd"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTgyMzIwNg==", "bodyText": "Instead of returning diagnostics as a list, Can we append them to the TOML model then and there?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#discussion_r521823206", "createdAt": "2020-11-12T04:03:31Z", "author": {"login": "SupunS"}, "path": "misc/toml-validator/src/main/java/io/ballerina/toml/validator/models/Type.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.ballerina.toml.validator.models;\n+\n+import io.ballerina.toml.semantic.TomlType;\n+import io.ballerina.toml.semantic.ast.TomlKeyValueNode;\n+import io.ballerina.toml.semantic.ast.TomlLongValueNode;\n+import io.ballerina.toml.semantic.ast.TomlStringValueNode;\n+import io.ballerina.toml.semantic.ast.TomlValueNode;\n+import io.ballerina.toml.semantic.ast.TopLevelNode;\n+import io.ballerina.toml.semantic.diagnostics.TomlDiagnostic;\n+import io.ballerina.toml.semantic.diagnostics.TomlNodeLocation;\n+import io.ballerina.tools.diagnostics.Diagnostic;\n+import io.ballerina.tools.diagnostics.DiagnosticInfo;\n+import io.ballerina.tools.diagnostics.DiagnosticSeverity;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Contains the validation logic related to Type checking and type related validations.\n+ *\n+ * @since 2.0.0\n+ */\n+public class Type implements Command {\n+\n+    private final Schema schema;\n+    private final TopLevelNode topLevelNode;\n+\n+    public Type(Schema schema, TopLevelNode topLevelNode) {\n+        this.schema = schema;\n+        this.topLevelNode = topLevelNode;\n+    }\n+\n+    @Override\n+    public List<Diagnostic> apply() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "735b35e4ad3f152d36632484187926ce0403c8cd"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTgyNTAxOA==", "bodyText": "Can we have a better name for AdditionalProperties?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#discussion_r521825018", "createdAt": "2020-11-12T04:06:18Z", "author": {"login": "SupunS"}, "path": "misc/toml-validator/src/main/java/io/ballerina/toml/validator/models/AdditionalProperties.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.ballerina.toml.validator.models;\n+\n+import io.ballerina.toml.semantic.TomlType;\n+import io.ballerina.toml.semantic.ast.TomlTableNode;\n+import io.ballerina.toml.semantic.ast.TopLevelNode;\n+import io.ballerina.toml.semantic.diagnostics.TomlDiagnostic;\n+import io.ballerina.tools.diagnostics.Diagnostic;\n+import io.ballerina.tools.diagnostics.DiagnosticInfo;\n+import io.ballerina.tools.diagnostics.DiagnosticSeverity;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Contains the validation logic for AdditionalProperties in the JSON schema.\n+ *\n+ * @since 2.0.0\n+ */\n+public class AdditionalProperties implements Command {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "735b35e4ad3f152d36632484187926ce0403c8cd"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTgyNjk1NA==", "bodyText": "Add java-docs for all public APIs", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#discussion_r521826954", "createdAt": "2020-11-12T04:09:22Z", "author": {"login": "SupunS"}, "path": "misc/toml-validator/src/main/java/io/ballerina/toml/validator/models/Schema.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.ballerina.toml.validator.models;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.annotations.SerializedName;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Map;\n+\n+/**\n+ * Represents deserialized version of a Json Schema.\n+ */\n+public class Schema {\n+    @SerializedName(\"$schema\")\n+    private String schema;\n+    private String title;\n+    private String description;\n+    private String type;\n+    private boolean additionalProperties;\n+    private Map<String, Schema> properties;\n+    private Schema items;\n+    private Integer minimum;\n+    private Integer maximum;\n+    private String pattern;\n+\n+    private Schema () {}\n+\n+    public static Schema from(Path jsonPath) throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "735b35e4ad3f152d36632484187926ce0403c8cd"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTgyNzIwMA==", "bodyText": "Missing @since", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#discussion_r521827200", "createdAt": "2020-11-12T04:09:45Z", "author": {"login": "SupunS"}, "path": "misc/toml-validator/src/main/java/io/ballerina/toml/validator/models/Schema.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.ballerina.toml.validator.models;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.annotations.SerializedName;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Map;\n+\n+/**\n+ * Represents deserialized version of a Json Schema.\n+ */\n+public class Schema {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "735b35e4ad3f152d36632484187926ce0403c8cd"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTgyODQ3NQ==", "bodyText": "Can we call this a C2CSchemaValidator?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#discussion_r521828475", "createdAt": "2020-11-12T04:13:36Z", "author": {"login": "SupunS"}, "path": "misc/toml-validator/src/main/java/io/ballerina/toml/validator/models/Type.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.ballerina.toml.validator.models;\n+\n+import io.ballerina.toml.semantic.TomlType;\n+import io.ballerina.toml.semantic.ast.TomlKeyValueNode;\n+import io.ballerina.toml.semantic.ast.TomlLongValueNode;\n+import io.ballerina.toml.semantic.ast.TomlStringValueNode;\n+import io.ballerina.toml.semantic.ast.TomlValueNode;\n+import io.ballerina.toml.semantic.ast.TopLevelNode;\n+import io.ballerina.toml.semantic.diagnostics.TomlDiagnostic;\n+import io.ballerina.toml.semantic.diagnostics.TomlNodeLocation;\n+import io.ballerina.tools.diagnostics.Diagnostic;\n+import io.ballerina.tools.diagnostics.DiagnosticInfo;\n+import io.ballerina.tools.diagnostics.DiagnosticSeverity;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Contains the validation logic related to Type checking and type related validations.\n+ *\n+ * @since 2.0.0\n+ */\n+public class Type implements Command {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTgyMjAzMg=="}, "originalCommit": {"oid": "735b35e4ad3f152d36632484187926ce0403c8cd"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTgyOTMwOQ==", "bodyText": "Since this is a C2C specific validator implementation, I think this should go to the C2C repo.\nThe base validator framework can be moved to the toml-parser module itself.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#discussion_r521829309", "createdAt": "2020-11-12T04:17:14Z", "author": {"login": "SupunS"}, "path": "misc/toml-validator/src/main/java/io/ballerina/toml/validator/models/Type.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.ballerina.toml.validator.models;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "735b35e4ad3f152d36632484187926ce0403c8cd"}, "originalPosition": 19}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "735b35e4ad3f152d36632484187926ce0403c8cd", "author": {"user": {"login": "xlight05", "name": "Anjana Supun"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/735b35e4ad3f152d36632484187926ce0403c8cd", "committedDate": "2020-11-10T14:12:18Z", "message": "Fix diagnostic filename issue"}, "afterCommit": {"oid": "fb41946970d61a8ef366e9b8501b393ecdab712d", "author": {"user": {"login": "xlight05", "name": "Anjana Supun"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/fb41946970d61a8ef366e9b8501b393ecdab712d", "committedDate": "2020-11-13T10:35:39Z", "message": "Move toml validator into toml parser"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3f17c623a69b885381689f76ed19969647ed23f9", "author": {"user": {"login": "xlight05", "name": "Anjana Supun"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3f17c623a69b885381689f76ed19969647ed23f9", "committedDate": "2020-11-15T11:58:00Z", "message": "Remove Ballerina lang dependancy"}, "afterCommit": {"oid": "2bb042bc2a4e4f662b3761996071b8e1c0bd3aa5", "author": {"user": {"login": "xlight05", "name": "Anjana Supun"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2bb042bc2a4e4f662b3761996071b8e1c0bd3aa5", "committedDate": "2020-11-15T12:28:32Z", "message": "Remove Ballerina lang dependancy"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a2fb53e6cc964a6c3801833d2c4e014c8cc5bd9e", "author": {"user": {"login": "xlight05", "name": "Anjana Supun"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a2fb53e6cc964a6c3801833d2c4e014c8cc5bd9e", "committedDate": "2020-11-15T17:11:38Z", "message": "Improve validator error messages"}, "afterCommit": {"oid": "d241cf7d09135a267ebfa2e18dd9ceb551d829ff", "author": {"user": {"login": "xlight05", "name": "Anjana Supun"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/d241cf7d09135a267ebfa2e18dd9ceb551d829ff", "committedDate": "2020-11-15T17:13:44Z", "message": "Improve validator error messages"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d241cf7d09135a267ebfa2e18dd9ceb551d829ff", "author": {"user": {"login": "xlight05", "name": "Anjana Supun"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/d241cf7d09135a267ebfa2e18dd9ceb551d829ff", "committedDate": "2020-11-15T17:13:44Z", "message": "Improve validator error messages"}, "afterCommit": {"oid": "99c1f91e783f80a1e18990b522bf585e50df8a73", "author": {"user": {"login": "xlight05", "name": "Anjana Supun"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/99c1f91e783f80a1e18990b522bf585e50df8a73", "committedDate": "2020-11-18T13:24:18Z", "message": "Introduce one visitor instead of having multiple visitors for each validations"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "99c1f91e783f80a1e18990b522bf585e50df8a73", "author": {"user": {"login": "xlight05", "name": "Anjana Supun"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/99c1f91e783f80a1e18990b522bf585e50df8a73", "committedDate": "2020-11-18T13:24:18Z", "message": "Introduce one visitor instead of having multiple visitors for each validations"}, "afterCommit": {"oid": "df22a7272687960ca6a77f0054ed275dafee64a7", "author": {"user": {"login": "xlight05", "name": "Anjana Supun"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/df22a7272687960ca6a77f0054ed275dafee64a7", "committedDate": "2020-11-19T05:10:40Z", "message": "Make AST Visitor abstract class"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2a0f237f1364351f1a305b6aa1a2cbb7dcf5671d", "author": {"user": {"login": "xlight05", "name": "Anjana Supun"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2a0f237f1364351f1a305b6aa1a2cbb7dcf5671d", "committedDate": "2020-11-19T09:03:44Z", "message": "Initial Impl of Toml Validator\n\nMove toml validator into toml parser"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e88e4d88108b11607f08c1b5448818759f778b98", "author": {"user": {"login": "xlight05", "name": "Anjana Supun"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e88e4d88108b11607f08c1b5448818759f778b98", "committedDate": "2020-11-19T09:03:44Z", "message": "Make ast nodes store diagnostics"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e0a952d8c1b206b7e6003be6504564d4554794a2", "author": {"user": {"login": "xlight05", "name": "Anjana Supun"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e0a952d8c1b206b7e6003be6504564d4554794a2", "committedDate": "2020-11-19T09:03:44Z", "message": "Add hierarchical schemas"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dfd443c9b29690575d2a7ee9c241ed56253f4b0e", "author": {"user": {"login": "xlight05", "name": "Anjana Supun"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/dfd443c9b29690575d2a7ee9c241ed56253f4b0e", "committedDate": "2020-11-19T09:03:44Z", "message": "Introduce one visitor instead of having multiple visitors for each validations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4e52cd5571f73c88ed5c1706c22ed418a36cc0c0", "author": {"user": {"login": "xlight05", "name": "Anjana Supun"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/4e52cd5571f73c88ed5c1706c22ed418a36cc0c0", "committedDate": "2020-11-19T09:03:44Z", "message": "Make AST Visitor abstract class"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "df22a7272687960ca6a77f0054ed275dafee64a7", "author": {"user": {"login": "xlight05", "name": "Anjana Supun"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/df22a7272687960ca6a77f0054ed275dafee64a7", "committedDate": "2020-11-19T05:10:40Z", "message": "Make AST Visitor abstract class"}, "afterCommit": {"oid": "4e52cd5571f73c88ed5c1706c22ed418a36cc0c0", "author": {"user": {"login": "xlight05", "name": "Anjana Supun"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/4e52cd5571f73c88ed5c1706c22ed418a36cc0c0", "committedDate": "2020-11-19T09:03:44Z", "message": "Make AST Visitor abstract class"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2cdb11e327e94a5d61713ea806ea31a91833ec3a", "author": {"user": {"login": "xlight05", "name": "Anjana Supun"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2cdb11e327e94a5d61713ea806ea31a91833ec3a", "committedDate": "2020-11-19T11:56:07Z", "message": "Address review suggestions"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM1MDc0NzMz", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#pullrequestreview-535074733", "createdAt": "2020-11-20T04:41:19Z", "commit": {"oid": "2cdb11e327e94a5d61713ea806ea31a91833ec3a"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 21, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQwNDo0MToyMFrOH29jNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQwNTozMzo0M1rOH2-2Cg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzM5MzU5MQ==", "bodyText": "Remove the commented out codes", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#discussion_r527393591", "createdAt": "2020-11-20T04:41:20Z", "author": {"login": "SupunS"}, "path": "misc/toml-parser/src/main/java/io/ballerina/toml/semantic/ast/TomlNode.java", "diffHunk": "@@ -32,29 +33,38 @@\n public abstract class TomlNode implements Node {\n \n     private final TomlType kind;\n-    private final List<TomlDiagnostic> diagnostics;\n-    private final TomlNodeLocation location; //The position of this node in the source file.\n+    private final TomlNodeLocation location;\n+    protected Set<Diagnostic> diagnostics;\n \n     public TomlNode(TomlType kind, TomlNodeLocation location) {\n-        this.diagnostics = new ArrayList<>();\n         this.kind = kind;\n         this.location = location;\n+        diagnostics = new TreeSet<>(new DiagnosticComparator());\n+//        copySyntaxDiagnostics();\n     }\n \n     public abstract void accept(TomlNodeVisitor visitor);\n \n-    public List<TomlDiagnostic> diagnostics() {\n+    public Set<Diagnostic> diagnostics() {\n         return diagnostics;\n     }\n \n-    public void addDiagnostic(TomlDiagnostic diagnostic) {\n+    public void addDiagnostic(Diagnostic diagnostic) {\n         diagnostics.add(diagnostic);\n     }\n \n     public TomlNodeLocation location() {\n         return location;\n     }\n \n+//    private void copySyntaxDiagnostics() {\n+//        if (stNode != null && stNode.hasDiagnostics()) {\n+//            for (Diagnostic diagnostic : stNode.diagnostics()) {\n+//                this.addDiagnostic(diagnostic);\n+//            }\n+//        }\n+//    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2cdb11e327e94a5d61713ea806ea31a91833ec3a"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzM5NDA4Mg==", "bodyText": "Its better for the API to return a List<Diagnostic>", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#discussion_r527394082", "createdAt": "2020-11-20T04:43:04Z", "author": {"login": "SupunS"}, "path": "misc/toml-parser/src/main/java/io/ballerina/toml/semantic/ast/TomlNode.java", "diffHunk": "@@ -32,29 +33,38 @@\n public abstract class TomlNode implements Node {\n \n     private final TomlType kind;\n-    private final List<TomlDiagnostic> diagnostics;\n-    private final TomlNodeLocation location; //The position of this node in the source file.\n+    private final TomlNodeLocation location;\n+    protected Set<Diagnostic> diagnostics;\n \n     public TomlNode(TomlType kind, TomlNodeLocation location) {\n-        this.diagnostics = new ArrayList<>();\n         this.kind = kind;\n         this.location = location;\n+        diagnostics = new TreeSet<>(new DiagnosticComparator());\n+//        copySyntaxDiagnostics();\n     }\n \n     public abstract void accept(TomlNodeVisitor visitor);\n \n-    public List<TomlDiagnostic> diagnostics() {\n+    public Set<Diagnostic> diagnostics() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2cdb11e327e94a5d61713ea806ea31a91833ec3a"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzM5NDY5Nw==", "bodyText": "Lets follow the early-exit pattern for if-else conditions", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#discussion_r527394697", "createdAt": "2020-11-20T04:45:39Z", "author": {"login": "SupunS"}, "path": "misc/toml-parser/src/main/java/io/ballerina/toml/validator/SchemaValidator.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.ballerina.toml.validator;\n+\n+import io.ballerina.toml.semantic.ast.TomlBooleanValueNode;\n+import io.ballerina.toml.semantic.ast.TomlDoubleValueNodeNode;\n+import io.ballerina.toml.semantic.ast.TomlKeyValueNode;\n+import io.ballerina.toml.semantic.ast.TomlLongValueNode;\n+import io.ballerina.toml.semantic.ast.TomlNode;\n+import io.ballerina.toml.semantic.ast.TomlNodeVisitor;\n+import io.ballerina.toml.semantic.ast.TomlStringValueNode;\n+import io.ballerina.toml.semantic.ast.TomlTableArrayNode;\n+import io.ballerina.toml.semantic.ast.TomlTableNode;\n+import io.ballerina.toml.semantic.ast.TomlValueNode;\n+import io.ballerina.toml.semantic.ast.TopLevelNode;\n+import io.ballerina.toml.semantic.diagnostics.TomlDiagnostic;\n+import io.ballerina.toml.semantic.diagnostics.TomlNodeLocation;\n+import io.ballerina.toml.validator.schema.AbstractSchema;\n+import io.ballerina.toml.validator.schema.ArraySchema;\n+import io.ballerina.toml.validator.schema.NumericSchema;\n+import io.ballerina.toml.validator.schema.ObjectSchema;\n+import io.ballerina.toml.validator.schema.Schema;\n+import io.ballerina.toml.validator.schema.StringSchema;\n+import io.ballerina.toml.validator.schema.Type;\n+import io.ballerina.tools.diagnostics.Diagnostic;\n+import io.ballerina.tools.diagnostics.DiagnosticInfo;\n+import io.ballerina.tools.diagnostics.DiagnosticSeverity;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Visitor to validate toml object against rules in json schema.\n+ *\n+ * @since 2.0.0\n+ */\n+public class SchemaValidator extends TomlNodeVisitor {\n+\n+    private AbstractSchema schema;\n+    private String key;\n+\n+    public SchemaValidator(Schema schema) {\n+        this.schema = schema;\n+    }\n+\n+    @Override\n+    public void visit(TomlTableNode tomlTableNode) {\n+        if (schema.type() != Type.OBJECT) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2cdb11e327e94a5d61713ea806ea31a91833ec3a"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzM5NTQ0MQ==", "bodyText": "Let's follow a similar approach that is used in the parser and compiler to log diagnostics, using diagnostic codes and templates.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#discussion_r527395441", "createdAt": "2020-11-20T04:48:48Z", "author": {"login": "SupunS"}, "path": "misc/toml-parser/src/main/java/io/ballerina/toml/validator/SchemaValidator.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.ballerina.toml.validator;\n+\n+import io.ballerina.toml.semantic.ast.TomlBooleanValueNode;\n+import io.ballerina.toml.semantic.ast.TomlDoubleValueNodeNode;\n+import io.ballerina.toml.semantic.ast.TomlKeyValueNode;\n+import io.ballerina.toml.semantic.ast.TomlLongValueNode;\n+import io.ballerina.toml.semantic.ast.TomlNode;\n+import io.ballerina.toml.semantic.ast.TomlNodeVisitor;\n+import io.ballerina.toml.semantic.ast.TomlStringValueNode;\n+import io.ballerina.toml.semantic.ast.TomlTableArrayNode;\n+import io.ballerina.toml.semantic.ast.TomlTableNode;\n+import io.ballerina.toml.semantic.ast.TomlValueNode;\n+import io.ballerina.toml.semantic.ast.TopLevelNode;\n+import io.ballerina.toml.semantic.diagnostics.TomlDiagnostic;\n+import io.ballerina.toml.semantic.diagnostics.TomlNodeLocation;\n+import io.ballerina.toml.validator.schema.AbstractSchema;\n+import io.ballerina.toml.validator.schema.ArraySchema;\n+import io.ballerina.toml.validator.schema.NumericSchema;\n+import io.ballerina.toml.validator.schema.ObjectSchema;\n+import io.ballerina.toml.validator.schema.Schema;\n+import io.ballerina.toml.validator.schema.StringSchema;\n+import io.ballerina.toml.validator.schema.Type;\n+import io.ballerina.tools.diagnostics.Diagnostic;\n+import io.ballerina.tools.diagnostics.DiagnosticInfo;\n+import io.ballerina.tools.diagnostics.DiagnosticSeverity;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Visitor to validate toml object against rules in json schema.\n+ *\n+ * @since 2.0.0\n+ */\n+public class SchemaValidator extends TomlNodeVisitor {\n+\n+    private AbstractSchema schema;\n+    private String key;\n+\n+    public SchemaValidator(Schema schema) {\n+        this.schema = schema;\n+    }\n+\n+    @Override\n+    public void visit(TomlTableNode tomlTableNode) {\n+        if (schema.type() != Type.OBJECT) {\n+            TomlDiagnostic diagnostic = getTomlDiagnostic(tomlTableNode.location(), \"TVE0002\", \"error.invalid.type\",\n+                    DiagnosticSeverity.ERROR, String.format(\"Key \\\"%s\\\" expects %s . Found object\", this.key,\n+                            schema.type()));\n+            tomlTableNode.addDiagnostic(diagnostic);\n+        } else {\n+            ObjectSchema objectSchema = (ObjectSchema) schema;\n+            Map<String, AbstractSchema> properties = objectSchema.properties();\n+            Map<String, TopLevelNode> tableChildren = tomlTableNode.children();\n+            for (Map.Entry<String, TopLevelNode> propertyEntry : tableChildren.entrySet()) {\n+                String key = propertyEntry.getKey();\n+                TopLevelNode value = propertyEntry.getValue();\n+                AbstractSchema abstractSchema = properties.get(key);\n+                if (abstractSchema != null) {\n+                    this.schema = abstractSchema;\n+                    this.key = key;\n+                    lookupNode(value);\n+                } else {\n+                    if (!objectSchema.hasAdditionalProperties()) {\n+                        DiagnosticInfo diagnosticInfo = new DiagnosticInfo(\"TVE0001\", \"warn.unexpected.property\",\n+                                DiagnosticSeverity.WARNING);\n+                        TomlDiagnostic diagnostic = new TomlDiagnostic(value.location(), diagnosticInfo,\n+                                \"Unexpected Property \\\"\" + key + \"\\\"\");\n+                        tomlTableNode.addDiagnostic(diagnostic);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visit(TomlTableArrayNode tomlTableArrayNode) {\n+        if (schema.type() != Type.ARRAY) {\n+            TomlDiagnostic diagnostic =\n+                    getTomlDiagnostic(tomlTableArrayNode.location(), \"TVE0002\", \"error.invalid.type\",\n+                            DiagnosticSeverity.ERROR, String.format(\"Key \\\"%s\\\" expects %s . Found array\", this.key,\n+                                    schema.type()));\n+            tomlTableArrayNode.addDiagnostic(diagnostic);\n+        } else {\n+            ArraySchema arraySchema = (ArraySchema) schema;\n+            AbstractSchema items = arraySchema.items();\n+            List<TomlTableNode> children = tomlTableArrayNode.children();\n+            for (TomlTableNode child : children) {\n+                this.schema = items;\n+                visit(child);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visit(TomlKeyValueNode keyValue) {\n+        TomlValueNode value = keyValue.value();\n+        lookupNode(value);\n+    }\n+\n+    @Override\n+    public void visit(TomlValueNode tomlValue) {\n+        lookupNode(tomlValue);\n+    }\n+\n+    @Override\n+    public void visit(TomlStringValueNode tomlStringValueNode) {\n+        if (schema.type() != Type.STRING) {\n+            TomlDiagnostic diagnostic =\n+                    getTomlDiagnostic(tomlStringValueNode.location(), \"TVE0002\", \"error.invalid.type\",\n+                            DiagnosticSeverity.ERROR,\n+                            String.format(\"Key \\\"%s\\\" expects %s . Found string\", this.key, schema.type()));\n+            tomlStringValueNode.addDiagnostic(diagnostic);\n+        } else {\n+            StringSchema stringSchema = (StringSchema) this.schema;\n+            if (stringSchema.pattern().isPresent()) {\n+                String pattern = stringSchema.pattern().get();\n+                if (!Pattern.compile(pattern).matcher(tomlStringValueNode.getValue()).matches()) {\n+                    TomlDiagnostic diagnostic = getTomlDiagnostic(tomlStringValueNode.location(), \"TVE0003\",\n+                            \"error.regex.mismatch\", DiagnosticSeverity.ERROR,\n+                            String.format(\"Key \\\"%s\\\" value does not match the Regex provided in Schema %s\", this.key,\n+                                    pattern));\n+                    tomlStringValueNode.addDiagnostic(diagnostic);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visit(TomlDoubleValueNodeNode tomlDoubleValueNodeNode) {\n+        if (schema.type() != Type.NUMBER) {\n+            TomlDiagnostic diagnostic = getTomlDiagnostic(tomlDoubleValueNodeNode.location(), \"TVE0002\",\n+                    \"error.invalid.type\", DiagnosticSeverity.ERROR,\n+                    String.format(\"Key \\\"%s\\\" expects %s . Found number\", this.key, schema.type()));\n+            tomlDoubleValueNodeNode.addDiagnostic(diagnostic);\n+        } else {\n+            List<Diagnostic> diagnostics =\n+                    validateMinMaxValues((NumericSchema) schema, tomlDoubleValueNodeNode.getValue(),\n+                            tomlDoubleValueNodeNode.location());\n+            for (Diagnostic diagnostic : diagnostics) {\n+                tomlDoubleValueNodeNode.addDiagnostic(diagnostic);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visit(TomlLongValueNode tomlLongValueNode) {\n+        if (schema.type() != Type.INTEGER) {\n+            TomlDiagnostic diagnostic = getTomlDiagnostic(tomlLongValueNode.location(), \"TVE0002\",\n+                    \"error.invalid.type\", DiagnosticSeverity.ERROR,\n+                    String.format(\"Key \\\"%s\\\" expects %s . Found integer\", this.key, schema.type()));\n+            tomlLongValueNode.addDiagnostic(diagnostic);\n+        } else {\n+            List<Diagnostic> diagnostics =\n+                    validateMinMaxValues((NumericSchema) schema, Double.valueOf(tomlLongValueNode.getValue()),\n+                            tomlLongValueNode.location());\n+            for (Diagnostic diagnostic : diagnostics) {\n+                tomlLongValueNode.addDiagnostic(diagnostic);\n+            }\n+        }\n+    }\n+\n+    private List<Diagnostic> validateMinMaxValues(NumericSchema numericSchema, Double value,\n+                                                  TomlNodeLocation location) {\n+        List<Diagnostic> diagnostics = new ArrayList<>();\n+        if (numericSchema.maximum().isPresent()) {\n+            Double max = numericSchema.maximum().get();\n+            if (value >= max) {\n+                TomlDiagnostic diagnostic = getTomlDiagnostic(location, \"TVE0005\", \"error\" +\n+                                \".maximum.value.exceed\", DiagnosticSeverity.ERROR,\n+                        String.format(\"Key \\\"%s\\\" value can't be higher than %f\", this.key,\n+                                max));\n+                diagnostics.add(diagnostic);\n+            }\n+        }\n+        if (numericSchema.minimum().isPresent()) {\n+            Double min = numericSchema.minimum().get();\n+            if (value <= min) {\n+                TomlDiagnostic diagnostic = getTomlDiagnostic(location, \"TVE0004\",\n+                        \"error.minimum.value.deceed\", DiagnosticSeverity.ERROR,\n+                        String.format(\"Key \\\"%s\\\" value can't be lower than %f\", this.key,\n+                                min));\n+                diagnostics.add(diagnostic);\n+            }\n+        }\n+        return diagnostics;\n+    }\n+\n+    @Override\n+    public void visit(TomlBooleanValueNode tomlBooleanValueNode) {\n+        if (schema.type() != Type.BOOLEAN) {\n+            TomlDiagnostic diagnostic = getTomlDiagnostic(tomlBooleanValueNode.location(), \"TVE0002\",\n+                    \"error.invalid.type\", DiagnosticSeverity.ERROR,\n+                    String.format(\"Key \\\"%s\\\" expects %s . Found boolean\", this.key, schema.type()));\n+            tomlBooleanValueNode.addDiagnostic(diagnostic);\n+        }\n+    }\n+\n+    private void lookupNode(TomlNode node) {\n+        AbstractSchema previousSchema = this.schema;\n+        String previousKey = this.key;\n+        node.accept(this);\n+        this.schema = previousSchema;\n+        this.key = previousKey;\n+    }\n+\n+    private TomlDiagnostic getTomlDiagnostic(TomlNodeLocation location, String code, String template,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2cdb11e327e94a5d61713ea806ea31a91833ec3a"}, "originalPosition": 227}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzM5NTkyMQ==", "bodyText": "lookupNode -> visitNode", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#discussion_r527395921", "createdAt": "2020-11-20T04:50:37Z", "author": {"login": "SupunS"}, "path": "misc/toml-parser/src/main/java/io/ballerina/toml/validator/SchemaValidator.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.ballerina.toml.validator;\n+\n+import io.ballerina.toml.semantic.ast.TomlBooleanValueNode;\n+import io.ballerina.toml.semantic.ast.TomlDoubleValueNodeNode;\n+import io.ballerina.toml.semantic.ast.TomlKeyValueNode;\n+import io.ballerina.toml.semantic.ast.TomlLongValueNode;\n+import io.ballerina.toml.semantic.ast.TomlNode;\n+import io.ballerina.toml.semantic.ast.TomlNodeVisitor;\n+import io.ballerina.toml.semantic.ast.TomlStringValueNode;\n+import io.ballerina.toml.semantic.ast.TomlTableArrayNode;\n+import io.ballerina.toml.semantic.ast.TomlTableNode;\n+import io.ballerina.toml.semantic.ast.TomlValueNode;\n+import io.ballerina.toml.semantic.ast.TopLevelNode;\n+import io.ballerina.toml.semantic.diagnostics.TomlDiagnostic;\n+import io.ballerina.toml.semantic.diagnostics.TomlNodeLocation;\n+import io.ballerina.toml.validator.schema.AbstractSchema;\n+import io.ballerina.toml.validator.schema.ArraySchema;\n+import io.ballerina.toml.validator.schema.NumericSchema;\n+import io.ballerina.toml.validator.schema.ObjectSchema;\n+import io.ballerina.toml.validator.schema.Schema;\n+import io.ballerina.toml.validator.schema.StringSchema;\n+import io.ballerina.toml.validator.schema.Type;\n+import io.ballerina.tools.diagnostics.Diagnostic;\n+import io.ballerina.tools.diagnostics.DiagnosticInfo;\n+import io.ballerina.tools.diagnostics.DiagnosticSeverity;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Visitor to validate toml object against rules in json schema.\n+ *\n+ * @since 2.0.0\n+ */\n+public class SchemaValidator extends TomlNodeVisitor {\n+\n+    private AbstractSchema schema;\n+    private String key;\n+\n+    public SchemaValidator(Schema schema) {\n+        this.schema = schema;\n+    }\n+\n+    @Override\n+    public void visit(TomlTableNode tomlTableNode) {\n+        if (schema.type() != Type.OBJECT) {\n+            TomlDiagnostic diagnostic = getTomlDiagnostic(tomlTableNode.location(), \"TVE0002\", \"error.invalid.type\",\n+                    DiagnosticSeverity.ERROR, String.format(\"Key \\\"%s\\\" expects %s . Found object\", this.key,\n+                            schema.type()));\n+            tomlTableNode.addDiagnostic(diagnostic);\n+        } else {\n+            ObjectSchema objectSchema = (ObjectSchema) schema;\n+            Map<String, AbstractSchema> properties = objectSchema.properties();\n+            Map<String, TopLevelNode> tableChildren = tomlTableNode.children();\n+            for (Map.Entry<String, TopLevelNode> propertyEntry : tableChildren.entrySet()) {\n+                String key = propertyEntry.getKey();\n+                TopLevelNode value = propertyEntry.getValue();\n+                AbstractSchema abstractSchema = properties.get(key);\n+                if (abstractSchema != null) {\n+                    this.schema = abstractSchema;\n+                    this.key = key;\n+                    lookupNode(value);\n+                } else {\n+                    if (!objectSchema.hasAdditionalProperties()) {\n+                        DiagnosticInfo diagnosticInfo = new DiagnosticInfo(\"TVE0001\", \"warn.unexpected.property\",\n+                                DiagnosticSeverity.WARNING);\n+                        TomlDiagnostic diagnostic = new TomlDiagnostic(value.location(), diagnosticInfo,\n+                                \"Unexpected Property \\\"\" + key + \"\\\"\");\n+                        tomlTableNode.addDiagnostic(diagnostic);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visit(TomlTableArrayNode tomlTableArrayNode) {\n+        if (schema.type() != Type.ARRAY) {\n+            TomlDiagnostic diagnostic =\n+                    getTomlDiagnostic(tomlTableArrayNode.location(), \"TVE0002\", \"error.invalid.type\",\n+                            DiagnosticSeverity.ERROR, String.format(\"Key \\\"%s\\\" expects %s . Found array\", this.key,\n+                                    schema.type()));\n+            tomlTableArrayNode.addDiagnostic(diagnostic);\n+        } else {\n+            ArraySchema arraySchema = (ArraySchema) schema;\n+            AbstractSchema items = arraySchema.items();\n+            List<TomlTableNode> children = tomlTableArrayNode.children();\n+            for (TomlTableNode child : children) {\n+                this.schema = items;\n+                visit(child);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visit(TomlKeyValueNode keyValue) {\n+        TomlValueNode value = keyValue.value();\n+        lookupNode(value);\n+    }\n+\n+    @Override\n+    public void visit(TomlValueNode tomlValue) {\n+        lookupNode(tomlValue);\n+    }\n+\n+    @Override\n+    public void visit(TomlStringValueNode tomlStringValueNode) {\n+        if (schema.type() != Type.STRING) {\n+            TomlDiagnostic diagnostic =\n+                    getTomlDiagnostic(tomlStringValueNode.location(), \"TVE0002\", \"error.invalid.type\",\n+                            DiagnosticSeverity.ERROR,\n+                            String.format(\"Key \\\"%s\\\" expects %s . Found string\", this.key, schema.type()));\n+            tomlStringValueNode.addDiagnostic(diagnostic);\n+        } else {\n+            StringSchema stringSchema = (StringSchema) this.schema;\n+            if (stringSchema.pattern().isPresent()) {\n+                String pattern = stringSchema.pattern().get();\n+                if (!Pattern.compile(pattern).matcher(tomlStringValueNode.getValue()).matches()) {\n+                    TomlDiagnostic diagnostic = getTomlDiagnostic(tomlStringValueNode.location(), \"TVE0003\",\n+                            \"error.regex.mismatch\", DiagnosticSeverity.ERROR,\n+                            String.format(\"Key \\\"%s\\\" value does not match the Regex provided in Schema %s\", this.key,\n+                                    pattern));\n+                    tomlStringValueNode.addDiagnostic(diagnostic);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visit(TomlDoubleValueNodeNode tomlDoubleValueNodeNode) {\n+        if (schema.type() != Type.NUMBER) {\n+            TomlDiagnostic diagnostic = getTomlDiagnostic(tomlDoubleValueNodeNode.location(), \"TVE0002\",\n+                    \"error.invalid.type\", DiagnosticSeverity.ERROR,\n+                    String.format(\"Key \\\"%s\\\" expects %s . Found number\", this.key, schema.type()));\n+            tomlDoubleValueNodeNode.addDiagnostic(diagnostic);\n+        } else {\n+            List<Diagnostic> diagnostics =\n+                    validateMinMaxValues((NumericSchema) schema, tomlDoubleValueNodeNode.getValue(),\n+                            tomlDoubleValueNodeNode.location());\n+            for (Diagnostic diagnostic : diagnostics) {\n+                tomlDoubleValueNodeNode.addDiagnostic(diagnostic);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visit(TomlLongValueNode tomlLongValueNode) {\n+        if (schema.type() != Type.INTEGER) {\n+            TomlDiagnostic diagnostic = getTomlDiagnostic(tomlLongValueNode.location(), \"TVE0002\",\n+                    \"error.invalid.type\", DiagnosticSeverity.ERROR,\n+                    String.format(\"Key \\\"%s\\\" expects %s . Found integer\", this.key, schema.type()));\n+            tomlLongValueNode.addDiagnostic(diagnostic);\n+        } else {\n+            List<Diagnostic> diagnostics =\n+                    validateMinMaxValues((NumericSchema) schema, Double.valueOf(tomlLongValueNode.getValue()),\n+                            tomlLongValueNode.location());\n+            for (Diagnostic diagnostic : diagnostics) {\n+                tomlLongValueNode.addDiagnostic(diagnostic);\n+            }\n+        }\n+    }\n+\n+    private List<Diagnostic> validateMinMaxValues(NumericSchema numericSchema, Double value,\n+                                                  TomlNodeLocation location) {\n+        List<Diagnostic> diagnostics = new ArrayList<>();\n+        if (numericSchema.maximum().isPresent()) {\n+            Double max = numericSchema.maximum().get();\n+            if (value >= max) {\n+                TomlDiagnostic diagnostic = getTomlDiagnostic(location, \"TVE0005\", \"error\" +\n+                                \".maximum.value.exceed\", DiagnosticSeverity.ERROR,\n+                        String.format(\"Key \\\"%s\\\" value can't be higher than %f\", this.key,\n+                                max));\n+                diagnostics.add(diagnostic);\n+            }\n+        }\n+        if (numericSchema.minimum().isPresent()) {\n+            Double min = numericSchema.minimum().get();\n+            if (value <= min) {\n+                TomlDiagnostic diagnostic = getTomlDiagnostic(location, \"TVE0004\",\n+                        \"error.minimum.value.deceed\", DiagnosticSeverity.ERROR,\n+                        String.format(\"Key \\\"%s\\\" value can't be lower than %f\", this.key,\n+                                min));\n+                diagnostics.add(diagnostic);\n+            }\n+        }\n+        return diagnostics;\n+    }\n+\n+    @Override\n+    public void visit(TomlBooleanValueNode tomlBooleanValueNode) {\n+        if (schema.type() != Type.BOOLEAN) {\n+            TomlDiagnostic diagnostic = getTomlDiagnostic(tomlBooleanValueNode.location(), \"TVE0002\",\n+                    \"error.invalid.type\", DiagnosticSeverity.ERROR,\n+                    String.format(\"Key \\\"%s\\\" expects %s . Found boolean\", this.key, schema.type()));\n+            tomlBooleanValueNode.addDiagnostic(diagnostic);\n+        }\n+    }\n+\n+    private void lookupNode(TomlNode node) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2cdb11e327e94a5d61713ea806ea31a91833ec3a"}, "originalPosition": 219}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzM5NjQwOA==", "bodyText": "This seems to not correct. You are caching the state only after changing it. So what you cache is the changed state, not the original state.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#discussion_r527396408", "createdAt": "2020-11-20T04:52:18Z", "author": {"login": "SupunS"}, "path": "misc/toml-parser/src/main/java/io/ballerina/toml/validator/SchemaValidator.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.ballerina.toml.validator;\n+\n+import io.ballerina.toml.semantic.ast.TomlBooleanValueNode;\n+import io.ballerina.toml.semantic.ast.TomlDoubleValueNodeNode;\n+import io.ballerina.toml.semantic.ast.TomlKeyValueNode;\n+import io.ballerina.toml.semantic.ast.TomlLongValueNode;\n+import io.ballerina.toml.semantic.ast.TomlNode;\n+import io.ballerina.toml.semantic.ast.TomlNodeVisitor;\n+import io.ballerina.toml.semantic.ast.TomlStringValueNode;\n+import io.ballerina.toml.semantic.ast.TomlTableArrayNode;\n+import io.ballerina.toml.semantic.ast.TomlTableNode;\n+import io.ballerina.toml.semantic.ast.TomlValueNode;\n+import io.ballerina.toml.semantic.ast.TopLevelNode;\n+import io.ballerina.toml.semantic.diagnostics.TomlDiagnostic;\n+import io.ballerina.toml.semantic.diagnostics.TomlNodeLocation;\n+import io.ballerina.toml.validator.schema.AbstractSchema;\n+import io.ballerina.toml.validator.schema.ArraySchema;\n+import io.ballerina.toml.validator.schema.NumericSchema;\n+import io.ballerina.toml.validator.schema.ObjectSchema;\n+import io.ballerina.toml.validator.schema.Schema;\n+import io.ballerina.toml.validator.schema.StringSchema;\n+import io.ballerina.toml.validator.schema.Type;\n+import io.ballerina.tools.diagnostics.Diagnostic;\n+import io.ballerina.tools.diagnostics.DiagnosticInfo;\n+import io.ballerina.tools.diagnostics.DiagnosticSeverity;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Visitor to validate toml object against rules in json schema.\n+ *\n+ * @since 2.0.0\n+ */\n+public class SchemaValidator extends TomlNodeVisitor {\n+\n+    private AbstractSchema schema;\n+    private String key;\n+\n+    public SchemaValidator(Schema schema) {\n+        this.schema = schema;\n+    }\n+\n+    @Override\n+    public void visit(TomlTableNode tomlTableNode) {\n+        if (schema.type() != Type.OBJECT) {\n+            TomlDiagnostic diagnostic = getTomlDiagnostic(tomlTableNode.location(), \"TVE0002\", \"error.invalid.type\",\n+                    DiagnosticSeverity.ERROR, String.format(\"Key \\\"%s\\\" expects %s . Found object\", this.key,\n+                            schema.type()));\n+            tomlTableNode.addDiagnostic(diagnostic);\n+        } else {\n+            ObjectSchema objectSchema = (ObjectSchema) schema;\n+            Map<String, AbstractSchema> properties = objectSchema.properties();\n+            Map<String, TopLevelNode> tableChildren = tomlTableNode.children();\n+            for (Map.Entry<String, TopLevelNode> propertyEntry : tableChildren.entrySet()) {\n+                String key = propertyEntry.getKey();\n+                TopLevelNode value = propertyEntry.getValue();\n+                AbstractSchema abstractSchema = properties.get(key);\n+                if (abstractSchema != null) {\n+                    this.schema = abstractSchema;\n+                    this.key = key;\n+                    lookupNode(value);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2cdb11e327e94a5d61713ea806ea31a91833ec3a"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzM5NzQxOA==", "bodyText": "A visitor should be visited using child.accept(this)", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#discussion_r527397418", "createdAt": "2020-11-20T04:56:18Z", "author": {"login": "SupunS"}, "path": "misc/toml-parser/src/main/java/io/ballerina/toml/validator/SchemaValidator.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.ballerina.toml.validator;\n+\n+import io.ballerina.toml.semantic.ast.TomlBooleanValueNode;\n+import io.ballerina.toml.semantic.ast.TomlDoubleValueNodeNode;\n+import io.ballerina.toml.semantic.ast.TomlKeyValueNode;\n+import io.ballerina.toml.semantic.ast.TomlLongValueNode;\n+import io.ballerina.toml.semantic.ast.TomlNode;\n+import io.ballerina.toml.semantic.ast.TomlNodeVisitor;\n+import io.ballerina.toml.semantic.ast.TomlStringValueNode;\n+import io.ballerina.toml.semantic.ast.TomlTableArrayNode;\n+import io.ballerina.toml.semantic.ast.TomlTableNode;\n+import io.ballerina.toml.semantic.ast.TomlValueNode;\n+import io.ballerina.toml.semantic.ast.TopLevelNode;\n+import io.ballerina.toml.semantic.diagnostics.TomlDiagnostic;\n+import io.ballerina.toml.semantic.diagnostics.TomlNodeLocation;\n+import io.ballerina.toml.validator.schema.AbstractSchema;\n+import io.ballerina.toml.validator.schema.ArraySchema;\n+import io.ballerina.toml.validator.schema.NumericSchema;\n+import io.ballerina.toml.validator.schema.ObjectSchema;\n+import io.ballerina.toml.validator.schema.Schema;\n+import io.ballerina.toml.validator.schema.StringSchema;\n+import io.ballerina.toml.validator.schema.Type;\n+import io.ballerina.tools.diagnostics.Diagnostic;\n+import io.ballerina.tools.diagnostics.DiagnosticInfo;\n+import io.ballerina.tools.diagnostics.DiagnosticSeverity;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Visitor to validate toml object against rules in json schema.\n+ *\n+ * @since 2.0.0\n+ */\n+public class SchemaValidator extends TomlNodeVisitor {\n+\n+    private AbstractSchema schema;\n+    private String key;\n+\n+    public SchemaValidator(Schema schema) {\n+        this.schema = schema;\n+    }\n+\n+    @Override\n+    public void visit(TomlTableNode tomlTableNode) {\n+        if (schema.type() != Type.OBJECT) {\n+            TomlDiagnostic diagnostic = getTomlDiagnostic(tomlTableNode.location(), \"TVE0002\", \"error.invalid.type\",\n+                    DiagnosticSeverity.ERROR, String.format(\"Key \\\"%s\\\" expects %s . Found object\", this.key,\n+                            schema.type()));\n+            tomlTableNode.addDiagnostic(diagnostic);\n+        } else {\n+            ObjectSchema objectSchema = (ObjectSchema) schema;\n+            Map<String, AbstractSchema> properties = objectSchema.properties();\n+            Map<String, TopLevelNode> tableChildren = tomlTableNode.children();\n+            for (Map.Entry<String, TopLevelNode> propertyEntry : tableChildren.entrySet()) {\n+                String key = propertyEntry.getKey();\n+                TopLevelNode value = propertyEntry.getValue();\n+                AbstractSchema abstractSchema = properties.get(key);\n+                if (abstractSchema != null) {\n+                    this.schema = abstractSchema;\n+                    this.key = key;\n+                    lookupNode(value);\n+                } else {\n+                    if (!objectSchema.hasAdditionalProperties()) {\n+                        DiagnosticInfo diagnosticInfo = new DiagnosticInfo(\"TVE0001\", \"warn.unexpected.property\",\n+                                DiagnosticSeverity.WARNING);\n+                        TomlDiagnostic diagnostic = new TomlDiagnostic(value.location(), diagnosticInfo,\n+                                \"Unexpected Property \\\"\" + key + \"\\\"\");\n+                        tomlTableNode.addDiagnostic(diagnostic);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visit(TomlTableArrayNode tomlTableArrayNode) {\n+        if (schema.type() != Type.ARRAY) {\n+            TomlDiagnostic diagnostic =\n+                    getTomlDiagnostic(tomlTableArrayNode.location(), \"TVE0002\", \"error.invalid.type\",\n+                            DiagnosticSeverity.ERROR, String.format(\"Key \\\"%s\\\" expects %s . Found array\", this.key,\n+                                    schema.type()));\n+            tomlTableArrayNode.addDiagnostic(diagnostic);\n+        } else {\n+            ArraySchema arraySchema = (ArraySchema) schema;\n+            AbstractSchema items = arraySchema.items();\n+            List<TomlTableNode> children = tomlTableArrayNode.children();\n+            for (TomlTableNode child : children) {\n+                this.schema = items;\n+                visit(child);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2cdb11e327e94a5d61713ea806ea31a91833ec3a"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzM5ODM3Ng==", "bodyText": "variable name abstractSchema is a bit misleading. Shall we call it just schema?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#discussion_r527398376", "createdAt": "2020-11-20T05:00:07Z", "author": {"login": "SupunS"}, "path": "misc/toml-parser/src/main/java/io/ballerina/toml/validator/SchemaValidator.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.ballerina.toml.validator;\n+\n+import io.ballerina.toml.semantic.ast.TomlBooleanValueNode;\n+import io.ballerina.toml.semantic.ast.TomlDoubleValueNodeNode;\n+import io.ballerina.toml.semantic.ast.TomlKeyValueNode;\n+import io.ballerina.toml.semantic.ast.TomlLongValueNode;\n+import io.ballerina.toml.semantic.ast.TomlNode;\n+import io.ballerina.toml.semantic.ast.TomlNodeVisitor;\n+import io.ballerina.toml.semantic.ast.TomlStringValueNode;\n+import io.ballerina.toml.semantic.ast.TomlTableArrayNode;\n+import io.ballerina.toml.semantic.ast.TomlTableNode;\n+import io.ballerina.toml.semantic.ast.TomlValueNode;\n+import io.ballerina.toml.semantic.ast.TopLevelNode;\n+import io.ballerina.toml.semantic.diagnostics.TomlDiagnostic;\n+import io.ballerina.toml.semantic.diagnostics.TomlNodeLocation;\n+import io.ballerina.toml.validator.schema.AbstractSchema;\n+import io.ballerina.toml.validator.schema.ArraySchema;\n+import io.ballerina.toml.validator.schema.NumericSchema;\n+import io.ballerina.toml.validator.schema.ObjectSchema;\n+import io.ballerina.toml.validator.schema.Schema;\n+import io.ballerina.toml.validator.schema.StringSchema;\n+import io.ballerina.toml.validator.schema.Type;\n+import io.ballerina.tools.diagnostics.Diagnostic;\n+import io.ballerina.tools.diagnostics.DiagnosticInfo;\n+import io.ballerina.tools.diagnostics.DiagnosticSeverity;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Visitor to validate toml object against rules in json schema.\n+ *\n+ * @since 2.0.0\n+ */\n+public class SchemaValidator extends TomlNodeVisitor {\n+\n+    private AbstractSchema schema;\n+    private String key;\n+\n+    public SchemaValidator(Schema schema) {\n+        this.schema = schema;\n+    }\n+\n+    @Override\n+    public void visit(TomlTableNode tomlTableNode) {\n+        if (schema.type() != Type.OBJECT) {\n+            TomlDiagnostic diagnostic = getTomlDiagnostic(tomlTableNode.location(), \"TVE0002\", \"error.invalid.type\",\n+                    DiagnosticSeverity.ERROR, String.format(\"Key \\\"%s\\\" expects %s . Found object\", this.key,\n+                            schema.type()));\n+            tomlTableNode.addDiagnostic(diagnostic);\n+        } else {\n+            ObjectSchema objectSchema = (ObjectSchema) schema;\n+            Map<String, AbstractSchema> properties = objectSchema.properties();\n+            Map<String, TopLevelNode> tableChildren = tomlTableNode.children();\n+            for (Map.Entry<String, TopLevelNode> propertyEntry : tableChildren.entrySet()) {\n+                String key = propertyEntry.getKey();\n+                TopLevelNode value = propertyEntry.getValue();\n+                AbstractSchema abstractSchema = properties.get(key);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2cdb11e327e94a5d61713ea806ea31a91833ec3a"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzM5ODY2NA==", "bodyText": "Usually a table has 'entries'\nSo better to change tableChildren -> tableEntries\nIt would also be better to change the method name as well x.children() to x.entries()", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#discussion_r527398664", "createdAt": "2020-11-20T05:01:10Z", "author": {"login": "SupunS"}, "path": "misc/toml-parser/src/main/java/io/ballerina/toml/validator/SchemaValidator.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.ballerina.toml.validator;\n+\n+import io.ballerina.toml.semantic.ast.TomlBooleanValueNode;\n+import io.ballerina.toml.semantic.ast.TomlDoubleValueNodeNode;\n+import io.ballerina.toml.semantic.ast.TomlKeyValueNode;\n+import io.ballerina.toml.semantic.ast.TomlLongValueNode;\n+import io.ballerina.toml.semantic.ast.TomlNode;\n+import io.ballerina.toml.semantic.ast.TomlNodeVisitor;\n+import io.ballerina.toml.semantic.ast.TomlStringValueNode;\n+import io.ballerina.toml.semantic.ast.TomlTableArrayNode;\n+import io.ballerina.toml.semantic.ast.TomlTableNode;\n+import io.ballerina.toml.semantic.ast.TomlValueNode;\n+import io.ballerina.toml.semantic.ast.TopLevelNode;\n+import io.ballerina.toml.semantic.diagnostics.TomlDiagnostic;\n+import io.ballerina.toml.semantic.diagnostics.TomlNodeLocation;\n+import io.ballerina.toml.validator.schema.AbstractSchema;\n+import io.ballerina.toml.validator.schema.ArraySchema;\n+import io.ballerina.toml.validator.schema.NumericSchema;\n+import io.ballerina.toml.validator.schema.ObjectSchema;\n+import io.ballerina.toml.validator.schema.Schema;\n+import io.ballerina.toml.validator.schema.StringSchema;\n+import io.ballerina.toml.validator.schema.Type;\n+import io.ballerina.tools.diagnostics.Diagnostic;\n+import io.ballerina.tools.diagnostics.DiagnosticInfo;\n+import io.ballerina.tools.diagnostics.DiagnosticSeverity;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Visitor to validate toml object against rules in json schema.\n+ *\n+ * @since 2.0.0\n+ */\n+public class SchemaValidator extends TomlNodeVisitor {\n+\n+    private AbstractSchema schema;\n+    private String key;\n+\n+    public SchemaValidator(Schema schema) {\n+        this.schema = schema;\n+    }\n+\n+    @Override\n+    public void visit(TomlTableNode tomlTableNode) {\n+        if (schema.type() != Type.OBJECT) {\n+            TomlDiagnostic diagnostic = getTomlDiagnostic(tomlTableNode.location(), \"TVE0002\", \"error.invalid.type\",\n+                    DiagnosticSeverity.ERROR, String.format(\"Key \\\"%s\\\" expects %s . Found object\", this.key,\n+                            schema.type()));\n+            tomlTableNode.addDiagnostic(diagnostic);\n+        } else {\n+            ObjectSchema objectSchema = (ObjectSchema) schema;\n+            Map<String, AbstractSchema> properties = objectSchema.properties();\n+            Map<String, TopLevelNode> tableChildren = tomlTableNode.children();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2cdb11e327e94a5d61713ea806ea31a91833ec3a"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzM5ODk5MA==", "bodyText": "propertyEntry -> tableEntry", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#discussion_r527398990", "createdAt": "2020-11-20T05:02:19Z", "author": {"login": "SupunS"}, "path": "misc/toml-parser/src/main/java/io/ballerina/toml/validator/SchemaValidator.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.ballerina.toml.validator;\n+\n+import io.ballerina.toml.semantic.ast.TomlBooleanValueNode;\n+import io.ballerina.toml.semantic.ast.TomlDoubleValueNodeNode;\n+import io.ballerina.toml.semantic.ast.TomlKeyValueNode;\n+import io.ballerina.toml.semantic.ast.TomlLongValueNode;\n+import io.ballerina.toml.semantic.ast.TomlNode;\n+import io.ballerina.toml.semantic.ast.TomlNodeVisitor;\n+import io.ballerina.toml.semantic.ast.TomlStringValueNode;\n+import io.ballerina.toml.semantic.ast.TomlTableArrayNode;\n+import io.ballerina.toml.semantic.ast.TomlTableNode;\n+import io.ballerina.toml.semantic.ast.TomlValueNode;\n+import io.ballerina.toml.semantic.ast.TopLevelNode;\n+import io.ballerina.toml.semantic.diagnostics.TomlDiagnostic;\n+import io.ballerina.toml.semantic.diagnostics.TomlNodeLocation;\n+import io.ballerina.toml.validator.schema.AbstractSchema;\n+import io.ballerina.toml.validator.schema.ArraySchema;\n+import io.ballerina.toml.validator.schema.NumericSchema;\n+import io.ballerina.toml.validator.schema.ObjectSchema;\n+import io.ballerina.toml.validator.schema.Schema;\n+import io.ballerina.toml.validator.schema.StringSchema;\n+import io.ballerina.toml.validator.schema.Type;\n+import io.ballerina.tools.diagnostics.Diagnostic;\n+import io.ballerina.tools.diagnostics.DiagnosticInfo;\n+import io.ballerina.tools.diagnostics.DiagnosticSeverity;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Visitor to validate toml object against rules in json schema.\n+ *\n+ * @since 2.0.0\n+ */\n+public class SchemaValidator extends TomlNodeVisitor {\n+\n+    private AbstractSchema schema;\n+    private String key;\n+\n+    public SchemaValidator(Schema schema) {\n+        this.schema = schema;\n+    }\n+\n+    @Override\n+    public void visit(TomlTableNode tomlTableNode) {\n+        if (schema.type() != Type.OBJECT) {\n+            TomlDiagnostic diagnostic = getTomlDiagnostic(tomlTableNode.location(), \"TVE0002\", \"error.invalid.type\",\n+                    DiagnosticSeverity.ERROR, String.format(\"Key \\\"%s\\\" expects %s . Found object\", this.key,\n+                            schema.type()));\n+            tomlTableNode.addDiagnostic(diagnostic);\n+        } else {\n+            ObjectSchema objectSchema = (ObjectSchema) schema;\n+            Map<String, AbstractSchema> properties = objectSchema.properties();\n+            Map<String, TopLevelNode> tableChildren = tomlTableNode.children();\n+            for (Map.Entry<String, TopLevelNode> propertyEntry : tableChildren.entrySet()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2cdb11e327e94a5d61713ea806ea31a91833ec3a"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzQwMTAzOA==", "bodyText": "additionalProperties -> hasAdditionalProperties", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#discussion_r527401038", "createdAt": "2020-11-20T05:10:15Z", "author": {"login": "SupunS"}, "path": "misc/toml-parser/src/main/java/io/ballerina/toml/validator/schema/ObjectSchema.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.ballerina.toml.validator.schema;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+/**\n+ * Represents Object schema in JSON schema.\n+ *\n+ * @since 2.0.0\n+ */\n+public class ObjectSchema extends AbstractSchema {\n+    private String description;\n+    private boolean additionalProperties;\n+    private Map<String, AbstractSchema> properties;\n+\n+    public ObjectSchema(Type type) {\n+        super(type);\n+        this.additionalProperties = true;\n+        this.properties = new HashMap<>();\n+    }\n+\n+    public ObjectSchema(Type type, Map<String, AbstractSchema> properties) {\n+        super(type);\n+        this.additionalProperties = true;\n+        this.properties = properties;\n+    }\n+\n+    public ObjectSchema(Type type, String description, boolean additionalProperties,\n+                        Map<String, AbstractSchema> properties) {\n+        super(type);\n+        this.description = description;\n+        this.additionalProperties = additionalProperties;\n+        this.properties = properties;\n+    }\n+\n+    public Optional<String> description() {\n+        return Optional.ofNullable(description);\n+    }\n+\n+    public boolean hasAdditionalProperties() {\n+        return additionalProperties;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2cdb11e327e94a5d61713ea806ea31a91833ec3a"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzQwMTc4Mw==", "bodyText": "items -> memberSchema", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#discussion_r527401783", "createdAt": "2020-11-20T05:12:55Z", "author": {"login": "SupunS"}, "path": "misc/toml-parser/src/main/java/io/ballerina/toml/validator/SchemaValidator.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.ballerina.toml.validator;\n+\n+import io.ballerina.toml.semantic.ast.TomlBooleanValueNode;\n+import io.ballerina.toml.semantic.ast.TomlDoubleValueNodeNode;\n+import io.ballerina.toml.semantic.ast.TomlKeyValueNode;\n+import io.ballerina.toml.semantic.ast.TomlLongValueNode;\n+import io.ballerina.toml.semantic.ast.TomlNode;\n+import io.ballerina.toml.semantic.ast.TomlNodeVisitor;\n+import io.ballerina.toml.semantic.ast.TomlStringValueNode;\n+import io.ballerina.toml.semantic.ast.TomlTableArrayNode;\n+import io.ballerina.toml.semantic.ast.TomlTableNode;\n+import io.ballerina.toml.semantic.ast.TomlValueNode;\n+import io.ballerina.toml.semantic.ast.TopLevelNode;\n+import io.ballerina.toml.semantic.diagnostics.TomlDiagnostic;\n+import io.ballerina.toml.semantic.diagnostics.TomlNodeLocation;\n+import io.ballerina.toml.validator.schema.AbstractSchema;\n+import io.ballerina.toml.validator.schema.ArraySchema;\n+import io.ballerina.toml.validator.schema.NumericSchema;\n+import io.ballerina.toml.validator.schema.ObjectSchema;\n+import io.ballerina.toml.validator.schema.Schema;\n+import io.ballerina.toml.validator.schema.StringSchema;\n+import io.ballerina.toml.validator.schema.Type;\n+import io.ballerina.tools.diagnostics.Diagnostic;\n+import io.ballerina.tools.diagnostics.DiagnosticInfo;\n+import io.ballerina.tools.diagnostics.DiagnosticSeverity;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Visitor to validate toml object against rules in json schema.\n+ *\n+ * @since 2.0.0\n+ */\n+public class SchemaValidator extends TomlNodeVisitor {\n+\n+    private AbstractSchema schema;\n+    private String key;\n+\n+    public SchemaValidator(Schema schema) {\n+        this.schema = schema;\n+    }\n+\n+    @Override\n+    public void visit(TomlTableNode tomlTableNode) {\n+        if (schema.type() != Type.OBJECT) {\n+            TomlDiagnostic diagnostic = getTomlDiagnostic(tomlTableNode.location(), \"TVE0002\", \"error.invalid.type\",\n+                    DiagnosticSeverity.ERROR, String.format(\"Key \\\"%s\\\" expects %s . Found object\", this.key,\n+                            schema.type()));\n+            tomlTableNode.addDiagnostic(diagnostic);\n+        } else {\n+            ObjectSchema objectSchema = (ObjectSchema) schema;\n+            Map<String, AbstractSchema> properties = objectSchema.properties();\n+            Map<String, TopLevelNode> tableChildren = tomlTableNode.children();\n+            for (Map.Entry<String, TopLevelNode> propertyEntry : tableChildren.entrySet()) {\n+                String key = propertyEntry.getKey();\n+                TopLevelNode value = propertyEntry.getValue();\n+                AbstractSchema abstractSchema = properties.get(key);\n+                if (abstractSchema != null) {\n+                    this.schema = abstractSchema;\n+                    this.key = key;\n+                    lookupNode(value);\n+                } else {\n+                    if (!objectSchema.hasAdditionalProperties()) {\n+                        DiagnosticInfo diagnosticInfo = new DiagnosticInfo(\"TVE0001\", \"warn.unexpected.property\",\n+                                DiagnosticSeverity.WARNING);\n+                        TomlDiagnostic diagnostic = new TomlDiagnostic(value.location(), diagnosticInfo,\n+                                \"Unexpected Property \\\"\" + key + \"\\\"\");\n+                        tomlTableNode.addDiagnostic(diagnostic);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visit(TomlTableArrayNode tomlTableArrayNode) {\n+        if (schema.type() != Type.ARRAY) {\n+            TomlDiagnostic diagnostic =\n+                    getTomlDiagnostic(tomlTableArrayNode.location(), \"TVE0002\", \"error.invalid.type\",\n+                            DiagnosticSeverity.ERROR, String.format(\"Key \\\"%s\\\" expects %s . Found array\", this.key,\n+                                    schema.type()));\n+            tomlTableArrayNode.addDiagnostic(diagnostic);\n+        } else {\n+            ArraySchema arraySchema = (ArraySchema) schema;\n+            AbstractSchema items = arraySchema.items();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2cdb11e327e94a5d61713ea806ea31a91833ec3a"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzQwMjcyMg==", "bodyText": "Here we are traversing the diagnostics again.\nInstead, can't we add the diagnostics to the node itself directly?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#discussion_r527402722", "createdAt": "2020-11-20T05:16:30Z", "author": {"login": "SupunS"}, "path": "misc/toml-parser/src/main/java/io/ballerina/toml/validator/SchemaValidator.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.ballerina.toml.validator;\n+\n+import io.ballerina.toml.semantic.ast.TomlBooleanValueNode;\n+import io.ballerina.toml.semantic.ast.TomlDoubleValueNodeNode;\n+import io.ballerina.toml.semantic.ast.TomlKeyValueNode;\n+import io.ballerina.toml.semantic.ast.TomlLongValueNode;\n+import io.ballerina.toml.semantic.ast.TomlNode;\n+import io.ballerina.toml.semantic.ast.TomlNodeVisitor;\n+import io.ballerina.toml.semantic.ast.TomlStringValueNode;\n+import io.ballerina.toml.semantic.ast.TomlTableArrayNode;\n+import io.ballerina.toml.semantic.ast.TomlTableNode;\n+import io.ballerina.toml.semantic.ast.TomlValueNode;\n+import io.ballerina.toml.semantic.ast.TopLevelNode;\n+import io.ballerina.toml.semantic.diagnostics.TomlDiagnostic;\n+import io.ballerina.toml.semantic.diagnostics.TomlNodeLocation;\n+import io.ballerina.toml.validator.schema.AbstractSchema;\n+import io.ballerina.toml.validator.schema.ArraySchema;\n+import io.ballerina.toml.validator.schema.NumericSchema;\n+import io.ballerina.toml.validator.schema.ObjectSchema;\n+import io.ballerina.toml.validator.schema.Schema;\n+import io.ballerina.toml.validator.schema.StringSchema;\n+import io.ballerina.toml.validator.schema.Type;\n+import io.ballerina.tools.diagnostics.Diagnostic;\n+import io.ballerina.tools.diagnostics.DiagnosticInfo;\n+import io.ballerina.tools.diagnostics.DiagnosticSeverity;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Visitor to validate toml object against rules in json schema.\n+ *\n+ * @since 2.0.0\n+ */\n+public class SchemaValidator extends TomlNodeVisitor {\n+\n+    private AbstractSchema schema;\n+    private String key;\n+\n+    public SchemaValidator(Schema schema) {\n+        this.schema = schema;\n+    }\n+\n+    @Override\n+    public void visit(TomlTableNode tomlTableNode) {\n+        if (schema.type() != Type.OBJECT) {\n+            TomlDiagnostic diagnostic = getTomlDiagnostic(tomlTableNode.location(), \"TVE0002\", \"error.invalid.type\",\n+                    DiagnosticSeverity.ERROR, String.format(\"Key \\\"%s\\\" expects %s . Found object\", this.key,\n+                            schema.type()));\n+            tomlTableNode.addDiagnostic(diagnostic);\n+        } else {\n+            ObjectSchema objectSchema = (ObjectSchema) schema;\n+            Map<String, AbstractSchema> properties = objectSchema.properties();\n+            Map<String, TopLevelNode> tableChildren = tomlTableNode.children();\n+            for (Map.Entry<String, TopLevelNode> propertyEntry : tableChildren.entrySet()) {\n+                String key = propertyEntry.getKey();\n+                TopLevelNode value = propertyEntry.getValue();\n+                AbstractSchema abstractSchema = properties.get(key);\n+                if (abstractSchema != null) {\n+                    this.schema = abstractSchema;\n+                    this.key = key;\n+                    lookupNode(value);\n+                } else {\n+                    if (!objectSchema.hasAdditionalProperties()) {\n+                        DiagnosticInfo diagnosticInfo = new DiagnosticInfo(\"TVE0001\", \"warn.unexpected.property\",\n+                                DiagnosticSeverity.WARNING);\n+                        TomlDiagnostic diagnostic = new TomlDiagnostic(value.location(), diagnosticInfo,\n+                                \"Unexpected Property \\\"\" + key + \"\\\"\");\n+                        tomlTableNode.addDiagnostic(diagnostic);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visit(TomlTableArrayNode tomlTableArrayNode) {\n+        if (schema.type() != Type.ARRAY) {\n+            TomlDiagnostic diagnostic =\n+                    getTomlDiagnostic(tomlTableArrayNode.location(), \"TVE0002\", \"error.invalid.type\",\n+                            DiagnosticSeverity.ERROR, String.format(\"Key \\\"%s\\\" expects %s . Found array\", this.key,\n+                                    schema.type()));\n+            tomlTableArrayNode.addDiagnostic(diagnostic);\n+        } else {\n+            ArraySchema arraySchema = (ArraySchema) schema;\n+            AbstractSchema items = arraySchema.items();\n+            List<TomlTableNode> children = tomlTableArrayNode.children();\n+            for (TomlTableNode child : children) {\n+                this.schema = items;\n+                visit(child);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visit(TomlKeyValueNode keyValue) {\n+        TomlValueNode value = keyValue.value();\n+        lookupNode(value);\n+    }\n+\n+    @Override\n+    public void visit(TomlValueNode tomlValue) {\n+        lookupNode(tomlValue);\n+    }\n+\n+    @Override\n+    public void visit(TomlStringValueNode tomlStringValueNode) {\n+        if (schema.type() != Type.STRING) {\n+            TomlDiagnostic diagnostic =\n+                    getTomlDiagnostic(tomlStringValueNode.location(), \"TVE0002\", \"error.invalid.type\",\n+                            DiagnosticSeverity.ERROR,\n+                            String.format(\"Key \\\"%s\\\" expects %s . Found string\", this.key, schema.type()));\n+            tomlStringValueNode.addDiagnostic(diagnostic);\n+        } else {\n+            StringSchema stringSchema = (StringSchema) this.schema;\n+            if (stringSchema.pattern().isPresent()) {\n+                String pattern = stringSchema.pattern().get();\n+                if (!Pattern.compile(pattern).matcher(tomlStringValueNode.getValue()).matches()) {\n+                    TomlDiagnostic diagnostic = getTomlDiagnostic(tomlStringValueNode.location(), \"TVE0003\",\n+                            \"error.regex.mismatch\", DiagnosticSeverity.ERROR,\n+                            String.format(\"Key \\\"%s\\\" value does not match the Regex provided in Schema %s\", this.key,\n+                                    pattern));\n+                    tomlStringValueNode.addDiagnostic(diagnostic);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visit(TomlDoubleValueNodeNode tomlDoubleValueNodeNode) {\n+        if (schema.type() != Type.NUMBER) {\n+            TomlDiagnostic diagnostic = getTomlDiagnostic(tomlDoubleValueNodeNode.location(), \"TVE0002\",\n+                    \"error.invalid.type\", DiagnosticSeverity.ERROR,\n+                    String.format(\"Key \\\"%s\\\" expects %s . Found number\", this.key, schema.type()));\n+            tomlDoubleValueNodeNode.addDiagnostic(diagnostic);\n+        } else {\n+            List<Diagnostic> diagnostics =\n+                    validateMinMaxValues((NumericSchema) schema, tomlDoubleValueNodeNode.getValue(),\n+                            tomlDoubleValueNodeNode.location());\n+            for (Diagnostic diagnostic : diagnostics) {\n+                tomlDoubleValueNodeNode.addDiagnostic(diagnostic);\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2cdb11e327e94a5d61713ea806ea31a91833ec3a"}, "originalPosition": 162}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzQwMzU3NA==", "bodyText": "We should throw our own exception here. Throwing an exception from  the gson library is not correct.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#discussion_r527403574", "createdAt": "2020-11-20T05:19:58Z", "author": {"login": "SupunS"}, "path": "misc/toml-parser/src/main/java/io/ballerina/toml/validator/schema/SchemaDeserializer.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.ballerina.toml.validator.schema;\n+\n+import com.google.gson.JsonDeserializationContext;\n+import com.google.gson.JsonDeserializer;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParseException;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Responsible for Deserializing abstract Schema nodes accordingly.\n+ *\n+ * @since 2.0.0\n+ */\n+public class SchemaDeserializer implements JsonDeserializer<AbstractSchema> {\n+\n+    @Override\n+    public AbstractSchema deserialize(JsonElement jsonElement, java.lang.reflect.Type refType,\n+                                      JsonDeserializationContext jsonDeserializationContext)\n+            throws JsonParseException {\n+        JsonObject jsonObj = jsonElement.getAsJsonObject();\n+        String type = jsonObj.get(\"type\").getAsString();\n+        switch (type) {\n+            case \"object\":\n+                return getObjectSchema(jsonDeserializationContext, jsonObj);\n+            case \"array\":\n+                return getArraySchema(jsonDeserializationContext, jsonObj);\n+            case \"integer\":\n+                return getNumericSchema(jsonObj, Type.INTEGER);\n+            case \"number\":\n+                return getNumericSchema(jsonObj, Type.NUMBER);\n+            case \"string\":\n+                return getStringSchema(jsonObj);\n+            case \"boolean\":\n+                return new BooleanSchema(Type.BOOLEAN);\n+            default:\n+                throw new JsonParseException(\"type \" + type + \" is not supported type\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2cdb11e327e94a5d61713ea806ea31a91833ec3a"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzQwMzg0OA==", "bodyText": "Shall we move all these hardcoded strings to constants?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#discussion_r527403848", "createdAt": "2020-11-20T05:21:00Z", "author": {"login": "SupunS"}, "path": "misc/toml-parser/src/main/java/io/ballerina/toml/validator/schema/SchemaDeserializer.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.ballerina.toml.validator.schema;\n+\n+import com.google.gson.JsonDeserializationContext;\n+import com.google.gson.JsonDeserializer;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParseException;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Responsible for Deserializing abstract Schema nodes accordingly.\n+ *\n+ * @since 2.0.0\n+ */\n+public class SchemaDeserializer implements JsonDeserializer<AbstractSchema> {\n+\n+    @Override\n+    public AbstractSchema deserialize(JsonElement jsonElement, java.lang.reflect.Type refType,\n+                                      JsonDeserializationContext jsonDeserializationContext)\n+            throws JsonParseException {\n+        JsonObject jsonObj = jsonElement.getAsJsonObject();\n+        String type = jsonObj.get(\"type\").getAsString();\n+        switch (type) {\n+            case \"object\":\n+                return getObjectSchema(jsonDeserializationContext, jsonObj);\n+            case \"array\":\n+                return getArraySchema(jsonDeserializationContext, jsonObj);\n+            case \"integer\":\n+                return getNumericSchema(jsonObj, Type.INTEGER);\n+            case \"number\":\n+                return getNumericSchema(jsonObj, Type.NUMBER);\n+            case \"string\":\n+                return getStringSchema(jsonObj);\n+            case \"boolean\":\n+                return new BooleanSchema(Type.BOOLEAN);\n+            default:\n+                throw new JsonParseException(\"type \" + type + \" is not supported type\");\n+        }\n+    }\n+\n+    private ObjectSchema getObjectSchema(JsonDeserializationContext jsonDeserializationContext, JsonObject jsonObj) {\n+        JsonElement descriptionProperty = jsonObj.get(\"description\");\n+        String description = descriptionProperty != null ? descriptionProperty.getAsString() : null;\n+        JsonElement additionalProperty = jsonObj.get(\"additionalProperties\");\n+        boolean additionalProperties = additionalProperty == null || additionalProperty.getAsBoolean();\n+        JsonObject properties = jsonObj.get(\"properties\").getAsJsonObject();\n+        Set<Map.Entry<String, JsonElement>> entries = properties.entrySet();\n+        Map<String, AbstractSchema> propertiesList = new HashMap<>();\n+        for (Map.Entry<String, JsonElement> entry : entries) {\n+            String key = entry.getKey();\n+            AbstractSchema\n+                    abstractSchema = jsonDeserializationContext.deserialize(entry.getValue(), AbstractSchema.class);\n+            propertiesList.put(key, abstractSchema);\n+        }\n+        return new ObjectSchema(Type.OBJECT, description, additionalProperties, propertiesList);\n+    }\n+\n+    private AbstractSchema getArraySchema(JsonDeserializationContext jsonDeserializationContext, JsonObject jsonObj) {\n+        JsonElement items = jsonObj.get(\"items\").getAsJsonObject();\n+        AbstractSchema abstractSchema = jsonDeserializationContext.deserialize(items, AbstractSchema.class);\n+        return new ArraySchema(Type.ARRAY, abstractSchema);\n+    }\n+\n+    private StringSchema getStringSchema(JsonObject jsonObj) {\n+        JsonElement patternProperty = jsonObj.get(\"pattern\");\n+        String pattern = patternProperty != null ? patternProperty.getAsString() : null;\n+        return new StringSchema(Type.STRING, pattern);\n+    }\n+\n+    private NumericSchema getNumericSchema(JsonObject jsonObj, Type type) {\n+        JsonElement minimumProperty = jsonObj.get(\"minimum\");\n+        Double minimum = minimumProperty != null ? minimumProperty.getAsDouble() : null;\n+        JsonElement maximumProperty = jsonObj.get(\"maximum\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2cdb11e327e94a5d61713ea806ea31a91833ec3a"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzQwOTgyOA==", "bodyText": "Trying to get as double without checking the value first can lead to runtime errors, such as ClassCastExceptions, NumberFormatExceptions, etc. So we need to do the validations first, and throw proper errors.\nDo we have any negative test cases for the schema?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#discussion_r527409828", "createdAt": "2020-11-20T05:28:05Z", "author": {"login": "SupunS"}, "path": "misc/toml-parser/src/main/java/io/ballerina/toml/validator/schema/SchemaDeserializer.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.ballerina.toml.validator.schema;\n+\n+import com.google.gson.JsonDeserializationContext;\n+import com.google.gson.JsonDeserializer;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParseException;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Responsible for Deserializing abstract Schema nodes accordingly.\n+ *\n+ * @since 2.0.0\n+ */\n+public class SchemaDeserializer implements JsonDeserializer<AbstractSchema> {\n+\n+    @Override\n+    public AbstractSchema deserialize(JsonElement jsonElement, java.lang.reflect.Type refType,\n+                                      JsonDeserializationContext jsonDeserializationContext)\n+            throws JsonParseException {\n+        JsonObject jsonObj = jsonElement.getAsJsonObject();\n+        String type = jsonObj.get(\"type\").getAsString();\n+        switch (type) {\n+            case \"object\":\n+                return getObjectSchema(jsonDeserializationContext, jsonObj);\n+            case \"array\":\n+                return getArraySchema(jsonDeserializationContext, jsonObj);\n+            case \"integer\":\n+                return getNumericSchema(jsonObj, Type.INTEGER);\n+            case \"number\":\n+                return getNumericSchema(jsonObj, Type.NUMBER);\n+            case \"string\":\n+                return getStringSchema(jsonObj);\n+            case \"boolean\":\n+                return new BooleanSchema(Type.BOOLEAN);\n+            default:\n+                throw new JsonParseException(\"type \" + type + \" is not supported type\");\n+        }\n+    }\n+\n+    private ObjectSchema getObjectSchema(JsonDeserializationContext jsonDeserializationContext, JsonObject jsonObj) {\n+        JsonElement descriptionProperty = jsonObj.get(\"description\");\n+        String description = descriptionProperty != null ? descriptionProperty.getAsString() : null;\n+        JsonElement additionalProperty = jsonObj.get(\"additionalProperties\");\n+        boolean additionalProperties = additionalProperty == null || additionalProperty.getAsBoolean();\n+        JsonObject properties = jsonObj.get(\"properties\").getAsJsonObject();\n+        Set<Map.Entry<String, JsonElement>> entries = properties.entrySet();\n+        Map<String, AbstractSchema> propertiesList = new HashMap<>();\n+        for (Map.Entry<String, JsonElement> entry : entries) {\n+            String key = entry.getKey();\n+            AbstractSchema\n+                    abstractSchema = jsonDeserializationContext.deserialize(entry.getValue(), AbstractSchema.class);\n+            propertiesList.put(key, abstractSchema);\n+        }\n+        return new ObjectSchema(Type.OBJECT, description, additionalProperties, propertiesList);\n+    }\n+\n+    private AbstractSchema getArraySchema(JsonDeserializationContext jsonDeserializationContext, JsonObject jsonObj) {\n+        JsonElement items = jsonObj.get(\"items\").getAsJsonObject();\n+        AbstractSchema abstractSchema = jsonDeserializationContext.deserialize(items, AbstractSchema.class);\n+        return new ArraySchema(Type.ARRAY, abstractSchema);\n+    }\n+\n+    private StringSchema getStringSchema(JsonObject jsonObj) {\n+        JsonElement patternProperty = jsonObj.get(\"pattern\");\n+        String pattern = patternProperty != null ? patternProperty.getAsString() : null;\n+        return new StringSchema(Type.STRING, pattern);\n+    }\n+\n+    private NumericSchema getNumericSchema(JsonObject jsonObj, Type type) {\n+        JsonElement minimumProperty = jsonObj.get(\"minimum\");\n+        Double minimum = minimumProperty != null ? minimumProperty.getAsDouble() : null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2cdb11e327e94a5d61713ea806ea31a91833ec3a"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzQxMDk5Ng==", "bodyText": "Let's remove the get prefix from all methods.\nThis also should return a list.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#discussion_r527410996", "createdAt": "2020-11-20T05:29:27Z", "author": {"login": "SupunS"}, "path": "misc/toml-parser/src/main/java/io/ballerina/toml/api/Toml.java", "diffHunk": "@@ -169,19 +206,23 @@ public Toml getTable(String key) {\n      */\n     public List<Toml> getTables(String key) {\n         TopLevelNode tableNode = rootNode.children().get(key);\n+        if (tableNode == null || tableNode.kind() != TomlType.TABLE_ARRAY) {\n+            return null;\n+        }\n+        TomlTableArrayNode tomlTableArrayNode = (TomlTableArrayNode) tableNode;\n+        List<TomlTableNode> childs = tomlTableArrayNode.children();\n         List<Toml> tomlList = new ArrayList<>();\n-        if (tableNode.kind() == TomlType.TABLE_ARRAY) {\n-            TomlTableArrayNode tomlTableArrayNode = (TomlTableArrayNode) tableNode;\n-            List<TomlTableNode> childs = tomlTableArrayNode.children();\n-            for (TomlTableNode child : childs) {\n-                tomlList.add(new Toml(child));\n-            }\n-            return tomlList;\n+        for (TomlTableNode child : childs) {\n+            tomlList.add(new Toml(child));\n         }\n         return tomlList;\n     }\n \n-    public List<TomlDiagnostic> getDiagnostics() {\n+    public Set<Diagnostic> getDiagnostics() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2cdb11e327e94a5d61713ea806ea31a91833ec3a"}, "originalPosition": 175}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzQxMjkwNQ==", "bodyText": "rootSchema -> schema", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#discussion_r527412905", "createdAt": "2020-11-20T05:31:30Z", "author": {"login": "SupunS"}, "path": "misc/toml-parser/src/main/java/io/ballerina/toml/api/Toml.java", "diffHunk": "@@ -82,45 +104,60 @@ public static Toml read(Path path) throws IOException {\n      * @throws IOException if file is not accessible\n      */\n     public static Toml read(InputStream inputStream) throws IOException {\n-        return read(new InputStreamReader(inputStream, StandardCharsets.UTF_8));\n+       return read(new String(inputStream.readAllBytes(), StandardCharsets.UTF_8), null);\n     }\n \n     /**\n-     * Read TOML File using Reader.\n+     * Read TOML File using InputStream and validate against a json schema.\n      *\n-     * @param reader reader of the TOML file\n+     * @param inputStream InputStream of the TOML file\n+     * @param rootSchema Root schema of the validator\n      * @return TOML Object\n      * @throws IOException if file is not accessible\n      */\n-    public static Toml read(Reader reader) throws IOException {\n-        BufferedReader bufferedReader = new BufferedReader(reader);\n-        StringBuilder w = new StringBuilder();\n-        for (String line = bufferedReader.readLine(); line != null; line = bufferedReader.readLine()) {\n-            w.append(line).append('\\n');\n-        }\n-        return read(w.toString());\n+    public static Toml read(InputStream inputStream, Schema rootSchema) throws IOException {\n+        return read(new String(inputStream.readAllBytes(), StandardCharsets.UTF_8), null, rootSchema);\n     }\n \n     /**\n      * Parse TOML file using TOML String.\n      *\n      * @param content String representation of the TOML file content.\n+     * @param filePath path of the TOML file\n      * @return TOML Object\n      */\n-    public static Toml read(String content) {\n+    public static Toml read(String content, String filePath) {\n         TextDocument textDocument = TextDocuments.from(content);\n-        SyntaxTree syntaxTree = SyntaxTree.from(textDocument);\n-        List<TomlDiagnostic> tomlDiagnostics = reportSyntaxDiagnostics(syntaxTree);\n+        SyntaxTree syntaxTree = SyntaxTree.from(textDocument, filePath);\n         TomlTransformer nodeTransformer = new TomlTransformer();\n         TomlTableNode\n                 transformedTable = (TomlTableNode) nodeTransformer.transform((DocumentNode) syntaxTree.rootNode());\n-        transformedTable.setSyntacticalDiagnostics(tomlDiagnostics);\n-        tomlDiagnostics.addAll(transformedTable.collectSemanticDiagnostics());\n+        transformedTable.addSyntaxDiagnostics(reportSyntaxDiagnostics(syntaxTree));\n         return new Toml(transformedTable);\n     }\n \n-    private static List<TomlDiagnostic> reportSyntaxDiagnostics(SyntaxTree tree) {\n-        List<TomlDiagnostic> diagnostics = new ArrayList<>();\n+    /**\n+     * Parse TOML file using TOML String and validate against a json schema.\n+     *\n+     * @param content String representation of the TOML file content.\n+     * @param filePath path of the TOML file\n+     * @return TOML Object\n+     */\n+    public static Toml read(String content, String filePath, Schema rootSchema) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2cdb11e327e94a5d61713ea806ea31a91833ec3a"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzQxMzI5MQ==", "bodyText": "Third parameter is missing in the doc comment", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#discussion_r527413291", "createdAt": "2020-11-20T05:31:54Z", "author": {"login": "SupunS"}, "path": "misc/toml-parser/src/main/java/io/ballerina/toml/api/Toml.java", "diffHunk": "@@ -82,45 +104,60 @@ public static Toml read(Path path) throws IOException {\n      * @throws IOException if file is not accessible\n      */\n     public static Toml read(InputStream inputStream) throws IOException {\n-        return read(new InputStreamReader(inputStream, StandardCharsets.UTF_8));\n+       return read(new String(inputStream.readAllBytes(), StandardCharsets.UTF_8), null);\n     }\n \n     /**\n-     * Read TOML File using Reader.\n+     * Read TOML File using InputStream and validate against a json schema.\n      *\n-     * @param reader reader of the TOML file\n+     * @param inputStream InputStream of the TOML file\n+     * @param rootSchema Root schema of the validator\n      * @return TOML Object\n      * @throws IOException if file is not accessible\n      */\n-    public static Toml read(Reader reader) throws IOException {\n-        BufferedReader bufferedReader = new BufferedReader(reader);\n-        StringBuilder w = new StringBuilder();\n-        for (String line = bufferedReader.readLine(); line != null; line = bufferedReader.readLine()) {\n-            w.append(line).append('\\n');\n-        }\n-        return read(w.toString());\n+    public static Toml read(InputStream inputStream, Schema rootSchema) throws IOException {\n+        return read(new String(inputStream.readAllBytes(), StandardCharsets.UTF_8), null, rootSchema);\n     }\n \n     /**\n      * Parse TOML file using TOML String.\n      *\n      * @param content String representation of the TOML file content.\n+     * @param filePath path of the TOML file\n      * @return TOML Object\n      */\n-    public static Toml read(String content) {\n+    public static Toml read(String content, String filePath) {\n         TextDocument textDocument = TextDocuments.from(content);\n-        SyntaxTree syntaxTree = SyntaxTree.from(textDocument);\n-        List<TomlDiagnostic> tomlDiagnostics = reportSyntaxDiagnostics(syntaxTree);\n+        SyntaxTree syntaxTree = SyntaxTree.from(textDocument, filePath);\n         TomlTransformer nodeTransformer = new TomlTransformer();\n         TomlTableNode\n                 transformedTable = (TomlTableNode) nodeTransformer.transform((DocumentNode) syntaxTree.rootNode());\n-        transformedTable.setSyntacticalDiagnostics(tomlDiagnostics);\n-        tomlDiagnostics.addAll(transformedTable.collectSemanticDiagnostics());\n+        transformedTable.addSyntaxDiagnostics(reportSyntaxDiagnostics(syntaxTree));\n         return new Toml(transformedTable);\n     }\n \n-    private static List<TomlDiagnostic> reportSyntaxDiagnostics(SyntaxTree tree) {\n-        List<TomlDiagnostic> diagnostics = new ArrayList<>();\n+    /**\n+     * Parse TOML file using TOML String and validate against a json schema.\n+     *\n+     * @param content String representation of the TOML file content.\n+     * @param filePath path of the TOML file\n+     * @return TOML Object\n+     */\n+    public static Toml read(String content, String filePath, Schema rootSchema) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzQxMjkwNQ=="}, "originalCommit": {"oid": "2cdb11e327e94a5d61713ea806ea31a91833ec3a"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzQxMzk3OA==", "bodyText": "rootSchema -> schema", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#discussion_r527413978", "createdAt": "2020-11-20T05:32:44Z", "author": {"login": "SupunS"}, "path": "misc/toml-parser/src/main/java/io/ballerina/toml/api/Toml.java", "diffHunk": "@@ -82,45 +104,60 @@ public static Toml read(Path path) throws IOException {\n      * @throws IOException if file is not accessible\n      */\n     public static Toml read(InputStream inputStream) throws IOException {\n-        return read(new InputStreamReader(inputStream, StandardCharsets.UTF_8));\n+       return read(new String(inputStream.readAllBytes(), StandardCharsets.UTF_8), null);\n     }\n \n     /**\n-     * Read TOML File using Reader.\n+     * Read TOML File using InputStream and validate against a json schema.\n      *\n-     * @param reader reader of the TOML file\n+     * @param inputStream InputStream of the TOML file\n+     * @param rootSchema Root schema of the validator\n      * @return TOML Object\n      * @throws IOException if file is not accessible\n      */\n-    public static Toml read(Reader reader) throws IOException {\n-        BufferedReader bufferedReader = new BufferedReader(reader);\n-        StringBuilder w = new StringBuilder();\n-        for (String line = bufferedReader.readLine(); line != null; line = bufferedReader.readLine()) {\n-            w.append(line).append('\\n');\n-        }\n-        return read(w.toString());\n+    public static Toml read(InputStream inputStream, Schema rootSchema) throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2cdb11e327e94a5d61713ea806ea31a91833ec3a"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzQxNDc5NA==", "bodyText": "keep a newline after a block (if-else, while, etc)", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#discussion_r527414794", "createdAt": "2020-11-20T05:33:43Z", "author": {"login": "SupunS"}, "path": "misc/toml-parser/src/main/java/io/ballerina/toml/api/Toml.java", "diffHunk": "@@ -169,19 +206,23 @@ public Toml getTable(String key) {\n      */\n     public List<Toml> getTables(String key) {\n         TopLevelNode tableNode = rootNode.children().get(key);\n+        if (tableNode == null || tableNode.kind() != TomlType.TABLE_ARRAY) {\n+            return null;\n+        }\n+        TomlTableArrayNode tomlTableArrayNode = (TomlTableArrayNode) tableNode;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2cdb11e327e94a5d61713ea806ea31a91833ec3a"}, "originalPosition": 158}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "028b7c3f37457fa99dce57a0bacedf5476eb650a", "author": {"user": {"login": "xlight05", "name": "Anjana Supun"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/028b7c3f37457fa99dce57a0bacedf5476eb650a", "committedDate": "2020-11-20T09:48:15Z", "message": "Address Review comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM1MzI2NDYw", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#pullrequestreview-535326460", "createdAt": "2020-11-20T10:56:51Z", "commit": {"oid": "028b7c3f37457fa99dce57a0bacedf5476eb650a"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxMDo1Njo1MVrOH3K9VQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxMDo1ODoyM1rOH3LAHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzYxMzI2OQ==", "bodyText": "If we are not changing the states, no need to cache it either", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#discussion_r527613269", "createdAt": "2020-11-20T10:56:51Z", "author": {"login": "SupunS"}, "path": "misc/toml-parser/src/main/java/io/ballerina/toml/validator/SchemaValidator.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.ballerina.toml.validator;\n+\n+import io.ballerina.toml.semantic.ast.TomlBooleanValueNode;\n+import io.ballerina.toml.semantic.ast.TomlDoubleValueNodeNode;\n+import io.ballerina.toml.semantic.ast.TomlKeyValueNode;\n+import io.ballerina.toml.semantic.ast.TomlLongValueNode;\n+import io.ballerina.toml.semantic.ast.TomlNode;\n+import io.ballerina.toml.semantic.ast.TomlNodeVisitor;\n+import io.ballerina.toml.semantic.ast.TomlStringValueNode;\n+import io.ballerina.toml.semantic.ast.TomlTableArrayNode;\n+import io.ballerina.toml.semantic.ast.TomlTableNode;\n+import io.ballerina.toml.semantic.ast.TomlValueNode;\n+import io.ballerina.toml.semantic.ast.TopLevelNode;\n+import io.ballerina.toml.semantic.diagnostics.TomlDiagnostic;\n+import io.ballerina.toml.semantic.diagnostics.TomlNodeLocation;\n+import io.ballerina.toml.validator.schema.AbstractSchema;\n+import io.ballerina.toml.validator.schema.ArraySchema;\n+import io.ballerina.toml.validator.schema.NumericSchema;\n+import io.ballerina.toml.validator.schema.ObjectSchema;\n+import io.ballerina.toml.validator.schema.Schema;\n+import io.ballerina.toml.validator.schema.StringSchema;\n+import io.ballerina.toml.validator.schema.Type;\n+import io.ballerina.tools.diagnostics.Diagnostic;\n+import io.ballerina.tools.diagnostics.DiagnosticInfo;\n+import io.ballerina.tools.diagnostics.DiagnosticSeverity;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Visitor to validate toml object against rules in json schema.\n+ *\n+ * @since 2.0.0\n+ */\n+public class SchemaValidator extends TomlNodeVisitor {\n+\n+    private AbstractSchema schema;\n+    private String key;\n+\n+    public SchemaValidator(Schema schema) {\n+        this.schema = schema;\n+    }\n+\n+    @Override\n+    public void visit(TomlTableNode tomlTableNode) {\n+        if (schema.type() != Type.OBJECT) {\n+            TomlDiagnostic diagnostic = getTomlDiagnostic(tomlTableNode.location(), \"TVE0002\", \"error.invalid.type\",\n+                    DiagnosticSeverity.ERROR, String.format(\"Key \\\"%s\\\" expects %s . Found object\", this.key,\n+                            schema.type()));\n+            tomlTableNode.addDiagnostic(diagnostic);\n+            return;\n+        }\n+        ObjectSchema objectSchema = (ObjectSchema) schema;\n+        Map<String, AbstractSchema> properties = objectSchema.properties();\n+        Map<String, TopLevelNode> tableEntries = tomlTableNode.entries();\n+        for (Map.Entry<String, TopLevelNode> tableEntry : tableEntries.entrySet()) {\n+            String key = tableEntry.getKey();\n+            TopLevelNode value = tableEntry.getValue();\n+            AbstractSchema schema = properties.get(key);\n+            if (schema != null) {\n+                visitNode(value, schema, key);\n+                continue;\n+            }\n+            if (!objectSchema.hasAdditionalProperties()) {\n+                DiagnosticInfo diagnosticInfo = new DiagnosticInfo(\"TVE0001\", \"warn.unexpected.property\",\n+                        DiagnosticSeverity.WARNING);\n+                TomlDiagnostic diagnostic = new TomlDiagnostic(value.location(), diagnosticInfo,\n+                        \"Unexpected Property \\\"\" + key + \"\\\"\");\n+                tomlTableNode.addDiagnostic(diagnostic);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visit(TomlTableArrayNode tomlTableArrayNode) {\n+        if (schema.type() != Type.ARRAY) {\n+            TomlDiagnostic diagnostic =\n+                    getTomlDiagnostic(tomlTableArrayNode.location(), \"TVE0002\", \"error.invalid.type\",\n+                            DiagnosticSeverity.ERROR, String.format(\"Key \\\"%s\\\" expects %s . Found array\", this.key,\n+                                    schema.type()));\n+            tomlTableArrayNode.addDiagnostic(diagnostic);\n+            return;\n+        }\n+        ArraySchema arraySchema = (ArraySchema) schema;\n+        AbstractSchema memberSchema = arraySchema.items();\n+        List<TomlTableNode> children = tomlTableArrayNode.children();\n+        for (TomlTableNode child : children) {\n+            visitNode(child, memberSchema);\n+        }\n+    }\n+\n+    @Override\n+    public void visit(TomlKeyValueNode keyValue) {\n+        TomlValueNode value = keyValue.value();\n+        visitNode(value);\n+    }\n+\n+    @Override\n+    public void visit(TomlValueNode tomlValue) {\n+        visitNode(tomlValue);\n+    }\n+\n+    @Override\n+    public void visit(TomlStringValueNode tomlStringValueNode) {\n+        if (schema.type() != Type.STRING) {\n+            TomlDiagnostic diagnostic =\n+                    getTomlDiagnostic(tomlStringValueNode.location(), \"TVE0002\", \"error.invalid.type\",\n+                            DiagnosticSeverity.ERROR,\n+                            String.format(\"Key \\\"%s\\\" expects %s . Found string\", this.key, schema.type()));\n+            tomlStringValueNode.addDiagnostic(diagnostic);\n+            return;\n+        }\n+        StringSchema stringSchema = (StringSchema) this.schema;\n+        if (stringSchema.pattern().isPresent()) {\n+            String pattern = stringSchema.pattern().get();\n+            if (!Pattern.compile(pattern).matcher(tomlStringValueNode.getValue()).matches()) {\n+                TomlDiagnostic diagnostic = getTomlDiagnostic(tomlStringValueNode.location(), \"TVE0003\",\n+                        \"error.regex.mismatch\", DiagnosticSeverity.ERROR,\n+                        String.format(\"Key \\\"%s\\\" value does not match the Regex provided in Schema %s\", this.key,\n+                                pattern));\n+                tomlStringValueNode.addDiagnostic(diagnostic);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visit(TomlDoubleValueNodeNode tomlDoubleValueNodeNode) {\n+        if (schema.type() != Type.NUMBER) {\n+            TomlDiagnostic diagnostic = getTomlDiagnostic(tomlDoubleValueNodeNode.location(), \"TVE0002\",\n+                    \"error.invalid.type\", DiagnosticSeverity.ERROR,\n+                    String.format(\"Key \\\"%s\\\" expects %s . Found number\", this.key, schema.type()));\n+            tomlDoubleValueNodeNode.addDiagnostic(diagnostic);\n+            return;\n+        }\n+        List<Diagnostic> diagnostics =\n+                validateMinMaxValues((NumericSchema) schema, tomlDoubleValueNodeNode.getValue(),\n+                        tomlDoubleValueNodeNode.location());\n+        tomlDoubleValueNodeNode.addDiagnostics(diagnostics);\n+    }\n+\n+    @Override\n+    public void visit(TomlLongValueNode tomlLongValueNode) {\n+        if (schema.type() != Type.INTEGER) {\n+            TomlDiagnostic diagnostic = getTomlDiagnostic(tomlLongValueNode.location(), \"TVE0002\",\n+                    \"error.invalid.type\", DiagnosticSeverity.ERROR,\n+                    String.format(\"Key \\\"%s\\\" expects %s . Found integer\", this.key, schema.type()));\n+            tomlLongValueNode.addDiagnostic(diagnostic);\n+            return;\n+        }\n+        List<Diagnostic> diagnostics =\n+                validateMinMaxValues((NumericSchema) schema, Double.valueOf(tomlLongValueNode.getValue()),\n+                        tomlLongValueNode.location());\n+        for (Diagnostic diagnostic : diagnostics) {\n+            tomlLongValueNode.addDiagnostic(diagnostic);\n+        }\n+    }\n+\n+    private List<Diagnostic> validateMinMaxValues(NumericSchema numericSchema, Double value,\n+                                                  TomlNodeLocation location) {\n+        List<Diagnostic> diagnostics = new ArrayList<>();\n+        if (numericSchema.maximum().isPresent()) {\n+            Double max = numericSchema.maximum().get();\n+            if (value >= max) {\n+                TomlDiagnostic diagnostic = getTomlDiagnostic(location, \"TVE0005\", \"error\" +\n+                                \".maximum.value.exceed\", DiagnosticSeverity.ERROR,\n+                        String.format(\"Key \\\"%s\\\" value can't be higher than %f\", this.key,\n+                                max));\n+                diagnostics.add(diagnostic);\n+            }\n+        }\n+        if (numericSchema.minimum().isPresent()) {\n+            Double min = numericSchema.minimum().get();\n+            if (value <= min) {\n+                TomlDiagnostic diagnostic = getTomlDiagnostic(location, \"TVE0004\",\n+                        \"error.minimum.value.deceed\", DiagnosticSeverity.ERROR,\n+                        String.format(\"Key \\\"%s\\\" value can't be lower than %f\", this.key,\n+                                min));\n+                diagnostics.add(diagnostic);\n+            }\n+        }\n+        return diagnostics;\n+    }\n+\n+    @Override\n+    public void visit(TomlBooleanValueNode tomlBooleanValueNode) {\n+        if (schema.type() != Type.BOOLEAN) {\n+            TomlDiagnostic diagnostic = getTomlDiagnostic(tomlBooleanValueNode.location(), \"TVE0002\",\n+                    \"error.invalid.type\", DiagnosticSeverity.ERROR,\n+                    String.format(\"Key \\\"%s\\\" expects %s . Found boolean\", this.key, schema.type()));\n+            tomlBooleanValueNode.addDiagnostic(diagnostic);\n+        }\n+    }\n+\n+    private void visitNode(TomlNode node) {\n+        AbstractSchema previousSchema = this.schema;\n+        String previousKey = this.key;\n+        node.accept(this);\n+        this.schema = previousSchema;\n+        this.key = previousKey;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "028b7c3f37457fa99dce57a0bacedf5476eb650a"}, "originalPosition": 219}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzYxMzk4MA==", "bodyText": "all the constants should be private since they are not used anywhere else", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#discussion_r527613980", "createdAt": "2020-11-20T10:58:23Z", "author": {"login": "SupunS"}, "path": "misc/toml-parser/src/main/java/io/ballerina/toml/validator/schema/SchemaDeserializer.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.ballerina.toml.validator.schema;\n+\n+import com.google.gson.JsonDeserializationContext;\n+import com.google.gson.JsonDeserializer;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Responsible for Deserializing abstract Schema nodes accordingly.\n+ *\n+ * @since 2.0.0\n+ */\n+public class SchemaDeserializer implements JsonDeserializer<AbstractSchema> {\n+\n+    public static final String TYPE = \"type\";\n+    public static final String OBJECT = \"object\";\n+    public static final String ARRAY = \"array\";\n+    public static final String INTEGER = \"integer\";\n+    public static final String NUMBER = \"number\";\n+    public static final String STRING = \"string\";\n+    public static final String BOOLEAN = \"boolean\";\n+    public static final String DESCRIPTION = \"description\";\n+    public static final String ADDITIONAL_PROPERTIES = \"additionalProperties\";\n+    public static final String PROPERTIES = \"properties\";\n+    public static final String ITEMS = \"items\";\n+    public static final String PATTERN = \"pattern\";\n+    public static final String MINIMUM = \"minimum\";\n+    public static final String MAXIMUM = \"maximum\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "028b7c3f37457fa99dce57a0bacedf5476eb650a"}, "originalPosition": 50}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3290, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}