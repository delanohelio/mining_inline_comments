{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc4NzgwMDIx", "number": 25604, "title": "Add `array:sort` function", "bodyText": "Purpose\n\n$title according to ballerina-platform/ballerina-spec#572.\n\nFixes #25421\nApproach\n\nDescribe how you are implementing the solutions along with the design details.\n\nSamples\ntype Student record {|\n   int id;\n   string name;\n|};\n\nfunction testSort() {\n    Student s1 = {id: 3, name: \"Ben\"};\n    Student s2 = {id: 2, name: \"Matthew\"};\n    Student s3 = {id: 1, name: \"Amber\"};\n\n    Student[] arr = [s1, s2, s3];\n\n    Student[] sortedArr = arr.sort(\"descending\", function(Student s) returns string {\n        return s.name;\n    });\n}\n\nRemarks\n\nList any other known issues, related PRs, TODO items, or any other notes related to the PR.\n\nCheck List\n\n Read the Contributing Guide\n Updated Change Log\n Checked Tooling Support (#)\n Added necessary tests\n\n Unit Tests\n Spec Conformance Tests\n Integration Tests\n Ballerina By Example Tests\n\n\n Increased Test Coverage\n Added necessary documentation\n\n API documentation\n Module documentation in Module.md files\n Ballerina By Examples", "createdAt": "2020-09-03T17:29:08Z", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604", "merged": true, "mergeCommit": {"oid": "2d85ecc6a3817026bf83976f25f8ec8f8de198c3"}, "closed": true, "closedAt": "2020-09-09T10:25:25Z", "author": {"login": "lasinicl"}, "timelineItems": {"totalCount": 40, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdFO6lXgH2gAyNDc4NzgwMDIxOjk1OTUzNmEwZWY0NGQ3NTAwYTQyNzkxOTc3MjZjOTdhY2VjZmUzYmY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdHJj-sgFqTQ4NDg2ODcwNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "959536a0ef44d7500a4279197726c97acecfe3bf", "author": {"user": {"login": "lasinicl", "name": "Lasini Liyange"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/959536a0ef44d7500a4279197726c97acecfe3bf", "committedDate": "2020-09-03T11:29:31Z", "message": "Add support for revamped array:sort function"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a26ce67f53ca20c2eba82a88eb6ed33e98b310c2", "author": {"user": {"login": "lasinicl", "name": "Lasini Liyange"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a26ce67f53ca20c2eba82a88eb6ed33e98b310c2", "committedDate": "2020-09-03T11:30:01Z", "message": "Add tests for array:sort function"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1c5c87f602f18158ed30461d92032de5758a2d0b", "author": {"user": {"login": "lasinicl", "name": "Lasini Liyange"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1c5c87f602f18158ed30461d92032de5758a2d0b", "committedDate": "2020-09-03T17:15:42Z", "message": "Refactor code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3684528fc6b404386962b35984c02b97d29938f7", "author": {"user": {"login": "lasinicl", "name": "Lasini Liyange"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3684528fc6b404386962b35984c02b97d29938f7", "committedDate": "2020-09-03T17:16:18Z", "message": "Add more tests for array:sort"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f6242477c6a3f424e14896da82d393f2393efb0d", "author": {"user": {"login": "lasinicl", "name": "Lasini Liyange"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f6242477c6a3f424e14896da82d393f2393efb0d", "committedDate": "2020-09-03T17:28:12Z", "message": "Remove unnecessary newlines"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgyMTI3MDU1", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#pullrequestreview-482127055", "createdAt": "2020-09-03T19:08:32Z", "commit": {"oid": "f6242477c6a3f424e14896da82d393f2393efb0d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxOTowODozMlrOHMz_AQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxOTowODozMlrOHMz_AQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE5NjY3Mw==", "bodyText": "I think this is meant to be \"ordered\", not \"sorted\".", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#discussion_r483196673", "createdAt": "2020-09-03T19:08:32Z", "author": {"login": "pubudu91"}, "path": "langlib/lang.array/src/main/ballerina/src/lang.array/array.bal", "diffHunk": "@@ -152,14 +152,33 @@ public function lastIndexOf(PureType[] arr, PureType val, int startIndex = arr.l\n # + return - `arr` with its members in reverse order\n public function reverse(Type[] arr) returns Type[] = external;\n \n-# Sorts an array using a comparator function.\n-# The comparator function must return a value less than, equal to or greater than zero\n-# according as its first argument is to be ordered before, equal to or after its second argument.\n-#\n-# + arr - the array to be sorted\n-# + func - comparator function\n-# + return - `arr` with its members sorted\n-public function sort(Type[] arr, function(Type val1, Type val2) returns int func) returns Type[] = external;\n+# Direction for `sort` function.\n+public enum SortDirection {\n+   ASCENDING = \"ascending\",\n+   DESCENDING = \"descending\"\n+}\n+\n+# A type parameter that is a subtype of `()|boolean|int|float|decimal|string`.\n+type BasicType ()|boolean|int|float|decimal|string;\n+\n+# Any ordered type is a subtype of this.\n+type OrderedType BasicType|BasicType[];\n+\n+// TO DO: Add this when cyclic type reference in union type definitions is supported\n+//# Any ordered type is a subtype of this.\n+//public type OrderedType ()|boolean|int|float|decimal|string|OrderedType[];\n+\n+# Sorts an array.\n+# If the member type of the array is not sorted, then the `key` function", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f6242477c6a3f424e14896da82d393f2393efb0d"}, "originalPosition": 29}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgyMTMxOTE1", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#pullrequestreview-482131915", "createdAt": "2020-09-03T19:16:08Z", "commit": {"oid": "f6242477c6a3f424e14896da82d393f2393efb0d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxOToxNjowOFrOHM0OCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxOToxNjowOFrOHM0OCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIwMDUyMQ==", "bodyText": "No need to special case the array right? Can use the same switch case to do this.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#discussion_r483200521", "createdAt": "2020-09-03T19:16:08Z", "author": {"login": "pubudu91"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -3474,6 +3474,15 @@ public BType resolveExprType(BType type) {\n      * @return boolean whether the type is basic type or not.\n      */\n     public boolean isBasicType(BType type) {\n+        if (type.tag == TypeTags.ARRAY) {\n+            BType arrType = ((BArrayType) type).eType;\n+            return checkBasicType(arrType);\n+        } else {\n+            return checkBasicType(type);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f6242477c6a3f424e14896da82d393f2393efb0d"}, "originalPosition": 8}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgyMTM5MDI3", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#pullrequestreview-482139027", "createdAt": "2020-09-03T19:27:17Z", "commit": {"oid": "f6242477c6a3f424e14896da82d393f2393efb0d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxOToyNzoxN1rOHM0i9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxOToyNzoxN1rOHM0i9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIwNTg3Nw==", "bodyText": "Ideally, there shouldn't be any need to hard code the type checking for this. Why do we need to do this?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#discussion_r483205877", "createdAt": "2020-09-03T19:27:17Z", "author": {"login": "pubudu91"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -5390,6 +5395,28 @@ private BType checkInvocationArgs(BLangInvocation iExpr, List<BType> paramTypes,\n         }\n     }\n \n+    private void checkArrayLibSortFuncArgs(BLangInvocation iExpr) {\n+        if (iExpr.argExprs.size() <= 2) {\n+            if (!types.isBasicType(iExpr.expr.type)) {\n+                dlog.error(iExpr.expr.pos, DiagnosticCode.INVALID_SORT_ARRAY_MEMBER_TYPE, iExpr.expr.type);\n+            }\n+        } else if (iExpr.argExprs.size() == 3) {\n+            if (iExpr.argExprs.get(2).type != null) {\n+                if (iExpr.argExprs.get(2).type.tag == TypeTags.SEMANTIC_ERROR) {\n+                    return;\n+                } else if (iExpr.argExprs.get(2).type.tag == TypeTags.NIL && !types.isBasicType(iExpr.expr.type)) {\n+                    dlog.error(iExpr.expr.pos, DiagnosticCode.INVALID_SORT_ARRAY_MEMBER_TYPE, iExpr.expr.type);\n+                }\n+            } else {\n+                BLangLambdaFunction func = (BLangLambdaFunction) iExpr.argExprs.get(2);\n+                BType returnType = func.function.type.getReturnType();\n+                if (!types.isBasicType(returnType)) {\n+                    dlog.error(iExpr.expr.pos, DiagnosticCode.INVALID_SORT_FUNC_RETURN_TYPE, returnType);\n+                }\n+            }\n+        }\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f6242477c6a3f424e14896da82d393f2393efb0d"}, "originalPosition": 36}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgyMzQ5NDc0", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#pullrequestreview-482349474", "createdAt": "2020-09-04T04:31:12Z", "commit": {"oid": "f6242477c6a3f424e14896da82d393f2393efb0d"}, "state": "COMMENTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwNDozMToxM1rOHM_JDQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwNTo0MDoxNVrOHNAR5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzM3OTQ2OQ==", "bodyText": "Have we created an issue to track this?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#discussion_r483379469", "createdAt": "2020-09-04T04:31:13Z", "author": {"login": "MaryamZi"}, "path": "langlib/lang.array/src/main/ballerina/src/lang.array/array.bal", "diffHunk": "@@ -152,14 +152,33 @@ public function lastIndexOf(PureType[] arr, PureType val, int startIndex = arr.l\n # + return - `arr` with its members in reverse order\n public function reverse(Type[] arr) returns Type[] = external;\n \n-# Sorts an array using a comparator function.\n-# The comparator function must return a value less than, equal to or greater than zero\n-# according as its first argument is to be ordered before, equal to or after its second argument.\n-#\n-# + arr - the array to be sorted\n-# + func - comparator function\n-# + return - `arr` with its members sorted\n-public function sort(Type[] arr, function(Type val1, Type val2) returns int func) returns Type[] = external;\n+# Direction for `sort` function.\n+public enum SortDirection {\n+   ASCENDING = \"ascending\",\n+   DESCENDING = \"descending\"\n+}\n+\n+# A type parameter that is a subtype of `()|boolean|int|float|decimal|string`.\n+type BasicType ()|boolean|int|float|decimal|string;\n+\n+# Any ordered type is a subtype of this.\n+type OrderedType BasicType|BasicType[];\n+\n+// TO DO: Add this when cyclic type reference in union type definitions is supported", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f6242477c6a3f424e14896da82d393f2393efb0d"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzM4OTc5NA==", "bodyText": "Since function doesn't change for a single invocation, wouldn't it be better to do\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    for (int i = 0; i < arr.size(); i++) {\n          \n          \n            \n                        if (function != null) {\n          \n          \n            \n                            Object x = function.call(new Object[]{strand, arr.get(i), true});\n          \n          \n            \n                            sortArr[i][0] = x;\n          \n          \n            \n                        } else {\n          \n          \n            \n                            sortArr[i][0] = arr.get(i);\n          \n          \n            \n                        }\n          \n          \n            \n                        sortArr[i][1] = arr.get(i);\n          \n          \n            \n                    }\n          \n          \n            \n                    if (function != null) {\n          \n          \n            \n                        for (int i = 0; i < arr.size(); i++) {\n          \n          \n            \n                            sortArr[i][0] = function.call(new Object[]{strand, arr.get(i), true});\n          \n          \n            \n                            sortArr[i][1] = arr.get(i);\n          \n          \n            \n                        }\n          \n          \n            \n                    } else {\n          \n          \n            \n                        for (int i = 0; i < arr.size(); i++) {\n          \n          \n            \n                            sortArr[i][0] = sortArr[i][1] = arr.get(i);\n          \n          \n            \n                        }\n          \n          \n            \n                    }", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#discussion_r483389794", "createdAt": "2020-09-04T05:10:02Z", "author": {"login": "MaryamZi"}, "path": "langlib/lang.array/src/main/java/org/ballerinalang/langlib/array/Sort.java", "diffHunk": "@@ -18,73 +18,185 @@\n \n package org.ballerinalang.langlib.array;\n \n+import org.ballerinalang.jvm.BallerinaErrors;\n import org.ballerinalang.jvm.scheduling.Strand;\n import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BFunctionType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BUnionType;\n+import org.ballerinalang.jvm.types.TypeTags;\n import org.ballerinalang.jvm.values.ArrayValue;\n-import org.ballerinalang.jvm.values.ArrayValueImpl;\n import org.ballerinalang.jvm.values.FPValue;\n import org.ballerinalang.model.types.TypeKind;\n import org.ballerinalang.natives.annotations.Argument;\n import org.ballerinalang.natives.annotations.BallerinaFunction;\n import org.ballerinalang.natives.annotations.ReturnType;\n \n+import java.math.BigDecimal;\n+import java.util.Optional;\n+\n import static org.ballerinalang.jvm.values.utils.ArrayUtils.checkIsArrayOnlyOperation;\n import static org.ballerinalang.util.BLangCompilerConstants.ARRAY_VERSION;\n \n /**\n- * Native implementation of lang.array:sort((any|error)[], function).\n+ * Native implementation of lang.array:sort((any|error)[], direction, function).\n  *\n  * @since 1.0\n  */\n @BallerinaFunction(\n         orgName = \"ballerina\", packageName = \"lang.array\", version = ARRAY_VERSION, functionName = \"sort\",\n-        args = {@Argument(name = \"arr\", type = TypeKind.ARRAY), @Argument(name = \"func\", type = TypeKind.FUNCTION)},\n+        args = {@Argument(name = \"arr\", type = TypeKind.ARRAY), @Argument(name = \"direction\", type = TypeKind.OBJECT),\n+                @Argument(name = \"func\", type = TypeKind.OBJECT)},\n         returnType = {@ReturnType(type = TypeKind.ARRAY)},\n         isPublic = true\n )\n public class Sort {\n \n-    public static ArrayValue sort(Strand strand, ArrayValue arr, FPValue<Object, Long> func) {\n+    public static ArrayValue sort(Strand strand, ArrayValue arr, Object direction, Object func) {\n         checkIsArrayOnlyOperation(arr.getType(), \"sort()\");\n-        ArrayValue aux = new ArrayValueImpl((BArrayType) arr.getType());\n-        mergesort(arr, aux, 0, arr.size() - 1, strand, func);\n+        FPValue<Object, Object> function = (FPValue<Object, Object>) func;\n+        BType elemType = ((BArrayType) arr.getType()).getElementType();\n+        boolean isAscending = true;\n+        if (direction.toString().equals(\"descending\")) {\n+            isAscending = false;\n+        }\n+\n+        Object[][] sortArr = new Object[arr.size()][2];\n+        Object[][] sortArrClone = new Object[arr.size()][2];\n+        for (int i = 0; i < arr.size(); i++) {\n+            if (function != null) {\n+                Object x = function.call(new Object[]{strand, arr.get(i), true});\n+                sortArr[i][0] = x;\n+            } else {\n+                sortArr[i][0] = arr.get(i);\n+            }\n+            sortArr[i][1] = arr.get(i);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f6242477c6a3f424e14896da82d393f2393efb0d"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzM4OTkzMA==", "bodyText": "If go with the suggestion to swap the null check above, we can move this there too.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#discussion_r483389930", "createdAt": "2020-09-04T05:10:32Z", "author": {"login": "MaryamZi"}, "path": "langlib/lang.array/src/main/java/org/ballerinalang/langlib/array/Sort.java", "diffHunk": "@@ -18,73 +18,185 @@\n \n package org.ballerinalang.langlib.array;\n \n+import org.ballerinalang.jvm.BallerinaErrors;\n import org.ballerinalang.jvm.scheduling.Strand;\n import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BFunctionType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BUnionType;\n+import org.ballerinalang.jvm.types.TypeTags;\n import org.ballerinalang.jvm.values.ArrayValue;\n-import org.ballerinalang.jvm.values.ArrayValueImpl;\n import org.ballerinalang.jvm.values.FPValue;\n import org.ballerinalang.model.types.TypeKind;\n import org.ballerinalang.natives.annotations.Argument;\n import org.ballerinalang.natives.annotations.BallerinaFunction;\n import org.ballerinalang.natives.annotations.ReturnType;\n \n+import java.math.BigDecimal;\n+import java.util.Optional;\n+\n import static org.ballerinalang.jvm.values.utils.ArrayUtils.checkIsArrayOnlyOperation;\n import static org.ballerinalang.util.BLangCompilerConstants.ARRAY_VERSION;\n \n /**\n- * Native implementation of lang.array:sort((any|error)[], function).\n+ * Native implementation of lang.array:sort((any|error)[], direction, function).\n  *\n  * @since 1.0\n  */\n @BallerinaFunction(\n         orgName = \"ballerina\", packageName = \"lang.array\", version = ARRAY_VERSION, functionName = \"sort\",\n-        args = {@Argument(name = \"arr\", type = TypeKind.ARRAY), @Argument(name = \"func\", type = TypeKind.FUNCTION)},\n+        args = {@Argument(name = \"arr\", type = TypeKind.ARRAY), @Argument(name = \"direction\", type = TypeKind.OBJECT),\n+                @Argument(name = \"func\", type = TypeKind.OBJECT)},\n         returnType = {@ReturnType(type = TypeKind.ARRAY)},\n         isPublic = true\n )\n public class Sort {\n \n-    public static ArrayValue sort(Strand strand, ArrayValue arr, FPValue<Object, Long> func) {\n+    public static ArrayValue sort(Strand strand, ArrayValue arr, Object direction, Object func) {\n         checkIsArrayOnlyOperation(arr.getType(), \"sort()\");\n-        ArrayValue aux = new ArrayValueImpl((BArrayType) arr.getType());\n-        mergesort(arr, aux, 0, arr.size() - 1, strand, func);\n+        FPValue<Object, Object> function = (FPValue<Object, Object>) func;\n+        BType elemType = ((BArrayType) arr.getType()).getElementType();\n+        boolean isAscending = true;\n+        if (direction.toString().equals(\"descending\")) {\n+            isAscending = false;\n+        }\n+\n+        Object[][] sortArr = new Object[arr.size()][2];\n+        Object[][] sortArrClone = new Object[arr.size()][2];\n+        for (int i = 0; i < arr.size(); i++) {\n+            if (function != null) {\n+                Object x = function.call(new Object[]{strand, arr.get(i), true});\n+                sortArr[i][0] = x;\n+            } else {\n+                sortArr[i][0] = arr.get(i);\n+            }\n+            sortArr[i][1] = arr.get(i);\n+        }\n+\n+        if (function != null) {\n+            elemType = ((BFunctionType) function.getType()).retType;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f6242477c6a3f424e14896da82d393f2393efb0d"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzM5MTY5OA==", "bodyText": "We avoid using streams due to perf impact.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#discussion_r483391698", "createdAt": "2020-09-04T05:16:44Z", "author": {"login": "MaryamZi"}, "path": "langlib/lang.array/src/main/java/org/ballerinalang/langlib/array/Sort.java", "diffHunk": "@@ -18,73 +18,185 @@\n \n package org.ballerinalang.langlib.array;\n \n+import org.ballerinalang.jvm.BallerinaErrors;\n import org.ballerinalang.jvm.scheduling.Strand;\n import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BFunctionType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BUnionType;\n+import org.ballerinalang.jvm.types.TypeTags;\n import org.ballerinalang.jvm.values.ArrayValue;\n-import org.ballerinalang.jvm.values.ArrayValueImpl;\n import org.ballerinalang.jvm.values.FPValue;\n import org.ballerinalang.model.types.TypeKind;\n import org.ballerinalang.natives.annotations.Argument;\n import org.ballerinalang.natives.annotations.BallerinaFunction;\n import org.ballerinalang.natives.annotations.ReturnType;\n \n+import java.math.BigDecimal;\n+import java.util.Optional;\n+\n import static org.ballerinalang.jvm.values.utils.ArrayUtils.checkIsArrayOnlyOperation;\n import static org.ballerinalang.util.BLangCompilerConstants.ARRAY_VERSION;\n \n /**\n- * Native implementation of lang.array:sort((any|error)[], function).\n+ * Native implementation of lang.array:sort((any|error)[], direction, function).\n  *\n  * @since 1.0\n  */\n @BallerinaFunction(\n         orgName = \"ballerina\", packageName = \"lang.array\", version = ARRAY_VERSION, functionName = \"sort\",\n-        args = {@Argument(name = \"arr\", type = TypeKind.ARRAY), @Argument(name = \"func\", type = TypeKind.FUNCTION)},\n+        args = {@Argument(name = \"arr\", type = TypeKind.ARRAY), @Argument(name = \"direction\", type = TypeKind.OBJECT),\n+                @Argument(name = \"func\", type = TypeKind.OBJECT)},\n         returnType = {@ReturnType(type = TypeKind.ARRAY)},\n         isPublic = true\n )\n public class Sort {\n \n-    public static ArrayValue sort(Strand strand, ArrayValue arr, FPValue<Object, Long> func) {\n+    public static ArrayValue sort(Strand strand, ArrayValue arr, Object direction, Object func) {\n         checkIsArrayOnlyOperation(arr.getType(), \"sort()\");\n-        ArrayValue aux = new ArrayValueImpl((BArrayType) arr.getType());\n-        mergesort(arr, aux, 0, arr.size() - 1, strand, func);\n+        FPValue<Object, Object> function = (FPValue<Object, Object>) func;\n+        BType elemType = ((BArrayType) arr.getType()).getElementType();\n+        boolean isAscending = true;\n+        if (direction.toString().equals(\"descending\")) {\n+            isAscending = false;\n+        }\n+\n+        Object[][] sortArr = new Object[arr.size()][2];\n+        Object[][] sortArrClone = new Object[arr.size()][2];\n+        for (int i = 0; i < arr.size(); i++) {\n+            if (function != null) {\n+                Object x = function.call(new Object[]{strand, arr.get(i), true});\n+                sortArr[i][0] = x;\n+            } else {\n+                sortArr[i][0] = arr.get(i);\n+            }\n+            sortArr[i][1] = arr.get(i);\n+        }\n+\n+        if (function != null) {\n+            elemType = ((BFunctionType) function.getType()).retType;\n+        }\n+        if (elemType.getTag() == TypeTags.UNION_TAG) {\n+            elemType = getType(elemType);\n+        }\n+        if (elemType.getTag() == TypeTags.ARRAY_TAG) {\n+            BType type = ((BArrayType) elemType).getElementType();\n+            if (type.getTag() == TypeTags.UNION_TAG) {\n+                elemType = getType(type);\n+            }\n+        }\n+\n+        mergesort(sortArr, sortArrClone, 0, sortArr.length - 1, isAscending, elemType);\n+\n+        for (int k = 0; k < sortArr.length; k++) {\n+            arr.add(k, sortArr[k][1]);\n+        }\n+\n         return arr;\n     }\n \n-    // Adapted from https://algs4.cs.princeton.edu/22mergesort/Merge.java.html\n-    private static void mergesort(ArrayValue input, ArrayValue aux, int lo, int hi, Strand strand,\n-                                  FPValue<Object, Long> comparator) {\n+    private static BType getType(BType type) {\n+        Optional<BType> mainType = ((BUnionType) type).getMemberTypes().stream()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f6242477c6a3f424e14896da82d393f2393efb0d"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzM5MTgyMQ==", "bodyText": "What if the union has multiple compatible types? Should it not be an error?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#discussion_r483391821", "createdAt": "2020-09-04T05:17:11Z", "author": {"login": "MaryamZi"}, "path": "langlib/lang.array/src/main/java/org/ballerinalang/langlib/array/Sort.java", "diffHunk": "@@ -18,73 +18,185 @@\n \n package org.ballerinalang.langlib.array;\n \n+import org.ballerinalang.jvm.BallerinaErrors;\n import org.ballerinalang.jvm.scheduling.Strand;\n import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BFunctionType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BUnionType;\n+import org.ballerinalang.jvm.types.TypeTags;\n import org.ballerinalang.jvm.values.ArrayValue;\n-import org.ballerinalang.jvm.values.ArrayValueImpl;\n import org.ballerinalang.jvm.values.FPValue;\n import org.ballerinalang.model.types.TypeKind;\n import org.ballerinalang.natives.annotations.Argument;\n import org.ballerinalang.natives.annotations.BallerinaFunction;\n import org.ballerinalang.natives.annotations.ReturnType;\n \n+import java.math.BigDecimal;\n+import java.util.Optional;\n+\n import static org.ballerinalang.jvm.values.utils.ArrayUtils.checkIsArrayOnlyOperation;\n import static org.ballerinalang.util.BLangCompilerConstants.ARRAY_VERSION;\n \n /**\n- * Native implementation of lang.array:sort((any|error)[], function).\n+ * Native implementation of lang.array:sort((any|error)[], direction, function).\n  *\n  * @since 1.0\n  */\n @BallerinaFunction(\n         orgName = \"ballerina\", packageName = \"lang.array\", version = ARRAY_VERSION, functionName = \"sort\",\n-        args = {@Argument(name = \"arr\", type = TypeKind.ARRAY), @Argument(name = \"func\", type = TypeKind.FUNCTION)},\n+        args = {@Argument(name = \"arr\", type = TypeKind.ARRAY), @Argument(name = \"direction\", type = TypeKind.OBJECT),\n+                @Argument(name = \"func\", type = TypeKind.OBJECT)},\n         returnType = {@ReturnType(type = TypeKind.ARRAY)},\n         isPublic = true\n )\n public class Sort {\n \n-    public static ArrayValue sort(Strand strand, ArrayValue arr, FPValue<Object, Long> func) {\n+    public static ArrayValue sort(Strand strand, ArrayValue arr, Object direction, Object func) {\n         checkIsArrayOnlyOperation(arr.getType(), \"sort()\");\n-        ArrayValue aux = new ArrayValueImpl((BArrayType) arr.getType());\n-        mergesort(arr, aux, 0, arr.size() - 1, strand, func);\n+        FPValue<Object, Object> function = (FPValue<Object, Object>) func;\n+        BType elemType = ((BArrayType) arr.getType()).getElementType();\n+        boolean isAscending = true;\n+        if (direction.toString().equals(\"descending\")) {\n+            isAscending = false;\n+        }\n+\n+        Object[][] sortArr = new Object[arr.size()][2];\n+        Object[][] sortArrClone = new Object[arr.size()][2];\n+        for (int i = 0; i < arr.size(); i++) {\n+            if (function != null) {\n+                Object x = function.call(new Object[]{strand, arr.get(i), true});\n+                sortArr[i][0] = x;\n+            } else {\n+                sortArr[i][0] = arr.get(i);\n+            }\n+            sortArr[i][1] = arr.get(i);\n+        }\n+\n+        if (function != null) {\n+            elemType = ((BFunctionType) function.getType()).retType;\n+        }\n+        if (elemType.getTag() == TypeTags.UNION_TAG) {\n+            elemType = getType(elemType);\n+        }\n+        if (elemType.getTag() == TypeTags.ARRAY_TAG) {\n+            BType type = ((BArrayType) elemType).getElementType();\n+            if (type.getTag() == TypeTags.UNION_TAG) {\n+                elemType = getType(type);\n+            }\n+        }\n+\n+        mergesort(sortArr, sortArrClone, 0, sortArr.length - 1, isAscending, elemType);\n+\n+        for (int k = 0; k < sortArr.length; k++) {\n+            arr.add(k, sortArr[k][1]);\n+        }\n+\n         return arr;\n     }\n \n-    // Adapted from https://algs4.cs.princeton.edu/22mergesort/Merge.java.html\n-    private static void mergesort(ArrayValue input, ArrayValue aux, int lo, int hi, Strand strand,\n-                                  FPValue<Object, Long> comparator) {\n+    private static BType getType(BType type) {\n+        Optional<BType> mainType = ((BUnionType) type).getMemberTypes().stream()\n+                .filter(m -> m.getTag() == TypeTags.INT_TAG || m.getTag() == TypeTags.BYTE_TAG ||\n+                        m.getTag() == TypeTags.FLOAT_TAG || m.getTag() == TypeTags.DECIMAL_TAG ||\n+                        m.getTag() == TypeTags.STRING_TAG || m.getTag() == TypeTags.BOOLEAN_TAG ||\n+                        m.getTag() == TypeTags.ARRAY_TAG).findFirst();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f6242477c6a3f424e14896da82d393f2393efb0d"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzM5MjAwNw==", "bodyText": "Can we rename the function to indicate what we're actually looking for and change the param to a BUnionType?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#discussion_r483392007", "createdAt": "2020-09-04T05:17:53Z", "author": {"login": "MaryamZi"}, "path": "langlib/lang.array/src/main/java/org/ballerinalang/langlib/array/Sort.java", "diffHunk": "@@ -18,73 +18,185 @@\n \n package org.ballerinalang.langlib.array;\n \n+import org.ballerinalang.jvm.BallerinaErrors;\n import org.ballerinalang.jvm.scheduling.Strand;\n import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BFunctionType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BUnionType;\n+import org.ballerinalang.jvm.types.TypeTags;\n import org.ballerinalang.jvm.values.ArrayValue;\n-import org.ballerinalang.jvm.values.ArrayValueImpl;\n import org.ballerinalang.jvm.values.FPValue;\n import org.ballerinalang.model.types.TypeKind;\n import org.ballerinalang.natives.annotations.Argument;\n import org.ballerinalang.natives.annotations.BallerinaFunction;\n import org.ballerinalang.natives.annotations.ReturnType;\n \n+import java.math.BigDecimal;\n+import java.util.Optional;\n+\n import static org.ballerinalang.jvm.values.utils.ArrayUtils.checkIsArrayOnlyOperation;\n import static org.ballerinalang.util.BLangCompilerConstants.ARRAY_VERSION;\n \n /**\n- * Native implementation of lang.array:sort((any|error)[], function).\n+ * Native implementation of lang.array:sort((any|error)[], direction, function).\n  *\n  * @since 1.0\n  */\n @BallerinaFunction(\n         orgName = \"ballerina\", packageName = \"lang.array\", version = ARRAY_VERSION, functionName = \"sort\",\n-        args = {@Argument(name = \"arr\", type = TypeKind.ARRAY), @Argument(name = \"func\", type = TypeKind.FUNCTION)},\n+        args = {@Argument(name = \"arr\", type = TypeKind.ARRAY), @Argument(name = \"direction\", type = TypeKind.OBJECT),\n+                @Argument(name = \"func\", type = TypeKind.OBJECT)},\n         returnType = {@ReturnType(type = TypeKind.ARRAY)},\n         isPublic = true\n )\n public class Sort {\n \n-    public static ArrayValue sort(Strand strand, ArrayValue arr, FPValue<Object, Long> func) {\n+    public static ArrayValue sort(Strand strand, ArrayValue arr, Object direction, Object func) {\n         checkIsArrayOnlyOperation(arr.getType(), \"sort()\");\n-        ArrayValue aux = new ArrayValueImpl((BArrayType) arr.getType());\n-        mergesort(arr, aux, 0, arr.size() - 1, strand, func);\n+        FPValue<Object, Object> function = (FPValue<Object, Object>) func;\n+        BType elemType = ((BArrayType) arr.getType()).getElementType();\n+        boolean isAscending = true;\n+        if (direction.toString().equals(\"descending\")) {\n+            isAscending = false;\n+        }\n+\n+        Object[][] sortArr = new Object[arr.size()][2];\n+        Object[][] sortArrClone = new Object[arr.size()][2];\n+        for (int i = 0; i < arr.size(); i++) {\n+            if (function != null) {\n+                Object x = function.call(new Object[]{strand, arr.get(i), true});\n+                sortArr[i][0] = x;\n+            } else {\n+                sortArr[i][0] = arr.get(i);\n+            }\n+            sortArr[i][1] = arr.get(i);\n+        }\n+\n+        if (function != null) {\n+            elemType = ((BFunctionType) function.getType()).retType;\n+        }\n+        if (elemType.getTag() == TypeTags.UNION_TAG) {\n+            elemType = getType(elemType);\n+        }\n+        if (elemType.getTag() == TypeTags.ARRAY_TAG) {\n+            BType type = ((BArrayType) elemType).getElementType();\n+            if (type.getTag() == TypeTags.UNION_TAG) {\n+                elemType = getType(type);\n+            }\n+        }\n+\n+        mergesort(sortArr, sortArrClone, 0, sortArr.length - 1, isAscending, elemType);\n+\n+        for (int k = 0; k < sortArr.length; k++) {\n+            arr.add(k, sortArr[k][1]);\n+        }\n+\n         return arr;\n     }\n \n-    // Adapted from https://algs4.cs.princeton.edu/22mergesort/Merge.java.html\n-    private static void mergesort(ArrayValue input, ArrayValue aux, int lo, int hi, Strand strand,\n-                                  FPValue<Object, Long> comparator) {\n+    private static BType getType(BType type) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f6242477c6a3f424e14896da82d393f2393efb0d"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzM5MjcwNw==", "bodyText": "Since you're definitely returning in the previous if bock we can make this another if instead of an else-if right?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#discussion_r483392707", "createdAt": "2020-09-04T05:20:32Z", "author": {"login": "MaryamZi"}, "path": "langlib/lang.array/src/main/java/org/ballerinalang/langlib/array/Sort.java", "diffHunk": "@@ -18,73 +18,185 @@\n \n package org.ballerinalang.langlib.array;\n \n+import org.ballerinalang.jvm.BallerinaErrors;\n import org.ballerinalang.jvm.scheduling.Strand;\n import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BFunctionType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BUnionType;\n+import org.ballerinalang.jvm.types.TypeTags;\n import org.ballerinalang.jvm.values.ArrayValue;\n-import org.ballerinalang.jvm.values.ArrayValueImpl;\n import org.ballerinalang.jvm.values.FPValue;\n import org.ballerinalang.model.types.TypeKind;\n import org.ballerinalang.natives.annotations.Argument;\n import org.ballerinalang.natives.annotations.BallerinaFunction;\n import org.ballerinalang.natives.annotations.ReturnType;\n \n+import java.math.BigDecimal;\n+import java.util.Optional;\n+\n import static org.ballerinalang.jvm.values.utils.ArrayUtils.checkIsArrayOnlyOperation;\n import static org.ballerinalang.util.BLangCompilerConstants.ARRAY_VERSION;\n \n /**\n- * Native implementation of lang.array:sort((any|error)[], function).\n+ * Native implementation of lang.array:sort((any|error)[], direction, function).\n  *\n  * @since 1.0\n  */\n @BallerinaFunction(\n         orgName = \"ballerina\", packageName = \"lang.array\", version = ARRAY_VERSION, functionName = \"sort\",\n-        args = {@Argument(name = \"arr\", type = TypeKind.ARRAY), @Argument(name = \"func\", type = TypeKind.FUNCTION)},\n+        args = {@Argument(name = \"arr\", type = TypeKind.ARRAY), @Argument(name = \"direction\", type = TypeKind.OBJECT),\n+                @Argument(name = \"func\", type = TypeKind.OBJECT)},\n         returnType = {@ReturnType(type = TypeKind.ARRAY)},\n         isPublic = true\n )\n public class Sort {\n \n-    public static ArrayValue sort(Strand strand, ArrayValue arr, FPValue<Object, Long> func) {\n+    public static ArrayValue sort(Strand strand, ArrayValue arr, Object direction, Object func) {\n         checkIsArrayOnlyOperation(arr.getType(), \"sort()\");\n-        ArrayValue aux = new ArrayValueImpl((BArrayType) arr.getType());\n-        mergesort(arr, aux, 0, arr.size() - 1, strand, func);\n+        FPValue<Object, Object> function = (FPValue<Object, Object>) func;\n+        BType elemType = ((BArrayType) arr.getType()).getElementType();\n+        boolean isAscending = true;\n+        if (direction.toString().equals(\"descending\")) {\n+            isAscending = false;\n+        }\n+\n+        Object[][] sortArr = new Object[arr.size()][2];\n+        Object[][] sortArrClone = new Object[arr.size()][2];\n+        for (int i = 0; i < arr.size(); i++) {\n+            if (function != null) {\n+                Object x = function.call(new Object[]{strand, arr.get(i), true});\n+                sortArr[i][0] = x;\n+            } else {\n+                sortArr[i][0] = arr.get(i);\n+            }\n+            sortArr[i][1] = arr.get(i);\n+        }\n+\n+        if (function != null) {\n+            elemType = ((BFunctionType) function.getType()).retType;\n+        }\n+        if (elemType.getTag() == TypeTags.UNION_TAG) {\n+            elemType = getType(elemType);\n+        }\n+        if (elemType.getTag() == TypeTags.ARRAY_TAG) {\n+            BType type = ((BArrayType) elemType).getElementType();\n+            if (type.getTag() == TypeTags.UNION_TAG) {\n+                elemType = getType(type);\n+            }\n+        }\n+\n+        mergesort(sortArr, sortArrClone, 0, sortArr.length - 1, isAscending, elemType);\n+\n+        for (int k = 0; k < sortArr.length; k++) {\n+            arr.add(k, sortArr[k][1]);\n+        }\n+\n         return arr;\n     }\n \n-    // Adapted from https://algs4.cs.princeton.edu/22mergesort/Merge.java.html\n-    private static void mergesort(ArrayValue input, ArrayValue aux, int lo, int hi, Strand strand,\n-                                  FPValue<Object, Long> comparator) {\n+    private static BType getType(BType type) {\n+        Optional<BType> mainType = ((BUnionType) type).getMemberTypes().stream()\n+                .filter(m -> m.getTag() == TypeTags.INT_TAG || m.getTag() == TypeTags.BYTE_TAG ||\n+                        m.getTag() == TypeTags.FLOAT_TAG || m.getTag() == TypeTags.DECIMAL_TAG ||\n+                        m.getTag() == TypeTags.STRING_TAG || m.getTag() == TypeTags.BOOLEAN_TAG ||\n+                        m.getTag() == TypeTags.ARRAY_TAG).findFirst();\n+        if (mainType.isPresent()) {\n+            type = mainType.get();\n+        }\n+        return type;\n+    }\n+\n+    private static void mergesort(Object[][] input, Object[][] aux, int lo, int hi, boolean isAscending, BType type) {\n         if (hi <= lo) {\n             return;\n         }\n \n         int mid = lo + (hi - lo) / 2;\n \n-        mergesort(input, aux, lo, mid, strand, comparator);\n-        mergesort(input, aux, mid + 1, hi, strand, comparator);\n+        mergesort(input, aux, lo, mid, isAscending, type);\n+        mergesort(input, aux, mid + 1, hi, isAscending, type);\n \n-        merge(input, aux, lo, mid, hi, strand, comparator);\n+        merge(input, aux, lo, mid, hi, isAscending, type);\n     }\n \n-    private static void merge(ArrayValue input, ArrayValue aux, int lo, int mid, int hi, Strand strand,\n-                              FPValue<Object, Long> comparator) {\n-        int elemTypeTag = input.getElementType().getTag();\n-\n-        for (int i = lo; i <= hi; i++) {\n-            aux.add(i, input.get(i));\n+    private static void merge(Object[][] input, Object[][] aux, int lo, int mid, int hi, boolean isAscending,\n+                              BType type) {\n+        if (hi + 1 - lo >= 0) {\n+            System.arraycopy(input, lo, aux, lo, hi + 1 - lo);\n         }\n \n         for (int i = lo, j = mid + 1, k = lo; k <= hi; k++) {\n+            int index;\n             if (i > mid) {\n-                input.add(k, aux.get(j++));\n+                index = j++;\n             } else if (j > hi) {\n-                input.add(k, aux.get(i++));\n-            } else if (comparator.call(new Object[]{strand, aux.get(j), true, aux.get(i), true}) < 0) {\n-                input.add(k, aux.get(j++));\n+                index = i++;\n+            } else if (isAscending && sortFunc(aux[j][0], aux[i][0], type, true) < 0) {\n+                index = j++;\n+            } else if (!isAscending && sortFunc(aux[i][0], aux[j][0], type, false) < 0) {\n+                index = j++;\n             } else {\n-                input.add(k, aux.get(i++));\n+                index = i++;\n             }\n+            input[k] = aux[index];\n         }\n     }\n \n+    private static int sortFunc(Object value1, Object value2, BType type, boolean isAscending) {\n+        int c = -999;\n+        // () should come last irrespective of the sort direction.\n+        if (value1 == null) {\n+            if (value2 == null) {\n+                return 0;\n+            }\n+            if (isAscending) {\n+                return 1;\n+            }\n+            return -1;\n+        } else if (value2 == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f6242477c6a3f424e14896da82d393f2393efb0d"}, "originalPosition": 163}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzM5MzI1NQ==", "bodyText": "What about subtypes like SIGNED32_INT_TAG, SIGNED16_INT_TAG, etc.? Same for string and char too.\nThe util methods in TypeTags.java may be useful. org.ballerinalang.jvm.types.TypeTags#isIntegerTypeTag", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#discussion_r483393255", "createdAt": "2020-09-04T05:22:37Z", "author": {"login": "MaryamZi"}, "path": "langlib/lang.array/src/main/java/org/ballerinalang/langlib/array/Sort.java", "diffHunk": "@@ -18,73 +18,185 @@\n \n package org.ballerinalang.langlib.array;\n \n+import org.ballerinalang.jvm.BallerinaErrors;\n import org.ballerinalang.jvm.scheduling.Strand;\n import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BFunctionType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BUnionType;\n+import org.ballerinalang.jvm.types.TypeTags;\n import org.ballerinalang.jvm.values.ArrayValue;\n-import org.ballerinalang.jvm.values.ArrayValueImpl;\n import org.ballerinalang.jvm.values.FPValue;\n import org.ballerinalang.model.types.TypeKind;\n import org.ballerinalang.natives.annotations.Argument;\n import org.ballerinalang.natives.annotations.BallerinaFunction;\n import org.ballerinalang.natives.annotations.ReturnType;\n \n+import java.math.BigDecimal;\n+import java.util.Optional;\n+\n import static org.ballerinalang.jvm.values.utils.ArrayUtils.checkIsArrayOnlyOperation;\n import static org.ballerinalang.util.BLangCompilerConstants.ARRAY_VERSION;\n \n /**\n- * Native implementation of lang.array:sort((any|error)[], function).\n+ * Native implementation of lang.array:sort((any|error)[], direction, function).\n  *\n  * @since 1.0\n  */\n @BallerinaFunction(\n         orgName = \"ballerina\", packageName = \"lang.array\", version = ARRAY_VERSION, functionName = \"sort\",\n-        args = {@Argument(name = \"arr\", type = TypeKind.ARRAY), @Argument(name = \"func\", type = TypeKind.FUNCTION)},\n+        args = {@Argument(name = \"arr\", type = TypeKind.ARRAY), @Argument(name = \"direction\", type = TypeKind.OBJECT),\n+                @Argument(name = \"func\", type = TypeKind.OBJECT)},\n         returnType = {@ReturnType(type = TypeKind.ARRAY)},\n         isPublic = true\n )\n public class Sort {\n \n-    public static ArrayValue sort(Strand strand, ArrayValue arr, FPValue<Object, Long> func) {\n+    public static ArrayValue sort(Strand strand, ArrayValue arr, Object direction, Object func) {\n         checkIsArrayOnlyOperation(arr.getType(), \"sort()\");\n-        ArrayValue aux = new ArrayValueImpl((BArrayType) arr.getType());\n-        mergesort(arr, aux, 0, arr.size() - 1, strand, func);\n+        FPValue<Object, Object> function = (FPValue<Object, Object>) func;\n+        BType elemType = ((BArrayType) arr.getType()).getElementType();\n+        boolean isAscending = true;\n+        if (direction.toString().equals(\"descending\")) {\n+            isAscending = false;\n+        }\n+\n+        Object[][] sortArr = new Object[arr.size()][2];\n+        Object[][] sortArrClone = new Object[arr.size()][2];\n+        for (int i = 0; i < arr.size(); i++) {\n+            if (function != null) {\n+                Object x = function.call(new Object[]{strand, arr.get(i), true});\n+                sortArr[i][0] = x;\n+            } else {\n+                sortArr[i][0] = arr.get(i);\n+            }\n+            sortArr[i][1] = arr.get(i);\n+        }\n+\n+        if (function != null) {\n+            elemType = ((BFunctionType) function.getType()).retType;\n+        }\n+        if (elemType.getTag() == TypeTags.UNION_TAG) {\n+            elemType = getType(elemType);\n+        }\n+        if (elemType.getTag() == TypeTags.ARRAY_TAG) {\n+            BType type = ((BArrayType) elemType).getElementType();\n+            if (type.getTag() == TypeTags.UNION_TAG) {\n+                elemType = getType(type);\n+            }\n+        }\n+\n+        mergesort(sortArr, sortArrClone, 0, sortArr.length - 1, isAscending, elemType);\n+\n+        for (int k = 0; k < sortArr.length; k++) {\n+            arr.add(k, sortArr[k][1]);\n+        }\n+\n         return arr;\n     }\n \n-    // Adapted from https://algs4.cs.princeton.edu/22mergesort/Merge.java.html\n-    private static void mergesort(ArrayValue input, ArrayValue aux, int lo, int hi, Strand strand,\n-                                  FPValue<Object, Long> comparator) {\n+    private static BType getType(BType type) {\n+        Optional<BType> mainType = ((BUnionType) type).getMemberTypes().stream()\n+                .filter(m -> m.getTag() == TypeTags.INT_TAG || m.getTag() == TypeTags.BYTE_TAG ||\n+                        m.getTag() == TypeTags.FLOAT_TAG || m.getTag() == TypeTags.DECIMAL_TAG ||\n+                        m.getTag() == TypeTags.STRING_TAG || m.getTag() == TypeTags.BOOLEAN_TAG ||\n+                        m.getTag() == TypeTags.ARRAY_TAG).findFirst();\n+        if (mainType.isPresent()) {\n+            type = mainType.get();\n+        }\n+        return type;\n+    }\n+\n+    private static void mergesort(Object[][] input, Object[][] aux, int lo, int hi, boolean isAscending, BType type) {\n         if (hi <= lo) {\n             return;\n         }\n \n         int mid = lo + (hi - lo) / 2;\n \n-        mergesort(input, aux, lo, mid, strand, comparator);\n-        mergesort(input, aux, mid + 1, hi, strand, comparator);\n+        mergesort(input, aux, lo, mid, isAscending, type);\n+        mergesort(input, aux, mid + 1, hi, isAscending, type);\n \n-        merge(input, aux, lo, mid, hi, strand, comparator);\n+        merge(input, aux, lo, mid, hi, isAscending, type);\n     }\n \n-    private static void merge(ArrayValue input, ArrayValue aux, int lo, int mid, int hi, Strand strand,\n-                              FPValue<Object, Long> comparator) {\n-        int elemTypeTag = input.getElementType().getTag();\n-\n-        for (int i = lo; i <= hi; i++) {\n-            aux.add(i, input.get(i));\n+    private static void merge(Object[][] input, Object[][] aux, int lo, int mid, int hi, boolean isAscending,\n+                              BType type) {\n+        if (hi + 1 - lo >= 0) {\n+            System.arraycopy(input, lo, aux, lo, hi + 1 - lo);\n         }\n \n         for (int i = lo, j = mid + 1, k = lo; k <= hi; k++) {\n+            int index;\n             if (i > mid) {\n-                input.add(k, aux.get(j++));\n+                index = j++;\n             } else if (j > hi) {\n-                input.add(k, aux.get(i++));\n-            } else if (comparator.call(new Object[]{strand, aux.get(j), true, aux.get(i), true}) < 0) {\n-                input.add(k, aux.get(j++));\n+                index = i++;\n+            } else if (isAscending && sortFunc(aux[j][0], aux[i][0], type, true) < 0) {\n+                index = j++;\n+            } else if (!isAscending && sortFunc(aux[i][0], aux[j][0], type, false) < 0) {\n+                index = j++;\n             } else {\n-                input.add(k, aux.get(i++));\n+                index = i++;\n             }\n+            input[k] = aux[index];\n         }\n     }\n \n+    private static int sortFunc(Object value1, Object value2, BType type, boolean isAscending) {\n+        int c = -999;\n+        // () should come last irrespective of the sort direction.\n+        if (value1 == null) {\n+            if (value2 == null) {\n+                return 0;\n+            }\n+            if (isAscending) {\n+                return 1;\n+            }\n+            return -1;\n+        } else if (value2 == null) {\n+            if (isAscending) {\n+                return -1;\n+            }\n+            return 1;\n+        } else if (type.getTag() == TypeTags.INT_TAG) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f6242477c6a3f424e14896da82d393f2393efb0d"}, "originalPosition": 168}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzM5Mzk2NQ==", "bodyText": "This doesn't seem to follow the normal practice we follow for langlib errors. We currently have a simple string as the error message and the second arg goes into the detail. Please check other usage of this method.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#discussion_r483393965", "createdAt": "2020-09-04T05:25:15Z", "author": {"login": "MaryamZi"}, "path": "langlib/lang.array/src/main/java/org/ballerinalang/langlib/array/Sort.java", "diffHunk": "@@ -18,73 +18,185 @@\n \n package org.ballerinalang.langlib.array;\n \n+import org.ballerinalang.jvm.BallerinaErrors;\n import org.ballerinalang.jvm.scheduling.Strand;\n import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BFunctionType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BUnionType;\n+import org.ballerinalang.jvm.types.TypeTags;\n import org.ballerinalang.jvm.values.ArrayValue;\n-import org.ballerinalang.jvm.values.ArrayValueImpl;\n import org.ballerinalang.jvm.values.FPValue;\n import org.ballerinalang.model.types.TypeKind;\n import org.ballerinalang.natives.annotations.Argument;\n import org.ballerinalang.natives.annotations.BallerinaFunction;\n import org.ballerinalang.natives.annotations.ReturnType;\n \n+import java.math.BigDecimal;\n+import java.util.Optional;\n+\n import static org.ballerinalang.jvm.values.utils.ArrayUtils.checkIsArrayOnlyOperation;\n import static org.ballerinalang.util.BLangCompilerConstants.ARRAY_VERSION;\n \n /**\n- * Native implementation of lang.array:sort((any|error)[], function).\n+ * Native implementation of lang.array:sort((any|error)[], direction, function).\n  *\n  * @since 1.0\n  */\n @BallerinaFunction(\n         orgName = \"ballerina\", packageName = \"lang.array\", version = ARRAY_VERSION, functionName = \"sort\",\n-        args = {@Argument(name = \"arr\", type = TypeKind.ARRAY), @Argument(name = \"func\", type = TypeKind.FUNCTION)},\n+        args = {@Argument(name = \"arr\", type = TypeKind.ARRAY), @Argument(name = \"direction\", type = TypeKind.OBJECT),\n+                @Argument(name = \"func\", type = TypeKind.OBJECT)},\n         returnType = {@ReturnType(type = TypeKind.ARRAY)},\n         isPublic = true\n )\n public class Sort {\n \n-    public static ArrayValue sort(Strand strand, ArrayValue arr, FPValue<Object, Long> func) {\n+    public static ArrayValue sort(Strand strand, ArrayValue arr, Object direction, Object func) {\n         checkIsArrayOnlyOperation(arr.getType(), \"sort()\");\n-        ArrayValue aux = new ArrayValueImpl((BArrayType) arr.getType());\n-        mergesort(arr, aux, 0, arr.size() - 1, strand, func);\n+        FPValue<Object, Object> function = (FPValue<Object, Object>) func;\n+        BType elemType = ((BArrayType) arr.getType()).getElementType();\n+        boolean isAscending = true;\n+        if (direction.toString().equals(\"descending\")) {\n+            isAscending = false;\n+        }\n+\n+        Object[][] sortArr = new Object[arr.size()][2];\n+        Object[][] sortArrClone = new Object[arr.size()][2];\n+        for (int i = 0; i < arr.size(); i++) {\n+            if (function != null) {\n+                Object x = function.call(new Object[]{strand, arr.get(i), true});\n+                sortArr[i][0] = x;\n+            } else {\n+                sortArr[i][0] = arr.get(i);\n+            }\n+            sortArr[i][1] = arr.get(i);\n+        }\n+\n+        if (function != null) {\n+            elemType = ((BFunctionType) function.getType()).retType;\n+        }\n+        if (elemType.getTag() == TypeTags.UNION_TAG) {\n+            elemType = getType(elemType);\n+        }\n+        if (elemType.getTag() == TypeTags.ARRAY_TAG) {\n+            BType type = ((BArrayType) elemType).getElementType();\n+            if (type.getTag() == TypeTags.UNION_TAG) {\n+                elemType = getType(type);\n+            }\n+        }\n+\n+        mergesort(sortArr, sortArrClone, 0, sortArr.length - 1, isAscending, elemType);\n+\n+        for (int k = 0; k < sortArr.length; k++) {\n+            arr.add(k, sortArr[k][1]);\n+        }\n+\n         return arr;\n     }\n \n-    // Adapted from https://algs4.cs.princeton.edu/22mergesort/Merge.java.html\n-    private static void mergesort(ArrayValue input, ArrayValue aux, int lo, int hi, Strand strand,\n-                                  FPValue<Object, Long> comparator) {\n+    private static BType getType(BType type) {\n+        Optional<BType> mainType = ((BUnionType) type).getMemberTypes().stream()\n+                .filter(m -> m.getTag() == TypeTags.INT_TAG || m.getTag() == TypeTags.BYTE_TAG ||\n+                        m.getTag() == TypeTags.FLOAT_TAG || m.getTag() == TypeTags.DECIMAL_TAG ||\n+                        m.getTag() == TypeTags.STRING_TAG || m.getTag() == TypeTags.BOOLEAN_TAG ||\n+                        m.getTag() == TypeTags.ARRAY_TAG).findFirst();\n+        if (mainType.isPresent()) {\n+            type = mainType.get();\n+        }\n+        return type;\n+    }\n+\n+    private static void mergesort(Object[][] input, Object[][] aux, int lo, int hi, boolean isAscending, BType type) {\n         if (hi <= lo) {\n             return;\n         }\n \n         int mid = lo + (hi - lo) / 2;\n \n-        mergesort(input, aux, lo, mid, strand, comparator);\n-        mergesort(input, aux, mid + 1, hi, strand, comparator);\n+        mergesort(input, aux, lo, mid, isAscending, type);\n+        mergesort(input, aux, mid + 1, hi, isAscending, type);\n \n-        merge(input, aux, lo, mid, hi, strand, comparator);\n+        merge(input, aux, lo, mid, hi, isAscending, type);\n     }\n \n-    private static void merge(ArrayValue input, ArrayValue aux, int lo, int mid, int hi, Strand strand,\n-                              FPValue<Object, Long> comparator) {\n-        int elemTypeTag = input.getElementType().getTag();\n-\n-        for (int i = lo; i <= hi; i++) {\n-            aux.add(i, input.get(i));\n+    private static void merge(Object[][] input, Object[][] aux, int lo, int mid, int hi, boolean isAscending,\n+                              BType type) {\n+        if (hi + 1 - lo >= 0) {\n+            System.arraycopy(input, lo, aux, lo, hi + 1 - lo);\n         }\n \n         for (int i = lo, j = mid + 1, k = lo; k <= hi; k++) {\n+            int index;\n             if (i > mid) {\n-                input.add(k, aux.get(j++));\n+                index = j++;\n             } else if (j > hi) {\n-                input.add(k, aux.get(i++));\n-            } else if (comparator.call(new Object[]{strand, aux.get(j), true, aux.get(i), true}) < 0) {\n-                input.add(k, aux.get(j++));\n+                index = i++;\n+            } else if (isAscending && sortFunc(aux[j][0], aux[i][0], type, true) < 0) {\n+                index = j++;\n+            } else if (!isAscending && sortFunc(aux[i][0], aux[j][0], type, false) < 0) {\n+                index = j++;\n             } else {\n-                input.add(k, aux.get(i++));\n+                index = i++;\n             }\n+            input[k] = aux[index];\n         }\n     }\n \n+    private static int sortFunc(Object value1, Object value2, BType type, boolean isAscending) {\n+        int c = -999;\n+        // () should come last irrespective of the sort direction.\n+        if (value1 == null) {\n+            if (value2 == null) {\n+                return 0;\n+            }\n+            if (isAscending) {\n+                return 1;\n+            }\n+            return -1;\n+        } else if (value2 == null) {\n+            if (isAscending) {\n+                return -1;\n+            }\n+            return 1;\n+        } else if (type.getTag() == TypeTags.INT_TAG) {\n+            c = Long.compare((long) value1, (long) value2);\n+        } else if (type.getTag() == TypeTags.FLOAT_TAG) {\n+            // NaN should be placed last or one before the last when () is present irrespective of the sort direction.\n+            if (Double.isNaN((double) value1)) {\n+                if (Double.isNaN((double) value2)) {\n+                    return 0;\n+                }\n+                if (isAscending) {\n+                    return 1;\n+                }\n+                return -1;\n+            } else if (Double.isNaN((double) value2)) {\n+                if (isAscending) {\n+                    return -1;\n+                }\n+                return 1;\n+            }\n+            c = Double.compare((double) value1, (double) value2);\n+        } else if (type.getTag() == TypeTags.DECIMAL_TAG) {\n+            c = new BigDecimal(value1.toString()).compareTo(new BigDecimal(value2.toString()));\n+        } else if (type.getTag() == TypeTags.BOOLEAN_TAG) {\n+            c = Boolean.compare((boolean) value1, (boolean) value2);\n+        } else if (type.getTag() == TypeTags.STRING_TAG) {\n+            c = value1.toString().compareToIgnoreCase(value2.toString());\n+        } else if (type.getTag() == TypeTags.BYTE_TAG) {\n+            c = Integer.compare((int) value1, (int) value2);\n+        } else if (type.getTag() == TypeTags.ARRAY_TAG) {\n+            for (int i = 0; i < ((ArrayValue) value1).size(); i++) {\n+                c = sortFunc(((ArrayValue) value1).get(i), ((ArrayValue) value2).get(i),\n+                        ((ArrayValue) value1).getElementType(), isAscending);\n+                if (c != 0) {\n+                    break;\n+                }\n+            }\n+        } else {\n+            throw BallerinaErrors.createError(\"invalid sort key type\", \"Failed to sort array\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f6242477c6a3f424e14896da82d393f2393efb0d"}, "originalPosition": 204}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzM5NTc3Mw==", "bodyText": "This also seems to miss the int and string subtypes. I also think isBasicType (I think isSimpleBasicType is more accurate here) should just check for the simple basic types in line with the spec, and we can maybe introduce a separate method that handles arrays and unions, eventually calling isBasicType.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#discussion_r483395773", "createdAt": "2020-09-04T05:31:49Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -3474,6 +3474,15 @@ public BType resolveExprType(BType type) {\n      * @return boolean whether the type is basic type or not.\n      */\n     public boolean isBasicType(BType type) {\n+        if (type.tag == TypeTags.ARRAY) {\n+            BType arrType = ((BArrayType) type).eType;\n+            return checkBasicType(arrType);\n+        } else {\n+            return checkBasicType(type);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIwMDUyMQ=="}, "originalCommit": {"oid": "f6242477c6a3f424e14896da82d393f2393efb0d"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzM5NzQ5OQ==", "bodyText": "I think we can refactor this method a bit by returning early on error and merging the if blocks.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (iExpr.argExprs.size() <= 2) {\n          \n          \n            \n                        if (!types.isBasicType(iExpr.expr.type)) {\n          \n          \n            \n                            dlog.error(iExpr.expr.pos, DiagnosticCode.INVALID_SORT_ARRAY_MEMBER_TYPE, iExpr.expr.type);\n          \n          \n            \n                        }\n          \n          \n            \n                    } else if (iExpr.argExprs.size() == 3) {\n          \n          \n            \n                        if (iExpr.argExprs.get(2).type != null) {\n          \n          \n            \n                            if (iExpr.argExprs.get(2).type.tag == TypeTags.SEMANTIC_ERROR) {\n          \n          \n            \n                                return;\n          \n          \n            \n                            } else if (iExpr.argExprs.get(2).type.tag == TypeTags.NIL && !types.isBasicType(iExpr.expr.type)) {\n          \n          \n            \n                                dlog.error(iExpr.expr.pos, DiagnosticCode.INVALID_SORT_ARRAY_MEMBER_TYPE, iExpr.expr.type);\n          \n          \n            \n                            }\n          \n          \n            \n                        } else {\n          \n          \n            \n                            BLangLambdaFunction func = (BLangLambdaFunction) iExpr.argExprs.get(2);\n          \n          \n            \n                            BType returnType = func.function.type.getReturnType();\n          \n          \n            \n                            if (!types.isBasicType(returnType)) {\n          \n          \n            \n                                dlog.error(iExpr.expr.pos, DiagnosticCode.INVALID_SORT_FUNC_RETURN_TYPE, returnType);\n          \n          \n            \n                            }\n          \n          \n            \n                        }\n          \n          \n            \n                    }\n          \n          \n            \n                }\n          \n          \n            \n                private void checkArrayLibSortFuncArgs(BLangInvocation iExpr) {\n          \n          \n            \n                    if (iExpr.argExprs.size() <= 2 && !types.isBasicType(iExpr.expr.type)) {\n          \n          \n            \n                        dlog.error(iExpr.expr.pos, DiagnosticCode.INVALID_SORT_ARRAY_MEMBER_TYPE, iExpr.expr.type);\n          \n          \n            \n                    } \n          \n          \n            \n                    \n          \n          \n            \n                    if (iExpr.argExprs.size() != 3) {\n          \n          \n            \n                        return;\n          \n          \n            \n                    }\n          \n          \n            \n            \n          \n          \n            \n                    BLangExpression argThree = iExpr.argExprs.get(2);\n          \n          \n            \n                    BType argThreeType = argThree.type;\n          \n          \n            \n                    if (argThreeType != null) {\n          \n          \n            \n                        if (argThreeType.tag == TypeTags.SEMANTIC_ERROR) {\n          \n          \n            \n                            return;\n          \n          \n            \n                        }\n          \n          \n            \n                        \n          \n          \n            \n                        if (argThreeType.tag == TypeTags.NIL && !types.isBasicType(iExpr.expr.type)) {\n          \n          \n            \n                            dlog.error(iExpr.expr.pos, DiagnosticCode.INVALID_SORT_ARRAY_MEMBER_TYPE, iExpr.expr.type);\n          \n          \n            \n                            return;\n          \n          \n            \n                        }\n          \n          \n            \n                    }\n          \n          \n            \n                    \n          \n          \n            \n                    BLangLambdaFunction func = (BLangLambdaFunction) argThree;\n          \n          \n            \n                    BType returnType = func.function.type.getReturnType();\n          \n          \n            \n                    if (!types.isBasicType(returnType)) {\n          \n          \n            \n                        dlog.error(iExpr.expr.pos, DiagnosticCode.INVALID_SORT_FUNC_RETURN_TYPE, returnType);\n          \n          \n            \n                    }\n          \n          \n            \n                }", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#discussion_r483397499", "createdAt": "2020-09-04T05:37:55Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -5390,6 +5395,28 @@ private BType checkInvocationArgs(BLangInvocation iExpr, List<BType> paramTypes,\n         }\n     }\n \n+    private void checkArrayLibSortFuncArgs(BLangInvocation iExpr) {\n+        if (iExpr.argExprs.size() <= 2) {\n+            if (!types.isBasicType(iExpr.expr.type)) {\n+                dlog.error(iExpr.expr.pos, DiagnosticCode.INVALID_SORT_ARRAY_MEMBER_TYPE, iExpr.expr.type);\n+            }\n+        } else if (iExpr.argExprs.size() == 3) {\n+            if (iExpr.argExprs.get(2).type != null) {\n+                if (iExpr.argExprs.get(2).type.tag == TypeTags.SEMANTIC_ERROR) {\n+                    return;\n+                } else if (iExpr.argExprs.get(2).type.tag == TypeTags.NIL && !types.isBasicType(iExpr.expr.type)) {\n+                    dlog.error(iExpr.expr.pos, DiagnosticCode.INVALID_SORT_ARRAY_MEMBER_TYPE, iExpr.expr.type);\n+                }\n+            } else {\n+                BLangLambdaFunction func = (BLangLambdaFunction) iExpr.argExprs.get(2);\n+                BType returnType = func.function.type.getReturnType();\n+                if (!types.isBasicType(returnType)) {\n+                    dlog.error(iExpr.expr.pos, DiagnosticCode.INVALID_SORT_FUNC_RETURN_TYPE, returnType);\n+                }\n+            }\n+        }\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f6242477c6a3f424e14896da82d393f2393efb0d"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzM5ODExOA==", "bodyText": "In org.wso2.ballerinalang.compiler.semantics.analyzer.TypeChecker#checkInLangLib we do some langlib specific validations. Wondering if we should move this also there.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#discussion_r483398118", "createdAt": "2020-09-04T05:40:15Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -5228,6 +5228,11 @@ private BType checkInvocationArgs(BLangInvocation iExpr, List<BType> paramTypes,\n             requiredParams.add(nonRestParam);\n         }\n \n+        // check argument types in arr:sort function\n+        if (iExpr.langLibInvocation && iExpr.name.value.equals(\"sort\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f6242477c6a3f424e14896da82d393f2393efb0d"}, "originalPosition": 5}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7903eae523a001f7295dc45221c011ac96703fb0", "author": {"user": {"login": "lasinicl", "name": "Lasini Liyange"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7903eae523a001f7295dc45221c011ac96703fb0", "committedDate": "2020-09-04T13:37:36Z", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into array-sort-func"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2443e4b262ebdace6d3ed06cb2b5efc3573f83b6", "author": {"user": {"login": "lasinicl", "name": "Lasini Liyange"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2443e4b262ebdace6d3ed06cb2b5efc3573f83b6", "committedDate": "2020-09-04T14:13:21Z", "message": "Fix review suggestions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "855f834aa20e94b6a93c662e8a9dec63b4cca104", "author": {"user": {"login": "lasinicl", "name": "Lasini Liyange"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/855f834aa20e94b6a93c662e8a9dec63b4cca104", "committedDate": "2020-09-08T05:33:19Z", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into array-sort-func"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8481a2bd849a79154b46e06d56d3557762ce64c5", "author": {"user": {"login": "lasinicl", "name": "Lasini Liyange"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/8481a2bd849a79154b46e06d56d3557762ce64c5", "committedDate": "2020-09-08T06:01:00Z", "message": "Improve array sort"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1cacfe176dd2f95f07d35b746f1f60dbb1f56e12", "author": {"user": {"login": "lasinicl", "name": "Lasini Liyange"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1cacfe176dd2f95f07d35b746f1f60dbb1f56e12", "committedDate": "2020-09-08T06:22:08Z", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into array-sort-func"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgzODU2ODQ2", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#pullrequestreview-483856846", "createdAt": "2020-09-08T07:18:04Z", "commit": {"oid": "8481a2bd849a79154b46e06d56d3557762ce64c5"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQwNzoxODowNFrOHOP2TQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQwNzoyMTozN1rOHOP9ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDcwMTc3Mw==", "bodyText": "Isn't this invalid key function return type?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#discussion_r484701773", "createdAt": "2020-09-08T07:18:04Z", "author": {"login": "mohanvive"}, "path": "compiler/ballerina-lang/src/main/java/org/ballerinalang/util/diagnostic/DiagnosticCode.java", "diffHunk": "@@ -302,6 +302,8 @@\n     INVALID_LIST_INDEX_EXPR(\"invalid.list.index.expr\"),\n     INVALID_ARRAY_INDEX_EXPR(\"invalid.array.index.expr\"),\n     SEALED_ARRAY_TYPE_CAN_NOT_INFER_SIZE(\"sealed.array.type.can.not.infer.size\"),\n+    INVALID_SORT_FUNC_RETURN_TYPE(\"invalid.sort.func.return.type\"),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8481a2bd849a79154b46e06d56d3557762ce64c5"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDcwMzE5Mw==", "bodyText": "Don't we need any error message for this case and it needs to be the first condition to verify in the method.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#discussion_r484703193", "createdAt": "2020-09-08T07:20:47Z", "author": {"login": "mohanvive"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -5384,6 +5389,37 @@ private BType checkInvocationArgs(BLangInvocation iExpr, List<BType> paramTypes,\n         }\n     }\n \n+    private void checkArrayLibSortFuncArgs(BLangInvocation iExpr) {\n+        if (iExpr.argExprs.size() <= 2 && !types.isOrderedType(iExpr.expr.type)) {\n+            dlog.error(iExpr.expr.pos, DiagnosticCode.INVALID_SORT_ARRAY_MEMBER_TYPE, iExpr.expr.type);\n+        }\n+\n+        if (iExpr.argExprs.size() != 3) {\n+            return;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8481a2bd849a79154b46e06d56d3557762ce64c5"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDcwMzY0Ng==", "bodyText": "Please use proper names for arguments. (argThreee does not provide any context)", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#discussion_r484703646", "createdAt": "2020-09-08T07:21:37Z", "author": {"login": "mohanvive"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -5384,6 +5389,37 @@ private BType checkInvocationArgs(BLangInvocation iExpr, List<BType> paramTypes,\n         }\n     }\n \n+    private void checkArrayLibSortFuncArgs(BLangInvocation iExpr) {\n+        if (iExpr.argExprs.size() <= 2 && !types.isOrderedType(iExpr.expr.type)) {\n+            dlog.error(iExpr.expr.pos, DiagnosticCode.INVALID_SORT_ARRAY_MEMBER_TYPE, iExpr.expr.type);\n+        }\n+\n+        if (iExpr.argExprs.size() != 3) {\n+            return;\n+        }\n+\n+        BLangExpression argThree = iExpr.argExprs.get(2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8481a2bd849a79154b46e06d56d3557762ce64c5"}, "originalPosition": 34}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgzODY4Nzk1", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#pullrequestreview-483868795", "createdAt": "2020-09-08T07:35:01Z", "commit": {"oid": "8481a2bd849a79154b46e06d56d3557762ce64c5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQwNzozNTowMVrOHOQbpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQwNzozNTowMVrOHOQbpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDcxMTMzNA==", "bodyText": "Shouldn't it simply be a recursive call to isOrderedType() on elementType? For example, what happens if the array has more than two dimensions?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#discussion_r484711334", "createdAt": "2020-09-08T07:35:01Z", "author": {"login": "pubudu91"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -3467,30 +3467,44 @@ public BType resolveExprType(BType type) {\n         }\n     }\n \n-    /**\n-     * Check whether a order-key expression type is a basic type.\n-     *\n-     * @param type type of the order-key expression.\n-     * @return boolean whether the type is basic type or not.\n-     */\n-    public boolean isBasicType(BType type) {\n-        switch (type.tag) {\n-            case TypeTags.INT:\n+    private boolean isSimpleBasicType(int tag) {\n+        switch (tag) {\n             case TypeTags.BYTE:\n             case TypeTags.FLOAT:\n             case TypeTags.DECIMAL:\n-            case TypeTags.STRING:\n             case TypeTags.BOOLEAN:\n             case TypeTags.NIL:\n                 return true;\n+            default:\n+                return (TypeTags.isIntegerTypeTag(tag)) || (TypeTags.isStringTypeTag(tag));\n+        }\n+    }\n+\n+    /**\n+     * Check whether a type is an ordered type.\n+     *\n+     * @param type type.\n+     * @return boolean whether the type is an ordered type or not.\n+     */\n+    public boolean isOrderedType(BType type) {\n+        switch (type.tag) {\n             case TypeTags.UNION:\n-                if (((BUnionType) type).getMemberTypes().contains(symTable.nilType)) {\n-                    return true;\n-                } else {\n-                    return false;\n+                Set<BType> memberTypes = ((BUnionType) type).getMemberTypes();\n+                // can not sort (string?|int)/(string|int), can sort string?\n+                return memberTypes.size() <= 2 && memberTypes.contains(symTable.nilType);\n+            case TypeTags.ARRAY:\n+                BType elementType = ((BArrayType) type).eType;\n+                if (elementType.tag == TypeTags.ARRAY) {\n+                    elementType = ((BArrayType) elementType).eType;\n                 }\n+                if (elementType.tag == TypeTags.UNION) {\n+                    Set<BType> memTypes = ((BUnionType) elementType).getMemberTypes();\n+                    // can not sort (string?|int)[]/(string|int)[], can sort string?[]\n+                    return memTypes.size() <= 2 && memTypes.contains(symTable.nilType);\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8481a2bd849a79154b46e06d56d3557762ce64c5"}, "originalPosition": 52}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgzODY5NzIw", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#pullrequestreview-483869720", "createdAt": "2020-09-08T07:36:21Z", "commit": {"oid": "8481a2bd849a79154b46e06d56d3557762ce64c5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQwNzozNjoyMVrOHOQenA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQwNzozNjoyMVrOHOQenA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDcxMjA5Mg==", "bodyText": "What happens here if the union has a non-ordered type as a member type?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#discussion_r484712092", "createdAt": "2020-09-08T07:36:21Z", "author": {"login": "pubudu91"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -3467,30 +3467,44 @@ public BType resolveExprType(BType type) {\n         }\n     }\n \n-    /**\n-     * Check whether a order-key expression type is a basic type.\n-     *\n-     * @param type type of the order-key expression.\n-     * @return boolean whether the type is basic type or not.\n-     */\n-    public boolean isBasicType(BType type) {\n-        switch (type.tag) {\n-            case TypeTags.INT:\n+    private boolean isSimpleBasicType(int tag) {\n+        switch (tag) {\n             case TypeTags.BYTE:\n             case TypeTags.FLOAT:\n             case TypeTags.DECIMAL:\n-            case TypeTags.STRING:\n             case TypeTags.BOOLEAN:\n             case TypeTags.NIL:\n                 return true;\n+            default:\n+                return (TypeTags.isIntegerTypeTag(tag)) || (TypeTags.isStringTypeTag(tag));\n+        }\n+    }\n+\n+    /**\n+     * Check whether a type is an ordered type.\n+     *\n+     * @param type type.\n+     * @return boolean whether the type is an ordered type or not.\n+     */\n+    public boolean isOrderedType(BType type) {\n+        switch (type.tag) {\n             case TypeTags.UNION:\n-                if (((BUnionType) type).getMemberTypes().contains(symTable.nilType)) {\n-                    return true;\n-                } else {\n-                    return false;\n+                Set<BType> memberTypes = ((BUnionType) type).getMemberTypes();\n+                // can not sort (string?|int)/(string|int), can sort string?\n+                return memberTypes.size() <= 2 && memberTypes.contains(symTable.nilType);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8481a2bd849a79154b46e06d56d3557762ce64c5"}, "originalPosition": 42}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgzODgwNzcy", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#pullrequestreview-483880772", "createdAt": "2020-09-08T07:51:56Z", "commit": {"oid": "8481a2bd849a79154b46e06d56d3557762ce64c5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQwNzo1MTo1NlrOHORAxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQwNzo1MTo1NlrOHORAxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDcyMDgzOA==", "bodyText": "At this point, don't need the iExpr.langLibInvocation check here since at this point, we know for sure (Line# 2753) that this is a lang lib call.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#discussion_r484720838", "createdAt": "2020-09-08T07:51:56Z", "author": {"login": "pubudu91"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -2761,6 +2761,11 @@ private void checkInLangLib(BLangInvocation iExpr, BType varRefType) {\n         }\n \n         checkIllegalStorageSizeChangeMethodCall(iExpr, varRefType);\n+\n+        // check argument types in arr:sort function\n+        if (iExpr.langLibInvocation && iExpr.name.value.equals(\"sort\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8481a2bd849a79154b46e06d56d3557762ce64c5"}, "originalPosition": 6}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "05beec628f686a94eeca165b415de0885514352f", "author": {"user": {"login": "lasinicl", "name": "Lasini Liyange"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/05beec628f686a94eeca165b415de0885514352f", "committedDate": "2020-09-08T09:01:53Z", "message": "Fix sort in http"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fe3596855969923da43d26c3662d17899c966f3c", "author": {"user": {"login": "lasinicl", "name": "Lasini Liyange"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/fe3596855969923da43d26c3662d17899c966f3c", "committedDate": "2020-09-08T09:02:37Z", "message": "Fix review suggestions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b0960a00392c7e1c41c054b832038dbf900e0d3a", "author": {"user": {"login": "lasinicl", "name": "Lasini Liyange"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b0960a00392c7e1c41c054b832038dbf900e0d3a", "committedDate": "2020-09-08T10:21:15Z", "message": "Fix review suggestions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "210648a091d744aa53e4c729fce5d79f0d5801d0", "author": {"user": {"login": "lasinicl", "name": "Lasini Liyange"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/210648a091d744aa53e4c729fce5d79f0d5801d0", "committedDate": "2020-09-08T10:33:43Z", "message": "Fix failing tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6b7913235ed9de8d2679e6837fb55979520daeac", "author": {"user": {"login": "lasinicl", "name": "Lasini Liyange"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6b7913235ed9de8d2679e6837fb55979520daeac", "committedDate": "2020-09-08T11:24:05Z", "message": "Fix tests with sort"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0MDg2ODgz", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#pullrequestreview-484086883", "createdAt": "2020-09-08T12:35:09Z", "commit": {"oid": "6b7913235ed9de8d2679e6837fb55979520daeac"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0MjEwMTQ3", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#pullrequestreview-484210147", "createdAt": "2020-09-08T14:40:34Z", "commit": {"oid": "6b7913235ed9de8d2679e6837fb55979520daeac"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNDo0MDozNFrOHOgeGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNDo0MDozNFrOHOgeGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk3NDEwNA==", "bodyText": "Put the constant value on the left side of equals to avoid possible NPEs", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#discussion_r484974104", "createdAt": "2020-09-08T14:40:34Z", "author": {"login": "grainier"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -2761,6 +2761,11 @@ private void checkInLangLib(BLangInvocation iExpr, BType varRefType) {\n         }\n \n         checkIllegalStorageSizeChangeMethodCall(iExpr, varRefType);\n+\n+        // check argument types in arr:sort function\n+        if (iExpr.name.value.equals(\"sort\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b7913235ed9de8d2679e6837fb55979520daeac"}, "originalPosition": 6}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0MjE1ODM2", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#pullrequestreview-484215836", "createdAt": "2020-09-08T14:46:13Z", "commit": {"oid": "6b7913235ed9de8d2679e6837fb55979520daeac"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNDo0NjoxM1rOHOguzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNDo0NjoxM1rOHOguzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk3ODM4MQ==", "bodyText": "What is this -999? And Why it's -999?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#discussion_r484978381", "createdAt": "2020-09-08T14:46:13Z", "author": {"login": "grainier"}, "path": "langlib/lang.array/src/main/java/org/ballerinalang/langlib/array/Sort.java", "diffHunk": "@@ -18,73 +18,230 @@\n \n package org.ballerinalang.langlib.array;\n \n+import org.ballerinalang.jvm.BallerinaErrors;\n import org.ballerinalang.jvm.scheduling.Strand;\n import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BFunctionType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BUnionType;\n+import org.ballerinalang.jvm.types.TypeTags;\n import org.ballerinalang.jvm.values.ArrayValue;\n-import org.ballerinalang.jvm.values.ArrayValueImpl;\n import org.ballerinalang.jvm.values.FPValue;\n import org.ballerinalang.model.types.TypeKind;\n import org.ballerinalang.natives.annotations.Argument;\n import org.ballerinalang.natives.annotations.BallerinaFunction;\n import org.ballerinalang.natives.annotations.ReturnType;\n \n+import java.math.BigDecimal;\n+import java.util.List;\n+import java.util.PrimitiveIterator;\n+\n import static org.ballerinalang.jvm.values.utils.ArrayUtils.checkIsArrayOnlyOperation;\n import static org.ballerinalang.util.BLangCompilerConstants.ARRAY_VERSION;\n \n /**\n- * Native implementation of lang.array:sort((any|error)[], function).\n+ * Native implementation of lang.array:sort((any|error)[], direction, function).\n  *\n  * @since 1.0\n  */\n @BallerinaFunction(\n         orgName = \"ballerina\", packageName = \"lang.array\", version = ARRAY_VERSION, functionName = \"sort\",\n-        args = {@Argument(name = \"arr\", type = TypeKind.ARRAY), @Argument(name = \"func\", type = TypeKind.FUNCTION)},\n+        args = {@Argument(name = \"arr\", type = TypeKind.ARRAY), @Argument(name = \"direction\", type = TypeKind.OBJECT),\n+                @Argument(name = \"func\", type = TypeKind.OBJECT)},\n         returnType = {@ReturnType(type = TypeKind.ARRAY)},\n         isPublic = true\n )\n public class Sort {\n \n-    public static ArrayValue sort(Strand strand, ArrayValue arr, FPValue<Object, Long> func) {\n+    public static ArrayValue sort(Strand strand, ArrayValue arr, Object direction, Object func) {\n         checkIsArrayOnlyOperation(arr.getType(), \"sort()\");\n-        ArrayValue aux = new ArrayValueImpl((BArrayType) arr.getType());\n-        mergesort(arr, aux, 0, arr.size() - 1, strand, func);\n+        FPValue<Object, Object> function = (FPValue<Object, Object>) func;\n+        BType elemType = ((BArrayType) arr.getType()).getElementType();\n+        boolean isAscending = true;\n+        if (direction.toString().equals(\"descending\")) {\n+            isAscending = false;\n+        }\n+\n+        Object[][] sortArr = new Object[arr.size()][2];\n+        Object[][] sortArrClone = new Object[arr.size()][2];\n+        if (function != null) {\n+            elemType = ((BFunctionType) function.getType()).retType;\n+            for (int i = 0; i < arr.size(); i++) {\n+                sortArr[i][0] = function.call(new Object[]{strand, arr.get(i), true});\n+                sortArr[i][1] = arr.get(i);\n+            }\n+        } else {\n+            for (int i = 0; i < arr.size(); i++) {\n+                sortArr[i][0] = sortArr[i][1] = arr.get(i);\n+            }\n+        }\n+\n+        if (elemType.getTag() == TypeTags.UNION_TAG) {\n+            elemType = getMemberType((BUnionType) elemType);\n+        }\n+        if (elemType.getTag() == TypeTags.ARRAY_TAG) {\n+            BType type = ((BArrayType) elemType).getElementType();\n+            if (type.getTag() == TypeTags.UNION_TAG) {\n+                BType memberType = getMemberType((BUnionType) type);\n+                elemType = new BArrayType(memberType);\n+            }\n+        }\n+\n+        mergesort(sortArr, sortArrClone, 0, sortArr.length - 1, isAscending, elemType);\n+\n+        for (int k = 0; k < sortArr.length; k++) {\n+            arr.add(k, sortArr[k][1]);\n+        }\n+\n         return arr;\n     }\n \n+    private static BType getMemberType(BUnionType unionType) {\n+        List<BType> memberTypes = unionType.getMemberTypes();\n+        for (BType type : memberTypes) {\n+            if (type.getTag() != TypeTags.NULL_TAG) {\n+                return type;\n+            }\n+        }\n+        return unionType;\n+    }\n+\n     // Adapted from https://algs4.cs.princeton.edu/22mergesort/Merge.java.html\n-    private static void mergesort(ArrayValue input, ArrayValue aux, int lo, int hi, Strand strand,\n-                                  FPValue<Object, Long> comparator) {\n+    private static void mergesort(Object[][] input, Object[][] aux, int lo, int hi, boolean isAscending, BType type) {\n         if (hi <= lo) {\n             return;\n         }\n \n         int mid = lo + (hi - lo) / 2;\n \n-        mergesort(input, aux, lo, mid, strand, comparator);\n-        mergesort(input, aux, mid + 1, hi, strand, comparator);\n+        mergesort(input, aux, lo, mid, isAscending, type);\n+        mergesort(input, aux, mid + 1, hi, isAscending, type);\n \n-        merge(input, aux, lo, mid, hi, strand, comparator);\n+        merge(input, aux, lo, mid, hi, isAscending, type);\n     }\n \n-    private static void merge(ArrayValue input, ArrayValue aux, int lo, int mid, int hi, Strand strand,\n-                              FPValue<Object, Long> comparator) {\n-        int elemTypeTag = input.getElementType().getTag();\n-\n-        for (int i = lo; i <= hi; i++) {\n-            aux.add(i, input.get(i));\n+    private static void merge(Object[][] input, Object[][] aux, int lo, int mid, int hi, boolean isAscending,\n+                              BType type) {\n+        if (hi + 1 - lo >= 0) {\n+            System.arraycopy(input, lo, aux, lo, hi + 1 - lo);\n         }\n \n         for (int i = lo, j = mid + 1, k = lo; k <= hi; k++) {\n+            int index;\n             if (i > mid) {\n-                input.add(k, aux.get(j++));\n+                index = j++;\n             } else if (j > hi) {\n-                input.add(k, aux.get(i++));\n-            } else if (comparator.call(new Object[]{strand, aux.get(j), true, aux.get(i), true}) < 0) {\n-                input.add(k, aux.get(j++));\n+                index = i++;\n+            } else if (isAscending && sortFunc(aux[j][0], aux[i][0], type, true) < 0) {\n+                index = j++;\n+            } else if (!isAscending && sortFunc(aux[i][0], aux[j][0], type, false) < 0) {\n+                index = j++;\n             } else {\n-                input.add(k, aux.get(i++));\n+                index = i++;\n             }\n+            input[k] = aux[index];\n         }\n     }\n \n+    private static int sortFunc(Object value1, Object value2, BType type, boolean isAscending) {\n+        int c = -999;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b7913235ed9de8d2679e6837fb55979520daeac"}, "originalPosition": 152}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0MjIyMTcw", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#pullrequestreview-484222170", "createdAt": "2020-09-08T14:52:41Z", "commit": {"oid": "6b7913235ed9de8d2679e6837fb55979520daeac"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "62d470fa9d5069bfa89d83bc91d049141beb1712", "author": {"user": {"login": "lasinicl", "name": "Lasini Liyange"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/62d470fa9d5069bfa89d83bc91d049141beb1712", "committedDate": "2020-09-08T15:35:09Z", "message": "Fix review suggestions"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0NDE3NDg5", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#pullrequestreview-484417489", "createdAt": "2020-09-08T19:05:44Z", "commit": {"oid": "62d470fa9d5069bfa89d83bc91d049141beb1712"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxOTowNTo0NVrOHOqVtw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxOTowNTo0NVrOHOqVtw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEzNTc5OQ==", "bodyText": "Just wondering whether it'd be better to avoid saying \"array\", considering that this applies to tuples as well? @MaryamZi\nAlso, the first  \"type\" in the message after the colon seems redundant.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#discussion_r485135799", "createdAt": "2020-09-08T19:05:45Z", "author": {"login": "pubudu91"}, "path": "compiler/ballerina-lang/src/main/resources/compiler.properties", "diffHunk": "@@ -1050,6 +1050,12 @@ error.array.index.out.of.range=\\\n error.sealed.array.type.can.not.infer.size=\\\n   invalid usage of sealed type: can not infer array size\n \n+error.invalid.key.func.return.type=\\\n+  invalid array sort key function return type: type ''{0}'' is not an ordered type\n+\n+error.invalid.sort.array.member.type=\\\n+  invalid member type of the array to sort: type ''{0}'' is not an ordered type", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62d470fa9d5069bfa89d83bc91d049141beb1712"}, "originalPosition": 8}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0NDQ2NTM1", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#pullrequestreview-484446535", "createdAt": "2020-09-08T19:51:38Z", "commit": {"oid": "62d470fa9d5069bfa89d83bc91d049141beb1712"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxOTo1MTozOFrOHOrxfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxOTo1MTozOFrOHOrxfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE1OTI5NA==", "bodyText": "This error message needs to conform to the same format we follow for other lang lib errors. You can check the other places in the lang lib where panics are created for reference. Also, IIRC, we don't start the detail with a capital letter. @MaryamZi", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#discussion_r485159294", "createdAt": "2020-09-08T19:51:38Z", "author": {"login": "pubudu91"}, "path": "langlib/lang.array/src/main/java/org/ballerinalang/langlib/array/Sort.java", "diffHunk": "@@ -18,73 +18,229 @@\n \n package org.ballerinalang.langlib.array;\n \n+import org.ballerinalang.jvm.BallerinaErrors;\n import org.ballerinalang.jvm.scheduling.Strand;\n import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BFunctionType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BUnionType;\n+import org.ballerinalang.jvm.types.TypeTags;\n import org.ballerinalang.jvm.values.ArrayValue;\n-import org.ballerinalang.jvm.values.ArrayValueImpl;\n import org.ballerinalang.jvm.values.FPValue;\n import org.ballerinalang.model.types.TypeKind;\n import org.ballerinalang.natives.annotations.Argument;\n import org.ballerinalang.natives.annotations.BallerinaFunction;\n import org.ballerinalang.natives.annotations.ReturnType;\n \n+import java.math.BigDecimal;\n+import java.util.List;\n+import java.util.PrimitiveIterator;\n+\n import static org.ballerinalang.jvm.values.utils.ArrayUtils.checkIsArrayOnlyOperation;\n import static org.ballerinalang.util.BLangCompilerConstants.ARRAY_VERSION;\n \n /**\n- * Native implementation of lang.array:sort((any|error)[], function).\n+ * Native implementation of lang.array:sort((any|error)[], direction, function).\n  *\n  * @since 1.0\n  */\n @BallerinaFunction(\n         orgName = \"ballerina\", packageName = \"lang.array\", version = ARRAY_VERSION, functionName = \"sort\",\n-        args = {@Argument(name = \"arr\", type = TypeKind.ARRAY), @Argument(name = \"func\", type = TypeKind.FUNCTION)},\n+        args = {@Argument(name = \"arr\", type = TypeKind.ARRAY), @Argument(name = \"direction\", type = TypeKind.OBJECT),\n+                @Argument(name = \"func\", type = TypeKind.OBJECT)},\n         returnType = {@ReturnType(type = TypeKind.ARRAY)},\n         isPublic = true\n )\n public class Sort {\n \n-    public static ArrayValue sort(Strand strand, ArrayValue arr, FPValue<Object, Long> func) {\n+    public static ArrayValue sort(Strand strand, ArrayValue arr, Object direction, Object func) {\n         checkIsArrayOnlyOperation(arr.getType(), \"sort()\");\n-        ArrayValue aux = new ArrayValueImpl((BArrayType) arr.getType());\n-        mergesort(arr, aux, 0, arr.size() - 1, strand, func);\n+        FPValue<Object, Object> function = (FPValue<Object, Object>) func;\n+        BType elemType = ((BArrayType) arr.getType()).getElementType();\n+        boolean isAscending = true;\n+        if (direction.toString().equals(\"descending\")) {\n+            isAscending = false;\n+        }\n+\n+        Object[][] sortArr = new Object[arr.size()][2];\n+        Object[][] sortArrClone = new Object[arr.size()][2];\n+        if (function != null) {\n+            elemType = ((BFunctionType) function.getType()).retType;\n+            for (int i = 0; i < arr.size(); i++) {\n+                sortArr[i][0] = function.call(new Object[]{strand, arr.get(i), true});\n+                sortArr[i][1] = arr.get(i);\n+            }\n+        } else {\n+            for (int i = 0; i < arr.size(); i++) {\n+                sortArr[i][0] = sortArr[i][1] = arr.get(i);\n+            }\n+        }\n+\n+        if (elemType.getTag() == TypeTags.UNION_TAG) {\n+            elemType = getMemberType((BUnionType) elemType);\n+        }\n+        if (elemType.getTag() == TypeTags.ARRAY_TAG) {\n+            BType type = ((BArrayType) elemType).getElementType();\n+            if (type.getTag() == TypeTags.UNION_TAG) {\n+                BType memberType = getMemberType((BUnionType) type);\n+                elemType = new BArrayType(memberType);\n+            }\n+        }\n+\n+        mergesort(sortArr, sortArrClone, 0, sortArr.length - 1, isAscending, elemType);\n+\n+        for (int k = 0; k < sortArr.length; k++) {\n+            arr.add(k, sortArr[k][1]);\n+        }\n+\n         return arr;\n     }\n \n+    private static BType getMemberType(BUnionType unionType) {\n+        List<BType> memberTypes = unionType.getMemberTypes();\n+        for (BType type : memberTypes) {\n+            if (type.getTag() != TypeTags.NULL_TAG) {\n+                return type;\n+            }\n+        }\n+        return unionType;\n+    }\n+\n     // Adapted from https://algs4.cs.princeton.edu/22mergesort/Merge.java.html\n-    private static void mergesort(ArrayValue input, ArrayValue aux, int lo, int hi, Strand strand,\n-                                  FPValue<Object, Long> comparator) {\n+    private static void mergesort(Object[][] input, Object[][] aux, int lo, int hi, boolean isAscending, BType type) {\n         if (hi <= lo) {\n             return;\n         }\n \n         int mid = lo + (hi - lo) / 2;\n \n-        mergesort(input, aux, lo, mid, strand, comparator);\n-        mergesort(input, aux, mid + 1, hi, strand, comparator);\n+        mergesort(input, aux, lo, mid, isAscending, type);\n+        mergesort(input, aux, mid + 1, hi, isAscending, type);\n \n-        merge(input, aux, lo, mid, hi, strand, comparator);\n+        merge(input, aux, lo, mid, hi, isAscending, type);\n     }\n \n-    private static void merge(ArrayValue input, ArrayValue aux, int lo, int mid, int hi, Strand strand,\n-                              FPValue<Object, Long> comparator) {\n-        int elemTypeTag = input.getElementType().getTag();\n-\n-        for (int i = lo; i <= hi; i++) {\n-            aux.add(i, input.get(i));\n+    private static void merge(Object[][] input, Object[][] aux, int lo, int mid, int hi, boolean isAscending,\n+                              BType type) {\n+        if (hi + 1 - lo >= 0) {\n+            System.arraycopy(input, lo, aux, lo, hi + 1 - lo);\n         }\n \n         for (int i = lo, j = mid + 1, k = lo; k <= hi; k++) {\n+            int index;\n             if (i > mid) {\n-                input.add(k, aux.get(j++));\n+                index = j++;\n             } else if (j > hi) {\n-                input.add(k, aux.get(i++));\n-            } else if (comparator.call(new Object[]{strand, aux.get(j), true, aux.get(i), true}) < 0) {\n-                input.add(k, aux.get(j++));\n+                index = i++;\n+            } else if (isAscending && sortFunc(aux[j][0], aux[i][0], type, true) < 0) {\n+                index = j++;\n+            } else if (!isAscending && sortFunc(aux[i][0], aux[j][0], type, false) < 0) {\n+                index = j++;\n             } else {\n-                input.add(k, aux.get(i++));\n+                index = i++;\n             }\n+            input[k] = aux[index];\n         }\n     }\n \n+    private static int sortFunc(Object value1, Object value2, BType type, boolean isAscending) {\n+        // () should come last irrespective of the sort direction.\n+        if (value1 == null) {\n+            if (value2 == null) {\n+                return 0;\n+            }\n+            if (isAscending) {\n+                return 1;\n+            }\n+            return -1;\n+        }\n+        if (value2 == null) {\n+            if (isAscending) {\n+                return -1;\n+            }\n+            return 1;\n+        }\n+        if (TypeTags.isIntegerTypeTag(type.getTag())) {\n+            return Long.compare((long) value1, (long) value2);\n+        } else if (type.getTag() == TypeTags.FLOAT_TAG) {\n+            // NaN should be placed last or one before the last when () is present irrespective of the sort direction.\n+            if (Double.isNaN((double) value1)) {\n+                if (Double.isNaN((double) value2)) {\n+                    return 0;\n+                }\n+                if (isAscending) {\n+                    return 1;\n+                }\n+                return -1;\n+            }\n+            if (Double.isNaN((double) value2)) {\n+                if (isAscending) {\n+                    return -1;\n+                }\n+                return 1;\n+            }\n+            // -0.0 = +0.0\n+            if ((double) value1 == 0 && (double) value2 == 0) {\n+                return 0;\n+            }\n+            return Double.compare((double) value1, (double) value2);\n+        } else if (type.getTag() == TypeTags.DECIMAL_TAG) {\n+            return new BigDecimal(value1.toString()).compareTo(new BigDecimal(value2.toString()));\n+        } else if (type.getTag() == TypeTags.BOOLEAN_TAG) {\n+            return Boolean.compare((boolean) value1, (boolean) value2);\n+        } else if (TypeTags.isStringTypeTag(type.getTag())) {\n+            return codePointCompare(value1.toString(), value2.toString());\n+        } else if (type.getTag() == TypeTags.BYTE_TAG) {\n+            return Integer.compare((int) value1, (int) value2);\n+        } else if (type.getTag() == TypeTags.ARRAY_TAG) {\n+            int lengthVal1 = ((ArrayValue) value1).size();\n+            int lengthVal2 = ((ArrayValue) value2).size();\n+            if (lengthVal1 == 0) {\n+                if (lengthVal2 == 0) {\n+                    return 0;\n+                }\n+                return -1;\n+            }\n+            if (lengthVal2 == 0) {\n+                return 1;\n+            }\n+            int len = Math.min(lengthVal1, lengthVal2);\n+            int c = 0;\n+            for (int i = 0; i < len; i++) {\n+                c = sortFunc(((ArrayValue) value1).get(i), ((ArrayValue) value2).get(i),\n+                        ((BArrayType) type).getElementType(), isAscending);\n+                if (c != 0) {\n+                    break;\n+                } else {\n+                    if (i == len - 1 && lengthVal1 < lengthVal2) {\n+                        return -1;\n+                    }\n+                }\n+            }\n+            return c;\n+        }\n+        throw BallerinaErrors.createError(\"Invalid type to sort\", \"Expected an ordered type, but found type: \"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62d470fa9d5069bfa89d83bc91d049141beb1712"}, "originalPosition": 227}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0NDU2MDc2", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#pullrequestreview-484456076", "createdAt": "2020-09-08T20:06:35Z", "commit": {"oid": "62d470fa9d5069bfa89d83bc91d049141beb1712"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMDowNjozNVrOHOsPBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMDowNjozNVrOHOsPBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE2Njg1NQ==", "bodyText": "This changes the original ordering behaviour implemented by the provided comparator. I think we'll have to sort it twice to achieve the same effect: first, sort using the length as above and second, sort using the created time. @chamil321 thoughts?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#discussion_r485166855", "createdAt": "2020-09-08T20:06:35Z", "author": {"login": "pubudu91"}, "path": "stdlib/http/src/main/ballerina/src/http/http_request.bal", "diffHunk": "@@ -534,7 +535,14 @@ public type Request object {\n     # + cookiesToAdd - Represents the cookies to be added\n     public function addCookies(Cookie[] cookiesToAdd) {\n         string cookieheader = \"\";\n-        Cookie[] sortedCookies = cookiesToAdd.sort(comparator);\n+        Cookie[] sortedCookies = cookiesToAdd.sort(array:ASCENDING, function(Cookie c) returns int {\n+            var cookiePath = c.path;\n+            int l = 0;\n+            if (cookiePath is string) {\n+                l = cookiePath.length();\n+            }\n+            return l;\n+        });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62d470fa9d5069bfa89d83bc91d049141beb1712"}, "originalPosition": 20}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0NDU2MzY1", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#pullrequestreview-484456365", "createdAt": "2020-09-08T20:07:01Z", "commit": {"oid": "62d470fa9d5069bfa89d83bc91d049141beb1712"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMDowNzowMVrOHOsP4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMDowNzowMVrOHOsP4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE2NzA3Mg==", "bodyText": "Same comment as above", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#discussion_r485167072", "createdAt": "2020-09-08T20:07:01Z", "author": {"login": "pubudu91"}, "path": "stdlib/http/src/main/ballerina/src/http/websocket/websocket_client.bal", "diffHunk": "@@ -237,7 +238,14 @@ public function addCookies(WebSocketClientConfiguration|WebSocketFailoverClientC\n     string cookieHeader = \"\";\n     var cookiesToAdd = config[\"cookies\"];\n     if (cookiesToAdd is Cookie[]) {\n-        Cookie[] sortedCookies = cookiesToAdd.sort(comparator);\n+        Cookie[] sortedCookies = cookiesToAdd.sort(array:ASCENDING, function(Cookie c) returns int {\n+            var cookiePath = c.path;\n+            int l = 0;\n+            if (cookiePath is string) {\n+                l = cookiePath.length();\n+            }\n+            return l;\n+        });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62d470fa9d5069bfa89d83bc91d049141beb1712"}, "originalPosition": 20}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0NDYwODQ4", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#pullrequestreview-484460848", "createdAt": "2020-09-08T20:14:05Z", "commit": {"oid": "62d470fa9d5069bfa89d83bc91d049141beb1712"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMDoxNDowNVrOHOsdeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMDoxNDowNVrOHOsdeg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3MDU1NA==", "bodyText": "Shall we add a couple of tests for the array:sort() style of usage as well? Both positive and negative.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#discussion_r485170554", "createdAt": "2020-09-08T20:14:05Z", "author": {"login": "pubudu91"}, "path": "langlib/langlib-test/src/test/java/org/ballerinalang/langlib/test/LangLibArrayTest.java", "diffHunk": "@@ -419,66 +382,153 @@ public void callingLengthModificationFunctionsOnFixedLengthLists() {\n         int errorIndex = 0;\n         BAssertUtil.validateError(negativeResult, errorIndex++, \"cannot call 'push' on fixed length list(s) of type \" +\n                                           \"'int[1]'\",\n-                                  19, 22);\n+                                  20, 22);\n         BAssertUtil.validateError(negativeResult, errorIndex++, \"cannot call 'push' on fixed length list(s) of type \" +\n                                           \"'[int,int]'\",\n-                                  24, 22);\n+                                  25, 22);\n         BAssertUtil.validateError(negativeResult, errorIndex++, \"cannot call 'pop' on fixed length list(s) of type \" +\n                                           \"'int[1]'\",\n-                                  29, 35);\n+                                  30, 35);\n         BAssertUtil.validateError(negativeResult, errorIndex++, \"cannot call 'pop' on fixed length list(s) of type \" +\n                                           \"'[int,int]'\",\n-                                  34, 35);\n+                                  35, 35);\n         BAssertUtil.validateError(negativeResult, errorIndex++, \"cannot call 'shift' on fixed length list(s) of type \" +\n                                           \"'int[1]'\",\n-                                  45, 30);\n+                                  46, 30);\n         BAssertUtil.validateError(negativeResult, errorIndex++, \"cannot call 'unshift' on fixed length list(s) of \" +\n                                           \"type 'int[1]'\",\n-                                  50, 22);\n+                                  51, 22);\n         BAssertUtil.validateError(negativeResult, errorIndex++, \"cannot call 'shift' on fixed length list(s) of type \" +\n                                           \"'[int,int]'\",\n-                                  55, 35);\n+                                  56, 35);\n         BAssertUtil.validateError(negativeResult, errorIndex++,\n                                   \"cannot call 'unshift' on fixed length list(s) of type '[int,int]'\",\n-                                  60, 22);\n+                                  61, 22);\n         BAssertUtil.validateError(negativeResult, errorIndex++, \"cannot call 'push' on fixed length list(s) of type \" +\n                                           \"'int[2]'\",\n-                                  66, 22);\n+                                  67, 22);\n         BAssertUtil.validateError(negativeResult, errorIndex++, \"cannot call 'pop' on fixed length list(s) of type \" +\n                                           \"'int[2]'\",\n-                                  67, 30);\n+                                  68, 30);\n         BAssertUtil.validateError(negativeResult, errorIndex++, \"cannot call 'shift' on fixed length list(s) of type \" +\n                                           \"'int[2]'\",\n-                                  68, 26);\n+                                  69, 26);\n         BAssertUtil.validateError(negativeResult, errorIndex++, \"cannot call 'unshift' on fixed length list(s) of \" +\n                                           \"type 'int[2]'\",\n-                                  69, 22);\n+                                  70, 22);\n         BAssertUtil.validateError(negativeResult, errorIndex++,\n                                   \"cannot call 'push' on fixed length list(s) of type '(int[1]|float[1])'\",\n-                                  74, 22);\n+                                  75, 22);\n         BAssertUtil.validateError(negativeResult, errorIndex++,\n                                   \"cannot call 'push' on fixed length list(s) of type '([int,int][1]|[float,\" +\n                                           \"float][1])'\",\n-                                  79, 22);\n+                                  80, 22);\n         BAssertUtil.validateError(negativeResult, errorIndex++,\n                                   \"cannot call 'shift' on tuple(s) of type '[int,string...]': cannot violate inherent\" +\n                                           \" type\",\n-                                  84, 24);\n+                                  85, 24);\n         BAssertUtil.validateError(negativeResult, errorIndex++,\n                                   \"cannot call 'shift' on tuple(s) of type '[int,string,int...]': cannot violate \" +\n                                           \"inherent type\",\n-                                  89, 24);\n+                                  90, 24);\n         BAssertUtil.validateError(negativeResult, errorIndex++,\n                                   \"cannot call 'push' on fixed length list(s) of type '([int,int]|[float,float])'\",\n-                                  100, 22);\n+                                  101, 22);\n         BAssertUtil.validateError(negativeResult, errorIndex++,\n                                   \"cannot call 'shift' on fixed length list(s) of type '[string,int]'\",\n-                                  118, 24);\n+                                  119, 24);\n+        BAssertUtil.validateError(negativeResult, errorIndex++,\n+                \"incompatible types: expected '(descending|ascending)', found 'function (int) returns (int)'\",\n+                126, 32);\n+        BAssertUtil.validateError(negativeResult, errorIndex++,\n+                \"incompatible types: expected '(descending|ascending)', found 'function (int) returns (int)'\",\n+                130, 33);\n+        BAssertUtil.validateError(negativeResult, errorIndex++,\n+                \"incompatible types: expected 'function ((any|error)) returns \" +\n+                        \"((boolean|int|float|decimal|string|(boolean|int|float|decimal|string)?[])?)?', \" +\n+                        \"found 'string'\", 132, 8);\n+        BAssertUtil.validateError(negativeResult, errorIndex++,\n+                \"invalid member type of the array to sort: type '(string|int)[]' is not an ordered type\",\n+                136, 33);\n+        BAssertUtil.validateError(negativeResult, errorIndex++,\n+                \"invalid member type of the array to sort: type '(string|int)[]' is not an ordered type\",\n+                138, 33);\n+        BAssertUtil.validateError(negativeResult, errorIndex++,\n+                \"invalid member type of the array to sort: type '(string|int)[]' is not an ordered type\",\n+                140, 33);\n+        BAssertUtil.validateError(negativeResult, errorIndex++,\n+                \"invalid array sort key function return type: type '(string|int)' is not an ordered type\",\n+                142, 33);\n+        BAssertUtil.validateError(negativeResult, errorIndex++,\n+                \"invalid member type of the array to sort: type 'map<string>?[]' is not an ordered type\",\n+                148, 35);\n+        BAssertUtil.validateError(negativeResult, errorIndex++,\n+                \"incompatible types: expected 'function ((any|error)) returns ((boolean|int|float|decimal|string|\" +\n+                        \"(boolean|int|float|decimal|string)?[])?)?', found 'function (map<string>?) \" +\n+                        \"returns (map<string>?)'\",\n+                150, 62);\n+        BAssertUtil.validateError(negativeResult, errorIndex++,\n+                \"too many arguments in call to 'sort()'\", 154, 24);\n         Assert.assertEquals(negativeResult.getErrorCount(), errorIndex);\n     }\n \n     @Test\n     public void testShiftOperation() {\n         BRunUtil.invoke(compileResult, \"testShiftOperation\");\n     }\n+\n+    @Test\n+    public void testSort1() {\n+        BRunUtil.invoke(compileResult, \"testSort1\");\n+    }\n+\n+    @Test\n+    public void testSort2() {\n+        BRunUtil.invoke(compileResult, \"testSort2\");\n+    }\n+\n+    @Test\n+    public void testSort3() {\n+        BValue[] returns = BRunUtil.invoke(compileResult, \"testSort3\");\n+\n+        assertEquals(returns[0].getType().getTag(), TypeTags.ARRAY_TAG);\n+        BValueArray arr = (BValueArray) returns[0];\n+\n+        assertEquals(arr.elementType.getTag(), TypeTags.INT_TAG);\n+        assertEquals(arr.size(), 100);\n+\n+        for (int i = 1; i < arr.size(); i++) {\n+            assertTrue(arr.getInt(i) < arr.getInt(i - 1));\n+        }\n+    }\n+\n+    @Test\n+    public void testSort4() {\n+        BRunUtil.invoke(compileResult, \"testSort4\");\n+    }\n+\n+    @Test\n+    public void testSort5() {\n+        BRunUtil.invoke(compileResult, \"testSort5\");\n+    }\n+\n+    @Test\n+    public void testSort6() {\n+        BRunUtil.invoke(compileResult, \"testSort6\");\n+    }\n+\n+    @Test\n+    public void testSort7() {\n+        BRunUtil.invoke(compileResult, \"testSort7\");\n+    }\n+\n+    @Test\n+    public void testSort8() {\n+        BRunUtil.invoke(compileResult, \"testSort8\");\n+    }\n+\n+    @Test\n+    public void testSort9() {\n+        BRunUtil.invoke(compileResult, \"testSort9\");\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62d470fa9d5069bfa89d83bc91d049141beb1712"}, "originalPosition": 221}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0NDYzMzcw", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#pullrequestreview-484463370", "createdAt": "2020-09-08T20:17:57Z", "commit": {"oid": "62d470fa9d5069bfa89d83bc91d049141beb1712"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMDoxNzo1N1rOHOslOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMDoxNzo1N1rOHOslOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3MjUzNw==", "bodyText": "For what scenarios would keyFunctionType be null here?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#discussion_r485172537", "createdAt": "2020-09-08T20:17:57Z", "author": {"login": "pubudu91"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -5384,6 +5390,37 @@ private BType checkInvocationArgs(BLangInvocation iExpr, List<BType> paramTypes,\n         }\n     }\n \n+    private void checkArrayLibSortFuncArgs(BLangInvocation iExpr) {\n+        if (iExpr.argExprs.size() <= 2 && !types.isOrderedType(iExpr.expr.type)) {\n+            dlog.error(iExpr.expr.pos, DiagnosticCode.INVALID_SORT_ARRAY_MEMBER_TYPE, iExpr.expr.type);\n+        }\n+\n+        if (iExpr.argExprs.size() != 3) {\n+            return;\n+        }\n+\n+        BLangExpression keyFunction = iExpr.argExprs.get(2);\n+        BType keyFunctionType = keyFunction.type;\n+        if (keyFunctionType != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62d470fa9d5069bfa89d83bc91d049141beb1712"}, "originalPosition": 37}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f1416eb0f110589cdffa66156ab4f381c0ffeb6b", "author": {"user": {"login": "lasinicl", "name": "Lasini Liyange"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f1416eb0f110589cdffa66156ab4f381c0ffeb6b", "committedDate": "2020-09-09T02:37:54Z", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into array-sort-func"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1f6f38fcf679fb780b4176cd8f6d7a6dfedab9aa", "author": {"user": {"login": "lasinicl", "name": "Lasini Liyange"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1f6f38fcf679fb780b4176cd8f6d7a6dfedab9aa", "committedDate": "2020-09-09T04:51:19Z", "message": "Fix review suggestions"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0Njc4MjMx", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#pullrequestreview-484678231", "createdAt": "2020-09-09T05:48:48Z", "commit": {"oid": "1f6f38fcf679fb780b4176cd8f6d7a6dfedab9aa"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwNTo0ODo0OFrOHO3mRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwNTo0ODo0OFrOHO3mRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM1MzAyOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              invalid member type of the array/tuple to sort: type ''{0}'' is not an ordered type\n          \n          \n            \n              invalid member type of the array/tuple to sort: ''{0}'' is not an ordered type", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#discussion_r485353028", "createdAt": "2020-09-09T05:48:48Z", "author": {"login": "pubudu91"}, "path": "compiler/ballerina-lang/src/main/resources/compiler.properties", "diffHunk": "@@ -1051,10 +1051,10 @@ error.sealed.array.type.can.not.infer.size=\\\n   invalid usage of sealed type: can not infer array size\n \n error.invalid.key.func.return.type=\\\n-  invalid array sort key function return type: type ''{0}'' is not an ordered type\n+  invalid sort key function return type: ''{0}'' is not an ordered type\n \n error.invalid.sort.array.member.type=\\\n-  invalid member type of the array to sort: type ''{0}'' is not an ordered type\n+  invalid member type of the array/tuple to sort: type ''{0}'' is not an ordered type", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f6f38fcf679fb780b4176cd8f6d7a6dfedab9aa"}, "originalPosition": 9}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0Njc4ODQy", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#pullrequestreview-484678842", "createdAt": "2020-09-09T05:50:20Z", "commit": {"oid": "1f6f38fcf679fb780b4176cd8f6d7a6dfedab9aa"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwNTo1MDoyMFrOHO3oTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwNTo1MDoyMFrOHO3oTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM1MzU0OA==", "bodyText": "Shall we just simply say but found '\" + type.toString() + \"'\"?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#discussion_r485353548", "createdAt": "2020-09-09T05:50:20Z", "author": {"login": "pubudu91"}, "path": "langlib/lang.array/src/main/java/org/ballerinalang/langlib/array/Sort.java", "diffHunk": "@@ -219,8 +222,8 @@ private static int sortFunc(Object value1, Object value2, BType type, boolean is\n             }\n             return c;\n         }\n-        throw BallerinaErrors.createError(\"Invalid type to sort\", \"Expected an ordered type, but found type: \"\n-                + type.toString());\n+        throw BallerinaErrors.createError(getModulePrefixedReason(ARRAY_LANG_LIB, INVALID_TYPE_TO_SORT),\n+                \"expected an ordered type, but found type: '\" + type.toString() + \"'\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f6f38fcf679fb780b4176cd8f6d7a6dfedab9aa"}, "originalPosition": 17}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4dda78b72b814f75fffb77fbf713d65f272323f0", "author": {"user": {"login": "lasinicl", "name": "Lasini Liyange"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/4dda78b72b814f75fffb77fbf713d65f272323f0", "committedDate": "2020-09-09T08:06:58Z", "message": "Fix review suggestions"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0ODY4NzA3", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#pullrequestreview-484868707", "createdAt": "2020-09-09T10:23:09Z", "commit": {"oid": "4dda78b72b814f75fffb77fbf713d65f272323f0"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4803, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}