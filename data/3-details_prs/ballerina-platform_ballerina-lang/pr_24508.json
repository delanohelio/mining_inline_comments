{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQxODU4NjI3", "number": 24508, "title": "Refactor and use switch statements", "bodyText": "Purpose\nThis PR refactor jvm codegen package with following changes.\n\nUse switch statements wherever appropriate\nRemove redundant method arguments and variables\n\nRelated to #24405", "createdAt": "2020-06-30T08:10:52Z", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24508", "merged": true, "mergeCommit": {"oid": "a2756b9b7c65eb84acaaa2227272835e80353698"}, "closed": true, "closedAt": "2020-07-03T06:36:19Z", "author": {"login": "Kishanthan"}, "timelineItems": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcwTK1wgBqjM0OTcwOTk4Mjk=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcxMqY-AFqTQ0MjE1NTIzNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "590506b2ec7c13b9116631411a8be0a680a81028", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/590506b2ec7c13b9116631411a8be0a680a81028", "committedDate": "2020-06-30T08:09:01Z", "message": "Use switch statements"}, "afterCommit": {"oid": "c005391be7b384b4f8fa6a5f6232702902c19819", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c005391be7b384b4f8fa6a5f6232702902c19819", "committedDate": "2020-06-30T10:34:10Z", "message": "Use switch statements"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9af3400b5ca13cc641615862e941bb0dc0343e5a", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/9af3400b5ca13cc641615862e941bb0dc0343e5a", "committedDate": "2020-06-30T14:04:50Z", "message": "Use switch statements"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "99c05c724e4aad540d0410d41f90cf0e9c86e633", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/99c05c724e4aad540d0410d41f90cf0e9c86e633", "committedDate": "2020-06-30T11:04:45Z", "message": "Fix code quality warnings\n\nThis commit has the following fixes\n- Remove unused method parameters\n- Remove unused variables"}, "afterCommit": {"oid": "9af3400b5ca13cc641615862e941bb0dc0343e5a", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/9af3400b5ca13cc641615862e941bb0dc0343e5a", "committedDate": "2020-06-30T14:04:50Z", "message": "Use switch statements"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e3c76390d1fe89fea969ca45e2fff4a790857542", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e3c76390d1fe89fea969ca45e2fff4a790857542", "committedDate": "2020-07-01T06:55:11Z", "message": "Refactor unused method params and vars\n\nThis commit has the following fixes\n\n- Remove unused method parameters\n- Remove unused variables"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aa82d51019a7c0fb7fd70ee3eab4978fc7cdf53e", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/aa82d51019a7c0fb7fd70ee3eab4978fc7cdf53e", "committedDate": "2020-07-01T06:55:52Z", "message": "Remove and refactor redundant else blocks"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d900759889dcc377bf9b90d9f629486d362c89ca", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/d900759889dcc377bf9b90d9f629486d362c89ca", "committedDate": "2020-07-01T06:51:24Z", "message": "Remove and refactor redundant else blocks"}, "afterCommit": {"oid": "aa82d51019a7c0fb7fd70ee3eab4978fc7cdf53e", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/aa82d51019a7c0fb7fd70ee3eab4978fc7cdf53e", "committedDate": "2020-07-01T06:55:52Z", "message": "Remove and refactor redundant else blocks"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ca9ab9ba06e4614fe16b9340155316da79893968", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/ca9ab9ba06e4614fe16b9340155316da79893968", "committedDate": "2020-07-01T08:36:19Z", "message": "Remove unused variables\n\nThis commit also merge duplicate switch cases in JvmTerminatorGen"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxOTE2NTEz", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24508#pullrequestreview-441916513", "createdAt": "2020-07-02T18:04:03Z", "commit": {"oid": "ca9ab9ba06e4614fe16b9340155316da79893968"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxODowNDowM1rOGsYJZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxODowNDoyNVrOGsYKGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE4NjE1MA==", "bodyText": "Shall we remove the commented code? We can add a Todo if needed about what to fix properly and remove the code. Anyone can see the code from git history right?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24508#discussion_r449186150", "createdAt": "2020-07-02T18:04:03Z", "author": {"login": "riyafa"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/codegen/JvmCastGen.java", "diffHunk": "@@ -310,122 +379,174 @@ private static void generateJToBCheckCast(MethodVisitor mv, BIRVarToJVMIndexMap\n \n         if (TypeTags.isIntegerTypeTag(targetType.tag)) {\n             generateCheckCastJToBInt(mv, sourceType);\n-        } else if (targetType.tag == TypeTags.FLOAT) {\n-            generateCheckCastJToBFloat(mv, sourceType);\n-        } else if (targetType.tag == TypeTags.DECIMAL) {\n-            generateCheckCastJToBDecimal(mv, sourceType);\n-        } else if (targetType.tag == TypeTags.BOOLEAN) {\n-            generateCheckCastJToBBoolean(mv, sourceType);\n-        } else if (targetType.tag == TypeTags.BYTE) {\n-            generateCheckCastJToBByte(mv, sourceType);\n-        } else if (targetType.tag == TypeTags.NIL || targetType.tag == TypeTags.NEVER) {\n-            // Do nothing\n-        } else {\n-            if (targetType.tag == TypeTags.UNION) {\n-                generateCheckCastJToBUnionType(mv, indexMap, sourceType, (BUnionType) targetType);\n-            } else if (targetType.tag == TypeTags.ANYDATA) {\n-                generateCheckCastJToBAnyData(mv, indexMap, sourceType);\n-            } else if (targetType.tag == TypeTags.HANDLE) {\n-                generateJCastToBHandle(mv, sourceType);\n-            } else if (targetType.tag == TypeTags.ANY) {\n-                generateJCastToBAny(mv, indexMap, sourceType, targetType);\n-            } else if (targetType.tag == TypeTags.JSON) {\n-                generateCheckCastJToBJSON(mv, indexMap, sourceType);\n-            } else if (targetType.tag == TypeTags.FINITE) {\n-                generateCheckCastJToBFiniteType(mv, indexMap, sourceType, targetType);\n-                // TODO fix below properly - rajith\n-                //} else if (sourceType is bir:BXMLType && targetType is bir:BMapType) {\n-                //    generateXMLToAttributesMap(mv, sourceType);\n-                //    return;\n-                //} else if (targetType is bir:BFiniteType) {\n-                //    generateCheckCastToFiniteType(mv, sourceType, targetType);\n-                //    return;\n-                //} else if (sourceType is bir:BRecordType && (targetType is bir:BMapType && targetType.constraint\n-                // is bir:BTypeAny)) {\n-                //    // do nothing\n-            }\n+            return;\n+        }\n \n-            checkCast(mv, targetType);\n-            String targetTypeClass = getTargetClass(targetType);\n-            if (targetTypeClass != null) {\n-                mv.visitTypeInsn(CHECKCAST, targetTypeClass);\n-            }\n+        switch (targetType.tag) {\n+            case TypeTags.FLOAT:\n+                generateCheckCastJToBFloat(mv, sourceType);\n+                break;\n+            case TypeTags.DECIMAL:\n+                generateCheckCastJToBDecimal(mv, sourceType);\n+                break;\n+            case TypeTags.BOOLEAN:\n+                generateCheckCastJToBBoolean(mv, sourceType);\n+                break;\n+            case TypeTags.BYTE:\n+                generateCheckCastJToBByte(mv, sourceType);\n+                break;\n+            case TypeTags.NIL:\n+            case TypeTags.NEVER:\n+                // Do nothing\n+                break;\n+            default:\n+                switch (targetType.tag) {\n+                    case TypeTags.UNION:\n+                        generateCheckCastJToBUnionType(mv, indexMap, sourceType, (BUnionType) targetType);\n+                        break;\n+                    case TypeTags.ANYDATA:\n+                        generateCheckCastJToBAnyData(mv, indexMap, sourceType);\n+                        break;\n+                    case TypeTags.HANDLE:\n+                        generateJCastToBHandle(mv, sourceType);\n+                        break;\n+                    case TypeTags.ANY:\n+                        generateJCastToBAny(mv, indexMap, sourceType, targetType);\n+                        break;\n+                    case TypeTags.JSON:\n+                        generateCheckCastJToBJSON(mv, indexMap, sourceType);\n+                        break;\n+                    case TypeTags.FINITE:\n+                        generateCheckCastJToBFiniteType(mv, indexMap, sourceType, targetType);\n+                        // TODO fix below properly - rajith\n+                        //} else if (sourceType is bir:BXMLType && targetType is bir:BMapType) {\n+                        //    generateXMLToAttributesMap(mv, sourceType);\n+                        //    return;\n+                        //} else if (targetType is bir:BFiniteType) {\n+                        //    generateCheckCastToFiniteType(mv, sourceType, targetType);\n+                        //    return;\n+                        //} else if (sourceType is bir:BRecordType && (targetType is bir:BMapType &&\n+                        // targetType.constraint\n+                        // is bir:BTypeAny)) {\n+                        //    // do nothing", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca9ab9ba06e4614fe16b9340155316da79893968"}, "originalPosition": 444}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE4NjMyOA==", "bodyText": "Shall we remove commented code?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24508#discussion_r449186328", "createdAt": "2020-07-02T18:04:25Z", "author": {"login": "riyafa"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/codegen/JvmCastGen.java", "diffHunk": "@@ -310,122 +379,174 @@ private static void generateJToBCheckCast(MethodVisitor mv, BIRVarToJVMIndexMap\n \n         if (TypeTags.isIntegerTypeTag(targetType.tag)) {\n             generateCheckCastJToBInt(mv, sourceType);\n-        } else if (targetType.tag == TypeTags.FLOAT) {\n-            generateCheckCastJToBFloat(mv, sourceType);\n-        } else if (targetType.tag == TypeTags.DECIMAL) {\n-            generateCheckCastJToBDecimal(mv, sourceType);\n-        } else if (targetType.tag == TypeTags.BOOLEAN) {\n-            generateCheckCastJToBBoolean(mv, sourceType);\n-        } else if (targetType.tag == TypeTags.BYTE) {\n-            generateCheckCastJToBByte(mv, sourceType);\n-        } else if (targetType.tag == TypeTags.NIL || targetType.tag == TypeTags.NEVER) {\n-            // Do nothing\n-        } else {\n-            if (targetType.tag == TypeTags.UNION) {\n-                generateCheckCastJToBUnionType(mv, indexMap, sourceType, (BUnionType) targetType);\n-            } else if (targetType.tag == TypeTags.ANYDATA) {\n-                generateCheckCastJToBAnyData(mv, indexMap, sourceType);\n-            } else if (targetType.tag == TypeTags.HANDLE) {\n-                generateJCastToBHandle(mv, sourceType);\n-            } else if (targetType.tag == TypeTags.ANY) {\n-                generateJCastToBAny(mv, indexMap, sourceType, targetType);\n-            } else if (targetType.tag == TypeTags.JSON) {\n-                generateCheckCastJToBJSON(mv, indexMap, sourceType);\n-            } else if (targetType.tag == TypeTags.FINITE) {\n-                generateCheckCastJToBFiniteType(mv, indexMap, sourceType, targetType);\n-                // TODO fix below properly - rajith\n-                //} else if (sourceType is bir:BXMLType && targetType is bir:BMapType) {\n-                //    generateXMLToAttributesMap(mv, sourceType);\n-                //    return;\n-                //} else if (targetType is bir:BFiniteType) {\n-                //    generateCheckCastToFiniteType(mv, sourceType, targetType);\n-                //    return;\n-                //} else if (sourceType is bir:BRecordType && (targetType is bir:BMapType && targetType.constraint\n-                // is bir:BTypeAny)) {\n-                //    // do nothing\n-            }\n+            return;\n+        }\n \n-            checkCast(mv, targetType);\n-            String targetTypeClass = getTargetClass(targetType);\n-            if (targetTypeClass != null) {\n-                mv.visitTypeInsn(CHECKCAST, targetTypeClass);\n-            }\n+        switch (targetType.tag) {\n+            case TypeTags.FLOAT:\n+                generateCheckCastJToBFloat(mv, sourceType);\n+                break;\n+            case TypeTags.DECIMAL:\n+                generateCheckCastJToBDecimal(mv, sourceType);\n+                break;\n+            case TypeTags.BOOLEAN:\n+                generateCheckCastJToBBoolean(mv, sourceType);\n+                break;\n+            case TypeTags.BYTE:\n+                generateCheckCastJToBByte(mv, sourceType);\n+                break;\n+            case TypeTags.NIL:\n+            case TypeTags.NEVER:\n+                // Do nothing\n+                break;\n+            default:\n+                switch (targetType.tag) {\n+                    case TypeTags.UNION:\n+                        generateCheckCastJToBUnionType(mv, indexMap, sourceType, (BUnionType) targetType);\n+                        break;\n+                    case TypeTags.ANYDATA:\n+                        generateCheckCastJToBAnyData(mv, indexMap, sourceType);\n+                        break;\n+                    case TypeTags.HANDLE:\n+                        generateJCastToBHandle(mv, sourceType);\n+                        break;\n+                    case TypeTags.ANY:\n+                        generateJCastToBAny(mv, indexMap, sourceType, targetType);\n+                        break;\n+                    case TypeTags.JSON:\n+                        generateCheckCastJToBJSON(mv, indexMap, sourceType);\n+                        break;\n+                    case TypeTags.FINITE:\n+                        generateCheckCastJToBFiniteType(mv, indexMap, sourceType, targetType);\n+                        // TODO fix below properly - rajith\n+                        //} else if (sourceType is bir:BXMLType && targetType is bir:BMapType) {\n+                        //    generateXMLToAttributesMap(mv, sourceType);\n+                        //    return;\n+                        //} else if (targetType is bir:BFiniteType) {\n+                        //    generateCheckCastToFiniteType(mv, sourceType, targetType);\n+                        //    return;\n+                        //} else if (sourceType is bir:BRecordType && (targetType is bir:BMapType &&\n+                        // targetType.constraint\n+                        // is bir:BTypeAny)) {\n+                        //    // do nothing\n+                        break;\n+                }\n+\n+                checkCast(mv, targetType);\n+                String targetTypeClass = getTargetClass(targetType);\n+                if (targetTypeClass != null) {\n+                    mv.visitTypeInsn(CHECKCAST, targetTypeClass);\n+                }\n+                break;\n         }\n     }\n \n     private static void generateCheckCastJToBInt(MethodVisitor mv, JType sourceType) {\n \n-        if (sourceType.jTag == JTypeTags.JBYTE) {\n-            mv.visitInsn(I2B);\n-            mv.visitMethodInsn(INVOKESTATIC, \"java/lang/Byte\", \"toUnsignedInt\", \"(B)I\", false);\n-            mv.visitInsn(I2L);\n-        } else if (sourceType.jTag == JTypeTags.JCHAR) {\n-            mv.visitInsn(I2L);\n-        } else if (sourceType.jTag == JTypeTags.JSHORT) {\n-            mv.visitInsn(I2L);\n-        } else if (sourceType.jTag == JTypeTags.JINT) {\n-            mv.visitInsn(I2L);\n-        } else if (sourceType.jTag == JTypeTags.JLONG) {\n-            // do nothing\n-            // According to the spec doc, below two are not needed\n-            // } else if (sourceType is jvm:JFloat) {\n-            //     mv.visitMethodInsn(INVOKESTATIC, TYPE_CONVERTER, \"jFloatToBInt\", \"(F)J\", false);\n-            // } else if (sourceType is jvm:JDouble) {\n-            //     mv.visitMethodInsn(INVOKESTATIC, TYPE_CONVERTER, \"jDoubleToBInt\", \"(D)J\", false);\n-        } else if (sourceType.jTag == JTypeTags.JREF) {\n-            mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, \"anyToJLong\", String.format(\"(L%s;)J\", OBJECT), false);\n-        } else {\n-            throw new BLangCompilerException(String.format(\"Casting is not supported from '%s' to 'int'\", sourceType));\n+        switch (sourceType.jTag) {\n+            case JTypeTags.JBYTE:\n+                mv.visitInsn(I2B);\n+                mv.visitMethodInsn(INVOKESTATIC, \"java/lang/Byte\", \"toUnsignedInt\", \"(B)I\", false);\n+                mv.visitInsn(I2L);\n+                break;\n+            case JTypeTags.JCHAR:\n+                mv.visitInsn(I2L);\n+                break;\n+            case JTypeTags.JSHORT:\n+                mv.visitInsn(I2L);\n+                break;\n+            case JTypeTags.JINT:\n+                mv.visitInsn(I2L);\n+                break;\n+            case JTypeTags.JLONG:\n+                // do nothing\n+                // According to the spec doc, below two are not needed\n+                // } else if (sourceType is jvm:JFloat) {\n+                //     mv.visitMethodInsn(INVOKESTATIC, TYPE_CONVERTER, \"jFloatToBInt\", \"(F)J\", false);\n+                // } else if (sourceType is jvm:JDouble) {\n+                //     mv.visitMethodInsn(INVOKESTATIC, TYPE_CONVERTER, \"jDoubleToBInt\", \"(D)J\", false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca9ab9ba06e4614fe16b9340155316da79893968"}, "originalPosition": 501}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7f7d76761e5016c7732dfa8be609e9abd7a6ab69", "author": {"user": {"login": "Kishanthan", "name": "Kishanthan Thangarajah"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7f7d76761e5016c7732dfa8be609e9abd7a6ab69", "committedDate": "2020-07-03T05:29:25Z", "message": "Remove commented out code segements"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQyMTU1MjM1", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24508#pullrequestreview-442155235", "createdAt": "2020-07-03T05:33:32Z", "commit": {"oid": "7f7d76761e5016c7732dfa8be609e9abd7a6ab69"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4243, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}