{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIyNzA5NTk4", "number": 23479, "reviewThreads": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwMzo0NDoyNlrOD_7NUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwNTowNzoyM1rOD_78nQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4MzU2OTQ0OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwMzo0NDoyNlrOGa4big==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwMzo0NDoyNlrOGa4big==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0MDcxNA==", "bodyText": "Can we get rid of this remove operation? Is it possible to avoid adding, rather than removing", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23479#discussion_r430840714", "createdAt": "2020-05-27T03:44:26Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -10208,6 +10212,149 @@ private Boolean isFollowTypedBindingPattern(SyntaxKind tokenKind) {\n         }\n     }\n \n+    /**\n+     * Parse mapping-binding-patterns.\n+     *\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     *\n+     * @return mapping-binding-pattern node\n+     */\n+    private STNode parseMappingBindingPattern() {\n+        startContext(ParserRuleContext.MAPPING_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBrace = parseOpenBrace();\n+\n+        STNode mappingBindingPatternMember = parseMappingBindingPatternMember();\n+        bindingPatterns.add(mappingBindingPatternMember);\n+\n+        // parsing the main chunck of mapping-binding-pattern\n+        STToken token = peek(); // get next valid token\n+        STNode mappingBindingPatternRhs = null;\n+        while (!isEndOfMappingBindingPattern(token.kind) &&\n+                mappingBindingPatternMember.kind != SyntaxKind.REST_BINDING_PATTERN) {\n+            mappingBindingPatternRhs = parseMappingBindingpatternRhs(token.kind);\n+            if (mappingBindingPatternRhs == null) {\n+                break;\n+            }\n+\n+            bindingPatterns.add(mappingBindingPatternRhs);\n+            mappingBindingPatternMember = parseMappingBindingPatternMember();\n+            bindingPatterns.add(mappingBindingPatternMember);\n+            token = peek();\n+        }\n+\n+        STNode closeBrace = parseCloseBrace();\n+\n+        // seperating out the rest-binding-pattern\n+        STNode restBindingPattern;\n+        if (mappingBindingPatternMember.kind == SyntaxKind.REST_BINDING_PATTERN) {\n+            restBindingPattern = bindingPatterns.remove(bindingPatterns.size() - 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9e616c312e66de69a60a209f2af8be80c64dd5c"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4MzU3MjUwOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwMzo0NjozN1rOGa4dhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwMzo0NjozN1rOGa4dhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0MTIyMw==", "bodyText": "Should this be moved inside the loop?\nAccording to the grammar, list can be empty too", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23479#discussion_r430841223", "createdAt": "2020-05-27T03:46:37Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -10208,6 +10212,149 @@ private Boolean isFollowTypedBindingPattern(SyntaxKind tokenKind) {\n         }\n     }\n \n+    /**\n+     * Parse mapping-binding-patterns.\n+     *\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     *\n+     * @return mapping-binding-pattern node\n+     */\n+    private STNode parseMappingBindingPattern() {\n+        startContext(ParserRuleContext.MAPPING_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBrace = parseOpenBrace();\n+\n+        STNode mappingBindingPatternMember = parseMappingBindingPatternMember();\n+        bindingPatterns.add(mappingBindingPatternMember);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9e616c312e66de69a60a209f2af8be80c64dd5c"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4MzU3ODE4OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwMzo1MDoyNlrOGa4g1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwMzo1MDoyNlrOGa4g1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0MjA3MQ==", "bodyText": "since what this method does is parsing the next token followed by the member, how about parseMappingBindingPatternMemberEnd for method name?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23479#discussion_r430842071", "createdAt": "2020-05-27T03:50:26Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -10208,6 +10212,149 @@ private Boolean isFollowTypedBindingPattern(SyntaxKind tokenKind) {\n         }\n     }\n \n+    /**\n+     * Parse mapping-binding-patterns.\n+     *\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     *\n+     * @return mapping-binding-pattern node\n+     */\n+    private STNode parseMappingBindingPattern() {\n+        startContext(ParserRuleContext.MAPPING_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBrace = parseOpenBrace();\n+\n+        STNode mappingBindingPatternMember = parseMappingBindingPatternMember();\n+        bindingPatterns.add(mappingBindingPatternMember);\n+\n+        // parsing the main chunck of mapping-binding-pattern\n+        STToken token = peek(); // get next valid token\n+        STNode mappingBindingPatternRhs = null;\n+        while (!isEndOfMappingBindingPattern(token.kind) &&\n+                mappingBindingPatternMember.kind != SyntaxKind.REST_BINDING_PATTERN) {\n+            mappingBindingPatternRhs = parseMappingBindingpatternRhs(token.kind);\n+            if (mappingBindingPatternRhs == null) {\n+                break;\n+            }\n+\n+            bindingPatterns.add(mappingBindingPatternRhs);\n+            mappingBindingPatternMember = parseMappingBindingPatternMember();\n+            bindingPatterns.add(mappingBindingPatternMember);\n+            token = peek();\n+        }\n+\n+        STNode closeBrace = parseCloseBrace();\n+\n+        // seperating out the rest-binding-pattern\n+        STNode restBindingPattern;\n+        if (mappingBindingPatternMember.kind == SyntaxKind.REST_BINDING_PATTERN) {\n+            restBindingPattern = bindingPatterns.remove(bindingPatterns.size() - 1);\n+        } else {\n+            restBindingPattern = STNodeFactory.createEmptyNode();\n+        }\n+\n+        STNode bindingPatternsNode = STNodeFactory.createNodeList(bindingPatterns);\n+        endContext();\n+        return STNodeFactory.createMappingBindingPatternNode(openBrace, bindingPatternsNode, restBindingPattern,\n+                closeBrace);\n+    }\n+\n+    /**\n+     * Parse mapping-binding-pattern entry.\n+     *\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     *\n+     * @return mapping-binding-pattern node\n+     */\n+    private STNode parseMappingBindingPatternMember() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case ELLIPSIS_TOKEN:\n+                return parseRestBindingPattern();\n+            default:\n+                return parseFieldBindingPattern();\n+        }\n+    }\n+\n+    private STNode parseMappingBindingpatternRhs() {\n+        return parseMappingBindingpatternRhs(peek().kind);\n+    }\n+\n+    private STNode parseMappingBindingpatternRhs(SyntaxKind nextTokenKind) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9e616c312e66de69a60a209f2af8be80c64dd5c"}, "originalPosition": 102}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4MzU3ODYwOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwMzo1MDo0NlrOGa4hHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwMzo1MDo0NlrOGa4hHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0MjE0MA==", "bodyText": "MAPPING_BINDING_PATTERN_MEMBER_END", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23479#discussion_r430842140", "createdAt": "2020-05-27T03:50:46Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -10208,6 +10212,149 @@ private Boolean isFollowTypedBindingPattern(SyntaxKind tokenKind) {\n         }\n     }\n \n+    /**\n+     * Parse mapping-binding-patterns.\n+     *\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     *\n+     * @return mapping-binding-pattern node\n+     */\n+    private STNode parseMappingBindingPattern() {\n+        startContext(ParserRuleContext.MAPPING_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBrace = parseOpenBrace();\n+\n+        STNode mappingBindingPatternMember = parseMappingBindingPatternMember();\n+        bindingPatterns.add(mappingBindingPatternMember);\n+\n+        // parsing the main chunck of mapping-binding-pattern\n+        STToken token = peek(); // get next valid token\n+        STNode mappingBindingPatternRhs = null;\n+        while (!isEndOfMappingBindingPattern(token.kind) &&\n+                mappingBindingPatternMember.kind != SyntaxKind.REST_BINDING_PATTERN) {\n+            mappingBindingPatternRhs = parseMappingBindingpatternRhs(token.kind);\n+            if (mappingBindingPatternRhs == null) {\n+                break;\n+            }\n+\n+            bindingPatterns.add(mappingBindingPatternRhs);\n+            mappingBindingPatternMember = parseMappingBindingPatternMember();\n+            bindingPatterns.add(mappingBindingPatternMember);\n+            token = peek();\n+        }\n+\n+        STNode closeBrace = parseCloseBrace();\n+\n+        // seperating out the rest-binding-pattern\n+        STNode restBindingPattern;\n+        if (mappingBindingPatternMember.kind == SyntaxKind.REST_BINDING_PATTERN) {\n+            restBindingPattern = bindingPatterns.remove(bindingPatterns.size() - 1);\n+        } else {\n+            restBindingPattern = STNodeFactory.createEmptyNode();\n+        }\n+\n+        STNode bindingPatternsNode = STNodeFactory.createNodeList(bindingPatterns);\n+        endContext();\n+        return STNodeFactory.createMappingBindingPatternNode(openBrace, bindingPatternsNode, restBindingPattern,\n+                closeBrace);\n+    }\n+\n+    /**\n+     * Parse mapping-binding-pattern entry.\n+     *\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     *\n+     * @return mapping-binding-pattern node\n+     */\n+    private STNode parseMappingBindingPatternMember() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case ELLIPSIS_TOKEN:\n+                return parseRestBindingPattern();\n+            default:\n+                return parseFieldBindingPattern();\n+        }\n+    }\n+\n+    private STNode parseMappingBindingpatternRhs() {\n+        return parseMappingBindingpatternRhs(peek().kind);\n+    }\n+\n+    private STNode parseMappingBindingpatternRhs(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case COMMA_TOKEN:\n+                return parseComma();\n+            case CLOSE_BRACE_TOKEN:\n+                return null;\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.MAPPING_BINDING_PATTERN_END_OR_CONTINUE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9e616c312e66de69a60a209f2af8be80c64dd5c"}, "originalPosition": 109}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4MzU4MjQyOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwMzo1MzoxMlrOGa4jPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwODo0MzowNFrOGa_WHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0MjY4NA==", "bodyText": "Should only keep CLOSE_BRACE_TOKEN and EOF_TOKEN and remove others. Because only these two are the ones that we can treat as the 'end' for sure. Anything else should go to recovery.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23479#discussion_r430842684", "createdAt": "2020-05-27T03:53:12Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -10208,6 +10212,149 @@ private Boolean isFollowTypedBindingPattern(SyntaxKind tokenKind) {\n         }\n     }\n \n+    /**\n+     * Parse mapping-binding-patterns.\n+     *\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     *\n+     * @return mapping-binding-pattern node\n+     */\n+    private STNode parseMappingBindingPattern() {\n+        startContext(ParserRuleContext.MAPPING_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBrace = parseOpenBrace();\n+\n+        STNode mappingBindingPatternMember = parseMappingBindingPatternMember();\n+        bindingPatterns.add(mappingBindingPatternMember);\n+\n+        // parsing the main chunck of mapping-binding-pattern\n+        STToken token = peek(); // get next valid token\n+        STNode mappingBindingPatternRhs = null;\n+        while (!isEndOfMappingBindingPattern(token.kind) &&\n+                mappingBindingPatternMember.kind != SyntaxKind.REST_BINDING_PATTERN) {\n+            mappingBindingPatternRhs = parseMappingBindingpatternRhs(token.kind);\n+            if (mappingBindingPatternRhs == null) {\n+                break;\n+            }\n+\n+            bindingPatterns.add(mappingBindingPatternRhs);\n+            mappingBindingPatternMember = parseMappingBindingPatternMember();\n+            bindingPatterns.add(mappingBindingPatternMember);\n+            token = peek();\n+        }\n+\n+        STNode closeBrace = parseCloseBrace();\n+\n+        // seperating out the rest-binding-pattern\n+        STNode restBindingPattern;\n+        if (mappingBindingPatternMember.kind == SyntaxKind.REST_BINDING_PATTERN) {\n+            restBindingPattern = bindingPatterns.remove(bindingPatterns.size() - 1);\n+        } else {\n+            restBindingPattern = STNodeFactory.createEmptyNode();\n+        }\n+\n+        STNode bindingPatternsNode = STNodeFactory.createNodeList(bindingPatterns);\n+        endContext();\n+        return STNodeFactory.createMappingBindingPatternNode(openBrace, bindingPatternsNode, restBindingPattern,\n+                closeBrace);\n+    }\n+\n+    /**\n+     * Parse mapping-binding-pattern entry.\n+     *\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     *\n+     * @return mapping-binding-pattern node\n+     */\n+    private STNode parseMappingBindingPatternMember() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case ELLIPSIS_TOKEN:\n+                return parseRestBindingPattern();\n+            default:\n+                return parseFieldBindingPattern();\n+        }\n+    }\n+\n+    private STNode parseMappingBindingpatternRhs() {\n+        return parseMappingBindingpatternRhs(peek().kind);\n+    }\n+\n+    private STNode parseMappingBindingpatternRhs(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case COMMA_TOKEN:\n+                return parseComma();\n+            case CLOSE_BRACE_TOKEN:\n+                return null;\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.MAPPING_BINDING_PATTERN_END_OR_CONTINUE);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseMappingBindingpatternRhs(solution.tokenKind);\n+        }\n+    }\n+\n+    /**\n+     * Parse field-binding-pattern.\n+     *\n+     * field-binding-pattern := field-name : binding-pattern | varname\n+     *\n+     * @return field-binding-pattern node\n+     */\n+    private STNode parseFieldBindingPattern() {\n+        startContext(ParserRuleContext.FIELD_BINDING_PATTERN);\n+        STNode fieldName = parseVariableName();\n+        STNode colon = STNodeFactory.createEmptyNode();\n+        STNode bindingPattern = STNodeFactory.createEmptyNode();\n+\n+        if (!isEndOfFieldBindingPattern(peek().kind)) {\n+            colon = parseColon();\n+            bindingPattern = parseBindingPattern();\n+        }\n+        endContext();\n+        return STNodeFactory.createFieldBindingPatternNode(fieldName,\n+                colon,\n+                bindingPattern);\n+    }\n+\n+    private boolean isEndOfMappingBindingPattern(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case IN_KEYWORD:\n+            case CLOSE_BRACE_TOKEN:\n+            case EOF_TOKEN:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9e616c312e66de69a60a209f2af8be80c64dd5c"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk1NDAxNA==", "bodyText": "all keywords that follow a typed binding pattern should also be treated as end for sure right?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23479#discussion_r430954014", "createdAt": "2020-05-27T08:43:04Z", "author": {"login": "m36dot"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -10208,6 +10212,149 @@ private Boolean isFollowTypedBindingPattern(SyntaxKind tokenKind) {\n         }\n     }\n \n+    /**\n+     * Parse mapping-binding-patterns.\n+     *\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     *\n+     * @return mapping-binding-pattern node\n+     */\n+    private STNode parseMappingBindingPattern() {\n+        startContext(ParserRuleContext.MAPPING_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBrace = parseOpenBrace();\n+\n+        STNode mappingBindingPatternMember = parseMappingBindingPatternMember();\n+        bindingPatterns.add(mappingBindingPatternMember);\n+\n+        // parsing the main chunck of mapping-binding-pattern\n+        STToken token = peek(); // get next valid token\n+        STNode mappingBindingPatternRhs = null;\n+        while (!isEndOfMappingBindingPattern(token.kind) &&\n+                mappingBindingPatternMember.kind != SyntaxKind.REST_BINDING_PATTERN) {\n+            mappingBindingPatternRhs = parseMappingBindingpatternRhs(token.kind);\n+            if (mappingBindingPatternRhs == null) {\n+                break;\n+            }\n+\n+            bindingPatterns.add(mappingBindingPatternRhs);\n+            mappingBindingPatternMember = parseMappingBindingPatternMember();\n+            bindingPatterns.add(mappingBindingPatternMember);\n+            token = peek();\n+        }\n+\n+        STNode closeBrace = parseCloseBrace();\n+\n+        // seperating out the rest-binding-pattern\n+        STNode restBindingPattern;\n+        if (mappingBindingPatternMember.kind == SyntaxKind.REST_BINDING_PATTERN) {\n+            restBindingPattern = bindingPatterns.remove(bindingPatterns.size() - 1);\n+        } else {\n+            restBindingPattern = STNodeFactory.createEmptyNode();\n+        }\n+\n+        STNode bindingPatternsNode = STNodeFactory.createNodeList(bindingPatterns);\n+        endContext();\n+        return STNodeFactory.createMappingBindingPatternNode(openBrace, bindingPatternsNode, restBindingPattern,\n+                closeBrace);\n+    }\n+\n+    /**\n+     * Parse mapping-binding-pattern entry.\n+     *\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     *\n+     * @return mapping-binding-pattern node\n+     */\n+    private STNode parseMappingBindingPatternMember() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case ELLIPSIS_TOKEN:\n+                return parseRestBindingPattern();\n+            default:\n+                return parseFieldBindingPattern();\n+        }\n+    }\n+\n+    private STNode parseMappingBindingpatternRhs() {\n+        return parseMappingBindingpatternRhs(peek().kind);\n+    }\n+\n+    private STNode parseMappingBindingpatternRhs(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case COMMA_TOKEN:\n+                return parseComma();\n+            case CLOSE_BRACE_TOKEN:\n+                return null;\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.MAPPING_BINDING_PATTERN_END_OR_CONTINUE);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseMappingBindingpatternRhs(solution.tokenKind);\n+        }\n+    }\n+\n+    /**\n+     * Parse field-binding-pattern.\n+     *\n+     * field-binding-pattern := field-name : binding-pattern | varname\n+     *\n+     * @return field-binding-pattern node\n+     */\n+    private STNode parseFieldBindingPattern() {\n+        startContext(ParserRuleContext.FIELD_BINDING_PATTERN);\n+        STNode fieldName = parseVariableName();\n+        STNode colon = STNodeFactory.createEmptyNode();\n+        STNode bindingPattern = STNodeFactory.createEmptyNode();\n+\n+        if (!isEndOfFieldBindingPattern(peek().kind)) {\n+            colon = parseColon();\n+            bindingPattern = parseBindingPattern();\n+        }\n+        endContext();\n+        return STNodeFactory.createFieldBindingPatternNode(fieldName,\n+                colon,\n+                bindingPattern);\n+    }\n+\n+    private boolean isEndOfMappingBindingPattern(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case IN_KEYWORD:\n+            case CLOSE_BRACE_TOKEN:\n+            case EOF_TOKEN:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0MjY4NA=="}, "originalCommit": {"oid": "a9e616c312e66de69a60a209f2af8be80c64dd5c"}, "originalPosition": 149}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4MzU4Mzk3OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwMzo1NDoyNFrOGa4kIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxMDo0MTozNVrOGbDmEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0MjkxMw==", "bodyText": "replace with a switch case.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23479#discussion_r430842913", "createdAt": "2020-05-27T03:54:24Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -10208,6 +10212,149 @@ private Boolean isFollowTypedBindingPattern(SyntaxKind tokenKind) {\n         }\n     }\n \n+    /**\n+     * Parse mapping-binding-patterns.\n+     *\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     *\n+     * @return mapping-binding-pattern node\n+     */\n+    private STNode parseMappingBindingPattern() {\n+        startContext(ParserRuleContext.MAPPING_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBrace = parseOpenBrace();\n+\n+        STNode mappingBindingPatternMember = parseMappingBindingPatternMember();\n+        bindingPatterns.add(mappingBindingPatternMember);\n+\n+        // parsing the main chunck of mapping-binding-pattern\n+        STToken token = peek(); // get next valid token\n+        STNode mappingBindingPatternRhs = null;\n+        while (!isEndOfMappingBindingPattern(token.kind) &&\n+                mappingBindingPatternMember.kind != SyntaxKind.REST_BINDING_PATTERN) {\n+            mappingBindingPatternRhs = parseMappingBindingpatternRhs(token.kind);\n+            if (mappingBindingPatternRhs == null) {\n+                break;\n+            }\n+\n+            bindingPatterns.add(mappingBindingPatternRhs);\n+            mappingBindingPatternMember = parseMappingBindingPatternMember();\n+            bindingPatterns.add(mappingBindingPatternMember);\n+            token = peek();\n+        }\n+\n+        STNode closeBrace = parseCloseBrace();\n+\n+        // seperating out the rest-binding-pattern\n+        STNode restBindingPattern;\n+        if (mappingBindingPatternMember.kind == SyntaxKind.REST_BINDING_PATTERN) {\n+            restBindingPattern = bindingPatterns.remove(bindingPatterns.size() - 1);\n+        } else {\n+            restBindingPattern = STNodeFactory.createEmptyNode();\n+        }\n+\n+        STNode bindingPatternsNode = STNodeFactory.createNodeList(bindingPatterns);\n+        endContext();\n+        return STNodeFactory.createMappingBindingPatternNode(openBrace, bindingPatternsNode, restBindingPattern,\n+                closeBrace);\n+    }\n+\n+    /**\n+     * Parse mapping-binding-pattern entry.\n+     *\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     *\n+     * @return mapping-binding-pattern node\n+     */\n+    private STNode parseMappingBindingPatternMember() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case ELLIPSIS_TOKEN:\n+                return parseRestBindingPattern();\n+            default:\n+                return parseFieldBindingPattern();\n+        }\n+    }\n+\n+    private STNode parseMappingBindingpatternRhs() {\n+        return parseMappingBindingpatternRhs(peek().kind);\n+    }\n+\n+    private STNode parseMappingBindingpatternRhs(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case COMMA_TOKEN:\n+                return parseComma();\n+            case CLOSE_BRACE_TOKEN:\n+                return null;\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.MAPPING_BINDING_PATTERN_END_OR_CONTINUE);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseMappingBindingpatternRhs(solution.tokenKind);\n+        }\n+    }\n+\n+    /**\n+     * Parse field-binding-pattern.\n+     *\n+     * field-binding-pattern := field-name : binding-pattern | varname\n+     *\n+     * @return field-binding-pattern node\n+     */\n+    private STNode parseFieldBindingPattern() {\n+        startContext(ParserRuleContext.FIELD_BINDING_PATTERN);\n+        STNode fieldName = parseVariableName();\n+        STNode colon = STNodeFactory.createEmptyNode();\n+        STNode bindingPattern = STNodeFactory.createEmptyNode();\n+\n+        if (!isEndOfFieldBindingPattern(peek().kind)) {\n+            colon = parseColon();\n+            bindingPattern = parseBindingPattern();\n+        }\n+        endContext();\n+        return STNodeFactory.createFieldBindingPatternNode(fieldName,\n+                colon,\n+                bindingPattern);\n+    }\n+\n+    private boolean isEndOfMappingBindingPattern(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case IN_KEYWORD:\n+            case CLOSE_BRACE_TOKEN:\n+            case EOF_TOKEN:\n+            case EQUAL_TOKEN:\n+                return true;\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean isEndOfFieldBindingPattern(SyntaxKind nextTokenKind) {\n+        if (isEndOfMappingBindingPattern(nextTokenKind) ||", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9e616c312e66de69a60a209f2af8be80c64dd5c"}, "originalPosition": 158}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk2MzcyMw==", "bodyText": "you can't have method calls in switch case right?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23479#discussion_r430963723", "createdAt": "2020-05-27T08:58:33Z", "author": {"login": "m36dot"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -10208,6 +10212,149 @@ private Boolean isFollowTypedBindingPattern(SyntaxKind tokenKind) {\n         }\n     }\n \n+    /**\n+     * Parse mapping-binding-patterns.\n+     *\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     *\n+     * @return mapping-binding-pattern node\n+     */\n+    private STNode parseMappingBindingPattern() {\n+        startContext(ParserRuleContext.MAPPING_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBrace = parseOpenBrace();\n+\n+        STNode mappingBindingPatternMember = parseMappingBindingPatternMember();\n+        bindingPatterns.add(mappingBindingPatternMember);\n+\n+        // parsing the main chunck of mapping-binding-pattern\n+        STToken token = peek(); // get next valid token\n+        STNode mappingBindingPatternRhs = null;\n+        while (!isEndOfMappingBindingPattern(token.kind) &&\n+                mappingBindingPatternMember.kind != SyntaxKind.REST_BINDING_PATTERN) {\n+            mappingBindingPatternRhs = parseMappingBindingpatternRhs(token.kind);\n+            if (mappingBindingPatternRhs == null) {\n+                break;\n+            }\n+\n+            bindingPatterns.add(mappingBindingPatternRhs);\n+            mappingBindingPatternMember = parseMappingBindingPatternMember();\n+            bindingPatterns.add(mappingBindingPatternMember);\n+            token = peek();\n+        }\n+\n+        STNode closeBrace = parseCloseBrace();\n+\n+        // seperating out the rest-binding-pattern\n+        STNode restBindingPattern;\n+        if (mappingBindingPatternMember.kind == SyntaxKind.REST_BINDING_PATTERN) {\n+            restBindingPattern = bindingPatterns.remove(bindingPatterns.size() - 1);\n+        } else {\n+            restBindingPattern = STNodeFactory.createEmptyNode();\n+        }\n+\n+        STNode bindingPatternsNode = STNodeFactory.createNodeList(bindingPatterns);\n+        endContext();\n+        return STNodeFactory.createMappingBindingPatternNode(openBrace, bindingPatternsNode, restBindingPattern,\n+                closeBrace);\n+    }\n+\n+    /**\n+     * Parse mapping-binding-pattern entry.\n+     *\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     *\n+     * @return mapping-binding-pattern node\n+     */\n+    private STNode parseMappingBindingPatternMember() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case ELLIPSIS_TOKEN:\n+                return parseRestBindingPattern();\n+            default:\n+                return parseFieldBindingPattern();\n+        }\n+    }\n+\n+    private STNode parseMappingBindingpatternRhs() {\n+        return parseMappingBindingpatternRhs(peek().kind);\n+    }\n+\n+    private STNode parseMappingBindingpatternRhs(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case COMMA_TOKEN:\n+                return parseComma();\n+            case CLOSE_BRACE_TOKEN:\n+                return null;\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.MAPPING_BINDING_PATTERN_END_OR_CONTINUE);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseMappingBindingpatternRhs(solution.tokenKind);\n+        }\n+    }\n+\n+    /**\n+     * Parse field-binding-pattern.\n+     *\n+     * field-binding-pattern := field-name : binding-pattern | varname\n+     *\n+     * @return field-binding-pattern node\n+     */\n+    private STNode parseFieldBindingPattern() {\n+        startContext(ParserRuleContext.FIELD_BINDING_PATTERN);\n+        STNode fieldName = parseVariableName();\n+        STNode colon = STNodeFactory.createEmptyNode();\n+        STNode bindingPattern = STNodeFactory.createEmptyNode();\n+\n+        if (!isEndOfFieldBindingPattern(peek().kind)) {\n+            colon = parseColon();\n+            bindingPattern = parseBindingPattern();\n+        }\n+        endContext();\n+        return STNodeFactory.createFieldBindingPatternNode(fieldName,\n+                colon,\n+                bindingPattern);\n+    }\n+\n+    private boolean isEndOfMappingBindingPattern(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case IN_KEYWORD:\n+            case CLOSE_BRACE_TOKEN:\n+            case EOF_TOKEN:\n+            case EQUAL_TOKEN:\n+                return true;\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean isEndOfFieldBindingPattern(SyntaxKind nextTokenKind) {\n+        if (isEndOfMappingBindingPattern(nextTokenKind) ||", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0MjkxMw=="}, "originalCommit": {"oid": "a9e616c312e66de69a60a209f2af8be80c64dd5c"}, "originalPosition": 158}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTAyMzYzMw==", "bodyText": "I meant, we can have all cases inside the switch case. no need of a func-call.\nIts better in-terms of performance.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23479#discussion_r431023633", "createdAt": "2020-05-27T10:41:35Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -10208,6 +10212,149 @@ private Boolean isFollowTypedBindingPattern(SyntaxKind tokenKind) {\n         }\n     }\n \n+    /**\n+     * Parse mapping-binding-patterns.\n+     *\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     *\n+     * @return mapping-binding-pattern node\n+     */\n+    private STNode parseMappingBindingPattern() {\n+        startContext(ParserRuleContext.MAPPING_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBrace = parseOpenBrace();\n+\n+        STNode mappingBindingPatternMember = parseMappingBindingPatternMember();\n+        bindingPatterns.add(mappingBindingPatternMember);\n+\n+        // parsing the main chunck of mapping-binding-pattern\n+        STToken token = peek(); // get next valid token\n+        STNode mappingBindingPatternRhs = null;\n+        while (!isEndOfMappingBindingPattern(token.kind) &&\n+                mappingBindingPatternMember.kind != SyntaxKind.REST_BINDING_PATTERN) {\n+            mappingBindingPatternRhs = parseMappingBindingpatternRhs(token.kind);\n+            if (mappingBindingPatternRhs == null) {\n+                break;\n+            }\n+\n+            bindingPatterns.add(mappingBindingPatternRhs);\n+            mappingBindingPatternMember = parseMappingBindingPatternMember();\n+            bindingPatterns.add(mappingBindingPatternMember);\n+            token = peek();\n+        }\n+\n+        STNode closeBrace = parseCloseBrace();\n+\n+        // seperating out the rest-binding-pattern\n+        STNode restBindingPattern;\n+        if (mappingBindingPatternMember.kind == SyntaxKind.REST_BINDING_PATTERN) {\n+            restBindingPattern = bindingPatterns.remove(bindingPatterns.size() - 1);\n+        } else {\n+            restBindingPattern = STNodeFactory.createEmptyNode();\n+        }\n+\n+        STNode bindingPatternsNode = STNodeFactory.createNodeList(bindingPatterns);\n+        endContext();\n+        return STNodeFactory.createMappingBindingPatternNode(openBrace, bindingPatternsNode, restBindingPattern,\n+                closeBrace);\n+    }\n+\n+    /**\n+     * Parse mapping-binding-pattern entry.\n+     *\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     *\n+     * @return mapping-binding-pattern node\n+     */\n+    private STNode parseMappingBindingPatternMember() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case ELLIPSIS_TOKEN:\n+                return parseRestBindingPattern();\n+            default:\n+                return parseFieldBindingPattern();\n+        }\n+    }\n+\n+    private STNode parseMappingBindingpatternRhs() {\n+        return parseMappingBindingpatternRhs(peek().kind);\n+    }\n+\n+    private STNode parseMappingBindingpatternRhs(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case COMMA_TOKEN:\n+                return parseComma();\n+            case CLOSE_BRACE_TOKEN:\n+                return null;\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.MAPPING_BINDING_PATTERN_END_OR_CONTINUE);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseMappingBindingpatternRhs(solution.tokenKind);\n+        }\n+    }\n+\n+    /**\n+     * Parse field-binding-pattern.\n+     *\n+     * field-binding-pattern := field-name : binding-pattern | varname\n+     *\n+     * @return field-binding-pattern node\n+     */\n+    private STNode parseFieldBindingPattern() {\n+        startContext(ParserRuleContext.FIELD_BINDING_PATTERN);\n+        STNode fieldName = parseVariableName();\n+        STNode colon = STNodeFactory.createEmptyNode();\n+        STNode bindingPattern = STNodeFactory.createEmptyNode();\n+\n+        if (!isEndOfFieldBindingPattern(peek().kind)) {\n+            colon = parseColon();\n+            bindingPattern = parseBindingPattern();\n+        }\n+        endContext();\n+        return STNodeFactory.createFieldBindingPatternNode(fieldName,\n+                colon,\n+                bindingPattern);\n+    }\n+\n+    private boolean isEndOfMappingBindingPattern(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case IN_KEYWORD:\n+            case CLOSE_BRACE_TOKEN:\n+            case EOF_TOKEN:\n+            case EQUAL_TOKEN:\n+                return true;\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean isEndOfFieldBindingPattern(SyntaxKind nextTokenKind) {\n+        if (isEndOfMappingBindingPattern(nextTokenKind) ||", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0MjkxMw=="}, "originalCommit": {"oid": "a9e616c312e66de69a60a209f2af8be80c64dd5c"}, "originalPosition": 158}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4MzU5MDg4OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwMzo1OToxNVrOGa4oTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxMDo0Mzo0MVrOGbDqzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0Mzk4Mw==", "bodyText": "Can we live without starting a context?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23479#discussion_r430843983", "createdAt": "2020-05-27T03:59:15Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -10208,6 +10212,149 @@ private Boolean isFollowTypedBindingPattern(SyntaxKind tokenKind) {\n         }\n     }\n \n+    /**\n+     * Parse mapping-binding-patterns.\n+     *\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     *\n+     * @return mapping-binding-pattern node\n+     */\n+    private STNode parseMappingBindingPattern() {\n+        startContext(ParserRuleContext.MAPPING_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBrace = parseOpenBrace();\n+\n+        STNode mappingBindingPatternMember = parseMappingBindingPatternMember();\n+        bindingPatterns.add(mappingBindingPatternMember);\n+\n+        // parsing the main chunck of mapping-binding-pattern\n+        STToken token = peek(); // get next valid token\n+        STNode mappingBindingPatternRhs = null;\n+        while (!isEndOfMappingBindingPattern(token.kind) &&\n+                mappingBindingPatternMember.kind != SyntaxKind.REST_BINDING_PATTERN) {\n+            mappingBindingPatternRhs = parseMappingBindingpatternRhs(token.kind);\n+            if (mappingBindingPatternRhs == null) {\n+                break;\n+            }\n+\n+            bindingPatterns.add(mappingBindingPatternRhs);\n+            mappingBindingPatternMember = parseMappingBindingPatternMember();\n+            bindingPatterns.add(mappingBindingPatternMember);\n+            token = peek();\n+        }\n+\n+        STNode closeBrace = parseCloseBrace();\n+\n+        // seperating out the rest-binding-pattern\n+        STNode restBindingPattern;\n+        if (mappingBindingPatternMember.kind == SyntaxKind.REST_BINDING_PATTERN) {\n+            restBindingPattern = bindingPatterns.remove(bindingPatterns.size() - 1);\n+        } else {\n+            restBindingPattern = STNodeFactory.createEmptyNode();\n+        }\n+\n+        STNode bindingPatternsNode = STNodeFactory.createNodeList(bindingPatterns);\n+        endContext();\n+        return STNodeFactory.createMappingBindingPatternNode(openBrace, bindingPatternsNode, restBindingPattern,\n+                closeBrace);\n+    }\n+\n+    /**\n+     * Parse mapping-binding-pattern entry.\n+     *\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     *\n+     * @return mapping-binding-pattern node\n+     */\n+    private STNode parseMappingBindingPatternMember() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case ELLIPSIS_TOKEN:\n+                return parseRestBindingPattern();\n+            default:\n+                return parseFieldBindingPattern();\n+        }\n+    }\n+\n+    private STNode parseMappingBindingpatternRhs() {\n+        return parseMappingBindingpatternRhs(peek().kind);\n+    }\n+\n+    private STNode parseMappingBindingpatternRhs(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case COMMA_TOKEN:\n+                return parseComma();\n+            case CLOSE_BRACE_TOKEN:\n+                return null;\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.MAPPING_BINDING_PATTERN_END_OR_CONTINUE);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseMappingBindingpatternRhs(solution.tokenKind);\n+        }\n+    }\n+\n+    /**\n+     * Parse field-binding-pattern.\n+     *\n+     * field-binding-pattern := field-name : binding-pattern | varname\n+     *\n+     * @return field-binding-pattern node\n+     */\n+    private STNode parseFieldBindingPattern() {\n+        startContext(ParserRuleContext.FIELD_BINDING_PATTERN);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9e616c312e66de69a60a209f2af8be80c64dd5c"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg2MjgwMg==", "bodyText": "hmm, should be possible but its much neater I think to start a context as I can easily recover fieldname : binding-pattern | fieldname", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23479#discussion_r430862802", "createdAt": "2020-05-27T05:20:56Z", "author": {"login": "m36dot"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -10208,6 +10212,149 @@ private Boolean isFollowTypedBindingPattern(SyntaxKind tokenKind) {\n         }\n     }\n \n+    /**\n+     * Parse mapping-binding-patterns.\n+     *\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     *\n+     * @return mapping-binding-pattern node\n+     */\n+    private STNode parseMappingBindingPattern() {\n+        startContext(ParserRuleContext.MAPPING_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBrace = parseOpenBrace();\n+\n+        STNode mappingBindingPatternMember = parseMappingBindingPatternMember();\n+        bindingPatterns.add(mappingBindingPatternMember);\n+\n+        // parsing the main chunck of mapping-binding-pattern\n+        STToken token = peek(); // get next valid token\n+        STNode mappingBindingPatternRhs = null;\n+        while (!isEndOfMappingBindingPattern(token.kind) &&\n+                mappingBindingPatternMember.kind != SyntaxKind.REST_BINDING_PATTERN) {\n+            mappingBindingPatternRhs = parseMappingBindingpatternRhs(token.kind);\n+            if (mappingBindingPatternRhs == null) {\n+                break;\n+            }\n+\n+            bindingPatterns.add(mappingBindingPatternRhs);\n+            mappingBindingPatternMember = parseMappingBindingPatternMember();\n+            bindingPatterns.add(mappingBindingPatternMember);\n+            token = peek();\n+        }\n+\n+        STNode closeBrace = parseCloseBrace();\n+\n+        // seperating out the rest-binding-pattern\n+        STNode restBindingPattern;\n+        if (mappingBindingPatternMember.kind == SyntaxKind.REST_BINDING_PATTERN) {\n+            restBindingPattern = bindingPatterns.remove(bindingPatterns.size() - 1);\n+        } else {\n+            restBindingPattern = STNodeFactory.createEmptyNode();\n+        }\n+\n+        STNode bindingPatternsNode = STNodeFactory.createNodeList(bindingPatterns);\n+        endContext();\n+        return STNodeFactory.createMappingBindingPatternNode(openBrace, bindingPatternsNode, restBindingPattern,\n+                closeBrace);\n+    }\n+\n+    /**\n+     * Parse mapping-binding-pattern entry.\n+     *\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     *\n+     * @return mapping-binding-pattern node\n+     */\n+    private STNode parseMappingBindingPatternMember() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case ELLIPSIS_TOKEN:\n+                return parseRestBindingPattern();\n+            default:\n+                return parseFieldBindingPattern();\n+        }\n+    }\n+\n+    private STNode parseMappingBindingpatternRhs() {\n+        return parseMappingBindingpatternRhs(peek().kind);\n+    }\n+\n+    private STNode parseMappingBindingpatternRhs(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case COMMA_TOKEN:\n+                return parseComma();\n+            case CLOSE_BRACE_TOKEN:\n+                return null;\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.MAPPING_BINDING_PATTERN_END_OR_CONTINUE);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseMappingBindingpatternRhs(solution.tokenKind);\n+        }\n+    }\n+\n+    /**\n+     * Parse field-binding-pattern.\n+     *\n+     * field-binding-pattern := field-name : binding-pattern | varname\n+     *\n+     * @return field-binding-pattern node\n+     */\n+    private STNode parseFieldBindingPattern() {\n+        startContext(ParserRuleContext.FIELD_BINDING_PATTERN);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0Mzk4Mw=="}, "originalCommit": {"oid": "a9e616c312e66de69a60a209f2af8be80c64dd5c"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTAyNDg0Nw==", "bodyText": "Again, this would be solved if you use filed-name, in place of var-name, when parsing the first identifier.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23479#discussion_r431024847", "createdAt": "2020-05-27T10:43:41Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -10208,6 +10212,149 @@ private Boolean isFollowTypedBindingPattern(SyntaxKind tokenKind) {\n         }\n     }\n \n+    /**\n+     * Parse mapping-binding-patterns.\n+     *\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     *\n+     * @return mapping-binding-pattern node\n+     */\n+    private STNode parseMappingBindingPattern() {\n+        startContext(ParserRuleContext.MAPPING_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBrace = parseOpenBrace();\n+\n+        STNode mappingBindingPatternMember = parseMappingBindingPatternMember();\n+        bindingPatterns.add(mappingBindingPatternMember);\n+\n+        // parsing the main chunck of mapping-binding-pattern\n+        STToken token = peek(); // get next valid token\n+        STNode mappingBindingPatternRhs = null;\n+        while (!isEndOfMappingBindingPattern(token.kind) &&\n+                mappingBindingPatternMember.kind != SyntaxKind.REST_BINDING_PATTERN) {\n+            mappingBindingPatternRhs = parseMappingBindingpatternRhs(token.kind);\n+            if (mappingBindingPatternRhs == null) {\n+                break;\n+            }\n+\n+            bindingPatterns.add(mappingBindingPatternRhs);\n+            mappingBindingPatternMember = parseMappingBindingPatternMember();\n+            bindingPatterns.add(mappingBindingPatternMember);\n+            token = peek();\n+        }\n+\n+        STNode closeBrace = parseCloseBrace();\n+\n+        // seperating out the rest-binding-pattern\n+        STNode restBindingPattern;\n+        if (mappingBindingPatternMember.kind == SyntaxKind.REST_BINDING_PATTERN) {\n+            restBindingPattern = bindingPatterns.remove(bindingPatterns.size() - 1);\n+        } else {\n+            restBindingPattern = STNodeFactory.createEmptyNode();\n+        }\n+\n+        STNode bindingPatternsNode = STNodeFactory.createNodeList(bindingPatterns);\n+        endContext();\n+        return STNodeFactory.createMappingBindingPatternNode(openBrace, bindingPatternsNode, restBindingPattern,\n+                closeBrace);\n+    }\n+\n+    /**\n+     * Parse mapping-binding-pattern entry.\n+     *\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     *\n+     * @return mapping-binding-pattern node\n+     */\n+    private STNode parseMappingBindingPatternMember() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case ELLIPSIS_TOKEN:\n+                return parseRestBindingPattern();\n+            default:\n+                return parseFieldBindingPattern();\n+        }\n+    }\n+\n+    private STNode parseMappingBindingpatternRhs() {\n+        return parseMappingBindingpatternRhs(peek().kind);\n+    }\n+\n+    private STNode parseMappingBindingpatternRhs(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case COMMA_TOKEN:\n+                return parseComma();\n+            case CLOSE_BRACE_TOKEN:\n+                return null;\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.MAPPING_BINDING_PATTERN_END_OR_CONTINUE);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseMappingBindingpatternRhs(solution.tokenKind);\n+        }\n+    }\n+\n+    /**\n+     * Parse field-binding-pattern.\n+     *\n+     * field-binding-pattern := field-name : binding-pattern | varname\n+     *\n+     * @return field-binding-pattern node\n+     */\n+    private STNode parseFieldBindingPattern() {\n+        startContext(ParserRuleContext.FIELD_BINDING_PATTERN);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0Mzk4Mw=="}, "originalCommit": {"oid": "a9e616c312e66de69a60a209f2af8be80c64dd5c"}, "originalPosition": 130}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4MzU5MjUzOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwNDowMDoyMFrOGa4pTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwNDowMDoyMFrOGa4pTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0NDIzNw==", "bodyText": "MAPPING_BINDING_PATTERN_MEMBER", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23479#discussion_r430844237", "createdAt": "2020-05-27T04:00:20Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -397,14 +397,24 @@\n             { ParserRuleContext.CLOSE_PARENTHESIS, ParserRuleContext.TYPE_DESCRIPTOR };\n \n     private static final ParserRuleContext[] BINDING_PATTERN =\n-            { ParserRuleContext.CAPTURE_BINDING_PATTERN, ParserRuleContext.LIST_BINDING_PATTERN };\n+            { ParserRuleContext.CAPTURE_BINDING_PATTERN, ParserRuleContext.LIST_BINDING_PATTERN,\n+                    ParserRuleContext.MAPPING_BINDING_PATTERN};\n \n     private static final ParserRuleContext[] LIST_BINDING_PATTERN_CONTENTS =\n             { ParserRuleContext.REST_BINDING_PATTERN, ParserRuleContext.BINDING_PATTERN };\n \n+    private static final ParserRuleContext[] MAPPING_BINDING_PATTERN_CONTENTS =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9e616c312e66de69a60a209f2af8be80c64dd5c"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4MzY3MzExOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwNDo1NjoyOFrOGa5aQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxMDozMDoxOFrOGbDO6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg1Njc3MA==", "bodyText": "Next rule should be \"colon, comma, or close bracket\"", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23479#discussion_r430856770", "createdAt": "2020-05-27T04:56:28Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -3049,7 +3096,11 @@ private ParserRuleContext getNextRuleForVarName() {\n             return getNextRuleForTypedBindingPattern();\n         } else if (parentCtx == ParserRuleContext.REST_BINDING_PATTERN) {\n             return getNextRuleForTypedBindingPattern();\n-        } else if (isStatement(parentCtx) || parentCtx == ParserRuleContext.LISTENER_DECL ||\n+        } else if (parentCtx == ParserRuleContext.FIELD_BINDING_PATTERN) {\n+            return getNextRuleForTypedBindingPattern();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9e616c312e66de69a60a209f2af8be80c64dd5c"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg2MjQzNw==", "bodyText": "thats what that method returns", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23479#discussion_r430862437", "createdAt": "2020-05-27T05:19:28Z", "author": {"login": "m36dot"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -3049,7 +3096,11 @@ private ParserRuleContext getNextRuleForVarName() {\n             return getNextRuleForTypedBindingPattern();\n         } else if (parentCtx == ParserRuleContext.REST_BINDING_PATTERN) {\n             return getNextRuleForTypedBindingPattern();\n-        } else if (isStatement(parentCtx) || parentCtx == ParserRuleContext.LISTENER_DECL ||\n+        } else if (parentCtx == ParserRuleContext.FIELD_BINDING_PATTERN) {\n+            return getNextRuleForTypedBindingPattern();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg1Njc3MA=="}, "originalCommit": {"oid": "a9e616c312e66de69a60a209f2af8be80c64dd5c"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTAxNzcwNw==", "bodyText": "But thats a bit conceptually wrong. Here its like saying next rule for the type-binding pattern can be a colon. But no typed-binding pattern can be followed by a colon.\nI think the root cause is using var-name to represent field-name. Both of them are identifiers, but in different contexts.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23479#discussion_r431017707", "createdAt": "2020-05-27T10:30:18Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -3049,7 +3096,11 @@ private ParserRuleContext getNextRuleForVarName() {\n             return getNextRuleForTypedBindingPattern();\n         } else if (parentCtx == ParserRuleContext.REST_BINDING_PATTERN) {\n             return getNextRuleForTypedBindingPattern();\n-        } else if (isStatement(parentCtx) || parentCtx == ParserRuleContext.LISTENER_DECL ||\n+        } else if (parentCtx == ParserRuleContext.FIELD_BINDING_PATTERN) {\n+            return getNextRuleForTypedBindingPattern();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg1Njc3MA=="}, "originalCommit": {"oid": "a9e616c312e66de69a60a209f2af8be80c64dd5c"}, "originalPosition": 134}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4MzY4NTE3OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-treegen/src/main/resources/syntax_tree_descriptor.json", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwNTowNDowOVrOGa5hfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwNTowNDowOVrOGa5hfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg1ODYyMw==", "bodyText": "Since both of these exist together, I think we should have two separate representations for the two kinds of field-binding-patterns", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23479#discussion_r430858623", "createdAt": "2020-05-27T05:04:09Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-treegen/src/main/resources/syntax_tree_descriptor.json", "diffHunk": "@@ -2917,6 +2917,52 @@\n                 }\n             ]\n         },\n+        {\n+            \"name\": \"MappingBindingPatternNode\",\n+            \"base\": \"BindingPatternNode\",\n+            \"kind\": \"MAPPING_BINDING_PATTERN\",\n+            \"attributes\": [\n+                {\n+                    \"name\": \"openBrace\",\n+                    \"type\": \"Token\"\n+                },\n+                {\n+                    \"name\": \"fieldBindingPatterns\",\n+                    \"type\": \"FieldBindingPatternNode\",\n+                    \"occurrences\": \"MULTIPLE_SEPARATED\"\n+                },\n+                {\n+                    \"name\": \"restBindingPattern\",\n+                    \"type\": \"RestBindingPatternNode\",\n+                    \"isOptional\": true\n+                },\n+                {\n+                    \"name\": \"closeBrace\",\n+                    \"type\": \"Token\"\n+                }\n+            ]\n+        },\n+        {\n+            \"name\": \"FieldBindingPatternNode\",\n+            \"base\": \"Node\",\n+            \"kind\": \"FIELD_BINDING_PATTERN\",\n+            \"attributes\": [\n+                {\n+                    \"name\": \"variableName\",\n+                    \"type\": \"SimpleNameReferenceNode\"\n+                },\n+                {\n+                    \"name\": \"colon\",\n+                    \"type\": \"Token\",\n+                    \"isOptional\": true\n+                },\n+                {\n+                    \"name\": \"bindingPattern\",\n+                    \"type\": \"BindingPatternNode\",\n+                    \"isOptional\": true\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9e616c312e66de69a60a209f2af8be80c64dd5c"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4MzY5MDUzOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwNTowNzoyM1rOGa5kpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwNTowNzoyM1rOGa5kpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg1OTQzMA==", "bodyText": "Since this can be either field-name or variable-name, we shouldn't use parseVariableName().\nPlease refer to parseWaitField() and parseReceiveField(), those has a similar scenarios.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23479#discussion_r430859430", "createdAt": "2020-05-27T05:07:23Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -10208,6 +10212,149 @@ private Boolean isFollowTypedBindingPattern(SyntaxKind tokenKind) {\n         }\n     }\n \n+    /**\n+     * Parse mapping-binding-patterns.\n+     *\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     *\n+     * @return mapping-binding-pattern node\n+     */\n+    private STNode parseMappingBindingPattern() {\n+        startContext(ParserRuleContext.MAPPING_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBrace = parseOpenBrace();\n+\n+        STNode mappingBindingPatternMember = parseMappingBindingPatternMember();\n+        bindingPatterns.add(mappingBindingPatternMember);\n+\n+        // parsing the main chunck of mapping-binding-pattern\n+        STToken token = peek(); // get next valid token\n+        STNode mappingBindingPatternRhs = null;\n+        while (!isEndOfMappingBindingPattern(token.kind) &&\n+                mappingBindingPatternMember.kind != SyntaxKind.REST_BINDING_PATTERN) {\n+            mappingBindingPatternRhs = parseMappingBindingpatternRhs(token.kind);\n+            if (mappingBindingPatternRhs == null) {\n+                break;\n+            }\n+\n+            bindingPatterns.add(mappingBindingPatternRhs);\n+            mappingBindingPatternMember = parseMappingBindingPatternMember();\n+            bindingPatterns.add(mappingBindingPatternMember);\n+            token = peek();\n+        }\n+\n+        STNode closeBrace = parseCloseBrace();\n+\n+        // seperating out the rest-binding-pattern\n+        STNode restBindingPattern;\n+        if (mappingBindingPatternMember.kind == SyntaxKind.REST_BINDING_PATTERN) {\n+            restBindingPattern = bindingPatterns.remove(bindingPatterns.size() - 1);\n+        } else {\n+            restBindingPattern = STNodeFactory.createEmptyNode();\n+        }\n+\n+        STNode bindingPatternsNode = STNodeFactory.createNodeList(bindingPatterns);\n+        endContext();\n+        return STNodeFactory.createMappingBindingPatternNode(openBrace, bindingPatternsNode, restBindingPattern,\n+                closeBrace);\n+    }\n+\n+    /**\n+     * Parse mapping-binding-pattern entry.\n+     *\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     *\n+     * @return mapping-binding-pattern node\n+     */\n+    private STNode parseMappingBindingPatternMember() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case ELLIPSIS_TOKEN:\n+                return parseRestBindingPattern();\n+            default:\n+                return parseFieldBindingPattern();\n+        }\n+    }\n+\n+    private STNode parseMappingBindingpatternRhs() {\n+        return parseMappingBindingpatternRhs(peek().kind);\n+    }\n+\n+    private STNode parseMappingBindingpatternRhs(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case COMMA_TOKEN:\n+                return parseComma();\n+            case CLOSE_BRACE_TOKEN:\n+                return null;\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.MAPPING_BINDING_PATTERN_END_OR_CONTINUE);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseMappingBindingpatternRhs(solution.tokenKind);\n+        }\n+    }\n+\n+    /**\n+     * Parse field-binding-pattern.\n+     *\n+     * field-binding-pattern := field-name : binding-pattern | varname\n+     *\n+     * @return field-binding-pattern node\n+     */\n+    private STNode parseFieldBindingPattern() {\n+        startContext(ParserRuleContext.FIELD_BINDING_PATTERN);\n+        STNode fieldName = parseVariableName();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9e616c312e66de69a60a209f2af8be80c64dd5c"}, "originalPosition": 131}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3604, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}