{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk0MDQzODM4", "number": 26137, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwNzo0MjowNVrOErDWPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QwNjoxMDo1MFrOEs4Q_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNTc5MDY4OnYy", "diffSide": "RIGHT", "path": "misc/testerina/modules/testerina-runtime/src/main/java/org/ballerinalang/test/runtime/entity/CoverageReport.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwNzo0MjowNVrOHdmhfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwODowOToyOFrOHdnh-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDgwMTkxNw==", "bodyText": "Lets resolve each child directory. i.e. targetDirPath.resolve(\"caches\").resolve(\"jar_cache\").resolve(orgName)", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26137#discussion_r500801917", "createdAt": "2020-10-07T07:42:05Z", "author": {"login": "azinneera"}, "path": "misc/testerina/modules/testerina-runtime/src/main/java/org/ballerinalang/test/runtime/entity/CoverageReport.java", "diffHunk": "@@ -68,6 +69,9 @@ public CoverageReport(Path sourceJarPath, Path targetDirPath, String orgName, St\n         this.classesDirectory = projectDir.resolve(TesterinaConstants.BIN_DIR);\n         this.executionDataFile = projectDir.resolve(TesterinaConstants.EXEC_FILE_NAME);\n         this.execFileLoader = new ExecFileLoader();\n+\n+        this.jarCache = targetDirPath.resolve(\"caches/jar_cache/\").resolve(orgName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b8f6976bf2a4e7230da0a684b0a04d73ab8407d6"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDgwMjE2MQ==", "bodyText": "Applies to L74 as well.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26137#discussion_r500802161", "createdAt": "2020-10-07T07:42:28Z", "author": {"login": "azinneera"}, "path": "misc/testerina/modules/testerina-runtime/src/main/java/org/ballerinalang/test/runtime/entity/CoverageReport.java", "diffHunk": "@@ -68,6 +69,9 @@ public CoverageReport(Path sourceJarPath, Path targetDirPath, String orgName, St\n         this.classesDirectory = projectDir.resolve(TesterinaConstants.BIN_DIR);\n         this.executionDataFile = projectDir.resolve(TesterinaConstants.EXEC_FILE_NAME);\n         this.execFileLoader = new ExecFileLoader();\n+\n+        this.jarCache = targetDirPath.resolve(\"caches/jar_cache/\").resolve(orgName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDgwMTkxNw=="}, "originalCommit": {"oid": "b8f6976bf2a4e7230da0a684b0a04d73ab8407d6"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDgxODQyNQ==", "bodyText": "Changed to resolve each child directory", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26137#discussion_r500818425", "createdAt": "2020-10-07T08:09:28Z", "author": {"login": "Ibaqu"}, "path": "misc/testerina/modules/testerina-runtime/src/main/java/org/ballerinalang/test/runtime/entity/CoverageReport.java", "diffHunk": "@@ -68,6 +69,9 @@ public CoverageReport(Path sourceJarPath, Path targetDirPath, String orgName, St\n         this.classesDirectory = projectDir.resolve(TesterinaConstants.BIN_DIR);\n         this.executionDataFile = projectDir.resolve(TesterinaConstants.EXEC_FILE_NAME);\n         this.execFileLoader = new ExecFileLoader();\n+\n+        this.jarCache = targetDirPath.resolve(\"caches/jar_cache/\").resolve(orgName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDgwMTkxNw=="}, "originalCommit": {"oid": "b8f6976bf2a4e7230da0a684b0a04d73ab8407d6"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNTgwMzA1OnYy", "diffSide": "RIGHT", "path": "misc/testerina/modules/testerina-runtime/src/main/java/org/ballerinalang/test/runtime/entity/ModuleCoverage.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwNzo0NToxNlrOHdmo6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwODowOTozOFrOHdnibQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDgwMzgxNw==", "bodyText": "unnecessary new lines", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26137#discussion_r500803817", "createdAt": "2020-10-07T07:45:16Z", "author": {"login": "azinneera"}, "path": "misc/testerina/modules/testerina-runtime/src/main/java/org/ballerinalang/test/runtime/entity/ModuleCoverage.java", "diffHunk": "@@ -1,3 +1,5 @@\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b8f6976bf2a4e7230da0a684b0a04d73ab8407d6"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDgxODU0MQ==", "bodyText": "Removed new lines", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26137#discussion_r500818541", "createdAt": "2020-10-07T08:09:38Z", "author": {"login": "Ibaqu"}, "path": "misc/testerina/modules/testerina-runtime/src/main/java/org/ballerinalang/test/runtime/entity/ModuleCoverage.java", "diffHunk": "@@ -1,3 +1,5 @@\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDgwMzgxNw=="}, "originalCommit": {"oid": "b8f6976bf2a4e7230da0a684b0a04d73ab8407d6"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1NDkyNzIwOnYy", "diffSide": "RIGHT", "path": "misc/testerina/modules/testerina-runtime/src/main/java/org/ballerinalang/test/runtime/entity/CoverageReport.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QwNjowMjo0NFrOHgWj8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QwNzo1NDo1OVrOHgZ9Lw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzY4NjEyOA==", "bodyText": "How did we come up with this value as 5 for maxDepth?\nShall we define it as a constant?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26137#discussion_r503686128", "createdAt": "2020-10-13T06:02:44Z", "author": {"login": "Dilhasha"}, "path": "misc/testerina/modules/testerina-runtime/src/main/java/org/ballerinalang/test/runtime/entity/CoverageReport.java", "diffHunk": "@@ -76,60 +80,94 @@ public CoverageReport(Path sourceJarPath, Path targetDirPath, String orgName, St\n      * @throws IOException when file operations are failed\n      */\n     public void generateReport() throws IOException {\n-        try {\n-            CodeCoverageUtils.unzipCompiledSource(sourceJarPath, projectDir, orgName, moduleName, version);\n-        } catch (NoSuchFileException e) {\n+\n+        // Obtain a path list of all the .jar files generated\n+        List<Path> pathList;\n+        try (Stream<Path> walk = Files.walk(this.jarCache, 5)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e92a4c0edf72e515749c1a633c3d113fedcba84"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzc0MTc0Mw==", "bodyText": "Defined the Depth as a constant in TesterinaConstants", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26137#discussion_r503741743", "createdAt": "2020-10-13T07:54:59Z", "author": {"login": "Ibaqu"}, "path": "misc/testerina/modules/testerina-runtime/src/main/java/org/ballerinalang/test/runtime/entity/CoverageReport.java", "diffHunk": "@@ -76,60 +80,94 @@ public CoverageReport(Path sourceJarPath, Path targetDirPath, String orgName, St\n      * @throws IOException when file operations are failed\n      */\n     public void generateReport() throws IOException {\n-        try {\n-            CodeCoverageUtils.unzipCompiledSource(sourceJarPath, projectDir, orgName, moduleName, version);\n-        } catch (NoSuchFileException e) {\n+\n+        // Obtain a path list of all the .jar files generated\n+        List<Path> pathList;\n+        try (Stream<Path> walk = Files.walk(this.jarCache, 5)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzY4NjEyOA=="}, "originalCommit": {"oid": "5e92a4c0edf72e515749c1a633c3d113fedcba84"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1NDkyOTg2OnYy", "diffSide": "RIGHT", "path": "misc/testerina/modules/testerina-runtime/src/main/java/org/ballerinalang/test/runtime/entity/CoverageReport.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QwNjowMzo1NFrOHgWlig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QwNjozMToxOFrOHgXOHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzY4NjUzOA==", "bodyText": "Is this a TODO?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26137#discussion_r503686538", "createdAt": "2020-10-13T06:03:54Z", "author": {"login": "Dilhasha"}, "path": "misc/testerina/modules/testerina-runtime/src/main/java/org/ballerinalang/test/runtime/entity/CoverageReport.java", "diffHunk": "@@ -76,60 +80,94 @@ public CoverageReport(Path sourceJarPath, Path targetDirPath, String orgName, St\n      * @throws IOException when file operations are failed\n      */\n     public void generateReport() throws IOException {\n-        try {\n-            CodeCoverageUtils.unzipCompiledSource(sourceJarPath, projectDir, orgName, moduleName, version);\n-        } catch (NoSuchFileException e) {\n+\n+        // Obtain a path list of all the .jar files generated\n+        List<Path> pathList;\n+        try (Stream<Path> walk = Files.walk(this.jarCache, 5)) {\n+            pathList = walk.map(path -> path).filter(f -> f.toString().endsWith(version + \".jar\")).collect(\n+                    Collectors.toList());\n+        } catch (IOException e) {\n             return;\n         }\n \n-        execFileLoader.load(executionDataFile.toFile());\n+        if (!pathList.isEmpty()) {\n+            // For each jar file found, we unzip it for this particular module\n+            for (Path moduleJarPath : pathList) {\n+                try {\n+                    // Creates coverage folder with each class per module\n+                    CodeCoverageUtils.unzipCompiledSource(moduleJarPath, projectDir, orgName, moduleName, version);\n+                } catch (NoSuchFileException e) {\n+                    return;\n+                }\n+            }\n+\n+            execFileLoader.load(executionDataFile.toFile());\n+            final IBundleCoverage bundleCoverage = analyzeStructure();\n+            createReport(bundleCoverage);\n+        } else {\n+            String msg = \"Unable to generate code coverage for the module \" + moduleName + \". Jar files dont exist.\";\n+            throw new NoSuchFileException(msg);\n+        }\n \n-        final IBundleCoverage bundleCoverage = analyzeStructure();\n-        createReport(bundleCoverage);\n     }\n \n     private IBundleCoverage analyzeStructure() throws IOException {\n         final CoverageBuilder coverageBuilder = new CoverageBuilder();\n-        final Analyzer analyzer = new Analyzer(\n-                execFileLoader.getExecutionDataStore(), coverageBuilder);\n+        final Analyzer analyzer = new Analyzer(execFileLoader.getExecutionDataStore(), coverageBuilder);\n         analyzer.analyzeAll(classesDirectory.toFile());\n         return coverageBuilder.getBundle(title);\n     }\n \n     private void createReport(final IBundleCoverage bundleCoverage) {\n-        boolean containsSourceFiles;\n+        boolean containsSourceFiles = true;\n \n         for (IPackageCoverage packageCoverage : bundleCoverage.getPackages()) {\n+            // I havent tested the behaviour of single files", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e92a4c0edf72e515749c1a633c3d113fedcba84"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzY5NjkyNg==", "bodyText": "Code coverage is actually not supported for single files. I checked. I will remove this TODO comment", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26137#discussion_r503696926", "createdAt": "2020-10-13T06:31:18Z", "author": {"login": "Ibaqu"}, "path": "misc/testerina/modules/testerina-runtime/src/main/java/org/ballerinalang/test/runtime/entity/CoverageReport.java", "diffHunk": "@@ -76,60 +80,94 @@ public CoverageReport(Path sourceJarPath, Path targetDirPath, String orgName, St\n      * @throws IOException when file operations are failed\n      */\n     public void generateReport() throws IOException {\n-        try {\n-            CodeCoverageUtils.unzipCompiledSource(sourceJarPath, projectDir, orgName, moduleName, version);\n-        } catch (NoSuchFileException e) {\n+\n+        // Obtain a path list of all the .jar files generated\n+        List<Path> pathList;\n+        try (Stream<Path> walk = Files.walk(this.jarCache, 5)) {\n+            pathList = walk.map(path -> path).filter(f -> f.toString().endsWith(version + \".jar\")).collect(\n+                    Collectors.toList());\n+        } catch (IOException e) {\n             return;\n         }\n \n-        execFileLoader.load(executionDataFile.toFile());\n+        if (!pathList.isEmpty()) {\n+            // For each jar file found, we unzip it for this particular module\n+            for (Path moduleJarPath : pathList) {\n+                try {\n+                    // Creates coverage folder with each class per module\n+                    CodeCoverageUtils.unzipCompiledSource(moduleJarPath, projectDir, orgName, moduleName, version);\n+                } catch (NoSuchFileException e) {\n+                    return;\n+                }\n+            }\n+\n+            execFileLoader.load(executionDataFile.toFile());\n+            final IBundleCoverage bundleCoverage = analyzeStructure();\n+            createReport(bundleCoverage);\n+        } else {\n+            String msg = \"Unable to generate code coverage for the module \" + moduleName + \". Jar files dont exist.\";\n+            throw new NoSuchFileException(msg);\n+        }\n \n-        final IBundleCoverage bundleCoverage = analyzeStructure();\n-        createReport(bundleCoverage);\n     }\n \n     private IBundleCoverage analyzeStructure() throws IOException {\n         final CoverageBuilder coverageBuilder = new CoverageBuilder();\n-        final Analyzer analyzer = new Analyzer(\n-                execFileLoader.getExecutionDataStore(), coverageBuilder);\n+        final Analyzer analyzer = new Analyzer(execFileLoader.getExecutionDataStore(), coverageBuilder);\n         analyzer.analyzeAll(classesDirectory.toFile());\n         return coverageBuilder.getBundle(title);\n     }\n \n     private void createReport(final IBundleCoverage bundleCoverage) {\n-        boolean containsSourceFiles;\n+        boolean containsSourceFiles = true;\n \n         for (IPackageCoverage packageCoverage : bundleCoverage.getPackages()) {\n+            // I havent tested the behaviour of single files", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzY4NjUzOA=="}, "originalCommit": {"oid": "5e92a4c0edf72e515749c1a633c3d113fedcba84"}, "originalPosition": 104}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1NDk0NjU0OnYy", "diffSide": "RIGHT", "path": "misc/testerina/modules/testerina-runtime/src/main/java/org/ballerinalang/test/runtime/entity/CoverageReport.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QwNjoxMDo1MFrOHgWvLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QwNzo1Mzo1OVrOHgZ60w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzY4OTAwNA==", "bodyText": "The module name can include \".\" as well right?\nLet's assume we have a project with 2 modules as \"module_test\" & \"module.test\", will this have an impact?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26137#discussion_r503689004", "createdAt": "2020-10-13T06:10:50Z", "author": {"login": "Dilhasha"}, "path": "misc/testerina/modules/testerina-runtime/src/main/java/org/ballerinalang/test/runtime/entity/CoverageReport.java", "diffHunk": "@@ -76,60 +80,94 @@ public CoverageReport(Path sourceJarPath, Path targetDirPath, String orgName, St\n      * @throws IOException when file operations are failed\n      */\n     public void generateReport() throws IOException {\n-        try {\n-            CodeCoverageUtils.unzipCompiledSource(sourceJarPath, projectDir, orgName, moduleName, version);\n-        } catch (NoSuchFileException e) {\n+\n+        // Obtain a path list of all the .jar files generated\n+        List<Path> pathList;\n+        try (Stream<Path> walk = Files.walk(this.jarCache, 5)) {\n+            pathList = walk.map(path -> path).filter(f -> f.toString().endsWith(version + \".jar\")).collect(\n+                    Collectors.toList());\n+        } catch (IOException e) {\n             return;\n         }\n \n-        execFileLoader.load(executionDataFile.toFile());\n+        if (!pathList.isEmpty()) {\n+            // For each jar file found, we unzip it for this particular module\n+            for (Path moduleJarPath : pathList) {\n+                try {\n+                    // Creates coverage folder with each class per module\n+                    CodeCoverageUtils.unzipCompiledSource(moduleJarPath, projectDir, orgName, moduleName, version);\n+                } catch (NoSuchFileException e) {\n+                    return;\n+                }\n+            }\n+\n+            execFileLoader.load(executionDataFile.toFile());\n+            final IBundleCoverage bundleCoverage = analyzeStructure();\n+            createReport(bundleCoverage);\n+        } else {\n+            String msg = \"Unable to generate code coverage for the module \" + moduleName + \". Jar files dont exist.\";\n+            throw new NoSuchFileException(msg);\n+        }\n \n-        final IBundleCoverage bundleCoverage = analyzeStructure();\n-        createReport(bundleCoverage);\n     }\n \n     private IBundleCoverage analyzeStructure() throws IOException {\n         final CoverageBuilder coverageBuilder = new CoverageBuilder();\n-        final Analyzer analyzer = new Analyzer(\n-                execFileLoader.getExecutionDataStore(), coverageBuilder);\n+        final Analyzer analyzer = new Analyzer(execFileLoader.getExecutionDataStore(), coverageBuilder);\n         analyzer.analyzeAll(classesDirectory.toFile());\n         return coverageBuilder.getBundle(title);\n     }\n \n     private void createReport(final IBundleCoverage bundleCoverage) {\n-        boolean containsSourceFiles;\n+        boolean containsSourceFiles = true;\n \n         for (IPackageCoverage packageCoverage : bundleCoverage.getPackages()) {\n+            // I havent tested the behaviour of single files\n             if (TesterinaConstants.DOT.equals(moduleName)) {\n                 containsSourceFiles = packageCoverage.getName().isEmpty();\n-            } else {\n-                containsSourceFiles = packageCoverage.getName().contains(orgName + \"/\" + moduleName);\n             }\n+\n             if (containsSourceFiles) {\n                 for (ISourceFileCoverage sourceFileCoverage : packageCoverage.getSourceFiles()) {\n-                    if (sourceFileCoverage.getName().contains(BLangConstants.BLANG_SRC_FILE_SUFFIX) &&\n-                            !sourceFileCoverage.getName().contains(\"tests/\")) {\n+\n+                    // Extract the Module name individually for each source file\n+                    // This is done since some source files come from other modules\n+                    // sourceFileCoverage : \"<orgname>/<moduleName>:<version>\n+                    String sourceFileModule = sourceFileCoverage.getPackageName().split(\"/\")[1];\n+\n+                    if (sourceFileCoverage.getName().contains(BLangConstants.BLANG_SRC_FILE_SUFFIX)\n+                            && !sourceFileCoverage.getName().contains(\"tests/\")) {\n                         List<Integer> coveredLines = new ArrayList<>();\n                         List<Integer> missedLines = new ArrayList<>();\n+\n                         for (int i = sourceFileCoverage.getFirstLine(); i <= sourceFileCoverage.getLastLine(); i++) {\n                             ILine line = sourceFileCoverage.getLine(i);\n-                            if (line.getInstructionCounter().getTotalCount() == 0\n-                                    && line.getBranchCounter().getTotalCount() == 0) {\n+\n+                            if (line.getInstructionCounter().getTotalCount() == 0 &&\n+                                    line.getBranchCounter().getTotalCount() == 0) {\n                                 // do nothing. This is to capture the empty lines\n-                            } else if ((line.getBranchCounter().getCoveredCount() == 0\n-                                    && line.getBranchCounter().getMissedCount() > 0)\n-                                    || line.getStatus() == NOT_COVERED) {\n+                            } else if ((line.getBranchCounter().getCoveredCount() == 0 &&\n+                                    line.getBranchCounter().getMissedCount() > 0) || line.getStatus() == NOT_COVERED) {\n                                 missedLines.add(i);\n                             } else if (line.getStatus() == PARTLY_COVERED || line.getStatus() == FULLY_COVERED) {\n                                 coveredLines.add(i);\n                             }\n                         }\n-                        ModuleCoverage.getInstance().addSourceFileCoverage(moduleName, sourceFileCoverage.getName(),\n-                                coveredLines, missedLines);\n+\n+                        // Only add the source files that belong to the same module\n+                        if (sourceFileModule.equals(moduleName)) {\n+                            ModuleCoverage.getInstance().addSourceFileCoverage(sourceFileModule,\n+                                    sourceFileCoverage.getName(), coveredLines, missedLines);\n+                        } else {\n+                            String jsonCachePath = this.jsonCache.toString() + \"/\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e92a4c0edf72e515749c1a633c3d113fedcba84"}, "originalPosition": 152}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzcwNTQ1Nw==", "bodyText": "Yes. This certainly is a problem. Although it doesn't cause any impact to the overall functionality, it still creates unnecessary cache files when a module has '_' in its name.\nI will fix this to only consider the version when replacing '_' with '.'", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26137#discussion_r503705457", "createdAt": "2020-10-13T06:51:06Z", "author": {"login": "Ibaqu"}, "path": "misc/testerina/modules/testerina-runtime/src/main/java/org/ballerinalang/test/runtime/entity/CoverageReport.java", "diffHunk": "@@ -76,60 +80,94 @@ public CoverageReport(Path sourceJarPath, Path targetDirPath, String orgName, St\n      * @throws IOException when file operations are failed\n      */\n     public void generateReport() throws IOException {\n-        try {\n-            CodeCoverageUtils.unzipCompiledSource(sourceJarPath, projectDir, orgName, moduleName, version);\n-        } catch (NoSuchFileException e) {\n+\n+        // Obtain a path list of all the .jar files generated\n+        List<Path> pathList;\n+        try (Stream<Path> walk = Files.walk(this.jarCache, 5)) {\n+            pathList = walk.map(path -> path).filter(f -> f.toString().endsWith(version + \".jar\")).collect(\n+                    Collectors.toList());\n+        } catch (IOException e) {\n             return;\n         }\n \n-        execFileLoader.load(executionDataFile.toFile());\n+        if (!pathList.isEmpty()) {\n+            // For each jar file found, we unzip it for this particular module\n+            for (Path moduleJarPath : pathList) {\n+                try {\n+                    // Creates coverage folder with each class per module\n+                    CodeCoverageUtils.unzipCompiledSource(moduleJarPath, projectDir, orgName, moduleName, version);\n+                } catch (NoSuchFileException e) {\n+                    return;\n+                }\n+            }\n+\n+            execFileLoader.load(executionDataFile.toFile());\n+            final IBundleCoverage bundleCoverage = analyzeStructure();\n+            createReport(bundleCoverage);\n+        } else {\n+            String msg = \"Unable to generate code coverage for the module \" + moduleName + \". Jar files dont exist.\";\n+            throw new NoSuchFileException(msg);\n+        }\n \n-        final IBundleCoverage bundleCoverage = analyzeStructure();\n-        createReport(bundleCoverage);\n     }\n \n     private IBundleCoverage analyzeStructure() throws IOException {\n         final CoverageBuilder coverageBuilder = new CoverageBuilder();\n-        final Analyzer analyzer = new Analyzer(\n-                execFileLoader.getExecutionDataStore(), coverageBuilder);\n+        final Analyzer analyzer = new Analyzer(execFileLoader.getExecutionDataStore(), coverageBuilder);\n         analyzer.analyzeAll(classesDirectory.toFile());\n         return coverageBuilder.getBundle(title);\n     }\n \n     private void createReport(final IBundleCoverage bundleCoverage) {\n-        boolean containsSourceFiles;\n+        boolean containsSourceFiles = true;\n \n         for (IPackageCoverage packageCoverage : bundleCoverage.getPackages()) {\n+            // I havent tested the behaviour of single files\n             if (TesterinaConstants.DOT.equals(moduleName)) {\n                 containsSourceFiles = packageCoverage.getName().isEmpty();\n-            } else {\n-                containsSourceFiles = packageCoverage.getName().contains(orgName + \"/\" + moduleName);\n             }\n+\n             if (containsSourceFiles) {\n                 for (ISourceFileCoverage sourceFileCoverage : packageCoverage.getSourceFiles()) {\n-                    if (sourceFileCoverage.getName().contains(BLangConstants.BLANG_SRC_FILE_SUFFIX) &&\n-                            !sourceFileCoverage.getName().contains(\"tests/\")) {\n+\n+                    // Extract the Module name individually for each source file\n+                    // This is done since some source files come from other modules\n+                    // sourceFileCoverage : \"<orgname>/<moduleName>:<version>\n+                    String sourceFileModule = sourceFileCoverage.getPackageName().split(\"/\")[1];\n+\n+                    if (sourceFileCoverage.getName().contains(BLangConstants.BLANG_SRC_FILE_SUFFIX)\n+                            && !sourceFileCoverage.getName().contains(\"tests/\")) {\n                         List<Integer> coveredLines = new ArrayList<>();\n                         List<Integer> missedLines = new ArrayList<>();\n+\n                         for (int i = sourceFileCoverage.getFirstLine(); i <= sourceFileCoverage.getLastLine(); i++) {\n                             ILine line = sourceFileCoverage.getLine(i);\n-                            if (line.getInstructionCounter().getTotalCount() == 0\n-                                    && line.getBranchCounter().getTotalCount() == 0) {\n+\n+                            if (line.getInstructionCounter().getTotalCount() == 0 &&\n+                                    line.getBranchCounter().getTotalCount() == 0) {\n                                 // do nothing. This is to capture the empty lines\n-                            } else if ((line.getBranchCounter().getCoveredCount() == 0\n-                                    && line.getBranchCounter().getMissedCount() > 0)\n-                                    || line.getStatus() == NOT_COVERED) {\n+                            } else if ((line.getBranchCounter().getCoveredCount() == 0 &&\n+                                    line.getBranchCounter().getMissedCount() > 0) || line.getStatus() == NOT_COVERED) {\n                                 missedLines.add(i);\n                             } else if (line.getStatus() == PARTLY_COVERED || line.getStatus() == FULLY_COVERED) {\n                                 coveredLines.add(i);\n                             }\n                         }\n-                        ModuleCoverage.getInstance().addSourceFileCoverage(moduleName, sourceFileCoverage.getName(),\n-                                coveredLines, missedLines);\n+\n+                        // Only add the source files that belong to the same module\n+                        if (sourceFileModule.equals(moduleName)) {\n+                            ModuleCoverage.getInstance().addSourceFileCoverage(sourceFileModule,\n+                                    sourceFileCoverage.getName(), coveredLines, missedLines);\n+                        } else {\n+                            String jsonCachePath = this.jsonCache.toString() + \"/\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzY4OTAwNA=="}, "originalCommit": {"oid": "5e92a4c0edf72e515749c1a633c3d113fedcba84"}, "originalPosition": 152}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzc0MTEzOQ==", "bodyText": "I have added a function that deals with extracting the version and replacing the _ with .\nThis should only apply to the version and the module name will be spared.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26137#discussion_r503741139", "createdAt": "2020-10-13T07:53:59Z", "author": {"login": "Ibaqu"}, "path": "misc/testerina/modules/testerina-runtime/src/main/java/org/ballerinalang/test/runtime/entity/CoverageReport.java", "diffHunk": "@@ -76,60 +80,94 @@ public CoverageReport(Path sourceJarPath, Path targetDirPath, String orgName, St\n      * @throws IOException when file operations are failed\n      */\n     public void generateReport() throws IOException {\n-        try {\n-            CodeCoverageUtils.unzipCompiledSource(sourceJarPath, projectDir, orgName, moduleName, version);\n-        } catch (NoSuchFileException e) {\n+\n+        // Obtain a path list of all the .jar files generated\n+        List<Path> pathList;\n+        try (Stream<Path> walk = Files.walk(this.jarCache, 5)) {\n+            pathList = walk.map(path -> path).filter(f -> f.toString().endsWith(version + \".jar\")).collect(\n+                    Collectors.toList());\n+        } catch (IOException e) {\n             return;\n         }\n \n-        execFileLoader.load(executionDataFile.toFile());\n+        if (!pathList.isEmpty()) {\n+            // For each jar file found, we unzip it for this particular module\n+            for (Path moduleJarPath : pathList) {\n+                try {\n+                    // Creates coverage folder with each class per module\n+                    CodeCoverageUtils.unzipCompiledSource(moduleJarPath, projectDir, orgName, moduleName, version);\n+                } catch (NoSuchFileException e) {\n+                    return;\n+                }\n+            }\n+\n+            execFileLoader.load(executionDataFile.toFile());\n+            final IBundleCoverage bundleCoverage = analyzeStructure();\n+            createReport(bundleCoverage);\n+        } else {\n+            String msg = \"Unable to generate code coverage for the module \" + moduleName + \". Jar files dont exist.\";\n+            throw new NoSuchFileException(msg);\n+        }\n \n-        final IBundleCoverage bundleCoverage = analyzeStructure();\n-        createReport(bundleCoverage);\n     }\n \n     private IBundleCoverage analyzeStructure() throws IOException {\n         final CoverageBuilder coverageBuilder = new CoverageBuilder();\n-        final Analyzer analyzer = new Analyzer(\n-                execFileLoader.getExecutionDataStore(), coverageBuilder);\n+        final Analyzer analyzer = new Analyzer(execFileLoader.getExecutionDataStore(), coverageBuilder);\n         analyzer.analyzeAll(classesDirectory.toFile());\n         return coverageBuilder.getBundle(title);\n     }\n \n     private void createReport(final IBundleCoverage bundleCoverage) {\n-        boolean containsSourceFiles;\n+        boolean containsSourceFiles = true;\n \n         for (IPackageCoverage packageCoverage : bundleCoverage.getPackages()) {\n+            // I havent tested the behaviour of single files\n             if (TesterinaConstants.DOT.equals(moduleName)) {\n                 containsSourceFiles = packageCoverage.getName().isEmpty();\n-            } else {\n-                containsSourceFiles = packageCoverage.getName().contains(orgName + \"/\" + moduleName);\n             }\n+\n             if (containsSourceFiles) {\n                 for (ISourceFileCoverage sourceFileCoverage : packageCoverage.getSourceFiles()) {\n-                    if (sourceFileCoverage.getName().contains(BLangConstants.BLANG_SRC_FILE_SUFFIX) &&\n-                            !sourceFileCoverage.getName().contains(\"tests/\")) {\n+\n+                    // Extract the Module name individually for each source file\n+                    // This is done since some source files come from other modules\n+                    // sourceFileCoverage : \"<orgname>/<moduleName>:<version>\n+                    String sourceFileModule = sourceFileCoverage.getPackageName().split(\"/\")[1];\n+\n+                    if (sourceFileCoverage.getName().contains(BLangConstants.BLANG_SRC_FILE_SUFFIX)\n+                            && !sourceFileCoverage.getName().contains(\"tests/\")) {\n                         List<Integer> coveredLines = new ArrayList<>();\n                         List<Integer> missedLines = new ArrayList<>();\n+\n                         for (int i = sourceFileCoverage.getFirstLine(); i <= sourceFileCoverage.getLastLine(); i++) {\n                             ILine line = sourceFileCoverage.getLine(i);\n-                            if (line.getInstructionCounter().getTotalCount() == 0\n-                                    && line.getBranchCounter().getTotalCount() == 0) {\n+\n+                            if (line.getInstructionCounter().getTotalCount() == 0 &&\n+                                    line.getBranchCounter().getTotalCount() == 0) {\n                                 // do nothing. This is to capture the empty lines\n-                            } else if ((line.getBranchCounter().getCoveredCount() == 0\n-                                    && line.getBranchCounter().getMissedCount() > 0)\n-                                    || line.getStatus() == NOT_COVERED) {\n+                            } else if ((line.getBranchCounter().getCoveredCount() == 0 &&\n+                                    line.getBranchCounter().getMissedCount() > 0) || line.getStatus() == NOT_COVERED) {\n                                 missedLines.add(i);\n                             } else if (line.getStatus() == PARTLY_COVERED || line.getStatus() == FULLY_COVERED) {\n                                 coveredLines.add(i);\n                             }\n                         }\n-                        ModuleCoverage.getInstance().addSourceFileCoverage(moduleName, sourceFileCoverage.getName(),\n-                                coveredLines, missedLines);\n+\n+                        // Only add the source files that belong to the same module\n+                        if (sourceFileModule.equals(moduleName)) {\n+                            ModuleCoverage.getInstance().addSourceFileCoverage(sourceFileModule,\n+                                    sourceFileCoverage.getName(), coveredLines, missedLines);\n+                        } else {\n+                            String jsonCachePath = this.jsonCache.toString() + \"/\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzY4OTAwNA=="}, "originalCommit": {"oid": "5e92a4c0edf72e515749c1a633c3d113fedcba84"}, "originalPosition": 152}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4829, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}