{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMzOTc5MDY2", "number": 24057, "title": "Add lang-lib methods to improve JSON compatibility", "bodyText": "Purpose\nAdd following functions\n\nfromJsonWithType(json v, typedesc t) returns t|error\nfromJsonStringWithType(string str, typedesc t) returns t|error\ntoJson(anydata v) returns json\ntoJsonString(anydata v) returns string\n\nFixes #23335, #24247, #24625\nApproach\n\nDescribe how you are implementing the solutions along with the design details.\n\nSamples\n\nProvide high-level details about the samples related to this feature.\n\nRemarks\n\nList any other known issues, related PRs, TODO items, or any other notes related to the PR.\n\nCheck List\n\n Read the Contributing Guide\n Updated Change Log\n Checked Tooling Support (#)\n Added necessary tests\n\n Unit Tests\n Spec Conformance Tests\n Integration Tests\n Ballerina By Example Tests\n\n\n Increased Test Coverage\n Added necessary documentation\n\n API documentation\n Module documentation in Module.md files\n Ballerina By Examples", "createdAt": "2020-06-13T08:42:56Z", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057", "merged": true, "mergeCommit": {"oid": "93d924537a68e9e0dbdf7374d51347abb9c5a07a"}, "closed": true, "closedAt": "2020-07-16T15:32:07Z", "author": {"login": "dulajdilshan"}, "timelineItems": {"totalCount": 57, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcq5oG_AFqTQzMDEzMzAyNA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABc1hA6eAFqTQ0OTk2NjE2MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwMTMzMDI0", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#pullrequestreview-430133024", "createdAt": "2020-06-13T11:32:19Z", "commit": {"oid": "8077e15459944ea37f0c4a73d99bad2da6fe288f"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QxMTozMjoyMFrOGjXHjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QxNToyMDo0MFrOGjYAkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTczMjEwOA==", "bodyText": "I don't think this is where we should change. IMO we should do something like https://github.com/ballerina-platform/ballerina-lang/blob/master/bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/JSONParser.java#L64 because\n\nthere may be other non-array member string values that will not get changed to BString if we change only here.\n\nFor example, the following might fail\npublic function main() {\n    string st = \"\\\"hello\\\"\";\n    string j = <string> st.fromJsonString();\n}\n\nOn paths where changeForBString is already called and there are arrays present we'll be calling this method twice unnecessarily.\n\ne.g., \n  \n    \n      ballerina-lang/bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/JSONParser.java\n    \n    \n         Line 95\n      in\n      8077e15\n    \n    \n    \n    \n\n        \n          \n           return changeForBString(jsonObj);", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r439732108", "createdAt": "2020-06-13T11:32:20Z", "author": {"login": "MaryamZi"}, "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/JSONParser.java", "diffHunk": "@@ -687,7 +687,7 @@ public State transition(StateMachine sm, char[] buff, int i, int count) throws J\n                     ch = buff[i];\n                     sm.processLocation(ch);\n                     if (ch == sm.currentQuoteChar) {\n-                        ((ArrayValue) sm.currentJsonNode).append(sm.value());\n+                        ((ArrayValue) sm.currentJsonNode).append(changeForBString(sm.value()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8077e15459944ea37f0c4a73d99bad2da6fe288f"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTczMjcyOQ==", "bodyText": "Noticed some minor punctuation differences in the descriptions here and in the spec, shall we recheck and have the same as the ones in the spec for these functions?\nLet's also maintain the same order.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r439732729", "createdAt": "2020-06-13T11:42:54Z", "author": {"login": "MaryamZi"}, "path": "langlib/lang.value/src/main/ballerina/src/lang.value/value.bal", "diffHunk": "@@ -117,9 +117,26 @@ public function toString((any|error) v) returns string = external;\n \n # Returns the string that represents `v` in JSON format.\n #\n-# + v - json value", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8077e15459944ea37f0c4a73d99bad2da6fe288f"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTczOTUyNA==", "bodyText": "Please check the following example.\npublic function main() {\n    map<int> m = {a: 1, b: 2};\n    map<json> mj = <map<json>> m.toJson();\n\n    mj[\"c\"] = \"non-int json\";\n}\nThis currently fails with\n$ ballerina run xyz.bal\nCompiling source\n        xyz.bal\nRunning executables\n\nerror: {ballerina/lang.map}InherentTypeViolation message=invalid map insertion: expected value of type 'int', found 'string'\n        at xyz:main(xyz.bal:5)", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r439739524", "createdAt": "2020-06-13T13:30:08Z", "author": {"login": "MaryamZi"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.model.types.TypeKind;\n+import org.ballerinalang.natives.annotations.Argument;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+import org.ballerinalang.natives.annotations.ReturnType;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:toJson.\n+ * Converts a value of type `anydata` to `json`.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"toJson\",\n+        args = {\n+                @Argument(name = \"v\", type = TypeKind.ANYDATA),\n+        },\n+        returnType = {\n+                @ReturnType(type = TypeKind.JSON),\n+                @ReturnType(type = TypeKind.ERROR)\n+        },\n+        isPublic = true\n+)\n+public class ToJson {\n+\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object toJson(Strand strand, Object value) {\n+        if (value == null) {\n+            return null;\n+        }\n+\n+        BType sourceType = TypeChecker.getType(value);\n+        BType targetJsonType = BTypes.typeJSON;\n+        if (!TypeChecker.checkIsLikeType(value, targetJsonType, true)) {\n+            if (sourceType.getTag() >= TypeTags.XML_ELEMENT_TAG || sourceType.getTag() == TypeTags.XML_TAG) {\n+                return ToString.toString(strand, value);\n+            } else {\n+                throw createConversionError(value, targetJsonType);\n+            }\n+        }\n+\n+        // handle primitive values\n+        if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+            if (TypeChecker.checkIsType(value, targetJsonType)) {\n+                return value;\n+            } else {\n+                // Has to be a numeric conversion.\n+                return TypeConverter.convertValues(targetJsonType, value);\n+            }\n+        }\n+\n+        return convert((RefValue) value, targetJsonType, new ArrayList<>(), strand);\n+    }\n+\n+    private static Object convert(RefValue value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  Strand strand) {\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(CONSTRUCT_FROM_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE, value.getType()));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        Object newValue;\n+        switch (value.getType().getTag()) {\n+            case TypeTags.MAP_TAG:\n+            case TypeTags.RECORD_TYPE_TAG:\n+                newValue = convertMapToJson((MapValue<?, ?>) value, targetType, unresolvedValues, strand);\n+                break;\n+            case TypeTags.ARRAY_TAG:\n+            case TypeTags.TUPLE_TAG:\n+                newValue = convertArrayToJson((ArrayValue) value, targetType, unresolvedValues, strand);\n+                break;\n+            case TypeTags.XML_TAG:\n+            case TypeTags.XML_ELEMENT_TAG:\n+            case TypeTags.XML_COMMENT_TAG:\n+            case TypeTags.XML_PI_TAG:\n+            case TypeTags.XML_TEXT_TAG:\n+            case TypeTags.ERROR_TAG:\n+                newValue = value.copy(new HashMap<>());\n+                break;\n+            default:\n+                // should never reach here\n+                throw BallerinaErrors.createConversionError(value, targetType);\n+        }\n+\n+        unresolvedValues.remove(typeValuePair);\n+        return newValue;\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  boolean allowAmbiguity, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            return createError(CONSTRUCT_FROM_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+        List<BType> convertibleTypes;\n+        convertibleTypes = TypeConverter.getConvertibleTypes(value, targetType);\n+        if (convertibleTypes.isEmpty()) {\n+            throw createConversionError(value, targetType);\n+        } else if (!allowAmbiguity && convertibleTypes.size() > 1) {\n+            throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+        }\n+\n+        BType sourceType = TypeChecker.getType(value);\n+        BType matchingType = convertibleTypes.get(0);\n+        // handle primitive values\n+        if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+            if (TypeChecker.checkIsType(value, matchingType)) {\n+                return value;\n+            } else {\n+                // Has to be a numeric conversion.\n+                return TypeConverter.convertValues(matchingType, value);\n+            }\n+        }\n+\n+        return convert((RefValue) value, matchingType, unresolvedValues, strand);\n+    }\n+\n+    private static Object convertMapToJson(MapValue<?, ?> map, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                           Strand strand) {\n+        switch (targetType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+                MapValueImpl<BString, Object> newMap = new MapValueImpl<>(targetType);\n+                for (Map.Entry entry : map.entrySet()) {\n+                    BType constraintType = ((BMapType) targetType).getConstrainedType();\n+                    putToMap(newMap, entry, constraintType, unresolvedValues, strand);\n+                }\n+                return newMap;\n+            case TypeTags.JSON_TAG:\n+                BType matchingType = TypeConverter.resolveMatchingTypeForUnion(map, targetType);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8077e15459944ea37f0c4a73d99bad2da6fe288f"}, "originalPosition": 189}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc0NDY4NQ==", "bodyText": "This PR doesn't add .toJson() support for tables right?\nThe following fails at runtime\ntype Foo record {|\n    int id;\n    string str;\n|};\n\npublic function main() {\n    table<Foo> tb = table [\n        {id: 12, str: \"abc\"},\n        {id: 34, str: \"def\"}\n    ];\n\n    json j = tb.toJson();\n}\nballerina run xyz.bal\nCompiling source\n        xyz.bal\nRunning executables\n\nerror: {ballerina/lang.typedesc}ConversionError message='table<Foo>' value cannot be converted to 'json'\n        at ballerina.lang_value.1_0_0:toJson(value.bal:139)\n           xyz:main(xyz.bal:12)", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r439744685", "createdAt": "2020-06-13T14:49:40Z", "author": {"login": "MaryamZi"}, "path": "langlib/lang.value/src/main/ballerina/src/lang.value/value.bal", "diffHunk": "@@ -117,9 +117,26 @@ public function toString((any|error) v) returns string = external;\n \n # Returns the string that represents `v` in JSON format.\n #\n-# + v - json value\n+# + v - anydata value\n # + return - string representation of json\n-public function toJsonString(json v) returns string = external;\n+public function toJsonString(anydata v) returns string = external;\n+\n+# Converts a value of type `anydata` to `json`.\n+# This does a deep copy of `v` converting values that do\n+# not belong to json into values that do.\n+# A value of type `xml` is converted into a string as if\n+# by the `toString` function.\n+# A value of type `table` is converted into a list of\n+# mappings one for each row.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8077e15459944ea37f0c4a73d99bad2da6fe288f"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc0NjcwNQ==", "bodyText": "XML conversion doesn't seem to work when its in a map?\npublic function main() {\n    xml x = xml `<foo><bar/>Hello World</foo>`;\n    json j1 = x.toJson(); // WORKS\n\n    map<anydata> m1 = {a: 1, b: \"str\"};\n    json j2 = m1.toJson(); // WORKS\n\n    map<anydata> m2 = {a: 1, b: x};\n    json j3 = m2.toJson(); // ERROR - error: {ballerina/lang.typedesc}ConversionError \n                        // message='map<anydata>' value cannot be converted to 'json'\n}", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r439746705", "createdAt": "2020-06-13T15:20:40Z", "author": {"login": "MaryamZi"}, "path": "langlib/lang.value/src/main/ballerina/src/lang.value/value.bal", "diffHunk": "@@ -117,9 +117,26 @@ public function toString((any|error) v) returns string = external;\n \n # Returns the string that represents `v` in JSON format.\n #\n-# + v - json value\n+# + v - anydata value\n # + return - string representation of json\n-public function toJsonString(json v) returns string = external;\n+public function toJsonString(anydata v) returns string = external;\n+\n+# Converts a value of type `anydata` to `json`.\n+# This does a deep copy of `v` converting values that do\n+# not belong to json into values that do.\n+# A value of type `xml` is converted into a string as if", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8077e15459944ea37f0c4a73d99bad2da6fe288f"}, "originalPosition": 13}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwMTU4Mzc4", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#pullrequestreview-430158378", "createdAt": "2020-06-13T18:48:04Z", "commit": {"oid": "8077e15459944ea37f0c4a73d99bad2da6fe288f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QxODo0ODowNFrOGjY14Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QxODo0ODowNFrOGjY14Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc2MDM1Mw==", "bodyText": "Double check this error message format. AFAIK, the convention is to prefix the reason with the module. But I can see that some of the lang.value functions have used this format. Let's check with the others and verify.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r439760353", "createdAt": "2020-06-13T18:48:04Z", "author": {"login": "pubudu91"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonStringWithType.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.JSONParser;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.model.types.TypeKind;\n+import org.ballerinalang.natives.annotations.Argument;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+import org.ballerinalang.natives.annotations.ReturnType;\n+\n+import java.io.Reader;\n+import java.io.StringReader;\n+\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ * Converts a string in JSON format to a user-specified type.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonStringWithType\",\n+        args = {\n+                @Argument(name = \"str\", type = TypeKind.STRING),\n+                @Argument(name = \"t\", type = TypeKind.TYPEDESC)\n+        },\n+        returnType = {\n+                @ReturnType(type = TypeKind.ANYDATA),\n+                @ReturnType(type = TypeKind.ERROR)\n+        },\n+        isPublic = true\n+)\n+public class FromJsonStringWithType {\n+\n+    public static Object fromJsonStringWithType(Strand strand, BString value, TypedescValue t) {\n+\n+        String str = value.getValue();\n+        if (str.equals(\"null\")) {\n+            return null;\n+        }\n+        Reader reader = new StringReader(str);\n+        try {\n+            Object jsonFromString = JSONParser.parse(reader);\n+            return FromJsonWithType.fromJsonWithType(strand, jsonFromString, t);\n+        } catch (BallerinaException e) {\n+            return BallerinaErrors.createError(\"{ballerina}FromJsonStringWithTypeError\", e.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8077e15459944ea37f0c4a73d99bad2da6fe288f"}, "originalPosition": 69}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a0bd25d975176a41fc5551b3fa16995359e39bba", "author": {"user": {"login": "dulajdilshan", "name": "Dulaj Dilshan"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a0bd25d975176a41fc5551b3fa16995359e39bba", "committedDate": "2020-06-14T16:47:10Z", "message": "Order langlib function descriptions"}, "afterCommit": {"oid": "1801ce4a280eb6c65f11988f2a0adb5b56788a7e", "author": {"user": {"login": "dulajdilshan", "name": "Dulaj Dilshan"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1801ce4a280eb6c65f11988f2a0adb5b56788a7e", "committedDate": "2020-06-15T17:21:12Z", "message": "Allow more tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwOTgyODI3", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#pullrequestreview-430982827", "createdAt": "2020-06-15T20:49:42Z", "commit": {"oid": "1801ce4a280eb6c65f11988f2a0adb5b56788a7e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQyMDo0OTo0MlrOGkCPJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQyMDo0OTo0MlrOGkCPJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQzODU2Ng==", "bodyText": "Why are we trying to convert it to an XML value if there aren't any convertible types? Consider the following example,\nimport ballerina/io;\n\npublic function main() {\n    string foo = \"Foo\";\n    var v = foo.fromJsonWithType(int);\n    io:println(v);\n}\nThe above fails with the following panic:\nerror {ballerina/lang.typedesc}ConversionError message='string' value cannot be converted to 'int': failed to parse xml: Unexpected character 'F' (code 70) in prolog; expected '<'\n at [row,col {unknown-source}]: [1,1]\n\nIt says string value cannot be converted to int but then has an XML parsing error as well.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r440438566", "createdAt": "2020-06-15T20:49:42Z", "author": {"login": "pubudu91"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,290 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypedescType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.model.types.TypeKind;\n+import org.ballerinalang.natives.annotations.Argument;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+import org.ballerinalang.natives.annotations.ReturnType;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        args = {\n+                @Argument(name = \"v\", type = TypeKind.ANYDATA),\n+                @Argument(name = \"t\", type = TypeKind.TYPEDESC)\n+        },\n+        returnType = {\n+                @ReturnType(type = TypeKind.ANYDATA),\n+                @ReturnType(type = TypeKind.ERROR)\n+        },\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        // typedesc<json>.constructFrom like usage\n+        if (describingType.getTag() == TypeTags.TYPEDESC_TAG) {\n+            return convert(((BTypedescType) t.getDescribingType()).getConstraint(), v, t, strand);\n+        }\n+        // json.constructFrom like usage\n+        return convert(describingType, v, t, strand);\n+    }\n+\n+    public static Object convert(BType convertType, Object inputValue) {\n+        return convert(convertType, inputValue, null, null);\n+    }\n+\n+    public static Object convert(BType convertType, Object inputValue, TypedescValue t, Strand strand) {\n+        try {\n+            return convert(inputValue, convertType, new ArrayList<>(), t, strand);\n+        } catch (ErrorValue e) {\n+            return e;\n+        } catch (BallerinaException e) {\n+            return createError(CONSTRUCT_FROM_CONVERSION_ERROR, e.getDetail());\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+        return convert(value, targetType, unresolvedValues, false, t, strand);\n+    }\n+\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  boolean allowAmbiguity, TypedescValue t, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            return createError(CONSTRUCT_FROM_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+        List<BType> convertibleTypes;\n+        convertibleTypes = TypeConverter.getConvertibleTypes(value, targetType);\n+        if (convertibleTypes.isEmpty()) {\n+            if (TypeChecker.getType(value).getTag() == TypeTags.STRING_TAG) {\n+                try {\n+                    return XMLFactory.parse(((StringValue) value).getValue());\n+                } catch (Throwable e) {\n+                    throw createConversionError(value, targetType, e.getMessage());\n+                }\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1801ce4a280eb6c65f11988f2a0adb5b56788a7e"}, "originalPosition": 136}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2c1f7ab4dcb46a21efd4aab0537603c72a6ec017", "author": {"user": {"login": "dulajdilshan", "name": "Dulaj Dilshan"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2c1f7ab4dcb46a21efd4aab0537603c72a6ec017", "committedDate": "2020-06-15T20:25:55Z", "message": "Fix cast error"}, "afterCommit": {"oid": "0f7f31f56391c00bca0e631d0db24e25c803ff64", "author": {"user": {"login": "dulajdilshan", "name": "Dulaj Dilshan"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/0f7f31f56391c00bca0e631d0db24e25c803ff64", "committedDate": "2020-06-16T05:46:12Z", "message": "Fix showing XML conversion error in other string type related conversions"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxMTg2NzYw", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#pullrequestreview-431186760", "createdAt": "2020-06-16T06:12:37Z", "commit": {"oid": "0f7f31f56391c00bca0e631d0db24e25c803ff64"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQwNjoxMjozN1rOGkMkWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQwNjoxMjozN1rOGkMkWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYwNzgzMg==", "bodyText": "Shall we add an upper bound for the subtypes as well for the following? If we add another anydata type, this will break.\ntargetType.getTag() >= TypeTags.XML_ELEMENT_TAG", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r440607832", "createdAt": "2020-06-16T06:12:37Z", "author": {"login": "pubudu91"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,291 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypedescType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.model.types.TypeKind;\n+import org.ballerinalang.natives.annotations.Argument;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+import org.ballerinalang.natives.annotations.ReturnType;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        args = {\n+                @Argument(name = \"v\", type = TypeKind.ANYDATA),\n+                @Argument(name = \"t\", type = TypeKind.TYPEDESC)\n+        },\n+        returnType = {\n+                @ReturnType(type = TypeKind.ANYDATA),\n+                @ReturnType(type = TypeKind.ERROR)\n+        },\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        // typedesc<json>.constructFrom like usage\n+        if (describingType.getTag() == TypeTags.TYPEDESC_TAG) {\n+            return convert(((BTypedescType) t.getDescribingType()).getConstraint(), v, t, strand);\n+        }\n+        // json.constructFrom like usage\n+        return convert(describingType, v, t, strand);\n+    }\n+\n+    public static Object convert(BType convertType, Object inputValue) {\n+        return convert(convertType, inputValue, null, null);\n+    }\n+\n+    public static Object convert(BType convertType, Object inputValue, TypedescValue t, Strand strand) {\n+        try {\n+            return convert(inputValue, convertType, new ArrayList<>(), t, strand);\n+        } catch (ErrorValue e) {\n+            return e;\n+        } catch (BallerinaException e) {\n+            return createError(CONSTRUCT_FROM_CONVERSION_ERROR, e.getDetail());\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+        return convert(value, targetType, unresolvedValues, false, t, strand);\n+    }\n+\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  boolean allowAmbiguity, TypedescValue t, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            return createError(CONSTRUCT_FROM_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+        List<BType> convertibleTypes;\n+        convertibleTypes = TypeConverter.getConvertibleTypes(value, targetType);\n+        if (convertibleTypes.isEmpty()) {\n+            if (TypeChecker.getType(value).getTag() == TypeTags.STRING_TAG &&\n+                    (targetType.getTag() >= TypeTags.XML_ELEMENT_TAG || targetType.getTag() == TypeTags.XML_TAG)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f7f31f56391c00bca0e631d0db24e25c803ff64"}, "originalPosition": 131}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxMTkxODYz", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#pullrequestreview-431191863", "createdAt": "2020-06-16T06:23:22Z", "commit": {"oid": "7b347b097d8ac0c0ee19ac2c060a0824b1366dc9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQwNjoyMzoyMlrOGkM0Tg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQwNjoyMzoyMlrOGkM0Tg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYxMTkxOA==", "bodyText": "Since this array type is not going to change, how about adding it to BTypes, instead of creating a new JSON array type each time?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r440611918", "createdAt": "2020-06-16T06:23:22Z", "author": {"login": "pubudu91"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,291 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypedescType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.model.types.TypeKind;\n+import org.ballerinalang.natives.annotations.Argument;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+import org.ballerinalang.natives.annotations.ReturnType;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        args = {\n+                @Argument(name = \"v\", type = TypeKind.ANYDATA),\n+                @Argument(name = \"t\", type = TypeKind.TYPEDESC)\n+        },\n+        returnType = {\n+                @ReturnType(type = TypeKind.ANYDATA),\n+                @ReturnType(type = TypeKind.ERROR)\n+        },\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        // typedesc<json>.constructFrom like usage\n+        if (describingType.getTag() == TypeTags.TYPEDESC_TAG) {\n+            return convert(((BTypedescType) t.getDescribingType()).getConstraint(), v, t, strand);\n+        }\n+        // json.constructFrom like usage\n+        return convert(describingType, v, t, strand);\n+    }\n+\n+    public static Object convert(BType convertType, Object inputValue) {\n+        return convert(convertType, inputValue, null, null);\n+    }\n+\n+    public static Object convert(BType convertType, Object inputValue, TypedescValue t, Strand strand) {\n+        try {\n+            return convert(inputValue, convertType, new ArrayList<>(), t, strand);\n+        } catch (ErrorValue e) {\n+            return e;\n+        } catch (BallerinaException e) {\n+            return createError(CONSTRUCT_FROM_CONVERSION_ERROR, e.getDetail());\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+        return convert(value, targetType, unresolvedValues, false, t, strand);\n+    }\n+\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  boolean allowAmbiguity, TypedescValue t, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            return createError(CONSTRUCT_FROM_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+        List<BType> convertibleTypes;\n+        convertibleTypes = TypeConverter.getConvertibleTypes(value, targetType);\n+        if (convertibleTypes.isEmpty()) {\n+            if (TypeChecker.getType(value).getTag() == TypeTags.STRING_TAG &&\n+                    (targetType.getTag() >= TypeTags.XML_ELEMENT_TAG || targetType.getTag() == TypeTags.XML_TAG)) {\n+                try {\n+                    return XMLFactory.parse(((StringValue) value).getValue());\n+                } catch (Throwable e) {\n+                    throw createConversionError(value, targetType, e.getMessage());\n+                }\n+            }\n+            throw createConversionError(value, targetType);\n+        } else if (!allowAmbiguity && convertibleTypes.size() > 1) {\n+            throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+        }\n+\n+        BType sourceType = TypeChecker.getType(value);\n+        BType matchingType = convertibleTypes.get(0);\n+        // handle primitive values\n+        if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+            if (TypeChecker.checkIsType(value, matchingType)) {\n+                return value;\n+            } else {\n+                // Has to be a numeric conversion.\n+                return TypeConverter.convertValues(matchingType, value);\n+            }\n+        }\n+\n+        return convert((RefValue) value, matchingType, unresolvedValues, t, strand);\n+    }\n+\n+    private static Object convert(RefValue value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(CONSTRUCT_FROM_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE, value.getType()));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        Object newValue;\n+        switch (value.getType().getTag()) {\n+            case TypeTags.MAP_TAG:\n+            case TypeTags.RECORD_TYPE_TAG:\n+                newValue = convertMap((MapValue<?, ?>) value, targetType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ARRAY_TAG:\n+            case TypeTags.TUPLE_TAG:\n+                newValue = convertArray((ArrayValue) value, targetType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.XML_TAG:\n+            case TypeTags.XML_ELEMENT_TAG:\n+            case TypeTags.XML_COMMENT_TAG:\n+            case TypeTags.XML_PI_TAG:\n+            case TypeTags.XML_TEXT_TAG:\n+            case TypeTags.ERROR_TAG:\n+                newValue = value.copy(new HashMap<>());\n+                break;\n+            default:\n+                // should never reach here\n+                throw BallerinaErrors.createConversionError(value, targetType);\n+        }\n+\n+        unresolvedValues.remove(typeValuePair);\n+        return newValue;\n+    }\n+\n+    private static Object convertMap(MapValue<?, ?> map, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                     TypedescValue t, Strand strand) {\n+        switch (targetType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+                MapValueImpl<BString, Object> newMap = new MapValueImpl<>(targetType);\n+                for (Map.Entry entry : map.entrySet()) {\n+                    BType constraintType = ((BMapType) targetType).getConstrainedType();\n+                    putToMap(newMap, entry, constraintType, unresolvedValues, t, strand);\n+                }\n+                return newMap;\n+            case TypeTags.RECORD_TYPE_TAG:\n+                BRecordType recordType = (BRecordType) targetType;\n+                MapValueImpl<BString, Object> newRecord;\n+                if (t != null && t.getDescribingType() == targetType) {\n+                    newRecord = (MapValueImpl<BString, Object>) t.instantiate(strand);\n+                } else {\n+                    newRecord = (MapValueImpl<BString, Object>) BallerinaValues\n+                            .createRecordValue(recordType.getPackage(), recordType.getName());\n+                }\n+\n+                BType restFieldType = recordType.restFieldType;\n+                Map<String, BType> targetTypeField = new HashMap<>();\n+                for (BField field : recordType.getFields().values()) {\n+                    targetTypeField.put(field.getFieldName(), field.getFieldType());\n+                }\n+\n+                for (Map.Entry entry : map.entrySet()) {\n+                    BType fieldType = targetTypeField.getOrDefault(entry.getKey().toString(), restFieldType);\n+                    putToMap(newRecord, entry, fieldType, unresolvedValues, t, strand);\n+                }\n+                return newRecord;\n+            case TypeTags.JSON_TAG:\n+                BType matchingType = TypeConverter.resolveMatchingTypeForUnion(map, targetType);\n+                return convert(map, matchingType, unresolvedValues, t, strand);\n+            default:\n+                break;\n+        }\n+        // should never reach here\n+        throw BallerinaErrors.createConversionError(map, targetType);\n+    }\n+\n+\n+    private static Object convertArray(ArrayValue array, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                       TypedescValue t, Strand strand) {\n+        switch (targetType.getTag()) {\n+            case TypeTags.ARRAY_TAG:\n+                BArrayType arrayType = (BArrayType) targetType;\n+                ArrayValueImpl newArray = new ArrayValueImpl(arrayType);\n+                for (int i = 0; i < array.size(); i++) {\n+                    Object newValue = convert(array.get(i), arrayType.getElementType(), unresolvedValues, t, strand);\n+                    newArray.add(i, newValue);\n+                }\n+                return newArray;\n+            case TypeTags.TUPLE_TAG:\n+                BTupleType tupleType = (BTupleType) targetType;\n+                TupleValueImpl newTuple = new TupleValueImpl(tupleType);\n+                int minLen = tupleType.getTupleTypes().size();\n+                for (int i = 0; i < array.size(); i++) {\n+                    BType elementType = (i < minLen) ? tupleType.getTupleTypes().get(i) : tupleType.getRestType();\n+                    Object newValue = convert(array.get(i), elementType, unresolvedValues, t, strand);\n+                    newTuple.add(i, newValue);\n+                }\n+                return newTuple;\n+            case TypeTags.JSON_TAG:\n+                newArray = new ArrayValueImpl(new BArrayType(BTypes.typeJSON));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b347b097d8ac0c0ee19ac2c060a0824b1366dc9"}, "originalPosition": 260}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxMjE1NjEx", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#pullrequestreview-431215611", "createdAt": "2020-06-16T07:07:36Z", "commit": {"oid": "7b347b097d8ac0c0ee19ac2c060a0824b1366dc9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQwNzowNzozNlrOGkN91A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQwNzowNzozNlrOGkN91A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYzMDc0MA==", "bodyText": "This should be thrown right? Since the signature of toJson() is json", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r440630740", "createdAt": "2020-06-16T07:07:36Z", "author": {"login": "pubudu91"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "diffHunk": "@@ -0,0 +1,344 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.JSONUtils;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.model.types.TypeKind;\n+import org.ballerinalang.natives.annotations.Argument;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+import org.ballerinalang.natives.annotations.ReturnType;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:toJson.\n+ * Converts a value of type `anydata` to `json`.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"toJson\",\n+        args = {\n+                @Argument(name = \"v\", type = TypeKind.ANYDATA),\n+        },\n+        returnType = {\n+                @ReturnType(type = TypeKind.JSON),\n+                @ReturnType(type = TypeKind.ERROR)\n+        },\n+        isPublic = true\n+)\n+public class ToJson {\n+\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object toJson(Strand strand, Object value) {\n+        if (value == null) {\n+            return null;\n+        }\n+\n+        BType sourceType = TypeChecker.getType(value);\n+        BType targetJsonType = BTypes.typeJSON;\n+        if (!isConvertibleToJson(value, new ArrayList<>())) {\n+            if (sourceType.getTag() >= TypeTags.XML_ELEMENT_TAG || sourceType.getTag() == TypeTags.XML_TAG) {\n+                return ToString.toString(strand, value);\n+            } else {\n+                throw createConversionError(value, targetJsonType);\n+            }\n+        }\n+\n+        // handle primitive values\n+        if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+            if (TypeChecker.checkIsType(value, targetJsonType)) {\n+                return value;\n+            } else {\n+                // Has to be a numeric conversion.\n+                return TypeConverter.convertValues(targetJsonType, value);\n+            }\n+        }\n+\n+        return convert((RefValue) value, targetJsonType, new ArrayList<>(), strand);\n+    }\n+\n+    private static Object convert(RefValue value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  Strand strand) {\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(CONSTRUCT_FROM_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE, value.getType()));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        Object newValue;\n+        switch (value.getType().getTag()) {\n+            case TypeTags.MAP_TAG:\n+            case TypeTags.RECORD_TYPE_TAG:\n+                newValue = convertMapToJson((MapValue<?, ?>) value, targetType, unresolvedValues, strand);\n+                break;\n+            case TypeTags.ARRAY_TAG:\n+            case TypeTags.TUPLE_TAG:\n+                newValue = convertArrayToJson((ArrayValue) value, targetType, unresolvedValues, strand);\n+                break;\n+            case TypeTags.XML_TAG:\n+            case TypeTags.XML_ELEMENT_TAG:\n+            case TypeTags.XML_COMMENT_TAG:\n+            case TypeTags.XML_PI_TAG:\n+            case TypeTags.XML_TEXT_TAG:\n+                newValue = ToString.toString(strand, value);\n+                break;\n+            case TypeTags.TABLE_TAG:\n+                try {\n+                    newValue = JSONUtils.toJSON((TableValueImpl) value);\n+                } catch (Exception e) {\n+                    return createConversionError(value, targetType, e.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b347b097d8ac0c0ee19ac2c060a0824b1366dc9"}, "originalPosition": 142}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxMjg3MzM4", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#pullrequestreview-431287338", "createdAt": "2020-06-16T08:43:00Z", "commit": {"oid": "7b347b097d8ac0c0ee19ac2c060a0824b1366dc9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQwODo0MzowMFrOGkRVcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQwODo0MzowMFrOGkRVcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY4NTkzNg==", "bodyText": "Why are we committing this and the next file?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r440685936", "createdAt": "2020-06-16T08:43:00Z", "author": {"login": "MaryamZi"}, "path": "misc/testerina/modules/report-tools/package-lock.json", "diffHunk": "@@ -1,6 +1,6 @@\n {\n   \"name\": \"@ballerina/testerina-report\",\n-  \"version\": \"2.0.0-Preview1-M3\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b347b097d8ac0c0ee19ac2c060a0824b1366dc9"}, "originalPosition": 3}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7b347b097d8ac0c0ee19ac2c060a0824b1366dc9", "author": {"user": {"login": "dulajdilshan", "name": "Dulaj Dilshan"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7b347b097d8ac0c0ee19ac2c060a0824b1366dc9", "committedDate": "2020-06-16T06:09:15Z", "message": "Show the reason for the failure of 'table' to 'json' conversion"}, "afterCommit": {"oid": "a077ffb23f5a9e15d2c18eec61e64a926a5d7b4a", "author": {"user": {"login": "dulajdilshan", "name": "Dulaj Dilshan"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a077ffb23f5a9e15d2c18eec61e64a926a5d7b4a", "committedDate": "2020-06-16T14:03:37Z", "message": "Change error message in 'fromJsonStringWithType' langlib method"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a077ffb23f5a9e15d2c18eec61e64a926a5d7b4a", "author": {"user": {"login": "dulajdilshan", "name": "Dulaj Dilshan"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a077ffb23f5a9e15d2c18eec61e64a926a5d7b4a", "committedDate": "2020-06-16T14:03:37Z", "message": "Change error message in 'fromJsonStringWithType' langlib method"}, "afterCommit": {"oid": "6a2f3b589925768e932552b23987b87aed442edb", "author": {"user": {"login": "dulajdilshan", "name": "Dulaj Dilshan"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6a2f3b589925768e932552b23987b87aed442edb", "committedDate": "2020-06-16T20:31:15Z", "message": "Disable langlib value tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM0Nzc0MjM1", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#pullrequestreview-434774235", "createdAt": "2020-06-22T09:55:38Z", "commit": {"oid": "6a2f3b589925768e932552b23987b87aed442edb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQwOTo1NTozOVrOGm51ZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQwOTo1NTozOVrOGm51ZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ0NjYyOQ==", "bodyText": "Should return", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r443446629", "createdAt": "2020-06-22T09:55:39Z", "author": {"login": "dulajdilshan"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,340 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTableType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypedescType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.model.types.TypeKind;\n+import org.ballerinalang.natives.annotations.Argument;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+import org.ballerinalang.natives.annotations.ReturnType;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        args = {\n+                @Argument(name = \"v\", type = TypeKind.ANYDATA),\n+                @Argument(name = \"t\", type = TypeKind.TYPEDESC)\n+        },\n+        returnType = {\n+                @ReturnType(type = TypeKind.ANYDATA),\n+                @ReturnType(type = TypeKind.ERROR)\n+        },\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        // typedesc<json>.constructFrom like usage\n+        if (describingType.getTag() == TypeTags.TYPEDESC_TAG) {\n+            return convert(((BTypedescType) t.getDescribingType()).getConstraint(), v, t, strand);\n+        }\n+        // json.constructFrom like usage\n+        return convert(describingType, v, t, strand);\n+    }\n+\n+    public static Object convert(BType convertType, Object inputValue, TypedescValue t, Strand strand) {\n+        try {\n+            return convert(inputValue, convertType, new ArrayList<>(), t, strand);\n+        } catch (ErrorValue e) {\n+            return e;\n+        } catch (BallerinaException e) {\n+            return createError(CONSTRUCT_FROM_CONVERSION_ERROR, e.getDetail());\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+        return convert(value, targetType, unresolvedValues, false, t, strand);\n+    }\n+\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  boolean allowAmbiguity, TypedescValue t, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            return createError(CONSTRUCT_FROM_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+        List<BType> convertibleTypes;\n+        convertibleTypes = getConvertibleTypesFromJson(value, targetType);\n+        if (convertibleTypes.isEmpty()) {\n+            throw createConversionError(value, targetType);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6a2f3b589925768e932552b23987b87aed442edb"}, "originalPosition": 128}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM0Nzc1MDY5", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#pullrequestreview-434775069", "createdAt": "2020-06-22T09:56:44Z", "commit": {"oid": "6a2f3b589925768e932552b23987b87aed442edb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQwOTo1Njo0NFrOGm53zg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQwOTo1Njo0NFrOGm53zg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ0NzI0Ng==", "bodyText": "no need isambiguity", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r443447246", "createdAt": "2020-06-22T09:56:44Z", "author": {"login": "dulajdilshan"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,340 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTableType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypedescType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.model.types.TypeKind;\n+import org.ballerinalang.natives.annotations.Argument;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+import org.ballerinalang.natives.annotations.ReturnType;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        args = {\n+                @Argument(name = \"v\", type = TypeKind.ANYDATA),\n+                @Argument(name = \"t\", type = TypeKind.TYPEDESC)\n+        },\n+        returnType = {\n+                @ReturnType(type = TypeKind.ANYDATA),\n+                @ReturnType(type = TypeKind.ERROR)\n+        },\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        // typedesc<json>.constructFrom like usage\n+        if (describingType.getTag() == TypeTags.TYPEDESC_TAG) {\n+            return convert(((BTypedescType) t.getDescribingType()).getConstraint(), v, t, strand);\n+        }\n+        // json.constructFrom like usage\n+        return convert(describingType, v, t, strand);\n+    }\n+\n+    public static Object convert(BType convertType, Object inputValue, TypedescValue t, Strand strand) {\n+        try {\n+            return convert(inputValue, convertType, new ArrayList<>(), t, strand);\n+        } catch (ErrorValue e) {\n+            return e;\n+        } catch (BallerinaException e) {\n+            return createError(CONSTRUCT_FROM_CONVERSION_ERROR, e.getDetail());\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+        return convert(value, targetType, unresolvedValues, false, t, strand);\n+    }\n+\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  boolean allowAmbiguity, TypedescValue t, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            return createError(CONSTRUCT_FROM_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+        List<BType> convertibleTypes;\n+        convertibleTypes = getConvertibleTypesFromJson(value, targetType);\n+        if (convertibleTypes.isEmpty()) {\n+            throw createConversionError(value, targetType);\n+        } else if (!allowAmbiguity && convertibleTypes.size() > 1) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6a2f3b589925768e932552b23987b87aed442edb"}, "originalPosition": 129}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM0ODAwODkz", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#pullrequestreview-434800893", "createdAt": "2020-06-22T10:34:00Z", "commit": {"oid": "6a2f3b589925768e932552b23987b87aed442edb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMDozNDowMFrOGm7Egw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMDozNDowMFrOGm7Egw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ2Njg4Mw==", "bodyText": "Error put as a cause", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r443466883", "createdAt": "2020-06-22T10:34:00Z", "author": {"login": "dulajdilshan"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,340 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTableType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypedescType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.model.types.TypeKind;\n+import org.ballerinalang.natives.annotations.Argument;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+import org.ballerinalang.natives.annotations.ReturnType;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        args = {\n+                @Argument(name = \"v\", type = TypeKind.ANYDATA),\n+                @Argument(name = \"t\", type = TypeKind.TYPEDESC)\n+        },\n+        returnType = {\n+                @ReturnType(type = TypeKind.ANYDATA),\n+                @ReturnType(type = TypeKind.ERROR)\n+        },\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        // typedesc<json>.constructFrom like usage\n+        if (describingType.getTag() == TypeTags.TYPEDESC_TAG) {\n+            return convert(((BTypedescType) t.getDescribingType()).getConstraint(), v, t, strand);\n+        }\n+        // json.constructFrom like usage\n+        return convert(describingType, v, t, strand);\n+    }\n+\n+    public static Object convert(BType convertType, Object inputValue, TypedescValue t, Strand strand) {\n+        try {\n+            return convert(inputValue, convertType, new ArrayList<>(), t, strand);\n+        } catch (ErrorValue e) {\n+            return e;\n+        } catch (BallerinaException e) {\n+            return createError(CONSTRUCT_FROM_CONVERSION_ERROR, e.getDetail());\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+        return convert(value, targetType, unresolvedValues, false, t, strand);\n+    }\n+\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  boolean allowAmbiguity, TypedescValue t, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            return createError(CONSTRUCT_FROM_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+        List<BType> convertibleTypes;\n+        convertibleTypes = getConvertibleTypesFromJson(value, targetType);\n+        if (convertibleTypes.isEmpty()) {\n+            throw createConversionError(value, targetType);\n+        } else if (!allowAmbiguity && convertibleTypes.size() > 1) {\n+            throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+        }\n+\n+        BType sourceType = TypeChecker.getType(value);\n+        BType matchingType = convertibleTypes.get(0);\n+\n+        // handle string (xml as string) to xml conversion\n+        if (TypeChecker.getType(value).getTag() == TypeTags.STRING_TAG &&\n+                ((matchingType.getTag() >= TypeTags.XML_ELEMENT_TAG && matchingType.getTag() <= TypeTags.XML_TEXT_TAG)\n+                        || matchingType.getTag() == TypeTags.XML_TAG)) {\n+            try {\n+                return XMLFactory.parse(((StringValue) value).getValue());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6a2f3b589925768e932552b23987b87aed442edb"}, "originalPosition": 141}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6a2f3b589925768e932552b23987b87aed442edb", "author": {"user": {"login": "dulajdilshan", "name": "Dulaj Dilshan"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6a2f3b589925768e932552b23987b87aed442edb", "committedDate": "2020-06-16T20:31:15Z", "message": "Disable langlib value tests"}, "afterCommit": {"oid": "b0073636ea0493ddb1d44e18b2afa599d563946a", "author": {"user": {"login": "dulajdilshan", "name": "Dulaj Dilshan"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b0073636ea0493ddb1d44e18b2afa599d563946a", "committedDate": "2020-06-30T06:24:32Z", "message": "Refactor \"fromJsonWithType\" according to the code review suggestions"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b0073636ea0493ddb1d44e18b2afa599d563946a", "author": {"user": {"login": "dulajdilshan", "name": "Dulaj Dilshan"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b0073636ea0493ddb1d44e18b2afa599d563946a", "committedDate": "2020-06-30T06:24:32Z", "message": "Refactor \"fromJsonWithType\" according to the code review suggestions"}, "afterCommit": {"oid": "aa0eab3df2f3c2a6d1e7e831b3996d68eb4cb186", "author": {"user": {"login": "dulajdilshan", "name": "Dulaj Dilshan"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/aa0eab3df2f3c2a6d1e7e831b3996d68eb4cb186", "committedDate": "2020-06-30T08:40:24Z", "message": "Fix error in the value lib test"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "aa0eab3df2f3c2a6d1e7e831b3996d68eb4cb186", "author": {"user": {"login": "dulajdilshan", "name": "Dulaj Dilshan"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/aa0eab3df2f3c2a6d1e7e831b3996d68eb4cb186", "committedDate": "2020-06-30T08:40:24Z", "message": "Fix error in the value lib test"}, "afterCommit": {"oid": "39bbe770806904ada758446ee80c9df6cfeed410", "author": {"user": {"login": "dulajdilshan", "name": "Dulaj Dilshan"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/39bbe770806904ada758446ee80c9df6cfeed410", "committedDate": "2020-06-30T08:56:32Z", "message": "Fix error in the value lib test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQyMzk3NTY2", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#pullrequestreview-442397566", "createdAt": "2020-07-03T13:00:51Z", "commit": {"oid": "39bbe770806904ada758446ee80c9df6cfeed410"}, "state": "COMMENTED", "comments": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxMzowMDo1MVrOGsvr0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxODo0Nzo0MVrOGs2X-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU3MTc5NA==", "bodyText": "Can't we do something like\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            Object val = record.get(key);\n          \n          \n            \n                            BString strVal = org.ballerinalang.jvm.StringUtils.fromString(\n          \n          \n            \n                                    org.ballerinalang.jvm.values.utils.StringUtils.getStringValue(val));\n          \n          \n            \n                            jsonObject.put(StringUtils.fromString(name), strVal);\n          \n          \n            \n            //                jsonObject.put(StringUtils.fromString(name), record.getStringValue(key));\n          \n          \n            \n                            BString strVal = StringUtils.fromString(\n          \n          \n            \n                                    org.ballerinalang.jvm.values.utils.StringUtils.getStringValue(record.get(key)));\n          \n          \n            \n                            jsonObject.put(StringUtils.fromString(name), strVal);\n          \n      \n    \n    \n  \n\ninstead?\nLet's also remove commented out code.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r449571794", "createdAt": "2020-07-03T13:00:51Z", "author": {"login": "MaryamZi"}, "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TableJSONDataSource.java", "diffHunk": "@@ -159,7 +159,11 @@ private static void constructJsonData(MapValueImpl record, MapValue<BString, Obj\n                         getStructData(record.getMapValue(key), structFields, index, key));\n                 break;\n             case TypeTags.XML_TAG:\n-                jsonObject.put(StringUtils.fromString(name), record.getStringValue(key));\n+                Object val = record.get(key);\n+                BString strVal = org.ballerinalang.jvm.StringUtils.fromString(\n+                        org.ballerinalang.jvm.values.utils.StringUtils.getStringValue(val));\n+                jsonObject.put(StringUtils.fromString(name), strVal);\n+//                jsonObject.put(StringUtils.fromString(name), record.getStringValue(key));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39bbe770806904ada758446ee80c9df6cfeed410"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY0NTc1MQ==", "bodyText": "In this value type check, we check for simple basic types and string right? Since they are always json, wondering if we can skip the next line and directly return true.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r449645751", "createdAt": "2020-07-03T16:01:49Z", "author": {"login": "MaryamZi"}, "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeChecker.java", "diffHunk": "@@ -343,6 +343,56 @@ public static boolean isSameType(BType sourceType, BType targetType) {\n         return false;\n     }\n \n+    public static boolean isConvertibleToJson(Object sourceValue, List<TypeValuePair> unresolvedValues) {\n+\n+        BType sourceType = TypeChecker.getType(sourceValue);\n+\n+        if (TypeChecker.checkIsLikeType(sourceValue, BTypes.typeJSON, true)) {\n+            return true;\n+        }\n+\n+        if (sourceType.getTag() == TypeTags.ARRAY_TAG) {\n+            ArrayValue source = (ArrayValue) sourceValue;\n+            BType elementType = ((BArrayType) source.getType()).getElementType();\n+            if (BTypes.isValueType(elementType)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39bbe770806904ada758446ee80c9df6cfeed410"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY1OTc1NA==", "bodyText": "Do we need this isConvertibleToJson check at all? toJson can only be called on anydata values right? And unless they have cycles (which seems to be checked independent of this check), it is pretty much guaranteed that they can be converted to json?\n\n  \n    \n      ballerina-lang/langlib/lang.value/src/main/ballerina/src/lang.value/value.bal\n    \n    \n         Line 133\n      in\n      39bbe77\n    \n    \n    \n    \n\n        \n          \n           public function toJson(anydata v) returns json = external;", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r449659754", "createdAt": "2020-07-03T16:55:56Z", "author": {"login": "MaryamZi"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.JSONUtils;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:toJson.\n+ * Converts a value of type `anydata` to `json`.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"toJson\",\n+        isPublic = true\n+)\n+public class ToJson {\n+\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object toJson(Strand strand, Object value) {\n+        BType targetJsonType = BTypes.typeJSON;\n+        try {\n+            return convert(value, targetJsonType, new ArrayList<>(), strand);\n+        } catch (Exception e) {\n+            return e;\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE,\n+                            ((RefValue) value).getType()));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (!TypeChecker.isConvertibleToJson(value, new ArrayList<>())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39bbe770806904ada758446ee80c9df6cfeed410"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY1OTkwMA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    BType targetJsonType = BTypes.typeJSON;\n          \n          \n            \n                    try {\n          \n          \n            \n                        return convert(value, targetJsonType, new ArrayList<>(), strand);\n          \n          \n            \n                    try {\n          \n          \n            \n                        return convert(value, BTypes.typeJSON, new ArrayList<>(), strand);", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r449659900", "createdAt": "2020-07-03T16:56:38Z", "author": {"login": "MaryamZi"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.JSONUtils;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:toJson.\n+ * Converts a value of type `anydata` to `json`.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"toJson\",\n+        isPublic = true\n+)\n+public class ToJson {\n+\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object toJson(Strand strand, Object value) {\n+        BType targetJsonType = BTypes.typeJSON;\n+        try {\n+            return convert(value, targetJsonType, new ArrayList<>(), strand);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39bbe770806904ada758446ee80c9df6cfeed410"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2MDMyMQ==", "bodyText": "Isn't the target type always json? Makes this check always true right?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r449660321", "createdAt": "2020-07-03T16:58:33Z", "author": {"login": "MaryamZi"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.JSONUtils;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:toJson.\n+ * Converts a value of type `anydata` to `json`.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"toJson\",\n+        isPublic = true\n+)\n+public class ToJson {\n+\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object toJson(Strand strand, Object value) {\n+        BType targetJsonType = BTypes.typeJSON;\n+        try {\n+            return convert(value, targetJsonType, new ArrayList<>(), strand);\n+        } catch (Exception e) {\n+            return e;\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39bbe770806904ada758446ee80c9df6cfeed410"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2NjAxOQ==", "bodyText": "Once we remove error from anydata, we won't reach here right? For the time-being I think we can panic if reach here.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r449666019", "createdAt": "2020-07-03T17:26:08Z", "author": {"login": "MaryamZi"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.JSONUtils;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:toJson.\n+ * Converts a value of type `anydata` to `json`.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"toJson\",\n+        isPublic = true\n+)\n+public class ToJson {\n+\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object toJson(Strand strand, Object value) {\n+        BType targetJsonType = BTypes.typeJSON;\n+        try {\n+            return convert(value, targetJsonType, new ArrayList<>(), strand);\n+        } catch (Exception e) {\n+            return e;\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE,\n+                            ((RefValue) value).getType()));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (!TypeChecker.isConvertibleToJson(value, new ArrayList<>())) {\n+            return createConversionError(value, targetType);\n+        }\n+\n+        Object newValue;\n+        switch (TypeChecker.getType(value).getTag()) {\n+            case TypeTags.XML_TAG:\n+            case TypeTags.XML_ELEMENT_TAG:\n+            case TypeTags.XML_COMMENT_TAG:\n+            case TypeTags.XML_PI_TAG:\n+            case TypeTags.XML_TEXT_TAG:\n+                newValue = ToString.toString(strand, value);\n+                break;\n+            case TypeTags.TUPLE_TAG:\n+            case TypeTags.ARRAY_TAG:\n+                newValue = convertArrayToJson((ArrayValue) value, unresolvedValues, strand);\n+                break;\n+            case TypeTags.TABLE_TAG:\n+                try {\n+                    newValue = JSONUtils.toJSON((TableValueImpl) value);\n+                } catch (Exception e) {\n+                    throw createConversionError(value, targetType, e.getMessage());\n+                }\n+                break;\n+            case TypeTags.RECORD_TYPE_TAG:\n+            case TypeTags.MAP_TAG:\n+                newValue = convertMapToJson((MapValue<?, ?>) value, new BMapType(BTypes.typeJSON),\n+                        unresolvedValues, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39bbe770806904ada758446ee80c9df6cfeed410"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2NzQ1Mw==", "bodyText": "We get here only for simple basic types and string, and we don't have to do any conversions here right?\nIMO, we can move this to after the null check and remove this here.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r449667453", "createdAt": "2020-07-03T17:33:10Z", "author": {"login": "MaryamZi"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.JSONUtils;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:toJson.\n+ * Converts a value of type `anydata` to `json`.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"toJson\",\n+        isPublic = true\n+)\n+public class ToJson {\n+\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object toJson(Strand strand, Object value) {\n+        BType targetJsonType = BTypes.typeJSON;\n+        try {\n+            return convert(value, targetJsonType, new ArrayList<>(), strand);\n+        } catch (Exception e) {\n+            return e;\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE,\n+                            ((RefValue) value).getType()));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (!TypeChecker.isConvertibleToJson(value, new ArrayList<>())) {\n+            return createConversionError(value, targetType);\n+        }\n+\n+        Object newValue;\n+        switch (TypeChecker.getType(value).getTag()) {\n+            case TypeTags.XML_TAG:\n+            case TypeTags.XML_ELEMENT_TAG:\n+            case TypeTags.XML_COMMENT_TAG:\n+            case TypeTags.XML_PI_TAG:\n+            case TypeTags.XML_TEXT_TAG:\n+                newValue = ToString.toString(strand, value);\n+                break;\n+            case TypeTags.TUPLE_TAG:\n+            case TypeTags.ARRAY_TAG:\n+                newValue = convertArrayToJson((ArrayValue) value, unresolvedValues, strand);\n+                break;\n+            case TypeTags.TABLE_TAG:\n+                try {\n+                    newValue = JSONUtils.toJSON((TableValueImpl) value);\n+                } catch (Exception e) {\n+                    throw createConversionError(value, targetType, e.getMessage());\n+                }\n+                break;\n+            case TypeTags.RECORD_TYPE_TAG:\n+            case TypeTags.MAP_TAG:\n+                newValue = convertMapToJson((MapValue<?, ?>) value, new BMapType(BTypes.typeJSON),\n+                        unresolvedValues, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:\n+                newValue = ((RefValue) value).copy(new HashMap<>());\n+                break;\n+            default:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39bbe770806904ada758446ee80c9df6cfeed410"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2ODE4OA==", "bodyText": "Also, assuming this is for simple basic types, they are always JSON. So we don't have to check getConvertibleTypes.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r449668188", "createdAt": "2020-07-03T17:37:04Z", "author": {"login": "MaryamZi"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.JSONUtils;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:toJson.\n+ * Converts a value of type `anydata` to `json`.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"toJson\",\n+        isPublic = true\n+)\n+public class ToJson {\n+\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object toJson(Strand strand, Object value) {\n+        BType targetJsonType = BTypes.typeJSON;\n+        try {\n+            return convert(value, targetJsonType, new ArrayList<>(), strand);\n+        } catch (Exception e) {\n+            return e;\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE,\n+                            ((RefValue) value).getType()));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (!TypeChecker.isConvertibleToJson(value, new ArrayList<>())) {\n+            return createConversionError(value, targetType);\n+        }\n+\n+        Object newValue;\n+        switch (TypeChecker.getType(value).getTag()) {\n+            case TypeTags.XML_TAG:\n+            case TypeTags.XML_ELEMENT_TAG:\n+            case TypeTags.XML_COMMENT_TAG:\n+            case TypeTags.XML_PI_TAG:\n+            case TypeTags.XML_TEXT_TAG:\n+                newValue = ToString.toString(strand, value);\n+                break;\n+            case TypeTags.TUPLE_TAG:\n+            case TypeTags.ARRAY_TAG:\n+                newValue = convertArrayToJson((ArrayValue) value, unresolvedValues, strand);\n+                break;\n+            case TypeTags.TABLE_TAG:\n+                try {\n+                    newValue = JSONUtils.toJSON((TableValueImpl) value);\n+                } catch (Exception e) {\n+                    throw createConversionError(value, targetType, e.getMessage());\n+                }\n+                break;\n+            case TypeTags.RECORD_TYPE_TAG:\n+            case TypeTags.MAP_TAG:\n+                newValue = convertMapToJson((MapValue<?, ?>) value, new BMapType(BTypes.typeJSON),\n+                        unresolvedValues, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:\n+                newValue = ((RefValue) value).copy(new HashMap<>());\n+                break;\n+            default:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2NzQ1Mw=="}, "originalCommit": {"oid": "39bbe770806904ada758446ee80c9df6cfeed410"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2ODU3OA==", "bodyText": "targetType is always map<json> right? We can have a constant/final variable for the type in this class or BTypes, or move the type creation to within this method.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r449668578", "createdAt": "2020-07-03T17:39:03Z", "author": {"login": "MaryamZi"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.JSONUtils;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:toJson.\n+ * Converts a value of type `anydata` to `json`.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"toJson\",\n+        isPublic = true\n+)\n+public class ToJson {\n+\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object toJson(Strand strand, Object value) {\n+        BType targetJsonType = BTypes.typeJSON;\n+        try {\n+            return convert(value, targetJsonType, new ArrayList<>(), strand);\n+        } catch (Exception e) {\n+            return e;\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE,\n+                            ((RefValue) value).getType()));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (!TypeChecker.isConvertibleToJson(value, new ArrayList<>())) {\n+            return createConversionError(value, targetType);\n+        }\n+\n+        Object newValue;\n+        switch (TypeChecker.getType(value).getTag()) {\n+            case TypeTags.XML_TAG:\n+            case TypeTags.XML_ELEMENT_TAG:\n+            case TypeTags.XML_COMMENT_TAG:\n+            case TypeTags.XML_PI_TAG:\n+            case TypeTags.XML_TEXT_TAG:\n+                newValue = ToString.toString(strand, value);\n+                break;\n+            case TypeTags.TUPLE_TAG:\n+            case TypeTags.ARRAY_TAG:\n+                newValue = convertArrayToJson((ArrayValue) value, unresolvedValues, strand);\n+                break;\n+            case TypeTags.TABLE_TAG:\n+                try {\n+                    newValue = JSONUtils.toJSON((TableValueImpl) value);\n+                } catch (Exception e) {\n+                    throw createConversionError(value, targetType, e.getMessage());\n+                }\n+                break;\n+            case TypeTags.RECORD_TYPE_TAG:\n+            case TypeTags.MAP_TAG:\n+                newValue = convertMapToJson((MapValue<?, ?>) value, new BMapType(BTypes.typeJSON),\n+                        unresolvedValues, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:\n+                newValue = ((RefValue) value).copy(new HashMap<>());\n+                break;\n+            default:\n+                List<BType> convertibleTypes = TypeConverter.getConvertibleTypes(value, BTypes.typeJSON);\n+                if (convertibleTypes.size() == 0) {\n+                    throw createConversionError(value, targetType);\n+                } else if (convertibleTypes.size() > 1) {\n+                    throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+                }\n+\n+                BType sourceType = TypeChecker.getType(value);\n+                BType matchingType = convertibleTypes.get(0);\n+\n+                // handle primitive values\n+                if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+                    if (TypeChecker.checkIsType(value, matchingType)) {\n+                        newValue = value;\n+                    } else {\n+                        // Has to be a numeric conversion.\n+                        newValue = TypeConverter.convertValues(matchingType, value);\n+                    }\n+                } else {\n+                    throw createConversionError(value, targetType);\n+                }\n+                break;\n+        }\n+\n+        unresolvedValues.remove(typeValuePair);\n+        return newValue;\n+    }\n+\n+    private static Object convertMapToJson(MapValue<?, ?> map, BType targetType, List<TypeValuePair> unresolvedValues,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39bbe770806904ada758446ee80c9df6cfeed410"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2ODkwMg==", "bodyText": "We should have extracted this out to a variable. But then again since this is always json, we can use the JSON type in BTypes.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r449668902", "createdAt": "2020-07-03T17:40:49Z", "author": {"login": "MaryamZi"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.JSONUtils;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:toJson.\n+ * Converts a value of type `anydata` to `json`.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"toJson\",\n+        isPublic = true\n+)\n+public class ToJson {\n+\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object toJson(Strand strand, Object value) {\n+        BType targetJsonType = BTypes.typeJSON;\n+        try {\n+            return convert(value, targetJsonType, new ArrayList<>(), strand);\n+        } catch (Exception e) {\n+            return e;\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE,\n+                            ((RefValue) value).getType()));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (!TypeChecker.isConvertibleToJson(value, new ArrayList<>())) {\n+            return createConversionError(value, targetType);\n+        }\n+\n+        Object newValue;\n+        switch (TypeChecker.getType(value).getTag()) {\n+            case TypeTags.XML_TAG:\n+            case TypeTags.XML_ELEMENT_TAG:\n+            case TypeTags.XML_COMMENT_TAG:\n+            case TypeTags.XML_PI_TAG:\n+            case TypeTags.XML_TEXT_TAG:\n+                newValue = ToString.toString(strand, value);\n+                break;\n+            case TypeTags.TUPLE_TAG:\n+            case TypeTags.ARRAY_TAG:\n+                newValue = convertArrayToJson((ArrayValue) value, unresolvedValues, strand);\n+                break;\n+            case TypeTags.TABLE_TAG:\n+                try {\n+                    newValue = JSONUtils.toJSON((TableValueImpl) value);\n+                } catch (Exception e) {\n+                    throw createConversionError(value, targetType, e.getMessage());\n+                }\n+                break;\n+            case TypeTags.RECORD_TYPE_TAG:\n+            case TypeTags.MAP_TAG:\n+                newValue = convertMapToJson((MapValue<?, ?>) value, new BMapType(BTypes.typeJSON),\n+                        unresolvedValues, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:\n+                newValue = ((RefValue) value).copy(new HashMap<>());\n+                break;\n+            default:\n+                List<BType> convertibleTypes = TypeConverter.getConvertibleTypes(value, BTypes.typeJSON);\n+                if (convertibleTypes.size() == 0) {\n+                    throw createConversionError(value, targetType);\n+                } else if (convertibleTypes.size() > 1) {\n+                    throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+                }\n+\n+                BType sourceType = TypeChecker.getType(value);\n+                BType matchingType = convertibleTypes.get(0);\n+\n+                // handle primitive values\n+                if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+                    if (TypeChecker.checkIsType(value, matchingType)) {\n+                        newValue = value;\n+                    } else {\n+                        // Has to be a numeric conversion.\n+                        newValue = TypeConverter.convertValues(matchingType, value);\n+                    }\n+                } else {\n+                    throw createConversionError(value, targetType);\n+                }\n+                break;\n+        }\n+\n+        unresolvedValues.remove(typeValuePair);\n+        return newValue;\n+    }\n+\n+    private static Object convertMapToJson(MapValue<?, ?> map, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                           Strand strand) {\n+        MapValueImpl<BString, Object> newMap = new MapValueImpl<>(targetType);\n+        for (Map.Entry entry : map.entrySet()) {\n+            BType constraintType = ((BMapType) targetType).getConstrainedType();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39bbe770806904ada758446ee80c9df6cfeed410"}, "originalPosition": 164}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2OTQwNg==", "bodyText": "Can't we use BTypes.typeJsonArray you've introduced?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r449669406", "createdAt": "2020-07-03T17:43:31Z", "author": {"login": "MaryamZi"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.JSONUtils;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:toJson.\n+ * Converts a value of type `anydata` to `json`.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"toJson\",\n+        isPublic = true\n+)\n+public class ToJson {\n+\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object toJson(Strand strand, Object value) {\n+        BType targetJsonType = BTypes.typeJSON;\n+        try {\n+            return convert(value, targetJsonType, new ArrayList<>(), strand);\n+        } catch (Exception e) {\n+            return e;\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE,\n+                            ((RefValue) value).getType()));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (!TypeChecker.isConvertibleToJson(value, new ArrayList<>())) {\n+            return createConversionError(value, targetType);\n+        }\n+\n+        Object newValue;\n+        switch (TypeChecker.getType(value).getTag()) {\n+            case TypeTags.XML_TAG:\n+            case TypeTags.XML_ELEMENT_TAG:\n+            case TypeTags.XML_COMMENT_TAG:\n+            case TypeTags.XML_PI_TAG:\n+            case TypeTags.XML_TEXT_TAG:\n+                newValue = ToString.toString(strand, value);\n+                break;\n+            case TypeTags.TUPLE_TAG:\n+            case TypeTags.ARRAY_TAG:\n+                newValue = convertArrayToJson((ArrayValue) value, unresolvedValues, strand);\n+                break;\n+            case TypeTags.TABLE_TAG:\n+                try {\n+                    newValue = JSONUtils.toJSON((TableValueImpl) value);\n+                } catch (Exception e) {\n+                    throw createConversionError(value, targetType, e.getMessage());\n+                }\n+                break;\n+            case TypeTags.RECORD_TYPE_TAG:\n+            case TypeTags.MAP_TAG:\n+                newValue = convertMapToJson((MapValue<?, ?>) value, new BMapType(BTypes.typeJSON),\n+                        unresolvedValues, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:\n+                newValue = ((RefValue) value).copy(new HashMap<>());\n+                break;\n+            default:\n+                List<BType> convertibleTypes = TypeConverter.getConvertibleTypes(value, BTypes.typeJSON);\n+                if (convertibleTypes.size() == 0) {\n+                    throw createConversionError(value, targetType);\n+                } else if (convertibleTypes.size() > 1) {\n+                    throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+                }\n+\n+                BType sourceType = TypeChecker.getType(value);\n+                BType matchingType = convertibleTypes.get(0);\n+\n+                // handle primitive values\n+                if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+                    if (TypeChecker.checkIsType(value, matchingType)) {\n+                        newValue = value;\n+                    } else {\n+                        // Has to be a numeric conversion.\n+                        newValue = TypeConverter.convertValues(matchingType, value);\n+                    }\n+                } else {\n+                    throw createConversionError(value, targetType);\n+                }\n+                break;\n+        }\n+\n+        unresolvedValues.remove(typeValuePair);\n+        return newValue;\n+    }\n+\n+    private static Object convertMapToJson(MapValue<?, ?> map, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                           Strand strand) {\n+        MapValueImpl<BString, Object> newMap = new MapValueImpl<>(targetType);\n+        for (Map.Entry entry : map.entrySet()) {\n+            BType constraintType = ((BMapType) targetType).getConstrainedType();\n+            putToMap(newMap, entry, constraintType, unresolvedValues, strand);\n+        }\n+        return newMap;\n+    }\n+\n+    private static Object convertArrayToJson(ArrayValue array, List<TypeValuePair> unresolvedValues,\n+                                             Strand strand) {\n+        ArrayValueImpl newArray = new ArrayValueImpl(new BArrayType(BTypes.typeJSON));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39bbe770806904ada758446ee80c9df6cfeed410"}, "originalPosition": 172}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2OTU0NQ==", "bodyText": "We don't need a separate method for this right?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r449669545", "createdAt": "2020-07-03T17:44:16Z", "author": {"login": "MaryamZi"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.JSONUtils;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:toJson.\n+ * Converts a value of type `anydata` to `json`.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"toJson\",\n+        isPublic = true\n+)\n+public class ToJson {\n+\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object toJson(Strand strand, Object value) {\n+        BType targetJsonType = BTypes.typeJSON;\n+        try {\n+            return convert(value, targetJsonType, new ArrayList<>(), strand);\n+        } catch (Exception e) {\n+            return e;\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE,\n+                            ((RefValue) value).getType()));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (!TypeChecker.isConvertibleToJson(value, new ArrayList<>())) {\n+            return createConversionError(value, targetType);\n+        }\n+\n+        Object newValue;\n+        switch (TypeChecker.getType(value).getTag()) {\n+            case TypeTags.XML_TAG:\n+            case TypeTags.XML_ELEMENT_TAG:\n+            case TypeTags.XML_COMMENT_TAG:\n+            case TypeTags.XML_PI_TAG:\n+            case TypeTags.XML_TEXT_TAG:\n+                newValue = ToString.toString(strand, value);\n+                break;\n+            case TypeTags.TUPLE_TAG:\n+            case TypeTags.ARRAY_TAG:\n+                newValue = convertArrayToJson((ArrayValue) value, unresolvedValues, strand);\n+                break;\n+            case TypeTags.TABLE_TAG:\n+                try {\n+                    newValue = JSONUtils.toJSON((TableValueImpl) value);\n+                } catch (Exception e) {\n+                    throw createConversionError(value, targetType, e.getMessage());\n+                }\n+                break;\n+            case TypeTags.RECORD_TYPE_TAG:\n+            case TypeTags.MAP_TAG:\n+                newValue = convertMapToJson((MapValue<?, ?>) value, new BMapType(BTypes.typeJSON),\n+                        unresolvedValues, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:\n+                newValue = ((RefValue) value).copy(new HashMap<>());\n+                break;\n+            default:\n+                List<BType> convertibleTypes = TypeConverter.getConvertibleTypes(value, BTypes.typeJSON);\n+                if (convertibleTypes.size() == 0) {\n+                    throw createConversionError(value, targetType);\n+                } else if (convertibleTypes.size() > 1) {\n+                    throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+                }\n+\n+                BType sourceType = TypeChecker.getType(value);\n+                BType matchingType = convertibleTypes.get(0);\n+\n+                // handle primitive values\n+                if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+                    if (TypeChecker.checkIsType(value, matchingType)) {\n+                        newValue = value;\n+                    } else {\n+                        // Has to be a numeric conversion.\n+                        newValue = TypeConverter.convertValues(matchingType, value);\n+                    }\n+                } else {\n+                    throw createConversionError(value, targetType);\n+                }\n+                break;\n+        }\n+\n+        unresolvedValues.remove(typeValuePair);\n+        return newValue;\n+    }\n+\n+    private static Object convertMapToJson(MapValue<?, ?> map, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                           Strand strand) {\n+        MapValueImpl<BString, Object> newMap = new MapValueImpl<>(targetType);\n+        for (Map.Entry entry : map.entrySet()) {\n+            BType constraintType = ((BMapType) targetType).getConstrainedType();\n+            putToMap(newMap, entry, constraintType, unresolvedValues, strand);\n+        }\n+        return newMap;\n+    }\n+\n+    private static Object convertArrayToJson(ArrayValue array, List<TypeValuePair> unresolvedValues,\n+                                             Strand strand) {\n+        ArrayValueImpl newArray = new ArrayValueImpl(new BArrayType(BTypes.typeJSON));\n+        for (int i = 0; i < array.size(); i++) {\n+            Object newValue = convert(array.get(i), BTypes.typeJSON, unresolvedValues, strand);\n+            newArray.add(i, newValue);\n+        }\n+        return newArray;\n+    }\n+\n+    private static void putToMap(MapValue<BString, Object> map, Map.Entry entry, BType fieldType,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39bbe770806904ada758446ee80c9df6cfeed410"}, "originalPosition": 180}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY3Mzg2Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            @Test(enabled = true)\n          \n          \n            \n            @Test", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r449673862", "createdAt": "2020-07-03T18:06:36Z", "author": {"login": "MaryamZi"}, "path": "langlib/langlib-test/src/test/java/org/ballerinalang/langlib/test/LangLibValueTest.java", "diffHunk": "@@ -41,7 +41,7 @@\n  *\n  * @since 1.0\n  */\n-@Test(enabled = false)\n+@Test(enabled = true)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39bbe770806904ada758446ee80c9df6cfeed410"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY3NzYzNA==", "bodyText": "We can just remove (enabled = false). Please fix everywhere.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r449677634", "createdAt": "2020-07-03T18:26:39Z", "author": {"login": "MaryamZi"}, "path": "langlib/langlib-test/src/test/java/org/ballerinalang/langlib/test/LangLibValueTest.java", "diffHunk": "@@ -41,7 +41,7 @@\n  *\n  * @since 1.0\n  */\n-@Test(enabled = false)\n+@Test(enabled = true)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY3Mzg2Mg=="}, "originalCommit": {"oid": "39bbe770806904ada758446ee80c9df6cfeed410"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY3ODIyMw==", "bodyText": "Do we have to remove since we'll be creating a new list for each call to the method? Can you check others too.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r449678223", "createdAt": "2020-07-03T18:29:57Z", "author": {"login": "MaryamZi"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTableType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        try {\n+            return convert(v, describingType, new ArrayList<>(), t, strand);\n+        } catch (ErrorValue e) {\n+            return e;\n+        } catch (BallerinaException e) {\n+            return createError(VALUE_LANG_LIB_CONVERSION_ERROR, e.getDetail());\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+        BType sourceType = TypeChecker.getType(value);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE, sourceType));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        List<BType> convertibleTypes = TypeConverter.getConvertibleTypesFromJson(value, targetType, new ArrayList<>());\n+        if (convertibleTypes.isEmpty()) {\n+            throw createConversionError(value, targetType);\n+        } else if (convertibleTypes.size() > 1) {\n+            throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+        }\n+\n+        BType matchingType = convertibleTypes.get(0);\n+\n+        Object newValue;\n+        switch (sourceType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+            case TypeTags.RECORD_TYPE_TAG:\n+                newValue = convertMap((MapValue<?, ?>) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ARRAY_TAG:\n+            case TypeTags.TUPLE_TAG:\n+                newValue = convertArray((ArrayValue) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:\n+                newValue = ((RefValue) value).copy(new HashMap<>());\n+                break;\n+            default:\n+                if (((matchingType.getTag() >= TypeTags.XML_ELEMENT_TAG &&\n+                        matchingType.getTag() <= TypeTags.XML_TEXT_TAG) || matchingType.getTag() == TypeTags.XML_TAG)) {\n+                    try {\n+                        newValue = XMLFactory.parse(((StringValue) value).getValue());\n+                        break;\n+                    } catch (Throwable e) {\n+                        throw createConversionError(value, targetType, e.getMessage());\n+                    }\n+                }\n+\n+                // handle primitive values\n+                if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+                    if (TypeChecker.checkIsType(value, matchingType)) {\n+                        newValue = value;\n+                    } else {\n+                        // Has to be a numeric conversion.\n+                        newValue = TypeConverter.convertValues(matchingType, value);\n+                    }\n+                    break;\n+                }\n+                // should never reach here\n+                throw BallerinaErrors.createConversionError(value, targetType);\n+        }\n+\n+        unresolvedValues.remove(typeValuePair);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39bbe770806904ada758446ee80c9df6cfeed410"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY4MTQwMw==", "bodyText": "We need to consider maps also right? And arrays/tuples?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r449681403", "createdAt": "2020-07-03T18:47:41Z", "author": {"login": "MaryamZi"}, "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeConverter.java", "diffHunk": "@@ -263,7 +264,44 @@ static boolean isConvertibleToFloatingPointTypes(Object value) {\n         return convertibleTypes;\n     }\n \n-    private static boolean isConvertibleToRecordType(Object sourceValue, BRecordType targetType,\n+    public static List<BType> getConvertibleTypesFromJson(Object value, BType targetType,\n+                                                          List<TypeValuePair> unresolvedValues) {\n+        List<BType> convertibleTypes = new ArrayList<>();\n+\n+        int targetTypeTag = targetType.getTag();\n+\n+        convertibleTypes.addAll(TypeConverter.getConvertibleTypes(value, targetType));\n+\n+        if (convertibleTypes.size() == 0) {\n+            switch (targetTypeTag) {\n+                case TypeTags.RECORD_TYPE_TAG:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39bbe770806904ada758446ee80c9df6cfeed410"}, "originalPosition": 32}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQzODA5ODg4", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#pullrequestreview-443809888", "createdAt": "2020-07-07T11:42:47Z", "commit": {"oid": "39bbe770806904ada758446ee80c9df6cfeed410"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxMTo0Mjo0N1rOGt6xEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxMTo0Mjo0N1rOGt6xEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDgwMTkzOA==", "bodyText": "Can you also include a couple of tests where,\n\nthe variable type is anydata\nthe variable type is a record with an xml field", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r450801938", "createdAt": "2020-07-07T11:42:47Z", "author": {"login": "pubudu91"}, "path": "langlib/langlib-test/src/test/resources/test-src/valuelib_test.bal", "diffHunk": "@@ -50,6 +50,33 @@ function testToJsonString() returns map<string> {\n     return result;\n }\n \n+function testToJsonStringForNonJsonTypes() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39bbe770806904ada758446ee80c9df6cfeed410"}, "originalPosition": 4}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "39bbe770806904ada758446ee80c9df6cfeed410", "author": {"user": {"login": "dulajdilshan", "name": "Dulaj Dilshan"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/39bbe770806904ada758446ee80c9df6cfeed410", "committedDate": "2020-06-30T08:56:32Z", "message": "Fix error in the value lib test"}, "afterCommit": {"oid": "4eab681541972b946f574cd3232aae86a19cb817", "author": {"user": {"login": "dulajdilshan", "name": "Dulaj Dilshan"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/4eab681541972b946f574cd3232aae86a19cb817", "committedDate": "2020-07-08T23:16:23Z", "message": "Do requested changes"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4eab681541972b946f574cd3232aae86a19cb817", "author": {"user": {"login": "dulajdilshan", "name": "Dulaj Dilshan"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/4eab681541972b946f574cd3232aae86a19cb817", "committedDate": "2020-07-08T23:16:23Z", "message": "Do requested changes"}, "afterCommit": {"oid": "2a31013c144b3612838e874c86d65cdfd2702d49", "author": {"user": {"login": "dulajdilshan", "name": "Dulaj Dilshan"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2a31013c144b3612838e874c86d65cdfd2702d49", "committedDate": "2020-07-09T01:05:22Z", "message": "Do requested changes"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1eea7daf5d67590db796de7ddd0c4413ee6a63ca", "author": {"user": {"login": "dulajdilshan", "name": "Dulaj Dilshan"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1eea7daf5d67590db796de7ddd0c4413ee6a63ca", "committedDate": "2020-07-09T01:11:49Z", "message": "Remove isConvertibleToJson method in TypeChecker"}, "afterCommit": {"oid": "69a619558a21aedaa2ac5727653f1b03e548c99e", "author": {"user": {"login": "dulajdilshan", "name": "Dulaj Dilshan"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/69a619558a21aedaa2ac5727653f1b03e548c99e", "committedDate": "2020-07-09T09:20:03Z", "message": "Add more tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "18319d65386ad7772f516aed1adbb4e5ba4896f8", "author": {"user": {"login": "dulajdilshan", "name": "Dulaj Dilshan"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/18319d65386ad7772f516aed1adbb4e5ba4896f8", "committedDate": "2020-07-15T14:11:13Z", "message": "Add 'typeJsonArray' to BTypes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "584d1f4f88a7748393c236a367567ccd4113b8b1", "author": {"user": {"login": "dulajdilshan", "name": "Dulaj Dilshan"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/584d1f4f88a7748393c236a367567ccd4113b8b1", "committedDate": "2020-07-15T14:11:13Z", "message": "Add 'fromJsonWithType' langlib method"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "826fdf23b9d3eef7d7907a51ea8c768e957779b2", "author": {"user": {"login": "dulajdilshan", "name": "Dulaj Dilshan"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/826fdf23b9d3eef7d7907a51ea8c768e957779b2", "committedDate": "2020-07-15T14:11:13Z", "message": "Add 'fromJsonStringWithType' langlib method"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "08ec106ed797507f30ac84d2ddaabb73061138e2", "author": {"user": {"login": "dulajdilshan", "name": "Dulaj Dilshan"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/08ec106ed797507f30ac84d2ddaabb73061138e2", "committedDate": "2020-07-15T14:11:13Z", "message": "Add 'toJson' langlib method"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5a1a546bf0e5c85fcee5e882af47e2000976f9fc", "author": {"user": {"login": "dulajdilshan", "name": "Dulaj Dilshan"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/5a1a546bf0e5c85fcee5e882af47e2000976f9fc", "committedDate": "2020-07-15T14:11:13Z", "message": "Allow \"toJsonString\" lanlib method to support for anydata type"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e16087ac3c123daff005349f682b357e8413bb76", "author": {"user": {"login": "dulajdilshan", "name": "Dulaj Dilshan"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e16087ac3c123daff005349f682b357e8413bb76", "committedDate": "2020-07-15T14:11:13Z", "message": "Fix String to BString casting error"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7102f2b90bec1d8a9390d1ff8fafb1fc7ab3ad72", "author": {"user": {"login": "dulajdilshan", "name": "Dulaj Dilshan"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7102f2b90bec1d8a9390d1ff8fafb1fc7ab3ad72", "committedDate": "2020-07-15T14:11:13Z", "message": "Add test cases"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5e950db86a85c766a500ff5549178165b5365e5d", "author": {"user": {"login": "dulajdilshan", "name": "Dulaj Dilshan"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/5e950db86a85c766a500ff5549178165b5365e5d", "committedDate": "2020-07-15T14:11:13Z", "message": "Fix failing completion tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2b83515421b45e1e7d1b55aa65ed8409494cfeca", "author": {"user": {"login": "dulajdilshan", "name": "Dulaj Dilshan"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2b83515421b45e1e7d1b55aa65ed8409494cfeca", "committedDate": "2020-07-15T14:11:13Z", "message": "Order langlib function descriptions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bc38590c8df908dd7cf02cc1001c751330a02159", "author": {"user": {"login": "dulajdilshan", "name": "Dulaj Dilshan"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/bc38590c8df908dd7cf02cc1001c751330a02159", "committedDate": "2020-07-15T14:11:13Z", "message": "Change error message in 'fromJsonStringWithType' langlib method"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f34ad6fe935633d63c0a1756d276d4854db975cf", "author": {"user": {"login": "dulajdilshan", "name": "Dulaj Dilshan"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f34ad6fe935633d63c0a1756d276d4854db975cf", "committedDate": "2020-07-15T14:11:13Z", "message": "Add support for xml-typed fields in table to json conversion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c3d367ec5c9731c3200c4a7d8f36b58c2992d021", "author": {"user": {"login": "dulajdilshan", "name": "Dulaj Dilshan"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c3d367ec5c9731c3200c4a7d8f36b58c2992d021", "committedDate": "2020-07-15T14:11:13Z", "message": "Add json to table conversion in \"fromJsonWithType\" langlib method"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4bdd9da0f1679bf81679e3ecea87298c3edb861c", "author": {"user": {"login": "dulajdilshan", "name": "Dulaj Dilshan"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/4bdd9da0f1679bf81679e3ecea87298c3edb861c", "committedDate": "2020-07-15T14:11:13Z", "message": "Disable langlib value tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1bd08e5009ef6242c30a5e58f947ae8f68f8f289", "author": {"user": {"login": "dulajdilshan", "name": "Dulaj Dilshan"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1bd08e5009ef6242c30a5e58f947ae8f68f8f289", "committedDate": "2020-07-15T14:11:13Z", "message": "Fix 24247"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1f0ac42e95261685d1ff9640a7e9840d94921fd4", "author": {"user": {"login": "dulajdilshan", "name": "Dulaj Dilshan"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1f0ac42e95261685d1ff9640a7e9840d94921fd4", "committedDate": "2020-07-15T14:11:13Z", "message": "Fix errors in the langlib value tests"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "69a619558a21aedaa2ac5727653f1b03e548c99e", "author": {"user": {"login": "dulajdilshan", "name": "Dulaj Dilshan"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/69a619558a21aedaa2ac5727653f1b03e548c99e", "committedDate": "2020-07-09T09:20:03Z", "message": "Add more tests"}, "afterCommit": {"oid": "2e69a1cd29698b34530672d87c94c48f962da06d", "author": {"user": {"login": "dulajdilshan", "name": "Dulaj Dilshan"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2e69a1cd29698b34530672d87c94c48f962da06d", "committedDate": "2020-07-15T14:11:14Z", "message": "Add more tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ5MTIxMzQy", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#pullrequestreview-449121342", "createdAt": "2020-07-15T16:32:09Z", "commit": {"oid": "2e69a1cd29698b34530672d87c94c48f962da06d"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxNjozMjowOVrOGyF-qQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxNzo0MDo1M1rOGyI3zQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTE3OTk0NQ==", "bodyText": "This same method gets called for jsonutils:fromTable right? In that context, I am not sure if converting to string is the expected behaviour. I think what is expected is the result of applying jsonutils:fromXML. Shall we create an issue to track clarifying this with the stdlib team?\nI guess this is broken atm anyway, since record.getStringValue(key) is called for XML.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455179945", "createdAt": "2020-07-15T16:32:09Z", "author": {"login": "MaryamZi"}, "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TableJSONDataSource.java", "diffHunk": "@@ -159,7 +159,9 @@ private static void constructJsonData(MapValueImpl record, MapValue<BString, Obj\n                         getStructData(record.getMapValue(key), structFields, index, key));\n                 break;\n             case TypeTags.XML_TAG:\n-                jsonObject.put(StringUtils.fromString(name), record.getStringValue(key));\n+                BString strVal = org.ballerinalang.jvm.StringUtils.fromString(\n+                        org.ballerinalang.jvm.values.utils.StringUtils.getStringValue(record.get(key)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e69a1cd29698b34530672d87c94c48f962da06d"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTE4MDU1OQ==", "bodyText": "Checked with\nimport ballerina/jsonutils;\n\ntype Foo record {|\n    int i;\n    xml x;\n|};\n\npublic function main() {\n    table<Foo> tb = table [\n        {i: 1, x: xml `<foo>FOO</foo>`}\n    ];\n\n    json j = jsonutils:fromTable(tb);\n}\nFails with\n$ ballerina run qwe.bal \nCompiling source\n        qwe.bal\nRunning executables\n\nerror: java.lang.ClassCastException message=org.ballerinalang.jvm.values.XMLItem cannot be cast to org.ballerinalang.jvm.values.api.BString\n        at ballerina.0_5_0:externFromTable(jsonutils.bal:63)\n           ballerina.0_5_0:fromTable(jsonutils.bal:60)\n           qwe:main(qwe.bal:13)", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455180559", "createdAt": "2020-07-15T16:33:06Z", "author": {"login": "MaryamZi"}, "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TableJSONDataSource.java", "diffHunk": "@@ -159,7 +159,9 @@ private static void constructJsonData(MapValueImpl record, MapValue<BString, Obj\n                         getStructData(record.getMapValue(key), structFields, index, key));\n                 break;\n             case TypeTags.XML_TAG:\n-                jsonObject.put(StringUtils.fromString(name), record.getStringValue(key));\n+                BString strVal = org.ballerinalang.jvm.StringUtils.fromString(\n+                        org.ballerinalang.jvm.values.utils.StringUtils.getStringValue(record.get(key)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTE3OTk0NQ=="}, "originalCommit": {"oid": "2e69a1cd29698b34530672d87c94c48f962da06d"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTIyNzM0MQ==", "bodyText": "TypeConverter.getConvertibleTypes(value, targetType) calls isConvertibleToRecordType with isFromJson set to false right?\nWhat if targetType is a union of two records, say Foo|Bar, and the value is convertible to Foo even when  isFromJson is false in isConvertibleToRecordType, but it is only convertible to Bar when isFromJson is true?\nSo IINM, from L273 when we reach here convertibleTypes will only have Foo and we return that in L301. But if we actually check isConvertibleToRecordType(value, (BRecordType) targetType, true, unresolvedValues) it'll evaluate to true for Bar, and there'll actually be 2 convertible types?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455227341", "createdAt": "2020-07-15T17:40:53Z", "author": {"login": "MaryamZi"}, "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeConverter.java", "diffHunk": "@@ -263,7 +264,44 @@ static boolean isConvertibleToFloatingPointTypes(Object value) {\n         return convertibleTypes;\n     }\n \n-    private static boolean isConvertibleToRecordType(Object sourceValue, BRecordType targetType,\n+    public static List<BType> getConvertibleTypesFromJson(Object value, BType targetType,\n+                                                          List<TypeValuePair> unresolvedValues) {\n+        List<BType> convertibleTypes = new ArrayList<>();\n+\n+        int targetTypeTag = targetType.getTag();\n+\n+        convertibleTypes.addAll(TypeConverter.getConvertibleTypes(value, targetType));\n+\n+        if (convertibleTypes.size() == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e69a1cd29698b34530672d87c94c48f962da06d"}, "originalPosition": 30}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ5MjMyNDc2", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#pullrequestreview-449232476", "createdAt": "2020-07-15T18:41:07Z", "commit": {"oid": "2e69a1cd29698b34530672d87c94c48f962da06d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxODo0MTowN1rOGyLG6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxODo0MTowN1rOGyLG6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI2Mzk3OA==", "bodyText": "Re: the constraint, the spec says\n\nThe type specified by a row-type-parameter must be a subtype of map<any|error>\n\nSo it is always a record or a map right? Do we need this check?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455263978", "createdAt": "2020-07-15T18:41:07Z", "author": {"login": "MaryamZi"}, "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeConverter.java", "diffHunk": "@@ -263,7 +264,44 @@ static boolean isConvertibleToFloatingPointTypes(Object value) {\n         return convertibleTypes;\n     }\n \n-    private static boolean isConvertibleToRecordType(Object sourceValue, BRecordType targetType,\n+    public static List<BType> getConvertibleTypesFromJson(Object value, BType targetType,\n+                                                          List<TypeValuePair> unresolvedValues) {\n+        List<BType> convertibleTypes = new ArrayList<>();\n+\n+        int targetTypeTag = targetType.getTag();\n+\n+        convertibleTypes.addAll(TypeConverter.getConvertibleTypes(value, targetType));\n+\n+        if (convertibleTypes.size() == 0) {\n+            switch (targetTypeTag) {\n+                case TypeTags.RECORD_TYPE_TAG:\n+                    if (isConvertibleToRecordType(value, (BRecordType) targetType, true, unresolvedValues)) {\n+                        convertibleTypes.add(targetType);\n+                    }\n+                    break;\n+                case TypeTags.TABLE_TAG:\n+                    if (((BTableType) targetType).getConstrainedType().getTag() == TypeTags.RECORD_TYPE_TAG ||\n+                            ((BTableType) targetType).getConstrainedType().getTag() == TypeTags.MAP_TAG) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e69a1cd29698b34530672d87c94c48f962da06d"}, "originalPosition": 39}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ5MjQ0ODYw", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#pullrequestreview-449244860", "createdAt": "2020-07-15T18:58:22Z", "commit": {"oid": "2e69a1cd29698b34530672d87c94c48f962da06d"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxODo1ODoyMlrOGyLtSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxOTozMjoyM1rOGyM26Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI3MzgwMg==", "bodyText": "Do we need this default case?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455273802", "createdAt": "2020-07-15T18:58:22Z", "author": {"login": "MaryamZi"}, "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeConverter.java", "diffHunk": "@@ -263,7 +264,44 @@ static boolean isConvertibleToFloatingPointTypes(Object value) {\n         return convertibleTypes;\n     }\n \n-    private static boolean isConvertibleToRecordType(Object sourceValue, BRecordType targetType,\n+    public static List<BType> getConvertibleTypesFromJson(Object value, BType targetType,\n+                                                          List<TypeValuePair> unresolvedValues) {\n+        List<BType> convertibleTypes = new ArrayList<>();\n+\n+        int targetTypeTag = targetType.getTag();\n+\n+        convertibleTypes.addAll(TypeConverter.getConvertibleTypes(value, targetType));\n+\n+        if (convertibleTypes.size() == 0) {\n+            switch (targetTypeTag) {\n+                case TypeTags.RECORD_TYPE_TAG:\n+                    if (isConvertibleToRecordType(value, (BRecordType) targetType, true, unresolvedValues)) {\n+                        convertibleTypes.add(targetType);\n+                    }\n+                    break;\n+                case TypeTags.TABLE_TAG:\n+                    if (((BTableType) targetType).getConstrainedType().getTag() == TypeTags.RECORD_TYPE_TAG ||\n+                            ((BTableType) targetType).getConstrainedType().getTag() == TypeTags.MAP_TAG) {\n+                        convertibleTypes.add(targetType);\n+                    }\n+                    break;\n+                case TypeTags.XML_TAG:\n+                case TypeTags.XML_ELEMENT_TAG:\n+                case TypeTags.XML_COMMENT_TAG:\n+                case TypeTags.XML_PI_TAG:\n+                case TypeTags.XML_TEXT_TAG:\n+                    if (TypeChecker.getType(value).getTag() == TypeTags.STRING_TAG) {\n+                        convertibleTypes.add(targetType);\n+                    }\n+                    break;\n+                default:\n+                    break;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e69a1cd29698b34530672d87c94c48f962da06d"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI4MDM1Mg==", "bodyText": "The only difference in the if and else blocks is the method called right? The arguments are all the same? Instead of the isFromJson parameter can we not use something like a functional interface, which I believe is what @rdhananjaya also suggested once.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455280352", "createdAt": "2020-07-15T19:10:09Z", "author": {"login": "MaryamZi"}, "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeConverter.java", "diffHunk": "@@ -299,17 +337,33 @@ private static boolean isConvertibleToRecordType(Object sourceValue, BRecordType\n             Map.Entry valueEntry = (Map.Entry) object;\n             String fieldName = valueEntry.getKey().toString();\n \n-            if (targetFieldTypes.containsKey(fieldName)) {\n-                if (getConvertibleTypes(valueEntry.getValue(), targetFieldTypes.get(fieldName),\n-                                        unresolvedValues).size() != 1) {\n+            if (isFromJson) {\n+                if (targetFieldTypes.containsKey(fieldName)) {\n+                    if (getConvertibleTypesFromJson(valueEntry.getValue(), targetFieldTypes.get(fieldName),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e69a1cd29698b34530672d87c94c48f962da06d"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI5MTEyOQ==", "bodyText": "We need to check if the target type is nilable.\nThe folowing crashes.\ntype IntMap map<int>;\n\npublic function main() {\n    string s = \"null\";\n\n    map<int> m = checkpanic s.fromJsonStringWithType(IntMap); // doesn't panic\n\n    int i = m.get(\"first\");\n}\nThe get fails with an NPE in the internal log.\n[2020-07-16 00:57:59,786] SEVERE {b7a.log.crash} - null \njava.lang.NullPointerException\n\tat org.ballerinalang.langlib.map.Get.get(Get.java:45)\n\tat ballerina.lang_map.1_1_0.map.get(map.bal:51)\n\tat qwe.main(qwe.bal:8)\n\tat ___init.$lambda$main$(.)\n\tat org.ballerinalang.jvm.scheduling.SchedulerItem.execute(Scheduler.java:500)\n\tat org.ballerinalang.jvm.scheduling.Scheduler.run(Scheduler.java:276)\n\tat org.ballerinalang.jvm.scheduling.Scheduler.runSafely(Scheduler.java:244)\n\tat java.lang.Thread.run(Thread.java:745)", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455291129", "createdAt": "2020-07-15T19:29:32Z", "author": {"login": "MaryamZi"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonStringWithType.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.JSONParser;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.model.types.TypeKind;\n+import org.ballerinalang.natives.annotations.Argument;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+import org.ballerinalang.natives.annotations.ReturnType;\n+\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CONVERSION_ERROR;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ * Converts a string in JSON format to a user-specified type.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonStringWithType\",\n+        args = {\n+                @Argument(name = \"str\", type = TypeKind.STRING),\n+                @Argument(name = \"t\", type = TypeKind.TYPEDESC)\n+        },\n+        returnType = {\n+                @ReturnType(type = TypeKind.ANYDATA),\n+                @ReturnType(type = TypeKind.ERROR)\n+        },\n+        isPublic = true\n+)\n+public class FromJsonStringWithType {\n+\n+    public static Object fromJsonStringWithType(Strand strand, BString value, TypedescValue t) {\n+\n+        String str = value.getValue();\n+        if (str.equals(\"null\")) {\n+            return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e69a1cd29698b34530672d87c94c48f962da06d"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI5MjY0OQ==", "bodyText": "Do we need to special case \"null\" anyway? The JSONParser and FromJsonWithType.fromJsonWithType will handle this properly right?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455292649", "createdAt": "2020-07-15T19:32:23Z", "author": {"login": "MaryamZi"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonStringWithType.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.JSONParser;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.model.types.TypeKind;\n+import org.ballerinalang.natives.annotations.Argument;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+import org.ballerinalang.natives.annotations.ReturnType;\n+\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CONVERSION_ERROR;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ * Converts a string in JSON format to a user-specified type.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonStringWithType\",\n+        args = {\n+                @Argument(name = \"str\", type = TypeKind.STRING),\n+                @Argument(name = \"t\", type = TypeKind.TYPEDESC)\n+        },\n+        returnType = {\n+                @ReturnType(type = TypeKind.ANYDATA),\n+                @ReturnType(type = TypeKind.ERROR)\n+        },\n+        isPublic = true\n+)\n+public class FromJsonStringWithType {\n+\n+    public static Object fromJsonStringWithType(Strand strand, BString value, TypedescValue t) {\n+\n+        String str = value.getValue();\n+        if (str.equals(\"null\")) {\n+            return null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI5MTEyOQ=="}, "originalCommit": {"oid": "2e69a1cd29698b34530672d87c94c48f962da06d"}, "originalPosition": 61}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ5MjczMzQ0", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#pullrequestreview-449273344", "createdAt": "2020-07-15T19:40:17Z", "commit": {"oid": "2e69a1cd29698b34530672d87c94c48f962da06d"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxOTo0MDoxN1rOGyNG1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQyMDo1NTo1N1rOGyPjjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI5NjcyNQ==", "bodyText": "A json value can never hold an error. Do we need this case?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455296725", "createdAt": "2020-07-15T19:40:17Z", "author": {"login": "MaryamZi"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTableType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        try {\n+            return convert(v, describingType, new ArrayList<>(), t, strand);\n+        } catch (ErrorValue e) {\n+            return e;\n+        } catch (BallerinaException e) {\n+            return createError(VALUE_LANG_LIB_CONVERSION_ERROR, e.getDetail());\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+        BType sourceType = TypeChecker.getType(value);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE, sourceType));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        List<BType> convertibleTypes = TypeConverter.getConvertibleTypesFromJson(value, targetType, new ArrayList<>());\n+        if (convertibleTypes.isEmpty()) {\n+            throw createConversionError(value, targetType);\n+        } else if (convertibleTypes.size() > 1) {\n+            throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+        }\n+\n+        BType matchingType = convertibleTypes.get(0);\n+\n+        Object newValue;\n+        switch (sourceType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+            case TypeTags.RECORD_TYPE_TAG:\n+                newValue = convertMap((MapValue<?, ?>) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ARRAY_TAG:\n+            case TypeTags.TUPLE_TAG:\n+                newValue = convertArray((ArrayValue) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:\n+                newValue = ((RefValue) value).copy(new HashMap<>());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e69a1cd29698b34530672d87c94c48f962da06d"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMxMjg0OA==", "bodyText": "Can't we use org.ballerinalang.jvm.types.TypeTags#isXMLTypeTag here instead?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455312848", "createdAt": "2020-07-15T20:10:33Z", "author": {"login": "MaryamZi"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTableType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        try {\n+            return convert(v, describingType, new ArrayList<>(), t, strand);\n+        } catch (ErrorValue e) {\n+            return e;\n+        } catch (BallerinaException e) {\n+            return createError(VALUE_LANG_LIB_CONVERSION_ERROR, e.getDetail());\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+        BType sourceType = TypeChecker.getType(value);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE, sourceType));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        List<BType> convertibleTypes = TypeConverter.getConvertibleTypesFromJson(value, targetType, new ArrayList<>());\n+        if (convertibleTypes.isEmpty()) {\n+            throw createConversionError(value, targetType);\n+        } else if (convertibleTypes.size() > 1) {\n+            throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+        }\n+\n+        BType matchingType = convertibleTypes.get(0);\n+\n+        Object newValue;\n+        switch (sourceType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+            case TypeTags.RECORD_TYPE_TAG:\n+                newValue = convertMap((MapValue<?, ?>) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ARRAY_TAG:\n+            case TypeTags.TUPLE_TAG:\n+                newValue = convertArray((ArrayValue) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:\n+                newValue = ((RefValue) value).copy(new HashMap<>());\n+                break;\n+            default:\n+                if (((matchingType.getTag() >= TypeTags.XML_ELEMENT_TAG &&\n+                        matchingType.getTag() <= TypeTags.XML_TEXT_TAG) || matchingType.getTag() == TypeTags.XML_TAG)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e69a1cd29698b34530672d87c94c48f962da06d"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMxOTI0OQ==", "bodyText": "We should move this out of the for loop, or we'll be extracting the constraint per entry.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455319249", "createdAt": "2020-07-15T20:22:39Z", "author": {"login": "MaryamZi"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTableType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        try {\n+            return convert(v, describingType, new ArrayList<>(), t, strand);\n+        } catch (ErrorValue e) {\n+            return e;\n+        } catch (BallerinaException e) {\n+            return createError(VALUE_LANG_LIB_CONVERSION_ERROR, e.getDetail());\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+        BType sourceType = TypeChecker.getType(value);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE, sourceType));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        List<BType> convertibleTypes = TypeConverter.getConvertibleTypesFromJson(value, targetType, new ArrayList<>());\n+        if (convertibleTypes.isEmpty()) {\n+            throw createConversionError(value, targetType);\n+        } else if (convertibleTypes.size() > 1) {\n+            throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+        }\n+\n+        BType matchingType = convertibleTypes.get(0);\n+\n+        Object newValue;\n+        switch (sourceType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+            case TypeTags.RECORD_TYPE_TAG:\n+                newValue = convertMap((MapValue<?, ?>) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ARRAY_TAG:\n+            case TypeTags.TUPLE_TAG:\n+                newValue = convertArray((ArrayValue) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:\n+                newValue = ((RefValue) value).copy(new HashMap<>());\n+                break;\n+            default:\n+                if (((matchingType.getTag() >= TypeTags.XML_ELEMENT_TAG &&\n+                        matchingType.getTag() <= TypeTags.XML_TEXT_TAG) || matchingType.getTag() == TypeTags.XML_TAG)) {\n+                    try {\n+                        newValue = XMLFactory.parse(((StringValue) value).getValue());\n+                        break;\n+                    } catch (Throwable e) {\n+                        throw createConversionError(value, targetType, e.getMessage());\n+                    }\n+                }\n+\n+                // handle primitive values\n+                if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+                    if (TypeChecker.checkIsType(value, matchingType)) {\n+                        newValue = value;\n+                    } else {\n+                        // Has to be a numeric conversion.\n+                        newValue = TypeConverter.convertValues(matchingType, value);\n+                    }\n+                    break;\n+                }\n+                // should never reach here\n+                throw BallerinaErrors.createConversionError(value, targetType);\n+        }\n+\n+        unresolvedValues.remove(typeValuePair);\n+        return newValue;\n+    }\n+\n+    private static Object convertMap(MapValue<?, ?> map, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                     TypedescValue t, Strand strand) {\n+        switch (targetType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+                MapValueImpl<BString, Object> newMap = new MapValueImpl<>(targetType);\n+                for (Map.Entry entry : map.entrySet()) {\n+                    BType constraintType = ((BMapType) targetType).getConstrainedType();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e69a1cd29698b34530672d87c94c48f962da06d"}, "originalPosition": 167}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMyMTA1Mg==", "bodyText": "This also we don't need right?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455321052", "createdAt": "2020-07-15T20:26:01Z", "author": {"login": "MaryamZi"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTableType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        try {\n+            return convert(v, describingType, new ArrayList<>(), t, strand);\n+        } catch (ErrorValue e) {\n+            return e;\n+        } catch (BallerinaException e) {\n+            return createError(VALUE_LANG_LIB_CONVERSION_ERROR, e.getDetail());\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+        BType sourceType = TypeChecker.getType(value);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE, sourceType));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        List<BType> convertibleTypes = TypeConverter.getConvertibleTypesFromJson(value, targetType, new ArrayList<>());\n+        if (convertibleTypes.isEmpty()) {\n+            throw createConversionError(value, targetType);\n+        } else if (convertibleTypes.size() > 1) {\n+            throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+        }\n+\n+        BType matchingType = convertibleTypes.get(0);\n+\n+        Object newValue;\n+        switch (sourceType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+            case TypeTags.RECORD_TYPE_TAG:\n+                newValue = convertMap((MapValue<?, ?>) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ARRAY_TAG:\n+            case TypeTags.TUPLE_TAG:\n+                newValue = convertArray((ArrayValue) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:\n+                newValue = ((RefValue) value).copy(new HashMap<>());\n+                break;\n+            default:\n+                if (((matchingType.getTag() >= TypeTags.XML_ELEMENT_TAG &&\n+                        matchingType.getTag() <= TypeTags.XML_TEXT_TAG) || matchingType.getTag() == TypeTags.XML_TAG)) {\n+                    try {\n+                        newValue = XMLFactory.parse(((StringValue) value).getValue());\n+                        break;\n+                    } catch (Throwable e) {\n+                        throw createConversionError(value, targetType, e.getMessage());\n+                    }\n+                }\n+\n+                // handle primitive values\n+                if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+                    if (TypeChecker.checkIsType(value, matchingType)) {\n+                        newValue = value;\n+                    } else {\n+                        // Has to be a numeric conversion.\n+                        newValue = TypeConverter.convertValues(matchingType, value);\n+                    }\n+                    break;\n+                }\n+                // should never reach here\n+                throw BallerinaErrors.createConversionError(value, targetType);\n+        }\n+\n+        unresolvedValues.remove(typeValuePair);\n+        return newValue;\n+    }\n+\n+    private static Object convertMap(MapValue<?, ?> map, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                     TypedescValue t, Strand strand) {\n+        switch (targetType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+                MapValueImpl<BString, Object> newMap = new MapValueImpl<>(targetType);\n+                for (Map.Entry entry : map.entrySet()) {\n+                    BType constraintType = ((BMapType) targetType).getConstrainedType();\n+                    putToMap(newMap, entry, constraintType, unresolvedValues, t, strand);\n+                }\n+                return newMap;\n+            case TypeTags.RECORD_TYPE_TAG:\n+                BRecordType recordType = (BRecordType) targetType;\n+                MapValueImpl<BString, Object> newRecord;\n+                if (t != null && t.getDescribingType() == targetType) {\n+                    newRecord = (MapValueImpl<BString, Object>) t.instantiate(strand);\n+                } else {\n+                    newRecord = (MapValueImpl<BString, Object>) BallerinaValues\n+                            .createRecordValue(recordType.getPackage(), recordType.getName());\n+                }\n+\n+                BType restFieldType = recordType.restFieldType;\n+                Map<String, BType> targetTypeField = new HashMap<>();\n+                for (BField field : recordType.getFields().values()) {\n+                    targetTypeField.put(field.getFieldName(), field.getFieldType());\n+                }\n+\n+                for (Map.Entry entry : map.entrySet()) {\n+                    BType fieldType = targetTypeField.getOrDefault(entry.getKey().toString(), restFieldType);\n+                    putToMap(newRecord, entry, fieldType, unresolvedValues, t, strand);\n+                }\n+                return newRecord;\n+            case TypeTags.JSON_TAG:\n+                BType matchingType = TypeConverter.resolveMatchingTypeForUnion(map, targetType);\n+                return convert(map, matchingType, unresolvedValues, t, strand);\n+            default:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e69a1cd29698b34530672d87c94c48f962da06d"}, "originalPosition": 195}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMyMjc4NA==", "bodyText": "Better to pass the targetType itself instead of BTypes.typeJSON since it could be json & readonly.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455322784", "createdAt": "2020-07-15T20:29:17Z", "author": {"login": "MaryamZi"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTableType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        try {\n+            return convert(v, describingType, new ArrayList<>(), t, strand);\n+        } catch (ErrorValue e) {\n+            return e;\n+        } catch (BallerinaException e) {\n+            return createError(VALUE_LANG_LIB_CONVERSION_ERROR, e.getDetail());\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+        BType sourceType = TypeChecker.getType(value);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE, sourceType));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        List<BType> convertibleTypes = TypeConverter.getConvertibleTypesFromJson(value, targetType, new ArrayList<>());\n+        if (convertibleTypes.isEmpty()) {\n+            throw createConversionError(value, targetType);\n+        } else if (convertibleTypes.size() > 1) {\n+            throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+        }\n+\n+        BType matchingType = convertibleTypes.get(0);\n+\n+        Object newValue;\n+        switch (sourceType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+            case TypeTags.RECORD_TYPE_TAG:\n+                newValue = convertMap((MapValue<?, ?>) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ARRAY_TAG:\n+            case TypeTags.TUPLE_TAG:\n+                newValue = convertArray((ArrayValue) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:\n+                newValue = ((RefValue) value).copy(new HashMap<>());\n+                break;\n+            default:\n+                if (((matchingType.getTag() >= TypeTags.XML_ELEMENT_TAG &&\n+                        matchingType.getTag() <= TypeTags.XML_TEXT_TAG) || matchingType.getTag() == TypeTags.XML_TAG)) {\n+                    try {\n+                        newValue = XMLFactory.parse(((StringValue) value).getValue());\n+                        break;\n+                    } catch (Throwable e) {\n+                        throw createConversionError(value, targetType, e.getMessage());\n+                    }\n+                }\n+\n+                // handle primitive values\n+                if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+                    if (TypeChecker.checkIsType(value, matchingType)) {\n+                        newValue = value;\n+                    } else {\n+                        // Has to be a numeric conversion.\n+                        newValue = TypeConverter.convertValues(matchingType, value);\n+                    }\n+                    break;\n+                }\n+                // should never reach here\n+                throw BallerinaErrors.createConversionError(value, targetType);\n+        }\n+\n+        unresolvedValues.remove(typeValuePair);\n+        return newValue;\n+    }\n+\n+    private static Object convertMap(MapValue<?, ?> map, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                     TypedescValue t, Strand strand) {\n+        switch (targetType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+                MapValueImpl<BString, Object> newMap = new MapValueImpl<>(targetType);\n+                for (Map.Entry entry : map.entrySet()) {\n+                    BType constraintType = ((BMapType) targetType).getConstrainedType();\n+                    putToMap(newMap, entry, constraintType, unresolvedValues, t, strand);\n+                }\n+                return newMap;\n+            case TypeTags.RECORD_TYPE_TAG:\n+                BRecordType recordType = (BRecordType) targetType;\n+                MapValueImpl<BString, Object> newRecord;\n+                if (t != null && t.getDescribingType() == targetType) {\n+                    newRecord = (MapValueImpl<BString, Object>) t.instantiate(strand);\n+                } else {\n+                    newRecord = (MapValueImpl<BString, Object>) BallerinaValues\n+                            .createRecordValue(recordType.getPackage(), recordType.getName());\n+                }\n+\n+                BType restFieldType = recordType.restFieldType;\n+                Map<String, BType> targetTypeField = new HashMap<>();\n+                for (BField field : recordType.getFields().values()) {\n+                    targetTypeField.put(field.getFieldName(), field.getFieldType());\n+                }\n+\n+                for (Map.Entry entry : map.entrySet()) {\n+                    BType fieldType = targetTypeField.getOrDefault(entry.getKey().toString(), restFieldType);\n+                    putToMap(newRecord, entry, fieldType, unresolvedValues, t, strand);\n+                }\n+                return newRecord;\n+            case TypeTags.JSON_TAG:\n+                BType matchingType = TypeConverter.resolveMatchingTypeForUnion(map, targetType);\n+                return convert(map, matchingType, unresolvedValues, t, strand);\n+            default:\n+                break;\n+        }\n+        // should never reach here\n+        throw BallerinaErrors.createConversionError(map, targetType);\n+    }\n+\n+\n+    private static Object convertArray(ArrayValue array, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                       TypedescValue t, Strand strand) {\n+        switch (targetType.getTag()) {\n+            case TypeTags.ARRAY_TAG:\n+                BArrayType arrayType = (BArrayType) targetType;\n+                ArrayValueImpl newArray = new ArrayValueImpl(arrayType);\n+                for (int i = 0; i < array.size(); i++) {\n+                    Object newValue = convert(array.get(i), arrayType.getElementType(), unresolvedValues, t, strand);\n+                    newArray.add(i, newValue);\n+                }\n+                return newArray;\n+            case TypeTags.TUPLE_TAG:\n+                BTupleType tupleType = (BTupleType) targetType;\n+                TupleValueImpl newTuple = new TupleValueImpl(tupleType);\n+                int minLen = tupleType.getTupleTypes().size();\n+                for (int i = 0; i < array.size(); i++) {\n+                    BType elementType = (i < minLen) ? tupleType.getTupleTypes().get(i) : tupleType.getRestType();\n+                    Object newValue = convert(array.get(i), elementType, unresolvedValues, t, strand);\n+                    newTuple.add(i, newValue);\n+                }\n+                return newTuple;\n+            case TypeTags.JSON_TAG:\n+                newArray = new ArrayValueImpl((BArrayType) BTypes.typeJsonArray);\n+                for (int i = 0; i < array.size(); i++) {\n+                    Object newValue = convert(array.get(i), BTypes.typeJSON, unresolvedValues, t, strand);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e69a1cd29698b34530672d87c94c48f962da06d"}, "originalPosition": 227}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMyMzgwNw==", "bodyText": "Why do we create a new type?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455323807", "createdAt": "2020-07-15T20:31:12Z", "author": {"login": "MaryamZi"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTableType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        try {\n+            return convert(v, describingType, new ArrayList<>(), t, strand);\n+        } catch (ErrorValue e) {\n+            return e;\n+        } catch (BallerinaException e) {\n+            return createError(VALUE_LANG_LIB_CONVERSION_ERROR, e.getDetail());\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+        BType sourceType = TypeChecker.getType(value);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE, sourceType));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        List<BType> convertibleTypes = TypeConverter.getConvertibleTypesFromJson(value, targetType, new ArrayList<>());\n+        if (convertibleTypes.isEmpty()) {\n+            throw createConversionError(value, targetType);\n+        } else if (convertibleTypes.size() > 1) {\n+            throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+        }\n+\n+        BType matchingType = convertibleTypes.get(0);\n+\n+        Object newValue;\n+        switch (sourceType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+            case TypeTags.RECORD_TYPE_TAG:\n+                newValue = convertMap((MapValue<?, ?>) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ARRAY_TAG:\n+            case TypeTags.TUPLE_TAG:\n+                newValue = convertArray((ArrayValue) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:\n+                newValue = ((RefValue) value).copy(new HashMap<>());\n+                break;\n+            default:\n+                if (((matchingType.getTag() >= TypeTags.XML_ELEMENT_TAG &&\n+                        matchingType.getTag() <= TypeTags.XML_TEXT_TAG) || matchingType.getTag() == TypeTags.XML_TAG)) {\n+                    try {\n+                        newValue = XMLFactory.parse(((StringValue) value).getValue());\n+                        break;\n+                    } catch (Throwable e) {\n+                        throw createConversionError(value, targetType, e.getMessage());\n+                    }\n+                }\n+\n+                // handle primitive values\n+                if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+                    if (TypeChecker.checkIsType(value, matchingType)) {\n+                        newValue = value;\n+                    } else {\n+                        // Has to be a numeric conversion.\n+                        newValue = TypeConverter.convertValues(matchingType, value);\n+                    }\n+                    break;\n+                }\n+                // should never reach here\n+                throw BallerinaErrors.createConversionError(value, targetType);\n+        }\n+\n+        unresolvedValues.remove(typeValuePair);\n+        return newValue;\n+    }\n+\n+    private static Object convertMap(MapValue<?, ?> map, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                     TypedescValue t, Strand strand) {\n+        switch (targetType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+                MapValueImpl<BString, Object> newMap = new MapValueImpl<>(targetType);\n+                for (Map.Entry entry : map.entrySet()) {\n+                    BType constraintType = ((BMapType) targetType).getConstrainedType();\n+                    putToMap(newMap, entry, constraintType, unresolvedValues, t, strand);\n+                }\n+                return newMap;\n+            case TypeTags.RECORD_TYPE_TAG:\n+                BRecordType recordType = (BRecordType) targetType;\n+                MapValueImpl<BString, Object> newRecord;\n+                if (t != null && t.getDescribingType() == targetType) {\n+                    newRecord = (MapValueImpl<BString, Object>) t.instantiate(strand);\n+                } else {\n+                    newRecord = (MapValueImpl<BString, Object>) BallerinaValues\n+                            .createRecordValue(recordType.getPackage(), recordType.getName());\n+                }\n+\n+                BType restFieldType = recordType.restFieldType;\n+                Map<String, BType> targetTypeField = new HashMap<>();\n+                for (BField field : recordType.getFields().values()) {\n+                    targetTypeField.put(field.getFieldName(), field.getFieldType());\n+                }\n+\n+                for (Map.Entry entry : map.entrySet()) {\n+                    BType fieldType = targetTypeField.getOrDefault(entry.getKey().toString(), restFieldType);\n+                    putToMap(newRecord, entry, fieldType, unresolvedValues, t, strand);\n+                }\n+                return newRecord;\n+            case TypeTags.JSON_TAG:\n+                BType matchingType = TypeConverter.resolveMatchingTypeForUnion(map, targetType);\n+                return convert(map, matchingType, unresolvedValues, t, strand);\n+            default:\n+                break;\n+        }\n+        // should never reach here\n+        throw BallerinaErrors.createConversionError(map, targetType);\n+    }\n+\n+\n+    private static Object convertArray(ArrayValue array, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                       TypedescValue t, Strand strand) {\n+        switch (targetType.getTag()) {\n+            case TypeTags.ARRAY_TAG:\n+                BArrayType arrayType = (BArrayType) targetType;\n+                ArrayValueImpl newArray = new ArrayValueImpl(arrayType);\n+                for (int i = 0; i < array.size(); i++) {\n+                    Object newValue = convert(array.get(i), arrayType.getElementType(), unresolvedValues, t, strand);\n+                    newArray.add(i, newValue);\n+                }\n+                return newArray;\n+            case TypeTags.TUPLE_TAG:\n+                BTupleType tupleType = (BTupleType) targetType;\n+                TupleValueImpl newTuple = new TupleValueImpl(tupleType);\n+                int minLen = tupleType.getTupleTypes().size();\n+                for (int i = 0; i < array.size(); i++) {\n+                    BType elementType = (i < minLen) ? tupleType.getTupleTypes().get(i) : tupleType.getRestType();\n+                    Object newValue = convert(array.get(i), elementType, unresolvedValues, t, strand);\n+                    newTuple.add(i, newValue);\n+                }\n+                return newTuple;\n+            case TypeTags.JSON_TAG:\n+                newArray = new ArrayValueImpl((BArrayType) BTypes.typeJsonArray);\n+                for (int i = 0; i < array.size(); i++) {\n+                    Object newValue = convert(array.get(i), BTypes.typeJSON, unresolvedValues, t, strand);\n+                    newArray.add(i, newValue);\n+                }\n+                return newArray;\n+            case TypeTags.TABLE_TAG:\n+                BTableType tableType = (BTableType) targetType;\n+\n+                BTableType newTableType = new BTableType(tableType.getConstrainedType(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e69a1cd29698b34530672d87c94c48f962da06d"}, "originalPosition": 234}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMzNjg0Ng==", "bodyText": "Do we ever reach here? All the numeric basic types are both anydata and json. So, I don't think you'll ever have to do a numeric conversion?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455336846", "createdAt": "2020-07-15T20:55:57Z", "author": {"login": "MaryamZi"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.JSONUtils;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:toJson.\n+ * Converts a value of type `anydata` to `json`.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"toJson\",\n+        isPublic = true\n+)\n+public class ToJson {\n+\n+    public static Object toJson(Strand strand, Object value) {\n+        try {\n+            return convert(value, new ArrayList<>(), strand);\n+        } catch (Exception e) {\n+            return e;\n+        }\n+    }\n+\n+    private static Object convert(Object value, List<TypeValuePair> unresolvedValues, Strand strand) {\n+        BType jsonType = BTypes.typeJSON;\n+\n+        if (value == null) {\n+            return null;\n+        }\n+\n+        BType sourceType = TypeChecker.getType(value);\n+\n+        if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+            if (TypeChecker.checkIsType(value, jsonType)) {\n+                return value;\n+            } else {\n+                // Has to be a numeric conversion.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e69a1cd29698b34530672d87c94c48f962da06d"}, "originalPosition": 89}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ5NjI0MzE4", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#pullrequestreview-449624318", "createdAt": "2020-07-16T08:20:17Z", "commit": {"oid": "2e69a1cd29698b34530672d87c94c48f962da06d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQwODoyMDoxN1rOGygNgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQwODoyMDoxN1rOGygNgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTYwOTcyOQ==", "bodyText": "Do we need this null check here? t can never be null right?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455609729", "createdAt": "2020-07-16T08:20:17Z", "author": {"login": "pubudu91"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTableType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        try {\n+            return convert(v, describingType, new ArrayList<>(), t, strand);\n+        } catch (ErrorValue e) {\n+            return e;\n+        } catch (BallerinaException e) {\n+            return createError(VALUE_LANG_LIB_CONVERSION_ERROR, e.getDetail());\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+        BType sourceType = TypeChecker.getType(value);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE, sourceType));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        List<BType> convertibleTypes = TypeConverter.getConvertibleTypesFromJson(value, targetType, new ArrayList<>());\n+        if (convertibleTypes.isEmpty()) {\n+            throw createConversionError(value, targetType);\n+        } else if (convertibleTypes.size() > 1) {\n+            throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+        }\n+\n+        BType matchingType = convertibleTypes.get(0);\n+\n+        Object newValue;\n+        switch (sourceType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+            case TypeTags.RECORD_TYPE_TAG:\n+                newValue = convertMap((MapValue<?, ?>) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ARRAY_TAG:\n+            case TypeTags.TUPLE_TAG:\n+                newValue = convertArray((ArrayValue) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:\n+                newValue = ((RefValue) value).copy(new HashMap<>());\n+                break;\n+            default:\n+                if (((matchingType.getTag() >= TypeTags.XML_ELEMENT_TAG &&\n+                        matchingType.getTag() <= TypeTags.XML_TEXT_TAG) || matchingType.getTag() == TypeTags.XML_TAG)) {\n+                    try {\n+                        newValue = XMLFactory.parse(((StringValue) value).getValue());\n+                        break;\n+                    } catch (Throwable e) {\n+                        throw createConversionError(value, targetType, e.getMessage());\n+                    }\n+                }\n+\n+                // handle primitive values\n+                if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+                    if (TypeChecker.checkIsType(value, matchingType)) {\n+                        newValue = value;\n+                    } else {\n+                        // Has to be a numeric conversion.\n+                        newValue = TypeConverter.convertValues(matchingType, value);\n+                    }\n+                    break;\n+                }\n+                // should never reach here\n+                throw BallerinaErrors.createConversionError(value, targetType);\n+        }\n+\n+        unresolvedValues.remove(typeValuePair);\n+        return newValue;\n+    }\n+\n+    private static Object convertMap(MapValue<?, ?> map, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                     TypedescValue t, Strand strand) {\n+        switch (targetType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+                MapValueImpl<BString, Object> newMap = new MapValueImpl<>(targetType);\n+                for (Map.Entry entry : map.entrySet()) {\n+                    BType constraintType = ((BMapType) targetType).getConstrainedType();\n+                    putToMap(newMap, entry, constraintType, unresolvedValues, t, strand);\n+                }\n+                return newMap;\n+            case TypeTags.RECORD_TYPE_TAG:\n+                BRecordType recordType = (BRecordType) targetType;\n+                MapValueImpl<BString, Object> newRecord;\n+                if (t != null && t.getDescribingType() == targetType) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e69a1cd29698b34530672d87c94c48f962da06d"}, "originalPosition": 174}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ5NjM1NDky", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#pullrequestreview-449635492", "createdAt": "2020-07-16T08:34:41Z", "commit": {"oid": "2e69a1cd29698b34530672d87c94c48f962da06d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQwODozNDo0MVrOGygwhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQwODozNDo0MVrOGygwhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTYxODY5NA==", "bodyText": "Is there a need to pass both t and describingType?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455618694", "createdAt": "2020-07-16T08:34:41Z", "author": {"login": "pubudu91"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTableType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        try {\n+            return convert(v, describingType, new ArrayList<>(), t, strand);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e69a1cd29698b34530672d87c94c48f962da06d"}, "originalPosition": 81}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "32a33fc1798b697a55693b80a4d948526e932ea9", "author": {"user": {"login": "dulajdilshan", "name": "Dulaj Dilshan"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/32a33fc1798b697a55693b80a4d948526e932ea9", "committedDate": "2020-07-16T13:46:28Z", "message": "Add fromJsonWIthType negative test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e5430d4b59f2b4c5b8f768ef7a246d15c0d2f23a", "author": {"user": {"login": "dulajdilshan", "name": "Dulaj Dilshan"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e5430d4b59f2b4c5b8f768ef7a246d15c0d2f23a", "committedDate": "2020-07-16T13:46:29Z", "message": "Refactor \"toJson\" according to the code review suggestions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "470bf15ddd203933e41a785ab47c5c4be4ddd678", "author": {"user": {"login": "dulajdilshan", "name": "Dulaj Dilshan"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/470bf15ddd203933e41a785ab47c5c4be4ddd678", "committedDate": "2020-07-16T13:46:29Z", "message": "Add value lang lib error message string"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7e5fbfb2ec384f5722593f972780e362dce450d2", "author": {"user": {"login": "dulajdilshan", "name": "Dulaj Dilshan"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7e5fbfb2ec384f5722593f972780e362dce450d2", "committedDate": "2020-07-16T13:46:29Z", "message": "Refactor \"fromJsonWithType\" according to the code review suggestions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f6adcd93547a952d138340eb1aa45e035622e6a9", "author": {"user": {"login": "dulajdilshan", "name": "Dulaj Dilshan"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f6adcd93547a952d138340eb1aa45e035622e6a9", "committedDate": "2020-07-16T13:46:29Z", "message": "Fix error in the value lib test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c7fb4adc13cf293ae82c9a318bf9c26eecca8b12", "author": {"user": {"login": "dulajdilshan", "name": "Dulaj Dilshan"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c7fb4adc13cf293ae82c9a318bf9c26eecca8b12", "committedDate": "2020-07-16T13:46:29Z", "message": "Do requested changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "558fb27f777cd1fb6fcf5f4d87aab7aac6f0b630", "author": {"user": {"login": "dulajdilshan", "name": "Dulaj Dilshan"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/558fb27f777cd1fb6fcf5f4d87aab7aac6f0b630", "committedDate": "2020-07-16T13:46:29Z", "message": "Remove isConvertibleToJson method in TypeChecker"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "04214fd7fd9ee8ac827123d407fa1c629fff0730", "author": {"user": {"login": "dulajdilshan", "name": "Dulaj Dilshan"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/04214fd7fd9ee8ac827123d407fa1c629fff0730", "committedDate": "2020-07-16T13:46:30Z", "message": "Add more tests"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2e69a1cd29698b34530672d87c94c48f962da06d", "author": {"user": {"login": "dulajdilshan", "name": "Dulaj Dilshan"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2e69a1cd29698b34530672d87c94c48f962da06d", "committedDate": "2020-07-15T14:11:14Z", "message": "Add more tests"}, "afterCommit": {"oid": "de711a0900748c01d3b478823bc6f073b2a2a285", "author": {"user": {"login": "dulajdilshan", "name": "Dulaj Dilshan"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/de711a0900748c01d3b478823bc6f073b2a2a285", "committedDate": "2020-07-16T13:46:30Z", "message": "Change according to the suggestions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "344e13a81c953c6fc2e2b7af0d156eba0227532d", "author": {"user": {"login": "dulajdilshan", "name": "Dulaj Dilshan"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/344e13a81c953c6fc2e2b7af0d156eba0227532d", "committedDate": "2020-07-16T14:22:18Z", "message": "Change according to the suggestions"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "de711a0900748c01d3b478823bc6f073b2a2a285", "author": {"user": {"login": "dulajdilshan", "name": "Dulaj Dilshan"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/de711a0900748c01d3b478823bc6f073b2a2a285", "committedDate": "2020-07-16T13:46:30Z", "message": "Change according to the suggestions"}, "afterCommit": {"oid": "344e13a81c953c6fc2e2b7af0d156eba0227532d", "author": {"user": {"login": "dulajdilshan", "name": "Dulaj Dilshan"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/344e13a81c953c6fc2e2b7af0d156eba0227532d", "committedDate": "2020-07-16T14:22:18Z", "message": "Change according to the suggestions"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ5OTQ1MzI2", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#pullrequestreview-449945326", "createdAt": "2020-07-16T15:10:12Z", "commit": {"oid": "344e13a81c953c6fc2e2b7af0d156eba0227532d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNToxMDoxMlrOGyvj6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNToxMDoxMlrOGyvj6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg2MTIyNQ==", "bodyText": "I think what @MaryamZi meant was to simply pass str to the JSON parser without special casing \"null\".", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455861225", "createdAt": "2020-07-16T15:10:12Z", "author": {"login": "pubudu91"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonStringWithType.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.JSONParser;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.model.types.TypeKind;\n+import org.ballerinalang.natives.annotations.Argument;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+import org.ballerinalang.natives.annotations.ReturnType;\n+\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ * Converts a string in JSON format to a user-specified type.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonStringWithType\",\n+        args = {\n+                @Argument(name = \"str\", type = TypeKind.STRING),\n+                @Argument(name = \"t\", type = TypeKind.TYPEDESC)\n+        },\n+        returnType = {\n+                @ReturnType(type = TypeKind.ANYDATA),\n+                @ReturnType(type = TypeKind.ERROR)\n+        },\n+        isPublic = true\n+)\n+public class FromJsonStringWithType {\n+\n+    public static Object fromJsonStringWithType(Strand strand, BString value, TypedescValue t) {\n+\n+        String str = value.getValue();\n+        try {\n+            if (str.equals(\"null\")) {\n+                return FromJsonWithType.fromJsonWithType(strand, null, t);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "344e13a81c953c6fc2e2b7af0d156eba0227532d"}, "originalPosition": 62}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ5OTY2MTYx", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#pullrequestreview-449966161", "createdAt": "2020-07-16T15:31:56Z", "commit": {"oid": "344e13a81c953c6fc2e2b7af0d156eba0227532d"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4323, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}