{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE2NjY4NzA2", "number": 23178, "reviewThreads": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwMzowMDozM1rOD75Iuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxNjowMDo1NFrOD8i5kA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MTI4Njk5OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": true, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwMzowMDozM1rOGUf0pA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxMTozODowOFrOGUteXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE0NjA4NA==", "bodyText": "We can extract the content inside the while loop to a method. That method simply parse and returns a clause. We have done a similar thing in the parseFollowUpArg() method.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23178#discussion_r424146084", "createdAt": "2020-05-13T03:00:33Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -8185,4 +8166,295 @@ private boolean isEndOfTypeList(SyntaxKind nextTokenKind) {\n     private STNode parseTupleRestTypeDesc() {\n         return STNodeFactory.createEmptyNode();\n     }\n+\n+    /**\n+     * Parse table constructor or query expression.\n+     * <p>\n+     * <code>\n+     * table-constructor-or-query-expr := table-constructor-expr | query-expr\n+     * <br/>\n+     * table-constructor-expr := table [key-specifier] [ [row-list] ]\n+     * <br/>\n+     * query-expr := [query-construct-type] query-pipeline select-clause\n+     * <br/>\n+     * query-construct-type := table key-specifier | stream\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+\n+    private STNode parseTableConstructorOrQuery() {\n+        startContext(ParserRuleContext.TABLE_CONSTRUCTOR_OR_QUERY_EXPRESSION);\n+        return parseTableConstructorOrQuery(peek().kind);\n+    }\n+\n+    private STNode parseTableConstructorOrQuery(SyntaxKind nextTokenKind) {\n+        STNode queryConstructType;\n+        switch (nextTokenKind) {\n+            case FROM_KEYWORD:\n+                queryConstructType = STNodeFactory.createEmptyNode();\n+                return parseQueryExprRhs(queryConstructType);\n+            case STREAM_KEYWORD:\n+                queryConstructType = parseStreamKeyword();\n+                return parseQueryExprRhs(queryConstructType);\n+            case TABLE_KEYWORD:\n+                STNode tableKeyword = parseTableKeyword();\n+                STNode keySpecifier = STNodeFactory.createEmptyNode();\n+                return parseTableConstructorOrQuery(tableKeyword, keySpecifier);\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.TABLE_CONSTRUCTOR_OR_QUERY_START);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseTableConstructorOrQuery(solution.tokenKind);\n+        }\n+\n+    }\n+\n+    private STNode parseTableConstructorOrQuery(STNode tableKeyword, STNode keySpecifier) {\n+        return parseTableConstructorOrQuery(peek().kind, tableKeyword, keySpecifier);\n+    }\n+\n+    private STNode parseTableConstructorOrQuery(SyntaxKind nextTokenKind, STNode tableKeyword, STNode keySpecifier) {\n+        switch (nextTokenKind) {\n+            case OPEN_BRACKET_TOKEN:\n+                return parseTableConstructorExprRhs(tableKeyword, keySpecifier);\n+            case KEY_KEYWORD:\n+                keySpecifier = parseKeySpecifier();\n+                return parseTableConstructorOrQueryRhs(peek().kind, tableKeyword, keySpecifier);\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.TABLE_KEYWORD_RHS, tableKeyword, keySpecifier);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseTableConstructorOrQuery(solution.tokenKind, tableKeyword, keySpecifier);\n+        }\n+    }\n+\n+    private STNode parseTableConstructorOrQueryRhs(STNode tableKeyword, STNode keySpecifier) {\n+        return parseTableConstructorOrQueryRhs(peek().kind, tableKeyword, keySpecifier);\n+    }\n+\n+    private STNode parseTableConstructorOrQueryRhs(SyntaxKind nextTokenKind, STNode tableKeyword, STNode keySpecifier) {\n+        switch (nextTokenKind) {\n+            case FROM_KEYWORD:\n+                return parseQueryExprRhs(parseQueryConstructType(tableKeyword, keySpecifier));\n+            case OPEN_BRACKET_TOKEN:\n+                return parseTableConstructorExprRhs(tableKeyword, keySpecifier);\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.TABLE_CONSTRUCTOR_OR_QUERY_RHS,\n+                    tableKeyword, keySpecifier);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseTableConstructorOrQueryRhs(solution.tokenKind, tableKeyword, keySpecifier);\n+        }\n+    }\n+\n+    /**\n+     * Parse query expression.\n+     * <code>query-expr-rhs := query-pipeline select-clause</code>\n+     *\n+     * @param queryConstructType queryConstructType that precedes this rhs\n+     * @return Parsed node\n+     */\n+    private STNode parseQueryExprRhs(STNode queryConstructType) {\n+        switchContext(ParserRuleContext.QUERY_EXPRESSION);\n+        STNode queryPipeline = parseQueryPipeline();\n+        STNode selectClause = parseSelectClause();;\n+        endContext();\n+        return STNodeFactory.createQueryExpressionNode(queryConstructType, queryPipeline, selectClause);\n+    }\n+\n+    /**\n+     * Parse query construct type.\n+     * <p>\n+     * <code>query-construct-type := table key-specifier</code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseQueryConstructType(STNode tableKeyword, STNode keySpecifier) {\n+        return STNodeFactory.createQueryConstructTypeNode(tableKeyword, keySpecifier);\n+    }\n+\n+    /**\n+     * Parse query pipeline.\n+     * <p>\n+     * <code>\n+     * query-pipeline := from-clause intermediate-clause*\n+     * <br/>\n+     * intermediate-clause := from-clause | where-clause | let-clause\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseQueryPipeline() {\n+        STNode fromClause = parseFromClause();\n+        List<STNode> clauses = new ArrayList<>();\n+        return parseQueryPipeline(fromClause, clauses);\n+    }\n+\n+    private STNode parseQueryPipeline(STNode fromClause, List<STNode> clauses) {\n+        return parseQueryPipeline(peek().kind, fromClause, clauses);\n+    }\n+    private STNode parseQueryPipeline(SyntaxKind nextTokenKind, STNode fromClause, List<STNode> clauses) {\n+        STNode clause;\n+\n+        while (true) {\n+            switch (nextTokenKind) {\n+                case FROM_KEYWORD:\n+                    clause = parseFromClause();\n+                    clauses.add(clause);\n+                    nextTokenKind = peek().kind;\n+                    continue;\n+                case WHERE_KEYWORD:\n+                    clause = parseWhereClause();\n+                    clauses.add(clause);\n+                    nextTokenKind = peek().kind;\n+                    continue;\n+                case LET_KEYWORD:\n+                    clause = parseLetClause();\n+                    clauses.add(clause);\n+                    nextTokenKind = peek().kind;\n+                    continue;\n+                case SELECT_KEYWORD:\n+                    break;\n+                default:\n+                    if (nextTokenKind == SyntaxKind.EOF_TOKEN) {\n+                        return parseQueryPipeline(SyntaxKind.SELECT_KEYWORD, fromClause, clauses);\n+                    }\n+\n+                    Solution solution = recover(peek(), ParserRuleContext.QUERY_EXPRESSION_RHS, fromClause, clauses);\n+\n+                    // If the parser recovered by inserting a token, then try to re-parse the same\n+                    // rule with the inserted token. This is done to pick the correct branch\n+                    // to continue the parsing.\n+                    if (solution.action == Action.REMOVE) {\n+                        return solution.recoveredNode;\n+                    }\n+\n+                    return parseQueryPipeline(solution.tokenKind, fromClause, clauses);\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e36e0403c39213b5761bcd15bea21abc38e8c087"}, "originalPosition": 443}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDMyOTY5NQ==", "bodyText": "Suppose we extract this to a new new method say parseIntermediateClause. Then what should be return if Solution solution = recover(),  recovered a SELECT_KEYWORD? We can't pass select clause inside that method as it should be passed after the parseQueryPipeline", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23178#discussion_r424329695", "createdAt": "2020-05-13T10:18:08Z", "author": {"login": "lochana-chathura"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -8185,4 +8166,295 @@ private boolean isEndOfTypeList(SyntaxKind nextTokenKind) {\n     private STNode parseTupleRestTypeDesc() {\n         return STNodeFactory.createEmptyNode();\n     }\n+\n+    /**\n+     * Parse table constructor or query expression.\n+     * <p>\n+     * <code>\n+     * table-constructor-or-query-expr := table-constructor-expr | query-expr\n+     * <br/>\n+     * table-constructor-expr := table [key-specifier] [ [row-list] ]\n+     * <br/>\n+     * query-expr := [query-construct-type] query-pipeline select-clause\n+     * <br/>\n+     * query-construct-type := table key-specifier | stream\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+\n+    private STNode parseTableConstructorOrQuery() {\n+        startContext(ParserRuleContext.TABLE_CONSTRUCTOR_OR_QUERY_EXPRESSION);\n+        return parseTableConstructorOrQuery(peek().kind);\n+    }\n+\n+    private STNode parseTableConstructorOrQuery(SyntaxKind nextTokenKind) {\n+        STNode queryConstructType;\n+        switch (nextTokenKind) {\n+            case FROM_KEYWORD:\n+                queryConstructType = STNodeFactory.createEmptyNode();\n+                return parseQueryExprRhs(queryConstructType);\n+            case STREAM_KEYWORD:\n+                queryConstructType = parseStreamKeyword();\n+                return parseQueryExprRhs(queryConstructType);\n+            case TABLE_KEYWORD:\n+                STNode tableKeyword = parseTableKeyword();\n+                STNode keySpecifier = STNodeFactory.createEmptyNode();\n+                return parseTableConstructorOrQuery(tableKeyword, keySpecifier);\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.TABLE_CONSTRUCTOR_OR_QUERY_START);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseTableConstructorOrQuery(solution.tokenKind);\n+        }\n+\n+    }\n+\n+    private STNode parseTableConstructorOrQuery(STNode tableKeyword, STNode keySpecifier) {\n+        return parseTableConstructorOrQuery(peek().kind, tableKeyword, keySpecifier);\n+    }\n+\n+    private STNode parseTableConstructorOrQuery(SyntaxKind nextTokenKind, STNode tableKeyword, STNode keySpecifier) {\n+        switch (nextTokenKind) {\n+            case OPEN_BRACKET_TOKEN:\n+                return parseTableConstructorExprRhs(tableKeyword, keySpecifier);\n+            case KEY_KEYWORD:\n+                keySpecifier = parseKeySpecifier();\n+                return parseTableConstructorOrQueryRhs(peek().kind, tableKeyword, keySpecifier);\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.TABLE_KEYWORD_RHS, tableKeyword, keySpecifier);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseTableConstructorOrQuery(solution.tokenKind, tableKeyword, keySpecifier);\n+        }\n+    }\n+\n+    private STNode parseTableConstructorOrQueryRhs(STNode tableKeyword, STNode keySpecifier) {\n+        return parseTableConstructorOrQueryRhs(peek().kind, tableKeyword, keySpecifier);\n+    }\n+\n+    private STNode parseTableConstructorOrQueryRhs(SyntaxKind nextTokenKind, STNode tableKeyword, STNode keySpecifier) {\n+        switch (nextTokenKind) {\n+            case FROM_KEYWORD:\n+                return parseQueryExprRhs(parseQueryConstructType(tableKeyword, keySpecifier));\n+            case OPEN_BRACKET_TOKEN:\n+                return parseTableConstructorExprRhs(tableKeyword, keySpecifier);\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.TABLE_CONSTRUCTOR_OR_QUERY_RHS,\n+                    tableKeyword, keySpecifier);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseTableConstructorOrQueryRhs(solution.tokenKind, tableKeyword, keySpecifier);\n+        }\n+    }\n+\n+    /**\n+     * Parse query expression.\n+     * <code>query-expr-rhs := query-pipeline select-clause</code>\n+     *\n+     * @param queryConstructType queryConstructType that precedes this rhs\n+     * @return Parsed node\n+     */\n+    private STNode parseQueryExprRhs(STNode queryConstructType) {\n+        switchContext(ParserRuleContext.QUERY_EXPRESSION);\n+        STNode queryPipeline = parseQueryPipeline();\n+        STNode selectClause = parseSelectClause();;\n+        endContext();\n+        return STNodeFactory.createQueryExpressionNode(queryConstructType, queryPipeline, selectClause);\n+    }\n+\n+    /**\n+     * Parse query construct type.\n+     * <p>\n+     * <code>query-construct-type := table key-specifier</code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseQueryConstructType(STNode tableKeyword, STNode keySpecifier) {\n+        return STNodeFactory.createQueryConstructTypeNode(tableKeyword, keySpecifier);\n+    }\n+\n+    /**\n+     * Parse query pipeline.\n+     * <p>\n+     * <code>\n+     * query-pipeline := from-clause intermediate-clause*\n+     * <br/>\n+     * intermediate-clause := from-clause | where-clause | let-clause\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseQueryPipeline() {\n+        STNode fromClause = parseFromClause();\n+        List<STNode> clauses = new ArrayList<>();\n+        return parseQueryPipeline(fromClause, clauses);\n+    }\n+\n+    private STNode parseQueryPipeline(STNode fromClause, List<STNode> clauses) {\n+        return parseQueryPipeline(peek().kind, fromClause, clauses);\n+    }\n+    private STNode parseQueryPipeline(SyntaxKind nextTokenKind, STNode fromClause, List<STNode> clauses) {\n+        STNode clause;\n+\n+        while (true) {\n+            switch (nextTokenKind) {\n+                case FROM_KEYWORD:\n+                    clause = parseFromClause();\n+                    clauses.add(clause);\n+                    nextTokenKind = peek().kind;\n+                    continue;\n+                case WHERE_KEYWORD:\n+                    clause = parseWhereClause();\n+                    clauses.add(clause);\n+                    nextTokenKind = peek().kind;\n+                    continue;\n+                case LET_KEYWORD:\n+                    clause = parseLetClause();\n+                    clauses.add(clause);\n+                    nextTokenKind = peek().kind;\n+                    continue;\n+                case SELECT_KEYWORD:\n+                    break;\n+                default:\n+                    if (nextTokenKind == SyntaxKind.EOF_TOKEN) {\n+                        return parseQueryPipeline(SyntaxKind.SELECT_KEYWORD, fromClause, clauses);\n+                    }\n+\n+                    Solution solution = recover(peek(), ParserRuleContext.QUERY_EXPRESSION_RHS, fromClause, clauses);\n+\n+                    // If the parser recovered by inserting a token, then try to re-parse the same\n+                    // rule with the inserted token. This is done to pick the correct branch\n+                    // to continue the parsing.\n+                    if (solution.action == Action.REMOVE) {\n+                        return solution.recoveredNode;\n+                    }\n+\n+                    return parseQueryPipeline(solution.tokenKind, fromClause, clauses);\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE0NjA4NA=="}, "originalCommit": {"oid": "e36e0403c39213b5761bcd15bea21abc38e8c087"}, "originalPosition": 443}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDMzMzA4OA==", "bodyText": "we can actually parse is as select-clause. caller can check the kind of the clause returned by this method and stop the loop, if its a select clause.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23178#discussion_r424333088", "createdAt": "2020-05-13T10:24:26Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -8185,4 +8166,295 @@ private boolean isEndOfTypeList(SyntaxKind nextTokenKind) {\n     private STNode parseTupleRestTypeDesc() {\n         return STNodeFactory.createEmptyNode();\n     }\n+\n+    /**\n+     * Parse table constructor or query expression.\n+     * <p>\n+     * <code>\n+     * table-constructor-or-query-expr := table-constructor-expr | query-expr\n+     * <br/>\n+     * table-constructor-expr := table [key-specifier] [ [row-list] ]\n+     * <br/>\n+     * query-expr := [query-construct-type] query-pipeline select-clause\n+     * <br/>\n+     * query-construct-type := table key-specifier | stream\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+\n+    private STNode parseTableConstructorOrQuery() {\n+        startContext(ParserRuleContext.TABLE_CONSTRUCTOR_OR_QUERY_EXPRESSION);\n+        return parseTableConstructorOrQuery(peek().kind);\n+    }\n+\n+    private STNode parseTableConstructorOrQuery(SyntaxKind nextTokenKind) {\n+        STNode queryConstructType;\n+        switch (nextTokenKind) {\n+            case FROM_KEYWORD:\n+                queryConstructType = STNodeFactory.createEmptyNode();\n+                return parseQueryExprRhs(queryConstructType);\n+            case STREAM_KEYWORD:\n+                queryConstructType = parseStreamKeyword();\n+                return parseQueryExprRhs(queryConstructType);\n+            case TABLE_KEYWORD:\n+                STNode tableKeyword = parseTableKeyword();\n+                STNode keySpecifier = STNodeFactory.createEmptyNode();\n+                return parseTableConstructorOrQuery(tableKeyword, keySpecifier);\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.TABLE_CONSTRUCTOR_OR_QUERY_START);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseTableConstructorOrQuery(solution.tokenKind);\n+        }\n+\n+    }\n+\n+    private STNode parseTableConstructorOrQuery(STNode tableKeyword, STNode keySpecifier) {\n+        return parseTableConstructorOrQuery(peek().kind, tableKeyword, keySpecifier);\n+    }\n+\n+    private STNode parseTableConstructorOrQuery(SyntaxKind nextTokenKind, STNode tableKeyword, STNode keySpecifier) {\n+        switch (nextTokenKind) {\n+            case OPEN_BRACKET_TOKEN:\n+                return parseTableConstructorExprRhs(tableKeyword, keySpecifier);\n+            case KEY_KEYWORD:\n+                keySpecifier = parseKeySpecifier();\n+                return parseTableConstructorOrQueryRhs(peek().kind, tableKeyword, keySpecifier);\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.TABLE_KEYWORD_RHS, tableKeyword, keySpecifier);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseTableConstructorOrQuery(solution.tokenKind, tableKeyword, keySpecifier);\n+        }\n+    }\n+\n+    private STNode parseTableConstructorOrQueryRhs(STNode tableKeyword, STNode keySpecifier) {\n+        return parseTableConstructorOrQueryRhs(peek().kind, tableKeyword, keySpecifier);\n+    }\n+\n+    private STNode parseTableConstructorOrQueryRhs(SyntaxKind nextTokenKind, STNode tableKeyword, STNode keySpecifier) {\n+        switch (nextTokenKind) {\n+            case FROM_KEYWORD:\n+                return parseQueryExprRhs(parseQueryConstructType(tableKeyword, keySpecifier));\n+            case OPEN_BRACKET_TOKEN:\n+                return parseTableConstructorExprRhs(tableKeyword, keySpecifier);\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.TABLE_CONSTRUCTOR_OR_QUERY_RHS,\n+                    tableKeyword, keySpecifier);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseTableConstructorOrQueryRhs(solution.tokenKind, tableKeyword, keySpecifier);\n+        }\n+    }\n+\n+    /**\n+     * Parse query expression.\n+     * <code>query-expr-rhs := query-pipeline select-clause</code>\n+     *\n+     * @param queryConstructType queryConstructType that precedes this rhs\n+     * @return Parsed node\n+     */\n+    private STNode parseQueryExprRhs(STNode queryConstructType) {\n+        switchContext(ParserRuleContext.QUERY_EXPRESSION);\n+        STNode queryPipeline = parseQueryPipeline();\n+        STNode selectClause = parseSelectClause();;\n+        endContext();\n+        return STNodeFactory.createQueryExpressionNode(queryConstructType, queryPipeline, selectClause);\n+    }\n+\n+    /**\n+     * Parse query construct type.\n+     * <p>\n+     * <code>query-construct-type := table key-specifier</code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseQueryConstructType(STNode tableKeyword, STNode keySpecifier) {\n+        return STNodeFactory.createQueryConstructTypeNode(tableKeyword, keySpecifier);\n+    }\n+\n+    /**\n+     * Parse query pipeline.\n+     * <p>\n+     * <code>\n+     * query-pipeline := from-clause intermediate-clause*\n+     * <br/>\n+     * intermediate-clause := from-clause | where-clause | let-clause\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseQueryPipeline() {\n+        STNode fromClause = parseFromClause();\n+        List<STNode> clauses = new ArrayList<>();\n+        return parseQueryPipeline(fromClause, clauses);\n+    }\n+\n+    private STNode parseQueryPipeline(STNode fromClause, List<STNode> clauses) {\n+        return parseQueryPipeline(peek().kind, fromClause, clauses);\n+    }\n+    private STNode parseQueryPipeline(SyntaxKind nextTokenKind, STNode fromClause, List<STNode> clauses) {\n+        STNode clause;\n+\n+        while (true) {\n+            switch (nextTokenKind) {\n+                case FROM_KEYWORD:\n+                    clause = parseFromClause();\n+                    clauses.add(clause);\n+                    nextTokenKind = peek().kind;\n+                    continue;\n+                case WHERE_KEYWORD:\n+                    clause = parseWhereClause();\n+                    clauses.add(clause);\n+                    nextTokenKind = peek().kind;\n+                    continue;\n+                case LET_KEYWORD:\n+                    clause = parseLetClause();\n+                    clauses.add(clause);\n+                    nextTokenKind = peek().kind;\n+                    continue;\n+                case SELECT_KEYWORD:\n+                    break;\n+                default:\n+                    if (nextTokenKind == SyntaxKind.EOF_TOKEN) {\n+                        return parseQueryPipeline(SyntaxKind.SELECT_KEYWORD, fromClause, clauses);\n+                    }\n+\n+                    Solution solution = recover(peek(), ParserRuleContext.QUERY_EXPRESSION_RHS, fromClause, clauses);\n+\n+                    // If the parser recovered by inserting a token, then try to re-parse the same\n+                    // rule with the inserted token. This is done to pick the correct branch\n+                    // to continue the parsing.\n+                    if (solution.action == Action.REMOVE) {\n+                        return solution.recoveredNode;\n+                    }\n+\n+                    return parseQueryPipeline(solution.tokenKind, fromClause, clauses);\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE0NjA4NA=="}, "originalCommit": {"oid": "e36e0403c39213b5761bcd15bea21abc38e8c087"}, "originalPosition": 443}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDMzNDEzMg==", "bodyText": "+1", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23178#discussion_r424334132", "createdAt": "2020-05-13T10:26:17Z", "author": {"login": "lochana-chathura"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -8185,4 +8166,295 @@ private boolean isEndOfTypeList(SyntaxKind nextTokenKind) {\n     private STNode parseTupleRestTypeDesc() {\n         return STNodeFactory.createEmptyNode();\n     }\n+\n+    /**\n+     * Parse table constructor or query expression.\n+     * <p>\n+     * <code>\n+     * table-constructor-or-query-expr := table-constructor-expr | query-expr\n+     * <br/>\n+     * table-constructor-expr := table [key-specifier] [ [row-list] ]\n+     * <br/>\n+     * query-expr := [query-construct-type] query-pipeline select-clause\n+     * <br/>\n+     * query-construct-type := table key-specifier | stream\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+\n+    private STNode parseTableConstructorOrQuery() {\n+        startContext(ParserRuleContext.TABLE_CONSTRUCTOR_OR_QUERY_EXPRESSION);\n+        return parseTableConstructorOrQuery(peek().kind);\n+    }\n+\n+    private STNode parseTableConstructorOrQuery(SyntaxKind nextTokenKind) {\n+        STNode queryConstructType;\n+        switch (nextTokenKind) {\n+            case FROM_KEYWORD:\n+                queryConstructType = STNodeFactory.createEmptyNode();\n+                return parseQueryExprRhs(queryConstructType);\n+            case STREAM_KEYWORD:\n+                queryConstructType = parseStreamKeyword();\n+                return parseQueryExprRhs(queryConstructType);\n+            case TABLE_KEYWORD:\n+                STNode tableKeyword = parseTableKeyword();\n+                STNode keySpecifier = STNodeFactory.createEmptyNode();\n+                return parseTableConstructorOrQuery(tableKeyword, keySpecifier);\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.TABLE_CONSTRUCTOR_OR_QUERY_START);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseTableConstructorOrQuery(solution.tokenKind);\n+        }\n+\n+    }\n+\n+    private STNode parseTableConstructorOrQuery(STNode tableKeyword, STNode keySpecifier) {\n+        return parseTableConstructorOrQuery(peek().kind, tableKeyword, keySpecifier);\n+    }\n+\n+    private STNode parseTableConstructorOrQuery(SyntaxKind nextTokenKind, STNode tableKeyword, STNode keySpecifier) {\n+        switch (nextTokenKind) {\n+            case OPEN_BRACKET_TOKEN:\n+                return parseTableConstructorExprRhs(tableKeyword, keySpecifier);\n+            case KEY_KEYWORD:\n+                keySpecifier = parseKeySpecifier();\n+                return parseTableConstructorOrQueryRhs(peek().kind, tableKeyword, keySpecifier);\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.TABLE_KEYWORD_RHS, tableKeyword, keySpecifier);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseTableConstructorOrQuery(solution.tokenKind, tableKeyword, keySpecifier);\n+        }\n+    }\n+\n+    private STNode parseTableConstructorOrQueryRhs(STNode tableKeyword, STNode keySpecifier) {\n+        return parseTableConstructorOrQueryRhs(peek().kind, tableKeyword, keySpecifier);\n+    }\n+\n+    private STNode parseTableConstructorOrQueryRhs(SyntaxKind nextTokenKind, STNode tableKeyword, STNode keySpecifier) {\n+        switch (nextTokenKind) {\n+            case FROM_KEYWORD:\n+                return parseQueryExprRhs(parseQueryConstructType(tableKeyword, keySpecifier));\n+            case OPEN_BRACKET_TOKEN:\n+                return parseTableConstructorExprRhs(tableKeyword, keySpecifier);\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.TABLE_CONSTRUCTOR_OR_QUERY_RHS,\n+                    tableKeyword, keySpecifier);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseTableConstructorOrQueryRhs(solution.tokenKind, tableKeyword, keySpecifier);\n+        }\n+    }\n+\n+    /**\n+     * Parse query expression.\n+     * <code>query-expr-rhs := query-pipeline select-clause</code>\n+     *\n+     * @param queryConstructType queryConstructType that precedes this rhs\n+     * @return Parsed node\n+     */\n+    private STNode parseQueryExprRhs(STNode queryConstructType) {\n+        switchContext(ParserRuleContext.QUERY_EXPRESSION);\n+        STNode queryPipeline = parseQueryPipeline();\n+        STNode selectClause = parseSelectClause();;\n+        endContext();\n+        return STNodeFactory.createQueryExpressionNode(queryConstructType, queryPipeline, selectClause);\n+    }\n+\n+    /**\n+     * Parse query construct type.\n+     * <p>\n+     * <code>query-construct-type := table key-specifier</code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseQueryConstructType(STNode tableKeyword, STNode keySpecifier) {\n+        return STNodeFactory.createQueryConstructTypeNode(tableKeyword, keySpecifier);\n+    }\n+\n+    /**\n+     * Parse query pipeline.\n+     * <p>\n+     * <code>\n+     * query-pipeline := from-clause intermediate-clause*\n+     * <br/>\n+     * intermediate-clause := from-clause | where-clause | let-clause\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseQueryPipeline() {\n+        STNode fromClause = parseFromClause();\n+        List<STNode> clauses = new ArrayList<>();\n+        return parseQueryPipeline(fromClause, clauses);\n+    }\n+\n+    private STNode parseQueryPipeline(STNode fromClause, List<STNode> clauses) {\n+        return parseQueryPipeline(peek().kind, fromClause, clauses);\n+    }\n+    private STNode parseQueryPipeline(SyntaxKind nextTokenKind, STNode fromClause, List<STNode> clauses) {\n+        STNode clause;\n+\n+        while (true) {\n+            switch (nextTokenKind) {\n+                case FROM_KEYWORD:\n+                    clause = parseFromClause();\n+                    clauses.add(clause);\n+                    nextTokenKind = peek().kind;\n+                    continue;\n+                case WHERE_KEYWORD:\n+                    clause = parseWhereClause();\n+                    clauses.add(clause);\n+                    nextTokenKind = peek().kind;\n+                    continue;\n+                case LET_KEYWORD:\n+                    clause = parseLetClause();\n+                    clauses.add(clause);\n+                    nextTokenKind = peek().kind;\n+                    continue;\n+                case SELECT_KEYWORD:\n+                    break;\n+                default:\n+                    if (nextTokenKind == SyntaxKind.EOF_TOKEN) {\n+                        return parseQueryPipeline(SyntaxKind.SELECT_KEYWORD, fromClause, clauses);\n+                    }\n+\n+                    Solution solution = recover(peek(), ParserRuleContext.QUERY_EXPRESSION_RHS, fromClause, clauses);\n+\n+                    // If the parser recovered by inserting a token, then try to re-parse the same\n+                    // rule with the inserted token. This is done to pick the correct branch\n+                    // to continue the parsing.\n+                    if (solution.action == Action.REMOVE) {\n+                        return solution.recoveredNode;\n+                    }\n+\n+                    return parseQueryPipeline(solution.tokenKind, fromClause, clauses);\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE0NjA4NA=="}, "originalCommit": {"oid": "e36e0403c39213b5761bcd15bea21abc38e8c087"}, "originalPosition": 443}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM2OTMyNQ==", "bodyText": "private STNode parseQueryExprRhs(STNode queryConstructType) {\n        switchContext(ParserRuleContext.QUERY_EXPRESSION);\n        STNode fromClause = parseFromClause();\n\n        List<STNode> clauses = new ArrayList<>();\n        STNode clause = null;\n\n        while (!isEndOfIntermediateClause(peek().kind)) {\n            clause = parseIntermediateClause();\n            if (clause.kind == SyntaxKind.SELECT_CLAUSE) {\n                break;\n            }\n            clauses.add(clause);\n        }\n\n        if (clause == null || clause.kind != SyntaxKind.SELECT_CLAUSE) {\n            clause = parseSelectClause();\n        }\n        \n        STNode intermediateClauses = STNodeFactory.createNodeList(clauses);\n        STNode queryPipeline = STNodeFactory.createQueryPipelineNode(fromClause, intermediateClauses);\n        return STNodeFactory.createQueryExpressionNode(queryConstructType, queryPipeline, clause);\n    }", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23178#discussion_r424369325", "createdAt": "2020-05-13T11:37:21Z", "author": {"login": "lochana-chathura"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -8185,4 +8166,295 @@ private boolean isEndOfTypeList(SyntaxKind nextTokenKind) {\n     private STNode parseTupleRestTypeDesc() {\n         return STNodeFactory.createEmptyNode();\n     }\n+\n+    /**\n+     * Parse table constructor or query expression.\n+     * <p>\n+     * <code>\n+     * table-constructor-or-query-expr := table-constructor-expr | query-expr\n+     * <br/>\n+     * table-constructor-expr := table [key-specifier] [ [row-list] ]\n+     * <br/>\n+     * query-expr := [query-construct-type] query-pipeline select-clause\n+     * <br/>\n+     * query-construct-type := table key-specifier | stream\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+\n+    private STNode parseTableConstructorOrQuery() {\n+        startContext(ParserRuleContext.TABLE_CONSTRUCTOR_OR_QUERY_EXPRESSION);\n+        return parseTableConstructorOrQuery(peek().kind);\n+    }\n+\n+    private STNode parseTableConstructorOrQuery(SyntaxKind nextTokenKind) {\n+        STNode queryConstructType;\n+        switch (nextTokenKind) {\n+            case FROM_KEYWORD:\n+                queryConstructType = STNodeFactory.createEmptyNode();\n+                return parseQueryExprRhs(queryConstructType);\n+            case STREAM_KEYWORD:\n+                queryConstructType = parseStreamKeyword();\n+                return parseQueryExprRhs(queryConstructType);\n+            case TABLE_KEYWORD:\n+                STNode tableKeyword = parseTableKeyword();\n+                STNode keySpecifier = STNodeFactory.createEmptyNode();\n+                return parseTableConstructorOrQuery(tableKeyword, keySpecifier);\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.TABLE_CONSTRUCTOR_OR_QUERY_START);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseTableConstructorOrQuery(solution.tokenKind);\n+        }\n+\n+    }\n+\n+    private STNode parseTableConstructorOrQuery(STNode tableKeyword, STNode keySpecifier) {\n+        return parseTableConstructorOrQuery(peek().kind, tableKeyword, keySpecifier);\n+    }\n+\n+    private STNode parseTableConstructorOrQuery(SyntaxKind nextTokenKind, STNode tableKeyword, STNode keySpecifier) {\n+        switch (nextTokenKind) {\n+            case OPEN_BRACKET_TOKEN:\n+                return parseTableConstructorExprRhs(tableKeyword, keySpecifier);\n+            case KEY_KEYWORD:\n+                keySpecifier = parseKeySpecifier();\n+                return parseTableConstructorOrQueryRhs(peek().kind, tableKeyword, keySpecifier);\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.TABLE_KEYWORD_RHS, tableKeyword, keySpecifier);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseTableConstructorOrQuery(solution.tokenKind, tableKeyword, keySpecifier);\n+        }\n+    }\n+\n+    private STNode parseTableConstructorOrQueryRhs(STNode tableKeyword, STNode keySpecifier) {\n+        return parseTableConstructorOrQueryRhs(peek().kind, tableKeyword, keySpecifier);\n+    }\n+\n+    private STNode parseTableConstructorOrQueryRhs(SyntaxKind nextTokenKind, STNode tableKeyword, STNode keySpecifier) {\n+        switch (nextTokenKind) {\n+            case FROM_KEYWORD:\n+                return parseQueryExprRhs(parseQueryConstructType(tableKeyword, keySpecifier));\n+            case OPEN_BRACKET_TOKEN:\n+                return parseTableConstructorExprRhs(tableKeyword, keySpecifier);\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.TABLE_CONSTRUCTOR_OR_QUERY_RHS,\n+                    tableKeyword, keySpecifier);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseTableConstructorOrQueryRhs(solution.tokenKind, tableKeyword, keySpecifier);\n+        }\n+    }\n+\n+    /**\n+     * Parse query expression.\n+     * <code>query-expr-rhs := query-pipeline select-clause</code>\n+     *\n+     * @param queryConstructType queryConstructType that precedes this rhs\n+     * @return Parsed node\n+     */\n+    private STNode parseQueryExprRhs(STNode queryConstructType) {\n+        switchContext(ParserRuleContext.QUERY_EXPRESSION);\n+        STNode queryPipeline = parseQueryPipeline();\n+        STNode selectClause = parseSelectClause();;\n+        endContext();\n+        return STNodeFactory.createQueryExpressionNode(queryConstructType, queryPipeline, selectClause);\n+    }\n+\n+    /**\n+     * Parse query construct type.\n+     * <p>\n+     * <code>query-construct-type := table key-specifier</code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseQueryConstructType(STNode tableKeyword, STNode keySpecifier) {\n+        return STNodeFactory.createQueryConstructTypeNode(tableKeyword, keySpecifier);\n+    }\n+\n+    /**\n+     * Parse query pipeline.\n+     * <p>\n+     * <code>\n+     * query-pipeline := from-clause intermediate-clause*\n+     * <br/>\n+     * intermediate-clause := from-clause | where-clause | let-clause\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseQueryPipeline() {\n+        STNode fromClause = parseFromClause();\n+        List<STNode> clauses = new ArrayList<>();\n+        return parseQueryPipeline(fromClause, clauses);\n+    }\n+\n+    private STNode parseQueryPipeline(STNode fromClause, List<STNode> clauses) {\n+        return parseQueryPipeline(peek().kind, fromClause, clauses);\n+    }\n+    private STNode parseQueryPipeline(SyntaxKind nextTokenKind, STNode fromClause, List<STNode> clauses) {\n+        STNode clause;\n+\n+        while (true) {\n+            switch (nextTokenKind) {\n+                case FROM_KEYWORD:\n+                    clause = parseFromClause();\n+                    clauses.add(clause);\n+                    nextTokenKind = peek().kind;\n+                    continue;\n+                case WHERE_KEYWORD:\n+                    clause = parseWhereClause();\n+                    clauses.add(clause);\n+                    nextTokenKind = peek().kind;\n+                    continue;\n+                case LET_KEYWORD:\n+                    clause = parseLetClause();\n+                    clauses.add(clause);\n+                    nextTokenKind = peek().kind;\n+                    continue;\n+                case SELECT_KEYWORD:\n+                    break;\n+                default:\n+                    if (nextTokenKind == SyntaxKind.EOF_TOKEN) {\n+                        return parseQueryPipeline(SyntaxKind.SELECT_KEYWORD, fromClause, clauses);\n+                    }\n+\n+                    Solution solution = recover(peek(), ParserRuleContext.QUERY_EXPRESSION_RHS, fromClause, clauses);\n+\n+                    // If the parser recovered by inserting a token, then try to re-parse the same\n+                    // rule with the inserted token. This is done to pick the correct branch\n+                    // to continue the parsing.\n+                    if (solution.action == Action.REMOVE) {\n+                        return solution.recoveredNode;\n+                    }\n+\n+                    return parseQueryPipeline(solution.tokenKind, fromClause, clauses);\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE0NjA4NA=="}, "originalCommit": {"oid": "e36e0403c39213b5761bcd15bea21abc38e8c087"}, "originalPosition": 443}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM2OTU3Ng==", "bodyText": "private STNode parseQueryExprRhs(STNode queryConstructType) {\n        switchContext(ParserRuleContext.QUERY_EXPRESSION);\n        STNode fromClause = parseFromClause();\n\n        STNode clause;\n        STNode intermediateClauses;\n        STNode queryPipeline;\n\n        List<STNode> clauses = new ArrayList<>();\n        while (!isEndOfIntermediateClause(peek().kind)) {\n            clause = parseIntermediateClause();\n\n            if (clause.kind == SyntaxKind.SELECT_CLAUSE) {\n                intermediateClauses = STNodeFactory.createNodeList(clauses);\n                queryPipeline = STNodeFactory.createQueryPipelineNode(fromClause, intermediateClauses);\n                return STNodeFactory.createQueryExpressionNode(queryConstructType, queryPipeline, clause);\n            }\n            \n            clauses.add(clause);\n        }\n\n        clause = parseSelectClause();\n        intermediateClauses = STNodeFactory.createNodeList(clauses);\n        queryPipeline = STNodeFactory.createQueryPipelineNode(fromClause, intermediateClauses);\n        return STNodeFactory.createQueryExpressionNode(queryConstructType, queryPipeline, clause);\n    }", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23178#discussion_r424369576", "createdAt": "2020-05-13T11:37:46Z", "author": {"login": "lochana-chathura"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -8185,4 +8166,295 @@ private boolean isEndOfTypeList(SyntaxKind nextTokenKind) {\n     private STNode parseTupleRestTypeDesc() {\n         return STNodeFactory.createEmptyNode();\n     }\n+\n+    /**\n+     * Parse table constructor or query expression.\n+     * <p>\n+     * <code>\n+     * table-constructor-or-query-expr := table-constructor-expr | query-expr\n+     * <br/>\n+     * table-constructor-expr := table [key-specifier] [ [row-list] ]\n+     * <br/>\n+     * query-expr := [query-construct-type] query-pipeline select-clause\n+     * <br/>\n+     * query-construct-type := table key-specifier | stream\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+\n+    private STNode parseTableConstructorOrQuery() {\n+        startContext(ParserRuleContext.TABLE_CONSTRUCTOR_OR_QUERY_EXPRESSION);\n+        return parseTableConstructorOrQuery(peek().kind);\n+    }\n+\n+    private STNode parseTableConstructorOrQuery(SyntaxKind nextTokenKind) {\n+        STNode queryConstructType;\n+        switch (nextTokenKind) {\n+            case FROM_KEYWORD:\n+                queryConstructType = STNodeFactory.createEmptyNode();\n+                return parseQueryExprRhs(queryConstructType);\n+            case STREAM_KEYWORD:\n+                queryConstructType = parseStreamKeyword();\n+                return parseQueryExprRhs(queryConstructType);\n+            case TABLE_KEYWORD:\n+                STNode tableKeyword = parseTableKeyword();\n+                STNode keySpecifier = STNodeFactory.createEmptyNode();\n+                return parseTableConstructorOrQuery(tableKeyword, keySpecifier);\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.TABLE_CONSTRUCTOR_OR_QUERY_START);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseTableConstructorOrQuery(solution.tokenKind);\n+        }\n+\n+    }\n+\n+    private STNode parseTableConstructorOrQuery(STNode tableKeyword, STNode keySpecifier) {\n+        return parseTableConstructorOrQuery(peek().kind, tableKeyword, keySpecifier);\n+    }\n+\n+    private STNode parseTableConstructorOrQuery(SyntaxKind nextTokenKind, STNode tableKeyword, STNode keySpecifier) {\n+        switch (nextTokenKind) {\n+            case OPEN_BRACKET_TOKEN:\n+                return parseTableConstructorExprRhs(tableKeyword, keySpecifier);\n+            case KEY_KEYWORD:\n+                keySpecifier = parseKeySpecifier();\n+                return parseTableConstructorOrQueryRhs(peek().kind, tableKeyword, keySpecifier);\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.TABLE_KEYWORD_RHS, tableKeyword, keySpecifier);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseTableConstructorOrQuery(solution.tokenKind, tableKeyword, keySpecifier);\n+        }\n+    }\n+\n+    private STNode parseTableConstructorOrQueryRhs(STNode tableKeyword, STNode keySpecifier) {\n+        return parseTableConstructorOrQueryRhs(peek().kind, tableKeyword, keySpecifier);\n+    }\n+\n+    private STNode parseTableConstructorOrQueryRhs(SyntaxKind nextTokenKind, STNode tableKeyword, STNode keySpecifier) {\n+        switch (nextTokenKind) {\n+            case FROM_KEYWORD:\n+                return parseQueryExprRhs(parseQueryConstructType(tableKeyword, keySpecifier));\n+            case OPEN_BRACKET_TOKEN:\n+                return parseTableConstructorExprRhs(tableKeyword, keySpecifier);\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.TABLE_CONSTRUCTOR_OR_QUERY_RHS,\n+                    tableKeyword, keySpecifier);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseTableConstructorOrQueryRhs(solution.tokenKind, tableKeyword, keySpecifier);\n+        }\n+    }\n+\n+    /**\n+     * Parse query expression.\n+     * <code>query-expr-rhs := query-pipeline select-clause</code>\n+     *\n+     * @param queryConstructType queryConstructType that precedes this rhs\n+     * @return Parsed node\n+     */\n+    private STNode parseQueryExprRhs(STNode queryConstructType) {\n+        switchContext(ParserRuleContext.QUERY_EXPRESSION);\n+        STNode queryPipeline = parseQueryPipeline();\n+        STNode selectClause = parseSelectClause();;\n+        endContext();\n+        return STNodeFactory.createQueryExpressionNode(queryConstructType, queryPipeline, selectClause);\n+    }\n+\n+    /**\n+     * Parse query construct type.\n+     * <p>\n+     * <code>query-construct-type := table key-specifier</code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseQueryConstructType(STNode tableKeyword, STNode keySpecifier) {\n+        return STNodeFactory.createQueryConstructTypeNode(tableKeyword, keySpecifier);\n+    }\n+\n+    /**\n+     * Parse query pipeline.\n+     * <p>\n+     * <code>\n+     * query-pipeline := from-clause intermediate-clause*\n+     * <br/>\n+     * intermediate-clause := from-clause | where-clause | let-clause\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseQueryPipeline() {\n+        STNode fromClause = parseFromClause();\n+        List<STNode> clauses = new ArrayList<>();\n+        return parseQueryPipeline(fromClause, clauses);\n+    }\n+\n+    private STNode parseQueryPipeline(STNode fromClause, List<STNode> clauses) {\n+        return parseQueryPipeline(peek().kind, fromClause, clauses);\n+    }\n+    private STNode parseQueryPipeline(SyntaxKind nextTokenKind, STNode fromClause, List<STNode> clauses) {\n+        STNode clause;\n+\n+        while (true) {\n+            switch (nextTokenKind) {\n+                case FROM_KEYWORD:\n+                    clause = parseFromClause();\n+                    clauses.add(clause);\n+                    nextTokenKind = peek().kind;\n+                    continue;\n+                case WHERE_KEYWORD:\n+                    clause = parseWhereClause();\n+                    clauses.add(clause);\n+                    nextTokenKind = peek().kind;\n+                    continue;\n+                case LET_KEYWORD:\n+                    clause = parseLetClause();\n+                    clauses.add(clause);\n+                    nextTokenKind = peek().kind;\n+                    continue;\n+                case SELECT_KEYWORD:\n+                    break;\n+                default:\n+                    if (nextTokenKind == SyntaxKind.EOF_TOKEN) {\n+                        return parseQueryPipeline(SyntaxKind.SELECT_KEYWORD, fromClause, clauses);\n+                    }\n+\n+                    Solution solution = recover(peek(), ParserRuleContext.QUERY_EXPRESSION_RHS, fromClause, clauses);\n+\n+                    // If the parser recovered by inserting a token, then try to re-parse the same\n+                    // rule with the inserted token. This is done to pick the correct branch\n+                    // to continue the parsing.\n+                    if (solution.action == Action.REMOVE) {\n+                        return solution.recoveredNode;\n+                    }\n+\n+                    return parseQueryPipeline(solution.tokenKind, fromClause, clauses);\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE0NjA4NA=="}, "originalCommit": {"oid": "e36e0403c39213b5761bcd15bea21abc38e8c087"}, "originalPosition": 443}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM2OTc1Nw==", "bodyText": "two approaches. Any suggestion or improvement?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23178#discussion_r424369757", "createdAt": "2020-05-13T11:38:08Z", "author": {"login": "lochana-chathura"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -8185,4 +8166,295 @@ private boolean isEndOfTypeList(SyntaxKind nextTokenKind) {\n     private STNode parseTupleRestTypeDesc() {\n         return STNodeFactory.createEmptyNode();\n     }\n+\n+    /**\n+     * Parse table constructor or query expression.\n+     * <p>\n+     * <code>\n+     * table-constructor-or-query-expr := table-constructor-expr | query-expr\n+     * <br/>\n+     * table-constructor-expr := table [key-specifier] [ [row-list] ]\n+     * <br/>\n+     * query-expr := [query-construct-type] query-pipeline select-clause\n+     * <br/>\n+     * query-construct-type := table key-specifier | stream\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+\n+    private STNode parseTableConstructorOrQuery() {\n+        startContext(ParserRuleContext.TABLE_CONSTRUCTOR_OR_QUERY_EXPRESSION);\n+        return parseTableConstructorOrQuery(peek().kind);\n+    }\n+\n+    private STNode parseTableConstructorOrQuery(SyntaxKind nextTokenKind) {\n+        STNode queryConstructType;\n+        switch (nextTokenKind) {\n+            case FROM_KEYWORD:\n+                queryConstructType = STNodeFactory.createEmptyNode();\n+                return parseQueryExprRhs(queryConstructType);\n+            case STREAM_KEYWORD:\n+                queryConstructType = parseStreamKeyword();\n+                return parseQueryExprRhs(queryConstructType);\n+            case TABLE_KEYWORD:\n+                STNode tableKeyword = parseTableKeyword();\n+                STNode keySpecifier = STNodeFactory.createEmptyNode();\n+                return parseTableConstructorOrQuery(tableKeyword, keySpecifier);\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.TABLE_CONSTRUCTOR_OR_QUERY_START);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseTableConstructorOrQuery(solution.tokenKind);\n+        }\n+\n+    }\n+\n+    private STNode parseTableConstructorOrQuery(STNode tableKeyword, STNode keySpecifier) {\n+        return parseTableConstructorOrQuery(peek().kind, tableKeyword, keySpecifier);\n+    }\n+\n+    private STNode parseTableConstructorOrQuery(SyntaxKind nextTokenKind, STNode tableKeyword, STNode keySpecifier) {\n+        switch (nextTokenKind) {\n+            case OPEN_BRACKET_TOKEN:\n+                return parseTableConstructorExprRhs(tableKeyword, keySpecifier);\n+            case KEY_KEYWORD:\n+                keySpecifier = parseKeySpecifier();\n+                return parseTableConstructorOrQueryRhs(peek().kind, tableKeyword, keySpecifier);\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.TABLE_KEYWORD_RHS, tableKeyword, keySpecifier);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseTableConstructorOrQuery(solution.tokenKind, tableKeyword, keySpecifier);\n+        }\n+    }\n+\n+    private STNode parseTableConstructorOrQueryRhs(STNode tableKeyword, STNode keySpecifier) {\n+        return parseTableConstructorOrQueryRhs(peek().kind, tableKeyword, keySpecifier);\n+    }\n+\n+    private STNode parseTableConstructorOrQueryRhs(SyntaxKind nextTokenKind, STNode tableKeyword, STNode keySpecifier) {\n+        switch (nextTokenKind) {\n+            case FROM_KEYWORD:\n+                return parseQueryExprRhs(parseQueryConstructType(tableKeyword, keySpecifier));\n+            case OPEN_BRACKET_TOKEN:\n+                return parseTableConstructorExprRhs(tableKeyword, keySpecifier);\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.TABLE_CONSTRUCTOR_OR_QUERY_RHS,\n+                    tableKeyword, keySpecifier);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseTableConstructorOrQueryRhs(solution.tokenKind, tableKeyword, keySpecifier);\n+        }\n+    }\n+\n+    /**\n+     * Parse query expression.\n+     * <code>query-expr-rhs := query-pipeline select-clause</code>\n+     *\n+     * @param queryConstructType queryConstructType that precedes this rhs\n+     * @return Parsed node\n+     */\n+    private STNode parseQueryExprRhs(STNode queryConstructType) {\n+        switchContext(ParserRuleContext.QUERY_EXPRESSION);\n+        STNode queryPipeline = parseQueryPipeline();\n+        STNode selectClause = parseSelectClause();;\n+        endContext();\n+        return STNodeFactory.createQueryExpressionNode(queryConstructType, queryPipeline, selectClause);\n+    }\n+\n+    /**\n+     * Parse query construct type.\n+     * <p>\n+     * <code>query-construct-type := table key-specifier</code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseQueryConstructType(STNode tableKeyword, STNode keySpecifier) {\n+        return STNodeFactory.createQueryConstructTypeNode(tableKeyword, keySpecifier);\n+    }\n+\n+    /**\n+     * Parse query pipeline.\n+     * <p>\n+     * <code>\n+     * query-pipeline := from-clause intermediate-clause*\n+     * <br/>\n+     * intermediate-clause := from-clause | where-clause | let-clause\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseQueryPipeline() {\n+        STNode fromClause = parseFromClause();\n+        List<STNode> clauses = new ArrayList<>();\n+        return parseQueryPipeline(fromClause, clauses);\n+    }\n+\n+    private STNode parseQueryPipeline(STNode fromClause, List<STNode> clauses) {\n+        return parseQueryPipeline(peek().kind, fromClause, clauses);\n+    }\n+    private STNode parseQueryPipeline(SyntaxKind nextTokenKind, STNode fromClause, List<STNode> clauses) {\n+        STNode clause;\n+\n+        while (true) {\n+            switch (nextTokenKind) {\n+                case FROM_KEYWORD:\n+                    clause = parseFromClause();\n+                    clauses.add(clause);\n+                    nextTokenKind = peek().kind;\n+                    continue;\n+                case WHERE_KEYWORD:\n+                    clause = parseWhereClause();\n+                    clauses.add(clause);\n+                    nextTokenKind = peek().kind;\n+                    continue;\n+                case LET_KEYWORD:\n+                    clause = parseLetClause();\n+                    clauses.add(clause);\n+                    nextTokenKind = peek().kind;\n+                    continue;\n+                case SELECT_KEYWORD:\n+                    break;\n+                default:\n+                    if (nextTokenKind == SyntaxKind.EOF_TOKEN) {\n+                        return parseQueryPipeline(SyntaxKind.SELECT_KEYWORD, fromClause, clauses);\n+                    }\n+\n+                    Solution solution = recover(peek(), ParserRuleContext.QUERY_EXPRESSION_RHS, fromClause, clauses);\n+\n+                    // If the parser recovered by inserting a token, then try to re-parse the same\n+                    // rule with the inserted token. This is done to pick the correct branch\n+                    // to continue the parsing.\n+                    if (solution.action == Action.REMOVE) {\n+                        return solution.recoveredNode;\n+                    }\n+\n+                    return parseQueryPipeline(solution.tokenKind, fromClause, clauses);\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE0NjA4NA=="}, "originalCommit": {"oid": "e36e0403c39213b5761bcd15bea21abc38e8c087"}, "originalPosition": 443}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MTI5MjgzOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwMzowNDoyMVrOGUf4QQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwMzowNDoyMVrOGUf4QQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE0NzAwOQ==", "bodyText": "Extra semicolon", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23178#discussion_r424147009", "createdAt": "2020-05-13T03:04:21Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -8185,4 +8166,295 @@ private boolean isEndOfTypeList(SyntaxKind nextTokenKind) {\n     private STNode parseTupleRestTypeDesc() {\n         return STNodeFactory.createEmptyNode();\n     }\n+\n+    /**\n+     * Parse table constructor or query expression.\n+     * <p>\n+     * <code>\n+     * table-constructor-or-query-expr := table-constructor-expr | query-expr\n+     * <br/>\n+     * table-constructor-expr := table [key-specifier] [ [row-list] ]\n+     * <br/>\n+     * query-expr := [query-construct-type] query-pipeline select-clause\n+     * <br/>\n+     * query-construct-type := table key-specifier | stream\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+\n+    private STNode parseTableConstructorOrQuery() {\n+        startContext(ParserRuleContext.TABLE_CONSTRUCTOR_OR_QUERY_EXPRESSION);\n+        return parseTableConstructorOrQuery(peek().kind);\n+    }\n+\n+    private STNode parseTableConstructorOrQuery(SyntaxKind nextTokenKind) {\n+        STNode queryConstructType;\n+        switch (nextTokenKind) {\n+            case FROM_KEYWORD:\n+                queryConstructType = STNodeFactory.createEmptyNode();\n+                return parseQueryExprRhs(queryConstructType);\n+            case STREAM_KEYWORD:\n+                queryConstructType = parseStreamKeyword();\n+                return parseQueryExprRhs(queryConstructType);\n+            case TABLE_KEYWORD:\n+                STNode tableKeyword = parseTableKeyword();\n+                STNode keySpecifier = STNodeFactory.createEmptyNode();\n+                return parseTableConstructorOrQuery(tableKeyword, keySpecifier);\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.TABLE_CONSTRUCTOR_OR_QUERY_START);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseTableConstructorOrQuery(solution.tokenKind);\n+        }\n+\n+    }\n+\n+    private STNode parseTableConstructorOrQuery(STNode tableKeyword, STNode keySpecifier) {\n+        return parseTableConstructorOrQuery(peek().kind, tableKeyword, keySpecifier);\n+    }\n+\n+    private STNode parseTableConstructorOrQuery(SyntaxKind nextTokenKind, STNode tableKeyword, STNode keySpecifier) {\n+        switch (nextTokenKind) {\n+            case OPEN_BRACKET_TOKEN:\n+                return parseTableConstructorExprRhs(tableKeyword, keySpecifier);\n+            case KEY_KEYWORD:\n+                keySpecifier = parseKeySpecifier();\n+                return parseTableConstructorOrQueryRhs(peek().kind, tableKeyword, keySpecifier);\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.TABLE_KEYWORD_RHS, tableKeyword, keySpecifier);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseTableConstructorOrQuery(solution.tokenKind, tableKeyword, keySpecifier);\n+        }\n+    }\n+\n+    private STNode parseTableConstructorOrQueryRhs(STNode tableKeyword, STNode keySpecifier) {\n+        return parseTableConstructorOrQueryRhs(peek().kind, tableKeyword, keySpecifier);\n+    }\n+\n+    private STNode parseTableConstructorOrQueryRhs(SyntaxKind nextTokenKind, STNode tableKeyword, STNode keySpecifier) {\n+        switch (nextTokenKind) {\n+            case FROM_KEYWORD:\n+                return parseQueryExprRhs(parseQueryConstructType(tableKeyword, keySpecifier));\n+            case OPEN_BRACKET_TOKEN:\n+                return parseTableConstructorExprRhs(tableKeyword, keySpecifier);\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.TABLE_CONSTRUCTOR_OR_QUERY_RHS,\n+                    tableKeyword, keySpecifier);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseTableConstructorOrQueryRhs(solution.tokenKind, tableKeyword, keySpecifier);\n+        }\n+    }\n+\n+    /**\n+     * Parse query expression.\n+     * <code>query-expr-rhs := query-pipeline select-clause</code>\n+     *\n+     * @param queryConstructType queryConstructType that precedes this rhs\n+     * @return Parsed node\n+     */\n+    private STNode parseQueryExprRhs(STNode queryConstructType) {\n+        switchContext(ParserRuleContext.QUERY_EXPRESSION);\n+        STNode queryPipeline = parseQueryPipeline();\n+        STNode selectClause = parseSelectClause();;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e36e0403c39213b5761bcd15bea21abc38e8c087"}, "originalPosition": 370}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MTI5NzgzOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwMzowNzo0N1rOGUf7Pw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwMzowNzo0N1rOGUf7Pw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE0Nzc3NQ==", "bodyText": "This is a bit dangerous, as we may get stuck in an infinite loop. Better to do a while(!isEndOfExpression())", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23178#discussion_r424147775", "createdAt": "2020-05-13T03:07:47Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -8185,4 +8166,295 @@ private boolean isEndOfTypeList(SyntaxKind nextTokenKind) {\n     private STNode parseTupleRestTypeDesc() {\n         return STNodeFactory.createEmptyNode();\n     }\n+\n+    /**\n+     * Parse table constructor or query expression.\n+     * <p>\n+     * <code>\n+     * table-constructor-or-query-expr := table-constructor-expr | query-expr\n+     * <br/>\n+     * table-constructor-expr := table [key-specifier] [ [row-list] ]\n+     * <br/>\n+     * query-expr := [query-construct-type] query-pipeline select-clause\n+     * <br/>\n+     * query-construct-type := table key-specifier | stream\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+\n+    private STNode parseTableConstructorOrQuery() {\n+        startContext(ParserRuleContext.TABLE_CONSTRUCTOR_OR_QUERY_EXPRESSION);\n+        return parseTableConstructorOrQuery(peek().kind);\n+    }\n+\n+    private STNode parseTableConstructorOrQuery(SyntaxKind nextTokenKind) {\n+        STNode queryConstructType;\n+        switch (nextTokenKind) {\n+            case FROM_KEYWORD:\n+                queryConstructType = STNodeFactory.createEmptyNode();\n+                return parseQueryExprRhs(queryConstructType);\n+            case STREAM_KEYWORD:\n+                queryConstructType = parseStreamKeyword();\n+                return parseQueryExprRhs(queryConstructType);\n+            case TABLE_KEYWORD:\n+                STNode tableKeyword = parseTableKeyword();\n+                STNode keySpecifier = STNodeFactory.createEmptyNode();\n+                return parseTableConstructorOrQuery(tableKeyword, keySpecifier);\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.TABLE_CONSTRUCTOR_OR_QUERY_START);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseTableConstructorOrQuery(solution.tokenKind);\n+        }\n+\n+    }\n+\n+    private STNode parseTableConstructorOrQuery(STNode tableKeyword, STNode keySpecifier) {\n+        return parseTableConstructorOrQuery(peek().kind, tableKeyword, keySpecifier);\n+    }\n+\n+    private STNode parseTableConstructorOrQuery(SyntaxKind nextTokenKind, STNode tableKeyword, STNode keySpecifier) {\n+        switch (nextTokenKind) {\n+            case OPEN_BRACKET_TOKEN:\n+                return parseTableConstructorExprRhs(tableKeyword, keySpecifier);\n+            case KEY_KEYWORD:\n+                keySpecifier = parseKeySpecifier();\n+                return parseTableConstructorOrQueryRhs(peek().kind, tableKeyword, keySpecifier);\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.TABLE_KEYWORD_RHS, tableKeyword, keySpecifier);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseTableConstructorOrQuery(solution.tokenKind, tableKeyword, keySpecifier);\n+        }\n+    }\n+\n+    private STNode parseTableConstructorOrQueryRhs(STNode tableKeyword, STNode keySpecifier) {\n+        return parseTableConstructorOrQueryRhs(peek().kind, tableKeyword, keySpecifier);\n+    }\n+\n+    private STNode parseTableConstructorOrQueryRhs(SyntaxKind nextTokenKind, STNode tableKeyword, STNode keySpecifier) {\n+        switch (nextTokenKind) {\n+            case FROM_KEYWORD:\n+                return parseQueryExprRhs(parseQueryConstructType(tableKeyword, keySpecifier));\n+            case OPEN_BRACKET_TOKEN:\n+                return parseTableConstructorExprRhs(tableKeyword, keySpecifier);\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.TABLE_CONSTRUCTOR_OR_QUERY_RHS,\n+                    tableKeyword, keySpecifier);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseTableConstructorOrQueryRhs(solution.tokenKind, tableKeyword, keySpecifier);\n+        }\n+    }\n+\n+    /**\n+     * Parse query expression.\n+     * <code>query-expr-rhs := query-pipeline select-clause</code>\n+     *\n+     * @param queryConstructType queryConstructType that precedes this rhs\n+     * @return Parsed node\n+     */\n+    private STNode parseQueryExprRhs(STNode queryConstructType) {\n+        switchContext(ParserRuleContext.QUERY_EXPRESSION);\n+        STNode queryPipeline = parseQueryPipeline();\n+        STNode selectClause = parseSelectClause();;\n+        endContext();\n+        return STNodeFactory.createQueryExpressionNode(queryConstructType, queryPipeline, selectClause);\n+    }\n+\n+    /**\n+     * Parse query construct type.\n+     * <p>\n+     * <code>query-construct-type := table key-specifier</code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseQueryConstructType(STNode tableKeyword, STNode keySpecifier) {\n+        return STNodeFactory.createQueryConstructTypeNode(tableKeyword, keySpecifier);\n+    }\n+\n+    /**\n+     * Parse query pipeline.\n+     * <p>\n+     * <code>\n+     * query-pipeline := from-clause intermediate-clause*\n+     * <br/>\n+     * intermediate-clause := from-clause | where-clause | let-clause\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseQueryPipeline() {\n+        STNode fromClause = parseFromClause();\n+        List<STNode> clauses = new ArrayList<>();\n+        return parseQueryPipeline(fromClause, clauses);\n+    }\n+\n+    private STNode parseQueryPipeline(STNode fromClause, List<STNode> clauses) {\n+        return parseQueryPipeline(peek().kind, fromClause, clauses);\n+    }\n+    private STNode parseQueryPipeline(SyntaxKind nextTokenKind, STNode fromClause, List<STNode> clauses) {\n+        STNode clause;\n+\n+        while (true) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e36e0403c39213b5761bcd15bea21abc38e8c087"}, "originalPosition": 409}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MTMwMDExOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwMzowOToyMlrOGUf8rg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxMjoyNDo0MlrOGUvAcw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE0ODE0Mg==", "bodyText": "We can see if there are more clauses after the select clause as well, and give an error.\nCan do the same thing as in parseQueryPipeline, but simply log and error.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23178#discussion_r424148142", "createdAt": "2020-05-13T03:09:22Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -8185,4 +8166,295 @@ private boolean isEndOfTypeList(SyntaxKind nextTokenKind) {\n     private STNode parseTupleRestTypeDesc() {\n         return STNodeFactory.createEmptyNode();\n     }\n+\n+    /**\n+     * Parse table constructor or query expression.\n+     * <p>\n+     * <code>\n+     * table-constructor-or-query-expr := table-constructor-expr | query-expr\n+     * <br/>\n+     * table-constructor-expr := table [key-specifier] [ [row-list] ]\n+     * <br/>\n+     * query-expr := [query-construct-type] query-pipeline select-clause\n+     * <br/>\n+     * query-construct-type := table key-specifier | stream\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+\n+    private STNode parseTableConstructorOrQuery() {\n+        startContext(ParserRuleContext.TABLE_CONSTRUCTOR_OR_QUERY_EXPRESSION);\n+        return parseTableConstructorOrQuery(peek().kind);\n+    }\n+\n+    private STNode parseTableConstructorOrQuery(SyntaxKind nextTokenKind) {\n+        STNode queryConstructType;\n+        switch (nextTokenKind) {\n+            case FROM_KEYWORD:\n+                queryConstructType = STNodeFactory.createEmptyNode();\n+                return parseQueryExprRhs(queryConstructType);\n+            case STREAM_KEYWORD:\n+                queryConstructType = parseStreamKeyword();\n+                return parseQueryExprRhs(queryConstructType);\n+            case TABLE_KEYWORD:\n+                STNode tableKeyword = parseTableKeyword();\n+                STNode keySpecifier = STNodeFactory.createEmptyNode();\n+                return parseTableConstructorOrQuery(tableKeyword, keySpecifier);\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.TABLE_CONSTRUCTOR_OR_QUERY_START);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseTableConstructorOrQuery(solution.tokenKind);\n+        }\n+\n+    }\n+\n+    private STNode parseTableConstructorOrQuery(STNode tableKeyword, STNode keySpecifier) {\n+        return parseTableConstructorOrQuery(peek().kind, tableKeyword, keySpecifier);\n+    }\n+\n+    private STNode parseTableConstructorOrQuery(SyntaxKind nextTokenKind, STNode tableKeyword, STNode keySpecifier) {\n+        switch (nextTokenKind) {\n+            case OPEN_BRACKET_TOKEN:\n+                return parseTableConstructorExprRhs(tableKeyword, keySpecifier);\n+            case KEY_KEYWORD:\n+                keySpecifier = parseKeySpecifier();\n+                return parseTableConstructorOrQueryRhs(peek().kind, tableKeyword, keySpecifier);\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.TABLE_KEYWORD_RHS, tableKeyword, keySpecifier);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseTableConstructorOrQuery(solution.tokenKind, tableKeyword, keySpecifier);\n+        }\n+    }\n+\n+    private STNode parseTableConstructorOrQueryRhs(STNode tableKeyword, STNode keySpecifier) {\n+        return parseTableConstructorOrQueryRhs(peek().kind, tableKeyword, keySpecifier);\n+    }\n+\n+    private STNode parseTableConstructorOrQueryRhs(SyntaxKind nextTokenKind, STNode tableKeyword, STNode keySpecifier) {\n+        switch (nextTokenKind) {\n+            case FROM_KEYWORD:\n+                return parseQueryExprRhs(parseQueryConstructType(tableKeyword, keySpecifier));\n+            case OPEN_BRACKET_TOKEN:\n+                return parseTableConstructorExprRhs(tableKeyword, keySpecifier);\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.TABLE_CONSTRUCTOR_OR_QUERY_RHS,\n+                    tableKeyword, keySpecifier);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseTableConstructorOrQueryRhs(solution.tokenKind, tableKeyword, keySpecifier);\n+        }\n+    }\n+\n+    /**\n+     * Parse query expression.\n+     * <code>query-expr-rhs := query-pipeline select-clause</code>\n+     *\n+     * @param queryConstructType queryConstructType that precedes this rhs\n+     * @return Parsed node\n+     */\n+    private STNode parseQueryExprRhs(STNode queryConstructType) {\n+        switchContext(ParserRuleContext.QUERY_EXPRESSION);\n+        STNode queryPipeline = parseQueryPipeline();\n+        STNode selectClause = parseSelectClause();;\n+        endContext();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e36e0403c39213b5761bcd15bea21abc38e8c087"}, "originalPosition": 371}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM5NDg2Nw==", "bodyText": "So this logic also go inside parseQueryExprRhs if we are to go ahead with one of above mentioned approaches?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23178#discussion_r424394867", "createdAt": "2020-05-13T12:24:42Z", "author": {"login": "lochana-chathura"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -8185,4 +8166,295 @@ private boolean isEndOfTypeList(SyntaxKind nextTokenKind) {\n     private STNode parseTupleRestTypeDesc() {\n         return STNodeFactory.createEmptyNode();\n     }\n+\n+    /**\n+     * Parse table constructor or query expression.\n+     * <p>\n+     * <code>\n+     * table-constructor-or-query-expr := table-constructor-expr | query-expr\n+     * <br/>\n+     * table-constructor-expr := table [key-specifier] [ [row-list] ]\n+     * <br/>\n+     * query-expr := [query-construct-type] query-pipeline select-clause\n+     * <br/>\n+     * query-construct-type := table key-specifier | stream\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+\n+    private STNode parseTableConstructorOrQuery() {\n+        startContext(ParserRuleContext.TABLE_CONSTRUCTOR_OR_QUERY_EXPRESSION);\n+        return parseTableConstructorOrQuery(peek().kind);\n+    }\n+\n+    private STNode parseTableConstructorOrQuery(SyntaxKind nextTokenKind) {\n+        STNode queryConstructType;\n+        switch (nextTokenKind) {\n+            case FROM_KEYWORD:\n+                queryConstructType = STNodeFactory.createEmptyNode();\n+                return parseQueryExprRhs(queryConstructType);\n+            case STREAM_KEYWORD:\n+                queryConstructType = parseStreamKeyword();\n+                return parseQueryExprRhs(queryConstructType);\n+            case TABLE_KEYWORD:\n+                STNode tableKeyword = parseTableKeyword();\n+                STNode keySpecifier = STNodeFactory.createEmptyNode();\n+                return parseTableConstructorOrQuery(tableKeyword, keySpecifier);\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.TABLE_CONSTRUCTOR_OR_QUERY_START);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseTableConstructorOrQuery(solution.tokenKind);\n+        }\n+\n+    }\n+\n+    private STNode parseTableConstructorOrQuery(STNode tableKeyword, STNode keySpecifier) {\n+        return parseTableConstructorOrQuery(peek().kind, tableKeyword, keySpecifier);\n+    }\n+\n+    private STNode parseTableConstructorOrQuery(SyntaxKind nextTokenKind, STNode tableKeyword, STNode keySpecifier) {\n+        switch (nextTokenKind) {\n+            case OPEN_BRACKET_TOKEN:\n+                return parseTableConstructorExprRhs(tableKeyword, keySpecifier);\n+            case KEY_KEYWORD:\n+                keySpecifier = parseKeySpecifier();\n+                return parseTableConstructorOrQueryRhs(peek().kind, tableKeyword, keySpecifier);\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.TABLE_KEYWORD_RHS, tableKeyword, keySpecifier);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseTableConstructorOrQuery(solution.tokenKind, tableKeyword, keySpecifier);\n+        }\n+    }\n+\n+    private STNode parseTableConstructorOrQueryRhs(STNode tableKeyword, STNode keySpecifier) {\n+        return parseTableConstructorOrQueryRhs(peek().kind, tableKeyword, keySpecifier);\n+    }\n+\n+    private STNode parseTableConstructorOrQueryRhs(SyntaxKind nextTokenKind, STNode tableKeyword, STNode keySpecifier) {\n+        switch (nextTokenKind) {\n+            case FROM_KEYWORD:\n+                return parseQueryExprRhs(parseQueryConstructType(tableKeyword, keySpecifier));\n+            case OPEN_BRACKET_TOKEN:\n+                return parseTableConstructorExprRhs(tableKeyword, keySpecifier);\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.TABLE_CONSTRUCTOR_OR_QUERY_RHS,\n+                    tableKeyword, keySpecifier);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseTableConstructorOrQueryRhs(solution.tokenKind, tableKeyword, keySpecifier);\n+        }\n+    }\n+\n+    /**\n+     * Parse query expression.\n+     * <code>query-expr-rhs := query-pipeline select-clause</code>\n+     *\n+     * @param queryConstructType queryConstructType that precedes this rhs\n+     * @return Parsed node\n+     */\n+    private STNode parseQueryExprRhs(STNode queryConstructType) {\n+        switchContext(ParserRuleContext.QUERY_EXPRESSION);\n+        STNode queryPipeline = parseQueryPipeline();\n+        STNode selectClause = parseSelectClause();;\n+        endContext();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE0ODE0Mg=="}, "originalCommit": {"oid": "e36e0403c39213b5761bcd15bea21abc38e8c087"}, "originalPosition": 371}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MTMwNjY1OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwMzoxMzo0N1rOGUgAiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwMzoxMzo0N1rOGUgAiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE0OTEzMQ==", "bodyText": "We don't need to create an empty key-specifier and pass it.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23178#discussion_r424149131", "createdAt": "2020-05-13T03:13:47Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -8185,4 +8166,295 @@ private boolean isEndOfTypeList(SyntaxKind nextTokenKind) {\n     private STNode parseTupleRestTypeDesc() {\n         return STNodeFactory.createEmptyNode();\n     }\n+\n+    /**\n+     * Parse table constructor or query expression.\n+     * <p>\n+     * <code>\n+     * table-constructor-or-query-expr := table-constructor-expr | query-expr\n+     * <br/>\n+     * table-constructor-expr := table [key-specifier] [ [row-list] ]\n+     * <br/>\n+     * query-expr := [query-construct-type] query-pipeline select-clause\n+     * <br/>\n+     * query-construct-type := table key-specifier | stream\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+\n+    private STNode parseTableConstructorOrQuery() {\n+        startContext(ParserRuleContext.TABLE_CONSTRUCTOR_OR_QUERY_EXPRESSION);\n+        return parseTableConstructorOrQuery(peek().kind);\n+    }\n+\n+    private STNode parseTableConstructorOrQuery(SyntaxKind nextTokenKind) {\n+        STNode queryConstructType;\n+        switch (nextTokenKind) {\n+            case FROM_KEYWORD:\n+                queryConstructType = STNodeFactory.createEmptyNode();\n+                return parseQueryExprRhs(queryConstructType);\n+            case STREAM_KEYWORD:\n+                queryConstructType = parseStreamKeyword();\n+                return parseQueryExprRhs(queryConstructType);\n+            case TABLE_KEYWORD:\n+                STNode tableKeyword = parseTableKeyword();\n+                STNode keySpecifier = STNodeFactory.createEmptyNode();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e36e0403c39213b5761bcd15bea21abc38e8c087"}, "originalPosition": 293}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MTMxODExOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwMzoyMjowMFrOGUgHqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxMDoyNToyNFrOGUrRYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE1MDk1NA==", "bodyText": "We can switch the context at the point where we give QUERY_EXPRESSION / TABLE_CONSTRUCTOR as the next rule.\nNot a big issue though, just thought it would be slightly clear for a reader.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23178#discussion_r424150954", "createdAt": "2020-05-13T03:22:00Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -1454,6 +1495,15 @@ protected ParserRuleContext getNextRule(ParserRuleContext currentCtx, int nextLo\n                 break;\n         }\n \n+        switch (currentCtx) {\n+            case TABLE_CONSTRUCTOR:\n+            case QUERY_EXPRESSION:\n+                switchContext(currentCtx);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e36e0403c39213b5761bcd15bea21abc38e8c087"}, "originalPosition": 152}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDMzMDU1MA==", "bodyText": "private static final ParserRuleContext[] TABLE_CONSTRUCTOR_OR_QUERY_START =\n            { ParserRuleContext.TABLE_KEYWORD, ParserRuleContext.STREAM_KEYWORD, ParserRuleContext.QUERY_EXPRESSION };\n\n    private static final ParserRuleContext[] TABLE_CONSTRUCTOR_OR_QUERY_RHS =\n            { ParserRuleContext.TABLE_CONSTRUCTOR, ParserRuleContext.QUERY_EXPRESSION };\n\nActually those two ctx are not called directly as the next rule. They are called inside above arrays ?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23178#discussion_r424330550", "createdAt": "2020-05-13T10:19:50Z", "author": {"login": "lochana-chathura"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -1454,6 +1495,15 @@ protected ParserRuleContext getNextRule(ParserRuleContext currentCtx, int nextLo\n                 break;\n         }\n \n+        switch (currentCtx) {\n+            case TABLE_CONSTRUCTOR:\n+            case QUERY_EXPRESSION:\n+                switchContext(currentCtx);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE1MDk1NA=="}, "originalCommit": {"oid": "e36e0403c39213b5761bcd15bea21abc38e8c087"}, "originalPosition": 152}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDMzMzY2NA==", "bodyText": "ack. Then its OK to keep it.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23178#discussion_r424333664", "createdAt": "2020-05-13T10:25:24Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -1454,6 +1495,15 @@ protected ParserRuleContext getNextRule(ParserRuleContext currentCtx, int nextLo\n                 break;\n         }\n \n+        switch (currentCtx) {\n+            case TABLE_CONSTRUCTOR:\n+            case QUERY_EXPRESSION:\n+                switchContext(currentCtx);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE1MDk1NA=="}, "originalCommit": {"oid": "e36e0403c39213b5761bcd15bea21abc38e8c087"}, "originalPosition": 152}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MTMyNzMyOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-treegen/src/main/resources/syntax_tree_descriptor.json", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwMzoyODoyOFrOGUgNRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwMzoyODoyOFrOGUgNRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE1MjM5MQ==", "bodyText": "Shall we introduce a base node for all the clause nodes?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23178#discussion_r424152391", "createdAt": "2020-05-13T03:28:28Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-treegen/src/main/resources/syntax_tree_descriptor.json", "diffHunk": "@@ -2438,6 +2438,129 @@\n                     \"type\": \"Token\"\n                 }\n             ]\n+        },\n+        {\n+            \"name\": \"QueryConstructTypeNode\",\n+            \"base\": \"Node\",\n+            \"kind\": \"QUERY_CONSTRUCT_TYPE\",\n+            \"attributes\": [\n+                {\n+                    \"name\": \"tableKeyword\",\n+                    \"type\": \"Token\"\n+                },\n+                {\n+                    \"name\": \"KeySpecifier\",\n+                    \"type\": \"KeySpecifierNode\"\n+                }\n+            ]\n+        },\n+        {\n+            \"name\": \"FromClauseNode\",\n+            \"base\": \"Node\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e36e0403c39213b5761bcd15bea21abc38e8c087"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MTMzMzU2OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwMzozMzoxMFrOGUgRHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxMjoxNDoxMFrOGUunww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE1MzM3Mg==", "bodyText": "Can we end the context here, rather than in the respective child methods?\nSo that we can make sure the context is ended, no matter which branch it goes within the  parseTableConstructorOrQuery", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23178#discussion_r424153372", "createdAt": "2020-05-13T03:33:10Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -8185,4 +8166,295 @@ private boolean isEndOfTypeList(SyntaxKind nextTokenKind) {\n     private STNode parseTupleRestTypeDesc() {\n         return STNodeFactory.createEmptyNode();\n     }\n+\n+    /**\n+     * Parse table constructor or query expression.\n+     * <p>\n+     * <code>\n+     * table-constructor-or-query-expr := table-constructor-expr | query-expr\n+     * <br/>\n+     * table-constructor-expr := table [key-specifier] [ [row-list] ]\n+     * <br/>\n+     * query-expr := [query-construct-type] query-pipeline select-clause\n+     * <br/>\n+     * query-construct-type := table key-specifier | stream\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+\n+    private STNode parseTableConstructorOrQuery() {\n+        startContext(ParserRuleContext.TABLE_CONSTRUCTOR_OR_QUERY_EXPRESSION);\n+        return parseTableConstructorOrQuery(peek().kind);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e36e0403c39213b5761bcd15bea21abc38e8c087"}, "originalPosition": 279}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM3MjIwMA==", "bodyText": "You mean this change right?\nprivate STNode parseTableConstructorOrQuery() {\n        startContext(ParserRuleContext.TABLE_CONSTRUCTOR_OR_QUERY_EXPRESSION);\n        STNode tableOrQueryExpr = parseTableConstructorOrQuery(peek().kind);\n        endContext();\n        return tableOrQueryExpr;\n    }", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23178#discussion_r424372200", "createdAt": "2020-05-13T11:43:02Z", "author": {"login": "lochana-chathura"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -8185,4 +8166,295 @@ private boolean isEndOfTypeList(SyntaxKind nextTokenKind) {\n     private STNode parseTupleRestTypeDesc() {\n         return STNodeFactory.createEmptyNode();\n     }\n+\n+    /**\n+     * Parse table constructor or query expression.\n+     * <p>\n+     * <code>\n+     * table-constructor-or-query-expr := table-constructor-expr | query-expr\n+     * <br/>\n+     * table-constructor-expr := table [key-specifier] [ [row-list] ]\n+     * <br/>\n+     * query-expr := [query-construct-type] query-pipeline select-clause\n+     * <br/>\n+     * query-construct-type := table key-specifier | stream\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+\n+    private STNode parseTableConstructorOrQuery() {\n+        startContext(ParserRuleContext.TABLE_CONSTRUCTOR_OR_QUERY_EXPRESSION);\n+        return parseTableConstructorOrQuery(peek().kind);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE1MzM3Mg=="}, "originalCommit": {"oid": "e36e0403c39213b5761bcd15bea21abc38e8c087"}, "originalPosition": 279}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM4ODU0Nw==", "bodyText": "yes.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23178#discussion_r424388547", "createdAt": "2020-05-13T12:14:10Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -8185,4 +8166,295 @@ private boolean isEndOfTypeList(SyntaxKind nextTokenKind) {\n     private STNode parseTupleRestTypeDesc() {\n         return STNodeFactory.createEmptyNode();\n     }\n+\n+    /**\n+     * Parse table constructor or query expression.\n+     * <p>\n+     * <code>\n+     * table-constructor-or-query-expr := table-constructor-expr | query-expr\n+     * <br/>\n+     * table-constructor-expr := table [key-specifier] [ [row-list] ]\n+     * <br/>\n+     * query-expr := [query-construct-type] query-pipeline select-clause\n+     * <br/>\n+     * query-construct-type := table key-specifier | stream\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+\n+    private STNode parseTableConstructorOrQuery() {\n+        startContext(ParserRuleContext.TABLE_CONSTRUCTOR_OR_QUERY_EXPRESSION);\n+        return parseTableConstructorOrQuery(peek().kind);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE1MzM3Mg=="}, "originalCommit": {"oid": "e36e0403c39213b5761bcd15bea21abc38e8c087"}, "originalPosition": 279}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0Nzg2OTk0OnYy", "diffSide": "LEFT", "path": "compiler/ballerina-parser/src/test/java/io/ballerinalang/compiler/parser/test/syntax/expressions/TableConstructorTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxNTowNTowMVrOGVgs2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxNTowNTowMVrOGVgs2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTIwOTA0OQ==", "bodyText": "This was removed from table constructor tests as this is recovered as a query expression. Similar test case has been added under query expression test cases :)", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23178#discussion_r425209049", "createdAt": "2020-05-14T15:05:01Z", "author": {"login": "lochana-chathura"}, "path": "compiler/ballerina-parser/src/test/java/io/ballerinalang/compiler/parser/test/syntax/expressions/TableConstructorTest.java", "diffHunk": "@@ -117,9 +117,4 @@ public void testTableWithExtraToken() {\n         test(\"table foo key() [{k1:v1}]\", \"table-constructor/table_constructor_assert_24.json\");\n         test(\"table foo [{k1:v1}]\", \"table-constructor/table_constructor_assert_25.json\");\n     }\n-\n-    @Test\n-    public void testTableWithTwoKeySpecifiersWithExtraTokenInBetween() {\n-        test(\"table key(a) foo key(b) []\", \"table-constructor/table_constructor_assert_26.json\");\n-    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5cab218deb30646b008a3509e91d1016af69551"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0ODEwOTg5OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxNTo1Njo1NFrOGVjEug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxNjo1MTo0N1rOGVlcDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTI0NzkzMA==", "bodyText": "As a safety measure, we can check whether the solution.tokenKind is an endOfIntermediateClause, and return null if so. That way we can avoid going to recovery infinitely. Returning null from this method can be treated as the end of intermediate clauses.\nWe can do that as an improvement though. This is more than good enough for now.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23178#discussion_r425247930", "createdAt": "2020-05-14T15:56:54Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -8423,4 +8409,338 @@ private STNode parseParenthesisedTypeDesc() {\n         STNode closeParen = parseCloseParenthesis();\n         return STNodeFactory.createParenthesisedTypeDescriptorNode(openParen, typedesc, closeParen);\n     }\n+\n+    /**\n+     * Parse table constructor or query expression.\n+     * <p>\n+     * <code>\n+     * table-constructor-or-query-expr := table-constructor-expr | query-expr\n+     * <br/>\n+     * table-constructor-expr := table [key-specifier] [ [row-list] ]\n+     * <br/>\n+     * query-expr := [query-construct-type] query-pipeline select-clause\n+     * <br/>\n+     * query-construct-type := table key-specifier | stream\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+\n+    private STNode parseTableConstructorOrQuery(boolean isRhsExpr) {\n+        startContext(ParserRuleContext.TABLE_CONSTRUCTOR_OR_QUERY_EXPRESSION);\n+        STNode tableOrQueryExpr = parseTableConstructorOrQuery(peek().kind, isRhsExpr);\n+        endContext();\n+        return tableOrQueryExpr;\n+    }\n+\n+    private STNode parseTableConstructorOrQuery(SyntaxKind nextTokenKind, boolean isRhsExpr) {\n+        STNode queryConstructType;\n+        switch (nextTokenKind) {\n+            case FROM_KEYWORD:\n+                queryConstructType = STNodeFactory.createEmptyNode();\n+                return parseQueryExprRhs(queryConstructType, isRhsExpr);\n+            case STREAM_KEYWORD:\n+                queryConstructType = parseStreamKeyword();\n+                return parseQueryExprRhs(queryConstructType, isRhsExpr);\n+            case TABLE_KEYWORD:\n+                STNode tableKeyword = parseTableKeyword();\n+                return parseTableConstructorOrQuery(tableKeyword, isRhsExpr);\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.TABLE_CONSTRUCTOR_OR_QUERY_START, isRhsExpr);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseTableConstructorOrQuery(solution.tokenKind, isRhsExpr);\n+        }\n+\n+    }\n+\n+    private STNode parseTableConstructorOrQuery(STNode tableKeyword, boolean isRhsExpr) {\n+        return parseTableConstructorOrQuery(peek().kind, tableKeyword, isRhsExpr);\n+    }\n+\n+    private STNode parseTableConstructorOrQuery(SyntaxKind nextTokenKind, STNode tableKeyword, boolean isRhsExpr) {\n+        STNode keySpecifier;\n+        switch (nextTokenKind) {\n+            case OPEN_BRACKET_TOKEN:\n+                keySpecifier = STNodeFactory.createEmptyNode();\n+                return parseTableConstructorExprRhs(tableKeyword, keySpecifier);\n+            case KEY_KEYWORD:\n+                keySpecifier = parseKeySpecifier();\n+                return parseTableConstructorOrQueryRhs(tableKeyword, keySpecifier, isRhsExpr);\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.TABLE_KEYWORD_RHS, tableKeyword, isRhsExpr);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseTableConstructorOrQuery(solution.tokenKind, tableKeyword, isRhsExpr);\n+        }\n+    }\n+\n+    private STNode parseTableConstructorOrQueryRhs(STNode tableKeyword, STNode keySpecifier, boolean isRhsExpr) {\n+        return parseTableConstructorOrQueryRhs(peek().kind, tableKeyword, keySpecifier, isRhsExpr);\n+    }\n+\n+    private STNode parseTableConstructorOrQueryRhs(SyntaxKind nextTokenKind, STNode tableKeyword, STNode keySpecifier,\n+                                                   boolean isRhsExpr) {\n+        switch (nextTokenKind) {\n+            case FROM_KEYWORD:\n+                return parseQueryExprRhs(parseQueryConstructType(tableKeyword, keySpecifier), isRhsExpr);\n+            case OPEN_BRACKET_TOKEN:\n+                return parseTableConstructorExprRhs(tableKeyword, keySpecifier);\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.TABLE_CONSTRUCTOR_OR_QUERY_RHS,\n+                        tableKeyword, keySpecifier, isRhsExpr);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseTableConstructorOrQueryRhs(solution.tokenKind, tableKeyword, keySpecifier, isRhsExpr);\n+        }\n+    }\n+\n+    /**\n+     * Parse query construct type.\n+     * <p>\n+     * <code>query-construct-type := table key-specifier</code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseQueryConstructType(STNode tableKeyword, STNode keySpecifier) {\n+        return STNodeFactory.createQueryConstructTypeNode(tableKeyword, keySpecifier);\n+    }\n+\n+    /**\n+     * Parse query expression.\n+     * <p>\n+     * <code>\n+     * query-expr-rhs := query-pipeline select-clause\n+     * <br/>\n+     * query-pipeline := from-clause intermediate-clause*\n+     * </code>\n+     *\n+     * @param queryConstructType queryConstructType that precedes this rhs\n+     * @return Parsed node\n+     */\n+    private STNode parseQueryExprRhs(STNode queryConstructType, boolean isRhsExpr) {\n+        switchContext(ParserRuleContext.QUERY_EXPRESSION);\n+        STNode fromClause = parseFromClause(isRhsExpr);\n+\n+        List<STNode> clauses = new ArrayList<>();\n+        boolean hasReachedSelectClause = false;\n+\n+        STNode intermediateClause;\n+        STNode selectClause = null;\n+\n+        while (!isEndOfIntermediateClause(peek().kind)) {\n+            intermediateClause = parseIntermediateClause(isRhsExpr);\n+\n+            if (!hasReachedSelectClause) {\n+                if (intermediateClause.kind == SyntaxKind.SELECT_CLAUSE) {\n+                    selectClause = intermediateClause;\n+                    hasReachedSelectClause = true;\n+                } else {\n+                    clauses.add(intermediateClause);\n+                }\n+            } else {\n+                // If there are more clauses after select clause they are ignored\n+                // TODO: In future we should store ignored nodes\n+                this.errorHandler.reportMissingTokenError(\"extra clauses after select clause\");\n+            }\n+        }\n+\n+        if (!hasReachedSelectClause) {\n+            selectClause = parseSelectClause(isRhsExpr);\n+        }\n+\n+        STNode intermediateClauses = STNodeFactory.createNodeList(clauses);\n+        STNode queryPipeline = STNodeFactory.createQueryPipelineNode(fromClause, intermediateClauses);\n+        return STNodeFactory.createQueryExpressionNode(queryConstructType, queryPipeline, selectClause);\n+    }\n+\n+    /**\n+     * Parse an intermediate clause.\n+     * <p>\n+     * <code>\n+     * intermediate-clause := from-clause | where-clause | let-clause\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseIntermediateClause(boolean isRhsExpr) {\n+        return parseIntermediateClause(peek().kind, isRhsExpr);\n+    }\n+\n+    private STNode parseIntermediateClause(SyntaxKind nextTokenKind, boolean isRhsExpr) {\n+        switch (nextTokenKind) {\n+            case FROM_KEYWORD:\n+                return parseFromClause(isRhsExpr);\n+            case WHERE_KEYWORD:\n+                return parseWhereClause(isRhsExpr);\n+            case LET_KEYWORD:\n+                return parseLetClause(isRhsExpr);\n+            case SELECT_KEYWORD:\n+                return parseSelectClause(isRhsExpr);\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.QUERY_EXPRESSION_RHS, isRhsExpr);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseIntermediateClause(solution.tokenKind, isRhsExpr);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5cab218deb30646b008a3509e91d1016af69551"}, "originalPosition": 456}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTI4NjY3MQ==", "bodyText": "It seems to be a trivial change in the code. Shall I make that change?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23178#discussion_r425286671", "createdAt": "2020-05-14T16:51:47Z", "author": {"login": "lochana-chathura"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -8423,4 +8409,338 @@ private STNode parseParenthesisedTypeDesc() {\n         STNode closeParen = parseCloseParenthesis();\n         return STNodeFactory.createParenthesisedTypeDescriptorNode(openParen, typedesc, closeParen);\n     }\n+\n+    /**\n+     * Parse table constructor or query expression.\n+     * <p>\n+     * <code>\n+     * table-constructor-or-query-expr := table-constructor-expr | query-expr\n+     * <br/>\n+     * table-constructor-expr := table [key-specifier] [ [row-list] ]\n+     * <br/>\n+     * query-expr := [query-construct-type] query-pipeline select-clause\n+     * <br/>\n+     * query-construct-type := table key-specifier | stream\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+\n+    private STNode parseTableConstructorOrQuery(boolean isRhsExpr) {\n+        startContext(ParserRuleContext.TABLE_CONSTRUCTOR_OR_QUERY_EXPRESSION);\n+        STNode tableOrQueryExpr = parseTableConstructorOrQuery(peek().kind, isRhsExpr);\n+        endContext();\n+        return tableOrQueryExpr;\n+    }\n+\n+    private STNode parseTableConstructorOrQuery(SyntaxKind nextTokenKind, boolean isRhsExpr) {\n+        STNode queryConstructType;\n+        switch (nextTokenKind) {\n+            case FROM_KEYWORD:\n+                queryConstructType = STNodeFactory.createEmptyNode();\n+                return parseQueryExprRhs(queryConstructType, isRhsExpr);\n+            case STREAM_KEYWORD:\n+                queryConstructType = parseStreamKeyword();\n+                return parseQueryExprRhs(queryConstructType, isRhsExpr);\n+            case TABLE_KEYWORD:\n+                STNode tableKeyword = parseTableKeyword();\n+                return parseTableConstructorOrQuery(tableKeyword, isRhsExpr);\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.TABLE_CONSTRUCTOR_OR_QUERY_START, isRhsExpr);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseTableConstructorOrQuery(solution.tokenKind, isRhsExpr);\n+        }\n+\n+    }\n+\n+    private STNode parseTableConstructorOrQuery(STNode tableKeyword, boolean isRhsExpr) {\n+        return parseTableConstructorOrQuery(peek().kind, tableKeyword, isRhsExpr);\n+    }\n+\n+    private STNode parseTableConstructorOrQuery(SyntaxKind nextTokenKind, STNode tableKeyword, boolean isRhsExpr) {\n+        STNode keySpecifier;\n+        switch (nextTokenKind) {\n+            case OPEN_BRACKET_TOKEN:\n+                keySpecifier = STNodeFactory.createEmptyNode();\n+                return parseTableConstructorExprRhs(tableKeyword, keySpecifier);\n+            case KEY_KEYWORD:\n+                keySpecifier = parseKeySpecifier();\n+                return parseTableConstructorOrQueryRhs(tableKeyword, keySpecifier, isRhsExpr);\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.TABLE_KEYWORD_RHS, tableKeyword, isRhsExpr);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseTableConstructorOrQuery(solution.tokenKind, tableKeyword, isRhsExpr);\n+        }\n+    }\n+\n+    private STNode parseTableConstructorOrQueryRhs(STNode tableKeyword, STNode keySpecifier, boolean isRhsExpr) {\n+        return parseTableConstructorOrQueryRhs(peek().kind, tableKeyword, keySpecifier, isRhsExpr);\n+    }\n+\n+    private STNode parseTableConstructorOrQueryRhs(SyntaxKind nextTokenKind, STNode tableKeyword, STNode keySpecifier,\n+                                                   boolean isRhsExpr) {\n+        switch (nextTokenKind) {\n+            case FROM_KEYWORD:\n+                return parseQueryExprRhs(parseQueryConstructType(tableKeyword, keySpecifier), isRhsExpr);\n+            case OPEN_BRACKET_TOKEN:\n+                return parseTableConstructorExprRhs(tableKeyword, keySpecifier);\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.TABLE_CONSTRUCTOR_OR_QUERY_RHS,\n+                        tableKeyword, keySpecifier, isRhsExpr);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseTableConstructorOrQueryRhs(solution.tokenKind, tableKeyword, keySpecifier, isRhsExpr);\n+        }\n+    }\n+\n+    /**\n+     * Parse query construct type.\n+     * <p>\n+     * <code>query-construct-type := table key-specifier</code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseQueryConstructType(STNode tableKeyword, STNode keySpecifier) {\n+        return STNodeFactory.createQueryConstructTypeNode(tableKeyword, keySpecifier);\n+    }\n+\n+    /**\n+     * Parse query expression.\n+     * <p>\n+     * <code>\n+     * query-expr-rhs := query-pipeline select-clause\n+     * <br/>\n+     * query-pipeline := from-clause intermediate-clause*\n+     * </code>\n+     *\n+     * @param queryConstructType queryConstructType that precedes this rhs\n+     * @return Parsed node\n+     */\n+    private STNode parseQueryExprRhs(STNode queryConstructType, boolean isRhsExpr) {\n+        switchContext(ParserRuleContext.QUERY_EXPRESSION);\n+        STNode fromClause = parseFromClause(isRhsExpr);\n+\n+        List<STNode> clauses = new ArrayList<>();\n+        boolean hasReachedSelectClause = false;\n+\n+        STNode intermediateClause;\n+        STNode selectClause = null;\n+\n+        while (!isEndOfIntermediateClause(peek().kind)) {\n+            intermediateClause = parseIntermediateClause(isRhsExpr);\n+\n+            if (!hasReachedSelectClause) {\n+                if (intermediateClause.kind == SyntaxKind.SELECT_CLAUSE) {\n+                    selectClause = intermediateClause;\n+                    hasReachedSelectClause = true;\n+                } else {\n+                    clauses.add(intermediateClause);\n+                }\n+            } else {\n+                // If there are more clauses after select clause they are ignored\n+                // TODO: In future we should store ignored nodes\n+                this.errorHandler.reportMissingTokenError(\"extra clauses after select clause\");\n+            }\n+        }\n+\n+        if (!hasReachedSelectClause) {\n+            selectClause = parseSelectClause(isRhsExpr);\n+        }\n+\n+        STNode intermediateClauses = STNodeFactory.createNodeList(clauses);\n+        STNode queryPipeline = STNodeFactory.createQueryPipelineNode(fromClause, intermediateClauses);\n+        return STNodeFactory.createQueryExpressionNode(queryConstructType, queryPipeline, selectClause);\n+    }\n+\n+    /**\n+     * Parse an intermediate clause.\n+     * <p>\n+     * <code>\n+     * intermediate-clause := from-clause | where-clause | let-clause\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseIntermediateClause(boolean isRhsExpr) {\n+        return parseIntermediateClause(peek().kind, isRhsExpr);\n+    }\n+\n+    private STNode parseIntermediateClause(SyntaxKind nextTokenKind, boolean isRhsExpr) {\n+        switch (nextTokenKind) {\n+            case FROM_KEYWORD:\n+                return parseFromClause(isRhsExpr);\n+            case WHERE_KEYWORD:\n+                return parseWhereClause(isRhsExpr);\n+            case LET_KEYWORD:\n+                return parseLetClause(isRhsExpr);\n+            case SELECT_KEYWORD:\n+                return parseSelectClause(isRhsExpr);\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.QUERY_EXPRESSION_RHS, isRhsExpr);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseIntermediateClause(solution.tokenKind, isRhsExpr);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTI0NzkzMA=="}, "originalCommit": {"oid": "f5cab218deb30646b008a3509e91d1016af69551"}, "originalPosition": 456}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0ODEyOTQ0OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxNjowMDo1NFrOGVjQ_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQwMTo1NTowM1rOGVz4rw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTI1MTA3MA==", "bodyText": "Do we need to add EXPRESSION_RHS as an option here?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23178#discussion_r425251070", "createdAt": "2020-05-14T16:00:54Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -333,6 +333,15 @@\n     private static final ParserRuleContext[] NEW_KEYWORD_RHS =\n             { ParserRuleContext.TYPE_DESC_IN_NEW_EXPR, ParserRuleContext.EXPRESSION_RHS };\n \n+    private static final ParserRuleContext[] TABLE_CONSTRUCTOR_OR_QUERY_START =\n+            { ParserRuleContext.TABLE_KEYWORD, ParserRuleContext.STREAM_KEYWORD, ParserRuleContext.QUERY_EXPRESSION };\n+\n+    private static final ParserRuleContext[] TABLE_CONSTRUCTOR_OR_QUERY_RHS =\n+            { ParserRuleContext.TABLE_CONSTRUCTOR, ParserRuleContext.QUERY_EXPRESSION };\n+\n+    private static final ParserRuleContext[] QUERY_EXPRESSION_RHS =\n+            { ParserRuleContext.SELECT_CLAUSE, ParserRuleContext.WHERE_CLAUSE, ParserRuleContext.FROM_CLAUSE,\n+                    ParserRuleContext.LET_CLAUSE };", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5cab218deb30646b008a3509e91d1016af69551"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTI4NjM3OQ==", "bodyText": "Do we? Then it will end up in an infinite loop right? QUERY_EXPRESSION_RHS is called as a next rule inside seekMatchInExpressionRhs and then QUERY_EXPRESSION_RHS again call seekMatchInExpressionRhs and go on?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23178#discussion_r425286379", "createdAt": "2020-05-14T16:51:16Z", "author": {"login": "lochana-chathura"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -333,6 +333,15 @@\n     private static final ParserRuleContext[] NEW_KEYWORD_RHS =\n             { ParserRuleContext.TYPE_DESC_IN_NEW_EXPR, ParserRuleContext.EXPRESSION_RHS };\n \n+    private static final ParserRuleContext[] TABLE_CONSTRUCTOR_OR_QUERY_START =\n+            { ParserRuleContext.TABLE_KEYWORD, ParserRuleContext.STREAM_KEYWORD, ParserRuleContext.QUERY_EXPRESSION };\n+\n+    private static final ParserRuleContext[] TABLE_CONSTRUCTOR_OR_QUERY_RHS =\n+            { ParserRuleContext.TABLE_CONSTRUCTOR, ParserRuleContext.QUERY_EXPRESSION };\n+\n+    private static final ParserRuleContext[] QUERY_EXPRESSION_RHS =\n+            { ParserRuleContext.SELECT_CLAUSE, ParserRuleContext.WHERE_CLAUSE, ParserRuleContext.FROM_CLAUSE,\n+                    ParserRuleContext.LET_CLAUSE };", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTI1MTA3MA=="}, "originalCommit": {"oid": "f5cab218deb30646b008a3509e91d1016af69551"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTUxNjg1Ng==", "bodyText": "I see. How does it match something like a semicolon at the end of the expr?\ne.g.:  ... where a > b ;", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23178#discussion_r425516856", "createdAt": "2020-05-15T01:29:09Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -333,6 +333,15 @@\n     private static final ParserRuleContext[] NEW_KEYWORD_RHS =\n             { ParserRuleContext.TYPE_DESC_IN_NEW_EXPR, ParserRuleContext.EXPRESSION_RHS };\n \n+    private static final ParserRuleContext[] TABLE_CONSTRUCTOR_OR_QUERY_START =\n+            { ParserRuleContext.TABLE_KEYWORD, ParserRuleContext.STREAM_KEYWORD, ParserRuleContext.QUERY_EXPRESSION };\n+\n+    private static final ParserRuleContext[] TABLE_CONSTRUCTOR_OR_QUERY_RHS =\n+            { ParserRuleContext.TABLE_CONSTRUCTOR, ParserRuleContext.QUERY_EXPRESSION };\n+\n+    private static final ParserRuleContext[] QUERY_EXPRESSION_RHS =\n+            { ParserRuleContext.SELECT_CLAUSE, ParserRuleContext.WHERE_CLAUSE, ParserRuleContext.FROM_CLAUSE,\n+                    ParserRuleContext.LET_CLAUSE };", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTI1MTA3MA=="}, "originalCommit": {"oid": "f5cab218deb30646b008a3509e91d1016af69551"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTUyMzM3NQ==", "bodyText": "May be we could add something like END_OF_QUERY, then end the query-expr context inside it, and then go ahead for EXPRESSION_RHS?\nbtw, I am merging the PR anyway, since the rest of the changes looks fine.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23178#discussion_r425523375", "createdAt": "2020-05-15T01:55:03Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -333,6 +333,15 @@\n     private static final ParserRuleContext[] NEW_KEYWORD_RHS =\n             { ParserRuleContext.TYPE_DESC_IN_NEW_EXPR, ParserRuleContext.EXPRESSION_RHS };\n \n+    private static final ParserRuleContext[] TABLE_CONSTRUCTOR_OR_QUERY_START =\n+            { ParserRuleContext.TABLE_KEYWORD, ParserRuleContext.STREAM_KEYWORD, ParserRuleContext.QUERY_EXPRESSION };\n+\n+    private static final ParserRuleContext[] TABLE_CONSTRUCTOR_OR_QUERY_RHS =\n+            { ParserRuleContext.TABLE_CONSTRUCTOR, ParserRuleContext.QUERY_EXPRESSION };\n+\n+    private static final ParserRuleContext[] QUERY_EXPRESSION_RHS =\n+            { ParserRuleContext.SELECT_CLAUSE, ParserRuleContext.WHERE_CLAUSE, ParserRuleContext.FROM_CLAUSE,\n+                    ParserRuleContext.LET_CLAUSE };", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTI1MTA3MA=="}, "originalCommit": {"oid": "f5cab218deb30646b008a3509e91d1016af69551"}, "originalPosition": 34}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3748, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}