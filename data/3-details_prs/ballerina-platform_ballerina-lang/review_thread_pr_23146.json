{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE0NjI0MTMx", "number": 23146, "reviewThreads": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QxMzoxMDozMFrOD6PajQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxMjozNDowMVrOD7oO2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMzk2NTU3OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QxMzoxMDozMFrOGR9wSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxMTo1MTo1OFrOGUC6Fg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQ5MDc2Mg==", "bodyText": "if none of the above, should it be treated as simply new?\ni.e.: foo(new);,  where function foo(T x) {...}", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146#discussion_r421490762", "createdAt": "2020-05-07T13:10:30Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -3172,6 +3180,127 @@ private STNode parseActionOrExpressionInLhs(SyntaxKind nextTokenKind, STNode lhs\n         return parseExpressionRhs(nextTokenKind, DEFAULT_OP_PRECEDENCE, lhsExpr, false, true);\n     }\n \n+    /**\n+     * <p>\n+     * Parse a new expression.\n+     * </p>\n+     * <code>\n+     *  new-expr := explicit-new-expr | implicit-new-expr\n+     *  explicit-new-expr := new type-descriptor ( arg-list )\n+     *  implicit-new-expr := new [( arg-list )]\n+     * </code>\n+     *\n+     * @return Parsed NewExpression node.\n+     */\n+    private STNode parseNewExpression() {\n+        startContext(ParserRuleContext.NEW_EXPRESSION);\n+        STNode newKeyword = parseNewKeyword();\n+        STNode newExpression = parseNewExpression(newKeyword);\n+        endContext();\n+        return newExpression;\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse `new` keyword.\n+     * </p>\n+     *\n+     * @return Parsed NEW_KEYWORD Token.\n+     */\n+    private STNode parseNewKeyword() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.NEW_KEYWORD) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(token, ParserRuleContext.NEW_KEYWORD);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    private STNode parseNewExpression(STNode newKeyword) {\n+        STNode token = peek();\n+        return parseNewExpression(token.kind, newKeyword);\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse an implicit or explicit expression.\n+     * </p>\n+     * @param kind next token kind.\n+     * @param newKeyword parsed node for `new` keyword.\n+     * @return Parsed new-expression node.\n+     */\n+    private STNode parseNewExpression(SyntaxKind kind, STNode newKeyword) {\n+        switch (kind) {\n+            case OPEN_PAREN_TOKEN:\n+                return parseImplicitNewExpression(newKeyword);\n+            case SEMICOLON_TOKEN:\n+                return STNodeFactory.createImplicitNewExpression(newKeyword, STNodeFactory.createEmptyNode());\n+            case IDENTIFIER_TOKEN:\n+            case OBJECT_KEYWORD:\n+                // TODO: Support `stream` keyword once introduced\n+                return parseExplicitNewExpression(newKeyword);\n+            default:\n+                Solution sol = recover(peek(), ParserRuleContext.NEW_EXPRESSION, newKeyword);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ae4c6e850b7ecb589b3f16e8966ac7109266ee3"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTUwOTE0OQ==", "bodyText": "btw, IMO this context not NEW_EXPRESSION, its more like NEW_KEYWORD_RHS", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146#discussion_r421509149", "createdAt": "2020-05-07T13:36:50Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -3172,6 +3180,127 @@ private STNode parseActionOrExpressionInLhs(SyntaxKind nextTokenKind, STNode lhs\n         return parseExpressionRhs(nextTokenKind, DEFAULT_OP_PRECEDENCE, lhsExpr, false, true);\n     }\n \n+    /**\n+     * <p>\n+     * Parse a new expression.\n+     * </p>\n+     * <code>\n+     *  new-expr := explicit-new-expr | implicit-new-expr\n+     *  explicit-new-expr := new type-descriptor ( arg-list )\n+     *  implicit-new-expr := new [( arg-list )]\n+     * </code>\n+     *\n+     * @return Parsed NewExpression node.\n+     */\n+    private STNode parseNewExpression() {\n+        startContext(ParserRuleContext.NEW_EXPRESSION);\n+        STNode newKeyword = parseNewKeyword();\n+        STNode newExpression = parseNewExpression(newKeyword);\n+        endContext();\n+        return newExpression;\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse `new` keyword.\n+     * </p>\n+     *\n+     * @return Parsed NEW_KEYWORD Token.\n+     */\n+    private STNode parseNewKeyword() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.NEW_KEYWORD) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(token, ParserRuleContext.NEW_KEYWORD);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    private STNode parseNewExpression(STNode newKeyword) {\n+        STNode token = peek();\n+        return parseNewExpression(token.kind, newKeyword);\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse an implicit or explicit expression.\n+     * </p>\n+     * @param kind next token kind.\n+     * @param newKeyword parsed node for `new` keyword.\n+     * @return Parsed new-expression node.\n+     */\n+    private STNode parseNewExpression(SyntaxKind kind, STNode newKeyword) {\n+        switch (kind) {\n+            case OPEN_PAREN_TOKEN:\n+                return parseImplicitNewExpression(newKeyword);\n+            case SEMICOLON_TOKEN:\n+                return STNodeFactory.createImplicitNewExpression(newKeyword, STNodeFactory.createEmptyNode());\n+            case IDENTIFIER_TOKEN:\n+            case OBJECT_KEYWORD:\n+                // TODO: Support `stream` keyword once introduced\n+                return parseExplicitNewExpression(newKeyword);\n+            default:\n+                Solution sol = recover(peek(), ParserRuleContext.NEW_EXPRESSION, newKeyword);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQ5MDc2Mg=="}, "originalCommit": {"oid": "8ae4c6e850b7ecb589b3f16e8966ac7109266ee3"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjUxOTE3OA==", "bodyText": "fixed with 07c06fd for comment 2. Need to analyse how to handle comment one :)", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146#discussion_r422519178", "createdAt": "2020-05-09T16:51:38Z", "author": {"login": "dulvinw"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -3172,6 +3180,127 @@ private STNode parseActionOrExpressionInLhs(SyntaxKind nextTokenKind, STNode lhs\n         return parseExpressionRhs(nextTokenKind, DEFAULT_OP_PRECEDENCE, lhsExpr, false, true);\n     }\n \n+    /**\n+     * <p>\n+     * Parse a new expression.\n+     * </p>\n+     * <code>\n+     *  new-expr := explicit-new-expr | implicit-new-expr\n+     *  explicit-new-expr := new type-descriptor ( arg-list )\n+     *  implicit-new-expr := new [( arg-list )]\n+     * </code>\n+     *\n+     * @return Parsed NewExpression node.\n+     */\n+    private STNode parseNewExpression() {\n+        startContext(ParserRuleContext.NEW_EXPRESSION);\n+        STNode newKeyword = parseNewKeyword();\n+        STNode newExpression = parseNewExpression(newKeyword);\n+        endContext();\n+        return newExpression;\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse `new` keyword.\n+     * </p>\n+     *\n+     * @return Parsed NEW_KEYWORD Token.\n+     */\n+    private STNode parseNewKeyword() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.NEW_KEYWORD) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(token, ParserRuleContext.NEW_KEYWORD);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    private STNode parseNewExpression(STNode newKeyword) {\n+        STNode token = peek();\n+        return parseNewExpression(token.kind, newKeyword);\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse an implicit or explicit expression.\n+     * </p>\n+     * @param kind next token kind.\n+     * @param newKeyword parsed node for `new` keyword.\n+     * @return Parsed new-expression node.\n+     */\n+    private STNode parseNewExpression(SyntaxKind kind, STNode newKeyword) {\n+        switch (kind) {\n+            case OPEN_PAREN_TOKEN:\n+                return parseImplicitNewExpression(newKeyword);\n+            case SEMICOLON_TOKEN:\n+                return STNodeFactory.createImplicitNewExpression(newKeyword, STNodeFactory.createEmptyNode());\n+            case IDENTIFIER_TOKEN:\n+            case OBJECT_KEYWORD:\n+                // TODO: Support `stream` keyword once introduced\n+                return parseExplicitNewExpression(newKeyword);\n+            default:\n+                Solution sol = recover(peek(), ParserRuleContext.NEW_EXPRESSION, newKeyword);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQ5MDc2Mg=="}, "originalCommit": {"oid": "8ae4c6e850b7ecb589b3f16e8966ac7109266ee3"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY3MjM0Mg==", "bodyText": "Resolved the comment 1 scenario as well", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146#discussion_r423672342", "createdAt": "2020-05-12T11:51:58Z", "author": {"login": "dulvinw"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -3172,6 +3180,127 @@ private STNode parseActionOrExpressionInLhs(SyntaxKind nextTokenKind, STNode lhs\n         return parseExpressionRhs(nextTokenKind, DEFAULT_OP_PRECEDENCE, lhsExpr, false, true);\n     }\n \n+    /**\n+     * <p>\n+     * Parse a new expression.\n+     * </p>\n+     * <code>\n+     *  new-expr := explicit-new-expr | implicit-new-expr\n+     *  explicit-new-expr := new type-descriptor ( arg-list )\n+     *  implicit-new-expr := new [( arg-list )]\n+     * </code>\n+     *\n+     * @return Parsed NewExpression node.\n+     */\n+    private STNode parseNewExpression() {\n+        startContext(ParserRuleContext.NEW_EXPRESSION);\n+        STNode newKeyword = parseNewKeyword();\n+        STNode newExpression = parseNewExpression(newKeyword);\n+        endContext();\n+        return newExpression;\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse `new` keyword.\n+     * </p>\n+     *\n+     * @return Parsed NEW_KEYWORD Token.\n+     */\n+    private STNode parseNewKeyword() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.NEW_KEYWORD) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(token, ParserRuleContext.NEW_KEYWORD);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    private STNode parseNewExpression(STNode newKeyword) {\n+        STNode token = peek();\n+        return parseNewExpression(token.kind, newKeyword);\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse an implicit or explicit expression.\n+     * </p>\n+     * @param kind next token kind.\n+     * @param newKeyword parsed node for `new` keyword.\n+     * @return Parsed new-expression node.\n+     */\n+    private STNode parseNewExpression(SyntaxKind kind, STNode newKeyword) {\n+        switch (kind) {\n+            case OPEN_PAREN_TOKEN:\n+                return parseImplicitNewExpression(newKeyword);\n+            case SEMICOLON_TOKEN:\n+                return STNodeFactory.createImplicitNewExpression(newKeyword, STNodeFactory.createEmptyNode());\n+            case IDENTIFIER_TOKEN:\n+            case OBJECT_KEYWORD:\n+                // TODO: Support `stream` keyword once introduced\n+                return parseExplicitNewExpression(newKeyword);\n+            default:\n+                Solution sol = recover(peek(), ParserRuleContext.NEW_EXPRESSION, newKeyword);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQ5MDc2Mg=="}, "originalCommit": {"oid": "8ae4c6e850b7ecb589b3f16e8966ac7109266ee3"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMzk4MDg2OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QxMzoxNDoxM1rOGR95ow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQxNjoyODoyNFrOGS8X9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQ5MzE1NQ==", "bodyText": "Need to validate whether this is a object-type-desc or a type-reference", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146#discussion_r421493155", "createdAt": "2020-05-07T13:14:13Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -3172,6 +3180,127 @@ private STNode parseActionOrExpressionInLhs(SyntaxKind nextTokenKind, STNode lhs\n         return parseExpressionRhs(nextTokenKind, DEFAULT_OP_PRECEDENCE, lhsExpr, false, true);\n     }\n \n+    /**\n+     * <p>\n+     * Parse a new expression.\n+     * </p>\n+     * <code>\n+     *  new-expr := explicit-new-expr | implicit-new-expr\n+     *  explicit-new-expr := new type-descriptor ( arg-list )\n+     *  implicit-new-expr := new [( arg-list )]\n+     * </code>\n+     *\n+     * @return Parsed NewExpression node.\n+     */\n+    private STNode parseNewExpression() {\n+        startContext(ParserRuleContext.NEW_EXPRESSION);\n+        STNode newKeyword = parseNewKeyword();\n+        STNode newExpression = parseNewExpression(newKeyword);\n+        endContext();\n+        return newExpression;\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse `new` keyword.\n+     * </p>\n+     *\n+     * @return Parsed NEW_KEYWORD Token.\n+     */\n+    private STNode parseNewKeyword() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.NEW_KEYWORD) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(token, ParserRuleContext.NEW_KEYWORD);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    private STNode parseNewExpression(STNode newKeyword) {\n+        STNode token = peek();\n+        return parseNewExpression(token.kind, newKeyword);\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse an implicit or explicit expression.\n+     * </p>\n+     * @param kind next token kind.\n+     * @param newKeyword parsed node for `new` keyword.\n+     * @return Parsed new-expression node.\n+     */\n+    private STNode parseNewExpression(SyntaxKind kind, STNode newKeyword) {\n+        switch (kind) {\n+            case OPEN_PAREN_TOKEN:\n+                return parseImplicitNewExpression(newKeyword);\n+            case SEMICOLON_TOKEN:\n+                return STNodeFactory.createImplicitNewExpression(newKeyword, STNodeFactory.createEmptyNode());\n+            case IDENTIFIER_TOKEN:\n+            case OBJECT_KEYWORD:\n+                // TODO: Support `stream` keyword once introduced\n+                return parseExplicitNewExpression(newKeyword);\n+            default:\n+                Solution sol = recover(peek(), ParserRuleContext.NEW_EXPRESSION, newKeyword);\n+                return parseNewExpression(sol.recoveredNode.kind, newKeyword);\n+        }\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse an Explicit New expression.\n+     * </p>\n+     * <code>\n+     *  explicit-new-expr := new type-descriptor ( arg-list )\n+     * </code>\n+     *\n+     * @param newKeyword Parsed `new` keyword.\n+     * @return the Parsed Explicit New Expression.\n+     */\n+    private STNode parseExplicitNewExpression(STNode newKeyword) {\n+        startContext(ParserRuleContext.EXPLICIT_NEW_RHS);\n+        STNode typeDescriptor = parseTypeDescriptor();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ae4c6e850b7ecb589b3f16e8966ac7109266ee3"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjUxNjcyNw==", "bodyText": "Since I come to this stage with only OBJECT_KEYWORD i didn't think i need to do that. But since the discussion we had to enable all the types and then validate, to give a meaningful error, I think i have to change the logic here", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146#discussion_r422516727", "createdAt": "2020-05-09T16:28:24Z", "author": {"login": "dulvinw"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -3172,6 +3180,127 @@ private STNode parseActionOrExpressionInLhs(SyntaxKind nextTokenKind, STNode lhs\n         return parseExpressionRhs(nextTokenKind, DEFAULT_OP_PRECEDENCE, lhsExpr, false, true);\n     }\n \n+    /**\n+     * <p>\n+     * Parse a new expression.\n+     * </p>\n+     * <code>\n+     *  new-expr := explicit-new-expr | implicit-new-expr\n+     *  explicit-new-expr := new type-descriptor ( arg-list )\n+     *  implicit-new-expr := new [( arg-list )]\n+     * </code>\n+     *\n+     * @return Parsed NewExpression node.\n+     */\n+    private STNode parseNewExpression() {\n+        startContext(ParserRuleContext.NEW_EXPRESSION);\n+        STNode newKeyword = parseNewKeyword();\n+        STNode newExpression = parseNewExpression(newKeyword);\n+        endContext();\n+        return newExpression;\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse `new` keyword.\n+     * </p>\n+     *\n+     * @return Parsed NEW_KEYWORD Token.\n+     */\n+    private STNode parseNewKeyword() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.NEW_KEYWORD) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(token, ParserRuleContext.NEW_KEYWORD);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    private STNode parseNewExpression(STNode newKeyword) {\n+        STNode token = peek();\n+        return parseNewExpression(token.kind, newKeyword);\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse an implicit or explicit expression.\n+     * </p>\n+     * @param kind next token kind.\n+     * @param newKeyword parsed node for `new` keyword.\n+     * @return Parsed new-expression node.\n+     */\n+    private STNode parseNewExpression(SyntaxKind kind, STNode newKeyword) {\n+        switch (kind) {\n+            case OPEN_PAREN_TOKEN:\n+                return parseImplicitNewExpression(newKeyword);\n+            case SEMICOLON_TOKEN:\n+                return STNodeFactory.createImplicitNewExpression(newKeyword, STNodeFactory.createEmptyNode());\n+            case IDENTIFIER_TOKEN:\n+            case OBJECT_KEYWORD:\n+                // TODO: Support `stream` keyword once introduced\n+                return parseExplicitNewExpression(newKeyword);\n+            default:\n+                Solution sol = recover(peek(), ParserRuleContext.NEW_EXPRESSION, newKeyword);\n+                return parseNewExpression(sol.recoveredNode.kind, newKeyword);\n+        }\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse an Explicit New expression.\n+     * </p>\n+     * <code>\n+     *  explicit-new-expr := new type-descriptor ( arg-list )\n+     * </code>\n+     *\n+     * @param newKeyword Parsed `new` keyword.\n+     * @return the Parsed Explicit New Expression.\n+     */\n+    private STNode parseExplicitNewExpression(STNode newKeyword) {\n+        startContext(ParserRuleContext.EXPLICIT_NEW_RHS);\n+        STNode typeDescriptor = parseTypeDescriptor();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQ5MzE1NQ=="}, "originalCommit": {"oid": "8ae4c6e850b7ecb589b3f16e8966ac7109266ee3"}, "originalPosition": 114}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMzk5NzYyOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QxMzoxODowN1rOGR-EIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQxNjo1MToyNlrOGS8hgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQ5NTg0MQ==", "bodyText": "unused method?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146#discussion_r421495841", "createdAt": "2020-05-07T13:18:07Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -3172,6 +3180,127 @@ private STNode parseActionOrExpressionInLhs(SyntaxKind nextTokenKind, STNode lhs\n         return parseExpressionRhs(nextTokenKind, DEFAULT_OP_PRECEDENCE, lhsExpr, false, true);\n     }\n \n+    /**\n+     * <p>\n+     * Parse a new expression.\n+     * </p>\n+     * <code>\n+     *  new-expr := explicit-new-expr | implicit-new-expr\n+     *  explicit-new-expr := new type-descriptor ( arg-list )\n+     *  implicit-new-expr := new [( arg-list )]\n+     * </code>\n+     *\n+     * @return Parsed NewExpression node.\n+     */\n+    private STNode parseNewExpression() {\n+        startContext(ParserRuleContext.NEW_EXPRESSION);\n+        STNode newKeyword = parseNewKeyword();\n+        STNode newExpression = parseNewExpression(newKeyword);\n+        endContext();\n+        return newExpression;\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse `new` keyword.\n+     * </p>\n+     *\n+     * @return Parsed NEW_KEYWORD Token.\n+     */\n+    private STNode parseNewKeyword() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.NEW_KEYWORD) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(token, ParserRuleContext.NEW_KEYWORD);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    private STNode parseNewExpression(STNode newKeyword) {\n+        STNode token = peek();\n+        return parseNewExpression(token.kind, newKeyword);\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse an implicit or explicit expression.\n+     * </p>\n+     * @param kind next token kind.\n+     * @param newKeyword parsed node for `new` keyword.\n+     * @return Parsed new-expression node.\n+     */\n+    private STNode parseNewExpression(SyntaxKind kind, STNode newKeyword) {\n+        switch (kind) {\n+            case OPEN_PAREN_TOKEN:\n+                return parseImplicitNewExpression(newKeyword);\n+            case SEMICOLON_TOKEN:\n+                return STNodeFactory.createImplicitNewExpression(newKeyword, STNodeFactory.createEmptyNode());\n+            case IDENTIFIER_TOKEN:\n+            case OBJECT_KEYWORD:\n+                // TODO: Support `stream` keyword once introduced\n+                return parseExplicitNewExpression(newKeyword);\n+            default:\n+                Solution sol = recover(peek(), ParserRuleContext.NEW_EXPRESSION, newKeyword);\n+                return parseNewExpression(sol.recoveredNode.kind, newKeyword);\n+        }\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse an Explicit New expression.\n+     * </p>\n+     * <code>\n+     *  explicit-new-expr := new type-descriptor ( arg-list )\n+     * </code>\n+     *\n+     * @param newKeyword Parsed `new` keyword.\n+     * @return the Parsed Explicit New Expression.\n+     */\n+    private STNode parseExplicitNewExpression(STNode newKeyword) {\n+        startContext(ParserRuleContext.EXPLICIT_NEW_RHS);\n+        STNode typeDescriptor = parseTypeDescriptor();\n+        STNode parenthesizedArgsList = parseParenthesizedArgList();\n+        endContext();\n+\n+        return STNodeFactory.createExplicitNewExpression(newKeyword, typeDescriptor, parenthesizedArgsList);\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse an <code>implicit-new-expr</code> with arguments.\n+     * </p>\n+     *\n+     * @param newKeyword Parsed `new` keyword.\n+     * @return Parsed implicit-new-expr.\n+     */\n+    private STNode parseImplicitNewExpression(STNode newKeyword) {\n+        STNode implicitNewArgList = parseParenthesizedArgList();\n+\n+        return STNodeFactory.createImplicitNewExpression(newKeyword, implicitNewArgList);\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse the parenthesized argument list for a <code>new-expr</code>.\n+     * </p>\n+     *\n+     * @return Parsed parenthesized rhs of <code>new-expr</code>.\n+     */\n+    private STNode parseParenthesizedArgList() {\n+        startContext(ParserRuleContext.NEW_RHS);\n+        STNode openParan = parseOpenParenthesis();\n+        STNode arguments = parseArgsList();\n+        STNode closeParan = parseCloseParenthesis();\n+        endContext();\n+\n+        return STNodeFactory.createParenthesizedArgList(openParan, arguments, closeParan);\n+    }\n+\n+    private STNode parseActionOrExpressionInLhs(STNode lhsExpr) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ae4c6e850b7ecb589b3f16e8966ac7109266ee3"}, "originalPosition": 152}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjUxNjk3OQ==", "bodyText": "Yes I have checked in by mistake. I'll remove :)", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146#discussion_r422516979", "createdAt": "2020-05-09T16:30:40Z", "author": {"login": "dulvinw"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -3172,6 +3180,127 @@ private STNode parseActionOrExpressionInLhs(SyntaxKind nextTokenKind, STNode lhs\n         return parseExpressionRhs(nextTokenKind, DEFAULT_OP_PRECEDENCE, lhsExpr, false, true);\n     }\n \n+    /**\n+     * <p>\n+     * Parse a new expression.\n+     * </p>\n+     * <code>\n+     *  new-expr := explicit-new-expr | implicit-new-expr\n+     *  explicit-new-expr := new type-descriptor ( arg-list )\n+     *  implicit-new-expr := new [( arg-list )]\n+     * </code>\n+     *\n+     * @return Parsed NewExpression node.\n+     */\n+    private STNode parseNewExpression() {\n+        startContext(ParserRuleContext.NEW_EXPRESSION);\n+        STNode newKeyword = parseNewKeyword();\n+        STNode newExpression = parseNewExpression(newKeyword);\n+        endContext();\n+        return newExpression;\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse `new` keyword.\n+     * </p>\n+     *\n+     * @return Parsed NEW_KEYWORD Token.\n+     */\n+    private STNode parseNewKeyword() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.NEW_KEYWORD) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(token, ParserRuleContext.NEW_KEYWORD);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    private STNode parseNewExpression(STNode newKeyword) {\n+        STNode token = peek();\n+        return parseNewExpression(token.kind, newKeyword);\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse an implicit or explicit expression.\n+     * </p>\n+     * @param kind next token kind.\n+     * @param newKeyword parsed node for `new` keyword.\n+     * @return Parsed new-expression node.\n+     */\n+    private STNode parseNewExpression(SyntaxKind kind, STNode newKeyword) {\n+        switch (kind) {\n+            case OPEN_PAREN_TOKEN:\n+                return parseImplicitNewExpression(newKeyword);\n+            case SEMICOLON_TOKEN:\n+                return STNodeFactory.createImplicitNewExpression(newKeyword, STNodeFactory.createEmptyNode());\n+            case IDENTIFIER_TOKEN:\n+            case OBJECT_KEYWORD:\n+                // TODO: Support `stream` keyword once introduced\n+                return parseExplicitNewExpression(newKeyword);\n+            default:\n+                Solution sol = recover(peek(), ParserRuleContext.NEW_EXPRESSION, newKeyword);\n+                return parseNewExpression(sol.recoveredNode.kind, newKeyword);\n+        }\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse an Explicit New expression.\n+     * </p>\n+     * <code>\n+     *  explicit-new-expr := new type-descriptor ( arg-list )\n+     * </code>\n+     *\n+     * @param newKeyword Parsed `new` keyword.\n+     * @return the Parsed Explicit New Expression.\n+     */\n+    private STNode parseExplicitNewExpression(STNode newKeyword) {\n+        startContext(ParserRuleContext.EXPLICIT_NEW_RHS);\n+        STNode typeDescriptor = parseTypeDescriptor();\n+        STNode parenthesizedArgsList = parseParenthesizedArgList();\n+        endContext();\n+\n+        return STNodeFactory.createExplicitNewExpression(newKeyword, typeDescriptor, parenthesizedArgsList);\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse an <code>implicit-new-expr</code> with arguments.\n+     * </p>\n+     *\n+     * @param newKeyword Parsed `new` keyword.\n+     * @return Parsed implicit-new-expr.\n+     */\n+    private STNode parseImplicitNewExpression(STNode newKeyword) {\n+        STNode implicitNewArgList = parseParenthesizedArgList();\n+\n+        return STNodeFactory.createImplicitNewExpression(newKeyword, implicitNewArgList);\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse the parenthesized argument list for a <code>new-expr</code>.\n+     * </p>\n+     *\n+     * @return Parsed parenthesized rhs of <code>new-expr</code>.\n+     */\n+    private STNode parseParenthesizedArgList() {\n+        startContext(ParserRuleContext.NEW_RHS);\n+        STNode openParan = parseOpenParenthesis();\n+        STNode arguments = parseArgsList();\n+        STNode closeParan = parseCloseParenthesis();\n+        endContext();\n+\n+        return STNodeFactory.createParenthesizedArgList(openParan, arguments, closeParan);\n+    }\n+\n+    private STNode parseActionOrExpressionInLhs(STNode lhsExpr) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQ5NTg0MQ=="}, "originalCommit": {"oid": "8ae4c6e850b7ecb589b3f16e8966ac7109266ee3"}, "originalPosition": 152}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjUxOTE2OA==", "bodyText": "fixed with 07c06fd", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146#discussion_r422519168", "createdAt": "2020-05-09T16:51:26Z", "author": {"login": "dulvinw"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -3172,6 +3180,127 @@ private STNode parseActionOrExpressionInLhs(SyntaxKind nextTokenKind, STNode lhs\n         return parseExpressionRhs(nextTokenKind, DEFAULT_OP_PRECEDENCE, lhsExpr, false, true);\n     }\n \n+    /**\n+     * <p>\n+     * Parse a new expression.\n+     * </p>\n+     * <code>\n+     *  new-expr := explicit-new-expr | implicit-new-expr\n+     *  explicit-new-expr := new type-descriptor ( arg-list )\n+     *  implicit-new-expr := new [( arg-list )]\n+     * </code>\n+     *\n+     * @return Parsed NewExpression node.\n+     */\n+    private STNode parseNewExpression() {\n+        startContext(ParserRuleContext.NEW_EXPRESSION);\n+        STNode newKeyword = parseNewKeyword();\n+        STNode newExpression = parseNewExpression(newKeyword);\n+        endContext();\n+        return newExpression;\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse `new` keyword.\n+     * </p>\n+     *\n+     * @return Parsed NEW_KEYWORD Token.\n+     */\n+    private STNode parseNewKeyword() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.NEW_KEYWORD) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(token, ParserRuleContext.NEW_KEYWORD);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    private STNode parseNewExpression(STNode newKeyword) {\n+        STNode token = peek();\n+        return parseNewExpression(token.kind, newKeyword);\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse an implicit or explicit expression.\n+     * </p>\n+     * @param kind next token kind.\n+     * @param newKeyword parsed node for `new` keyword.\n+     * @return Parsed new-expression node.\n+     */\n+    private STNode parseNewExpression(SyntaxKind kind, STNode newKeyword) {\n+        switch (kind) {\n+            case OPEN_PAREN_TOKEN:\n+                return parseImplicitNewExpression(newKeyword);\n+            case SEMICOLON_TOKEN:\n+                return STNodeFactory.createImplicitNewExpression(newKeyword, STNodeFactory.createEmptyNode());\n+            case IDENTIFIER_TOKEN:\n+            case OBJECT_KEYWORD:\n+                // TODO: Support `stream` keyword once introduced\n+                return parseExplicitNewExpression(newKeyword);\n+            default:\n+                Solution sol = recover(peek(), ParserRuleContext.NEW_EXPRESSION, newKeyword);\n+                return parseNewExpression(sol.recoveredNode.kind, newKeyword);\n+        }\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse an Explicit New expression.\n+     * </p>\n+     * <code>\n+     *  explicit-new-expr := new type-descriptor ( arg-list )\n+     * </code>\n+     *\n+     * @param newKeyword Parsed `new` keyword.\n+     * @return the Parsed Explicit New Expression.\n+     */\n+    private STNode parseExplicitNewExpression(STNode newKeyword) {\n+        startContext(ParserRuleContext.EXPLICIT_NEW_RHS);\n+        STNode typeDescriptor = parseTypeDescriptor();\n+        STNode parenthesizedArgsList = parseParenthesizedArgList();\n+        endContext();\n+\n+        return STNodeFactory.createExplicitNewExpression(newKeyword, typeDescriptor, parenthesizedArgsList);\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse an <code>implicit-new-expr</code> with arguments.\n+     * </p>\n+     *\n+     * @param newKeyword Parsed `new` keyword.\n+     * @return Parsed implicit-new-expr.\n+     */\n+    private STNode parseImplicitNewExpression(STNode newKeyword) {\n+        STNode implicitNewArgList = parseParenthesizedArgList();\n+\n+        return STNodeFactory.createImplicitNewExpression(newKeyword, implicitNewArgList);\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse the parenthesized argument list for a <code>new-expr</code>.\n+     * </p>\n+     *\n+     * @return Parsed parenthesized rhs of <code>new-expr</code>.\n+     */\n+    private STNode parseParenthesizedArgList() {\n+        startContext(ParserRuleContext.NEW_RHS);\n+        STNode openParan = parseOpenParenthesis();\n+        STNode arguments = parseArgsList();\n+        STNode closeParan = parseCloseParenthesis();\n+        endContext();\n+\n+        return STNodeFactory.createParenthesizedArgList(openParan, arguments, closeParan);\n+    }\n+\n+    private STNode parseActionOrExpressionInLhs(STNode lhsExpr) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQ5NTg0MQ=="}, "originalCommit": {"oid": "8ae4c6e850b7ecb589b3f16e8966ac7109266ee3"}, "originalPosition": 152}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMzk5ODQ1OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QxMzoxODoyMVrOGR-Eug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQxNjo1MToxOVrOGS8hbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQ5NTk5NA==", "bodyText": "extra newline", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146#discussion_r421495994", "createdAt": "2020-05-07T13:18:21Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -3172,6 +3180,127 @@ private STNode parseActionOrExpressionInLhs(SyntaxKind nextTokenKind, STNode lhs\n         return parseExpressionRhs(nextTokenKind, DEFAULT_OP_PRECEDENCE, lhsExpr, false, true);\n     }\n \n+    /**\n+     * <p>\n+     * Parse a new expression.\n+     * </p>\n+     * <code>\n+     *  new-expr := explicit-new-expr | implicit-new-expr\n+     *  explicit-new-expr := new type-descriptor ( arg-list )\n+     *  implicit-new-expr := new [( arg-list )]\n+     * </code>\n+     *\n+     * @return Parsed NewExpression node.\n+     */\n+    private STNode parseNewExpression() {\n+        startContext(ParserRuleContext.NEW_EXPRESSION);\n+        STNode newKeyword = parseNewKeyword();\n+        STNode newExpression = parseNewExpression(newKeyword);\n+        endContext();\n+        return newExpression;\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse `new` keyword.\n+     * </p>\n+     *\n+     * @return Parsed NEW_KEYWORD Token.\n+     */\n+    private STNode parseNewKeyword() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.NEW_KEYWORD) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(token, ParserRuleContext.NEW_KEYWORD);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    private STNode parseNewExpression(STNode newKeyword) {\n+        STNode token = peek();\n+        return parseNewExpression(token.kind, newKeyword);\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse an implicit or explicit expression.\n+     * </p>\n+     * @param kind next token kind.\n+     * @param newKeyword parsed node for `new` keyword.\n+     * @return Parsed new-expression node.\n+     */\n+    private STNode parseNewExpression(SyntaxKind kind, STNode newKeyword) {\n+        switch (kind) {\n+            case OPEN_PAREN_TOKEN:\n+                return parseImplicitNewExpression(newKeyword);\n+            case SEMICOLON_TOKEN:\n+                return STNodeFactory.createImplicitNewExpression(newKeyword, STNodeFactory.createEmptyNode());\n+            case IDENTIFIER_TOKEN:\n+            case OBJECT_KEYWORD:\n+                // TODO: Support `stream` keyword once introduced\n+                return parseExplicitNewExpression(newKeyword);\n+            default:\n+                Solution sol = recover(peek(), ParserRuleContext.NEW_EXPRESSION, newKeyword);\n+                return parseNewExpression(sol.recoveredNode.kind, newKeyword);\n+        }\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse an Explicit New expression.\n+     * </p>\n+     * <code>\n+     *  explicit-new-expr := new type-descriptor ( arg-list )\n+     * </code>\n+     *\n+     * @param newKeyword Parsed `new` keyword.\n+     * @return the Parsed Explicit New Expression.\n+     */\n+    private STNode parseExplicitNewExpression(STNode newKeyword) {\n+        startContext(ParserRuleContext.EXPLICIT_NEW_RHS);\n+        STNode typeDescriptor = parseTypeDescriptor();\n+        STNode parenthesizedArgsList = parseParenthesizedArgList();\n+        endContext();\n+\n+        return STNodeFactory.createExplicitNewExpression(newKeyword, typeDescriptor, parenthesizedArgsList);\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse an <code>implicit-new-expr</code> with arguments.\n+     * </p>\n+     *\n+     * @param newKeyword Parsed `new` keyword.\n+     * @return Parsed implicit-new-expr.\n+     */\n+    private STNode parseImplicitNewExpression(STNode newKeyword) {\n+        STNode implicitNewArgList = parseParenthesizedArgList();\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ae4c6e850b7ecb589b3f16e8966ac7109266ee3"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjUxOTE0OA==", "bodyText": "fixed with 07c06fd", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146#discussion_r422519148", "createdAt": "2020-05-09T16:51:19Z", "author": {"login": "dulvinw"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -3172,6 +3180,127 @@ private STNode parseActionOrExpressionInLhs(SyntaxKind nextTokenKind, STNode lhs\n         return parseExpressionRhs(nextTokenKind, DEFAULT_OP_PRECEDENCE, lhsExpr, false, true);\n     }\n \n+    /**\n+     * <p>\n+     * Parse a new expression.\n+     * </p>\n+     * <code>\n+     *  new-expr := explicit-new-expr | implicit-new-expr\n+     *  explicit-new-expr := new type-descriptor ( arg-list )\n+     *  implicit-new-expr := new [( arg-list )]\n+     * </code>\n+     *\n+     * @return Parsed NewExpression node.\n+     */\n+    private STNode parseNewExpression() {\n+        startContext(ParserRuleContext.NEW_EXPRESSION);\n+        STNode newKeyword = parseNewKeyword();\n+        STNode newExpression = parseNewExpression(newKeyword);\n+        endContext();\n+        return newExpression;\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse `new` keyword.\n+     * </p>\n+     *\n+     * @return Parsed NEW_KEYWORD Token.\n+     */\n+    private STNode parseNewKeyword() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.NEW_KEYWORD) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(token, ParserRuleContext.NEW_KEYWORD);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    private STNode parseNewExpression(STNode newKeyword) {\n+        STNode token = peek();\n+        return parseNewExpression(token.kind, newKeyword);\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse an implicit or explicit expression.\n+     * </p>\n+     * @param kind next token kind.\n+     * @param newKeyword parsed node for `new` keyword.\n+     * @return Parsed new-expression node.\n+     */\n+    private STNode parseNewExpression(SyntaxKind kind, STNode newKeyword) {\n+        switch (kind) {\n+            case OPEN_PAREN_TOKEN:\n+                return parseImplicitNewExpression(newKeyword);\n+            case SEMICOLON_TOKEN:\n+                return STNodeFactory.createImplicitNewExpression(newKeyword, STNodeFactory.createEmptyNode());\n+            case IDENTIFIER_TOKEN:\n+            case OBJECT_KEYWORD:\n+                // TODO: Support `stream` keyword once introduced\n+                return parseExplicitNewExpression(newKeyword);\n+            default:\n+                Solution sol = recover(peek(), ParserRuleContext.NEW_EXPRESSION, newKeyword);\n+                return parseNewExpression(sol.recoveredNode.kind, newKeyword);\n+        }\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse an Explicit New expression.\n+     * </p>\n+     * <code>\n+     *  explicit-new-expr := new type-descriptor ( arg-list )\n+     * </code>\n+     *\n+     * @param newKeyword Parsed `new` keyword.\n+     * @return the Parsed Explicit New Expression.\n+     */\n+    private STNode parseExplicitNewExpression(STNode newKeyword) {\n+        startContext(ParserRuleContext.EXPLICIT_NEW_RHS);\n+        STNode typeDescriptor = parseTypeDescriptor();\n+        STNode parenthesizedArgsList = parseParenthesizedArgList();\n+        endContext();\n+\n+        return STNodeFactory.createExplicitNewExpression(newKeyword, typeDescriptor, parenthesizedArgsList);\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse an <code>implicit-new-expr</code> with arguments.\n+     * </p>\n+     *\n+     * @param newKeyword Parsed `new` keyword.\n+     * @return Parsed implicit-new-expr.\n+     */\n+    private STNode parseImplicitNewExpression(STNode newKeyword) {\n+        STNode implicitNewArgList = parseParenthesizedArgList();\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQ5NTk5NA=="}, "originalCommit": {"oid": "8ae4c6e850b7ecb589b3f16e8966ac7109266ee3"}, "originalPosition": 131}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNDAyOTQ3OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QxMzoyNToxNVrOGR-X-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQxNjo1MToxMlrOGS8hXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTUwMDkyMA==", "bodyText": "Need to add NEW_KEYWORD to the EXPRESSION_START array. Otherwise, if theres an error before the new, expression, then error handler will not know to treat new as a expression.\ni.e: Check something like: T x  new(); where the equal sign is missing before new expression.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146#discussion_r421500920", "createdAt": "2020-05-07T13:25:15Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -1020,6 +1023,8 @@ protected Result seekMatch(ParserRuleContext currentCtx, int lookahead, int curr\n                 case STRING_KEYWORD:\n                     hasMatch = nextToken.kind == SyntaxKind.XML_KEYWORD;\n                     break;\n+                case NEW_EXPRESSION:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ae4c6e850b7ecb589b3f16e8966ac7109266ee3"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjUxOTEzMw==", "bodyText": "fixed with 07c06fd", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146#discussion_r422519133", "createdAt": "2020-05-09T16:51:12Z", "author": {"login": "dulvinw"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -1020,6 +1023,8 @@ protected Result seekMatch(ParserRuleContext currentCtx, int lookahead, int curr\n                 case STRING_KEYWORD:\n                     hasMatch = nextToken.kind == SyntaxKind.XML_KEYWORD;\n                     break;\n+                case NEW_EXPRESSION:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTUwMDkyMA=="}, "originalCommit": {"oid": "8ae4c6e850b7ecb589b3f16e8966ac7109266ee3"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNDA0NTg4OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QxMzoyODo1M1rOGR-iGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQxNjo1MTowNlrOGS8hUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTUwMzUxNQ==", "bodyText": "You are starting a context for NEW_RHS and EXPLICIT_NEW_RHS here, but its never ended.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146#discussion_r421503515", "createdAt": "2020-05-07T13:28:53Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -1343,6 +1350,8 @@ protected ParserRuleContext getNextRule(ParserRuleContext currentCtx, int nextLo\n             case KEY_SPECIFIER:\n             case ERROR_TYPE_DESCRIPTOR:\n             case LET_VAR_DECL:\n+            case NEW_RHS:\n+            case EXPLICIT_NEW_RHS:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ae4c6e850b7ecb589b3f16e8966ac7109266ee3"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjUxOTEyMQ==", "bodyText": "fixed with 07c06fd", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146#discussion_r422519121", "createdAt": "2020-05-09T16:51:06Z", "author": {"login": "dulvinw"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -1343,6 +1350,8 @@ protected ParserRuleContext getNextRule(ParserRuleContext currentCtx, int nextLo\n             case KEY_SPECIFIER:\n             case ERROR_TYPE_DESCRIPTOR:\n             case LET_VAR_DECL:\n+            case NEW_RHS:\n+            case EXPLICIT_NEW_RHS:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTUwMzUxNQ=="}, "originalCommit": {"oid": "8ae4c6e850b7ecb589b3f16e8966ac7109266ee3"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNDA2MjYyOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QxMzozMjo0MVrOGR-soA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQxNjo1MzoxMlrOGS8iKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTUwNjIwOA==", "bodyText": "Shall we have a different name instead of NEW_RHS. When we say new-rhs, what comes to mind is all possible alternatives after new keyword. i.e: (open-paren | identifier | expr-rhs)", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146#discussion_r421506208", "createdAt": "2020-05-07T13:32:41Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -3172,6 +3180,127 @@ private STNode parseActionOrExpressionInLhs(SyntaxKind nextTokenKind, STNode lhs\n         return parseExpressionRhs(nextTokenKind, DEFAULT_OP_PRECEDENCE, lhsExpr, false, true);\n     }\n \n+    /**\n+     * <p>\n+     * Parse a new expression.\n+     * </p>\n+     * <code>\n+     *  new-expr := explicit-new-expr | implicit-new-expr\n+     *  explicit-new-expr := new type-descriptor ( arg-list )\n+     *  implicit-new-expr := new [( arg-list )]\n+     * </code>\n+     *\n+     * @return Parsed NewExpression node.\n+     */\n+    private STNode parseNewExpression() {\n+        startContext(ParserRuleContext.NEW_EXPRESSION);\n+        STNode newKeyword = parseNewKeyword();\n+        STNode newExpression = parseNewExpression(newKeyword);\n+        endContext();\n+        return newExpression;\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse `new` keyword.\n+     * </p>\n+     *\n+     * @return Parsed NEW_KEYWORD Token.\n+     */\n+    private STNode parseNewKeyword() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.NEW_KEYWORD) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(token, ParserRuleContext.NEW_KEYWORD);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    private STNode parseNewExpression(STNode newKeyword) {\n+        STNode token = peek();\n+        return parseNewExpression(token.kind, newKeyword);\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse an implicit or explicit expression.\n+     * </p>\n+     * @param kind next token kind.\n+     * @param newKeyword parsed node for `new` keyword.\n+     * @return Parsed new-expression node.\n+     */\n+    private STNode parseNewExpression(SyntaxKind kind, STNode newKeyword) {\n+        switch (kind) {\n+            case OPEN_PAREN_TOKEN:\n+                return parseImplicitNewExpression(newKeyword);\n+            case SEMICOLON_TOKEN:\n+                return STNodeFactory.createImplicitNewExpression(newKeyword, STNodeFactory.createEmptyNode());\n+            case IDENTIFIER_TOKEN:\n+            case OBJECT_KEYWORD:\n+                // TODO: Support `stream` keyword once introduced\n+                return parseExplicitNewExpression(newKeyword);\n+            default:\n+                Solution sol = recover(peek(), ParserRuleContext.NEW_EXPRESSION, newKeyword);\n+                return parseNewExpression(sol.recoveredNode.kind, newKeyword);\n+        }\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse an Explicit New expression.\n+     * </p>\n+     * <code>\n+     *  explicit-new-expr := new type-descriptor ( arg-list )\n+     * </code>\n+     *\n+     * @param newKeyword Parsed `new` keyword.\n+     * @return the Parsed Explicit New Expression.\n+     */\n+    private STNode parseExplicitNewExpression(STNode newKeyword) {\n+        startContext(ParserRuleContext.EXPLICIT_NEW_RHS);\n+        STNode typeDescriptor = parseTypeDescriptor();\n+        STNode parenthesizedArgsList = parseParenthesizedArgList();\n+        endContext();\n+\n+        return STNodeFactory.createExplicitNewExpression(newKeyword, typeDescriptor, parenthesizedArgsList);\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse an <code>implicit-new-expr</code> with arguments.\n+     * </p>\n+     *\n+     * @param newKeyword Parsed `new` keyword.\n+     * @return Parsed implicit-new-expr.\n+     */\n+    private STNode parseImplicitNewExpression(STNode newKeyword) {\n+        STNode implicitNewArgList = parseParenthesizedArgList();\n+\n+        return STNodeFactory.createImplicitNewExpression(newKeyword, implicitNewArgList);\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse the parenthesized argument list for a <code>new-expr</code>.\n+     * </p>\n+     *\n+     * @return Parsed parenthesized rhs of <code>new-expr</code>.\n+     */\n+    private STNode parseParenthesizedArgList() {\n+        startContext(ParserRuleContext.NEW_RHS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ae4c6e850b7ecb589b3f16e8966ac7109266ee3"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjUxNjg1Mw==", "bodyText": "I'll use new-expr-args? @SupunS", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146#discussion_r422516853", "createdAt": "2020-05-09T16:29:35Z", "author": {"login": "dulvinw"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -3172,6 +3180,127 @@ private STNode parseActionOrExpressionInLhs(SyntaxKind nextTokenKind, STNode lhs\n         return parseExpressionRhs(nextTokenKind, DEFAULT_OP_PRECEDENCE, lhsExpr, false, true);\n     }\n \n+    /**\n+     * <p>\n+     * Parse a new expression.\n+     * </p>\n+     * <code>\n+     *  new-expr := explicit-new-expr | implicit-new-expr\n+     *  explicit-new-expr := new type-descriptor ( arg-list )\n+     *  implicit-new-expr := new [( arg-list )]\n+     * </code>\n+     *\n+     * @return Parsed NewExpression node.\n+     */\n+    private STNode parseNewExpression() {\n+        startContext(ParserRuleContext.NEW_EXPRESSION);\n+        STNode newKeyword = parseNewKeyword();\n+        STNode newExpression = parseNewExpression(newKeyword);\n+        endContext();\n+        return newExpression;\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse `new` keyword.\n+     * </p>\n+     *\n+     * @return Parsed NEW_KEYWORD Token.\n+     */\n+    private STNode parseNewKeyword() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.NEW_KEYWORD) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(token, ParserRuleContext.NEW_KEYWORD);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    private STNode parseNewExpression(STNode newKeyword) {\n+        STNode token = peek();\n+        return parseNewExpression(token.kind, newKeyword);\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse an implicit or explicit expression.\n+     * </p>\n+     * @param kind next token kind.\n+     * @param newKeyword parsed node for `new` keyword.\n+     * @return Parsed new-expression node.\n+     */\n+    private STNode parseNewExpression(SyntaxKind kind, STNode newKeyword) {\n+        switch (kind) {\n+            case OPEN_PAREN_TOKEN:\n+                return parseImplicitNewExpression(newKeyword);\n+            case SEMICOLON_TOKEN:\n+                return STNodeFactory.createImplicitNewExpression(newKeyword, STNodeFactory.createEmptyNode());\n+            case IDENTIFIER_TOKEN:\n+            case OBJECT_KEYWORD:\n+                // TODO: Support `stream` keyword once introduced\n+                return parseExplicitNewExpression(newKeyword);\n+            default:\n+                Solution sol = recover(peek(), ParserRuleContext.NEW_EXPRESSION, newKeyword);\n+                return parseNewExpression(sol.recoveredNode.kind, newKeyword);\n+        }\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse an Explicit New expression.\n+     * </p>\n+     * <code>\n+     *  explicit-new-expr := new type-descriptor ( arg-list )\n+     * </code>\n+     *\n+     * @param newKeyword Parsed `new` keyword.\n+     * @return the Parsed Explicit New Expression.\n+     */\n+    private STNode parseExplicitNewExpression(STNode newKeyword) {\n+        startContext(ParserRuleContext.EXPLICIT_NEW_RHS);\n+        STNode typeDescriptor = parseTypeDescriptor();\n+        STNode parenthesizedArgsList = parseParenthesizedArgList();\n+        endContext();\n+\n+        return STNodeFactory.createExplicitNewExpression(newKeyword, typeDescriptor, parenthesizedArgsList);\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse an <code>implicit-new-expr</code> with arguments.\n+     * </p>\n+     *\n+     * @param newKeyword Parsed `new` keyword.\n+     * @return Parsed implicit-new-expr.\n+     */\n+    private STNode parseImplicitNewExpression(STNode newKeyword) {\n+        STNode implicitNewArgList = parseParenthesizedArgList();\n+\n+        return STNodeFactory.createImplicitNewExpression(newKeyword, implicitNewArgList);\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse the parenthesized argument list for a <code>new-expr</code>.\n+     * </p>\n+     *\n+     * @return Parsed parenthesized rhs of <code>new-expr</code>.\n+     */\n+    private STNode parseParenthesizedArgList() {\n+        startContext(ParserRuleContext.NEW_RHS);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTUwNjIwOA=="}, "originalCommit": {"oid": "8ae4c6e850b7ecb589b3f16e8966ac7109266ee3"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjUxOTMzOA==", "bodyText": "fixed with 07c06fd using new-expr-args. Let me know if I should use something else", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146#discussion_r422519338", "createdAt": "2020-05-09T16:53:12Z", "author": {"login": "dulvinw"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -3172,6 +3180,127 @@ private STNode parseActionOrExpressionInLhs(SyntaxKind nextTokenKind, STNode lhs\n         return parseExpressionRhs(nextTokenKind, DEFAULT_OP_PRECEDENCE, lhsExpr, false, true);\n     }\n \n+    /**\n+     * <p>\n+     * Parse a new expression.\n+     * </p>\n+     * <code>\n+     *  new-expr := explicit-new-expr | implicit-new-expr\n+     *  explicit-new-expr := new type-descriptor ( arg-list )\n+     *  implicit-new-expr := new [( arg-list )]\n+     * </code>\n+     *\n+     * @return Parsed NewExpression node.\n+     */\n+    private STNode parseNewExpression() {\n+        startContext(ParserRuleContext.NEW_EXPRESSION);\n+        STNode newKeyword = parseNewKeyword();\n+        STNode newExpression = parseNewExpression(newKeyword);\n+        endContext();\n+        return newExpression;\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse `new` keyword.\n+     * </p>\n+     *\n+     * @return Parsed NEW_KEYWORD Token.\n+     */\n+    private STNode parseNewKeyword() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.NEW_KEYWORD) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(token, ParserRuleContext.NEW_KEYWORD);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    private STNode parseNewExpression(STNode newKeyword) {\n+        STNode token = peek();\n+        return parseNewExpression(token.kind, newKeyword);\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse an implicit or explicit expression.\n+     * </p>\n+     * @param kind next token kind.\n+     * @param newKeyword parsed node for `new` keyword.\n+     * @return Parsed new-expression node.\n+     */\n+    private STNode parseNewExpression(SyntaxKind kind, STNode newKeyword) {\n+        switch (kind) {\n+            case OPEN_PAREN_TOKEN:\n+                return parseImplicitNewExpression(newKeyword);\n+            case SEMICOLON_TOKEN:\n+                return STNodeFactory.createImplicitNewExpression(newKeyword, STNodeFactory.createEmptyNode());\n+            case IDENTIFIER_TOKEN:\n+            case OBJECT_KEYWORD:\n+                // TODO: Support `stream` keyword once introduced\n+                return parseExplicitNewExpression(newKeyword);\n+            default:\n+                Solution sol = recover(peek(), ParserRuleContext.NEW_EXPRESSION, newKeyword);\n+                return parseNewExpression(sol.recoveredNode.kind, newKeyword);\n+        }\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse an Explicit New expression.\n+     * </p>\n+     * <code>\n+     *  explicit-new-expr := new type-descriptor ( arg-list )\n+     * </code>\n+     *\n+     * @param newKeyword Parsed `new` keyword.\n+     * @return the Parsed Explicit New Expression.\n+     */\n+    private STNode parseExplicitNewExpression(STNode newKeyword) {\n+        startContext(ParserRuleContext.EXPLICIT_NEW_RHS);\n+        STNode typeDescriptor = parseTypeDescriptor();\n+        STNode parenthesizedArgsList = parseParenthesizedArgList();\n+        endContext();\n+\n+        return STNodeFactory.createExplicitNewExpression(newKeyword, typeDescriptor, parenthesizedArgsList);\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse an <code>implicit-new-expr</code> with arguments.\n+     * </p>\n+     *\n+     * @param newKeyword Parsed `new` keyword.\n+     * @return Parsed implicit-new-expr.\n+     */\n+    private STNode parseImplicitNewExpression(STNode newKeyword) {\n+        STNode implicitNewArgList = parseParenthesizedArgList();\n+\n+        return STNodeFactory.createImplicitNewExpression(newKeyword, implicitNewArgList);\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse the parenthesized argument list for a <code>new-expr</code>.\n+     * </p>\n+     *\n+     * @return Parsed parenthesized rhs of <code>new-expr</code>.\n+     */\n+    private STNode parseParenthesizedArgList() {\n+        startContext(ParserRuleContext.NEW_RHS);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTUwNjIwOA=="}, "originalCommit": {"oid": "8ae4c6e850b7ecb589b3f16e8966ac7109266ee3"}, "originalPosition": 143}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzODQ2NTg4OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxMjoxOTozMVrOGUD1SQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxMjoxOTozMVrOGUD1SQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY4NzQ5Nw==", "bodyText": "Lets create an issue for this", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146#discussion_r423687497", "createdAt": "2020-05-12T12:19:31Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -3481,6 +3489,116 @@ private STNode parseActionOrExpressionInLhs(SyntaxKind nextTokenKind, STNode lhs\n         return parseExpressionRhs(nextTokenKind, DEFAULT_OP_PRECEDENCE, lhsExpr, false, true);\n     }\n \n+    /**\n+     * <p>\n+     * Parse a new expression.\n+     * </p>\n+     * <code>\n+     *  new-expr := explicit-new-expr | implicit-new-expr\n+     *  explicit-new-expr := new type-descriptor ( arg-list )\n+     *  implicit-new-expr := new [( arg-list )]\n+     * </code>\n+     *\n+     * @return Parsed NewExpression node.\n+     */\n+    private STNode parseNewExpression() {\n+        STNode newKeyword = parseNewKeyword();\n+        return parseNewKeywordRhs(newKeyword);\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse `new` keyword.\n+     * </p>\n+     *\n+     * @return Parsed NEW_KEYWORD Token.\n+     */\n+    private STNode parseNewKeyword() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.NEW_KEYWORD) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(token, ParserRuleContext.NEW_KEYWORD);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    private STNode parseNewKeywordRhs(STNode newKeyword) {\n+        STNode token = peek();\n+        return parseNewKeywordRhs(token.kind, newKeyword);\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse an implicit or explicit expression.\n+     * </p>\n+     * @param kind next token kind.\n+     * @param newKeyword parsed node for `new` keyword.\n+     * @return Parsed new-expression node.\n+     */\n+    private STNode parseNewKeywordRhs(SyntaxKind kind, STNode newKeyword) {\n+        switch (kind) {\n+            case OPEN_PAREN_TOKEN:\n+                return parseImplicitNewRhs(newKeyword);\n+            case SEMICOLON_TOKEN:\n+                break;\n+            case IDENTIFIER_TOKEN:\n+            case OBJECT_KEYWORD:\n+                // TODO: Support `stream` keyword once introduced", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e8aad69b94e8bc3dd3b15a8d862d785bd3b86b6"}, "originalPosition": 117}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzODQ3MjA5OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxMjoyMToyMVrOGUD5VQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxNTo0Mzo1MlrOGUNBsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY4ODUzMw==", "bodyText": "Shall we rename EXPLICIT_NEW_RHS to TYPE_DESC_IN_NEW_EXPR, to be aligned with the convention we used in other places?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146#discussion_r423688533", "createdAt": "2020-05-12T12:21:21Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -3481,6 +3489,116 @@ private STNode parseActionOrExpressionInLhs(SyntaxKind nextTokenKind, STNode lhs\n         return parseExpressionRhs(nextTokenKind, DEFAULT_OP_PRECEDENCE, lhsExpr, false, true);\n     }\n \n+    /**\n+     * <p>\n+     * Parse a new expression.\n+     * </p>\n+     * <code>\n+     *  new-expr := explicit-new-expr | implicit-new-expr\n+     *  explicit-new-expr := new type-descriptor ( arg-list )\n+     *  implicit-new-expr := new [( arg-list )]\n+     * </code>\n+     *\n+     * @return Parsed NewExpression node.\n+     */\n+    private STNode parseNewExpression() {\n+        STNode newKeyword = parseNewKeyword();\n+        return parseNewKeywordRhs(newKeyword);\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse `new` keyword.\n+     * </p>\n+     *\n+     * @return Parsed NEW_KEYWORD Token.\n+     */\n+    private STNode parseNewKeyword() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.NEW_KEYWORD) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(token, ParserRuleContext.NEW_KEYWORD);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    private STNode parseNewKeywordRhs(STNode newKeyword) {\n+        STNode token = peek();\n+        return parseNewKeywordRhs(token.kind, newKeyword);\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse an implicit or explicit expression.\n+     * </p>\n+     * @param kind next token kind.\n+     * @param newKeyword parsed node for `new` keyword.\n+     * @return Parsed new-expression node.\n+     */\n+    private STNode parseNewKeywordRhs(SyntaxKind kind, STNode newKeyword) {\n+        switch (kind) {\n+            case OPEN_PAREN_TOKEN:\n+                return parseImplicitNewRhs(newKeyword);\n+            case SEMICOLON_TOKEN:\n+                break;\n+            case IDENTIFIER_TOKEN:\n+            case OBJECT_KEYWORD:\n+                // TODO: Support `stream` keyword once introduced\n+                return parseExplicitNewRhs(newKeyword);\n+            default:\n+                break;\n+        }\n+\n+        return STNodeFactory.createImplicitNewExpression(newKeyword, STNodeFactory.createEmptyNode());\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse an Explicit New expression.\n+     * </p>\n+     * <code>\n+     *  explicit-new-expr := new type-descriptor ( arg-list )\n+     * </code>\n+     *\n+     * @param newKeyword Parsed `new` keyword.\n+     * @return the Parsed Explicit New Expression.\n+     */\n+    private STNode parseExplicitNewRhs(STNode newKeyword) {\n+        STNode typeDescriptor = parseTypeDescriptor(ParserRuleContext.EXPLICIT_NEW_RHS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e8aad69b94e8bc3dd3b15a8d862d785bd3b86b6"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzgzODEyOQ==", "bodyText": "fixed in 401f175", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146#discussion_r423838129", "createdAt": "2020-05-12T15:43:52Z", "author": {"login": "dulvinw"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -3481,6 +3489,116 @@ private STNode parseActionOrExpressionInLhs(SyntaxKind nextTokenKind, STNode lhs\n         return parseExpressionRhs(nextTokenKind, DEFAULT_OP_PRECEDENCE, lhsExpr, false, true);\n     }\n \n+    /**\n+     * <p>\n+     * Parse a new expression.\n+     * </p>\n+     * <code>\n+     *  new-expr := explicit-new-expr | implicit-new-expr\n+     *  explicit-new-expr := new type-descriptor ( arg-list )\n+     *  implicit-new-expr := new [( arg-list )]\n+     * </code>\n+     *\n+     * @return Parsed NewExpression node.\n+     */\n+    private STNode parseNewExpression() {\n+        STNode newKeyword = parseNewKeyword();\n+        return parseNewKeywordRhs(newKeyword);\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse `new` keyword.\n+     * </p>\n+     *\n+     * @return Parsed NEW_KEYWORD Token.\n+     */\n+    private STNode parseNewKeyword() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.NEW_KEYWORD) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(token, ParserRuleContext.NEW_KEYWORD);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    private STNode parseNewKeywordRhs(STNode newKeyword) {\n+        STNode token = peek();\n+        return parseNewKeywordRhs(token.kind, newKeyword);\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse an implicit or explicit expression.\n+     * </p>\n+     * @param kind next token kind.\n+     * @param newKeyword parsed node for `new` keyword.\n+     * @return Parsed new-expression node.\n+     */\n+    private STNode parseNewKeywordRhs(SyntaxKind kind, STNode newKeyword) {\n+        switch (kind) {\n+            case OPEN_PAREN_TOKEN:\n+                return parseImplicitNewRhs(newKeyword);\n+            case SEMICOLON_TOKEN:\n+                break;\n+            case IDENTIFIER_TOKEN:\n+            case OBJECT_KEYWORD:\n+                // TODO: Support `stream` keyword once introduced\n+                return parseExplicitNewRhs(newKeyword);\n+            default:\n+                break;\n+        }\n+\n+        return STNodeFactory.createImplicitNewExpression(newKeyword, STNodeFactory.createEmptyNode());\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse an Explicit New expression.\n+     * </p>\n+     * <code>\n+     *  explicit-new-expr := new type-descriptor ( arg-list )\n+     * </code>\n+     *\n+     * @param newKeyword Parsed `new` keyword.\n+     * @return the Parsed Explicit New Expression.\n+     */\n+    private STNode parseExplicitNewRhs(STNode newKeyword) {\n+        STNode typeDescriptor = parseTypeDescriptor(ParserRuleContext.EXPLICIT_NEW_RHS);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY4ODUzMw=="}, "originalCommit": {"oid": "5e8aad69b94e8bc3dd3b15a8d862d785bd3b86b6"}, "originalPosition": 138}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzODQ4ODU4OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxMjoyNTo1N1rOGUEEIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxNTo0Mzo0NlrOGUNBaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY5MTI5OA==", "bodyText": "I don't think we need it here.\nThis should be added to all the places where other TYPE_DESC_IN_** contexts are added.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146#discussion_r423691298", "createdAt": "2020-05-12T12:25:57Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -1920,6 +1933,7 @@ protected ParserRuleContext getNextRule(ParserRuleContext currentCtx, int nextLo\n             case ARG_LIST_START:\n                 return ParserRuleContext.ARG_LIST;\n             case ARG_LIST_END:\n+            case EXPLICIT_NEW_RHS:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fefff93efc037821b671f5ac9b72118bdcfcfce"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzgzODA1Nw==", "bodyText": "fixed in 401f175", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146#discussion_r423838057", "createdAt": "2020-05-12T15:43:46Z", "author": {"login": "dulvinw"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -1920,6 +1933,7 @@ protected ParserRuleContext getNextRule(ParserRuleContext currentCtx, int nextLo\n             case ARG_LIST_START:\n                 return ParserRuleContext.ARG_LIST;\n             case ARG_LIST_END:\n+            case EXPLICIT_NEW_RHS:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY5MTI5OA=="}, "originalCommit": {"oid": "7fefff93efc037821b671f5ac9b72118bdcfcfce"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzODQ5MDcxOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxMjoyNjozM1rOGUEFgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxNTo0Mzo0MVrOGUNBNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY5MTY1MA==", "bodyText": "Same as above", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146#discussion_r423691650", "createdAt": "2020-05-12T12:26:33Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -2390,6 +2404,8 @@ private ParserRuleContext getNextRuleForCloseBrace(int nextLookahead) {\n             case INTERPOLATION:\n                 endContext();\n                 return ParserRuleContext.TEMPLATE_MEMBER;\n+            case EXPLICIT_NEW_RHS:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fefff93efc037821b671f5ac9b72118bdcfcfce"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzgzODAwNQ==", "bodyText": "fixed in 401f175", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146#discussion_r423838005", "createdAt": "2020-05-12T15:43:41Z", "author": {"login": "dulvinw"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -2390,6 +2404,8 @@ private ParserRuleContext getNextRuleForCloseBrace(int nextLookahead) {\n             case INTERPOLATION:\n                 endContext();\n                 return ParserRuleContext.TEMPLATE_MEMBER;\n+            case EXPLICIT_NEW_RHS:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY5MTY1MA=="}, "originalCommit": {"oid": "7fefff93efc037821b671f5ac9b72118bdcfcfce"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzODQ5MjkxOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxMjoyNzoxNFrOGUEHBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxNTo0MzozNVrOGUNA9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY5MjAzOA==", "bodyText": "better to rename NEW_EXPR  --> NEW_KEYWORD_RHS", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146#discussion_r423692038", "createdAt": "2020-05-12T12:27:14Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -323,6 +323,10 @@\n             { ParserRuleContext.END_OF_TYPE_DESC, ParserRuleContext.ARRAY_TYPE_DESCRIPTOR,\n                     ParserRuleContext.OPTIONAL_TYPE_DESCRIPTOR, ParserRuleContext.PIPE };\n \n+    private static final ParserRuleContext[] NEW_EXPR =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fefff93efc037821b671f5ac9b72118bdcfcfce"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzgzNzk0MA==", "bodyText": "fixed in 401f175", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146#discussion_r423837940", "createdAt": "2020-05-12T15:43:35Z", "author": {"login": "dulvinw"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -323,6 +323,10 @@\n             { ParserRuleContext.END_OF_TYPE_DESC, ParserRuleContext.ARRAY_TYPE_DESCRIPTOR,\n                     ParserRuleContext.OPTIONAL_TYPE_DESCRIPTOR, ParserRuleContext.PIPE };\n \n+    private static final ParserRuleContext[] NEW_EXPR =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY5MjAzOA=="}, "originalCommit": {"oid": "7fefff93efc037821b671f5ac9b72118bdcfcfce"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzODUwNTYyOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxMjozMDozOVrOGUEPUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxNTo0MzoyOFrOGUNAlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY5NDE2MQ==", "bodyText": "This Should be ARG_LIST_START. Its also matches against the ( , but it handles the arg-contexts", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146#discussion_r423694161", "createdAt": "2020-05-12T12:30:39Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -2390,6 +2404,8 @@ private ParserRuleContext getNextRuleForCloseBrace(int nextLookahead) {\n             case INTERPOLATION:\n                 endContext();\n                 return ParserRuleContext.TEMPLATE_MEMBER;\n+            case EXPLICIT_NEW_RHS:\n+                return ParserRuleContext.OPEN_PARENTHESIS;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fefff93efc037821b671f5ac9b72118bdcfcfce"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzgzNzg0NQ==", "bodyText": "fixed in 401f175", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146#discussion_r423837845", "createdAt": "2020-05-12T15:43:28Z", "author": {"login": "dulvinw"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -2390,6 +2404,8 @@ private ParserRuleContext getNextRuleForCloseBrace(int nextLookahead) {\n             case INTERPOLATION:\n                 endContext();\n                 return ParserRuleContext.TEMPLATE_MEMBER;\n+            case EXPLICIT_NEW_RHS:\n+                return ParserRuleContext.OPEN_PARENTHESIS;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY5NDE2MQ=="}, "originalCommit": {"oid": "7fefff93efc037821b671f5ac9b72118bdcfcfce"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzODUxMjk5OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-treegen/src/main/resources/syntax_tree_descriptor.json", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxMjozMjo0M1rOGUEUEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxNTo0MzoyMVrOGUNARA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY5NTM3Ng==", "bodyText": "type should be TypeDescriptorNode", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146#discussion_r423695376", "createdAt": "2020-05-12T12:32:43Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-treegen/src/main/resources/syntax_tree_descriptor.json", "diffHunk": "@@ -2438,6 +2438,66 @@\n                     \"type\": \"Token\"\n                 }\n             ]\n+        },\n+        {\n+            \"name\": \"NewExpression\",\n+            \"base\": \"ExpressionNode\",\n+            \"isAbstract\": true\n+        },\n+        {\n+            \"name\": \"ExplicitNewExpression\",\n+            \"base\": \"NewExpression\",\n+            \"kind\": \"EXPLICIT_NEW\",\n+            \"attributes\": [\n+                {\n+                    \"name\": \"NewKeyword\",\n+                    \"type\": \"Token\"\n+                },\n+                {\n+                    \"name\": \"TypeDescriptor\",\n+                    \"type\": \"Node\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fefff93efc037821b671f5ac9b72118bdcfcfce"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzgzNzc2NA==", "bodyText": "fixed in 401f175", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146#discussion_r423837764", "createdAt": "2020-05-12T15:43:21Z", "author": {"login": "dulvinw"}, "path": "compiler/ballerina-treegen/src/main/resources/syntax_tree_descriptor.json", "diffHunk": "@@ -2438,6 +2438,66 @@\n                     \"type\": \"Token\"\n                 }\n             ]\n+        },\n+        {\n+            \"name\": \"NewExpression\",\n+            \"base\": \"ExpressionNode\",\n+            \"isAbstract\": true\n+        },\n+        {\n+            \"name\": \"ExplicitNewExpression\",\n+            \"base\": \"NewExpression\",\n+            \"kind\": \"EXPLICIT_NEW\",\n+            \"attributes\": [\n+                {\n+                    \"name\": \"NewKeyword\",\n+                    \"type\": \"Token\"\n+                },\n+                {\n+                    \"name\": \"TypeDescriptor\",\n+                    \"type\": \"Node\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY5NTM3Ng=="}, "originalCommit": {"oid": "7fefff93efc037821b671f5ac9b72118bdcfcfce"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzODUxNTEwOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-treegen/src/main/resources/syntax_tree_descriptor.json", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxMjozMzoyM1rOGUEVfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxNTo0Mjo1NlrOGUM-8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY5NTc0MA==", "bodyText": "EXPLICIT_NEW_EXPRESSION", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146#discussion_r423695740", "createdAt": "2020-05-12T12:33:23Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-treegen/src/main/resources/syntax_tree_descriptor.json", "diffHunk": "@@ -2438,6 +2438,66 @@\n                     \"type\": \"Token\"\n                 }\n             ]\n+        },\n+        {\n+            \"name\": \"NewExpression\",\n+            \"base\": \"ExpressionNode\",\n+            \"isAbstract\": true\n+        },\n+        {\n+            \"name\": \"ExplicitNewExpression\",\n+            \"base\": \"NewExpression\",\n+            \"kind\": \"EXPLICIT_NEW\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fefff93efc037821b671f5ac9b72118bdcfcfce"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzgzNzQyNQ==", "bodyText": "fixed in 401f175", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146#discussion_r423837425", "createdAt": "2020-05-12T15:42:56Z", "author": {"login": "dulvinw"}, "path": "compiler/ballerina-treegen/src/main/resources/syntax_tree_descriptor.json", "diffHunk": "@@ -2438,6 +2438,66 @@\n                     \"type\": \"Token\"\n                 }\n             ]\n+        },\n+        {\n+            \"name\": \"NewExpression\",\n+            \"base\": \"ExpressionNode\",\n+            \"isAbstract\": true\n+        },\n+        {\n+            \"name\": \"ExplicitNewExpression\",\n+            \"base\": \"NewExpression\",\n+            \"kind\": \"EXPLICIT_NEW\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY5NTc0MA=="}, "originalCommit": {"oid": "7fefff93efc037821b671f5ac9b72118bdcfcfce"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzODUxNzM5OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-treegen/src/main/resources/syntax_tree_descriptor.json", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxMjozNDowMVrOGUEW9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxNTo0Mjo1MFrOGUM-pQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY5NjExOA==", "bodyText": "all nodes-names must end with ...Node", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146#discussion_r423696118", "createdAt": "2020-05-12T12:34:01Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-treegen/src/main/resources/syntax_tree_descriptor.json", "diffHunk": "@@ -2438,6 +2438,66 @@\n                     \"type\": \"Token\"\n                 }\n             ]\n+        },\n+        {\n+            \"name\": \"NewExpression\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fefff93efc037821b671f5ac9b72118bdcfcfce"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzgzNzM0OQ==", "bodyText": "Fixed in 401f175", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146#discussion_r423837349", "createdAt": "2020-05-12T15:42:50Z", "author": {"login": "dulvinw"}, "path": "compiler/ballerina-treegen/src/main/resources/syntax_tree_descriptor.json", "diffHunk": "@@ -2438,6 +2438,66 @@\n                     \"type\": \"Token\"\n                 }\n             ]\n+        },\n+        {\n+            \"name\": \"NewExpression\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY5NjExOA=="}, "originalCommit": {"oid": "7fefff93efc037821b671f5ac9b72118bdcfcfce"}, "originalPosition": 6}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3741, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}