{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk2NDA3MDA3", "number": 22352, "title": "Allow passing args for non-rest params via the vararg", "bodyText": "Purpose\nThis PR will allow passing args for non-rest params via the vararg.\nFixes #17943\ne.g.,\nimport ballerina/io;\n\npublic function main() {\n    // This works.\n    foo(1, \"hello\", \"world\");\n\n    [int, string...] x = [1, \"hello\", \"world\"];\n    // Now this also works.\n    foo(...x);\n}\n\nfunction foo(int i, string... s) {\n    io:println(i); // 1\n\n    foreach string st in s {\n        io:println(st); // hello\n                             // world\n    }\n}\nAdditionally it will also\n\nallow passing args for the rest param as both individual args and a vararg\n\nimport ballerina/io;\n\npublic function main() {\n    string[] x = [\"world\", \"from Ballerina\"];\n    foo(1, \"hello\", ...x);\n}\n\nfunction foo(int i, string... s) {\n    io:println(i); // 1\n    io:println(s.length()); // 3\n\n    foreach string st in s {\n        io:println(st); // hello\n                        // world\n                        // from Ballerina\n    }\n}\n\nremove adding parameter defaults when there's a rest param\n\nFixes #22204\nThe following will result in a compilation error now.\npublic function main() {\n    string[] x = [\"hello\", \"world\"];\n    foo(1, ...x); // incompatible types: expected '[float,string...]', found 'string[]'\n}\n\nfunction foo(int i, float f = 1.0, string... s) {\n}\nIf the vararg list provided as the first member a type compatible with the defaultable parameter, that member would be used as the arg for the relevant defaultable parameter.\nimport ballerina/io;\n\npublic function main() {\n    [float, string, string] x = [1.0, \"hello\", \"world\"];\n    foo(1, ...x);\n}\n\nfunction foo(int i, float f = 1.0, string... s) {\n    io:println(i); // 1\n    io:println(f); // 1.0\n    io:println(s); // hello world\n}\n\nThis PR also fixes two bugs.\n\nFixes #22340\nFixes #22350\nCheck List\n\n Read the Contributing Guide\n Updated Change Log\n Checked Tooling Support (#)\n Added necessary tests\n\n Unit Tests\n Spec Conformance Tests\n Integration Tests\n Ballerina By Example Tests\n\n\n Increased Test Coverage\n Added necessary documentation\n\n API documentation\n Module documentation in Module.md files\n Ballerina By Examples", "createdAt": "2020-03-31T15:18:36Z", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22352", "merged": true, "mergeCommit": {"oid": "8becb986958319958ef5d9aeaeeecf4e1089ebdf"}, "closed": true, "closedAt": "2020-04-27T12:08:05Z", "author": {"login": "MaryamZi"}, "timelineItems": {"totalCount": 19, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcSalafgH2gAyMzk2NDA3MDA3OjU5MTUzN2I1ZDFiZDI1YThmZjEzNWIxNDc2MWM1Y2EzY2FiYzhkNjY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcbuIknAFqTQwMDg4NzI3NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "591537b5d1bd25a8ff135b14761c5ca3cabc8d66", "author": {"user": {"login": "MaryamZi", "name": "Maryam Ziyad"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/591537b5d1bd25a8ff135b14761c5ca3cabc8d66", "committedDate": "2020-03-29T14:15:07Z", "message": "Intro semantic analysis changes for rest arg fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6e4779361f0be11a6ce67ced85cb427dcc092941", "author": {"user": {"login": "MaryamZi", "name": "Maryam Ziyad"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6e4779361f0be11a6ce67ced85cb427dcc092941", "committedDate": "2020-03-29T14:18:05Z", "message": "Intro desugar changes for rest arg changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4bc68e38e8e80beb25cf789fea2dbc4514ee405f", "author": {"user": {"login": "MaryamZi", "name": "Maryam Ziyad"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/4bc68e38e8e80beb25cf789fea2dbc4514ee405f", "committedDate": "2020-03-29T14:18:09Z", "message": "Refactor code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f361c93047d71a2b0218a5b54f1c08095a042261", "author": {"user": {"login": "MaryamZi", "name": "Maryam Ziyad"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f361c93047d71a2b0218a5b54f1c08095a042261", "committedDate": "2020-03-29T16:37:42Z", "message": "Fix issues in sync with langlib change branch"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8bfe3f4291261c01622877115035c81d482cc574", "author": {"user": {"login": "MaryamZi", "name": "Maryam Ziyad"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/8bfe3f4291261c01622877115035c81d482cc574", "committedDate": "2020-03-30T17:38:33Z", "message": "Fix tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8beb546ee0c66ac46f06cab3f2f62dc8bec207b6", "author": {"user": {"login": "MaryamZi", "name": "Maryam Ziyad"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/8beb546ee0c66ac46f06cab3f2f62dc8bec207b6", "committedDate": "2020-03-31T05:42:25Z", "message": "Add negative tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fb5ef322de428c1319adbb326216b778a0575a2a", "author": {"user": {"login": "MaryamZi", "name": "Maryam Ziyad"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/fb5ef322de428c1319adbb326216b778a0575a2a", "committedDate": "2020-03-31T11:39:11Z", "message": "Fix type-checking for tuple with rest desc."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4788433e494561c9b4b73435a805ab94e7a8e21f", "author": {"user": {"login": "MaryamZi", "name": "Maryam Ziyad"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/4788433e494561c9b4b73435a805ab94e7a8e21f", "committedDate": "2020-03-31T13:13:37Z", "message": "Fix too many args error not being logged and add tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d560f8bd010cd882369ccce10c9f3aabeb36d58c", "author": {"user": {"login": "MaryamZi", "name": "Maryam Ziyad"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/d560f8bd010cd882369ccce10c9f3aabeb36d58c", "committedDate": "2020-03-31T15:15:05Z", "message": "Fix slice on tuple with rest desc."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f464c038368c6b30a1ff2b1125665bdbcb480a2d", "author": {"user": {"login": "MaryamZi", "name": "Maryam Ziyad"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f464c038368c6b30a1ff2b1125665bdbcb480a2d", "committedDate": "2020-04-01T08:16:01Z", "message": "Merge branch 'master' of https://github.com/ballerina-lang/ballerina into func-call-2"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a3de0504b70b2f24c86cb079c3baca7e5f2e45cc", "author": {"user": {"login": "MaryamZi", "name": "Maryam Ziyad"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a3de0504b70b2f24c86cb079c3baca7e5f2e45cc", "committedDate": "2020-04-02T03:51:44Z", "message": "Merge branch 'master' of https://github.com/ballerina-lang/ballerina into func-call-2"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg4OTc5MDIx", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22352#pullrequestreview-388979021", "createdAt": "2020-04-07T10:18:01Z", "commit": {"oid": "a3de0504b70b2f24c86cb079c3baca7e5f2e45cc"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxMDoxODowMVrOGB8zgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxMDozNzozN1rOGB9eEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY5Nzk4NA==", "bodyText": "restArgs.get(restArgs.size() - 1)\nI think we can extract this or related logic to a variable. This is used multiple times. This will simplify the code increasing readability.\nL5083, L5088, L5098, L5115 (condition)", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22352#discussion_r404697984", "createdAt": "2020-04-07T10:18:01Z", "author": {"login": "KRVPerera"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java", "diffHunk": "@@ -5065,36 +5071,154 @@ private void reorderArguments(BLangInvocation iExpr) {\n         }\n \n         BInvokableSymbol invokableSymbol = (BInvokableSymbol) symbol;\n+\n+        List<BLangExpression> restArgs = iExpr.restArgs;\n+        int originalRequiredArgCount = iExpr.requiredArgs.size();\n+\n+        // Constructs used when the vararg provides args for required/defaultable params.\n+        BLangExpression varargRef = null;\n+        BLangBlockStmt blockStmt = null;\n+\n+        if (!iExpr.restArgs.isEmpty() &&\n+                restArgs.get(restArgs.size() - 1).getKind() == NodeKind.REST_ARGS_EXPR &&", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3de0504b70b2f24c86cb079c3baca7e5f2e45cc"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY5ODQxNg==", "bodyText": "Doesn't iExpr.restArgs already has an ArrayList ?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22352#discussion_r404698416", "createdAt": "2020-04-07T10:18:47Z", "author": {"login": "KRVPerera"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java", "diffHunk": "@@ -5065,36 +5071,154 @@ private void reorderArguments(BLangInvocation iExpr) {\n         }\n \n         BInvokableSymbol invokableSymbol = (BInvokableSymbol) symbol;\n+\n+        List<BLangExpression> restArgs = iExpr.restArgs;\n+        int originalRequiredArgCount = iExpr.requiredArgs.size();\n+\n+        // Constructs used when the vararg provides args for required/defaultable params.\n+        BLangExpression varargRef = null;\n+        BLangBlockStmt blockStmt = null;\n+\n+        if (!iExpr.restArgs.isEmpty() &&\n+                restArgs.get(restArgs.size() - 1).getKind() == NodeKind.REST_ARGS_EXPR &&\n+                iExpr.requiredArgs.size() < invokableSymbol.params.size()) {\n+            // All or part of the args for the required and defaultable parameters are provided via the vararg.\n+            // We have to first evaluate the vararg's expression, define a variable, and pass a reference to it\n+            // to use for member access when adding such required arguments from the vararg.\n+            BLangExpression expr = ((BLangRestArgsExpression) restArgs.get(restArgs.size() - 1)).expr;\n+            DiagnosticPos varargExpPos = expr.pos;\n+            BType varargVarType = expr.type;\n+            String varargVarName = DESUGARED_VARARG_KEY + this.varargCount++;\n+\n+            BVarSymbol varargVarSymbol = new BVarSymbol(0, names.fromString(varargVarName), this.env.scope.owner.pkgID,\n+                                                        varargVarType, this.env.scope.owner);\n+            varargRef = ASTBuilderUtil.createVariableRef(varargExpPos, varargVarSymbol);\n+\n+            BLangSimpleVariable var = createVariable(varargExpPos, varargVarName, varargVarType,\n+                                                     ((BLangRestArgsExpression) restArgs.get(restArgs.size() - 1)).expr,\n+                                                     varargVarSymbol);\n+\n+            BLangSimpleVariableDef varDef = ASTBuilderUtil.createVariableDef(varargExpPos);\n+            varDef.var = var;\n+            varDef.type = varargVarType;\n+\n+            blockStmt = createBlockStmt(varargExpPos);\n+            blockStmt.stmts.add(varDef);\n+        }\n+\n         if (!invokableSymbol.params.isEmpty()) {\n             // Re-order the arguments\n-            reorderNamedArgs(iExpr, invokableSymbol);\n+            reorderNamedArgs(iExpr, invokableSymbol, varargRef);\n         }\n \n-        if (invokableSymbol.restParam == null) {\n+        // There are no rest args at all or args for the rest param are only given as individual args (i.e., no vararg).\n+        if (restArgs.isEmpty() || restArgs.get(restArgs.size() - 1).getKind() != NodeKind.REST_ARGS_EXPR) {\n+            if (invokableSymbol.restParam == null) {\n+                return;\n+            }\n+\n+            BLangArrayLiteral arrayLiteral = (BLangArrayLiteral) TreeBuilder.createArrayLiteralExpressionNode();\n+            List<BLangExpression> exprs = new ArrayList<>();\n+\n+            BArrayType arrayType = (BArrayType) invokableSymbol.restParam.type;\n+            BType elemType = arrayType.eType;\n+\n+            for (BLangExpression restArg : restArgs) {\n+                exprs.add(addConversionExprIfRequired(restArg, elemType));\n+            }\n+\n+            arrayLiteral.exprs = exprs;\n+            arrayLiteral.type = arrayType;\n+            iExpr.restArgs = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3de0504b70b2f24c86cb079c3baca7e5f2e45cc"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY5OTAwOA==", "bodyText": "Do we need this exprs? It can directly be arrayLiteral.exprs", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22352#discussion_r404699008", "createdAt": "2020-04-07T10:19:46Z", "author": {"login": "KRVPerera"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java", "diffHunk": "@@ -5065,36 +5071,154 @@ private void reorderArguments(BLangInvocation iExpr) {\n         }\n \n         BInvokableSymbol invokableSymbol = (BInvokableSymbol) symbol;\n+\n+        List<BLangExpression> restArgs = iExpr.restArgs;\n+        int originalRequiredArgCount = iExpr.requiredArgs.size();\n+\n+        // Constructs used when the vararg provides args for required/defaultable params.\n+        BLangExpression varargRef = null;\n+        BLangBlockStmt blockStmt = null;\n+\n+        if (!iExpr.restArgs.isEmpty() &&\n+                restArgs.get(restArgs.size() - 1).getKind() == NodeKind.REST_ARGS_EXPR &&\n+                iExpr.requiredArgs.size() < invokableSymbol.params.size()) {\n+            // All or part of the args for the required and defaultable parameters are provided via the vararg.\n+            // We have to first evaluate the vararg's expression, define a variable, and pass a reference to it\n+            // to use for member access when adding such required arguments from the vararg.\n+            BLangExpression expr = ((BLangRestArgsExpression) restArgs.get(restArgs.size() - 1)).expr;\n+            DiagnosticPos varargExpPos = expr.pos;\n+            BType varargVarType = expr.type;\n+            String varargVarName = DESUGARED_VARARG_KEY + this.varargCount++;\n+\n+            BVarSymbol varargVarSymbol = new BVarSymbol(0, names.fromString(varargVarName), this.env.scope.owner.pkgID,\n+                                                        varargVarType, this.env.scope.owner);\n+            varargRef = ASTBuilderUtil.createVariableRef(varargExpPos, varargVarSymbol);\n+\n+            BLangSimpleVariable var = createVariable(varargExpPos, varargVarName, varargVarType,\n+                                                     ((BLangRestArgsExpression) restArgs.get(restArgs.size() - 1)).expr,\n+                                                     varargVarSymbol);\n+\n+            BLangSimpleVariableDef varDef = ASTBuilderUtil.createVariableDef(varargExpPos);\n+            varDef.var = var;\n+            varDef.type = varargVarType;\n+\n+            blockStmt = createBlockStmt(varargExpPos);\n+            blockStmt.stmts.add(varDef);\n+        }\n+\n         if (!invokableSymbol.params.isEmpty()) {\n             // Re-order the arguments\n-            reorderNamedArgs(iExpr, invokableSymbol);\n+            reorderNamedArgs(iExpr, invokableSymbol, varargRef);\n         }\n \n-        if (invokableSymbol.restParam == null) {\n+        // There are no rest args at all or args for the rest param are only given as individual args (i.e., no vararg).\n+        if (restArgs.isEmpty() || restArgs.get(restArgs.size() - 1).getKind() != NodeKind.REST_ARGS_EXPR) {\n+            if (invokableSymbol.restParam == null) {\n+                return;\n+            }\n+\n+            BLangArrayLiteral arrayLiteral = (BLangArrayLiteral) TreeBuilder.createArrayLiteralExpressionNode();\n+            List<BLangExpression> exprs = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3de0504b70b2f24c86cb079c3baca7e5f2e45cc"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDcwMDIyNw==", "bodyText": "iExpr.requiredArgs.size()is already extracted to variable originalRequiredArgCount", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22352#discussion_r404700227", "createdAt": "2020-04-07T10:21:48Z", "author": {"login": "KRVPerera"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java", "diffHunk": "@@ -5065,36 +5071,154 @@ private void reorderArguments(BLangInvocation iExpr) {\n         }\n \n         BInvokableSymbol invokableSymbol = (BInvokableSymbol) symbol;\n+\n+        List<BLangExpression> restArgs = iExpr.restArgs;\n+        int originalRequiredArgCount = iExpr.requiredArgs.size();\n+\n+        // Constructs used when the vararg provides args for required/defaultable params.\n+        BLangExpression varargRef = null;\n+        BLangBlockStmt blockStmt = null;\n+\n+        if (!iExpr.restArgs.isEmpty() &&\n+                restArgs.get(restArgs.size() - 1).getKind() == NodeKind.REST_ARGS_EXPR &&\n+                iExpr.requiredArgs.size() < invokableSymbol.params.size()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3de0504b70b2f24c86cb079c3baca7e5f2e45cc"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDcwODAxOA==", "bodyText": "Where does this change?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22352#discussion_r404708018", "createdAt": "2020-04-07T10:35:54Z", "author": {"login": "KRVPerera"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java", "diffHunk": "@@ -5065,36 +5071,154 @@ private void reorderArguments(BLangInvocation iExpr) {\n         }\n \n         BInvokableSymbol invokableSymbol = (BInvokableSymbol) symbol;\n+\n+        List<BLangExpression> restArgs = iExpr.restArgs;\n+        int originalRequiredArgCount = iExpr.requiredArgs.size();\n+\n+        // Constructs used when the vararg provides args for required/defaultable params.\n+        BLangExpression varargRef = null;\n+        BLangBlockStmt blockStmt = null;\n+\n+        if (!iExpr.restArgs.isEmpty() &&\n+                restArgs.get(restArgs.size() - 1).getKind() == NodeKind.REST_ARGS_EXPR &&\n+                iExpr.requiredArgs.size() < invokableSymbol.params.size()) {\n+            // All or part of the args for the required and defaultable parameters are provided via the vararg.\n+            // We have to first evaluate the vararg's expression, define a variable, and pass a reference to it\n+            // to use for member access when adding such required arguments from the vararg.\n+            BLangExpression expr = ((BLangRestArgsExpression) restArgs.get(restArgs.size() - 1)).expr;\n+            DiagnosticPos varargExpPos = expr.pos;\n+            BType varargVarType = expr.type;\n+            String varargVarName = DESUGARED_VARARG_KEY + this.varargCount++;\n+\n+            BVarSymbol varargVarSymbol = new BVarSymbol(0, names.fromString(varargVarName), this.env.scope.owner.pkgID,\n+                                                        varargVarType, this.env.scope.owner);\n+            varargRef = ASTBuilderUtil.createVariableRef(varargExpPos, varargVarSymbol);\n+\n+            BLangSimpleVariable var = createVariable(varargExpPos, varargVarName, varargVarType,\n+                                                     ((BLangRestArgsExpression) restArgs.get(restArgs.size() - 1)).expr,\n+                                                     varargVarSymbol);\n+\n+            BLangSimpleVariableDef varDef = ASTBuilderUtil.createVariableDef(varargExpPos);\n+            varDef.var = var;\n+            varDef.type = varargVarType;\n+\n+            blockStmt = createBlockStmt(varargExpPos);\n+            blockStmt.stmts.add(varDef);\n+        }\n+\n         if (!invokableSymbol.params.isEmpty()) {\n             // Re-order the arguments\n-            reorderNamedArgs(iExpr, invokableSymbol);\n+            reorderNamedArgs(iExpr, invokableSymbol, varargRef);\n         }\n \n-        if (invokableSymbol.restParam == null) {\n+        // There are no rest args at all or args for the rest param are only given as individual args (i.e., no vararg).\n+        if (restArgs.isEmpty() || restArgs.get(restArgs.size() - 1).getKind() != NodeKind.REST_ARGS_EXPR) {\n+            if (invokableSymbol.restParam == null) {\n+                return;\n+            }\n+\n+            BLangArrayLiteral arrayLiteral = (BLangArrayLiteral) TreeBuilder.createArrayLiteralExpressionNode();\n+            List<BLangExpression> exprs = new ArrayList<>();\n+\n+            BArrayType arrayType = (BArrayType) invokableSymbol.restParam.type;\n+            BType elemType = arrayType.eType;\n+\n+            for (BLangExpression restArg : restArgs) {\n+                exprs.add(addConversionExprIfRequired(restArg, elemType));\n+            }\n+\n+            arrayLiteral.exprs = exprs;\n+            arrayLiteral.type = arrayType;\n+            iExpr.restArgs = new ArrayList<>();\n+            iExpr.restArgs.add(arrayLiteral);\n             return;\n         }\n \n-        // Create an array out of all the rest arguments, and pass it as a single argument.\n-        // If there is only one optional argument and its type is restArg (i.e: ...x), then\n-        // leave it as is.\n-        if (iExpr.restArgs.size() == 1 && iExpr.restArgs.get(0).getKind() == NodeKind.REST_ARGS_EXPR) {\n+        // There are no individual rest args, but there is a single vararg.\n+        if (restArgs.size() == 1 && restArgs.get(0).getKind() == NodeKind.REST_ARGS_EXPR) {\n+\n+            // If the number of expressions in `iExpr.requiredArgs` hasn't changed, the vararg only contained\n+            // arguments for the rest parameter.\n+            if (iExpr.requiredArgs.size() == originalRequiredArgCount) {\n+                return;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3de0504b70b2f24c86cb079c3baca7e5f2e45cc"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDcwODQ5MA==", "bodyText": "Is it better to rename type to reflect it is actually the type of rest param?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22352#discussion_r404708490", "createdAt": "2020-04-07T10:36:48Z", "author": {"login": "KRVPerera"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java", "diffHunk": "@@ -5065,36 +5071,154 @@ private void reorderArguments(BLangInvocation iExpr) {\n         }\n \n         BInvokableSymbol invokableSymbol = (BInvokableSymbol) symbol;\n+\n+        List<BLangExpression> restArgs = iExpr.restArgs;\n+        int originalRequiredArgCount = iExpr.requiredArgs.size();\n+\n+        // Constructs used when the vararg provides args for required/defaultable params.\n+        BLangExpression varargRef = null;\n+        BLangBlockStmt blockStmt = null;\n+\n+        if (!iExpr.restArgs.isEmpty() &&\n+                restArgs.get(restArgs.size() - 1).getKind() == NodeKind.REST_ARGS_EXPR &&\n+                iExpr.requiredArgs.size() < invokableSymbol.params.size()) {\n+            // All or part of the args for the required and defaultable parameters are provided via the vararg.\n+            // We have to first evaluate the vararg's expression, define a variable, and pass a reference to it\n+            // to use for member access when adding such required arguments from the vararg.\n+            BLangExpression expr = ((BLangRestArgsExpression) restArgs.get(restArgs.size() - 1)).expr;\n+            DiagnosticPos varargExpPos = expr.pos;\n+            BType varargVarType = expr.type;\n+            String varargVarName = DESUGARED_VARARG_KEY + this.varargCount++;\n+\n+            BVarSymbol varargVarSymbol = new BVarSymbol(0, names.fromString(varargVarName), this.env.scope.owner.pkgID,\n+                                                        varargVarType, this.env.scope.owner);\n+            varargRef = ASTBuilderUtil.createVariableRef(varargExpPos, varargVarSymbol);\n+\n+            BLangSimpleVariable var = createVariable(varargExpPos, varargVarName, varargVarType,\n+                                                     ((BLangRestArgsExpression) restArgs.get(restArgs.size() - 1)).expr,\n+                                                     varargVarSymbol);\n+\n+            BLangSimpleVariableDef varDef = ASTBuilderUtil.createVariableDef(varargExpPos);\n+            varDef.var = var;\n+            varDef.type = varargVarType;\n+\n+            blockStmt = createBlockStmt(varargExpPos);\n+            blockStmt.stmts.add(varDef);\n+        }\n+\n         if (!invokableSymbol.params.isEmpty()) {\n             // Re-order the arguments\n-            reorderNamedArgs(iExpr, invokableSymbol);\n+            reorderNamedArgs(iExpr, invokableSymbol, varargRef);\n         }\n \n-        if (invokableSymbol.restParam == null) {\n+        // There are no rest args at all or args for the rest param are only given as individual args (i.e., no vararg).\n+        if (restArgs.isEmpty() || restArgs.get(restArgs.size() - 1).getKind() != NodeKind.REST_ARGS_EXPR) {\n+            if (invokableSymbol.restParam == null) {\n+                return;\n+            }\n+\n+            BLangArrayLiteral arrayLiteral = (BLangArrayLiteral) TreeBuilder.createArrayLiteralExpressionNode();\n+            List<BLangExpression> exprs = new ArrayList<>();\n+\n+            BArrayType arrayType = (BArrayType) invokableSymbol.restParam.type;\n+            BType elemType = arrayType.eType;\n+\n+            for (BLangExpression restArg : restArgs) {\n+                exprs.add(addConversionExprIfRequired(restArg, elemType));\n+            }\n+\n+            arrayLiteral.exprs = exprs;\n+            arrayLiteral.type = arrayType;\n+            iExpr.restArgs = new ArrayList<>();\n+            iExpr.restArgs.add(arrayLiteral);\n             return;\n         }\n \n-        // Create an array out of all the rest arguments, and pass it as a single argument.\n-        // If there is only one optional argument and its type is restArg (i.e: ...x), then\n-        // leave it as is.\n-        if (iExpr.restArgs.size() == 1 && iExpr.restArgs.get(0).getKind() == NodeKind.REST_ARGS_EXPR) {\n+        // There are no individual rest args, but there is a single vararg.\n+        if (restArgs.size() == 1 && restArgs.get(0).getKind() == NodeKind.REST_ARGS_EXPR) {\n+\n+            // If the number of expressions in `iExpr.requiredArgs` hasn't changed, the vararg only contained\n+            // arguments for the rest parameter.\n+            if (iExpr.requiredArgs.size() == originalRequiredArgCount) {\n+                return;\n+            }\n+\n+            // Args for some or all of the required/defaultable parameters have been provided via the vararg.\n+            // Remove the first required arg and add a statement expression instead.\n+            // The removed first arg is set as the expression and the vararg expression definition is set as\n+            // statement(s).\n+            BLangExpression firstNonRestArg = iExpr.requiredArgs.remove(0);\n+            BLangStatementExpression stmtExpression = createStatementExpression(blockStmt, firstNonRestArg);\n+            stmtExpression.type = firstNonRestArg.type;\n+            iExpr.requiredArgs.add(0, stmtExpression);\n+\n+            // The original value passed as the vararg has to now be sliced to pass only the args for the rest param,\n+            // if there is a rest param.\n+            if (invokableSymbol.restParam == null) {\n+                return;\n+            }\n+\n+            BLangLiteral startIndex = createIntLiteral(invokableSymbol.params.size() - originalRequiredArgCount);\n+            BLangInvocation sliceInvocation =\n+                    createLangLibInvocationNode(SLICE_LANGLIB_METHOD, varargRef,\n+                                                new ArrayList<BLangExpression>() {{\n+                                                    add(startIndex);\n+                                                }},\n+                                                varargRef.type, varargRef.pos);\n+            restArgs.remove(0);\n+            restArgs.add(addConversionExprIfRequired(sliceInvocation, invokableSymbol.restParam.type));\n             return;\n         }\n+\n+        // Now the `restArgs` list has both individual rest args and a vararg, all for the rest param.\n+        // We create a new array with the individual rest args and push the list passed as the vararg to it.\n+        BArrayType type = (BArrayType) invokableSymbol.restParam.type;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3de0504b70b2f24c86cb079c3baca7e5f2e45cc"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDcwODg4Mw==", "bodyText": "This can be arrayLiteral.exprs = new ArrayList<>();", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22352#discussion_r404708883", "createdAt": "2020-04-07T10:37:37Z", "author": {"login": "KRVPerera"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java", "diffHunk": "@@ -5065,36 +5071,154 @@ private void reorderArguments(BLangInvocation iExpr) {\n         }\n \n         BInvokableSymbol invokableSymbol = (BInvokableSymbol) symbol;\n+\n+        List<BLangExpression> restArgs = iExpr.restArgs;\n+        int originalRequiredArgCount = iExpr.requiredArgs.size();\n+\n+        // Constructs used when the vararg provides args for required/defaultable params.\n+        BLangExpression varargRef = null;\n+        BLangBlockStmt blockStmt = null;\n+\n+        if (!iExpr.restArgs.isEmpty() &&\n+                restArgs.get(restArgs.size() - 1).getKind() == NodeKind.REST_ARGS_EXPR &&\n+                iExpr.requiredArgs.size() < invokableSymbol.params.size()) {\n+            // All or part of the args for the required and defaultable parameters are provided via the vararg.\n+            // We have to first evaluate the vararg's expression, define a variable, and pass a reference to it\n+            // to use for member access when adding such required arguments from the vararg.\n+            BLangExpression expr = ((BLangRestArgsExpression) restArgs.get(restArgs.size() - 1)).expr;\n+            DiagnosticPos varargExpPos = expr.pos;\n+            BType varargVarType = expr.type;\n+            String varargVarName = DESUGARED_VARARG_KEY + this.varargCount++;\n+\n+            BVarSymbol varargVarSymbol = new BVarSymbol(0, names.fromString(varargVarName), this.env.scope.owner.pkgID,\n+                                                        varargVarType, this.env.scope.owner);\n+            varargRef = ASTBuilderUtil.createVariableRef(varargExpPos, varargVarSymbol);\n+\n+            BLangSimpleVariable var = createVariable(varargExpPos, varargVarName, varargVarType,\n+                                                     ((BLangRestArgsExpression) restArgs.get(restArgs.size() - 1)).expr,\n+                                                     varargVarSymbol);\n+\n+            BLangSimpleVariableDef varDef = ASTBuilderUtil.createVariableDef(varargExpPos);\n+            varDef.var = var;\n+            varDef.type = varargVarType;\n+\n+            blockStmt = createBlockStmt(varargExpPos);\n+            blockStmt.stmts.add(varDef);\n+        }\n+\n         if (!invokableSymbol.params.isEmpty()) {\n             // Re-order the arguments\n-            reorderNamedArgs(iExpr, invokableSymbol);\n+            reorderNamedArgs(iExpr, invokableSymbol, varargRef);\n         }\n \n-        if (invokableSymbol.restParam == null) {\n+        // There are no rest args at all or args for the rest param are only given as individual args (i.e., no vararg).\n+        if (restArgs.isEmpty() || restArgs.get(restArgs.size() - 1).getKind() != NodeKind.REST_ARGS_EXPR) {\n+            if (invokableSymbol.restParam == null) {\n+                return;\n+            }\n+\n+            BLangArrayLiteral arrayLiteral = (BLangArrayLiteral) TreeBuilder.createArrayLiteralExpressionNode();\n+            List<BLangExpression> exprs = new ArrayList<>();\n+\n+            BArrayType arrayType = (BArrayType) invokableSymbol.restParam.type;\n+            BType elemType = arrayType.eType;\n+\n+            for (BLangExpression restArg : restArgs) {\n+                exprs.add(addConversionExprIfRequired(restArg, elemType));\n+            }\n+\n+            arrayLiteral.exprs = exprs;\n+            arrayLiteral.type = arrayType;\n+            iExpr.restArgs = new ArrayList<>();\n+            iExpr.restArgs.add(arrayLiteral);\n             return;\n         }\n \n-        // Create an array out of all the rest arguments, and pass it as a single argument.\n-        // If there is only one optional argument and its type is restArg (i.e: ...x), then\n-        // leave it as is.\n-        if (iExpr.restArgs.size() == 1 && iExpr.restArgs.get(0).getKind() == NodeKind.REST_ARGS_EXPR) {\n+        // There are no individual rest args, but there is a single vararg.\n+        if (restArgs.size() == 1 && restArgs.get(0).getKind() == NodeKind.REST_ARGS_EXPR) {\n+\n+            // If the number of expressions in `iExpr.requiredArgs` hasn't changed, the vararg only contained\n+            // arguments for the rest parameter.\n+            if (iExpr.requiredArgs.size() == originalRequiredArgCount) {\n+                return;\n+            }\n+\n+            // Args for some or all of the required/defaultable parameters have been provided via the vararg.\n+            // Remove the first required arg and add a statement expression instead.\n+            // The removed first arg is set as the expression and the vararg expression definition is set as\n+            // statement(s).\n+            BLangExpression firstNonRestArg = iExpr.requiredArgs.remove(0);\n+            BLangStatementExpression stmtExpression = createStatementExpression(blockStmt, firstNonRestArg);\n+            stmtExpression.type = firstNonRestArg.type;\n+            iExpr.requiredArgs.add(0, stmtExpression);\n+\n+            // The original value passed as the vararg has to now be sliced to pass only the args for the rest param,\n+            // if there is a rest param.\n+            if (invokableSymbol.restParam == null) {\n+                return;\n+            }\n+\n+            BLangLiteral startIndex = createIntLiteral(invokableSymbol.params.size() - originalRequiredArgCount);\n+            BLangInvocation sliceInvocation =\n+                    createLangLibInvocationNode(SLICE_LANGLIB_METHOD, varargRef,\n+                                                new ArrayList<BLangExpression>() {{\n+                                                    add(startIndex);\n+                                                }},\n+                                                varargRef.type, varargRef.pos);\n+            restArgs.remove(0);\n+            restArgs.add(addConversionExprIfRequired(sliceInvocation, invokableSymbol.restParam.type));\n             return;\n         }\n+\n+        // Now the `restArgs` list has both individual rest args and a vararg, all for the rest param.\n+        // We create a new array with the individual rest args and push the list passed as the vararg to it.\n+        BArrayType type = (BArrayType) invokableSymbol.restParam.type;\n+\n         BLangArrayLiteral arrayLiteral = (BLangArrayLiteral) TreeBuilder.createArrayLiteralExpressionNode();\n-        arrayLiteral.type = invokableSymbol.restParam.type;\n+        arrayLiteral.type = type;\n \n-        BType elemType = ((BArrayType) arrayLiteral.type).eType;\n-        List<BLangExpression> rewrittenRestArgs = new ArrayList<>();\n-        for (BLangExpression restArg : iExpr.restArgs) {\n-            rewrittenRestArgs.add(addConversionExprIfRequired(restArg, elemType));\n+        BType elemType = type.eType;\n+        DiagnosticPos pos = restArgs.get(0).pos;\n+\n+        List<BLangExpression> exprs = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3de0504b70b2f24c86cb079c3baca7e5f2e45cc"}, "originalPosition": 151}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e80562179f469165cd2b9e337180cd96d4d03c01", "author": {"user": {"login": "MaryamZi", "name": "Maryam Ziyad"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e80562179f469165cd2b9e337180cd96d4d03c01", "committedDate": "2020-04-08T04:29:48Z", "message": "Resolve conflicts and Merge branch 'master' of https://github.com/ballerina-lang/ballerina into func-call-2"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9df5679cf9b5eabedf383b4ef1c3fb6c93470636", "author": {"user": {"login": "MaryamZi", "name": "Maryam Ziyad"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/9df5679cf9b5eabedf383b4ef1c3fb6c93470636", "committedDate": "2020-04-08T05:22:40Z", "message": "Refactor code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1d0df0403e6a320a308d82feee9f331e1d605f80", "author": {"user": {"login": "MaryamZi", "name": "Maryam Ziyad"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1d0df0403e6a320a308d82feee9f331e1d605f80", "committedDate": "2020-04-15T10:03:38Z", "message": "Merge branch 'master' of https://github.com/ballerina-lang/ballerina into func-call-2"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4b8a3d523d0f596e5a6067e0ea07e8253fd803d4", "author": {"user": {"login": "MaryamZi", "name": "Maryam Ziyad"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/4b8a3d523d0f596e5a6067e0ea07e8253fd803d4", "committedDate": "2020-04-16T06:50:28Z", "message": "Merge branch 'master' of https://github.com/ballerina-lang/ballerina into func-call-2"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1609879ebb86ab9f553ee0d2125f9691814ae161", "author": {"user": {"login": "MaryamZi", "name": "Maryam Ziyad"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1609879ebb86ab9f553ee0d2125f9691814ae161", "committedDate": "2020-04-16T09:23:48Z", "message": "Merge branch 'master' of https://github.com/ballerina-lang/ballerina into func-call-2"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b98967bf53d82219bfcd6c02bb45c193afab623f", "author": {"user": {"login": "MaryamZi", "name": "Maryam Ziyad"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b98967bf53d82219bfcd6c02bb45c193afab623f", "committedDate": "2020-04-16T09:52:50Z", "message": "Fix bstring unit tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwODg3Mjc0", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22352#pullrequestreview-400887274", "createdAt": "2020-04-27T12:07:02Z", "commit": {"oid": "b98967bf53d82219bfcd6c02bb45c193afab623f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4119, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}