{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDUzMDU0MjY1", "number": 24838, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwNTowMzoxMlrOEP9eXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QwOTowNTo1MlrOERXZ1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1MTcxMjkzOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/DocumentationLexer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwNTowMzoxMlrOGz4Tpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwNToxNzo0M1rOGz4tAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzA1MzA5NA==", "bodyText": "do we inject parser diagnostic to the compiler diagnostic somewhere? or two APIs act independently?\nright now I log a warning for this in the node transformer as well.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24838#discussion_r457053094", "createdAt": "2020-07-20T05:03:12Z", "author": {"login": "lochana-chathura"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/DocumentationLexer.java", "diffHunk": "@@ -669,23 +702,79 @@ private STToken readDocumentationBacktickContentToken() {\n         if (nextToken == LexerTerminals.BACKTICK) {\n             reader.advance();\n             switchMode(ParserMode.DOCUMENTATION_INTERNAL);\n+            resetSpecialKeywordInPlace();\n             return getDocumentationSyntaxTokenWithNoTrivia(SyntaxKind.BACKTICK_TOKEN);\n         }\n \n+        int lookAheadCount = 0;\n+        String backtickStr = \"\";\n         while (!reader.isEOF()) {\n             switch (nextToken) {\n                 case LexerTerminals.BACKTICK:\n                 case LexerTerminals.NEWLINE:\n                 case LexerTerminals.CARRIAGE_RETURN:\n                     break;\n                 default:\n-                    reader.advance();\n-                    nextToken = peek();\n+                    backtickStr = backtickStr.concat(String.valueOf((char) nextToken));\n+                    lookAheadCount++;\n+                    nextToken = reader.peek(lookAheadCount);\n                     continue;\n             }\n             break;\n         }\n \n-        return getDocumentationLiteral(SyntaxKind.BACKTICK_CONTENT);\n+        if (!isSpecialKeywordInPlace) {\n+            // Look for a x(), m:x(), T.y(), m:T.y() match\n+            boolean hasMatch = backtickStr.matches(backtickExprRegex);\n+            if (hasMatch) {\n+                switchMode(ParserMode.DOCUMENTATION_BACKTICK_EXPR);\n+                return readDocumentationBacktickExprToken();\n+            } else {\n+                reportLexerError(DiagnosticWarningCode.WARNING_INVALID_DOCUMENTATION_EXPRESSION);\n+                reader.advance(lookAheadCount);\n+                return getDocumentationLiteral(SyntaxKind.BACKTICK_CONTENT);\n+            }\n+        }\n+\n+        reader.advance(lookAheadCount);\n+        resetSpecialKeywordInPlace();\n+\n+        boolean isIdentifier = backtickStr.matches(identifierRegex);\n+        if (isIdentifier) {\n+            return getIdentifierToken();\n+        } else {\n+            reportLexerError(DiagnosticWarningCode.WARNING_INVALID_DOCUMENTATION_IDENTIFIER);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e2cb44e514f316b9221a763b0158a5b233c5a75"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzA1OTU4Nw==", "bodyText": "Yes, we add all the parser errors to the compiler-diagnostics at the Parser.java class", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24838#discussion_r457059587", "createdAt": "2020-07-20T05:17:43Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/DocumentationLexer.java", "diffHunk": "@@ -669,23 +702,79 @@ private STToken readDocumentationBacktickContentToken() {\n         if (nextToken == LexerTerminals.BACKTICK) {\n             reader.advance();\n             switchMode(ParserMode.DOCUMENTATION_INTERNAL);\n+            resetSpecialKeywordInPlace();\n             return getDocumentationSyntaxTokenWithNoTrivia(SyntaxKind.BACKTICK_TOKEN);\n         }\n \n+        int lookAheadCount = 0;\n+        String backtickStr = \"\";\n         while (!reader.isEOF()) {\n             switch (nextToken) {\n                 case LexerTerminals.BACKTICK:\n                 case LexerTerminals.NEWLINE:\n                 case LexerTerminals.CARRIAGE_RETURN:\n                     break;\n                 default:\n-                    reader.advance();\n-                    nextToken = peek();\n+                    backtickStr = backtickStr.concat(String.valueOf((char) nextToken));\n+                    lookAheadCount++;\n+                    nextToken = reader.peek(lookAheadCount);\n                     continue;\n             }\n             break;\n         }\n \n-        return getDocumentationLiteral(SyntaxKind.BACKTICK_CONTENT);\n+        if (!isSpecialKeywordInPlace) {\n+            // Look for a x(), m:x(), T.y(), m:T.y() match\n+            boolean hasMatch = backtickStr.matches(backtickExprRegex);\n+            if (hasMatch) {\n+                switchMode(ParserMode.DOCUMENTATION_BACKTICK_EXPR);\n+                return readDocumentationBacktickExprToken();\n+            } else {\n+                reportLexerError(DiagnosticWarningCode.WARNING_INVALID_DOCUMENTATION_EXPRESSION);\n+                reader.advance(lookAheadCount);\n+                return getDocumentationLiteral(SyntaxKind.BACKTICK_CONTENT);\n+            }\n+        }\n+\n+        reader.advance(lookAheadCount);\n+        resetSpecialKeywordInPlace();\n+\n+        boolean isIdentifier = backtickStr.matches(identifierRegex);\n+        if (isIdentifier) {\n+            return getIdentifierToken();\n+        } else {\n+            reportLexerError(DiagnosticWarningCode.WARNING_INVALID_DOCUMENTATION_IDENTIFIER);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzA1MzA5NA=="}, "originalCommit": {"oid": "1e2cb44e514f316b9221a763b0158a5b233c5a75"}, "originalPosition": 132}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1MTgwNjgwOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/DocumentationLexer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwNTozMTo1NVrOGz5Ffg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwNTozMTo1NVrOGz5Ffg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzA2NTg1NA==", "bodyText": "Shall we use our own method to visit the characters and do this validation?\nRegex-matching can be expensive. I think if we remove that regex, way we can also avoid Line#718 (string concat) which is also a bit expensive.\nUsually numeric operations are much faster compared to string operations. eg: (int/char comparison vs string compare, array-access vs map-access)", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24838#discussion_r457065854", "createdAt": "2020-07-20T05:31:55Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/DocumentationLexer.java", "diffHunk": "@@ -669,23 +702,79 @@ private STToken readDocumentationBacktickContentToken() {\n         if (nextToken == LexerTerminals.BACKTICK) {\n             reader.advance();\n             switchMode(ParserMode.DOCUMENTATION_INTERNAL);\n+            resetSpecialKeywordInPlace();\n             return getDocumentationSyntaxTokenWithNoTrivia(SyntaxKind.BACKTICK_TOKEN);\n         }\n \n+        int lookAheadCount = 0;\n+        String backtickStr = \"\";\n         while (!reader.isEOF()) {\n             switch (nextToken) {\n                 case LexerTerminals.BACKTICK:\n                 case LexerTerminals.NEWLINE:\n                 case LexerTerminals.CARRIAGE_RETURN:\n                     break;\n                 default:\n-                    reader.advance();\n-                    nextToken = peek();\n+                    backtickStr = backtickStr.concat(String.valueOf((char) nextToken));\n+                    lookAheadCount++;\n+                    nextToken = reader.peek(lookAheadCount);\n                     continue;\n             }\n             break;\n         }\n \n-        return getDocumentationLiteral(SyntaxKind.BACKTICK_CONTENT);\n+        if (!isSpecialKeywordInPlace) {\n+            // Look for a x(), m:x(), T.y(), m:T.y() match\n+            boolean hasMatch = backtickStr.matches(backtickExprRegex);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e2cb44e514f316b9221a763b0158a5b233c5a75"}, "originalPosition": 114}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1MTgyODU0OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/parser/BLangNodeTransformer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwNTozODoxN1rOGz5Q-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwNTozODoxN1rOGz5Q-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzA2ODc5NQ==", "bodyText": "Shall we return the normal-positions if there are no metadata?\nReason is, theres a plan for making metadata optional in the syntax tree.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24838#discussion_r457068795", "createdAt": "2020-07-20T05:38:17Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/parser/BLangNodeTransformer.java", "diffHunk": "@@ -456,6 +459,24 @@ private DiagnosticPos getPosition(Node node) {\n                 endPos.offset() + 1);\n     }\n \n+    private DiagnosticPos getPositionWithoutMetadata(Node node) {\n+        if (node == null) {\n+            return null;\n+        }\n+        NonTerminalNode nonTerminalNode = (NonTerminalNode) node;\n+        ChildNodeList children = nonTerminalNode.children();\n+        // If there's metadata it will be the first child.\n+        // Hence set start position from next immediate child.\n+        if (children.get(0).kind() == SyntaxKind.METADATA) {\n+            LinePosition startPos = children.get(1).lineRange().startLine();\n+            LinePosition endPos = node.lineRange().endLine();\n+            return new DiagnosticPos(diagnosticSource, startPos.line() + 1, endPos.line() + 1, startPos.offset() + 1,\n+                    endPos.offset() + 1);\n+        } else {\n+            throw new IllegalArgumentException(\"Node should have metadata\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e2cb44e514f316b9221a763b0158a5b233c5a75"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1MTg0NjQxOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/parser/BLangNodeTransformer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwNTo0Mzo0NFrOGz5aqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwNTo0Mzo0NFrOGz5aqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzA3MTI3Mg==", "bodyText": "can take !referenceType.isPresent() condition out, as its common for both conditions.\nAlso would be good to extract this content to a separate method?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24838#discussion_r457071272", "createdAt": "2020-07-20T05:43:44Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/parser/BLangNodeTransformer.java", "diffHunk": "@@ -4258,26 +4303,69 @@ private String addReferencesAndReturnDocumentationText(LinkedList<BLangMarkdownR\n                 BLangMarkdownReferenceDocumentation bLangRefDoc = new BLangMarkdownReferenceDocumentation();\n                 DocumentationReferenceNode docReferenceNode = (DocumentationReferenceNode) element;\n \n+                DiagnosticPos pos = getPosition(docReferenceNode);\n+                bLangRefDoc.pos = pos;\n+\n+                Token startBacktick = docReferenceNode.startBacktick();\n+                Node backtickContent = docReferenceNode.backtickContent();\n+                Token endBacktick = docReferenceNode.endBacktick();\n+\n+                String contentString = backtickContent.isMissing() ? \"\" : backtickContent.toString();\n+                bLangRefDoc.referenceName = contentString;\n+\n                 bLangRefDoc.type = DocumentationReferenceType.BACKTICK_CONTENT;\n-                docReferenceNode.referenceType().ifPresent(\n+                Optional<Token> referenceType = docReferenceNode.referenceType();\n+                referenceType.ifPresent(\n                         refType -> {\n                             bLangRefDoc.type = stringToRefType(refType.text());\n+                            if (backtickContent.kind() == SyntaxKind.BACKTICK_CONTENT) {\n+                                // backtick content preceded by a special keyword, should be an identifier\n+                                bLangRefDoc.hasParserWarnings = true;\n+                                dlog.warning(pos, DiagnosticCode.INVALID_DOCUMENTATION_IDENTIFIER, contentString);\n+                            } else {\n+                                bLangRefDoc.identifier = ((Token) backtickContent).text();\n+                            }\n                             docText.append(refType.toString());\n                         }\n                 );\n \n-                Token startBacktick = docReferenceNode.startBacktick();\n-                docText.append(startBacktick.isMissing() ? \"\" : startBacktick.text());\n+                if (!referenceType.isPresent() && backtickContent.kind() == SyntaxKind.BACKTICK_CONTENT) {\n+                    // reaching here means, backtick content is not in one of x(), m:x(), T.y(), m:T.y() formats\n+                    // no warning is logged for this case\n+                    bLangRefDoc.hasParserWarnings = true;\n+                }\n \n-                Token backtickContent = docReferenceNode.backtickContent();\n-                String contentString = backtickContent.isMissing() ? \"\" : backtickContent.text();\n-                bLangRefDoc.referenceName = contentString;\n-                docText.append(contentString);\n+                if (!referenceType.isPresent() && backtickContent.kind() != SyntaxKind.BACKTICK_CONTENT) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e2cb44e514f316b9221a763b0158a5b233c5a75"}, "originalPosition": 218}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1MTg2MDgxOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/parser/BLangNodeTransformer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwNTo0NzozOFrOGz5iHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwNTo0NzozOFrOGz5iHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzA3MzE4MA==", "bodyText": "I think we can remove this warning, since all parser errors (should) get added to compiler diagnostics.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24838#discussion_r457073180", "createdAt": "2020-07-20T05:47:38Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/parser/BLangNodeTransformer.java", "diffHunk": "@@ -4258,26 +4303,69 @@ private String addReferencesAndReturnDocumentationText(LinkedList<BLangMarkdownR\n                 BLangMarkdownReferenceDocumentation bLangRefDoc = new BLangMarkdownReferenceDocumentation();\n                 DocumentationReferenceNode docReferenceNode = (DocumentationReferenceNode) element;\n \n+                DiagnosticPos pos = getPosition(docReferenceNode);\n+                bLangRefDoc.pos = pos;\n+\n+                Token startBacktick = docReferenceNode.startBacktick();\n+                Node backtickContent = docReferenceNode.backtickContent();\n+                Token endBacktick = docReferenceNode.endBacktick();\n+\n+                String contentString = backtickContent.isMissing() ? \"\" : backtickContent.toString();\n+                bLangRefDoc.referenceName = contentString;\n+\n                 bLangRefDoc.type = DocumentationReferenceType.BACKTICK_CONTENT;\n-                docReferenceNode.referenceType().ifPresent(\n+                Optional<Token> referenceType = docReferenceNode.referenceType();\n+                referenceType.ifPresent(\n                         refType -> {\n                             bLangRefDoc.type = stringToRefType(refType.text());\n+                            if (backtickContent.kind() == SyntaxKind.BACKTICK_CONTENT) {\n+                                // backtick content preceded by a special keyword, should be an identifier\n+                                bLangRefDoc.hasParserWarnings = true;\n+                                dlog.warning(pos, DiagnosticCode.INVALID_DOCUMENTATION_IDENTIFIER, contentString);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e2cb44e514f316b9221a763b0158a5b233c5a75"}, "originalPosition": 198}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1MTg4ODkwOnYy", "diffSide": "RIGHT", "path": "stdlib/mime/src/main/ballerina/src/mime/natives.bal", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwNTo1NToxNlrOGz5xEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxNjoxOToxNlrOG1p-0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzA3NzAwOQ==", "bodyText": "shouldn't this be allowed?\ni.e:\n# some text followed by type `M:X`\n\nSpec says \"if it is a qualified name M:X, then the source file must have imported M, and X must refer to a public name of an appropriate type in M\"", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24838#discussion_r457077009", "createdAt": "2020-07-20T05:55:16Z", "author": {"login": "SupunS"}, "path": "stdlib/mime/src/main/ballerina/src/mime/natives.bal", "diffHunk": "@@ -620,7 +620,7 @@ function externHasHeader(Entity entity, string headerName, HeaderPosition positi\n # + contentToBeEncoded - Content that needs to be encoded can be of type `string`, `byte[]` or `io:ReadableByteChannel`\n # + charset - Charset to be used. This is used only with the string input\n # + return - An encoded `string` if the given input is of type string, an encoded `byte[]` if the given input is of\n-#            type byte[], an encoded `io:ReadableByteChannel` if the given input is of type `io:ReadableByteChannel`,\n+#            type byte[], an encoded `io:ReadableByteChannel` if the given input is of type ``io:ReadableByteChannel``,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e2cb44e514f316b9221a763b0158a5b233c5a75"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODU3MTk3NA==", "bodyText": "this fix was added with fac6140.\nseems we have to make an exception for function keyword.\nSpec says,\nBFM also recognizes `f()` as an alternative to function `f`. In both cases, f can have any of the following forms\nx(), m:x(), T.y(), m:T.y()\nso for function keyword, all together 6 formats(x, m:x, x(), m:x(), T.y(), m:T.y()) should be allowed right?\nthere were no jballerina-unit-tests for that though", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24838#discussion_r458571974", "createdAt": "2020-07-22T06:50:30Z", "author": {"login": "lochana-chathura"}, "path": "stdlib/mime/src/main/ballerina/src/mime/natives.bal", "diffHunk": "@@ -620,7 +620,7 @@ function externHasHeader(Entity entity, string headerName, HeaderPosition positi\n # + contentToBeEncoded - Content that needs to be encoded can be of type `string`, `byte[]` or `io:ReadableByteChannel`\n # + charset - Charset to be used. This is used only with the string input\n # + return - An encoded `string` if the given input is of type string, an encoded `byte[]` if the given input is of\n-#            type byte[], an encoded `io:ReadableByteChannel` if the given input is of type `io:ReadableByteChannel`,\n+#            type byte[], an encoded `io:ReadableByteChannel` if the given input is of type ``io:ReadableByteChannel``,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzA3NzAwOQ=="}, "originalCommit": {"oid": "1e2cb44e514f316b9221a763b0158a5b233c5a75"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODkxNTUzNg==", "bodyText": "yea, thats correct.\nWe can add some parser test - that would be sufficient.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24838#discussion_r458915536", "createdAt": "2020-07-22T16:19:16Z", "author": {"login": "SupunS"}, "path": "stdlib/mime/src/main/ballerina/src/mime/natives.bal", "diffHunk": "@@ -620,7 +620,7 @@ function externHasHeader(Entity entity, string headerName, HeaderPosition positi\n # + contentToBeEncoded - Content that needs to be encoded can be of type `string`, `byte[]` or `io:ReadableByteChannel`\n # + charset - Charset to be used. This is used only with the string input\n # + return - An encoded `string` if the given input is of type string, an encoded `byte[]` if the given input is of\n-#            type byte[], an encoded `io:ReadableByteChannel` if the given input is of type `io:ReadableByteChannel`,\n+#            type byte[], an encoded `io:ReadableByteChannel` if the given input is of type ``io:ReadableByteChannel``,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzA3NzAwOQ=="}, "originalCommit": {"oid": "1e2cb44e514f316b9221a763b0158a5b233c5a75"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2NTc4ODM1OnYy", "diffSide": "RIGHT", "path": "tests/jballerina-unit-test/src/test/java/org/ballerinalang/test/documentation/MarkdownDocumentationTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QwNDo1MzoxNlrOG18LGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QwOTowNDoyNFrOG2CIgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIxMzU5Mg==", "bodyText": "In case of invalid backtick content, earlier position was given as the start position of doc ref. Now it is directly pointed at the backtick content.\ne.g.\nFor, # service `9invalidServ` \n\nearlier position: warn column 3\nnew position: warn column 12", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24838#discussion_r459213592", "createdAt": "2020-07-23T04:53:16Z", "author": {"login": "lochana-chathura"}, "path": "tests/jballerina-unit-test/src/test/java/org/ballerinalang/test/documentation/MarkdownDocumentationTest.java", "diffHunk": "@@ -340,7 +340,7 @@ public void testDocumentationNegative() {\n         BAssertUtil.validateWarning(compileResult, index++, \"no documentable return parameter\", 11, 1);\n         BAssertUtil.validateWarning(compileResult, index++, \"undocumented field 'cd'\", 15, 5);\n         BAssertUtil.validateWarning(compileResult, index++,\n-                \"invalid identifier in documentation reference '9invalidServ'\", 21, 3);\n+                \"invalid identifier in documentation reference '9invalidServ'\", 21, 12);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a4568b25640b53b6629b36730c00e32c99f63436"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTMxMTIzMw==", "bodyText": "thats great!", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24838#discussion_r459311233", "createdAt": "2020-07-23T09:04:24Z", "author": {"login": "SupunS"}, "path": "tests/jballerina-unit-test/src/test/java/org/ballerinalang/test/documentation/MarkdownDocumentationTest.java", "diffHunk": "@@ -340,7 +340,7 @@ public void testDocumentationNegative() {\n         BAssertUtil.validateWarning(compileResult, index++, \"no documentable return parameter\", 11, 1);\n         BAssertUtil.validateWarning(compileResult, index++, \"undocumented field 'cd'\", 15, 5);\n         BAssertUtil.validateWarning(compileResult, index++,\n-                \"invalid identifier in documentation reference '9invalidServ'\", 21, 3);\n+                \"invalid identifier in documentation reference '9invalidServ'\", 21, 12);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIxMzU5Mg=="}, "originalCommit": {"oid": "a4568b25640b53b6629b36730c00e32c99f63436"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2NjQ0Njk1OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/parser/Parser.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QwOTowNTo1M1rOG2CLow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QwOTowNTo1M1rOG2CLow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTMxMjAzNQ==", "bodyText": "can doo == for equal check", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24838#discussion_r459312035", "createdAt": "2020-07-23T09:05:53Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/parser/Parser.java", "diffHunk": "@@ -268,8 +269,16 @@ private void reportSyntaxDiagnostics(BDiagnosticSource diagnosticSource, SyntaxT\n \n             // TODO This is the temporary mechanism\n             // We need to merge the diagnostic reporting mechanisms of the new parser and the semantic analyzer\n-            DiagnosticCode code = DiagnosticCode.SYNTAX_ERROR;\n-            dlog.error(pos, code, syntaxDiagnostic.message());\n+            DiagnosticCode code;\n+\n+            DiagnosticSeverity severity = syntaxDiagnostic.diagnosticInfo().severity();\n+            if (DiagnosticSeverity.WARNING.equals(severity)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a4568b25640b53b6629b36730c00e32c99f63436"}, "originalPosition": 17}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 408, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}