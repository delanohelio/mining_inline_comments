{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDgyNjIzOTY5", "number": 25680, "reviewThreads": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxMjoyOToyNlrOEiF37g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNzo1NzoxN1rOEio1nA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0MTgzMjc4OnYy", "diffSide": "RIGHT", "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/FormatterUtils.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxMjoyOToyNlrOHPxK2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwNDowMjoxN1rOHQNfSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjI5NjI4MQ==", "bodyText": "We could use a switch-case in-place of the if-else. It can nicely handle these multiple matches as well.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25680#discussion_r486296281", "createdAt": "2020-09-10T12:29:26Z", "author": {"login": "SupunS"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/FormatterUtils.java", "diffHunk": "@@ -0,0 +1,230 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.core;\n+\n+import io.ballerina.tools.text.LinePosition;\n+import io.ballerina.tools.text.LineRange;\n+import io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory;\n+import io.ballerinalang.compiler.syntax.tree.Minutiae;\n+import io.ballerinalang.compiler.syntax.tree.MinutiaeList;\n+import io.ballerinalang.compiler.syntax.tree.Node;\n+import io.ballerinalang.compiler.syntax.tree.SyntaxKind;\n+import io.ballerinalang.compiler.syntax.tree.Token;\n+import org.wso2.ballerinalang.compiler.util.diagnotic.DiagnosticPos;\n+\n+import static io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory.createMinutiaeList;\n+import static io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory.createWhitespaceMinutiae;\n+\n+/**\n+ * Class that contains the util functions used by the formatting tree modifier.\n+ */\n+class FormatterUtils {\n+\n+    /**\n+     * Get the node position.\n+     *\n+     * @param node node\n+     * @return node position\n+     */\n+    static DiagnosticPos getPosition(Node node) {\n+        if (node == null) {\n+            return null;\n+        }\n+        LineRange range = node.lineRange();\n+        LinePosition startPos = range.startLine();\n+        LinePosition endPos = range.endLine();\n+        int startOffset = startPos.offset();\n+        if (node.kind().equals(SyntaxKind.FUNCTION_DEFINITION) || node.kind().equals(SyntaxKind.TYPE_DEFINITION) ||\n+                node.kind().equals(SyntaxKind.CONST_DECLARATION)) {\n+            startOffset = (startOffset / 4) * 4;\n+        }\n+        return new DiagnosticPos(null, startPos.line() + 1, endPos.line() + 1,\n+                startOffset, endPos.offset());\n+    }\n+\n+    // TODO: Use a generic way to get the parent node using querying.\n+    static <T extends Node> Node getParent(T node, SyntaxKind syntaxKind) {\n+        Node parent = node.parent();\n+        if (parent == null) {\n+            parent = node;\n+        }\n+        SyntaxKind parentKind = parent.kind();\n+        if (parentKind == SyntaxKind.MODULE_VAR_DECL) {\n+            if (parent.parent() != null && parent.parent().kind() == SyntaxKind.MODULE_PART &&\n+                    syntaxKind == SyntaxKind.QUALIFIED_NAME_REFERENCE) {\n+                return null;\n+            }\n+            return parent;\n+        } else if (parentKind == SyntaxKind.FUNCTION_DEFINITION ||\n+                parentKind == SyntaxKind.IF_ELSE_STATEMENT ||\n+                parentKind == SyntaxKind.ELSE_BLOCK ||\n+                parentKind == SyntaxKind.WHILE_STATEMENT ||\n+                parentKind == SyntaxKind.CONST_DECLARATION ||\n+                parentKind == SyntaxKind.METHOD_DECLARATION ||\n+                parentKind == SyntaxKind.TYPE_DEFINITION) {\n+            return parent;\n+        } else if (syntaxKind == SyntaxKind.SIMPLE_NAME_REFERENCE) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d7c8311da6403c402327513c87a6e040a6db4ce6"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc2MDI2NQ==", "bodyText": "Thanks for the input, planning on refactoring and simplifying the logic separately in a different PR.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25680#discussion_r486760265", "createdAt": "2020-09-11T04:02:17Z", "author": {"login": "IrushiL"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/FormatterUtils.java", "diffHunk": "@@ -0,0 +1,230 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.core;\n+\n+import io.ballerina.tools.text.LinePosition;\n+import io.ballerina.tools.text.LineRange;\n+import io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory;\n+import io.ballerinalang.compiler.syntax.tree.Minutiae;\n+import io.ballerinalang.compiler.syntax.tree.MinutiaeList;\n+import io.ballerinalang.compiler.syntax.tree.Node;\n+import io.ballerinalang.compiler.syntax.tree.SyntaxKind;\n+import io.ballerinalang.compiler.syntax.tree.Token;\n+import org.wso2.ballerinalang.compiler.util.diagnotic.DiagnosticPos;\n+\n+import static io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory.createMinutiaeList;\n+import static io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory.createWhitespaceMinutiae;\n+\n+/**\n+ * Class that contains the util functions used by the formatting tree modifier.\n+ */\n+class FormatterUtils {\n+\n+    /**\n+     * Get the node position.\n+     *\n+     * @param node node\n+     * @return node position\n+     */\n+    static DiagnosticPos getPosition(Node node) {\n+        if (node == null) {\n+            return null;\n+        }\n+        LineRange range = node.lineRange();\n+        LinePosition startPos = range.startLine();\n+        LinePosition endPos = range.endLine();\n+        int startOffset = startPos.offset();\n+        if (node.kind().equals(SyntaxKind.FUNCTION_DEFINITION) || node.kind().equals(SyntaxKind.TYPE_DEFINITION) ||\n+                node.kind().equals(SyntaxKind.CONST_DECLARATION)) {\n+            startOffset = (startOffset / 4) * 4;\n+        }\n+        return new DiagnosticPos(null, startPos.line() + 1, endPos.line() + 1,\n+                startOffset, endPos.offset());\n+    }\n+\n+    // TODO: Use a generic way to get the parent node using querying.\n+    static <T extends Node> Node getParent(T node, SyntaxKind syntaxKind) {\n+        Node parent = node.parent();\n+        if (parent == null) {\n+            parent = node;\n+        }\n+        SyntaxKind parentKind = parent.kind();\n+        if (parentKind == SyntaxKind.MODULE_VAR_DECL) {\n+            if (parent.parent() != null && parent.parent().kind() == SyntaxKind.MODULE_PART &&\n+                    syntaxKind == SyntaxKind.QUALIFIED_NAME_REFERENCE) {\n+                return null;\n+            }\n+            return parent;\n+        } else if (parentKind == SyntaxKind.FUNCTION_DEFINITION ||\n+                parentKind == SyntaxKind.IF_ELSE_STATEMENT ||\n+                parentKind == SyntaxKind.ELSE_BLOCK ||\n+                parentKind == SyntaxKind.WHILE_STATEMENT ||\n+                parentKind == SyntaxKind.CONST_DECLARATION ||\n+                parentKind == SyntaxKind.METHOD_DECLARATION ||\n+                parentKind == SyntaxKind.TYPE_DEFINITION) {\n+            return parent;\n+        } else if (syntaxKind == SyntaxKind.SIMPLE_NAME_REFERENCE) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjI5NjI4MQ=="}, "originalCommit": {"oid": "d7c8311da6403c402327513c87a6e040a6db4ce6"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0MTgzODE2OnYy", "diffSide": "RIGHT", "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/FormatterUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxMjozMDo0M1rOHPxN9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwMzo1Nzo1M1rOHQNa9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjI5NzA3OA==", "bodyText": "since parent.parent() is used multiple times within the function, we can extract it to a variable", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25680#discussion_r486297078", "createdAt": "2020-09-10T12:30:43Z", "author": {"login": "SupunS"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/FormatterUtils.java", "diffHunk": "@@ -0,0 +1,230 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.core;\n+\n+import io.ballerina.tools.text.LinePosition;\n+import io.ballerina.tools.text.LineRange;\n+import io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory;\n+import io.ballerinalang.compiler.syntax.tree.Minutiae;\n+import io.ballerinalang.compiler.syntax.tree.MinutiaeList;\n+import io.ballerinalang.compiler.syntax.tree.Node;\n+import io.ballerinalang.compiler.syntax.tree.SyntaxKind;\n+import io.ballerinalang.compiler.syntax.tree.Token;\n+import org.wso2.ballerinalang.compiler.util.diagnotic.DiagnosticPos;\n+\n+import static io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory.createMinutiaeList;\n+import static io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory.createWhitespaceMinutiae;\n+\n+/**\n+ * Class that contains the util functions used by the formatting tree modifier.\n+ */\n+class FormatterUtils {\n+\n+    /**\n+     * Get the node position.\n+     *\n+     * @param node node\n+     * @return node position\n+     */\n+    static DiagnosticPos getPosition(Node node) {\n+        if (node == null) {\n+            return null;\n+        }\n+        LineRange range = node.lineRange();\n+        LinePosition startPos = range.startLine();\n+        LinePosition endPos = range.endLine();\n+        int startOffset = startPos.offset();\n+        if (node.kind().equals(SyntaxKind.FUNCTION_DEFINITION) || node.kind().equals(SyntaxKind.TYPE_DEFINITION) ||\n+                node.kind().equals(SyntaxKind.CONST_DECLARATION)) {\n+            startOffset = (startOffset / 4) * 4;\n+        }\n+        return new DiagnosticPos(null, startPos.line() + 1, endPos.line() + 1,\n+                startOffset, endPos.offset());\n+    }\n+\n+    // TODO: Use a generic way to get the parent node using querying.\n+    static <T extends Node> Node getParent(T node, SyntaxKind syntaxKind) {\n+        Node parent = node.parent();\n+        if (parent == null) {\n+            parent = node;\n+        }\n+        SyntaxKind parentKind = parent.kind();\n+        if (parentKind == SyntaxKind.MODULE_VAR_DECL) {\n+            if (parent.parent() != null && parent.parent().kind() == SyntaxKind.MODULE_PART &&", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d7c8311da6403c402327513c87a6e040a6db4ce6"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc1OTE1OA==", "bodyText": "Fixed.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25680#discussion_r486759158", "createdAt": "2020-09-11T03:57:53Z", "author": {"login": "IrushiL"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/FormatterUtils.java", "diffHunk": "@@ -0,0 +1,230 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.core;\n+\n+import io.ballerina.tools.text.LinePosition;\n+import io.ballerina.tools.text.LineRange;\n+import io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory;\n+import io.ballerinalang.compiler.syntax.tree.Minutiae;\n+import io.ballerinalang.compiler.syntax.tree.MinutiaeList;\n+import io.ballerinalang.compiler.syntax.tree.Node;\n+import io.ballerinalang.compiler.syntax.tree.SyntaxKind;\n+import io.ballerinalang.compiler.syntax.tree.Token;\n+import org.wso2.ballerinalang.compiler.util.diagnotic.DiagnosticPos;\n+\n+import static io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory.createMinutiaeList;\n+import static io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory.createWhitespaceMinutiae;\n+\n+/**\n+ * Class that contains the util functions used by the formatting tree modifier.\n+ */\n+class FormatterUtils {\n+\n+    /**\n+     * Get the node position.\n+     *\n+     * @param node node\n+     * @return node position\n+     */\n+    static DiagnosticPos getPosition(Node node) {\n+        if (node == null) {\n+            return null;\n+        }\n+        LineRange range = node.lineRange();\n+        LinePosition startPos = range.startLine();\n+        LinePosition endPos = range.endLine();\n+        int startOffset = startPos.offset();\n+        if (node.kind().equals(SyntaxKind.FUNCTION_DEFINITION) || node.kind().equals(SyntaxKind.TYPE_DEFINITION) ||\n+                node.kind().equals(SyntaxKind.CONST_DECLARATION)) {\n+            startOffset = (startOffset / 4) * 4;\n+        }\n+        return new DiagnosticPos(null, startPos.line() + 1, endPos.line() + 1,\n+                startOffset, endPos.offset());\n+    }\n+\n+    // TODO: Use a generic way to get the parent node using querying.\n+    static <T extends Node> Node getParent(T node, SyntaxKind syntaxKind) {\n+        Node parent = node.parent();\n+        if (parent == null) {\n+            parent = node;\n+        }\n+        SyntaxKind parentKind = parent.kind();\n+        if (parentKind == SyntaxKind.MODULE_VAR_DECL) {\n+            if (parent.parent() != null && parent.parent().kind() == SyntaxKind.MODULE_PART &&", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjI5NzA3OA=="}, "originalCommit": {"oid": "d7c8311da6403c402327513c87a6e040a6db4ce6"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0MTg0MTQ2OnYy", "diffSide": "RIGHT", "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/FormatterUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxMjozMTo0MVrOHPxQEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwMzo1ODowNlrOHQNbPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjI5NzYxOA==", "bodyText": "Shall we we use == instead of .equals()?\nLets fix in all places.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25680#discussion_r486297618", "createdAt": "2020-09-10T12:31:41Z", "author": {"login": "SupunS"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/FormatterUtils.java", "diffHunk": "@@ -0,0 +1,230 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.core;\n+\n+import io.ballerina.tools.text.LinePosition;\n+import io.ballerina.tools.text.LineRange;\n+import io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory;\n+import io.ballerinalang.compiler.syntax.tree.Minutiae;\n+import io.ballerinalang.compiler.syntax.tree.MinutiaeList;\n+import io.ballerinalang.compiler.syntax.tree.Node;\n+import io.ballerinalang.compiler.syntax.tree.SyntaxKind;\n+import io.ballerinalang.compiler.syntax.tree.Token;\n+import org.wso2.ballerinalang.compiler.util.diagnotic.DiagnosticPos;\n+\n+import static io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory.createMinutiaeList;\n+import static io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory.createWhitespaceMinutiae;\n+\n+/**\n+ * Class that contains the util functions used by the formatting tree modifier.\n+ */\n+class FormatterUtils {\n+\n+    /**\n+     * Get the node position.\n+     *\n+     * @param node node\n+     * @return node position\n+     */\n+    static DiagnosticPos getPosition(Node node) {\n+        if (node == null) {\n+            return null;\n+        }\n+        LineRange range = node.lineRange();\n+        LinePosition startPos = range.startLine();\n+        LinePosition endPos = range.endLine();\n+        int startOffset = startPos.offset();\n+        if (node.kind().equals(SyntaxKind.FUNCTION_DEFINITION) || node.kind().equals(SyntaxKind.TYPE_DEFINITION) ||", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d7c8311da6403c402327513c87a6e040a6db4ce6"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc1OTIzMQ==", "bodyText": "Done.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25680#discussion_r486759231", "createdAt": "2020-09-11T03:58:06Z", "author": {"login": "IrushiL"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/FormatterUtils.java", "diffHunk": "@@ -0,0 +1,230 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.core;\n+\n+import io.ballerina.tools.text.LinePosition;\n+import io.ballerina.tools.text.LineRange;\n+import io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory;\n+import io.ballerinalang.compiler.syntax.tree.Minutiae;\n+import io.ballerinalang.compiler.syntax.tree.MinutiaeList;\n+import io.ballerinalang.compiler.syntax.tree.Node;\n+import io.ballerinalang.compiler.syntax.tree.SyntaxKind;\n+import io.ballerinalang.compiler.syntax.tree.Token;\n+import org.wso2.ballerinalang.compiler.util.diagnotic.DiagnosticPos;\n+\n+import static io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory.createMinutiaeList;\n+import static io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory.createWhitespaceMinutiae;\n+\n+/**\n+ * Class that contains the util functions used by the formatting tree modifier.\n+ */\n+class FormatterUtils {\n+\n+    /**\n+     * Get the node position.\n+     *\n+     * @param node node\n+     * @return node position\n+     */\n+    static DiagnosticPos getPosition(Node node) {\n+        if (node == null) {\n+            return null;\n+        }\n+        LineRange range = node.lineRange();\n+        LinePosition startPos = range.startLine();\n+        LinePosition endPos = range.endLine();\n+        int startOffset = startPos.offset();\n+        if (node.kind().equals(SyntaxKind.FUNCTION_DEFINITION) || node.kind().equals(SyntaxKind.TYPE_DEFINITION) ||", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjI5NzYxOA=="}, "originalCommit": {"oid": "d7c8311da6403c402327513c87a6e040a6db4ce6"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0MTg0NTk1OnYy", "diffSide": "RIGHT", "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/FormatterUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxMjozMjo0OFrOHPxSxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwMzo1ODozOVrOHQNbrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjI5ODMwOQ==", "bodyText": "can extract node.parent().kind() to a variable", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25680#discussion_r486298309", "createdAt": "2020-09-10T12:32:48Z", "author": {"login": "SupunS"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/FormatterUtils.java", "diffHunk": "@@ -0,0 +1,230 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.core;\n+\n+import io.ballerina.tools.text.LinePosition;\n+import io.ballerina.tools.text.LineRange;\n+import io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory;\n+import io.ballerinalang.compiler.syntax.tree.Minutiae;\n+import io.ballerinalang.compiler.syntax.tree.MinutiaeList;\n+import io.ballerinalang.compiler.syntax.tree.Node;\n+import io.ballerinalang.compiler.syntax.tree.SyntaxKind;\n+import io.ballerinalang.compiler.syntax.tree.Token;\n+import org.wso2.ballerinalang.compiler.util.diagnotic.DiagnosticPos;\n+\n+import static io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory.createMinutiaeList;\n+import static io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory.createWhitespaceMinutiae;\n+\n+/**\n+ * Class that contains the util functions used by the formatting tree modifier.\n+ */\n+class FormatterUtils {\n+\n+    /**\n+     * Get the node position.\n+     *\n+     * @param node node\n+     * @return node position\n+     */\n+    static DiagnosticPos getPosition(Node node) {\n+        if (node == null) {\n+            return null;\n+        }\n+        LineRange range = node.lineRange();\n+        LinePosition startPos = range.startLine();\n+        LinePosition endPos = range.endLine();\n+        int startOffset = startPos.offset();\n+        if (node.kind().equals(SyntaxKind.FUNCTION_DEFINITION) || node.kind().equals(SyntaxKind.TYPE_DEFINITION) ||\n+                node.kind().equals(SyntaxKind.CONST_DECLARATION)) {\n+            startOffset = (startOffset / 4) * 4;\n+        }\n+        return new DiagnosticPos(null, startPos.line() + 1, endPos.line() + 1,\n+                startOffset, endPos.offset());\n+    }\n+\n+    // TODO: Use a generic way to get the parent node using querying.\n+    static <T extends Node> Node getParent(T node, SyntaxKind syntaxKind) {\n+        Node parent = node.parent();\n+        if (parent == null) {\n+            parent = node;\n+        }\n+        SyntaxKind parentKind = parent.kind();\n+        if (parentKind == SyntaxKind.MODULE_VAR_DECL) {\n+            if (parent.parent() != null && parent.parent().kind() == SyntaxKind.MODULE_PART &&\n+                    syntaxKind == SyntaxKind.QUALIFIED_NAME_REFERENCE) {\n+                return null;\n+            }\n+            return parent;\n+        } else if (parentKind == SyntaxKind.FUNCTION_DEFINITION ||\n+                parentKind == SyntaxKind.IF_ELSE_STATEMENT ||\n+                parentKind == SyntaxKind.ELSE_BLOCK ||\n+                parentKind == SyntaxKind.WHILE_STATEMENT ||\n+                parentKind == SyntaxKind.CONST_DECLARATION ||\n+                parentKind == SyntaxKind.METHOD_DECLARATION ||\n+                parentKind == SyntaxKind.TYPE_DEFINITION) {\n+            return parent;\n+        } else if (syntaxKind == SyntaxKind.SIMPLE_NAME_REFERENCE) {\n+            if (parentKind == SyntaxKind.REQUIRED_PARAM ||\n+                    parentKind == SyntaxKind.POSITIONAL_ARG ||\n+                    parentKind == SyntaxKind.BINARY_EXPRESSION ||\n+                    parentKind == SyntaxKind.RETURN_STATEMENT ||\n+                    parentKind == SyntaxKind.REMOTE_METHOD_CALL_ACTION ||\n+                    parentKind.equals(SyntaxKind.FIELD_ACCESS) ||\n+                    (parentKind == SyntaxKind.FUNCTION_CALL && parent.parent() != null &&\n+                            parent.parent().kind() == SyntaxKind.ASSIGNMENT_STATEMENT)) {\n+                return null;\n+            }\n+            return getParent(parent, syntaxKind);\n+        } else if (syntaxKind.equals(SyntaxKind.STRING_TYPE_DESC) &&\n+                parentKind.equals(SyntaxKind.RECORD_FIELD) && parent.parent() != null &&\n+                parent.parent().kind().equals(SyntaxKind.RECORD_TYPE_DESC)) {\n+            return getParent(parent, syntaxKind);\n+        } else if (parentKind == SyntaxKind.SERVICE_DECLARATION ||\n+                parentKind == SyntaxKind.BINARY_EXPRESSION) {\n+            if (syntaxKind == SyntaxKind.QUALIFIED_NAME_REFERENCE) {\n+                return null;\n+            }\n+            return parent;\n+        } else if (parentKind == SyntaxKind.REQUIRED_PARAM) {\n+            return null;\n+        } else if (parentKind.equals(SyntaxKind.OBJECT_TYPE_DESC)) {\n+            if (parent.parent() != null && parent.parent().kind().equals(SyntaxKind.RETURN_TYPE_DESCRIPTOR)) {\n+                return parent.parent().parent().parent();\n+            } else if (parent.parent() != null && parent.parent().kind().equals(SyntaxKind.TYPE_DEFINITION)) {\n+                return getParent(parent, syntaxKind);\n+            } else {\n+                return parent;\n+            }\n+        } else if (parent.parent() != null) {\n+            return getParent(parent, syntaxKind);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    static int getIndentation(Node node, int indentation, FormattingOptions formattingOptions) {\n+        if (node == null) {\n+            return indentation;\n+        }\n+        if (node.parent() != null && (node.parent().kind().equals(SyntaxKind.BLOCK_STATEMENT) ||\n+                node.parent().kind().equals(SyntaxKind.FUNCTION_BODY_BLOCK) ||", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d7c8311da6403c402327513c87a6e040a6db4ce6"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc1OTM0MA==", "bodyText": "Done.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25680#discussion_r486759340", "createdAt": "2020-09-11T03:58:39Z", "author": {"login": "IrushiL"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/FormatterUtils.java", "diffHunk": "@@ -0,0 +1,230 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.core;\n+\n+import io.ballerina.tools.text.LinePosition;\n+import io.ballerina.tools.text.LineRange;\n+import io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory;\n+import io.ballerinalang.compiler.syntax.tree.Minutiae;\n+import io.ballerinalang.compiler.syntax.tree.MinutiaeList;\n+import io.ballerinalang.compiler.syntax.tree.Node;\n+import io.ballerinalang.compiler.syntax.tree.SyntaxKind;\n+import io.ballerinalang.compiler.syntax.tree.Token;\n+import org.wso2.ballerinalang.compiler.util.diagnotic.DiagnosticPos;\n+\n+import static io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory.createMinutiaeList;\n+import static io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory.createWhitespaceMinutiae;\n+\n+/**\n+ * Class that contains the util functions used by the formatting tree modifier.\n+ */\n+class FormatterUtils {\n+\n+    /**\n+     * Get the node position.\n+     *\n+     * @param node node\n+     * @return node position\n+     */\n+    static DiagnosticPos getPosition(Node node) {\n+        if (node == null) {\n+            return null;\n+        }\n+        LineRange range = node.lineRange();\n+        LinePosition startPos = range.startLine();\n+        LinePosition endPos = range.endLine();\n+        int startOffset = startPos.offset();\n+        if (node.kind().equals(SyntaxKind.FUNCTION_DEFINITION) || node.kind().equals(SyntaxKind.TYPE_DEFINITION) ||\n+                node.kind().equals(SyntaxKind.CONST_DECLARATION)) {\n+            startOffset = (startOffset / 4) * 4;\n+        }\n+        return new DiagnosticPos(null, startPos.line() + 1, endPos.line() + 1,\n+                startOffset, endPos.offset());\n+    }\n+\n+    // TODO: Use a generic way to get the parent node using querying.\n+    static <T extends Node> Node getParent(T node, SyntaxKind syntaxKind) {\n+        Node parent = node.parent();\n+        if (parent == null) {\n+            parent = node;\n+        }\n+        SyntaxKind parentKind = parent.kind();\n+        if (parentKind == SyntaxKind.MODULE_VAR_DECL) {\n+            if (parent.parent() != null && parent.parent().kind() == SyntaxKind.MODULE_PART &&\n+                    syntaxKind == SyntaxKind.QUALIFIED_NAME_REFERENCE) {\n+                return null;\n+            }\n+            return parent;\n+        } else if (parentKind == SyntaxKind.FUNCTION_DEFINITION ||\n+                parentKind == SyntaxKind.IF_ELSE_STATEMENT ||\n+                parentKind == SyntaxKind.ELSE_BLOCK ||\n+                parentKind == SyntaxKind.WHILE_STATEMENT ||\n+                parentKind == SyntaxKind.CONST_DECLARATION ||\n+                parentKind == SyntaxKind.METHOD_DECLARATION ||\n+                parentKind == SyntaxKind.TYPE_DEFINITION) {\n+            return parent;\n+        } else if (syntaxKind == SyntaxKind.SIMPLE_NAME_REFERENCE) {\n+            if (parentKind == SyntaxKind.REQUIRED_PARAM ||\n+                    parentKind == SyntaxKind.POSITIONAL_ARG ||\n+                    parentKind == SyntaxKind.BINARY_EXPRESSION ||\n+                    parentKind == SyntaxKind.RETURN_STATEMENT ||\n+                    parentKind == SyntaxKind.REMOTE_METHOD_CALL_ACTION ||\n+                    parentKind.equals(SyntaxKind.FIELD_ACCESS) ||\n+                    (parentKind == SyntaxKind.FUNCTION_CALL && parent.parent() != null &&\n+                            parent.parent().kind() == SyntaxKind.ASSIGNMENT_STATEMENT)) {\n+                return null;\n+            }\n+            return getParent(parent, syntaxKind);\n+        } else if (syntaxKind.equals(SyntaxKind.STRING_TYPE_DESC) &&\n+                parentKind.equals(SyntaxKind.RECORD_FIELD) && parent.parent() != null &&\n+                parent.parent().kind().equals(SyntaxKind.RECORD_TYPE_DESC)) {\n+            return getParent(parent, syntaxKind);\n+        } else if (parentKind == SyntaxKind.SERVICE_DECLARATION ||\n+                parentKind == SyntaxKind.BINARY_EXPRESSION) {\n+            if (syntaxKind == SyntaxKind.QUALIFIED_NAME_REFERENCE) {\n+                return null;\n+            }\n+            return parent;\n+        } else if (parentKind == SyntaxKind.REQUIRED_PARAM) {\n+            return null;\n+        } else if (parentKind.equals(SyntaxKind.OBJECT_TYPE_DESC)) {\n+            if (parent.parent() != null && parent.parent().kind().equals(SyntaxKind.RETURN_TYPE_DESCRIPTOR)) {\n+                return parent.parent().parent().parent();\n+            } else if (parent.parent() != null && parent.parent().kind().equals(SyntaxKind.TYPE_DEFINITION)) {\n+                return getParent(parent, syntaxKind);\n+            } else {\n+                return parent;\n+            }\n+        } else if (parent.parent() != null) {\n+            return getParent(parent, syntaxKind);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    static int getIndentation(Node node, int indentation, FormattingOptions formattingOptions) {\n+        if (node == null) {\n+            return indentation;\n+        }\n+        if (node.parent() != null && (node.parent().kind().equals(SyntaxKind.BLOCK_STATEMENT) ||\n+                node.parent().kind().equals(SyntaxKind.FUNCTION_BODY_BLOCK) ||", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjI5ODMwOQ=="}, "originalCommit": {"oid": "d7c8311da6403c402327513c87a6e040a6db4ce6"}, "originalPosition": 123}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0MTg1ODM5OnYy", "diffSide": "RIGHT", "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/FormattingTreeModifier.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxMjozNjowN1rOHPxaaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwNDowMDowNlrOHQNdHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjMwMDI2Nw==", "bodyText": "extract  blockStatementNode.parent().kind() to a variable", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25680#discussion_r486300267", "createdAt": "2020-09-10T12:36:07Z", "author": {"login": "SupunS"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/FormattingTreeModifier.java", "diffHunk": "@@ -913,10 +972,17 @@ public MetadataNode transform(MetadataNode metadataNode) {\n \n     @Override\n     public BlockStatementNode transform(BlockStatementNode blockStatementNode) {\n-        if (!isInLineRange(blockStatementNode)) {\n+        if (!isInLineRange(blockStatementNode, lineRange)) {\n             return blockStatementNode;\n         }\n-        int startColumn = getStartColumn(blockStatementNode, blockStatementNode.kind(), false);\n+        boolean addSpaces = false;\n+        if (blockStatementNode.parent().kind().equals(SyntaxKind.NAMED_WORKER_DECLARATION) ||\n+                blockStatementNode.parent().kind().equals(SyntaxKind.QUERY_ACTION) ||\n+                blockStatementNode.parent().kind().equals(SyntaxKind.FOREACH_STATEMENT) ||\n+                blockStatementNode.parent().kind().equals(SyntaxKind.FUNCTION_BODY_BLOCK)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d7c8311da6403c402327513c87a6e040a6db4ce6"}, "originalPosition": 583}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc1OTcwOA==", "bodyText": "Fixed.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25680#discussion_r486759708", "createdAt": "2020-09-11T04:00:06Z", "author": {"login": "IrushiL"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/FormattingTreeModifier.java", "diffHunk": "@@ -913,10 +972,17 @@ public MetadataNode transform(MetadataNode metadataNode) {\n \n     @Override\n     public BlockStatementNode transform(BlockStatementNode blockStatementNode) {\n-        if (!isInLineRange(blockStatementNode)) {\n+        if (!isInLineRange(blockStatementNode, lineRange)) {\n             return blockStatementNode;\n         }\n-        int startColumn = getStartColumn(blockStatementNode, blockStatementNode.kind(), false);\n+        boolean addSpaces = false;\n+        if (blockStatementNode.parent().kind().equals(SyntaxKind.NAMED_WORKER_DECLARATION) ||\n+                blockStatementNode.parent().kind().equals(SyntaxKind.QUERY_ACTION) ||\n+                blockStatementNode.parent().kind().equals(SyntaxKind.FOREACH_STATEMENT) ||\n+                blockStatementNode.parent().kind().equals(SyntaxKind.FUNCTION_BODY_BLOCK)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjMwMDI2Nw=="}, "originalCommit": {"oid": "d7c8311da6403c402327513c87a6e040a6db4ce6"}, "originalPosition": 583}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0MTg3NjE2OnYy", "diffSide": "RIGHT", "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/FormattingTreeModifier.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxMjo0MDoyOVrOHPxlOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwNDowODowOVrOHQNkdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjMwMzAzMw==", "bodyText": "Whats the node we are getting here by listConstructorExpressionNode.children().get(1)?\nCan we use the specific method in ListConstructorExpressionNode class?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25680#discussion_r486303033", "createdAt": "2020-09-10T12:40:29Z", "author": {"login": "SupunS"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/FormattingTreeModifier.java", "diffHunk": "@@ -1437,18 +1636,29 @@ public ByteArrayLiteralNode transform(ByteArrayLiteralNode byteArrayLiteralNode)\n \n     @Override\n     public ListConstructorExpressionNode transform(ListConstructorExpressionNode listConstructorExpressionNode) {\n+        if (!isInLineRange(listConstructorExpressionNode, lineRange)) {\n+            return listConstructorExpressionNode;\n+        }\n+        int newLines = 0;\n+        if (listConstructorExpressionNode.children().get(1).kind().equals(SyntaxKind.MAPPING_CONSTRUCTOR)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d7c8311da6403c402327513c87a6e040a6db4ce6"}, "originalPosition": 1061}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc2MTU5MQ==", "bodyText": "The expected node here is a MappingConstructorExpressionNode.\nListConstructorExpressionNode class returns a SeparatedNodeList as the set of expressions, so both ways would result in a similar code implementation AFAIU, but I will check on as to whether this could be improved.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25680#discussion_r486761591", "createdAt": "2020-09-11T04:08:09Z", "author": {"login": "IrushiL"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/FormattingTreeModifier.java", "diffHunk": "@@ -1437,18 +1636,29 @@ public ByteArrayLiteralNode transform(ByteArrayLiteralNode byteArrayLiteralNode)\n \n     @Override\n     public ListConstructorExpressionNode transform(ListConstructorExpressionNode listConstructorExpressionNode) {\n+        if (!isInLineRange(listConstructorExpressionNode, lineRange)) {\n+            return listConstructorExpressionNode;\n+        }\n+        int newLines = 0;\n+        if (listConstructorExpressionNode.children().get(1).kind().equals(SyntaxKind.MAPPING_CONSTRUCTOR)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjMwMzAzMw=="}, "originalCommit": {"oid": "d7c8311da6403c402327513c87a6e040a6db4ce6"}, "originalPosition": 1061}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0MTg4NzU0OnYy", "diffSide": "RIGHT", "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NodeFormattingMetrics.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxMjo0MzoyN1rOHPxsOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwNDowMzowNFrOHQNgAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjMwNDgyNg==", "bodyText": "Condition of this is-block is a tad too big. Let's extract it to a separate function.\nWe can simply do: addSpaces = newlyAddedFunction();", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25680#discussion_r486304826", "createdAt": "2020-09-10T12:43:27Z", "author": {"login": "SupunS"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NodeFormattingMetrics.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.core;\n+\n+import io.ballerinalang.compiler.syntax.tree.BuiltinSimpleNameReferenceNode;\n+import io.ballerinalang.compiler.syntax.tree.Node;\n+import io.ballerinalang.compiler.syntax.tree.NonTerminalNode;\n+import io.ballerinalang.compiler.syntax.tree.ObjectFieldNode;\n+import io.ballerinalang.compiler.syntax.tree.SyntaxKind;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+\n+/**\n+ * Class that stores the formatting metrics for a particular node.\n+ */\n+class NodeFormattingMetrics {\n+\n+    private Node node;\n+    private NonTerminalNode parent;\n+    private NonTerminalNode grandParent;\n+\n+    NodeFormattingMetrics(Node node) {\n+\n+        this.node = node;\n+        this.parent = node.parent();\n+        if (parent != null) {\n+            this.grandParent = parent.parent();\n+        } else {\n+            this.grandParent = null;\n+        }\n+        setNodeMetrics();\n+    }\n+\n+    private void setNodeMetrics() {\n+        if (node instanceof BuiltinSimpleNameReferenceNode) {\n+            handleBuiltinSimpleNameReferenceNode();\n+        }\n+    }\n+\n+    boolean handleBuiltinSimpleNameReferenceNode() {\n+        boolean addSpaces = true;\n+        ArrayList<SyntaxKind> parentNodes = new ArrayList<>(\n+                Arrays.asList(\n+                        SyntaxKind.FUNCTION_CALL,\n+                        SyntaxKind.TYPE_TEST_EXPRESSION,\n+                        SyntaxKind.TYPE_PARAMETER,\n+                        SyntaxKind.TYPE_CAST_PARAM,\n+                        SyntaxKind.UNION_TYPE_DESC,\n+                        SyntaxKind.XML_TYPE_DESC));\n+        if (parent != null && (parentNodes.contains(parent.kind()) || grandParent != null &&\n+                ((parent.kind().equals(SyntaxKind.TYPED_BINDING_PATTERN) &&\n+                        grandParent.kind().equals(SyntaxKind.FOREACH_STATEMENT)) ||\n+                (parent.kind().equals(SyntaxKind.UNION_TYPE_DESC) &&\n+                        grandParent.kind().equals(SyntaxKind.PARAMETERIZED_TYPE_DESC)) ||\n+                (parent.kind().equals(SyntaxKind.OBJECT_FIELD) &&\n+                        ((ObjectFieldNode) parent).visibilityQualifier().isPresent()) ||\n+                (grandParent.kind().equals(SyntaxKind.LOCAL_VAR_DECL) &&\n+                        grandParent.children().get(1).equals(parent)) ||\n+                grandParent.kind().equals(SyntaxKind.FROM_CLAUSE) ||\n+                grandParent.kind().equals(SyntaxKind.PARAMETERIZED_TYPE_DESC)))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d7c8311da6403c402327513c87a6e040a6db4ce6"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc2MDQ1MA==", "bodyText": "Thanks for the input, planning on refactoring and simplifying the logic separately in a different PR.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25680#discussion_r486760450", "createdAt": "2020-09-11T04:03:04Z", "author": {"login": "IrushiL"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NodeFormattingMetrics.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.core;\n+\n+import io.ballerinalang.compiler.syntax.tree.BuiltinSimpleNameReferenceNode;\n+import io.ballerinalang.compiler.syntax.tree.Node;\n+import io.ballerinalang.compiler.syntax.tree.NonTerminalNode;\n+import io.ballerinalang.compiler.syntax.tree.ObjectFieldNode;\n+import io.ballerinalang.compiler.syntax.tree.SyntaxKind;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+\n+/**\n+ * Class that stores the formatting metrics for a particular node.\n+ */\n+class NodeFormattingMetrics {\n+\n+    private Node node;\n+    private NonTerminalNode parent;\n+    private NonTerminalNode grandParent;\n+\n+    NodeFormattingMetrics(Node node) {\n+\n+        this.node = node;\n+        this.parent = node.parent();\n+        if (parent != null) {\n+            this.grandParent = parent.parent();\n+        } else {\n+            this.grandParent = null;\n+        }\n+        setNodeMetrics();\n+    }\n+\n+    private void setNodeMetrics() {\n+        if (node instanceof BuiltinSimpleNameReferenceNode) {\n+            handleBuiltinSimpleNameReferenceNode();\n+        }\n+    }\n+\n+    boolean handleBuiltinSimpleNameReferenceNode() {\n+        boolean addSpaces = true;\n+        ArrayList<SyntaxKind> parentNodes = new ArrayList<>(\n+                Arrays.asList(\n+                        SyntaxKind.FUNCTION_CALL,\n+                        SyntaxKind.TYPE_TEST_EXPRESSION,\n+                        SyntaxKind.TYPE_PARAMETER,\n+                        SyntaxKind.TYPE_CAST_PARAM,\n+                        SyntaxKind.UNION_TYPE_DESC,\n+                        SyntaxKind.XML_TYPE_DESC));\n+        if (parent != null && (parentNodes.contains(parent.kind()) || grandParent != null &&\n+                ((parent.kind().equals(SyntaxKind.TYPED_BINDING_PATTERN) &&\n+                        grandParent.kind().equals(SyntaxKind.FOREACH_STATEMENT)) ||\n+                (parent.kind().equals(SyntaxKind.UNION_TYPE_DESC) &&\n+                        grandParent.kind().equals(SyntaxKind.PARAMETERIZED_TYPE_DESC)) ||\n+                (parent.kind().equals(SyntaxKind.OBJECT_FIELD) &&\n+                        ((ObjectFieldNode) parent).visibilityQualifier().isPresent()) ||\n+                (grandParent.kind().equals(SyntaxKind.LOCAL_VAR_DECL) &&\n+                        grandParent.children().get(1).equals(parent)) ||\n+                grandParent.kind().equals(SyntaxKind.FROM_CLAUSE) ||\n+                grandParent.kind().equals(SyntaxKind.PARAMETERIZED_TYPE_DESC)))) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjMwNDgyNg=="}, "originalCommit": {"oid": "d7c8311da6403c402327513c87a6e040a6db4ce6"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0MTg4ODU5OnYy", "diffSide": "RIGHT", "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NodeFormattingMetrics.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxMjo0Mzo0NFrOHPxs5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwNDowMjozMFrOHQNffQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjMwNDk5OA==", "bodyText": "Same as above", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25680#discussion_r486304998", "createdAt": "2020-09-10T12:43:44Z", "author": {"login": "SupunS"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NodeFormattingMetrics.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.core;\n+\n+import io.ballerinalang.compiler.syntax.tree.BuiltinSimpleNameReferenceNode;\n+import io.ballerinalang.compiler.syntax.tree.Node;\n+import io.ballerinalang.compiler.syntax.tree.NonTerminalNode;\n+import io.ballerinalang.compiler.syntax.tree.ObjectFieldNode;\n+import io.ballerinalang.compiler.syntax.tree.SyntaxKind;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+\n+/**\n+ * Class that stores the formatting metrics for a particular node.\n+ */\n+class NodeFormattingMetrics {\n+\n+    private Node node;\n+    private NonTerminalNode parent;\n+    private NonTerminalNode grandParent;\n+\n+    NodeFormattingMetrics(Node node) {\n+\n+        this.node = node;\n+        this.parent = node.parent();\n+        if (parent != null) {\n+            this.grandParent = parent.parent();\n+        } else {\n+            this.grandParent = null;\n+        }\n+        setNodeMetrics();\n+    }\n+\n+    private void setNodeMetrics() {\n+        if (node instanceof BuiltinSimpleNameReferenceNode) {\n+            handleBuiltinSimpleNameReferenceNode();\n+        }\n+    }\n+\n+    boolean handleBuiltinSimpleNameReferenceNode() {\n+        boolean addSpaces = true;\n+        ArrayList<SyntaxKind> parentNodes = new ArrayList<>(\n+                Arrays.asList(\n+                        SyntaxKind.FUNCTION_CALL,\n+                        SyntaxKind.TYPE_TEST_EXPRESSION,\n+                        SyntaxKind.TYPE_PARAMETER,\n+                        SyntaxKind.TYPE_CAST_PARAM,\n+                        SyntaxKind.UNION_TYPE_DESC,\n+                        SyntaxKind.XML_TYPE_DESC));\n+        if (parent != null && (parentNodes.contains(parent.kind()) || grandParent != null &&\n+                ((parent.kind().equals(SyntaxKind.TYPED_BINDING_PATTERN) &&\n+                        grandParent.kind().equals(SyntaxKind.FOREACH_STATEMENT)) ||\n+                (parent.kind().equals(SyntaxKind.UNION_TYPE_DESC) &&\n+                        grandParent.kind().equals(SyntaxKind.PARAMETERIZED_TYPE_DESC)) ||\n+                (parent.kind().equals(SyntaxKind.OBJECT_FIELD) &&\n+                        ((ObjectFieldNode) parent).visibilityQualifier().isPresent()) ||\n+                (grandParent.kind().equals(SyntaxKind.LOCAL_VAR_DECL) &&\n+                        grandParent.children().get(1).equals(parent)) ||\n+                grandParent.kind().equals(SyntaxKind.FROM_CLAUSE) ||\n+                grandParent.kind().equals(SyntaxKind.PARAMETERIZED_TYPE_DESC)))) {\n+            addSpaces = false;\n+        }\n+        if (parent != null && grandParent != null && (parent.kind().equals(SyntaxKind.UNION_TYPE_DESC) &&\n+                !grandParent.kind().equals(SyntaxKind.TYPE_CAST_PARAM) && parent.children().get(0).equals(node))) {\n+            addSpaces = true;\n+        }\n+        return addSpaces;\n+    }\n+\n+    boolean handleSimpleNameReferenceNode() {\n+        boolean addSpaces = false;\n+        ArrayList<SyntaxKind> parentNodes = new ArrayList<>(\n+                Arrays.asList(\n+                        SyntaxKind.TYPED_BINDING_PATTERN,\n+                        SyntaxKind.FIELD_ACCESS,\n+                        SyntaxKind.RECORD_FIELD_WITH_DEFAULT_VALUE,\n+                        SyntaxKind.OPTIONAL_TYPE_DESC,\n+                        SyntaxKind.ARRAY_TYPE_DESC));\n+        if (parent != null && ((parentNodes.contains(parent.kind())) || grandParent != null &&\n+                ((parent.kind().equals(SyntaxKind.INDEXED_EXPRESSION) &&\n+                        grandParent.kind().equals(SyntaxKind.ASSIGNMENT_STATEMENT)) ||\n+                ((parent.kind().equals(SyntaxKind.ASYNC_SEND_ACTION) ||\n+                parent.kind().equals(SyntaxKind.ASSIGNMENT_STATEMENT)) &&\n+                        parent.children().get(0).equals(node))))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d7c8311da6403c402327513c87a6e040a6db4ce6"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc2MDMxNw==", "bodyText": "Thanks for the input, planning on refactoring and simplifying the logic separately in a different PR.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25680#discussion_r486760317", "createdAt": "2020-09-11T04:02:30Z", "author": {"login": "IrushiL"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NodeFormattingMetrics.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.core;\n+\n+import io.ballerinalang.compiler.syntax.tree.BuiltinSimpleNameReferenceNode;\n+import io.ballerinalang.compiler.syntax.tree.Node;\n+import io.ballerinalang.compiler.syntax.tree.NonTerminalNode;\n+import io.ballerinalang.compiler.syntax.tree.ObjectFieldNode;\n+import io.ballerinalang.compiler.syntax.tree.SyntaxKind;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+\n+/**\n+ * Class that stores the formatting metrics for a particular node.\n+ */\n+class NodeFormattingMetrics {\n+\n+    private Node node;\n+    private NonTerminalNode parent;\n+    private NonTerminalNode grandParent;\n+\n+    NodeFormattingMetrics(Node node) {\n+\n+        this.node = node;\n+        this.parent = node.parent();\n+        if (parent != null) {\n+            this.grandParent = parent.parent();\n+        } else {\n+            this.grandParent = null;\n+        }\n+        setNodeMetrics();\n+    }\n+\n+    private void setNodeMetrics() {\n+        if (node instanceof BuiltinSimpleNameReferenceNode) {\n+            handleBuiltinSimpleNameReferenceNode();\n+        }\n+    }\n+\n+    boolean handleBuiltinSimpleNameReferenceNode() {\n+        boolean addSpaces = true;\n+        ArrayList<SyntaxKind> parentNodes = new ArrayList<>(\n+                Arrays.asList(\n+                        SyntaxKind.FUNCTION_CALL,\n+                        SyntaxKind.TYPE_TEST_EXPRESSION,\n+                        SyntaxKind.TYPE_PARAMETER,\n+                        SyntaxKind.TYPE_CAST_PARAM,\n+                        SyntaxKind.UNION_TYPE_DESC,\n+                        SyntaxKind.XML_TYPE_DESC));\n+        if (parent != null && (parentNodes.contains(parent.kind()) || grandParent != null &&\n+                ((parent.kind().equals(SyntaxKind.TYPED_BINDING_PATTERN) &&\n+                        grandParent.kind().equals(SyntaxKind.FOREACH_STATEMENT)) ||\n+                (parent.kind().equals(SyntaxKind.UNION_TYPE_DESC) &&\n+                        grandParent.kind().equals(SyntaxKind.PARAMETERIZED_TYPE_DESC)) ||\n+                (parent.kind().equals(SyntaxKind.OBJECT_FIELD) &&\n+                        ((ObjectFieldNode) parent).visibilityQualifier().isPresent()) ||\n+                (grandParent.kind().equals(SyntaxKind.LOCAL_VAR_DECL) &&\n+                        grandParent.children().get(1).equals(parent)) ||\n+                grandParent.kind().equals(SyntaxKind.FROM_CLAUSE) ||\n+                grandParent.kind().equals(SyntaxKind.PARAMETERIZED_TYPE_DESC)))) {\n+            addSpaces = false;\n+        }\n+        if (parent != null && grandParent != null && (parent.kind().equals(SyntaxKind.UNION_TYPE_DESC) &&\n+                !grandParent.kind().equals(SyntaxKind.TYPE_CAST_PARAM) && parent.children().get(0).equals(node))) {\n+            addSpaces = true;\n+        }\n+        return addSpaces;\n+    }\n+\n+    boolean handleSimpleNameReferenceNode() {\n+        boolean addSpaces = false;\n+        ArrayList<SyntaxKind> parentNodes = new ArrayList<>(\n+                Arrays.asList(\n+                        SyntaxKind.TYPED_BINDING_PATTERN,\n+                        SyntaxKind.FIELD_ACCESS,\n+                        SyntaxKind.RECORD_FIELD_WITH_DEFAULT_VALUE,\n+                        SyntaxKind.OPTIONAL_TYPE_DESC,\n+                        SyntaxKind.ARRAY_TYPE_DESC));\n+        if (parent != null && ((parentNodes.contains(parent.kind())) || grandParent != null &&\n+                ((parent.kind().equals(SyntaxKind.INDEXED_EXPRESSION) &&\n+                        grandParent.kind().equals(SyntaxKind.ASSIGNMENT_STATEMENT)) ||\n+                ((parent.kind().equals(SyntaxKind.ASYNC_SEND_ACTION) ||\n+                parent.kind().equals(SyntaxKind.ASSIGNMENT_STATEMENT)) &&\n+                        parent.children().get(0).equals(node))))) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjMwNDk5OA=="}, "originalCommit": {"oid": "d7c8311da6403c402327513c87a6e040a6db4ce6"}, "originalPosition": 98}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0MTkwMjM0OnYy", "diffSide": "RIGHT", "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NodeFormattingMetrics.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxMjo0NzoxNVrOHPx1gQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwMzo1NTo0MlrOHQNZAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjMwNzIwMQ==", "bodyText": "Do we need the outer wrapper new ArrayList<>()? I think Arrays.asList() returns an array-list", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25680#discussion_r486307201", "createdAt": "2020-09-10T12:47:15Z", "author": {"login": "SupunS"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NodeFormattingMetrics.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.core;\n+\n+import io.ballerinalang.compiler.syntax.tree.BuiltinSimpleNameReferenceNode;\n+import io.ballerinalang.compiler.syntax.tree.Node;\n+import io.ballerinalang.compiler.syntax.tree.NonTerminalNode;\n+import io.ballerinalang.compiler.syntax.tree.ObjectFieldNode;\n+import io.ballerinalang.compiler.syntax.tree.SyntaxKind;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+\n+/**\n+ * Class that stores the formatting metrics for a particular node.\n+ */\n+class NodeFormattingMetrics {\n+\n+    private Node node;\n+    private NonTerminalNode parent;\n+    private NonTerminalNode grandParent;\n+\n+    NodeFormattingMetrics(Node node) {\n+\n+        this.node = node;\n+        this.parent = node.parent();\n+        if (parent != null) {\n+            this.grandParent = parent.parent();\n+        } else {\n+            this.grandParent = null;\n+        }\n+        setNodeMetrics();\n+    }\n+\n+    private void setNodeMetrics() {\n+        if (node instanceof BuiltinSimpleNameReferenceNode) {\n+            handleBuiltinSimpleNameReferenceNode();\n+        }\n+    }\n+\n+    boolean handleBuiltinSimpleNameReferenceNode() {\n+        boolean addSpaces = true;\n+        ArrayList<SyntaxKind> parentNodes = new ArrayList<>(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d7c8311da6403c402327513c87a6e040a6db4ce6"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc1ODY1Ng==", "bodyText": "Fixed.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25680#discussion_r486758656", "createdAt": "2020-09-11T03:55:42Z", "author": {"login": "IrushiL"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NodeFormattingMetrics.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.core;\n+\n+import io.ballerinalang.compiler.syntax.tree.BuiltinSimpleNameReferenceNode;\n+import io.ballerinalang.compiler.syntax.tree.Node;\n+import io.ballerinalang.compiler.syntax.tree.NonTerminalNode;\n+import io.ballerinalang.compiler.syntax.tree.ObjectFieldNode;\n+import io.ballerinalang.compiler.syntax.tree.SyntaxKind;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+\n+/**\n+ * Class that stores the formatting metrics for a particular node.\n+ */\n+class NodeFormattingMetrics {\n+\n+    private Node node;\n+    private NonTerminalNode parent;\n+    private NonTerminalNode grandParent;\n+\n+    NodeFormattingMetrics(Node node) {\n+\n+        this.node = node;\n+        this.parent = node.parent();\n+        if (parent != null) {\n+            this.grandParent = parent.parent();\n+        } else {\n+            this.grandParent = null;\n+        }\n+        setNodeMetrics();\n+    }\n+\n+    private void setNodeMetrics() {\n+        if (node instanceof BuiltinSimpleNameReferenceNode) {\n+            handleBuiltinSimpleNameReferenceNode();\n+        }\n+    }\n+\n+    boolean handleBuiltinSimpleNameReferenceNode() {\n+        boolean addSpaces = true;\n+        ArrayList<SyntaxKind> parentNodes = new ArrayList<>(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjMwNzIwMQ=="}, "originalCommit": {"oid": "d7c8311da6403c402327513c87a6e040a6db4ce6"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NzQ5ODY5OnYy", "diffSide": "RIGHT", "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/FormatterUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNzozNzo1M1rOHQn2Cw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQwMjoyMjoyMFrOHRB4pw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE5MjA3NQ==", "bodyText": "Instead of returning a possibly null node, shall we use Optional here?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25680#discussion_r487192075", "createdAt": "2020-09-11T17:37:53Z", "author": {"login": "nadeeshaan"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/FormatterUtils.java", "diffHunk": "@@ -0,0 +1,415 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.core;\n+\n+import io.ballerina.tools.text.LinePosition;\n+import io.ballerina.tools.text.LineRange;\n+import io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory;\n+import io.ballerinalang.compiler.syntax.tree.ChildNodeList;\n+import io.ballerinalang.compiler.syntax.tree.Minutiae;\n+import io.ballerinalang.compiler.syntax.tree.MinutiaeList;\n+import io.ballerinalang.compiler.syntax.tree.Node;\n+import io.ballerinalang.compiler.syntax.tree.NonTerminalNode;\n+import io.ballerinalang.compiler.syntax.tree.SyntaxKind;\n+import io.ballerinalang.compiler.syntax.tree.Token;\n+import org.wso2.ballerinalang.compiler.util.diagnotic.DiagnosticPos;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import static io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory.createMinutiaeList;\n+import static io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory.createWhitespaceMinutiae;\n+\n+/**\n+ * Class that contains the util functions used by the formatting tree modifier.\n+ */\n+class FormatterUtils {\n+\n+    private static final String LINE_SEPARATOR = \"line.separator\";\n+\n+    /**\n+     * Get the node position.\n+     *\n+     * @param node node\n+     * @return node position\n+     */\n+    static DiagnosticPos getPosition(Node node) {\n+        if (node == null) {\n+            return null;\n+        }\n+        LineRange range = node.lineRange();\n+        LinePosition startPos = range.startLine();\n+        LinePosition endPos = range.endLine();\n+        int startOffset = startPos.offset();\n+        if (node.kind() == (SyntaxKind.FUNCTION_DEFINITION) || node.kind() == (SyntaxKind.TYPE_DEFINITION) ||\n+                node.kind() == (SyntaxKind.CONST_DECLARATION) || node.kind() == (SyntaxKind.OBJECT_TYPE_DESC)) {\n+            startOffset = (startOffset / 4) * 4;\n+        }\n+        return new DiagnosticPos(null, startPos.line() + 1, endPos.line() + 1,\n+                startOffset, endPos.offset());\n+    }\n+\n+    // TODO: Use a generic way to get the parent node using querying.\n+    static <T extends Node> Node getParent(T node, SyntaxKind syntaxKind) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abf30d5163ce0ebdc71f6463696d834f80cc2f05"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzYxODcyNw==", "bodyText": "Since this method is called recursively to find the effective parent node for indentation, converting its return type to optional seems to clutter the code without much of a benefit IMO, or is there something that I might be missing here?\nA null return value is expected in a case where a node has no parent. Here, there won't be an addition of columns to the existing indentation.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25680#discussion_r487618727", "createdAt": "2020-09-14T02:22:20Z", "author": {"login": "IrushiL"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/FormatterUtils.java", "diffHunk": "@@ -0,0 +1,415 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.core;\n+\n+import io.ballerina.tools.text.LinePosition;\n+import io.ballerina.tools.text.LineRange;\n+import io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory;\n+import io.ballerinalang.compiler.syntax.tree.ChildNodeList;\n+import io.ballerinalang.compiler.syntax.tree.Minutiae;\n+import io.ballerinalang.compiler.syntax.tree.MinutiaeList;\n+import io.ballerinalang.compiler.syntax.tree.Node;\n+import io.ballerinalang.compiler.syntax.tree.NonTerminalNode;\n+import io.ballerinalang.compiler.syntax.tree.SyntaxKind;\n+import io.ballerinalang.compiler.syntax.tree.Token;\n+import org.wso2.ballerinalang.compiler.util.diagnotic.DiagnosticPos;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import static io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory.createMinutiaeList;\n+import static io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory.createWhitespaceMinutiae;\n+\n+/**\n+ * Class that contains the util functions used by the formatting tree modifier.\n+ */\n+class FormatterUtils {\n+\n+    private static final String LINE_SEPARATOR = \"line.separator\";\n+\n+    /**\n+     * Get the node position.\n+     *\n+     * @param node node\n+     * @return node position\n+     */\n+    static DiagnosticPos getPosition(Node node) {\n+        if (node == null) {\n+            return null;\n+        }\n+        LineRange range = node.lineRange();\n+        LinePosition startPos = range.startLine();\n+        LinePosition endPos = range.endLine();\n+        int startOffset = startPos.offset();\n+        if (node.kind() == (SyntaxKind.FUNCTION_DEFINITION) || node.kind() == (SyntaxKind.TYPE_DEFINITION) ||\n+                node.kind() == (SyntaxKind.CONST_DECLARATION) || node.kind() == (SyntaxKind.OBJECT_TYPE_DESC)) {\n+            startOffset = (startOffset / 4) * 4;\n+        }\n+        return new DiagnosticPos(null, startPos.line() + 1, endPos.line() + 1,\n+                startOffset, endPos.offset());\n+    }\n+\n+    // TODO: Use a generic way to get the parent node using querying.\n+    static <T extends Node> Node getParent(T node, SyntaxKind syntaxKind) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE5MjA3NQ=="}, "originalCommit": {"oid": "abf30d5163ce0ebdc71f6463696d834f80cc2f05"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NzUxNDM3OnYy", "diffSide": "RIGHT", "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/FormatterUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNzo0MjoyOFrOHQn_nA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQwMTozMjo1M1rOHRBSAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE5NDUyNA==", "bodyText": "Since the if, else-if ladder is complex, shall we stick to individual if clauses? It seems we return within each clause and there is no fall through.this way we can remove several inner else clauses and will become the logic bit cleaner", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25680#discussion_r487194524", "createdAt": "2020-09-11T17:42:28Z", "author": {"login": "nadeeshaan"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/FormatterUtils.java", "diffHunk": "@@ -0,0 +1,415 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.core;\n+\n+import io.ballerina.tools.text.LinePosition;\n+import io.ballerina.tools.text.LineRange;\n+import io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory;\n+import io.ballerinalang.compiler.syntax.tree.ChildNodeList;\n+import io.ballerinalang.compiler.syntax.tree.Minutiae;\n+import io.ballerinalang.compiler.syntax.tree.MinutiaeList;\n+import io.ballerinalang.compiler.syntax.tree.Node;\n+import io.ballerinalang.compiler.syntax.tree.NonTerminalNode;\n+import io.ballerinalang.compiler.syntax.tree.SyntaxKind;\n+import io.ballerinalang.compiler.syntax.tree.Token;\n+import org.wso2.ballerinalang.compiler.util.diagnotic.DiagnosticPos;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import static io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory.createMinutiaeList;\n+import static io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory.createWhitespaceMinutiae;\n+\n+/**\n+ * Class that contains the util functions used by the formatting tree modifier.\n+ */\n+class FormatterUtils {\n+\n+    private static final String LINE_SEPARATOR = \"line.separator\";\n+\n+    /**\n+     * Get the node position.\n+     *\n+     * @param node node\n+     * @return node position\n+     */\n+    static DiagnosticPos getPosition(Node node) {\n+        if (node == null) {\n+            return null;\n+        }\n+        LineRange range = node.lineRange();\n+        LinePosition startPos = range.startLine();\n+        LinePosition endPos = range.endLine();\n+        int startOffset = startPos.offset();\n+        if (node.kind() == (SyntaxKind.FUNCTION_DEFINITION) || node.kind() == (SyntaxKind.TYPE_DEFINITION) ||\n+                node.kind() == (SyntaxKind.CONST_DECLARATION) || node.kind() == (SyntaxKind.OBJECT_TYPE_DESC)) {\n+            startOffset = (startOffset / 4) * 4;\n+        }\n+        return new DiagnosticPos(null, startPos.line() + 1, endPos.line() + 1,\n+                startOffset, endPos.offset());\n+    }\n+\n+    // TODO: Use a generic way to get the parent node using querying.\n+    static <T extends Node> Node getParent(T node, SyntaxKind syntaxKind) {\n+        Node parent = node.parent();\n+        if (parent == null) {\n+            parent = node;\n+        }\n+        Node grandParent = parent.parent();\n+        SyntaxKind parentKind = parent.kind();\n+        if (parentKind == (SyntaxKind.MODULE_VAR_DECL)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abf30d5163ce0ebdc71f6463696d834f80cc2f05"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzYwODgzMg==", "bodyText": "Fixed", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25680#discussion_r487608832", "createdAt": "2020-09-14T01:32:53Z", "author": {"login": "IrushiL"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/FormatterUtils.java", "diffHunk": "@@ -0,0 +1,415 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.core;\n+\n+import io.ballerina.tools.text.LinePosition;\n+import io.ballerina.tools.text.LineRange;\n+import io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory;\n+import io.ballerinalang.compiler.syntax.tree.ChildNodeList;\n+import io.ballerinalang.compiler.syntax.tree.Minutiae;\n+import io.ballerinalang.compiler.syntax.tree.MinutiaeList;\n+import io.ballerinalang.compiler.syntax.tree.Node;\n+import io.ballerinalang.compiler.syntax.tree.NonTerminalNode;\n+import io.ballerinalang.compiler.syntax.tree.SyntaxKind;\n+import io.ballerinalang.compiler.syntax.tree.Token;\n+import org.wso2.ballerinalang.compiler.util.diagnotic.DiagnosticPos;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import static io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory.createMinutiaeList;\n+import static io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory.createWhitespaceMinutiae;\n+\n+/**\n+ * Class that contains the util functions used by the formatting tree modifier.\n+ */\n+class FormatterUtils {\n+\n+    private static final String LINE_SEPARATOR = \"line.separator\";\n+\n+    /**\n+     * Get the node position.\n+     *\n+     * @param node node\n+     * @return node position\n+     */\n+    static DiagnosticPos getPosition(Node node) {\n+        if (node == null) {\n+            return null;\n+        }\n+        LineRange range = node.lineRange();\n+        LinePosition startPos = range.startLine();\n+        LinePosition endPos = range.endLine();\n+        int startOffset = startPos.offset();\n+        if (node.kind() == (SyntaxKind.FUNCTION_DEFINITION) || node.kind() == (SyntaxKind.TYPE_DEFINITION) ||\n+                node.kind() == (SyntaxKind.CONST_DECLARATION) || node.kind() == (SyntaxKind.OBJECT_TYPE_DESC)) {\n+            startOffset = (startOffset / 4) * 4;\n+        }\n+        return new DiagnosticPos(null, startPos.line() + 1, endPos.line() + 1,\n+                startOffset, endPos.offset());\n+    }\n+\n+    // TODO: Use a generic way to get the parent node using querying.\n+    static <T extends Node> Node getParent(T node, SyntaxKind syntaxKind) {\n+        Node parent = node.parent();\n+        if (parent == null) {\n+            parent = node;\n+        }\n+        Node grandParent = parent.parent();\n+        SyntaxKind parentKind = parent.kind();\n+        if (parentKind == (SyntaxKind.MODULE_VAR_DECL)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE5NDUyNA=="}, "originalCommit": {"oid": "abf30d5163ce0ebdc71f6463696d834f80cc2f05"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NzUyMDA3OnYy", "diffSide": "RIGHT", "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/FormatterUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNzo0NDoxOVrOHQoDLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQwMToyMDowOFrOHRBIdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE5NTQzNw==", "bodyText": "let's add a private constructor", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25680#discussion_r487195437", "createdAt": "2020-09-11T17:44:19Z", "author": {"login": "nadeeshaan"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/FormatterUtils.java", "diffHunk": "@@ -0,0 +1,415 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.core;\n+\n+import io.ballerina.tools.text.LinePosition;\n+import io.ballerina.tools.text.LineRange;\n+import io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory;\n+import io.ballerinalang.compiler.syntax.tree.ChildNodeList;\n+import io.ballerinalang.compiler.syntax.tree.Minutiae;\n+import io.ballerinalang.compiler.syntax.tree.MinutiaeList;\n+import io.ballerinalang.compiler.syntax.tree.Node;\n+import io.ballerinalang.compiler.syntax.tree.NonTerminalNode;\n+import io.ballerinalang.compiler.syntax.tree.SyntaxKind;\n+import io.ballerinalang.compiler.syntax.tree.Token;\n+import org.wso2.ballerinalang.compiler.util.diagnotic.DiagnosticPos;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import static io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory.createMinutiaeList;\n+import static io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory.createWhitespaceMinutiae;\n+\n+/**\n+ * Class that contains the util functions used by the formatting tree modifier.\n+ */\n+class FormatterUtils {\n+\n+    private static final String LINE_SEPARATOR = \"line.separator\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abf30d5163ce0ebdc71f6463696d834f80cc2f05"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzYwNjM5MA==", "bodyText": "Done", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25680#discussion_r487606390", "createdAt": "2020-09-14T01:20:08Z", "author": {"login": "IrushiL"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/FormatterUtils.java", "diffHunk": "@@ -0,0 +1,415 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.core;\n+\n+import io.ballerina.tools.text.LinePosition;\n+import io.ballerina.tools.text.LineRange;\n+import io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory;\n+import io.ballerinalang.compiler.syntax.tree.ChildNodeList;\n+import io.ballerinalang.compiler.syntax.tree.Minutiae;\n+import io.ballerinalang.compiler.syntax.tree.MinutiaeList;\n+import io.ballerinalang.compiler.syntax.tree.Node;\n+import io.ballerinalang.compiler.syntax.tree.NonTerminalNode;\n+import io.ballerinalang.compiler.syntax.tree.SyntaxKind;\n+import io.ballerinalang.compiler.syntax.tree.Token;\n+import org.wso2.ballerinalang.compiler.util.diagnotic.DiagnosticPos;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import static io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory.createMinutiaeList;\n+import static io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory.createWhitespaceMinutiae;\n+\n+/**\n+ * Class that contains the util functions used by the formatting tree modifier.\n+ */\n+class FormatterUtils {\n+\n+    private static final String LINE_SEPARATOR = \"line.separator\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE5NTQzNw=="}, "originalCommit": {"oid": "abf30d5163ce0ebdc71f6463696d834f80cc2f05"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NzUzMjcwOnYy", "diffSide": "RIGHT", "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/FormatterUtils.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNzo0ODoxMlrOHQoK3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQwMzo0MjoxM1rOHRC5VQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE5NzQwNg==", "bodyText": "Effectively we return here a null, is it possible to return an Optional as the return type of the method?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25680#discussion_r487197406", "createdAt": "2020-09-11T17:48:12Z", "author": {"login": "nadeeshaan"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/FormatterUtils.java", "diffHunk": "@@ -0,0 +1,415 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.core;\n+\n+import io.ballerina.tools.text.LinePosition;\n+import io.ballerina.tools.text.LineRange;\n+import io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory;\n+import io.ballerinalang.compiler.syntax.tree.ChildNodeList;\n+import io.ballerinalang.compiler.syntax.tree.Minutiae;\n+import io.ballerinalang.compiler.syntax.tree.MinutiaeList;\n+import io.ballerinalang.compiler.syntax.tree.Node;\n+import io.ballerinalang.compiler.syntax.tree.NonTerminalNode;\n+import io.ballerinalang.compiler.syntax.tree.SyntaxKind;\n+import io.ballerinalang.compiler.syntax.tree.Token;\n+import org.wso2.ballerinalang.compiler.util.diagnotic.DiagnosticPos;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import static io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory.createMinutiaeList;\n+import static io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory.createWhitespaceMinutiae;\n+\n+/**\n+ * Class that contains the util functions used by the formatting tree modifier.\n+ */\n+class FormatterUtils {\n+\n+    private static final String LINE_SEPARATOR = \"line.separator\";\n+\n+    /**\n+     * Get the node position.\n+     *\n+     * @param node node\n+     * @return node position\n+     */\n+    static DiagnosticPos getPosition(Node node) {\n+        if (node == null) {\n+            return null;\n+        }\n+        LineRange range = node.lineRange();\n+        LinePosition startPos = range.startLine();\n+        LinePosition endPos = range.endLine();\n+        int startOffset = startPos.offset();\n+        if (node.kind() == (SyntaxKind.FUNCTION_DEFINITION) || node.kind() == (SyntaxKind.TYPE_DEFINITION) ||\n+                node.kind() == (SyntaxKind.CONST_DECLARATION) || node.kind() == (SyntaxKind.OBJECT_TYPE_DESC)) {\n+            startOffset = (startOffset / 4) * 4;\n+        }\n+        return new DiagnosticPos(null, startPos.line() + 1, endPos.line() + 1,\n+                startOffset, endPos.offset());\n+    }\n+\n+    // TODO: Use a generic way to get the parent node using querying.\n+    static <T extends Node> Node getParent(T node, SyntaxKind syntaxKind) {\n+        Node parent = node.parent();\n+        if (parent == null) {\n+            parent = node;\n+        }\n+        Node grandParent = parent.parent();\n+        SyntaxKind parentKind = parent.kind();\n+        if (parentKind == (SyntaxKind.MODULE_VAR_DECL)) {\n+            if (grandParent != null && grandParent.kind() == (SyntaxKind.MODULE_PART) &&\n+                    syntaxKind == (SyntaxKind.QUALIFIED_NAME_REFERENCE)) {\n+                return null;\n+            }\n+            return parent;\n+        } else if (parentKind == (SyntaxKind.FUNCTION_DEFINITION) ||\n+                parentKind == (SyntaxKind.ELSE_BLOCK) ||\n+                parentKind == (SyntaxKind.IF_ELSE_STATEMENT) ||\n+                parentKind == (SyntaxKind.LOCAL_TYPE_DEFINITION_STATEMENT) ||\n+                parentKind == (SyntaxKind.WHILE_STATEMENT) ||\n+                parentKind == (SyntaxKind.CONST_DECLARATION) ||\n+                parentKind == (SyntaxKind.METHOD_DECLARATION) ||\n+                parentKind == (SyntaxKind.TYPE_DEFINITION)) {\n+            return parent;\n+        } else if (syntaxKind == (SyntaxKind.SIMPLE_NAME_REFERENCE)) {\n+            if (parentKind == (SyntaxKind.REQUIRED_PARAM) ||\n+                    parentKind == (SyntaxKind.POSITIONAL_ARG) ||\n+                    parentKind == (SyntaxKind.BINARY_EXPRESSION) ||\n+                    parentKind == (SyntaxKind.BRACED_EXPRESSION) ||\n+                    parentKind == (SyntaxKind.RETURN_STATEMENT) ||\n+                    parentKind == (SyntaxKind.REMOTE_METHOD_CALL_ACTION) ||\n+                    parentKind == (SyntaxKind.FIELD_ACCESS) ||\n+                    (parentKind == (SyntaxKind.FUNCTION_CALL) && grandParent != null &&\n+                            grandParent.kind() == (SyntaxKind.ASSIGNMENT_STATEMENT))) {\n+                return null;\n+            }\n+            return getParent(parent, syntaxKind);\n+        } else if (syntaxKind == (SyntaxKind.STRING_TYPE_DESC) &&\n+                parentKind == (SyntaxKind.RECORD_FIELD) && grandParent != null &&\n+                grandParent.kind() == (SyntaxKind.RECORD_TYPE_DESC)) {\n+            return getParent(parent, syntaxKind);\n+        } else if (parentKind == (SyntaxKind.SERVICE_DECLARATION) ||\n+                parentKind == (SyntaxKind.BINARY_EXPRESSION)) {\n+            if (syntaxKind == (SyntaxKind.QUALIFIED_NAME_REFERENCE)) {\n+                return null;\n+            }\n+            return parent;\n+        } else if (parentKind == (SyntaxKind.REQUIRED_PARAM)) {\n+            return null;\n+        } else if (parentKind == (SyntaxKind.OBJECT_TYPE_DESC)) {\n+            if (grandParent != null && grandParent.kind() == (SyntaxKind.RETURN_TYPE_DESCRIPTOR)) {\n+                return grandParent.parent().parent();\n+            } else if (grandParent != null && grandParent.kind() == (SyntaxKind.TYPE_DEFINITION)) {\n+                return getParent(parent, syntaxKind);\n+            } else {\n+                return parent;\n+            }\n+        } else if (grandParent != null) {\n+            return getParent(parent, syntaxKind);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    static int getIndentation(Node node, int indentation, FormattingOptions formattingOptions) {\n+        if (node == null) {\n+            return indentation;\n+        }\n+        if (node.parent() != null) {\n+            SyntaxKind parentKind = node.parent().kind();\n+            if (parentKind == SyntaxKind.BLOCK_STATEMENT ||\n+                    parentKind == SyntaxKind.FUNCTION_BODY_BLOCK ||\n+                    parentKind == SyntaxKind.LIST_CONSTRUCTOR ||\n+                    parentKind == SyntaxKind.TYPE_DEFINITION ||\n+                    parentKind == SyntaxKind.METHOD_DECLARATION ||\n+                    parentKind == SyntaxKind.MAPPING_CONSTRUCTOR) {\n+                indentation += formattingOptions.getTabSize();\n+            }\n+        }\n+        return getIndentation(node.parent(), indentation, formattingOptions);\n+    }\n+\n+    private static MinutiaeList getCommentMinutiae(MinutiaeList minutiaeList, boolean isLeading) {\n+        MinutiaeList minutiaes = AbstractNodeFactory.createEmptyMinutiaeList();\n+        for (int i = 0; i < minutiaeList.size(); i++) {\n+            if (minutiaeList.get(i).kind() == (SyntaxKind.COMMENT_MINUTIAE)) {\n+                if (i > 0) {\n+                    minutiaes = minutiaes.add(minutiaeList.get(i - 1));\n+                }\n+                minutiaes = minutiaes.add(minutiaeList.get(i));\n+                if ((i + 1) < minutiaeList.size() && isLeading) {\n+                    minutiaes = minutiaes.add(minutiaeList.get(i + 1));\n+                }\n+            }\n+        }\n+        return minutiaes;\n+    }\n+\n+    private static String getWhiteSpaces(int column, int newLines) {\n+        StringBuilder whiteSpaces = new StringBuilder();\n+        for (int i = 0; i <= (newLines - 1); i++) {\n+            whiteSpaces.append(System.getProperty(LINE_SEPARATOR));\n+        }\n+        for (int i = 0; i <= (column - 1); i++) {\n+            whiteSpaces.append(\" \");\n+        }\n+        return whiteSpaces.toString();\n+    }\n+\n+    /**\n+     * Initialize the token with empty minutiae lists.\n+     *\n+     * @param node node\n+     * @return token with empty minutiae\n+     */\n+    static <T extends Token> Token getToken(T node) {\n+        if (node == null) {\n+            return node;\n+        }\n+        MinutiaeList leadingMinutiaeList = AbstractNodeFactory.createEmptyMinutiaeList();\n+        MinutiaeList trailingMinutiaeList = AbstractNodeFactory.createEmptyMinutiaeList();\n+        if (node.containsLeadingMinutiae()) {\n+            leadingMinutiaeList = getCommentMinutiae(node.leadingMinutiae(), true);\n+        }\n+        if (node.containsTrailingMinutiae()) {\n+            trailingMinutiaeList = getCommentMinutiae(node.trailingMinutiae(), false);\n+        }\n+        return node.modify(leadingMinutiaeList, trailingMinutiaeList);\n+    }\n+\n+    static boolean isInLineRange(Node node, LineRange lineRange) {\n+        if (lineRange == null) {\n+            return true;\n+        }\n+        int nodeStartLine = node.lineRange().startLine().line();\n+        int nodeStartOffset = node.lineRange().startLine().offset();\n+        int nodeEndLine = node.lineRange().endLine().line();\n+        int nodeEndOffset = node.lineRange().endLine().offset();\n+\n+        int startLine = lineRange.startLine().line();\n+        int startOffset = lineRange.startLine().offset();\n+        int endLine = lineRange.endLine().line();\n+        int endOffset = lineRange.endLine().offset();\n+\n+        if (nodeStartLine >= startLine && nodeEndLine <= endLine) {\n+            if (nodeStartLine == startLine || nodeEndLine == endLine) {\n+                return nodeStartOffset >= startOffset && nodeEndOffset <= endOffset;\n+            }\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Update the minutiae and return the token.\n+     *\n+     * @param token            token\n+     * @param leadingSpaces    leading spaces\n+     * @param trailingSpaces   trailing spaces\n+     * @param leadingNewLines  leading new lines\n+     * @param trailingNewLines trailing new lines\n+     * @return updated token\n+     */\n+    static Token formatToken(Token token, int leadingSpaces, int trailingSpaces, int leadingNewLines,\n+                             int trailingNewLines) {\n+        if (token == null) {\n+            return token;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abf30d5163ce0ebdc71f6463696d834f80cc2f05"}, "originalPosition": 232}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzYxNjI0MA==", "bodyText": "Here the intended behavior is to return the token itself if the token value sent for the formatToken method is null. Since we can't really replace a null token with a different value, is there a benefit of wrapping it around an Optional?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25680#discussion_r487616240", "createdAt": "2020-09-14T02:10:38Z", "author": {"login": "IrushiL"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/FormatterUtils.java", "diffHunk": "@@ -0,0 +1,415 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.core;\n+\n+import io.ballerina.tools.text.LinePosition;\n+import io.ballerina.tools.text.LineRange;\n+import io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory;\n+import io.ballerinalang.compiler.syntax.tree.ChildNodeList;\n+import io.ballerinalang.compiler.syntax.tree.Minutiae;\n+import io.ballerinalang.compiler.syntax.tree.MinutiaeList;\n+import io.ballerinalang.compiler.syntax.tree.Node;\n+import io.ballerinalang.compiler.syntax.tree.NonTerminalNode;\n+import io.ballerinalang.compiler.syntax.tree.SyntaxKind;\n+import io.ballerinalang.compiler.syntax.tree.Token;\n+import org.wso2.ballerinalang.compiler.util.diagnotic.DiagnosticPos;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import static io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory.createMinutiaeList;\n+import static io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory.createWhitespaceMinutiae;\n+\n+/**\n+ * Class that contains the util functions used by the formatting tree modifier.\n+ */\n+class FormatterUtils {\n+\n+    private static final String LINE_SEPARATOR = \"line.separator\";\n+\n+    /**\n+     * Get the node position.\n+     *\n+     * @param node node\n+     * @return node position\n+     */\n+    static DiagnosticPos getPosition(Node node) {\n+        if (node == null) {\n+            return null;\n+        }\n+        LineRange range = node.lineRange();\n+        LinePosition startPos = range.startLine();\n+        LinePosition endPos = range.endLine();\n+        int startOffset = startPos.offset();\n+        if (node.kind() == (SyntaxKind.FUNCTION_DEFINITION) || node.kind() == (SyntaxKind.TYPE_DEFINITION) ||\n+                node.kind() == (SyntaxKind.CONST_DECLARATION) || node.kind() == (SyntaxKind.OBJECT_TYPE_DESC)) {\n+            startOffset = (startOffset / 4) * 4;\n+        }\n+        return new DiagnosticPos(null, startPos.line() + 1, endPos.line() + 1,\n+                startOffset, endPos.offset());\n+    }\n+\n+    // TODO: Use a generic way to get the parent node using querying.\n+    static <T extends Node> Node getParent(T node, SyntaxKind syntaxKind) {\n+        Node parent = node.parent();\n+        if (parent == null) {\n+            parent = node;\n+        }\n+        Node grandParent = parent.parent();\n+        SyntaxKind parentKind = parent.kind();\n+        if (parentKind == (SyntaxKind.MODULE_VAR_DECL)) {\n+            if (grandParent != null && grandParent.kind() == (SyntaxKind.MODULE_PART) &&\n+                    syntaxKind == (SyntaxKind.QUALIFIED_NAME_REFERENCE)) {\n+                return null;\n+            }\n+            return parent;\n+        } else if (parentKind == (SyntaxKind.FUNCTION_DEFINITION) ||\n+                parentKind == (SyntaxKind.ELSE_BLOCK) ||\n+                parentKind == (SyntaxKind.IF_ELSE_STATEMENT) ||\n+                parentKind == (SyntaxKind.LOCAL_TYPE_DEFINITION_STATEMENT) ||\n+                parentKind == (SyntaxKind.WHILE_STATEMENT) ||\n+                parentKind == (SyntaxKind.CONST_DECLARATION) ||\n+                parentKind == (SyntaxKind.METHOD_DECLARATION) ||\n+                parentKind == (SyntaxKind.TYPE_DEFINITION)) {\n+            return parent;\n+        } else if (syntaxKind == (SyntaxKind.SIMPLE_NAME_REFERENCE)) {\n+            if (parentKind == (SyntaxKind.REQUIRED_PARAM) ||\n+                    parentKind == (SyntaxKind.POSITIONAL_ARG) ||\n+                    parentKind == (SyntaxKind.BINARY_EXPRESSION) ||\n+                    parentKind == (SyntaxKind.BRACED_EXPRESSION) ||\n+                    parentKind == (SyntaxKind.RETURN_STATEMENT) ||\n+                    parentKind == (SyntaxKind.REMOTE_METHOD_CALL_ACTION) ||\n+                    parentKind == (SyntaxKind.FIELD_ACCESS) ||\n+                    (parentKind == (SyntaxKind.FUNCTION_CALL) && grandParent != null &&\n+                            grandParent.kind() == (SyntaxKind.ASSIGNMENT_STATEMENT))) {\n+                return null;\n+            }\n+            return getParent(parent, syntaxKind);\n+        } else if (syntaxKind == (SyntaxKind.STRING_TYPE_DESC) &&\n+                parentKind == (SyntaxKind.RECORD_FIELD) && grandParent != null &&\n+                grandParent.kind() == (SyntaxKind.RECORD_TYPE_DESC)) {\n+            return getParent(parent, syntaxKind);\n+        } else if (parentKind == (SyntaxKind.SERVICE_DECLARATION) ||\n+                parentKind == (SyntaxKind.BINARY_EXPRESSION)) {\n+            if (syntaxKind == (SyntaxKind.QUALIFIED_NAME_REFERENCE)) {\n+                return null;\n+            }\n+            return parent;\n+        } else if (parentKind == (SyntaxKind.REQUIRED_PARAM)) {\n+            return null;\n+        } else if (parentKind == (SyntaxKind.OBJECT_TYPE_DESC)) {\n+            if (grandParent != null && grandParent.kind() == (SyntaxKind.RETURN_TYPE_DESCRIPTOR)) {\n+                return grandParent.parent().parent();\n+            } else if (grandParent != null && grandParent.kind() == (SyntaxKind.TYPE_DEFINITION)) {\n+                return getParent(parent, syntaxKind);\n+            } else {\n+                return parent;\n+            }\n+        } else if (grandParent != null) {\n+            return getParent(parent, syntaxKind);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    static int getIndentation(Node node, int indentation, FormattingOptions formattingOptions) {\n+        if (node == null) {\n+            return indentation;\n+        }\n+        if (node.parent() != null) {\n+            SyntaxKind parentKind = node.parent().kind();\n+            if (parentKind == SyntaxKind.BLOCK_STATEMENT ||\n+                    parentKind == SyntaxKind.FUNCTION_BODY_BLOCK ||\n+                    parentKind == SyntaxKind.LIST_CONSTRUCTOR ||\n+                    parentKind == SyntaxKind.TYPE_DEFINITION ||\n+                    parentKind == SyntaxKind.METHOD_DECLARATION ||\n+                    parentKind == SyntaxKind.MAPPING_CONSTRUCTOR) {\n+                indentation += formattingOptions.getTabSize();\n+            }\n+        }\n+        return getIndentation(node.parent(), indentation, formattingOptions);\n+    }\n+\n+    private static MinutiaeList getCommentMinutiae(MinutiaeList minutiaeList, boolean isLeading) {\n+        MinutiaeList minutiaes = AbstractNodeFactory.createEmptyMinutiaeList();\n+        for (int i = 0; i < minutiaeList.size(); i++) {\n+            if (minutiaeList.get(i).kind() == (SyntaxKind.COMMENT_MINUTIAE)) {\n+                if (i > 0) {\n+                    minutiaes = minutiaes.add(minutiaeList.get(i - 1));\n+                }\n+                minutiaes = minutiaes.add(minutiaeList.get(i));\n+                if ((i + 1) < minutiaeList.size() && isLeading) {\n+                    minutiaes = minutiaes.add(minutiaeList.get(i + 1));\n+                }\n+            }\n+        }\n+        return minutiaes;\n+    }\n+\n+    private static String getWhiteSpaces(int column, int newLines) {\n+        StringBuilder whiteSpaces = new StringBuilder();\n+        for (int i = 0; i <= (newLines - 1); i++) {\n+            whiteSpaces.append(System.getProperty(LINE_SEPARATOR));\n+        }\n+        for (int i = 0; i <= (column - 1); i++) {\n+            whiteSpaces.append(\" \");\n+        }\n+        return whiteSpaces.toString();\n+    }\n+\n+    /**\n+     * Initialize the token with empty minutiae lists.\n+     *\n+     * @param node node\n+     * @return token with empty minutiae\n+     */\n+    static <T extends Token> Token getToken(T node) {\n+        if (node == null) {\n+            return node;\n+        }\n+        MinutiaeList leadingMinutiaeList = AbstractNodeFactory.createEmptyMinutiaeList();\n+        MinutiaeList trailingMinutiaeList = AbstractNodeFactory.createEmptyMinutiaeList();\n+        if (node.containsLeadingMinutiae()) {\n+            leadingMinutiaeList = getCommentMinutiae(node.leadingMinutiae(), true);\n+        }\n+        if (node.containsTrailingMinutiae()) {\n+            trailingMinutiaeList = getCommentMinutiae(node.trailingMinutiae(), false);\n+        }\n+        return node.modify(leadingMinutiaeList, trailingMinutiaeList);\n+    }\n+\n+    static boolean isInLineRange(Node node, LineRange lineRange) {\n+        if (lineRange == null) {\n+            return true;\n+        }\n+        int nodeStartLine = node.lineRange().startLine().line();\n+        int nodeStartOffset = node.lineRange().startLine().offset();\n+        int nodeEndLine = node.lineRange().endLine().line();\n+        int nodeEndOffset = node.lineRange().endLine().offset();\n+\n+        int startLine = lineRange.startLine().line();\n+        int startOffset = lineRange.startLine().offset();\n+        int endLine = lineRange.endLine().line();\n+        int endOffset = lineRange.endLine().offset();\n+\n+        if (nodeStartLine >= startLine && nodeEndLine <= endLine) {\n+            if (nodeStartLine == startLine || nodeEndLine == endLine) {\n+                return nodeStartOffset >= startOffset && nodeEndOffset <= endOffset;\n+            }\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Update the minutiae and return the token.\n+     *\n+     * @param token            token\n+     * @param leadingSpaces    leading spaces\n+     * @param trailingSpaces   trailing spaces\n+     * @param leadingNewLines  leading new lines\n+     * @param trailingNewLines trailing new lines\n+     * @return updated token\n+     */\n+    static Token formatToken(Token token, int leadingSpaces, int trailingSpaces, int leadingNewLines,\n+                             int trailingNewLines) {\n+        if (token == null) {\n+            return token;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE5NzQwNg=="}, "originalCommit": {"oid": "abf30d5163ce0ebdc71f6463696d834f80cc2f05"}, "originalPosition": 232}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzYzNDk5MQ==", "bodyText": "When we wrapping inside an Optional, particular API usage has to explicitly check for the isPresent. Otherwise there is a chance we are missing the null check and run into NPEs.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25680#discussion_r487634991", "createdAt": "2020-09-14T03:40:52Z", "author": {"login": "nadeeshaan"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/FormatterUtils.java", "diffHunk": "@@ -0,0 +1,415 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.core;\n+\n+import io.ballerina.tools.text.LinePosition;\n+import io.ballerina.tools.text.LineRange;\n+import io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory;\n+import io.ballerinalang.compiler.syntax.tree.ChildNodeList;\n+import io.ballerinalang.compiler.syntax.tree.Minutiae;\n+import io.ballerinalang.compiler.syntax.tree.MinutiaeList;\n+import io.ballerinalang.compiler.syntax.tree.Node;\n+import io.ballerinalang.compiler.syntax.tree.NonTerminalNode;\n+import io.ballerinalang.compiler.syntax.tree.SyntaxKind;\n+import io.ballerinalang.compiler.syntax.tree.Token;\n+import org.wso2.ballerinalang.compiler.util.diagnotic.DiagnosticPos;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import static io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory.createMinutiaeList;\n+import static io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory.createWhitespaceMinutiae;\n+\n+/**\n+ * Class that contains the util functions used by the formatting tree modifier.\n+ */\n+class FormatterUtils {\n+\n+    private static final String LINE_SEPARATOR = \"line.separator\";\n+\n+    /**\n+     * Get the node position.\n+     *\n+     * @param node node\n+     * @return node position\n+     */\n+    static DiagnosticPos getPosition(Node node) {\n+        if (node == null) {\n+            return null;\n+        }\n+        LineRange range = node.lineRange();\n+        LinePosition startPos = range.startLine();\n+        LinePosition endPos = range.endLine();\n+        int startOffset = startPos.offset();\n+        if (node.kind() == (SyntaxKind.FUNCTION_DEFINITION) || node.kind() == (SyntaxKind.TYPE_DEFINITION) ||\n+                node.kind() == (SyntaxKind.CONST_DECLARATION) || node.kind() == (SyntaxKind.OBJECT_TYPE_DESC)) {\n+            startOffset = (startOffset / 4) * 4;\n+        }\n+        return new DiagnosticPos(null, startPos.line() + 1, endPos.line() + 1,\n+                startOffset, endPos.offset());\n+    }\n+\n+    // TODO: Use a generic way to get the parent node using querying.\n+    static <T extends Node> Node getParent(T node, SyntaxKind syntaxKind) {\n+        Node parent = node.parent();\n+        if (parent == null) {\n+            parent = node;\n+        }\n+        Node grandParent = parent.parent();\n+        SyntaxKind parentKind = parent.kind();\n+        if (parentKind == (SyntaxKind.MODULE_VAR_DECL)) {\n+            if (grandParent != null && grandParent.kind() == (SyntaxKind.MODULE_PART) &&\n+                    syntaxKind == (SyntaxKind.QUALIFIED_NAME_REFERENCE)) {\n+                return null;\n+            }\n+            return parent;\n+        } else if (parentKind == (SyntaxKind.FUNCTION_DEFINITION) ||\n+                parentKind == (SyntaxKind.ELSE_BLOCK) ||\n+                parentKind == (SyntaxKind.IF_ELSE_STATEMENT) ||\n+                parentKind == (SyntaxKind.LOCAL_TYPE_DEFINITION_STATEMENT) ||\n+                parentKind == (SyntaxKind.WHILE_STATEMENT) ||\n+                parentKind == (SyntaxKind.CONST_DECLARATION) ||\n+                parentKind == (SyntaxKind.METHOD_DECLARATION) ||\n+                parentKind == (SyntaxKind.TYPE_DEFINITION)) {\n+            return parent;\n+        } else if (syntaxKind == (SyntaxKind.SIMPLE_NAME_REFERENCE)) {\n+            if (parentKind == (SyntaxKind.REQUIRED_PARAM) ||\n+                    parentKind == (SyntaxKind.POSITIONAL_ARG) ||\n+                    parentKind == (SyntaxKind.BINARY_EXPRESSION) ||\n+                    parentKind == (SyntaxKind.BRACED_EXPRESSION) ||\n+                    parentKind == (SyntaxKind.RETURN_STATEMENT) ||\n+                    parentKind == (SyntaxKind.REMOTE_METHOD_CALL_ACTION) ||\n+                    parentKind == (SyntaxKind.FIELD_ACCESS) ||\n+                    (parentKind == (SyntaxKind.FUNCTION_CALL) && grandParent != null &&\n+                            grandParent.kind() == (SyntaxKind.ASSIGNMENT_STATEMENT))) {\n+                return null;\n+            }\n+            return getParent(parent, syntaxKind);\n+        } else if (syntaxKind == (SyntaxKind.STRING_TYPE_DESC) &&\n+                parentKind == (SyntaxKind.RECORD_FIELD) && grandParent != null &&\n+                grandParent.kind() == (SyntaxKind.RECORD_TYPE_DESC)) {\n+            return getParent(parent, syntaxKind);\n+        } else if (parentKind == (SyntaxKind.SERVICE_DECLARATION) ||\n+                parentKind == (SyntaxKind.BINARY_EXPRESSION)) {\n+            if (syntaxKind == (SyntaxKind.QUALIFIED_NAME_REFERENCE)) {\n+                return null;\n+            }\n+            return parent;\n+        } else if (parentKind == (SyntaxKind.REQUIRED_PARAM)) {\n+            return null;\n+        } else if (parentKind == (SyntaxKind.OBJECT_TYPE_DESC)) {\n+            if (grandParent != null && grandParent.kind() == (SyntaxKind.RETURN_TYPE_DESCRIPTOR)) {\n+                return grandParent.parent().parent();\n+            } else if (grandParent != null && grandParent.kind() == (SyntaxKind.TYPE_DEFINITION)) {\n+                return getParent(parent, syntaxKind);\n+            } else {\n+                return parent;\n+            }\n+        } else if (grandParent != null) {\n+            return getParent(parent, syntaxKind);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    static int getIndentation(Node node, int indentation, FormattingOptions formattingOptions) {\n+        if (node == null) {\n+            return indentation;\n+        }\n+        if (node.parent() != null) {\n+            SyntaxKind parentKind = node.parent().kind();\n+            if (parentKind == SyntaxKind.BLOCK_STATEMENT ||\n+                    parentKind == SyntaxKind.FUNCTION_BODY_BLOCK ||\n+                    parentKind == SyntaxKind.LIST_CONSTRUCTOR ||\n+                    parentKind == SyntaxKind.TYPE_DEFINITION ||\n+                    parentKind == SyntaxKind.METHOD_DECLARATION ||\n+                    parentKind == SyntaxKind.MAPPING_CONSTRUCTOR) {\n+                indentation += formattingOptions.getTabSize();\n+            }\n+        }\n+        return getIndentation(node.parent(), indentation, formattingOptions);\n+    }\n+\n+    private static MinutiaeList getCommentMinutiae(MinutiaeList minutiaeList, boolean isLeading) {\n+        MinutiaeList minutiaes = AbstractNodeFactory.createEmptyMinutiaeList();\n+        for (int i = 0; i < minutiaeList.size(); i++) {\n+            if (minutiaeList.get(i).kind() == (SyntaxKind.COMMENT_MINUTIAE)) {\n+                if (i > 0) {\n+                    minutiaes = minutiaes.add(minutiaeList.get(i - 1));\n+                }\n+                minutiaes = minutiaes.add(minutiaeList.get(i));\n+                if ((i + 1) < minutiaeList.size() && isLeading) {\n+                    minutiaes = minutiaes.add(minutiaeList.get(i + 1));\n+                }\n+            }\n+        }\n+        return minutiaes;\n+    }\n+\n+    private static String getWhiteSpaces(int column, int newLines) {\n+        StringBuilder whiteSpaces = new StringBuilder();\n+        for (int i = 0; i <= (newLines - 1); i++) {\n+            whiteSpaces.append(System.getProperty(LINE_SEPARATOR));\n+        }\n+        for (int i = 0; i <= (column - 1); i++) {\n+            whiteSpaces.append(\" \");\n+        }\n+        return whiteSpaces.toString();\n+    }\n+\n+    /**\n+     * Initialize the token with empty minutiae lists.\n+     *\n+     * @param node node\n+     * @return token with empty minutiae\n+     */\n+    static <T extends Token> Token getToken(T node) {\n+        if (node == null) {\n+            return node;\n+        }\n+        MinutiaeList leadingMinutiaeList = AbstractNodeFactory.createEmptyMinutiaeList();\n+        MinutiaeList trailingMinutiaeList = AbstractNodeFactory.createEmptyMinutiaeList();\n+        if (node.containsLeadingMinutiae()) {\n+            leadingMinutiaeList = getCommentMinutiae(node.leadingMinutiae(), true);\n+        }\n+        if (node.containsTrailingMinutiae()) {\n+            trailingMinutiaeList = getCommentMinutiae(node.trailingMinutiae(), false);\n+        }\n+        return node.modify(leadingMinutiaeList, trailingMinutiaeList);\n+    }\n+\n+    static boolean isInLineRange(Node node, LineRange lineRange) {\n+        if (lineRange == null) {\n+            return true;\n+        }\n+        int nodeStartLine = node.lineRange().startLine().line();\n+        int nodeStartOffset = node.lineRange().startLine().offset();\n+        int nodeEndLine = node.lineRange().endLine().line();\n+        int nodeEndOffset = node.lineRange().endLine().offset();\n+\n+        int startLine = lineRange.startLine().line();\n+        int startOffset = lineRange.startLine().offset();\n+        int endLine = lineRange.endLine().line();\n+        int endOffset = lineRange.endLine().offset();\n+\n+        if (nodeStartLine >= startLine && nodeEndLine <= endLine) {\n+            if (nodeStartLine == startLine || nodeEndLine == endLine) {\n+                return nodeStartOffset >= startOffset && nodeEndOffset <= endOffset;\n+            }\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Update the minutiae and return the token.\n+     *\n+     * @param token            token\n+     * @param leadingSpaces    leading spaces\n+     * @param trailingSpaces   trailing spaces\n+     * @param leadingNewLines  leading new lines\n+     * @param trailingNewLines trailing new lines\n+     * @return updated token\n+     */\n+    static Token formatToken(Token token, int leadingSpaces, int trailingSpaces, int leadingNewLines,\n+                             int trailingNewLines) {\n+        if (token == null) {\n+            return token;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE5NzQwNg=="}, "originalCommit": {"oid": "abf30d5163ce0ebdc71f6463696d834f80cc2f05"}, "originalPosition": 232}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzYzNTI4NQ==", "bodyText": "I see. I will incorporate this in the refactoring PR.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25680#discussion_r487635285", "createdAt": "2020-09-14T03:42:13Z", "author": {"login": "IrushiL"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/FormatterUtils.java", "diffHunk": "@@ -0,0 +1,415 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.core;\n+\n+import io.ballerina.tools.text.LinePosition;\n+import io.ballerina.tools.text.LineRange;\n+import io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory;\n+import io.ballerinalang.compiler.syntax.tree.ChildNodeList;\n+import io.ballerinalang.compiler.syntax.tree.Minutiae;\n+import io.ballerinalang.compiler.syntax.tree.MinutiaeList;\n+import io.ballerinalang.compiler.syntax.tree.Node;\n+import io.ballerinalang.compiler.syntax.tree.NonTerminalNode;\n+import io.ballerinalang.compiler.syntax.tree.SyntaxKind;\n+import io.ballerinalang.compiler.syntax.tree.Token;\n+import org.wso2.ballerinalang.compiler.util.diagnotic.DiagnosticPos;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import static io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory.createMinutiaeList;\n+import static io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory.createWhitespaceMinutiae;\n+\n+/**\n+ * Class that contains the util functions used by the formatting tree modifier.\n+ */\n+class FormatterUtils {\n+\n+    private static final String LINE_SEPARATOR = \"line.separator\";\n+\n+    /**\n+     * Get the node position.\n+     *\n+     * @param node node\n+     * @return node position\n+     */\n+    static DiagnosticPos getPosition(Node node) {\n+        if (node == null) {\n+            return null;\n+        }\n+        LineRange range = node.lineRange();\n+        LinePosition startPos = range.startLine();\n+        LinePosition endPos = range.endLine();\n+        int startOffset = startPos.offset();\n+        if (node.kind() == (SyntaxKind.FUNCTION_DEFINITION) || node.kind() == (SyntaxKind.TYPE_DEFINITION) ||\n+                node.kind() == (SyntaxKind.CONST_DECLARATION) || node.kind() == (SyntaxKind.OBJECT_TYPE_DESC)) {\n+            startOffset = (startOffset / 4) * 4;\n+        }\n+        return new DiagnosticPos(null, startPos.line() + 1, endPos.line() + 1,\n+                startOffset, endPos.offset());\n+    }\n+\n+    // TODO: Use a generic way to get the parent node using querying.\n+    static <T extends Node> Node getParent(T node, SyntaxKind syntaxKind) {\n+        Node parent = node.parent();\n+        if (parent == null) {\n+            parent = node;\n+        }\n+        Node grandParent = parent.parent();\n+        SyntaxKind parentKind = parent.kind();\n+        if (parentKind == (SyntaxKind.MODULE_VAR_DECL)) {\n+            if (grandParent != null && grandParent.kind() == (SyntaxKind.MODULE_PART) &&\n+                    syntaxKind == (SyntaxKind.QUALIFIED_NAME_REFERENCE)) {\n+                return null;\n+            }\n+            return parent;\n+        } else if (parentKind == (SyntaxKind.FUNCTION_DEFINITION) ||\n+                parentKind == (SyntaxKind.ELSE_BLOCK) ||\n+                parentKind == (SyntaxKind.IF_ELSE_STATEMENT) ||\n+                parentKind == (SyntaxKind.LOCAL_TYPE_DEFINITION_STATEMENT) ||\n+                parentKind == (SyntaxKind.WHILE_STATEMENT) ||\n+                parentKind == (SyntaxKind.CONST_DECLARATION) ||\n+                parentKind == (SyntaxKind.METHOD_DECLARATION) ||\n+                parentKind == (SyntaxKind.TYPE_DEFINITION)) {\n+            return parent;\n+        } else if (syntaxKind == (SyntaxKind.SIMPLE_NAME_REFERENCE)) {\n+            if (parentKind == (SyntaxKind.REQUIRED_PARAM) ||\n+                    parentKind == (SyntaxKind.POSITIONAL_ARG) ||\n+                    parentKind == (SyntaxKind.BINARY_EXPRESSION) ||\n+                    parentKind == (SyntaxKind.BRACED_EXPRESSION) ||\n+                    parentKind == (SyntaxKind.RETURN_STATEMENT) ||\n+                    parentKind == (SyntaxKind.REMOTE_METHOD_CALL_ACTION) ||\n+                    parentKind == (SyntaxKind.FIELD_ACCESS) ||\n+                    (parentKind == (SyntaxKind.FUNCTION_CALL) && grandParent != null &&\n+                            grandParent.kind() == (SyntaxKind.ASSIGNMENT_STATEMENT))) {\n+                return null;\n+            }\n+            return getParent(parent, syntaxKind);\n+        } else if (syntaxKind == (SyntaxKind.STRING_TYPE_DESC) &&\n+                parentKind == (SyntaxKind.RECORD_FIELD) && grandParent != null &&\n+                grandParent.kind() == (SyntaxKind.RECORD_TYPE_DESC)) {\n+            return getParent(parent, syntaxKind);\n+        } else if (parentKind == (SyntaxKind.SERVICE_DECLARATION) ||\n+                parentKind == (SyntaxKind.BINARY_EXPRESSION)) {\n+            if (syntaxKind == (SyntaxKind.QUALIFIED_NAME_REFERENCE)) {\n+                return null;\n+            }\n+            return parent;\n+        } else if (parentKind == (SyntaxKind.REQUIRED_PARAM)) {\n+            return null;\n+        } else if (parentKind == (SyntaxKind.OBJECT_TYPE_DESC)) {\n+            if (grandParent != null && grandParent.kind() == (SyntaxKind.RETURN_TYPE_DESCRIPTOR)) {\n+                return grandParent.parent().parent();\n+            } else if (grandParent != null && grandParent.kind() == (SyntaxKind.TYPE_DEFINITION)) {\n+                return getParent(parent, syntaxKind);\n+            } else {\n+                return parent;\n+            }\n+        } else if (grandParent != null) {\n+            return getParent(parent, syntaxKind);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    static int getIndentation(Node node, int indentation, FormattingOptions formattingOptions) {\n+        if (node == null) {\n+            return indentation;\n+        }\n+        if (node.parent() != null) {\n+            SyntaxKind parentKind = node.parent().kind();\n+            if (parentKind == SyntaxKind.BLOCK_STATEMENT ||\n+                    parentKind == SyntaxKind.FUNCTION_BODY_BLOCK ||\n+                    parentKind == SyntaxKind.LIST_CONSTRUCTOR ||\n+                    parentKind == SyntaxKind.TYPE_DEFINITION ||\n+                    parentKind == SyntaxKind.METHOD_DECLARATION ||\n+                    parentKind == SyntaxKind.MAPPING_CONSTRUCTOR) {\n+                indentation += formattingOptions.getTabSize();\n+            }\n+        }\n+        return getIndentation(node.parent(), indentation, formattingOptions);\n+    }\n+\n+    private static MinutiaeList getCommentMinutiae(MinutiaeList minutiaeList, boolean isLeading) {\n+        MinutiaeList minutiaes = AbstractNodeFactory.createEmptyMinutiaeList();\n+        for (int i = 0; i < minutiaeList.size(); i++) {\n+            if (minutiaeList.get(i).kind() == (SyntaxKind.COMMENT_MINUTIAE)) {\n+                if (i > 0) {\n+                    minutiaes = minutiaes.add(minutiaeList.get(i - 1));\n+                }\n+                minutiaes = minutiaes.add(minutiaeList.get(i));\n+                if ((i + 1) < minutiaeList.size() && isLeading) {\n+                    minutiaes = minutiaes.add(minutiaeList.get(i + 1));\n+                }\n+            }\n+        }\n+        return minutiaes;\n+    }\n+\n+    private static String getWhiteSpaces(int column, int newLines) {\n+        StringBuilder whiteSpaces = new StringBuilder();\n+        for (int i = 0; i <= (newLines - 1); i++) {\n+            whiteSpaces.append(System.getProperty(LINE_SEPARATOR));\n+        }\n+        for (int i = 0; i <= (column - 1); i++) {\n+            whiteSpaces.append(\" \");\n+        }\n+        return whiteSpaces.toString();\n+    }\n+\n+    /**\n+     * Initialize the token with empty minutiae lists.\n+     *\n+     * @param node node\n+     * @return token with empty minutiae\n+     */\n+    static <T extends Token> Token getToken(T node) {\n+        if (node == null) {\n+            return node;\n+        }\n+        MinutiaeList leadingMinutiaeList = AbstractNodeFactory.createEmptyMinutiaeList();\n+        MinutiaeList trailingMinutiaeList = AbstractNodeFactory.createEmptyMinutiaeList();\n+        if (node.containsLeadingMinutiae()) {\n+            leadingMinutiaeList = getCommentMinutiae(node.leadingMinutiae(), true);\n+        }\n+        if (node.containsTrailingMinutiae()) {\n+            trailingMinutiaeList = getCommentMinutiae(node.trailingMinutiae(), false);\n+        }\n+        return node.modify(leadingMinutiaeList, trailingMinutiaeList);\n+    }\n+\n+    static boolean isInLineRange(Node node, LineRange lineRange) {\n+        if (lineRange == null) {\n+            return true;\n+        }\n+        int nodeStartLine = node.lineRange().startLine().line();\n+        int nodeStartOffset = node.lineRange().startLine().offset();\n+        int nodeEndLine = node.lineRange().endLine().line();\n+        int nodeEndOffset = node.lineRange().endLine().offset();\n+\n+        int startLine = lineRange.startLine().line();\n+        int startOffset = lineRange.startLine().offset();\n+        int endLine = lineRange.endLine().line();\n+        int endOffset = lineRange.endLine().offset();\n+\n+        if (nodeStartLine >= startLine && nodeEndLine <= endLine) {\n+            if (nodeStartLine == startLine || nodeEndLine == endLine) {\n+                return nodeStartOffset >= startOffset && nodeEndOffset <= endOffset;\n+            }\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Update the minutiae and return the token.\n+     *\n+     * @param token            token\n+     * @param leadingSpaces    leading spaces\n+     * @param trailingSpaces   trailing spaces\n+     * @param leadingNewLines  leading new lines\n+     * @param trailingNewLines trailing new lines\n+     * @return updated token\n+     */\n+    static Token formatToken(Token token, int leadingSpaces, int trailingSpaces, int leadingNewLines,\n+                             int trailingNewLines) {\n+        if (token == null) {\n+            return token;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE5NzQwNg=="}, "originalCommit": {"oid": "abf30d5163ce0ebdc71f6463696d834f80cc2f05"}, "originalPosition": 232}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NzUzNjgwOnYy", "diffSide": "RIGHT", "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/FormatterUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNzo0OToyN1rOHQoNSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQwMToxOTo1NlrOHRBIWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE5ODAyNQ==", "bodyText": "Let's do an early return here", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25680#discussion_r487198025", "createdAt": "2020-09-11T17:49:27Z", "author": {"login": "nadeeshaan"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/FormatterUtils.java", "diffHunk": "@@ -0,0 +1,415 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.core;\n+\n+import io.ballerina.tools.text.LinePosition;\n+import io.ballerina.tools.text.LineRange;\n+import io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory;\n+import io.ballerinalang.compiler.syntax.tree.ChildNodeList;\n+import io.ballerinalang.compiler.syntax.tree.Minutiae;\n+import io.ballerinalang.compiler.syntax.tree.MinutiaeList;\n+import io.ballerinalang.compiler.syntax.tree.Node;\n+import io.ballerinalang.compiler.syntax.tree.NonTerminalNode;\n+import io.ballerinalang.compiler.syntax.tree.SyntaxKind;\n+import io.ballerinalang.compiler.syntax.tree.Token;\n+import org.wso2.ballerinalang.compiler.util.diagnotic.DiagnosticPos;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import static io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory.createMinutiaeList;\n+import static io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory.createWhitespaceMinutiae;\n+\n+/**\n+ * Class that contains the util functions used by the formatting tree modifier.\n+ */\n+class FormatterUtils {\n+\n+    private static final String LINE_SEPARATOR = \"line.separator\";\n+\n+    /**\n+     * Get the node position.\n+     *\n+     * @param node node\n+     * @return node position\n+     */\n+    static DiagnosticPos getPosition(Node node) {\n+        if (node == null) {\n+            return null;\n+        }\n+        LineRange range = node.lineRange();\n+        LinePosition startPos = range.startLine();\n+        LinePosition endPos = range.endLine();\n+        int startOffset = startPos.offset();\n+        if (node.kind() == (SyntaxKind.FUNCTION_DEFINITION) || node.kind() == (SyntaxKind.TYPE_DEFINITION) ||\n+                node.kind() == (SyntaxKind.CONST_DECLARATION) || node.kind() == (SyntaxKind.OBJECT_TYPE_DESC)) {\n+            startOffset = (startOffset / 4) * 4;\n+        }\n+        return new DiagnosticPos(null, startPos.line() + 1, endPos.line() + 1,\n+                startOffset, endPos.offset());\n+    }\n+\n+    // TODO: Use a generic way to get the parent node using querying.\n+    static <T extends Node> Node getParent(T node, SyntaxKind syntaxKind) {\n+        Node parent = node.parent();\n+        if (parent == null) {\n+            parent = node;\n+        }\n+        Node grandParent = parent.parent();\n+        SyntaxKind parentKind = parent.kind();\n+        if (parentKind == (SyntaxKind.MODULE_VAR_DECL)) {\n+            if (grandParent != null && grandParent.kind() == (SyntaxKind.MODULE_PART) &&\n+                    syntaxKind == (SyntaxKind.QUALIFIED_NAME_REFERENCE)) {\n+                return null;\n+            }\n+            return parent;\n+        } else if (parentKind == (SyntaxKind.FUNCTION_DEFINITION) ||\n+                parentKind == (SyntaxKind.ELSE_BLOCK) ||\n+                parentKind == (SyntaxKind.IF_ELSE_STATEMENT) ||\n+                parentKind == (SyntaxKind.LOCAL_TYPE_DEFINITION_STATEMENT) ||\n+                parentKind == (SyntaxKind.WHILE_STATEMENT) ||\n+                parentKind == (SyntaxKind.CONST_DECLARATION) ||\n+                parentKind == (SyntaxKind.METHOD_DECLARATION) ||\n+                parentKind == (SyntaxKind.TYPE_DEFINITION)) {\n+            return parent;\n+        } else if (syntaxKind == (SyntaxKind.SIMPLE_NAME_REFERENCE)) {\n+            if (parentKind == (SyntaxKind.REQUIRED_PARAM) ||\n+                    parentKind == (SyntaxKind.POSITIONAL_ARG) ||\n+                    parentKind == (SyntaxKind.BINARY_EXPRESSION) ||\n+                    parentKind == (SyntaxKind.BRACED_EXPRESSION) ||\n+                    parentKind == (SyntaxKind.RETURN_STATEMENT) ||\n+                    parentKind == (SyntaxKind.REMOTE_METHOD_CALL_ACTION) ||\n+                    parentKind == (SyntaxKind.FIELD_ACCESS) ||\n+                    (parentKind == (SyntaxKind.FUNCTION_CALL) && grandParent != null &&\n+                            grandParent.kind() == (SyntaxKind.ASSIGNMENT_STATEMENT))) {\n+                return null;\n+            }\n+            return getParent(parent, syntaxKind);\n+        } else if (syntaxKind == (SyntaxKind.STRING_TYPE_DESC) &&\n+                parentKind == (SyntaxKind.RECORD_FIELD) && grandParent != null &&\n+                grandParent.kind() == (SyntaxKind.RECORD_TYPE_DESC)) {\n+            return getParent(parent, syntaxKind);\n+        } else if (parentKind == (SyntaxKind.SERVICE_DECLARATION) ||\n+                parentKind == (SyntaxKind.BINARY_EXPRESSION)) {\n+            if (syntaxKind == (SyntaxKind.QUALIFIED_NAME_REFERENCE)) {\n+                return null;\n+            }\n+            return parent;\n+        } else if (parentKind == (SyntaxKind.REQUIRED_PARAM)) {\n+            return null;\n+        } else if (parentKind == (SyntaxKind.OBJECT_TYPE_DESC)) {\n+            if (grandParent != null && grandParent.kind() == (SyntaxKind.RETURN_TYPE_DESCRIPTOR)) {\n+                return grandParent.parent().parent();\n+            } else if (grandParent != null && grandParent.kind() == (SyntaxKind.TYPE_DEFINITION)) {\n+                return getParent(parent, syntaxKind);\n+            } else {\n+                return parent;\n+            }\n+        } else if (grandParent != null) {\n+            return getParent(parent, syntaxKind);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    static int getIndentation(Node node, int indentation, FormattingOptions formattingOptions) {\n+        if (node == null) {\n+            return indentation;\n+        }\n+        if (node.parent() != null) {\n+            SyntaxKind parentKind = node.parent().kind();\n+            if (parentKind == SyntaxKind.BLOCK_STATEMENT ||\n+                    parentKind == SyntaxKind.FUNCTION_BODY_BLOCK ||\n+                    parentKind == SyntaxKind.LIST_CONSTRUCTOR ||\n+                    parentKind == SyntaxKind.TYPE_DEFINITION ||\n+                    parentKind == SyntaxKind.METHOD_DECLARATION ||\n+                    parentKind == SyntaxKind.MAPPING_CONSTRUCTOR) {\n+                indentation += formattingOptions.getTabSize();\n+            }\n+        }\n+        return getIndentation(node.parent(), indentation, formattingOptions);\n+    }\n+\n+    private static MinutiaeList getCommentMinutiae(MinutiaeList minutiaeList, boolean isLeading) {\n+        MinutiaeList minutiaes = AbstractNodeFactory.createEmptyMinutiaeList();\n+        for (int i = 0; i < minutiaeList.size(); i++) {\n+            if (minutiaeList.get(i).kind() == (SyntaxKind.COMMENT_MINUTIAE)) {\n+                if (i > 0) {\n+                    minutiaes = minutiaes.add(minutiaeList.get(i - 1));\n+                }\n+                minutiaes = minutiaes.add(minutiaeList.get(i));\n+                if ((i + 1) < minutiaeList.size() && isLeading) {\n+                    minutiaes = minutiaes.add(minutiaeList.get(i + 1));\n+                }\n+            }\n+        }\n+        return minutiaes;\n+    }\n+\n+    private static String getWhiteSpaces(int column, int newLines) {\n+        StringBuilder whiteSpaces = new StringBuilder();\n+        for (int i = 0; i <= (newLines - 1); i++) {\n+            whiteSpaces.append(System.getProperty(LINE_SEPARATOR));\n+        }\n+        for (int i = 0; i <= (column - 1); i++) {\n+            whiteSpaces.append(\" \");\n+        }\n+        return whiteSpaces.toString();\n+    }\n+\n+    /**\n+     * Initialize the token with empty minutiae lists.\n+     *\n+     * @param node node\n+     * @return token with empty minutiae\n+     */\n+    static <T extends Token> Token getToken(T node) {\n+        if (node == null) {\n+            return node;\n+        }\n+        MinutiaeList leadingMinutiaeList = AbstractNodeFactory.createEmptyMinutiaeList();\n+        MinutiaeList trailingMinutiaeList = AbstractNodeFactory.createEmptyMinutiaeList();\n+        if (node.containsLeadingMinutiae()) {\n+            leadingMinutiaeList = getCommentMinutiae(node.leadingMinutiae(), true);\n+        }\n+        if (node.containsTrailingMinutiae()) {\n+            trailingMinutiaeList = getCommentMinutiae(node.trailingMinutiae(), false);\n+        }\n+        return node.modify(leadingMinutiaeList, trailingMinutiaeList);\n+    }\n+\n+    static boolean isInLineRange(Node node, LineRange lineRange) {\n+        if (lineRange == null) {\n+            return true;\n+        }\n+        int nodeStartLine = node.lineRange().startLine().line();\n+        int nodeStartOffset = node.lineRange().startLine().offset();\n+        int nodeEndLine = node.lineRange().endLine().line();\n+        int nodeEndOffset = node.lineRange().endLine().offset();\n+\n+        int startLine = lineRange.startLine().line();\n+        int startOffset = lineRange.startLine().offset();\n+        int endLine = lineRange.endLine().line();\n+        int endOffset = lineRange.endLine().offset();\n+\n+        if (nodeStartLine >= startLine && nodeEndLine <= endLine) {\n+            if (nodeStartLine == startLine || nodeEndLine == endLine) {\n+                return nodeStartOffset >= startOffset && nodeEndOffset <= endOffset;\n+            }\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Update the minutiae and return the token.\n+     *\n+     * @param token            token\n+     * @param leadingSpaces    leading spaces\n+     * @param trailingSpaces   trailing spaces\n+     * @param leadingNewLines  leading new lines\n+     * @param trailingNewLines trailing new lines\n+     * @return updated token\n+     */\n+    static Token formatToken(Token token, int leadingSpaces, int trailingSpaces, int leadingNewLines,\n+                             int trailingNewLines) {\n+        if (token == null) {\n+            return token;\n+        }\n+        MinutiaeList newLeadingMinutiaeList = modifyMinutiaeList(leadingSpaces, leadingNewLines);\n+        MinutiaeList newTrailingMinutiaeList = modifyMinutiaeList(trailingSpaces, trailingNewLines);\n+\n+        return token.modify(newLeadingMinutiaeList, newTrailingMinutiaeList);\n+    }\n+\n+    private static MinutiaeList modifyMinutiaeList(int spaces, int newLines) {\n+        Minutiae minutiae = createWhitespaceMinutiae(getWhiteSpaces(spaces, newLines));\n+        return createMinutiaeList(minutiae);\n+    }\n+\n+    private static int getChildLocation(NonTerminalNode parent, Node child) {\n+        if (parent != null && child != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abf30d5163ce0ebdc71f6463696d834f80cc2f05"}, "originalPosition": 246}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzYwNjM2Mg==", "bodyText": "Done.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25680#discussion_r487606362", "createdAt": "2020-09-14T01:19:56Z", "author": {"login": "IrushiL"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/FormatterUtils.java", "diffHunk": "@@ -0,0 +1,415 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.core;\n+\n+import io.ballerina.tools.text.LinePosition;\n+import io.ballerina.tools.text.LineRange;\n+import io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory;\n+import io.ballerinalang.compiler.syntax.tree.ChildNodeList;\n+import io.ballerinalang.compiler.syntax.tree.Minutiae;\n+import io.ballerinalang.compiler.syntax.tree.MinutiaeList;\n+import io.ballerinalang.compiler.syntax.tree.Node;\n+import io.ballerinalang.compiler.syntax.tree.NonTerminalNode;\n+import io.ballerinalang.compiler.syntax.tree.SyntaxKind;\n+import io.ballerinalang.compiler.syntax.tree.Token;\n+import org.wso2.ballerinalang.compiler.util.diagnotic.DiagnosticPos;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import static io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory.createMinutiaeList;\n+import static io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory.createWhitespaceMinutiae;\n+\n+/**\n+ * Class that contains the util functions used by the formatting tree modifier.\n+ */\n+class FormatterUtils {\n+\n+    private static final String LINE_SEPARATOR = \"line.separator\";\n+\n+    /**\n+     * Get the node position.\n+     *\n+     * @param node node\n+     * @return node position\n+     */\n+    static DiagnosticPos getPosition(Node node) {\n+        if (node == null) {\n+            return null;\n+        }\n+        LineRange range = node.lineRange();\n+        LinePosition startPos = range.startLine();\n+        LinePosition endPos = range.endLine();\n+        int startOffset = startPos.offset();\n+        if (node.kind() == (SyntaxKind.FUNCTION_DEFINITION) || node.kind() == (SyntaxKind.TYPE_DEFINITION) ||\n+                node.kind() == (SyntaxKind.CONST_DECLARATION) || node.kind() == (SyntaxKind.OBJECT_TYPE_DESC)) {\n+            startOffset = (startOffset / 4) * 4;\n+        }\n+        return new DiagnosticPos(null, startPos.line() + 1, endPos.line() + 1,\n+                startOffset, endPos.offset());\n+    }\n+\n+    // TODO: Use a generic way to get the parent node using querying.\n+    static <T extends Node> Node getParent(T node, SyntaxKind syntaxKind) {\n+        Node parent = node.parent();\n+        if (parent == null) {\n+            parent = node;\n+        }\n+        Node grandParent = parent.parent();\n+        SyntaxKind parentKind = parent.kind();\n+        if (parentKind == (SyntaxKind.MODULE_VAR_DECL)) {\n+            if (grandParent != null && grandParent.kind() == (SyntaxKind.MODULE_PART) &&\n+                    syntaxKind == (SyntaxKind.QUALIFIED_NAME_REFERENCE)) {\n+                return null;\n+            }\n+            return parent;\n+        } else if (parentKind == (SyntaxKind.FUNCTION_DEFINITION) ||\n+                parentKind == (SyntaxKind.ELSE_BLOCK) ||\n+                parentKind == (SyntaxKind.IF_ELSE_STATEMENT) ||\n+                parentKind == (SyntaxKind.LOCAL_TYPE_DEFINITION_STATEMENT) ||\n+                parentKind == (SyntaxKind.WHILE_STATEMENT) ||\n+                parentKind == (SyntaxKind.CONST_DECLARATION) ||\n+                parentKind == (SyntaxKind.METHOD_DECLARATION) ||\n+                parentKind == (SyntaxKind.TYPE_DEFINITION)) {\n+            return parent;\n+        } else if (syntaxKind == (SyntaxKind.SIMPLE_NAME_REFERENCE)) {\n+            if (parentKind == (SyntaxKind.REQUIRED_PARAM) ||\n+                    parentKind == (SyntaxKind.POSITIONAL_ARG) ||\n+                    parentKind == (SyntaxKind.BINARY_EXPRESSION) ||\n+                    parentKind == (SyntaxKind.BRACED_EXPRESSION) ||\n+                    parentKind == (SyntaxKind.RETURN_STATEMENT) ||\n+                    parentKind == (SyntaxKind.REMOTE_METHOD_CALL_ACTION) ||\n+                    parentKind == (SyntaxKind.FIELD_ACCESS) ||\n+                    (parentKind == (SyntaxKind.FUNCTION_CALL) && grandParent != null &&\n+                            grandParent.kind() == (SyntaxKind.ASSIGNMENT_STATEMENT))) {\n+                return null;\n+            }\n+            return getParent(parent, syntaxKind);\n+        } else if (syntaxKind == (SyntaxKind.STRING_TYPE_DESC) &&\n+                parentKind == (SyntaxKind.RECORD_FIELD) && grandParent != null &&\n+                grandParent.kind() == (SyntaxKind.RECORD_TYPE_DESC)) {\n+            return getParent(parent, syntaxKind);\n+        } else if (parentKind == (SyntaxKind.SERVICE_DECLARATION) ||\n+                parentKind == (SyntaxKind.BINARY_EXPRESSION)) {\n+            if (syntaxKind == (SyntaxKind.QUALIFIED_NAME_REFERENCE)) {\n+                return null;\n+            }\n+            return parent;\n+        } else if (parentKind == (SyntaxKind.REQUIRED_PARAM)) {\n+            return null;\n+        } else if (parentKind == (SyntaxKind.OBJECT_TYPE_DESC)) {\n+            if (grandParent != null && grandParent.kind() == (SyntaxKind.RETURN_TYPE_DESCRIPTOR)) {\n+                return grandParent.parent().parent();\n+            } else if (grandParent != null && grandParent.kind() == (SyntaxKind.TYPE_DEFINITION)) {\n+                return getParent(parent, syntaxKind);\n+            } else {\n+                return parent;\n+            }\n+        } else if (grandParent != null) {\n+            return getParent(parent, syntaxKind);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    static int getIndentation(Node node, int indentation, FormattingOptions formattingOptions) {\n+        if (node == null) {\n+            return indentation;\n+        }\n+        if (node.parent() != null) {\n+            SyntaxKind parentKind = node.parent().kind();\n+            if (parentKind == SyntaxKind.BLOCK_STATEMENT ||\n+                    parentKind == SyntaxKind.FUNCTION_BODY_BLOCK ||\n+                    parentKind == SyntaxKind.LIST_CONSTRUCTOR ||\n+                    parentKind == SyntaxKind.TYPE_DEFINITION ||\n+                    parentKind == SyntaxKind.METHOD_DECLARATION ||\n+                    parentKind == SyntaxKind.MAPPING_CONSTRUCTOR) {\n+                indentation += formattingOptions.getTabSize();\n+            }\n+        }\n+        return getIndentation(node.parent(), indentation, formattingOptions);\n+    }\n+\n+    private static MinutiaeList getCommentMinutiae(MinutiaeList minutiaeList, boolean isLeading) {\n+        MinutiaeList minutiaes = AbstractNodeFactory.createEmptyMinutiaeList();\n+        for (int i = 0; i < minutiaeList.size(); i++) {\n+            if (minutiaeList.get(i).kind() == (SyntaxKind.COMMENT_MINUTIAE)) {\n+                if (i > 0) {\n+                    minutiaes = minutiaes.add(minutiaeList.get(i - 1));\n+                }\n+                minutiaes = minutiaes.add(minutiaeList.get(i));\n+                if ((i + 1) < minutiaeList.size() && isLeading) {\n+                    minutiaes = minutiaes.add(minutiaeList.get(i + 1));\n+                }\n+            }\n+        }\n+        return minutiaes;\n+    }\n+\n+    private static String getWhiteSpaces(int column, int newLines) {\n+        StringBuilder whiteSpaces = new StringBuilder();\n+        for (int i = 0; i <= (newLines - 1); i++) {\n+            whiteSpaces.append(System.getProperty(LINE_SEPARATOR));\n+        }\n+        for (int i = 0; i <= (column - 1); i++) {\n+            whiteSpaces.append(\" \");\n+        }\n+        return whiteSpaces.toString();\n+    }\n+\n+    /**\n+     * Initialize the token with empty minutiae lists.\n+     *\n+     * @param node node\n+     * @return token with empty minutiae\n+     */\n+    static <T extends Token> Token getToken(T node) {\n+        if (node == null) {\n+            return node;\n+        }\n+        MinutiaeList leadingMinutiaeList = AbstractNodeFactory.createEmptyMinutiaeList();\n+        MinutiaeList trailingMinutiaeList = AbstractNodeFactory.createEmptyMinutiaeList();\n+        if (node.containsLeadingMinutiae()) {\n+            leadingMinutiaeList = getCommentMinutiae(node.leadingMinutiae(), true);\n+        }\n+        if (node.containsTrailingMinutiae()) {\n+            trailingMinutiaeList = getCommentMinutiae(node.trailingMinutiae(), false);\n+        }\n+        return node.modify(leadingMinutiaeList, trailingMinutiaeList);\n+    }\n+\n+    static boolean isInLineRange(Node node, LineRange lineRange) {\n+        if (lineRange == null) {\n+            return true;\n+        }\n+        int nodeStartLine = node.lineRange().startLine().line();\n+        int nodeStartOffset = node.lineRange().startLine().offset();\n+        int nodeEndLine = node.lineRange().endLine().line();\n+        int nodeEndOffset = node.lineRange().endLine().offset();\n+\n+        int startLine = lineRange.startLine().line();\n+        int startOffset = lineRange.startLine().offset();\n+        int endLine = lineRange.endLine().line();\n+        int endOffset = lineRange.endLine().offset();\n+\n+        if (nodeStartLine >= startLine && nodeEndLine <= endLine) {\n+            if (nodeStartLine == startLine || nodeEndLine == endLine) {\n+                return nodeStartOffset >= startOffset && nodeEndOffset <= endOffset;\n+            }\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Update the minutiae and return the token.\n+     *\n+     * @param token            token\n+     * @param leadingSpaces    leading spaces\n+     * @param trailingSpaces   trailing spaces\n+     * @param leadingNewLines  leading new lines\n+     * @param trailingNewLines trailing new lines\n+     * @return updated token\n+     */\n+    static Token formatToken(Token token, int leadingSpaces, int trailingSpaces, int leadingNewLines,\n+                             int trailingNewLines) {\n+        if (token == null) {\n+            return token;\n+        }\n+        MinutiaeList newLeadingMinutiaeList = modifyMinutiaeList(leadingSpaces, leadingNewLines);\n+        MinutiaeList newTrailingMinutiaeList = modifyMinutiaeList(trailingSpaces, trailingNewLines);\n+\n+        return token.modify(newLeadingMinutiaeList, newTrailingMinutiaeList);\n+    }\n+\n+    private static MinutiaeList modifyMinutiaeList(int spaces, int newLines) {\n+        Minutiae minutiae = createWhitespaceMinutiae(getWhiteSpaces(spaces, newLines));\n+        return createMinutiaeList(minutiae);\n+    }\n+\n+    private static int getChildLocation(NonTerminalNode parent, Node child) {\n+        if (parent != null && child != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE5ODAyNQ=="}, "originalCommit": {"oid": "abf30d5163ce0ebdc71f6463696d834f80cc2f05"}, "originalPosition": 246}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NzU0NTUxOnYy", "diffSide": "RIGHT", "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/FormatterUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNzo1MjoxN1rOHQoSuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQwMToxOTo0MVrOHRBIIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE5OTQxOQ==", "bodyText": "we can remove the else clause since we do a return within the if clause", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25680#discussion_r487199419", "createdAt": "2020-09-11T17:52:17Z", "author": {"login": "nadeeshaan"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/FormatterUtils.java", "diffHunk": "@@ -0,0 +1,415 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.core;\n+\n+import io.ballerina.tools.text.LinePosition;\n+import io.ballerina.tools.text.LineRange;\n+import io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory;\n+import io.ballerinalang.compiler.syntax.tree.ChildNodeList;\n+import io.ballerinalang.compiler.syntax.tree.Minutiae;\n+import io.ballerinalang.compiler.syntax.tree.MinutiaeList;\n+import io.ballerinalang.compiler.syntax.tree.Node;\n+import io.ballerinalang.compiler.syntax.tree.NonTerminalNode;\n+import io.ballerinalang.compiler.syntax.tree.SyntaxKind;\n+import io.ballerinalang.compiler.syntax.tree.Token;\n+import org.wso2.ballerinalang.compiler.util.diagnotic.DiagnosticPos;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import static io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory.createMinutiaeList;\n+import static io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory.createWhitespaceMinutiae;\n+\n+/**\n+ * Class that contains the util functions used by the formatting tree modifier.\n+ */\n+class FormatterUtils {\n+\n+    private static final String LINE_SEPARATOR = \"line.separator\";\n+\n+    /**\n+     * Get the node position.\n+     *\n+     * @param node node\n+     * @return node position\n+     */\n+    static DiagnosticPos getPosition(Node node) {\n+        if (node == null) {\n+            return null;\n+        }\n+        LineRange range = node.lineRange();\n+        LinePosition startPos = range.startLine();\n+        LinePosition endPos = range.endLine();\n+        int startOffset = startPos.offset();\n+        if (node.kind() == (SyntaxKind.FUNCTION_DEFINITION) || node.kind() == (SyntaxKind.TYPE_DEFINITION) ||\n+                node.kind() == (SyntaxKind.CONST_DECLARATION) || node.kind() == (SyntaxKind.OBJECT_TYPE_DESC)) {\n+            startOffset = (startOffset / 4) * 4;\n+        }\n+        return new DiagnosticPos(null, startPos.line() + 1, endPos.line() + 1,\n+                startOffset, endPos.offset());\n+    }\n+\n+    // TODO: Use a generic way to get the parent node using querying.\n+    static <T extends Node> Node getParent(T node, SyntaxKind syntaxKind) {\n+        Node parent = node.parent();\n+        if (parent == null) {\n+            parent = node;\n+        }\n+        Node grandParent = parent.parent();\n+        SyntaxKind parentKind = parent.kind();\n+        if (parentKind == (SyntaxKind.MODULE_VAR_DECL)) {\n+            if (grandParent != null && grandParent.kind() == (SyntaxKind.MODULE_PART) &&\n+                    syntaxKind == (SyntaxKind.QUALIFIED_NAME_REFERENCE)) {\n+                return null;\n+            }\n+            return parent;\n+        } else if (parentKind == (SyntaxKind.FUNCTION_DEFINITION) ||\n+                parentKind == (SyntaxKind.ELSE_BLOCK) ||\n+                parentKind == (SyntaxKind.IF_ELSE_STATEMENT) ||\n+                parentKind == (SyntaxKind.LOCAL_TYPE_DEFINITION_STATEMENT) ||\n+                parentKind == (SyntaxKind.WHILE_STATEMENT) ||\n+                parentKind == (SyntaxKind.CONST_DECLARATION) ||\n+                parentKind == (SyntaxKind.METHOD_DECLARATION) ||\n+                parentKind == (SyntaxKind.TYPE_DEFINITION)) {\n+            return parent;\n+        } else if (syntaxKind == (SyntaxKind.SIMPLE_NAME_REFERENCE)) {\n+            if (parentKind == (SyntaxKind.REQUIRED_PARAM) ||\n+                    parentKind == (SyntaxKind.POSITIONAL_ARG) ||\n+                    parentKind == (SyntaxKind.BINARY_EXPRESSION) ||\n+                    parentKind == (SyntaxKind.BRACED_EXPRESSION) ||\n+                    parentKind == (SyntaxKind.RETURN_STATEMENT) ||\n+                    parentKind == (SyntaxKind.REMOTE_METHOD_CALL_ACTION) ||\n+                    parentKind == (SyntaxKind.FIELD_ACCESS) ||\n+                    (parentKind == (SyntaxKind.FUNCTION_CALL) && grandParent != null &&\n+                            grandParent.kind() == (SyntaxKind.ASSIGNMENT_STATEMENT))) {\n+                return null;\n+            }\n+            return getParent(parent, syntaxKind);\n+        } else if (syntaxKind == (SyntaxKind.STRING_TYPE_DESC) &&\n+                parentKind == (SyntaxKind.RECORD_FIELD) && grandParent != null &&\n+                grandParent.kind() == (SyntaxKind.RECORD_TYPE_DESC)) {\n+            return getParent(parent, syntaxKind);\n+        } else if (parentKind == (SyntaxKind.SERVICE_DECLARATION) ||\n+                parentKind == (SyntaxKind.BINARY_EXPRESSION)) {\n+            if (syntaxKind == (SyntaxKind.QUALIFIED_NAME_REFERENCE)) {\n+                return null;\n+            }\n+            return parent;\n+        } else if (parentKind == (SyntaxKind.REQUIRED_PARAM)) {\n+            return null;\n+        } else if (parentKind == (SyntaxKind.OBJECT_TYPE_DESC)) {\n+            if (grandParent != null && grandParent.kind() == (SyntaxKind.RETURN_TYPE_DESCRIPTOR)) {\n+                return grandParent.parent().parent();\n+            } else if (grandParent != null && grandParent.kind() == (SyntaxKind.TYPE_DEFINITION)) {\n+                return getParent(parent, syntaxKind);\n+            } else {\n+                return parent;\n+            }\n+        } else if (grandParent != null) {\n+            return getParent(parent, syntaxKind);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    static int getIndentation(Node node, int indentation, FormattingOptions formattingOptions) {\n+        if (node == null) {\n+            return indentation;\n+        }\n+        if (node.parent() != null) {\n+            SyntaxKind parentKind = node.parent().kind();\n+            if (parentKind == SyntaxKind.BLOCK_STATEMENT ||\n+                    parentKind == SyntaxKind.FUNCTION_BODY_BLOCK ||\n+                    parentKind == SyntaxKind.LIST_CONSTRUCTOR ||\n+                    parentKind == SyntaxKind.TYPE_DEFINITION ||\n+                    parentKind == SyntaxKind.METHOD_DECLARATION ||\n+                    parentKind == SyntaxKind.MAPPING_CONSTRUCTOR) {\n+                indentation += formattingOptions.getTabSize();\n+            }\n+        }\n+        return getIndentation(node.parent(), indentation, formattingOptions);\n+    }\n+\n+    private static MinutiaeList getCommentMinutiae(MinutiaeList minutiaeList, boolean isLeading) {\n+        MinutiaeList minutiaes = AbstractNodeFactory.createEmptyMinutiaeList();\n+        for (int i = 0; i < minutiaeList.size(); i++) {\n+            if (minutiaeList.get(i).kind() == (SyntaxKind.COMMENT_MINUTIAE)) {\n+                if (i > 0) {\n+                    minutiaes = minutiaes.add(minutiaeList.get(i - 1));\n+                }\n+                minutiaes = minutiaes.add(minutiaeList.get(i));\n+                if ((i + 1) < minutiaeList.size() && isLeading) {\n+                    minutiaes = minutiaes.add(minutiaeList.get(i + 1));\n+                }\n+            }\n+        }\n+        return minutiaes;\n+    }\n+\n+    private static String getWhiteSpaces(int column, int newLines) {\n+        StringBuilder whiteSpaces = new StringBuilder();\n+        for (int i = 0; i <= (newLines - 1); i++) {\n+            whiteSpaces.append(System.getProperty(LINE_SEPARATOR));\n+        }\n+        for (int i = 0; i <= (column - 1); i++) {\n+            whiteSpaces.append(\" \");\n+        }\n+        return whiteSpaces.toString();\n+    }\n+\n+    /**\n+     * Initialize the token with empty minutiae lists.\n+     *\n+     * @param node node\n+     * @return token with empty minutiae\n+     */\n+    static <T extends Token> Token getToken(T node) {\n+        if (node == null) {\n+            return node;\n+        }\n+        MinutiaeList leadingMinutiaeList = AbstractNodeFactory.createEmptyMinutiaeList();\n+        MinutiaeList trailingMinutiaeList = AbstractNodeFactory.createEmptyMinutiaeList();\n+        if (node.containsLeadingMinutiae()) {\n+            leadingMinutiaeList = getCommentMinutiae(node.leadingMinutiae(), true);\n+        }\n+        if (node.containsTrailingMinutiae()) {\n+            trailingMinutiaeList = getCommentMinutiae(node.trailingMinutiae(), false);\n+        }\n+        return node.modify(leadingMinutiaeList, trailingMinutiaeList);\n+    }\n+\n+    static boolean isInLineRange(Node node, LineRange lineRange) {\n+        if (lineRange == null) {\n+            return true;\n+        }\n+        int nodeStartLine = node.lineRange().startLine().line();\n+        int nodeStartOffset = node.lineRange().startLine().offset();\n+        int nodeEndLine = node.lineRange().endLine().line();\n+        int nodeEndOffset = node.lineRange().endLine().offset();\n+\n+        int startLine = lineRange.startLine().line();\n+        int startOffset = lineRange.startLine().offset();\n+        int endLine = lineRange.endLine().line();\n+        int endOffset = lineRange.endLine().offset();\n+\n+        if (nodeStartLine >= startLine && nodeEndLine <= endLine) {\n+            if (nodeStartLine == startLine || nodeEndLine == endLine) {\n+                return nodeStartOffset >= startOffset && nodeEndOffset <= endOffset;\n+            }\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Update the minutiae and return the token.\n+     *\n+     * @param token            token\n+     * @param leadingSpaces    leading spaces\n+     * @param trailingSpaces   trailing spaces\n+     * @param leadingNewLines  leading new lines\n+     * @param trailingNewLines trailing new lines\n+     * @return updated token\n+     */\n+    static Token formatToken(Token token, int leadingSpaces, int trailingSpaces, int leadingNewLines,\n+                             int trailingNewLines) {\n+        if (token == null) {\n+            return token;\n+        }\n+        MinutiaeList newLeadingMinutiaeList = modifyMinutiaeList(leadingSpaces, leadingNewLines);\n+        MinutiaeList newTrailingMinutiaeList = modifyMinutiaeList(trailingSpaces, trailingNewLines);\n+\n+        return token.modify(newLeadingMinutiaeList, newTrailingMinutiaeList);\n+    }\n+\n+    private static MinutiaeList modifyMinutiaeList(int spaces, int newLines) {\n+        Minutiae minutiae = createWhitespaceMinutiae(getWhiteSpaces(spaces, newLines));\n+        return createMinutiaeList(minutiae);\n+    }\n+\n+    private static int getChildLocation(NonTerminalNode parent, Node child) {\n+        if (parent != null && child != null) {\n+            for (int i = 0; i < parent.children().size(); i++) {\n+                if (parent.children().get(i).equals(child)) {\n+                    return i;\n+                }\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    private static int regexCount(String context, String pattern) {\n+        Matcher matcher = Pattern.compile(String.valueOf(pattern)).matcher(context);\n+        int response = 0;\n+        while (matcher.find()) {\n+            response++;\n+        }\n+        return response;\n+    }\n+\n+    private static Token getStartingToken(Node node) {\n+        if (node instanceof Token) {\n+            return (Token) node;\n+        }\n+        ChildNodeList childNodeList = ((NonTerminalNode) node).children();\n+        return getStartingToken(childNodeList.get(0));\n+    }\n+\n+    private static Token getEndingToken(Node node) {\n+        if (node instanceof Token) {\n+            return (Token) node;\n+        }\n+        ChildNodeList childNodeList = ((NonTerminalNode) node).children();\n+        return getStartingToken(childNodeList.get(childNodeList.size() - 1));\n+    }\n+\n+    static boolean preserveNewLine(NonTerminalNode node) {\n+        ArrayList<SyntaxKind> endTokens = new ArrayList<>(\n+                Arrays.asList(\n+                        SyntaxKind.CLOSE_BRACE_TOKEN,\n+                        SyntaxKind.CLOSE_BRACE_PIPE_TOKEN,\n+                        SyntaxKind.CLOSE_BRACKET_TOKEN,\n+                        SyntaxKind.CLOSE_PAREN_TOKEN));\n+        boolean preserve = false;\n+        MinutiaeList nodeEnd = getEndingToken(node).trailingMinutiae();\n+        if (nodeEnd.toString().contains(System.getProperty(LINE_SEPARATOR))) {\n+            int childIndex = getChildLocation(node.parent(), node);\n+            if (childIndex != -1) {\n+                Node nextNode = node.parent().children().get(childIndex + 1);\n+                if (nextNode != null && !endTokens.contains(nextNode.kind())) {\n+                    MinutiaeList siblingStart = getStartingToken(nextNode).leadingMinutiae();\n+                    int newLines = regexCount(nodeEnd.toString(), System.getProperty(LINE_SEPARATOR));\n+                    if (siblingStart.toString().contains(System.getProperty(LINE_SEPARATOR)) || newLines > 1) {\n+                        preserve = true;\n+                    }\n+                }\n+            }\n+        }\n+        return preserve;\n+    }\n+\n+    private static ArrayList<NonTerminalNode> nestedIfBlock(NonTerminalNode node) {\n+        NonTerminalNode parent = node.parent();\n+        ArrayList<NonTerminalNode> nestedParent = new ArrayList<>();\n+        if (parent == null) {\n+            return new ArrayList<>(0);\n+        } else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abf30d5163ce0ebdc71f6463696d834f80cc2f05"}, "originalPosition": 311}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzYwNjMwNA==", "bodyText": "Fixed.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25680#discussion_r487606304", "createdAt": "2020-09-14T01:19:41Z", "author": {"login": "IrushiL"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/FormatterUtils.java", "diffHunk": "@@ -0,0 +1,415 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.core;\n+\n+import io.ballerina.tools.text.LinePosition;\n+import io.ballerina.tools.text.LineRange;\n+import io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory;\n+import io.ballerinalang.compiler.syntax.tree.ChildNodeList;\n+import io.ballerinalang.compiler.syntax.tree.Minutiae;\n+import io.ballerinalang.compiler.syntax.tree.MinutiaeList;\n+import io.ballerinalang.compiler.syntax.tree.Node;\n+import io.ballerinalang.compiler.syntax.tree.NonTerminalNode;\n+import io.ballerinalang.compiler.syntax.tree.SyntaxKind;\n+import io.ballerinalang.compiler.syntax.tree.Token;\n+import org.wso2.ballerinalang.compiler.util.diagnotic.DiagnosticPos;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import static io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory.createMinutiaeList;\n+import static io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory.createWhitespaceMinutiae;\n+\n+/**\n+ * Class that contains the util functions used by the formatting tree modifier.\n+ */\n+class FormatterUtils {\n+\n+    private static final String LINE_SEPARATOR = \"line.separator\";\n+\n+    /**\n+     * Get the node position.\n+     *\n+     * @param node node\n+     * @return node position\n+     */\n+    static DiagnosticPos getPosition(Node node) {\n+        if (node == null) {\n+            return null;\n+        }\n+        LineRange range = node.lineRange();\n+        LinePosition startPos = range.startLine();\n+        LinePosition endPos = range.endLine();\n+        int startOffset = startPos.offset();\n+        if (node.kind() == (SyntaxKind.FUNCTION_DEFINITION) || node.kind() == (SyntaxKind.TYPE_DEFINITION) ||\n+                node.kind() == (SyntaxKind.CONST_DECLARATION) || node.kind() == (SyntaxKind.OBJECT_TYPE_DESC)) {\n+            startOffset = (startOffset / 4) * 4;\n+        }\n+        return new DiagnosticPos(null, startPos.line() + 1, endPos.line() + 1,\n+                startOffset, endPos.offset());\n+    }\n+\n+    // TODO: Use a generic way to get the parent node using querying.\n+    static <T extends Node> Node getParent(T node, SyntaxKind syntaxKind) {\n+        Node parent = node.parent();\n+        if (parent == null) {\n+            parent = node;\n+        }\n+        Node grandParent = parent.parent();\n+        SyntaxKind parentKind = parent.kind();\n+        if (parentKind == (SyntaxKind.MODULE_VAR_DECL)) {\n+            if (grandParent != null && grandParent.kind() == (SyntaxKind.MODULE_PART) &&\n+                    syntaxKind == (SyntaxKind.QUALIFIED_NAME_REFERENCE)) {\n+                return null;\n+            }\n+            return parent;\n+        } else if (parentKind == (SyntaxKind.FUNCTION_DEFINITION) ||\n+                parentKind == (SyntaxKind.ELSE_BLOCK) ||\n+                parentKind == (SyntaxKind.IF_ELSE_STATEMENT) ||\n+                parentKind == (SyntaxKind.LOCAL_TYPE_DEFINITION_STATEMENT) ||\n+                parentKind == (SyntaxKind.WHILE_STATEMENT) ||\n+                parentKind == (SyntaxKind.CONST_DECLARATION) ||\n+                parentKind == (SyntaxKind.METHOD_DECLARATION) ||\n+                parentKind == (SyntaxKind.TYPE_DEFINITION)) {\n+            return parent;\n+        } else if (syntaxKind == (SyntaxKind.SIMPLE_NAME_REFERENCE)) {\n+            if (parentKind == (SyntaxKind.REQUIRED_PARAM) ||\n+                    parentKind == (SyntaxKind.POSITIONAL_ARG) ||\n+                    parentKind == (SyntaxKind.BINARY_EXPRESSION) ||\n+                    parentKind == (SyntaxKind.BRACED_EXPRESSION) ||\n+                    parentKind == (SyntaxKind.RETURN_STATEMENT) ||\n+                    parentKind == (SyntaxKind.REMOTE_METHOD_CALL_ACTION) ||\n+                    parentKind == (SyntaxKind.FIELD_ACCESS) ||\n+                    (parentKind == (SyntaxKind.FUNCTION_CALL) && grandParent != null &&\n+                            grandParent.kind() == (SyntaxKind.ASSIGNMENT_STATEMENT))) {\n+                return null;\n+            }\n+            return getParent(parent, syntaxKind);\n+        } else if (syntaxKind == (SyntaxKind.STRING_TYPE_DESC) &&\n+                parentKind == (SyntaxKind.RECORD_FIELD) && grandParent != null &&\n+                grandParent.kind() == (SyntaxKind.RECORD_TYPE_DESC)) {\n+            return getParent(parent, syntaxKind);\n+        } else if (parentKind == (SyntaxKind.SERVICE_DECLARATION) ||\n+                parentKind == (SyntaxKind.BINARY_EXPRESSION)) {\n+            if (syntaxKind == (SyntaxKind.QUALIFIED_NAME_REFERENCE)) {\n+                return null;\n+            }\n+            return parent;\n+        } else if (parentKind == (SyntaxKind.REQUIRED_PARAM)) {\n+            return null;\n+        } else if (parentKind == (SyntaxKind.OBJECT_TYPE_DESC)) {\n+            if (grandParent != null && grandParent.kind() == (SyntaxKind.RETURN_TYPE_DESCRIPTOR)) {\n+                return grandParent.parent().parent();\n+            } else if (grandParent != null && grandParent.kind() == (SyntaxKind.TYPE_DEFINITION)) {\n+                return getParent(parent, syntaxKind);\n+            } else {\n+                return parent;\n+            }\n+        } else if (grandParent != null) {\n+            return getParent(parent, syntaxKind);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    static int getIndentation(Node node, int indentation, FormattingOptions formattingOptions) {\n+        if (node == null) {\n+            return indentation;\n+        }\n+        if (node.parent() != null) {\n+            SyntaxKind parentKind = node.parent().kind();\n+            if (parentKind == SyntaxKind.BLOCK_STATEMENT ||\n+                    parentKind == SyntaxKind.FUNCTION_BODY_BLOCK ||\n+                    parentKind == SyntaxKind.LIST_CONSTRUCTOR ||\n+                    parentKind == SyntaxKind.TYPE_DEFINITION ||\n+                    parentKind == SyntaxKind.METHOD_DECLARATION ||\n+                    parentKind == SyntaxKind.MAPPING_CONSTRUCTOR) {\n+                indentation += formattingOptions.getTabSize();\n+            }\n+        }\n+        return getIndentation(node.parent(), indentation, formattingOptions);\n+    }\n+\n+    private static MinutiaeList getCommentMinutiae(MinutiaeList minutiaeList, boolean isLeading) {\n+        MinutiaeList minutiaes = AbstractNodeFactory.createEmptyMinutiaeList();\n+        for (int i = 0; i < minutiaeList.size(); i++) {\n+            if (minutiaeList.get(i).kind() == (SyntaxKind.COMMENT_MINUTIAE)) {\n+                if (i > 0) {\n+                    minutiaes = minutiaes.add(minutiaeList.get(i - 1));\n+                }\n+                minutiaes = minutiaes.add(minutiaeList.get(i));\n+                if ((i + 1) < minutiaeList.size() && isLeading) {\n+                    minutiaes = minutiaes.add(minutiaeList.get(i + 1));\n+                }\n+            }\n+        }\n+        return minutiaes;\n+    }\n+\n+    private static String getWhiteSpaces(int column, int newLines) {\n+        StringBuilder whiteSpaces = new StringBuilder();\n+        for (int i = 0; i <= (newLines - 1); i++) {\n+            whiteSpaces.append(System.getProperty(LINE_SEPARATOR));\n+        }\n+        for (int i = 0; i <= (column - 1); i++) {\n+            whiteSpaces.append(\" \");\n+        }\n+        return whiteSpaces.toString();\n+    }\n+\n+    /**\n+     * Initialize the token with empty minutiae lists.\n+     *\n+     * @param node node\n+     * @return token with empty minutiae\n+     */\n+    static <T extends Token> Token getToken(T node) {\n+        if (node == null) {\n+            return node;\n+        }\n+        MinutiaeList leadingMinutiaeList = AbstractNodeFactory.createEmptyMinutiaeList();\n+        MinutiaeList trailingMinutiaeList = AbstractNodeFactory.createEmptyMinutiaeList();\n+        if (node.containsLeadingMinutiae()) {\n+            leadingMinutiaeList = getCommentMinutiae(node.leadingMinutiae(), true);\n+        }\n+        if (node.containsTrailingMinutiae()) {\n+            trailingMinutiaeList = getCommentMinutiae(node.trailingMinutiae(), false);\n+        }\n+        return node.modify(leadingMinutiaeList, trailingMinutiaeList);\n+    }\n+\n+    static boolean isInLineRange(Node node, LineRange lineRange) {\n+        if (lineRange == null) {\n+            return true;\n+        }\n+        int nodeStartLine = node.lineRange().startLine().line();\n+        int nodeStartOffset = node.lineRange().startLine().offset();\n+        int nodeEndLine = node.lineRange().endLine().line();\n+        int nodeEndOffset = node.lineRange().endLine().offset();\n+\n+        int startLine = lineRange.startLine().line();\n+        int startOffset = lineRange.startLine().offset();\n+        int endLine = lineRange.endLine().line();\n+        int endOffset = lineRange.endLine().offset();\n+\n+        if (nodeStartLine >= startLine && nodeEndLine <= endLine) {\n+            if (nodeStartLine == startLine || nodeEndLine == endLine) {\n+                return nodeStartOffset >= startOffset && nodeEndOffset <= endOffset;\n+            }\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Update the minutiae and return the token.\n+     *\n+     * @param token            token\n+     * @param leadingSpaces    leading spaces\n+     * @param trailingSpaces   trailing spaces\n+     * @param leadingNewLines  leading new lines\n+     * @param trailingNewLines trailing new lines\n+     * @return updated token\n+     */\n+    static Token formatToken(Token token, int leadingSpaces, int trailingSpaces, int leadingNewLines,\n+                             int trailingNewLines) {\n+        if (token == null) {\n+            return token;\n+        }\n+        MinutiaeList newLeadingMinutiaeList = modifyMinutiaeList(leadingSpaces, leadingNewLines);\n+        MinutiaeList newTrailingMinutiaeList = modifyMinutiaeList(trailingSpaces, trailingNewLines);\n+\n+        return token.modify(newLeadingMinutiaeList, newTrailingMinutiaeList);\n+    }\n+\n+    private static MinutiaeList modifyMinutiaeList(int spaces, int newLines) {\n+        Minutiae minutiae = createWhitespaceMinutiae(getWhiteSpaces(spaces, newLines));\n+        return createMinutiaeList(minutiae);\n+    }\n+\n+    private static int getChildLocation(NonTerminalNode parent, Node child) {\n+        if (parent != null && child != null) {\n+            for (int i = 0; i < parent.children().size(); i++) {\n+                if (parent.children().get(i).equals(child)) {\n+                    return i;\n+                }\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    private static int regexCount(String context, String pattern) {\n+        Matcher matcher = Pattern.compile(String.valueOf(pattern)).matcher(context);\n+        int response = 0;\n+        while (matcher.find()) {\n+            response++;\n+        }\n+        return response;\n+    }\n+\n+    private static Token getStartingToken(Node node) {\n+        if (node instanceof Token) {\n+            return (Token) node;\n+        }\n+        ChildNodeList childNodeList = ((NonTerminalNode) node).children();\n+        return getStartingToken(childNodeList.get(0));\n+    }\n+\n+    private static Token getEndingToken(Node node) {\n+        if (node instanceof Token) {\n+            return (Token) node;\n+        }\n+        ChildNodeList childNodeList = ((NonTerminalNode) node).children();\n+        return getStartingToken(childNodeList.get(childNodeList.size() - 1));\n+    }\n+\n+    static boolean preserveNewLine(NonTerminalNode node) {\n+        ArrayList<SyntaxKind> endTokens = new ArrayList<>(\n+                Arrays.asList(\n+                        SyntaxKind.CLOSE_BRACE_TOKEN,\n+                        SyntaxKind.CLOSE_BRACE_PIPE_TOKEN,\n+                        SyntaxKind.CLOSE_BRACKET_TOKEN,\n+                        SyntaxKind.CLOSE_PAREN_TOKEN));\n+        boolean preserve = false;\n+        MinutiaeList nodeEnd = getEndingToken(node).trailingMinutiae();\n+        if (nodeEnd.toString().contains(System.getProperty(LINE_SEPARATOR))) {\n+            int childIndex = getChildLocation(node.parent(), node);\n+            if (childIndex != -1) {\n+                Node nextNode = node.parent().children().get(childIndex + 1);\n+                if (nextNode != null && !endTokens.contains(nextNode.kind())) {\n+                    MinutiaeList siblingStart = getStartingToken(nextNode).leadingMinutiae();\n+                    int newLines = regexCount(nodeEnd.toString(), System.getProperty(LINE_SEPARATOR));\n+                    if (siblingStart.toString().contains(System.getProperty(LINE_SEPARATOR)) || newLines > 1) {\n+                        preserve = true;\n+                    }\n+                }\n+            }\n+        }\n+        return preserve;\n+    }\n+\n+    private static ArrayList<NonTerminalNode> nestedIfBlock(NonTerminalNode node) {\n+        NonTerminalNode parent = node.parent();\n+        ArrayList<NonTerminalNode> nestedParent = new ArrayList<>();\n+        if (parent == null) {\n+            return new ArrayList<>(0);\n+        } else {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE5OTQxOQ=="}, "originalCommit": {"oid": "abf30d5163ce0ebdc71f6463696d834f80cc2f05"}, "originalPosition": 311}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NzU0OTQ0OnYy", "diffSide": "RIGHT", "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/FormatterUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNzo1Mzo0NFrOHQoVOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQwMTozMDo0OVrOHRBQVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzIwMDA1Ng==", "bodyText": "instead of returning null, is it possible to return the empty list?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25680#discussion_r487200056", "createdAt": "2020-09-11T17:53:44Z", "author": {"login": "nadeeshaan"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/FormatterUtils.java", "diffHunk": "@@ -0,0 +1,415 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.core;\n+\n+import io.ballerina.tools.text.LinePosition;\n+import io.ballerina.tools.text.LineRange;\n+import io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory;\n+import io.ballerinalang.compiler.syntax.tree.ChildNodeList;\n+import io.ballerinalang.compiler.syntax.tree.Minutiae;\n+import io.ballerinalang.compiler.syntax.tree.MinutiaeList;\n+import io.ballerinalang.compiler.syntax.tree.Node;\n+import io.ballerinalang.compiler.syntax.tree.NonTerminalNode;\n+import io.ballerinalang.compiler.syntax.tree.SyntaxKind;\n+import io.ballerinalang.compiler.syntax.tree.Token;\n+import org.wso2.ballerinalang.compiler.util.diagnotic.DiagnosticPos;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import static io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory.createMinutiaeList;\n+import static io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory.createWhitespaceMinutiae;\n+\n+/**\n+ * Class that contains the util functions used by the formatting tree modifier.\n+ */\n+class FormatterUtils {\n+\n+    private static final String LINE_SEPARATOR = \"line.separator\";\n+\n+    /**\n+     * Get the node position.\n+     *\n+     * @param node node\n+     * @return node position\n+     */\n+    static DiagnosticPos getPosition(Node node) {\n+        if (node == null) {\n+            return null;\n+        }\n+        LineRange range = node.lineRange();\n+        LinePosition startPos = range.startLine();\n+        LinePosition endPos = range.endLine();\n+        int startOffset = startPos.offset();\n+        if (node.kind() == (SyntaxKind.FUNCTION_DEFINITION) || node.kind() == (SyntaxKind.TYPE_DEFINITION) ||\n+                node.kind() == (SyntaxKind.CONST_DECLARATION) || node.kind() == (SyntaxKind.OBJECT_TYPE_DESC)) {\n+            startOffset = (startOffset / 4) * 4;\n+        }\n+        return new DiagnosticPos(null, startPos.line() + 1, endPos.line() + 1,\n+                startOffset, endPos.offset());\n+    }\n+\n+    // TODO: Use a generic way to get the parent node using querying.\n+    static <T extends Node> Node getParent(T node, SyntaxKind syntaxKind) {\n+        Node parent = node.parent();\n+        if (parent == null) {\n+            parent = node;\n+        }\n+        Node grandParent = parent.parent();\n+        SyntaxKind parentKind = parent.kind();\n+        if (parentKind == (SyntaxKind.MODULE_VAR_DECL)) {\n+            if (grandParent != null && grandParent.kind() == (SyntaxKind.MODULE_PART) &&\n+                    syntaxKind == (SyntaxKind.QUALIFIED_NAME_REFERENCE)) {\n+                return null;\n+            }\n+            return parent;\n+        } else if (parentKind == (SyntaxKind.FUNCTION_DEFINITION) ||\n+                parentKind == (SyntaxKind.ELSE_BLOCK) ||\n+                parentKind == (SyntaxKind.IF_ELSE_STATEMENT) ||\n+                parentKind == (SyntaxKind.LOCAL_TYPE_DEFINITION_STATEMENT) ||\n+                parentKind == (SyntaxKind.WHILE_STATEMENT) ||\n+                parentKind == (SyntaxKind.CONST_DECLARATION) ||\n+                parentKind == (SyntaxKind.METHOD_DECLARATION) ||\n+                parentKind == (SyntaxKind.TYPE_DEFINITION)) {\n+            return parent;\n+        } else if (syntaxKind == (SyntaxKind.SIMPLE_NAME_REFERENCE)) {\n+            if (parentKind == (SyntaxKind.REQUIRED_PARAM) ||\n+                    parentKind == (SyntaxKind.POSITIONAL_ARG) ||\n+                    parentKind == (SyntaxKind.BINARY_EXPRESSION) ||\n+                    parentKind == (SyntaxKind.BRACED_EXPRESSION) ||\n+                    parentKind == (SyntaxKind.RETURN_STATEMENT) ||\n+                    parentKind == (SyntaxKind.REMOTE_METHOD_CALL_ACTION) ||\n+                    parentKind == (SyntaxKind.FIELD_ACCESS) ||\n+                    (parentKind == (SyntaxKind.FUNCTION_CALL) && grandParent != null &&\n+                            grandParent.kind() == (SyntaxKind.ASSIGNMENT_STATEMENT))) {\n+                return null;\n+            }\n+            return getParent(parent, syntaxKind);\n+        } else if (syntaxKind == (SyntaxKind.STRING_TYPE_DESC) &&\n+                parentKind == (SyntaxKind.RECORD_FIELD) && grandParent != null &&\n+                grandParent.kind() == (SyntaxKind.RECORD_TYPE_DESC)) {\n+            return getParent(parent, syntaxKind);\n+        } else if (parentKind == (SyntaxKind.SERVICE_DECLARATION) ||\n+                parentKind == (SyntaxKind.BINARY_EXPRESSION)) {\n+            if (syntaxKind == (SyntaxKind.QUALIFIED_NAME_REFERENCE)) {\n+                return null;\n+            }\n+            return parent;\n+        } else if (parentKind == (SyntaxKind.REQUIRED_PARAM)) {\n+            return null;\n+        } else if (parentKind == (SyntaxKind.OBJECT_TYPE_DESC)) {\n+            if (grandParent != null && grandParent.kind() == (SyntaxKind.RETURN_TYPE_DESCRIPTOR)) {\n+                return grandParent.parent().parent();\n+            } else if (grandParent != null && grandParent.kind() == (SyntaxKind.TYPE_DEFINITION)) {\n+                return getParent(parent, syntaxKind);\n+            } else {\n+                return parent;\n+            }\n+        } else if (grandParent != null) {\n+            return getParent(parent, syntaxKind);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    static int getIndentation(Node node, int indentation, FormattingOptions formattingOptions) {\n+        if (node == null) {\n+            return indentation;\n+        }\n+        if (node.parent() != null) {\n+            SyntaxKind parentKind = node.parent().kind();\n+            if (parentKind == SyntaxKind.BLOCK_STATEMENT ||\n+                    parentKind == SyntaxKind.FUNCTION_BODY_BLOCK ||\n+                    parentKind == SyntaxKind.LIST_CONSTRUCTOR ||\n+                    parentKind == SyntaxKind.TYPE_DEFINITION ||\n+                    parentKind == SyntaxKind.METHOD_DECLARATION ||\n+                    parentKind == SyntaxKind.MAPPING_CONSTRUCTOR) {\n+                indentation += formattingOptions.getTabSize();\n+            }\n+        }\n+        return getIndentation(node.parent(), indentation, formattingOptions);\n+    }\n+\n+    private static MinutiaeList getCommentMinutiae(MinutiaeList minutiaeList, boolean isLeading) {\n+        MinutiaeList minutiaes = AbstractNodeFactory.createEmptyMinutiaeList();\n+        for (int i = 0; i < minutiaeList.size(); i++) {\n+            if (minutiaeList.get(i).kind() == (SyntaxKind.COMMENT_MINUTIAE)) {\n+                if (i > 0) {\n+                    minutiaes = minutiaes.add(minutiaeList.get(i - 1));\n+                }\n+                minutiaes = minutiaes.add(minutiaeList.get(i));\n+                if ((i + 1) < minutiaeList.size() && isLeading) {\n+                    minutiaes = minutiaes.add(minutiaeList.get(i + 1));\n+                }\n+            }\n+        }\n+        return minutiaes;\n+    }\n+\n+    private static String getWhiteSpaces(int column, int newLines) {\n+        StringBuilder whiteSpaces = new StringBuilder();\n+        for (int i = 0; i <= (newLines - 1); i++) {\n+            whiteSpaces.append(System.getProperty(LINE_SEPARATOR));\n+        }\n+        for (int i = 0; i <= (column - 1); i++) {\n+            whiteSpaces.append(\" \");\n+        }\n+        return whiteSpaces.toString();\n+    }\n+\n+    /**\n+     * Initialize the token with empty minutiae lists.\n+     *\n+     * @param node node\n+     * @return token with empty minutiae\n+     */\n+    static <T extends Token> Token getToken(T node) {\n+        if (node == null) {\n+            return node;\n+        }\n+        MinutiaeList leadingMinutiaeList = AbstractNodeFactory.createEmptyMinutiaeList();\n+        MinutiaeList trailingMinutiaeList = AbstractNodeFactory.createEmptyMinutiaeList();\n+        if (node.containsLeadingMinutiae()) {\n+            leadingMinutiaeList = getCommentMinutiae(node.leadingMinutiae(), true);\n+        }\n+        if (node.containsTrailingMinutiae()) {\n+            trailingMinutiaeList = getCommentMinutiae(node.trailingMinutiae(), false);\n+        }\n+        return node.modify(leadingMinutiaeList, trailingMinutiaeList);\n+    }\n+\n+    static boolean isInLineRange(Node node, LineRange lineRange) {\n+        if (lineRange == null) {\n+            return true;\n+        }\n+        int nodeStartLine = node.lineRange().startLine().line();\n+        int nodeStartOffset = node.lineRange().startLine().offset();\n+        int nodeEndLine = node.lineRange().endLine().line();\n+        int nodeEndOffset = node.lineRange().endLine().offset();\n+\n+        int startLine = lineRange.startLine().line();\n+        int startOffset = lineRange.startLine().offset();\n+        int endLine = lineRange.endLine().line();\n+        int endOffset = lineRange.endLine().offset();\n+\n+        if (nodeStartLine >= startLine && nodeEndLine <= endLine) {\n+            if (nodeStartLine == startLine || nodeEndLine == endLine) {\n+                return nodeStartOffset >= startOffset && nodeEndOffset <= endOffset;\n+            }\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Update the minutiae and return the token.\n+     *\n+     * @param token            token\n+     * @param leadingSpaces    leading spaces\n+     * @param trailingSpaces   trailing spaces\n+     * @param leadingNewLines  leading new lines\n+     * @param trailingNewLines trailing new lines\n+     * @return updated token\n+     */\n+    static Token formatToken(Token token, int leadingSpaces, int trailingSpaces, int leadingNewLines,\n+                             int trailingNewLines) {\n+        if (token == null) {\n+            return token;\n+        }\n+        MinutiaeList newLeadingMinutiaeList = modifyMinutiaeList(leadingSpaces, leadingNewLines);\n+        MinutiaeList newTrailingMinutiaeList = modifyMinutiaeList(trailingSpaces, trailingNewLines);\n+\n+        return token.modify(newLeadingMinutiaeList, newTrailingMinutiaeList);\n+    }\n+\n+    private static MinutiaeList modifyMinutiaeList(int spaces, int newLines) {\n+        Minutiae minutiae = createWhitespaceMinutiae(getWhiteSpaces(spaces, newLines));\n+        return createMinutiaeList(minutiae);\n+    }\n+\n+    private static int getChildLocation(NonTerminalNode parent, Node child) {\n+        if (parent != null && child != null) {\n+            for (int i = 0; i < parent.children().size(); i++) {\n+                if (parent.children().get(i).equals(child)) {\n+                    return i;\n+                }\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    private static int regexCount(String context, String pattern) {\n+        Matcher matcher = Pattern.compile(String.valueOf(pattern)).matcher(context);\n+        int response = 0;\n+        while (matcher.find()) {\n+            response++;\n+        }\n+        return response;\n+    }\n+\n+    private static Token getStartingToken(Node node) {\n+        if (node instanceof Token) {\n+            return (Token) node;\n+        }\n+        ChildNodeList childNodeList = ((NonTerminalNode) node).children();\n+        return getStartingToken(childNodeList.get(0));\n+    }\n+\n+    private static Token getEndingToken(Node node) {\n+        if (node instanceof Token) {\n+            return (Token) node;\n+        }\n+        ChildNodeList childNodeList = ((NonTerminalNode) node).children();\n+        return getStartingToken(childNodeList.get(childNodeList.size() - 1));\n+    }\n+\n+    static boolean preserveNewLine(NonTerminalNode node) {\n+        ArrayList<SyntaxKind> endTokens = new ArrayList<>(\n+                Arrays.asList(\n+                        SyntaxKind.CLOSE_BRACE_TOKEN,\n+                        SyntaxKind.CLOSE_BRACE_PIPE_TOKEN,\n+                        SyntaxKind.CLOSE_BRACKET_TOKEN,\n+                        SyntaxKind.CLOSE_PAREN_TOKEN));\n+        boolean preserve = false;\n+        MinutiaeList nodeEnd = getEndingToken(node).trailingMinutiae();\n+        if (nodeEnd.toString().contains(System.getProperty(LINE_SEPARATOR))) {\n+            int childIndex = getChildLocation(node.parent(), node);\n+            if (childIndex != -1) {\n+                Node nextNode = node.parent().children().get(childIndex + 1);\n+                if (nextNode != null && !endTokens.contains(nextNode.kind())) {\n+                    MinutiaeList siblingStart = getStartingToken(nextNode).leadingMinutiae();\n+                    int newLines = regexCount(nodeEnd.toString(), System.getProperty(LINE_SEPARATOR));\n+                    if (siblingStart.toString().contains(System.getProperty(LINE_SEPARATOR)) || newLines > 1) {\n+                        preserve = true;\n+                    }\n+                }\n+            }\n+        }\n+        return preserve;\n+    }\n+\n+    private static ArrayList<NonTerminalNode> nestedIfBlock(NonTerminalNode node) {\n+        NonTerminalNode parent = node.parent();\n+        ArrayList<NonTerminalNode> nestedParent = new ArrayList<>();\n+        if (parent == null) {\n+            return new ArrayList<>(0);\n+        } else {\n+            while (parent != null) {\n+                if (parent.kind() == (node.kind())) {\n+                    nestedParent.add(parent);\n+                }\n+                parent = parent.parent();\n+            }\n+        }\n+        return nestedParent.isEmpty() ? null : nestedParent;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abf30d5163ce0ebdc71f6463696d834f80cc2f05"}, "originalPosition": 319}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzYwODQwNQ==", "bodyText": "Done", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25680#discussion_r487608405", "createdAt": "2020-09-14T01:30:49Z", "author": {"login": "IrushiL"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/FormatterUtils.java", "diffHunk": "@@ -0,0 +1,415 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.core;\n+\n+import io.ballerina.tools.text.LinePosition;\n+import io.ballerina.tools.text.LineRange;\n+import io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory;\n+import io.ballerinalang.compiler.syntax.tree.ChildNodeList;\n+import io.ballerinalang.compiler.syntax.tree.Minutiae;\n+import io.ballerinalang.compiler.syntax.tree.MinutiaeList;\n+import io.ballerinalang.compiler.syntax.tree.Node;\n+import io.ballerinalang.compiler.syntax.tree.NonTerminalNode;\n+import io.ballerinalang.compiler.syntax.tree.SyntaxKind;\n+import io.ballerinalang.compiler.syntax.tree.Token;\n+import org.wso2.ballerinalang.compiler.util.diagnotic.DiagnosticPos;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import static io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory.createMinutiaeList;\n+import static io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory.createWhitespaceMinutiae;\n+\n+/**\n+ * Class that contains the util functions used by the formatting tree modifier.\n+ */\n+class FormatterUtils {\n+\n+    private static final String LINE_SEPARATOR = \"line.separator\";\n+\n+    /**\n+     * Get the node position.\n+     *\n+     * @param node node\n+     * @return node position\n+     */\n+    static DiagnosticPos getPosition(Node node) {\n+        if (node == null) {\n+            return null;\n+        }\n+        LineRange range = node.lineRange();\n+        LinePosition startPos = range.startLine();\n+        LinePosition endPos = range.endLine();\n+        int startOffset = startPos.offset();\n+        if (node.kind() == (SyntaxKind.FUNCTION_DEFINITION) || node.kind() == (SyntaxKind.TYPE_DEFINITION) ||\n+                node.kind() == (SyntaxKind.CONST_DECLARATION) || node.kind() == (SyntaxKind.OBJECT_TYPE_DESC)) {\n+            startOffset = (startOffset / 4) * 4;\n+        }\n+        return new DiagnosticPos(null, startPos.line() + 1, endPos.line() + 1,\n+                startOffset, endPos.offset());\n+    }\n+\n+    // TODO: Use a generic way to get the parent node using querying.\n+    static <T extends Node> Node getParent(T node, SyntaxKind syntaxKind) {\n+        Node parent = node.parent();\n+        if (parent == null) {\n+            parent = node;\n+        }\n+        Node grandParent = parent.parent();\n+        SyntaxKind parentKind = parent.kind();\n+        if (parentKind == (SyntaxKind.MODULE_VAR_DECL)) {\n+            if (grandParent != null && grandParent.kind() == (SyntaxKind.MODULE_PART) &&\n+                    syntaxKind == (SyntaxKind.QUALIFIED_NAME_REFERENCE)) {\n+                return null;\n+            }\n+            return parent;\n+        } else if (parentKind == (SyntaxKind.FUNCTION_DEFINITION) ||\n+                parentKind == (SyntaxKind.ELSE_BLOCK) ||\n+                parentKind == (SyntaxKind.IF_ELSE_STATEMENT) ||\n+                parentKind == (SyntaxKind.LOCAL_TYPE_DEFINITION_STATEMENT) ||\n+                parentKind == (SyntaxKind.WHILE_STATEMENT) ||\n+                parentKind == (SyntaxKind.CONST_DECLARATION) ||\n+                parentKind == (SyntaxKind.METHOD_DECLARATION) ||\n+                parentKind == (SyntaxKind.TYPE_DEFINITION)) {\n+            return parent;\n+        } else if (syntaxKind == (SyntaxKind.SIMPLE_NAME_REFERENCE)) {\n+            if (parentKind == (SyntaxKind.REQUIRED_PARAM) ||\n+                    parentKind == (SyntaxKind.POSITIONAL_ARG) ||\n+                    parentKind == (SyntaxKind.BINARY_EXPRESSION) ||\n+                    parentKind == (SyntaxKind.BRACED_EXPRESSION) ||\n+                    parentKind == (SyntaxKind.RETURN_STATEMENT) ||\n+                    parentKind == (SyntaxKind.REMOTE_METHOD_CALL_ACTION) ||\n+                    parentKind == (SyntaxKind.FIELD_ACCESS) ||\n+                    (parentKind == (SyntaxKind.FUNCTION_CALL) && grandParent != null &&\n+                            grandParent.kind() == (SyntaxKind.ASSIGNMENT_STATEMENT))) {\n+                return null;\n+            }\n+            return getParent(parent, syntaxKind);\n+        } else if (syntaxKind == (SyntaxKind.STRING_TYPE_DESC) &&\n+                parentKind == (SyntaxKind.RECORD_FIELD) && grandParent != null &&\n+                grandParent.kind() == (SyntaxKind.RECORD_TYPE_DESC)) {\n+            return getParent(parent, syntaxKind);\n+        } else if (parentKind == (SyntaxKind.SERVICE_DECLARATION) ||\n+                parentKind == (SyntaxKind.BINARY_EXPRESSION)) {\n+            if (syntaxKind == (SyntaxKind.QUALIFIED_NAME_REFERENCE)) {\n+                return null;\n+            }\n+            return parent;\n+        } else if (parentKind == (SyntaxKind.REQUIRED_PARAM)) {\n+            return null;\n+        } else if (parentKind == (SyntaxKind.OBJECT_TYPE_DESC)) {\n+            if (grandParent != null && grandParent.kind() == (SyntaxKind.RETURN_TYPE_DESCRIPTOR)) {\n+                return grandParent.parent().parent();\n+            } else if (grandParent != null && grandParent.kind() == (SyntaxKind.TYPE_DEFINITION)) {\n+                return getParent(parent, syntaxKind);\n+            } else {\n+                return parent;\n+            }\n+        } else if (grandParent != null) {\n+            return getParent(parent, syntaxKind);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    static int getIndentation(Node node, int indentation, FormattingOptions formattingOptions) {\n+        if (node == null) {\n+            return indentation;\n+        }\n+        if (node.parent() != null) {\n+            SyntaxKind parentKind = node.parent().kind();\n+            if (parentKind == SyntaxKind.BLOCK_STATEMENT ||\n+                    parentKind == SyntaxKind.FUNCTION_BODY_BLOCK ||\n+                    parentKind == SyntaxKind.LIST_CONSTRUCTOR ||\n+                    parentKind == SyntaxKind.TYPE_DEFINITION ||\n+                    parentKind == SyntaxKind.METHOD_DECLARATION ||\n+                    parentKind == SyntaxKind.MAPPING_CONSTRUCTOR) {\n+                indentation += formattingOptions.getTabSize();\n+            }\n+        }\n+        return getIndentation(node.parent(), indentation, formattingOptions);\n+    }\n+\n+    private static MinutiaeList getCommentMinutiae(MinutiaeList minutiaeList, boolean isLeading) {\n+        MinutiaeList minutiaes = AbstractNodeFactory.createEmptyMinutiaeList();\n+        for (int i = 0; i < minutiaeList.size(); i++) {\n+            if (minutiaeList.get(i).kind() == (SyntaxKind.COMMENT_MINUTIAE)) {\n+                if (i > 0) {\n+                    minutiaes = minutiaes.add(minutiaeList.get(i - 1));\n+                }\n+                minutiaes = minutiaes.add(minutiaeList.get(i));\n+                if ((i + 1) < minutiaeList.size() && isLeading) {\n+                    minutiaes = minutiaes.add(minutiaeList.get(i + 1));\n+                }\n+            }\n+        }\n+        return minutiaes;\n+    }\n+\n+    private static String getWhiteSpaces(int column, int newLines) {\n+        StringBuilder whiteSpaces = new StringBuilder();\n+        for (int i = 0; i <= (newLines - 1); i++) {\n+            whiteSpaces.append(System.getProperty(LINE_SEPARATOR));\n+        }\n+        for (int i = 0; i <= (column - 1); i++) {\n+            whiteSpaces.append(\" \");\n+        }\n+        return whiteSpaces.toString();\n+    }\n+\n+    /**\n+     * Initialize the token with empty minutiae lists.\n+     *\n+     * @param node node\n+     * @return token with empty minutiae\n+     */\n+    static <T extends Token> Token getToken(T node) {\n+        if (node == null) {\n+            return node;\n+        }\n+        MinutiaeList leadingMinutiaeList = AbstractNodeFactory.createEmptyMinutiaeList();\n+        MinutiaeList trailingMinutiaeList = AbstractNodeFactory.createEmptyMinutiaeList();\n+        if (node.containsLeadingMinutiae()) {\n+            leadingMinutiaeList = getCommentMinutiae(node.leadingMinutiae(), true);\n+        }\n+        if (node.containsTrailingMinutiae()) {\n+            trailingMinutiaeList = getCommentMinutiae(node.trailingMinutiae(), false);\n+        }\n+        return node.modify(leadingMinutiaeList, trailingMinutiaeList);\n+    }\n+\n+    static boolean isInLineRange(Node node, LineRange lineRange) {\n+        if (lineRange == null) {\n+            return true;\n+        }\n+        int nodeStartLine = node.lineRange().startLine().line();\n+        int nodeStartOffset = node.lineRange().startLine().offset();\n+        int nodeEndLine = node.lineRange().endLine().line();\n+        int nodeEndOffset = node.lineRange().endLine().offset();\n+\n+        int startLine = lineRange.startLine().line();\n+        int startOffset = lineRange.startLine().offset();\n+        int endLine = lineRange.endLine().line();\n+        int endOffset = lineRange.endLine().offset();\n+\n+        if (nodeStartLine >= startLine && nodeEndLine <= endLine) {\n+            if (nodeStartLine == startLine || nodeEndLine == endLine) {\n+                return nodeStartOffset >= startOffset && nodeEndOffset <= endOffset;\n+            }\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Update the minutiae and return the token.\n+     *\n+     * @param token            token\n+     * @param leadingSpaces    leading spaces\n+     * @param trailingSpaces   trailing spaces\n+     * @param leadingNewLines  leading new lines\n+     * @param trailingNewLines trailing new lines\n+     * @return updated token\n+     */\n+    static Token formatToken(Token token, int leadingSpaces, int trailingSpaces, int leadingNewLines,\n+                             int trailingNewLines) {\n+        if (token == null) {\n+            return token;\n+        }\n+        MinutiaeList newLeadingMinutiaeList = modifyMinutiaeList(leadingSpaces, leadingNewLines);\n+        MinutiaeList newTrailingMinutiaeList = modifyMinutiaeList(trailingSpaces, trailingNewLines);\n+\n+        return token.modify(newLeadingMinutiaeList, newTrailingMinutiaeList);\n+    }\n+\n+    private static MinutiaeList modifyMinutiaeList(int spaces, int newLines) {\n+        Minutiae minutiae = createWhitespaceMinutiae(getWhiteSpaces(spaces, newLines));\n+        return createMinutiaeList(minutiae);\n+    }\n+\n+    private static int getChildLocation(NonTerminalNode parent, Node child) {\n+        if (parent != null && child != null) {\n+            for (int i = 0; i < parent.children().size(); i++) {\n+                if (parent.children().get(i).equals(child)) {\n+                    return i;\n+                }\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    private static int regexCount(String context, String pattern) {\n+        Matcher matcher = Pattern.compile(String.valueOf(pattern)).matcher(context);\n+        int response = 0;\n+        while (matcher.find()) {\n+            response++;\n+        }\n+        return response;\n+    }\n+\n+    private static Token getStartingToken(Node node) {\n+        if (node instanceof Token) {\n+            return (Token) node;\n+        }\n+        ChildNodeList childNodeList = ((NonTerminalNode) node).children();\n+        return getStartingToken(childNodeList.get(0));\n+    }\n+\n+    private static Token getEndingToken(Node node) {\n+        if (node instanceof Token) {\n+            return (Token) node;\n+        }\n+        ChildNodeList childNodeList = ((NonTerminalNode) node).children();\n+        return getStartingToken(childNodeList.get(childNodeList.size() - 1));\n+    }\n+\n+    static boolean preserveNewLine(NonTerminalNode node) {\n+        ArrayList<SyntaxKind> endTokens = new ArrayList<>(\n+                Arrays.asList(\n+                        SyntaxKind.CLOSE_BRACE_TOKEN,\n+                        SyntaxKind.CLOSE_BRACE_PIPE_TOKEN,\n+                        SyntaxKind.CLOSE_BRACKET_TOKEN,\n+                        SyntaxKind.CLOSE_PAREN_TOKEN));\n+        boolean preserve = false;\n+        MinutiaeList nodeEnd = getEndingToken(node).trailingMinutiae();\n+        if (nodeEnd.toString().contains(System.getProperty(LINE_SEPARATOR))) {\n+            int childIndex = getChildLocation(node.parent(), node);\n+            if (childIndex != -1) {\n+                Node nextNode = node.parent().children().get(childIndex + 1);\n+                if (nextNode != null && !endTokens.contains(nextNode.kind())) {\n+                    MinutiaeList siblingStart = getStartingToken(nextNode).leadingMinutiae();\n+                    int newLines = regexCount(nodeEnd.toString(), System.getProperty(LINE_SEPARATOR));\n+                    if (siblingStart.toString().contains(System.getProperty(LINE_SEPARATOR)) || newLines > 1) {\n+                        preserve = true;\n+                    }\n+                }\n+            }\n+        }\n+        return preserve;\n+    }\n+\n+    private static ArrayList<NonTerminalNode> nestedIfBlock(NonTerminalNode node) {\n+        NonTerminalNode parent = node.parent();\n+        ArrayList<NonTerminalNode> nestedParent = new ArrayList<>();\n+        if (parent == null) {\n+            return new ArrayList<>(0);\n+        } else {\n+            while (parent != null) {\n+                if (parent.kind() == (node.kind())) {\n+                    nestedParent.add(parent);\n+                }\n+                parent = parent.parent();\n+            }\n+        }\n+        return nestedParent.isEmpty() ? null : nestedParent;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzIwMDA1Ng=="}, "originalCommit": {"oid": "abf30d5163ce0ebdc71f6463696d834f80cc2f05"}, "originalPosition": 319}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NzU1NTQ0OnYy", "diffSide": "RIGHT", "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/FormatterUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNzo1NTozMFrOHQoY1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQwMToyMjo1MFrOHRBKTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzIwMDk4MA==", "bodyText": "let's remove the else-if ladder and stick to the if clauses since each clause have a return", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25680#discussion_r487200980", "createdAt": "2020-09-11T17:55:30Z", "author": {"login": "nadeeshaan"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/FormatterUtils.java", "diffHunk": "@@ -0,0 +1,415 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.core;\n+\n+import io.ballerina.tools.text.LinePosition;\n+import io.ballerina.tools.text.LineRange;\n+import io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory;\n+import io.ballerinalang.compiler.syntax.tree.ChildNodeList;\n+import io.ballerinalang.compiler.syntax.tree.Minutiae;\n+import io.ballerinalang.compiler.syntax.tree.MinutiaeList;\n+import io.ballerinalang.compiler.syntax.tree.Node;\n+import io.ballerinalang.compiler.syntax.tree.NonTerminalNode;\n+import io.ballerinalang.compiler.syntax.tree.SyntaxKind;\n+import io.ballerinalang.compiler.syntax.tree.Token;\n+import org.wso2.ballerinalang.compiler.util.diagnotic.DiagnosticPos;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import static io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory.createMinutiaeList;\n+import static io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory.createWhitespaceMinutiae;\n+\n+/**\n+ * Class that contains the util functions used by the formatting tree modifier.\n+ */\n+class FormatterUtils {\n+\n+    private static final String LINE_SEPARATOR = \"line.separator\";\n+\n+    /**\n+     * Get the node position.\n+     *\n+     * @param node node\n+     * @return node position\n+     */\n+    static DiagnosticPos getPosition(Node node) {\n+        if (node == null) {\n+            return null;\n+        }\n+        LineRange range = node.lineRange();\n+        LinePosition startPos = range.startLine();\n+        LinePosition endPos = range.endLine();\n+        int startOffset = startPos.offset();\n+        if (node.kind() == (SyntaxKind.FUNCTION_DEFINITION) || node.kind() == (SyntaxKind.TYPE_DEFINITION) ||\n+                node.kind() == (SyntaxKind.CONST_DECLARATION) || node.kind() == (SyntaxKind.OBJECT_TYPE_DESC)) {\n+            startOffset = (startOffset / 4) * 4;\n+        }\n+        return new DiagnosticPos(null, startPos.line() + 1, endPos.line() + 1,\n+                startOffset, endPos.offset());\n+    }\n+\n+    // TODO: Use a generic way to get the parent node using querying.\n+    static <T extends Node> Node getParent(T node, SyntaxKind syntaxKind) {\n+        Node parent = node.parent();\n+        if (parent == null) {\n+            parent = node;\n+        }\n+        Node grandParent = parent.parent();\n+        SyntaxKind parentKind = parent.kind();\n+        if (parentKind == (SyntaxKind.MODULE_VAR_DECL)) {\n+            if (grandParent != null && grandParent.kind() == (SyntaxKind.MODULE_PART) &&\n+                    syntaxKind == (SyntaxKind.QUALIFIED_NAME_REFERENCE)) {\n+                return null;\n+            }\n+            return parent;\n+        } else if (parentKind == (SyntaxKind.FUNCTION_DEFINITION) ||\n+                parentKind == (SyntaxKind.ELSE_BLOCK) ||\n+                parentKind == (SyntaxKind.IF_ELSE_STATEMENT) ||\n+                parentKind == (SyntaxKind.LOCAL_TYPE_DEFINITION_STATEMENT) ||\n+                parentKind == (SyntaxKind.WHILE_STATEMENT) ||\n+                parentKind == (SyntaxKind.CONST_DECLARATION) ||\n+                parentKind == (SyntaxKind.METHOD_DECLARATION) ||\n+                parentKind == (SyntaxKind.TYPE_DEFINITION)) {\n+            return parent;\n+        } else if (syntaxKind == (SyntaxKind.SIMPLE_NAME_REFERENCE)) {\n+            if (parentKind == (SyntaxKind.REQUIRED_PARAM) ||\n+                    parentKind == (SyntaxKind.POSITIONAL_ARG) ||\n+                    parentKind == (SyntaxKind.BINARY_EXPRESSION) ||\n+                    parentKind == (SyntaxKind.BRACED_EXPRESSION) ||\n+                    parentKind == (SyntaxKind.RETURN_STATEMENT) ||\n+                    parentKind == (SyntaxKind.REMOTE_METHOD_CALL_ACTION) ||\n+                    parentKind == (SyntaxKind.FIELD_ACCESS) ||\n+                    (parentKind == (SyntaxKind.FUNCTION_CALL) && grandParent != null &&\n+                            grandParent.kind() == (SyntaxKind.ASSIGNMENT_STATEMENT))) {\n+                return null;\n+            }\n+            return getParent(parent, syntaxKind);\n+        } else if (syntaxKind == (SyntaxKind.STRING_TYPE_DESC) &&\n+                parentKind == (SyntaxKind.RECORD_FIELD) && grandParent != null &&\n+                grandParent.kind() == (SyntaxKind.RECORD_TYPE_DESC)) {\n+            return getParent(parent, syntaxKind);\n+        } else if (parentKind == (SyntaxKind.SERVICE_DECLARATION) ||\n+                parentKind == (SyntaxKind.BINARY_EXPRESSION)) {\n+            if (syntaxKind == (SyntaxKind.QUALIFIED_NAME_REFERENCE)) {\n+                return null;\n+            }\n+            return parent;\n+        } else if (parentKind == (SyntaxKind.REQUIRED_PARAM)) {\n+            return null;\n+        } else if (parentKind == (SyntaxKind.OBJECT_TYPE_DESC)) {\n+            if (grandParent != null && grandParent.kind() == (SyntaxKind.RETURN_TYPE_DESCRIPTOR)) {\n+                return grandParent.parent().parent();\n+            } else if (grandParent != null && grandParent.kind() == (SyntaxKind.TYPE_DEFINITION)) {\n+                return getParent(parent, syntaxKind);\n+            } else {\n+                return parent;\n+            }\n+        } else if (grandParent != null) {\n+            return getParent(parent, syntaxKind);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    static int getIndentation(Node node, int indentation, FormattingOptions formattingOptions) {\n+        if (node == null) {\n+            return indentation;\n+        }\n+        if (node.parent() != null) {\n+            SyntaxKind parentKind = node.parent().kind();\n+            if (parentKind == SyntaxKind.BLOCK_STATEMENT ||\n+                    parentKind == SyntaxKind.FUNCTION_BODY_BLOCK ||\n+                    parentKind == SyntaxKind.LIST_CONSTRUCTOR ||\n+                    parentKind == SyntaxKind.TYPE_DEFINITION ||\n+                    parentKind == SyntaxKind.METHOD_DECLARATION ||\n+                    parentKind == SyntaxKind.MAPPING_CONSTRUCTOR) {\n+                indentation += formattingOptions.getTabSize();\n+            }\n+        }\n+        return getIndentation(node.parent(), indentation, formattingOptions);\n+    }\n+\n+    private static MinutiaeList getCommentMinutiae(MinutiaeList minutiaeList, boolean isLeading) {\n+        MinutiaeList minutiaes = AbstractNodeFactory.createEmptyMinutiaeList();\n+        for (int i = 0; i < minutiaeList.size(); i++) {\n+            if (minutiaeList.get(i).kind() == (SyntaxKind.COMMENT_MINUTIAE)) {\n+                if (i > 0) {\n+                    minutiaes = minutiaes.add(minutiaeList.get(i - 1));\n+                }\n+                minutiaes = minutiaes.add(minutiaeList.get(i));\n+                if ((i + 1) < minutiaeList.size() && isLeading) {\n+                    minutiaes = minutiaes.add(minutiaeList.get(i + 1));\n+                }\n+            }\n+        }\n+        return minutiaes;\n+    }\n+\n+    private static String getWhiteSpaces(int column, int newLines) {\n+        StringBuilder whiteSpaces = new StringBuilder();\n+        for (int i = 0; i <= (newLines - 1); i++) {\n+            whiteSpaces.append(System.getProperty(LINE_SEPARATOR));\n+        }\n+        for (int i = 0; i <= (column - 1); i++) {\n+            whiteSpaces.append(\" \");\n+        }\n+        return whiteSpaces.toString();\n+    }\n+\n+    /**\n+     * Initialize the token with empty minutiae lists.\n+     *\n+     * @param node node\n+     * @return token with empty minutiae\n+     */\n+    static <T extends Token> Token getToken(T node) {\n+        if (node == null) {\n+            return node;\n+        }\n+        MinutiaeList leadingMinutiaeList = AbstractNodeFactory.createEmptyMinutiaeList();\n+        MinutiaeList trailingMinutiaeList = AbstractNodeFactory.createEmptyMinutiaeList();\n+        if (node.containsLeadingMinutiae()) {\n+            leadingMinutiaeList = getCommentMinutiae(node.leadingMinutiae(), true);\n+        }\n+        if (node.containsTrailingMinutiae()) {\n+            trailingMinutiaeList = getCommentMinutiae(node.trailingMinutiae(), false);\n+        }\n+        return node.modify(leadingMinutiaeList, trailingMinutiaeList);\n+    }\n+\n+    static boolean isInLineRange(Node node, LineRange lineRange) {\n+        if (lineRange == null) {\n+            return true;\n+        }\n+        int nodeStartLine = node.lineRange().startLine().line();\n+        int nodeStartOffset = node.lineRange().startLine().offset();\n+        int nodeEndLine = node.lineRange().endLine().line();\n+        int nodeEndOffset = node.lineRange().endLine().offset();\n+\n+        int startLine = lineRange.startLine().line();\n+        int startOffset = lineRange.startLine().offset();\n+        int endLine = lineRange.endLine().line();\n+        int endOffset = lineRange.endLine().offset();\n+\n+        if (nodeStartLine >= startLine && nodeEndLine <= endLine) {\n+            if (nodeStartLine == startLine || nodeEndLine == endLine) {\n+                return nodeStartOffset >= startOffset && nodeEndOffset <= endOffset;\n+            }\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Update the minutiae and return the token.\n+     *\n+     * @param token            token\n+     * @param leadingSpaces    leading spaces\n+     * @param trailingSpaces   trailing spaces\n+     * @param leadingNewLines  leading new lines\n+     * @param trailingNewLines trailing new lines\n+     * @return updated token\n+     */\n+    static Token formatToken(Token token, int leadingSpaces, int trailingSpaces, int leadingNewLines,\n+                             int trailingNewLines) {\n+        if (token == null) {\n+            return token;\n+        }\n+        MinutiaeList newLeadingMinutiaeList = modifyMinutiaeList(leadingSpaces, leadingNewLines);\n+        MinutiaeList newTrailingMinutiaeList = modifyMinutiaeList(trailingSpaces, trailingNewLines);\n+\n+        return token.modify(newLeadingMinutiaeList, newTrailingMinutiaeList);\n+    }\n+\n+    private static MinutiaeList modifyMinutiaeList(int spaces, int newLines) {\n+        Minutiae minutiae = createWhitespaceMinutiae(getWhiteSpaces(spaces, newLines));\n+        return createMinutiaeList(minutiae);\n+    }\n+\n+    private static int getChildLocation(NonTerminalNode parent, Node child) {\n+        if (parent != null && child != null) {\n+            for (int i = 0; i < parent.children().size(); i++) {\n+                if (parent.children().get(i).equals(child)) {\n+                    return i;\n+                }\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    private static int regexCount(String context, String pattern) {\n+        Matcher matcher = Pattern.compile(String.valueOf(pattern)).matcher(context);\n+        int response = 0;\n+        while (matcher.find()) {\n+            response++;\n+        }\n+        return response;\n+    }\n+\n+    private static Token getStartingToken(Node node) {\n+        if (node instanceof Token) {\n+            return (Token) node;\n+        }\n+        ChildNodeList childNodeList = ((NonTerminalNode) node).children();\n+        return getStartingToken(childNodeList.get(0));\n+    }\n+\n+    private static Token getEndingToken(Node node) {\n+        if (node instanceof Token) {\n+            return (Token) node;\n+        }\n+        ChildNodeList childNodeList = ((NonTerminalNode) node).children();\n+        return getStartingToken(childNodeList.get(childNodeList.size() - 1));\n+    }\n+\n+    static boolean preserveNewLine(NonTerminalNode node) {\n+        ArrayList<SyntaxKind> endTokens = new ArrayList<>(\n+                Arrays.asList(\n+                        SyntaxKind.CLOSE_BRACE_TOKEN,\n+                        SyntaxKind.CLOSE_BRACE_PIPE_TOKEN,\n+                        SyntaxKind.CLOSE_BRACKET_TOKEN,\n+                        SyntaxKind.CLOSE_PAREN_TOKEN));\n+        boolean preserve = false;\n+        MinutiaeList nodeEnd = getEndingToken(node).trailingMinutiae();\n+        if (nodeEnd.toString().contains(System.getProperty(LINE_SEPARATOR))) {\n+            int childIndex = getChildLocation(node.parent(), node);\n+            if (childIndex != -1) {\n+                Node nextNode = node.parent().children().get(childIndex + 1);\n+                if (nextNode != null && !endTokens.contains(nextNode.kind())) {\n+                    MinutiaeList siblingStart = getStartingToken(nextNode).leadingMinutiae();\n+                    int newLines = regexCount(nodeEnd.toString(), System.getProperty(LINE_SEPARATOR));\n+                    if (siblingStart.toString().contains(System.getProperty(LINE_SEPARATOR)) || newLines > 1) {\n+                        preserve = true;\n+                    }\n+                }\n+            }\n+        }\n+        return preserve;\n+    }\n+\n+    private static ArrayList<NonTerminalNode> nestedIfBlock(NonTerminalNode node) {\n+        NonTerminalNode parent = node.parent();\n+        ArrayList<NonTerminalNode> nestedParent = new ArrayList<>();\n+        if (parent == null) {\n+            return new ArrayList<>(0);\n+        } else {\n+            while (parent != null) {\n+                if (parent.kind() == (node.kind())) {\n+                    nestedParent.add(parent);\n+                }\n+                parent = parent.parent();\n+            }\n+        }\n+        return nestedParent.isEmpty() ? null : nestedParent;\n+    }\n+\n+    /**\n+     * return the indented start column.\n+     *\n+     * @param node       node\n+     * @param addSpaces  add spaces or not\n+     * @return start position\n+     */\n+    static int getStartColumn(Node node, boolean addSpaces, FormattingOptions formattingOptions) {\n+        Node parent;\n+        if (node.kind() == (SyntaxKind.IF_ELSE_STATEMENT)) {\n+            Indentation indent = getIfElseParent((NonTerminalNode) node);\n+            parent = indent.getParent();\n+            addSpaces = indent.getAddSpaces();\n+        } else if (node.kind() == (SyntaxKind.BLOCK_STATEMENT)) {\n+            Indentation indent = getBlockParent(node);\n+            parent = indent.getParent();\n+            addSpaces = indent.getAddSpaces();\n+        } else {\n+            parent = getParent(node, node.kind());\n+        }\n+        if (parent != null) {\n+            int indentation = 0;\n+            if (addSpaces) {\n+                indentation = (FormatterUtils.getIndentation(node, 0, formattingOptions));\n+            }\n+            return getPosition(parent).sCol + indentation;\n+        }\n+        return 0;\n+    }\n+\n+    private static Indentation getIfElseParent(NonTerminalNode node) {\n+        NonTerminalNode parent = node.parent();\n+        if (parent == null) {\n+            parent = node;\n+        }\n+        if (parent.kind() == (SyntaxKind.FUNCTION_DEFINITION)) {\n+            return new Indentation(parent, true);\n+        } else if (parent.parent() != null) {\n+            return getIfElseParent(parent);\n+        }\n+        return new Indentation(null, false);\n+    }\n+\n+    private static Indentation getBlockParent(Node node) {\n+        Node parent = node.parent();\n+        if (parent == null) {\n+            parent = node;\n+        }\n+        ArrayList<SyntaxKind> parentWithSpaces = new ArrayList<>(\n+                Arrays.asList(\n+                        SyntaxKind.WHILE_STATEMENT,\n+                        SyntaxKind.FUNCTION_DEFINITION));\n+        ArrayList<SyntaxKind> parentWithoutSpaces = new ArrayList<>(\n+                Arrays.asList(\n+                        SyntaxKind.NAMED_WORKER_DECLARATION,\n+                        SyntaxKind.LOCAL_VAR_DECL,\n+                        SyntaxKind.FOREACH_STATEMENT));\n+\n+        if (parentWithSpaces.contains(parent.kind())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abf30d5163ce0ebdc71f6463696d834f80cc2f05"}, "originalPosition": 380}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzYwNjg2MQ==", "bodyText": "Done", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25680#discussion_r487606861", "createdAt": "2020-09-14T01:22:50Z", "author": {"login": "IrushiL"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/FormatterUtils.java", "diffHunk": "@@ -0,0 +1,415 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.core;\n+\n+import io.ballerina.tools.text.LinePosition;\n+import io.ballerina.tools.text.LineRange;\n+import io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory;\n+import io.ballerinalang.compiler.syntax.tree.ChildNodeList;\n+import io.ballerinalang.compiler.syntax.tree.Minutiae;\n+import io.ballerinalang.compiler.syntax.tree.MinutiaeList;\n+import io.ballerinalang.compiler.syntax.tree.Node;\n+import io.ballerinalang.compiler.syntax.tree.NonTerminalNode;\n+import io.ballerinalang.compiler.syntax.tree.SyntaxKind;\n+import io.ballerinalang.compiler.syntax.tree.Token;\n+import org.wso2.ballerinalang.compiler.util.diagnotic.DiagnosticPos;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import static io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory.createMinutiaeList;\n+import static io.ballerinalang.compiler.syntax.tree.AbstractNodeFactory.createWhitespaceMinutiae;\n+\n+/**\n+ * Class that contains the util functions used by the formatting tree modifier.\n+ */\n+class FormatterUtils {\n+\n+    private static final String LINE_SEPARATOR = \"line.separator\";\n+\n+    /**\n+     * Get the node position.\n+     *\n+     * @param node node\n+     * @return node position\n+     */\n+    static DiagnosticPos getPosition(Node node) {\n+        if (node == null) {\n+            return null;\n+        }\n+        LineRange range = node.lineRange();\n+        LinePosition startPos = range.startLine();\n+        LinePosition endPos = range.endLine();\n+        int startOffset = startPos.offset();\n+        if (node.kind() == (SyntaxKind.FUNCTION_DEFINITION) || node.kind() == (SyntaxKind.TYPE_DEFINITION) ||\n+                node.kind() == (SyntaxKind.CONST_DECLARATION) || node.kind() == (SyntaxKind.OBJECT_TYPE_DESC)) {\n+            startOffset = (startOffset / 4) * 4;\n+        }\n+        return new DiagnosticPos(null, startPos.line() + 1, endPos.line() + 1,\n+                startOffset, endPos.offset());\n+    }\n+\n+    // TODO: Use a generic way to get the parent node using querying.\n+    static <T extends Node> Node getParent(T node, SyntaxKind syntaxKind) {\n+        Node parent = node.parent();\n+        if (parent == null) {\n+            parent = node;\n+        }\n+        Node grandParent = parent.parent();\n+        SyntaxKind parentKind = parent.kind();\n+        if (parentKind == (SyntaxKind.MODULE_VAR_DECL)) {\n+            if (grandParent != null && grandParent.kind() == (SyntaxKind.MODULE_PART) &&\n+                    syntaxKind == (SyntaxKind.QUALIFIED_NAME_REFERENCE)) {\n+                return null;\n+            }\n+            return parent;\n+        } else if (parentKind == (SyntaxKind.FUNCTION_DEFINITION) ||\n+                parentKind == (SyntaxKind.ELSE_BLOCK) ||\n+                parentKind == (SyntaxKind.IF_ELSE_STATEMENT) ||\n+                parentKind == (SyntaxKind.LOCAL_TYPE_DEFINITION_STATEMENT) ||\n+                parentKind == (SyntaxKind.WHILE_STATEMENT) ||\n+                parentKind == (SyntaxKind.CONST_DECLARATION) ||\n+                parentKind == (SyntaxKind.METHOD_DECLARATION) ||\n+                parentKind == (SyntaxKind.TYPE_DEFINITION)) {\n+            return parent;\n+        } else if (syntaxKind == (SyntaxKind.SIMPLE_NAME_REFERENCE)) {\n+            if (parentKind == (SyntaxKind.REQUIRED_PARAM) ||\n+                    parentKind == (SyntaxKind.POSITIONAL_ARG) ||\n+                    parentKind == (SyntaxKind.BINARY_EXPRESSION) ||\n+                    parentKind == (SyntaxKind.BRACED_EXPRESSION) ||\n+                    parentKind == (SyntaxKind.RETURN_STATEMENT) ||\n+                    parentKind == (SyntaxKind.REMOTE_METHOD_CALL_ACTION) ||\n+                    parentKind == (SyntaxKind.FIELD_ACCESS) ||\n+                    (parentKind == (SyntaxKind.FUNCTION_CALL) && grandParent != null &&\n+                            grandParent.kind() == (SyntaxKind.ASSIGNMENT_STATEMENT))) {\n+                return null;\n+            }\n+            return getParent(parent, syntaxKind);\n+        } else if (syntaxKind == (SyntaxKind.STRING_TYPE_DESC) &&\n+                parentKind == (SyntaxKind.RECORD_FIELD) && grandParent != null &&\n+                grandParent.kind() == (SyntaxKind.RECORD_TYPE_DESC)) {\n+            return getParent(parent, syntaxKind);\n+        } else if (parentKind == (SyntaxKind.SERVICE_DECLARATION) ||\n+                parentKind == (SyntaxKind.BINARY_EXPRESSION)) {\n+            if (syntaxKind == (SyntaxKind.QUALIFIED_NAME_REFERENCE)) {\n+                return null;\n+            }\n+            return parent;\n+        } else if (parentKind == (SyntaxKind.REQUIRED_PARAM)) {\n+            return null;\n+        } else if (parentKind == (SyntaxKind.OBJECT_TYPE_DESC)) {\n+            if (grandParent != null && grandParent.kind() == (SyntaxKind.RETURN_TYPE_DESCRIPTOR)) {\n+                return grandParent.parent().parent();\n+            } else if (grandParent != null && grandParent.kind() == (SyntaxKind.TYPE_DEFINITION)) {\n+                return getParent(parent, syntaxKind);\n+            } else {\n+                return parent;\n+            }\n+        } else if (grandParent != null) {\n+            return getParent(parent, syntaxKind);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    static int getIndentation(Node node, int indentation, FormattingOptions formattingOptions) {\n+        if (node == null) {\n+            return indentation;\n+        }\n+        if (node.parent() != null) {\n+            SyntaxKind parentKind = node.parent().kind();\n+            if (parentKind == SyntaxKind.BLOCK_STATEMENT ||\n+                    parentKind == SyntaxKind.FUNCTION_BODY_BLOCK ||\n+                    parentKind == SyntaxKind.LIST_CONSTRUCTOR ||\n+                    parentKind == SyntaxKind.TYPE_DEFINITION ||\n+                    parentKind == SyntaxKind.METHOD_DECLARATION ||\n+                    parentKind == SyntaxKind.MAPPING_CONSTRUCTOR) {\n+                indentation += formattingOptions.getTabSize();\n+            }\n+        }\n+        return getIndentation(node.parent(), indentation, formattingOptions);\n+    }\n+\n+    private static MinutiaeList getCommentMinutiae(MinutiaeList minutiaeList, boolean isLeading) {\n+        MinutiaeList minutiaes = AbstractNodeFactory.createEmptyMinutiaeList();\n+        for (int i = 0; i < minutiaeList.size(); i++) {\n+            if (minutiaeList.get(i).kind() == (SyntaxKind.COMMENT_MINUTIAE)) {\n+                if (i > 0) {\n+                    minutiaes = minutiaes.add(minutiaeList.get(i - 1));\n+                }\n+                minutiaes = minutiaes.add(minutiaeList.get(i));\n+                if ((i + 1) < minutiaeList.size() && isLeading) {\n+                    minutiaes = minutiaes.add(minutiaeList.get(i + 1));\n+                }\n+            }\n+        }\n+        return minutiaes;\n+    }\n+\n+    private static String getWhiteSpaces(int column, int newLines) {\n+        StringBuilder whiteSpaces = new StringBuilder();\n+        for (int i = 0; i <= (newLines - 1); i++) {\n+            whiteSpaces.append(System.getProperty(LINE_SEPARATOR));\n+        }\n+        for (int i = 0; i <= (column - 1); i++) {\n+            whiteSpaces.append(\" \");\n+        }\n+        return whiteSpaces.toString();\n+    }\n+\n+    /**\n+     * Initialize the token with empty minutiae lists.\n+     *\n+     * @param node node\n+     * @return token with empty minutiae\n+     */\n+    static <T extends Token> Token getToken(T node) {\n+        if (node == null) {\n+            return node;\n+        }\n+        MinutiaeList leadingMinutiaeList = AbstractNodeFactory.createEmptyMinutiaeList();\n+        MinutiaeList trailingMinutiaeList = AbstractNodeFactory.createEmptyMinutiaeList();\n+        if (node.containsLeadingMinutiae()) {\n+            leadingMinutiaeList = getCommentMinutiae(node.leadingMinutiae(), true);\n+        }\n+        if (node.containsTrailingMinutiae()) {\n+            trailingMinutiaeList = getCommentMinutiae(node.trailingMinutiae(), false);\n+        }\n+        return node.modify(leadingMinutiaeList, trailingMinutiaeList);\n+    }\n+\n+    static boolean isInLineRange(Node node, LineRange lineRange) {\n+        if (lineRange == null) {\n+            return true;\n+        }\n+        int nodeStartLine = node.lineRange().startLine().line();\n+        int nodeStartOffset = node.lineRange().startLine().offset();\n+        int nodeEndLine = node.lineRange().endLine().line();\n+        int nodeEndOffset = node.lineRange().endLine().offset();\n+\n+        int startLine = lineRange.startLine().line();\n+        int startOffset = lineRange.startLine().offset();\n+        int endLine = lineRange.endLine().line();\n+        int endOffset = lineRange.endLine().offset();\n+\n+        if (nodeStartLine >= startLine && nodeEndLine <= endLine) {\n+            if (nodeStartLine == startLine || nodeEndLine == endLine) {\n+                return nodeStartOffset >= startOffset && nodeEndOffset <= endOffset;\n+            }\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Update the minutiae and return the token.\n+     *\n+     * @param token            token\n+     * @param leadingSpaces    leading spaces\n+     * @param trailingSpaces   trailing spaces\n+     * @param leadingNewLines  leading new lines\n+     * @param trailingNewLines trailing new lines\n+     * @return updated token\n+     */\n+    static Token formatToken(Token token, int leadingSpaces, int trailingSpaces, int leadingNewLines,\n+                             int trailingNewLines) {\n+        if (token == null) {\n+            return token;\n+        }\n+        MinutiaeList newLeadingMinutiaeList = modifyMinutiaeList(leadingSpaces, leadingNewLines);\n+        MinutiaeList newTrailingMinutiaeList = modifyMinutiaeList(trailingSpaces, trailingNewLines);\n+\n+        return token.modify(newLeadingMinutiaeList, newTrailingMinutiaeList);\n+    }\n+\n+    private static MinutiaeList modifyMinutiaeList(int spaces, int newLines) {\n+        Minutiae minutiae = createWhitespaceMinutiae(getWhiteSpaces(spaces, newLines));\n+        return createMinutiaeList(minutiae);\n+    }\n+\n+    private static int getChildLocation(NonTerminalNode parent, Node child) {\n+        if (parent != null && child != null) {\n+            for (int i = 0; i < parent.children().size(); i++) {\n+                if (parent.children().get(i).equals(child)) {\n+                    return i;\n+                }\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    private static int regexCount(String context, String pattern) {\n+        Matcher matcher = Pattern.compile(String.valueOf(pattern)).matcher(context);\n+        int response = 0;\n+        while (matcher.find()) {\n+            response++;\n+        }\n+        return response;\n+    }\n+\n+    private static Token getStartingToken(Node node) {\n+        if (node instanceof Token) {\n+            return (Token) node;\n+        }\n+        ChildNodeList childNodeList = ((NonTerminalNode) node).children();\n+        return getStartingToken(childNodeList.get(0));\n+    }\n+\n+    private static Token getEndingToken(Node node) {\n+        if (node instanceof Token) {\n+            return (Token) node;\n+        }\n+        ChildNodeList childNodeList = ((NonTerminalNode) node).children();\n+        return getStartingToken(childNodeList.get(childNodeList.size() - 1));\n+    }\n+\n+    static boolean preserveNewLine(NonTerminalNode node) {\n+        ArrayList<SyntaxKind> endTokens = new ArrayList<>(\n+                Arrays.asList(\n+                        SyntaxKind.CLOSE_BRACE_TOKEN,\n+                        SyntaxKind.CLOSE_BRACE_PIPE_TOKEN,\n+                        SyntaxKind.CLOSE_BRACKET_TOKEN,\n+                        SyntaxKind.CLOSE_PAREN_TOKEN));\n+        boolean preserve = false;\n+        MinutiaeList nodeEnd = getEndingToken(node).trailingMinutiae();\n+        if (nodeEnd.toString().contains(System.getProperty(LINE_SEPARATOR))) {\n+            int childIndex = getChildLocation(node.parent(), node);\n+            if (childIndex != -1) {\n+                Node nextNode = node.parent().children().get(childIndex + 1);\n+                if (nextNode != null && !endTokens.contains(nextNode.kind())) {\n+                    MinutiaeList siblingStart = getStartingToken(nextNode).leadingMinutiae();\n+                    int newLines = regexCount(nodeEnd.toString(), System.getProperty(LINE_SEPARATOR));\n+                    if (siblingStart.toString().contains(System.getProperty(LINE_SEPARATOR)) || newLines > 1) {\n+                        preserve = true;\n+                    }\n+                }\n+            }\n+        }\n+        return preserve;\n+    }\n+\n+    private static ArrayList<NonTerminalNode> nestedIfBlock(NonTerminalNode node) {\n+        NonTerminalNode parent = node.parent();\n+        ArrayList<NonTerminalNode> nestedParent = new ArrayList<>();\n+        if (parent == null) {\n+            return new ArrayList<>(0);\n+        } else {\n+            while (parent != null) {\n+                if (parent.kind() == (node.kind())) {\n+                    nestedParent.add(parent);\n+                }\n+                parent = parent.parent();\n+            }\n+        }\n+        return nestedParent.isEmpty() ? null : nestedParent;\n+    }\n+\n+    /**\n+     * return the indented start column.\n+     *\n+     * @param node       node\n+     * @param addSpaces  add spaces or not\n+     * @return start position\n+     */\n+    static int getStartColumn(Node node, boolean addSpaces, FormattingOptions formattingOptions) {\n+        Node parent;\n+        if (node.kind() == (SyntaxKind.IF_ELSE_STATEMENT)) {\n+            Indentation indent = getIfElseParent((NonTerminalNode) node);\n+            parent = indent.getParent();\n+            addSpaces = indent.getAddSpaces();\n+        } else if (node.kind() == (SyntaxKind.BLOCK_STATEMENT)) {\n+            Indentation indent = getBlockParent(node);\n+            parent = indent.getParent();\n+            addSpaces = indent.getAddSpaces();\n+        } else {\n+            parent = getParent(node, node.kind());\n+        }\n+        if (parent != null) {\n+            int indentation = 0;\n+            if (addSpaces) {\n+                indentation = (FormatterUtils.getIndentation(node, 0, formattingOptions));\n+            }\n+            return getPosition(parent).sCol + indentation;\n+        }\n+        return 0;\n+    }\n+\n+    private static Indentation getIfElseParent(NonTerminalNode node) {\n+        NonTerminalNode parent = node.parent();\n+        if (parent == null) {\n+            parent = node;\n+        }\n+        if (parent.kind() == (SyntaxKind.FUNCTION_DEFINITION)) {\n+            return new Indentation(parent, true);\n+        } else if (parent.parent() != null) {\n+            return getIfElseParent(parent);\n+        }\n+        return new Indentation(null, false);\n+    }\n+\n+    private static Indentation getBlockParent(Node node) {\n+        Node parent = node.parent();\n+        if (parent == null) {\n+            parent = node;\n+        }\n+        ArrayList<SyntaxKind> parentWithSpaces = new ArrayList<>(\n+                Arrays.asList(\n+                        SyntaxKind.WHILE_STATEMENT,\n+                        SyntaxKind.FUNCTION_DEFINITION));\n+        ArrayList<SyntaxKind> parentWithoutSpaces = new ArrayList<>(\n+                Arrays.asList(\n+                        SyntaxKind.NAMED_WORKER_DECLARATION,\n+                        SyntaxKind.LOCAL_VAR_DECL,\n+                        SyntaxKind.FOREACH_STATEMENT));\n+\n+        if (parentWithSpaces.contains(parent.kind())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzIwMDk4MA=="}, "originalCommit": {"oid": "abf30d5163ce0ebdc71f6463696d834f80cc2f05"}, "originalPosition": 380}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NzU2MTI0OnYy", "diffSide": "RIGHT", "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NodeIndentation.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNzo1NzoxN1rOHQoceQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQwMToyMTozMFrOHRBJcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzIwMTkxMw==", "bodyText": "Any reason to omit the type parameter of the List?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25680#discussion_r487201913", "createdAt": "2020-09-11T17:57:17Z", "author": {"login": "nadeeshaan"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NodeIndentation.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.core;\n+\n+import io.ballerinalang.compiler.syntax.tree.Node;\n+import io.ballerinalang.compiler.syntax.tree.NonTerminalNode;\n+import io.ballerinalang.compiler.syntax.tree.ObjectFieldNode;\n+import io.ballerinalang.compiler.syntax.tree.SyntaxKind;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static org.ballerinalang.formatter.core.FormatterUtils.getStartColumn;\n+\n+/**\n+ * Class that computes the formatting indentation for a particular node.\n+ */\n+class NodeIndentation {\n+\n+    private NodeIndentation() {\n+\n+    }\n+\n+    static int builtinSimpleNameReferenceNode(Node node, FormattingOptions options) {\n+        NonTerminalNode parent = node.parent();\n+        NonTerminalNode grandParent = null;\n+        if (parent != null) {\n+            grandParent = parent.parent();\n+        }\n+        boolean addSpaces = true;\n+        List parentNodes = Arrays.asList(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abf30d5163ce0ebdc71f6463696d834f80cc2f05"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzYwNjY0Mg==", "bodyText": "Not really, added the parameter.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25680#discussion_r487606642", "createdAt": "2020-09-14T01:21:30Z", "author": {"login": "IrushiL"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NodeIndentation.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.core;\n+\n+import io.ballerinalang.compiler.syntax.tree.Node;\n+import io.ballerinalang.compiler.syntax.tree.NonTerminalNode;\n+import io.ballerinalang.compiler.syntax.tree.ObjectFieldNode;\n+import io.ballerinalang.compiler.syntax.tree.SyntaxKind;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static org.ballerinalang.formatter.core.FormatterUtils.getStartColumn;\n+\n+/**\n+ * Class that computes the formatting indentation for a particular node.\n+ */\n+class NodeIndentation {\n+\n+    private NodeIndentation() {\n+\n+    }\n+\n+    static int builtinSimpleNameReferenceNode(Node node, FormattingOptions options) {\n+        NonTerminalNode parent = node.parent();\n+        NonTerminalNode grandParent = null;\n+        if (parent != null) {\n+            grandParent = parent.parent();\n+        }\n+        boolean addSpaces = true;\n+        List parentNodes = Arrays.asList(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzIwMTkxMw=="}, "originalCommit": {"oid": "abf30d5163ce0ebdc71f6463696d834f80cc2f05"}, "originalPosition": 45}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 55, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}