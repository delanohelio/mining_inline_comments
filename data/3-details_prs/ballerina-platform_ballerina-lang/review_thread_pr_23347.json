{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE5ODkwMTU3", "number": 23347, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwNTo1NTowOFrOD9pXzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwMzozMToyMVrOD-C9hg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1OTY3NTY3OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwNTo1NTowOFrOGXQ1kg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxMjo1NTo0NFrOGXfEFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA0NjI5MA==", "bodyText": "Better to pass the nodeKind as a parameter, coz you may be reaching here after recovering (inserting a token). Then the next tokenKind may not be same as peek().kind.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23347#discussion_r427046290", "createdAt": "2020-05-19T05:55:08Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -9343,4 +9350,55 @@ private STNode parseIntersectionTypeDescriptor(STNode leftTypeDesc, ParserRuleCo\n         STNode rightTypeDesc = parseTypeDescriptor(context);\n         return STNodeFactory.createIntersectionTypeDescriptorNode(leftTypeDesc, bitwiseAndToken, rightTypeDesc);\n     }\n+\n+    /**\n+     * Parse singleton type descriptor.\n+     * <p>singleton-type-descriptor := simple-const-expr\n+     * simple-const-expr :=\n+     *   nil-literal\n+     *   | boolean-literal\n+     *   | [Sign] int-literal\n+     *   | [Sign] floating-point-literal\n+     *   | string-literal\n+     *   | constant-reference-expr</p>\n+     */\n+    private STNode parseSingletonTypeDesc() {\n+        STNode simpleContExpr =  parseConstExpr();\n+        return STNodeFactory.createSingletonTypeDescriptorNode(simpleContExpr);\n+    }\n+\n+    private STNode parseSignedIntOrFloat() {\n+        STNode operator = parseUnaryOperator();\n+        STNode literal;\n+        STToken nextToken = peek();\n+        switch (nextToken.kind) {\n+            case HEX_INTEGER_LITERAL:\n+            case DECIMAL_FLOATING_POINT_LITERAL:\n+            case HEX_FLOATING_POINT_LITERAL:\n+                literal = consume();\n+                break;\n+            default:   //decimal integer literal\n+                literal = parseDecimalIntLiteral(ParserRuleContext.DECIMAL_INTEGER_LITERAL);\n+        }\n+        return STNodeFactory.createUnaryExpressionNode(operator, literal);\n+    }\n+\n+    private boolean isSingletonTypeDescStartToken() {\n+        STToken nextToken = peek();\n+        switch (nextToken.kind) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1ec563e664c720b63a3b7901ec948f7071fbe2b2"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzI3OTM4MQ==", "bodyText": "done", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23347#discussion_r427279381", "createdAt": "2020-05-19T12:55:44Z", "author": {"login": "rdulmina"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -9343,4 +9350,55 @@ private STNode parseIntersectionTypeDescriptor(STNode leftTypeDesc, ParserRuleCo\n         STNode rightTypeDesc = parseTypeDescriptor(context);\n         return STNodeFactory.createIntersectionTypeDescriptorNode(leftTypeDesc, bitwiseAndToken, rightTypeDesc);\n     }\n+\n+    /**\n+     * Parse singleton type descriptor.\n+     * <p>singleton-type-descriptor := simple-const-expr\n+     * simple-const-expr :=\n+     *   nil-literal\n+     *   | boolean-literal\n+     *   | [Sign] int-literal\n+     *   | [Sign] floating-point-literal\n+     *   | string-literal\n+     *   | constant-reference-expr</p>\n+     */\n+    private STNode parseSingletonTypeDesc() {\n+        STNode simpleContExpr =  parseConstExpr();\n+        return STNodeFactory.createSingletonTypeDescriptorNode(simpleContExpr);\n+    }\n+\n+    private STNode parseSignedIntOrFloat() {\n+        STNode operator = parseUnaryOperator();\n+        STNode literal;\n+        STToken nextToken = peek();\n+        switch (nextToken.kind) {\n+            case HEX_INTEGER_LITERAL:\n+            case DECIMAL_FLOATING_POINT_LITERAL:\n+            case HEX_FLOATING_POINT_LITERAL:\n+                literal = consume();\n+                break;\n+            default:   //decimal integer literal\n+                literal = parseDecimalIntLiteral(ParserRuleContext.DECIMAL_INTEGER_LITERAL);\n+        }\n+        return STNodeFactory.createUnaryExpressionNode(operator, literal);\n+    }\n+\n+    private boolean isSingletonTypeDescStartToken() {\n+        STToken nextToken = peek();\n+        switch (nextToken.kind) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA0NjI5MA=="}, "originalCommit": {"oid": "1ec563e664c720b63a3b7901ec948f7071fbe2b2"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1OTY4MTEyOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwNTo1Nzo1MFrOGXQ5BQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxMzo0MTo0OFrOGXhBAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA0NzE3Mw==", "bodyText": "We come here trying to get the next expected token/context after close-parenthesis of a nil-literal. In that case the next token is an rhs of an expression. So this has to be ParserRuleContext.EXPRESSION_RHS", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23347#discussion_r427047173", "createdAt": "2020-05-19T05:57:50Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -2169,7 +2184,7 @@ private ParserRuleContext getNextRuleForCloseParenthsis() {\n             return ParserRuleContext.TYPEDESC_RHS;\n         } else if (parentCtx == ParserRuleContext.NIL_LITERAL) {\n             endContext();\n-            return ParserRuleContext.EXPRESSION_RHS;\n+            return getNextRuleForExpr();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1ec563e664c720b63a3b7901ec948f7071fbe2b2"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzI3OTgzNw==", "bodyText": "@SupunS it returns EXPRESSION_RHS inside getNextRuleForExpr() method", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23347#discussion_r427279837", "createdAt": "2020-05-19T12:56:26Z", "author": {"login": "rdulmina"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -2169,7 +2184,7 @@ private ParserRuleContext getNextRuleForCloseParenthsis() {\n             return ParserRuleContext.TYPEDESC_RHS;\n         } else if (parentCtx == ParserRuleContext.NIL_LITERAL) {\n             endContext();\n-            return ParserRuleContext.EXPRESSION_RHS;\n+            return getNextRuleForExpr();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA0NzE3Mw=="}, "originalCommit": {"oid": "1ec563e664c720b63a3b7901ec948f7071fbe2b2"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzMxMTM2MQ==", "bodyText": "ack", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23347#discussion_r427311361", "createdAt": "2020-05-19T13:41:48Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -2169,7 +2184,7 @@ private ParserRuleContext getNextRuleForCloseParenthsis() {\n             return ParserRuleContext.TYPEDESC_RHS;\n         } else if (parentCtx == ParserRuleContext.NIL_LITERAL) {\n             endContext();\n-            return ParserRuleContext.EXPRESSION_RHS;\n+            return getNextRuleForExpr();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA0NzE3Mw=="}, "originalCommit": {"oid": "1ec563e664c720b63a3b7901ec948f7071fbe2b2"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1OTcwNTk5OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwNjowOTo0MVrOGXRIqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxMjo1NjozNVrOGXfGTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA1MTE3Nw==", "bodyText": "There are situations where, a statement can start with an expression.\ne.g: sync-send/async-send action-stmt (https://ballerina.io/ballerina-spec/spec.html#send-action)\nfunction foo() {\n   5 -> w1;    // send value 5 to worker w1\n}\n\nSo I think here you'll have to look some more tokens ahead, and determine whether this is actually a singleton type start or whether this is an expression.\nAlso need to note, this ambiguity is there only for var-decl-stmt. This issue is not there for other places where a type-desc is expected.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23347#discussion_r427051177", "createdAt": "2020-05-19T06:09:41Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -9343,4 +9350,55 @@ private STNode parseIntersectionTypeDescriptor(STNode leftTypeDesc, ParserRuleCo\n         STNode rightTypeDesc = parseTypeDescriptor(context);\n         return STNodeFactory.createIntersectionTypeDescriptorNode(leftTypeDesc, bitwiseAndToken, rightTypeDesc);\n     }\n+\n+    /**\n+     * Parse singleton type descriptor.\n+     * <p>singleton-type-descriptor := simple-const-expr\n+     * simple-const-expr :=\n+     *   nil-literal\n+     *   | boolean-literal\n+     *   | [Sign] int-literal\n+     *   | [Sign] floating-point-literal\n+     *   | string-literal\n+     *   | constant-reference-expr</p>\n+     */\n+    private STNode parseSingletonTypeDesc() {\n+        STNode simpleContExpr =  parseConstExpr();\n+        return STNodeFactory.createSingletonTypeDescriptorNode(simpleContExpr);\n+    }\n+\n+    private STNode parseSignedIntOrFloat() {\n+        STNode operator = parseUnaryOperator();\n+        STNode literal;\n+        STToken nextToken = peek();\n+        switch (nextToken.kind) {\n+            case HEX_INTEGER_LITERAL:\n+            case DECIMAL_FLOATING_POINT_LITERAL:\n+            case HEX_FLOATING_POINT_LITERAL:\n+                literal = consume();\n+                break;\n+            default:   //decimal integer literal\n+                literal = parseDecimalIntLiteral(ParserRuleContext.DECIMAL_INTEGER_LITERAL);\n+        }\n+        return STNodeFactory.createUnaryExpressionNode(operator, literal);\n+    }\n+\n+    private boolean isSingletonTypeDescStartToken() {\n+        STToken nextToken = peek();\n+        switch (nextToken.kind) {\n+            case STRING_LITERAL:\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case DECIMAL_FLOATING_POINT_LITERAL:\n+            case HEX_FLOATING_POINT_LITERAL:\n+            case TRUE_KEYWORD:\n+            case FALSE_KEYWORD:\n+            case NULL_KEYWORD:\n+            case PLUS_TOKEN:\n+            case MINUS_TOKEN:\n+                return true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1ec563e664c720b63a3b7901ec948f7071fbe2b2"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzI3OTk1MA==", "bodyText": "Changed", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23347#discussion_r427279950", "createdAt": "2020-05-19T12:56:35Z", "author": {"login": "rdulmina"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -9343,4 +9350,55 @@ private STNode parseIntersectionTypeDescriptor(STNode leftTypeDesc, ParserRuleCo\n         STNode rightTypeDesc = parseTypeDescriptor(context);\n         return STNodeFactory.createIntersectionTypeDescriptorNode(leftTypeDesc, bitwiseAndToken, rightTypeDesc);\n     }\n+\n+    /**\n+     * Parse singleton type descriptor.\n+     * <p>singleton-type-descriptor := simple-const-expr\n+     * simple-const-expr :=\n+     *   nil-literal\n+     *   | boolean-literal\n+     *   | [Sign] int-literal\n+     *   | [Sign] floating-point-literal\n+     *   | string-literal\n+     *   | constant-reference-expr</p>\n+     */\n+    private STNode parseSingletonTypeDesc() {\n+        STNode simpleContExpr =  parseConstExpr();\n+        return STNodeFactory.createSingletonTypeDescriptorNode(simpleContExpr);\n+    }\n+\n+    private STNode parseSignedIntOrFloat() {\n+        STNode operator = parseUnaryOperator();\n+        STNode literal;\n+        STToken nextToken = peek();\n+        switch (nextToken.kind) {\n+            case HEX_INTEGER_LITERAL:\n+            case DECIMAL_FLOATING_POINT_LITERAL:\n+            case HEX_FLOATING_POINT_LITERAL:\n+                literal = consume();\n+                break;\n+            default:   //decimal integer literal\n+                literal = parseDecimalIntLiteral(ParserRuleContext.DECIMAL_INTEGER_LITERAL);\n+        }\n+        return STNodeFactory.createUnaryExpressionNode(operator, literal);\n+    }\n+\n+    private boolean isSingletonTypeDescStartToken() {\n+        STToken nextToken = peek();\n+        switch (nextToken.kind) {\n+            case STRING_LITERAL:\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case DECIMAL_FLOATING_POINT_LITERAL:\n+            case HEX_FLOATING_POINT_LITERAL:\n+            case TRUE_KEYWORD:\n+            case FALSE_KEYWORD:\n+            case NULL_KEYWORD:\n+            case PLUS_TOKEN:\n+            case MINUS_TOKEN:\n+                return true;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA1MTE3Nw=="}, "originalCommit": {"oid": "1ec563e664c720b63a3b7901ec948f7071fbe2b2"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MTI5NTk1OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxMzozNDoxNlrOGXgrhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxMzozNDoxNlrOGXgrhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzMwNTg2Mw==", "bodyText": "This can be a problem if two consecutive tokens are equal.\nI feel you'll have to pass the peek-index as an argument here. I've done a similar thing in isValidExpressionStart() in: #23365", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23347#discussion_r427305863", "createdAt": "2020-05-19T13:34:16Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -9343,4 +9360,85 @@ private STNode parseIntersectionTypeDescriptor(STNode leftTypeDesc, ParserRuleCo\n         STNode rightTypeDesc = parseTypeDescriptor(context);\n         return STNodeFactory.createIntersectionTypeDescriptorNode(leftTypeDesc, bitwiseAndToken, rightTypeDesc);\n     }\n+\n+    /**\n+     * Parse singleton type descriptor.\n+     * <p>singleton-type-descriptor := simple-const-expr\n+     * simple-const-expr :=\n+     *   nil-literal\n+     *   | boolean-literal\n+     *   | [Sign] int-literal\n+     *   | [Sign] floating-point-literal\n+     *   | string-literal\n+     *   | constant-reference-expr</p>\n+     */\n+    private STNode parseSingletonTypeDesc() {\n+        STNode simpleContExpr =  parseConstExpr();\n+        return STNodeFactory.createSingletonTypeDescriptorNode(simpleContExpr);\n+    }\n+\n+    private STNode parseSignedIntOrFloat() {\n+        STNode operator = parseUnaryOperator();\n+        STNode literal;\n+        STToken nextToken = peek();\n+        switch (nextToken.kind) {\n+            case HEX_INTEGER_LITERAL:\n+            case DECIMAL_FLOATING_POINT_LITERAL:\n+            case HEX_FLOATING_POINT_LITERAL:\n+                literal = consume();\n+                break;\n+            default:   //decimal integer literal\n+                literal = parseDecimalIntLiteral(ParserRuleContext.DECIMAL_INTEGER_LITERAL);\n+        }\n+        return STNodeFactory.createUnaryExpressionNode(operator, literal);\n+    }\n+\n+    private boolean isSingletonTypeDescStart(SyntaxKind tokenKind, boolean inTypeDescCtx) {\n+        STToken nextToken = peek();\n+        STToken nextNextToken, nextNextNextToken;\n+        if (tokenKind != nextToken.kind) { //this will be true if and only if we come here after recovering", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "645121b4682eaf553907797e3f9729bb9b1fc8ca"}, "originalPosition": 101}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MTMxNTc1OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxMzozODo0MlrOGXg4Hw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxMzozODo0MlrOGXg4Hw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzMwOTA4Nw==", "bodyText": "Might need to check whether a basic-literal is followed by | or &. Because with type binding patterns, var name would not always be an identifier.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23347#discussion_r427309087", "createdAt": "2020-05-19T13:38:42Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -9343,4 +9360,85 @@ private STNode parseIntersectionTypeDescriptor(STNode leftTypeDesc, ParserRuleCo\n         STNode rightTypeDesc = parseTypeDescriptor(context);\n         return STNodeFactory.createIntersectionTypeDescriptorNode(leftTypeDesc, bitwiseAndToken, rightTypeDesc);\n     }\n+\n+    /**\n+     * Parse singleton type descriptor.\n+     * <p>singleton-type-descriptor := simple-const-expr\n+     * simple-const-expr :=\n+     *   nil-literal\n+     *   | boolean-literal\n+     *   | [Sign] int-literal\n+     *   | [Sign] floating-point-literal\n+     *   | string-literal\n+     *   | constant-reference-expr</p>\n+     */\n+    private STNode parseSingletonTypeDesc() {\n+        STNode simpleContExpr =  parseConstExpr();\n+        return STNodeFactory.createSingletonTypeDescriptorNode(simpleContExpr);\n+    }\n+\n+    private STNode parseSignedIntOrFloat() {\n+        STNode operator = parseUnaryOperator();\n+        STNode literal;\n+        STToken nextToken = peek();\n+        switch (nextToken.kind) {\n+            case HEX_INTEGER_LITERAL:\n+            case DECIMAL_FLOATING_POINT_LITERAL:\n+            case HEX_FLOATING_POINT_LITERAL:\n+                literal = consume();\n+                break;\n+            default:   //decimal integer literal\n+                literal = parseDecimalIntLiteral(ParserRuleContext.DECIMAL_INTEGER_LITERAL);\n+        }\n+        return STNodeFactory.createUnaryExpressionNode(operator, literal);\n+    }\n+\n+    private boolean isSingletonTypeDescStart(SyntaxKind tokenKind, boolean inTypeDescCtx) {\n+        STToken nextToken = peek();\n+        STToken nextNextToken, nextNextNextToken;\n+        if (tokenKind != nextToken.kind) { //this will be true if and only if we come here after recovering\n+            nextNextToken = nextToken;\n+            nextNextNextToken = peek(2);\n+        } else {\n+            nextNextToken = peek(2);\n+            nextNextNextToken = peek(3);\n+        }\n+        switch (tokenKind) {\n+            case STRING_LITERAL:\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case DECIMAL_FLOATING_POINT_LITERAL:\n+            case HEX_FLOATING_POINT_LITERAL:\n+            case TRUE_KEYWORD:\n+            case FALSE_KEYWORD:\n+            case NULL_KEYWORD:\n+                if (inTypeDescCtx || nextNextToken.kind == SyntaxKind.IDENTIFIER_TOKEN) {\n+                    return true;\n+                }\n+                return false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "645121b4682eaf553907797e3f9729bb9b1fc8ca"}, "originalPosition": 120}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2Mzg2ODEyOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-treegen/src/main/resources/syntax_tree_descriptor.json", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwMzozMToxMlrOGX6D3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwODowNjo0NlrOGX_8UA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcyMTY5Mw==", "bodyText": "base is TypeDescriptorNode", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23347#discussion_r427721693", "createdAt": "2020-05-20T03:31:12Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-treegen/src/main/resources/syntax_tree_descriptor.json", "diffHunk": "@@ -2813,6 +2813,17 @@\n                 }\n             ]\n         },\n+        {\n+            \"name\": \"SingletonTypeDescriptorNode\",\n+            \"base\": \"Node\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f781a7aaeeb4495deb220d6b17cc78803efb742"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzgxODA2NA==", "bodyText": "done", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23347#discussion_r427818064", "createdAt": "2020-05-20T08:06:46Z", "author": {"login": "rdulmina"}, "path": "compiler/ballerina-treegen/src/main/resources/syntax_tree_descriptor.json", "diffHunk": "@@ -2813,6 +2813,17 @@\n                 }\n             ]\n         },\n+        {\n+            \"name\": \"SingletonTypeDescriptorNode\",\n+            \"base\": \"Node\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcyMTY5Mw=="}, "originalCommit": {"oid": "4f781a7aaeeb4495deb220d6b17cc78803efb742"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2Mzg2ODIyOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-treegen/src/main/resources/syntax_tree_descriptor.json", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwMzozMToyMVrOGX6D-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwODowNjo1MVrOGX_8fQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcyMTcyMg==", "bodyText": "base is ExpressionNode", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23347#discussion_r427721722", "createdAt": "2020-05-20T03:31:21Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-treegen/src/main/resources/syntax_tree_descriptor.json", "diffHunk": "@@ -2813,6 +2813,17 @@\n                 }\n             ]\n         },\n+        {\n+            \"name\": \"SingletonTypeDescriptorNode\",\n+            \"base\": \"Node\",\n+            \"kind\": \"SINGLETON_TYPE_DESC\",\n+            \"attributes\": [\n+                {\n+                    \"name\": \"simpleContExprNode\",\n+                    \"type\": \"Node\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f781a7aaeeb4495deb220d6b17cc78803efb742"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzgxODEwOQ==", "bodyText": "done", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23347#discussion_r427818109", "createdAt": "2020-05-20T08:06:51Z", "author": {"login": "rdulmina"}, "path": "compiler/ballerina-treegen/src/main/resources/syntax_tree_descriptor.json", "diffHunk": "@@ -2813,6 +2813,17 @@\n                 }\n             ]\n         },\n+        {\n+            \"name\": \"SingletonTypeDescriptorNode\",\n+            \"base\": \"Node\",\n+            \"kind\": \"SINGLETON_TYPE_DESC\",\n+            \"attributes\": [\n+                {\n+                    \"name\": \"simpleContExprNode\",\n+                    \"type\": \"Node\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcyMTcyMg=="}, "originalCommit": {"oid": "4f781a7aaeeb4495deb220d6b17cc78803efb742"}, "originalPosition": 11}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3667, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}