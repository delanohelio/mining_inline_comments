{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkyOTk1NDk2", "number": 26106, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwNDowOTowMlrOEn6pxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwNDoxMDo1NlrOEn6q7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwMjkwODg0OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-treegen/src/main/resources/syntax_tree_descriptor.json", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwNDowOTowMlrOHYt3eQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwNTozMzo1NlrOHYu-3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY3OTM1Mw==", "bodyText": "Can the \"type\" be a NameReference node?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26106#discussion_r495679353", "createdAt": "2020-09-28T04:09:02Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-treegen/src/main/resources/syntax_tree_descriptor.json", "diffHunk": "@@ -3977,13 +3977,18 @@\n             ]\n         },\n         {\n-            \"name\": \"FunctionalMatchPatternNode\",\n+            \"name\": \"ErrorMatchPatternNode\",\n             \"base\": \"Node\",\n-            \"kind\": \"FUNCTIONAL_MATCH_PATTERN\",\n+            \"kind\": \"ERROR_MATCH_PATTERN\",\n             \"attributes\": [\n                 {\n-                    \"name\": \"typeRef\",\n-                    \"type\": \"Node\"\n+                    \"name\": \"errorKeyword\",\n+                    \"type\": \"Token\"\n+                },\n+                {\n+                    \"name\": \"typeReference\",\n+                    \"type\": \"Node\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5715172d1a0f0325bef0e47a7ac55d23144fd89b"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY5NzYzMA==", "bodyText": "changed", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26106#discussion_r495697630", "createdAt": "2020-09-28T05:33:56Z", "author": {"login": "rdulmina"}, "path": "compiler/ballerina-treegen/src/main/resources/syntax_tree_descriptor.json", "diffHunk": "@@ -3977,13 +3977,18 @@\n             ]\n         },\n         {\n-            \"name\": \"FunctionalMatchPatternNode\",\n+            \"name\": \"ErrorMatchPatternNode\",\n             \"base\": \"Node\",\n-            \"kind\": \"FUNCTIONAL_MATCH_PATTERN\",\n+            \"kind\": \"ERROR_MATCH_PATTERN\",\n             \"attributes\": [\n                 {\n-                    \"name\": \"typeRef\",\n-                    \"type\": \"Node\"\n+                    \"name\": \"errorKeyword\",\n+                    \"type\": \"Token\"\n+                },\n+                {\n+                    \"name\": \"typeReference\",\n+                    \"type\": \"Node\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY3OTM1Mw=="}, "originalCommit": {"oid": "5715172d1a0f0325bef0e47a7ac55d23144fd89b"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwMjkxMTgwOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwNDoxMDo1NlrOHYt5KA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwNTozNDowMlrOHYu-8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY3OTc4NA==", "bodyText": "It would be good to add the spec-snippet here as well, as a doc comment.\nThat would make it easier to quickly refer the grammar for someone who checks the code..", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26106#discussion_r495679784", "createdAt": "2020-09-28T04:10:56Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -12216,84 +12213,174 @@ private boolean isMatchPatternEnd(SyntaxKind tokenKind) {\n     /**\n      * Parse functional match pattern.\n      * <p>\n-     * functional-match-pattern := functionally-constructible-type-reference ( arg-list-match-pattern )\n-     * <br/>\n-     * functionally-constructible-type-reference := error | type-reference\n-     * <br/>\n-     * type-reference := identifier | qualified-identifier\n-     * <br/>\n-     * arg-list-match-pattern := positional-arg-match-patterns [, other-arg-match-patterns]\n-     * | other-arg-match-patterns\n+     * error-match-pattern := error [error-type-reference] ( error-arg-list-match-pattern )\n+     * error-arg-list-match-pattern :=\n+     * error-message-match-pattern [, error-cause-match-pattern] [, error-field-match-patterns]\n+     * | [error-field-match-patterns]\n+     * error-message-match-pattern := simple-match-pattern\n+     * error-cause-match-pattern := simple-match-pattern | error-match-pattern\n+     * simple-match-pattern :=\n+     * wildcard-match-pattern\n+     * | const-pattern\n+     * | var variable-name\n+     * error-field-match-patterns :=\n+     * named-arg-match-pattern (, named-arg-match-pattern)* [, rest-match-pattern]\n+     * | rest-match-pattern\n+     * named-arg-match-pattern := arg-name = match-pattern\n      * </p>\n      *\n      * @return Parsed functional match pattern node.\n      */\n-    private STNode parseFunctionalMatchPattern(STNode typeRef) {\n-        startContext(ParserRuleContext.FUNCTIONAL_MATCH_PATTERN);\n+    private STNode parseErrorMatchPattern() {\n+        startContext(ParserRuleContext.ERROR_MATCH_PATTERN);\n+        STNode errorKeyword = consume();\n+        return parseErrorMatchPattern(errorKeyword);\n+    }\n+\n+    private STNode parseErrorMatchPattern(STNode errorKeyword) {\n+        STToken nextToken = peek();\n+        STNode typeRef;\n+        switch (nextToken.kind) {\n+            case IDENTIFIER_TOKEN:\n+                typeRef = parseTypeReference();\n+                break;\n+            case OPEN_PAREN_TOKEN:\n+                typeRef = STNodeFactory.createEmptyNode();\n+                break;\n+            default:\n+                recover(peek(), ParserRuleContext.ERROR_MATCH_PATTERN_ERROR_KEYWORD_RHS);\n+                return parseErrorMatchPattern(errorKeyword);\n+        }\n+        return parseErrorMatchPattern(errorKeyword, typeRef);\n+    }\n+\n+    private STNode parseErrorMatchPattern(STNode errorKeyword, STNode typeRef) {\n         STNode openParenthesisToken = parseOpenParenthesis(ParserRuleContext.OPEN_PARENTHESIS);\n-        STNode argListMatchPatternNode = parseArgListMatchPatterns();\n+        STNode argListMatchPatternNode = parseErrorArgListMatchPatterns();\n         STNode closeParenthesisToken = parseCloseParenthesis();\n         endContext();\n-        return STNodeFactory.createFunctionalMatchPatternNode(typeRef, openParenthesisToken, argListMatchPatternNode,\n-                closeParenthesisToken);\n+        return STNodeFactory.createErrorMatchPatternNode(errorKeyword, typeRef, openParenthesisToken,\n+                argListMatchPatternNode, closeParenthesisToken);\n     }\n \n-    private STNode parseArgListMatchPatterns() {\n+    private STNode parseErrorArgListMatchPatterns() {\n         List<STNode> argListMatchPatterns = new ArrayList<>();\n-        SyntaxKind lastValidArgKind = SyntaxKind.IDENTIFIER_TOKEN;\n \n-        while (!isEndOfFunctionalMatchPattern()) {\n-            STNode currentArg = parseArgMatchPattern();\n-            DiagnosticErrorCode errorCode = validateArgMatchPatternOrder(lastValidArgKind, currentArg.kind);\n-            if (errorCode == null) {\n-                argListMatchPatterns.add(currentArg);\n-                lastValidArgKind = currentArg.kind;\n+        if (isEndOfErrorFieldMatchPatterns()) {\n+            return STNodeFactory.createNodeList(argListMatchPatterns);\n+        }\n+        startContext(ParserRuleContext.ERROR_ARG_LIST_MATCH_PATTERN_FIRST_ARG);\n+        STNode firstArg = parseErrorArgListMatchPattern(ParserRuleContext.ERROR_ARG_LIST_MATCH_PATTERN_START);\n+        endContext();\n+        if (isSimpleMatchPattern(firstArg.kind)) {\n+\n+            argListMatchPatterns.add(firstArg);\n+            STNode argEnd = parseErrorArgListMatchPatternEnd(ParserRuleContext.ERROR_MESSAGE_MATCH_PATTERN_END);\n+            if (argEnd != null) {\n+                // null marks the end of args\n+                STNode secondArg = parseErrorArgListMatchPattern(ParserRuleContext.ERROR_MESSAGE_MATCH_PATTERN_RHS);\n+                if (isValidSecondArgMatchPattern(secondArg.kind)) {\n+                    argListMatchPatterns.add(argEnd);\n+                    argListMatchPatterns.add(secondArg);\n+                } else {\n+                    updateLastNodeInListWithInvalidNode(argListMatchPatterns, argEnd, null);\n+                    updateLastNodeInListWithInvalidNode(argListMatchPatterns, secondArg,\n+                            DiagnosticErrorCode.ERROR_MATCH_PATTERN_NOT_ALLOWED);\n+                }\n+            }\n+        } else {\n+            if (firstArg.kind != SyntaxKind.NAMED_ARG_MATCH_PATTERN &&\n+                    firstArg.kind != SyntaxKind.REST_MATCH_PATTERN) {\n+                addInvalidNodeToNextToken(firstArg, DiagnosticErrorCode.ERROR_MATCH_PATTERN_NOT_ALLOWED);\n             } else {\n-                updateLastNodeInListWithInvalidNode(argListMatchPatterns, currentArg, errorCode);\n+                argListMatchPatterns.add(firstArg);\n             }\n+        }\n \n-            STNode argRhs = parseArgMatchPatternRhs();\n+        parseErrorFieldMatchPatterns(argListMatchPatterns);\n+        return STNodeFactory.createNodeList(argListMatchPatterns);\n+    }\n+\n+    private boolean isSimpleMatchPattern(SyntaxKind matchPatternKind) {\n+        switch (matchPatternKind) {\n+            case IDENTIFIER_TOKEN:\n+            case SIMPLE_NAME_REFERENCE:\n+            case NUMERIC_LITERAL:\n+            case STRING_LITERAL:\n+            case NULL_LITERAL:\n+            case NIL_LITERAL:\n+            case BOOLEAN_LITERAL:\n+            case TYPED_BINDING_PATTERN:\n+            case UNARY_EXPRESSION:\n+                return true;\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean isValidSecondArgMatchPattern(SyntaxKind syntaxKind) {\n+        switch (syntaxKind) {\n+            case ERROR_MATCH_PATTERN:\n+            case NAMED_ARG_MATCH_PATTERN:\n+            case REST_MATCH_PATTERN:\n+                return true;\n+            default:\n+                if (isSimpleMatchPattern(syntaxKind)) {\n+                    return true;\n+                }\n+                return false;\n+        }\n+    }\n \n-            if (argRhs == null) {\n+    private void parseErrorFieldMatchPatterns(List<STNode> argListMatchPatterns) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5715172d1a0f0325bef0e47a7ac55d23144fd89b"}, "originalPosition": 208}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY5NzY1MA==", "bodyText": "added", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26106#discussion_r495697650", "createdAt": "2020-09-28T05:34:02Z", "author": {"login": "rdulmina"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -12216,84 +12213,174 @@ private boolean isMatchPatternEnd(SyntaxKind tokenKind) {\n     /**\n      * Parse functional match pattern.\n      * <p>\n-     * functional-match-pattern := functionally-constructible-type-reference ( arg-list-match-pattern )\n-     * <br/>\n-     * functionally-constructible-type-reference := error | type-reference\n-     * <br/>\n-     * type-reference := identifier | qualified-identifier\n-     * <br/>\n-     * arg-list-match-pattern := positional-arg-match-patterns [, other-arg-match-patterns]\n-     * | other-arg-match-patterns\n+     * error-match-pattern := error [error-type-reference] ( error-arg-list-match-pattern )\n+     * error-arg-list-match-pattern :=\n+     * error-message-match-pattern [, error-cause-match-pattern] [, error-field-match-patterns]\n+     * | [error-field-match-patterns]\n+     * error-message-match-pattern := simple-match-pattern\n+     * error-cause-match-pattern := simple-match-pattern | error-match-pattern\n+     * simple-match-pattern :=\n+     * wildcard-match-pattern\n+     * | const-pattern\n+     * | var variable-name\n+     * error-field-match-patterns :=\n+     * named-arg-match-pattern (, named-arg-match-pattern)* [, rest-match-pattern]\n+     * | rest-match-pattern\n+     * named-arg-match-pattern := arg-name = match-pattern\n      * </p>\n      *\n      * @return Parsed functional match pattern node.\n      */\n-    private STNode parseFunctionalMatchPattern(STNode typeRef) {\n-        startContext(ParserRuleContext.FUNCTIONAL_MATCH_PATTERN);\n+    private STNode parseErrorMatchPattern() {\n+        startContext(ParserRuleContext.ERROR_MATCH_PATTERN);\n+        STNode errorKeyword = consume();\n+        return parseErrorMatchPattern(errorKeyword);\n+    }\n+\n+    private STNode parseErrorMatchPattern(STNode errorKeyword) {\n+        STToken nextToken = peek();\n+        STNode typeRef;\n+        switch (nextToken.kind) {\n+            case IDENTIFIER_TOKEN:\n+                typeRef = parseTypeReference();\n+                break;\n+            case OPEN_PAREN_TOKEN:\n+                typeRef = STNodeFactory.createEmptyNode();\n+                break;\n+            default:\n+                recover(peek(), ParserRuleContext.ERROR_MATCH_PATTERN_ERROR_KEYWORD_RHS);\n+                return parseErrorMatchPattern(errorKeyword);\n+        }\n+        return parseErrorMatchPattern(errorKeyword, typeRef);\n+    }\n+\n+    private STNode parseErrorMatchPattern(STNode errorKeyword, STNode typeRef) {\n         STNode openParenthesisToken = parseOpenParenthesis(ParserRuleContext.OPEN_PARENTHESIS);\n-        STNode argListMatchPatternNode = parseArgListMatchPatterns();\n+        STNode argListMatchPatternNode = parseErrorArgListMatchPatterns();\n         STNode closeParenthesisToken = parseCloseParenthesis();\n         endContext();\n-        return STNodeFactory.createFunctionalMatchPatternNode(typeRef, openParenthesisToken, argListMatchPatternNode,\n-                closeParenthesisToken);\n+        return STNodeFactory.createErrorMatchPatternNode(errorKeyword, typeRef, openParenthesisToken,\n+                argListMatchPatternNode, closeParenthesisToken);\n     }\n \n-    private STNode parseArgListMatchPatterns() {\n+    private STNode parseErrorArgListMatchPatterns() {\n         List<STNode> argListMatchPatterns = new ArrayList<>();\n-        SyntaxKind lastValidArgKind = SyntaxKind.IDENTIFIER_TOKEN;\n \n-        while (!isEndOfFunctionalMatchPattern()) {\n-            STNode currentArg = parseArgMatchPattern();\n-            DiagnosticErrorCode errorCode = validateArgMatchPatternOrder(lastValidArgKind, currentArg.kind);\n-            if (errorCode == null) {\n-                argListMatchPatterns.add(currentArg);\n-                lastValidArgKind = currentArg.kind;\n+        if (isEndOfErrorFieldMatchPatterns()) {\n+            return STNodeFactory.createNodeList(argListMatchPatterns);\n+        }\n+        startContext(ParserRuleContext.ERROR_ARG_LIST_MATCH_PATTERN_FIRST_ARG);\n+        STNode firstArg = parseErrorArgListMatchPattern(ParserRuleContext.ERROR_ARG_LIST_MATCH_PATTERN_START);\n+        endContext();\n+        if (isSimpleMatchPattern(firstArg.kind)) {\n+\n+            argListMatchPatterns.add(firstArg);\n+            STNode argEnd = parseErrorArgListMatchPatternEnd(ParserRuleContext.ERROR_MESSAGE_MATCH_PATTERN_END);\n+            if (argEnd != null) {\n+                // null marks the end of args\n+                STNode secondArg = parseErrorArgListMatchPattern(ParserRuleContext.ERROR_MESSAGE_MATCH_PATTERN_RHS);\n+                if (isValidSecondArgMatchPattern(secondArg.kind)) {\n+                    argListMatchPatterns.add(argEnd);\n+                    argListMatchPatterns.add(secondArg);\n+                } else {\n+                    updateLastNodeInListWithInvalidNode(argListMatchPatterns, argEnd, null);\n+                    updateLastNodeInListWithInvalidNode(argListMatchPatterns, secondArg,\n+                            DiagnosticErrorCode.ERROR_MATCH_PATTERN_NOT_ALLOWED);\n+                }\n+            }\n+        } else {\n+            if (firstArg.kind != SyntaxKind.NAMED_ARG_MATCH_PATTERN &&\n+                    firstArg.kind != SyntaxKind.REST_MATCH_PATTERN) {\n+                addInvalidNodeToNextToken(firstArg, DiagnosticErrorCode.ERROR_MATCH_PATTERN_NOT_ALLOWED);\n             } else {\n-                updateLastNodeInListWithInvalidNode(argListMatchPatterns, currentArg, errorCode);\n+                argListMatchPatterns.add(firstArg);\n             }\n+        }\n \n-            STNode argRhs = parseArgMatchPatternRhs();\n+        parseErrorFieldMatchPatterns(argListMatchPatterns);\n+        return STNodeFactory.createNodeList(argListMatchPatterns);\n+    }\n+\n+    private boolean isSimpleMatchPattern(SyntaxKind matchPatternKind) {\n+        switch (matchPatternKind) {\n+            case IDENTIFIER_TOKEN:\n+            case SIMPLE_NAME_REFERENCE:\n+            case NUMERIC_LITERAL:\n+            case STRING_LITERAL:\n+            case NULL_LITERAL:\n+            case NIL_LITERAL:\n+            case BOOLEAN_LITERAL:\n+            case TYPED_BINDING_PATTERN:\n+            case UNARY_EXPRESSION:\n+                return true;\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean isValidSecondArgMatchPattern(SyntaxKind syntaxKind) {\n+        switch (syntaxKind) {\n+            case ERROR_MATCH_PATTERN:\n+            case NAMED_ARG_MATCH_PATTERN:\n+            case REST_MATCH_PATTERN:\n+                return true;\n+            default:\n+                if (isSimpleMatchPattern(syntaxKind)) {\n+                    return true;\n+                }\n+                return false;\n+        }\n+    }\n \n-            if (argRhs == null) {\n+    private void parseErrorFieldMatchPatterns(List<STNode> argListMatchPatterns) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY3OTc4NA=="}, "originalCommit": {"oid": "5715172d1a0f0325bef0e47a7ac55d23144fd89b"}, "originalPosition": 208}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 47, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}