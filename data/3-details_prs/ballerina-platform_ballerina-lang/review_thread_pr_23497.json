{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIzMDI4NDM3", "number": 23497, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQwNzozMzo0MVrOD_jh9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxMTo0ODoxNFrOEADTnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3OTY5MDE0OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/test/resources/expressions/byte-array-literal/base64_literal_assert_05.json", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQwNzozMzo0MVrOGaSA-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQwNzozMzo0MVrOGaSA-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDIxMTMyMw==", "bodyText": "= is encoded like this when converting to JSON string. I think that's okay.\nOr\nsince PADDING_CHAR is always =, we can  use getSyntaxToken(SyntaxKind.PADDING_CHAR) instead of getLiteral(SyntaxKind.PADDING_CHAR) in the lexer thus the value property will not be here.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23497#discussion_r430211323", "createdAt": "2020-05-26T07:33:41Z", "author": {"login": "lochana-chathura"}, "path": "compiler/ballerina-parser/src/test/resources/expressions/byte-array-literal/base64_literal_assert_05.json", "diffHunk": "@@ -0,0 +1,82 @@\n+{\n+    \"kind\": \"BYTE_ARRAY_LITERAL\",\n+    \"children\": [\n+        {\n+            \"kind\": \"BASE64_KEYWORD\"\n+        },\n+        {\n+            \"kind\": \"BACKTICK_TOKEN\"\n+        },\n+        {\n+            \"kind\": \"LIST\",\n+            \"children\": [\n+                {\n+                    \"kind\": \"BASE64_GROUP\",\n+                    \"children\": [\n+                        {\n+                            \"kind\": \"BASE64_CHAR\",\n+                            \"value\": \"A\"\n+                        },\n+                        {\n+                            \"kind\": \"BASE64_CHAR\",\n+                            \"value\": \"w\"\n+                        },\n+                        {\n+                            \"kind\": \"BASE64_CHAR\",\n+                            \"value\": \"s\"\n+                        },\n+                        {\n+                            \"kind\": \"BASE64_CHAR\",\n+                            \"value\": \"z\"\n+                        }\n+                    ]\n+                },\n+                {\n+                    \"kind\": \"BASE64_GROUP\",\n+                    \"children\": [\n+                        {\n+                            \"kind\": \"BASE64_CHAR\",\n+                            \"value\": \"l\"\n+                        },\n+                        {\n+                            \"kind\": \"BASE64_CHAR\",\n+                            \"value\": \"q\"\n+                        },\n+                        {\n+                            \"kind\": \"BASE64_CHAR\",\n+                            \"value\": \"2\"\n+                        },\n+                        {\n+                            \"kind\": \"BASE64_CHAR\",\n+                            \"value\": \"r\"\n+                        }\n+                    ]\n+                },\n+                {\n+                    \"kind\": \"PADDED_BASE64_GROUP\",\n+                    \"children\": [\n+                        {\n+                            \"kind\": \"BASE64_CHAR\",\n+                            \"value\": \"t\"\n+                        },\n+                        {\n+                            \"kind\": \"BASE64_CHAR\",\n+                            \"value\": \"y\"\n+                        },\n+                        {\n+                            \"kind\": \"BASE64_CHAR\",\n+                            \"value\": \"s\"\n+                        },\n+                        {\n+                            \"kind\": \"PADDING_CHAR\",\n+                            \"value\": \"\\u003d\"\n+                        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "548ccc1bd4db4932ec405061c5e4cc151e01bd92"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NDUwNDcxOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwOTo0NTowNFrOGbBrdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxMTowOToxNlrOGbEcDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk5MjI0Ng==", "bodyText": "This was a mistake right?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23497#discussion_r430992246", "createdAt": "2020-05-27T09:45:04Z", "author": {"login": "lochana-chathura"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -9179,7 +9203,7 @@ private STNode parseStringTemplateExpression() {\n         STNode type = parseStringKeyword();\n         STNode startingBackTick = parseBacktickToken(ParserRuleContext.TEMPLATE_START);\n         STNode content = parseTemplateContent();\n-        STNode endingBackTick = parseBacktickToken(ParserRuleContext.TEMPLATE_START);\n+        STNode endingBackTick = parseBacktickToken(ParserRuleContext.TEMPLATE_END);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2300809c98e9168bfe029b8d62dd59ef8f2a89e4"}, "originalPosition": 170}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTAzNzQ1Mw==", "bodyText": "yes, seems so", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23497#discussion_r431037453", "createdAt": "2020-05-27T11:09:16Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -9179,7 +9203,7 @@ private STNode parseStringTemplateExpression() {\n         STNode type = parseStringKeyword();\n         STNode startingBackTick = parseBacktickToken(ParserRuleContext.TEMPLATE_START);\n         STNode content = parseTemplateContent();\n-        STNode endingBackTick = parseBacktickToken(ParserRuleContext.TEMPLATE_START);\n+        STNode endingBackTick = parseBacktickToken(ParserRuleContext.TEMPLATE_END);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk5MjI0Ng=="}, "originalCommit": {"oid": "2300809c98e9168bfe029b8d62dd59ef8f2a89e4"}, "originalPosition": 170}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NDUxMDUxOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwOTo0NjozNFrOGbBvGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwOTo0NjozNFrOGbBvGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk5MzE3Ng==", "bodyText": "here also a mistake?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23497#discussion_r430993176", "createdAt": "2020-05-27T09:46:34Z", "author": {"login": "lochana-chathura"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -917,7 +917,13 @@ protected Result seekMatch(ParserRuleContext currentCtx, int lookahead, int curr\n                     hasMatch = nextToken.kind == SyntaxKind.XML_KEYWORD;\n                     break;\n                 case STRING_KEYWORD:\n-                    hasMatch = nextToken.kind == SyntaxKind.XML_KEYWORD;\n+                    hasMatch = nextToken.kind == SyntaxKind.STRING_KEYWORD;\n+                    break;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2300809c98e9168bfe029b8d62dd59ef8f2a89e4"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NDc2NzQwOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxMTowNTowNVrOGbETeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxMTowNTowNVrOGbETeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTAzNTI1Nw==", "bodyText": "I think we can skip this check, since base16 and base64 keywords only occurs in expressions.\nThen if one of those two, then we can commit to say its one of those two literals.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23497#discussion_r431035257", "createdAt": "2020-05-27T11:05:05Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -4279,6 +4282,13 @@ private STNode parseTerminalExpression(SyntaxKind kind, STNode annots, boolean i\n                 return parseTransactionalExpression();\n             case SERVICE_KEYWORD:\n                 return parseServiceConstructorExpression(annots);\n+            case BASE16_KEYWORD:\n+            case BASE64_KEYWORD:\n+                nextNextToken = getNextNextToken(kind);\n+                if (nextNextToken.kind == SyntaxKind.BACKTICK_TOKEN) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0fbb1cf0199161125aaca5c14ba5b4afa74cd17e"}, "originalPosition": 118}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NDc3MjI2OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxMTowNjozMVrOGbEWfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxMTowNjozMVrOGbEWfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTAzNjAyOQ==", "bodyText": "Would something like \"field-access-identifier\" be a better word for both context and method name? because qualified-identifier is a bit generic..", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23497#discussion_r431036029", "createdAt": "2020-05-27T11:06:31Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -435,8 +434,8 @@ public STNode resumeParsing(ParserRuleContext context, Object... args) {\n                 return parseWaitFieldEnd();\n             case ANNOT_CHAINING_TOKEN:\n                 return parseAnnotChainingToken();\n-            case ANNOT_TAG_REFERENCE:\n-                return parseAnnotTagReference();\n+            case QUALIFIED_IDENTIFIER_OR_IDENTIFIER:\n+                return parseQualifiedIdentifierOrIdentifier();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0fbb1cf0199161125aaca5c14ba5b4afa74cd17e"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NDc5ODg0OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxMToxNTo0N1rOGbEn9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxMToxNTo0N1rOGbEn9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTA0MDUwMA==", "bodyText": "Shall we remove FIELD_OR_FUNC_NAME from parser rule context class as well?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23497#discussion_r431040500", "createdAt": "2020-05-27T11:15:47Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -11161,16 +11189,26 @@ private STNode parseDoKeyword() {\n     }\n \n     /**\n-     * Parse optional field access expression.\n+     * Parse optional field access or xml optional attribute access expression.\n      * <p>\n-     * <code>optional-field-access-expr := expression ?. field-name</code>\n+     * <code>\n+     * optional-field-access-expr := expression ?. field-name\n+     * <br/>\n+     * xml-optional-attribute-access-expr := expression ?. xml-attribute-name\n+     * <br/>\n+     * xml-attribute-name := xml-qualified-name | qualified-identifier | identifier\n+     * <br/>\n+     * xml-qualified-name := xml-namespace-prefix : identifier\n+     * <br/>\n+     * xml-namespace-prefix := identifier\n+     * </code>\n      *\n-     * @param lhsExpr Preceding expression of the optional field access\n+     * @param lhsExpr Preceding expression of the optional access\n      * @return Parsed node\n      */\n     private STNode parseOptionalFieldAccessExpression(STNode lhsExpr) {\n         STNode optionalFieldAccessToken = parseOptionalChainingToken();\n-        STNode fieldName = parseIdentifier(ParserRuleContext.FIELD_OR_FUNC_NAME);\n+        STNode fieldName = parseQualifiedIdentifierOrIdentifier();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0fbb1cf0199161125aaca5c14ba5b4afa74cd17e"}, "originalPosition": 241}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NDgxOTYwOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxMToyMjoxOFrOGbE1Mw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxMToyMjoxOFrOGbE1Mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTA0Mzg5MQ==", "bodyText": "we would never reach here right? In that case i think its ok to not to have the second 'if' condition", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23497#discussion_r431043891", "createdAt": "2020-05-27T11:22:18Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -11897,4 +11935,104 @@ private STNode parseServiceConstructorExpression(STNode annots) {\n                 serviceKeyword,\n                 serviceBody);\n     }\n+\n+    /**\n+     * Parse base16 literal.\n+     * <p>\n+     * <code>\n+     * byte-array-literal := Base16Literal | Base64Literal\n+     * <br/>\n+     * Base16Literal := base16 WS ` HexGroup* WS `\n+     * <br/>\n+     * Base64Literal := base64 WS ` Base64Group* [PaddedBase64Group] WS `\n+     * </code>\n+     *\n+     * @param kind byte array literal kind\n+     * @return parsed node\n+     */\n+    private STNode parseByteArrayLiteral(SyntaxKind kind) {\n+        STNode type;\n+\n+        if (kind == SyntaxKind.BASE16_KEYWORD) {\n+            type = parseBase16Keyword();\n+        } else {\n+            type = parseBase64Keyword();\n+        }\n+\n+        STNode startingBackTick = parseBacktickToken(ParserRuleContext.TEMPLATE_START);\n+        STNode content = parseByteArrayContent(kind);\n+        STNode endingBackTick = parseBacktickToken(ParserRuleContext.TEMPLATE_END);\n+        return STNodeFactory.createByteArrayLiteralNode(type, startingBackTick, content, endingBackTick);\n+    }\n+\n+    /**\n+     * Parse <code>base16</code> keyword.\n+     *\n+     * @return base16 keyword node\n+     */\n+    private STNode parseBase16Keyword() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.BASE16_KEYWORD) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(token, ParserRuleContext.BASE16_KEYWORD);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse <code>base64</code> keyword.\n+     *\n+     * @return base64 keyword node\n+     */\n+    private STNode parseBase64Keyword() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.BASE64_KEYWORD) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(token, ParserRuleContext.BASE64_KEYWORD);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Validate and parse byte array literal content.\n+     * An error is reported, if the content is invalid.\n+     *\n+     * @param kind byte array literal kind\n+     * @return parsed node\n+     */\n+    private STNode parseByteArrayContent(SyntaxKind kind) {\n+        STNode content = null;\n+        boolean isValidContent = false;\n+        STToken nextToken = peek();\n+\n+        while (!isEndOfBacktickContent(nextToken.kind)) {\n+            STNode contentItem = parseTemplateItem();\n+\n+            if (content == null && contentItem.kind == SyntaxKind.TEMPLATE_STRING) {\n+                if (kind == SyntaxKind.BASE16_KEYWORD &&\n+                        BallerinaLexer.isValidBase16LiteralContent(contentItem.toString())) {\n+                    content = contentItem;\n+                    isValidContent = true;\n+                } else if (kind == SyntaxKind.BASE64_KEYWORD &&\n+                        BallerinaLexer.isValidBase64LiteralContent(contentItem.toString())) {\n+                    content = contentItem;\n+                    isValidContent = true;\n+                } else {\n+                    content = contentItem;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0fbb1cf0199161125aaca5c14ba5b4afa74cd17e"}, "originalPosition": 397}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NDgzMjg1OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxMToyNjo1M1rOGbE9rg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxNDoxODo0OFrOGbMbVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTA0NjA2Mg==", "bodyText": "Shall we simplify this logic?\n\nParse everything.\nif size >1 , then error. no need to check character-wise\nif size ==1, and if thats not an TEMPLATE_STRING, again error.\nif non of those above, then validate.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23497#discussion_r431046062", "createdAt": "2020-05-27T11:26:53Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -11897,4 +11935,104 @@ private STNode parseServiceConstructorExpression(STNode annots) {\n                 serviceKeyword,\n                 serviceBody);\n     }\n+\n+    /**\n+     * Parse base16 literal.\n+     * <p>\n+     * <code>\n+     * byte-array-literal := Base16Literal | Base64Literal\n+     * <br/>\n+     * Base16Literal := base16 WS ` HexGroup* WS `\n+     * <br/>\n+     * Base64Literal := base64 WS ` Base64Group* [PaddedBase64Group] WS `\n+     * </code>\n+     *\n+     * @param kind byte array literal kind\n+     * @return parsed node\n+     */\n+    private STNode parseByteArrayLiteral(SyntaxKind kind) {\n+        STNode type;\n+\n+        if (kind == SyntaxKind.BASE16_KEYWORD) {\n+            type = parseBase16Keyword();\n+        } else {\n+            type = parseBase64Keyword();\n+        }\n+\n+        STNode startingBackTick = parseBacktickToken(ParserRuleContext.TEMPLATE_START);\n+        STNode content = parseByteArrayContent(kind);\n+        STNode endingBackTick = parseBacktickToken(ParserRuleContext.TEMPLATE_END);\n+        return STNodeFactory.createByteArrayLiteralNode(type, startingBackTick, content, endingBackTick);\n+    }\n+\n+    /**\n+     * Parse <code>base16</code> keyword.\n+     *\n+     * @return base16 keyword node\n+     */\n+    private STNode parseBase16Keyword() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.BASE16_KEYWORD) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(token, ParserRuleContext.BASE16_KEYWORD);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse <code>base64</code> keyword.\n+     *\n+     * @return base64 keyword node\n+     */\n+    private STNode parseBase64Keyword() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.BASE64_KEYWORD) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(token, ParserRuleContext.BASE64_KEYWORD);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Validate and parse byte array literal content.\n+     * An error is reported, if the content is invalid.\n+     *\n+     * @param kind byte array literal kind\n+     * @return parsed node\n+     */\n+    private STNode parseByteArrayContent(SyntaxKind kind) {\n+        STNode content = null;\n+        boolean isValidContent = false;\n+        STToken nextToken = peek();\n+\n+        while (!isEndOfBacktickContent(nextToken.kind)) {\n+            STNode contentItem = parseTemplateItem();\n+\n+            if (content == null && contentItem.kind == SyntaxKind.TEMPLATE_STRING) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0fbb1cf0199161125aaca5c14ba5b4afa74cd17e"}, "originalPosition": 387}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTE2ODM0MQ==", "bodyText": "HBN?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23497#discussion_r431168341", "createdAt": "2020-05-27T14:18:48Z", "author": {"login": "lochana-chathura"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -11897,4 +11935,104 @@ private STNode parseServiceConstructorExpression(STNode annots) {\n                 serviceKeyword,\n                 serviceBody);\n     }\n+\n+    /**\n+     * Parse base16 literal.\n+     * <p>\n+     * <code>\n+     * byte-array-literal := Base16Literal | Base64Literal\n+     * <br/>\n+     * Base16Literal := base16 WS ` HexGroup* WS `\n+     * <br/>\n+     * Base64Literal := base64 WS ` Base64Group* [PaddedBase64Group] WS `\n+     * </code>\n+     *\n+     * @param kind byte array literal kind\n+     * @return parsed node\n+     */\n+    private STNode parseByteArrayLiteral(SyntaxKind kind) {\n+        STNode type;\n+\n+        if (kind == SyntaxKind.BASE16_KEYWORD) {\n+            type = parseBase16Keyword();\n+        } else {\n+            type = parseBase64Keyword();\n+        }\n+\n+        STNode startingBackTick = parseBacktickToken(ParserRuleContext.TEMPLATE_START);\n+        STNode content = parseByteArrayContent(kind);\n+        STNode endingBackTick = parseBacktickToken(ParserRuleContext.TEMPLATE_END);\n+        return STNodeFactory.createByteArrayLiteralNode(type, startingBackTick, content, endingBackTick);\n+    }\n+\n+    /**\n+     * Parse <code>base16</code> keyword.\n+     *\n+     * @return base16 keyword node\n+     */\n+    private STNode parseBase16Keyword() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.BASE16_KEYWORD) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(token, ParserRuleContext.BASE16_KEYWORD);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse <code>base64</code> keyword.\n+     *\n+     * @return base64 keyword node\n+     */\n+    private STNode parseBase64Keyword() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.BASE64_KEYWORD) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(token, ParserRuleContext.BASE64_KEYWORD);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Validate and parse byte array literal content.\n+     * An error is reported, if the content is invalid.\n+     *\n+     * @param kind byte array literal kind\n+     * @return parsed node\n+     */\n+    private STNode parseByteArrayContent(SyntaxKind kind) {\n+        STNode content = null;\n+        boolean isValidContent = false;\n+        STToken nextToken = peek();\n+\n+        while (!isEndOfBacktickContent(nextToken.kind)) {\n+            STNode contentItem = parseTemplateItem();\n+\n+            if (content == null && contentItem.kind == SyntaxKind.TEMPLATE_STRING) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTA0NjA2Mg=="}, "originalCommit": {"oid": "0fbb1cf0199161125aaca5c14ba5b4afa74cd17e"}, "originalPosition": 387}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NDg5NjI5OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-treegen/src/main/resources/syntax_tree_descriptor.json", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxMTo0ODoxNFrOGbFmEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxMTo0ODoxNFrOGbFmEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTA1NjQwMw==", "bodyText": "type should be NameReferenceNode?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23497#discussion_r431056403", "createdAt": "2020-05-27T11:48:14Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-treegen/src/main/resources/syntax_tree_descriptor.json", "diffHunk": "@@ -648,7 +648,7 @@\n                 },\n                 {\n                     \"name\": \"fieldName\",\n-                    \"type\": \"Token\"\n+                    \"type\": \"Node\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0fbb1cf0199161125aaca5c14ba5b4afa74cd17e"}, "originalPosition": 5}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3613, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}