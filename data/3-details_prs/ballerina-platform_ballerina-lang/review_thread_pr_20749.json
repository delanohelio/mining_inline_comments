{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY3Mzg1MDE5", "number": 20749, "reviewThreads": {"totalCount": 57, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQxNTo1MzoyM1rODbReEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwNToyMTo0M1rODi8jUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5OTI0MzcwOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQxNTo1MzoyM1rOFiqWXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQwMDo0MzozNFrOFi5ctQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTg4OTc1OQ==", "bodyText": "Shall we improve formatting?\n                    dlog.error(listConstructor.pos, DiagnosticCode.MISMATCHING_ARRAY_LITERAL_VALUES, \n                               arrayType.size, listConstructor.exprs.size());", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r371889759", "createdAt": "2020-01-28T15:53:23Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -609,10 +609,14 @@ public void visit(BLangListConstructorExpr listConstructor) {\n             if (arrayType.state == BArrayState.OPEN_SEALED) {\n                 arrayType.size = listConstructor.exprs.size();\n                 arrayType.state = BArrayState.CLOSED_SEALED;\n-            } else if (arrayType.state != BArrayState.UNSEALED && arrayType.size != listConstructor.exprs.size()) {\n-                dlog.error(listConstructor.pos,\n-                        DiagnosticCode.MISMATCHING_ARRAY_LITERAL_VALUES, arrayType.size, listConstructor.exprs.size());\n-                return;\n+            } else if ((arrayType.state != BArrayState.UNSEALED) && (arrayType.size != listConstructor.exprs.size())) {\n+                if (arrayType.size < listConstructor.exprs.size()) {\n+                    dlog.error(listConstructor.pos,\n+                            DiagnosticCode.MISMATCHING_ARRAY_LITERAL_VALUES, arrayType.size, listConstructor.exprs.size\n+                            ());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bfea2e6ed3c01bef9d1ac8b0c18f1f469b872050"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjEzNzE0MQ==", "bodyText": "Reaching 120 character limit. Check now.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r372137141", "createdAt": "2020-01-29T00:43:34Z", "author": {"login": "KRVPerera"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -609,10 +609,14 @@ public void visit(BLangListConstructorExpr listConstructor) {\n             if (arrayType.state == BArrayState.OPEN_SEALED) {\n                 arrayType.size = listConstructor.exprs.size();\n                 arrayType.state = BArrayState.CLOSED_SEALED;\n-            } else if (arrayType.state != BArrayState.UNSEALED && arrayType.size != listConstructor.exprs.size()) {\n-                dlog.error(listConstructor.pos,\n-                        DiagnosticCode.MISMATCHING_ARRAY_LITERAL_VALUES, arrayType.size, listConstructor.exprs.size());\n-                return;\n+            } else if ((arrayType.state != BArrayState.UNSEALED) && (arrayType.size != listConstructor.exprs.size())) {\n+                if (arrayType.size < listConstructor.exprs.size()) {\n+                    dlog.error(listConstructor.pos,\n+                            DiagnosticCode.MISMATCHING_ARRAY_LITERAL_VALUES, arrayType.size, listConstructor.exprs.size\n+                            ());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTg4OTc1OQ=="}, "originalCommit": {"oid": "bfea2e6ed3c01bef9d1ac8b0c18f1f469b872050"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5OTI2Mjk4OnYy", "diffSide": "RIGHT", "path": "tests/jballerina-unit-test/src/test/java/org/ballerinalang/test/expressions/listconstructor/ListConstructorExprTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQxNTo1Nzo1NFrOFiqiaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQxNTo1Nzo1NFrOFiqiaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTg5Mjg0Mw==", "bodyText": "Shall we write this test to panic on failure instead? e.g., https://github.com/ballerina-platform/ballerina-lang/pull/20679/files#diff-8ef02e76dc938bb93e61ae0143f646cdR1060\nThat way we could remove the Java side assertions.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r371892843", "createdAt": "2020-01-28T15:57:54Z", "author": {"login": "MaryamZi"}, "path": "tests/jballerina-unit-test/src/test/java/org/ballerinalang/test/expressions/listconstructor/ListConstructorExprTest.java", "diffHunk": "@@ -59,4 +59,11 @@ public void diagnosticsTest() {\n                 23, 34);\n         Assert.assertEquals(resultNegative.getErrorCount(), i);\n     }\n+\n+    @Test\n+    public void testListConstructorAutoFillExpr() {\n+        BValue[] returns = BRunUtil.invoke(result, \"testListConstructorAutoFillExpr\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bfea2e6ed3c01bef9d1ac8b0c18f1f469b872050"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5OTI2NTc3OnYy", "diffSide": "RIGHT", "path": "tests/jballerina-unit-test/src/test/java/org/ballerinalang/test/statements/arrays/SealedArrayTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQxNTo1ODozOFrOFiqkPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQxNzozMDowMlrOFit_og==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTg5MzMxMA==", "bodyText": "We can write these tests also in Ballerina right?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r371893310", "createdAt": "2020-01-28T15:58:38Z", "author": {"login": "MaryamZi"}, "path": "tests/jballerina-unit-test/src/test/java/org/ballerinalang/test/statements/arrays/SealedArrayTest.java", "diffHunk": "@@ -53,6 +53,11 @@ public void testCreateIntegerSealedArray() {\n                 returnValues == null || returnValues.length == 0 || returnValues[0] == null, \"Invalid Return Values.\");\n         Assert.assertEquals(((BInteger) returnValues[0]).intValue(), 5, \"Length didn't match\");\n \n+        returnValues = BRunUtil.invoke(compileResult, \"createIntAutoFilledSealedArray\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bfea2e6ed3c01bef9d1ac8b0c18f1f469b872050"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTk0OTQ3NA==", "bodyText": "Using testerina asserts ? or with If conditions and panics?\nWhat is more suitable in the long term?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r371949474", "createdAt": "2020-01-28T17:30:02Z", "author": {"login": "KRVPerera"}, "path": "tests/jballerina-unit-test/src/test/java/org/ballerinalang/test/statements/arrays/SealedArrayTest.java", "diffHunk": "@@ -53,6 +53,11 @@ public void testCreateIntegerSealedArray() {\n                 returnValues == null || returnValues.length == 0 || returnValues[0] == null, \"Invalid Return Values.\");\n         Assert.assertEquals(((BInteger) returnValues[0]).intValue(), 5, \"Length didn't match\");\n \n+        returnValues = BRunUtil.invoke(compileResult, \"createIntAutoFilledSealedArray\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTg5MzMxMA=="}, "originalCommit": {"oid": "bfea2e6ed3c01bef9d1ac8b0c18f1f469b872050"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5OTI5NDUyOnYy", "diffSide": "RIGHT", "path": "tests/jballerina-unit-test/src/test/resources/test-src/statements/arrays/sealed-array.bal", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQxNjowNjowMFrOFiq2xw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQxNjowNjowMFrOFiq2xw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTg5ODA1NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            }\n          \n          \n            \n            }", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r371898055", "createdAt": "2020-01-28T16:06:00Z", "author": {"login": "MaryamZi"}, "path": "tests/jballerina-unit-test/src/test/resources/test-src/statements/arrays/sealed-array.bal", "diffHunk": "@@ -257,3 +327,13 @@ function testSealedArrayConstrainedMapInvalidIndex (int[3] x1, int index) {\n     x[\"v1\"] = x1;\n     x[\"v1\"][index] = 4;\n }\n+\n+// xml arrays\n+\n+function createXMLAutoFilledSealedArray() returns int {\n+    xml a = xml `<name>Ballerina</name>`;\n+    xml[5] sealedArray = [a, a];\n+    sealedArray[3] = a;\n+    xml test = sealedArray[4];\n+    return sealedArray.length();\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bfea2e6ed3c01bef9d1ac8b0c18f1f469b872050"}, "originalPosition": 167}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5OTI5ODEzOnYy", "diffSide": "RIGHT", "path": "tests/jballerina-unit-test/src/test/resources/test-src/statements/arrays/sealed-array-semantics-negative.bal", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQxNjowNjo1MlrOFiq5BA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQxNjozNjoxOFrOFisEFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTg5ODYyOA==", "bodyText": "Why are we commenting these out instead of removing them?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r371898628", "createdAt": "2020-01-28T16:06:52Z", "author": {"login": "MaryamZi"}, "path": "tests/jballerina-unit-test/src/test/resources/test-src/statements/arrays/sealed-array-semantics-negative.bal", "diffHunk": "@@ -27,7 +27,7 @@ function accessInvalidIndexOfSealedArrayUsingKeyword() returns string {\n }\n \n function initializeInvalidSizedSealedArray() {\n-    boolean[4] sealedArray1 = [true, true, false];\n+    //boolean[4] sealedArray1 = [true, true, false]; // this is valid now", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bfea2e6ed3c01bef9d1ac8b0c18f1f469b872050"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTkxNzg0Nw==", "bodyText": "Let me remove. I wanted to avoid rewriting every line number of the java side asset on message and line number.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r371917847", "createdAt": "2020-01-28T16:36:18Z", "author": {"login": "KRVPerera"}, "path": "tests/jballerina-unit-test/src/test/resources/test-src/statements/arrays/sealed-array-semantics-negative.bal", "diffHunk": "@@ -27,7 +27,7 @@ function accessInvalidIndexOfSealedArrayUsingKeyword() returns string {\n }\n \n function initializeInvalidSizedSealedArray() {\n-    boolean[4] sealedArray1 = [true, true, false];\n+    //boolean[4] sealedArray1 = [true, true, false]; // this is valid now", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTg5ODYyOA=="}, "originalCommit": {"oid": "bfea2e6ed3c01bef9d1ac8b0c18f1f469b872050"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMjA4NTQ4OnYy", "diffSide": "RIGHT", "path": "tests/jballerina-unit-test/src/test/resources/test-src/statements/arrays/sealed-array.bal", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxMTo0ODowNVrOFjFpxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQwMjo0MjozNFrOFjd9jw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjMzNzA5Mg==", "bodyText": "Add new line at EOF.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r372337092", "createdAt": "2020-01-29T11:48:05Z", "author": {"login": "kalaiyarasiganeshalingam"}, "path": "tests/jballerina-unit-test/src/test/resources/test-src/statements/arrays/sealed-array.bal", "diffHunk": "@@ -257,3 +334,36 @@ function testSealedArrayConstrainedMapInvalidIndex (int[3] x1, int index) {\n     x[\"v1\"] = x1;\n     x[\"v1\"][index] = 4;\n }\n+\n+// xml arrays\n+\n+function createXMLAutoFilledSealedArray() returns int {\n+    xml a = xml `<name>Ballerina</name>`;\n+    xml[5] sealedArray = [a, a];\n+    sealedArray[3] = a;\n+    xml test = sealedArray[4];\n+    return sealedArray.length();\n+}\n+\n+// helper methods\n+\n+function assertArrayLengthPanic(int expected, any[] arr, string message = \"Array length did not match\") {\n+    int actual = arr.length();\n+    if (expected != actual) {\n+        panic error(message + \" Expected : \" + expected.toString() + \" Actual : \" + actual.toString());\n+    }\n+}\n+\n+function assertArrayValuePanic(anydata expected, anydata[] arr, int index,  string message = \"Array value mismatch\") {\n+    anydata actual = arr[index];\n+    if (expected != actual) {\n+        panic error(message + \" Expected : \" + expected.toString() + \" Actual : \" + actual.toString());\n+    }\n+}\n+\n+function isEqualPanic(string expected, any[] arr, string message = \"Not equal\") {\n+    string actual = arr.toString().trim();\n+    if (expected != actual) {\n+        panic error(message + \" Expected : \" + expected + \" Actual : \" + actual);\n+    }\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "065350ed95e2194c657525c7bb4c17048337c6ef"}, "originalPosition": 313}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjczNTM3NQ==", "bodyText": "done", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r372735375", "createdAt": "2020-01-30T02:42:34Z", "author": {"login": "KRVPerera"}, "path": "tests/jballerina-unit-test/src/test/resources/test-src/statements/arrays/sealed-array.bal", "diffHunk": "@@ -257,3 +334,36 @@ function testSealedArrayConstrainedMapInvalidIndex (int[3] x1, int index) {\n     x[\"v1\"] = x1;\n     x[\"v1\"][index] = 4;\n }\n+\n+// xml arrays\n+\n+function createXMLAutoFilledSealedArray() returns int {\n+    xml a = xml `<name>Ballerina</name>`;\n+    xml[5] sealedArray = [a, a];\n+    sealedArray[3] = a;\n+    xml test = sealedArray[4];\n+    return sealedArray.length();\n+}\n+\n+// helper methods\n+\n+function assertArrayLengthPanic(int expected, any[] arr, string message = \"Array length did not match\") {\n+    int actual = arr.length();\n+    if (expected != actual) {\n+        panic error(message + \" Expected : \" + expected.toString() + \" Actual : \" + actual.toString());\n+    }\n+}\n+\n+function assertArrayValuePanic(anydata expected, anydata[] arr, int index,  string message = \"Array value mismatch\") {\n+    anydata actual = arr[index];\n+    if (expected != actual) {\n+        panic error(message + \" Expected : \" + expected.toString() + \" Actual : \" + actual.toString());\n+    }\n+}\n+\n+function isEqualPanic(string expected, any[] arr, string message = \"Not equal\") {\n+    string actual = arr.toString().trim();\n+    if (expected != actual) {\n+        panic error(message + \" Expected : \" + expected + \" Actual : \" + actual);\n+    }\n+}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjMzNzA5Mg=="}, "originalCommit": {"oid": "065350ed95e2194c657525c7bb4c17048337c6ef"}, "originalPosition": 313}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzMDg4MjI1OnYy", "diffSide": "RIGHT", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/values/ArrayValueImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wOVQxODo0OTo1MFrOFnWaUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wOVQxODo0OTo1MFrOFnWaUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjgwNTk2OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Optional<Boolean> hasFillerValue = Optional.empty();;\n          \n          \n            \n                private Optional<Boolean> hasFillerValue = Optional.empty();", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r376805968", "createdAt": "2020-02-09T18:49:50Z", "author": {"login": "MaryamZi"}, "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/values/ArrayValueImpl.java", "diffHunk": "@@ -71,6 +72,8 @@\n     private String[] stringValues;\n     private BString[] bStringValues;\n \n+    private Optional<Boolean> hasFillerValue = Optional.empty();;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14ed660461442578df396c6c3bb26b9062f823b1"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzMTc3MjA1OnYy", "diffSide": "RIGHT", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/values/ArrayValueImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQwOTowNzo0OVrOFneWEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwOTo0NToyOVrOFonx4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjkzNTk1NQ==", "bodyText": "Not due to this changes but IIUC, if this method gets called we've been initializing the array to the default size even if the array is a closed, fixed-length one? Shouldn't we only use the default if there is no explicit size?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r376935955", "createdAt": "2020-02-10T09:07:49Z", "author": {"login": "MaryamZi"}, "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/values/ArrayValueImpl.java", "diffHunk": "@@ -130,56 +133,60 @@ public ArrayValueImpl(BArrayType type) {\n         this.arrayType = type;\n         BArrayType arrayType = (BArrayType) type;\n         this.elementType = arrayType.getElementType();\n+        initArrayValues(elementType, false);\n         if (arrayType.getState() == ArrayState.CLOSED_SEALED) {\n             this.size = maxSize = arrayType.getSize();\n         }\n-        initArrayValues(this.elementType, false);\n     }\n \n     private void initArrayValues(BType elementType, boolean useBString) {\n+        int initialArraySize = Math.max(DEFAULT_ARRAY_SIZE, arrayType.getSize());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6a1ded361a9c36677290e97cd4a3ad1610dc21f1"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODEzOTEwNQ==", "bodyText": "Yes, I agree. For a fixed-length array (explicit size), there will be an unused allocated capacity due to this logic.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r378139105", "createdAt": "2020-02-12T09:45:29Z", "author": {"login": "KRVPerera"}, "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/values/ArrayValueImpl.java", "diffHunk": "@@ -130,56 +133,60 @@ public ArrayValueImpl(BArrayType type) {\n         this.arrayType = type;\n         BArrayType arrayType = (BArrayType) type;\n         this.elementType = arrayType.getElementType();\n+        initArrayValues(elementType, false);\n         if (arrayType.getState() == ArrayState.CLOSED_SEALED) {\n             this.size = maxSize = arrayType.getSize();\n         }\n-        initArrayValues(this.elementType, false);\n     }\n \n     private void initArrayValues(BType elementType, boolean useBString) {\n+        int initialArraySize = Math.max(DEFAULT_ARRAY_SIZE, arrayType.getSize());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjkzNTk1NQ=="}, "originalCommit": {"oid": "6a1ded361a9c36677290e97cd4a3ad1610dc21f1"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzMTc5MjA5OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQwOToxNDozN1rOFneiOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMDozMzowMVrOFpinuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjkzOTA2Nw==", "bodyText": "Not sure if this is the correct error? This just says \"invalid usage of list constructor with type 'T'\" right? IMO, we should say something that implies there's no filler value and there's a size mismatch.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r376939067", "createdAt": "2020-02-10T09:14:37Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -619,16 +620,25 @@ public void visit(BLangListConstructorExpr listConstructor) {\n             if (arrayType.state == BArrayState.OPEN_SEALED) {\n                 arrayType.size = listConstructor.exprs.size();\n                 arrayType.state = BArrayState.CLOSED_SEALED;\n-            } else if (arrayType.state != BArrayState.UNSEALED && arrayType.size != listConstructor.exprs.size()) {\n-                dlog.error(listConstructor.pos,\n-                        DiagnosticCode.MISMATCHING_ARRAY_LITERAL_VALUES, arrayType.size, listConstructor.exprs.size());\n-                return;\n+            } else if ((arrayType.state != BArrayState.UNSEALED) && (arrayType.size != listConstructor.exprs.size())) {\n+                if (arrayType.size < listConstructor.exprs.size()) {\n+                    dlog.error(listConstructor.pos,\n+                               DiagnosticCode.MISMATCHING_ARRAY_LITERAL_VALUES, arrayType.size,\n+                               listConstructor.exprs.size());\n+                    return;\n+                }\n+                //TODO: check fillable values\n+                if (!types.hasFillerValue(arrayType.eType)) {\n+                    dlog.error(listConstructor.pos, DiagnosticCode.INVALID_LIST_CONSTRUCTOR, expType);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6a1ded361a9c36677290e97cd4a3ad1610dc21f1"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTEwMzE2Mw==", "bodyText": "Check the error message on 281133b", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r379103163", "createdAt": "2020-02-13T20:33:01Z", "author": {"login": "KRVPerera"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -619,16 +620,25 @@ public void visit(BLangListConstructorExpr listConstructor) {\n             if (arrayType.state == BArrayState.OPEN_SEALED) {\n                 arrayType.size = listConstructor.exprs.size();\n                 arrayType.state = BArrayState.CLOSED_SEALED;\n-            } else if (arrayType.state != BArrayState.UNSEALED && arrayType.size != listConstructor.exprs.size()) {\n-                dlog.error(listConstructor.pos,\n-                        DiagnosticCode.MISMATCHING_ARRAY_LITERAL_VALUES, arrayType.size, listConstructor.exprs.size());\n-                return;\n+            } else if ((arrayType.state != BArrayState.UNSEALED) && (arrayType.size != listConstructor.exprs.size())) {\n+                if (arrayType.size < listConstructor.exprs.size()) {\n+                    dlog.error(listConstructor.pos,\n+                               DiagnosticCode.MISMATCHING_ARRAY_LITERAL_VALUES, arrayType.size,\n+                               listConstructor.exprs.size());\n+                    return;\n+                }\n+                //TODO: check fillable values\n+                if (!types.hasFillerValue(arrayType.eType)) {\n+                    dlog.error(listConstructor.pos, DiagnosticCode.INVALID_LIST_CONSTRUCTOR, expType);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjkzOTA2Nw=="}, "originalCommit": {"oid": "6a1ded361a9c36677290e97cd4a3ad1610dc21f1"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzMTgwMTUxOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQwOToxNzoxN1rOFnenog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxNDowNTo0MVrOFpU_KA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk0MDQ1MA==", "bodyText": "Shall we add the version?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r376940450", "createdAt": "2020-02-10T09:17:17Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -109,6 +110,31 @@\n     private Names names;\n     private int finiteTypeCount = 0;\n \n+    /**\n+     * Keep default values for basic types in String format.\n+     *", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6a1ded361a9c36677290e97cd4a3ad1610dc21f1"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk0MDgxNw==", "bodyText": "And shall we say filler instead of default?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r376940817", "createdAt": "2020-02-10T09:17:56Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -109,6 +110,31 @@\n     private Names names;\n     private int finiteTypeCount = 0;\n \n+    /**\n+     * Keep default values for basic types in String format.\n+     *", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk0MDQ1MA=="}, "originalCommit": {"oid": "6a1ded361a9c36677290e97cd4a3ad1610dc21f1"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODg3OTc4NA==", "bodyText": "added 1.1.2", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r378879784", "createdAt": "2020-02-13T14:05:41Z", "author": {"login": "KRVPerera"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -109,6 +110,31 @@\n     private Names names;\n     private int finiteTypeCount = 0;\n \n+    /**\n+     * Keep default values for basic types in String format.\n+     *", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk0MDQ1MA=="}, "originalCommit": {"oid": "6a1ded361a9c36677290e97cd4a3ad1610dc21f1"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzMTgwNTYzOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQwOToxODoyNVrOFneqBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQwOToxODoyNVrOFneqBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk0MTA2Mw==", "bodyText": "Is type ever null?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r376941063", "createdAt": "2020-02-10T09:18:25Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2537,4 +2563,154 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6a1ded361a9c36677290e97cd4a3ad1610dc21f1"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNTIwMjc3OnYy", "diffSide": "RIGHT", "path": "tests/jballerina-unit-test/src/test/java/org/ballerinalang/test/statements/arrays/ArrayFillTestRuntime.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQwNzoxNDoyMFrOFn_Bpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQwNzoxNDoyMFrOFn_Bpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ3MTM5OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Copyright (c) 2019, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n          \n          \n            \n             * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r377471398", "createdAt": "2020-02-11T07:14:20Z", "author": {"login": "kalaiyarasiganeshalingam"}, "path": "tests/jballerina-unit-test/src/test/java/org/ballerinalang/test/statements/arrays/ArrayFillTestRuntime.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Copyright (c) 2019, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c003414045f8ef10724fd7f140cf1b3454e7bfeb"}, "originalPosition": 2}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNTIwMzc5OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQwNzoxNTowNVrOFn_CPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQwNzoxNTowNVrOFn_CPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ3MTU0OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * This will handle two types\n          \n          \n            \n                 * This will handle two types.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r377471549", "createdAt": "2020-02-11T07:15:05Z", "author": {"login": "kalaiyarasiganeshalingam"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2537,4 +2563,196 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type == null) {\n+            return true;\n+        }\n+        if (type.tag < TypeTags.RECORD) {\n+            return true;\n+        }\n+        switch (type.tag) {\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+                return false;\n+            }\n+        } else {\n+            if (initFunction.symbol.getReturnType().getKind() == TypeKind.ERROR) {\n+                return false;\n+            }\n+            if (!hasFillerValue(initFunction.symbol.getReturnType())) {\n+                return false;\n+            }\n+            if (!initFunction.symbol.getParameters().stream()\n+                    .allMatch(bVarSymbol -> bVarSymbol.defaultableParam == true)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * This will handle two types", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c003414045f8ef10724fd7f140cf1b3454e7bfeb"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNTIwNDY5OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQwNzoxNTo0M1rOFn_CvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQwOToxMjoyMFrOFoBfNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ3MTY3Nw==", "bodyText": "Remove extra lines", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r377471677", "createdAt": "2020-02-11T07:15:43Z", "author": {"login": "kalaiyarasiganeshalingam"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -4766,4 +4775,6 @@ private boolean isConst(BLangExpression expression) {\n     private Name getCurrentCompUnit(BLangNode node) {\n         return names.fromString(node.pos.getSource().getCompilationUnitName());\n     }\n+\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c003414045f8ef10724fd7f140cf1b3454e7bfeb"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzUxMTczNQ==", "bodyText": "done", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r377511735", "createdAt": "2020-02-11T09:12:20Z", "author": {"login": "KRVPerera"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -4766,4 +4775,6 @@ private boolean isConst(BLangExpression expression) {\n     private Name getCurrentCompUnit(BLangNode node) {\n         return names.fromString(node.pos.getSource().getCompilationUnitName());\n     }\n+\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ3MTY3Nw=="}, "originalCommit": {"oid": "c003414045f8ef10724fd7f140cf1b3454e7bfeb"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNTQxNTUzOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQwODo1MzoxNVrOFoA-Cg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxMDo0ODoxOVrOFoEbfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzUwMzI0Mg==", "bodyText": "If we move this logic to a function, we can improve the readability of the code. WDYT?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r377503242", "createdAt": "2020-02-11T08:53:15Z", "author": {"login": "dulvinw"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -619,10 +619,18 @@ public void visit(BLangListConstructorExpr listConstructor) {\n             if (arrayType.state == BArrayState.OPEN_SEALED) {\n                 arrayType.size = listConstructor.exprs.size();\n                 arrayType.state = BArrayState.CLOSED_SEALED;\n-            } else if (arrayType.state != BArrayState.UNSEALED && arrayType.size != listConstructor.exprs.size()) {\n-                dlog.error(listConstructor.pos,\n-                        DiagnosticCode.MISMATCHING_ARRAY_LITERAL_VALUES, arrayType.size, listConstructor.exprs.size());\n-                return;\n+            } else if ((arrayType.state != BArrayState.UNSEALED) && (arrayType.size != listConstructor.exprs.size())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f58c8c21da6ba8cb86457d3e7c52e863a15a3b68"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzU1OTkzMg==", "bodyText": "It will be like two functions ..\nif (isSealedArray(arrayType) && isSizeMismatch(arrayType, listConstructor.exprs)). Will this help ?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r377559932", "createdAt": "2020-02-11T10:48:19Z", "author": {"login": "KRVPerera"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -619,10 +619,18 @@ public void visit(BLangListConstructorExpr listConstructor) {\n             if (arrayType.state == BArrayState.OPEN_SEALED) {\n                 arrayType.size = listConstructor.exprs.size();\n                 arrayType.state = BArrayState.CLOSED_SEALED;\n-            } else if (arrayType.state != BArrayState.UNSEALED && arrayType.size != listConstructor.exprs.size()) {\n-                dlog.error(listConstructor.pos,\n-                        DiagnosticCode.MISMATCHING_ARRAY_LITERAL_VALUES, arrayType.size, listConstructor.exprs.size());\n-                return;\n+            } else if ((arrayType.state != BArrayState.UNSEALED) && (arrayType.size != listConstructor.exprs.size())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzUwMzI0Mg=="}, "originalCommit": {"oid": "f58c8c21da6ba8cb86457d3e7c52e863a15a3b68"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNzUxOTc5OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxODo1OTo1NVrOFoVL7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxMDowMDozNVrOFooUMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgzNDQ3OA==", "bodyText": "We only need to check if the return type is not nil right?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r377834478", "createdAt": "2020-02-11T18:59:55Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2537,4 +2563,196 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type == null) {\n+            return true;\n+        }\n+        if (type.tag < TypeTags.RECORD) {\n+            return true;\n+        }\n+        switch (type.tag) {\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+                return false;\n+            }\n+        } else {\n+            if (initFunction.symbol.getReturnType().getKind() == TypeKind.ERROR) {\n+                return false;\n+            }\n+            if (!hasFillerValue(initFunction.symbol.getReturnType())) {\n+                return false;\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d7ffca3f2535a897d0e44911a0f4d7bff9869799"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODE0Nzg4OQ==", "bodyText": "yes", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r378147889", "createdAt": "2020-02-12T10:00:35Z", "author": {"login": "KRVPerera"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2537,4 +2563,196 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type == null) {\n+            return true;\n+        }\n+        if (type.tag < TypeTags.RECORD) {\n+            return true;\n+        }\n+        switch (type.tag) {\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+                return false;\n+            }\n+        } else {\n+            if (initFunction.symbol.getReturnType().getKind() == TypeKind.ERROR) {\n+                return false;\n+            }\n+            if (!hasFillerValue(initFunction.symbol.getReturnType())) {\n+                return false;\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgzNDQ3OA=="}, "originalCommit": {"oid": "d7ffca3f2535a897d0e44911a0f4d7bff9869799"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNzUzMjA1OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxOTowMzoyOVrOFoVTsg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxOTowNDo0MlrOFoVWPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgzNjQ2Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                .allMatch(bVarSymbol -> bVarSymbol.defaultableParam == true)) {\n          \n          \n            \n                                .allMatch(bVarSymbol -> bVarSymbol.defaultableParam)) {", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r377836466", "createdAt": "2020-02-11T19:03:29Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2537,4 +2563,196 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type == null) {\n+            return true;\n+        }\n+        if (type.tag < TypeTags.RECORD) {\n+            return true;\n+        }\n+        switch (type.tag) {\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+                return false;\n+            }\n+        } else {\n+            if (initFunction.symbol.getReturnType().getKind() == TypeKind.ERROR) {\n+                return false;\n+            }\n+            if (!hasFillerValue(initFunction.symbol.getReturnType())) {\n+                return false;\n+            }\n+            if (!initFunction.symbol.getParameters().stream()\n+                    .allMatch(bVarSymbol -> bVarSymbol.defaultableParam == true)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d7ffca3f2535a897d0e44911a0f4d7bff9869799"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgzNzExOQ==", "bodyText": "Shall we avoid using streams btw?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r377837119", "createdAt": "2020-02-11T19:04:42Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2537,4 +2563,196 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type == null) {\n+            return true;\n+        }\n+        if (type.tag < TypeTags.RECORD) {\n+            return true;\n+        }\n+        switch (type.tag) {\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+                return false;\n+            }\n+        } else {\n+            if (initFunction.symbol.getReturnType().getKind() == TypeKind.ERROR) {\n+                return false;\n+            }\n+            if (!hasFillerValue(initFunction.symbol.getReturnType())) {\n+                return false;\n+            }\n+            if (!initFunction.symbol.getParameters().stream()\n+                    .allMatch(bVarSymbol -> bVarSymbol.defaultableParam == true)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgzNjQ2Ng=="}, "originalCommit": {"oid": "d7ffca3f2535a897d0e44911a0f4d7bff9869799"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNzU4NzIyOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxOToxOTo1OFrOFoV29w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxMDowOTozMFrOFoom8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg0NTQ5NQ==", "bodyText": "Do we need the null check for value space members? Can the value be null?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r377845495", "createdAt": "2020-02-11T19:19:58Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2537,4 +2563,196 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type == null) {\n+            return true;\n+        }\n+        if (type.tag < TypeTags.RECORD) {\n+            return true;\n+        }\n+        switch (type.tag) {\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+                return false;\n+            }\n+        } else {\n+            if (initFunction.symbol.getReturnType().getKind() == TypeKind.ERROR) {\n+                return false;\n+            }\n+            if (!hasFillerValue(initFunction.symbol.getReturnType())) {\n+                return false;\n+            }\n+            if (!initFunction.symbol.getParameters().stream()\n+                    .allMatch(bVarSymbol -> bVarSymbol.defaultableParam == true)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * This will handle two types.\n+     *  Singleton : As singleton can have one value that value should it self be a valid fill value\n+     *  Union :\n+     *          1. if nil is a member it is the fill values\n+     *          2. else all the values should belong to same type and the default value for that type\n+     *              should be a member of the union\n+     * @param type BFiniteType union or finite\n+     * @return\n+     */\n+    private boolean checkFillerValue(BFiniteType type) {\n+        // For singleton types, that value is the implicit initial value\n+        if (type.valueSpace.size() == 1) {\n+            return true;\n+        }\n+\n+        // is first value null\n+        Iterator iterator = type.valueSpace.iterator();\n+        BLangExpression firstElement = (BLangExpression) iterator.next();\n+        if ((firstElement == null) || (firstElement.type.getKind() == TypeKind.NIL)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d7ffca3f2535a897d0e44911a0f4d7bff9869799"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODAzOTUwMg==", "bodyText": "Also, instead of this can't our first check be isNullable like for union types before iterating through the value space?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r378039502", "createdAt": "2020-02-12T04:50:18Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2537,4 +2563,196 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type == null) {\n+            return true;\n+        }\n+        if (type.tag < TypeTags.RECORD) {\n+            return true;\n+        }\n+        switch (type.tag) {\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+                return false;\n+            }\n+        } else {\n+            if (initFunction.symbol.getReturnType().getKind() == TypeKind.ERROR) {\n+                return false;\n+            }\n+            if (!hasFillerValue(initFunction.symbol.getReturnType())) {\n+                return false;\n+            }\n+            if (!initFunction.symbol.getParameters().stream()\n+                    .allMatch(bVarSymbol -> bVarSymbol.defaultableParam == true)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * This will handle two types.\n+     *  Singleton : As singleton can have one value that value should it self be a valid fill value\n+     *  Union :\n+     *          1. if nil is a member it is the fill values\n+     *          2. else all the values should belong to same type and the default value for that type\n+     *              should be a member of the union\n+     * @param type BFiniteType union or finite\n+     * @return\n+     */\n+    private boolean checkFillerValue(BFiniteType type) {\n+        // For singleton types, that value is the implicit initial value\n+        if (type.valueSpace.size() == 1) {\n+            return true;\n+        }\n+\n+        // is first value null\n+        Iterator iterator = type.valueSpace.iterator();\n+        BLangExpression firstElement = (BLangExpression) iterator.next();\n+        if ((firstElement == null) || (firstElement.type.getKind() == TypeKind.NIL)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg0NTQ5NQ=="}, "originalCommit": {"oid": "d7ffca3f2535a897d0e44911a0f4d7bff9869799"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODE1MjY4OA==", "bodyText": "let me check the null value.\nIsNullable for \"BFiniteType\" actually goes through every item in value space.\npublic boolean isNullable() {\n        return this.valueSpace.stream().anyMatch(v -> v.type.tag == TypeTags.NIL);\n}\nMay be we can remove nullable check in union type code inside loop and for first item. Let me check.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r378152688", "createdAt": "2020-02-12T10:09:30Z", "author": {"login": "KRVPerera"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2537,4 +2563,196 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type == null) {\n+            return true;\n+        }\n+        if (type.tag < TypeTags.RECORD) {\n+            return true;\n+        }\n+        switch (type.tag) {\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+                return false;\n+            }\n+        } else {\n+            if (initFunction.symbol.getReturnType().getKind() == TypeKind.ERROR) {\n+                return false;\n+            }\n+            if (!hasFillerValue(initFunction.symbol.getReturnType())) {\n+                return false;\n+            }\n+            if (!initFunction.symbol.getParameters().stream()\n+                    .allMatch(bVarSymbol -> bVarSymbol.defaultableParam == true)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * This will handle two types.\n+     *  Singleton : As singleton can have one value that value should it self be a valid fill value\n+     *  Union :\n+     *          1. if nil is a member it is the fill values\n+     *          2. else all the values should belong to same type and the default value for that type\n+     *              should be a member of the union\n+     * @param type BFiniteType union or finite\n+     * @return\n+     */\n+    private boolean checkFillerValue(BFiniteType type) {\n+        // For singleton types, that value is the implicit initial value\n+        if (type.valueSpace.size() == 1) {\n+            return true;\n+        }\n+\n+        // is first value null\n+        Iterator iterator = type.valueSpace.iterator();\n+        BLangExpression firstElement = (BLangExpression) iterator.next();\n+        if ((firstElement == null) || (firstElement.type.getKind() == TypeKind.NIL)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg0NTQ5NQ=="}, "originalCommit": {"oid": "d7ffca3f2535a897d0e44911a0f4d7bff9869799"}, "originalPosition": 114}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNzYwNjM3OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxOToyNTo0MlrOFoWDWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxOToyNTo0MlrOFoWDWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg0ODY2NA==", "bodyText": "return getDefaultFillValue(expr.type);", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r377848664", "createdAt": "2020-02-11T19:25:42Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2537,4 +2563,196 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type == null) {\n+            return true;\n+        }\n+        if (type.tag < TypeTags.RECORD) {\n+            return true;\n+        }\n+        switch (type.tag) {\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+                return false;\n+            }\n+        } else {\n+            if (initFunction.symbol.getReturnType().getKind() == TypeKind.ERROR) {\n+                return false;\n+            }\n+            if (!hasFillerValue(initFunction.symbol.getReturnType())) {\n+                return false;\n+            }\n+            if (!initFunction.symbol.getParameters().stream()\n+                    .allMatch(bVarSymbol -> bVarSymbol.defaultableParam == true)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * This will handle two types.\n+     *  Singleton : As singleton can have one value that value should it self be a valid fill value\n+     *  Union :\n+     *          1. if nil is a member it is the fill values\n+     *          2. else all the values should belong to same type and the default value for that type\n+     *              should be a member of the union\n+     * @param type BFiniteType union or finite\n+     * @return\n+     */\n+    private boolean checkFillerValue(BFiniteType type) {\n+        // For singleton types, that value is the implicit initial value\n+        if (type.valueSpace.size() == 1) {\n+            return true;\n+        }\n+\n+        // is first value null\n+        Iterator iterator = type.valueSpace.iterator();\n+        BLangExpression firstElement = (BLangExpression) iterator.next();\n+        if ((firstElement == null) || (firstElement.type.getKind() == TypeKind.NIL)) {\n+            return true;\n+        }\n+\n+        boolean allMembersHaveSameType = true;\n+        boolean defaultFillValuePresent = false;\n+\n+        // is first value is a valid fill value\n+        String defaultFillValue = getDefaultFillValue(firstElement);\n+        if (firstElement.toString().equals(defaultFillValue)) {\n+            defaultFillValuePresent = true;\n+        }\n+\n+        while (iterator.hasNext()) {\n+            Object value =  iterator.next();\n+            if (value == null) {\n+                return true;\n+            }\n+\n+            BType valueType = ((BLangExpression) value).type;\n+            if (valueType.getKind() == TypeKind.NIL) {\n+                return true;\n+            }\n+\n+            if (allMembersHaveSameType && !isSameType(valueType, firstElement.type)) {\n+                allMembersHaveSameType = false;\n+            }\n+\n+            if (!defaultFillValuePresent && value.toString().equals(defaultFillValue)) {\n+                defaultFillValuePresent = true;\n+            }\n+        }\n+\n+        if (!allMembersHaveSameType) {\n+            return false;\n+        }\n+\n+        return defaultFillValuePresent;\n+    }\n+\n+    private boolean checkFillerValue(BUnionType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+\n+        Iterator<BType> iterator = type.getMemberTypes().iterator();\n+        BType firstMember = iterator.next();\n+        // is first value is a valid fill value\n+        if (firstMember.getKind() == TypeKind.NIL) {\n+            return true;\n+        }\n+\n+        boolean allMembersHaveSameType = true;\n+        boolean defaultFillValuePresent = false;\n+\n+        // is first value is a valid fill value\n+        String defaultFillValue = getDefaultFillValue(firstMember);\n+        if (firstMember.toString().equals(defaultFillValue)) {\n+            defaultFillValuePresent = true;\n+        }\n+\n+        while (iterator.hasNext()) {\n+\n+            Object value =  iterator.next();\n+            if (value == null) {\n+                return true;\n+            }\n+\n+            if (allMembersHaveSameType && !isSameType(firstMember, iterator.next())) {\n+                allMembersHaveSameType = false;\n+            }\n+\n+            if (!defaultFillValuePresent && value.toString().equals(defaultFillValue)) {\n+                defaultFillValuePresent = true;\n+            }\n+        }\n+\n+        if (!allMembersHaveSameType) {\n+            return false;\n+        }\n+        return defaultFillValuePresent;\n+    }\n+\n+    private boolean checkFillerValue(BRecordType type) {\n+        for (BField field : type.fields) {\n+            if (field.symbol.defaultableParam) {\n+                continue;\n+            }\n+            if (!hasFillerValue(field.type)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private boolean checkFillerValue(BArrayType type) {\n+        return hasFillerValue(type.eType);\n+    }\n+\n+    private String getDefaultFillValue(BLangExpression expr) {\n+        BType type = expr.type;\n+        return getDefaultFillValue(type);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d7ffca3f2535a897d0e44911a0f4d7bff9869799"}, "originalPosition": 215}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzODgzMTY5OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwNDo1OTowNFrOFohzZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwOTozODoxN1rOFoniXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA0MTE5MQ==", "bodyText": "Can't we just check !isSameType(valueType, firstElement.type) and return false here?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r378041191", "createdAt": "2020-02-12T04:59:04Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2537,4 +2563,196 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type == null) {\n+            return true;\n+        }\n+        if (type.tag < TypeTags.RECORD) {\n+            return true;\n+        }\n+        switch (type.tag) {\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+                return false;\n+            }\n+        } else {\n+            if (initFunction.symbol.getReturnType().getKind() == TypeKind.ERROR) {\n+                return false;\n+            }\n+            if (!hasFillerValue(initFunction.symbol.getReturnType())) {\n+                return false;\n+            }\n+            if (!initFunction.symbol.getParameters().stream()\n+                    .allMatch(bVarSymbol -> bVarSymbol.defaultableParam == true)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * This will handle two types.\n+     *  Singleton : As singleton can have one value that value should it self be a valid fill value\n+     *  Union :\n+     *          1. if nil is a member it is the fill values\n+     *          2. else all the values should belong to same type and the default value for that type\n+     *              should be a member of the union\n+     * @param type BFiniteType union or finite\n+     * @return\n+     */\n+    private boolean checkFillerValue(BFiniteType type) {\n+        // For singleton types, that value is the implicit initial value\n+        if (type.valueSpace.size() == 1) {\n+            return true;\n+        }\n+\n+        // is first value null\n+        Iterator iterator = type.valueSpace.iterator();\n+        BLangExpression firstElement = (BLangExpression) iterator.next();\n+        if ((firstElement == null) || (firstElement.type.getKind() == TypeKind.NIL)) {\n+            return true;\n+        }\n+\n+        boolean allMembersHaveSameType = true;\n+        boolean defaultFillValuePresent = false;\n+\n+        // is first value is a valid fill value\n+        String defaultFillValue = getDefaultFillValue(firstElement);\n+        if (firstElement.toString().equals(defaultFillValue)) {\n+            defaultFillValuePresent = true;\n+        }\n+\n+        while (iterator.hasNext()) {\n+            Object value =  iterator.next();\n+            if (value == null) {\n+                return true;\n+            }\n+\n+            BType valueType = ((BLangExpression) value).type;\n+            if (valueType.getKind() == TypeKind.NIL) {\n+                return true;\n+            }\n+\n+            if (allMembersHaveSameType && !isSameType(valueType, firstElement.type)) {\n+                allMembersHaveSameType = false;\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c1d8da35d38db84786c9c1f2d6c088fc1779caa"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODEzNTEzNQ==", "bodyText": "What if at the end or after this there is a nil value. Therefore I let the loop continue. If there is nil it is the fill value.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r378135135", "createdAt": "2020-02-12T09:38:17Z", "author": {"login": "KRVPerera"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2537,4 +2563,196 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type == null) {\n+            return true;\n+        }\n+        if (type.tag < TypeTags.RECORD) {\n+            return true;\n+        }\n+        switch (type.tag) {\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+                return false;\n+            }\n+        } else {\n+            if (initFunction.symbol.getReturnType().getKind() == TypeKind.ERROR) {\n+                return false;\n+            }\n+            if (!hasFillerValue(initFunction.symbol.getReturnType())) {\n+                return false;\n+            }\n+            if (!initFunction.symbol.getParameters().stream()\n+                    .allMatch(bVarSymbol -> bVarSymbol.defaultableParam == true)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * This will handle two types.\n+     *  Singleton : As singleton can have one value that value should it self be a valid fill value\n+     *  Union :\n+     *          1. if nil is a member it is the fill values\n+     *          2. else all the values should belong to same type and the default value for that type\n+     *              should be a member of the union\n+     * @param type BFiniteType union or finite\n+     * @return\n+     */\n+    private boolean checkFillerValue(BFiniteType type) {\n+        // For singleton types, that value is the implicit initial value\n+        if (type.valueSpace.size() == 1) {\n+            return true;\n+        }\n+\n+        // is first value null\n+        Iterator iterator = type.valueSpace.iterator();\n+        BLangExpression firstElement = (BLangExpression) iterator.next();\n+        if ((firstElement == null) || (firstElement.type.getKind() == TypeKind.NIL)) {\n+            return true;\n+        }\n+\n+        boolean allMembersHaveSameType = true;\n+        boolean defaultFillValuePresent = false;\n+\n+        // is first value is a valid fill value\n+        String defaultFillValue = getDefaultFillValue(firstElement);\n+        if (firstElement.toString().equals(defaultFillValue)) {\n+            defaultFillValuePresent = true;\n+        }\n+\n+        while (iterator.hasNext()) {\n+            Object value =  iterator.next();\n+            if (value == null) {\n+                return true;\n+            }\n+\n+            BType valueType = ((BLangExpression) value).type;\n+            if (valueType.getKind() == TypeKind.NIL) {\n+                return true;\n+            }\n+\n+            if (allMembersHaveSameType && !isSameType(valueType, firstElement.type)) {\n+                allMembersHaveSameType = false;\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA0MTE5MQ=="}, "originalCommit": {"oid": "8c1d8da35d38db84786c9c1f2d6c088fc1779caa"}, "originalPosition": 140}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzODg0MjQ5OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwNTowODoxMFrOFoh6Cw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwNTowODoxMFrOFoh6Cw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA0Mjg5MQ==", "bodyText": "If this was true we would have already returned at https://github.com/ballerina-platform/ballerina-lang/pull/20749/files#diff-782094a79e6831ac57a34ad157af49c1R2678 right?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r378042891", "createdAt": "2020-02-12T05:08:10Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2537,4 +2563,196 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type == null) {\n+            return true;\n+        }\n+        if (type.tag < TypeTags.RECORD) {\n+            return true;\n+        }\n+        switch (type.tag) {\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+                return false;\n+            }\n+        } else {\n+            if (initFunction.symbol.getReturnType().getKind() == TypeKind.ERROR) {\n+                return false;\n+            }\n+            if (!hasFillerValue(initFunction.symbol.getReturnType())) {\n+                return false;\n+            }\n+            if (!initFunction.symbol.getParameters().stream()\n+                    .allMatch(bVarSymbol -> bVarSymbol.defaultableParam == true)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * This will handle two types.\n+     *  Singleton : As singleton can have one value that value should it self be a valid fill value\n+     *  Union :\n+     *          1. if nil is a member it is the fill values\n+     *          2. else all the values should belong to same type and the default value for that type\n+     *              should be a member of the union\n+     * @param type BFiniteType union or finite\n+     * @return\n+     */\n+    private boolean checkFillerValue(BFiniteType type) {\n+        // For singleton types, that value is the implicit initial value\n+        if (type.valueSpace.size() == 1) {\n+            return true;\n+        }\n+\n+        // is first value null\n+        Iterator iterator = type.valueSpace.iterator();\n+        BLangExpression firstElement = (BLangExpression) iterator.next();\n+        if ((firstElement == null) || (firstElement.type.getKind() == TypeKind.NIL)) {\n+            return true;\n+        }\n+\n+        boolean allMembersHaveSameType = true;\n+        boolean defaultFillValuePresent = false;\n+\n+        // is first value is a valid fill value\n+        String defaultFillValue = getDefaultFillValue(firstElement);\n+        if (firstElement.toString().equals(defaultFillValue)) {\n+            defaultFillValuePresent = true;\n+        }\n+\n+        while (iterator.hasNext()) {\n+            Object value =  iterator.next();\n+            if (value == null) {\n+                return true;\n+            }\n+\n+            BType valueType = ((BLangExpression) value).type;\n+            if (valueType.getKind() == TypeKind.NIL) {\n+                return true;\n+            }\n+\n+            if (allMembersHaveSameType && !isSameType(valueType, firstElement.type)) {\n+                allMembersHaveSameType = false;\n+            }\n+\n+            if (!defaultFillValuePresent && value.toString().equals(defaultFillValue)) {\n+                defaultFillValuePresent = true;\n+            }\n+        }\n+\n+        if (!allMembersHaveSameType) {\n+            return false;\n+        }\n+\n+        return defaultFillValuePresent;\n+    }\n+\n+    private boolean checkFillerValue(BUnionType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+\n+        Iterator<BType> iterator = type.getMemberTypes().iterator();\n+        BType firstMember = iterator.next();\n+        // is first value is a valid fill value\n+        if (firstMember.getKind() == TypeKind.NIL) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c1d8da35d38db84786c9c1f2d6c088fc1779caa"}, "originalPosition": 162}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzODg0MzAzOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwNTowODozOFrOFoh6Vg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwOTozODoxMVrOFoniJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA0Mjk2Ng==", "bodyText": "Again, can these be null?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r378042966", "createdAt": "2020-02-12T05:08:38Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2537,4 +2563,196 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type == null) {\n+            return true;\n+        }\n+        if (type.tag < TypeTags.RECORD) {\n+            return true;\n+        }\n+        switch (type.tag) {\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+                return false;\n+            }\n+        } else {\n+            if (initFunction.symbol.getReturnType().getKind() == TypeKind.ERROR) {\n+                return false;\n+            }\n+            if (!hasFillerValue(initFunction.symbol.getReturnType())) {\n+                return false;\n+            }\n+            if (!initFunction.symbol.getParameters().stream()\n+                    .allMatch(bVarSymbol -> bVarSymbol.defaultableParam == true)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * This will handle two types.\n+     *  Singleton : As singleton can have one value that value should it self be a valid fill value\n+     *  Union :\n+     *          1. if nil is a member it is the fill values\n+     *          2. else all the values should belong to same type and the default value for that type\n+     *              should be a member of the union\n+     * @param type BFiniteType union or finite\n+     * @return\n+     */\n+    private boolean checkFillerValue(BFiniteType type) {\n+        // For singleton types, that value is the implicit initial value\n+        if (type.valueSpace.size() == 1) {\n+            return true;\n+        }\n+\n+        // is first value null\n+        Iterator iterator = type.valueSpace.iterator();\n+        BLangExpression firstElement = (BLangExpression) iterator.next();\n+        if ((firstElement == null) || (firstElement.type.getKind() == TypeKind.NIL)) {\n+            return true;\n+        }\n+\n+        boolean allMembersHaveSameType = true;\n+        boolean defaultFillValuePresent = false;\n+\n+        // is first value is a valid fill value\n+        String defaultFillValue = getDefaultFillValue(firstElement);\n+        if (firstElement.toString().equals(defaultFillValue)) {\n+            defaultFillValuePresent = true;\n+        }\n+\n+        while (iterator.hasNext()) {\n+            Object value =  iterator.next();\n+            if (value == null) {\n+                return true;\n+            }\n+\n+            BType valueType = ((BLangExpression) value).type;\n+            if (valueType.getKind() == TypeKind.NIL) {\n+                return true;\n+            }\n+\n+            if (allMembersHaveSameType && !isSameType(valueType, firstElement.type)) {\n+                allMembersHaveSameType = false;\n+            }\n+\n+            if (!defaultFillValuePresent && value.toString().equals(defaultFillValue)) {\n+                defaultFillValuePresent = true;\n+            }\n+        }\n+\n+        if (!allMembersHaveSameType) {\n+            return false;\n+        }\n+\n+        return defaultFillValuePresent;\n+    }\n+\n+    private boolean checkFillerValue(BUnionType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+\n+        Iterator<BType> iterator = type.getMemberTypes().iterator();\n+        BType firstMember = iterator.next();\n+        // is first value is a valid fill value\n+        if (firstMember.getKind() == TypeKind.NIL) {\n+            return true;\n+        }\n+\n+        boolean allMembersHaveSameType = true;\n+        boolean defaultFillValuePresent = false;\n+\n+        // is first value is a valid fill value\n+        String defaultFillValue = getDefaultFillValue(firstMember);\n+        if (firstMember.toString().equals(defaultFillValue)) {\n+            defaultFillValuePresent = true;\n+        }\n+\n+        while (iterator.hasNext()) {\n+\n+            Object value =  iterator.next();\n+            if (value == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c1d8da35d38db84786c9c1f2d6c088fc1779caa"}, "originalPosition": 178}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODEzNTA3Ng==", "bodyText": "Let me remove. I think this should not be null", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r378135076", "createdAt": "2020-02-12T09:38:11Z", "author": {"login": "KRVPerera"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2537,4 +2563,196 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type == null) {\n+            return true;\n+        }\n+        if (type.tag < TypeTags.RECORD) {\n+            return true;\n+        }\n+        switch (type.tag) {\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+                return false;\n+            }\n+        } else {\n+            if (initFunction.symbol.getReturnType().getKind() == TypeKind.ERROR) {\n+                return false;\n+            }\n+            if (!hasFillerValue(initFunction.symbol.getReturnType())) {\n+                return false;\n+            }\n+            if (!initFunction.symbol.getParameters().stream()\n+                    .allMatch(bVarSymbol -> bVarSymbol.defaultableParam == true)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * This will handle two types.\n+     *  Singleton : As singleton can have one value that value should it self be a valid fill value\n+     *  Union :\n+     *          1. if nil is a member it is the fill values\n+     *          2. else all the values should belong to same type and the default value for that type\n+     *              should be a member of the union\n+     * @param type BFiniteType union or finite\n+     * @return\n+     */\n+    private boolean checkFillerValue(BFiniteType type) {\n+        // For singleton types, that value is the implicit initial value\n+        if (type.valueSpace.size() == 1) {\n+            return true;\n+        }\n+\n+        // is first value null\n+        Iterator iterator = type.valueSpace.iterator();\n+        BLangExpression firstElement = (BLangExpression) iterator.next();\n+        if ((firstElement == null) || (firstElement.type.getKind() == TypeKind.NIL)) {\n+            return true;\n+        }\n+\n+        boolean allMembersHaveSameType = true;\n+        boolean defaultFillValuePresent = false;\n+\n+        // is first value is a valid fill value\n+        String defaultFillValue = getDefaultFillValue(firstElement);\n+        if (firstElement.toString().equals(defaultFillValue)) {\n+            defaultFillValuePresent = true;\n+        }\n+\n+        while (iterator.hasNext()) {\n+            Object value =  iterator.next();\n+            if (value == null) {\n+                return true;\n+            }\n+\n+            BType valueType = ((BLangExpression) value).type;\n+            if (valueType.getKind() == TypeKind.NIL) {\n+                return true;\n+            }\n+\n+            if (allMembersHaveSameType && !isSameType(valueType, firstElement.type)) {\n+                allMembersHaveSameType = false;\n+            }\n+\n+            if (!defaultFillValuePresent && value.toString().equals(defaultFillValue)) {\n+                defaultFillValuePresent = true;\n+            }\n+        }\n+\n+        if (!allMembersHaveSameType) {\n+            return false;\n+        }\n+\n+        return defaultFillValuePresent;\n+    }\n+\n+    private boolean checkFillerValue(BUnionType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+\n+        Iterator<BType> iterator = type.getMemberTypes().iterator();\n+        BType firstMember = iterator.next();\n+        // is first value is a valid fill value\n+        if (firstMember.getKind() == TypeKind.NIL) {\n+            return true;\n+        }\n+\n+        boolean allMembersHaveSameType = true;\n+        boolean defaultFillValuePresent = false;\n+\n+        // is first value is a valid fill value\n+        String defaultFillValue = getDefaultFillValue(firstMember);\n+        if (firstMember.toString().equals(defaultFillValue)) {\n+            defaultFillValuePresent = true;\n+        }\n+\n+        while (iterator.hasNext()) {\n+\n+            Object value =  iterator.next();\n+            if (value == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA0Mjk2Ng=="}, "originalCommit": {"oid": "8c1d8da35d38db84786c9c1f2d6c088fc1779caa"}, "originalPosition": 178}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzODg1MjA0OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwNToxNjoxNVrOFoh_yQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwNToxNjoxNVrOFoh_yQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA0NDM2MQ==", "bodyText": "Is this set for record fields too? IINM, we usually check only a flag.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r378044361", "createdAt": "2020-02-12T05:16:15Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2537,4 +2563,196 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type == null) {\n+            return true;\n+        }\n+        if (type.tag < TypeTags.RECORD) {\n+            return true;\n+        }\n+        switch (type.tag) {\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+                return false;\n+            }\n+        } else {\n+            if (initFunction.symbol.getReturnType().getKind() == TypeKind.ERROR) {\n+                return false;\n+            }\n+            if (!hasFillerValue(initFunction.symbol.getReturnType())) {\n+                return false;\n+            }\n+            if (!initFunction.symbol.getParameters().stream()\n+                    .allMatch(bVarSymbol -> bVarSymbol.defaultableParam == true)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * This will handle two types.\n+     *  Singleton : As singleton can have one value that value should it self be a valid fill value\n+     *  Union :\n+     *          1. if nil is a member it is the fill values\n+     *          2. else all the values should belong to same type and the default value for that type\n+     *              should be a member of the union\n+     * @param type BFiniteType union or finite\n+     * @return\n+     */\n+    private boolean checkFillerValue(BFiniteType type) {\n+        // For singleton types, that value is the implicit initial value\n+        if (type.valueSpace.size() == 1) {\n+            return true;\n+        }\n+\n+        // is first value null\n+        Iterator iterator = type.valueSpace.iterator();\n+        BLangExpression firstElement = (BLangExpression) iterator.next();\n+        if ((firstElement == null) || (firstElement.type.getKind() == TypeKind.NIL)) {\n+            return true;\n+        }\n+\n+        boolean allMembersHaveSameType = true;\n+        boolean defaultFillValuePresent = false;\n+\n+        // is first value is a valid fill value\n+        String defaultFillValue = getDefaultFillValue(firstElement);\n+        if (firstElement.toString().equals(defaultFillValue)) {\n+            defaultFillValuePresent = true;\n+        }\n+\n+        while (iterator.hasNext()) {\n+            Object value =  iterator.next();\n+            if (value == null) {\n+                return true;\n+            }\n+\n+            BType valueType = ((BLangExpression) value).type;\n+            if (valueType.getKind() == TypeKind.NIL) {\n+                return true;\n+            }\n+\n+            if (allMembersHaveSameType && !isSameType(valueType, firstElement.type)) {\n+                allMembersHaveSameType = false;\n+            }\n+\n+            if (!defaultFillValuePresent && value.toString().equals(defaultFillValue)) {\n+                defaultFillValuePresent = true;\n+            }\n+        }\n+\n+        if (!allMembersHaveSameType) {\n+            return false;\n+        }\n+\n+        return defaultFillValuePresent;\n+    }\n+\n+    private boolean checkFillerValue(BUnionType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+\n+        Iterator<BType> iterator = type.getMemberTypes().iterator();\n+        BType firstMember = iterator.next();\n+        // is first value is a valid fill value\n+        if (firstMember.getKind() == TypeKind.NIL) {\n+            return true;\n+        }\n+\n+        boolean allMembersHaveSameType = true;\n+        boolean defaultFillValuePresent = false;\n+\n+        // is first value is a valid fill value\n+        String defaultFillValue = getDefaultFillValue(firstMember);\n+        if (firstMember.toString().equals(defaultFillValue)) {\n+            defaultFillValuePresent = true;\n+        }\n+\n+        while (iterator.hasNext()) {\n+\n+            Object value =  iterator.next();\n+            if (value == null) {\n+                return true;\n+            }\n+\n+            if (allMembersHaveSameType && !isSameType(firstMember, iterator.next())) {\n+                allMembersHaveSameType = false;\n+            }\n+\n+            if (!defaultFillValuePresent && value.toString().equals(defaultFillValue)) {\n+                defaultFillValuePresent = true;\n+            }\n+        }\n+\n+        if (!allMembersHaveSameType) {\n+            return false;\n+        }\n+        return defaultFillValuePresent;\n+    }\n+\n+    private boolean checkFillerValue(BRecordType type) {\n+        for (BField field : type.fields) {\n+            if (field.symbol.defaultableParam) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c1d8da35d38db84786c9c1f2d6c088fc1779caa"}, "originalPosition": 199}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzODg1NDY5OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwNToxODoyNlrOFoiBcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwOTo0MTo0OVrOFpwtjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA0NDc4NA==", "bodyText": "IINM, this is not correct. According to the spec, fill member should be done only for lists.\ntype Foo record {\n   string s;\n};\n\nFoo[2] arr = [];\nThis should still fail IMO.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r378044784", "createdAt": "2020-02-12T05:18:26Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2537,4 +2563,196 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type == null) {\n+            return true;\n+        }\n+        if (type.tag < TypeTags.RECORD) {\n+            return true;\n+        }\n+        switch (type.tag) {\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+                return false;\n+            }\n+        } else {\n+            if (initFunction.symbol.getReturnType().getKind() == TypeKind.ERROR) {\n+                return false;\n+            }\n+            if (!hasFillerValue(initFunction.symbol.getReturnType())) {\n+                return false;\n+            }\n+            if (!initFunction.symbol.getParameters().stream()\n+                    .allMatch(bVarSymbol -> bVarSymbol.defaultableParam == true)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * This will handle two types.\n+     *  Singleton : As singleton can have one value that value should it self be a valid fill value\n+     *  Union :\n+     *          1. if nil is a member it is the fill values\n+     *          2. else all the values should belong to same type and the default value for that type\n+     *              should be a member of the union\n+     * @param type BFiniteType union or finite\n+     * @return\n+     */\n+    private boolean checkFillerValue(BFiniteType type) {\n+        // For singleton types, that value is the implicit initial value\n+        if (type.valueSpace.size() == 1) {\n+            return true;\n+        }\n+\n+        // is first value null\n+        Iterator iterator = type.valueSpace.iterator();\n+        BLangExpression firstElement = (BLangExpression) iterator.next();\n+        if ((firstElement == null) || (firstElement.type.getKind() == TypeKind.NIL)) {\n+            return true;\n+        }\n+\n+        boolean allMembersHaveSameType = true;\n+        boolean defaultFillValuePresent = false;\n+\n+        // is first value is a valid fill value\n+        String defaultFillValue = getDefaultFillValue(firstElement);\n+        if (firstElement.toString().equals(defaultFillValue)) {\n+            defaultFillValuePresent = true;\n+        }\n+\n+        while (iterator.hasNext()) {\n+            Object value =  iterator.next();\n+            if (value == null) {\n+                return true;\n+            }\n+\n+            BType valueType = ((BLangExpression) value).type;\n+            if (valueType.getKind() == TypeKind.NIL) {\n+                return true;\n+            }\n+\n+            if (allMembersHaveSameType && !isSameType(valueType, firstElement.type)) {\n+                allMembersHaveSameType = false;\n+            }\n+\n+            if (!defaultFillValuePresent && value.toString().equals(defaultFillValue)) {\n+                defaultFillValuePresent = true;\n+            }\n+        }\n+\n+        if (!allMembersHaveSameType) {\n+            return false;\n+        }\n+\n+        return defaultFillValuePresent;\n+    }\n+\n+    private boolean checkFillerValue(BUnionType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+\n+        Iterator<BType> iterator = type.getMemberTypes().iterator();\n+        BType firstMember = iterator.next();\n+        // is first value is a valid fill value\n+        if (firstMember.getKind() == TypeKind.NIL) {\n+            return true;\n+        }\n+\n+        boolean allMembersHaveSameType = true;\n+        boolean defaultFillValuePresent = false;\n+\n+        // is first value is a valid fill value\n+        String defaultFillValue = getDefaultFillValue(firstMember);\n+        if (firstMember.toString().equals(defaultFillValue)) {\n+            defaultFillValuePresent = true;\n+        }\n+\n+        while (iterator.hasNext()) {\n+\n+            Object value =  iterator.next();\n+            if (value == null) {\n+                return true;\n+            }\n+\n+            if (allMembersHaveSameType && !isSameType(firstMember, iterator.next())) {\n+                allMembersHaveSameType = false;\n+            }\n+\n+            if (!defaultFillValuePresent && value.toString().equals(defaultFillValue)) {\n+                defaultFillValuePresent = true;\n+            }\n+        }\n+\n+        if (!allMembersHaveSameType) {\n+            return false;\n+        }\n+        return defaultFillValuePresent;\n+    }\n+\n+    private boolean checkFillerValue(BRecordType type) {\n+        for (BField field : type.fields) {\n+            if (field.symbol.defaultableParam) {\n+                continue;\n+            }\n+            if (!hasFillerValue(field.type)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c1d8da35d38db84786c9c1f2d6c088fc1779caa"}, "originalPosition": 202}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMzNDAzMA==", "bodyText": "Commit f21bca4\nshould address this.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r379334030", "createdAt": "2020-02-14T09:41:49Z", "author": {"login": "KRVPerera"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2537,4 +2563,196 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type == null) {\n+            return true;\n+        }\n+        if (type.tag < TypeTags.RECORD) {\n+            return true;\n+        }\n+        switch (type.tag) {\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+                return false;\n+            }\n+        } else {\n+            if (initFunction.symbol.getReturnType().getKind() == TypeKind.ERROR) {\n+                return false;\n+            }\n+            if (!hasFillerValue(initFunction.symbol.getReturnType())) {\n+                return false;\n+            }\n+            if (!initFunction.symbol.getParameters().stream()\n+                    .allMatch(bVarSymbol -> bVarSymbol.defaultableParam == true)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * This will handle two types.\n+     *  Singleton : As singleton can have one value that value should it self be a valid fill value\n+     *  Union :\n+     *          1. if nil is a member it is the fill values\n+     *          2. else all the values should belong to same type and the default value for that type\n+     *              should be a member of the union\n+     * @param type BFiniteType union or finite\n+     * @return\n+     */\n+    private boolean checkFillerValue(BFiniteType type) {\n+        // For singleton types, that value is the implicit initial value\n+        if (type.valueSpace.size() == 1) {\n+            return true;\n+        }\n+\n+        // is first value null\n+        Iterator iterator = type.valueSpace.iterator();\n+        BLangExpression firstElement = (BLangExpression) iterator.next();\n+        if ((firstElement == null) || (firstElement.type.getKind() == TypeKind.NIL)) {\n+            return true;\n+        }\n+\n+        boolean allMembersHaveSameType = true;\n+        boolean defaultFillValuePresent = false;\n+\n+        // is first value is a valid fill value\n+        String defaultFillValue = getDefaultFillValue(firstElement);\n+        if (firstElement.toString().equals(defaultFillValue)) {\n+            defaultFillValuePresent = true;\n+        }\n+\n+        while (iterator.hasNext()) {\n+            Object value =  iterator.next();\n+            if (value == null) {\n+                return true;\n+            }\n+\n+            BType valueType = ((BLangExpression) value).type;\n+            if (valueType.getKind() == TypeKind.NIL) {\n+                return true;\n+            }\n+\n+            if (allMembersHaveSameType && !isSameType(valueType, firstElement.type)) {\n+                allMembersHaveSameType = false;\n+            }\n+\n+            if (!defaultFillValuePresent && value.toString().equals(defaultFillValue)) {\n+                defaultFillValuePresent = true;\n+            }\n+        }\n+\n+        if (!allMembersHaveSameType) {\n+            return false;\n+        }\n+\n+        return defaultFillValuePresent;\n+    }\n+\n+    private boolean checkFillerValue(BUnionType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+\n+        Iterator<BType> iterator = type.getMemberTypes().iterator();\n+        BType firstMember = iterator.next();\n+        // is first value is a valid fill value\n+        if (firstMember.getKind() == TypeKind.NIL) {\n+            return true;\n+        }\n+\n+        boolean allMembersHaveSameType = true;\n+        boolean defaultFillValuePresent = false;\n+\n+        // is first value is a valid fill value\n+        String defaultFillValue = getDefaultFillValue(firstMember);\n+        if (firstMember.toString().equals(defaultFillValue)) {\n+            defaultFillValuePresent = true;\n+        }\n+\n+        while (iterator.hasNext()) {\n+\n+            Object value =  iterator.next();\n+            if (value == null) {\n+                return true;\n+            }\n+\n+            if (allMembersHaveSameType && !isSameType(firstMember, iterator.next())) {\n+                allMembersHaveSameType = false;\n+            }\n+\n+            if (!defaultFillValuePresent && value.toString().equals(defaultFillValue)) {\n+                defaultFillValuePresent = true;\n+            }\n+        }\n+\n+        if (!allMembersHaveSameType) {\n+            return false;\n+        }\n+        return defaultFillValuePresent;\n+    }\n+\n+    private boolean checkFillerValue(BRecordType type) {\n+        for (BField field : type.fields) {\n+            if (field.symbol.defaultableParam) {\n+                continue;\n+            }\n+            if (!hasFillerValue(field.type)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA0NDc4NA=="}, "originalCommit": {"oid": "8c1d8da35d38db84786c9c1f2d6c088fc1779caa"}, "originalPosition": 202}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MjYxMTY5OnYy", "diffSide": "LEFT", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/values/ArrayValueImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QxMTo0OTozNVrOFqhu9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QxMTo0OTozNVrOFqhu9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDEzNzIwNQ==", "bodyText": "Comments are invalid now?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r380137205", "createdAt": "2020-02-17T11:49:35Z", "author": {"login": "MaryamZi"}, "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/values/ArrayValueImpl.java", "diffHunk": "@@ -842,13 +850,15 @@ protected void rangeCheck(long index, int size) {\n     protected void fillerValueCheck(int index, int size) {\n         // if there has been values added beyond the current index, that means filler values\n         // has already been checked. Therefore no need to check again.\n-        if (this.size >= index) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d15f2572961cd44fb9146eabfa3b3131e70de7e"}, "originalPosition": 93}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MjY1MTU4OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/model/types/BFiniteType.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QxMjowNDoxNVrOFqiHRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QxMjowNDoxNVrOFqiHRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE0MzQzMA==", "bodyText": "Shouldn't the getter return an unmodifiable set too?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r380143430", "createdAt": "2020-02-17T12:04:15Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/model/types/BFiniteType.java", "diffHunk": "@@ -37,9 +37,11 @@\n  */\n public class BFiniteType extends BType implements FiniteType {\n \n-    public Set<BLangExpression> valueSpace;\n+    private Set<BLangExpression> valueSpace;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d15f2572961cd44fb9146eabfa3b3131e70de7e"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MjY2MDgwOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QxMjowNzozOFrOFqiNAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QxMjowNzozOFrOFqiNAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE0NDg5Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @since 1.1.2\n          \n          \n            \n                 * @since 1.2.0", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r380144896", "createdAt": "2020-02-17T12:07:38Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -109,6 +110,32 @@\n     private Names names;\n     private int finiteTypeCount = 0;\n \n+    /**\n+     * Keep filler value for basic types in String format.\n+     *\n+     * @since 1.1.2", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d15f2572961cd44fb9146eabfa3b3131e70de7e"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MjY3Mzk3OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QxMjoxMjo0NlrOFqiVbw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQwNjo0ODoxOVrOFq29Dg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE0NzA1NQ==", "bodyText": "This can be\n    return (type.tsymbol.flags & Flags.ABSTRACT) != Flags.ABSTRACT;\nright?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r380147055", "createdAt": "2020-02-17T12:12:46Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2537,4 +2564,166 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type.tag < TypeTags.RECORD) {\n+            return true;\n+        }\n+        switch (type.tag) {\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+                return false;\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d15f2572961cd44fb9146eabfa3b3131e70de7e"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDQ4NDg3OA==", "bodyText": "Even if the object is not an abstract object we still need to do some checks or parameters in the initializer function. But I changed the logic giving importance to abstraction check. Can you check the new logic whether I got your point correctly? ff0acc0", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r380484878", "createdAt": "2020-02-18T06:48:19Z", "author": {"login": "KRVPerera"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2537,4 +2564,166 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type.tag < TypeTags.RECORD) {\n+            return true;\n+        }\n+        switch (type.tag) {\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+                return false;\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE0NzA1NQ=="}, "originalCommit": {"oid": "3d15f2572961cd44fb9146eabfa3b3131e70de7e"}, "originalPosition": 155}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MjY3NjExOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QxMjoxMzoyN1rOFqiWmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QxMjoxMzoyN1rOFqiWmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE0NzM1Mg==", "bodyText": "We can then remove this else and move out this block?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r380147352", "createdAt": "2020-02-17T12:13:27Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2537,4 +2564,166 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type.tag < TypeTags.RECORD) {\n+            return true;\n+        }\n+        switch (type.tag) {\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+                return false;\n+            }\n+        } else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d15f2572961cd44fb9146eabfa3b3131e70de7e"}, "originalPosition": 156}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MjY4MDI5OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QxMjoxNDo0NlrOFqiZBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QxMjoxNDo0NlrOFqiZBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE0Nzk3NQ==", "bodyText": "IINM, this can never be just error. It's either nil or a union with error. Just checking initFunction.symbol.getReturnType().getKind() != TypeKind.NIL should be enough?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r380147975", "createdAt": "2020-02-17T12:14:46Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2537,4 +2564,166 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type.tag < TypeTags.RECORD) {\n+            return true;\n+        }\n+        switch (type.tag) {\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+                return false;\n+            }\n+        } else {\n+            if (initFunction.symbol.getReturnType().getKind() == TypeKind.ERROR) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d15f2572961cd44fb9146eabfa3b3131e70de7e"}, "originalPosition": 157}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MjcyMTIyOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QxMjoyODo1NFrOFqixeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QxMjoyODo1NFrOFqixeg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE1NDIzNA==", "bodyText": "IMO, we can remove this.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r380154234", "createdAt": "2020-02-17T12:28:54Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2537,4 +2564,166 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type.tag < TypeTags.RECORD) {\n+            return true;\n+        }\n+        switch (type.tag) {\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+                return false;\n+            }\n+        } else {\n+            if (initFunction.symbol.getReturnType().getKind() == TypeKind.ERROR) {\n+                return false;\n+            }\n+            if (initFunction.symbol.getReturnType().getKind() != TypeKind.NIL) {\n+                return false;\n+            }\n+            for (BVarSymbol bVarSymbol : initFunction.symbol.getParameters()) {\n+                if (!bVarSymbol.defaultableParam) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * This will handle two types. Singleton : As singleton can have one value that value should it self be a valid fill\n+     * value Union : 1. if nil is a member it is the fill values 2. else all the values should belong to same type and\n+     * the default value for that type should be a member of the union precondition : value space should have at least\n+     * one element\n+     *\n+     * @param type BFiniteType union or finite\n+     * @return boolean whether type has a valid filler value or not\n+     */\n+    private boolean checkFillerValue(BFiniteType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+\n+        // For singleton types, that value is the implicit initial value\n+        if (type.getValueSpace().size() == 1) {\n+            return true;\n+        }\n+\n+        Iterator iterator = type.getValueSpace().iterator();\n+        if (!iterator.hasNext()) { // sanity check this cannot be\n+            return false;\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d15f2572961cd44fb9146eabfa3b3131e70de7e"}, "originalPosition": 194}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MjczMTc2OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QxMjozMjozOVrOFqi3uw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QxMjozMjozOVrOFqi3uw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE1NTgzNQ==", "bodyText": "Can we extract out firstElement.type to a variable?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r380155835", "createdAt": "2020-02-17T12:32:39Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2537,4 +2564,166 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type.tag < TypeTags.RECORD) {\n+            return true;\n+        }\n+        switch (type.tag) {\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+                return false;\n+            }\n+        } else {\n+            if (initFunction.symbol.getReturnType().getKind() == TypeKind.ERROR) {\n+                return false;\n+            }\n+            if (initFunction.symbol.getReturnType().getKind() != TypeKind.NIL) {\n+                return false;\n+            }\n+            for (BVarSymbol bVarSymbol : initFunction.symbol.getParameters()) {\n+                if (!bVarSymbol.defaultableParam) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * This will handle two types. Singleton : As singleton can have one value that value should it self be a valid fill\n+     * value Union : 1. if nil is a member it is the fill values 2. else all the values should belong to same type and\n+     * the default value for that type should be a member of the union precondition : value space should have at least\n+     * one element\n+     *\n+     * @param type BFiniteType union or finite\n+     * @return boolean whether type has a valid filler value or not\n+     */\n+    private boolean checkFillerValue(BFiniteType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+\n+        // For singleton types, that value is the implicit initial value\n+        if (type.getValueSpace().size() == 1) {\n+            return true;\n+        }\n+\n+        Iterator iterator = type.getValueSpace().iterator();\n+        if (!iterator.hasNext()) { // sanity check this cannot be\n+            return false;\n+        }\n+        boolean defaultFillValuePresent = false;\n+\n+        BLangExpression firstElement = (BLangExpression) iterator.next();\n+        String defaultFillValue = getDefaultFillValue(firstElement);\n+        if (firstElement.toString().equals(defaultFillValue)) {\n+            defaultFillValuePresent = true;\n+        }\n+\n+        while (iterator.hasNext()) {\n+            Object value =  iterator.next();\n+            BType valueType = ((BLangExpression) value).type;\n+            if (!isSameType(valueType, firstElement.type)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d15f2572961cd44fb9146eabfa3b3131e70de7e"}, "originalPosition": 206}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2MzIwMTcyOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwNToxMjo1N1rOFsE4fg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxNjowOTo1MlrOFsZlEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc2MTY2Mg==", "bodyText": "Can we validate if this works for constants?\nconst ZERO = 0;\n\ntype Foo ZERO|1|2;", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r381761662", "createdAt": "2020-02-20T05:12:57Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2537,4 +2564,160 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type.tag < TypeTags.RECORD) {\n+            return true;\n+        }\n+        switch (type.tag) {\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+            return false;\n+        }\n+\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            return true;\n+        }\n+        if (initFunction.symbol.getReturnType().getKind() != TypeKind.NIL) {\n+            return false;\n+        }\n+\n+        for (BVarSymbol bVarSymbol : initFunction.symbol.getParameters()) {\n+            if (!bVarSymbol.defaultableParam) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * This will handle two types. Singleton : As singleton can have one value that value should it self be a valid fill\n+     * value Union : 1. if nil is a member it is the fill values 2. else all the values should belong to same type and\n+     * the default value for that type should be a member of the union precondition : value space should have at least\n+     * one element\n+     *\n+     * @param type BFiniteType union or finite\n+     * @return boolean whether type has a valid filler value or not\n+     */\n+    private boolean checkFillerValue(BFiniteType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+\n+        // For singleton types, that value is the implicit initial value\n+        if (type.getValueSpace().size() == 1) {\n+            return true;\n+        }\n+\n+        boolean defaultFillValuePresent = false;\n+\n+        Iterator iterator = type.getValueSpace().iterator();\n+        BLangExpression firstElement = (BLangExpression) iterator.next();\n+        BType firstElementType = firstElement.type;\n+        String defaultFillValue = getDefaultFillValue(firstElement);\n+        if (firstElement.toString().equals(defaultFillValue)) {\n+            defaultFillValuePresent = true;\n+        }\n+\n+        while (iterator.hasNext()) {\n+            Object value =  iterator.next();\n+            BType valueType = ((BLangExpression) value).type;\n+            if (!isSameType(valueType, firstElementType)) {\n+                return false;\n+            }\n+            if (!defaultFillValuePresent && value.toString().equals(defaultFillValue)) {\n+                defaultFillValuePresent = true;\n+            }\n+        }\n+        return defaultFillValuePresent;\n+    }\n+\n+    private boolean checkFillerValue(BUnionType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+        Iterator<BType> iterator = type.getMemberTypes().iterator();\n+        BType firstMember = iterator.next();\n+        boolean defaultFillValuePresent = false;\n+\n+        // is first value is a valid fill value\n+        String defaultFillValue = getDefaultFillValue(firstMember);\n+        if (firstMember.toString().equals(defaultFillValue)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff0acc05501340c2064c3bb1b3211752955782ad"}, "originalPosition": 223}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjEwMDc1Mw==", "bodyText": "fixed test case added\n7d525fc", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r382100753", "createdAt": "2020-02-20T16:09:52Z", "author": {"login": "KRVPerera"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2537,4 +2564,160 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type.tag < TypeTags.RECORD) {\n+            return true;\n+        }\n+        switch (type.tag) {\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+            return false;\n+        }\n+\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            return true;\n+        }\n+        if (initFunction.symbol.getReturnType().getKind() != TypeKind.NIL) {\n+            return false;\n+        }\n+\n+        for (BVarSymbol bVarSymbol : initFunction.symbol.getParameters()) {\n+            if (!bVarSymbol.defaultableParam) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * This will handle two types. Singleton : As singleton can have one value that value should it self be a valid fill\n+     * value Union : 1. if nil is a member it is the fill values 2. else all the values should belong to same type and\n+     * the default value for that type should be a member of the union precondition : value space should have at least\n+     * one element\n+     *\n+     * @param type BFiniteType union or finite\n+     * @return boolean whether type has a valid filler value or not\n+     */\n+    private boolean checkFillerValue(BFiniteType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+\n+        // For singleton types, that value is the implicit initial value\n+        if (type.getValueSpace().size() == 1) {\n+            return true;\n+        }\n+\n+        boolean defaultFillValuePresent = false;\n+\n+        Iterator iterator = type.getValueSpace().iterator();\n+        BLangExpression firstElement = (BLangExpression) iterator.next();\n+        BType firstElementType = firstElement.type;\n+        String defaultFillValue = getDefaultFillValue(firstElement);\n+        if (firstElement.toString().equals(defaultFillValue)) {\n+            defaultFillValuePresent = true;\n+        }\n+\n+        while (iterator.hasNext()) {\n+            Object value =  iterator.next();\n+            BType valueType = ((BLangExpression) value).type;\n+            if (!isSameType(valueType, firstElementType)) {\n+                return false;\n+            }\n+            if (!defaultFillValuePresent && value.toString().equals(defaultFillValue)) {\n+                defaultFillValuePresent = true;\n+            }\n+        }\n+        return defaultFillValuePresent;\n+    }\n+\n+    private boolean checkFillerValue(BUnionType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+        Iterator<BType> iterator = type.getMemberTypes().iterator();\n+        BType firstMember = iterator.next();\n+        boolean defaultFillValuePresent = false;\n+\n+        // is first value is a valid fill value\n+        String defaultFillValue = getDefaultFillValue(firstMember);\n+        if (firstMember.toString().equals(defaultFillValue)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc2MTY2Mg=="}, "originalCommit": {"oid": "ff0acc05501340c2064c3bb1b3211752955782ad"}, "originalPosition": 223}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2MzIwODM5OnYy", "diffSide": "RIGHT", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/values/ArrayValueImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwNToxNDo0MVrOFsE7yg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxNTo0Njo0NVrOFsYp8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc2MjUwNg==", "bodyText": "This fillerValueCheck() method is called for each and every add operation. So could this be an overhead?\nSince hasFillerValue needs to be calculated only once for a given type, can we move this flag to the array-type, and have it calculated only once during the initialisation of the type?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r381762506", "createdAt": "2020-02-20T05:14:41Z", "author": {"login": "SupunS"}, "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/values/ArrayValueImpl.java", "diffHunk": "@@ -840,15 +848,15 @@ protected void rangeCheck(long index, int size) {\n \n     @Override\n     protected void fillerValueCheck(int index, int size) {\n-        // if there has been values added beyond the current index, that means filler values\n-        // has already been checked. Therefore no need to check again.\n-        if (this.size >= index) {\n-            return;\n+        if (!hasFillerValue.isPresent()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff0acc05501340c2064c3bb1b3211752955782ad"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjA4NTYxOA==", "bodyText": "fixed by c0998bf", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r382085618", "createdAt": "2020-02-20T15:46:45Z", "author": {"login": "KRVPerera"}, "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/values/ArrayValueImpl.java", "diffHunk": "@@ -840,15 +848,15 @@ protected void rangeCheck(long index, int size) {\n \n     @Override\n     protected void fillerValueCheck(int index, int size) {\n-        // if there has been values added beyond the current index, that means filler values\n-        // has already been checked. Therefore no need to check again.\n-        if (this.size >= index) {\n-            return;\n+        if (!hasFillerValue.isPresent()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc2MjUwNg=="}, "originalCommit": {"oid": "ff0acc05501340c2064c3bb1b3211752955782ad"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2MzI4Njg2OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwNTozNTozNVrOFsFjWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwNjozNToyN1rOFss78Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc3MjYzNQ==", "bodyText": "Wondering if keeping this in the String format is the best approach? Can't we use the value itself and compare, based on the assumption that they will only be used for comparison with either literals or constant refs?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r381772635", "createdAt": "2020-02-20T05:35:35Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2537,4 +2564,160 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type.tag < TypeTags.RECORD) {\n+            return true;\n+        }\n+        switch (type.tag) {\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+            return false;\n+        }\n+\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            return true;\n+        }\n+        if (initFunction.symbol.getReturnType().getKind() != TypeKind.NIL) {\n+            return false;\n+        }\n+\n+        for (BVarSymbol bVarSymbol : initFunction.symbol.getParameters()) {\n+            if (!bVarSymbol.defaultableParam) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * This will handle two types. Singleton : As singleton can have one value that value should it self be a valid fill\n+     * value Union : 1. if nil is a member it is the fill values 2. else all the values should belong to same type and\n+     * the default value for that type should be a member of the union precondition : value space should have at least\n+     * one element\n+     *\n+     * @param type BFiniteType union or finite\n+     * @return boolean whether type has a valid filler value or not\n+     */\n+    private boolean checkFillerValue(BFiniteType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+\n+        // For singleton types, that value is the implicit initial value\n+        if (type.getValueSpace().size() == 1) {\n+            return true;\n+        }\n+\n+        boolean defaultFillValuePresent = false;\n+\n+        Iterator iterator = type.getValueSpace().iterator();\n+        BLangExpression firstElement = (BLangExpression) iterator.next();\n+        BType firstElementType = firstElement.type;\n+        String defaultFillValue = getDefaultFillValue(firstElement);\n+        if (firstElement.toString().equals(defaultFillValue)) {\n+            defaultFillValuePresent = true;\n+        }\n+\n+        while (iterator.hasNext()) {\n+            Object value =  iterator.next();\n+            BType valueType = ((BLangExpression) value).type;\n+            if (!isSameType(valueType, firstElementType)) {\n+                return false;\n+            }\n+            if (!defaultFillValuePresent && value.toString().equals(defaultFillValue)) {\n+                defaultFillValuePresent = true;\n+            }\n+        }\n+        return defaultFillValuePresent;\n+    }\n+\n+    private boolean checkFillerValue(BUnionType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+        Iterator<BType> iterator = type.getMemberTypes().iterator();\n+        BType firstMember = iterator.next();\n+        boolean defaultFillValuePresent = false;\n+\n+        // is first value is a valid fill value\n+        String defaultFillValue = getDefaultFillValue(firstMember);\n+        if (firstMember.toString().equals(defaultFillValue)) {\n+            defaultFillValuePresent = true;\n+        }\n+\n+        while (iterator.hasNext()) {\n+            Object value = iterator.next();\n+\n+            if (!isSameType(firstMember, iterator.next())) {\n+                return false;\n+            }\n+\n+            if (!defaultFillValuePresent && value.toString().equals(defaultFillValue)) {\n+                defaultFillValuePresent = true;\n+            }\n+        }\n+        return defaultFillValuePresent;\n+    }\n+\n+    private boolean checkFillerValue(BRecordType type) {\n+        for (BField field : type.fields) {\n+            if (Symbols.isFlagOn(field.symbol.flags, Flags.OPTIONAL)) {\n+                continue;\n+            }\n+            if (Symbols.isFlagOn(field.symbol.flags, Flags.REQUIRED)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private boolean checkFillerValue(BArrayType type) {\n+        return hasFillerValue(type.eType);\n+    }\n+\n+    private String getDefaultFillValue(BLangExpression expr) {\n+        return getDefaultFillValue(expr.type);\n+    }\n+\n+    private String getDefaultFillValue(BType type) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff0acc05501340c2064c3bb1b3211752955782ad"}, "originalPosition": 261}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE0Nzk4NQ==", "bodyText": "If the integer is '5' the valid fill value should be '0' for an int. Need to get the default value or implicit default value for int type which is zero.\nI have added a negative test case for this.\nTest Case:  https://github.com/ballerina-platform/ballerina-lang/pull/20749/files#diff-65f99a2264d6173185afec0d71e151c6R63\nError Message: https://github.com/ballerina-platform/ballerina-lang/pull/20749/files#diff-7319ccb85e364b3233fb96f11c424f29R212", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r382147985", "createdAt": "2020-02-20T17:28:38Z", "author": {"login": "KRVPerera"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2537,4 +2564,160 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type.tag < TypeTags.RECORD) {\n+            return true;\n+        }\n+        switch (type.tag) {\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+            return false;\n+        }\n+\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            return true;\n+        }\n+        if (initFunction.symbol.getReturnType().getKind() != TypeKind.NIL) {\n+            return false;\n+        }\n+\n+        for (BVarSymbol bVarSymbol : initFunction.symbol.getParameters()) {\n+            if (!bVarSymbol.defaultableParam) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * This will handle two types. Singleton : As singleton can have one value that value should it self be a valid fill\n+     * value Union : 1. if nil is a member it is the fill values 2. else all the values should belong to same type and\n+     * the default value for that type should be a member of the union precondition : value space should have at least\n+     * one element\n+     *\n+     * @param type BFiniteType union or finite\n+     * @return boolean whether type has a valid filler value or not\n+     */\n+    private boolean checkFillerValue(BFiniteType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+\n+        // For singleton types, that value is the implicit initial value\n+        if (type.getValueSpace().size() == 1) {\n+            return true;\n+        }\n+\n+        boolean defaultFillValuePresent = false;\n+\n+        Iterator iterator = type.getValueSpace().iterator();\n+        BLangExpression firstElement = (BLangExpression) iterator.next();\n+        BType firstElementType = firstElement.type;\n+        String defaultFillValue = getDefaultFillValue(firstElement);\n+        if (firstElement.toString().equals(defaultFillValue)) {\n+            defaultFillValuePresent = true;\n+        }\n+\n+        while (iterator.hasNext()) {\n+            Object value =  iterator.next();\n+            BType valueType = ((BLangExpression) value).type;\n+            if (!isSameType(valueType, firstElementType)) {\n+                return false;\n+            }\n+            if (!defaultFillValuePresent && value.toString().equals(defaultFillValue)) {\n+                defaultFillValuePresent = true;\n+            }\n+        }\n+        return defaultFillValuePresent;\n+    }\n+\n+    private boolean checkFillerValue(BUnionType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+        Iterator<BType> iterator = type.getMemberTypes().iterator();\n+        BType firstMember = iterator.next();\n+        boolean defaultFillValuePresent = false;\n+\n+        // is first value is a valid fill value\n+        String defaultFillValue = getDefaultFillValue(firstMember);\n+        if (firstMember.toString().equals(defaultFillValue)) {\n+            defaultFillValuePresent = true;\n+        }\n+\n+        while (iterator.hasNext()) {\n+            Object value = iterator.next();\n+\n+            if (!isSameType(firstMember, iterator.next())) {\n+                return false;\n+            }\n+\n+            if (!defaultFillValuePresent && value.toString().equals(defaultFillValue)) {\n+                defaultFillValuePresent = true;\n+            }\n+        }\n+        return defaultFillValuePresent;\n+    }\n+\n+    private boolean checkFillerValue(BRecordType type) {\n+        for (BField field : type.fields) {\n+            if (Symbols.isFlagOn(field.symbol.flags, Flags.OPTIONAL)) {\n+                continue;\n+            }\n+            if (Symbols.isFlagOn(field.symbol.flags, Flags.REQUIRED)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private boolean checkFillerValue(BArrayType type) {\n+        return hasFillerValue(type.eType);\n+    }\n+\n+    private String getDefaultFillValue(BLangExpression expr) {\n+        return getDefaultFillValue(expr.type);\n+    }\n+\n+    private String getDefaultFillValue(BType type) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc3MjYzNQ=="}, "originalCommit": {"oid": "ff0acc05501340c2064c3bb1b3211752955782ad"}, "originalPosition": 261}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQxNzkwNQ==", "bodyText": "Note: The code is written similar to run-time check. \n  \n    \n      ballerina-lang/bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeChecker.java\n    \n    \n         Line 1787\n      in\n      7e0d467\n    \n    \n    \n    \n\n        \n          \n           if (firstElement instanceof String) { \n        \n    \n  \n\n\nThe plan is to replace string enum with objects and also in accordance with spec. This may require calling initialiser methods to create zero value objects for every type. Should handle all basic types. Finally, it will be like src.equals(target)", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r382417905", "createdAt": "2020-02-21T06:35:27Z", "author": {"login": "KRVPerera"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2537,4 +2564,160 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type.tag < TypeTags.RECORD) {\n+            return true;\n+        }\n+        switch (type.tag) {\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+            return false;\n+        }\n+\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            return true;\n+        }\n+        if (initFunction.symbol.getReturnType().getKind() != TypeKind.NIL) {\n+            return false;\n+        }\n+\n+        for (BVarSymbol bVarSymbol : initFunction.symbol.getParameters()) {\n+            if (!bVarSymbol.defaultableParam) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * This will handle two types. Singleton : As singleton can have one value that value should it self be a valid fill\n+     * value Union : 1. if nil is a member it is the fill values 2. else all the values should belong to same type and\n+     * the default value for that type should be a member of the union precondition : value space should have at least\n+     * one element\n+     *\n+     * @param type BFiniteType union or finite\n+     * @return boolean whether type has a valid filler value or not\n+     */\n+    private boolean checkFillerValue(BFiniteType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+\n+        // For singleton types, that value is the implicit initial value\n+        if (type.getValueSpace().size() == 1) {\n+            return true;\n+        }\n+\n+        boolean defaultFillValuePresent = false;\n+\n+        Iterator iterator = type.getValueSpace().iterator();\n+        BLangExpression firstElement = (BLangExpression) iterator.next();\n+        BType firstElementType = firstElement.type;\n+        String defaultFillValue = getDefaultFillValue(firstElement);\n+        if (firstElement.toString().equals(defaultFillValue)) {\n+            defaultFillValuePresent = true;\n+        }\n+\n+        while (iterator.hasNext()) {\n+            Object value =  iterator.next();\n+            BType valueType = ((BLangExpression) value).type;\n+            if (!isSameType(valueType, firstElementType)) {\n+                return false;\n+            }\n+            if (!defaultFillValuePresent && value.toString().equals(defaultFillValue)) {\n+                defaultFillValuePresent = true;\n+            }\n+        }\n+        return defaultFillValuePresent;\n+    }\n+\n+    private boolean checkFillerValue(BUnionType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+        Iterator<BType> iterator = type.getMemberTypes().iterator();\n+        BType firstMember = iterator.next();\n+        boolean defaultFillValuePresent = false;\n+\n+        // is first value is a valid fill value\n+        String defaultFillValue = getDefaultFillValue(firstMember);\n+        if (firstMember.toString().equals(defaultFillValue)) {\n+            defaultFillValuePresent = true;\n+        }\n+\n+        while (iterator.hasNext()) {\n+            Object value = iterator.next();\n+\n+            if (!isSameType(firstMember, iterator.next())) {\n+                return false;\n+            }\n+\n+            if (!defaultFillValuePresent && value.toString().equals(defaultFillValue)) {\n+                defaultFillValuePresent = true;\n+            }\n+        }\n+        return defaultFillValuePresent;\n+    }\n+\n+    private boolean checkFillerValue(BRecordType type) {\n+        for (BField field : type.fields) {\n+            if (Symbols.isFlagOn(field.symbol.flags, Flags.OPTIONAL)) {\n+                continue;\n+            }\n+            if (Symbols.isFlagOn(field.symbol.flags, Flags.REQUIRED)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private boolean checkFillerValue(BArrayType type) {\n+        return hasFillerValue(type.eType);\n+    }\n+\n+    private String getDefaultFillValue(BLangExpression expr) {\n+        return getDefaultFillValue(expr.type);\n+    }\n+\n+    private String getDefaultFillValue(BType type) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc3MjYzNQ=="}, "originalCommit": {"oid": "ff0acc05501340c2064c3bb1b3211752955782ad"}, "originalPosition": 261}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2MzMwNzkyOnYy", "diffSide": "RIGHT", "path": "tests/jballerina-unit-test/src/test/java/org/ballerinalang/test/statements/arrays/SealedArrayTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwNTo0MToxOFrOFsFubg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxNjowNTo0MFrOFsZbQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc3NTQ3MA==", "bodyText": "Shall we remove the extra lines?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r381775470", "createdAt": "2020-02-20T05:41:18Z", "author": {"login": "MaryamZi"}, "path": "tests/jballerina-unit-test/src/test/java/org/ballerinalang/test/statements/arrays/SealedArrayTest.java", "diffHunk": "@@ -36,177 +36,117 @@\n  */\n public class SealedArrayTest {\n \n-    private CompileResult compileResult, resultNegative, semanticsNegative;\n+    private CompileResult compileResult, resultNegative, semanticsNegative, listExprNegative;\n \n     @BeforeClass\n     public void setup() {\n         compileResult = BCompileUtil.compile(\"test-src/statements/arrays/sealed-array.bal\");\n         resultNegative = BCompileUtil.compile(\"test-src/statements/arrays/sealed-array-negative.bal\");\n+        listExprNegative = BCompileUtil.compile(\"test-src/statements/arrays/sealed_array_listexpr_negative.bal\");\n         semanticsNegative = BCompileUtil.compile(\"test-src/statements/arrays/sealed-array-semantics-negative\" +\n                 \".bal\");\n     }\n \n     @Test\n     public void testCreateIntegerSealedArray() {\n-        BValue[] returnValues = BRunUtil.invoke(compileResult, \"createIntSealedArray\");\n-        Assert.assertFalse(\n-                returnValues == null || returnValues.length == 0 || returnValues[0] == null, \"Invalid Return Values.\");\n-        Assert.assertEquals(((BInteger) returnValues[0]).intValue(), 5, \"Length didn't match\");\n+        BRunUtil.invoke(compileResult, \"createIntSealedArray\");\n \n-        returnValues = BRunUtil.invoke(compileResult, \"createIntSealedArrayWithLabel\");\n-        Assert.assertFalse(\n-                returnValues == null || returnValues.length == 0 || returnValues[0] == null, \"Invalid Return Values.\");\n-        Assert.assertEquals(((BInteger) returnValues[0]).intValue(), 5, \"Length didn't match\");\n+        BRunUtil.invoke(compileResult, \"createIntAutoFilledSealedArray\");\n \n-        returnValues = BRunUtil.invoke(compileResult, \"createIntDefaultSealedArray\");\n-        Assert.assertFalse(\n-                returnValues == null || returnValues.length == 0 || returnValues[0] == null, \"Invalid Return Values.\");\n-        Assert.assertEquals(returnValues[0].stringValue(), \"[0, 0, 0, 0, 0]\", \"Length didn't match\");\n-        Assert.assertEquals(((BInteger) returnValues[1]).intValue(), 5, \"Length didn't match\");\n+        BRunUtil.invoke(compileResult, \"createIntSealedArrayWithLabel\");\n+\n+        BRunUtil.invoke(compileResult, \"createIntDefaultSealedArray\");\n     }\n \n     @Test\n     public void testCreateBooleanSealedArray() {\n-        BValue[] returnValues = BRunUtil.invoke(compileResult, \"createBoolSealedArray\");\n-        Assert.assertFalse(\n-                returnValues == null || returnValues.length == 0 || returnValues[0] == null, \"Invalid Return Values.\");\n-        Assert.assertEquals(((BInteger) returnValues[0]).intValue(), 5, \"Length didn't match\");\n+        BRunUtil.invoke(compileResult, \"createBoolSealedArray\");\n \n-        returnValues = BRunUtil.invoke(compileResult, \"createBoolSealedArrayWithLabel\");\n-        Assert.assertFalse(\n-                returnValues == null || returnValues.length == 0 || returnValues[0] == null, \"Invalid Return Values.\");\n-        Assert.assertEquals(((BInteger) returnValues[0]).intValue(), 5, \"Length didn't match\");\n+        BRunUtil.invoke(compileResult, \"createBoolAutoFilledSealedArray\");\n \n-        returnValues = BRunUtil.invoke(compileResult, \"createBoolDefaultSealedArray\");\n-        Assert.assertFalse(\n-                returnValues == null || returnValues.length == 0 || returnValues[0] == null, \"Invalid Return Values.\");\n-        Assert.assertEquals(returnValues[0].stringValue(),\n-                \"[false, false, false, false, false]\", \"Length didn't match\");\n-        Assert.assertEquals(((BInteger) returnValues[1]).intValue(), 5, \"Length didn't match\");\n+        BRunUtil.invoke(compileResult, \"createBoolSealedArrayWithLabel\");\n+\n+        BRunUtil.invoke(compileResult, \"createBoolDefaultSealedArray\");\n     }\n \n     @Test\n     public void testCreateFloatSealedArray() {\n-        BValue[] returnValues = BRunUtil.invoke(compileResult, \"createFloatSealedArray\");\n-        Assert.assertFalse(\n-                returnValues == null || returnValues.length == 0 || returnValues[0] == null, \"Invalid Return Values.\");\n-        Assert.assertEquals(((BInteger) returnValues[0]).intValue(), 5, \"Length didn't match\");\n+        BRunUtil.invoke(compileResult, \"createFloatSealedArray\");\n \n-        returnValues = BRunUtil.invoke(compileResult, \"createFloatSealedArrayWithLabel\");\n-        Assert.assertFalse(\n-                returnValues == null || returnValues.length == 0 || returnValues[0] == null, \"Invalid Return Values.\");\n-        Assert.assertEquals(((BInteger) returnValues[0]).intValue(), 5, \"Length didn't match\");\n+        BRunUtil.invoke(compileResult, \"createFloatAutoFilledSealedArray\");\n \n-        returnValues = BRunUtil.invoke(compileResult, \"createFloatDefaultSealedArray\");\n-        Assert.assertFalse(\n-                returnValues == null || returnValues.length == 0 || returnValues[0] == null, \"Invalid Return Values.\");\n-        Assert.assertEquals(returnValues[0].stringValue(), \"[0.0, 0.0, 0.0, 0.0, 0.0]\", \"Length didn't match\");\n-        Assert.assertEquals(((BInteger) returnValues[1]).intValue(), 5, \"Length didn't match\");\n+        BRunUtil.invoke(compileResult, \"createFloatSealedArrayWithLabel\");\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff0acc05501340c2064c3bb1b3211752955782ad"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjA5ODI0MQ==", "bodyText": "Fixed ab2afb7", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r382098241", "createdAt": "2020-02-20T16:05:40Z", "author": {"login": "KRVPerera"}, "path": "tests/jballerina-unit-test/src/test/java/org/ballerinalang/test/statements/arrays/SealedArrayTest.java", "diffHunk": "@@ -36,177 +36,117 @@\n  */\n public class SealedArrayTest {\n \n-    private CompileResult compileResult, resultNegative, semanticsNegative;\n+    private CompileResult compileResult, resultNegative, semanticsNegative, listExprNegative;\n \n     @BeforeClass\n     public void setup() {\n         compileResult = BCompileUtil.compile(\"test-src/statements/arrays/sealed-array.bal\");\n         resultNegative = BCompileUtil.compile(\"test-src/statements/arrays/sealed-array-negative.bal\");\n+        listExprNegative = BCompileUtil.compile(\"test-src/statements/arrays/sealed_array_listexpr_negative.bal\");\n         semanticsNegative = BCompileUtil.compile(\"test-src/statements/arrays/sealed-array-semantics-negative\" +\n                 \".bal\");\n     }\n \n     @Test\n     public void testCreateIntegerSealedArray() {\n-        BValue[] returnValues = BRunUtil.invoke(compileResult, \"createIntSealedArray\");\n-        Assert.assertFalse(\n-                returnValues == null || returnValues.length == 0 || returnValues[0] == null, \"Invalid Return Values.\");\n-        Assert.assertEquals(((BInteger) returnValues[0]).intValue(), 5, \"Length didn't match\");\n+        BRunUtil.invoke(compileResult, \"createIntSealedArray\");\n \n-        returnValues = BRunUtil.invoke(compileResult, \"createIntSealedArrayWithLabel\");\n-        Assert.assertFalse(\n-                returnValues == null || returnValues.length == 0 || returnValues[0] == null, \"Invalid Return Values.\");\n-        Assert.assertEquals(((BInteger) returnValues[0]).intValue(), 5, \"Length didn't match\");\n+        BRunUtil.invoke(compileResult, \"createIntAutoFilledSealedArray\");\n \n-        returnValues = BRunUtil.invoke(compileResult, \"createIntDefaultSealedArray\");\n-        Assert.assertFalse(\n-                returnValues == null || returnValues.length == 0 || returnValues[0] == null, \"Invalid Return Values.\");\n-        Assert.assertEquals(returnValues[0].stringValue(), \"[0, 0, 0, 0, 0]\", \"Length didn't match\");\n-        Assert.assertEquals(((BInteger) returnValues[1]).intValue(), 5, \"Length didn't match\");\n+        BRunUtil.invoke(compileResult, \"createIntSealedArrayWithLabel\");\n+\n+        BRunUtil.invoke(compileResult, \"createIntDefaultSealedArray\");\n     }\n \n     @Test\n     public void testCreateBooleanSealedArray() {\n-        BValue[] returnValues = BRunUtil.invoke(compileResult, \"createBoolSealedArray\");\n-        Assert.assertFalse(\n-                returnValues == null || returnValues.length == 0 || returnValues[0] == null, \"Invalid Return Values.\");\n-        Assert.assertEquals(((BInteger) returnValues[0]).intValue(), 5, \"Length didn't match\");\n+        BRunUtil.invoke(compileResult, \"createBoolSealedArray\");\n \n-        returnValues = BRunUtil.invoke(compileResult, \"createBoolSealedArrayWithLabel\");\n-        Assert.assertFalse(\n-                returnValues == null || returnValues.length == 0 || returnValues[0] == null, \"Invalid Return Values.\");\n-        Assert.assertEquals(((BInteger) returnValues[0]).intValue(), 5, \"Length didn't match\");\n+        BRunUtil.invoke(compileResult, \"createBoolAutoFilledSealedArray\");\n \n-        returnValues = BRunUtil.invoke(compileResult, \"createBoolDefaultSealedArray\");\n-        Assert.assertFalse(\n-                returnValues == null || returnValues.length == 0 || returnValues[0] == null, \"Invalid Return Values.\");\n-        Assert.assertEquals(returnValues[0].stringValue(),\n-                \"[false, false, false, false, false]\", \"Length didn't match\");\n-        Assert.assertEquals(((BInteger) returnValues[1]).intValue(), 5, \"Length didn't match\");\n+        BRunUtil.invoke(compileResult, \"createBoolSealedArrayWithLabel\");\n+\n+        BRunUtil.invoke(compileResult, \"createBoolDefaultSealedArray\");\n     }\n \n     @Test\n     public void testCreateFloatSealedArray() {\n-        BValue[] returnValues = BRunUtil.invoke(compileResult, \"createFloatSealedArray\");\n-        Assert.assertFalse(\n-                returnValues == null || returnValues.length == 0 || returnValues[0] == null, \"Invalid Return Values.\");\n-        Assert.assertEquals(((BInteger) returnValues[0]).intValue(), 5, \"Length didn't match\");\n+        BRunUtil.invoke(compileResult, \"createFloatSealedArray\");\n \n-        returnValues = BRunUtil.invoke(compileResult, \"createFloatSealedArrayWithLabel\");\n-        Assert.assertFalse(\n-                returnValues == null || returnValues.length == 0 || returnValues[0] == null, \"Invalid Return Values.\");\n-        Assert.assertEquals(((BInteger) returnValues[0]).intValue(), 5, \"Length didn't match\");\n+        BRunUtil.invoke(compileResult, \"createFloatAutoFilledSealedArray\");\n \n-        returnValues = BRunUtil.invoke(compileResult, \"createFloatDefaultSealedArray\");\n-        Assert.assertFalse(\n-                returnValues == null || returnValues.length == 0 || returnValues[0] == null, \"Invalid Return Values.\");\n-        Assert.assertEquals(returnValues[0].stringValue(), \"[0.0, 0.0, 0.0, 0.0, 0.0]\", \"Length didn't match\");\n-        Assert.assertEquals(((BInteger) returnValues[1]).intValue(), 5, \"Length didn't match\");\n+        BRunUtil.invoke(compileResult, \"createFloatSealedArrayWithLabel\");\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc3NTQ3MA=="}, "originalCommit": {"oid": "ff0acc05501340c2064c3bb1b3211752955782ad"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2MzMwODk5OnYy", "diffSide": "RIGHT", "path": "tests/jballerina-unit-test/src/test/java/org/ballerinalang/test/statements/arrays/SealedArrayTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwNTo0MTozNFrOFsFu6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxNjowMzoyN1rOFsZWEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc3NTU5Mw==", "bodyText": "Invalid comment?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r381775593", "createdAt": "2020-02-20T05:41:34Z", "author": {"login": "MaryamZi"}, "path": "tests/jballerina-unit-test/src/test/java/org/ballerinalang/test/statements/arrays/SealedArrayTest.java", "diffHunk": "@@ -282,51 +222,99 @@ public void testNegativeSealedArrays() {\n         BAssertUtil.validateError(resultNegative, 0, \"variable 'sealedArray1' is not initialized\", 19, 5);\n     }\n \n+    // TODO : uncomment", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff0acc05501340c2064c3bb1b3211752955782ad"}, "originalPosition": 231}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjA5NjkxNA==", "bodyText": "Fixed b76a0ff", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r382096914", "createdAt": "2020-02-20T16:03:27Z", "author": {"login": "KRVPerera"}, "path": "tests/jballerina-unit-test/src/test/java/org/ballerinalang/test/statements/arrays/SealedArrayTest.java", "diffHunk": "@@ -282,51 +222,99 @@ public void testNegativeSealedArrays() {\n         BAssertUtil.validateError(resultNegative, 0, \"variable 'sealedArray1' is not initialized\", 19, 5);\n     }\n \n+    // TODO : uncomment", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc3NTU5Mw=="}, "originalCommit": {"oid": "ff0acc05501340c2064c3bb1b3211752955782ad"}, "originalPosition": 231}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2MzMxMDY3OnYy", "diffSide": "RIGHT", "path": "tests/jballerina-unit-test/src/test/java/org/ballerinalang/test/statements/arrays/SealedArrayTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwNTo0MjowOFrOFsFv7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxNjowMzoxNVrOFsZVoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc3NTg1NA==", "bodyText": "Can we have these in a single line?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r381775854", "createdAt": "2020-02-20T05:42:08Z", "author": {"login": "MaryamZi"}, "path": "tests/jballerina-unit-test/src/test/java/org/ballerinalang/test/statements/arrays/SealedArrayTest.java", "diffHunk": "@@ -282,51 +222,99 @@ public void testNegativeSealedArrays() {\n         BAssertUtil.validateError(resultNegative, 0, \"variable 'sealedArray1' is not initialized\", 19, 5);\n     }\n \n+    // TODO : uncomment\n+    @Test()\n+    public void testNegativeAutoFillSealedArray() {\n+        Assert.assertEquals(listExprNegative.getErrorCount(), 11);\n+        BAssertUtil.validateError(listExprNegative, 0,\n+                                  \"invalid usage of list constructor: type 'Person[5]' does not have a filler value\",\n+                                  24,\n+                                  19);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff0acc05501340c2064c3bb1b3211752955782ad"}, "originalPosition": 238}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjA5NjgwMA==", "bodyText": "Fixed b76a0ff", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r382096800", "createdAt": "2020-02-20T16:03:15Z", "author": {"login": "KRVPerera"}, "path": "tests/jballerina-unit-test/src/test/java/org/ballerinalang/test/statements/arrays/SealedArrayTest.java", "diffHunk": "@@ -282,51 +222,99 @@ public void testNegativeSealedArrays() {\n         BAssertUtil.validateError(resultNegative, 0, \"variable 'sealedArray1' is not initialized\", 19, 5);\n     }\n \n+    // TODO : uncomment\n+    @Test()\n+    public void testNegativeAutoFillSealedArray() {\n+        Assert.assertEquals(listExprNegative.getErrorCount(), 11);\n+        BAssertUtil.validateError(listExprNegative, 0,\n+                                  \"invalid usage of list constructor: type 'Person[5]' does not have a filler value\",\n+                                  24,\n+                                  19);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc3NTg1NA=="}, "originalCommit": {"oid": "ff0acc05501340c2064c3bb1b3211752955782ad"}, "originalPosition": 238}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2MzM0MDI4OnYy", "diffSide": "RIGHT", "path": "tests/jballerina-unit-test/src/test/java/org/ballerinalang/test/statements/arrays/ArrayFillTestRuntime.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwNTo1MDoxMVrOFsF_RQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxNjowMzowOVrOFsZVXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc3OTc4MQ==", "bodyText": "Incorrect version?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r381779781", "createdAt": "2020-02-20T05:50:11Z", "author": {"login": "MaryamZi"}, "path": "tests/jballerina-unit-test/src/test/java/org/ballerinalang/test/statements/arrays/ArrayFillTestRuntime.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.ballerinalang.test.statements.arrays;\n+\n+import org.ballerinalang.test.util.BCompileUtil;\n+import org.ballerinalang.test.util.CompileResult;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+/**\n+ * Test cases for filling the elements of the array with its type's implicit initial value.\n+ *\n+ * @since 1.1.1", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff0acc05501340c2064c3bb1b3211752955782ad"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjA5NjczMw==", "bodyText": "fixed b76a0ff", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r382096733", "createdAt": "2020-02-20T16:03:09Z", "author": {"login": "KRVPerera"}, "path": "tests/jballerina-unit-test/src/test/java/org/ballerinalang/test/statements/arrays/ArrayFillTestRuntime.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.ballerinalang.test.statements.arrays;\n+\n+import org.ballerinalang.test.util.BCompileUtil;\n+import org.ballerinalang.test.util.CompileResult;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+/**\n+ * Test cases for filling the elements of the array with its type's implicit initial value.\n+ *\n+ * @since 1.1.1", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc3OTc4MQ=="}, "originalCommit": {"oid": "ff0acc05501340c2064c3bb1b3211752955782ad"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2MzM1NDc4OnYy", "diffSide": "RIGHT", "path": "tests/jballerina-unit-test/src/test/resources/test-src/expressions/listconstructor/list_constructor.bal", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwNTo1MzozMlrOFsGGMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxNjowMjo1MVrOFsZUow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc4MTU1NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                int [8] arrOfEightInts = [1, 2, 3];\n          \n          \n            \n                int[8] arrOfEightInts = [1, 2, 3];", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r381781555", "createdAt": "2020-02-20T05:53:32Z", "author": {"login": "MaryamZi"}, "path": "tests/jballerina-unit-test/src/test/resources/test-src/expressions/listconstructor/list_constructor.bal", "diffHunk": "@@ -35,3 +35,18 @@ function testListConstructorExpr() returns boolean {\n         && fooArr[0] == \"DDD\"\n         && fooArr[1] == 444;\n }\n+\n+function testListConstructorAutoFillExpr() {\n+    int [8] arrOfEightInts = [1, 2, 3];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff0acc05501340c2064c3bb1b3211752955782ad"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjA5NjU0Nw==", "bodyText": "Fixed b76a0ff", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r382096547", "createdAt": "2020-02-20T16:02:51Z", "author": {"login": "KRVPerera"}, "path": "tests/jballerina-unit-test/src/test/resources/test-src/expressions/listconstructor/list_constructor.bal", "diffHunk": "@@ -35,3 +35,18 @@ function testListConstructorExpr() returns boolean {\n         && fooArr[0] == \"DDD\"\n         && fooArr[1] == 444;\n }\n+\n+function testListConstructorAutoFillExpr() {\n+    int [8] arrOfEightInts = [1, 2, 3];", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc4MTU1NQ=="}, "originalCommit": {"oid": "ff0acc05501340c2064c3bb1b3211752955782ad"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2MzM1ODU4OnYy", "diffSide": "RIGHT", "path": "tests/jballerina-unit-test/src/test/resources/test-src/statements/arrays/array-fill-test.bal", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwNTo1NDoyM1rOFsGICQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxNjowMDozMlrOFsZO-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc4MjAyNQ==", "bodyText": "Can't we write these tests in Ballerina itself?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r381782025", "createdAt": "2020-02-20T05:54:23Z", "author": {"login": "MaryamZi"}, "path": "tests/jballerina-unit-test/src/test/resources/test-src/statements/arrays/array-fill-test.bal", "diffHunk": "@@ -70,6 +70,13 @@ function testTupleArrayFill(int index) returns [string, int][] {\n     return ar;\n }\n \n+function testTupleSealedArrayFill(int index) returns [string, int][] {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff0acc05501340c2064c3bb1b3211752955782ad"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjA5NTA5OQ==", "bodyText": "They are written in a way to pass an index value from and call each method from java. But yes we can refactor the whole file.  Shall we do it in a different PR.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r382095099", "createdAt": "2020-02-20T16:00:32Z", "author": {"login": "KRVPerera"}, "path": "tests/jballerina-unit-test/src/test/resources/test-src/statements/arrays/array-fill-test.bal", "diffHunk": "@@ -70,6 +70,13 @@ function testTupleArrayFill(int index) returns [string, int][] {\n     return ar;\n }\n \n+function testTupleSealedArrayFill(int index) returns [string, int][] {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc4MjAyNQ=="}, "originalCommit": {"oid": "ff0acc05501340c2064c3bb1b3211752955782ad"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2MzM4NDU0OnYy", "diffSide": "RIGHT", "path": "tests/jballerina-unit-test/src/test/resources/test-src/statements/arrays/array-fill-test.bal", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwNjowMDo1N1rOFsGU8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxNjowMjozNFrOFsZUAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc4NTMyOQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Person p = {name:\"John\", age:25};\n          \n          \n            \n                Person p = {name: \"John\", age: 25};", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r381785329", "createdAt": "2020-02-20T06:00:57Z", "author": {"login": "MaryamZi"}, "path": "tests/jballerina-unit-test/src/test/resources/test-src/statements/arrays/array-fill-test.bal", "diffHunk": "@@ -150,6 +157,14 @@ function testAnyArrayFill(int index) returns any[] {\n     return ar;\n }\n \n+function testAnySealedArrayFill(int index) returns any[] {\n+    Person p = {name:\"John\", age:25};", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff0acc05501340c2064c3bb1b3211752955782ad"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjA5NjM4NA==", "bodyText": "fixed b76a0ff", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r382096384", "createdAt": "2020-02-20T16:02:34Z", "author": {"login": "KRVPerera"}, "path": "tests/jballerina-unit-test/src/test/resources/test-src/statements/arrays/array-fill-test.bal", "diffHunk": "@@ -150,6 +157,14 @@ function testAnyArrayFill(int index) returns any[] {\n     return ar;\n }\n \n+function testAnySealedArrayFill(int index) returns any[] {\n+    Person p = {name:\"John\", age:25};", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc4NTMyOQ=="}, "originalCommit": {"oid": "ff0acc05501340c2064c3bb1b3211752955782ad"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2MzM5MTczOnYy", "diffSide": "RIGHT", "path": "tests/jballerina-unit-test/src/test/resources/test-src/statements/arrays/array-test.bal", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwNjowMjo1NVrOFsGYiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwNjowMjo1NVrOFsGYiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc4NjI1MQ==", "bodyText": "This is not used?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r381786251", "createdAt": "2020-02-20T06:02:55Z", "author": {"login": "MaryamZi"}, "path": "tests/jballerina-unit-test/src/test/resources/test-src/statements/arrays/array-test.bal", "diffHunk": "@@ -153,3 +153,23 @@ function testGetFromFrozenArray() returns int {\n \n     return -1;\n }\n+\n+type Age object {\n+    public int age;\n+    public function __init(int age) {\n+    \t self.age = age;\n+    }\n+};\n+\n+function testObjectDynamicArrayFilling() {\n+    Age[] y = [];\n+    y[0] = new(5);\n+    y[1] = new(5);\n+}\n+\n+function assertArrayLengthPanic(int expected, any[] arr, string message = \"Array length did not match\") {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff0acc05501340c2064c3bb1b3211752955782ad"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2MzM5MzI5OnYy", "diffSide": "RIGHT", "path": "tests/jballerina-unit-test/src/test/resources/test-src/statements/arrays/array-test.bal", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwNjowMzoxNlrOFsGZTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxNzoxNzoxM1rOFscFIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc4NjQ0NA==", "bodyText": "Is this test complete/called?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r381786444", "createdAt": "2020-02-20T06:03:16Z", "author": {"login": "MaryamZi"}, "path": "tests/jballerina-unit-test/src/test/resources/test-src/statements/arrays/array-test.bal", "diffHunk": "@@ -153,3 +153,23 @@ function testGetFromFrozenArray() returns int {\n \n     return -1;\n }\n+\n+type Age object {\n+    public int age;\n+    public function __init(int age) {\n+    \t self.age = age;\n+    }\n+};\n+\n+function testObjectDynamicArrayFilling() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff0acc05501340c2064c3bb1b3211752955782ad"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE0MTcyOA==", "bodyText": "Fixed 6469ab1#diff-73b31fb7a29b74dcbbff2be6c403b505R216", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r382141728", "createdAt": "2020-02-20T17:17:13Z", "author": {"login": "KRVPerera"}, "path": "tests/jballerina-unit-test/src/test/resources/test-src/statements/arrays/array-test.bal", "diffHunk": "@@ -153,3 +153,23 @@ function testGetFromFrozenArray() returns int {\n \n     return -1;\n }\n+\n+type Age object {\n+    public int age;\n+    public function __init(int age) {\n+    \t self.age = age;\n+    }\n+};\n+\n+function testObjectDynamicArrayFilling() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc4NjQ0NA=="}, "originalCommit": {"oid": "ff0acc05501340c2064c3bb1b3211752955782ad"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2MzQyODcyOnYy", "diffSide": "RIGHT", "path": "tests/jballerina-unit-test/src/test/resources/test-src/statements/arrays/sealed_array_listexpr_negative.bal", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwNjoxMjoxMlrOFsGq8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxNzowNTozOVrOFsbslA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc5MDk2Mw==", "bodyText": "The names are not quite clear IMO. :)", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r381790963", "createdAt": "2020-02-20T06:12:12Z", "author": {"login": "MaryamZi"}, "path": "tests/jballerina-unit-test/src/test/resources/test-src/statements/arrays/sealed_array_listexpr_negative.bal", "diffHunk": "@@ -0,0 +1,113 @@\n+// Copyright (c) 2020 WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+//\n+// WSO2 Inc. licenses this file to you under the Apache License,\n+// Version 2.0 (the \"License\"); you may not use this file except\n+// in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+type Person abstract object {\n+    public int age;\n+    function getFullName() returns string;\n+};\n+\n+// [0] cannot initialize abstract objects\n+function createAbstractObjectArray() {\n+    Person[5] x = [];\n+    Person p1 = x[2];\n+    p1.age = 20;\n+}\n+\n+// [1] cannot create multi dimensional arrays of abstract objects\n+function createAbstractObjectEmptyArray() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff0acc05501340c2064c3bb1b3211752955782ad"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjEzNTQ0NA==", "bodyText": "Fixed", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r382135444", "createdAt": "2020-02-20T17:05:39Z", "author": {"login": "KRVPerera"}, "path": "tests/jballerina-unit-test/src/test/resources/test-src/statements/arrays/sealed_array_listexpr_negative.bal", "diffHunk": "@@ -0,0 +1,113 @@\n+// Copyright (c) 2020 WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+//\n+// WSO2 Inc. licenses this file to you under the Apache License,\n+// Version 2.0 (the \"License\"); you may not use this file except\n+// in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+type Person abstract object {\n+    public int age;\n+    function getFullName() returns string;\n+};\n+\n+// [0] cannot initialize abstract objects\n+function createAbstractObjectArray() {\n+    Person[5] x = [];\n+    Person p1 = x[2];\n+    p1.age = 20;\n+}\n+\n+// [1] cannot create multi dimensional arrays of abstract objects\n+function createAbstractObjectEmptyArray() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc5MDk2Mw=="}, "originalCommit": {"oid": "ff0acc05501340c2064c3bb1b3211752955782ad"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2MzQ5Nzk5OnYy", "diffSide": "RIGHT", "path": "tests/jballerina-unit-test/src/test/resources/test-src/statements/arrays/sealed_array_listexpr_negative.bal", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwNjoyOTozOFrOFsHOJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxNzowNToxNVrOFsbrwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc5OTk3Mg==", "bodyText": "This shouldn't fail right?\nPerson[5][] means 5 arrays of open Person arrays (Person[])? So for the members, [] is a valid constructor?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r381799972", "createdAt": "2020-02-20T06:29:38Z", "author": {"login": "MaryamZi"}, "path": "tests/jballerina-unit-test/src/test/resources/test-src/statements/arrays/sealed_array_listexpr_negative.bal", "diffHunk": "@@ -0,0 +1,113 @@\n+// Copyright (c) 2020 WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+//\n+// WSO2 Inc. licenses this file to you under the Apache License,\n+// Version 2.0 (the \"License\"); you may not use this file except\n+// in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+type Person abstract object {\n+    public int age;\n+    function getFullName() returns string;\n+};\n+\n+// [0] cannot initialize abstract objects\n+function createAbstractObjectArray() {\n+    Person[5] x = [];\n+    Person p1 = x[2];\n+    p1.age = 20;\n+}\n+\n+// [1] cannot create multi dimensional arrays of abstract objects\n+function createAbstractObjectEmptyArray() {\n+    Person[5][] y = [];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff0acc05501340c2064c3bb1b3211752955782ad"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjEzNTIzNA==", "bodyText": "Fixed by a40950b", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r382135234", "createdAt": "2020-02-20T17:05:15Z", "author": {"login": "KRVPerera"}, "path": "tests/jballerina-unit-test/src/test/resources/test-src/statements/arrays/sealed_array_listexpr_negative.bal", "diffHunk": "@@ -0,0 +1,113 @@\n+// Copyright (c) 2020 WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+//\n+// WSO2 Inc. licenses this file to you under the Apache License,\n+// Version 2.0 (the \"License\"); you may not use this file except\n+// in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+type Person abstract object {\n+    public int age;\n+    function getFullName() returns string;\n+};\n+\n+// [0] cannot initialize abstract objects\n+function createAbstractObjectArray() {\n+    Person[5] x = [];\n+    Person p1 = x[2];\n+    p1.age = 20;\n+}\n+\n+// [1] cannot create multi dimensional arrays of abstract objects\n+function createAbstractObjectEmptyArray() {\n+    Person[5][] y = [];", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc5OTk3Mg=="}, "originalCommit": {"oid": "ff0acc05501340c2064c3bb1b3211752955782ad"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2NzMxNjYxOnYy", "diffSide": "RIGHT", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/values/ArrayValueImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwNDo1NToxMlrOFsrq_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwNjoyMTo1MVrOFsswHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM5NzE4MQ==", "bodyText": "Do we need to check this here?\nIsn't fillValues always called after fillerValueCheck?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r382397181", "createdAt": "2020-02-21T04:55:12Z", "author": {"login": "MaryamZi"}, "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/values/ArrayValueImpl.java", "diffHunk": "@@ -808,8 +813,9 @@ protected void fillValues(int index) {\n             case TypeTags.BOOLEAN_TAG:\n                 return;\n             default:\n-                Arrays.fill(refValues, size, index, elementType.getZeroValue());\n-\n+                if (arrayType.hasFillerValue()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17f429daf9d5785fbeee7d411c55b2c892bda422"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQxNDg3Ng==", "bodyText": "This is not true for code coming from desugar.\nAs an example.\n     AbstractPersonObject[5][] y = [];\n     AbstractPersonObject e1 = new Employee(\"John\", \"Doe\");\n     y[0] = [e1];\n     AbstractPersonObject[][5] r = [];\n     r[0] = [e1, e1, e1, e1, e1];\n\nr[0] = [e1, e1, e1, e1, e1] expands by first creating a sealed array. Then adding values.\nAbstractPersonObject[5] = [] \n\nThis is not allowed we cannot fill this by 5 AbstractPersonObject s. If user write this code it will give a compiler error . But since this is tool generated implementation we cannot error out this.\nfillerValueCheck error out only if there is a need for filling. Consecutive inserts should not fail too which is guranteed by index > size condition. Since this array size is already 5 as generated by desugar fillerValueCheck at runtime will not give an error.\nBir Dump:\nhttps://gist.github.com/KRVPerera/92dec4c3fd1eee166ba88dd891dd1163", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r382414876", "createdAt": "2020-02-21T06:21:51Z", "author": {"login": "KRVPerera"}, "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/values/ArrayValueImpl.java", "diffHunk": "@@ -808,8 +813,9 @@ protected void fillValues(int index) {\n             case TypeTags.BOOLEAN_TAG:\n                 return;\n             default:\n-                Arrays.fill(refValues, size, index, elementType.getZeroValue());\n-\n+                if (arrayType.hasFillerValue()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM5NzE4MQ=="}, "originalCommit": {"oid": "17f429daf9d5785fbeee7d411c55b2c892bda422"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2NzM4NDk1OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwNTo0NjozN1rOFssSzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwNjoyNzoyNlrOFss07w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQwNzM3Mw==", "bodyText": "We seem to have methods with different namescheckFillerValue, hasFillerValue, etc. across the class for similar checks. Shall we revisit these and group them together?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r382407373", "createdAt": "2020-02-21T05:46:37Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -109,6 +110,35 @@\n     private Names names;\n     private int finiteTypeCount = 0;\n \n+    private boolean checkFillerValue(BUnionType type) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17f429daf9d5785fbeee7d411c55b2c892bda422"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQxNjExMQ==", "bodyText": "hasFillerValue is the public method which calls checkfillerValue helper methods sometime recursively. I will try to refactor.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r382416111", "createdAt": "2020-02-21T06:27:26Z", "author": {"login": "KRVPerera"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -109,6 +110,35 @@\n     private Names names;\n     private int finiteTypeCount = 0;\n \n+    private boolean checkFillerValue(BUnionType type) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQwNzM3Mw=="}, "originalCommit": {"oid": "17f429daf9d5785fbeee7d411c55b2c892bda422"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2NzM4NTU3OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwNTo0Njo1OVrOFssTHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwNTo0Njo1OVrOFssTHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQwNzQ1NA==", "bodyText": "What about when the value space has more than one value but are all of the same type?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r382407454", "createdAt": "2020-02-21T05:46:59Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2553,4 +2583,182 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type.tag < TypeTags.RECORD) {\n+            return true;\n+        }\n+        switch (type.tag) {\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+            return false;\n+        }\n+\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            return true;\n+        }\n+        if (initFunction.symbol.getReturnType().getKind() != TypeKind.NIL) {\n+            return false;\n+        }\n+\n+        for (BVarSymbol bVarSymbol : initFunction.symbol.getParameters()) {\n+            if (!bVarSymbol.defaultableParam) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * This will handle two types. Singleton : As singleton can have one value that value should it self be a valid fill\n+     * value Union : 1. if nil is a member it is the fill values 2. else all the values should belong to same type and\n+     * the default value for that type should be a member of the union precondition : value space should have at least\n+     * one element\n+     *\n+     * @param type BFiniteType union or finite\n+     * @return boolean whether type has a valid filler value or not\n+     */\n+    private boolean checkFillerValue(BFiniteType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+\n+        // For singleton types, that value is the implicit initial value\n+        if (type.getValueSpace().size() == 1) {\n+            return true;\n+        }\n+\n+        boolean defaultFillValuePresent = false;\n+\n+        Iterator iterator = type.getValueSpace().iterator();\n+        BLangExpression firstElement = (BLangExpression) iterator.next();\n+        BType firstElementType = firstElement.type;\n+        String defaultFillValue = getDefaultFillValue(firstElement);\n+        if (defaultFillValue.equals(DefaultValues.UNKNOWN.getValue())) {\n+            return false;\n+        }\n+        if (firstElement.toString().equals(defaultFillValue)) {\n+            defaultFillValuePresent = true;\n+        }\n+\n+        while (iterator.hasNext()) {\n+            Object value = iterator.next();\n+            BType valueType = ((BLangExpression) value).type;\n+            if (!isSameType(valueType, firstElementType)) {\n+                return false;\n+            }\n+            if (!defaultFillValuePresent && value.toString().equals(defaultFillValue)) {\n+                defaultFillValuePresent = true;\n+            }\n+        }\n+        return defaultFillValuePresent;\n+    }\n+\n+    private String getDefaultFillValue(BType type) {\n+        switch(type.getKind()) {\n+            case INT:\n+            case BYTE:\n+                return DefaultValues.INTEGER.getValue();\n+            case STRING:\n+                return DefaultValues.STRING.getValue();\n+            case DECIMAL:\n+            case FLOAT:\n+                return DefaultValues.FLOAT.getValue();\n+            case BOOLEAN:\n+                return DefaultValues.BOOLEAN.getValue();\n+            case NIL:\n+                return DefaultValues.NIL.getValue();\n+            case ERROR:\n+            case TYPEDESC:\n+                return DefaultValues.UNKNOWN.getValue();\n+            default:\n+                if (type instanceof BFiniteType) {\n+                    return getDefaultFillValue((BFiniteType) type);\n+                }\n+                return DefaultValues.UNKNOWN.getValue();\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BRecordType type) {\n+        for (BField field : type.fields) {\n+            if (Symbols.isFlagOn(field.symbol.flags, Flags.OPTIONAL)) {\n+                continue;\n+            }\n+            if (Symbols.isFlagOn(field.symbol.flags, Flags.REQUIRED)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private boolean checkFillerValue(BArrayType type) {\n+        if (type.size == -1) {\n+            return true;\n+        }\n+        return hasFillerValue(type.eType);\n+    }\n+\n+    private String getDefaultFillValue(BLangExpression expr) {\n+        return getDefaultFillValue(expr.type);\n+    }\n+\n+    private String getDefaultFillValue(BFiniteType finiteType) {\n+        if (finiteType.getValueSpace().size() == 1) {\n+            for (BLangExpression valueLiteral : finiteType.getValueSpace()) {\n+                if (!(valueLiteral instanceof BLangLiteral)) {\n+                    return DefaultValues.UNKNOWN.getValue();\n+                }\n+                return valueLiteral.toString();\n+            }\n+        }\n+        return DefaultValues.UNKNOWN.getValue();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17f429daf9d5785fbeee7d411c55b2c892bda422"}, "originalPosition": 276}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3MjQxODU3OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/model/types/BFiniteType.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQwOToxMzoyNlrOFtZbQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQwOToxMzoyNlrOFtZbQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE0NjgxNg==", "bodyText": "isNullable call", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r383146816", "createdAt": "2020-02-24T09:13:26Z", "author": {"login": "KRVPerera"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/model/types/BFiniteType.java", "diffHunk": "@@ -111,4 +114,11 @@ public boolean isAnydata() {\n         this.isAnyData = Optional.of(true);\n         return true;\n     }\n+\n+    public void addValue(BLangExpression value) {\n+        this.valueSpace.add(value);\n+        if (!nullable && (value.type.tag == TypeTags.NIL)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17f429daf9d5785fbeee7d411c55b2c892bda422"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3OTY1MjMzOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwNDo0MzoxOFrOFueGxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwNjoyMDo0NVrOFufbRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI3MjA3MQ==", "bodyText": "The following should work right?\nconst FOO = \"foo\";\nconst BAR = \"bar\";\n\ntype FooBar FOO|BAR;\n\npublic function main() {\n    (map<FooBar>|map<string>)[2] x = [];\n}\nI guess it won't work with the isValueType check?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r384272071", "createdAt": "2020-02-26T04:43:18Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2553,4 +2565,150 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        switch (type.tag) {\n+            case TypeTags.INT:\n+            case TypeTags.BYTE:\n+            case TypeTags.FLOAT:\n+            case TypeTags.DECIMAL:\n+            case TypeTags.STRING:\n+            case TypeTags.BOOLEAN:\n+            case TypeTags.JSON:\n+            case TypeTags.XML:\n+            case TypeTags.TABLE:\n+            case TypeTags.NIL:\n+            case TypeTags.ANYDATA:\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+            return false;\n+        }\n+\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            return true;\n+        }\n+        if (initFunction.symbol.getReturnType().getKind() != TypeKind.NIL) {\n+            return false;\n+        }\n+\n+        for (BVarSymbol bVarSymbol : initFunction.symbol.getParameters()) {\n+            if (!bVarSymbol.defaultableParam) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * This will handle two types. Singleton : As singleton can have one value that value should it self be a valid fill\n+     * value Union : 1. if nil is a member it is the fill values 2. else all the values should belong to same type and\n+     * the default value for that type should be a member of the union precondition : value space should have at least\n+     * one element\n+     *\n+     * @param type BFiniteType union or finite\n+     * @return boolean whether type has a valid filler value or not\n+     */\n+    private boolean checkFillerValue(BFiniteType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+        if (type.getValueSpace().size() == 1) { // For singleton types, that value is the implicit initial value\n+            return true;\n+        }\n+        Iterator iterator = type.getValueSpace().iterator();\n+        BLangExpression firstElement = (BLangExpression) iterator.next();\n+        boolean defaultFillValuePresent = isImplicitDefaultValue(firstElement);\n+\n+        while (iterator.hasNext()) {\n+            BLangExpression value = (BLangExpression) iterator.next();\n+            if (!isSameType(value.type, firstElement.type)) {\n+                return false;\n+            }\n+            if (!defaultFillValuePresent && isImplicitDefaultValue(value)) {\n+                defaultFillValuePresent = true;\n+            }\n+        }\n+\n+        return defaultFillValuePresent;\n+    }\n+\n+    private boolean checkFillerValue(BUnionType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+        Iterator<BType> iterator = type.getMemberTypes().iterator();\n+        BType firstMember = iterator.next();\n+        while (iterator.hasNext()) {\n+            if (!isSameType(firstMember, iterator.next())) {\n+                return false;\n+            }\n+        }\n+        return isValueType(firstMember) && hasFillerValue(firstMember);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e493306b2169e6eb276e902de8689b1c2cce1b37"}, "originalPosition": 217}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI4NjQyNw==", "bodyText": "Shall we create an issue for this?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r384286427", "createdAt": "2020-02-26T05:51:11Z", "author": {"login": "hasithaa"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2553,4 +2565,150 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        switch (type.tag) {\n+            case TypeTags.INT:\n+            case TypeTags.BYTE:\n+            case TypeTags.FLOAT:\n+            case TypeTags.DECIMAL:\n+            case TypeTags.STRING:\n+            case TypeTags.BOOLEAN:\n+            case TypeTags.JSON:\n+            case TypeTags.XML:\n+            case TypeTags.TABLE:\n+            case TypeTags.NIL:\n+            case TypeTags.ANYDATA:\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+            return false;\n+        }\n+\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            return true;\n+        }\n+        if (initFunction.symbol.getReturnType().getKind() != TypeKind.NIL) {\n+            return false;\n+        }\n+\n+        for (BVarSymbol bVarSymbol : initFunction.symbol.getParameters()) {\n+            if (!bVarSymbol.defaultableParam) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * This will handle two types. Singleton : As singleton can have one value that value should it self be a valid fill\n+     * value Union : 1. if nil is a member it is the fill values 2. else all the values should belong to same type and\n+     * the default value for that type should be a member of the union precondition : value space should have at least\n+     * one element\n+     *\n+     * @param type BFiniteType union or finite\n+     * @return boolean whether type has a valid filler value or not\n+     */\n+    private boolean checkFillerValue(BFiniteType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+        if (type.getValueSpace().size() == 1) { // For singleton types, that value is the implicit initial value\n+            return true;\n+        }\n+        Iterator iterator = type.getValueSpace().iterator();\n+        BLangExpression firstElement = (BLangExpression) iterator.next();\n+        boolean defaultFillValuePresent = isImplicitDefaultValue(firstElement);\n+\n+        while (iterator.hasNext()) {\n+            BLangExpression value = (BLangExpression) iterator.next();\n+            if (!isSameType(value.type, firstElement.type)) {\n+                return false;\n+            }\n+            if (!defaultFillValuePresent && isImplicitDefaultValue(value)) {\n+                defaultFillValuePresent = true;\n+            }\n+        }\n+\n+        return defaultFillValuePresent;\n+    }\n+\n+    private boolean checkFillerValue(BUnionType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+        Iterator<BType> iterator = type.getMemberTypes().iterator();\n+        BType firstMember = iterator.next();\n+        while (iterator.hasNext()) {\n+            if (!isSameType(firstMember, iterator.next())) {\n+                return false;\n+            }\n+        }\n+        return isValueType(firstMember) && hasFillerValue(firstMember);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI3MjA3MQ=="}, "originalCommit": {"oid": "e493306b2169e6eb276e902de8689b1c2cce1b37"}, "originalPosition": 217}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI5MzcwMg==", "bodyText": "Created #21251", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r384293702", "createdAt": "2020-02-26T06:20:45Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2553,4 +2565,150 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        switch (type.tag) {\n+            case TypeTags.INT:\n+            case TypeTags.BYTE:\n+            case TypeTags.FLOAT:\n+            case TypeTags.DECIMAL:\n+            case TypeTags.STRING:\n+            case TypeTags.BOOLEAN:\n+            case TypeTags.JSON:\n+            case TypeTags.XML:\n+            case TypeTags.TABLE:\n+            case TypeTags.NIL:\n+            case TypeTags.ANYDATA:\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+            return false;\n+        }\n+\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            return true;\n+        }\n+        if (initFunction.symbol.getReturnType().getKind() != TypeKind.NIL) {\n+            return false;\n+        }\n+\n+        for (BVarSymbol bVarSymbol : initFunction.symbol.getParameters()) {\n+            if (!bVarSymbol.defaultableParam) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * This will handle two types. Singleton : As singleton can have one value that value should it self be a valid fill\n+     * value Union : 1. if nil is a member it is the fill values 2. else all the values should belong to same type and\n+     * the default value for that type should be a member of the union precondition : value space should have at least\n+     * one element\n+     *\n+     * @param type BFiniteType union or finite\n+     * @return boolean whether type has a valid filler value or not\n+     */\n+    private boolean checkFillerValue(BFiniteType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+        if (type.getValueSpace().size() == 1) { // For singleton types, that value is the implicit initial value\n+            return true;\n+        }\n+        Iterator iterator = type.getValueSpace().iterator();\n+        BLangExpression firstElement = (BLangExpression) iterator.next();\n+        boolean defaultFillValuePresent = isImplicitDefaultValue(firstElement);\n+\n+        while (iterator.hasNext()) {\n+            BLangExpression value = (BLangExpression) iterator.next();\n+            if (!isSameType(value.type, firstElement.type)) {\n+                return false;\n+            }\n+            if (!defaultFillValuePresent && isImplicitDefaultValue(value)) {\n+                defaultFillValuePresent = true;\n+            }\n+        }\n+\n+        return defaultFillValuePresent;\n+    }\n+\n+    private boolean checkFillerValue(BUnionType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+        Iterator<BType> iterator = type.getMemberTypes().iterator();\n+        BType firstMember = iterator.next();\n+        while (iterator.hasNext()) {\n+            if (!isSameType(firstMember, iterator.next())) {\n+                return false;\n+            }\n+        }\n+        return isValueType(firstMember) && hasFillerValue(firstMember);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI3MjA3MQ=="}, "originalCommit": {"oid": "e493306b2169e6eb276e902de8689b1c2cce1b37"}, "originalPosition": 217}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3OTY3NjQ3OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwNTowMjoxMFrOFueVnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwNTowMjoxMFrOFueVnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI3NTg3MQ==", "bodyText": "How about constant refs?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r384275871", "createdAt": "2020-02-26T05:02:10Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2553,4 +2565,150 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        switch (type.tag) {\n+            case TypeTags.INT:\n+            case TypeTags.BYTE:\n+            case TypeTags.FLOAT:\n+            case TypeTags.DECIMAL:\n+            case TypeTags.STRING:\n+            case TypeTags.BOOLEAN:\n+            case TypeTags.JSON:\n+            case TypeTags.XML:\n+            case TypeTags.TABLE:\n+            case TypeTags.NIL:\n+            case TypeTags.ANYDATA:\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+            return false;\n+        }\n+\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            return true;\n+        }\n+        if (initFunction.symbol.getReturnType().getKind() != TypeKind.NIL) {\n+            return false;\n+        }\n+\n+        for (BVarSymbol bVarSymbol : initFunction.symbol.getParameters()) {\n+            if (!bVarSymbol.defaultableParam) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * This will handle two types. Singleton : As singleton can have one value that value should it self be a valid fill\n+     * value Union : 1. if nil is a member it is the fill values 2. else all the values should belong to same type and\n+     * the default value for that type should be a member of the union precondition : value space should have at least\n+     * one element\n+     *\n+     * @param type BFiniteType union or finite\n+     * @return boolean whether type has a valid filler value or not\n+     */\n+    private boolean checkFillerValue(BFiniteType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+        if (type.getValueSpace().size() == 1) { // For singleton types, that value is the implicit initial value\n+            return true;\n+        }\n+        Iterator iterator = type.getValueSpace().iterator();\n+        BLangExpression firstElement = (BLangExpression) iterator.next();\n+        boolean defaultFillValuePresent = isImplicitDefaultValue(firstElement);\n+\n+        while (iterator.hasNext()) {\n+            BLangExpression value = (BLangExpression) iterator.next();\n+            if (!isSameType(value.type, firstElement.type)) {\n+                return false;\n+            }\n+            if (!defaultFillValuePresent && isImplicitDefaultValue(value)) {\n+                defaultFillValuePresent = true;\n+            }\n+        }\n+\n+        return defaultFillValuePresent;\n+    }\n+\n+    private boolean checkFillerValue(BUnionType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+        Iterator<BType> iterator = type.getMemberTypes().iterator();\n+        BType firstMember = iterator.next();\n+        while (iterator.hasNext()) {\n+            if (!isSameType(firstMember, iterator.next())) {\n+                return false;\n+            }\n+        }\n+        return isValueType(firstMember) && hasFillerValue(firstMember);\n+    }\n+\n+    private boolean isImplicitDefaultValue(BLangExpression expression) {\n+        if ((expression.getKind() == NodeKind.LITERAL) || (expression.getKind() == NodeKind.NUMERIC_LITERAL)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e493306b2169e6eb276e902de8689b1c2cce1b37"}, "originalPosition": 221}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3OTY3NzQwOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwNTowMzowMlrOFueWMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwNTowMzowMlrOFueWMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI3NjAxOA==", "bodyText": "Do we need this null check?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r384276018", "createdAt": "2020-02-26T05:03:02Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2553,4 +2565,150 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        switch (type.tag) {\n+            case TypeTags.INT:\n+            case TypeTags.BYTE:\n+            case TypeTags.FLOAT:\n+            case TypeTags.DECIMAL:\n+            case TypeTags.STRING:\n+            case TypeTags.BOOLEAN:\n+            case TypeTags.JSON:\n+            case TypeTags.XML:\n+            case TypeTags.TABLE:\n+            case TypeTags.NIL:\n+            case TypeTags.ANYDATA:\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+            return false;\n+        }\n+\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            return true;\n+        }\n+        if (initFunction.symbol.getReturnType().getKind() != TypeKind.NIL) {\n+            return false;\n+        }\n+\n+        for (BVarSymbol bVarSymbol : initFunction.symbol.getParameters()) {\n+            if (!bVarSymbol.defaultableParam) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * This will handle two types. Singleton : As singleton can have one value that value should it self be a valid fill\n+     * value Union : 1. if nil is a member it is the fill values 2. else all the values should belong to same type and\n+     * the default value for that type should be a member of the union precondition : value space should have at least\n+     * one element\n+     *\n+     * @param type BFiniteType union or finite\n+     * @return boolean whether type has a valid filler value or not\n+     */\n+    private boolean checkFillerValue(BFiniteType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+        if (type.getValueSpace().size() == 1) { // For singleton types, that value is the implicit initial value\n+            return true;\n+        }\n+        Iterator iterator = type.getValueSpace().iterator();\n+        BLangExpression firstElement = (BLangExpression) iterator.next();\n+        boolean defaultFillValuePresent = isImplicitDefaultValue(firstElement);\n+\n+        while (iterator.hasNext()) {\n+            BLangExpression value = (BLangExpression) iterator.next();\n+            if (!isSameType(value.type, firstElement.type)) {\n+                return false;\n+            }\n+            if (!defaultFillValuePresent && isImplicitDefaultValue(value)) {\n+                defaultFillValuePresent = true;\n+            }\n+        }\n+\n+        return defaultFillValuePresent;\n+    }\n+\n+    private boolean checkFillerValue(BUnionType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+        Iterator<BType> iterator = type.getMemberTypes().iterator();\n+        BType firstMember = iterator.next();\n+        while (iterator.hasNext()) {\n+            if (!isSameType(firstMember, iterator.next())) {\n+                return false;\n+            }\n+        }\n+        return isValueType(firstMember) && hasFillerValue(firstMember);\n+    }\n+\n+    private boolean isImplicitDefaultValue(BLangExpression expression) {\n+        if ((expression.getKind() == NodeKind.LITERAL) || (expression.getKind() == NodeKind.NUMERIC_LITERAL)) {\n+            BLangLiteral literalExpression = (BLangLiteral) expression;\n+            BType literalExprType = literalExpression.type;\n+            Object value = literalExpression.getValue();\n+            switch (literalExprType.getKind()) {\n+                case INT:\n+                case BYTE:\n+                    return value.equals(Long.valueOf(0));\n+                case STRING:\n+                    return value == null || value.equals(\"\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e493306b2169e6eb276e902de8689b1c2cce1b37"}, "originalPosition": 230}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3OTY3ODE4OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwNTowMzozMVrOFueWqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwNTowMzozMVrOFueWqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI3NjEzOA==", "bodyText": "Shouldn't we check if value is null?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r384276138", "createdAt": "2020-02-26T05:03:31Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2553,4 +2565,150 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        switch (type.tag) {\n+            case TypeTags.INT:\n+            case TypeTags.BYTE:\n+            case TypeTags.FLOAT:\n+            case TypeTags.DECIMAL:\n+            case TypeTags.STRING:\n+            case TypeTags.BOOLEAN:\n+            case TypeTags.JSON:\n+            case TypeTags.XML:\n+            case TypeTags.TABLE:\n+            case TypeTags.NIL:\n+            case TypeTags.ANYDATA:\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+            return false;\n+        }\n+\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            return true;\n+        }\n+        if (initFunction.symbol.getReturnType().getKind() != TypeKind.NIL) {\n+            return false;\n+        }\n+\n+        for (BVarSymbol bVarSymbol : initFunction.symbol.getParameters()) {\n+            if (!bVarSymbol.defaultableParam) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * This will handle two types. Singleton : As singleton can have one value that value should it self be a valid fill\n+     * value Union : 1. if nil is a member it is the fill values 2. else all the values should belong to same type and\n+     * the default value for that type should be a member of the union precondition : value space should have at least\n+     * one element\n+     *\n+     * @param type BFiniteType union or finite\n+     * @return boolean whether type has a valid filler value or not\n+     */\n+    private boolean checkFillerValue(BFiniteType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+        if (type.getValueSpace().size() == 1) { // For singleton types, that value is the implicit initial value\n+            return true;\n+        }\n+        Iterator iterator = type.getValueSpace().iterator();\n+        BLangExpression firstElement = (BLangExpression) iterator.next();\n+        boolean defaultFillValuePresent = isImplicitDefaultValue(firstElement);\n+\n+        while (iterator.hasNext()) {\n+            BLangExpression value = (BLangExpression) iterator.next();\n+            if (!isSameType(value.type, firstElement.type)) {\n+                return false;\n+            }\n+            if (!defaultFillValuePresent && isImplicitDefaultValue(value)) {\n+                defaultFillValuePresent = true;\n+            }\n+        }\n+\n+        return defaultFillValuePresent;\n+    }\n+\n+    private boolean checkFillerValue(BUnionType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+        Iterator<BType> iterator = type.getMemberTypes().iterator();\n+        BType firstMember = iterator.next();\n+        while (iterator.hasNext()) {\n+            if (!isSameType(firstMember, iterator.next())) {\n+                return false;\n+            }\n+        }\n+        return isValueType(firstMember) && hasFillerValue(firstMember);\n+    }\n+\n+    private boolean isImplicitDefaultValue(BLangExpression expression) {\n+        if ((expression.getKind() == NodeKind.LITERAL) || (expression.getKind() == NodeKind.NUMERIC_LITERAL)) {\n+            BLangLiteral literalExpression = (BLangLiteral) expression;\n+            BType literalExprType = literalExpression.type;\n+            Object value = literalExpression.getValue();\n+            switch (literalExprType.getKind()) {\n+                case INT:\n+                case BYTE:\n+                    return value.equals(Long.valueOf(0));\n+                case STRING:\n+                    return value == null || value.equals(\"\");\n+                case DECIMAL:\n+                case FLOAT:\n+                    return value.equals(String.valueOf(0.0));\n+                case BOOLEAN:\n+                    return value.equals(Boolean.valueOf(false));\n+                case NIL:\n+                    return true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e493306b2169e6eb276e902de8689b1c2cce1b37"}, "originalPosition": 237}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3OTY5MDIwOnYy", "diffSide": "RIGHT", "path": "tests/jballerina-unit-test/src/test/resources/test-src/statements/arrays/sealed-array.bal", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwNToxMjo0NVrOFueeIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwNToxMjo0NVrOFueeIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI3ODA0OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                assertArrayValuePanic(0, sealedArray, 2);\n          \n          \n            \n                assertArrayValuePanic(0, sealedArray, 3);\n          \n      \n    \n    \n  \n\n?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r384278048", "createdAt": "2020-02-26T05:12:45Z", "author": {"login": "MaryamZi"}, "path": "tests/jballerina-unit-test/src/test/resources/test-src/statements/arrays/sealed-array.bal", "diffHunk": "@@ -16,82 +16,123 @@\n \n // Int Arrays\n \n-function createIntSealedArray() returns int {\n+function createIntSealedArray() {\n     int[5] sealedArray = [2, 15, 200, 1500, 5000];\n-    return sealedArray.length();\n+    assertArrayLengthPanic(5, sealedArray);\n }\n \n-function createIntSealedArrayWithLabel() returns int {\n+function createIntAutoFilledSealedArray() {\n+    int[5] sealedArray = [2];\n+    sealedArray[4] = 2;\n+    assertArrayValuePanic(2, sealedArray, 4);\n+    assertArrayValuePanic(2, sealedArray, 0);\n+    assertArrayValuePanic(0, sealedArray, 1);\n+    assertArrayValuePanic(0, sealedArray, 2);\n+    assertArrayValuePanic(0, sealedArray, 2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e493306b2169e6eb276e902de8689b1c2cce1b37"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3OTY5NzQxOnYy", "diffSide": "RIGHT", "path": "tests/jballerina-unit-test/src/test/resources/test-src/statements/arrays/sealed-array.bal", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwNToxNzo1N1rOFueiTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwNToxNzo1N1rOFueiTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI3OTExOA==", "bodyText": "IMO, we should avoid using string representations for equality as much as possible.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r384279118", "createdAt": "2020-02-26T05:17:57Z", "author": {"login": "MaryamZi"}, "path": "tests/jballerina-unit-test/src/test/resources/test-src/statements/arrays/sealed-array.bal", "diffHunk": "@@ -16,82 +16,123 @@\n \n // Int Arrays\n \n-function createIntSealedArray() returns int {\n+function createIntSealedArray() {\n     int[5] sealedArray = [2, 15, 200, 1500, 5000];\n-    return sealedArray.length();\n+    assertArrayLengthPanic(5, sealedArray);\n }\n \n-function createIntSealedArrayWithLabel() returns int {\n+function createIntAutoFilledSealedArray() {\n+    int[5] sealedArray = [2];\n+    sealedArray[4] = 2;\n+    assertArrayValuePanic(2, sealedArray, 4);\n+    assertArrayValuePanic(2, sealedArray, 0);\n+    assertArrayValuePanic(0, sealedArray, 1);\n+    assertArrayValuePanic(0, sealedArray, 2);\n+    assertArrayValuePanic(0, sealedArray, 2);\n+    assertArrayLengthPanic(5, sealedArray);\n+}\n+\n+function createIntSealedArrayWithLabel() {\n     int[*] sealedArray = [2, 15, 200, 1500, 5000];\n-    return sealedArray.length();\n+    assertArrayLengthPanic(5, sealedArray);\n }\n \n-function createIntDefaultSealedArray() returns [int[], int] {\n+function createIntDefaultSealedArray() {\n     int[5] sealedArray = [0, 0, 0, 0, 0];\n-    return [sealedArray, sealedArray.length()];\n+    assertArrayLengthPanic(5, sealedArray);\n+    isEqualPanic(\"0 0 0 0 0\", sealedArray);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e493306b2169e6eb276e902de8689b1c2cce1b37"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3OTcwMjU3OnYy", "diffSide": "RIGHT", "path": "tests/jballerina-unit-test/src/test/resources/test-src/statements/arrays/sealed-array.bal", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwNToyMTo0M1rOFuelYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwNToyMTo0M1rOFuelYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI3OTkwNQ==", "bodyText": "Can we also assert the filled values?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r384279905", "createdAt": "2020-02-26T05:21:43Z", "author": {"login": "MaryamZi"}, "path": "tests/jballerina-unit-test/src/test/resources/test-src/statements/arrays/sealed-array.bal", "diffHunk": "@@ -16,82 +16,123 @@\n \n // Int Arrays\n \n-function createIntSealedArray() returns int {\n+function createIntSealedArray() {\n     int[5] sealedArray = [2, 15, 200, 1500, 5000];\n-    return sealedArray.length();\n+    assertArrayLengthPanic(5, sealedArray);\n }\n \n-function createIntSealedArrayWithLabel() returns int {\n+function createIntAutoFilledSealedArray() {\n+    int[5] sealedArray = [2];\n+    sealedArray[4] = 2;\n+    assertArrayValuePanic(2, sealedArray, 4);\n+    assertArrayValuePanic(2, sealedArray, 0);\n+    assertArrayValuePanic(0, sealedArray, 1);\n+    assertArrayValuePanic(0, sealedArray, 2);\n+    assertArrayValuePanic(0, sealedArray, 2);\n+    assertArrayLengthPanic(5, sealedArray);\n+}\n+\n+function createIntSealedArrayWithLabel() {\n     int[*] sealedArray = [2, 15, 200, 1500, 5000];\n-    return sealedArray.length();\n+    assertArrayLengthPanic(5, sealedArray);\n }\n \n-function createIntDefaultSealedArray() returns [int[], int] {\n+function createIntDefaultSealedArray() {\n     int[5] sealedArray = [0, 0, 0, 0, 0];\n-    return [sealedArray, sealedArray.length()];\n+    assertArrayLengthPanic(5, sealedArray);\n+    isEqualPanic(\"0 0 0 0 0\", sealedArray);\n }\n \n // Boolean Arrays\n \n-function createBoolSealedArray() returns int {\n+function createBoolSealedArray() {\n     boolean[5] sealedArray = [true, false, false, true, false];\n-    return sealedArray.length();\n+    assertArrayLengthPanic(5, sealedArray);\n+}\n+\n+function createBoolAutoFilledSealedArray() {\n+    boolean[5] sealedArray = [true, false];\n+    sealedArray[4] = false;\n+    assertArrayValuePanic(false, sealedArray, 4);\n+    assertArrayLengthPanic(5, sealedArray);\n }\n \n-function createBoolSealedArrayWithLabel() returns int {\n+function createBoolSealedArrayWithLabel() {\n     boolean[*] sealedArray = [true, false, false, true, false];\n-    return sealedArray.length();\n+    assertArrayLengthPanic(5, sealedArray);\n }\n \n-function createBoolDefaultSealedArray() returns [boolean[], int] {\n+function createBoolDefaultSealedArray() {\n     boolean[5] sealedArray = [false, false, false, false, false];\n-    return [sealedArray, sealedArray.length()];\n+    assertArrayLengthPanic(5, sealedArray);\n+    isEqualPanic(\"false false false false false\", sealedArray);\n }\n \n // Float Arrays\n \n-function createFloatSealedArray() returns int {\n+function createFloatSealedArray() {\n     float[5] sealedArray = [0.0, 15.2, 1100.0, -25.8, -10.0];\n-    return sealedArray.length();\n+    assertArrayLengthPanic(5, sealedArray);\n }\n \n-function createFloatSealedArrayWithLabel() returns int {\n+function createFloatAutoFilledSealedArray() {\n+    float[5] sealedArray = [0.0, 15.2];\n+    sealedArray[4] = 2.5;\n+    assertArrayValuePanic(2.5, sealedArray, 4);\n+    assertArrayLengthPanic(5, sealedArray);\n+}\n+\n+function createFloatSealedArrayWithLabel() {\n     float[*] sealedArray = [0.0, 15.2, 1100.0, -25.8, -10.0];\n-    return sealedArray.length();\n+    assertArrayLengthPanic(5, sealedArray);\n }\n \n-function createFloatDefaultSealedArray() returns [float[], int] {\n+function createFloatDefaultSealedArray() {\n     float[5] sealedArray = [0.0, 0.0, 0.0, 0.0, 0.0];\n-    return [sealedArray, sealedArray.length()];\n+    assertArrayLengthPanic(5, sealedArray);\n+    isEqualPanic(\"0.0 0.0 0.0 0.0 0.0\", sealedArray);\n }\n \n // String Arrays\n \n-function createStringSealedArray() returns int {\n+function createStringSealedArray() {\n     string[5] sealedArray = [\"a\", \"abc\", \"12\", \"-12\", \".\"];\n-    return sealedArray.length();\n+    assertArrayLengthPanic(5, sealedArray);\n+}\n+\n+function createStringAutoFilledSealedArray() {\n+    string[5] sealedArray = [\"a\"];\n+    assertArrayLengthPanic(5, sealedArray);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e493306b2169e6eb276e902de8689b1c2cce1b37"}, "originalPosition": 110}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 576, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}