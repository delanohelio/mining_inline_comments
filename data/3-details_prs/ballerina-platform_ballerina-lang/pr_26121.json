{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkzODU0MDcz", "number": 26121, "title": "[Formatter] Add several new node implementations", "bodyText": "Purpose\nAdds the following node implementations:\n\nImportDeclarationNode\nServiceDeclarationNode\nExplicitNewExpressionNode\nParenthesizedArgList\nServiceBodyNode\nQualifiedNameReferenceNode\nReturnTypeDescriptorNode\nOptionalTypeDescriptorNode\nExpressionStatementNode\nCheckExpressionNode\nRemoteMethodCallActionNode\nSimpleNameReferenceNode\nTypeDefinitionNode\nSingletonTypeDescriptorNode\nWhileStatementNode\nBracedExpressionNode\nAssignmentStatementNode\nCompoundAssignmentStatementNode\nDoStatementNode\nForEachStatementNode\nBinaryExpressionNode\nOnFailClauseNode\nReturnStatementNode\nFunctionCallExpressionNode\n\nPartially Fixes #26052\nApproach\n\nDescribe how you are implementing the solutions along with the design details.\n\nSamples\n\nProvide high-level details about the samples related to this feature.\n\nRemarks\n\nList any other known issues, related PRs, TODO items, or any other notes related to the PR.\n\nCheck List\n\n Read the Contributing Guide\n Updated Change Log\n Checked Tooling Support (#)\n Added necessary tests\n\n Unit Tests\n Spec Conformance Tests\n Integration Tests\n Ballerina By Example Tests\n\n\n Increased Test Coverage\n Added necessary documentation\n\n API documentation\n Module documentation in Module.md files\n Ballerina By Examples", "createdAt": "2020-09-28T04:10:26Z", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26121", "merged": true, "mergeCommit": {"oid": "a3dc5db0798748d23a73e1a029cf2eb9a577e99b"}, "closed": true, "closedAt": "2020-09-28T14:01:34Z", "author": {"login": "IrushiL"}, "timelineItems": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdMcbZ0AH2gAyNDkzODU0MDczOjU2MmZhZDhkZjQ4MjAzZmE3ZDliYTMwZjdjYWEwM2U3NGQxMTg5YWM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdNUEnyAFqTQ5NzU0Mjk3OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "562fad8df48203fa7d9ba30f7caa03e74d1189ac", "author": {"user": {"login": "IrushiL", "name": "Irushi Liyanage"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/562fad8df48203fa7d9ba30f7caa03e74d1189ac", "committedDate": "2020-09-25T21:11:36Z", "message": "Add several node implementations\n\nImportDeclarationNode, ServiceDeclarationNode, ExplicitNewExpressionNode, ParenthesizedArgList, ServiceBodyNode, QualifiedNameReferenceNode, ReturnTypeDescriptorNode, OptionalTypeDescriptorNode, ExpressionStatementNode, CheckExpressionNode, RemoteMethodCallActionNode, SimpleNameReferenceNode, TypeDefinitionNode, SingletonTypeDescriptorNode"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cbe2ae652ec6017566c3bce493b48a2de90279c7", "author": {"user": {"login": "IrushiL", "name": "Irushi Liyanage"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/cbe2ae652ec6017566c3bce493b48a2de90279c7", "committedDate": "2020-09-28T03:46:13Z", "message": "Add some more nodes\n\nWhileStatementNode, BracedExpressionNode, AssignmentStatementNode, CompoundAssignmentStatementNode, DoStatementNode, ForEachStatementNode, BinaryExpressionNode, OnFailClauseNode, ReturnStatementNode, FunctionCallExpressionNode"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "718a81afe866ca9273c113676aa2d38b1a3e8f45", "author": {"user": {"login": "IrushiL", "name": "Irushi Liyanage"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/718a81afe866ca9273c113676aa2d38b1a3e8f45", "committedDate": "2020-09-28T04:04:28Z", "message": "Fix formatting issues"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a775b9cadbd9a21307035b40d50e91dc8e229ffe", "author": {"user": {"login": "IrushiL", "name": "Irushi Liyanage"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a775b9cadbd9a21307035b40d50e91dc8e229ffe", "committedDate": "2020-09-28T04:41:40Z", "message": "Fix checkstyle issues"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3MTg4MDU2", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26121#pullrequestreview-497188056", "createdAt": "2020-09-28T05:04:23Z", "commit": {"oid": "a775b9cadbd9a21307035b40d50e91dc8e229ffe"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwNTowNDoyM1rOHYujcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwNToyMDoxMFrOHYuxbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY5MDYwOQ==", "bodyText": "no need of a WS after the last component of the module name?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26121#discussion_r495690609", "createdAt": "2020-09-28T05:04:23Z", "author": {"login": "SupunS"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "diffHunk": "@@ -399,6 +429,392 @@ public RecordFieldWithDefaultValueNode transform(RecordFieldWithDefaultValueNode\n                 .apply();\n     }\n \n+    @Override\n+    public ImportDeclarationNode transform(ImportDeclarationNode importDeclarationNode) {\n+        Token importKeyword = formatToken(importDeclarationNode.importKeyword(), 0, 0);\n+\n+        if (importDeclarationNode.orgName().isPresent()) {\n+            ImportOrgNameNode orgName = formatNode(importDeclarationNode.orgName().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withOrgName(orgName).apply();\n+        }\n+        SeparatedNodeList<IdentifierToken> moduleNames = formatSeparatedNodeList(importDeclarationNode.moduleName(),\n+                0, 0, 0, 0, 0, 0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a775b9cadbd9a21307035b40d50e91dc8e229ffe"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY5MDg2NA==", "bodyText": "here also should keep a trailing ws", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26121#discussion_r495690864", "createdAt": "2020-09-28T05:05:36Z", "author": {"login": "SupunS"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "diffHunk": "@@ -399,6 +429,392 @@ public RecordFieldWithDefaultValueNode transform(RecordFieldWithDefaultValueNode\n                 .apply();\n     }\n \n+    @Override\n+    public ImportDeclarationNode transform(ImportDeclarationNode importDeclarationNode) {\n+        Token importKeyword = formatToken(importDeclarationNode.importKeyword(), 0, 0);\n+\n+        if (importDeclarationNode.orgName().isPresent()) {\n+            ImportOrgNameNode orgName = formatNode(importDeclarationNode.orgName().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withOrgName(orgName).apply();\n+        }\n+        SeparatedNodeList<IdentifierToken> moduleNames = formatSeparatedNodeList(importDeclarationNode.moduleName(),\n+                0, 0, 0, 0, 0, 0);\n+\n+        if (importDeclarationNode.version().isPresent()) {\n+            ImportVersionNode version = formatNode(importDeclarationNode.version().get(), 0, 0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a775b9cadbd9a21307035b40d50e91dc8e229ffe"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY5MDkwMA==", "bodyText": "same as above", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26121#discussion_r495690900", "createdAt": "2020-09-28T05:05:45Z", "author": {"login": "SupunS"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "diffHunk": "@@ -399,6 +429,392 @@ public RecordFieldWithDefaultValueNode transform(RecordFieldWithDefaultValueNode\n                 .apply();\n     }\n \n+    @Override\n+    public ImportDeclarationNode transform(ImportDeclarationNode importDeclarationNode) {\n+        Token importKeyword = formatToken(importDeclarationNode.importKeyword(), 0, 0);\n+\n+        if (importDeclarationNode.orgName().isPresent()) {\n+            ImportOrgNameNode orgName = formatNode(importDeclarationNode.orgName().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withOrgName(orgName).apply();\n+        }\n+        SeparatedNodeList<IdentifierToken> moduleNames = formatSeparatedNodeList(importDeclarationNode.moduleName(),\n+                0, 0, 0, 0, 0, 0);\n+\n+        if (importDeclarationNode.version().isPresent()) {\n+            ImportVersionNode version = formatNode(importDeclarationNode.version().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withVersion(version).apply();\n+        }\n+        if (importDeclarationNode.prefix().isPresent()) {\n+            ImportPrefixNode prefix = formatNode(importDeclarationNode.prefix().get(), 0, 0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a775b9cadbd9a21307035b40d50e91dc8e229ffe"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY5MTMxOQ==", "bodyText": "last token inside every method should get the  trailing whitesapces and  newlines from this.trailingWS and this.trailingNL.\nLet's follow that pattern religiously in all methods :)", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26121#discussion_r495691319", "createdAt": "2020-09-28T05:07:40Z", "author": {"login": "SupunS"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "diffHunk": "@@ -399,6 +429,392 @@ public RecordFieldWithDefaultValueNode transform(RecordFieldWithDefaultValueNode\n                 .apply();\n     }\n \n+    @Override\n+    public ImportDeclarationNode transform(ImportDeclarationNode importDeclarationNode) {\n+        Token importKeyword = formatToken(importDeclarationNode.importKeyword(), 0, 0);\n+\n+        if (importDeclarationNode.orgName().isPresent()) {\n+            ImportOrgNameNode orgName = formatNode(importDeclarationNode.orgName().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withOrgName(orgName).apply();\n+        }\n+        SeparatedNodeList<IdentifierToken> moduleNames = formatSeparatedNodeList(importDeclarationNode.moduleName(),\n+                0, 0, 0, 0, 0, 0);\n+\n+        if (importDeclarationNode.version().isPresent()) {\n+            ImportVersionNode version = formatNode(importDeclarationNode.version().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withVersion(version).apply();\n+        }\n+        if (importDeclarationNode.prefix().isPresent()) {\n+            ImportPrefixNode prefix = formatNode(importDeclarationNode.prefix().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withPrefix(prefix).apply();\n+        }\n+        Token semicolon = formatToken(importDeclarationNode.semicolon(), 0, 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a775b9cadbd9a21307035b40d50e91dc8e229ffe"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY5MTY5Nw==", "bodyText": "I think its good to add all the child nodes of the import decl node along with this..\nsuch as ImportVersionNode, ImportPrefixNode", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26121#discussion_r495691697", "createdAt": "2020-09-28T05:09:29Z", "author": {"login": "SupunS"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "diffHunk": "@@ -399,6 +429,392 @@ public RecordFieldWithDefaultValueNode transform(RecordFieldWithDefaultValueNode\n                 .apply();\n     }\n \n+    @Override\n+    public ImportDeclarationNode transform(ImportDeclarationNode importDeclarationNode) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a775b9cadbd9a21307035b40d50e91dc8e229ffe"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY5MjEwOQ==", "bodyText": "if theres an on-fail clause, then we shouldn't use this.trailingWS and this.trailingNL\nSame goes for all other places where on-fail clause applies", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26121#discussion_r495692109", "createdAt": "2020-09-28T05:11:07Z", "author": {"login": "SupunS"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "diffHunk": "@@ -399,6 +429,392 @@ public RecordFieldWithDefaultValueNode transform(RecordFieldWithDefaultValueNode\n                 .apply();\n     }\n \n+    @Override\n+    public ImportDeclarationNode transform(ImportDeclarationNode importDeclarationNode) {\n+        Token importKeyword = formatToken(importDeclarationNode.importKeyword(), 0, 0);\n+\n+        if (importDeclarationNode.orgName().isPresent()) {\n+            ImportOrgNameNode orgName = formatNode(importDeclarationNode.orgName().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withOrgName(orgName).apply();\n+        }\n+        SeparatedNodeList<IdentifierToken> moduleNames = formatSeparatedNodeList(importDeclarationNode.moduleName(),\n+                0, 0, 0, 0, 0, 0);\n+\n+        if (importDeclarationNode.version().isPresent()) {\n+            ImportVersionNode version = formatNode(importDeclarationNode.version().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withVersion(version).apply();\n+        }\n+        if (importDeclarationNode.prefix().isPresent()) {\n+            ImportPrefixNode prefix = formatNode(importDeclarationNode.prefix().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withPrefix(prefix).apply();\n+        }\n+        Token semicolon = formatToken(importDeclarationNode.semicolon(), 0, 1);\n+\n+        return importDeclarationNode.modify()\n+                .withImportKeyword(importKeyword)\n+                .withModuleName(moduleNames)\n+                .withSemicolon(semicolon)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ServiceDeclarationNode transform(ServiceDeclarationNode serviceDeclarationNode) {\n+        if (serviceDeclarationNode.metadata().isPresent()) {\n+            MetadataNode metadata = formatNode(serviceDeclarationNode.metadata().get(), 1, 0);\n+            serviceDeclarationNode = serviceDeclarationNode.modify().withMetadata(metadata).apply();\n+        }\n+\n+        Token serviceKeyword = formatToken(serviceDeclarationNode.serviceKeyword(), 1, 0);\n+        IdentifierToken serviceName = formatToken(serviceDeclarationNode.serviceName(), 1, 0);\n+        Token onKeyword = formatToken(serviceDeclarationNode.onKeyword(), 1, 0);\n+        SeparatedNodeList<ExpressionNode> expressions =\n+                formatSeparatedNodeList(serviceDeclarationNode.expressions(), 0, 0, 0, 0);\n+        Node serviceBody = formatNode(serviceDeclarationNode.serviceBody(), this.trailingWS, this.trailingNL);\n+\n+        return serviceDeclarationNode.modify()\n+                .withServiceKeyword(serviceKeyword)\n+                .withServiceName(serviceName)\n+                .withOnKeyword(onKeyword)\n+                .withExpressions(expressions)\n+                .withServiceBody(serviceBody)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ExplicitNewExpressionNode transform(ExplicitNewExpressionNode explicitNewExpressionNode) {\n+        Token newKeywordToken = formatToken(explicitNewExpressionNode.newKeyword(), 1, 0);\n+        TypeDescriptorNode typeDescriptorNode = formatNode(explicitNewExpressionNode.typeDescriptor(), 0, 0);\n+        ParenthesizedArgList parenthesizedArgList = formatNode(explicitNewExpressionNode.parenthesizedArgList(), 0, 0);\n+\n+        return explicitNewExpressionNode.modify()\n+                .withNewKeyword(newKeywordToken)\n+                .withTypeDescriptor(typeDescriptorNode)\n+                .withParenthesizedArgList(parenthesizedArgList)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ParenthesizedArgList transform(ParenthesizedArgList parenthesizedArgList) {\n+        Token openParenToken = formatToken(parenthesizedArgList.openParenToken(), 0, 0);\n+        SeparatedNodeList<FunctionArgumentNode> arguments = formatSeparatedNodeList(parenthesizedArgList\n+                .arguments(), 0, 0, 0, 0);\n+        Token closeParenToken = formatToken(parenthesizedArgList.closeParenToken(), 1, 0);\n+\n+        return parenthesizedArgList.modify()\n+                .withOpenParenToken(openParenToken)\n+                .withArguments(arguments)\n+                .withCloseParenToken(closeParenToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ServiceBodyNode transform(ServiceBodyNode serviceBodyNode) {\n+        Token openBraceToken = formatToken(serviceBodyNode.openBraceToken(), 0, 1);\n+        indent(); // increase indentation for the statements to follow.\n+        NodeList<Node> resources = formatNodeList(serviceBodyNode.resources(), 0, 1, 0, 1);\n+        unindent(); // reset the indentation\n+        Token closeBraceToken = formatToken(serviceBodyNode.closeBraceToken(), this.trailingWS, this.trailingNL);\n+\n+        return serviceBodyNode.modify()\n+                .withOpenBraceToken(openBraceToken)\n+                .withResources(resources)\n+                .withCloseBraceToken(closeBraceToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public QualifiedNameReferenceNode transform(QualifiedNameReferenceNode qualifiedNameReferenceNode) {\n+        Token modulePrefix = formatToken(qualifiedNameReferenceNode.modulePrefix(), 0, 0);\n+        Token colon = formatToken((Token) qualifiedNameReferenceNode.colon(), 0, 0);\n+        IdentifierToken identifier = formatToken(qualifiedNameReferenceNode.identifier(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return qualifiedNameReferenceNode.modify()\n+                .withModulePrefix(modulePrefix)\n+                .withColon(colon)\n+                .withIdentifier(identifier)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ReturnTypeDescriptorNode transform(ReturnTypeDescriptorNode returnTypeDescriptorNode) {\n+        Token returnsKeyword = formatToken(returnTypeDescriptorNode.returnsKeyword(), 1, 0);\n+        NodeList<AnnotationNode> annotations = formatNodeList(returnTypeDescriptorNode.annotations(), 0, 0, 1, 0);\n+        Node type = formatNode(returnTypeDescriptorNode.type(), 1, 0);\n+\n+        return returnTypeDescriptorNode.modify()\n+                .withReturnsKeyword(returnsKeyword)\n+                .withAnnotations(annotations)\n+                .withType(type)\n+                .apply();\n+    }\n+\n+    @Override\n+    public OptionalTypeDescriptorNode transform(OptionalTypeDescriptorNode optionalTypeDescriptorNode) {\n+        Node typeDescriptor = formatNode(optionalTypeDescriptorNode.typeDescriptor(), 0, 0);\n+        Token questionMarkToken = formatToken(optionalTypeDescriptorNode.questionMarkToken(), 1, 0);\n+\n+        return optionalTypeDescriptorNode.modify()\n+                .withTypeDescriptor(typeDescriptor)\n+                .withQuestionMarkToken(questionMarkToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ExpressionStatementNode transform(ExpressionStatementNode expressionStatementNode) {\n+        ExpressionNode expression = formatNode(expressionStatementNode.expression(), this.trailingWS, this.trailingNL);\n+        Token semicolonToken = formatToken(expressionStatementNode.semicolonToken(), this.trailingWS, this.trailingNL);\n+\n+        return expressionStatementNode.modify()\n+                .withExpression(expression)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public CheckExpressionNode transform(CheckExpressionNode checkExpressionNode) {\n+        Token checkKeyword = formatToken(checkExpressionNode.checkKeyword(), 1, 0);\n+        ExpressionNode expressionNode = formatNode(checkExpressionNode.expression(), this.trailingWS, this.trailingNL);\n+\n+        return checkExpressionNode.modify()\n+                .withCheckKeyword(checkKeyword)\n+                .withExpression(expressionNode)\n+                .apply();\n+    }\n+\n+    @Override\n+    public RemoteMethodCallActionNode transform(RemoteMethodCallActionNode remoteMethodCallActionNode) {\n+        ExpressionNode expression = formatNode(remoteMethodCallActionNode.expression(), 0, 0);\n+        Token rightArrowToken = formatToken(remoteMethodCallActionNode.rightArrowToken(), 0, 0);\n+        SimpleNameReferenceNode methodName = formatNode(remoteMethodCallActionNode.methodName(), 0, 0);\n+        Token openParenToken = formatToken(remoteMethodCallActionNode.openParenToken(), 0, 0);\n+        SeparatedNodeList<FunctionArgumentNode> arguments = formatSeparatedNodeList(remoteMethodCallActionNode\n+                .arguments(), 1, 0, 0, 0);\n+        Token closeParenToken = formatToken(remoteMethodCallActionNode.closeParenToken(), 0, 0);\n+\n+        return remoteMethodCallActionNode.modify()\n+                .withExpression(expression)\n+                .withRightArrowToken(rightArrowToken)\n+                .withMethodName(methodName)\n+                .withOpenParenToken(openParenToken)\n+                .withArguments(arguments)\n+                .withCloseParenToken(closeParenToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public SimpleNameReferenceNode transform(SimpleNameReferenceNode simpleNameReferenceNode) {\n+        Token name = formatToken(simpleNameReferenceNode.name(), this.trailingWS, 0);\n+\n+        return simpleNameReferenceNode.modify()\n+                .withName(name)\n+                .apply();\n+    }\n+\n+    @Override\n+    public TypeDefinitionNode transform(TypeDefinitionNode typeDefinitionNode) {\n+        if (typeDefinitionNode.metadata().isPresent()) {\n+            MetadataNode metadata = formatNode(typeDefinitionNode.metadata().get(), 1, 0);\n+            typeDefinitionNode = typeDefinitionNode.modify().withMetadata(metadata).apply();\n+        }\n+        if (typeDefinitionNode.visibilityQualifier().isPresent()) {\n+            Token visibilityQualifier = formatToken(typeDefinitionNode.visibilityQualifier().get(), 1, 0);\n+            typeDefinitionNode = typeDefinitionNode.modify().withVisibilityQualifier(visibilityQualifier).apply();\n+        }\n+\n+        Token typeKeyword = formatToken(typeDefinitionNode.typeKeyword(), 1, 0);\n+        Token typeName = formatToken(typeDefinitionNode.typeName(), 1, 0);\n+        Node typeDescriptor = formatNode(typeDefinitionNode.typeDescriptor(), 1, 0);\n+        Token semicolonToken = formatToken(typeDefinitionNode.semicolonToken(), this.trailingWS, this.trailingNL);\n+\n+        return typeDefinitionNode.modify()\n+                .withTypeKeyword(typeKeyword)\n+                .withTypeName(typeName)\n+                .withTypeDescriptor(typeDescriptor)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public SingletonTypeDescriptorNode transform(SingletonTypeDescriptorNode singletonTypeDescriptorNode) {\n+        ExpressionNode simpleContExprNode = formatNode(singletonTypeDescriptorNode.simpleContExprNode(), 1, 0);\n+        return singletonTypeDescriptorNode.modify()\n+                .withSimpleContExprNode(simpleContExprNode)\n+                .apply();\n+    }\n+\n+    @Override\n+    public WhileStatementNode transform(WhileStatementNode whileStatementNode) {\n+        Token whileKeyword = formatToken(whileStatementNode.whileKeyword(), 1, 0);\n+        ExpressionNode condition = formatNode(whileStatementNode.condition(), 1, 0);\n+        BlockStatementNode whileBody = formatNode(whileStatementNode.whileBody(), this.trailingWS, this.trailingNL);\n+\n+        if (whileStatementNode.onFailClause().isPresent()) {\n+            OnFailClauseNode onFailClause = formatNode(whileStatementNode.onFailClause().get(),\n+                    this.trailingWS, this.trailingNL);\n+            whileStatementNode = whileStatementNode.modify().withOnFailClause(onFailClause).apply();\n+        }\n+\n+        return whileStatementNode.modify()\n+                .withWhileKeyword(whileKeyword)\n+                .withCondition(condition)\n+                .withWhileBody(whileBody)\n+                .apply();\n+    }\n+\n+    @Override\n+    public BracedExpressionNode transform(BracedExpressionNode bracedExpressionNode) {\n+        Token openParen = formatToken(bracedExpressionNode.openParen(), 0, 0);\n+        ExpressionNode expression = formatNode(bracedExpressionNode.expression(), 0, 0);\n+        Token closeParen = formatToken(bracedExpressionNode.closeParen(), 1, 0);\n+\n+        return bracedExpressionNode.modify()\n+                .withOpenParen(openParen)\n+                .withExpression(expression)\n+                .withCloseParen(closeParen)\n+                .apply();\n+    }\n+\n+    @Override\n+    public AssignmentStatementNode transform(AssignmentStatementNode assignmentStatementNode) {\n+        Node varRef = formatNode(assignmentStatementNode.varRef(), 1, 0);\n+        Token equalsToken = formatToken(assignmentStatementNode.equalsToken(), 1, 0);\n+        ExpressionNode expression = formatNode(assignmentStatementNode.expression(), 0, 0);\n+        Token semicolonToken = formatToken(assignmentStatementNode.semicolonToken(), this.trailingWS, this.trailingNL);\n+\n+        return assignmentStatementNode.modify()\n+                .withVarRef(varRef)\n+                .withEqualsToken(equalsToken)\n+                .withExpression(expression)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public CompoundAssignmentStatementNode transform(CompoundAssignmentStatementNode compoundAssignmentStatementNode) {\n+        ExpressionNode lhsExpression = formatNode(compoundAssignmentStatementNode.lhsExpression(), 1, 0);\n+        Token binaryOperator = formatToken(compoundAssignmentStatementNode.binaryOperator(), 0, 0);\n+        Token equalsToken = formatToken(compoundAssignmentStatementNode.equalsToken(), 1, 0);\n+        ExpressionNode rhsExpression = formatNode(compoundAssignmentStatementNode.rhsExpression(), 0, 0);\n+        Token semicolonToken = formatToken(compoundAssignmentStatementNode.semicolonToken(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return compoundAssignmentStatementNode.modify()\n+                .withLhsExpression(lhsExpression)\n+                .withBinaryOperator(binaryOperator)\n+                .withEqualsToken(equalsToken)\n+                .withRhsExpression(rhsExpression)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public DoStatementNode transform(DoStatementNode doStatementNode) {\n+        Token doKeyword = formatToken(doStatementNode.doKeyword(), 1, 0);\n+        BlockStatementNode blockStatement = formatNode(doStatementNode.blockStatement(),\n+                this.trailingWS, this.trailingNL);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a775b9cadbd9a21307035b40d50e91dc8e229ffe"}, "originalPosition": 390}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY5MzQ1OQ==", "bodyText": "I feel we should keep a WS after the last expression.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26121#discussion_r495693459", "createdAt": "2020-09-28T05:17:08Z", "author": {"login": "SupunS"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "diffHunk": "@@ -399,6 +429,392 @@ public RecordFieldWithDefaultValueNode transform(RecordFieldWithDefaultValueNode\n                 .apply();\n     }\n \n+    @Override\n+    public ImportDeclarationNode transform(ImportDeclarationNode importDeclarationNode) {\n+        Token importKeyword = formatToken(importDeclarationNode.importKeyword(), 0, 0);\n+\n+        if (importDeclarationNode.orgName().isPresent()) {\n+            ImportOrgNameNode orgName = formatNode(importDeclarationNode.orgName().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withOrgName(orgName).apply();\n+        }\n+        SeparatedNodeList<IdentifierToken> moduleNames = formatSeparatedNodeList(importDeclarationNode.moduleName(),\n+                0, 0, 0, 0, 0, 0);\n+\n+        if (importDeclarationNode.version().isPresent()) {\n+            ImportVersionNode version = formatNode(importDeclarationNode.version().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withVersion(version).apply();\n+        }\n+        if (importDeclarationNode.prefix().isPresent()) {\n+            ImportPrefixNode prefix = formatNode(importDeclarationNode.prefix().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withPrefix(prefix).apply();\n+        }\n+        Token semicolon = formatToken(importDeclarationNode.semicolon(), 0, 1);\n+\n+        return importDeclarationNode.modify()\n+                .withImportKeyword(importKeyword)\n+                .withModuleName(moduleNames)\n+                .withSemicolon(semicolon)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ServiceDeclarationNode transform(ServiceDeclarationNode serviceDeclarationNode) {\n+        if (serviceDeclarationNode.metadata().isPresent()) {\n+            MetadataNode metadata = formatNode(serviceDeclarationNode.metadata().get(), 1, 0);\n+            serviceDeclarationNode = serviceDeclarationNode.modify().withMetadata(metadata).apply();\n+        }\n+\n+        Token serviceKeyword = formatToken(serviceDeclarationNode.serviceKeyword(), 1, 0);\n+        IdentifierToken serviceName = formatToken(serviceDeclarationNode.serviceName(), 1, 0);\n+        Token onKeyword = formatToken(serviceDeclarationNode.onKeyword(), 1, 0);\n+        SeparatedNodeList<ExpressionNode> expressions =\n+                formatSeparatedNodeList(serviceDeclarationNode.expressions(), 0, 0, 0, 0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a775b9cadbd9a21307035b40d50e91dc8e229ffe"}, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY5NDE5MQ==", "bodyText": "Might need a WS after the binding pattern. otherwise will cause a syntax error", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26121#discussion_r495694191", "createdAt": "2020-09-28T05:20:10Z", "author": {"login": "SupunS"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "diffHunk": "@@ -399,6 +429,392 @@ public RecordFieldWithDefaultValueNode transform(RecordFieldWithDefaultValueNode\n                 .apply();\n     }\n \n+    @Override\n+    public ImportDeclarationNode transform(ImportDeclarationNode importDeclarationNode) {\n+        Token importKeyword = formatToken(importDeclarationNode.importKeyword(), 0, 0);\n+\n+        if (importDeclarationNode.orgName().isPresent()) {\n+            ImportOrgNameNode orgName = formatNode(importDeclarationNode.orgName().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withOrgName(orgName).apply();\n+        }\n+        SeparatedNodeList<IdentifierToken> moduleNames = formatSeparatedNodeList(importDeclarationNode.moduleName(),\n+                0, 0, 0, 0, 0, 0);\n+\n+        if (importDeclarationNode.version().isPresent()) {\n+            ImportVersionNode version = formatNode(importDeclarationNode.version().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withVersion(version).apply();\n+        }\n+        if (importDeclarationNode.prefix().isPresent()) {\n+            ImportPrefixNode prefix = formatNode(importDeclarationNode.prefix().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withPrefix(prefix).apply();\n+        }\n+        Token semicolon = formatToken(importDeclarationNode.semicolon(), 0, 1);\n+\n+        return importDeclarationNode.modify()\n+                .withImportKeyword(importKeyword)\n+                .withModuleName(moduleNames)\n+                .withSemicolon(semicolon)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ServiceDeclarationNode transform(ServiceDeclarationNode serviceDeclarationNode) {\n+        if (serviceDeclarationNode.metadata().isPresent()) {\n+            MetadataNode metadata = formatNode(serviceDeclarationNode.metadata().get(), 1, 0);\n+            serviceDeclarationNode = serviceDeclarationNode.modify().withMetadata(metadata).apply();\n+        }\n+\n+        Token serviceKeyword = formatToken(serviceDeclarationNode.serviceKeyword(), 1, 0);\n+        IdentifierToken serviceName = formatToken(serviceDeclarationNode.serviceName(), 1, 0);\n+        Token onKeyword = formatToken(serviceDeclarationNode.onKeyword(), 1, 0);\n+        SeparatedNodeList<ExpressionNode> expressions =\n+                formatSeparatedNodeList(serviceDeclarationNode.expressions(), 0, 0, 0, 0);\n+        Node serviceBody = formatNode(serviceDeclarationNode.serviceBody(), this.trailingWS, this.trailingNL);\n+\n+        return serviceDeclarationNode.modify()\n+                .withServiceKeyword(serviceKeyword)\n+                .withServiceName(serviceName)\n+                .withOnKeyword(onKeyword)\n+                .withExpressions(expressions)\n+                .withServiceBody(serviceBody)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ExplicitNewExpressionNode transform(ExplicitNewExpressionNode explicitNewExpressionNode) {\n+        Token newKeywordToken = formatToken(explicitNewExpressionNode.newKeyword(), 1, 0);\n+        TypeDescriptorNode typeDescriptorNode = formatNode(explicitNewExpressionNode.typeDescriptor(), 0, 0);\n+        ParenthesizedArgList parenthesizedArgList = formatNode(explicitNewExpressionNode.parenthesizedArgList(), 0, 0);\n+\n+        return explicitNewExpressionNode.modify()\n+                .withNewKeyword(newKeywordToken)\n+                .withTypeDescriptor(typeDescriptorNode)\n+                .withParenthesizedArgList(parenthesizedArgList)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ParenthesizedArgList transform(ParenthesizedArgList parenthesizedArgList) {\n+        Token openParenToken = formatToken(parenthesizedArgList.openParenToken(), 0, 0);\n+        SeparatedNodeList<FunctionArgumentNode> arguments = formatSeparatedNodeList(parenthesizedArgList\n+                .arguments(), 0, 0, 0, 0);\n+        Token closeParenToken = formatToken(parenthesizedArgList.closeParenToken(), 1, 0);\n+\n+        return parenthesizedArgList.modify()\n+                .withOpenParenToken(openParenToken)\n+                .withArguments(arguments)\n+                .withCloseParenToken(closeParenToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ServiceBodyNode transform(ServiceBodyNode serviceBodyNode) {\n+        Token openBraceToken = formatToken(serviceBodyNode.openBraceToken(), 0, 1);\n+        indent(); // increase indentation for the statements to follow.\n+        NodeList<Node> resources = formatNodeList(serviceBodyNode.resources(), 0, 1, 0, 1);\n+        unindent(); // reset the indentation\n+        Token closeBraceToken = formatToken(serviceBodyNode.closeBraceToken(), this.trailingWS, this.trailingNL);\n+\n+        return serviceBodyNode.modify()\n+                .withOpenBraceToken(openBraceToken)\n+                .withResources(resources)\n+                .withCloseBraceToken(closeBraceToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public QualifiedNameReferenceNode transform(QualifiedNameReferenceNode qualifiedNameReferenceNode) {\n+        Token modulePrefix = formatToken(qualifiedNameReferenceNode.modulePrefix(), 0, 0);\n+        Token colon = formatToken((Token) qualifiedNameReferenceNode.colon(), 0, 0);\n+        IdentifierToken identifier = formatToken(qualifiedNameReferenceNode.identifier(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return qualifiedNameReferenceNode.modify()\n+                .withModulePrefix(modulePrefix)\n+                .withColon(colon)\n+                .withIdentifier(identifier)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ReturnTypeDescriptorNode transform(ReturnTypeDescriptorNode returnTypeDescriptorNode) {\n+        Token returnsKeyword = formatToken(returnTypeDescriptorNode.returnsKeyword(), 1, 0);\n+        NodeList<AnnotationNode> annotations = formatNodeList(returnTypeDescriptorNode.annotations(), 0, 0, 1, 0);\n+        Node type = formatNode(returnTypeDescriptorNode.type(), 1, 0);\n+\n+        return returnTypeDescriptorNode.modify()\n+                .withReturnsKeyword(returnsKeyword)\n+                .withAnnotations(annotations)\n+                .withType(type)\n+                .apply();\n+    }\n+\n+    @Override\n+    public OptionalTypeDescriptorNode transform(OptionalTypeDescriptorNode optionalTypeDescriptorNode) {\n+        Node typeDescriptor = formatNode(optionalTypeDescriptorNode.typeDescriptor(), 0, 0);\n+        Token questionMarkToken = formatToken(optionalTypeDescriptorNode.questionMarkToken(), 1, 0);\n+\n+        return optionalTypeDescriptorNode.modify()\n+                .withTypeDescriptor(typeDescriptor)\n+                .withQuestionMarkToken(questionMarkToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ExpressionStatementNode transform(ExpressionStatementNode expressionStatementNode) {\n+        ExpressionNode expression = formatNode(expressionStatementNode.expression(), this.trailingWS, this.trailingNL);\n+        Token semicolonToken = formatToken(expressionStatementNode.semicolonToken(), this.trailingWS, this.trailingNL);\n+\n+        return expressionStatementNode.modify()\n+                .withExpression(expression)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public CheckExpressionNode transform(CheckExpressionNode checkExpressionNode) {\n+        Token checkKeyword = formatToken(checkExpressionNode.checkKeyword(), 1, 0);\n+        ExpressionNode expressionNode = formatNode(checkExpressionNode.expression(), this.trailingWS, this.trailingNL);\n+\n+        return checkExpressionNode.modify()\n+                .withCheckKeyword(checkKeyword)\n+                .withExpression(expressionNode)\n+                .apply();\n+    }\n+\n+    @Override\n+    public RemoteMethodCallActionNode transform(RemoteMethodCallActionNode remoteMethodCallActionNode) {\n+        ExpressionNode expression = formatNode(remoteMethodCallActionNode.expression(), 0, 0);\n+        Token rightArrowToken = formatToken(remoteMethodCallActionNode.rightArrowToken(), 0, 0);\n+        SimpleNameReferenceNode methodName = formatNode(remoteMethodCallActionNode.methodName(), 0, 0);\n+        Token openParenToken = formatToken(remoteMethodCallActionNode.openParenToken(), 0, 0);\n+        SeparatedNodeList<FunctionArgumentNode> arguments = formatSeparatedNodeList(remoteMethodCallActionNode\n+                .arguments(), 1, 0, 0, 0);\n+        Token closeParenToken = formatToken(remoteMethodCallActionNode.closeParenToken(), 0, 0);\n+\n+        return remoteMethodCallActionNode.modify()\n+                .withExpression(expression)\n+                .withRightArrowToken(rightArrowToken)\n+                .withMethodName(methodName)\n+                .withOpenParenToken(openParenToken)\n+                .withArguments(arguments)\n+                .withCloseParenToken(closeParenToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public SimpleNameReferenceNode transform(SimpleNameReferenceNode simpleNameReferenceNode) {\n+        Token name = formatToken(simpleNameReferenceNode.name(), this.trailingWS, 0);\n+\n+        return simpleNameReferenceNode.modify()\n+                .withName(name)\n+                .apply();\n+    }\n+\n+    @Override\n+    public TypeDefinitionNode transform(TypeDefinitionNode typeDefinitionNode) {\n+        if (typeDefinitionNode.metadata().isPresent()) {\n+            MetadataNode metadata = formatNode(typeDefinitionNode.metadata().get(), 1, 0);\n+            typeDefinitionNode = typeDefinitionNode.modify().withMetadata(metadata).apply();\n+        }\n+        if (typeDefinitionNode.visibilityQualifier().isPresent()) {\n+            Token visibilityQualifier = formatToken(typeDefinitionNode.visibilityQualifier().get(), 1, 0);\n+            typeDefinitionNode = typeDefinitionNode.modify().withVisibilityQualifier(visibilityQualifier).apply();\n+        }\n+\n+        Token typeKeyword = formatToken(typeDefinitionNode.typeKeyword(), 1, 0);\n+        Token typeName = formatToken(typeDefinitionNode.typeName(), 1, 0);\n+        Node typeDescriptor = formatNode(typeDefinitionNode.typeDescriptor(), 1, 0);\n+        Token semicolonToken = formatToken(typeDefinitionNode.semicolonToken(), this.trailingWS, this.trailingNL);\n+\n+        return typeDefinitionNode.modify()\n+                .withTypeKeyword(typeKeyword)\n+                .withTypeName(typeName)\n+                .withTypeDescriptor(typeDescriptor)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public SingletonTypeDescriptorNode transform(SingletonTypeDescriptorNode singletonTypeDescriptorNode) {\n+        ExpressionNode simpleContExprNode = formatNode(singletonTypeDescriptorNode.simpleContExprNode(), 1, 0);\n+        return singletonTypeDescriptorNode.modify()\n+                .withSimpleContExprNode(simpleContExprNode)\n+                .apply();\n+    }\n+\n+    @Override\n+    public WhileStatementNode transform(WhileStatementNode whileStatementNode) {\n+        Token whileKeyword = formatToken(whileStatementNode.whileKeyword(), 1, 0);\n+        ExpressionNode condition = formatNode(whileStatementNode.condition(), 1, 0);\n+        BlockStatementNode whileBody = formatNode(whileStatementNode.whileBody(), this.trailingWS, this.trailingNL);\n+\n+        if (whileStatementNode.onFailClause().isPresent()) {\n+            OnFailClauseNode onFailClause = formatNode(whileStatementNode.onFailClause().get(),\n+                    this.trailingWS, this.trailingNL);\n+            whileStatementNode = whileStatementNode.modify().withOnFailClause(onFailClause).apply();\n+        }\n+\n+        return whileStatementNode.modify()\n+                .withWhileKeyword(whileKeyword)\n+                .withCondition(condition)\n+                .withWhileBody(whileBody)\n+                .apply();\n+    }\n+\n+    @Override\n+    public BracedExpressionNode transform(BracedExpressionNode bracedExpressionNode) {\n+        Token openParen = formatToken(bracedExpressionNode.openParen(), 0, 0);\n+        ExpressionNode expression = formatNode(bracedExpressionNode.expression(), 0, 0);\n+        Token closeParen = formatToken(bracedExpressionNode.closeParen(), 1, 0);\n+\n+        return bracedExpressionNode.modify()\n+                .withOpenParen(openParen)\n+                .withExpression(expression)\n+                .withCloseParen(closeParen)\n+                .apply();\n+    }\n+\n+    @Override\n+    public AssignmentStatementNode transform(AssignmentStatementNode assignmentStatementNode) {\n+        Node varRef = formatNode(assignmentStatementNode.varRef(), 1, 0);\n+        Token equalsToken = formatToken(assignmentStatementNode.equalsToken(), 1, 0);\n+        ExpressionNode expression = formatNode(assignmentStatementNode.expression(), 0, 0);\n+        Token semicolonToken = formatToken(assignmentStatementNode.semicolonToken(), this.trailingWS, this.trailingNL);\n+\n+        return assignmentStatementNode.modify()\n+                .withVarRef(varRef)\n+                .withEqualsToken(equalsToken)\n+                .withExpression(expression)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public CompoundAssignmentStatementNode transform(CompoundAssignmentStatementNode compoundAssignmentStatementNode) {\n+        ExpressionNode lhsExpression = formatNode(compoundAssignmentStatementNode.lhsExpression(), 1, 0);\n+        Token binaryOperator = formatToken(compoundAssignmentStatementNode.binaryOperator(), 0, 0);\n+        Token equalsToken = formatToken(compoundAssignmentStatementNode.equalsToken(), 1, 0);\n+        ExpressionNode rhsExpression = formatNode(compoundAssignmentStatementNode.rhsExpression(), 0, 0);\n+        Token semicolonToken = formatToken(compoundAssignmentStatementNode.semicolonToken(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return compoundAssignmentStatementNode.modify()\n+                .withLhsExpression(lhsExpression)\n+                .withBinaryOperator(binaryOperator)\n+                .withEqualsToken(equalsToken)\n+                .withRhsExpression(rhsExpression)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public DoStatementNode transform(DoStatementNode doStatementNode) {\n+        Token doKeyword = formatToken(doStatementNode.doKeyword(), 1, 0);\n+        BlockStatementNode blockStatement = formatNode(doStatementNode.blockStatement(),\n+                this.trailingWS, this.trailingNL);\n+\n+        if (doStatementNode.onFailClause().isPresent()) {\n+            OnFailClauseNode onFailClause = formatNode(doStatementNode.onFailClause().get(),\n+                    this.trailingWS, this.trailingNL);\n+            doStatementNode = doStatementNode.modify().withOnFailClause(onFailClause).apply();\n+        }\n+\n+        return doStatementNode.modify()\n+                .withDoKeyword(doKeyword)\n+                .withBlockStatement(blockStatement)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ForEachStatementNode transform(ForEachStatementNode forEachStatementNode) {\n+        Token forEachKeyword = formatToken(forEachStatementNode.forEachKeyword(), 1, 0);\n+        TypedBindingPatternNode typedBindingPattern = formatNode(forEachStatementNode.typedBindingPattern(), 0, 0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a775b9cadbd9a21307035b40d50e91dc8e229ffe"}, "originalPosition": 407}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "79c525c19eeed07ce810afdb3aa2eb4753eef6a4", "author": {"user": {"login": "IrushiL", "name": "Irushi Liyanage"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/79c525c19eeed07ce810afdb3aa2eb4753eef6a4", "committedDate": "2020-09-28T07:42:01Z", "message": "Fix the import declaration statements"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c30db141252806ea0e358151d09f38f8c860f358", "author": {"user": {"login": "IrushiL", "name": "Irushi Liyanage"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c30db141252806ea0e358151d09f38f8c860f358", "committedDate": "2020-09-28T08:42:35Z", "message": "Fix review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5bd7b0d855a3e4ed165fc3da4b34b7de38a82199", "author": {"user": {"login": "IrushiL", "name": "Irushi Liyanage"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/5bd7b0d855a3e4ed165fc3da4b34b7de38a82199", "committedDate": "2020-09-28T11:55:23Z", "message": "Fix issues in the indentation logic"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3NDQ0MDU0", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26121#pullrequestreview-497444054", "createdAt": "2020-09-28T12:04:47Z", "commit": {"oid": "5bd7b0d855a3e4ed165fc3da4b34b7de38a82199"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxMjowNDo0N1rOHY6kTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxMjowNzo1MVrOHY6qbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg4NzQzOQ==", "bodyText": "moving this inside the below if (hasOnFailClause) { block would be cleaner..", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26121#discussion_r495887439", "createdAt": "2020-09-28T12:04:47Z", "author": {"login": "SupunS"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "diffHunk": "@@ -399,6 +429,436 @@ public RecordFieldWithDefaultValueNode transform(RecordFieldWithDefaultValueNode\n                 .apply();\n     }\n \n+    @Override\n+    public ImportDeclarationNode transform(ImportDeclarationNode importDeclarationNode) {\n+        Token importKeyword = formatToken(importDeclarationNode.importKeyword(), 1, 0);\n+\n+        boolean hasOrgName = importDeclarationNode.orgName().isPresent();\n+        boolean hasVersion = importDeclarationNode.version().isPresent();\n+        boolean hasPrefix = importDeclarationNode.prefix().isPresent();\n+\n+        if (hasOrgName) {\n+            ImportOrgNameNode orgName = formatNode(importDeclarationNode.orgName().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withOrgName(orgName).apply();\n+        }\n+        SeparatedNodeList<IdentifierToken> moduleNames = formatSeparatedNodeList(importDeclarationNode.moduleName(),\n+                0, 0, 0, 0, (hasVersion || hasPrefix) ? 1 : 0, 0);\n+\n+        if (hasVersion) {\n+            ImportVersionNode version = formatNode(importDeclarationNode.version().get(), hasPrefix ? 1 : 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withVersion(version).apply();\n+        }\n+        if (hasPrefix) {\n+            ImportPrefixNode prefix = formatNode(importDeclarationNode.prefix().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withPrefix(prefix).apply();\n+        }\n+        Token semicolon = formatToken(importDeclarationNode.semicolon(), this.trailingWS, this.trailingNL);\n+\n+        return importDeclarationNode.modify()\n+                .withImportKeyword(importKeyword)\n+                .withModuleName(moduleNames)\n+                .withSemicolon(semicolon)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ImportOrgNameNode transform(ImportOrgNameNode importOrgNameNode) {\n+        Token orgName = formatToken(importOrgNameNode.orgName(), 0, 0);\n+        Token slashToken = formatToken(importOrgNameNode.slashToken(), 0, 0);\n+\n+        return importOrgNameNode.modify()\n+                .withOrgName(orgName)\n+                .withSlashToken(slashToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ImportPrefixNode transform(ImportPrefixNode importPrefixNode) {\n+        Token asKeyword = formatToken(importPrefixNode.asKeyword(), 1, 0);\n+        Token prefix = formatToken(importPrefixNode.prefix(), 0, 0);\n+\n+        return importPrefixNode.modify()\n+                .withAsKeyword(asKeyword)\n+                .withPrefix(prefix)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ImportVersionNode transform(ImportVersionNode importVersionNode) {\n+        Token versionKeyword = formatToken(importVersionNode.versionKeyword(), 1, 0);\n+        SeparatedNodeList<Token> versionNumber = formatSeparatedNodeList(importVersionNode.versionNumber(),\n+                0, 0, 0, 0, this.trailingWS, 0);\n+\n+        return importVersionNode.modify()\n+                .withVersionKeyword(versionKeyword)\n+                .withVersionNumber(versionNumber)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ServiceDeclarationNode transform(ServiceDeclarationNode serviceDeclarationNode) {\n+        if (serviceDeclarationNode.metadata().isPresent()) {\n+            MetadataNode metadata = formatNode(serviceDeclarationNode.metadata().get(), 1, 0);\n+            serviceDeclarationNode = serviceDeclarationNode.modify().withMetadata(metadata).apply();\n+        }\n+\n+        Token serviceKeyword = formatToken(serviceDeclarationNode.serviceKeyword(), 1, 0);\n+        IdentifierToken serviceName = formatToken(serviceDeclarationNode.serviceName(), 1, 0);\n+        Token onKeyword = formatToken(serviceDeclarationNode.onKeyword(), 1, 0);\n+        SeparatedNodeList<ExpressionNode> expressions =\n+                formatSeparatedNodeList(serviceDeclarationNode.expressions(), 0, 0, 1, 0);\n+        Node serviceBody = formatNode(serviceDeclarationNode.serviceBody(), this.trailingWS, this.trailingNL);\n+\n+        return serviceDeclarationNode.modify()\n+                .withServiceKeyword(serviceKeyword)\n+                .withServiceName(serviceName)\n+                .withOnKeyword(onKeyword)\n+                .withExpressions(expressions)\n+                .withServiceBody(serviceBody)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ExplicitNewExpressionNode transform(ExplicitNewExpressionNode explicitNewExpressionNode) {\n+        Token newKeywordToken = formatToken(explicitNewExpressionNode.newKeyword(), 1, 0);\n+        TypeDescriptorNode typeDescriptorNode = formatNode(explicitNewExpressionNode.typeDescriptor(), 0, 0);\n+        ParenthesizedArgList parenthesizedArgList = formatNode(explicitNewExpressionNode.parenthesizedArgList(), 0, 0);\n+\n+        return explicitNewExpressionNode.modify()\n+                .withNewKeyword(newKeywordToken)\n+                .withTypeDescriptor(typeDescriptorNode)\n+                .withParenthesizedArgList(parenthesizedArgList)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ParenthesizedArgList transform(ParenthesizedArgList parenthesizedArgList) {\n+        Token openParenToken = formatToken(parenthesizedArgList.openParenToken(), 0, 0);\n+        SeparatedNodeList<FunctionArgumentNode> arguments = formatSeparatedNodeList(parenthesizedArgList\n+                .arguments(), 0, 0, 0, 0);\n+        Token closeParenToken = formatToken(parenthesizedArgList.closeParenToken(), this.trailingWS, this.trailingNL);\n+\n+        return parenthesizedArgList.modify()\n+                .withOpenParenToken(openParenToken)\n+                .withArguments(arguments)\n+                .withCloseParenToken(closeParenToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ServiceBodyNode transform(ServiceBodyNode serviceBodyNode) {\n+        Token openBraceToken = formatToken(serviceBodyNode.openBraceToken(), 0, 1);\n+        indent(); // increase indentation for the statements to follow.\n+        NodeList<Node> resources = formatNodeList(serviceBodyNode.resources(), 0, 1, 0, 1);\n+        unindent(); // reset the indentation\n+        Token closeBraceToken = formatToken(serviceBodyNode.closeBraceToken(), this.trailingWS, this.trailingNL);\n+\n+        return serviceBodyNode.modify()\n+                .withOpenBraceToken(openBraceToken)\n+                .withResources(resources)\n+                .withCloseBraceToken(closeBraceToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public QualifiedNameReferenceNode transform(QualifiedNameReferenceNode qualifiedNameReferenceNode) {\n+        Token modulePrefix = formatToken(qualifiedNameReferenceNode.modulePrefix(), 0, 0);\n+        Token colon = formatToken((Token) qualifiedNameReferenceNode.colon(), 0, 0);\n+        IdentifierToken identifier = formatToken(qualifiedNameReferenceNode.identifier(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return qualifiedNameReferenceNode.modify()\n+                .withModulePrefix(modulePrefix)\n+                .withColon(colon)\n+                .withIdentifier(identifier)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ReturnTypeDescriptorNode transform(ReturnTypeDescriptorNode returnTypeDescriptorNode) {\n+        Token returnsKeyword = formatToken(returnTypeDescriptorNode.returnsKeyword(), 1, 0);\n+        NodeList<AnnotationNode> annotations = formatNodeList(returnTypeDescriptorNode.annotations(), 0, 0, 1, 0);\n+        Node type = formatNode(returnTypeDescriptorNode.type(), 1, 0);\n+\n+        return returnTypeDescriptorNode.modify()\n+                .withReturnsKeyword(returnsKeyword)\n+                .withAnnotations(annotations)\n+                .withType(type)\n+                .apply();\n+    }\n+\n+    @Override\n+    public OptionalTypeDescriptorNode transform(OptionalTypeDescriptorNode optionalTypeDescriptorNode) {\n+        Node typeDescriptor = formatNode(optionalTypeDescriptorNode.typeDescriptor(), 0, 0);\n+        Token questionMarkToken = formatToken(optionalTypeDescriptorNode.questionMarkToken(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return optionalTypeDescriptorNode.modify()\n+                .withTypeDescriptor(typeDescriptor)\n+                .withQuestionMarkToken(questionMarkToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ExpressionStatementNode transform(ExpressionStatementNode expressionStatementNode) {\n+        ExpressionNode expression = formatNode(expressionStatementNode.expression(), 0, 0);\n+        Token semicolonToken = formatToken(expressionStatementNode.semicolonToken(), this.trailingWS, this.trailingNL);\n+\n+        return expressionStatementNode.modify()\n+                .withExpression(expression)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public CheckExpressionNode transform(CheckExpressionNode checkExpressionNode) {\n+        Token checkKeyword = formatToken(checkExpressionNode.checkKeyword(), 1, 0);\n+        ExpressionNode expressionNode = formatNode(checkExpressionNode.expression(), this.trailingWS, this.trailingNL);\n+\n+        return checkExpressionNode.modify()\n+                .withCheckKeyword(checkKeyword)\n+                .withExpression(expressionNode)\n+                .apply();\n+    }\n+\n+    @Override\n+    public RemoteMethodCallActionNode transform(RemoteMethodCallActionNode remoteMethodCallActionNode) {\n+        ExpressionNode expression = formatNode(remoteMethodCallActionNode.expression(), 0, 0);\n+        Token rightArrowToken = formatToken(remoteMethodCallActionNode.rightArrowToken(), 0, 0);\n+        SimpleNameReferenceNode methodName = formatNode(remoteMethodCallActionNode.methodName(), 0, 0);\n+        Token openParenToken = formatToken(remoteMethodCallActionNode.openParenToken(), 0, 0);\n+        SeparatedNodeList<FunctionArgumentNode> arguments = formatSeparatedNodeList(remoteMethodCallActionNode\n+                .arguments(), 1, 0, 0, 0);\n+        Token closeParenToken = formatToken(remoteMethodCallActionNode.closeParenToken(), this.trailingWS, this.trailingNL);\n+\n+        return remoteMethodCallActionNode.modify()\n+                .withExpression(expression)\n+                .withRightArrowToken(rightArrowToken)\n+                .withMethodName(methodName)\n+                .withOpenParenToken(openParenToken)\n+                .withArguments(arguments)\n+                .withCloseParenToken(closeParenToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public SimpleNameReferenceNode transform(SimpleNameReferenceNode simpleNameReferenceNode) {\n+        Token name = formatToken(simpleNameReferenceNode.name(), this.trailingWS, this.trailingNL);\n+\n+        return simpleNameReferenceNode.modify()\n+                .withName(name)\n+                .apply();\n+    }\n+\n+    @Override\n+    public TypeDefinitionNode transform(TypeDefinitionNode typeDefinitionNode) {\n+        if (typeDefinitionNode.metadata().isPresent()) {\n+            MetadataNode metadata = formatNode(typeDefinitionNode.metadata().get(), 1, 0);\n+            typeDefinitionNode = typeDefinitionNode.modify().withMetadata(metadata).apply();\n+        }\n+        if (typeDefinitionNode.visibilityQualifier().isPresent()) {\n+            Token visibilityQualifier = formatToken(typeDefinitionNode.visibilityQualifier().get(), 1, 0);\n+            typeDefinitionNode = typeDefinitionNode.modify().withVisibilityQualifier(visibilityQualifier).apply();\n+        }\n+\n+        Token typeKeyword = formatToken(typeDefinitionNode.typeKeyword(), 1, 0);\n+        Token typeName = formatToken(typeDefinitionNode.typeName(), 1, 0);\n+        Node typeDescriptor = formatNode(typeDefinitionNode.typeDescriptor(), 1, 0);\n+        Token semicolonToken = formatToken(typeDefinitionNode.semicolonToken(), this.trailingWS, this.trailingNL);\n+\n+        return typeDefinitionNode.modify()\n+                .withTypeKeyword(typeKeyword)\n+                .withTypeName(typeName)\n+                .withTypeDescriptor(typeDescriptor)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public SingletonTypeDescriptorNode transform(SingletonTypeDescriptorNode singletonTypeDescriptorNode) {\n+        ExpressionNode simpleContExprNode = formatNode(singletonTypeDescriptorNode.simpleContExprNode(), 1, 0);\n+        return singletonTypeDescriptorNode.modify()\n+                .withSimpleContExprNode(simpleContExprNode)\n+                .apply();\n+    }\n+\n+    @Override\n+    public WhileStatementNode transform(WhileStatementNode whileStatementNode) {\n+        boolean hasOnFailClause = whileStatementNode.onFailClause().isPresent();\n+        Token whileKeyword = formatToken(whileStatementNode.whileKeyword(), 1, 0);\n+        ExpressionNode condition = formatNode(whileStatementNode.condition(), 1, 0);\n+        BlockStatementNode whileBody = formatNode(whileStatementNode.whileBody(),\n+                hasOnFailClause ? 1 : this.trailingWS, hasOnFailClause ? 0 : this.trailingNL);\n+\n+        if (hasOnFailClause) {\n+            OnFailClauseNode onFailClause = formatNode(whileStatementNode.onFailClause().get(),\n+                    this.trailingWS, this.trailingNL);\n+            whileStatementNode = whileStatementNode.modify().withOnFailClause(onFailClause).apply();\n+        }\n+\n+        return whileStatementNode.modify()\n+                .withWhileKeyword(whileKeyword)\n+                .withCondition(condition)\n+                .withWhileBody(whileBody)\n+                .apply();\n+    }\n+\n+    @Override\n+    public BracedExpressionNode transform(BracedExpressionNode bracedExpressionNode) {\n+        Token openParen = formatToken(bracedExpressionNode.openParen(), 0, 0);\n+        ExpressionNode expression = formatNode(bracedExpressionNode.expression(), 0, 0);\n+        Token closeParen = formatToken(bracedExpressionNode.closeParen(), this.trailingWS, this.trailingNL);\n+\n+        return bracedExpressionNode.modify()\n+                .withOpenParen(openParen)\n+                .withExpression(expression)\n+                .withCloseParen(closeParen)\n+                .apply();\n+    }\n+\n+    @Override\n+    public AssignmentStatementNode transform(AssignmentStatementNode assignmentStatementNode) {\n+        Node varRef = formatNode(assignmentStatementNode.varRef(), 1, 0);\n+        Token equalsToken = formatToken(assignmentStatementNode.equalsToken(), 1, 0);\n+        ExpressionNode expression = formatNode(assignmentStatementNode.expression(), 0, 0);\n+        Token semicolonToken = formatToken(assignmentStatementNode.semicolonToken(), this.trailingWS, this.trailingNL);\n+\n+        return assignmentStatementNode.modify()\n+                .withVarRef(varRef)\n+                .withEqualsToken(equalsToken)\n+                .withExpression(expression)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public CompoundAssignmentStatementNode transform(CompoundAssignmentStatementNode compoundAssignmentStatementNode) {\n+        ExpressionNode lhsExpression = formatNode(compoundAssignmentStatementNode.lhsExpression(), 1, 0);\n+        Token binaryOperator = formatToken(compoundAssignmentStatementNode.binaryOperator(), 0, 0);\n+        Token equalsToken = formatToken(compoundAssignmentStatementNode.equalsToken(), 1, 0);\n+        ExpressionNode rhsExpression = formatNode(compoundAssignmentStatementNode.rhsExpression(), 0, 0);\n+        Token semicolonToken = formatToken(compoundAssignmentStatementNode.semicolonToken(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return compoundAssignmentStatementNode.modify()\n+                .withLhsExpression(lhsExpression)\n+                .withBinaryOperator(binaryOperator)\n+                .withEqualsToken(equalsToken)\n+                .withRhsExpression(rhsExpression)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public DoStatementNode transform(DoStatementNode doStatementNode) {\n+        boolean hasOnFailClause = doStatementNode.onFailClause().isPresent();\n+\n+        Token doKeyword = formatToken(doStatementNode.doKeyword(), 1, 0);\n+        BlockStatementNode blockStatement = formatNode(doStatementNode.blockStatement(),\n+                hasOnFailClause ? 1 : this.trailingWS, hasOnFailClause ? 0 : this.trailingNL);\n+\n+        if (hasOnFailClause) {\n+            OnFailClauseNode onFailClause = formatNode(doStatementNode.onFailClause().get(),\n+                    this.trailingWS, this.trailingNL);\n+            doStatementNode = doStatementNode.modify().withOnFailClause(onFailClause).apply();\n+        }\n+\n+        return doStatementNode.modify()\n+                .withDoKeyword(doKeyword)\n+                .withBlockStatement(blockStatement)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ForEachStatementNode transform(ForEachStatementNode forEachStatementNode) {\n+        boolean hasOnFailClause = forEachStatementNode.onFailClause().isPresent();\n+\n+        Token forEachKeyword = formatToken(forEachStatementNode.forEachKeyword(), 1, 0);\n+        TypedBindingPatternNode typedBindingPattern = formatNode(forEachStatementNode.typedBindingPattern(), 1, 0);\n+        Token inKeyword = formatToken(forEachStatementNode.inKeyword(), 1, 0);\n+        Node actionOrExpressionNode = formatNode(forEachStatementNode.actionOrExpressionNode(), 1, 0);\n+        StatementNode blockStatement = formatNode(forEachStatementNode.blockStatement(),\n+                hasOnFailClause ? 1 : this.trailingWS, hasOnFailClause ? 0 : this.trailingNL);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bd7b0d855a3e4ed165fc3da4b34b7de38a82199"}, "originalPosition": 456}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg4NzgzMA==", "bodyText": "should use global var for WS and NL", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26121#discussion_r495887830", "createdAt": "2020-09-28T12:05:31Z", "author": {"login": "SupunS"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "diffHunk": "@@ -399,6 +429,436 @@ public RecordFieldWithDefaultValueNode transform(RecordFieldWithDefaultValueNode\n                 .apply();\n     }\n \n+    @Override\n+    public ImportDeclarationNode transform(ImportDeclarationNode importDeclarationNode) {\n+        Token importKeyword = formatToken(importDeclarationNode.importKeyword(), 1, 0);\n+\n+        boolean hasOrgName = importDeclarationNode.orgName().isPresent();\n+        boolean hasVersion = importDeclarationNode.version().isPresent();\n+        boolean hasPrefix = importDeclarationNode.prefix().isPresent();\n+\n+        if (hasOrgName) {\n+            ImportOrgNameNode orgName = formatNode(importDeclarationNode.orgName().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withOrgName(orgName).apply();\n+        }\n+        SeparatedNodeList<IdentifierToken> moduleNames = formatSeparatedNodeList(importDeclarationNode.moduleName(),\n+                0, 0, 0, 0, (hasVersion || hasPrefix) ? 1 : 0, 0);\n+\n+        if (hasVersion) {\n+            ImportVersionNode version = formatNode(importDeclarationNode.version().get(), hasPrefix ? 1 : 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withVersion(version).apply();\n+        }\n+        if (hasPrefix) {\n+            ImportPrefixNode prefix = formatNode(importDeclarationNode.prefix().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withPrefix(prefix).apply();\n+        }\n+        Token semicolon = formatToken(importDeclarationNode.semicolon(), this.trailingWS, this.trailingNL);\n+\n+        return importDeclarationNode.modify()\n+                .withImportKeyword(importKeyword)\n+                .withModuleName(moduleNames)\n+                .withSemicolon(semicolon)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ImportOrgNameNode transform(ImportOrgNameNode importOrgNameNode) {\n+        Token orgName = formatToken(importOrgNameNode.orgName(), 0, 0);\n+        Token slashToken = formatToken(importOrgNameNode.slashToken(), 0, 0);\n+\n+        return importOrgNameNode.modify()\n+                .withOrgName(orgName)\n+                .withSlashToken(slashToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ImportPrefixNode transform(ImportPrefixNode importPrefixNode) {\n+        Token asKeyword = formatToken(importPrefixNode.asKeyword(), 1, 0);\n+        Token prefix = formatToken(importPrefixNode.prefix(), 0, 0);\n+\n+        return importPrefixNode.modify()\n+                .withAsKeyword(asKeyword)\n+                .withPrefix(prefix)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ImportVersionNode transform(ImportVersionNode importVersionNode) {\n+        Token versionKeyword = formatToken(importVersionNode.versionKeyword(), 1, 0);\n+        SeparatedNodeList<Token> versionNumber = formatSeparatedNodeList(importVersionNode.versionNumber(),\n+                0, 0, 0, 0, this.trailingWS, 0);\n+\n+        return importVersionNode.modify()\n+                .withVersionKeyword(versionKeyword)\n+                .withVersionNumber(versionNumber)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ServiceDeclarationNode transform(ServiceDeclarationNode serviceDeclarationNode) {\n+        if (serviceDeclarationNode.metadata().isPresent()) {\n+            MetadataNode metadata = formatNode(serviceDeclarationNode.metadata().get(), 1, 0);\n+            serviceDeclarationNode = serviceDeclarationNode.modify().withMetadata(metadata).apply();\n+        }\n+\n+        Token serviceKeyword = formatToken(serviceDeclarationNode.serviceKeyword(), 1, 0);\n+        IdentifierToken serviceName = formatToken(serviceDeclarationNode.serviceName(), 1, 0);\n+        Token onKeyword = formatToken(serviceDeclarationNode.onKeyword(), 1, 0);\n+        SeparatedNodeList<ExpressionNode> expressions =\n+                formatSeparatedNodeList(serviceDeclarationNode.expressions(), 0, 0, 1, 0);\n+        Node serviceBody = formatNode(serviceDeclarationNode.serviceBody(), this.trailingWS, this.trailingNL);\n+\n+        return serviceDeclarationNode.modify()\n+                .withServiceKeyword(serviceKeyword)\n+                .withServiceName(serviceName)\n+                .withOnKeyword(onKeyword)\n+                .withExpressions(expressions)\n+                .withServiceBody(serviceBody)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ExplicitNewExpressionNode transform(ExplicitNewExpressionNode explicitNewExpressionNode) {\n+        Token newKeywordToken = formatToken(explicitNewExpressionNode.newKeyword(), 1, 0);\n+        TypeDescriptorNode typeDescriptorNode = formatNode(explicitNewExpressionNode.typeDescriptor(), 0, 0);\n+        ParenthesizedArgList parenthesizedArgList = formatNode(explicitNewExpressionNode.parenthesizedArgList(), 0, 0);\n+\n+        return explicitNewExpressionNode.modify()\n+                .withNewKeyword(newKeywordToken)\n+                .withTypeDescriptor(typeDescriptorNode)\n+                .withParenthesizedArgList(parenthesizedArgList)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ParenthesizedArgList transform(ParenthesizedArgList parenthesizedArgList) {\n+        Token openParenToken = formatToken(parenthesizedArgList.openParenToken(), 0, 0);\n+        SeparatedNodeList<FunctionArgumentNode> arguments = formatSeparatedNodeList(parenthesizedArgList\n+                .arguments(), 0, 0, 0, 0);\n+        Token closeParenToken = formatToken(parenthesizedArgList.closeParenToken(), this.trailingWS, this.trailingNL);\n+\n+        return parenthesizedArgList.modify()\n+                .withOpenParenToken(openParenToken)\n+                .withArguments(arguments)\n+                .withCloseParenToken(closeParenToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ServiceBodyNode transform(ServiceBodyNode serviceBodyNode) {\n+        Token openBraceToken = formatToken(serviceBodyNode.openBraceToken(), 0, 1);\n+        indent(); // increase indentation for the statements to follow.\n+        NodeList<Node> resources = formatNodeList(serviceBodyNode.resources(), 0, 1, 0, 1);\n+        unindent(); // reset the indentation\n+        Token closeBraceToken = formatToken(serviceBodyNode.closeBraceToken(), this.trailingWS, this.trailingNL);\n+\n+        return serviceBodyNode.modify()\n+                .withOpenBraceToken(openBraceToken)\n+                .withResources(resources)\n+                .withCloseBraceToken(closeBraceToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public QualifiedNameReferenceNode transform(QualifiedNameReferenceNode qualifiedNameReferenceNode) {\n+        Token modulePrefix = formatToken(qualifiedNameReferenceNode.modulePrefix(), 0, 0);\n+        Token colon = formatToken((Token) qualifiedNameReferenceNode.colon(), 0, 0);\n+        IdentifierToken identifier = formatToken(qualifiedNameReferenceNode.identifier(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return qualifiedNameReferenceNode.modify()\n+                .withModulePrefix(modulePrefix)\n+                .withColon(colon)\n+                .withIdentifier(identifier)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ReturnTypeDescriptorNode transform(ReturnTypeDescriptorNode returnTypeDescriptorNode) {\n+        Token returnsKeyword = formatToken(returnTypeDescriptorNode.returnsKeyword(), 1, 0);\n+        NodeList<AnnotationNode> annotations = formatNodeList(returnTypeDescriptorNode.annotations(), 0, 0, 1, 0);\n+        Node type = formatNode(returnTypeDescriptorNode.type(), 1, 0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bd7b0d855a3e4ed165fc3da4b34b7de38a82199"}, "originalPosition": 256}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg4NzkzNA==", "bodyText": "should use global var for WS and NL", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26121#discussion_r495887934", "createdAt": "2020-09-28T12:05:44Z", "author": {"login": "SupunS"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "diffHunk": "@@ -399,6 +429,436 @@ public RecordFieldWithDefaultValueNode transform(RecordFieldWithDefaultValueNode\n                 .apply();\n     }\n \n+    @Override\n+    public ImportDeclarationNode transform(ImportDeclarationNode importDeclarationNode) {\n+        Token importKeyword = formatToken(importDeclarationNode.importKeyword(), 1, 0);\n+\n+        boolean hasOrgName = importDeclarationNode.orgName().isPresent();\n+        boolean hasVersion = importDeclarationNode.version().isPresent();\n+        boolean hasPrefix = importDeclarationNode.prefix().isPresent();\n+\n+        if (hasOrgName) {\n+            ImportOrgNameNode orgName = formatNode(importDeclarationNode.orgName().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withOrgName(orgName).apply();\n+        }\n+        SeparatedNodeList<IdentifierToken> moduleNames = formatSeparatedNodeList(importDeclarationNode.moduleName(),\n+                0, 0, 0, 0, (hasVersion || hasPrefix) ? 1 : 0, 0);\n+\n+        if (hasVersion) {\n+            ImportVersionNode version = formatNode(importDeclarationNode.version().get(), hasPrefix ? 1 : 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withVersion(version).apply();\n+        }\n+        if (hasPrefix) {\n+            ImportPrefixNode prefix = formatNode(importDeclarationNode.prefix().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withPrefix(prefix).apply();\n+        }\n+        Token semicolon = formatToken(importDeclarationNode.semicolon(), this.trailingWS, this.trailingNL);\n+\n+        return importDeclarationNode.modify()\n+                .withImportKeyword(importKeyword)\n+                .withModuleName(moduleNames)\n+                .withSemicolon(semicolon)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ImportOrgNameNode transform(ImportOrgNameNode importOrgNameNode) {\n+        Token orgName = formatToken(importOrgNameNode.orgName(), 0, 0);\n+        Token slashToken = formatToken(importOrgNameNode.slashToken(), 0, 0);\n+\n+        return importOrgNameNode.modify()\n+                .withOrgName(orgName)\n+                .withSlashToken(slashToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ImportPrefixNode transform(ImportPrefixNode importPrefixNode) {\n+        Token asKeyword = formatToken(importPrefixNode.asKeyword(), 1, 0);\n+        Token prefix = formatToken(importPrefixNode.prefix(), 0, 0);\n+\n+        return importPrefixNode.modify()\n+                .withAsKeyword(asKeyword)\n+                .withPrefix(prefix)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ImportVersionNode transform(ImportVersionNode importVersionNode) {\n+        Token versionKeyword = formatToken(importVersionNode.versionKeyword(), 1, 0);\n+        SeparatedNodeList<Token> versionNumber = formatSeparatedNodeList(importVersionNode.versionNumber(),\n+                0, 0, 0, 0, this.trailingWS, 0);\n+\n+        return importVersionNode.modify()\n+                .withVersionKeyword(versionKeyword)\n+                .withVersionNumber(versionNumber)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ServiceDeclarationNode transform(ServiceDeclarationNode serviceDeclarationNode) {\n+        if (serviceDeclarationNode.metadata().isPresent()) {\n+            MetadataNode metadata = formatNode(serviceDeclarationNode.metadata().get(), 1, 0);\n+            serviceDeclarationNode = serviceDeclarationNode.modify().withMetadata(metadata).apply();\n+        }\n+\n+        Token serviceKeyword = formatToken(serviceDeclarationNode.serviceKeyword(), 1, 0);\n+        IdentifierToken serviceName = formatToken(serviceDeclarationNode.serviceName(), 1, 0);\n+        Token onKeyword = formatToken(serviceDeclarationNode.onKeyword(), 1, 0);\n+        SeparatedNodeList<ExpressionNode> expressions =\n+                formatSeparatedNodeList(serviceDeclarationNode.expressions(), 0, 0, 1, 0);\n+        Node serviceBody = formatNode(serviceDeclarationNode.serviceBody(), this.trailingWS, this.trailingNL);\n+\n+        return serviceDeclarationNode.modify()\n+                .withServiceKeyword(serviceKeyword)\n+                .withServiceName(serviceName)\n+                .withOnKeyword(onKeyword)\n+                .withExpressions(expressions)\n+                .withServiceBody(serviceBody)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ExplicitNewExpressionNode transform(ExplicitNewExpressionNode explicitNewExpressionNode) {\n+        Token newKeywordToken = formatToken(explicitNewExpressionNode.newKeyword(), 1, 0);\n+        TypeDescriptorNode typeDescriptorNode = formatNode(explicitNewExpressionNode.typeDescriptor(), 0, 0);\n+        ParenthesizedArgList parenthesizedArgList = formatNode(explicitNewExpressionNode.parenthesizedArgList(), 0, 0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bd7b0d855a3e4ed165fc3da4b34b7de38a82199"}, "originalPosition": 200}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg4ODI5Mg==", "bodyText": "should use global var for WS and NL", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26121#discussion_r495888292", "createdAt": "2020-09-28T12:06:21Z", "author": {"login": "SupunS"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "diffHunk": "@@ -399,6 +429,436 @@ public RecordFieldWithDefaultValueNode transform(RecordFieldWithDefaultValueNode\n                 .apply();\n     }\n \n+    @Override\n+    public ImportDeclarationNode transform(ImportDeclarationNode importDeclarationNode) {\n+        Token importKeyword = formatToken(importDeclarationNode.importKeyword(), 1, 0);\n+\n+        boolean hasOrgName = importDeclarationNode.orgName().isPresent();\n+        boolean hasVersion = importDeclarationNode.version().isPresent();\n+        boolean hasPrefix = importDeclarationNode.prefix().isPresent();\n+\n+        if (hasOrgName) {\n+            ImportOrgNameNode orgName = formatNode(importDeclarationNode.orgName().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withOrgName(orgName).apply();\n+        }\n+        SeparatedNodeList<IdentifierToken> moduleNames = formatSeparatedNodeList(importDeclarationNode.moduleName(),\n+                0, 0, 0, 0, (hasVersion || hasPrefix) ? 1 : 0, 0);\n+\n+        if (hasVersion) {\n+            ImportVersionNode version = formatNode(importDeclarationNode.version().get(), hasPrefix ? 1 : 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withVersion(version).apply();\n+        }\n+        if (hasPrefix) {\n+            ImportPrefixNode prefix = formatNode(importDeclarationNode.prefix().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withPrefix(prefix).apply();\n+        }\n+        Token semicolon = formatToken(importDeclarationNode.semicolon(), this.trailingWS, this.trailingNL);\n+\n+        return importDeclarationNode.modify()\n+                .withImportKeyword(importKeyword)\n+                .withModuleName(moduleNames)\n+                .withSemicolon(semicolon)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ImportOrgNameNode transform(ImportOrgNameNode importOrgNameNode) {\n+        Token orgName = formatToken(importOrgNameNode.orgName(), 0, 0);\n+        Token slashToken = formatToken(importOrgNameNode.slashToken(), 0, 0);\n+\n+        return importOrgNameNode.modify()\n+                .withOrgName(orgName)\n+                .withSlashToken(slashToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ImportPrefixNode transform(ImportPrefixNode importPrefixNode) {\n+        Token asKeyword = formatToken(importPrefixNode.asKeyword(), 1, 0);\n+        Token prefix = formatToken(importPrefixNode.prefix(), 0, 0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bd7b0d855a3e4ed165fc3da4b34b7de38a82199"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg4ODM3NQ==", "bodyText": "should use global var for trailingNL", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26121#discussion_r495888375", "createdAt": "2020-09-28T12:06:32Z", "author": {"login": "SupunS"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "diffHunk": "@@ -399,6 +429,436 @@ public RecordFieldWithDefaultValueNode transform(RecordFieldWithDefaultValueNode\n                 .apply();\n     }\n \n+    @Override\n+    public ImportDeclarationNode transform(ImportDeclarationNode importDeclarationNode) {\n+        Token importKeyword = formatToken(importDeclarationNode.importKeyword(), 1, 0);\n+\n+        boolean hasOrgName = importDeclarationNode.orgName().isPresent();\n+        boolean hasVersion = importDeclarationNode.version().isPresent();\n+        boolean hasPrefix = importDeclarationNode.prefix().isPresent();\n+\n+        if (hasOrgName) {\n+            ImportOrgNameNode orgName = formatNode(importDeclarationNode.orgName().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withOrgName(orgName).apply();\n+        }\n+        SeparatedNodeList<IdentifierToken> moduleNames = formatSeparatedNodeList(importDeclarationNode.moduleName(),\n+                0, 0, 0, 0, (hasVersion || hasPrefix) ? 1 : 0, 0);\n+\n+        if (hasVersion) {\n+            ImportVersionNode version = formatNode(importDeclarationNode.version().get(), hasPrefix ? 1 : 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withVersion(version).apply();\n+        }\n+        if (hasPrefix) {\n+            ImportPrefixNode prefix = formatNode(importDeclarationNode.prefix().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withPrefix(prefix).apply();\n+        }\n+        Token semicolon = formatToken(importDeclarationNode.semicolon(), this.trailingWS, this.trailingNL);\n+\n+        return importDeclarationNode.modify()\n+                .withImportKeyword(importKeyword)\n+                .withModuleName(moduleNames)\n+                .withSemicolon(semicolon)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ImportOrgNameNode transform(ImportOrgNameNode importOrgNameNode) {\n+        Token orgName = formatToken(importOrgNameNode.orgName(), 0, 0);\n+        Token slashToken = formatToken(importOrgNameNode.slashToken(), 0, 0);\n+\n+        return importOrgNameNode.modify()\n+                .withOrgName(orgName)\n+                .withSlashToken(slashToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ImportPrefixNode transform(ImportPrefixNode importPrefixNode) {\n+        Token asKeyword = formatToken(importPrefixNode.asKeyword(), 1, 0);\n+        Token prefix = formatToken(importPrefixNode.prefix(), 0, 0);\n+\n+        return importPrefixNode.modify()\n+                .withAsKeyword(asKeyword)\n+                .withPrefix(prefix)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ImportVersionNode transform(ImportVersionNode importVersionNode) {\n+        Token versionKeyword = formatToken(importVersionNode.versionKeyword(), 1, 0);\n+        SeparatedNodeList<Token> versionNumber = formatSeparatedNodeList(importVersionNode.versionNumber(),\n+                0, 0, 0, 0, this.trailingWS, 0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bd7b0d855a3e4ed165fc3da4b34b7de38a82199"}, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg4ODYxNA==", "bodyText": "should use global var for WS and NL", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26121#discussion_r495888614", "createdAt": "2020-09-28T12:07:00Z", "author": {"login": "SupunS"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "diffHunk": "@@ -399,6 +429,436 @@ public RecordFieldWithDefaultValueNode transform(RecordFieldWithDefaultValueNode\n                 .apply();\n     }\n \n+    @Override\n+    public ImportDeclarationNode transform(ImportDeclarationNode importDeclarationNode) {\n+        Token importKeyword = formatToken(importDeclarationNode.importKeyword(), 1, 0);\n+\n+        boolean hasOrgName = importDeclarationNode.orgName().isPresent();\n+        boolean hasVersion = importDeclarationNode.version().isPresent();\n+        boolean hasPrefix = importDeclarationNode.prefix().isPresent();\n+\n+        if (hasOrgName) {\n+            ImportOrgNameNode orgName = formatNode(importDeclarationNode.orgName().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withOrgName(orgName).apply();\n+        }\n+        SeparatedNodeList<IdentifierToken> moduleNames = formatSeparatedNodeList(importDeclarationNode.moduleName(),\n+                0, 0, 0, 0, (hasVersion || hasPrefix) ? 1 : 0, 0);\n+\n+        if (hasVersion) {\n+            ImportVersionNode version = formatNode(importDeclarationNode.version().get(), hasPrefix ? 1 : 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withVersion(version).apply();\n+        }\n+        if (hasPrefix) {\n+            ImportPrefixNode prefix = formatNode(importDeclarationNode.prefix().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withPrefix(prefix).apply();\n+        }\n+        Token semicolon = formatToken(importDeclarationNode.semicolon(), this.trailingWS, this.trailingNL);\n+\n+        return importDeclarationNode.modify()\n+                .withImportKeyword(importKeyword)\n+                .withModuleName(moduleNames)\n+                .withSemicolon(semicolon)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ImportOrgNameNode transform(ImportOrgNameNode importOrgNameNode) {\n+        Token orgName = formatToken(importOrgNameNode.orgName(), 0, 0);\n+        Token slashToken = formatToken(importOrgNameNode.slashToken(), 0, 0);\n+\n+        return importOrgNameNode.modify()\n+                .withOrgName(orgName)\n+                .withSlashToken(slashToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ImportPrefixNode transform(ImportPrefixNode importPrefixNode) {\n+        Token asKeyword = formatToken(importPrefixNode.asKeyword(), 1, 0);\n+        Token prefix = formatToken(importPrefixNode.prefix(), 0, 0);\n+\n+        return importPrefixNode.modify()\n+                .withAsKeyword(asKeyword)\n+                .withPrefix(prefix)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ImportVersionNode transform(ImportVersionNode importVersionNode) {\n+        Token versionKeyword = formatToken(importVersionNode.versionKeyword(), 1, 0);\n+        SeparatedNodeList<Token> versionNumber = formatSeparatedNodeList(importVersionNode.versionNumber(),\n+                0, 0, 0, 0, this.trailingWS, 0);\n+\n+        return importVersionNode.modify()\n+                .withVersionKeyword(versionKeyword)\n+                .withVersionNumber(versionNumber)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ServiceDeclarationNode transform(ServiceDeclarationNode serviceDeclarationNode) {\n+        if (serviceDeclarationNode.metadata().isPresent()) {\n+            MetadataNode metadata = formatNode(serviceDeclarationNode.metadata().get(), 1, 0);\n+            serviceDeclarationNode = serviceDeclarationNode.modify().withMetadata(metadata).apply();\n+        }\n+\n+        Token serviceKeyword = formatToken(serviceDeclarationNode.serviceKeyword(), 1, 0);\n+        IdentifierToken serviceName = formatToken(serviceDeclarationNode.serviceName(), 1, 0);\n+        Token onKeyword = formatToken(serviceDeclarationNode.onKeyword(), 1, 0);\n+        SeparatedNodeList<ExpressionNode> expressions =\n+                formatSeparatedNodeList(serviceDeclarationNode.expressions(), 0, 0, 1, 0);\n+        Node serviceBody = formatNode(serviceDeclarationNode.serviceBody(), this.trailingWS, this.trailingNL);\n+\n+        return serviceDeclarationNode.modify()\n+                .withServiceKeyword(serviceKeyword)\n+                .withServiceName(serviceName)\n+                .withOnKeyword(onKeyword)\n+                .withExpressions(expressions)\n+                .withServiceBody(serviceBody)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ExplicitNewExpressionNode transform(ExplicitNewExpressionNode explicitNewExpressionNode) {\n+        Token newKeywordToken = formatToken(explicitNewExpressionNode.newKeyword(), 1, 0);\n+        TypeDescriptorNode typeDescriptorNode = formatNode(explicitNewExpressionNode.typeDescriptor(), 0, 0);\n+        ParenthesizedArgList parenthesizedArgList = formatNode(explicitNewExpressionNode.parenthesizedArgList(), 0, 0);\n+\n+        return explicitNewExpressionNode.modify()\n+                .withNewKeyword(newKeywordToken)\n+                .withTypeDescriptor(typeDescriptorNode)\n+                .withParenthesizedArgList(parenthesizedArgList)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ParenthesizedArgList transform(ParenthesizedArgList parenthesizedArgList) {\n+        Token openParenToken = formatToken(parenthesizedArgList.openParenToken(), 0, 0);\n+        SeparatedNodeList<FunctionArgumentNode> arguments = formatSeparatedNodeList(parenthesizedArgList\n+                .arguments(), 0, 0, 0, 0);\n+        Token closeParenToken = formatToken(parenthesizedArgList.closeParenToken(), this.trailingWS, this.trailingNL);\n+\n+        return parenthesizedArgList.modify()\n+                .withOpenParenToken(openParenToken)\n+                .withArguments(arguments)\n+                .withCloseParenToken(closeParenToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ServiceBodyNode transform(ServiceBodyNode serviceBodyNode) {\n+        Token openBraceToken = formatToken(serviceBodyNode.openBraceToken(), 0, 1);\n+        indent(); // increase indentation for the statements to follow.\n+        NodeList<Node> resources = formatNodeList(serviceBodyNode.resources(), 0, 1, 0, 1);\n+        unindent(); // reset the indentation\n+        Token closeBraceToken = formatToken(serviceBodyNode.closeBraceToken(), this.trailingWS, this.trailingNL);\n+\n+        return serviceBodyNode.modify()\n+                .withOpenBraceToken(openBraceToken)\n+                .withResources(resources)\n+                .withCloseBraceToken(closeBraceToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public QualifiedNameReferenceNode transform(QualifiedNameReferenceNode qualifiedNameReferenceNode) {\n+        Token modulePrefix = formatToken(qualifiedNameReferenceNode.modulePrefix(), 0, 0);\n+        Token colon = formatToken((Token) qualifiedNameReferenceNode.colon(), 0, 0);\n+        IdentifierToken identifier = formatToken(qualifiedNameReferenceNode.identifier(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return qualifiedNameReferenceNode.modify()\n+                .withModulePrefix(modulePrefix)\n+                .withColon(colon)\n+                .withIdentifier(identifier)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ReturnTypeDescriptorNode transform(ReturnTypeDescriptorNode returnTypeDescriptorNode) {\n+        Token returnsKeyword = formatToken(returnTypeDescriptorNode.returnsKeyword(), 1, 0);\n+        NodeList<AnnotationNode> annotations = formatNodeList(returnTypeDescriptorNode.annotations(), 0, 0, 1, 0);\n+        Node type = formatNode(returnTypeDescriptorNode.type(), 1, 0);\n+\n+        return returnTypeDescriptorNode.modify()\n+                .withReturnsKeyword(returnsKeyword)\n+                .withAnnotations(annotations)\n+                .withType(type)\n+                .apply();\n+    }\n+\n+    @Override\n+    public OptionalTypeDescriptorNode transform(OptionalTypeDescriptorNode optionalTypeDescriptorNode) {\n+        Node typeDescriptor = formatNode(optionalTypeDescriptorNode.typeDescriptor(), 0, 0);\n+        Token questionMarkToken = formatToken(optionalTypeDescriptorNode.questionMarkToken(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return optionalTypeDescriptorNode.modify()\n+                .withTypeDescriptor(typeDescriptor)\n+                .withQuestionMarkToken(questionMarkToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ExpressionStatementNode transform(ExpressionStatementNode expressionStatementNode) {\n+        ExpressionNode expression = formatNode(expressionStatementNode.expression(), 0, 0);\n+        Token semicolonToken = formatToken(expressionStatementNode.semicolonToken(), this.trailingWS, this.trailingNL);\n+\n+        return expressionStatementNode.modify()\n+                .withExpression(expression)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public CheckExpressionNode transform(CheckExpressionNode checkExpressionNode) {\n+        Token checkKeyword = formatToken(checkExpressionNode.checkKeyword(), 1, 0);\n+        ExpressionNode expressionNode = formatNode(checkExpressionNode.expression(), this.trailingWS, this.trailingNL);\n+\n+        return checkExpressionNode.modify()\n+                .withCheckKeyword(checkKeyword)\n+                .withExpression(expressionNode)\n+                .apply();\n+    }\n+\n+    @Override\n+    public RemoteMethodCallActionNode transform(RemoteMethodCallActionNode remoteMethodCallActionNode) {\n+        ExpressionNode expression = formatNode(remoteMethodCallActionNode.expression(), 0, 0);\n+        Token rightArrowToken = formatToken(remoteMethodCallActionNode.rightArrowToken(), 0, 0);\n+        SimpleNameReferenceNode methodName = formatNode(remoteMethodCallActionNode.methodName(), 0, 0);\n+        Token openParenToken = formatToken(remoteMethodCallActionNode.openParenToken(), 0, 0);\n+        SeparatedNodeList<FunctionArgumentNode> arguments = formatSeparatedNodeList(remoteMethodCallActionNode\n+                .arguments(), 1, 0, 0, 0);\n+        Token closeParenToken = formatToken(remoteMethodCallActionNode.closeParenToken(), this.trailingWS, this.trailingNL);\n+\n+        return remoteMethodCallActionNode.modify()\n+                .withExpression(expression)\n+                .withRightArrowToken(rightArrowToken)\n+                .withMethodName(methodName)\n+                .withOpenParenToken(openParenToken)\n+                .withArguments(arguments)\n+                .withCloseParenToken(closeParenToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public SimpleNameReferenceNode transform(SimpleNameReferenceNode simpleNameReferenceNode) {\n+        Token name = formatToken(simpleNameReferenceNode.name(), this.trailingWS, this.trailingNL);\n+\n+        return simpleNameReferenceNode.modify()\n+                .withName(name)\n+                .apply();\n+    }\n+\n+    @Override\n+    public TypeDefinitionNode transform(TypeDefinitionNode typeDefinitionNode) {\n+        if (typeDefinitionNode.metadata().isPresent()) {\n+            MetadataNode metadata = formatNode(typeDefinitionNode.metadata().get(), 1, 0);\n+            typeDefinitionNode = typeDefinitionNode.modify().withMetadata(metadata).apply();\n+        }\n+        if (typeDefinitionNode.visibilityQualifier().isPresent()) {\n+            Token visibilityQualifier = formatToken(typeDefinitionNode.visibilityQualifier().get(), 1, 0);\n+            typeDefinitionNode = typeDefinitionNode.modify().withVisibilityQualifier(visibilityQualifier).apply();\n+        }\n+\n+        Token typeKeyword = formatToken(typeDefinitionNode.typeKeyword(), 1, 0);\n+        Token typeName = formatToken(typeDefinitionNode.typeName(), 1, 0);\n+        Node typeDescriptor = formatNode(typeDefinitionNode.typeDescriptor(), 1, 0);\n+        Token semicolonToken = formatToken(typeDefinitionNode.semicolonToken(), this.trailingWS, this.trailingNL);\n+\n+        return typeDefinitionNode.modify()\n+                .withTypeKeyword(typeKeyword)\n+                .withTypeName(typeName)\n+                .withTypeDescriptor(typeDescriptor)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public SingletonTypeDescriptorNode transform(SingletonTypeDescriptorNode singletonTypeDescriptorNode) {\n+        ExpressionNode simpleContExprNode = formatNode(singletonTypeDescriptorNode.simpleContExprNode(), 1, 0);\n+        return singletonTypeDescriptorNode.modify()\n+                .withSimpleContExprNode(simpleContExprNode)\n+                .apply();\n+    }\n+\n+    @Override\n+    public WhileStatementNode transform(WhileStatementNode whileStatementNode) {\n+        boolean hasOnFailClause = whileStatementNode.onFailClause().isPresent();\n+        Token whileKeyword = formatToken(whileStatementNode.whileKeyword(), 1, 0);\n+        ExpressionNode condition = formatNode(whileStatementNode.condition(), 1, 0);\n+        BlockStatementNode whileBody = formatNode(whileStatementNode.whileBody(),\n+                hasOnFailClause ? 1 : this.trailingWS, hasOnFailClause ? 0 : this.trailingNL);\n+\n+        if (hasOnFailClause) {\n+            OnFailClauseNode onFailClause = formatNode(whileStatementNode.onFailClause().get(),\n+                    this.trailingWS, this.trailingNL);\n+            whileStatementNode = whileStatementNode.modify().withOnFailClause(onFailClause).apply();\n+        }\n+\n+        return whileStatementNode.modify()\n+                .withWhileKeyword(whileKeyword)\n+                .withCondition(condition)\n+                .withWhileBody(whileBody)\n+                .apply();\n+    }\n+\n+    @Override\n+    public BracedExpressionNode transform(BracedExpressionNode bracedExpressionNode) {\n+        Token openParen = formatToken(bracedExpressionNode.openParen(), 0, 0);\n+        ExpressionNode expression = formatNode(bracedExpressionNode.expression(), 0, 0);\n+        Token closeParen = formatToken(bracedExpressionNode.closeParen(), this.trailingWS, this.trailingNL);\n+\n+        return bracedExpressionNode.modify()\n+                .withOpenParen(openParen)\n+                .withExpression(expression)\n+                .withCloseParen(closeParen)\n+                .apply();\n+    }\n+\n+    @Override\n+    public AssignmentStatementNode transform(AssignmentStatementNode assignmentStatementNode) {\n+        Node varRef = formatNode(assignmentStatementNode.varRef(), 1, 0);\n+        Token equalsToken = formatToken(assignmentStatementNode.equalsToken(), 1, 0);\n+        ExpressionNode expression = formatNode(assignmentStatementNode.expression(), 0, 0);\n+        Token semicolonToken = formatToken(assignmentStatementNode.semicolonToken(), this.trailingWS, this.trailingNL);\n+\n+        return assignmentStatementNode.modify()\n+                .withVarRef(varRef)\n+                .withEqualsToken(equalsToken)\n+                .withExpression(expression)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public CompoundAssignmentStatementNode transform(CompoundAssignmentStatementNode compoundAssignmentStatementNode) {\n+        ExpressionNode lhsExpression = formatNode(compoundAssignmentStatementNode.lhsExpression(), 1, 0);\n+        Token binaryOperator = formatToken(compoundAssignmentStatementNode.binaryOperator(), 0, 0);\n+        Token equalsToken = formatToken(compoundAssignmentStatementNode.equalsToken(), 1, 0);\n+        ExpressionNode rhsExpression = formatNode(compoundAssignmentStatementNode.rhsExpression(), 0, 0);\n+        Token semicolonToken = formatToken(compoundAssignmentStatementNode.semicolonToken(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return compoundAssignmentStatementNode.modify()\n+                .withLhsExpression(lhsExpression)\n+                .withBinaryOperator(binaryOperator)\n+                .withEqualsToken(equalsToken)\n+                .withRhsExpression(rhsExpression)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public DoStatementNode transform(DoStatementNode doStatementNode) {\n+        boolean hasOnFailClause = doStatementNode.onFailClause().isPresent();\n+\n+        Token doKeyword = formatToken(doStatementNode.doKeyword(), 1, 0);\n+        BlockStatementNode blockStatement = formatNode(doStatementNode.blockStatement(),\n+                hasOnFailClause ? 1 : this.trailingWS, hasOnFailClause ? 0 : this.trailingNL);\n+\n+        if (hasOnFailClause) {\n+            OnFailClauseNode onFailClause = formatNode(doStatementNode.onFailClause().get(),\n+                    this.trailingWS, this.trailingNL);\n+            doStatementNode = doStatementNode.modify().withOnFailClause(onFailClause).apply();\n+        }\n+\n+        return doStatementNode.modify()\n+                .withDoKeyword(doKeyword)\n+                .withBlockStatement(blockStatement)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ForEachStatementNode transform(ForEachStatementNode forEachStatementNode) {\n+        boolean hasOnFailClause = forEachStatementNode.onFailClause().isPresent();\n+\n+        Token forEachKeyword = formatToken(forEachStatementNode.forEachKeyword(), 1, 0);\n+        TypedBindingPatternNode typedBindingPattern = formatNode(forEachStatementNode.typedBindingPattern(), 1, 0);\n+        Token inKeyword = formatToken(forEachStatementNode.inKeyword(), 1, 0);\n+        Node actionOrExpressionNode = formatNode(forEachStatementNode.actionOrExpressionNode(), 1, 0);\n+        StatementNode blockStatement = formatNode(forEachStatementNode.blockStatement(),\n+                hasOnFailClause ? 1 : this.trailingWS, hasOnFailClause ? 0 : this.trailingNL);\n+\n+        if (hasOnFailClause) {\n+            OnFailClauseNode onFailClause = formatNode(forEachStatementNode.onFailClause().get(),\n+                    this.trailingWS, this.trailingNL);\n+            forEachStatementNode = forEachStatementNode.modify().withOnFailClause(onFailClause).apply();\n+        }\n+\n+        return forEachStatementNode.modify()\n+                .withForEachKeyword(forEachKeyword)\n+                .withTypedBindingPattern(typedBindingPattern)\n+                .withInKeyword(inKeyword)\n+                .withActionOrExpressionNode(actionOrExpressionNode)\n+                .withBlockStatement(blockStatement)\n+                .apply();\n+    }\n+\n+    @Override\n+    public BinaryExpressionNode transform(BinaryExpressionNode binaryExpressionNode) {\n+        Node lhsExpr = formatNode(binaryExpressionNode.lhsExpr(), 1, 0);\n+        Token operator = formatToken(binaryExpressionNode.operator(), 1, 0);\n+        Node rhsExpr = formatNode(binaryExpressionNode.rhsExpr(), this.trailingWS, this.trailingNL);\n+\n+        return binaryExpressionNode.modify()\n+                .withLhsExpr(lhsExpr)\n+                .withOperator(operator)\n+                .withRhsExpr(rhsExpr)\n+                .apply();\n+    }\n+\n+    @Override\n+    public OnFailClauseNode transform(OnFailClauseNode onFailClauseNode) {\n+        Token onKeyword = formatToken(onFailClauseNode.onKeyword(), 1, 0);\n+        Token failKeyword = formatToken(onFailClauseNode.failKeyword(), 1, 0);\n+        TypeDescriptorNode typeDescriptor = formatNode(onFailClauseNode.typeDescriptor(), 1, 0);\n+        IdentifierToken failErrorName = formatToken(onFailClauseNode.failErrorName(), 1, 0);\n+        BlockStatementNode blockStatement = formatNode(onFailClauseNode.blockStatement(), 0, 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bd7b0d855a3e4ed165fc3da4b34b7de38a82199"}, "originalPosition": 492}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg4OTAwNQ==", "bodyText": "moving this inside the below if (hasOnFailClause) { block would be cleaner..", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26121#discussion_r495889005", "createdAt": "2020-09-28T12:07:51Z", "author": {"login": "SupunS"}, "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "diffHunk": "@@ -399,6 +429,436 @@ public RecordFieldWithDefaultValueNode transform(RecordFieldWithDefaultValueNode\n                 .apply();\n     }\n \n+    @Override\n+    public ImportDeclarationNode transform(ImportDeclarationNode importDeclarationNode) {\n+        Token importKeyword = formatToken(importDeclarationNode.importKeyword(), 1, 0);\n+\n+        boolean hasOrgName = importDeclarationNode.orgName().isPresent();\n+        boolean hasVersion = importDeclarationNode.version().isPresent();\n+        boolean hasPrefix = importDeclarationNode.prefix().isPresent();\n+\n+        if (hasOrgName) {\n+            ImportOrgNameNode orgName = formatNode(importDeclarationNode.orgName().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withOrgName(orgName).apply();\n+        }\n+        SeparatedNodeList<IdentifierToken> moduleNames = formatSeparatedNodeList(importDeclarationNode.moduleName(),\n+                0, 0, 0, 0, (hasVersion || hasPrefix) ? 1 : 0, 0);\n+\n+        if (hasVersion) {\n+            ImportVersionNode version = formatNode(importDeclarationNode.version().get(), hasPrefix ? 1 : 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withVersion(version).apply();\n+        }\n+        if (hasPrefix) {\n+            ImportPrefixNode prefix = formatNode(importDeclarationNode.prefix().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withPrefix(prefix).apply();\n+        }\n+        Token semicolon = formatToken(importDeclarationNode.semicolon(), this.trailingWS, this.trailingNL);\n+\n+        return importDeclarationNode.modify()\n+                .withImportKeyword(importKeyword)\n+                .withModuleName(moduleNames)\n+                .withSemicolon(semicolon)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ImportOrgNameNode transform(ImportOrgNameNode importOrgNameNode) {\n+        Token orgName = formatToken(importOrgNameNode.orgName(), 0, 0);\n+        Token slashToken = formatToken(importOrgNameNode.slashToken(), 0, 0);\n+\n+        return importOrgNameNode.modify()\n+                .withOrgName(orgName)\n+                .withSlashToken(slashToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ImportPrefixNode transform(ImportPrefixNode importPrefixNode) {\n+        Token asKeyword = formatToken(importPrefixNode.asKeyword(), 1, 0);\n+        Token prefix = formatToken(importPrefixNode.prefix(), 0, 0);\n+\n+        return importPrefixNode.modify()\n+                .withAsKeyword(asKeyword)\n+                .withPrefix(prefix)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ImportVersionNode transform(ImportVersionNode importVersionNode) {\n+        Token versionKeyword = formatToken(importVersionNode.versionKeyword(), 1, 0);\n+        SeparatedNodeList<Token> versionNumber = formatSeparatedNodeList(importVersionNode.versionNumber(),\n+                0, 0, 0, 0, this.trailingWS, 0);\n+\n+        return importVersionNode.modify()\n+                .withVersionKeyword(versionKeyword)\n+                .withVersionNumber(versionNumber)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ServiceDeclarationNode transform(ServiceDeclarationNode serviceDeclarationNode) {\n+        if (serviceDeclarationNode.metadata().isPresent()) {\n+            MetadataNode metadata = formatNode(serviceDeclarationNode.metadata().get(), 1, 0);\n+            serviceDeclarationNode = serviceDeclarationNode.modify().withMetadata(metadata).apply();\n+        }\n+\n+        Token serviceKeyword = formatToken(serviceDeclarationNode.serviceKeyword(), 1, 0);\n+        IdentifierToken serviceName = formatToken(serviceDeclarationNode.serviceName(), 1, 0);\n+        Token onKeyword = formatToken(serviceDeclarationNode.onKeyword(), 1, 0);\n+        SeparatedNodeList<ExpressionNode> expressions =\n+                formatSeparatedNodeList(serviceDeclarationNode.expressions(), 0, 0, 1, 0);\n+        Node serviceBody = formatNode(serviceDeclarationNode.serviceBody(), this.trailingWS, this.trailingNL);\n+\n+        return serviceDeclarationNode.modify()\n+                .withServiceKeyword(serviceKeyword)\n+                .withServiceName(serviceName)\n+                .withOnKeyword(onKeyword)\n+                .withExpressions(expressions)\n+                .withServiceBody(serviceBody)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ExplicitNewExpressionNode transform(ExplicitNewExpressionNode explicitNewExpressionNode) {\n+        Token newKeywordToken = formatToken(explicitNewExpressionNode.newKeyword(), 1, 0);\n+        TypeDescriptorNode typeDescriptorNode = formatNode(explicitNewExpressionNode.typeDescriptor(), 0, 0);\n+        ParenthesizedArgList parenthesizedArgList = formatNode(explicitNewExpressionNode.parenthesizedArgList(), 0, 0);\n+\n+        return explicitNewExpressionNode.modify()\n+                .withNewKeyword(newKeywordToken)\n+                .withTypeDescriptor(typeDescriptorNode)\n+                .withParenthesizedArgList(parenthesizedArgList)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ParenthesizedArgList transform(ParenthesizedArgList parenthesizedArgList) {\n+        Token openParenToken = formatToken(parenthesizedArgList.openParenToken(), 0, 0);\n+        SeparatedNodeList<FunctionArgumentNode> arguments = formatSeparatedNodeList(parenthesizedArgList\n+                .arguments(), 0, 0, 0, 0);\n+        Token closeParenToken = formatToken(parenthesizedArgList.closeParenToken(), this.trailingWS, this.trailingNL);\n+\n+        return parenthesizedArgList.modify()\n+                .withOpenParenToken(openParenToken)\n+                .withArguments(arguments)\n+                .withCloseParenToken(closeParenToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ServiceBodyNode transform(ServiceBodyNode serviceBodyNode) {\n+        Token openBraceToken = formatToken(serviceBodyNode.openBraceToken(), 0, 1);\n+        indent(); // increase indentation for the statements to follow.\n+        NodeList<Node> resources = formatNodeList(serviceBodyNode.resources(), 0, 1, 0, 1);\n+        unindent(); // reset the indentation\n+        Token closeBraceToken = formatToken(serviceBodyNode.closeBraceToken(), this.trailingWS, this.trailingNL);\n+\n+        return serviceBodyNode.modify()\n+                .withOpenBraceToken(openBraceToken)\n+                .withResources(resources)\n+                .withCloseBraceToken(closeBraceToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public QualifiedNameReferenceNode transform(QualifiedNameReferenceNode qualifiedNameReferenceNode) {\n+        Token modulePrefix = formatToken(qualifiedNameReferenceNode.modulePrefix(), 0, 0);\n+        Token colon = formatToken((Token) qualifiedNameReferenceNode.colon(), 0, 0);\n+        IdentifierToken identifier = formatToken(qualifiedNameReferenceNode.identifier(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return qualifiedNameReferenceNode.modify()\n+                .withModulePrefix(modulePrefix)\n+                .withColon(colon)\n+                .withIdentifier(identifier)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ReturnTypeDescriptorNode transform(ReturnTypeDescriptorNode returnTypeDescriptorNode) {\n+        Token returnsKeyword = formatToken(returnTypeDescriptorNode.returnsKeyword(), 1, 0);\n+        NodeList<AnnotationNode> annotations = formatNodeList(returnTypeDescriptorNode.annotations(), 0, 0, 1, 0);\n+        Node type = formatNode(returnTypeDescriptorNode.type(), 1, 0);\n+\n+        return returnTypeDescriptorNode.modify()\n+                .withReturnsKeyword(returnsKeyword)\n+                .withAnnotations(annotations)\n+                .withType(type)\n+                .apply();\n+    }\n+\n+    @Override\n+    public OptionalTypeDescriptorNode transform(OptionalTypeDescriptorNode optionalTypeDescriptorNode) {\n+        Node typeDescriptor = formatNode(optionalTypeDescriptorNode.typeDescriptor(), 0, 0);\n+        Token questionMarkToken = formatToken(optionalTypeDescriptorNode.questionMarkToken(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return optionalTypeDescriptorNode.modify()\n+                .withTypeDescriptor(typeDescriptor)\n+                .withQuestionMarkToken(questionMarkToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ExpressionStatementNode transform(ExpressionStatementNode expressionStatementNode) {\n+        ExpressionNode expression = formatNode(expressionStatementNode.expression(), 0, 0);\n+        Token semicolonToken = formatToken(expressionStatementNode.semicolonToken(), this.trailingWS, this.trailingNL);\n+\n+        return expressionStatementNode.modify()\n+                .withExpression(expression)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public CheckExpressionNode transform(CheckExpressionNode checkExpressionNode) {\n+        Token checkKeyword = formatToken(checkExpressionNode.checkKeyword(), 1, 0);\n+        ExpressionNode expressionNode = formatNode(checkExpressionNode.expression(), this.trailingWS, this.trailingNL);\n+\n+        return checkExpressionNode.modify()\n+                .withCheckKeyword(checkKeyword)\n+                .withExpression(expressionNode)\n+                .apply();\n+    }\n+\n+    @Override\n+    public RemoteMethodCallActionNode transform(RemoteMethodCallActionNode remoteMethodCallActionNode) {\n+        ExpressionNode expression = formatNode(remoteMethodCallActionNode.expression(), 0, 0);\n+        Token rightArrowToken = formatToken(remoteMethodCallActionNode.rightArrowToken(), 0, 0);\n+        SimpleNameReferenceNode methodName = formatNode(remoteMethodCallActionNode.methodName(), 0, 0);\n+        Token openParenToken = formatToken(remoteMethodCallActionNode.openParenToken(), 0, 0);\n+        SeparatedNodeList<FunctionArgumentNode> arguments = formatSeparatedNodeList(remoteMethodCallActionNode\n+                .arguments(), 1, 0, 0, 0);\n+        Token closeParenToken = formatToken(remoteMethodCallActionNode.closeParenToken(), this.trailingWS, this.trailingNL);\n+\n+        return remoteMethodCallActionNode.modify()\n+                .withExpression(expression)\n+                .withRightArrowToken(rightArrowToken)\n+                .withMethodName(methodName)\n+                .withOpenParenToken(openParenToken)\n+                .withArguments(arguments)\n+                .withCloseParenToken(closeParenToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public SimpleNameReferenceNode transform(SimpleNameReferenceNode simpleNameReferenceNode) {\n+        Token name = formatToken(simpleNameReferenceNode.name(), this.trailingWS, this.trailingNL);\n+\n+        return simpleNameReferenceNode.modify()\n+                .withName(name)\n+                .apply();\n+    }\n+\n+    @Override\n+    public TypeDefinitionNode transform(TypeDefinitionNode typeDefinitionNode) {\n+        if (typeDefinitionNode.metadata().isPresent()) {\n+            MetadataNode metadata = formatNode(typeDefinitionNode.metadata().get(), 1, 0);\n+            typeDefinitionNode = typeDefinitionNode.modify().withMetadata(metadata).apply();\n+        }\n+        if (typeDefinitionNode.visibilityQualifier().isPresent()) {\n+            Token visibilityQualifier = formatToken(typeDefinitionNode.visibilityQualifier().get(), 1, 0);\n+            typeDefinitionNode = typeDefinitionNode.modify().withVisibilityQualifier(visibilityQualifier).apply();\n+        }\n+\n+        Token typeKeyword = formatToken(typeDefinitionNode.typeKeyword(), 1, 0);\n+        Token typeName = formatToken(typeDefinitionNode.typeName(), 1, 0);\n+        Node typeDescriptor = formatNode(typeDefinitionNode.typeDescriptor(), 1, 0);\n+        Token semicolonToken = formatToken(typeDefinitionNode.semicolonToken(), this.trailingWS, this.trailingNL);\n+\n+        return typeDefinitionNode.modify()\n+                .withTypeKeyword(typeKeyword)\n+                .withTypeName(typeName)\n+                .withTypeDescriptor(typeDescriptor)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public SingletonTypeDescriptorNode transform(SingletonTypeDescriptorNode singletonTypeDescriptorNode) {\n+        ExpressionNode simpleContExprNode = formatNode(singletonTypeDescriptorNode.simpleContExprNode(), 1, 0);\n+        return singletonTypeDescriptorNode.modify()\n+                .withSimpleContExprNode(simpleContExprNode)\n+                .apply();\n+    }\n+\n+    @Override\n+    public WhileStatementNode transform(WhileStatementNode whileStatementNode) {\n+        boolean hasOnFailClause = whileStatementNode.onFailClause().isPresent();\n+        Token whileKeyword = formatToken(whileStatementNode.whileKeyword(), 1, 0);\n+        ExpressionNode condition = formatNode(whileStatementNode.condition(), 1, 0);\n+        BlockStatementNode whileBody = formatNode(whileStatementNode.whileBody(),\n+                hasOnFailClause ? 1 : this.trailingWS, hasOnFailClause ? 0 : this.trailingNL);\n+\n+        if (hasOnFailClause) {\n+            OnFailClauseNode onFailClause = formatNode(whileStatementNode.onFailClause().get(),\n+                    this.trailingWS, this.trailingNL);\n+            whileStatementNode = whileStatementNode.modify().withOnFailClause(onFailClause).apply();\n+        }\n+\n+        return whileStatementNode.modify()\n+                .withWhileKeyword(whileKeyword)\n+                .withCondition(condition)\n+                .withWhileBody(whileBody)\n+                .apply();\n+    }\n+\n+    @Override\n+    public BracedExpressionNode transform(BracedExpressionNode bracedExpressionNode) {\n+        Token openParen = formatToken(bracedExpressionNode.openParen(), 0, 0);\n+        ExpressionNode expression = formatNode(bracedExpressionNode.expression(), 0, 0);\n+        Token closeParen = formatToken(bracedExpressionNode.closeParen(), this.trailingWS, this.trailingNL);\n+\n+        return bracedExpressionNode.modify()\n+                .withOpenParen(openParen)\n+                .withExpression(expression)\n+                .withCloseParen(closeParen)\n+                .apply();\n+    }\n+\n+    @Override\n+    public AssignmentStatementNode transform(AssignmentStatementNode assignmentStatementNode) {\n+        Node varRef = formatNode(assignmentStatementNode.varRef(), 1, 0);\n+        Token equalsToken = formatToken(assignmentStatementNode.equalsToken(), 1, 0);\n+        ExpressionNode expression = formatNode(assignmentStatementNode.expression(), 0, 0);\n+        Token semicolonToken = formatToken(assignmentStatementNode.semicolonToken(), this.trailingWS, this.trailingNL);\n+\n+        return assignmentStatementNode.modify()\n+                .withVarRef(varRef)\n+                .withEqualsToken(equalsToken)\n+                .withExpression(expression)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public CompoundAssignmentStatementNode transform(CompoundAssignmentStatementNode compoundAssignmentStatementNode) {\n+        ExpressionNode lhsExpression = formatNode(compoundAssignmentStatementNode.lhsExpression(), 1, 0);\n+        Token binaryOperator = formatToken(compoundAssignmentStatementNode.binaryOperator(), 0, 0);\n+        Token equalsToken = formatToken(compoundAssignmentStatementNode.equalsToken(), 1, 0);\n+        ExpressionNode rhsExpression = formatNode(compoundAssignmentStatementNode.rhsExpression(), 0, 0);\n+        Token semicolonToken = formatToken(compoundAssignmentStatementNode.semicolonToken(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return compoundAssignmentStatementNode.modify()\n+                .withLhsExpression(lhsExpression)\n+                .withBinaryOperator(binaryOperator)\n+                .withEqualsToken(equalsToken)\n+                .withRhsExpression(rhsExpression)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public DoStatementNode transform(DoStatementNode doStatementNode) {\n+        boolean hasOnFailClause = doStatementNode.onFailClause().isPresent();\n+\n+        Token doKeyword = formatToken(doStatementNode.doKeyword(), 1, 0);\n+        BlockStatementNode blockStatement = formatNode(doStatementNode.blockStatement(),\n+                hasOnFailClause ? 1 : this.trailingWS, hasOnFailClause ? 0 : this.trailingNL);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bd7b0d855a3e4ed165fc3da4b34b7de38a82199"}, "originalPosition": 433}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "db8f6043c52588827582ab0229d0383934bfe3f0", "author": {"user": {"login": "IrushiL", "name": "Irushi Liyanage"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/db8f6043c52588827582ab0229d0383934bfe3f0", "committedDate": "2020-09-28T12:27:44Z", "message": "Fix review comments and add nodes UnionTypeDescriptorNode and NilTypeDescriptorNode"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e4f10898264b2a53a4d9d91533c9499e7555e349", "author": {"user": {"login": "IrushiL", "name": "Irushi Liyanage"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e4f10898264b2a53a4d9d91533c9499e7555e349", "committedDate": "2020-09-28T12:26:02Z", "message": "Fix review comments and add nodes UnionTypeDescriptorNode and NilTypeDescriptorNode"}, "afterCommit": {"oid": "db8f6043c52588827582ab0229d0383934bfe3f0", "author": {"user": {"login": "IrushiL", "name": "Irushi Liyanage"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/db8f6043c52588827582ab0229d0383934bfe3f0", "committedDate": "2020-09-28T12:27:44Z", "message": "Fix review comments and add nodes UnionTypeDescriptorNode and NilTypeDescriptorNode"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e8ac3142d6cf30c49158ce31044ab757d17723c0", "author": {"user": {"login": "IrushiL", "name": "Irushi Liyanage"}}, "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e8ac3142d6cf30c49158ce31044ab757d17723c0", "committedDate": "2020-09-28T12:32:54Z", "message": "Fix a review comment and a checkstyle issue"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3NTQyOTc5", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26121#pullrequestreview-497542979", "createdAt": "2020-09-28T14:01:24Z", "commit": {"oid": "e8ac3142d6cf30c49158ce31044ab757d17723c0"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4461, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}