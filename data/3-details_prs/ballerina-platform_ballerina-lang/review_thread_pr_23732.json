{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI3NzU4NTYz", "number": 23732, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMDowMjo0MlrOEC5UuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwNTo1ODo0NlrOEDTx9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNDcxODAwOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMDowMjo0MlrOGfoZcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwNTo0ODo0MVrOGgP7uw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgyMDkxNA==", "bodyText": "Under ARG_LIST context, ARG_LIST_START is always there as an alternative.\nIn other contexts, ARG_LIST_START is added as an alternative only if allowFuncCall is true.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23732#discussion_r435820914", "createdAt": "2020-06-05T10:02:42Z", "author": {"login": "lochana-chathura"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -1765,82 +1768,97 @@ private Result seekInAccessExpression(ParserRuleContext currentCtx, int lookahea\n      */\n     private Result seekMatchInExpressionRhs(int lookahead, int currentDepth, int currentMatches, boolean isEntryPoint) {\n         ParserRuleContext parentCtx = getParentContext();\n-        ParserRuleContext[] next;\n+        if (parentCtx == ParserRuleContext.FUNCTION_CALL_START) {\n+            endContext();\n+            return seekMatchInExpressionRhs(lookahead, currentDepth, currentMatches, isEntryPoint, true);\n+        } else {\n+            return seekMatchInExpressionRhs(lookahead, currentDepth, currentMatches, isEntryPoint, false);\n+        }\n+    }\n+\n+    private Result seekMatchInExpressionRhs(int lookahead, int currentDepth, int currentMatches, boolean isEntryPoint,\n+                                            boolean allowFuncCall) {\n+        ParserRuleContext parentCtx = getParentContext();\n+        ParserRuleContext[] alternatives = null;\n         switch (parentCtx) {\n             case ARG_LIST:\n-                next = new ParserRuleContext[] { ParserRuleContext.BINARY_OPERATOR, ParserRuleContext.DOT,\n+                alternatives = new ParserRuleContext[] { ParserRuleContext.BINARY_OPERATOR, ParserRuleContext.DOT,\n                         ParserRuleContext.ANNOT_CHAINING_TOKEN, ParserRuleContext.OPTIONAL_CHAINING_TOKEN,\n                         ParserRuleContext.CONDITIONAL_EXPRESSION, ParserRuleContext.XML_NAVIGATE_EXPR,\n                         ParserRuleContext.MEMBER_ACCESS_KEY_EXPR, ParserRuleContext.COMMA,\n                         ParserRuleContext.ARG_LIST_START, ParserRuleContext.ARG_LIST_END };\n-                return seekInAlternativesPaths(lookahead, currentDepth, currentMatches, next, isEntryPoint);\n+                return seekInAlternativesPaths(lookahead, currentDepth, currentMatches, alternatives, isEntryPoint);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "20a1af404b552bed3dd8f0e099cb243b4d6f030f"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ2ODY2Nw==", "bodyText": "Why is that needed?\nWhat if I write expr() inside func-args?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23732#discussion_r436468667", "createdAt": "2020-06-08T05:48:41Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -1765,82 +1768,97 @@ private Result seekInAccessExpression(ParserRuleContext currentCtx, int lookahea\n      */\n     private Result seekMatchInExpressionRhs(int lookahead, int currentDepth, int currentMatches, boolean isEntryPoint) {\n         ParserRuleContext parentCtx = getParentContext();\n-        ParserRuleContext[] next;\n+        if (parentCtx == ParserRuleContext.FUNCTION_CALL_START) {\n+            endContext();\n+            return seekMatchInExpressionRhs(lookahead, currentDepth, currentMatches, isEntryPoint, true);\n+        } else {\n+            return seekMatchInExpressionRhs(lookahead, currentDepth, currentMatches, isEntryPoint, false);\n+        }\n+    }\n+\n+    private Result seekMatchInExpressionRhs(int lookahead, int currentDepth, int currentMatches, boolean isEntryPoint,\n+                                            boolean allowFuncCall) {\n+        ParserRuleContext parentCtx = getParentContext();\n+        ParserRuleContext[] alternatives = null;\n         switch (parentCtx) {\n             case ARG_LIST:\n-                next = new ParserRuleContext[] { ParserRuleContext.BINARY_OPERATOR, ParserRuleContext.DOT,\n+                alternatives = new ParserRuleContext[] { ParserRuleContext.BINARY_OPERATOR, ParserRuleContext.DOT,\n                         ParserRuleContext.ANNOT_CHAINING_TOKEN, ParserRuleContext.OPTIONAL_CHAINING_TOKEN,\n                         ParserRuleContext.CONDITIONAL_EXPRESSION, ParserRuleContext.XML_NAVIGATE_EXPR,\n                         ParserRuleContext.MEMBER_ACCESS_KEY_EXPR, ParserRuleContext.COMMA,\n                         ParserRuleContext.ARG_LIST_START, ParserRuleContext.ARG_LIST_END };\n-                return seekInAlternativesPaths(lookahead, currentDepth, currentMatches, next, isEntryPoint);\n+                return seekInAlternativesPaths(lookahead, currentDepth, currentMatches, alternatives, isEntryPoint);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgyMDkxNA=="}, "originalCommit": {"oid": "20a1af404b552bed3dd8f0e099cb243b4d6f030f"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxOTAwNDE3OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwNToyODo1OFrOGgPoNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwNToyODo1OFrOGgPoNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ2MzY3MA==", "bodyText": "Shouldn't this be merged with isValidExprRhsStart?\nBecause there are other places where we use isValidExprRhsStart for the same purpose, and those should behave the same way right?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23732#discussion_r436463670", "createdAt": "2020-06-08T05:28:58Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -4299,6 +4299,15 @@ private boolean isValidExprRhsStart(SyntaxKind tokenKind) {\n         }\n     }\n \n+    private boolean isInvalidFunctionCallStart(SyntaxKind tokenKind, STNode lhsExpr) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04654775ff71bda4e848de10915aef00b0ffc477"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxOTAyNjk5OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwNTo0MzowNFrOGgP19w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwNjo1MzozOVrOGg7HGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ2NzE5MQ==", "bodyText": "This operation is a bit expensive. Can we avoid this?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23732#discussion_r436467191", "createdAt": "2020-06-08T05:43:04Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -1875,16 +1893,24 @@ private Result seekMatchInExpressionRhs(int lookahead, int currentDepth, int cur\n             throw new IllegalStateException(parentCtx.toString());\n         }\n \n-        ParserRuleContext[] alternatives =\n-                { ParserRuleContext.BINARY_OPERATOR, ParserRuleContext.IS_KEYWORD, ParserRuleContext.DOT,\n-                        ParserRuleContext.ANNOT_CHAINING_TOKEN, ParserRuleContext.OPTIONAL_CHAINING_TOKEN,\n-                        ParserRuleContext.CONDITIONAL_EXPRESSION, ParserRuleContext.XML_NAVIGATE_EXPR,\n-                        ParserRuleContext.MEMBER_ACCESS_KEY_EXPR, ParserRuleContext.RIGHT_ARROW,\n-                        ParserRuleContext.SYNC_SEND_TOKEN, nextContext, ParserRuleContext.ARG_LIST_START };\n+        alternatives = new ParserRuleContext[] { ParserRuleContext.BINARY_OPERATOR, ParserRuleContext.IS_KEYWORD,\n+                ParserRuleContext.DOT, ParserRuleContext.ANNOT_CHAINING_TOKEN,\n+                ParserRuleContext.OPTIONAL_CHAINING_TOKEN, ParserRuleContext.CONDITIONAL_EXPRESSION,\n+                ParserRuleContext.XML_NAVIGATE_EXPR, ParserRuleContext.MEMBER_ACCESS_KEY_EXPR,\n+                ParserRuleContext.RIGHT_ARROW, ParserRuleContext.SYNC_SEND_TOKEN, nextContext };\n \n+        if (allowFuncCall) {\n+            alternatives = addNewAlternative(alternatives, ParserRuleContext.ARG_LIST_START);\n+        }\n         return seekInAlternativesPaths(lookahead, currentDepth, currentMatches, alternatives, isEntryPoint);\n     }\n \n+    private ParserRuleContext[] addNewAlternative(ParserRuleContext[] alternatives, ParserRuleContext newAlternative) {\n+        List<ParserRuleContext> alternativesList = new ArrayList<>(Arrays.asList(alternatives));\n+        alternativesList.add(newAlternative);\n+        return alternativesList.toArray(alternatives);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04654775ff71bda4e848de10915aef00b0ffc477"}, "originalPosition": 168}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzE3NjA4OQ==", "bodyText": "Used System.arraycopy() instead of arrayLists. HBT?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23732#discussion_r437176089", "createdAt": "2020-06-09T06:53:39Z", "author": {"login": "lochana-chathura"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -1875,16 +1893,24 @@ private Result seekMatchInExpressionRhs(int lookahead, int currentDepth, int cur\n             throw new IllegalStateException(parentCtx.toString());\n         }\n \n-        ParserRuleContext[] alternatives =\n-                { ParserRuleContext.BINARY_OPERATOR, ParserRuleContext.IS_KEYWORD, ParserRuleContext.DOT,\n-                        ParserRuleContext.ANNOT_CHAINING_TOKEN, ParserRuleContext.OPTIONAL_CHAINING_TOKEN,\n-                        ParserRuleContext.CONDITIONAL_EXPRESSION, ParserRuleContext.XML_NAVIGATE_EXPR,\n-                        ParserRuleContext.MEMBER_ACCESS_KEY_EXPR, ParserRuleContext.RIGHT_ARROW,\n-                        ParserRuleContext.SYNC_SEND_TOKEN, nextContext, ParserRuleContext.ARG_LIST_START };\n+        alternatives = new ParserRuleContext[] { ParserRuleContext.BINARY_OPERATOR, ParserRuleContext.IS_KEYWORD,\n+                ParserRuleContext.DOT, ParserRuleContext.ANNOT_CHAINING_TOKEN,\n+                ParserRuleContext.OPTIONAL_CHAINING_TOKEN, ParserRuleContext.CONDITIONAL_EXPRESSION,\n+                ParserRuleContext.XML_NAVIGATE_EXPR, ParserRuleContext.MEMBER_ACCESS_KEY_EXPR,\n+                ParserRuleContext.RIGHT_ARROW, ParserRuleContext.SYNC_SEND_TOKEN, nextContext };\n \n+        if (allowFuncCall) {\n+            alternatives = addNewAlternative(alternatives, ParserRuleContext.ARG_LIST_START);\n+        }\n         return seekInAlternativesPaths(lookahead, currentDepth, currentMatches, alternatives, isEntryPoint);\n     }\n \n+    private ParserRuleContext[] addNewAlternative(ParserRuleContext[] alternatives, ParserRuleContext newAlternative) {\n+        List<ParserRuleContext> alternativesList = new ArrayList<>(Arrays.asList(alternatives));\n+        alternativesList.add(newAlternative);\n+        return alternativesList.toArray(alternatives);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ2NzE5MQ=="}, "originalCommit": {"oid": "04654775ff71bda4e848de10915aef00b0ffc477"}, "originalPosition": 168}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxOTA1MDQzOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwNTo1NzoyMVrOGgQExQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwNTo1NzoyMVrOGgQExQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3MDk4MQ==", "bodyText": "Can we do it without starting a context? because it is also an expensive operation. Should use that only if theres no other way.\nWhat if we give an alias, say \"VARIABLE_REF_RHS\", and that will call the seekMatchInExpressionRhs with the flag on/off", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23732#discussion_r436470981", "createdAt": "2020-06-08T05:57:21Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -3522,6 +3548,22 @@ private ParserRuleContext getNextRuleForExpr() {\n         return ParserRuleContext.EXPRESSION_RHS;\n     }\n \n+    private ParserRuleContext getNextRuleForExprStartsWithIdentifier() {\n+        ParserRuleContext parentCtx;\n+        parentCtx = getParentContext();\n+        if (parentCtx == ParserRuleContext.CONSTANT_EXPRESSION) {\n+            endContext();\n+            return getNextRuleForConstExpr();\n+        }\n+        return getNextRuleForExprWithFuncCallEnabled();\n+    }\n+\n+    private ParserRuleContext getNextRuleForExprWithFuncCallEnabled() {\n+        // Here we start a new context so that expr-rhs will allow function calls\n+        startContext(ParserRuleContext.FUNCTION_CALL_START);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04654775ff71bda4e848de10915aef00b0ffc477"}, "originalPosition": 208}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxOTA1MjcxOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwNTo1ODo0NlrOGgQGNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwNzowMjo0MlrOGg7Xmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3MTM1MA==", "bodyText": "Will the above logic be simplified, if we take the common things out, similar to the second switch-case?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23732#discussion_r436471350", "createdAt": "2020-06-08T05:58:46Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -1770,82 +1773,97 @@ private Result seekInAccessExpression(ParserRuleContext currentCtx, int lookahea\n      */\n     private Result seekMatchInExpressionRhs(int lookahead, int currentDepth, int currentMatches, boolean isEntryPoint) {\n         ParserRuleContext parentCtx = getParentContext();\n-        ParserRuleContext[] next;\n+        if (parentCtx == ParserRuleContext.FUNCTION_CALL_START) {\n+            endContext();\n+            return seekMatchInExpressionRhs(lookahead, currentDepth, currentMatches, isEntryPoint, true);\n+        } else {\n+            return seekMatchInExpressionRhs(lookahead, currentDepth, currentMatches, isEntryPoint, false);\n+        }\n+    }\n+\n+    private Result seekMatchInExpressionRhs(int lookahead, int currentDepth, int currentMatches, boolean isEntryPoint,\n+                                            boolean allowFuncCall) {\n+        ParserRuleContext parentCtx = getParentContext();\n+        ParserRuleContext[] alternatives = null;\n         switch (parentCtx) {\n             case ARG_LIST:\n-                next = new ParserRuleContext[] { ParserRuleContext.BINARY_OPERATOR, ParserRuleContext.DOT,\n+                alternatives = new ParserRuleContext[] { ParserRuleContext.BINARY_OPERATOR, ParserRuleContext.DOT,\n                         ParserRuleContext.ANNOT_CHAINING_TOKEN, ParserRuleContext.OPTIONAL_CHAINING_TOKEN,\n                         ParserRuleContext.CONDITIONAL_EXPRESSION, ParserRuleContext.XML_NAVIGATE_EXPR,\n                         ParserRuleContext.MEMBER_ACCESS_KEY_EXPR, ParserRuleContext.COMMA,\n                         ParserRuleContext.ARG_LIST_START, ParserRuleContext.ARG_LIST_END };\n-                return seekInAlternativesPaths(lookahead, currentDepth, currentMatches, next, isEntryPoint);\n+                return seekInAlternativesPaths(lookahead, currentDepth, currentMatches, alternatives, isEntryPoint);\n             case MAPPING_CONSTRUCTOR:\n             case MULTI_WAIT_FIELDS:\n-                next = new ParserRuleContext[] { ParserRuleContext.CLOSE_BRACE, ParserRuleContext.BINARY_OPERATOR,\n-                        ParserRuleContext.DOT, ParserRuleContext.ANNOT_CHAINING_TOKEN,\n-                        ParserRuleContext.OPTIONAL_CHAINING_TOKEN, ParserRuleContext.CONDITIONAL_EXPRESSION,\n-                        ParserRuleContext.XML_NAVIGATE_EXPR, ParserRuleContext.MEMBER_ACCESS_KEY_EXPR,\n-                        ParserRuleContext.COMMA, ParserRuleContext.ARG_LIST_START };\n-                return seekInAlternativesPaths(lookahead, currentDepth, currentMatches, next, isEntryPoint);\n+                alternatives = new ParserRuleContext[] { ParserRuleContext.CLOSE_BRACE,\n+                        ParserRuleContext.BINARY_OPERATOR, ParserRuleContext.DOT,\n+                        ParserRuleContext.ANNOT_CHAINING_TOKEN, ParserRuleContext.OPTIONAL_CHAINING_TOKEN,\n+                        ParserRuleContext.CONDITIONAL_EXPRESSION, ParserRuleContext.XML_NAVIGATE_EXPR,\n+                        ParserRuleContext.MEMBER_ACCESS_KEY_EXPR, ParserRuleContext.COMMA };\n+                break;\n             case COMPUTED_FIELD_NAME:\n                 // Here we give high priority to the comma. Therefore order of the below array matters.\n-                next = new ParserRuleContext[] { ParserRuleContext.CLOSE_BRACKET, ParserRuleContext.BINARY_OPERATOR,\n-                        ParserRuleContext.DOT, ParserRuleContext.ANNOT_CHAINING_TOKEN,\n-                        ParserRuleContext.OPTIONAL_CHAINING_TOKEN, ParserRuleContext.CONDITIONAL_EXPRESSION,\n-                        ParserRuleContext.XML_NAVIGATE_EXPR, ParserRuleContext.OPEN_BRACKET,\n-                        ParserRuleContext.ARG_LIST_START };\n-                return seekInAlternativesPaths(lookahead, currentDepth, currentMatches, next, isEntryPoint);\n+                alternatives = new ParserRuleContext[] { ParserRuleContext.CLOSE_BRACKET,\n+                        ParserRuleContext.BINARY_OPERATOR, ParserRuleContext.DOT,\n+                        ParserRuleContext.ANNOT_CHAINING_TOKEN, ParserRuleContext.OPTIONAL_CHAINING_TOKEN,\n+                        ParserRuleContext.CONDITIONAL_EXPRESSION, ParserRuleContext.XML_NAVIGATE_EXPR,\n+                        ParserRuleContext.OPEN_BRACKET };\n+                break;\n             case LISTENERS_LIST:\n-                next = new ParserRuleContext[] { ParserRuleContext.COMMA, ParserRuleContext.BINARY_OPERATOR,\n+                alternatives = new ParserRuleContext[] { ParserRuleContext.COMMA, ParserRuleContext.BINARY_OPERATOR,\n                         ParserRuleContext.DOT, ParserRuleContext.ANNOT_CHAINING_TOKEN,\n                         ParserRuleContext.OPTIONAL_CHAINING_TOKEN, ParserRuleContext.CONDITIONAL_EXPRESSION,\n                         ParserRuleContext.XML_NAVIGATE_EXPR, ParserRuleContext.MEMBER_ACCESS_KEY_EXPR,\n-                        ParserRuleContext.OPEN_BRACE, ParserRuleContext.ARG_LIST_START };\n-                return seekInAlternativesPaths(lookahead, currentDepth, currentMatches, next, isEntryPoint);\n+                        ParserRuleContext.OPEN_BRACE };\n+                break;\n             case LIST_CONSTRUCTOR:\n             case MEMBER_ACCESS_KEY_EXPR:\n             case BRACKETED_LIST:\n             case STMT_START_BRACKETED_LIST:\n-                next = new ParserRuleContext[] { ParserRuleContext.COMMA, ParserRuleContext.BINARY_OPERATOR,\n+                alternatives = new ParserRuleContext[] { ParserRuleContext.COMMA, ParserRuleContext.BINARY_OPERATOR,\n                         ParserRuleContext.DOT, ParserRuleContext.ANNOT_CHAINING_TOKEN,\n                         ParserRuleContext.OPTIONAL_CHAINING_TOKEN, ParserRuleContext.CONDITIONAL_EXPRESSION,\n                         ParserRuleContext.XML_NAVIGATE_EXPR, ParserRuleContext.MEMBER_ACCESS_KEY_EXPR,\n-                        ParserRuleContext.CLOSE_BRACKET, ParserRuleContext.ARG_LIST_START };\n-                return seekInAlternativesPaths(lookahead, currentDepth, currentMatches, next, isEntryPoint);\n+                        ParserRuleContext.CLOSE_BRACKET };\n+                break;\n             case LET_EXPR_LET_VAR_DECL:\n-                next = new ParserRuleContext[] { ParserRuleContext.COMMA, ParserRuleContext.BINARY_OPERATOR,\n+                alternatives = new ParserRuleContext[] { ParserRuleContext.COMMA, ParserRuleContext.BINARY_OPERATOR,\n                         ParserRuleContext.DOT, ParserRuleContext.ANNOT_CHAINING_TOKEN,\n                         ParserRuleContext.OPTIONAL_CHAINING_TOKEN, ParserRuleContext.CONDITIONAL_EXPRESSION,\n                         ParserRuleContext.XML_NAVIGATE_EXPR, ParserRuleContext.MEMBER_ACCESS_KEY_EXPR,\n-                        ParserRuleContext.IN_KEYWORD, ParserRuleContext.ARG_LIST_START };\n-                return seekInAlternativesPaths(lookahead, currentDepth, currentMatches, next, isEntryPoint);\n+                        ParserRuleContext.IN_KEYWORD };\n+                break;\n             case LET_CLAUSE_LET_VAR_DECL:\n-                next = new ParserRuleContext[] { ParserRuleContext.COMMA, ParserRuleContext.BINARY_OPERATOR,\n+                alternatives = new ParserRuleContext[] { ParserRuleContext.COMMA, ParserRuleContext.BINARY_OPERATOR,\n                         ParserRuleContext.DOT, ParserRuleContext.ANNOT_CHAINING_TOKEN,\n                         ParserRuleContext.OPTIONAL_CHAINING_TOKEN, ParserRuleContext.CONDITIONAL_EXPRESSION,\n                         ParserRuleContext.XML_NAVIGATE_EXPR, ParserRuleContext.MEMBER_ACCESS_KEY_EXPR,\n-                        ParserRuleContext.LET_CLAUSE_END, ParserRuleContext.ARG_LIST_START };\n-                return seekInAlternativesPaths(lookahead, currentDepth, currentMatches, next, isEntryPoint);\n+                        ParserRuleContext.LET_CLAUSE_END };\n+                break;\n             case QUERY_EXPRESSION:\n-                next = new ParserRuleContext[] { ParserRuleContext.BINARY_OPERATOR, ParserRuleContext.DOT,\n+                alternatives = new ParserRuleContext[] { ParserRuleContext.BINARY_OPERATOR, ParserRuleContext.DOT,\n                         ParserRuleContext.ANNOT_CHAINING_TOKEN, ParserRuleContext.OPTIONAL_CHAINING_TOKEN,\n                         ParserRuleContext.CONDITIONAL_EXPRESSION, ParserRuleContext.XML_NAVIGATE_EXPR,\n-                        ParserRuleContext.MEMBER_ACCESS_KEY_EXPR, ParserRuleContext.QUERY_PIPELINE_RHS,\n-                        ParserRuleContext.ARG_LIST_START };\n-                return seekInAlternativesPaths(lookahead, currentDepth, currentMatches, next, isEntryPoint);\n+                        ParserRuleContext.MEMBER_ACCESS_KEY_EXPR, ParserRuleContext.QUERY_PIPELINE_RHS };\n+                break;\n             default:\n                 if (isParameter(parentCtx)) {\n-                    next = new ParserRuleContext[] { ParserRuleContext.CLOSE_PARENTHESIS,\n+                    alternatives = new ParserRuleContext[] { ParserRuleContext.CLOSE_PARENTHESIS,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04654775ff71bda4e848de10915aef00b0ffc477"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzE3NzI2MA==", "bodyText": "Common alternatives are located in the middle of array. Number of alternatives before common and after common, are different for each ctx. So are we going to add the common ones at the end?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23732#discussion_r437177260", "createdAt": "2020-06-09T06:56:10Z", "author": {"login": "lochana-chathura"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -1770,82 +1773,97 @@ private Result seekInAccessExpression(ParserRuleContext currentCtx, int lookahea\n      */\n     private Result seekMatchInExpressionRhs(int lookahead, int currentDepth, int currentMatches, boolean isEntryPoint) {\n         ParserRuleContext parentCtx = getParentContext();\n-        ParserRuleContext[] next;\n+        if (parentCtx == ParserRuleContext.FUNCTION_CALL_START) {\n+            endContext();\n+            return seekMatchInExpressionRhs(lookahead, currentDepth, currentMatches, isEntryPoint, true);\n+        } else {\n+            return seekMatchInExpressionRhs(lookahead, currentDepth, currentMatches, isEntryPoint, false);\n+        }\n+    }\n+\n+    private Result seekMatchInExpressionRhs(int lookahead, int currentDepth, int currentMatches, boolean isEntryPoint,\n+                                            boolean allowFuncCall) {\n+        ParserRuleContext parentCtx = getParentContext();\n+        ParserRuleContext[] alternatives = null;\n         switch (parentCtx) {\n             case ARG_LIST:\n-                next = new ParserRuleContext[] { ParserRuleContext.BINARY_OPERATOR, ParserRuleContext.DOT,\n+                alternatives = new ParserRuleContext[] { ParserRuleContext.BINARY_OPERATOR, ParserRuleContext.DOT,\n                         ParserRuleContext.ANNOT_CHAINING_TOKEN, ParserRuleContext.OPTIONAL_CHAINING_TOKEN,\n                         ParserRuleContext.CONDITIONAL_EXPRESSION, ParserRuleContext.XML_NAVIGATE_EXPR,\n                         ParserRuleContext.MEMBER_ACCESS_KEY_EXPR, ParserRuleContext.COMMA,\n                         ParserRuleContext.ARG_LIST_START, ParserRuleContext.ARG_LIST_END };\n-                return seekInAlternativesPaths(lookahead, currentDepth, currentMatches, next, isEntryPoint);\n+                return seekInAlternativesPaths(lookahead, currentDepth, currentMatches, alternatives, isEntryPoint);\n             case MAPPING_CONSTRUCTOR:\n             case MULTI_WAIT_FIELDS:\n-                next = new ParserRuleContext[] { ParserRuleContext.CLOSE_BRACE, ParserRuleContext.BINARY_OPERATOR,\n-                        ParserRuleContext.DOT, ParserRuleContext.ANNOT_CHAINING_TOKEN,\n-                        ParserRuleContext.OPTIONAL_CHAINING_TOKEN, ParserRuleContext.CONDITIONAL_EXPRESSION,\n-                        ParserRuleContext.XML_NAVIGATE_EXPR, ParserRuleContext.MEMBER_ACCESS_KEY_EXPR,\n-                        ParserRuleContext.COMMA, ParserRuleContext.ARG_LIST_START };\n-                return seekInAlternativesPaths(lookahead, currentDepth, currentMatches, next, isEntryPoint);\n+                alternatives = new ParserRuleContext[] { ParserRuleContext.CLOSE_BRACE,\n+                        ParserRuleContext.BINARY_OPERATOR, ParserRuleContext.DOT,\n+                        ParserRuleContext.ANNOT_CHAINING_TOKEN, ParserRuleContext.OPTIONAL_CHAINING_TOKEN,\n+                        ParserRuleContext.CONDITIONAL_EXPRESSION, ParserRuleContext.XML_NAVIGATE_EXPR,\n+                        ParserRuleContext.MEMBER_ACCESS_KEY_EXPR, ParserRuleContext.COMMA };\n+                break;\n             case COMPUTED_FIELD_NAME:\n                 // Here we give high priority to the comma. Therefore order of the below array matters.\n-                next = new ParserRuleContext[] { ParserRuleContext.CLOSE_BRACKET, ParserRuleContext.BINARY_OPERATOR,\n-                        ParserRuleContext.DOT, ParserRuleContext.ANNOT_CHAINING_TOKEN,\n-                        ParserRuleContext.OPTIONAL_CHAINING_TOKEN, ParserRuleContext.CONDITIONAL_EXPRESSION,\n-                        ParserRuleContext.XML_NAVIGATE_EXPR, ParserRuleContext.OPEN_BRACKET,\n-                        ParserRuleContext.ARG_LIST_START };\n-                return seekInAlternativesPaths(lookahead, currentDepth, currentMatches, next, isEntryPoint);\n+                alternatives = new ParserRuleContext[] { ParserRuleContext.CLOSE_BRACKET,\n+                        ParserRuleContext.BINARY_OPERATOR, ParserRuleContext.DOT,\n+                        ParserRuleContext.ANNOT_CHAINING_TOKEN, ParserRuleContext.OPTIONAL_CHAINING_TOKEN,\n+                        ParserRuleContext.CONDITIONAL_EXPRESSION, ParserRuleContext.XML_NAVIGATE_EXPR,\n+                        ParserRuleContext.OPEN_BRACKET };\n+                break;\n             case LISTENERS_LIST:\n-                next = new ParserRuleContext[] { ParserRuleContext.COMMA, ParserRuleContext.BINARY_OPERATOR,\n+                alternatives = new ParserRuleContext[] { ParserRuleContext.COMMA, ParserRuleContext.BINARY_OPERATOR,\n                         ParserRuleContext.DOT, ParserRuleContext.ANNOT_CHAINING_TOKEN,\n                         ParserRuleContext.OPTIONAL_CHAINING_TOKEN, ParserRuleContext.CONDITIONAL_EXPRESSION,\n                         ParserRuleContext.XML_NAVIGATE_EXPR, ParserRuleContext.MEMBER_ACCESS_KEY_EXPR,\n-                        ParserRuleContext.OPEN_BRACE, ParserRuleContext.ARG_LIST_START };\n-                return seekInAlternativesPaths(lookahead, currentDepth, currentMatches, next, isEntryPoint);\n+                        ParserRuleContext.OPEN_BRACE };\n+                break;\n             case LIST_CONSTRUCTOR:\n             case MEMBER_ACCESS_KEY_EXPR:\n             case BRACKETED_LIST:\n             case STMT_START_BRACKETED_LIST:\n-                next = new ParserRuleContext[] { ParserRuleContext.COMMA, ParserRuleContext.BINARY_OPERATOR,\n+                alternatives = new ParserRuleContext[] { ParserRuleContext.COMMA, ParserRuleContext.BINARY_OPERATOR,\n                         ParserRuleContext.DOT, ParserRuleContext.ANNOT_CHAINING_TOKEN,\n                         ParserRuleContext.OPTIONAL_CHAINING_TOKEN, ParserRuleContext.CONDITIONAL_EXPRESSION,\n                         ParserRuleContext.XML_NAVIGATE_EXPR, ParserRuleContext.MEMBER_ACCESS_KEY_EXPR,\n-                        ParserRuleContext.CLOSE_BRACKET, ParserRuleContext.ARG_LIST_START };\n-                return seekInAlternativesPaths(lookahead, currentDepth, currentMatches, next, isEntryPoint);\n+                        ParserRuleContext.CLOSE_BRACKET };\n+                break;\n             case LET_EXPR_LET_VAR_DECL:\n-                next = new ParserRuleContext[] { ParserRuleContext.COMMA, ParserRuleContext.BINARY_OPERATOR,\n+                alternatives = new ParserRuleContext[] { ParserRuleContext.COMMA, ParserRuleContext.BINARY_OPERATOR,\n                         ParserRuleContext.DOT, ParserRuleContext.ANNOT_CHAINING_TOKEN,\n                         ParserRuleContext.OPTIONAL_CHAINING_TOKEN, ParserRuleContext.CONDITIONAL_EXPRESSION,\n                         ParserRuleContext.XML_NAVIGATE_EXPR, ParserRuleContext.MEMBER_ACCESS_KEY_EXPR,\n-                        ParserRuleContext.IN_KEYWORD, ParserRuleContext.ARG_LIST_START };\n-                return seekInAlternativesPaths(lookahead, currentDepth, currentMatches, next, isEntryPoint);\n+                        ParserRuleContext.IN_KEYWORD };\n+                break;\n             case LET_CLAUSE_LET_VAR_DECL:\n-                next = new ParserRuleContext[] { ParserRuleContext.COMMA, ParserRuleContext.BINARY_OPERATOR,\n+                alternatives = new ParserRuleContext[] { ParserRuleContext.COMMA, ParserRuleContext.BINARY_OPERATOR,\n                         ParserRuleContext.DOT, ParserRuleContext.ANNOT_CHAINING_TOKEN,\n                         ParserRuleContext.OPTIONAL_CHAINING_TOKEN, ParserRuleContext.CONDITIONAL_EXPRESSION,\n                         ParserRuleContext.XML_NAVIGATE_EXPR, ParserRuleContext.MEMBER_ACCESS_KEY_EXPR,\n-                        ParserRuleContext.LET_CLAUSE_END, ParserRuleContext.ARG_LIST_START };\n-                return seekInAlternativesPaths(lookahead, currentDepth, currentMatches, next, isEntryPoint);\n+                        ParserRuleContext.LET_CLAUSE_END };\n+                break;\n             case QUERY_EXPRESSION:\n-                next = new ParserRuleContext[] { ParserRuleContext.BINARY_OPERATOR, ParserRuleContext.DOT,\n+                alternatives = new ParserRuleContext[] { ParserRuleContext.BINARY_OPERATOR, ParserRuleContext.DOT,\n                         ParserRuleContext.ANNOT_CHAINING_TOKEN, ParserRuleContext.OPTIONAL_CHAINING_TOKEN,\n                         ParserRuleContext.CONDITIONAL_EXPRESSION, ParserRuleContext.XML_NAVIGATE_EXPR,\n-                        ParserRuleContext.MEMBER_ACCESS_KEY_EXPR, ParserRuleContext.QUERY_PIPELINE_RHS,\n-                        ParserRuleContext.ARG_LIST_START };\n-                return seekInAlternativesPaths(lookahead, currentDepth, currentMatches, next, isEntryPoint);\n+                        ParserRuleContext.MEMBER_ACCESS_KEY_EXPR, ParserRuleContext.QUERY_PIPELINE_RHS };\n+                break;\n             default:\n                 if (isParameter(parentCtx)) {\n-                    next = new ParserRuleContext[] { ParserRuleContext.CLOSE_PARENTHESIS,\n+                    alternatives = new ParserRuleContext[] { ParserRuleContext.CLOSE_PARENTHESIS,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3MTM1MA=="}, "originalCommit": {"oid": "04654775ff71bda4e848de10915aef00b0ffc477"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzE4MDMxNA==", "bodyText": "btw MEMBER_ACCESS_KEY_EXPR is missing as an alternative under COMPUTED_FIELD_NAME ctx. I think it's a mistake", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23732#discussion_r437180314", "createdAt": "2020-06-09T07:02:42Z", "author": {"login": "lochana-chathura"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -1770,82 +1773,97 @@ private Result seekInAccessExpression(ParserRuleContext currentCtx, int lookahea\n      */\n     private Result seekMatchInExpressionRhs(int lookahead, int currentDepth, int currentMatches, boolean isEntryPoint) {\n         ParserRuleContext parentCtx = getParentContext();\n-        ParserRuleContext[] next;\n+        if (parentCtx == ParserRuleContext.FUNCTION_CALL_START) {\n+            endContext();\n+            return seekMatchInExpressionRhs(lookahead, currentDepth, currentMatches, isEntryPoint, true);\n+        } else {\n+            return seekMatchInExpressionRhs(lookahead, currentDepth, currentMatches, isEntryPoint, false);\n+        }\n+    }\n+\n+    private Result seekMatchInExpressionRhs(int lookahead, int currentDepth, int currentMatches, boolean isEntryPoint,\n+                                            boolean allowFuncCall) {\n+        ParserRuleContext parentCtx = getParentContext();\n+        ParserRuleContext[] alternatives = null;\n         switch (parentCtx) {\n             case ARG_LIST:\n-                next = new ParserRuleContext[] { ParserRuleContext.BINARY_OPERATOR, ParserRuleContext.DOT,\n+                alternatives = new ParserRuleContext[] { ParserRuleContext.BINARY_OPERATOR, ParserRuleContext.DOT,\n                         ParserRuleContext.ANNOT_CHAINING_TOKEN, ParserRuleContext.OPTIONAL_CHAINING_TOKEN,\n                         ParserRuleContext.CONDITIONAL_EXPRESSION, ParserRuleContext.XML_NAVIGATE_EXPR,\n                         ParserRuleContext.MEMBER_ACCESS_KEY_EXPR, ParserRuleContext.COMMA,\n                         ParserRuleContext.ARG_LIST_START, ParserRuleContext.ARG_LIST_END };\n-                return seekInAlternativesPaths(lookahead, currentDepth, currentMatches, next, isEntryPoint);\n+                return seekInAlternativesPaths(lookahead, currentDepth, currentMatches, alternatives, isEntryPoint);\n             case MAPPING_CONSTRUCTOR:\n             case MULTI_WAIT_FIELDS:\n-                next = new ParserRuleContext[] { ParserRuleContext.CLOSE_BRACE, ParserRuleContext.BINARY_OPERATOR,\n-                        ParserRuleContext.DOT, ParserRuleContext.ANNOT_CHAINING_TOKEN,\n-                        ParserRuleContext.OPTIONAL_CHAINING_TOKEN, ParserRuleContext.CONDITIONAL_EXPRESSION,\n-                        ParserRuleContext.XML_NAVIGATE_EXPR, ParserRuleContext.MEMBER_ACCESS_KEY_EXPR,\n-                        ParserRuleContext.COMMA, ParserRuleContext.ARG_LIST_START };\n-                return seekInAlternativesPaths(lookahead, currentDepth, currentMatches, next, isEntryPoint);\n+                alternatives = new ParserRuleContext[] { ParserRuleContext.CLOSE_BRACE,\n+                        ParserRuleContext.BINARY_OPERATOR, ParserRuleContext.DOT,\n+                        ParserRuleContext.ANNOT_CHAINING_TOKEN, ParserRuleContext.OPTIONAL_CHAINING_TOKEN,\n+                        ParserRuleContext.CONDITIONAL_EXPRESSION, ParserRuleContext.XML_NAVIGATE_EXPR,\n+                        ParserRuleContext.MEMBER_ACCESS_KEY_EXPR, ParserRuleContext.COMMA };\n+                break;\n             case COMPUTED_FIELD_NAME:\n                 // Here we give high priority to the comma. Therefore order of the below array matters.\n-                next = new ParserRuleContext[] { ParserRuleContext.CLOSE_BRACKET, ParserRuleContext.BINARY_OPERATOR,\n-                        ParserRuleContext.DOT, ParserRuleContext.ANNOT_CHAINING_TOKEN,\n-                        ParserRuleContext.OPTIONAL_CHAINING_TOKEN, ParserRuleContext.CONDITIONAL_EXPRESSION,\n-                        ParserRuleContext.XML_NAVIGATE_EXPR, ParserRuleContext.OPEN_BRACKET,\n-                        ParserRuleContext.ARG_LIST_START };\n-                return seekInAlternativesPaths(lookahead, currentDepth, currentMatches, next, isEntryPoint);\n+                alternatives = new ParserRuleContext[] { ParserRuleContext.CLOSE_BRACKET,\n+                        ParserRuleContext.BINARY_OPERATOR, ParserRuleContext.DOT,\n+                        ParserRuleContext.ANNOT_CHAINING_TOKEN, ParserRuleContext.OPTIONAL_CHAINING_TOKEN,\n+                        ParserRuleContext.CONDITIONAL_EXPRESSION, ParserRuleContext.XML_NAVIGATE_EXPR,\n+                        ParserRuleContext.OPEN_BRACKET };\n+                break;\n             case LISTENERS_LIST:\n-                next = new ParserRuleContext[] { ParserRuleContext.COMMA, ParserRuleContext.BINARY_OPERATOR,\n+                alternatives = new ParserRuleContext[] { ParserRuleContext.COMMA, ParserRuleContext.BINARY_OPERATOR,\n                         ParserRuleContext.DOT, ParserRuleContext.ANNOT_CHAINING_TOKEN,\n                         ParserRuleContext.OPTIONAL_CHAINING_TOKEN, ParserRuleContext.CONDITIONAL_EXPRESSION,\n                         ParserRuleContext.XML_NAVIGATE_EXPR, ParserRuleContext.MEMBER_ACCESS_KEY_EXPR,\n-                        ParserRuleContext.OPEN_BRACE, ParserRuleContext.ARG_LIST_START };\n-                return seekInAlternativesPaths(lookahead, currentDepth, currentMatches, next, isEntryPoint);\n+                        ParserRuleContext.OPEN_BRACE };\n+                break;\n             case LIST_CONSTRUCTOR:\n             case MEMBER_ACCESS_KEY_EXPR:\n             case BRACKETED_LIST:\n             case STMT_START_BRACKETED_LIST:\n-                next = new ParserRuleContext[] { ParserRuleContext.COMMA, ParserRuleContext.BINARY_OPERATOR,\n+                alternatives = new ParserRuleContext[] { ParserRuleContext.COMMA, ParserRuleContext.BINARY_OPERATOR,\n                         ParserRuleContext.DOT, ParserRuleContext.ANNOT_CHAINING_TOKEN,\n                         ParserRuleContext.OPTIONAL_CHAINING_TOKEN, ParserRuleContext.CONDITIONAL_EXPRESSION,\n                         ParserRuleContext.XML_NAVIGATE_EXPR, ParserRuleContext.MEMBER_ACCESS_KEY_EXPR,\n-                        ParserRuleContext.CLOSE_BRACKET, ParserRuleContext.ARG_LIST_START };\n-                return seekInAlternativesPaths(lookahead, currentDepth, currentMatches, next, isEntryPoint);\n+                        ParserRuleContext.CLOSE_BRACKET };\n+                break;\n             case LET_EXPR_LET_VAR_DECL:\n-                next = new ParserRuleContext[] { ParserRuleContext.COMMA, ParserRuleContext.BINARY_OPERATOR,\n+                alternatives = new ParserRuleContext[] { ParserRuleContext.COMMA, ParserRuleContext.BINARY_OPERATOR,\n                         ParserRuleContext.DOT, ParserRuleContext.ANNOT_CHAINING_TOKEN,\n                         ParserRuleContext.OPTIONAL_CHAINING_TOKEN, ParserRuleContext.CONDITIONAL_EXPRESSION,\n                         ParserRuleContext.XML_NAVIGATE_EXPR, ParserRuleContext.MEMBER_ACCESS_KEY_EXPR,\n-                        ParserRuleContext.IN_KEYWORD, ParserRuleContext.ARG_LIST_START };\n-                return seekInAlternativesPaths(lookahead, currentDepth, currentMatches, next, isEntryPoint);\n+                        ParserRuleContext.IN_KEYWORD };\n+                break;\n             case LET_CLAUSE_LET_VAR_DECL:\n-                next = new ParserRuleContext[] { ParserRuleContext.COMMA, ParserRuleContext.BINARY_OPERATOR,\n+                alternatives = new ParserRuleContext[] { ParserRuleContext.COMMA, ParserRuleContext.BINARY_OPERATOR,\n                         ParserRuleContext.DOT, ParserRuleContext.ANNOT_CHAINING_TOKEN,\n                         ParserRuleContext.OPTIONAL_CHAINING_TOKEN, ParserRuleContext.CONDITIONAL_EXPRESSION,\n                         ParserRuleContext.XML_NAVIGATE_EXPR, ParserRuleContext.MEMBER_ACCESS_KEY_EXPR,\n-                        ParserRuleContext.LET_CLAUSE_END, ParserRuleContext.ARG_LIST_START };\n-                return seekInAlternativesPaths(lookahead, currentDepth, currentMatches, next, isEntryPoint);\n+                        ParserRuleContext.LET_CLAUSE_END };\n+                break;\n             case QUERY_EXPRESSION:\n-                next = new ParserRuleContext[] { ParserRuleContext.BINARY_OPERATOR, ParserRuleContext.DOT,\n+                alternatives = new ParserRuleContext[] { ParserRuleContext.BINARY_OPERATOR, ParserRuleContext.DOT,\n                         ParserRuleContext.ANNOT_CHAINING_TOKEN, ParserRuleContext.OPTIONAL_CHAINING_TOKEN,\n                         ParserRuleContext.CONDITIONAL_EXPRESSION, ParserRuleContext.XML_NAVIGATE_EXPR,\n-                        ParserRuleContext.MEMBER_ACCESS_KEY_EXPR, ParserRuleContext.QUERY_PIPELINE_RHS,\n-                        ParserRuleContext.ARG_LIST_START };\n-                return seekInAlternativesPaths(lookahead, currentDepth, currentMatches, next, isEntryPoint);\n+                        ParserRuleContext.MEMBER_ACCESS_KEY_EXPR, ParserRuleContext.QUERY_PIPELINE_RHS };\n+                break;\n             default:\n                 if (isParameter(parentCtx)) {\n-                    next = new ParserRuleContext[] { ParserRuleContext.CLOSE_PARENTHESIS,\n+                    alternatives = new ParserRuleContext[] { ParserRuleContext.CLOSE_PARENTHESIS,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3MTM1MA=="}, "originalCommit": {"oid": "04654775ff71bda4e848de10915aef00b0ffc477"}, "originalPosition": 121}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3449, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}