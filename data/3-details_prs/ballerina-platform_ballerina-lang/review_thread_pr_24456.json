{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM5ODc0Mzgx", "number": 24456, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxMzowMjo0NlrOEJpfng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxMzowNjozN1rOEJplsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4NTUyNDc4OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxMzowMjo0NlrOGqP3yA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQwNDozNTo1MVrOGqrW5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk1MzQxNg==", "bodyText": "Can we keep the original name?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24456#discussion_r446953416", "createdAt": "2020-06-29T13:02:46Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -500,7 +500,7 @@ public STNode resumeParsing(ParserRuleContext context, Object... args) {\n                 return parseMatchGuard();\n             case MATCH_PATTERN_START:\n                 return parseMatchPattern();\n-            case MATCH_PATTERN_RHS:\n+            case MATCH_PATTERN_OUTER_RHS:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1293cbac3cdcec24732d6e09bfe780c96db967fc"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQwMzc1MQ==", "bodyText": "Changed", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24456#discussion_r447403751", "createdAt": "2020-06-30T04:35:51Z", "author": {"login": "rdulmina"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -500,7 +500,7 @@ public STNode resumeParsing(ParserRuleContext context, Object... args) {\n                 return parseMatchGuard();\n             case MATCH_PATTERN_START:\n                 return parseMatchPattern();\n-            case MATCH_PATTERN_RHS:\n+            case MATCH_PATTERN_OUTER_RHS:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk1MzQxNg=="}, "originalCommit": {"oid": "1293cbac3cdcec24732d6e09bfe780c96db967fc"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4NTUyODM3OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxMzowMzozOVrOGqP5-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQwNDozNTo1NlrOGqrW9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk1Mzk3OA==", "bodyText": "list match pattern can also be an empty list. So a while loop would be a better option?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24456#discussion_r446953978", "createdAt": "2020-06-29T13:03:39Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -12492,6 +12496,100 @@ private STNode parseVarKeyword() {\n         }\n     }\n \n+    /**\n+     * Parse list match pattern.\n+     * <p>\n+     *     <code>\n+     *         list-match-pattern := [ list-member-match-patterns ]\n+     *         list-member-match-patterns :=\n+     *          match-pattern (, match-pattern)* [, rest-match-pattern]\n+     *          | [ rest-match-pattern ]\n+     *     </code>\n+     * </p>\n+     *\n+     * @return Parsed list match pattern node\n+     */\n+    private STNode parseListMatchPattern() {\n+        startContext(ParserRuleContext.LIST_MATCH_PATTERN);\n+        STNode openBracketToken = parseOpenBracket();\n+        List<STNode> matchPatternList = new ArrayList<>();\n+        STNode restMatchPattern = null;\n+        STNode matchPatternMemberRhs;\n+\n+        do {\n+            STToken nextToken = peek();\n+            if (nextToken.kind == SyntaxKind.ELLIPSIS_TOKEN) {\n+                restMatchPattern = parseRestMatchPattern();\n+                break;\n+            }\n+            STNode matchPatternListMember = parseMatchPattern();\n+            matchPatternList.add(matchPatternListMember);\n+            matchPatternMemberRhs = parseListMatchPatternMemberRhs();\n+\n+            if (matchPatternMemberRhs != null) {\n+                matchPatternList.add(matchPatternMemberRhs);\n+            }\n+        } while (matchPatternMemberRhs != null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1293cbac3cdcec24732d6e09bfe780c96db967fc"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQwMzc2Nw==", "bodyText": "Changed", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24456#discussion_r447403767", "createdAt": "2020-06-30T04:35:56Z", "author": {"login": "rdulmina"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -12492,6 +12496,100 @@ private STNode parseVarKeyword() {\n         }\n     }\n \n+    /**\n+     * Parse list match pattern.\n+     * <p>\n+     *     <code>\n+     *         list-match-pattern := [ list-member-match-patterns ]\n+     *         list-member-match-patterns :=\n+     *          match-pattern (, match-pattern)* [, rest-match-pattern]\n+     *          | [ rest-match-pattern ]\n+     *     </code>\n+     * </p>\n+     *\n+     * @return Parsed list match pattern node\n+     */\n+    private STNode parseListMatchPattern() {\n+        startContext(ParserRuleContext.LIST_MATCH_PATTERN);\n+        STNode openBracketToken = parseOpenBracket();\n+        List<STNode> matchPatternList = new ArrayList<>();\n+        STNode restMatchPattern = null;\n+        STNode matchPatternMemberRhs;\n+\n+        do {\n+            STToken nextToken = peek();\n+            if (nextToken.kind == SyntaxKind.ELLIPSIS_TOKEN) {\n+                restMatchPattern = parseRestMatchPattern();\n+                break;\n+            }\n+            STNode matchPatternListMember = parseMatchPattern();\n+            matchPatternList.add(matchPatternListMember);\n+            matchPatternMemberRhs = parseListMatchPatternMemberRhs();\n+\n+            if (matchPatternMemberRhs != null) {\n+                matchPatternList.add(matchPatternMemberRhs);\n+            }\n+        } while (matchPatternMemberRhs != null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk1Mzk3OA=="}, "originalCommit": {"oid": "1293cbac3cdcec24732d6e09bfe780c96db967fc"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4NTU0MDM1OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxMzowNjozN1rOGqQBNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQwNDozMDoxN1rOGqrRUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk1NTgzMA==", "bodyText": "should we add => also here? What if the close bracket is missing?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24456#discussion_r446955830", "createdAt": "2020-06-29T13:06:37Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -12492,6 +12496,100 @@ private STNode parseVarKeyword() {\n         }\n     }\n \n+    /**\n+     * Parse list match pattern.\n+     * <p>\n+     *     <code>\n+     *         list-match-pattern := [ list-member-match-patterns ]\n+     *         list-member-match-patterns :=\n+     *          match-pattern (, match-pattern)* [, rest-match-pattern]\n+     *          | [ rest-match-pattern ]\n+     *     </code>\n+     * </p>\n+     *\n+     * @return Parsed list match pattern node\n+     */\n+    private STNode parseListMatchPattern() {\n+        startContext(ParserRuleContext.LIST_MATCH_PATTERN);\n+        STNode openBracketToken = parseOpenBracket();\n+        List<STNode> matchPatternList = new ArrayList<>();\n+        STNode restMatchPattern = null;\n+        STNode matchPatternMemberRhs;\n+\n+        do {\n+            STToken nextToken = peek();\n+            if (nextToken.kind == SyntaxKind.ELLIPSIS_TOKEN) {\n+                restMatchPattern = parseRestMatchPattern();\n+                break;\n+            }\n+            STNode matchPatternListMember = parseMatchPattern();\n+            matchPatternList.add(matchPatternListMember);\n+            matchPatternMemberRhs = parseListMatchPatternMemberRhs();\n+\n+            if (matchPatternMemberRhs != null) {\n+                matchPatternList.add(matchPatternMemberRhs);\n+            }\n+        } while (matchPatternMemberRhs != null);\n+\n+        if (restMatchPattern == null) {\n+            restMatchPattern = STNodeFactory.createEmptyNode();\n+        }\n+\n+        STNode matchPatternListNode =  STNodeFactory.createNodeList(matchPatternList);\n+        STNode closeBracketToken = parseCloseBracket();\n+        endContext();\n+\n+        return STNodeFactory.createListMatchPatternNode(openBracketToken, matchPatternListNode, restMatchPattern,\n+                closeBracketToken);\n+    }\n+\n+    /** Parse rest match pattern.\n+     *<p>\n+     *     <code>\n+     *         rest-match-pattern := ... var variable-name\n+     *     </code>\n+     *</p>\n+     *\n+     * @return Parsed rest match pattern node\n+     */\n+    private STNode parseRestMatchPattern() {\n+        startContext(ParserRuleContext.REST_MATCH_PATTERN);\n+        //We approach here only after seeing ellipsis token hence consume.\n+        STNode ellipsisToken = consume();\n+        STNode varKeywordToken = parseVarKeyword();\n+        STNode variableName = parseVariableName();\n+        endContext();\n+\n+        STSimpleNameReferenceNode simpleNameReferenceNode =\n+                (STSimpleNameReferenceNode) STNodeFactory.createSimpleNameReferenceNode(variableName);\n+        return STNodeFactory.createRestMatchPatternNode(ellipsisToken, varKeywordToken, simpleNameReferenceNode);\n+    }\n+\n+    private STNode parseListMatchPatternMemberRhs() {\n+        return parseListMatchPatternMemberRhs(peek().kind);\n+    }\n+\n+    private STNode parseListMatchPatternMemberRhs(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case COMMA_TOKEN:\n+                return parseComma();\n+            case CLOSE_BRACKET_TOKEN:\n+            case EOF_TOKEN:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1293cbac3cdcec24732d6e09bfe780c96db967fc"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQwMjMyMg==", "bodyText": "Close bracket will recover there", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24456#discussion_r447402322", "createdAt": "2020-06-30T04:30:17Z", "author": {"login": "rdulmina"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -12492,6 +12496,100 @@ private STNode parseVarKeyword() {\n         }\n     }\n \n+    /**\n+     * Parse list match pattern.\n+     * <p>\n+     *     <code>\n+     *         list-match-pattern := [ list-member-match-patterns ]\n+     *         list-member-match-patterns :=\n+     *          match-pattern (, match-pattern)* [, rest-match-pattern]\n+     *          | [ rest-match-pattern ]\n+     *     </code>\n+     * </p>\n+     *\n+     * @return Parsed list match pattern node\n+     */\n+    private STNode parseListMatchPattern() {\n+        startContext(ParserRuleContext.LIST_MATCH_PATTERN);\n+        STNode openBracketToken = parseOpenBracket();\n+        List<STNode> matchPatternList = new ArrayList<>();\n+        STNode restMatchPattern = null;\n+        STNode matchPatternMemberRhs;\n+\n+        do {\n+            STToken nextToken = peek();\n+            if (nextToken.kind == SyntaxKind.ELLIPSIS_TOKEN) {\n+                restMatchPattern = parseRestMatchPattern();\n+                break;\n+            }\n+            STNode matchPatternListMember = parseMatchPattern();\n+            matchPatternList.add(matchPatternListMember);\n+            matchPatternMemberRhs = parseListMatchPatternMemberRhs();\n+\n+            if (matchPatternMemberRhs != null) {\n+                matchPatternList.add(matchPatternMemberRhs);\n+            }\n+        } while (matchPatternMemberRhs != null);\n+\n+        if (restMatchPattern == null) {\n+            restMatchPattern = STNodeFactory.createEmptyNode();\n+        }\n+\n+        STNode matchPatternListNode =  STNodeFactory.createNodeList(matchPatternList);\n+        STNode closeBracketToken = parseCloseBracket();\n+        endContext();\n+\n+        return STNodeFactory.createListMatchPatternNode(openBracketToken, matchPatternListNode, restMatchPattern,\n+                closeBracketToken);\n+    }\n+\n+    /** Parse rest match pattern.\n+     *<p>\n+     *     <code>\n+     *         rest-match-pattern := ... var variable-name\n+     *     </code>\n+     *</p>\n+     *\n+     * @return Parsed rest match pattern node\n+     */\n+    private STNode parseRestMatchPattern() {\n+        startContext(ParserRuleContext.REST_MATCH_PATTERN);\n+        //We approach here only after seeing ellipsis token hence consume.\n+        STNode ellipsisToken = consume();\n+        STNode varKeywordToken = parseVarKeyword();\n+        STNode variableName = parseVariableName();\n+        endContext();\n+\n+        STSimpleNameReferenceNode simpleNameReferenceNode =\n+                (STSimpleNameReferenceNode) STNodeFactory.createSimpleNameReferenceNode(variableName);\n+        return STNodeFactory.createRestMatchPatternNode(ellipsisToken, varKeywordToken, simpleNameReferenceNode);\n+    }\n+\n+    private STNode parseListMatchPatternMemberRhs() {\n+        return parseListMatchPatternMemberRhs(peek().kind);\n+    }\n+\n+    private STNode parseListMatchPatternMemberRhs(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case COMMA_TOKEN:\n+                return parseComma();\n+            case CLOSE_BRACKET_TOKEN:\n+            case EOF_TOKEN:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk1NTgzMA=="}, "originalCommit": {"oid": "1293cbac3cdcec24732d6e09bfe780c96db967fc"}, "originalPosition": 118}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3287, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}