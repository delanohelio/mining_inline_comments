{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ2Njk3NjI1", "number": 24673, "reviewThreads": {"totalCount": 46, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxMDozNjoxOFrOEPEohA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwODo0MjoxNVrOFGlwvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0MjQwMDA0OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/ballerinalang/model/TreeBuilder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxMDozNjoxOFrOGylKRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxMDozNjoxOFrOGylKRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTY5MDgyMA==", "bodyText": "remove new line", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r455690820", "createdAt": "2020-07-16T10:36:18Z", "author": {"login": "pcnfernando"}, "path": "compiler/ballerina-lang/src/main/java/org/ballerinalang/model/TreeBuilder.java", "diffHunk": "@@ -772,6 +776,15 @@ public static OnClauseNode createOnClauseNode() {\n         return new BLangOnClause();\n     }\n \n+    public static OrderKeyNode createOrderKeyNode() {\n+        return new BLangOrderKey();\n+    }\n+\n+    public static OrderByClauseNode createOrderByClauseNode() {\n+        return new BLangOrderByClause();\n+    }\n+\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "51c98ac3dd40db0337e5598d365ee10a4af7215a"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0MjQwNzc5OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/ballerinalang/model/clauses/OrderByClauseNode.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxMDozODo0NlrOGylPNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxMDozODo0NlrOGylPNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTY5MjA4Ng==", "bodyText": "it should be since swan lake. Check other places as well for classes you introduced", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r455692086", "createdAt": "2020-07-16T10:38:46Z", "author": {"login": "pcnfernando"}, "path": "compiler/ballerina-lang/src/main/java/org/ballerinalang/model/clauses/OrderByClauseNode.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+\n+package org.ballerinalang.model.clauses;\n+\n+import org.ballerinalang.model.tree.Node;\n+\n+import java.util.List;\n+\n+/**\n+ * The interface with the APIs to implement the \"order by\" clause.\n+ *\n+ * @since 2.0.0", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "51c98ac3dd40db0337e5598d365ee10a4af7215a"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0MjQxMTA5OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/ballerinalang/util/diagnostic/DiagnosticCode.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxMDozOTo0NVrOGylRTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxMDozOTo0NVrOGylRTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTY5MjYyMg==", "bodyText": "Try to group this with query errors", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r455692622", "createdAt": "2020-07-16T10:39:45Z", "author": {"login": "pcnfernando"}, "path": "compiler/ballerina-lang/src/main/java/org/ballerinalang/util/diagnostic/DiagnosticCode.java", "diffHunk": "@@ -431,6 +431,8 @@\n     ERROR_TYPE_EXPECTED(\"error.type.expected\"),\n     MISSING_REQUIRED_METHOD_NEXT(\"missing.required.method.next\"),\n \n+    ORDER_BY_NOT_SUPPORTED(\"order.by.not.supported\"),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "51c98ac3dd40db0337e5598d365ee10a4af7215a"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0MjQzMTM0OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/QueryDesugar.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxMDo0NTo0OVrOGyldkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxMDo0NTo0OVrOGyldkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTY5NTc2MQ==", "bodyText": "why are we filtering again? can't we have just the \"t\"? When can orElse be executed?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r455695761", "createdAt": "2020-07-16T10:45:49Z", "author": {"login": "pcnfernando"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/QueryDesugar.java", "diffHunk": "@@ -298,6 +310,54 @@ BLangStatementExpression desugar(BLangQueryAction queryAction, SymbolEnv env) {\n         return stmtExpr;\n     }\n \n+    /**\n+     * Get result type of the query output.\n+     *\n+     * @param type type of query expression.\n+     * @return result type.\n+     */\n+    private BType resolveExprType(BType type) {\n+        if (type.tag == TypeTags.STREAM) {\n+            return ((BStreamType) type).constraint;\n+        } else if (type.tag == TypeTags.TABLE) {\n+            return ((BTableType) type).constraint;\n+        } else if (type.tag == TypeTags.ARRAY) {\n+            return ((BArrayType) type).eType;\n+        } else if (type.tag == TypeTags.UNION) {\n+            List<BType> exprTypes = new ArrayList<>(((BUnionType) type).getMemberTypes());\n+            for (BType t : exprTypes) {\n+                BType returnType;\n+                if (t.tag == TypeTags.STREAM) {\n+                    returnType = ((BUnionType) type).getMemberTypes()\n+                            .stream().filter(m -> m.tag == TypeTags.STREAM)\n+                            .findFirst().orElse(symTable.streamType);\n+                    return ((BStreamType) returnType).constraint;\n+                } else if (t.tag == TypeTags.TABLE) {\n+                    returnType = ((BUnionType) type).getMemberTypes()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "51c98ac3dd40db0337e5598d365ee10a4af7215a"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0MjQzNDA5OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/ballerinalang/model/clauses/OrderKeyNode.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxMDo0Njo0M1rOGylfSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxMDo0Njo0M1rOGylfSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTY5NjIwMw==", "bodyText": "Add class comment", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r455696203", "createdAt": "2020-07-16T10:46:43Z", "author": {"login": "pcnfernando"}, "path": "compiler/ballerina-lang/src/main/java/org/ballerinalang/model/clauses/OrderKeyNode.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+\n+package org.ballerinalang.model.clauses;\n+\n+import org.ballerinalang.model.tree.Node;\n+import org.ballerinalang.model.tree.expressions.ExpressionNode;\n+\n+/**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "51c98ac3dd40db0337e5598d365ee10a4af7215a"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0MjQ0NTg5OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/QueryDesugar.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxMDo1MDoyNFrOGylmmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxMDo1MDoyNFrOGylmmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTY5ODA3NQ==", "bodyText": "Try to add the ballerina statements you are introducing as comments during desugaring", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r455698075", "createdAt": "2020-07-16T10:50:24Z", "author": {"login": "pcnfernando"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/QueryDesugar.java", "diffHunk": "@@ -241,6 +247,12 @@ BLangStatementExpression desugar(BLangQueryExpr queryExpr, SymbolEnv env) {\n         BLangBlockStmt queryBlock = ASTBuilderUtil.createBlockStmt(pos);\n         BLangVariableReference streamRef = buildStream(clauses, queryExpr.type, env, queryBlock);\n         BLangStatementExpression streamStmtExpr;\n+        if (orderByClause != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "51c98ac3dd40db0337e5598d365ee10a4af7215a"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0MjQ1NDEyOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/parser/BLangNodeTransformer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxMDo1Mjo0NlrOGylrhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxMDo1Mjo0NlrOGylrhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTY5OTMzMw==", "bodyText": "you can simplify this if", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r455699333", "createdAt": "2020-07-16T10:52:46Z", "author": {"login": "pcnfernando"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/parser/BLangNodeTransformer.java", "diffHunk": "@@ -3274,6 +3278,30 @@ public BLangNode transform(JoinClauseNode joinClauseNode) {\n         return joinClause;\n     }\n \n+    @Override\n+    public BLangNode transform(OrderByClauseNode orderByClauseNode) {\n+        BLangOrderByClause orderByClause = (BLangOrderByClause) TreeBuilder.createOrderByClauseNode();\n+        orderByClause.pos = getPosition(orderByClauseNode);\n+        for (OrderKeyNode orderKeyNode : orderByClauseNode.orderKey()) {\n+            orderByClause.addOrderKey(createOrderKey(orderKeyNode));\n+        }\n+        return orderByClause;\n+    }\n+\n+    public BLangOrderKey createOrderKey(OrderKeyNode orderKeyNode) {\n+        BLangOrderKey orderKey = (BLangOrderKey) TreeBuilder.createOrderKeyNode();\n+        orderKey.pos = getPosition(orderKeyNode);\n+        orderKey.expression = createExpression(orderKeyNode.expression());\n+        if (orderKeyNode.ascendingKeyword().isPresent()) {\n+            orderKey.isAscending = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "51c98ac3dd40db0337e5598d365ee10a4af7215a"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NTg5NjUzOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/CodeAnalyzer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwNTo1Nzo1OVrOGzGU7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwNTo1Nzo1OVrOGzGU7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIzNDIyMw==", "bodyText": "Same as before, check whether OrElse() will be executed?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r456234223", "createdAt": "2020-07-17T05:57:59Z", "author": {"login": "pcnfernando"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/CodeAnalyzer.java", "diffHunk": "@@ -2711,11 +2714,84 @@ public void visit(BLangQueryExpr queryExpr) {\n                         this.dlog.error(collection.pos, DiagnosticCode.NOT_ALLOWED_STREAM_USAGE_WITH_FROM);\n                     }\n                 }\n+            } else if (clause.getKind() == NodeKind.ORDER_BY) {\n+                checkOrderFieldValidity(queryExpr.type, (BLangOrderByClause) clause);\n             }\n             analyzeNode(clause, env);\n         }\n     }\n \n+    private void checkOrderFieldValidity(BType resultType, BLangOrderByClause clause) {\n+        if (resultType.tag == TypeTags.ARRAY) {\n+            resultType = ((BArrayType) resultType).eType;\n+        } else if (resultType.tag == TypeTags.TABLE) {\n+            resultType = ((BTableType) resultType).constraint;\n+        } else if (resultType.tag == TypeTags.STREAM) {\n+            resultType = ((BStreamType) resultType).constraint;\n+        } else if (resultType.tag == TypeTags.UNION) {\n+            List<BType> exprTypes = new ArrayList<>(((BUnionType) resultType).getMemberTypes());\n+            for (BType t : exprTypes) {\n+                BType returnType;\n+                if (t.tag == TypeTags.STREAM) {\n+                    returnType = ((BUnionType) resultType).getMemberTypes()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "57bf9f2e7d952ed4dd19cd54153df9ffb585a629"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1MTE5NjgxOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/CodeAnalyzer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwMToyMjowNFrOGz0DTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwMToyMjowNFrOGz0DTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk4MzM3NQ==", "bodyText": "Why don't we have to check string, xml cases here?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r456983375", "createdAt": "2020-07-20T01:22:04Z", "author": {"login": "grainier"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/CodeAnalyzer.java", "diffHunk": "@@ -2711,11 +2714,74 @@ public void visit(BLangQueryExpr queryExpr) {\n                         this.dlog.error(collection.pos, DiagnosticCode.NOT_ALLOWED_STREAM_USAGE_WITH_FROM);\n                     }\n                 }\n+            } else if (clause.getKind() == NodeKind.ORDER_BY) {\n+                checkOrderFieldValidity(queryExpr.type, (BLangOrderByClause) clause);\n             }\n             analyzeNode(clause, env);\n         }\n     }\n \n+    private void checkOrderFieldValidity(BType resultType, BLangOrderByClause clause) {\n+        if (resultType.tag == TypeTags.ARRAY) {\n+            resultType = ((BArrayType) resultType).eType;\n+        } else if (resultType.tag == TypeTags.TABLE) {\n+            resultType = ((BTableType) resultType).constraint;\n+        } else if (resultType.tag == TypeTags.STREAM) {\n+            resultType = ((BStreamType) resultType).constraint;\n+        } else if (resultType.tag == TypeTags.UNION) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "182ed4f795674a1e6c2c49f463d7ed020b5165cf"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1MTE5OTQ3OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/QueryDesugar.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwMToyNDo0M1rOGz0Eyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwMToyNDo0M1rOGz0Eyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk4Mzc1NA==", "bodyText": "You've written a similar function in CodeAnalyzer as well (but without string, XML checks). Is there a way to refactor both into one. Maybe we can but in Types?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r456983754", "createdAt": "2020-07-20T01:24:43Z", "author": {"login": "grainier"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/QueryDesugar.java", "diffHunk": "@@ -298,6 +311,38 @@ BLangStatementExpression desugar(BLangQueryAction queryAction, SymbolEnv env) {\n         return stmtExpr;\n     }\n \n+    /**\n+     * Get result type of the query output.\n+     *\n+     * @param type type of query expression.\n+     * @return result type.\n+     */\n+    private BType resolveExprType(BType type) {\n+        if (type.tag == TypeTags.STREAM) {\n+            return ((BStreamType) type).constraint;\n+        } else if (type.tag == TypeTags.TABLE) {\n+            return ((BTableType) type).constraint;\n+        } else if (type.tag == TypeTags.ARRAY) {\n+            return ((BArrayType) type).eType;\n+        } else if (type.tag == TypeTags.UNION) {\n+            List<BType> exprTypes = new ArrayList<>(((BUnionType) type).getMemberTypes());\n+            for (BType returnType : exprTypes) {\n+                if (returnType.tag == TypeTags.STREAM) {\n+                    return ((BStreamType) returnType).constraint;\n+                } else if (returnType.tag == TypeTags.TABLE) {\n+                    return ((BTableType) returnType).constraint;\n+                }  else if (returnType.tag == TypeTags.ARRAY) {\n+                    return ((BArrayType) returnType).eType;\n+                } else if (returnType.tag == TypeTags.STRING) {\n+                    return returnType;\n+                } else if (returnType.tag == TypeTags.XML) {\n+                    return returnType;\n+                }\n+            }\n+        }\n+        return type;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "182ed4f795674a1e6c2c49f463d7ed020b5165cf"}, "originalPosition": 89}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1MjcxMjY1OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwODo1Njo1OVrOG0A7jA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwODo1Njo1OVrOG0A7jA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzE5NDM4MA==", "bodyText": "Do we need to pass the context as a param?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r457194380", "createdAt": "2020-07-20T08:56:59Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -10287,6 +10356,98 @@ private STNode parseLetClause(boolean isRhsExpr) {\n         return STNodeFactory.createLetClauseNode(letKeyword, letVarDeclarations);\n     }\n \n+    /**\n+     * Parse order by clause.\n+     * <p>\n+     * <code>order-by-clause := order by expression (ascending | descending)? (expression (ascending | descending)?)*\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseOrderByClause(boolean isRhsExpr) {\n+        STToken nextToken = peek();\n+        if (nextToken.kind != SyntaxKind.ORDER_KEYWORD) {\n+            return STNodeFactory.createEmptyNode();\n+        }\n+        STNode orderKeyword = parseOrderKeyword();\n+        STNode byKeyword = parseByKeyword();\n+        STNode orderKeys = parseOrderKeyList(ParserRuleContext.ORDER_KEY, isRhsExpr);\n+\n+        byKeyword = cloneWithDiagnosticIfListEmpty(orderKeys, byKeyword,\n+                DiagnosticErrorCode.ERROR_MISSING_EXPRESSION);\n+\n+        return STNodeFactory.createOrderByClauseNode(orderKeyword, byKeyword, orderKeys);\n+    }\n+\n+    /**\n+     * Parse order key.\n+     * <p>\n+     * <code>order-key-list := order-key [, order-key]*</code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseOrderKeyList(ParserRuleContext context, boolean isRhsExpr) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc635f60e0d9f24bcd4d97af86cf6cf074e482fb"}, "originalPosition": 124}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1Mjc1NDYzOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwOTowNTowNlrOG0BTwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwOTowNTowNlrOG0BTwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzIwMDU3OA==", "bodyText": "Need to update resumeParsing method with each of these newly added methods (if they are calling the recover method)", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r457200578", "createdAt": "2020-07-20T09:05:06Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -10179,6 +10188,66 @@ private STNode parseOuterKeyword() {\n         }\n     }\n \n+    /**\n+     * Parse order-keyword.\n+     *\n+     * @return Order-keyword node\n+     */\n+    private STNode parseOrderKeyword() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc635f60e0d9f24bcd4d97af86cf6cf074e482fb"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1Mjc2NzMyOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwOTowNzoyMFrOG0BapA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwOTowNzoyMFrOG0BapA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzIwMjM0MA==", "bodyText": "When a comma separated list is parsed, theres a possibility of having some extraneous token after a member, that is not captured by isEndOfOrderKeys.\nTherefore we check the token before parsing the separator - because after recovering, we could even reach the end of the list. So we have to do something similar to parseListConstructorMemberEnd()/parseArgEnd() methods.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r457202340", "createdAt": "2020-07-20T09:07:20Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -10287,6 +10356,98 @@ private STNode parseLetClause(boolean isRhsExpr) {\n         return STNodeFactory.createLetClauseNode(letKeyword, letVarDeclarations);\n     }\n \n+    /**\n+     * Parse order by clause.\n+     * <p>\n+     * <code>order-by-clause := order by expression (ascending | descending)? (expression (ascending | descending)?)*\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseOrderByClause(boolean isRhsExpr) {\n+        STToken nextToken = peek();\n+        if (nextToken.kind != SyntaxKind.ORDER_KEYWORD) {\n+            return STNodeFactory.createEmptyNode();\n+        }\n+        STNode orderKeyword = parseOrderKeyword();\n+        STNode byKeyword = parseByKeyword();\n+        STNode orderKeys = parseOrderKeyList(ParserRuleContext.ORDER_KEY, isRhsExpr);\n+\n+        byKeyword = cloneWithDiagnosticIfListEmpty(orderKeys, byKeyword,\n+                DiagnosticErrorCode.ERROR_MISSING_EXPRESSION);\n+\n+        return STNodeFactory.createOrderByClauseNode(orderKeyword, byKeyword, orderKeys);\n+    }\n+\n+    /**\n+     * Parse order key.\n+     * <p>\n+     * <code>order-key-list := order-key [, order-key]*</code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseOrderKeyList(ParserRuleContext context, boolean isRhsExpr) {\n+        startContext(context);\n+        List<STNode> orderKeys = new ArrayList<>();\n+        STToken nextToken = peek();\n+\n+        // Make sure at least one order key is present\n+        if (isEndOfOrderKeys(nextToken.kind)) {\n+            endContext();\n+            return STNodeFactory.createEmptyNodeList();\n+        }\n+\n+        // Parse first order key, that has no leading comma\n+        STNode orderKey = parseOrderKey(isRhsExpr);\n+        orderKeys.add(orderKey);\n+\n+        // Parse the remaining order keys\n+        nextToken = peek();\n+        STNode leadingComma;\n+        while (!isEndOfOrderKeys(nextToken.kind)) {\n+            leadingComma = parseComma();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc635f60e0d9f24bcd4d97af86cf6cf074e482fb"}, "originalPosition": 143}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1Mjc3MjE1OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwOTowODoyM1rOG0BdaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwOTowODoyM1rOG0BdaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzIwMzA0OQ==", "bodyText": "Can you explain the reason for checking !isTypeStartingToken()?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r457203049", "createdAt": "2020-07-20T09:08:23Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -10287,6 +10356,98 @@ private STNode parseLetClause(boolean isRhsExpr) {\n         return STNodeFactory.createLetClauseNode(letKeyword, letVarDeclarations);\n     }\n \n+    /**\n+     * Parse order by clause.\n+     * <p>\n+     * <code>order-by-clause := order by expression (ascending | descending)? (expression (ascending | descending)?)*\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseOrderByClause(boolean isRhsExpr) {\n+        STToken nextToken = peek();\n+        if (nextToken.kind != SyntaxKind.ORDER_KEYWORD) {\n+            return STNodeFactory.createEmptyNode();\n+        }\n+        STNode orderKeyword = parseOrderKeyword();\n+        STNode byKeyword = parseByKeyword();\n+        STNode orderKeys = parseOrderKeyList(ParserRuleContext.ORDER_KEY, isRhsExpr);\n+\n+        byKeyword = cloneWithDiagnosticIfListEmpty(orderKeys, byKeyword,\n+                DiagnosticErrorCode.ERROR_MISSING_EXPRESSION);\n+\n+        return STNodeFactory.createOrderByClauseNode(orderKeyword, byKeyword, orderKeys);\n+    }\n+\n+    /**\n+     * Parse order key.\n+     * <p>\n+     * <code>order-key-list := order-key [, order-key]*</code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseOrderKeyList(ParserRuleContext context, boolean isRhsExpr) {\n+        startContext(context);\n+        List<STNode> orderKeys = new ArrayList<>();\n+        STToken nextToken = peek();\n+\n+        // Make sure at least one order key is present\n+        if (isEndOfOrderKeys(nextToken.kind)) {\n+            endContext();\n+            return STNodeFactory.createEmptyNodeList();\n+        }\n+\n+        // Parse first order key, that has no leading comma\n+        STNode orderKey = parseOrderKey(isRhsExpr);\n+        orderKeys.add(orderKey);\n+\n+        // Parse the remaining order keys\n+        nextToken = peek();\n+        STNode leadingComma;\n+        while (!isEndOfOrderKeys(nextToken.kind)) {\n+            leadingComma = parseComma();\n+            orderKeys.add(leadingComma);\n+            orderKey = parseOrderKey(isRhsExpr);\n+            orderKeys.add(orderKey);\n+            nextToken = peek();\n+        }\n+\n+        endContext();\n+        return STNodeFactory.createNodeList(orderKeys);\n+    }\n+\n+    private boolean isEndOfOrderKeys(SyntaxKind tokenKind) {\n+        switch (tokenKind) {\n+            case COMMA_TOKEN:\n+                return false;\n+            case IN_KEYWORD:\n+                return true;\n+            default:\n+                return !isTypeStartingToken(tokenKind);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc635f60e0d9f24bcd4d97af86cf6cf074e482fb"}, "originalPosition": 161}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1Mjc4MDc1OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwOToxMDowN1rOG0BiEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwOToxMDowN1rOG0BiEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzIwNDI0MA==", "bodyText": "Add case EOF", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r457204240", "createdAt": "2020-07-20T09:10:07Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -10287,6 +10356,98 @@ private STNode parseLetClause(boolean isRhsExpr) {\n         return STNodeFactory.createLetClauseNode(letKeyword, letVarDeclarations);\n     }\n \n+    /**\n+     * Parse order by clause.\n+     * <p>\n+     * <code>order-by-clause := order by expression (ascending | descending)? (expression (ascending | descending)?)*\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseOrderByClause(boolean isRhsExpr) {\n+        STToken nextToken = peek();\n+        if (nextToken.kind != SyntaxKind.ORDER_KEYWORD) {\n+            return STNodeFactory.createEmptyNode();\n+        }\n+        STNode orderKeyword = parseOrderKeyword();\n+        STNode byKeyword = parseByKeyword();\n+        STNode orderKeys = parseOrderKeyList(ParserRuleContext.ORDER_KEY, isRhsExpr);\n+\n+        byKeyword = cloneWithDiagnosticIfListEmpty(orderKeys, byKeyword,\n+                DiagnosticErrorCode.ERROR_MISSING_EXPRESSION);\n+\n+        return STNodeFactory.createOrderByClauseNode(orderKeyword, byKeyword, orderKeys);\n+    }\n+\n+    /**\n+     * Parse order key.\n+     * <p>\n+     * <code>order-key-list := order-key [, order-key]*</code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseOrderKeyList(ParserRuleContext context, boolean isRhsExpr) {\n+        startContext(context);\n+        List<STNode> orderKeys = new ArrayList<>();\n+        STToken nextToken = peek();\n+\n+        // Make sure at least one order key is present\n+        if (isEndOfOrderKeys(nextToken.kind)) {\n+            endContext();\n+            return STNodeFactory.createEmptyNodeList();\n+        }\n+\n+        // Parse first order key, that has no leading comma\n+        STNode orderKey = parseOrderKey(isRhsExpr);\n+        orderKeys.add(orderKey);\n+\n+        // Parse the remaining order keys\n+        nextToken = peek();\n+        STNode leadingComma;\n+        while (!isEndOfOrderKeys(nextToken.kind)) {\n+            leadingComma = parseComma();\n+            orderKeys.add(leadingComma);\n+            orderKey = parseOrderKey(isRhsExpr);\n+            orderKeys.add(orderKey);\n+            nextToken = peek();\n+        }\n+\n+        endContext();\n+        return STNodeFactory.createNodeList(orderKeys);\n+    }\n+\n+    private boolean isEndOfOrderKeys(SyntaxKind tokenKind) {\n+        switch (tokenKind) {\n+            case COMMA_TOKEN:\n+                return false;\n+            case IN_KEYWORD:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc635f60e0d9f24bcd4d97af86cf6cf074e482fb"}, "originalPosition": 158}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1Mjc5NTkzOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwOToxMzoxNlrOG0Bq3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwOToxMzoxNlrOG0Bq3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzIwNjQ5NQ==", "bodyText": "A switch-case would better suite for this.\nWe may have to go for error-recovery if the next token is neither ascending,descending nor a valid-token that is possible to come after the  order-key", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r457206495", "createdAt": "2020-07-20T09:13:16Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -10287,6 +10356,98 @@ private STNode parseLetClause(boolean isRhsExpr) {\n         return STNodeFactory.createLetClauseNode(letKeyword, letVarDeclarations);\n     }\n \n+    /**\n+     * Parse order by clause.\n+     * <p>\n+     * <code>order-by-clause := order by expression (ascending | descending)? (expression (ascending | descending)?)*\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseOrderByClause(boolean isRhsExpr) {\n+        STToken nextToken = peek();\n+        if (nextToken.kind != SyntaxKind.ORDER_KEYWORD) {\n+            return STNodeFactory.createEmptyNode();\n+        }\n+        STNode orderKeyword = parseOrderKeyword();\n+        STNode byKeyword = parseByKeyword();\n+        STNode orderKeys = parseOrderKeyList(ParserRuleContext.ORDER_KEY, isRhsExpr);\n+\n+        byKeyword = cloneWithDiagnosticIfListEmpty(orderKeys, byKeyword,\n+                DiagnosticErrorCode.ERROR_MISSING_EXPRESSION);\n+\n+        return STNodeFactory.createOrderByClauseNode(orderKeyword, byKeyword, orderKeys);\n+    }\n+\n+    /**\n+     * Parse order key.\n+     * <p>\n+     * <code>order-key-list := order-key [, order-key]*</code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseOrderKeyList(ParserRuleContext context, boolean isRhsExpr) {\n+        startContext(context);\n+        List<STNode> orderKeys = new ArrayList<>();\n+        STToken nextToken = peek();\n+\n+        // Make sure at least one order key is present\n+        if (isEndOfOrderKeys(nextToken.kind)) {\n+            endContext();\n+            return STNodeFactory.createEmptyNodeList();\n+        }\n+\n+        // Parse first order key, that has no leading comma\n+        STNode orderKey = parseOrderKey(isRhsExpr);\n+        orderKeys.add(orderKey);\n+\n+        // Parse the remaining order keys\n+        nextToken = peek();\n+        STNode leadingComma;\n+        while (!isEndOfOrderKeys(nextToken.kind)) {\n+            leadingComma = parseComma();\n+            orderKeys.add(leadingComma);\n+            orderKey = parseOrderKey(isRhsExpr);\n+            orderKeys.add(orderKey);\n+            nextToken = peek();\n+        }\n+\n+        endContext();\n+        return STNodeFactory.createNodeList(orderKeys);\n+    }\n+\n+    private boolean isEndOfOrderKeys(SyntaxKind tokenKind) {\n+        switch (tokenKind) {\n+            case COMMA_TOKEN:\n+                return false;\n+            case IN_KEYWORD:\n+                return true;\n+            default:\n+                return !isTypeStartingToken(tokenKind);\n+        }\n+    }\n+\n+    /**\n+     * Parse order key.\n+     * <p>\n+     * <code>order-key := expression (ascending | descending)?</code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseOrderKey(boolean isRhsExpr) {\n+        STNode expression = parseExpression(OperatorPrecedence.QUERY, isRhsExpr, false);\n+        STToken nextToken = peek();\n+        if (nextToken.kind == SyntaxKind.ASCENDING_KEYWORD) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc635f60e0d9f24bcd4d97af86cf6cf074e482fb"}, "originalPosition": 175}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1MjgxMDU5OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/syntax/tree/SyntaxKind.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwOToxNjowMlrOG0BzFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwOToxNjowMlrOG0BzFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzIwODU5OQ==", "bodyText": "theres an overlap in the numbers (another set of keywords starts with 250) - shall we update the \"Type keywords\" (the ones that are below) to start with 300?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r457208599", "createdAt": "2020-07-20T09:16:02Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/syntax/tree/SyntaxKind.java", "diffHunk": "@@ -98,6 +98,10 @@\n     JOIN_KEYWORD(244, \"join\"),\n     OUTER_KEYWORD(245, \"outer\"),\n     EQUALS_KEYWORD(246, \"equals\"),\n+    ORDER_KEYWORD(247, \"order\"),\n+    BY_KEYWORD(248, \"by\"),\n+    ASCENDING_KEYWORD(249, \"ascending\"),\n+    DESCENDING_KEYWORD(250, \"descending\"),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc635f60e0d9f24bcd4d97af86cf6cf074e482fb"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1MjgzODg1OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-treegen/src/main/resources/syntax_tree_descriptor.json", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwOToyMToyNlrOG0CChQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwOToyMToyNlrOG0CChQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzIxMjU0OQ==", "bodyText": "Defining both as optional allows someone to add both keywords at once in the syntax-tree.\nI think we need to have only one optional-field and that should hold the value regardless its ascending or descending.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r457212549", "createdAt": "2020-07-20T09:21:26Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-treegen/src/main/resources/syntax_tree_descriptor.json", "diffHunk": "@@ -4093,6 +4093,47 @@\n                     \"type\": \"Token\"\n                 }\n             ]\n+        },\n+        {\n+            \"name\": \"OrderByClauseNode\",\n+            \"base\": \"ClauseNode\",\n+            \"kind\": \"ORDER_BY_CLAUSE\",\n+            \"attributes\": [\n+                {\n+                    \"name\": \"orderKeyword\",\n+                    \"type\": \"Token\"\n+                },\n+                {\n+                    \"name\": \"byKeyword\",\n+                    \"type\": \"Token\"\n+                },\n+                {\n+                    \"name\": \"orderKey\",\n+                    \"type\": \"OrderKeyNode\",\n+                    \"occurrences\": \"MULTIPLE_SEPARATED\"\n+                }\n+            ]\n+        },\n+        {\n+            \"name\": \"OrderKeyNode\",\n+            \"base\": \"Node\",\n+            \"kind\": \"ORDER_KEY\",\n+            \"attributes\": [\n+                {\n+                    \"name\": \"expression\",\n+                    \"type\": \"ExpressionNode\"\n+                },\n+                {\n+                    \"name\": \"ascendingKeyword\",\n+                    \"type\": \"Token\",\n+                    \"isOptional\": true\n+                },\n+                {\n+                    \"name\": \"descendingKeyword\",\n+                    \"type\": \"Token\",\n+                    \"isOptional\": true\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc635f60e0d9f24bcd4d97af86cf6cf074e482fb"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1MjkxNzE3OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwOTozNToyNVrOG0CtnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwOTozNToyNVrOG0CtnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzIyMzU4MA==", "bodyText": "I think we can avoid this check. If first token is not ORDER_KEYWORD it will be handled inside parseOrderKeyword()", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r457223580", "createdAt": "2020-07-20T09:35:25Z", "author": {"login": "lochana-chathura"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -10287,6 +10356,98 @@ private STNode parseLetClause(boolean isRhsExpr) {\n         return STNodeFactory.createLetClauseNode(letKeyword, letVarDeclarations);\n     }\n \n+    /**\n+     * Parse order by clause.\n+     * <p>\n+     * <code>order-by-clause := order by expression (ascending | descending)? (expression (ascending | descending)?)*\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseOrderByClause(boolean isRhsExpr) {\n+        STToken nextToken = peek();\n+        if (nextToken.kind != SyntaxKind.ORDER_KEYWORD) {\n+            return STNodeFactory.createEmptyNode();\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc635f60e0d9f24bcd4d97af86cf6cf074e482fb"}, "originalPosition": 106}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1MjkyNTg0OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwOTozNzoxOVrOG0Cyyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwOTozNzoxOVrOG0Cyyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzIyNDkwNw==", "bodyText": "this looks more cleaner to me. order-by-clause := order by (expression (ascending | descending)?)+\nWDYT?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r457224907", "createdAt": "2020-07-20T09:37:19Z", "author": {"login": "lochana-chathura"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -10287,6 +10356,98 @@ private STNode parseLetClause(boolean isRhsExpr) {\n         return STNodeFactory.createLetClauseNode(letKeyword, letVarDeclarations);\n     }\n \n+    /**\n+     * Parse order by clause.\n+     * <p>\n+     * <code>order-by-clause := order by expression (ascending | descending)? (expression (ascending | descending)?)*", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc635f60e0d9f24bcd4d97af86cf6cf074e482fb"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1Mjk0MTAzOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwOTo0MDoyN1rOG0C7dA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwOTo0MDoyN1rOG0C7dA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzIyNzEyNA==", "bodyText": "Shall we add order-clause to documentation above; intermediate-clause := from-clause | where-clause | let-clause", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r457227124", "createdAt": "2020-07-20T09:40:27Z", "author": {"login": "lochana-chathura"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -10129,6 +10133,11 @@ private STNode parseIntermediateClause(SyntaxKind nextTokenKind, boolean isRhsEx\n             case JOIN_KEYWORD:\n             case OUTER_KEYWORD:\n                 return parseJoinClause(isRhsExpr);\n+            case ORDER_KEYWORD:\n+            case BY_KEYWORD:\n+            case ASCENDING_KEYWORD:\n+            case DESCENDING_KEYWORD:\n+                return parseOrderByClause(isRhsExpr);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc635f60e0d9f24bcd4d97af86cf6cf074e482fb"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1Mjk0ODA1OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwOTo0MTo1NVrOG0C_uw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwOTo0MTo1NVrOG0C_uw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzIyODIxOQ==", "bodyText": "Let's use STNodeFactory.createEmptyNode(); instead of passing null, in all places", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r457228219", "createdAt": "2020-07-20T09:41:55Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -10287,6 +10356,98 @@ private STNode parseLetClause(boolean isRhsExpr) {\n         return STNodeFactory.createLetClauseNode(letKeyword, letVarDeclarations);\n     }\n \n+    /**\n+     * Parse order by clause.\n+     * <p>\n+     * <code>order-by-clause := order by expression (ascending | descending)? (expression (ascending | descending)?)*\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseOrderByClause(boolean isRhsExpr) {\n+        STToken nextToken = peek();\n+        if (nextToken.kind != SyntaxKind.ORDER_KEYWORD) {\n+            return STNodeFactory.createEmptyNode();\n+        }\n+        STNode orderKeyword = parseOrderKeyword();\n+        STNode byKeyword = parseByKeyword();\n+        STNode orderKeys = parseOrderKeyList(ParserRuleContext.ORDER_KEY, isRhsExpr);\n+\n+        byKeyword = cloneWithDiagnosticIfListEmpty(orderKeys, byKeyword,\n+                DiagnosticErrorCode.ERROR_MISSING_EXPRESSION);\n+\n+        return STNodeFactory.createOrderByClauseNode(orderKeyword, byKeyword, orderKeys);\n+    }\n+\n+    /**\n+     * Parse order key.\n+     * <p>\n+     * <code>order-key-list := order-key [, order-key]*</code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseOrderKeyList(ParserRuleContext context, boolean isRhsExpr) {\n+        startContext(context);\n+        List<STNode> orderKeys = new ArrayList<>();\n+        STToken nextToken = peek();\n+\n+        // Make sure at least one order key is present\n+        if (isEndOfOrderKeys(nextToken.kind)) {\n+            endContext();\n+            return STNodeFactory.createEmptyNodeList();\n+        }\n+\n+        // Parse first order key, that has no leading comma\n+        STNode orderKey = parseOrderKey(isRhsExpr);\n+        orderKeys.add(orderKey);\n+\n+        // Parse the remaining order keys\n+        nextToken = peek();\n+        STNode leadingComma;\n+        while (!isEndOfOrderKeys(nextToken.kind)) {\n+            leadingComma = parseComma();\n+            orderKeys.add(leadingComma);\n+            orderKey = parseOrderKey(isRhsExpr);\n+            orderKeys.add(orderKey);\n+            nextToken = peek();\n+        }\n+\n+        endContext();\n+        return STNodeFactory.createNodeList(orderKeys);\n+    }\n+\n+    private boolean isEndOfOrderKeys(SyntaxKind tokenKind) {\n+        switch (tokenKind) {\n+            case COMMA_TOKEN:\n+                return false;\n+            case IN_KEYWORD:\n+                return true;\n+            default:\n+                return !isTypeStartingToken(tokenKind);\n+        }\n+    }\n+\n+    /**\n+     * Parse order key.\n+     * <p>\n+     * <code>order-key := expression (ascending | descending)?</code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseOrderKey(boolean isRhsExpr) {\n+        STNode expression = parseExpression(OperatorPrecedence.QUERY, isRhsExpr, false);\n+        STToken nextToken = peek();\n+        if (nextToken.kind == SyntaxKind.ASCENDING_KEYWORD) {\n+            STNode ascendingKeyword = parseAscendingKeyword();\n+            return STNodeFactory.createOrderKeyNode(expression, ascendingKeyword, null);\n+        } else if (nextToken.kind == SyntaxKind.DESCENDING_KEYWORD) {\n+            STNode descendingKeyword = parseDescendingKeyword();\n+            return STNodeFactory.createOrderKeyNode(expression, null, descendingKeyword);\n+        } else {\n+            return STNodeFactory.createOrderKeyNode(expression, null, null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc635f60e0d9f24bcd4d97af86cf6cf074e482fb"}, "originalPosition": 182}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2Mjc3MDk2OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMjowMjoxM1rOG1fS5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMjowMjoxM1rOG1fS5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc0MDQ1NA==", "bodyText": "Would be better to replace this with a switch-case. It'l be faster and neat than the if-else, since there many conditions.\nCan do the same for the above method as well.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r458740454", "createdAt": "2020-07-22T12:02:13Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -3432,4 +3432,65 @@ private boolean checkFillerValue(BArrayType type) {\n         }\n         return hasFillerValue(type.eType);\n     }\n+\n+    /**\n+     * Get result type of the query output.\n+     *\n+     * @param type type of query expression.\n+     * @return result type.\n+     */\n+    public BType resolveExprType(BType type) {\n+        if (type.tag == TypeTags.STREAM) {\n+            return ((BStreamType) type).constraint;\n+        } else if (type.tag == TypeTags.TABLE) {\n+            return ((BTableType) type).constraint;\n+        } else if (type.tag == TypeTags.ARRAY) {\n+            return ((BArrayType) type).eType;\n+        } else if (type.tag == TypeTags.UNION) {\n+            List<BType> exprTypes = new ArrayList<>(((BUnionType) type).getMemberTypes());\n+            for (BType returnType : exprTypes) {\n+                if (returnType.tag == TypeTags.STREAM) {\n+                    return ((BStreamType) returnType).constraint;\n+                } else if (returnType.tag == TypeTags.TABLE) {\n+                    return ((BTableType) returnType).constraint;\n+                }  else if (returnType.tag == TypeTags.ARRAY) {\n+                    return ((BArrayType) returnType).eType;\n+                } else if (returnType.tag == TypeTags.STRING) {\n+                    return returnType;\n+                } else if (returnType.tag == TypeTags.XML) {\n+                    return returnType;\n+                }\n+            }\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Check whether a type is a basic type.\n+     *\n+     * @param type type of the field.\n+     * @return boolean whether the type is basic type or not.\n+     */\n+    public boolean checkBasicType(BType type) {\n+        if (type.tag == TypeTags.INT) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4500b550b4b38ebcf432e84af6615fdf37f8c7bc"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2Mjc3MjU1OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMjowMjo0M1rOG1fT1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMjowMjo0M1rOG1fT1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc0MDY5Mg==", "bodyText": "Should BYTE type also go here?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r458740692", "createdAt": "2020-07-22T12:02:43Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -3432,4 +3432,65 @@ private boolean checkFillerValue(BArrayType type) {\n         }\n         return hasFillerValue(type.eType);\n     }\n+\n+    /**\n+     * Get result type of the query output.\n+     *\n+     * @param type type of query expression.\n+     * @return result type.\n+     */\n+    public BType resolveExprType(BType type) {\n+        if (type.tag == TypeTags.STREAM) {\n+            return ((BStreamType) type).constraint;\n+        } else if (type.tag == TypeTags.TABLE) {\n+            return ((BTableType) type).constraint;\n+        } else if (type.tag == TypeTags.ARRAY) {\n+            return ((BArrayType) type).eType;\n+        } else if (type.tag == TypeTags.UNION) {\n+            List<BType> exprTypes = new ArrayList<>(((BUnionType) type).getMemberTypes());\n+            for (BType returnType : exprTypes) {\n+                if (returnType.tag == TypeTags.STREAM) {\n+                    return ((BStreamType) returnType).constraint;\n+                } else if (returnType.tag == TypeTags.TABLE) {\n+                    return ((BTableType) returnType).constraint;\n+                }  else if (returnType.tag == TypeTags.ARRAY) {\n+                    return ((BArrayType) returnType).eType;\n+                } else if (returnType.tag == TypeTags.STRING) {\n+                    return returnType;\n+                } else if (returnType.tag == TypeTags.XML) {\n+                    return returnType;\n+                }\n+            }\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Check whether a type is a basic type.\n+     *\n+     * @param type type of the field.\n+     * @return boolean whether the type is basic type or not.\n+     */\n+    public boolean checkBasicType(BType type) {\n+        if (type.tag == TypeTags.INT) {\n+            return true;\n+        } else if (type.tag == TypeTags.FLOAT) {\n+            return true;\n+        } else if (type.tag == TypeTags.DECIMAL) {\n+            return true;\n+        } else if (type.tag == TypeTags.STRING) {\n+            return true;\n+        } else if (type.tag == TypeTags.BOOLEAN) {\n+            return true;\n+        } else if (type.tag == TypeTags.NIL) {\n+            return true;\n+        } else if (type.tag == TypeTags.UNION) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4500b550b4b38ebcf432e84af6615fdf37f8c7bc"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2Mjc3NTY0OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/parser/NodeCloner.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMjowMzo0NFrOG1fVzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMjowMzo0NFrOG1fVzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc0MTE5OA==", "bodyText": "extra newline", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r458741198", "createdAt": "2020-07-22T12:03:44Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/parser/NodeCloner.java", "diffHunk": "@@ -1395,6 +1397,23 @@ public void visit(BLangOnClause source) {\n         clone.expression = clone(source.expression);\n     }\n \n+    @Override\n+    public void visit(BLangOrderKey source) {\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4500b550b4b38ebcf432e84af6615fdf37f8c7bc"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2Mjc3NTc5OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/parser/NodeCloner.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMjowMzo0OFrOG1fV7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMjowMzo0OFrOG1fV7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc0MTIyOQ==", "bodyText": "extra newline", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r458741229", "createdAt": "2020-07-22T12:03:48Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/parser/NodeCloner.java", "diffHunk": "@@ -1395,6 +1397,23 @@ public void visit(BLangOnClause source) {\n         clone.expression = clone(source.expression);\n     }\n \n+    @Override\n+    public void visit(BLangOrderKey source) {\n+\n+        BLangOrderKey clone = new BLangOrderKey();\n+        source.cloneRef = clone;\n+        clone.expression = clone(source.expression);\n+        clone.isAscending = source.isAscending;\n+    }\n+\n+    @Override\n+    public void visit(BLangOrderByClause source) {\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4500b550b4b38ebcf432e84af6615fdf37f8c7bc"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2Mjc4MzQzOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/CodeAnalyzer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMjowNjoyMFrOG1famg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMjowNjoyMFrOG1famg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc0MjQyNg==", "bodyText": "shall we invert the condition and do an early-exit? That way we can avoid one level of right-indentations.\neg:\nif (resultType.tag != TypeTags.RECORD) {\n    return;\n}", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r458742426", "createdAt": "2020-07-22T12:06:20Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/CodeAnalyzer.java", "diffHunk": "@@ -2712,11 +2715,34 @@ public void visit(BLangQueryExpr queryExpr) {\n                         this.dlog.error(collection.pos, DiagnosticCode.NOT_ALLOWED_STREAM_USAGE_WITH_FROM);\n                     }\n                 }\n+            } else if (clause.getKind() == NodeKind.ORDER_BY) {\n+                checkOrderFieldValidity(queryExpr.type, (BLangOrderByClause) clause);\n             }\n             analyzeNode(clause, env);\n         }\n     }\n \n+    private void checkOrderFieldValidity(BType resultType, BLangOrderByClause clause) {\n+        resultType = types.resolveExprType(resultType);\n+        if (resultType.tag == TypeTags.RECORD) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4500b550b4b38ebcf432e84af6615fdf37f8c7bc"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2Mjc4ODQ1OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMjowNzo1N1rOG1fdvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMjowNzo1N1rOG1fdvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc0MzIyOA==", "bodyText": "can remove these extra newlines", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r458743228", "createdAt": "2020-07-22T12:07:57Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -10397,6 +10417,201 @@ private STNode parseLetClause(boolean isRhsExpr) {\n         return STNodeFactory.createLetClauseNode(letKeyword, letVarDeclarations);\n     }\n \n+    /**\n+     * Parse order-keyword.\n+     *\n+     * @return Order-keyword node\n+     */\n+    private STNode parseOrderKeyword() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.ORDER_KEYWORD) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(token, ParserRuleContext.ORDER_KEYWORD);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse by-keyword.\n+     *\n+     * @return By-keyword node\n+     */\n+    private STNode parseByKeyword() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.BY_KEYWORD) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(token, ParserRuleContext.BY_KEYWORD);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse ascending-keyword.\n+     *\n+     * @return Ascending-keyword node\n+     */\n+    private STNode parseAscendingKeyword() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.ASCENDING_KEYWORD) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(token, ParserRuleContext.ASCENDING_KEYWORD);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse descending-keyword.\n+     *\n+     * @return Descending-keyword node\n+     */\n+    private STNode parseDescendingKeyword() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.DESCENDING_KEYWORD) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(token, ParserRuleContext.DESCENDING_KEYWORD);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse order by clause.\n+     * <p>\n+     * <code>order-by-clause := order by order-key-list\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseOrderByClause(boolean isRhsExpr) {\n+        STNode orderKeyword = parseOrderKeyword();\n+        STNode byKeyword = parseByKeyword();\n+        STNode orderKeys = parseOrderKeyList(isRhsExpr);\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4500b550b4b38ebcf432e84af6615fdf37f8c7bc"}, "originalPosition": 117}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2Mjc5MjAyOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMjowOTowM1rOG1ff-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMjowOTowM1rOG1ff-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc0MzgwMA==", "bodyText": "comment is sort of not correct, since we don't do any validation here..", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r458743800", "createdAt": "2020-07-22T12:09:03Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -10397,6 +10417,201 @@ private STNode parseLetClause(boolean isRhsExpr) {\n         return STNodeFactory.createLetClauseNode(letKeyword, letVarDeclarations);\n     }\n \n+    /**\n+     * Parse order-keyword.\n+     *\n+     * @return Order-keyword node\n+     */\n+    private STNode parseOrderKeyword() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.ORDER_KEYWORD) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(token, ParserRuleContext.ORDER_KEYWORD);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse by-keyword.\n+     *\n+     * @return By-keyword node\n+     */\n+    private STNode parseByKeyword() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.BY_KEYWORD) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(token, ParserRuleContext.BY_KEYWORD);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse ascending-keyword.\n+     *\n+     * @return Ascending-keyword node\n+     */\n+    private STNode parseAscendingKeyword() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.ASCENDING_KEYWORD) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(token, ParserRuleContext.ASCENDING_KEYWORD);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse descending-keyword.\n+     *\n+     * @return Descending-keyword node\n+     */\n+    private STNode parseDescendingKeyword() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.DESCENDING_KEYWORD) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(token, ParserRuleContext.DESCENDING_KEYWORD);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse order by clause.\n+     * <p>\n+     * <code>order-by-clause := order by order-key-list\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseOrderByClause(boolean isRhsExpr) {\n+        STNode orderKeyword = parseOrderKeyword();\n+        STNode byKeyword = parseByKeyword();\n+        STNode orderKeys = parseOrderKeyList(isRhsExpr);\n+\n+        byKeyword = cloneWithDiagnosticIfListEmpty(orderKeys, byKeyword,\n+                DiagnosticErrorCode.ERROR_MISSING_ORDER_KEY);\n+\n+        return STNodeFactory.createOrderByClauseNode(orderKeyword, byKeyword, orderKeys);\n+    }\n+\n+    /**\n+     * Parse order key.\n+     * <p>\n+     * <code>order-key-list := order-key [, order-key]*</code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseOrderKeyList(boolean isRhsExpr) {\n+        startContext(ParserRuleContext.ORDER_KEY);\n+        List<STNode> orderKeys = new ArrayList<>();\n+        STToken nextToken = peek();\n+\n+        // Make sure at least one order key is present", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4500b550b4b38ebcf432e84af6615fdf37f8c7bc"}, "originalPosition": 136}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MjgwMzgyOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMjoxMjozNFrOG1fnFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMjoxMjozNFrOG1fnFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc0NTYyMA==", "bodyText": "since this list has only one member, we can remove the list and directly use EXPRESSION as the next rule, where ORDER_KEY_LIST_START is used. Can remove it from hasAlternativePaths() methods also, since it has only one path", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r458745620", "createdAt": "2020-07-22T12:12:34Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -558,6 +559,12 @@\n     private static final ParserRuleContext[] NAMED_ARG_MATCH_PATTERN_RHS =\n             { ParserRuleContext.NAMED_ARG_MATCH_PATTERN, ParserRuleContext.REST_MATCH_PATTERN };\n \n+    private static final ParserRuleContext[] ORDER_KEY_LIST_START =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4500b550b4b38ebcf432e84af6615fdf37f8c7bc"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MjgwODY2OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMjoxMzo1NVrOG1fp6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMjoxMzo1NVrOG1fp6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc0NjM0Ng==", "bodyText": "Need to update the isProductionWithAlternatives with the same.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r458746346", "createdAt": "2020-07-22T12:13:55Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -1174,6 +1185,8 @@ private boolean hasAlternativePaths(ParserRuleContext currentCtx) {\n             case TABLE_KEY_RHS:\n             case ERROR_TYPE_PARAMS:\n             case LET_VAR_DECL_START:\n+            case ORDER_KEY_LIST_START:\n+            case ORDER_KEY_LIST_END:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4500b550b4b38ebcf432e84af6615fdf37f8c7bc"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2Mjg0MTEzOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMjoyMzo0NVrOG1f-IA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMjoyMzo0NVrOG1f-IA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc1MTUyMA==", "bodyText": "Here we states which tokens can occur after some expression.\neg: ... order by foo <cursor>\nsince what follows after by keyword is an expression, we can put many tokens inplace of <cursor>, such as a binary operator (foo + bar), a dot (foo.bar), etc. So we need to add all those.\nYou can check for the common things compared to the other cases in the switch-case. Additionally, there can be ParserRuleContext.ORDER_CLAUSE_END.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r458751520", "createdAt": "2020-07-22T12:23:45Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -1906,6 +1925,11 @@ private Result seekMatchInExpressionRhs(int lookahead, int currentDepth, int cur\n                         ParserRuleContext.XML_NAVIGATE_EXPR, ParserRuleContext.MEMBER_ACCESS_KEY_EXPR,\n                         ParserRuleContext.LET_CLAUSE_END };\n                 break;\n+            case ORDER_KEY:\n+                alternatives = new ParserRuleContext[] { ParserRuleContext.COMMA, ParserRuleContext.EXPRESSION,\n+                        ParserRuleContext.ASCENDING_KEYWORD, ParserRuleContext.DESCENDING_KEYWORD,\n+                        ParserRuleContext.ORDER_CLAUSE_END };\n+                break;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4500b550b4b38ebcf432e84af6615fdf37f8c7bc"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2Mjg1MDM2OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMjoyNjoyM1rOG1gEAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMjoyNjoyM1rOG1gEAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc1MzAyNw==", "bodyText": "I think we shouldn't need to add it here, since an order-keyword cannot exist inside a let-var-decl.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r458753027", "createdAt": "2020-07-22T12:26:23Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -2688,6 +2717,21 @@ private ParserRuleContext getNextRuleForKeywords(ParserRuleContext currentCtx, i\n                     endContext(); // end let-clause-let-var-decl\n                 }\n                 return ParserRuleContext.EXPRESSION;\n+            case ORDER_KEYWORD:\n+                parentCtx = getParentContext();\n+                if (parentCtx == ParserRuleContext.LET_CLAUSE_LET_VAR_DECL) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4500b550b4b38ebcf432e84af6615fdf37f8c7bc"}, "originalPosition": 100}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2Mjg3NzYyOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMjozNDowNFrOG1gU-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMjozNDowNFrOG1gU-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc1NzM3MQ==", "bodyText": "Looks like a new context is not started for ORDER_CLAUSE_END, so this condition may never be true?\nI think a better approach would be to say, next token context after the ascending/descending keywords is ORDER_KEY_RHS. And it has alternative paths - ORDER_KEY and ORDER_CLAUSE_END", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r458757371", "createdAt": "2020-07-22T12:34:04Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -2688,6 +2717,21 @@ private ParserRuleContext getNextRuleForKeywords(ParserRuleContext currentCtx, i\n                     endContext(); // end let-clause-let-var-decl\n                 }\n                 return ParserRuleContext.EXPRESSION;\n+            case ORDER_KEYWORD:\n+                parentCtx = getParentContext();\n+                if (parentCtx == ParserRuleContext.LET_CLAUSE_LET_VAR_DECL) {\n+                    endContext(); // end let-clause-let-var-decl\n+                }\n+                return ParserRuleContext.BY_KEYWORD;\n+            case BY_KEYWORD:\n+                return ParserRuleContext.ORDER_KEY;\n+            case ASCENDING_KEYWORD:\n+            case DESCENDING_KEYWORD:\n+                parentCtx = getParentContext();\n+                if (parentCtx == ParserRuleContext.ORDER_CLAUSE_END) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4500b550b4b38ebcf432e84af6615fdf37f8c7bc"}, "originalPosition": 109}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2Mjg4MDE3OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMjozNDo0OFrOG1gWoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMjozNDo0OFrOG1gWoQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc1Nzc5Mw==", "bodyText": "I think you'll have to end the context which-ever path it takes, otherwise there will be nested contexts started without ending them", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r458757793", "createdAt": "2020-07-22T12:34:48Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -2688,6 +2717,21 @@ private ParserRuleContext getNextRuleForKeywords(ParserRuleContext currentCtx, i\n                     endContext(); // end let-clause-let-var-decl\n                 }\n                 return ParserRuleContext.EXPRESSION;\n+            case ORDER_KEYWORD:\n+                parentCtx = getParentContext();\n+                if (parentCtx == ParserRuleContext.LET_CLAUSE_LET_VAR_DECL) {\n+                    endContext(); // end let-clause-let-var-decl\n+                }\n+                return ParserRuleContext.BY_KEYWORD;\n+            case BY_KEYWORD:\n+                return ParserRuleContext.ORDER_KEY;\n+            case ASCENDING_KEYWORD:\n+            case DESCENDING_KEYWORD:\n+                parentCtx = getParentContext();\n+                if (parentCtx == ParserRuleContext.ORDER_CLAUSE_END) {\n+                    endContext(); // end order-key", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4500b550b4b38ebcf432e84af6615fdf37f8c7bc"}, "originalPosition": 110}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2Mjg5NDA2OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-treegen/src/main/resources/syntax_tree_descriptor.json", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMjozODo1MlrOG1gfng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMjozODo1MlrOG1gfng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc2MDA5NA==", "bodyText": "These two should be replaced by a single field.\neg:\n\"attributes\": [\n    {\n        \"name\": \"expression\",\n        \"type\": \"ExpressionNode\"\n    },\n    {\n        \"name\": \"order\",\n        \"type\": \"Token\"\n        \"isOptional\": true\n    }\n]\n\nThis way, only one can exist at a time.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r458760094", "createdAt": "2020-07-22T12:38:52Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-treegen/src/main/resources/syntax_tree_descriptor.json", "diffHunk": "@@ -4093,6 +4093,46 @@\n                     \"type\": \"Token\"\n                 }\n             ]\n+        },\n+        {\n+            \"name\": \"OrderByClauseNode\",\n+            \"base\": \"ClauseNode\",\n+            \"kind\": \"ORDER_BY_CLAUSE\",\n+            \"attributes\": [\n+                {\n+                    \"name\": \"orderKeyword\",\n+                    \"type\": \"Token\"\n+                },\n+                {\n+                    \"name\": \"byKeyword\",\n+                    \"type\": \"Token\"\n+                },\n+                {\n+                    \"name\": \"orderKey\",\n+                    \"type\": \"OrderKeyNode\",\n+                    \"occurrences\": \"MULTIPLE_SEPARATED\"\n+                }\n+            ]\n+        },\n+        {\n+            \"name\": \"OrderKeyNode\",\n+            \"base\": \"Node\",\n+            \"kind\": \"ORDER_KEY\",\n+            \"attributes\": [\n+                {\n+                    \"name\": \"expression\",\n+                    \"type\": \"ExpressionNode\"\n+                },\n+                {\n+                    \"name\": \"ascendingKeyword\",\n+                    \"type\": \"Token\"\n+                },\n+                {\n+                    \"name\": \"descendingKeyword\",\n+                    \"type\": \"Token\",\n+                    \"isOptional\": true\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4500b550b4b38ebcf432e84af6615fdf37f8c7bc"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MjkwNjQ2OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-parser/src/test/java/io/ballerinalang/compiler/parser/test/syntax/expressions/QueryExpressionTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMjo0MjoyMFrOG1gnSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMjo0MjoyMFrOG1gnSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc2MjA1OA==", "bodyText": "does this includes negative tests (tests with incorrect syntaxes) also?\n\nIf yes - shall we split it in to two? There are separate sections in the same test file for positive tests and negative tests\nIf not - shall we add some?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r458762058", "createdAt": "2020-07-22T12:42:20Z", "author": {"login": "SupunS"}, "path": "compiler/ballerina-parser/src/test/java/io/ballerinalang/compiler/parser/test/syntax/expressions/QueryExpressionTest.java", "diffHunk": "@@ -169,4 +169,16 @@ public void testQueryWithOperatorPrecedenceWithExtraClauses() {\n         test(\"from int a in b select c let int a = b + from int f in g select h\",\n                 \"query-expr/query_expr_assert_38.json\");\n     }\n+\n+    @Test\n+    public void testQueryWithOrderByClause() {\n+        test(\"from int a in b where c let int d = e order by f select g\", \"query-expr/query_expr_assert_39.json\");\n+        test(\"from int a in b where c let int d = e order by f ascending, g select h\", \"query-expr\" +\n+                \"/query_expr_assert_40.json\");\n+        test(\"from int a in b order by c ascending, d descending select e\", \"query-expr\" +\n+                \"/query_expr_assert_41.json\");\n+        test(\"from int a in b order by select c\", \"query-expr/query_expr_assert_42.json\");\n+        test(\"from int a in b order c select d\", \"query-expr/query_expr_assert_43.json\");\n+        test(\"from int a in b order by c ascending d select e\", \"query-expr/query_expr_assert_44.json\");\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4500b550b4b38ebcf432e84af6615fdf37f8c7bc"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyNDQxNDE5OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/parser/BLangPackageBuilder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwODoxMDoyMlrOIHpW3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwODo0NjoxN1rOIHqq-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg4ODU0Mw==", "bodyText": "try to use .isEmpty() rather when ever possible. these provided functions are more optimized", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r544888543", "createdAt": "2020-12-17T08:10:22Z", "author": {"login": "pcnfernando"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/parser/BLangPackageBuilder.java", "diffHunk": "@@ -2091,6 +2095,25 @@ void createOnClause(DiagnosticPos pos, Set<Whitespace> ws) {\n         joinClause.onClause = onClause;\n     }\n \n+    void createOrderByKey(DiagnosticPos pos, Set<Whitespace> ws, boolean isAscending) {\n+        BLangOrderKey orderKey = (BLangOrderKey) TreeBuilder.createOrderKeyNode();\n+        orderKey.pos = pos;\n+        orderKey.setOrderKey(this.exprNodeStack.pop());\n+        orderKey.setOrderDirection(isAscending);\n+        orderKeyListStack.push(orderKey);\n+    }\n+\n+    void createOrderByClause(DiagnosticPos pos, Set<Whitespace> ws) {\n+        BLangOrderByClause orderByClause = (BLangOrderByClause) TreeBuilder.createOrderByClauseNode();\n+        orderByClause.addWS(ws);\n+        orderByClause.pos = pos;\n+        Collections.reverse(orderKeyListStack);\n+        while (orderKeyListStack.size() > 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65deb30390b1ecb766a7c27a44a6f8c4175fb266"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDkxMDA3NQ==", "bodyText": "Will do. Unbale to address this here since BLangPackageBuilder.java is no longer used", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r544910075", "createdAt": "2020-12-17T08:46:17Z", "author": {"login": "lasinicl"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/parser/BLangPackageBuilder.java", "diffHunk": "@@ -2091,6 +2095,25 @@ void createOnClause(DiagnosticPos pos, Set<Whitespace> ws) {\n         joinClause.onClause = onClause;\n     }\n \n+    void createOrderByKey(DiagnosticPos pos, Set<Whitespace> ws, boolean isAscending) {\n+        BLangOrderKey orderKey = (BLangOrderKey) TreeBuilder.createOrderKeyNode();\n+        orderKey.pos = pos;\n+        orderKey.setOrderKey(this.exprNodeStack.pop());\n+        orderKey.setOrderDirection(isAscending);\n+        orderKeyListStack.push(orderKey);\n+    }\n+\n+    void createOrderByClause(DiagnosticPos pos, Set<Whitespace> ws) {\n+        BLangOrderByClause orderByClause = (BLangOrderByClause) TreeBuilder.createOrderByClauseNode();\n+        orderByClause.addWS(ws);\n+        orderByClause.pos = pos;\n+        Collections.reverse(orderKeyListStack);\n+        while (orderKeyListStack.size() > 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg4ODU0Mw=="}, "originalCommit": {"oid": "65deb30390b1ecb766a7c27a44a6f8c4175fb266"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyNDQxNjc3OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/parser/BLangParserListener.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwODoxMTowMlrOIHpYTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwODo1MDo1OVrOIHq2xw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg4ODkwOA==", "bodyText": "merge the two ifs", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r544888908", "createdAt": "2020-12-17T08:11:02Z", "author": {"login": "pcnfernando"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/parser/BLangParserListener.java", "diffHunk": "@@ -2933,6 +2933,31 @@ public void exitBinaryEqualsExpression(BallerinaParser.BinaryEqualsExpressionCon\n         this.pkgBuilder.createBinaryExpr(getCurrentPos(ctx), getWS(ctx), ctx.getChild(1).getText());\n     }\n \n+    @Override\n+    public void exitOrderKey(BallerinaParser.OrderKeyContext ctx) {\n+        if (isInErrorState) {\n+            return;\n+        }\n+\n+        boolean isAscending = true;\n+        if (ctx.orderDirection() != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65deb30390b1ecb766a7c27a44a6f8c4175fb266"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDkxMzA5NQ==", "bodyText": "BLangParserListener.java is no longer used.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r544913095", "createdAt": "2020-12-17T08:50:59Z", "author": {"login": "lasinicl"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/parser/BLangParserListener.java", "diffHunk": "@@ -2933,6 +2933,31 @@ public void exitBinaryEqualsExpression(BallerinaParser.BinaryEqualsExpressionCon\n         this.pkgBuilder.createBinaryExpr(getCurrentPos(ctx), getWS(ctx), ctx.getChild(1).getText());\n     }\n \n+    @Override\n+    public void exitOrderKey(BallerinaParser.OrderKeyContext ctx) {\n+        if (isInErrorState) {\n+            return;\n+        }\n+\n+        boolean isAscending = true;\n+        if (ctx.orderDirection() != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg4ODkwOA=="}, "originalCommit": {"oid": "65deb30390b1ecb766a7c27a44a6f8c4175fb266"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyNDQyODkzOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/CodeAnalyzer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwODoxNDowOVrOIHpfIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwODo1Njo1MlrOIHrFXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg5MDY1Ng==", "bodyText": "You can move orderKeyNode.getOrderKey().toString() as common local var", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r544890656", "createdAt": "2020-12-17T08:14:09Z", "author": {"login": "pcnfernando"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/CodeAnalyzer.java", "diffHunk": "@@ -2712,11 +2715,35 @@ public void visit(BLangQueryExpr queryExpr) {\n                         this.dlog.error(collection.pos, DiagnosticCode.NOT_ALLOWED_STREAM_USAGE_WITH_FROM);\n                     }\n                 }\n+            } else if (clause.getKind() == NodeKind.ORDER_BY) {\n+                checkOrderFieldValidity(queryExpr.type, (BLangOrderByClause) clause);\n             }\n             analyzeNode(clause, env);\n         }\n     }\n \n+    private void checkOrderFieldValidity(BType resultType, BLangOrderByClause clause) {\n+        resultType = types.resolveExprType(resultType);\n+        if (resultType.tag != TypeTags.RECORD) {\n+            return;\n+        }\n+        BRecordType recordType = (BRecordType) resultType;\n+        Map<String, BField> recordFields = recordType.fields;\n+        for (OrderKeyNode orderKeyNode : clause.getOrderKeyList()) {\n+            if (!recordFields.containsKey(orderKeyNode.getOrderKey().toString())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65deb30390b1ecb766a7c27a44a6f8c4175fb266"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDkxNjgzMA==", "bodyText": "This was removed in a later PR (#25108)", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r544916830", "createdAt": "2020-12-17T08:56:52Z", "author": {"login": "lasinicl"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/CodeAnalyzer.java", "diffHunk": "@@ -2712,11 +2715,35 @@ public void visit(BLangQueryExpr queryExpr) {\n                         this.dlog.error(collection.pos, DiagnosticCode.NOT_ALLOWED_STREAM_USAGE_WITH_FROM);\n                     }\n                 }\n+            } else if (clause.getKind() == NodeKind.ORDER_BY) {\n+                checkOrderFieldValidity(queryExpr.type, (BLangOrderByClause) clause);\n             }\n             analyzeNode(clause, env);\n         }\n     }\n \n+    private void checkOrderFieldValidity(BType resultType, BLangOrderByClause clause) {\n+        resultType = types.resolveExprType(resultType);\n+        if (resultType.tag != TypeTags.RECORD) {\n+            return;\n+        }\n+        BRecordType recordType = (BRecordType) resultType;\n+        Map<String, BField> recordFields = recordType.fields;\n+        for (OrderKeyNode orderKeyNode : clause.getOrderKeyList()) {\n+            if (!recordFields.containsKey(orderKeyNode.getOrderKey().toString())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg5MDY1Ng=="}, "originalCommit": {"oid": "65deb30390b1ecb766a7c27a44a6f8c4175fb266"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyNDQzNjkxOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/CodeAnalyzer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwODoxNjowNlrOIHpjxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwODo1Nzo1M1rOIHrIPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg5MTg0Ng==", "bodyText": "You can get this as common var and check !null instead of contains and use commonly for both if/else", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r544891846", "createdAt": "2020-12-17T08:16:06Z", "author": {"login": "pcnfernando"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/CodeAnalyzer.java", "diffHunk": "@@ -2712,11 +2715,35 @@ public void visit(BLangQueryExpr queryExpr) {\n                         this.dlog.error(collection.pos, DiagnosticCode.NOT_ALLOWED_STREAM_USAGE_WITH_FROM);\n                     }\n                 }\n+            } else if (clause.getKind() == NodeKind.ORDER_BY) {\n+                checkOrderFieldValidity(queryExpr.type, (BLangOrderByClause) clause);\n             }\n             analyzeNode(clause, env);\n         }\n     }\n \n+    private void checkOrderFieldValidity(BType resultType, BLangOrderByClause clause) {\n+        resultType = types.resolveExprType(resultType);\n+        if (resultType.tag != TypeTags.RECORD) {\n+            return;\n+        }\n+        BRecordType recordType = (BRecordType) resultType;\n+        Map<String, BField> recordFields = recordType.fields;\n+        for (OrderKeyNode orderKeyNode : clause.getOrderKeyList()) {\n+            if (!recordFields.containsKey(orderKeyNode.getOrderKey().toString())) {\n+                dlog.error(((BLangOrderKey) orderKeyNode).expression.pos,\n+                        DiagnosticCode.UNDEFINED_FIELD_IN_RECORD,\n+                        ((BLangOrderKey) orderKeyNode).expression, resultType);\n+            } else if (orderKeyNode.getOrderKey().toString() != null) {\n+                BType exprType = recordFields.get(orderKeyNode.getOrderKey().toString()).type;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65deb30390b1ecb766a7c27a44a6f8c4175fb266"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDkxNzU2NA==", "bodyText": "This was removed in a later PR (#25108)", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r544917564", "createdAt": "2020-12-17T08:57:53Z", "author": {"login": "lasinicl"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/CodeAnalyzer.java", "diffHunk": "@@ -2712,11 +2715,35 @@ public void visit(BLangQueryExpr queryExpr) {\n                         this.dlog.error(collection.pos, DiagnosticCode.NOT_ALLOWED_STREAM_USAGE_WITH_FROM);\n                     }\n                 }\n+            } else if (clause.getKind() == NodeKind.ORDER_BY) {\n+                checkOrderFieldValidity(queryExpr.type, (BLangOrderByClause) clause);\n             }\n             analyzeNode(clause, env);\n         }\n     }\n \n+    private void checkOrderFieldValidity(BType resultType, BLangOrderByClause clause) {\n+        resultType = types.resolveExprType(resultType);\n+        if (resultType.tag != TypeTags.RECORD) {\n+            return;\n+        }\n+        BRecordType recordType = (BRecordType) resultType;\n+        Map<String, BField> recordFields = recordType.fields;\n+        for (OrderKeyNode orderKeyNode : clause.getOrderKeyList()) {\n+            if (!recordFields.containsKey(orderKeyNode.getOrderKey().toString())) {\n+                dlog.error(((BLangOrderKey) orderKeyNode).expression.pos,\n+                        DiagnosticCode.UNDEFINED_FIELD_IN_RECORD,\n+                        ((BLangOrderKey) orderKeyNode).expression, resultType);\n+            } else if (orderKeyNode.getOrderKey().toString() != null) {\n+                BType exprType = recordFields.get(orderKeyNode.getOrderKey().toString()).type;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg5MTg0Ng=="}, "originalCommit": {"oid": "65deb30390b1ecb766a7c27a44a6f8c4175fb266"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyNDQ0OTUzOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/tree/clauses/BLangOrderByClause.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwODoxOTowN1rOIHpqyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwOTowOTozOFrOIHrmjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg5MzY0Mg==", "bodyText": "Unnecessary new line", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r544893642", "createdAt": "2020-12-17T08:19:07Z", "author": {"login": "pcnfernando"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/tree/clauses/BLangOrderByClause.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.wso2.ballerinalang.compiler.tree.clauses;\n+\n+import org.ballerinalang.model.clauses.OrderByClauseNode;\n+import org.ballerinalang.model.clauses.OrderKeyNode;\n+import org.ballerinalang.model.tree.NodeKind;\n+import org.wso2.ballerinalang.compiler.tree.BLangNode;\n+import org.wso2.ballerinalang.compiler.tree.BLangNodeVisitor;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.StringJoiner;\n+\n+/**\n+ * Implementation of \"order by\" clause statement.\n+ *\n+ * @since Swan Lake\n+ */\n+public class BLangOrderByClause extends BLangNode implements OrderByClauseNode {\n+    public List<OrderKeyNode> orderByKeyList = new ArrayList<>();\n+\n+    public BLangOrderByClause() {\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65deb30390b1ecb766a7c27a44a6f8c4175fb266"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDkyNTMyNQ==", "bodyText": "Fixed in b9ca2c1", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r544925325", "createdAt": "2020-12-17T09:09:38Z", "author": {"login": "lasinicl"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/tree/clauses/BLangOrderByClause.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.wso2.ballerinalang.compiler.tree.clauses;\n+\n+import org.ballerinalang.model.clauses.OrderByClauseNode;\n+import org.ballerinalang.model.clauses.OrderKeyNode;\n+import org.ballerinalang.model.tree.NodeKind;\n+import org.wso2.ballerinalang.compiler.tree.BLangNode;\n+import org.wso2.ballerinalang.compiler.tree.BLangNodeVisitor;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.StringJoiner;\n+\n+/**\n+ * Implementation of \"order by\" clause statement.\n+ *\n+ * @since Swan Lake\n+ */\n+public class BLangOrderByClause extends BLangNode implements OrderByClauseNode {\n+    public List<OrderKeyNode> orderByKeyList = new ArrayList<>();\n+\n+    public BLangOrderByClause() {\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg5MzY0Mg=="}, "originalCommit": {"oid": "65deb30390b1ecb766a7c27a44a6f8c4175fb266"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyNDQ5MzkyOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/tree/clauses/BLangOrderByClause.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwODoyOTo1N1rOIHqEIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwODoyOTo1N1rOIHqEIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDkwMDEyOA==", "bodyText": "You can use java streams api for joinning as well. No need to update it here. Just a suggestion for later since it's more descriptive.\neg:\norderByKeyList.stream()\n      .map(key -> key.toString())\n      .collect(Collectors.joining(\",\"));", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r544900128", "createdAt": "2020-12-17T08:29:57Z", "author": {"login": "pcnfernando"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/tree/clauses/BLangOrderByClause.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.wso2.ballerinalang.compiler.tree.clauses;\n+\n+import org.ballerinalang.model.clauses.OrderByClauseNode;\n+import org.ballerinalang.model.clauses.OrderKeyNode;\n+import org.ballerinalang.model.tree.NodeKind;\n+import org.wso2.ballerinalang.compiler.tree.BLangNode;\n+import org.wso2.ballerinalang.compiler.tree.BLangNodeVisitor;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.StringJoiner;\n+\n+/**\n+ * Implementation of \"order by\" clause statement.\n+ *\n+ * @since Swan Lake\n+ */\n+public class BLangOrderByClause extends BLangNode implements OrderByClauseNode {\n+    public List<OrderKeyNode> orderByKeyList = new ArrayList<>();\n+\n+    public BLangOrderByClause() {\n+\n+    }\n+\n+    @Override\n+    public NodeKind getKind() {\n+        return NodeKind.ORDER_BY;\n+    }\n+\n+    @Override\n+    public void accept(BLangNodeVisitor visitor) {\n+        visitor.visit(this);\n+    }\n+\n+    @Override\n+    public void addOrderKey(OrderKeyNode orderKeyNode) {\n+        orderByKeyList.add(orderKeyNode);\n+    }\n+\n+    @Override\n+    public List<OrderKeyNode> getOrderKeyList() {\n+        return orderByKeyList;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        StringJoiner declarations = new StringJoiner(\", \");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65deb30390b1ecb766a7c27a44a6f8c4175fb266"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyNDUzNTE0OnYy", "diffSide": "RIGHT", "path": "langlib/lang.query/src/main/ballerina/src/lang.query/helpers.bal", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwODozOTo1N1rOIHqbsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwOTowNDoxOVrOIHrZIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDkwNjE2MA==", "bodyText": "unnecessary line break", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r544906160", "createdAt": "2020-12-17T08:39:57Z", "author": {"login": "pcnfernando"}, "path": "langlib/lang.query/src/main/ballerina/src/lang.query/helpers.bal", "diffHunk": "@@ -141,6 +156,169 @@ public function consumeStream(stream<Type, error?> strm) returns error? {\n     }\n }\n \n+public type StreamOrderBy object {\n+    public string[] sortFields;\n+    public boolean[] sortTypes;\n+\n+    public function init(string[] sortFields, boolean[] sortTypes) {\n+        self.sortFields = sortFields;\n+        self.sortTypes = sortTypes;\n+    }\n+\n+    public function topDownMergeSort(@tainted Type[] events) returns @tainted Type[]{\n+        int index = 0;\n+        int n = events.length();\n+        Type[] b = [];\n+        while (index < n) {\n+            b[index] = events[index];\n+            index += 1;\n+        }\n+        self.topDownSplitMerge(b, 0, n, events);\n+        return events;\n+    }\n+\n+    function topDownSplitMerge(@tainted Type[] b, int iBegin, int iEnd, @tainted Type[] a) {\n+        if (iEnd - iBegin < 2) {\n+            return;\n+        }\n+        int iMiddle = (iEnd + iBegin) / 2;\n+        self.topDownSplitMerge(a, iBegin, iMiddle, b);\n+        self.topDownSplitMerge(a, iMiddle, iEnd, b);\n+        self.topDownMerge(b, iBegin, iMiddle, iEnd, a);\n+    }\n+\n+    function topDownMerge(@tainted Type[] a, int iBegin, int iMiddle, int iEnd, @tainted Type[] b) {\n+        int i = iBegin;\n+        int j = iMiddle;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65deb30390b1ecb766a7c27a44a6f8c4175fb266"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDkyMTg4OA==", "bodyText": "This function is no longer available since order by behavior was modified to use the array:sort() function", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r544921888", "createdAt": "2020-12-17T09:04:19Z", "author": {"login": "lasinicl"}, "path": "langlib/lang.query/src/main/ballerina/src/lang.query/helpers.bal", "diffHunk": "@@ -141,6 +156,169 @@ public function consumeStream(stream<Type, error?> strm) returns error? {\n     }\n }\n \n+public type StreamOrderBy object {\n+    public string[] sortFields;\n+    public boolean[] sortTypes;\n+\n+    public function init(string[] sortFields, boolean[] sortTypes) {\n+        self.sortFields = sortFields;\n+        self.sortTypes = sortTypes;\n+    }\n+\n+    public function topDownMergeSort(@tainted Type[] events) returns @tainted Type[]{\n+        int index = 0;\n+        int n = events.length();\n+        Type[] b = [];\n+        while (index < n) {\n+            b[index] = events[index];\n+            index += 1;\n+        }\n+        self.topDownSplitMerge(b, 0, n, events);\n+        return events;\n+    }\n+\n+    function topDownSplitMerge(@tainted Type[] b, int iBegin, int iEnd, @tainted Type[] a) {\n+        if (iEnd - iBegin < 2) {\n+            return;\n+        }\n+        int iMiddle = (iEnd + iBegin) / 2;\n+        self.topDownSplitMerge(a, iBegin, iMiddle, b);\n+        self.topDownSplitMerge(a, iMiddle, iEnd, b);\n+        self.topDownMerge(b, iBegin, iMiddle, iEnd, a);\n+    }\n+\n+    function topDownMerge(@tainted Type[] a, int iBegin, int iMiddle, int iEnd, @tainted Type[] b) {\n+        int i = iBegin;\n+        int j = iMiddle;\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDkwNjE2MA=="}, "originalCommit": {"oid": "65deb30390b1ecb766a7c27a44a6f8c4175fb266"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyNDUzODY3OnYy", "diffSide": "RIGHT", "path": "langlib/lang.query/src/main/ballerina/src/lang.query/helpers.bal", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwODo0MDo1M1rOIHqdzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwOTowNToyNlrOIHrb2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDkwNjcwMA==", "bodyText": "unnecessary new line", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r544906700", "createdAt": "2020-12-17T08:40:53Z", "author": {"login": "pcnfernando"}, "path": "langlib/lang.query/src/main/ballerina/src/lang.query/helpers.bal", "diffHunk": "@@ -141,6 +156,169 @@ public function consumeStream(stream<Type, error?> strm) returns error? {\n     }\n }\n \n+public type StreamOrderBy object {\n+    public string[] sortFields;\n+    public boolean[] sortTypes;\n+\n+    public function init(string[] sortFields, boolean[] sortTypes) {\n+        self.sortFields = sortFields;\n+        self.sortTypes = sortTypes;\n+    }\n+\n+    public function topDownMergeSort(@tainted Type[] events) returns @tainted Type[]{\n+        int index = 0;\n+        int n = events.length();\n+        Type[] b = [];\n+        while (index < n) {\n+            b[index] = events[index];\n+            index += 1;\n+        }\n+        self.topDownSplitMerge(b, 0, n, events);\n+        return events;\n+    }\n+\n+    function topDownSplitMerge(@tainted Type[] b, int iBegin, int iEnd, @tainted Type[] a) {\n+        if (iEnd - iBegin < 2) {\n+            return;\n+        }\n+        int iMiddle = (iEnd + iBegin) / 2;\n+        self.topDownSplitMerge(a, iBegin, iMiddle, b);\n+        self.topDownSplitMerge(a, iMiddle, iEnd, b);\n+        self.topDownMerge(b, iBegin, iMiddle, iEnd, a);\n+    }\n+\n+    function topDownMerge(@tainted Type[] a, int iBegin, int iMiddle, int iEnd, @tainted Type[] b) {\n+        int i = iBegin;\n+        int j = iMiddle;\n+\n+        int k = iBegin;\n+        while (k < iEnd) {\n+            if (i < iMiddle && (j >= iEnd || self.sortFunc(a[i], a[j], 0) < 0)) {\n+                b[k] = a[i];\n+                i = i + 1;\n+            } else {\n+                b[k] = a[j];\n+                j = j + 1;\n+            }\n+            k += 1;\n+        }\n+    }\n+\n+    function sortFunc(Type x, Type y, int fieldIndex) returns @tainted int {\n+        map<anydata> xMapValue = <map<anydata>>x;\n+        map<anydata> yMapValue = <map<anydata>>y;\n+\n+        var xFieldValue = xMapValue.get(self.sortFields[fieldIndex]);\n+        var yFieldValue = yMapValue.get(self.sortFields[fieldIndex]);\n+\n+        if (xFieldValue is ()) {\n+            if (yFieldValue is ()) {\n+                return 0;\n+            } else {\n+                return 1;\n+            }\n+        } else if (yFieldValue is ()) {\n+            return -1;\n+        } else if (xFieldValue is (int|float|decimal)) {\n+            if (yFieldValue is (int|float|decimal)) {\n+                int c;\n+                if (self.sortTypes[fieldIndex]) {\n+                    c = self.numberSort(xFieldValue, yFieldValue);\n+                } else {\n+                    c = self.numberSort(yFieldValue, xFieldValue);\n+                }\n+                return self.callNextSortFunc(x, y, c, fieldIndex + 1);\n+            } else {\n+                panic error(\"Inconsistent order field value\",\n+                message = self.sortFields[fieldIndex] + \" order field contain non-numeric values\");\n+            }\n+        } else if (xFieldValue is string) {\n+            if (yFieldValue is string) {\n+                int c;\n+                if (self.sortTypes[fieldIndex]) {\n+                    c = self.stringSort(xFieldValue, yFieldValue);\n+                } else {\n+                    c = self.stringSort(yFieldValue, xFieldValue);\n+                }\n+                return self.callNextSortFunc(x, y, c, fieldIndex + 1);\n+            } else {\n+                panic error(\"Inconsistent order field value\",\n+                message = self.sortFields[fieldIndex] + \" order field contain non-string type values\");\n+            }\n+        } else if (xFieldValue is boolean) {\n+            if (yFieldValue is boolean) {\n+                int c;\n+                if (self.sortTypes[fieldIndex]) {\n+                    c = self.booleanSort(xFieldValue, yFieldValue);\n+                } else {\n+                    c = self.booleanSort(yFieldValue, xFieldValue);\n+                }\n+                return self.callNextSortFunc(x, y, c, fieldIndex + 1);\n+            } else {\n+                  panic error(\"Inconsistent order field value\",\n+                  message = self.sortFields[fieldIndex] + \" order field contain non-boolean type values\");\n+            }\n+        } else {\n+            panic error(\"Unable to perform order by\",\n+            message = self.sortFields[fieldIndex] + \" field type incorrect\");\n+        }\n+    }\n+\n+    public function numberSort(int|float|decimal val1, int|float|decimal val2) returns int {\n+        if (val1 is int) {\n+            if (val2 is int) {\n+                return val1 - val2;\n+            } else if (val2 is float) {\n+                return <float>val1 < val2 ? -1 : <float>val1 == val2 ? 0 : 1;\n+            } else {\n+                return <decimal>val1 < val2 ? -1 : <decimal>val1 == val2 ? 0 : 1;\n+            }\n+        } else if (val1 is float) {\n+            if (val2 is int) {\n+                return val1 < <float>val2 ? -1 : val1 == <float>val2 ? 0 : 1;\n+            } else if (val2 is float){\n+                return val1 < val2 ? -1 : val1 == val2 ? 0 : 1;\n+            } else {\n+                return <decimal>val1 < val2 ? -1 : <decimal>val1 == val2 ? 0 : 1;\n+            }\n+        } else {\n+            if (val2 is (int|float)) {\n+                return val1 < <decimal>val2 ? -1 : val1 == <decimal>val2 ? 0 : 1;\n+            } else {\n+                return val1 < val2 ? -1 : val1 == val2 ? 0 : 1;\n+            }\n+        }\n+    }\n+\n+    public function stringSort(string st1, string st2) returns int {\n+        return strings:codePointCompare(st1, st2);\n+    }\n+\n+    public function booleanSort(boolean b1, boolean b2) returns int {\n+        if (b1) {\n+            if (b2) {\n+                return 0;\n+            } else {\n+                return 1;\n+            }\n+        } else {\n+            if (b2) {\n+                return -1;\n+            } else {\n+                return 0;\n+            }\n+        }\n+    }\n+\n+    function callNextSortFunc(Type x, Type y, int c, int fieldIndex) returns @tainted int {\n+        int result = c;\n+        if (result == 0 && (self.sortTypes.length() > fieldIndex)) {\n+            result = self.sortFunc(x, y, fieldIndex);\n+        }\n+        return result;\n+    }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65deb30390b1ecb766a7c27a44a6f8c4175fb266"}, "originalPosition": 194}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDkyMjU4Nw==", "bodyText": "same as above", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r544922587", "createdAt": "2020-12-17T09:05:26Z", "author": {"login": "lasinicl"}, "path": "langlib/lang.query/src/main/ballerina/src/lang.query/helpers.bal", "diffHunk": "@@ -141,6 +156,169 @@ public function consumeStream(stream<Type, error?> strm) returns error? {\n     }\n }\n \n+public type StreamOrderBy object {\n+    public string[] sortFields;\n+    public boolean[] sortTypes;\n+\n+    public function init(string[] sortFields, boolean[] sortTypes) {\n+        self.sortFields = sortFields;\n+        self.sortTypes = sortTypes;\n+    }\n+\n+    public function topDownMergeSort(@tainted Type[] events) returns @tainted Type[]{\n+        int index = 0;\n+        int n = events.length();\n+        Type[] b = [];\n+        while (index < n) {\n+            b[index] = events[index];\n+            index += 1;\n+        }\n+        self.topDownSplitMerge(b, 0, n, events);\n+        return events;\n+    }\n+\n+    function topDownSplitMerge(@tainted Type[] b, int iBegin, int iEnd, @tainted Type[] a) {\n+        if (iEnd - iBegin < 2) {\n+            return;\n+        }\n+        int iMiddle = (iEnd + iBegin) / 2;\n+        self.topDownSplitMerge(a, iBegin, iMiddle, b);\n+        self.topDownSplitMerge(a, iMiddle, iEnd, b);\n+        self.topDownMerge(b, iBegin, iMiddle, iEnd, a);\n+    }\n+\n+    function topDownMerge(@tainted Type[] a, int iBegin, int iMiddle, int iEnd, @tainted Type[] b) {\n+        int i = iBegin;\n+        int j = iMiddle;\n+\n+        int k = iBegin;\n+        while (k < iEnd) {\n+            if (i < iMiddle && (j >= iEnd || self.sortFunc(a[i], a[j], 0) < 0)) {\n+                b[k] = a[i];\n+                i = i + 1;\n+            } else {\n+                b[k] = a[j];\n+                j = j + 1;\n+            }\n+            k += 1;\n+        }\n+    }\n+\n+    function sortFunc(Type x, Type y, int fieldIndex) returns @tainted int {\n+        map<anydata> xMapValue = <map<anydata>>x;\n+        map<anydata> yMapValue = <map<anydata>>y;\n+\n+        var xFieldValue = xMapValue.get(self.sortFields[fieldIndex]);\n+        var yFieldValue = yMapValue.get(self.sortFields[fieldIndex]);\n+\n+        if (xFieldValue is ()) {\n+            if (yFieldValue is ()) {\n+                return 0;\n+            } else {\n+                return 1;\n+            }\n+        } else if (yFieldValue is ()) {\n+            return -1;\n+        } else if (xFieldValue is (int|float|decimal)) {\n+            if (yFieldValue is (int|float|decimal)) {\n+                int c;\n+                if (self.sortTypes[fieldIndex]) {\n+                    c = self.numberSort(xFieldValue, yFieldValue);\n+                } else {\n+                    c = self.numberSort(yFieldValue, xFieldValue);\n+                }\n+                return self.callNextSortFunc(x, y, c, fieldIndex + 1);\n+            } else {\n+                panic error(\"Inconsistent order field value\",\n+                message = self.sortFields[fieldIndex] + \" order field contain non-numeric values\");\n+            }\n+        } else if (xFieldValue is string) {\n+            if (yFieldValue is string) {\n+                int c;\n+                if (self.sortTypes[fieldIndex]) {\n+                    c = self.stringSort(xFieldValue, yFieldValue);\n+                } else {\n+                    c = self.stringSort(yFieldValue, xFieldValue);\n+                }\n+                return self.callNextSortFunc(x, y, c, fieldIndex + 1);\n+            } else {\n+                panic error(\"Inconsistent order field value\",\n+                message = self.sortFields[fieldIndex] + \" order field contain non-string type values\");\n+            }\n+        } else if (xFieldValue is boolean) {\n+            if (yFieldValue is boolean) {\n+                int c;\n+                if (self.sortTypes[fieldIndex]) {\n+                    c = self.booleanSort(xFieldValue, yFieldValue);\n+                } else {\n+                    c = self.booleanSort(yFieldValue, xFieldValue);\n+                }\n+                return self.callNextSortFunc(x, y, c, fieldIndex + 1);\n+            } else {\n+                  panic error(\"Inconsistent order field value\",\n+                  message = self.sortFields[fieldIndex] + \" order field contain non-boolean type values\");\n+            }\n+        } else {\n+            panic error(\"Unable to perform order by\",\n+            message = self.sortFields[fieldIndex] + \" field type incorrect\");\n+        }\n+    }\n+\n+    public function numberSort(int|float|decimal val1, int|float|decimal val2) returns int {\n+        if (val1 is int) {\n+            if (val2 is int) {\n+                return val1 - val2;\n+            } else if (val2 is float) {\n+                return <float>val1 < val2 ? -1 : <float>val1 == val2 ? 0 : 1;\n+            } else {\n+                return <decimal>val1 < val2 ? -1 : <decimal>val1 == val2 ? 0 : 1;\n+            }\n+        } else if (val1 is float) {\n+            if (val2 is int) {\n+                return val1 < <float>val2 ? -1 : val1 == <float>val2 ? 0 : 1;\n+            } else if (val2 is float){\n+                return val1 < val2 ? -1 : val1 == val2 ? 0 : 1;\n+            } else {\n+                return <decimal>val1 < val2 ? -1 : <decimal>val1 == val2 ? 0 : 1;\n+            }\n+        } else {\n+            if (val2 is (int|float)) {\n+                return val1 < <decimal>val2 ? -1 : val1 == <decimal>val2 ? 0 : 1;\n+            } else {\n+                return val1 < val2 ? -1 : val1 == val2 ? 0 : 1;\n+            }\n+        }\n+    }\n+\n+    public function stringSort(string st1, string st2) returns int {\n+        return strings:codePointCompare(st1, st2);\n+    }\n+\n+    public function booleanSort(boolean b1, boolean b2) returns int {\n+        if (b1) {\n+            if (b2) {\n+                return 0;\n+            } else {\n+                return 1;\n+            }\n+        } else {\n+            if (b2) {\n+                return -1;\n+            } else {\n+                return 0;\n+            }\n+        }\n+    }\n+\n+    function callNextSortFunc(Type x, Type y, int c, int fieldIndex) returns @tainted int {\n+        int result = c;\n+        if (result == 0 && (self.sortTypes.length() > fieldIndex)) {\n+            result = self.sortFunc(x, y, fieldIndex);\n+        }\n+        return result;\n+    }\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDkwNjcwMA=="}, "originalCommit": {"oid": "65deb30390b1ecb766a7c27a44a6f8c4175fb266"}, "originalPosition": 194}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyNDU0NDYxOnYy", "diffSide": "RIGHT", "path": "tests/jballerina-unit-test/src/test/resources/test-src/query/order-by-clause-negative.bal", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwODo0MjoxNVrOIHqhPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwOTowNjoyOFrOIHreQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDkwNzU4MA==", "bodyText": "missing eof", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r544907580", "createdAt": "2020-12-17T08:42:15Z", "author": {"login": "pcnfernando"}, "path": "tests/jballerina-unit-test/src/test/resources/test-src/query/order-by-clause-negative.bal", "diffHunk": "@@ -0,0 +1,80 @@\n+type Person record {|\n+    string firstName;\n+    string lastName;\n+    int age;\n+|};\n+\n+type Customer record {|\n+    string name;\n+    Address address;\n+|};\n+\n+type Address record {|\n+    int unitNo;\n+    string street;\n+|};\n+\n+type PersonTable table<Person> key(firstName);\n+\n+function testOrderByClauseWithInvalidOrderField() {\n+    Person p1 = {firstName: \"Alex\", lastName: \"George\", age: 23};\n+    Person p2 = {firstName: \"Ranjan\", lastName: \"Fonseka\", age: 30};\n+    Person p3 = {firstName: \"John\", lastName: \"David\", age: 33};\n+    Person p4 = {firstName: \"John\", lastName: \"Fonseka\", age: 28};\n+\n+    Person[] personList = [p1, p2, p3, p4];\n+\n+    Person[] outputPersonStream = from var person in personList\n+        order by lastname descending\n+        select {\n+            firstName: person.firstName,\n+            lastName: person.lastName,\n+            age: person.age\n+        };\n+}\n+\n+function testOrderByClauseWithInvalidOrderField2() {\n+    Person p1 = {firstName: \"Alex\", lastName: \"George\", age: 23};\n+    Person p2 = {firstName: \"Ranjan\", lastName: \"Fonseka\", age: 30};\n+    Person p3 = {firstName: \"John\", lastName: \"David\", age: 33};\n+    Person p4 = {firstName: \"John\", lastName: \"Fonseka\", age: 28};\n+\n+    Person[] personList = [p1, p2, p3, p4];\n+\n+    PersonTable|error personTable = table key(firstName) from var person in personList\n+        order by lastname descending\n+        select {\n+            firstName: person.firstName,\n+            lastName: person.lastName,\n+            age: person.age\n+        };\n+}\n+\n+function testOrderByClauseWithInvalidOrderField3() {\n+    Person p1 = {firstName: \"Alex\", lastName: \"George\", age: 23};\n+    Person p2 = {firstName: \"Ranjan\", lastName: \"Fonseka\", age: 30};\n+    Person p3 = {firstName: \"John\", lastName: \"David\", age: 33};\n+    Person p4 = {firstName: \"John\", lastName: \"Fonseka\", age: 28};\n+\n+    Person[] personList = [p1, p2, p3, p4];\n+\n+    stream<Person> personTable = stream from var person in personList\n+        order by lastname descending\n+        select {\n+            firstName: person.firstName,\n+            lastName: person.lastName,\n+            age: person.age\n+        };\n+}\n+\n+function testOrderByClauseWithComplexTypeFieldInOrderBy() {\n+    Customer c1 = {name: \"James\", address: {unitNo: 1, street: \"Main Street\"}};\n+    Customer c2 = {name: \"Frank\", address: {unitNo: 2, street: \"Main Street\"}};\n+    Customer c3 = {name: \"Nina\", address: {unitNo: 3, street: \"Palm Grove\"}};\n+\n+    Customer[] customerList = [c1, c2, c3];\n+\n+    Customer[] opList = from var customer in customerList\n+        order by address\n+        select customer;\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65deb30390b1ecb766a7c27a44a6f8c4175fb266"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDkyMzIwMA==", "bodyText": "It has already been fixed", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r544923200", "createdAt": "2020-12-17T09:06:28Z", "author": {"login": "lasinicl"}, "path": "tests/jballerina-unit-test/src/test/resources/test-src/query/order-by-clause-negative.bal", "diffHunk": "@@ -0,0 +1,80 @@\n+type Person record {|\n+    string firstName;\n+    string lastName;\n+    int age;\n+|};\n+\n+type Customer record {|\n+    string name;\n+    Address address;\n+|};\n+\n+type Address record {|\n+    int unitNo;\n+    string street;\n+|};\n+\n+type PersonTable table<Person> key(firstName);\n+\n+function testOrderByClauseWithInvalidOrderField() {\n+    Person p1 = {firstName: \"Alex\", lastName: \"George\", age: 23};\n+    Person p2 = {firstName: \"Ranjan\", lastName: \"Fonseka\", age: 30};\n+    Person p3 = {firstName: \"John\", lastName: \"David\", age: 33};\n+    Person p4 = {firstName: \"John\", lastName: \"Fonseka\", age: 28};\n+\n+    Person[] personList = [p1, p2, p3, p4];\n+\n+    Person[] outputPersonStream = from var person in personList\n+        order by lastname descending\n+        select {\n+            firstName: person.firstName,\n+            lastName: person.lastName,\n+            age: person.age\n+        };\n+}\n+\n+function testOrderByClauseWithInvalidOrderField2() {\n+    Person p1 = {firstName: \"Alex\", lastName: \"George\", age: 23};\n+    Person p2 = {firstName: \"Ranjan\", lastName: \"Fonseka\", age: 30};\n+    Person p3 = {firstName: \"John\", lastName: \"David\", age: 33};\n+    Person p4 = {firstName: \"John\", lastName: \"Fonseka\", age: 28};\n+\n+    Person[] personList = [p1, p2, p3, p4];\n+\n+    PersonTable|error personTable = table key(firstName) from var person in personList\n+        order by lastname descending\n+        select {\n+            firstName: person.firstName,\n+            lastName: person.lastName,\n+            age: person.age\n+        };\n+}\n+\n+function testOrderByClauseWithInvalidOrderField3() {\n+    Person p1 = {firstName: \"Alex\", lastName: \"George\", age: 23};\n+    Person p2 = {firstName: \"Ranjan\", lastName: \"Fonseka\", age: 30};\n+    Person p3 = {firstName: \"John\", lastName: \"David\", age: 33};\n+    Person p4 = {firstName: \"John\", lastName: \"Fonseka\", age: 28};\n+\n+    Person[] personList = [p1, p2, p3, p4];\n+\n+    stream<Person> personTable = stream from var person in personList\n+        order by lastname descending\n+        select {\n+            firstName: person.firstName,\n+            lastName: person.lastName,\n+            age: person.age\n+        };\n+}\n+\n+function testOrderByClauseWithComplexTypeFieldInOrderBy() {\n+    Customer c1 = {name: \"James\", address: {unitNo: 1, street: \"Main Street\"}};\n+    Customer c2 = {name: \"Frank\", address: {unitNo: 2, street: \"Main Street\"}};\n+    Customer c3 = {name: \"Nina\", address: {unitNo: 3, street: \"Palm Grove\"}};\n+\n+    Customer[] customerList = [c1, c2, c3];\n+\n+    Customer[] opList = from var customer in customerList\n+        order by address\n+        select customer;\n+}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDkwNzU4MA=="}, "originalCommit": {"oid": "65deb30390b1ecb766a7c27a44a6f8c4175fb266"}, "originalPosition": 80}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3244, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}